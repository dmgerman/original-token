multiline_comment|/*&n; *      Copyright (C) 1994-1996 Bas Laarhoven,&n; *                (C) 1996-1997 Claus-Justus Heine.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/lowlevel/fdc-isr.c,v $&n; * $Revision: 1.9 $&n; * $Date: 1997/10/17 23:01:53 $&n; *&n; *      This file contains the interrupt service routine and&n; *      associated code for the QIC-40/80/3010/3020 floppy-tape driver&n; *      &quot;ftape&quot; for Linux.&n; */
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
DECL|macro|volatile
mdefine_line|#define volatile&t;&t;/* */
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;linux/qic117.h&gt;
macro_line|#include &quot;../lowlevel/ftape-tracing.h&quot;
macro_line|#include &quot;../lowlevel/fdc-isr.h&quot;
macro_line|#include &quot;../lowlevel/fdc-io.h&quot;
macro_line|#include &quot;../lowlevel/ftape-ctl.h&quot;
macro_line|#include &quot;../lowlevel/ftape-rw.h&quot;
macro_line|#include &quot;../lowlevel/ftape-io.h&quot;
macro_line|#include &quot;../lowlevel/ftape-calibr.h&quot;
macro_line|#include &quot;../lowlevel/ftape-bsm.h&quot;
multiline_comment|/*      Global vars.&n; */
DECL|variable|ft_expected_stray_interrupts
r_volatile
r_int
id|ft_expected_stray_interrupts
suffix:semicolon
DECL|variable|ft_interrupt_seen
r_volatile
r_int
id|ft_interrupt_seen
suffix:semicolon
DECL|variable|ft_seek_completed
r_volatile
r_int
id|ft_seek_completed
suffix:semicolon
DECL|variable|ft_hide_interrupt
r_volatile
r_int
id|ft_hide_interrupt
suffix:semicolon
multiline_comment|/*      Local vars.&n; */
r_typedef
r_enum
(brace
DECL|enumerator|no_error
DECL|enumerator|id_am_error
DECL|enumerator|id_crc_error
id|no_error
op_assign
l_int|0
comma
id|id_am_error
op_assign
l_int|0x01
comma
id|id_crc_error
op_assign
l_int|0x02
comma
DECL|enumerator|data_am_error
DECL|enumerator|data_crc_error
id|data_am_error
op_assign
l_int|0x04
comma
id|data_crc_error
op_assign
l_int|0x08
comma
DECL|enumerator|no_data_error
DECL|enumerator|overrun_error
id|no_data_error
op_assign
l_int|0x10
comma
id|overrun_error
op_assign
l_int|0x20
comma
DECL|typedef|error_cause
)brace
id|error_cause
suffix:semicolon
DECL|variable|stop_read_ahead
r_static
r_int
id|stop_read_ahead
suffix:semicolon
DECL|function|print_error_cause
r_static
r_void
id|print_error_cause
c_func
(paren
r_int
id|cause
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cause
)paren
(brace
r_case
id|no_data_error
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;no data error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|id_am_error
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;id am error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|id_crc_error
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;id crc error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|data_am_error
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;data am error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|data_crc_error
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;data crc error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|overrun_error
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;overrun error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|fdc_mode_txt
r_static
r_char
op_star
id|fdc_mode_txt
c_func
(paren
id|fdc_mode_enum
id|mode
)paren
(brace
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|fdc_idle
suffix:colon
r_return
l_string|&quot;fdc_idle&quot;
suffix:semicolon
r_case
id|fdc_reading_data
suffix:colon
r_return
l_string|&quot;fdc_reading_data&quot;
suffix:semicolon
r_case
id|fdc_seeking
suffix:colon
r_return
l_string|&quot;fdc_seeking&quot;
suffix:semicolon
r_case
id|fdc_writing_data
suffix:colon
r_return
l_string|&quot;fdc_writing_data&quot;
suffix:semicolon
r_case
id|fdc_reading_id
suffix:colon
r_return
l_string|&quot;fdc_reading_id&quot;
suffix:semicolon
r_case
id|fdc_recalibrating
suffix:colon
r_return
l_string|&quot;fdc_recalibrating&quot;
suffix:semicolon
r_case
id|fdc_formatting
suffix:colon
r_return
l_string|&quot;fdc_formatting&quot;
suffix:semicolon
r_case
id|fdc_verifying
suffix:colon
r_return
l_string|&quot;fdc_verifying&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;unknown&quot;
suffix:semicolon
)brace
)brace
DECL|function|decode_irq_cause
r_static
r_inline
id|error_cause
id|decode_irq_cause
c_func
(paren
id|fdc_mode_enum
id|mode
comma
id|__u8
id|st
(braket
)braket
)paren
(brace
id|error_cause
id|cause
op_assign
id|no_error
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/*  Valid st[], decode cause of interrupt.&n;&t; */
r_switch
c_cond
(paren
id|st
(braket
l_int|0
)braket
op_amp
id|ST0_INT_MASK
)paren
(brace
r_case
id|FDC_INT_NORMAL
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;normal completion: %s&quot;
comma
id|fdc_mode_txt
c_func
(paren
id|mode
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDC_INT_ABNORMAL
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;abnormal completion %s&quot;
comma
id|fdc_mode_txt
c_func
(paren
id|mode
)paren
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;ST0: 0x%02x, ST1: 0x%02x, ST2: 0x%02x&quot;
comma
id|st
(braket
l_int|0
)braket
comma
id|st
(braket
l_int|1
)braket
comma
id|st
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;C: 0x%02x, H: 0x%02x, R: 0x%02x, N: 0x%02x&quot;
comma
id|st
(braket
l_int|3
)braket
comma
id|st
(braket
l_int|4
)braket
comma
id|st
(braket
l_int|5
)braket
comma
id|st
(braket
l_int|6
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
(braket
l_int|1
)braket
op_amp
l_int|0x01
)paren
(brace
r_if
c_cond
(paren
id|st
(braket
l_int|2
)braket
op_amp
l_int|0x01
)paren
(brace
id|cause
op_assign
id|data_am_error
suffix:semicolon
)brace
r_else
(brace
id|cause
op_assign
id|id_am_error
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|st
(braket
l_int|1
)braket
op_amp
l_int|0x20
)paren
(brace
r_if
c_cond
(paren
id|st
(braket
l_int|2
)braket
op_amp
l_int|0x20
)paren
(brace
id|cause
op_assign
id|data_crc_error
suffix:semicolon
)brace
r_else
(brace
id|cause
op_assign
id|id_crc_error
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|st
(braket
l_int|1
)braket
op_amp
l_int|0x04
)paren
(brace
id|cause
op_assign
id|no_data_error
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st
(braket
l_int|1
)braket
op_amp
l_int|0x10
)paren
(brace
id|cause
op_assign
id|overrun_error
suffix:semicolon
)brace
id|print_error_cause
c_func
(paren
id|cause
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDC_INT_INVALID
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;invalid completion %s&quot;
comma
id|fdc_mode_txt
c_func
(paren
id|mode
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDC_INT_READYCH
suffix:colon
r_if
c_cond
(paren
id|st
(braket
l_int|0
)braket
op_amp
id|ST0_SEEK_END
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;drive poll completed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;ready change %s&quot;
comma
id|fdc_mode_txt
c_func
(paren
id|mode
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|TRACE_EXIT
id|cause
suffix:semicolon
)brace
DECL|function|update_history
r_static
r_void
id|update_history
c_func
(paren
id|error_cause
id|cause
)paren
(brace
r_switch
c_cond
(paren
id|cause
)paren
(brace
r_case
id|id_am_error
suffix:colon
id|ft_history.id_am_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|id_crc_error
suffix:colon
id|ft_history.id_crc_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|data_am_error
suffix:colon
id|ft_history.data_am_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|data_crc_error
suffix:colon
id|ft_history.data_crc_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|overrun_error
suffix:colon
id|ft_history.overrun_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|no_data_error
suffix:colon
id|ft_history.no_data_errors
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
)brace
DECL|function|skip_bad_sector
r_static
r_void
id|skip_bad_sector
c_func
(paren
id|buffer_struct
op_star
id|buff
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/*  Mark sector as soft error and skip it&n;&t; */
r_if
c_cond
(paren
id|buff-&gt;remaining
OG
l_int|0
)paren
(brace
op_increment
id|buff-&gt;sector_offset
suffix:semicolon
op_increment
id|buff-&gt;data_offset
suffix:semicolon
op_decrement
id|buff-&gt;remaining
suffix:semicolon
id|buff-&gt;ptr
op_add_assign
id|FT_SECTOR_SIZE
suffix:semicolon
id|buff-&gt;bad_sector_map
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  Hey, what is this????????????? C code: if we shift &n;&t;&t; *  more than 31 bits, we get no shift. That&squot;s bad!!!!!!&n;&t;&t; */
op_increment
id|buff-&gt;sector_offset
suffix:semicolon
multiline_comment|/* hack for error maps */
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;skipping last sector in segment&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|update_error_maps
r_static
r_void
id|update_error_maps
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
r_int
r_int
id|error_offset
)paren
(brace
r_int
id|hard
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff-&gt;retry
OL
id|FT_SOFT_RETRIES
)paren
(brace
id|buff-&gt;soft_error_map
op_or_assign
(paren
l_int|1
op_lshift
id|error_offset
)paren
suffix:semicolon
)brace
r_else
(brace
id|buff-&gt;hard_error_map
op_or_assign
(paren
l_int|1
op_lshift
id|error_offset
)paren
suffix:semicolon
id|buff-&gt;soft_error_map
op_and_assign
op_complement
id|buff-&gt;hard_error_map
suffix:semicolon
id|buff-&gt;retry
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* will be set to 0 in setup_segment */
id|hard
op_assign
l_int|1
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;sector %d : %s error&bslash;n&quot;
id|KERN_INFO
l_string|&quot;hard map: 0x%08lx&bslash;n&quot;
id|KERN_INFO
l_string|&quot;soft map: 0x%08lx&quot;
comma
id|FT_SECTOR
c_func
(paren
id|error_offset
)paren
comma
id|hard
ques
c_cond
l_string|&quot;hard&quot;
suffix:colon
l_string|&quot;soft&quot;
comma
(paren
r_int
)paren
id|buff-&gt;hard_error_map
comma
(paren
r_int
)paren
id|buff-&gt;soft_error_map
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|print_progress
r_static
r_void
id|print_progress
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
id|error_cause
id|cause
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cause
)paren
(brace
r_case
id|no_error
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;%d Sector(s) transfered&quot;
comma
id|buff-&gt;sector_count
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|no_data_error
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;Sector %d not found&quot;
comma
id|FT_SECTOR
c_func
(paren
id|buff-&gt;sector_offset
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|overrun_error
suffix:colon
multiline_comment|/*  got an overrun error on the first byte, must be a&n;&t;&t; *  hardware problem&n;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;Unexpected error: failing DMA or FDC controller ?&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|data_crc_error
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;Error in sector %d&quot;
comma
id|FT_SECTOR
c_func
(paren
id|buff-&gt;sector_offset
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|id_crc_error
suffix:colon
r_case
id|id_am_error
suffix:colon
r_case
id|data_am_error
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;Error in sector %d&quot;
comma
id|FT_SECTOR
c_func
(paren
id|buff-&gt;sector_offset
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;Unexpected error at sector %d&quot;
comma
id|FT_SECTOR
c_func
(paren
id|buff-&gt;sector_offset
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*&n; *  Error cause:   Amount xferred:  Action:&n; *&n; *  id_am_error         0           mark bad and skip&n; *  id_crc_error        0           mark bad and skip&n; *  data_am_error       0           mark bad and skip&n; *  data_crc_error    % 1024        mark bad and skip&n; *  no_data_error       0           retry on write&n; *                                  mark bad and skip on read&n; *  overrun_error  [ 0..all-1 ]     mark bad and skip&n; *  no_error           all          continue&n; */
multiline_comment|/*  the arg `sector&squot; is returned by the fdc and tells us at which sector we&n; *  are positioned at (relative to starting sector of segment)&n; */
DECL|function|determine_verify_progress
r_static
r_void
id|determine_verify_progress
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
id|error_cause
id|cause
comma
id|__u8
id|sector
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cause
op_eq
id|no_error
op_logical_and
id|sector
op_eq
l_int|1
)paren
(brace
id|buff-&gt;sector_offset
op_assign
id|FT_SECTORS_PER_SEGMENT
suffix:semicolon
id|buff-&gt;remaining
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|TRACE_LEVEL
op_ge
id|ft_t_flow
)paren
(brace
id|print_progress
c_func
(paren
id|buff
comma
id|cause
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|buff-&gt;sector_offset
op_assign
id|sector
op_minus
id|buff-&gt;sect
suffix:semicolon
id|buff-&gt;remaining
op_assign
id|FT_SECTORS_PER_SEGMENT
op_minus
id|buff-&gt;sector_offset
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;%ssector offset: 0x%04x&quot;
comma
(paren
id|cause
op_eq
id|no_error
)paren
ques
c_cond
l_string|&quot;unexpected &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|buff-&gt;sector_offset
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cause
)paren
(brace
r_case
id|overrun_error
suffix:colon
r_break
suffix:semicolon
macro_line|#if 0
r_case
id|no_data_error
suffix:colon
id|buff-&gt;retry
op_assign
id|FT_SOFT_RETRIES
suffix:semicolon
r_if
c_cond
(paren
id|buff-&gt;hard_error_map
op_logical_and
id|buff-&gt;sector_offset
OG
l_int|1
op_logical_and
(paren
id|buff-&gt;hard_error_map
op_amp
(paren
l_int|1
op_lshift
(paren
id|buff-&gt;sector_offset
op_minus
l_int|2
)paren
)paren
)paren
)paren
(brace
id|buff-&gt;retry
op_decrement
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|buff-&gt;retry
op_assign
id|FT_SOFT_RETRIES
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TRACE_LEVEL
op_ge
id|ft_t_flow
)paren
(brace
id|print_progress
c_func
(paren
id|buff
comma
id|cause
)paren
suffix:semicolon
)brace
multiline_comment|/*  Sector_offset points to the problem area Now adjust&n;&t;&t; *  sector_offset so it always points one past he failing&n;&t;&t; *  sector. I.e. skip the bad sector.&n;&t;&t; */
op_increment
id|buff-&gt;sector_offset
suffix:semicolon
op_decrement
id|buff-&gt;remaining
suffix:semicolon
id|update_error_maps
c_func
(paren
id|buff
comma
id|buff-&gt;sector_offset
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|determine_progress
r_static
r_void
id|determine_progress
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
id|error_cause
id|cause
comma
id|__u8
id|sector
)paren
(brace
r_int
r_int
id|dma_residue
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/*  Using less preferred order of disable_dma and&n;&t; *  get_dma_residue because this seems to fail on at least one&n;&t; *  system if reversed!&n;&t; */
id|dma_residue
op_assign
id|get_dma_residue
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cause
op_ne
id|no_error
op_logical_or
id|dma_residue
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;%sDMA residue: 0x%04x&quot;
comma
(paren
id|cause
op_eq
id|no_error
)paren
ques
c_cond
l_string|&quot;unexpected &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|dma_residue
)paren
suffix:semicolon
multiline_comment|/* adjust to actual value: */
r_if
c_cond
(paren
id|dma_residue
op_eq
l_int|0
)paren
(brace
multiline_comment|/* this happens sometimes with overrun errors.&n;&t;&t;&t; * I don&squot;t know whether we could ignore the&n;&t;&t;&t; * overrun error. Play save.&n;&t;&t;&t; */
id|buff-&gt;sector_count
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|buff-&gt;sector_count
op_sub_assign
(paren
(paren
id|dma_residue
op_plus
(paren
id|FT_SECTOR_SIZE
op_minus
l_int|1
)paren
)paren
op_div
id|FT_SECTOR_SIZE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*  Update var&squot;s influenced by the DMA operation.&n;&t; */
r_if
c_cond
(paren
id|buff-&gt;sector_count
OG
l_int|0
)paren
(brace
id|buff-&gt;sector_offset
op_add_assign
id|buff-&gt;sector_count
suffix:semicolon
id|buff-&gt;data_offset
op_add_assign
id|buff-&gt;sector_count
suffix:semicolon
id|buff-&gt;ptr
op_add_assign
(paren
id|buff-&gt;sector_count
op_star
id|FT_SECTOR_SIZE
)paren
suffix:semicolon
id|buff-&gt;remaining
op_sub_assign
id|buff-&gt;sector_count
suffix:semicolon
id|buff-&gt;bad_sector_map
op_rshift_assign
id|buff-&gt;sector_count
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TRACE_LEVEL
op_ge
id|ft_t_flow
)paren
(brace
id|print_progress
c_func
(paren
id|buff
comma
id|cause
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cause
op_ne
id|no_error
)paren
(brace
r_if
c_cond
(paren
id|buff-&gt;remaining
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;foo?&bslash;n&quot;
id|KERN_INFO
l_string|&quot;count : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;offset: %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;soft  : %08x&bslash;n&quot;
id|KERN_INFO
l_string|&quot;hard  : %08x&quot;
comma
id|buff-&gt;sector_count
comma
id|buff-&gt;sector_offset
comma
id|buff-&gt;soft_error_map
comma
id|buff-&gt;hard_error_map
)paren
suffix:semicolon
)brace
multiline_comment|/*  Sector_offset points to the problem area, except if we got&n;&t;&t; *  a data_crc_error. In that case it points one past the&n;&t;&t; *  failing sector.&n;&t;&t; *&n;&t;&t; *  Now adjust sector_offset so it always points one past he&n;&t;&t; *  failing sector. I.e. skip the bad sector.  &n;&t;&t; */
r_if
c_cond
(paren
id|cause
op_ne
id|data_crc_error
)paren
(brace
id|skip_bad_sector
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
id|update_error_maps
c_func
(paren
id|buff
comma
id|buff-&gt;sector_offset
op_minus
l_int|1
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|calc_steps
r_static
r_int
id|calc_steps
c_func
(paren
r_int
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|ftape_current_cylinder
OG
id|cmd
)paren
(brace
r_return
id|ftape_current_cylinder
op_minus
id|cmd
suffix:semicolon
)brace
r_else
(brace
r_return
id|ftape_current_cylinder
op_plus
id|cmd
suffix:semicolon
)brace
)brace
DECL|function|pause_tape
r_static
r_void
id|pause_tape
c_func
(paren
r_int
id|retry
comma
r_int
id|mode
)paren
(brace
r_int
id|result
suffix:semicolon
id|__u8
id|out
(braket
l_int|3
)braket
op_assign
(brace
id|FDC_SEEK
comma
id|ft_drive_sel
comma
l_int|0
)brace
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/*  We&squot;ll use a raw seek command to get the tape to rewind and&n;&t; *  stop for a retry.&n;&t; */
op_increment
id|ft_history.rewinds
suffix:semicolon
r_if
c_cond
(paren
id|qic117_cmds
(braket
id|ftape_current_command
)braket
dot
id|non_intr
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;motion command may be issued too soon&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retry
op_logical_and
(paren
id|mode
op_eq
id|fdc_reading_data
op_logical_or
id|mode
op_eq
id|fdc_reading_id
op_logical_or
id|mode
op_eq
id|fdc_verifying
)paren
)paren
(brace
id|ftape_current_command
op_assign
id|QIC_MICRO_STEP_PAUSE
suffix:semicolon
id|ftape_might_be_off_track
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|ftape_current_command
op_assign
id|QIC_PAUSE
suffix:semicolon
)brace
id|out
(braket
l_int|2
)braket
op_assign
id|calc_steps
c_func
(paren
id|ftape_current_command
)paren
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|out
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* issue QIC_117 command */
id|ftape_current_cylinder
op_assign
id|out
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;qic-pause failed, status = %d&quot;
comma
id|result
)paren
suffix:semicolon
)brace
r_else
(brace
id|ft_location.known
op_assign
l_int|0
suffix:semicolon
id|ft_runner_status
op_assign
id|idle
suffix:semicolon
id|ft_hide_interrupt
op_assign
l_int|1
suffix:semicolon
id|ftape_tape_running
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|continue_xfer
r_static
r_void
id|continue_xfer
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
id|fdc_mode_enum
id|mode
comma
r_int
r_int
id|skip
)paren
(brace
r_int
id|write
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|fdc_writing_data
op_logical_or
id|mode
op_eq
id|fdc_deleting
)paren
(brace
id|write
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*  This part can be removed if it never happens&n;&t; */
r_if
c_cond
(paren
id|skip
OG
l_int|0
op_logical_and
(paren
id|ft_runner_status
op_ne
id|running
op_logical_or
(paren
id|write
op_logical_and
(paren
id|buff-&gt;status
op_ne
id|writing
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|write
op_logical_and
(paren
id|buff-&gt;status
op_ne
id|reading
op_logical_and
id|buff-&gt;status
op_ne
id|verifying
)paren
)paren
)paren
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;unexpected runner/buffer state %d/%d&quot;
comma
id|ft_runner_status
comma
id|buff-&gt;status
)paren
suffix:semicolon
id|buff-&gt;status
op_assign
id|error
suffix:semicolon
multiline_comment|/* finish this buffer: */
(paren
r_void
)paren
id|ftape_next_buffer
c_func
(paren
id|ft_queue_head
)paren
suffix:semicolon
id|ft_runner_status
op_assign
id|aborting
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|buff-&gt;remaining
OG
l_int|0
op_logical_and
id|ftape_calc_next_cluster
c_func
(paren
id|buff
)paren
OG
l_int|0
)paren
(brace
multiline_comment|/*  still sectors left in current segment, continue&n;&t;&t; *  with this segment&n;&t;&t; */
r_if
c_cond
(paren
id|fdc_setup_read_write
c_func
(paren
id|buff
comma
id|mode
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* failed, abort operation&n;&t;&t;&t; */
id|buff-&gt;bytes
op_assign
id|buff-&gt;ptr
op_minus
id|buff-&gt;address
suffix:semicolon
id|buff-&gt;status
op_assign
id|error
suffix:semicolon
multiline_comment|/* finish this buffer: */
(paren
r_void
)paren
id|ftape_next_buffer
c_func
(paren
id|ft_queue_head
)paren
suffix:semicolon
id|ft_runner_status
op_assign
id|aborting
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* current segment completed&n;&t;&t; */
r_int
r_int
id|last_segment
op_assign
id|buff-&gt;segment_id
suffix:semicolon
r_int
id|eot
op_assign
(paren
(paren
id|last_segment
op_plus
l_int|1
)paren
op_mod
id|ft_segments_per_track
)paren
op_eq
l_int|0
suffix:semicolon
r_int
r_int
id|next
op_assign
id|buff-&gt;next_segment
suffix:semicolon
multiline_comment|/* 0 means stop ! */
id|buff-&gt;bytes
op_assign
id|buff-&gt;ptr
op_minus
id|buff-&gt;address
suffix:semicolon
id|buff-&gt;status
op_assign
id|done
suffix:semicolon
id|buff
op_assign
id|ftape_next_buffer
c_func
(paren
id|ft_queue_head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eot
)paren
(brace
multiline_comment|/*  finished last segment on current track,&n;&t;&t;&t; *  can&squot;t continue&n;&t;&t;&t; */
id|ft_runner_status
op_assign
id|logical_eot
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|next
op_le
l_int|0
)paren
(brace
multiline_comment|/*  don&squot;t continue with next segment&n;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;no %s allowed, stopping tape&quot;
comma
(paren
id|write
)paren
ques
c_cond
l_string|&quot;write next&quot;
suffix:colon
l_string|&quot;read ahead&quot;
)paren
suffix:semicolon
id|pause_tape
c_func
(paren
l_int|0
comma
id|mode
)paren
suffix:semicolon
id|ft_runner_status
op_assign
id|idle
suffix:semicolon
multiline_comment|/*  not quite true until&n;&t;&t;&t;&t;&t;&t;   *  next irq &n;&t;&t;&t;&t;&t;&t;   */
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*  continue with next segment&n;&t;&t; */
r_if
c_cond
(paren
id|buff-&gt;status
op_ne
id|waiting
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;all input buffers %s, pausing tape&quot;
comma
(paren
id|write
)paren
ques
c_cond
l_string|&quot;empty&quot;
suffix:colon
l_string|&quot;full&quot;
)paren
suffix:semicolon
id|pause_tape
c_func
(paren
l_int|0
comma
id|mode
)paren
suffix:semicolon
id|ft_runner_status
op_assign
id|idle
suffix:semicolon
multiline_comment|/*  not quite true until&n;&t;&t;&t;&t;&t;&t;   *  next irq &n;&t;&t;&t;&t;&t;&t;   */
id|TRACE_EXIT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|write
op_logical_and
id|next
op_ne
id|buff-&gt;segment_id
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;segments out of order, aborting write&quot;
)paren
suffix:semicolon
id|ft_runner_status
op_assign
id|do_abort
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
id|ftape_setup_new_segment
c_func
(paren
id|buff
comma
id|next
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stop_read_ahead
)paren
(brace
id|buff-&gt;next_segment
op_assign
l_int|0
suffix:semicolon
id|stop_read_ahead
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ftape_calc_next_cluster
c_func
(paren
id|buff
)paren
op_eq
l_int|0
op_logical_or
id|fdc_setup_read_write
c_func
(paren
id|buff
comma
id|mode
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;couldn&squot;t start %s-ahead&quot;
comma
id|write
ques
c_cond
l_string|&quot;write&quot;
suffix:colon
l_string|&quot;read&quot;
)paren
suffix:semicolon
id|ft_runner_status
op_assign
id|do_abort
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* keep on going */
r_switch
c_cond
(paren
id|ft_driver_state
)paren
(brace
r_case
id|reading
suffix:colon
id|buff-&gt;status
op_assign
id|reading
suffix:semicolon
r_break
suffix:semicolon
r_case
id|verifying
suffix:colon
id|buff-&gt;status
op_assign
id|verifying
suffix:semicolon
r_break
suffix:semicolon
r_case
id|writing
suffix:colon
id|buff-&gt;status
op_assign
id|writing
suffix:semicolon
r_break
suffix:semicolon
r_case
id|deleting
suffix:colon
id|buff-&gt;status
op_assign
id|deleting
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;BUG: ft_driver_state %d should be one out of &quot;
l_string|&quot;{reading, writing, verifying, deleting}&quot;
comma
id|ft_driver_state
)paren
suffix:semicolon
id|buff-&gt;status
op_assign
id|write
ques
c_cond
id|writing
suffix:colon
id|reading
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|retry_sector
r_static
r_void
id|retry_sector
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
r_int
id|mode
comma
r_int
r_int
id|skip
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;%s error, will retry&quot;
comma
(paren
id|mode
op_eq
id|fdc_writing_data
op_logical_or
id|mode
op_eq
id|fdc_deleting
)paren
ques
c_cond
l_string|&quot;write&quot;
suffix:colon
l_string|&quot;read&quot;
)paren
suffix:semicolon
id|pause_tape
c_func
(paren
l_int|1
comma
id|mode
)paren
suffix:semicolon
id|ft_runner_status
op_assign
id|aborting
suffix:semicolon
id|buff-&gt;status
op_assign
id|error
suffix:semicolon
id|buff-&gt;skip
op_assign
id|skip
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|find_resume_point
r_static
r_int
r_int
id|find_resume_point
c_func
(paren
id|buffer_struct
op_star
id|buff
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|SectorMap
id|mask
suffix:semicolon
id|SectorMap
id|map
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/*  This function is to be called after all variables have been&n;&t; *  updated to point past the failing sector.&n;&t; *  If there are any soft errors before the failing sector,&n;&t; *  find the first soft error and return the sector offset.&n;&t; *  Otherwise find the last hard error.&n;&t; *  Note: there should always be at least one hard or soft error !&n;&t; */
r_if
c_cond
(paren
id|buff-&gt;sector_offset
template_param
l_int|32
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;BUG: sector_offset = %d&quot;
comma
id|buff-&gt;sector_offset
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff-&gt;sector_offset
op_ge
l_int|32
)paren
(brace
multiline_comment|/* C-limitation on shift ! */
id|mask
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
r_else
(brace
id|mask
op_assign
(paren
l_int|1
op_lshift
id|buff-&gt;sector_offset
)paren
op_minus
l_int|1
suffix:semicolon
)brace
id|map
op_assign
id|buff-&gt;soft_error_map
op_amp
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|map
)paren
(brace
r_while
c_loop
(paren
(paren
id|map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_eq
l_int|0
)paren
(brace
op_increment
id|i
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;at sector %d&quot;
comma
id|FT_SECTOR
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|map
op_assign
id|buff-&gt;hard_error_map
op_amp
id|mask
suffix:semicolon
id|i
op_assign
id|buff-&gt;sector_offset
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|map
)paren
(brace
r_while
c_loop
(paren
(paren
id|map
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_eq
l_int|0
)paren
(brace
op_decrement
id|i
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;after sector %d&quot;
comma
id|FT_SECTOR
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
op_increment
id|i
suffix:semicolon
multiline_comment|/* first sector after last hard error */
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;BUG: no soft or hard errors&quot;
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
id|i
suffix:semicolon
)brace
multiline_comment|/*  check possible dma residue when formatting, update position record in&n; *  buffer struct. This is, of course, modelled after determine_progress(), but&n; *  we don&squot;t need to set up for retries because the format process cannot be&n; *  interrupted (except at the end of the tape track).&n; */
DECL|function|determine_fmt_progress
r_static
r_int
id|determine_fmt_progress
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
id|error_cause
id|cause
)paren
(brace
r_int
r_int
id|dma_residue
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/*  Using less preferred order of disable_dma and&n;&t; *  get_dma_residue because this seems to fail on at least one&n;&t; *  system if reversed!&n;&t; */
id|dma_residue
op_assign
id|get_dma_residue
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cause
op_ne
id|no_error
op_logical_or
id|dma_residue
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;DMA residue = 0x%04x&quot;
comma
id|dma_residue
)paren
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
r_switch
c_cond
(paren
id|cause
)paren
(brace
r_case
id|no_error
suffix:colon
id|ft_runner_status
op_assign
id|aborting
suffix:semicolon
id|buff-&gt;status
op_assign
id|idle
suffix:semicolon
r_break
suffix:semicolon
r_case
id|overrun_error
suffix:colon
multiline_comment|/*  got an overrun error on the first byte, must be a&n;&t;&t;&t; *  hardware problem &n;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;Unexpected error: failing DMA controller ?&quot;
)paren
suffix:semicolon
id|ft_runner_status
op_assign
id|do_abort
suffix:semicolon
id|buff-&gt;status
op_assign
id|error
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Unexpected error at segment %d&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
id|ft_runner_status
op_assign
id|do_abort
suffix:semicolon
id|buff-&gt;status
op_assign
id|error
suffix:semicolon
r_break
suffix:semicolon
)brace
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* can only retry entire track in format mode&n;&t;&t;&t;&t;  */
)brace
multiline_comment|/*  Update var&squot;s influenced by the DMA operation.&n;&t; */
id|buff-&gt;ptr
op_add_assign
id|FT_SECTORS_PER_SEGMENT
op_star
l_int|4
suffix:semicolon
id|buff-&gt;bytes
op_sub_assign
id|FT_SECTORS_PER_SEGMENT
op_star
l_int|4
suffix:semicolon
id|buff-&gt;remaining
op_sub_assign
id|FT_SECTORS_PER_SEGMENT
suffix:semicolon
id|buff-&gt;segment_id
op_increment
suffix:semicolon
multiline_comment|/* done with segment */
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  Continue formatting, switch buffers if there is no data left in&n; *  current buffer. This is, of course, modelled after&n; *  continue_xfer(), but we don&squot;t need to set up for retries because&n; *  the format process cannot be interrupted (except at the end of the&n; *  tape track).&n; */
DECL|function|continue_formatting
r_static
r_void
id|continue_formatting
c_func
(paren
id|buffer_struct
op_star
id|buff
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff-&gt;remaining
op_le
l_int|0
)paren
(brace
multiline_comment|/*  no space left in dma buffer */
r_int
r_int
id|next
op_assign
id|buff-&gt;next_segment
suffix:semicolon
r_if
c_cond
(paren
id|next
op_eq
l_int|0
)paren
(brace
multiline_comment|/* end of tape track */
id|buff-&gt;status
op_assign
id|done
suffix:semicolon
id|ft_runner_status
op_assign
id|logical_eot
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Done formatting track %d&quot;
comma
id|ft_location.track
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  switch to next buffer!&n;&t;&t; */
id|buff-&gt;status
op_assign
id|done
suffix:semicolon
id|buff
op_assign
id|ftape_next_buffer
c_func
(paren
id|ft_queue_head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff-&gt;status
op_ne
id|waiting
op_logical_or
id|next
op_ne
id|buff-&gt;segment_id
)paren
(brace
r_goto
id|format_setup_error
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|fdc_setup_formatting
c_func
(paren
id|buff
)paren
OL
l_int|0
)paren
(brace
r_goto
id|format_setup_error
suffix:semicolon
)brace
id|buff-&gt;status
op_assign
id|formatting
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;Formatting segment %d on track %d&quot;
comma
id|buff-&gt;segment_id
comma
id|ft_location.track
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
id|format_setup_error
suffix:colon
id|ft_runner_status
op_assign
id|do_abort
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
id|buff-&gt;status
op_assign
id|error
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;Error setting up for segment %d on track %d&quot;
comma
id|buff-&gt;segment_id
comma
id|ft_location.track
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*  this handles writing, read id, reading and formatting&n; */
DECL|function|handle_fdc_busy
r_static
r_void
id|handle_fdc_busy
c_func
(paren
id|buffer_struct
op_star
id|buff
)paren
(brace
r_static
r_int
id|no_data_error_count
suffix:semicolon
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
id|error_cause
id|cause
suffix:semicolon
id|__u8
id|in
(braket
l_int|7
)braket
suffix:semicolon
r_int
id|skip
suffix:semicolon
id|fdc_mode_enum
id|fmode
op_assign
id|fdc_mode
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc_result
c_func
(paren
id|in
comma
l_int|7
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* better get it fast ! */
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;Probably fatal error during FDC Result Phase&bslash;n&quot;
id|KERN_INFO
l_string|&quot;drive may hang until (power on) reset :-(&quot;
)paren
suffix:semicolon
multiline_comment|/*  what to do next ????&n;&t;&t; */
id|TRACE_EXIT
suffix:semicolon
)brace
id|cause
op_assign
id|decode_irq_cause
c_func
(paren
id|fdc_mode
comma
id|in
)paren
suffix:semicolon
macro_line|#ifdef TESTING
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
id|ft_nr_buffers
suffix:semicolon
op_increment
id|i
)paren
id|TRACE
c_func
(paren
id|ft_t_any
comma
l_string|&quot;buffer[%d] status: %d, segment_id: %d&quot;
comma
id|i
comma
id|ft_buffer
(braket
id|i
)braket
op_member_access_from_pointer
id|status
comma
id|ft_buffer
(braket
id|i
)braket
op_member_access_from_pointer
id|segment_id
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|fmode
op_eq
id|fdc_reading_data
op_logical_and
id|ft_driver_state
op_eq
id|verifying
)paren
(brace
id|fmode
op_assign
id|fdc_verifying
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|fmode
)paren
(brace
r_case
id|fdc_verifying
suffix:colon
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|aborting
op_logical_or
id|ft_runner_status
op_eq
id|do_abort
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;aborting %s&quot;
comma
id|fdc_mode_txt
c_func
(paren
id|fdc_mode
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff-&gt;retry
OG
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;this is retry nr %d&quot;
comma
id|buff-&gt;retry
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cause
)paren
(brace
r_case
id|no_error
suffix:colon
id|no_data_error_count
op_assign
l_int|0
suffix:semicolon
id|determine_verify_progress
c_func
(paren
id|buff
comma
id|cause
comma
id|in
(braket
l_int|5
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in
(braket
l_int|2
)braket
op_amp
l_int|0x40
)paren
(brace
multiline_comment|/*  This should not happen when verifying&n;&t;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;deleted data in segment %d/%d&quot;
comma
id|buff-&gt;segment_id
comma
id|FT_SECTOR
c_func
(paren
id|buff-&gt;sector_offset
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|buff-&gt;remaining
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* abort transfer */
id|buff-&gt;hard_error_map
op_assign
id|EMPTY_SEGMENT
suffix:semicolon
id|skip
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|skip
op_assign
l_int|0
suffix:semicolon
)brace
id|continue_xfer
c_func
(paren
id|buff
comma
id|fdc_mode
comma
id|skip
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|no_data_error
suffix:colon
id|no_data_error_count
op_increment
suffix:semicolon
r_case
id|overrun_error
suffix:colon
id|retry
op_increment
suffix:semicolon
r_case
id|id_am_error
suffix:colon
r_case
id|id_crc_error
suffix:colon
r_case
id|data_am_error
suffix:colon
r_case
id|data_crc_error
suffix:colon
id|determine_verify_progress
c_func
(paren
id|buff
comma
id|cause
comma
id|in
(braket
l_int|5
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cause
op_eq
id|no_data_error
)paren
(brace
r_if
c_cond
(paren
id|no_data_error_count
op_ge
l_int|2
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;retrying because of successive &quot;
l_string|&quot;no data errors&quot;
)paren
suffix:semicolon
id|no_data_error_count
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|retry
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
id|no_data_error_count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retry
)paren
(brace
id|skip
op_assign
id|find_resume_point
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
r_else
(brace
id|skip
op_assign
id|buff-&gt;sector_offset
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retry
op_logical_and
id|skip
OL
l_int|32
)paren
(brace
id|retry_sector
c_func
(paren
id|buff
comma
id|fdc_mode
comma
id|skip
)paren
suffix:semicolon
)brace
r_else
(brace
id|continue_xfer
c_func
(paren
id|buff
comma
id|fdc_mode
comma
id|skip
)paren
suffix:semicolon
)brace
id|update_history
c_func
(paren
id|cause
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*  Don&squot;t know why this could happen &n;&t;&t;&t; *  but find out.&n;&t;&t;&t; */
id|determine_verify_progress
c_func
(paren
id|buff
comma
id|cause
comma
id|in
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|retry_sector
c_func
(paren
id|buff
comma
id|fdc_mode
comma
l_int|0
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;Error: unexpected error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|fdc_reading_data
suffix:colon
macro_line|#ifdef TESTING
multiline_comment|/* I&squot;m sorry, but: NOBODY ever used this trace&n;&t;&t; * messages for ages. I guess that Bas was the last person&n;&t;&t; * that ever really used this (thank you, between the lines)&n;&t;&t; */
r_if
c_cond
(paren
id|cause
op_eq
id|no_error
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;reading segment %d&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;error reading segment %d&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;IRQ:C: 0x%02x, H: 0x%02x, R: 0x%02x, N: 0x%02x&bslash;n&quot;
id|KERN_INFO
l_string|&quot;BUF:C: 0x%02x, H: 0x%02x, R: 0x%02x&quot;
comma
id|in
(braket
l_int|3
)braket
comma
id|in
(braket
l_int|4
)braket
comma
id|in
(braket
l_int|5
)braket
comma
id|in
(braket
l_int|6
)braket
comma
id|buff-&gt;cyl
comma
id|buff-&gt;head
comma
id|buff-&gt;sect
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|aborting
op_logical_or
id|ft_runner_status
op_eq
id|do_abort
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;aborting %s&quot;
comma
id|fdc_mode_txt
c_func
(paren
id|fdc_mode
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff-&gt;bad_sector_map
op_eq
id|FAKE_SEGMENT
)paren
(brace
multiline_comment|/* This condition occurs when reading a `fake&squot;&n;&t;&t;&t; * sector that&squot;s not accessible. Doesn&squot;t&n;&t;&t;&t; * really matter as we would have ignored it&n;&t;&t;&t; * anyway !&n;&t;&t;&t; *&n;&t;&t;&t; * Chance is that we&squot;re past the next segment&n;&t;&t;&t; * now, so the next operation may fail and&n;&t;&t;&t; * result in a retry.  &n;&t;&t;&t; */
id|buff-&gt;remaining
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* skip failing sector */
multiline_comment|/* buff-&gt;ptr       = buff-&gt;address; */
multiline_comment|/* fake success: */
id|continue_xfer
c_func
(paren
id|buff
comma
id|fdc_mode
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*  trace calls are expensive: place them AFTER&n;&t;&t;&t; *  the real stuff has been done.&n;&t;&t;&t; *  &n;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;skipping empty segment %d (read), size? %d&quot;
comma
id|buff-&gt;segment_id
comma
id|buff-&gt;ptr
op_minus
id|buff-&gt;address
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff-&gt;retry
OG
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;this is retry nr %d&quot;
comma
id|buff-&gt;retry
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cause
)paren
(brace
r_case
id|no_error
suffix:colon
id|determine_progress
c_func
(paren
id|buff
comma
id|cause
comma
id|in
(braket
l_int|5
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in
(braket
l_int|2
)braket
op_amp
l_int|0x40
)paren
(brace
multiline_comment|/*  Handle deleted data in header segments.&n;&t;&t;&t;&t; *  Skip segment and force read-ahead.&n;&t;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;deleted data in segment %d/%d&quot;
comma
id|buff-&gt;segment_id
comma
id|FT_SECTOR
c_func
(paren
id|buff-&gt;sector_offset
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|buff-&gt;deleted
op_assign
l_int|1
suffix:semicolon
id|buff-&gt;remaining
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*abort transfer */
id|buff-&gt;soft_error_map
op_or_assign
(paren
op_minus
l_int|1L
op_lshift
id|buff-&gt;sector_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff-&gt;segment_id
op_eq
l_int|0
)paren
(brace
multiline_comment|/* stop on next segment */
id|stop_read_ahead
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* force read-ahead: */
id|buff-&gt;next_segment
op_assign
id|buff-&gt;segment_id
op_plus
l_int|1
suffix:semicolon
id|skip
op_assign
(paren
id|FT_SECTORS_PER_SEGMENT
op_minus
id|buff-&gt;sector_offset
)paren
suffix:semicolon
)brace
r_else
(brace
id|skip
op_assign
l_int|0
suffix:semicolon
)brace
id|continue_xfer
c_func
(paren
id|buff
comma
id|fdc_mode
comma
id|skip
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|no_data_error
suffix:colon
multiline_comment|/* Tape started too far ahead of or behind the&n;&t;&t;&t; * right sector.  This may also happen in the&n;&t;&t;&t; * middle of a segment !&n;&t;&t;&t; *&n;&t;&t;&t; * Handle no-data as soft error. If next&n;&t;&t;&t; * sector fails too, a retry (with needed&n;&t;&t;&t; * reposition) will follow.&n;&t;&t;&t; */
id|retry
op_increment
suffix:semicolon
r_case
id|id_am_error
suffix:colon
r_case
id|id_crc_error
suffix:colon
r_case
id|data_am_error
suffix:colon
r_case
id|data_crc_error
suffix:colon
r_case
id|overrun_error
suffix:colon
id|retry
op_add_assign
(paren
id|buff-&gt;soft_error_map
op_ne
l_int|0
op_logical_or
id|buff-&gt;hard_error_map
op_ne
l_int|0
)paren
suffix:semicolon
id|determine_progress
c_func
(paren
id|buff
comma
id|cause
comma
id|in
(braket
l_int|5
)braket
)paren
suffix:semicolon
macro_line|#if 1 || defined(TESTING)
r_if
c_cond
(paren
id|cause
op_eq
id|overrun_error
)paren
id|retry
op_increment
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|retry
)paren
(brace
id|skip
op_assign
id|find_resume_point
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
r_else
(brace
id|skip
op_assign
id|buff-&gt;sector_offset
suffix:semicolon
)brace
multiline_comment|/*  Try to resume with next sector on single&n;&t;&t;&t; *  errors (let ecc correct it), but retry on&n;&t;&t;&t; *  no_data (we&squot;ll be past the target when we&n;&t;&t;&t; *  get here so we cannot retry) or on&n;&t;&t;&t; *  multiple errors (reduce chance on ecc&n;&t;&t;&t; *  failure).&n;&t;&t;&t; */
multiline_comment|/*  cH: 23/02/97: if the last sector in the &n;&t;&t;&t; *  segment was a hard error, then there is &n;&t;&t;&t; *  no sense in a retry. This occasion seldom&n;&t;&t;&t; *  occurs but ... @:&#xfffd;&#xfffd;&#xfffd;`@%&amp;&#xfffd;$&n;&t;&t;&t; */
r_if
c_cond
(paren
id|retry
op_logical_and
id|skip
OL
l_int|32
)paren
(brace
id|retry_sector
c_func
(paren
id|buff
comma
id|fdc_mode
comma
id|skip
)paren
suffix:semicolon
)brace
r_else
(brace
id|continue_xfer
c_func
(paren
id|buff
comma
id|fdc_mode
comma
id|skip
)paren
suffix:semicolon
)brace
id|update_history
c_func
(paren
id|cause
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*  Don&squot;t know why this could happen &n;&t;&t;&t; *  but find out.&n;&t;&t;&t; */
id|determine_progress
c_func
(paren
id|buff
comma
id|cause
comma
id|in
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|retry_sector
c_func
(paren
id|buff
comma
id|fdc_mode
comma
l_int|0
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;Error: unexpected error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|fdc_reading_id
suffix:colon
r_if
c_cond
(paren
id|cause
op_eq
id|no_error
)paren
(brace
id|fdc_cyl
op_assign
id|in
(braket
l_int|3
)braket
suffix:semicolon
id|fdc_head
op_assign
id|in
(braket
l_int|4
)braket
suffix:semicolon
id|fdc_sect
op_assign
id|in
(braket
l_int|5
)braket
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;id read: C: 0x%02x, H: 0x%02x, R: 0x%02x&quot;
comma
id|fdc_cyl
comma
id|fdc_head
comma
id|fdc_sect
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* no valid information, use invalid sector */
id|fdc_cyl
op_assign
id|fdc_head
op_assign
id|fdc_sect
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;Didn&squot;t find valid sector Id&quot;
)paren
suffix:semicolon
)brace
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fdc_deleting
suffix:colon
r_case
id|fdc_writing_data
suffix:colon
macro_line|#ifdef TESTING
r_if
c_cond
(paren
id|cause
op_eq
id|no_error
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;writing segment %d&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;error writing segment %d&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|aborting
op_logical_or
id|ft_runner_status
op_eq
id|do_abort
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;aborting %s&quot;
comma
id|fdc_mode_txt
c_func
(paren
id|fdc_mode
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff-&gt;retry
OG
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;this is retry nr %d&quot;
comma
id|buff-&gt;retry
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff-&gt;bad_sector_map
op_eq
id|FAKE_SEGMENT
)paren
(brace
multiline_comment|/* This condition occurs when trying to write to a&n;&t;&t;&t; * `fake&squot; sector that&squot;s not accessible. Doesn&squot;t really&n;&t;&t;&t; * matter as it isn&squot;t used anyway ! Might be located&n;&t;&t;&t; * at wrong segment, then we&squot;ll fail on the next&n;&t;&t;&t; * segment.&n;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;skipping empty segment (write)&quot;
)paren
suffix:semicolon
id|buff-&gt;remaining
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* skip failing sector */
multiline_comment|/* fake success: */
id|continue_xfer
c_func
(paren
id|buff
comma
id|fdc_mode
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cause
)paren
(brace
r_case
id|no_error
suffix:colon
id|determine_progress
c_func
(paren
id|buff
comma
id|cause
comma
id|in
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|continue_xfer
c_func
(paren
id|buff
comma
id|fdc_mode
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|no_data_error
suffix:colon
r_case
id|id_am_error
suffix:colon
r_case
id|id_crc_error
suffix:colon
r_case
id|data_am_error
suffix:colon
r_case
id|overrun_error
suffix:colon
id|update_history
c_func
(paren
id|cause
)paren
suffix:semicolon
id|determine_progress
c_func
(paren
id|buff
comma
id|cause
comma
id|in
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|skip
op_assign
id|find_resume_point
c_func
(paren
id|buff
)paren
suffix:semicolon
id|retry_sector
c_func
(paren
id|buff
comma
id|fdc_mode
comma
id|skip
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|in
(braket
l_int|1
)braket
op_amp
l_int|0x02
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;media not writable&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;unforeseen write error&quot;
)paren
suffix:semicolon
)brace
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* fdc_deleting || fdc_writing_data */
r_case
id|fdc_formatting
suffix:colon
multiline_comment|/*  The interrupt comes after formatting a segment. We then&n;&t;&t; *  have to set up QUICKLY for the next segment. But&n;&t;&t; *  afterwards, there is plenty of time.&n;&t;&t; */
r_switch
c_cond
(paren
id|cause
)paren
(brace
r_case
id|no_error
suffix:colon
multiline_comment|/*  would like to keep most of the formatting stuff&n;&t;&t;&t; *  outside the isr code, but timing is too critical&n;&t;&t;&t; */
r_if
c_cond
(paren
id|determine_fmt_progress
c_func
(paren
id|buff
comma
id|cause
)paren
op_ge
l_int|0
)paren
(brace
id|continue_formatting
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|no_data_error
suffix:colon
r_case
id|id_am_error
suffix:colon
r_case
id|id_crc_error
suffix:colon
r_case
id|data_am_error
suffix:colon
r_case
id|overrun_error
suffix:colon
r_default
suffix:colon
id|determine_fmt_progress
c_func
(paren
id|buff
comma
id|cause
)paren
suffix:semicolon
id|update_history
c_func
(paren
id|cause
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in
(braket
l_int|1
)braket
op_amp
l_int|0x02
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;media not writable&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;unforeseen write error&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* cause */
r_break
suffix:semicolon
r_default
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Warning: unexpected irq during: %s&quot;
comma
id|fdc_mode_txt
c_func
(paren
id|fdc_mode
)paren
)paren
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
r_break
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*      FDC interrupt service routine.&n; */
DECL|function|fdc_isr
r_void
id|fdc_isr
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|isr_active
suffix:semicolon
macro_line|#ifdef TESTING
r_int
r_int
id|t0
op_assign
id|ftape_timestamp
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isr_active
op_increment
)paren
(brace
op_decrement
id|isr_active
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;BUG: nested interrupt, not good !&quot;
)paren
suffix:semicolon
op_star
id|fdc.hook
op_assign
id|fdc_isr
suffix:semicolon
multiline_comment|/*  hook our handler into the fdc&n;&t;&t;&t;&t;      *  code again &n;&t;&t;&t;&t;      */
id|TRACE_EXIT
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|fdc.msr
)paren
op_amp
id|FDC_BUSY
)paren
(brace
multiline_comment|/*  Entering Result Phase */
id|ft_hide_interrupt
op_assign
l_int|0
suffix:semicolon
id|handle_fdc_busy
c_func
(paren
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|do_abort
)paren
(brace
multiline_comment|/*      cease operation, remember tape position&n;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;runner aborting&quot;
)paren
suffix:semicolon
id|ft_runner_status
op_assign
id|aborting
suffix:semicolon
op_increment
id|ft_expected_stray_interrupts
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* !FDC_BUSY */
multiline_comment|/*  clear interrupt, cause should be gotten by issuing&n;&t;&t; *  a Sense Interrupt Status command.&n;&t;&t; */
r_if
c_cond
(paren
id|fdc_mode
op_eq
id|fdc_recalibrating
op_logical_or
id|fdc_mode
op_eq
id|fdc_seeking
)paren
(brace
r_if
c_cond
(paren
id|ft_hide_interrupt
)paren
(brace
r_int
id|st0
suffix:semicolon
r_int
id|pcn
suffix:semicolon
r_if
c_cond
(paren
id|fdc_sense_interrupt_status
c_func
(paren
op_amp
id|st0
comma
op_amp
id|pcn
)paren
OL
l_int|0
)paren
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;sense interrupt status failed&quot;
)paren
suffix:semicolon
id|ftape_current_cylinder
op_assign
id|pcn
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;handled hidden interrupt&quot;
)paren
suffix:semicolon
)brace
id|ft_seek_completed
op_assign
l_int|1
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,0,16)
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|waitqueue_active
c_func
(paren
op_amp
id|ftape_wait_intr
)paren
)paren
(brace
macro_line|#else
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|ftape_wait_intr
)paren
(brace
macro_line|#endif
r_if
c_cond
(paren
id|ft_expected_stray_interrupts
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;unexpected stray interrupt&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;expected stray interrupt&quot;
)paren
suffix:semicolon
op_decrement
id|ft_expected_stray_interrupts
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|fdc_mode
op_eq
id|fdc_reading_data
op_logical_or
id|fdc_mode
op_eq
id|fdc_verifying
op_logical_or
id|fdc_mode
op_eq
id|fdc_writing_data
op_logical_or
id|fdc_mode
op_eq
id|fdc_deleting
op_logical_or
id|fdc_mode
op_eq
id|fdc_formatting
op_logical_or
id|fdc_mode
op_eq
id|fdc_reading_id
)paren
(brace
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|fdc.msr
)paren
op_amp
id|FDC_BUSY
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;***** FDC failure, busy too late&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;***** FDC failure, no busy&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;awaited stray interrupt&quot;
)paren
suffix:semicolon
)brace
)brace
id|ft_hide_interrupt
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*    Handle sleep code.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ft_hide_interrupt
)paren
(brace
id|ft_interrupt_seen
op_increment
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,0,16)
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ftape_wait_intr
)paren
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|ftape_wait_intr
)paren
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|ftape_wait_intr
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|ftape_wait_intr
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_else
(brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,0,16)
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;hiding interrupt while %s&quot;
comma
id|waitqueue_active
c_func
(paren
op_amp
id|ftape_wait_intr
)paren
ques
c_cond
l_string|&quot;waiting&quot;
suffix:colon
l_string|&quot;active&quot;
)paren
suffix:semicolon
macro_line|#else
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;hiding interrupt while %s&quot;
comma
id|ftape_wait_intr
ques
c_cond
l_string|&quot;waiting&quot;
suffix:colon
l_string|&quot;active&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef TESTING
id|t0
op_assign
id|ftape_timediff
c_func
(paren
id|t0
comma
id|ftape_timestamp
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t0
op_ge
l_int|1000
)paren
(brace
multiline_comment|/* only tell us about long calls */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;isr() duration: %5d usec&quot;
comma
id|t0
)paren
suffix:semicolon
)brace
macro_line|#endif
op_star
id|fdc.hook
op_assign
id|fdc_isr
suffix:semicolon
multiline_comment|/* hook our handler into the fdc code again */
op_decrement
id|isr_active
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
eof
