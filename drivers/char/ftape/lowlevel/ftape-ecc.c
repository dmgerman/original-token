multiline_comment|/*&n; *&n; *      Copyright (c) 1993 Ning and David Mosberger.&n; &n; This is based on code originally written by Bas Laarhoven (bas@vimec.nl)&n; and David L. Brown, Jr., and incorporates improvements suggested by&n; Kai Harrekilde-Petersen.&n;&n; This program is free software; you can redistribute it and/or&n; modify it under the terms of the GNU General Public License as&n; published by the Free Software Foundation; either version 2, or (at&n; your option) any later version.&n; &n; This program is distributed in the hope that it will be useful, but&n; WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; General Public License for more details.&n; &n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139,&n; USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/lowlevel/ftape-ecc.c,v $&n; * $Revision: 1.3 $&n; * $Date: 1997/10/05 19:18:10 $&n; *&n; *      This file contains the Reed-Solomon error correction code &n; *      for the QIC-40/80 floppy-tape driver for Linux.&n; */
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &quot;../lowlevel/ftape-tracing.h&quot;
macro_line|#include &quot;../lowlevel/ftape-ecc.h&quot;
multiline_comment|/* Machines that are big-endian should define macro BIG_ENDIAN.&n; * Unfortunately, there doesn&squot;t appear to be a standard include file&n; * that works for all OSs.&n; */
macro_line|#if defined(__sparc__) || defined(__hppa)
DECL|macro|BIG_ENDIAN
mdefine_line|#define BIG_ENDIAN
macro_line|#endif&t;&t;&t;&t;/* __sparc__ || __hppa */
macro_line|#if defined(__mips__)
macro_line|#error Find a smart way to determine the Endianness of the MIPS CPU
macro_line|#endif
multiline_comment|/* Notice: to minimize the potential for confusion, we use r to&n; *         denote the independent variable of the polynomials in the&n; *         Galois Field GF(2^8).  We reserve x for polynomials that&n; *         that have coefficients in GF(2^8).&n; *         &n; * The Galois Field in which coefficient arithmetic is performed are&n; * the polynomials over Z_2 (i.e., 0 and 1) modulo the irreducible&n; * polynomial f(r), where f(r)=r^8 + r^7 + r^2 + r + 1.  A polynomial&n; * is represented as a byte with the MSB as the coefficient of r^7 and&n; * the LSB as the coefficient of r^0.  For example, the binary&n; * representation of f(x) is 0x187 (of course, this doesn&squot;t fit into 8&n; * bits).  In this field, the polynomial r is a primitive element.&n; * That is, r^i with i in 0,...,255 enumerates all elements in the&n; * field.&n; *&n; * The generator polynomial for the QIC-80 ECC is&n; *&n; *      g(x) = x^3 + r^105*x^2 + r^105*x + 1&n; *&n; * which can be factored into:&n; *&n; *      g(x) = (x-r^-1)(x-r^0)(x-r^1)&n; *&n; * the byte representation of the coefficients are:&n; *&n; *      r^105 = 0xc0&n; *      r^-1  = 0xc3&n; *      r^0   = 0x01&n; *      r^1   = 0x02&n; *&n; * Notice that r^-1 = r^254 as exponent arithmetic is performed&n; * modulo 2^8-1 = 255.&n; *&n; * For more information on Galois Fields and Reed-Solomon codes, refer&n; * to any good book.  I found _An Introduction to Error Correcting&n; * Codes with Applications_ by S. A. Vanstone and P. C. van Oorschot&n; * to be a good introduction into the former.  _CODING THEORY: The&n; * Essentials_ I found very useful for its concise description of&n; * Reed-Solomon encoding/decoding.&n; *&n; */
DECL|typedef|Matrix
r_typedef
id|__u8
id|Matrix
(braket
l_int|3
)braket
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/*&n; * gfpow[] is defined such that gfpow[i] returns r^i if&n; * i is in the range [0..255].&n; */
DECL|variable|gfpow
r_static
r_const
id|__u8
id|gfpow
(braket
)braket
op_assign
(brace
l_int|0x01
comma
l_int|0x02
comma
l_int|0x04
comma
l_int|0x08
comma
l_int|0x10
comma
l_int|0x20
comma
l_int|0x40
comma
l_int|0x80
comma
l_int|0x87
comma
l_int|0x89
comma
l_int|0x95
comma
l_int|0xad
comma
l_int|0xdd
comma
l_int|0x3d
comma
l_int|0x7a
comma
l_int|0xf4
comma
l_int|0x6f
comma
l_int|0xde
comma
l_int|0x3b
comma
l_int|0x76
comma
l_int|0xec
comma
l_int|0x5f
comma
l_int|0xbe
comma
l_int|0xfb
comma
l_int|0x71
comma
l_int|0xe2
comma
l_int|0x43
comma
l_int|0x86
comma
l_int|0x8b
comma
l_int|0x91
comma
l_int|0xa5
comma
l_int|0xcd
comma
l_int|0x1d
comma
l_int|0x3a
comma
l_int|0x74
comma
l_int|0xe8
comma
l_int|0x57
comma
l_int|0xae
comma
l_int|0xdb
comma
l_int|0x31
comma
l_int|0x62
comma
l_int|0xc4
comma
l_int|0x0f
comma
l_int|0x1e
comma
l_int|0x3c
comma
l_int|0x78
comma
l_int|0xf0
comma
l_int|0x67
comma
l_int|0xce
comma
l_int|0x1b
comma
l_int|0x36
comma
l_int|0x6c
comma
l_int|0xd8
comma
l_int|0x37
comma
l_int|0x6e
comma
l_int|0xdc
comma
l_int|0x3f
comma
l_int|0x7e
comma
l_int|0xfc
comma
l_int|0x7f
comma
l_int|0xfe
comma
l_int|0x7b
comma
l_int|0xf6
comma
l_int|0x6b
comma
l_int|0xd6
comma
l_int|0x2b
comma
l_int|0x56
comma
l_int|0xac
comma
l_int|0xdf
comma
l_int|0x39
comma
l_int|0x72
comma
l_int|0xe4
comma
l_int|0x4f
comma
l_int|0x9e
comma
l_int|0xbb
comma
l_int|0xf1
comma
l_int|0x65
comma
l_int|0xca
comma
l_int|0x13
comma
l_int|0x26
comma
l_int|0x4c
comma
l_int|0x98
comma
l_int|0xb7
comma
l_int|0xe9
comma
l_int|0x55
comma
l_int|0xaa
comma
l_int|0xd3
comma
l_int|0x21
comma
l_int|0x42
comma
l_int|0x84
comma
l_int|0x8f
comma
l_int|0x99
comma
l_int|0xb5
comma
l_int|0xed
comma
l_int|0x5d
comma
l_int|0xba
comma
l_int|0xf3
comma
l_int|0x61
comma
l_int|0xc2
comma
l_int|0x03
comma
l_int|0x06
comma
l_int|0x0c
comma
l_int|0x18
comma
l_int|0x30
comma
l_int|0x60
comma
l_int|0xc0
comma
l_int|0x07
comma
l_int|0x0e
comma
l_int|0x1c
comma
l_int|0x38
comma
l_int|0x70
comma
l_int|0xe0
comma
l_int|0x47
comma
l_int|0x8e
comma
l_int|0x9b
comma
l_int|0xb1
comma
l_int|0xe5
comma
l_int|0x4d
comma
l_int|0x9a
comma
l_int|0xb3
comma
l_int|0xe1
comma
l_int|0x45
comma
l_int|0x8a
comma
l_int|0x93
comma
l_int|0xa1
comma
l_int|0xc5
comma
l_int|0x0d
comma
l_int|0x1a
comma
l_int|0x34
comma
l_int|0x68
comma
l_int|0xd0
comma
l_int|0x27
comma
l_int|0x4e
comma
l_int|0x9c
comma
l_int|0xbf
comma
l_int|0xf9
comma
l_int|0x75
comma
l_int|0xea
comma
l_int|0x53
comma
l_int|0xa6
comma
l_int|0xcb
comma
l_int|0x11
comma
l_int|0x22
comma
l_int|0x44
comma
l_int|0x88
comma
l_int|0x97
comma
l_int|0xa9
comma
l_int|0xd5
comma
l_int|0x2d
comma
l_int|0x5a
comma
l_int|0xb4
comma
l_int|0xef
comma
l_int|0x59
comma
l_int|0xb2
comma
l_int|0xe3
comma
l_int|0x41
comma
l_int|0x82
comma
l_int|0x83
comma
l_int|0x81
comma
l_int|0x85
comma
l_int|0x8d
comma
l_int|0x9d
comma
l_int|0xbd
comma
l_int|0xfd
comma
l_int|0x7d
comma
l_int|0xfa
comma
l_int|0x73
comma
l_int|0xe6
comma
l_int|0x4b
comma
l_int|0x96
comma
l_int|0xab
comma
l_int|0xd1
comma
l_int|0x25
comma
l_int|0x4a
comma
l_int|0x94
comma
l_int|0xaf
comma
l_int|0xd9
comma
l_int|0x35
comma
l_int|0x6a
comma
l_int|0xd4
comma
l_int|0x2f
comma
l_int|0x5e
comma
l_int|0xbc
comma
l_int|0xff
comma
l_int|0x79
comma
l_int|0xf2
comma
l_int|0x63
comma
l_int|0xc6
comma
l_int|0x0b
comma
l_int|0x16
comma
l_int|0x2c
comma
l_int|0x58
comma
l_int|0xb0
comma
l_int|0xe7
comma
l_int|0x49
comma
l_int|0x92
comma
l_int|0xa3
comma
l_int|0xc1
comma
l_int|0x05
comma
l_int|0x0a
comma
l_int|0x14
comma
l_int|0x28
comma
l_int|0x50
comma
l_int|0xa0
comma
l_int|0xc7
comma
l_int|0x09
comma
l_int|0x12
comma
l_int|0x24
comma
l_int|0x48
comma
l_int|0x90
comma
l_int|0xa7
comma
l_int|0xc9
comma
l_int|0x15
comma
l_int|0x2a
comma
l_int|0x54
comma
l_int|0xa8
comma
l_int|0xd7
comma
l_int|0x29
comma
l_int|0x52
comma
l_int|0xa4
comma
l_int|0xcf
comma
l_int|0x19
comma
l_int|0x32
comma
l_int|0x64
comma
l_int|0xc8
comma
l_int|0x17
comma
l_int|0x2e
comma
l_int|0x5c
comma
l_int|0xb8
comma
l_int|0xf7
comma
l_int|0x69
comma
l_int|0xd2
comma
l_int|0x23
comma
l_int|0x46
comma
l_int|0x8c
comma
l_int|0x9f
comma
l_int|0xb9
comma
l_int|0xf5
comma
l_int|0x6d
comma
l_int|0xda
comma
l_int|0x33
comma
l_int|0x66
comma
l_int|0xcc
comma
l_int|0x1f
comma
l_int|0x3e
comma
l_int|0x7c
comma
l_int|0xf8
comma
l_int|0x77
comma
l_int|0xee
comma
l_int|0x5b
comma
l_int|0xb6
comma
l_int|0xeb
comma
l_int|0x51
comma
l_int|0xa2
comma
l_int|0xc3
comma
l_int|0x01
)brace
suffix:semicolon
multiline_comment|/*&n; * This is a log table.  That is, gflog[r^i] returns i (modulo f(r)).&n; * gflog[0] is undefined and the first element is therefore not valid.&n; */
DECL|variable|gflog
r_static
r_const
id|__u8
id|gflog
(braket
l_int|256
)braket
op_assign
(brace
l_int|0xff
comma
l_int|0x00
comma
l_int|0x01
comma
l_int|0x63
comma
l_int|0x02
comma
l_int|0xc6
comma
l_int|0x64
comma
l_int|0x6a
comma
l_int|0x03
comma
l_int|0xcd
comma
l_int|0xc7
comma
l_int|0xbc
comma
l_int|0x65
comma
l_int|0x7e
comma
l_int|0x6b
comma
l_int|0x2a
comma
l_int|0x04
comma
l_int|0x8d
comma
l_int|0xce
comma
l_int|0x4e
comma
l_int|0xc8
comma
l_int|0xd4
comma
l_int|0xbd
comma
l_int|0xe1
comma
l_int|0x66
comma
l_int|0xdd
comma
l_int|0x7f
comma
l_int|0x31
comma
l_int|0x6c
comma
l_int|0x20
comma
l_int|0x2b
comma
l_int|0xf3
comma
l_int|0x05
comma
l_int|0x57
comma
l_int|0x8e
comma
l_int|0xe8
comma
l_int|0xcf
comma
l_int|0xac
comma
l_int|0x4f
comma
l_int|0x83
comma
l_int|0xc9
comma
l_int|0xd9
comma
l_int|0xd5
comma
l_int|0x41
comma
l_int|0xbe
comma
l_int|0x94
comma
l_int|0xe2
comma
l_int|0xb4
comma
l_int|0x67
comma
l_int|0x27
comma
l_int|0xde
comma
l_int|0xf0
comma
l_int|0x80
comma
l_int|0xb1
comma
l_int|0x32
comma
l_int|0x35
comma
l_int|0x6d
comma
l_int|0x45
comma
l_int|0x21
comma
l_int|0x12
comma
l_int|0x2c
comma
l_int|0x0d
comma
l_int|0xf4
comma
l_int|0x38
comma
l_int|0x06
comma
l_int|0x9b
comma
l_int|0x58
comma
l_int|0x1a
comma
l_int|0x8f
comma
l_int|0x79
comma
l_int|0xe9
comma
l_int|0x70
comma
l_int|0xd0
comma
l_int|0xc2
comma
l_int|0xad
comma
l_int|0xa8
comma
l_int|0x50
comma
l_int|0x75
comma
l_int|0x84
comma
l_int|0x48
comma
l_int|0xca
comma
l_int|0xfc
comma
l_int|0xda
comma
l_int|0x8a
comma
l_int|0xd6
comma
l_int|0x54
comma
l_int|0x42
comma
l_int|0x24
comma
l_int|0xbf
comma
l_int|0x98
comma
l_int|0x95
comma
l_int|0xf9
comma
l_int|0xe3
comma
l_int|0x5e
comma
l_int|0xb5
comma
l_int|0x15
comma
l_int|0x68
comma
l_int|0x61
comma
l_int|0x28
comma
l_int|0xba
comma
l_int|0xdf
comma
l_int|0x4c
comma
l_int|0xf1
comma
l_int|0x2f
comma
l_int|0x81
comma
l_int|0xe6
comma
l_int|0xb2
comma
l_int|0x3f
comma
l_int|0x33
comma
l_int|0xee
comma
l_int|0x36
comma
l_int|0x10
comma
l_int|0x6e
comma
l_int|0x18
comma
l_int|0x46
comma
l_int|0xa6
comma
l_int|0x22
comma
l_int|0x88
comma
l_int|0x13
comma
l_int|0xf7
comma
l_int|0x2d
comma
l_int|0xb8
comma
l_int|0x0e
comma
l_int|0x3d
comma
l_int|0xf5
comma
l_int|0xa4
comma
l_int|0x39
comma
l_int|0x3b
comma
l_int|0x07
comma
l_int|0x9e
comma
l_int|0x9c
comma
l_int|0x9d
comma
l_int|0x59
comma
l_int|0x9f
comma
l_int|0x1b
comma
l_int|0x08
comma
l_int|0x90
comma
l_int|0x09
comma
l_int|0x7a
comma
l_int|0x1c
comma
l_int|0xea
comma
l_int|0xa0
comma
l_int|0x71
comma
l_int|0x5a
comma
l_int|0xd1
comma
l_int|0x1d
comma
l_int|0xc3
comma
l_int|0x7b
comma
l_int|0xae
comma
l_int|0x0a
comma
l_int|0xa9
comma
l_int|0x91
comma
l_int|0x51
comma
l_int|0x5b
comma
l_int|0x76
comma
l_int|0x72
comma
l_int|0x85
comma
l_int|0xa1
comma
l_int|0x49
comma
l_int|0xeb
comma
l_int|0xcb
comma
l_int|0x7c
comma
l_int|0xfd
comma
l_int|0xc4
comma
l_int|0xdb
comma
l_int|0x1e
comma
l_int|0x8b
comma
l_int|0xd2
comma
l_int|0xd7
comma
l_int|0x92
comma
l_int|0x55
comma
l_int|0xaa
comma
l_int|0x43
comma
l_int|0x0b
comma
l_int|0x25
comma
l_int|0xaf
comma
l_int|0xc0
comma
l_int|0x73
comma
l_int|0x99
comma
l_int|0x77
comma
l_int|0x96
comma
l_int|0x5c
comma
l_int|0xfa
comma
l_int|0x52
comma
l_int|0xe4
comma
l_int|0xec
comma
l_int|0x5f
comma
l_int|0x4a
comma
l_int|0xb6
comma
l_int|0xa2
comma
l_int|0x16
comma
l_int|0x86
comma
l_int|0x69
comma
l_int|0xc5
comma
l_int|0x62
comma
l_int|0xfe
comma
l_int|0x29
comma
l_int|0x7d
comma
l_int|0xbb
comma
l_int|0xcc
comma
l_int|0xe0
comma
l_int|0xd3
comma
l_int|0x4d
comma
l_int|0x8c
comma
l_int|0xf2
comma
l_int|0x1f
comma
l_int|0x30
comma
l_int|0xdc
comma
l_int|0x82
comma
l_int|0xab
comma
l_int|0xe7
comma
l_int|0x56
comma
l_int|0xb3
comma
l_int|0x93
comma
l_int|0x40
comma
l_int|0xd8
comma
l_int|0x34
comma
l_int|0xb0
comma
l_int|0xef
comma
l_int|0x26
comma
l_int|0x37
comma
l_int|0x0c
comma
l_int|0x11
comma
l_int|0x44
comma
l_int|0x6f
comma
l_int|0x78
comma
l_int|0x19
comma
l_int|0x9a
comma
l_int|0x47
comma
l_int|0x74
comma
l_int|0xa7
comma
l_int|0xc1
comma
l_int|0x23
comma
l_int|0x53
comma
l_int|0x89
comma
l_int|0xfb
comma
l_int|0x14
comma
l_int|0x5d
comma
l_int|0xf8
comma
l_int|0x97
comma
l_int|0x2e
comma
l_int|0x4b
comma
l_int|0xb9
comma
l_int|0x60
comma
l_int|0x0f
comma
l_int|0xed
comma
l_int|0x3e
comma
l_int|0xe5
comma
l_int|0xf6
comma
l_int|0x87
comma
l_int|0xa5
comma
l_int|0x17
comma
l_int|0x3a
comma
l_int|0xa3
comma
l_int|0x3c
comma
l_int|0xb7
)brace
suffix:semicolon
multiline_comment|/* This is a multiplication table for the factor 0xc0 (i.e., r^105 (mod f(r)).&n; * gfmul_c0[f] returns r^105 * f(r) (modulo f(r)).&n; */
DECL|variable|gfmul_c0
r_static
r_const
id|__u8
id|gfmul_c0
(braket
l_int|256
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0xc0
comma
l_int|0x07
comma
l_int|0xc7
comma
l_int|0x0e
comma
l_int|0xce
comma
l_int|0x09
comma
l_int|0xc9
comma
l_int|0x1c
comma
l_int|0xdc
comma
l_int|0x1b
comma
l_int|0xdb
comma
l_int|0x12
comma
l_int|0xd2
comma
l_int|0x15
comma
l_int|0xd5
comma
l_int|0x38
comma
l_int|0xf8
comma
l_int|0x3f
comma
l_int|0xff
comma
l_int|0x36
comma
l_int|0xf6
comma
l_int|0x31
comma
l_int|0xf1
comma
l_int|0x24
comma
l_int|0xe4
comma
l_int|0x23
comma
l_int|0xe3
comma
l_int|0x2a
comma
l_int|0xea
comma
l_int|0x2d
comma
l_int|0xed
comma
l_int|0x70
comma
l_int|0xb0
comma
l_int|0x77
comma
l_int|0xb7
comma
l_int|0x7e
comma
l_int|0xbe
comma
l_int|0x79
comma
l_int|0xb9
comma
l_int|0x6c
comma
l_int|0xac
comma
l_int|0x6b
comma
l_int|0xab
comma
l_int|0x62
comma
l_int|0xa2
comma
l_int|0x65
comma
l_int|0xa5
comma
l_int|0x48
comma
l_int|0x88
comma
l_int|0x4f
comma
l_int|0x8f
comma
l_int|0x46
comma
l_int|0x86
comma
l_int|0x41
comma
l_int|0x81
comma
l_int|0x54
comma
l_int|0x94
comma
l_int|0x53
comma
l_int|0x93
comma
l_int|0x5a
comma
l_int|0x9a
comma
l_int|0x5d
comma
l_int|0x9d
comma
l_int|0xe0
comma
l_int|0x20
comma
l_int|0xe7
comma
l_int|0x27
comma
l_int|0xee
comma
l_int|0x2e
comma
l_int|0xe9
comma
l_int|0x29
comma
l_int|0xfc
comma
l_int|0x3c
comma
l_int|0xfb
comma
l_int|0x3b
comma
l_int|0xf2
comma
l_int|0x32
comma
l_int|0xf5
comma
l_int|0x35
comma
l_int|0xd8
comma
l_int|0x18
comma
l_int|0xdf
comma
l_int|0x1f
comma
l_int|0xd6
comma
l_int|0x16
comma
l_int|0xd1
comma
l_int|0x11
comma
l_int|0xc4
comma
l_int|0x04
comma
l_int|0xc3
comma
l_int|0x03
comma
l_int|0xca
comma
l_int|0x0a
comma
l_int|0xcd
comma
l_int|0x0d
comma
l_int|0x90
comma
l_int|0x50
comma
l_int|0x97
comma
l_int|0x57
comma
l_int|0x9e
comma
l_int|0x5e
comma
l_int|0x99
comma
l_int|0x59
comma
l_int|0x8c
comma
l_int|0x4c
comma
l_int|0x8b
comma
l_int|0x4b
comma
l_int|0x82
comma
l_int|0x42
comma
l_int|0x85
comma
l_int|0x45
comma
l_int|0xa8
comma
l_int|0x68
comma
l_int|0xaf
comma
l_int|0x6f
comma
l_int|0xa6
comma
l_int|0x66
comma
l_int|0xa1
comma
l_int|0x61
comma
l_int|0xb4
comma
l_int|0x74
comma
l_int|0xb3
comma
l_int|0x73
comma
l_int|0xba
comma
l_int|0x7a
comma
l_int|0xbd
comma
l_int|0x7d
comma
l_int|0x47
comma
l_int|0x87
comma
l_int|0x40
comma
l_int|0x80
comma
l_int|0x49
comma
l_int|0x89
comma
l_int|0x4e
comma
l_int|0x8e
comma
l_int|0x5b
comma
l_int|0x9b
comma
l_int|0x5c
comma
l_int|0x9c
comma
l_int|0x55
comma
l_int|0x95
comma
l_int|0x52
comma
l_int|0x92
comma
l_int|0x7f
comma
l_int|0xbf
comma
l_int|0x78
comma
l_int|0xb8
comma
l_int|0x71
comma
l_int|0xb1
comma
l_int|0x76
comma
l_int|0xb6
comma
l_int|0x63
comma
l_int|0xa3
comma
l_int|0x64
comma
l_int|0xa4
comma
l_int|0x6d
comma
l_int|0xad
comma
l_int|0x6a
comma
l_int|0xaa
comma
l_int|0x37
comma
l_int|0xf7
comma
l_int|0x30
comma
l_int|0xf0
comma
l_int|0x39
comma
l_int|0xf9
comma
l_int|0x3e
comma
l_int|0xfe
comma
l_int|0x2b
comma
l_int|0xeb
comma
l_int|0x2c
comma
l_int|0xec
comma
l_int|0x25
comma
l_int|0xe5
comma
l_int|0x22
comma
l_int|0xe2
comma
l_int|0x0f
comma
l_int|0xcf
comma
l_int|0x08
comma
l_int|0xc8
comma
l_int|0x01
comma
l_int|0xc1
comma
l_int|0x06
comma
l_int|0xc6
comma
l_int|0x13
comma
l_int|0xd3
comma
l_int|0x14
comma
l_int|0xd4
comma
l_int|0x1d
comma
l_int|0xdd
comma
l_int|0x1a
comma
l_int|0xda
comma
l_int|0xa7
comma
l_int|0x67
comma
l_int|0xa0
comma
l_int|0x60
comma
l_int|0xa9
comma
l_int|0x69
comma
l_int|0xae
comma
l_int|0x6e
comma
l_int|0xbb
comma
l_int|0x7b
comma
l_int|0xbc
comma
l_int|0x7c
comma
l_int|0xb5
comma
l_int|0x75
comma
l_int|0xb2
comma
l_int|0x72
comma
l_int|0x9f
comma
l_int|0x5f
comma
l_int|0x98
comma
l_int|0x58
comma
l_int|0x91
comma
l_int|0x51
comma
l_int|0x96
comma
l_int|0x56
comma
l_int|0x83
comma
l_int|0x43
comma
l_int|0x84
comma
l_int|0x44
comma
l_int|0x8d
comma
l_int|0x4d
comma
l_int|0x8a
comma
l_int|0x4a
comma
l_int|0xd7
comma
l_int|0x17
comma
l_int|0xd0
comma
l_int|0x10
comma
l_int|0xd9
comma
l_int|0x19
comma
l_int|0xde
comma
l_int|0x1e
comma
l_int|0xcb
comma
l_int|0x0b
comma
l_int|0xcc
comma
l_int|0x0c
comma
l_int|0xc5
comma
l_int|0x05
comma
l_int|0xc2
comma
l_int|0x02
comma
l_int|0xef
comma
l_int|0x2f
comma
l_int|0xe8
comma
l_int|0x28
comma
l_int|0xe1
comma
l_int|0x21
comma
l_int|0xe6
comma
l_int|0x26
comma
l_int|0xf3
comma
l_int|0x33
comma
l_int|0xf4
comma
l_int|0x34
comma
l_int|0xfd
comma
l_int|0x3d
comma
l_int|0xfa
comma
l_int|0x3a
)brace
suffix:semicolon
multiline_comment|/* Returns V modulo 255 provided V is in the range -255,-254,...,509.&n; */
DECL|function|mod255
r_static
r_inline
id|__u8
id|mod255
c_func
(paren
r_int
id|v
)paren
(brace
r_if
c_cond
(paren
id|v
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|v
OL
l_int|255
)paren
(brace
r_return
id|v
suffix:semicolon
)brace
r_else
(brace
r_return
id|v
op_minus
l_int|255
suffix:semicolon
)brace
)brace
r_else
(brace
r_return
id|v
op_plus
l_int|255
suffix:semicolon
)brace
)brace
multiline_comment|/* Add two numbers in the field.  Addition in this field is equivalent&n; * to a bit-wise exclusive OR operation---subtraction is therefore&n; * identical to addition.&n; */
DECL|function|gfadd
r_static
r_inline
id|__u8
id|gfadd
c_func
(paren
id|__u8
id|a
comma
id|__u8
id|b
)paren
(brace
r_return
id|a
op_xor
id|b
suffix:semicolon
)brace
multiline_comment|/* Add two vectors of numbers in the field.  Each byte in A and B gets&n; * added individually.&n; */
DECL|function|gfadd_long
r_static
r_inline
r_int
r_int
id|gfadd_long
c_func
(paren
r_int
r_int
id|a
comma
r_int
r_int
id|b
)paren
(brace
r_return
id|a
op_xor
id|b
suffix:semicolon
)brace
multiline_comment|/* Multiply two numbers in the field:&n; */
DECL|function|gfmul
r_static
r_inline
id|__u8
id|gfmul
c_func
(paren
id|__u8
id|a
comma
id|__u8
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
op_logical_and
id|b
)paren
(brace
r_return
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|a
)braket
op_plus
id|gflog
(braket
id|b
)braket
)paren
)braket
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Just like gfmul, except we have already looked up the log of the&n; * second number.&n; */
DECL|function|gfmul_exp
r_static
r_inline
id|__u8
id|gfmul_exp
c_func
(paren
id|__u8
id|a
comma
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
)paren
(brace
r_return
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|a
)braket
op_plus
id|b
)paren
)braket
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Just like gfmul_exp, except that A is a vector of numbers.  That&n; * is, each byte in A gets multiplied by gfpow[mod255(B)].&n; */
DECL|function|gfmul_exp_long
r_static
r_inline
r_int
r_int
id|gfmul_exp_long
c_func
(paren
r_int
r_int
id|a
comma
r_int
id|b
)paren
(brace
id|__u8
id|t
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
r_int
)paren
op_eq
l_int|4
)paren
(brace
r_return
(paren
(paren
(paren
id|t
op_assign
(paren
id|__u32
)paren
id|a
op_rshift
l_int|24
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
(paren
(paren
id|__u32
)paren
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|t
)braket
op_plus
id|b
)paren
)braket
)paren
op_lshift
l_int|24
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|t
op_assign
(paren
id|__u32
)paren
id|a
op_rshift
l_int|16
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
(paren
(paren
id|__u32
)paren
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|t
)braket
op_plus
id|b
)paren
)braket
)paren
op_lshift
l_int|16
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|t
op_assign
(paren
id|__u32
)paren
id|a
op_rshift
l_int|8
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
(paren
(paren
id|__u32
)paren
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|t
)braket
op_plus
id|b
)paren
)braket
)paren
op_lshift
l_int|8
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|t
op_assign
(paren
id|__u32
)paren
id|a
op_rshift
l_int|0
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
(paren
(paren
id|__u32
)paren
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|t
)braket
op_plus
id|b
)paren
)braket
)paren
op_lshift
l_int|0
)paren
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
r_sizeof
(paren
r_int
)paren
op_eq
l_int|8
)paren
(brace
r_return
(paren
(paren
(paren
id|t
op_assign
(paren
id|__u64
)paren
id|a
op_rshift
l_int|56
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
(paren
(paren
id|__u64
)paren
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|t
)braket
op_plus
id|b
)paren
)braket
)paren
op_lshift
l_int|56
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|t
op_assign
(paren
id|__u64
)paren
id|a
op_rshift
l_int|48
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
(paren
(paren
id|__u64
)paren
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|t
)braket
op_plus
id|b
)paren
)braket
)paren
op_lshift
l_int|48
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|t
op_assign
(paren
id|__u64
)paren
id|a
op_rshift
l_int|40
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
(paren
(paren
id|__u64
)paren
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|t
)braket
op_plus
id|b
)paren
)braket
)paren
op_lshift
l_int|40
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|t
op_assign
(paren
id|__u64
)paren
id|a
op_rshift
l_int|32
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
(paren
(paren
id|__u64
)paren
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|t
)braket
op_plus
id|b
)paren
)braket
)paren
op_lshift
l_int|32
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|t
op_assign
(paren
id|__u64
)paren
id|a
op_rshift
l_int|24
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
(paren
(paren
id|__u64
)paren
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|t
)braket
op_plus
id|b
)paren
)braket
)paren
op_lshift
l_int|24
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|t
op_assign
(paren
id|__u64
)paren
id|a
op_rshift
l_int|16
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
(paren
(paren
id|__u64
)paren
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|t
)braket
op_plus
id|b
)paren
)braket
)paren
op_lshift
l_int|16
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|t
op_assign
(paren
id|__u64
)paren
id|a
op_rshift
l_int|8
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
(paren
(paren
id|__u64
)paren
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|t
)braket
op_plus
id|b
)paren
)braket
)paren
op_lshift
l_int|8
)paren
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|t
op_assign
(paren
id|__u64
)paren
id|a
op_rshift
l_int|0
op_amp
l_int|0xff
)paren
ques
c_cond
(paren
(paren
(paren
id|__u64
)paren
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|t
)braket
op_plus
id|b
)paren
)braket
)paren
op_lshift
l_int|0
)paren
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
op_minus
l_int|1
comma
id|ft_t_err
comma
l_string|&quot;Error: size of long is %d bytes&quot;
comma
(paren
r_int
)paren
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Divide two numbers in the field.  Returns a/b (modulo f(x)).&n; */
DECL|function|gfdiv
r_static
r_inline
id|__u8
id|gfdiv
c_func
(paren
id|__u8
id|a
comma
id|__u8
id|b
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|b
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
l_int|0xff
comma
id|ft_t_bug
comma
l_string|&quot;Error: division by zero&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|a
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_return
id|gfpow
(braket
id|mod255
c_func
(paren
id|gflog
(braket
id|a
)braket
op_minus
id|gflog
(braket
id|b
)braket
)paren
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/* The following functions return the inverse of the matrix of the&n; * linear system that needs to be solved to determine the error&n; * magnitudes.  The first deals with matrices of rank 3, while the&n; * second deals with matrices of rank 2.  The error indices are passed&n; * in arguments L0,..,L2 (0=first sector, 31=last sector).  The error&n; * indices must be sorted in ascending order, i.e., L0&lt;L1&lt;L2.&n; *&n; * The linear system that needs to be solved for the error magnitudes&n; * is A * b = s, where s is the known vector of syndromes, b is the&n; * vector of error magnitudes and A in the ORDER=3 case:&n; *&n; *    A_3 = {{1/r^L[0], 1/r^L[1], 1/r^L[2]},&n; *          {        1,        1,        1},&n; *          { r^L[0], r^L[1], r^L[2]}} &n; */
DECL|function|gfinv3
r_static
r_inline
r_int
id|gfinv3
c_func
(paren
id|__u8
id|l0
comma
id|__u8
id|l1
comma
id|__u8
id|l2
comma
id|Matrix
id|Ainv
)paren
(brace
id|__u8
id|det
suffix:semicolon
id|__u8
id|t20
comma
id|t10
comma
id|t21
comma
id|t12
comma
id|t01
comma
id|t02
suffix:semicolon
r_int
id|log_det
suffix:semicolon
multiline_comment|/* compute some intermediate results: */
id|t20
op_assign
id|gfpow
(braket
id|l2
op_minus
id|l0
)braket
suffix:semicolon
multiline_comment|/* t20 = r^l2/r^l0 */
id|t10
op_assign
id|gfpow
(braket
id|l1
op_minus
id|l0
)braket
suffix:semicolon
multiline_comment|/* t10 = r^l1/r^l0 */
id|t21
op_assign
id|gfpow
(braket
id|l2
op_minus
id|l1
)braket
suffix:semicolon
multiline_comment|/* t21 = r^l2/r^l1 */
id|t12
op_assign
id|gfpow
(braket
id|l1
op_minus
id|l2
op_plus
l_int|255
)braket
suffix:semicolon
multiline_comment|/* t12 = r^l1/r^l2 */
id|t01
op_assign
id|gfpow
(braket
id|l0
op_minus
id|l1
op_plus
l_int|255
)braket
suffix:semicolon
multiline_comment|/* t01 = r^l0/r^l1 */
id|t02
op_assign
id|gfpow
(braket
id|l0
op_minus
id|l2
op_plus
l_int|255
)braket
suffix:semicolon
multiline_comment|/* t02 = r^l0/r^l2 */
multiline_comment|/* Calculate the determinant of matrix A_3^-1 (sometimes&n;&t; * called the Vandermonde determinant):&n;&t; */
id|det
op_assign
id|gfadd
c_func
(paren
id|t20
comma
id|gfadd
c_func
(paren
id|t10
comma
id|gfadd
c_func
(paren
id|t21
comma
id|gfadd
c_func
(paren
id|t12
comma
id|gfadd
c_func
(paren
id|t01
comma
id|t02
)paren
)paren
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|det
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
l_int|0
comma
id|ft_t_err
comma
l_string|&quot;Inversion failed (3 CRC errors, &gt;0 CRC failures)&quot;
)paren
suffix:semicolon
)brace
id|log_det
op_assign
l_int|255
op_minus
id|gflog
(braket
id|det
)braket
suffix:semicolon
multiline_comment|/* Now, calculate all of the coefficients:&n;&t; */
id|Ainv
(braket
l_int|0
)braket
(braket
l_int|0
)braket
op_assign
id|gfmul_exp
c_func
(paren
id|gfadd
c_func
(paren
id|gfpow
(braket
id|l1
)braket
comma
id|gfpow
(braket
id|l2
)braket
)paren
comma
id|log_det
)paren
suffix:semicolon
id|Ainv
(braket
l_int|0
)braket
(braket
l_int|1
)braket
op_assign
id|gfmul_exp
c_func
(paren
id|gfadd
c_func
(paren
id|t21
comma
id|t12
)paren
comma
id|log_det
)paren
suffix:semicolon
id|Ainv
(braket
l_int|0
)braket
(braket
l_int|2
)braket
op_assign
id|gfmul_exp
c_func
(paren
id|gfadd
c_func
(paren
id|gfpow
(braket
l_int|255
op_minus
id|l1
)braket
comma
id|gfpow
(braket
l_int|255
op_minus
id|l2
)braket
)paren
comma
id|log_det
)paren
suffix:semicolon
id|Ainv
(braket
l_int|1
)braket
(braket
l_int|0
)braket
op_assign
id|gfmul_exp
c_func
(paren
id|gfadd
c_func
(paren
id|gfpow
(braket
id|l0
)braket
comma
id|gfpow
(braket
id|l2
)braket
)paren
comma
id|log_det
)paren
suffix:semicolon
id|Ainv
(braket
l_int|1
)braket
(braket
l_int|1
)braket
op_assign
id|gfmul_exp
c_func
(paren
id|gfadd
c_func
(paren
id|t20
comma
id|t02
)paren
comma
id|log_det
)paren
suffix:semicolon
id|Ainv
(braket
l_int|1
)braket
(braket
l_int|2
)braket
op_assign
id|gfmul_exp
c_func
(paren
id|gfadd
c_func
(paren
id|gfpow
(braket
l_int|255
op_minus
id|l0
)braket
comma
id|gfpow
(braket
l_int|255
op_minus
id|l2
)braket
)paren
comma
id|log_det
)paren
suffix:semicolon
id|Ainv
(braket
l_int|2
)braket
(braket
l_int|0
)braket
op_assign
id|gfmul_exp
c_func
(paren
id|gfadd
c_func
(paren
id|gfpow
(braket
id|l0
)braket
comma
id|gfpow
(braket
id|l1
)braket
)paren
comma
id|log_det
)paren
suffix:semicolon
id|Ainv
(braket
l_int|2
)braket
(braket
l_int|1
)braket
op_assign
id|gfmul_exp
c_func
(paren
id|gfadd
c_func
(paren
id|t10
comma
id|t01
)paren
comma
id|log_det
)paren
suffix:semicolon
id|Ainv
(braket
l_int|2
)braket
(braket
l_int|2
)braket
op_assign
id|gfmul_exp
c_func
(paren
id|gfadd
c_func
(paren
id|gfpow
(braket
l_int|255
op_minus
id|l0
)braket
comma
id|gfpow
(braket
l_int|255
op_minus
id|l1
)braket
)paren
comma
id|log_det
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|gfinv2
r_static
r_inline
r_int
id|gfinv2
c_func
(paren
id|__u8
id|l0
comma
id|__u8
id|l1
comma
id|Matrix
id|Ainv
)paren
(brace
id|__u8
id|det
suffix:semicolon
id|__u8
id|t1
comma
id|t2
suffix:semicolon
r_int
id|log_det
suffix:semicolon
id|t1
op_assign
id|gfpow
(braket
l_int|255
op_minus
id|l0
)braket
suffix:semicolon
id|t2
op_assign
id|gfpow
(braket
l_int|255
op_minus
id|l1
)braket
suffix:semicolon
id|det
op_assign
id|gfadd
c_func
(paren
id|t1
comma
id|t2
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|det
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
l_int|0
comma
id|ft_t_err
comma
l_string|&quot;Inversion failed (2 CRC errors, &gt;0 CRC failures)&quot;
)paren
suffix:semicolon
)brace
id|log_det
op_assign
l_int|255
op_minus
id|gflog
(braket
id|det
)braket
suffix:semicolon
multiline_comment|/* Now, calculate all of the coefficients:&n;&t; */
id|Ainv
(braket
l_int|0
)braket
(braket
l_int|0
)braket
op_assign
id|Ainv
(braket
l_int|1
)braket
(braket
l_int|0
)braket
op_assign
id|gfpow
(braket
id|log_det
)braket
suffix:semicolon
id|Ainv
(braket
l_int|0
)braket
(braket
l_int|1
)braket
op_assign
id|gfmul_exp
c_func
(paren
id|t2
comma
id|log_det
)paren
suffix:semicolon
id|Ainv
(braket
l_int|1
)braket
(braket
l_int|1
)braket
op_assign
id|gfmul_exp
c_func
(paren
id|t1
comma
id|log_det
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Multiply matrix A by vector S and return result in vector B.  M is&n; * assumed to be of order NxN, S and B of order Nx1.&n; */
DECL|function|gfmat_mul
r_static
r_inline
r_void
id|gfmat_mul
c_func
(paren
r_int
id|n
comma
id|Matrix
id|A
comma
id|__u8
op_star
id|s
comma
id|__u8
op_star
id|b
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
id|__u8
id|dot_prod
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
op_increment
id|i
)paren
(brace
id|dot_prod
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|n
suffix:semicolon
op_increment
id|j
)paren
(brace
id|dot_prod
op_assign
id|gfadd
c_func
(paren
id|dot_prod
comma
id|gfmul
c_func
(paren
id|A
(braket
id|i
)braket
(braket
id|j
)braket
comma
id|s
(braket
id|j
)braket
)paren
)paren
suffix:semicolon
)brace
id|b
(braket
id|i
)braket
op_assign
id|dot_prod
suffix:semicolon
)brace
)brace
"&f;"
multiline_comment|/* The Reed Solomon ECC codes are computed over the N-th byte of each&n; * block, where N=SECTOR_SIZE.  There are up to 29 blocks of data, and&n; * 3 blocks of ECC.  The blocks are stored contiguously in memory.  A&n; * segment, consequently, is assumed to have at least 4 blocks: one or&n; * more data blocks plus three ECC blocks.&n; *&n; * Notice: In QIC-80 speak, a CRC error is a sector with an incorrect&n; *         CRC.  A CRC failure is a sector with incorrect data, but&n; *         a valid CRC.  In the error control literature, the former&n; *         is usually called &quot;erasure&quot;, the latter &quot;error.&quot;&n; */
multiline_comment|/* Compute the parity bytes for C columns of data, where C is the&n; * number of bytes that fit into a long integer.  We use a linear&n; * feed-back register to do this.  The parity bytes P[0], P[STRIDE],&n; * P[2*STRIDE] are computed such that:&n; *&n; *              x^k * p(x) + m(x) = 0 (modulo g(x))&n; *&n; * where k = NBLOCKS,&n; *       p(x) = P[0] + P[STRIDE]*x + P[2*STRIDE]*x^2, and&n; *       m(x) = sum_{i=0}^k m_i*x^i.&n; *       m_i = DATA[i*SECTOR_SIZE]&n; */
DECL|function|set_parity
r_static
r_inline
r_void
id|set_parity
c_func
(paren
r_int
r_int
op_star
id|data
comma
r_int
id|nblocks
comma
r_int
r_int
op_star
id|p
comma
r_int
id|stride
)paren
(brace
r_int
r_int
id|p0
comma
id|p1
comma
id|p2
comma
id|t1
comma
id|t2
comma
op_star
id|end
suffix:semicolon
id|end
op_assign
id|data
op_plus
id|nblocks
op_star
(paren
id|FT_SECTOR_SIZE
op_div
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|p0
op_assign
id|p1
op_assign
id|p2
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|data
OL
id|end
)paren
(brace
multiline_comment|/* The new parity bytes p0_i, p1_i, p2_i are computed&n;&t;&t; * from the old values p0_{i-1}, p1_{i-1}, p2_{i-1}&n;&t;&t; * recursively as:&n;&t;&t; *&n;&t;&t; *        p0_i = p1_{i-1} + r^105 * (m_{i-1} - p0_{i-1})&n;&t;&t; *        p1_i = p2_{i-1} + r^105 * (m_{i-1} - p0_{i-1})&n;&t;&t; *        p2_i =                    (m_{i-1} - p0_{i-1})&n;&t;&t; *&n;&t;&t; * With the initial condition: p0_0 = p1_0 = p2_0 = 0.&n;&t;&t; */
id|t1
op_assign
id|gfadd_long
c_func
(paren
op_star
id|data
comma
id|p0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Multiply each byte in t1 by 0xc0:&n;&t;&t; */
r_if
c_cond
(paren
r_sizeof
(paren
r_int
)paren
op_eq
l_int|4
)paren
(brace
id|t2
op_assign
(paren
(paren
(paren
id|__u32
)paren
id|gfmul_c0
(braket
(paren
id|__u32
)paren
id|t1
op_rshift
l_int|24
op_amp
l_int|0xff
)braket
)paren
op_lshift
l_int|24
op_or
(paren
(paren
id|__u32
)paren
id|gfmul_c0
(braket
(paren
id|__u32
)paren
id|t1
op_rshift
l_int|16
op_amp
l_int|0xff
)braket
)paren
op_lshift
l_int|16
op_or
(paren
(paren
id|__u32
)paren
id|gfmul_c0
(braket
(paren
id|__u32
)paren
id|t1
op_rshift
l_int|8
op_amp
l_int|0xff
)braket
)paren
op_lshift
l_int|8
op_or
(paren
(paren
id|__u32
)paren
id|gfmul_c0
(braket
(paren
id|__u32
)paren
id|t1
op_rshift
l_int|0
op_amp
l_int|0xff
)braket
)paren
op_lshift
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
r_sizeof
(paren
r_int
)paren
op_eq
l_int|8
)paren
(brace
id|t2
op_assign
(paren
(paren
(paren
id|__u64
)paren
id|gfmul_c0
(braket
(paren
id|__u64
)paren
id|t1
op_rshift
l_int|56
op_amp
l_int|0xff
)braket
)paren
op_lshift
l_int|56
op_or
(paren
(paren
id|__u64
)paren
id|gfmul_c0
(braket
(paren
id|__u64
)paren
id|t1
op_rshift
l_int|48
op_amp
l_int|0xff
)braket
)paren
op_lshift
l_int|48
op_or
(paren
(paren
id|__u64
)paren
id|gfmul_c0
(braket
(paren
id|__u64
)paren
id|t1
op_rshift
l_int|40
op_amp
l_int|0xff
)braket
)paren
op_lshift
l_int|40
op_or
(paren
(paren
id|__u64
)paren
id|gfmul_c0
(braket
(paren
id|__u64
)paren
id|t1
op_rshift
l_int|32
op_amp
l_int|0xff
)braket
)paren
op_lshift
l_int|32
op_or
(paren
(paren
id|__u64
)paren
id|gfmul_c0
(braket
(paren
id|__u64
)paren
id|t1
op_rshift
l_int|24
op_amp
l_int|0xff
)braket
)paren
op_lshift
l_int|24
op_or
(paren
(paren
id|__u64
)paren
id|gfmul_c0
(braket
(paren
id|__u64
)paren
id|t1
op_rshift
l_int|16
op_amp
l_int|0xff
)braket
)paren
op_lshift
l_int|16
op_or
(paren
(paren
id|__u64
)paren
id|gfmul_c0
(braket
(paren
id|__u64
)paren
id|t1
op_rshift
l_int|8
op_amp
l_int|0xff
)braket
)paren
op_lshift
l_int|8
op_or
(paren
(paren
id|__u64
)paren
id|gfmul_c0
(braket
(paren
id|__u64
)paren
id|t1
op_rshift
l_int|0
op_amp
l_int|0xff
)braket
)paren
op_lshift
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;Error: long is of size %d&quot;
comma
(paren
r_int
)paren
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
id|p0
op_assign
id|gfadd_long
c_func
(paren
id|t2
comma
id|p1
)paren
suffix:semicolon
id|p1
op_assign
id|gfadd_long
c_func
(paren
id|t2
comma
id|p2
)paren
suffix:semicolon
id|p2
op_assign
id|t1
suffix:semicolon
id|data
op_add_assign
id|FT_SECTOR_SIZE
op_div
r_sizeof
(paren
r_int
)paren
suffix:semicolon
)brace
op_star
id|p
op_assign
id|p0
suffix:semicolon
id|p
op_add_assign
id|stride
suffix:semicolon
op_star
id|p
op_assign
id|p1
suffix:semicolon
id|p
op_add_assign
id|stride
suffix:semicolon
op_star
id|p
op_assign
id|p2
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Compute the 3 syndrome values.  DATA should point to the first byte&n; * of the column for which the syndromes are desired.  The syndromes&n; * are computed over the first NBLOCKS of rows.  The three bytes will&n; * be placed in S[0], S[1], and S[2].&n; *&n; * S[i] is the value of the &quot;message&quot; polynomial m(x) evaluated at the&n; * i-th root of the generator polynomial g(x).&n; *&n; * As g(x)=(x-r^-1)(x-1)(x-r^1) we evaluate the message polynomial at&n; * x=r^-1 to get S[0], at x=r^0=1 to get S[1], and at x=r to get S[2].&n; * This could be done directly and efficiently via the Horner scheme.&n; * However, it would require multiplication tables for the factors&n; * r^-1 (0xc3) and r (0x02).  The following scheme does not require&n; * any multiplication tables beyond what&squot;s needed for set_parity()&n; * anyway and is slightly faster if there are no errors and slightly&n; * slower if there are errors.  The latter is hopefully the infrequent&n; * case.&n; *&n; * To understand the alternative algorithm, notice that set_parity(m,&n; * k, p) computes parity bytes such that:&n; *&n; *      x^k * p(x) = m(x) (modulo g(x)).&n; *&n; * That is, to evaluate m(r^m), where r^m is a root of g(x), we can&n; * simply evaluate (r^m)^k*p(r^m).  Also, notice that p is 0 if and&n; * only if s is zero.  That is, if all parity bytes are 0, we know&n; * there is no error in the data and consequently there is no need to&n; * compute s(x) at all!  In all other cases, we compute s(x) from p(x)&n; * by evaluating (r^m)^k*p(r^m) for m=-1, m=0, and m=1.  The p(x)&n; * polynomial is evaluated via the Horner scheme.&n; */
DECL|function|compute_syndromes
r_static
r_int
id|compute_syndromes
c_func
(paren
r_int
r_int
op_star
id|data
comma
r_int
id|nblocks
comma
r_int
r_int
op_star
id|s
)paren
(brace
r_int
r_int
id|p
(braket
l_int|3
)braket
suffix:semicolon
id|set_parity
c_func
(paren
id|data
comma
id|nblocks
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
(braket
l_int|0
)braket
op_or
id|p
(braket
l_int|1
)braket
op_or
id|p
(braket
l_int|2
)braket
)paren
(brace
multiline_comment|/* Some of the checked columns do not have a zero&n;&t;&t; * syndrome.  For simplicity, we compute the syndromes&n;&t;&t; * for all columns that we have computed the&n;&t;&t; * remainders for.&n;&t;&t; */
id|s
(braket
l_int|0
)braket
op_assign
id|gfmul_exp_long
c_func
(paren
id|gfadd_long
c_func
(paren
id|p
(braket
l_int|0
)braket
comma
id|gfmul_exp_long
c_func
(paren
id|gfadd_long
c_func
(paren
id|p
(braket
l_int|1
)braket
comma
id|gfmul_exp_long
c_func
(paren
id|p
(braket
l_int|2
)braket
comma
op_minus
l_int|1
)paren
)paren
comma
op_minus
l_int|1
)paren
)paren
comma
op_minus
id|nblocks
)paren
suffix:semicolon
id|s
(braket
l_int|1
)braket
op_assign
id|gfadd_long
c_func
(paren
id|gfadd_long
c_func
(paren
id|p
(braket
l_int|2
)braket
comma
id|p
(braket
l_int|1
)braket
)paren
comma
id|p
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|s
(braket
l_int|2
)braket
op_assign
id|gfmul_exp_long
c_func
(paren
id|gfadd_long
c_func
(paren
id|p
(braket
l_int|0
)braket
comma
id|gfmul_exp_long
c_func
(paren
id|gfadd_long
c_func
(paren
id|p
(braket
l_int|1
)braket
comma
id|gfmul_exp_long
c_func
(paren
id|p
(braket
l_int|2
)braket
comma
l_int|1
)paren
)paren
comma
l_int|1
)paren
)paren
comma
id|nblocks
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Correct the block in the column pointed to by DATA.  There are NBAD&n; * CRC errors and their indices are in BAD_LOC[0], up to&n; * BAD_LOC[NBAD-1].  If NBAD&gt;1, Ainv holds the inverse of the matrix&n; * of the linear system that needs to be solved to determine the error&n; * magnitudes.  S[0], S[1], and S[2] are the syndrome values.  If row&n; * j gets corrected, then bit j will be set in CORRECTION_MAP.&n; */
DECL|function|correct_block
r_static
r_inline
r_int
id|correct_block
c_func
(paren
id|__u8
op_star
id|data
comma
r_int
id|nblocks
comma
r_int
id|nbad
comma
r_int
op_star
id|bad_loc
comma
id|Matrix
id|Ainv
comma
id|__u8
op_star
id|s
comma
id|SectorMap
op_star
id|correction_map
)paren
(brace
r_int
id|ncorrected
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
id|__u8
id|t1
comma
id|t2
suffix:semicolon
id|__u8
id|c0
comma
id|c1
comma
id|c2
suffix:semicolon
multiline_comment|/* check bytes */
id|__u8
id|error_mag
(braket
l_int|3
)braket
comma
id|log_error_mag
suffix:semicolon
id|__u8
op_star
id|dp
comma
id|l
comma
id|e
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|nbad
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* might have a CRC failure: */
r_if
c_cond
(paren
id|s
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* more than one error */
id|TRACE_ABORT
c_func
(paren
op_minus
l_int|1
comma
id|ft_t_err
comma
l_string|&quot;ECC failed (0 CRC errors, &gt;1 CRC failures)&quot;
)paren
suffix:semicolon
)brace
id|t1
op_assign
id|gfdiv
c_func
(paren
id|s
(braket
l_int|1
)braket
comma
id|s
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bad_loc
(braket
id|nbad
op_increment
)braket
op_assign
id|gflog
(braket
id|t1
)braket
)paren
op_ge
id|nblocks
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;ECC failed (0 CRC errors, &gt;1 CRC failures)&quot;
)paren
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
op_minus
l_int|1
comma
id|ft_t_err
comma
l_string|&quot;attempt to correct data at %d&quot;
comma
id|bad_loc
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
id|error_mag
(braket
l_int|0
)braket
op_assign
id|s
(braket
l_int|1
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|t1
op_assign
id|gfadd
c_func
(paren
id|gfmul_exp
c_func
(paren
id|s
(braket
l_int|1
)braket
comma
id|bad_loc
(braket
l_int|0
)braket
)paren
comma
id|s
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|t2
op_assign
id|gfadd
c_func
(paren
id|gfmul_exp
c_func
(paren
id|s
(braket
l_int|0
)braket
comma
id|bad_loc
(braket
l_int|0
)braket
)paren
comma
id|s
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t1
op_eq
l_int|0
op_logical_and
id|t2
op_eq
l_int|0
)paren
(brace
multiline_comment|/* one erasure, no error: */
id|Ainv
(braket
l_int|0
)braket
(braket
l_int|0
)braket
op_assign
id|gfpow
(braket
id|bad_loc
(braket
l_int|0
)braket
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|t1
op_eq
l_int|0
op_logical_or
id|t2
op_eq
l_int|0
)paren
(brace
multiline_comment|/* one erasure and more than one error: */
id|TRACE_ABORT
c_func
(paren
op_minus
l_int|1
comma
id|ft_t_err
comma
l_string|&quot;ECC failed (1 erasure, &gt;1 error)&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* one erasure, one error: */
r_if
c_cond
(paren
(paren
id|bad_loc
(braket
id|nbad
op_increment
)braket
op_assign
id|gflog
(braket
id|gfdiv
c_func
(paren
id|t1
comma
id|t2
)paren
)braket
)paren
op_ge
id|nblocks
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;ECC failed &quot;
l_string|&quot;(1 CRC errors, &gt;1 CRC failures)&quot;
)paren
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
op_minus
l_int|1
comma
id|ft_t_err
comma
l_string|&quot;attempt to correct data at %d&quot;
comma
id|bad_loc
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|gfinv2
c_func
(paren
id|bad_loc
(braket
l_int|0
)braket
comma
id|bad_loc
(braket
l_int|1
)braket
comma
id|Ainv
)paren
)paren
(brace
multiline_comment|/* inversion failed---must have more&n;                                 *  than one error &n;&t;&t;&t;&t; */
id|TRACE_EXIT
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* FALL THROUGH TO ERROR MAGNITUDE COMPUTATION:&n;&t;&t; */
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
multiline_comment|/* compute error magnitudes: */
id|gfmat_mul
c_func
(paren
id|nbad
comma
id|Ainv
comma
id|s
comma
id|error_mag
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|TRACE_ABORT
c_func
(paren
op_minus
l_int|1
comma
id|ft_t_err
comma
l_string|&quot;Internal Error: number of CRC errors &gt; 3&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Perform correction by adding ERROR_MAG[i] to the byte at&n;&t; * offset BAD_LOC[i].  Also add the value of the computed&n;&t; * error polynomial to the syndrome values.  If the correction&n;&t; * was successful, the resulting check bytes should be zero&n;&t; * (i.e., the corrected data is a valid code word).&n;&t; */
id|c0
op_assign
id|s
(braket
l_int|0
)braket
suffix:semicolon
id|c1
op_assign
id|s
(braket
l_int|1
)braket
suffix:semicolon
id|c2
op_assign
id|s
(braket
l_int|2
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nbad
suffix:semicolon
op_increment
id|i
)paren
(brace
id|e
op_assign
id|error_mag
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|e
)paren
(brace
multiline_comment|/* correct the byte at offset L by magnitude E: */
id|l
op_assign
id|bad_loc
(braket
id|i
)braket
suffix:semicolon
id|dp
op_assign
op_amp
id|data
(braket
id|l
op_star
id|FT_SECTOR_SIZE
)braket
suffix:semicolon
op_star
id|dp
op_assign
id|gfadd
c_func
(paren
op_star
id|dp
comma
id|e
)paren
suffix:semicolon
op_star
id|correction_map
op_or_assign
l_int|1
op_lshift
id|l
suffix:semicolon
op_increment
id|ncorrected
suffix:semicolon
id|log_error_mag
op_assign
id|gflog
(braket
id|e
)braket
suffix:semicolon
id|c0
op_assign
id|gfadd
c_func
(paren
id|c0
comma
id|gfpow
(braket
id|mod255
c_func
(paren
id|log_error_mag
op_minus
id|l
)paren
)braket
)paren
suffix:semicolon
id|c1
op_assign
id|gfadd
c_func
(paren
id|c1
comma
id|e
)paren
suffix:semicolon
id|c2
op_assign
id|gfadd
c_func
(paren
id|c2
comma
id|gfpow
(braket
id|mod255
c_func
(paren
id|log_error_mag
op_plus
id|l
)paren
)braket
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|c0
op_logical_or
id|c1
op_logical_or
id|c2
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
l_int|1
comma
id|ft_t_err
comma
l_string|&quot;ECC self-check failed, too many errors&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
id|ncorrected
suffix:semicolon
)brace
macro_line|#if defined(ECC_SANITY_CHECK) || defined(ECC_PARANOID)
multiline_comment|/* Perform a sanity check on the computed parity bytes:&n; */
DECL|function|sanity_check
r_static
r_int
id|sanity_check
c_func
(paren
r_int
r_int
op_star
id|data
comma
r_int
id|nblocks
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_int
r_int
id|s
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|compute_syndromes
c_func
(paren
id|data
comma
id|nblocks
comma
id|s
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
l_int|0
comma
id|ft_bug
comma
l_string|&quot;Internal Error: syndrome self-check failed&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* defined(ECC_SANITY_CHECK) || defined(ECC_PARANOID) */
multiline_comment|/* Compute the parity for an entire segment of data.&n; */
DECL|function|ftape_ecc_set_segment_parity
r_int
id|ftape_ecc_set_segment_parity
c_func
(paren
r_struct
id|memory_segment
op_star
id|mseg
)paren
(brace
r_int
id|i
suffix:semicolon
id|__u8
op_star
id|parity_bytes
suffix:semicolon
id|parity_bytes
op_assign
op_amp
id|mseg-&gt;data
(braket
(paren
id|mseg-&gt;blocks
op_minus
l_int|3
)paren
op_star
id|FT_SECTOR_SIZE
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FT_SECTOR_SIZE
suffix:semicolon
id|i
op_add_assign
r_sizeof
(paren
r_int
)paren
)paren
(brace
id|set_parity
c_func
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|mseg-&gt;data
(braket
id|i
)braket
comma
id|mseg-&gt;blocks
op_minus
l_int|3
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|parity_bytes
(braket
id|i
)braket
comma
id|FT_SECTOR_SIZE
op_div
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
macro_line|#ifdef ECC_PARANOID
r_if
c_cond
(paren
op_logical_neg
id|sanity_check
c_func
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|mseg-&gt;data
(braket
id|i
)braket
comma
id|mseg-&gt;blocks
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* ECC_PARANOID */
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Checks and corrects (if possible) the segment MSEG.  Returns one of&n; * ECC_OK, ECC_CORRECTED, and ECC_FAILED.&n; */
DECL|function|ftape_ecc_correct_data
r_int
id|ftape_ecc_correct_data
c_func
(paren
r_struct
id|memory_segment
op_star
id|mseg
)paren
(brace
r_int
id|col
comma
id|i
comma
id|result
suffix:semicolon
r_int
id|ncorrected
op_assign
l_int|0
suffix:semicolon
r_int
id|nerasures
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* # of erasures (CRC errors) */
r_int
id|erasure_loc
(braket
l_int|3
)braket
suffix:semicolon
multiline_comment|/* erasure locations */
r_int
r_int
id|ss
(braket
l_int|3
)braket
suffix:semicolon
id|__u8
id|s
(braket
l_int|3
)braket
suffix:semicolon
id|Matrix
id|Ainv
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|mseg-&gt;corrected
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* find first column that has non-zero syndromes: */
r_for
c_loop
(paren
id|col
op_assign
l_int|0
suffix:semicolon
id|col
OL
id|FT_SECTOR_SIZE
suffix:semicolon
id|col
op_add_assign
r_sizeof
(paren
r_int
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|compute_syndromes
c_func
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|mseg-&gt;data
(braket
id|col
)braket
comma
id|mseg-&gt;blocks
comma
id|ss
)paren
)paren
(brace
multiline_comment|/* something is wrong---have to fix things */
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|col
op_ge
id|FT_SECTOR_SIZE
)paren
(brace
multiline_comment|/* all syndromes are ok, therefore nothing to correct */
id|TRACE_EXIT
id|ECC_OK
suffix:semicolon
)brace
multiline_comment|/* count the number of CRC errors if there were any: */
r_if
c_cond
(paren
id|mseg-&gt;read_bad
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mseg-&gt;blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|BAD_CHECK
c_func
(paren
id|mseg-&gt;read_bad
comma
id|i
)paren
)paren
(brace
r_if
c_cond
(paren
id|nerasures
op_ge
l_int|3
)paren
(brace
multiline_comment|/* this is too much for ECC */
id|TRACE_ABORT
c_func
(paren
id|ECC_FAILED
comma
id|ft_t_err
comma
l_string|&quot;ECC failed (&gt;3 CRC errors)&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* if */
id|erasure_loc
(braket
id|nerasures
op_increment
)braket
op_assign
id|i
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * If there are at least 2 CRC errors, determine inverse of matrix&n;&t; * of linear system to be solved:&n;&t; */
r_switch
c_cond
(paren
id|nerasures
)paren
(brace
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|gfinv2
c_func
(paren
id|erasure_loc
(braket
l_int|0
)braket
comma
id|erasure_loc
(braket
l_int|1
)braket
comma
id|Ainv
)paren
)paren
(brace
id|TRACE_EXIT
id|ECC_FAILED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|gfinv3
c_func
(paren
id|erasure_loc
(braket
l_int|0
)braket
comma
id|erasure_loc
(braket
l_int|1
)braket
comma
id|erasure_loc
(braket
l_int|2
)braket
comma
id|Ainv
)paren
)paren
(brace
id|TRACE_EXIT
id|ECC_FAILED
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* this is not an error condition... */
r_break
suffix:semicolon
)brace
r_do
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
r_int
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|s
(braket
l_int|0
)braket
op_assign
id|ss
(braket
l_int|0
)braket
suffix:semicolon
id|s
(braket
l_int|1
)braket
op_assign
id|ss
(braket
l_int|1
)braket
suffix:semicolon
id|s
(braket
l_int|2
)braket
op_assign
id|ss
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|s
(braket
l_int|0
)braket
op_or
id|s
(braket
l_int|1
)braket
op_or
id|s
(braket
l_int|2
)braket
)paren
(brace
macro_line|#ifdef BIG_ENDIAN
id|result
op_assign
id|correct_block
c_func
(paren
op_amp
id|mseg-&gt;data
(braket
id|col
op_plus
r_sizeof
(paren
r_int
)paren
op_minus
l_int|1
op_minus
id|i
)braket
comma
id|mseg-&gt;blocks
comma
id|nerasures
comma
id|erasure_loc
comma
id|Ainv
comma
id|s
comma
op_amp
id|mseg-&gt;corrected
)paren
suffix:semicolon
macro_line|#else
id|result
op_assign
id|correct_block
c_func
(paren
op_amp
id|mseg-&gt;data
(braket
id|col
op_plus
id|i
)braket
comma
id|mseg-&gt;blocks
comma
id|nerasures
comma
id|erasure_loc
comma
id|Ainv
comma
id|s
comma
op_amp
id|mseg-&gt;corrected
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE_EXIT
id|ECC_FAILED
suffix:semicolon
)brace
id|ncorrected
op_add_assign
id|result
suffix:semicolon
)brace
id|ss
(braket
l_int|0
)braket
op_rshift_assign
l_int|8
suffix:semicolon
id|ss
(braket
l_int|1
)braket
op_rshift_assign
l_int|8
suffix:semicolon
id|ss
(braket
l_int|2
)braket
op_rshift_assign
l_int|8
suffix:semicolon
)brace
macro_line|#ifdef ECC_SANITY_CHECK
r_if
c_cond
(paren
op_logical_neg
id|sanity_check
c_func
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|mseg-&gt;data
(braket
id|col
)braket
comma
id|mseg-&gt;blocks
)paren
)paren
(brace
id|TRACE_EXIT
id|ECC_FAILED
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* ECC_SANITY_CHECK */
multiline_comment|/* find next column with non-zero syndromes: */
r_while
c_loop
(paren
(paren
id|col
op_add_assign
r_sizeof
(paren
r_int
)paren
)paren
OL
id|FT_SECTOR_SIZE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|compute_syndromes
c_func
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
id|mseg-&gt;data
(braket
id|col
)braket
comma
id|mseg-&gt;blocks
comma
id|ss
)paren
)paren
(brace
multiline_comment|/* something is wrong---have to fix things */
r_break
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|col
OL
id|FT_SECTOR_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ncorrected
op_logical_and
id|nerasures
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;block contained error not caught by CRC&quot;
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
(paren
id|ncorrected
OG
l_int|0
)paren
ques
c_cond
id|ft_t_noise
suffix:colon
id|ft_t_any
comma
l_string|&quot;number of corrections: %d&quot;
comma
id|ncorrected
)paren
suffix:semicolon
id|TRACE_EXIT
id|ncorrected
ques
c_cond
id|ECC_CORRECTED
suffix:colon
id|ECC_OK
suffix:semicolon
)brace
eof
