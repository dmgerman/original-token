multiline_comment|/*&n; *      Copyright (C) 1993-1995 Bas Laarhoven,&n; *                (C) 1996-1997 Claus-Justus Heine.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/lowlevel/ftape-write.c,v $&n; * $Revision: 1.3.4.1 $&n; * $Date: 1997/11/14 18:07:04 $&n; *&n; *      This file contains the writing code&n; *      for the QIC-117 floppy-tape driver for Linux.&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;linux/qic117.h&gt;
macro_line|#include &quot;../lowlevel/ftape-tracing.h&quot;
macro_line|#include &quot;../lowlevel/ftape-write.h&quot;
macro_line|#include &quot;../lowlevel/ftape-read.h&quot;
macro_line|#include &quot;../lowlevel/ftape-io.h&quot;
macro_line|#include &quot;../lowlevel/ftape-ctl.h&quot;
macro_line|#include &quot;../lowlevel/ftape-rw.h&quot;
macro_line|#include &quot;../lowlevel/ftape-ecc.h&quot;
macro_line|#include &quot;../lowlevel/ftape-bsm.h&quot;
macro_line|#include &quot;../lowlevel/fdc-isr.h&quot;
multiline_comment|/*      Global vars.&n; */
multiline_comment|/*      Local vars.&n; */
DECL|variable|last_write_failed
r_static
r_int
id|last_write_failed
suffix:semicolon
DECL|function|ftape_zap_write_buffers
r_void
id|ftape_zap_write_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ft_nr_buffers
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ft_buffer
(braket
id|i
)braket
op_member_access_from_pointer
id|status
op_assign
id|done
suffix:semicolon
)brace
id|ftape_reset_buffer
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|copy_and_gen_ecc
r_static
r_int
id|copy_and_gen_ecc
c_func
(paren
r_void
op_star
id|destination
comma
r_const
r_void
op_star
id|source
comma
r_const
id|SectorMap
id|bad_sector_map
)paren
(brace
r_int
id|result
suffix:semicolon
r_struct
id|memory_segment
id|mseg
suffix:semicolon
r_int
id|bads
op_assign
id|count_ones
c_func
(paren
id|bad_sector_map
)paren
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bads
OG
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;bad sectors in map: %d&quot;
comma
id|bads
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bads
op_plus
l_int|3
op_ge
id|FT_SECTORS_PER_SEGMENT
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;empty segment&quot;
)paren
suffix:semicolon
id|mseg.blocks
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* skip entire segment */
id|result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* nothing written */
)brace
r_else
(brace
id|mseg.blocks
op_assign
id|FT_SECTORS_PER_SEGMENT
op_minus
id|bads
suffix:semicolon
id|mseg.data
op_assign
id|destination
suffix:semicolon
id|memcpy
c_func
(paren
id|mseg.data
comma
id|source
comma
(paren
id|mseg.blocks
op_minus
l_int|3
)paren
op_star
id|FT_SECTOR_SIZE
)paren
suffix:semicolon
id|result
op_assign
id|ftape_ecc_set_segment_parity
c_func
(paren
op_amp
id|mseg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;ecc_set_segment_parity failed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
(paren
id|mseg.blocks
op_minus
l_int|3
)paren
op_star
id|FT_SECTOR_SIZE
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|ftape_start_writing
r_int
id|ftape_start_writing
c_func
(paren
r_const
id|ft_write_mode_t
id|mode
)paren
(brace
id|buffer_struct
op_star
id|head
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
suffix:semicolon
r_int
id|segment_id
op_assign
id|head-&gt;segment_id
suffix:semicolon
r_int
id|result
suffix:semicolon
id|buffer_state_enum
id|wanted_state
op_assign
(paren
id|mode
op_eq
id|FT_WR_DELETE
ques
c_cond
id|deleting
suffix:colon
id|writing
)paren
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ft_driver_state
op_ne
id|wanted_state
)paren
op_logical_or
id|head-&gt;status
op_ne
id|waiting
)paren
(brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
id|ftape_setup_new_segment
c_func
(paren
id|head
comma
id|segment_id
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_eq
id|FT_WR_SINGLE
)paren
(brace
multiline_comment|/* stop tape instead of pause */
id|head-&gt;next_segment
op_assign
l_int|0
suffix:semicolon
)brace
id|ftape_calc_next_cluster
c_func
(paren
id|head
)paren
suffix:semicolon
multiline_comment|/* prepare */
id|head-&gt;status
op_assign
id|ft_driver_state
suffix:semicolon
multiline_comment|/* either writing or deleting */
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|idle
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;starting runner for segment %d&quot;
comma
id|segment_id
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_start_tape
c_func
(paren
id|segment_id
comma
id|head-&gt;sector_offset
)paren
comma
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;runner not idle, not starting tape&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* go */
id|result
op_assign
id|fdc_setup_read_write
c_func
(paren
id|head
comma
(paren
id|mode
op_eq
id|FT_WR_DELETE
ques
c_cond
id|FDC_WRITE_DELETED
suffix:colon
id|FDC_WRITE
)paren
)paren
suffix:semicolon
id|ftape_set_state
c_func
(paren
id|wanted_state
)paren
suffix:semicolon
multiline_comment|/* should not be necessary */
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*  Wait until all data is actually written to tape.&n; *  &n; *  There is a problem: when the tape runs into logical EOT, then this&n; *  failes. We need to restart the runner in this case.&n; */
DECL|function|ftape_loop_until_writes_done
r_int
id|ftape_loop_until_writes_done
c_func
(paren
r_void
)paren
(brace
id|buffer_struct
op_star
id|head
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ft_driver_state
op_eq
id|writing
op_logical_or
id|ft_driver_state
op_eq
id|deleting
)paren
op_logical_and
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
op_member_access_from_pointer
id|status
op_ne
id|done
)paren
(brace
multiline_comment|/* set the runner status to idle if at lEOT */
id|TRACE_CATCH
c_func
(paren
id|ftape_handle_logical_eot
c_func
(paren
)paren
comma
id|last_write_failed
op_assign
l_int|1
)paren
suffix:semicolon
multiline_comment|/* restart the tape if necessary */
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|idle
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;runner is idle, restarting&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_driver_state
op_eq
id|deleting
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_start_writing
c_func
(paren
id|FT_WR_DELETE
)paren
comma
id|last_write_failed
op_assign
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_start_writing
c_func
(paren
id|FT_WR_MULTI
)paren
comma
id|last_write_failed
op_assign
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;tail: %d, head: %d&quot;
comma
id|ftape_buffer_id
c_func
(paren
id|ft_queue_tail
)paren
comma
id|ftape_buffer_id
c_func
(paren
id|ft_queue_head
)paren
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_interrupt_wait
c_func
(paren
l_int|5
op_star
id|FT_SECOND
)paren
comma
id|last_write_failed
op_assign
l_int|1
)paren
suffix:semicolon
id|head
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head-&gt;status
op_eq
id|error
)paren
(brace
multiline_comment|/* Allow escape from loop when signaled !&n;&t;&t;&t; */
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head-&gt;hard_error_map
op_ne
l_int|0
)paren
(brace
multiline_comment|/*  Implement hard write error recovery here&n;&t;&t;&t;&t; */
)brace
multiline_comment|/* retry this one */
id|head-&gt;status
op_assign
id|waiting
suffix:semicolon
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|aborting
)paren
(brace
id|ftape_dumb_stop
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_runner_status
op_ne
id|idle
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;unexpected state: &quot;
l_string|&quot;ft_runner_status != idle&quot;
)paren
suffix:semicolon
)brace
id|ftape_start_writing
c_func
(paren
id|ft_driver_state
op_eq
id|deleting
ques
c_cond
id|FT_WR_MULTI
suffix:colon
id|FT_WR_DELETE
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;looping until writes done&quot;
)paren
suffix:semicolon
)brace
id|ftape_set_state
c_func
(paren
id|idle
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      Write given segment from buffer at address to tape.&n; */
DECL|function|write_segment
r_static
r_int
id|write_segment
c_func
(paren
r_const
r_int
id|segment_id
comma
r_const
r_void
op_star
id|address
comma
r_const
id|ft_write_mode_t
id|write_mode
)paren
(brace
r_int
id|bytes_written
op_assign
l_int|0
suffix:semicolon
id|buffer_struct
op_star
id|tail
suffix:semicolon
id|buffer_state_enum
id|wanted_state
op_assign
(paren
id|write_mode
op_eq
id|FT_WR_DELETE
ques
c_cond
id|deleting
suffix:colon
id|writing
)paren
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;segment_id = %d&quot;
comma
id|segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_driver_state
op_ne
id|wanted_state
)paren
(brace
r_if
c_cond
(paren
id|ft_driver_state
op_eq
id|deleting
op_logical_or
id|wanted_state
op_eq
id|deleting
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_loop_until_writes_done
c_func
(paren
)paren
comma
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;calling ftape_abort_operation&quot;
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_abort_operation
c_func
(paren
)paren
comma
)paren
suffix:semicolon
id|ftape_zap_write_buffers
c_func
(paren
)paren
suffix:semicolon
id|ftape_set_state
c_func
(paren
id|wanted_state
)paren
suffix:semicolon
)brace
multiline_comment|/*    if all buffers full we&squot;ll have to wait...&n;&t; */
id|ftape_wait_segment
c_func
(paren
id|wanted_state
)paren
suffix:semicolon
id|tail
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_tail
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|tail-&gt;status
)paren
(brace
r_case
id|done
suffix:colon
id|ft_history.defects
op_add_assign
id|count_ones
c_func
(paren
id|tail-&gt;hard_error_map
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|waiting
suffix:colon
multiline_comment|/* this could happen with multiple EMPTY_SEGMENTs, but&n;&t;&t; * shouldn&squot;t happen any more as we re-start the runner even&n;&t;&t; * with an empty segment.&n;&t;&t; */
id|bytes_written
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|error
suffix:colon
multiline_comment|/*  setup for a retry&n;&t;&t; */
id|tail-&gt;status
op_assign
id|waiting
suffix:semicolon
id|bytes_written
op_assign
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* force retry */
r_if
c_cond
(paren
id|tail-&gt;hard_error_map
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;warning: %d hard error(s) in written segment&quot;
comma
id|count_ones
c_func
(paren
id|tail-&gt;hard_error_map
)paren
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;hard_error_map = 0x%08lx&quot;
comma
(paren
r_int
)paren
id|tail-&gt;hard_error_map
)paren
suffix:semicolon
multiline_comment|/*  Implement hard write error recovery here&n;&t;&t;&t; */
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;wait for empty segment failed, tail status: %d&quot;
comma
id|tail-&gt;status
)paren
suffix:semicolon
)brace
multiline_comment|/*    should runner stop ?&n;&t; */
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|aborting
)paren
(brace
id|buffer_struct
op_star
id|head
op_assign
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head-&gt;status
op_eq
id|wanted_state
)paren
(brace
id|head-&gt;status
op_assign
id|done
suffix:semicolon
multiline_comment|/* ???? */
)brace
multiline_comment|/*  don&squot;t call abort_operation(), we don&squot;t want to zap&n;&t;&t; *  the dma buffers&n;&t;&t; */
id|TRACE_CATCH
c_func
(paren
id|ftape_dumb_stop
c_func
(paren
)paren
comma
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  If just passed last segment on tape: wait for BOT&n;&t;&t; *  or EOT mark. Sets ft_runner_status to idle if at lEOT&n;&t;&t; *  and successful &n;&t;&t; */
id|TRACE_CATCH
c_func
(paren
id|ftape_handle_logical_eot
c_func
(paren
)paren
comma
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tail-&gt;status
op_eq
id|done
)paren
(brace
multiline_comment|/* now at least one buffer is empty, fill it with our&n;&t;&t; * data.  skip bad sectors and generate ecc.&n;&t;&t; * copy_and_gen_ecc return nr of bytes written, range&n;&t;&t; * 0..29 Kb inclusive!  &n;&t;&t; *&n;&t;&t; * Empty segments are handled inside coyp_and_gen_ecc()&n;&t;&t; */
r_if
c_cond
(paren
id|write_mode
op_ne
id|FT_WR_DELETE
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|bytes_written
op_assign
id|copy_and_gen_ecc
c_func
(paren
id|tail-&gt;address
comma
id|address
comma
id|ftape_get_bad_sector_entry
c_func
(paren
id|segment_id
)paren
)paren
comma
)paren
suffix:semicolon
)brace
id|tail-&gt;segment_id
op_assign
id|segment_id
suffix:semicolon
id|tail-&gt;status
op_assign
id|waiting
suffix:semicolon
id|tail
op_assign
id|ftape_next_buffer
c_func
(paren
id|ft_queue_tail
)paren
suffix:semicolon
)brace
multiline_comment|/*  Start tape only if all buffers full or flush mode.&n;&t; *  This will give higher probability of streaming.&n;&t; */
r_if
c_cond
(paren
id|ft_runner_status
op_ne
id|running
op_logical_and
(paren
(paren
id|tail-&gt;status
op_eq
id|waiting
op_logical_and
id|ftape_get_buffer
c_func
(paren
id|ft_queue_head
)paren
op_eq
id|tail
)paren
op_logical_or
id|write_mode
op_ne
id|FT_WR_ASYNC
)paren
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_start_writing
c_func
(paren
id|write_mode
)paren
comma
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
id|bytes_written
suffix:semicolon
)brace
multiline_comment|/*  Write as much as fits from buffer to the given segment on tape&n; *  and handle retries.&n; *  Return the number of bytes written (&gt;= 0), or:&n; *      -EIO          write failed&n; *      -EINTR        interrupted by signal&n; *      -ENOSPC       device full&n; */
DECL|function|ftape_write_segment
r_int
id|ftape_write_segment
c_func
(paren
r_const
r_int
id|segment_id
comma
r_const
r_void
op_star
id|buffer
comma
r_const
id|ft_write_mode_t
id|flush
)paren
(brace
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|ft_history.used
op_or_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|segment_id
op_ge
id|ft_tracks_per_tape
op_star
id|ft_segments_per_track
)paren
(brace
multiline_comment|/* tape full */
id|TRACE_ABORT
c_func
(paren
op_minus
id|ENOSPC
comma
id|ft_t_err
comma
l_string|&quot;invalid segment id: %d (max %d)&quot;
comma
id|segment_id
comma
id|ft_tracks_per_tape
op_star
id|ft_segments_per_track
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|result
op_assign
id|write_segment
c_func
(paren
id|segment_id
comma
id|buffer
comma
id|flush
)paren
)paren
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
multiline_comment|/* empty segment */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;empty segment, nothing written&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EAGAIN
)paren
(brace
r_if
c_cond
(paren
op_increment
id|retry
OG
l_int|100
)paren
(brace
multiline_comment|/* give up */
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;write failed, &gt;100 retries in segment&quot;
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;write error, retry %d (%d)&quot;
comma
id|retry
comma
id|ftape_get_buffer
c_func
(paren
id|ft_queue_tail
)paren
op_member_access_from_pointer
id|segment_id
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE_ABORT
c_func
(paren
id|result
comma
id|ft_t_err
comma
l_string|&quot;write_segment failed, error: %d&quot;
comma
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/* Allow escape from loop when signaled !&n;&t;&t; */
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
)brace
)brace
eof
