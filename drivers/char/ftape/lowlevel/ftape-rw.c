multiline_comment|/*&n; *      Copyright (C) 1993-1996 Bas Laarhoven,&n; *                (C) 1996-1997 Claus-Justus Heine.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/lowlevel/ftape-rw.c,v $&n; * $Revision: 1.7 $&n; * $Date: 1997/10/28 14:26:49 $&n; *&n; *      This file contains some common code for the segment read and&n; *      segment write routines for the QIC-117 floppy-tape driver for&n; *      Linux.&n; */
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;linux/qic117.h&gt;
macro_line|#include &quot;../lowlevel/ftape-tracing.h&quot;
macro_line|#include &quot;../lowlevel/ftape-rw.h&quot;
macro_line|#include &quot;../lowlevel/fdc-io.h&quot;
macro_line|#include &quot;../lowlevel/ftape-init.h&quot;
macro_line|#include &quot;../lowlevel/ftape-io.h&quot;
macro_line|#include &quot;../lowlevel/ftape-ctl.h&quot;
macro_line|#include &quot;../lowlevel/ftape-read.h&quot;
macro_line|#include &quot;../lowlevel/ftape-ecc.h&quot;
macro_line|#include &quot;../lowlevel/ftape-bsm.h&quot;
multiline_comment|/*      Global vars.&n; */
DECL|variable|ft_nr_buffers
r_int
id|ft_nr_buffers
suffix:semicolon
DECL|variable|ft_buffer
id|buffer_struct
op_star
id|ft_buffer
(braket
id|FT_MAX_NR_BUFFERS
)braket
suffix:semicolon
DECL|variable|ft_head
r_static
r_volatile
r_int
id|ft_head
suffix:semicolon
DECL|variable|ft_tail
r_static
r_volatile
r_int
id|ft_tail
suffix:semicolon
multiline_comment|/* not volatile but need same type as head */
DECL|variable|fdc_setup_error
r_int
id|fdc_setup_error
suffix:semicolon
DECL|variable|ft_location
id|location_record
id|ft_location
op_assign
(brace
op_minus
l_int|1
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|ftape_tape_running
r_volatile
r_int
id|ftape_tape_running
suffix:semicolon
multiline_comment|/*      Local vars.&n; */
DECL|variable|overrun_count_offset
r_static
r_int
id|overrun_count_offset
suffix:semicolon
DECL|variable|inhibit_correction
r_static
r_int
id|inhibit_correction
suffix:semicolon
multiline_comment|/*  maxmimal allowed overshoot when fast seeking&n; */
DECL|macro|OVERSHOOT_LIMIT
mdefine_line|#define OVERSHOOT_LIMIT 10
multiline_comment|/*      Increment cyclic buffer nr.&n; */
DECL|function|ftape_next_buffer
id|buffer_struct
op_star
id|ftape_next_buffer
c_func
(paren
id|ft_buffer_queue_t
id|pos
)paren
(brace
r_switch
c_cond
(paren
id|pos
)paren
(brace
r_case
id|ft_queue_head
suffix:colon
r_if
c_cond
(paren
op_increment
id|ft_head
op_ge
id|ft_nr_buffers
)paren
(brace
id|ft_head
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ft_buffer
(braket
id|ft_head
)braket
suffix:semicolon
r_case
id|ft_queue_tail
suffix:colon
r_if
c_cond
(paren
op_increment
id|ft_tail
op_ge
id|ft_nr_buffers
)paren
(brace
id|ft_tail
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|ft_buffer
(braket
id|ft_tail
)braket
suffix:semicolon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|ftape_buffer_id
r_int
id|ftape_buffer_id
c_func
(paren
id|ft_buffer_queue_t
id|pos
)paren
(brace
r_switch
c_cond
(paren
id|pos
)paren
(brace
r_case
id|ft_queue_head
suffix:colon
r_return
id|ft_head
suffix:semicolon
r_case
id|ft_queue_tail
suffix:colon
r_return
id|ft_tail
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|ftape_get_buffer
id|buffer_struct
op_star
id|ftape_get_buffer
c_func
(paren
id|ft_buffer_queue_t
id|pos
)paren
(brace
r_switch
c_cond
(paren
id|pos
)paren
(brace
r_case
id|ft_queue_head
suffix:colon
r_return
id|ft_buffer
(braket
id|ft_head
)braket
suffix:semicolon
r_case
id|ft_queue_tail
suffix:colon
r_return
id|ft_buffer
(braket
id|ft_tail
)braket
suffix:semicolon
r_default
suffix:colon
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|ftape_reset_buffer
r_void
id|ftape_reset_buffer
c_func
(paren
r_void
)paren
(brace
id|ft_head
op_assign
id|ft_tail
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_set_state
id|buffer_state_enum
id|ftape_set_state
c_func
(paren
id|buffer_state_enum
id|new_state
)paren
(brace
id|buffer_state_enum
id|old_state
op_assign
id|ft_driver_state
suffix:semicolon
id|ft_driver_state
op_assign
id|new_state
suffix:semicolon
r_return
id|old_state
suffix:semicolon
)brace
multiline_comment|/*      Calculate Floppy Disk Controller and DMA parameters for a segment.&n; *      head:   selects buffer struct in array.&n; *      offset: number of physical sectors to skip (including bad ones).&n; *      count:  number of physical sectors to handle (including bad ones).&n; */
DECL|function|setup_segment
r_static
r_int
id|setup_segment
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
r_int
id|segment_id
comma
r_int
r_int
id|sector_offset
comma
r_int
r_int
id|sector_count
comma
r_int
id|retry
)paren
(brace
id|SectorMap
id|offset_mask
suffix:semicolon
id|SectorMap
id|mask
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|buff-&gt;segment_id
op_assign
id|segment_id
suffix:semicolon
id|buff-&gt;sector_offset
op_assign
id|sector_offset
suffix:semicolon
id|buff-&gt;remaining
op_assign
id|sector_count
suffix:semicolon
id|buff-&gt;head
op_assign
id|segment_id
op_div
id|ftape_segments_per_head
suffix:semicolon
id|buff-&gt;cyl
op_assign
(paren
id|segment_id
op_mod
id|ftape_segments_per_head
)paren
op_div
id|ftape_segments_per_cylinder
suffix:semicolon
id|buff-&gt;sect
op_assign
(paren
id|segment_id
op_mod
id|ftape_segments_per_cylinder
)paren
op_star
id|FT_SECTORS_PER_SEGMENT
op_plus
l_int|1
suffix:semicolon
id|buff-&gt;deleted
op_assign
l_int|0
suffix:semicolon
id|offset_mask
op_assign
(paren
l_int|1
op_lshift
id|buff-&gt;sector_offset
)paren
op_minus
l_int|1
suffix:semicolon
id|mask
op_assign
id|ftape_get_bad_sector_entry
c_func
(paren
id|segment_id
)paren
op_amp
id|offset_mask
suffix:semicolon
r_while
c_loop
(paren
id|mask
)paren
(brace
r_if
c_cond
(paren
id|mask
op_amp
l_int|1
)paren
(brace
id|offset_mask
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* don&squot;t count bad sector */
)brace
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|buff-&gt;data_offset
op_assign
id|count_ones
c_func
(paren
id|offset_mask
)paren
suffix:semicolon
multiline_comment|/* good sectors to skip */
id|buff-&gt;ptr
op_assign
id|buff-&gt;address
op_plus
id|buff-&gt;data_offset
op_star
id|FT_SECTOR_SIZE
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;data offset = %d sectors&quot;
comma
id|buff-&gt;data_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retry
)paren
(brace
id|buff-&gt;soft_error_map
op_and_assign
id|offset_mask
suffix:semicolon
multiline_comment|/* keep skipped part */
)brace
r_else
(brace
id|buff-&gt;hard_error_map
op_assign
id|buff-&gt;soft_error_map
op_assign
l_int|0
suffix:semicolon
)brace
id|buff-&gt;bad_sector_map
op_assign
id|ftape_get_bad_sector_entry
c_func
(paren
id|buff-&gt;segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff-&gt;bad_sector_map
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;segment: %d, bad sector map: %08lx&quot;
comma
id|buff-&gt;segment_id
comma
(paren
r_int
)paren
id|buff-&gt;bad_sector_map
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;segment: %d&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff-&gt;sector_offset
OG
l_int|0
)paren
(brace
id|buff-&gt;bad_sector_map
op_rshift_assign
id|buff-&gt;sector_offset
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buff-&gt;sector_offset
op_ne
l_int|0
op_logical_or
id|buff-&gt;remaining
op_ne
id|FT_SECTORS_PER_SEGMENT
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;sector offset = %d, count = %d&quot;
comma
id|buff-&gt;sector_offset
comma
id|buff-&gt;remaining
)paren
suffix:semicolon
)brace
multiline_comment|/*    Segments with 3 or less sectors are not written with valid&n;&t; *    data because there is no space left for the ecc.  The&n;&t; *    data written is whatever happens to be in the buffer.&n;&t; *    Reading such a segment will return a zero byte-count.&n;&t; *    To allow us to read/write segments with all bad sectors&n;&t; *    we fake one readable sector in the segment. This&n;&t; *    prevents having to handle these segments in a very&n;&t; *    special way.  It is not important if the reading of this&n;&t; *    bad sector fails or not (the data is ignored). It is&n;&t; *    only read to keep the driver running.&n;&t; *&n;&t; *    The QIC-40/80 spec. has no information on how to handle&n;&t; *    this case, so this is my interpretation.  &n;&t; */
r_if
c_cond
(paren
id|buff-&gt;bad_sector_map
op_eq
id|EMPTY_SEGMENT
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;empty segment %d, fake first sector good&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff-&gt;ptr
op_ne
id|buff-&gt;address
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;This is a bug: %p/%p&quot;
comma
id|buff-&gt;ptr
comma
id|buff-&gt;address
)paren
suffix:semicolon
)brace
id|buff-&gt;bad_sector_map
op_assign
id|FAKE_SEGMENT
suffix:semicolon
)brace
id|fdc_setup_error
op_assign
l_int|0
suffix:semicolon
id|buff-&gt;next_segment
op_assign
id|segment_id
op_plus
l_int|1
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      Calculate Floppy Disk Controller and DMA parameters for a new segment.&n; */
DECL|function|ftape_setup_new_segment
r_int
id|ftape_setup_new_segment
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
r_int
id|segment_id
comma
r_int
id|skip
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|old_segment_id
op_assign
op_minus
l_int|1
suffix:semicolon
r_static
id|buffer_state_enum
id|old_ft_driver_state
op_assign
id|idle
suffix:semicolon
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
r_int
id|offset
op_assign
l_int|0
suffix:semicolon
r_int
id|count
op_assign
id|FT_SECTORS_PER_SEGMENT
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;%s segment %d (old = %d)&quot;
comma
(paren
id|ft_driver_state
op_eq
id|reading
op_logical_or
id|ft_driver_state
op_eq
id|verifying
)paren
ques
c_cond
l_string|&quot;reading&quot;
suffix:colon
l_string|&quot;writing&quot;
comma
id|segment_id
comma
id|old_segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_driver_state
op_ne
id|old_ft_driver_state
)paren
(brace
multiline_comment|/* when verifying */
id|old_segment_id
op_assign
op_minus
l_int|1
suffix:semicolon
id|old_ft_driver_state
op_assign
id|ft_driver_state
suffix:semicolon
)brace
r_if
c_cond
(paren
id|segment_id
op_eq
id|old_segment_id
)paren
(brace
op_increment
id|buff-&gt;retry
suffix:semicolon
op_increment
id|ft_history.retries
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;setting up for retry nr %d&quot;
comma
id|buff-&gt;retry
)paren
suffix:semicolon
id|retry
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|skip
op_logical_and
id|buff-&gt;skip
OG
l_int|0
)paren
(brace
multiline_comment|/* allow skip on retry */
id|offset
op_assign
id|buff-&gt;skip
suffix:semicolon
id|count
op_sub_assign
id|offset
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;skipping %d sectors&quot;
comma
id|offset
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|buff-&gt;retry
op_assign
l_int|0
suffix:semicolon
id|buff-&gt;skip
op_assign
l_int|0
suffix:semicolon
id|old_segment_id
op_assign
id|segment_id
suffix:semicolon
)brace
id|result
op_assign
id|setup_segment
c_func
(paren
id|buff
comma
id|segment_id
comma
id|offset
comma
id|count
comma
id|retry
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*      Determine size of next cluster of good sectors.&n; */
DECL|function|ftape_calc_next_cluster
r_int
id|ftape_calc_next_cluster
c_func
(paren
id|buffer_struct
op_star
id|buff
)paren
(brace
multiline_comment|/* Skip bad sectors.&n;&t; */
r_while
c_loop
(paren
id|buff-&gt;remaining
OG
l_int|0
op_logical_and
(paren
id|buff-&gt;bad_sector_map
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|buff-&gt;bad_sector_map
op_rshift_assign
l_int|1
suffix:semicolon
op_increment
id|buff-&gt;sector_offset
suffix:semicolon
op_decrement
id|buff-&gt;remaining
suffix:semicolon
)brace
multiline_comment|/* Find next cluster of good sectors&n;&t; */
r_if
c_cond
(paren
id|buff-&gt;bad_sector_map
op_eq
l_int|0
)paren
(brace
multiline_comment|/* speed up */
id|buff-&gt;sector_count
op_assign
id|buff-&gt;remaining
suffix:semicolon
)brace
r_else
(brace
id|SectorMap
id|map
op_assign
id|buff-&gt;bad_sector_map
suffix:semicolon
id|buff-&gt;sector_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|buff-&gt;sector_count
OL
id|buff-&gt;remaining
op_logical_and
(paren
id|map
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
op_increment
id|buff-&gt;sector_count
suffix:semicolon
id|map
op_rshift_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|buff-&gt;sector_count
suffix:semicolon
)brace
multiline_comment|/*  if just passed the last segment on a track, wait for BOT&n; *  or EOT mark.&n; */
DECL|function|ftape_handle_logical_eot
r_int
id|ftape_handle_logical_eot
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|logical_eot
)paren
(brace
r_int
id|status
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;tape at logical EOT&quot;
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_ready_wait
c_func
(paren
id|ftape_timeout.seek
comma
op_amp
id|status
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
(paren
id|QIC_STATUS_AT_BOT
op_or
id|QIC_STATUS_AT_EOT
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;eot/bot not reached&quot;
)paren
suffix:semicolon
)brace
id|ft_runner_status
op_assign
id|end_of_tape
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|end_of_tape
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;runner stopped because of logical EOT&quot;
)paren
suffix:semicolon
id|ft_runner_status
op_assign
id|idle
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|check_bot_eot
r_static
r_int
id|check_bot_eot
c_func
(paren
r_int
id|status
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|QIC_STATUS_AT_BOT
op_or
id|QIC_STATUS_AT_EOT
)paren
)paren
(brace
id|ft_location.bot
op_assign
(paren
(paren
id|ft_location.track
op_amp
l_int|1
)paren
op_eq
l_int|0
ques
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_AT_BOT
)paren
op_ne
l_int|0
suffix:colon
(paren
id|status
op_amp
id|QIC_STATUS_AT_EOT
)paren
op_ne
l_int|0
)paren
suffix:semicolon
id|ft_location.eot
op_assign
op_logical_neg
id|ft_location.bot
suffix:semicolon
id|ft_location.segment
op_assign
(paren
id|ft_location.track
op_plus
(paren
id|ft_location.bot
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
)paren
op_star
id|ft_segments_per_track
op_minus
l_int|1
suffix:semicolon
id|ft_location.sector
op_assign
op_minus
l_int|1
suffix:semicolon
id|ft_location.known
op_assign
l_int|1
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;tape at logical %s&quot;
comma
id|ft_location.bot
ques
c_cond
l_string|&quot;bot&quot;
suffix:colon
l_string|&quot;eot&quot;
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;segment = %d&quot;
comma
id|ft_location.segment
)paren
suffix:semicolon
)brace
r_else
(brace
id|ft_location.known
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
id|ft_location.known
suffix:semicolon
)brace
multiline_comment|/*      Read Id of first sector passing tape head.&n; */
DECL|function|ftape_read_id
r_int
id|ftape_read_id
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
id|__u8
id|out
(braket
l_int|2
)braket
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/* Assume tape is running on entry, be able to handle&n;&t; * situation where it stopped or is stopping.&n;&t; */
id|ft_location.known
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default is location not known */
id|out
(braket
l_int|0
)braket
op_assign
id|FDC_READID
suffix:semicolon
id|out
(braket
l_int|1
)braket
op_assign
id|ft_drive_sel
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_command
c_func
(paren
id|out
comma
l_int|2
)paren
comma
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|fdc_interrupt_wait
c_func
(paren
l_int|20
op_star
id|FT_SECOND
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|fdc_sect
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ftape_report_drive_status
c_func
(paren
op_amp
id|status
)paren
op_ge
l_int|0
op_logical_and
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
)paren
(brace
id|ftape_tape_running
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;tape has stopped&quot;
)paren
suffix:semicolon
id|check_bot_eot
c_func
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|ft_location.known
op_assign
l_int|1
suffix:semicolon
id|ft_location.segment
op_assign
(paren
id|ftape_segments_per_head
op_star
id|fdc_head
op_plus
id|ftape_segments_per_cylinder
op_star
id|fdc_cyl
op_plus
(paren
id|fdc_sect
op_minus
l_int|1
)paren
op_div
id|FT_SECTORS_PER_SEGMENT
)paren
suffix:semicolon
id|ft_location.sector
op_assign
(paren
(paren
id|fdc_sect
op_minus
l_int|1
)paren
op_mod
id|FT_SECTORS_PER_SEGMENT
)paren
suffix:semicolon
id|ft_location.eot
op_assign
id|ft_location.bot
op_assign
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
op_minus
id|ETIME
suffix:colon
multiline_comment|/*  Didn&squot;t find id on tape, must be near end: Wait&n;&t;&t; *  until stopped.&n;&t;&t; */
r_if
c_cond
(paren
id|ftape_ready_wait
c_func
(paren
id|FT_FOREVER
comma
op_amp
id|status
)paren
op_ge
l_int|0
)paren
(brace
id|ftape_tape_running
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;tape has stopped&quot;
)paren
suffix:semicolon
id|check_bot_eot
c_func
(paren
id|status
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*  Interrupted or otherwise failing&n;&t;&t; *  fdc_interrupt_wait() &n;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;fdc_interrupt_wait failed&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ft_location.known
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_flow
comma
l_string|&quot;no id found&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_location.sector
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;passing segment %d/%d&quot;
comma
id|ft_location.segment
comma
id|ft_location.sector
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;passing segment %d/%d&quot;
comma
id|ft_location.segment
comma
id|ft_location.sector
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|logical_forward
r_static
r_int
id|logical_forward
c_func
(paren
r_void
)paren
(brace
id|ftape_tape_running
op_assign
l_int|1
suffix:semicolon
r_return
id|ftape_command
c_func
(paren
id|QIC_LOGICAL_FORWARD
)paren
suffix:semicolon
)brace
DECL|function|ftape_stop_tape
r_int
id|ftape_stop_tape
c_func
(paren
r_int
op_star
id|pstatus
)paren
(brace
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_do
(brace
id|result
op_assign
id|ftape_command_wait
c_func
(paren
id|QIC_STOP_TAPE
comma
id|ftape_timeout.stop
comma
id|pstatus
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|pstatus
op_amp
id|QIC_STATUS_READY
)paren
op_eq
l_int|0
)paren
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|ftape_tape_running
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|result
OL
l_int|0
op_logical_and
op_increment
id|retry
op_le
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;failed ! (fatal)&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|ftape_dumb_stop
r_int
id|ftape_dumb_stop
c_func
(paren
r_void
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|status
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
multiline_comment|/*  Abort current fdc operation if it&squot;s busy (probably read&n;&t; *  or write operation pending) with a reset.&n;&t; */
r_if
c_cond
(paren
id|fdc_ready_wait
c_func
(paren
l_int|100
multiline_comment|/* usec */
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;aborting fdc operation&quot;
)paren
suffix:semicolon
id|fdc_reset
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*  Reading id&squot;s after the last segment on a track may fail&n;&t; *  but eventually the drive will become ready (logical eot).&n;&t; */
id|result
op_assign
id|ftape_report_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
id|ft_location.known
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_and
id|status
op_amp
id|QIC_STATUS_READY
)paren
(brace
multiline_comment|/* Tape is not running any more.&n;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;tape already halted&quot;
)paren
suffix:semicolon
id|check_bot_eot
c_func
(paren
id|status
)paren
suffix:semicolon
id|ftape_tape_running
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ftape_tape_running
)paren
(brace
multiline_comment|/*  Tape is (was) still moving.&n;&t;&t;&t; */
macro_line|#ifdef TESTING
id|ftape_read_id
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|result
op_assign
id|ftape_stop_tape
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  Tape not yet ready but stopped.&n;&t;&t;&t; */
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|ftape_timeout.pause
comma
op_amp
id|status
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|ftape_tape_running
op_logical_and
op_logical_neg
(paren
id|sigtestsetmask
c_func
(paren
op_amp
id|current-&gt;pending.signal
comma
id|_NEVER_BLOCK
)paren
)paren
)paren
suffix:semicolon
macro_line|#ifndef TESTING
id|ft_location.known
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ft_runner_status
op_eq
id|aborting
op_logical_or
id|ft_runner_status
op_eq
id|do_abort
)paren
(brace
id|ft_runner_status
op_assign
id|idle
suffix:semicolon
)brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*      Wait until runner has finished tail buffer.&n; *&n; */
DECL|function|ftape_wait_segment
r_int
id|ftape_wait_segment
c_func
(paren
id|buffer_state_enum
id|state
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ft_buffer
(braket
id|ft_tail
)braket
op_member_access_from_pointer
id|status
op_eq
id|state
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;state: %d&quot;
comma
id|ft_buffer
(braket
id|ft_tail
)braket
op_member_access_from_pointer
id|status
)paren
suffix:semicolon
multiline_comment|/*  First buffer still being worked on, wait up to timeout.&n;&t;&t; *&n;&t;&t; *  Note: we check two times for being killed. 50&n;&t;&t; *  seconds are quite long. Note that&n;&t;&t; *  fdc_interrupt_wait() is not killable by any&n;&t;&t; *  means. ftape_read_segment() wants us to return&n;&t;&t; *  -EINTR in case of a signal.  &n;&t;&t; */
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
id|result
op_assign
id|fdc_interrupt_wait
c_func
(paren
l_int|50
op_star
id|FT_SECOND
)paren
suffix:semicolon
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
id|result
comma
id|ft_t_err
comma
l_string|&quot;fdc_interrupt_wait failed&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdc_setup_error
)paren
(brace
multiline_comment|/* recover... FIXME */
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;setup error&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ft_buffer
(braket
id|ft_tail
)braket
op_member_access_from_pointer
id|status
op_ne
id|error
)paren
(brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|ftape_report_drive_status
c_func
(paren
op_amp
id|status
)paren
comma
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;ftape_report_drive_status: 0x%02x&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
op_logical_and
(paren
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
)paren
(brace
r_int
r_int
id|error
suffix:semicolon
id|qic117_cmd_t
id|command
suffix:semicolon
multiline_comment|/*  Report and clear error state.&n;&t;&t; *  In case the drive can&squot;t operate at the selected&n;&t;&t; *  rate, select the next lower data rate.&n;&t;&t; */
id|ftape_report_error
c_func
(paren
op_amp
id|error
comma
op_amp
id|command
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|31
op_logical_and
id|command
op_eq
id|QIC_LOGICAL_FORWARD
)paren
(brace
multiline_comment|/* drive does not accept this data rate */
r_if
c_cond
(paren
id|ft_data_rate
OG
l_int|250
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;Probable data rate conflict&quot;
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;Lowering data rate to %d Kbps&quot;
comma
id|ft_data_rate
op_div
l_int|2
)paren
suffix:semicolon
id|ftape_half_data_rate
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_buffer
(braket
id|ft_tail
)braket
op_member_access_from_pointer
id|retry
OG
l_int|0
)paren
(brace
multiline_comment|/* give it a chance */
op_decrement
id|ft_buffer
(braket
id|ft_tail
)braket
op_member_access_from_pointer
id|retry
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* no rate is accepted... */
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;We&squot;re dead :(&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;Unknown error&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* g.p. error */
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/* forward */
r_static
r_int
id|seek_forward
c_func
(paren
r_int
id|segment_id
comma
r_int
id|fast
)paren
suffix:semicolon
DECL|function|fast_seek
r_static
r_int
id|fast_seek
c_func
(paren
r_int
id|count
comma
r_int
id|reverse
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
multiline_comment|/*  If positioned at begin or end of tape, fast seeking needs&n;&t;&t; *  special treatment.&n;&t;&t; *  Starting from logical bot needs a (slow) seek to the first&n;&t;&t; *  segment before the high speed seek. Most drives do this&n;&t;&t; *  automatically but some older don&squot;t, so we treat them&n;&t;&t; *  all the same.&n;&t;&t; *  Starting from logical eot is even more difficult because&n;&t;&t; *  we cannot (slow) reverse seek to the last segment.&n;&t;&t; *  TO BE IMPLEMENTED.&n;&t;&t; */
id|inhibit_correction
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ft_location.known
op_logical_and
(paren
(paren
id|ft_location.bot
op_logical_and
op_logical_neg
id|reverse
)paren
op_logical_or
(paren
id|ft_location.eot
op_logical_and
id|reverse
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|reverse
)paren
(brace
multiline_comment|/*  (slow) skip to first segment on a track&n;&t;&t;&t;&t; */
id|seek_forward
c_func
(paren
id|ft_location.track
op_star
id|ft_segments_per_track
comma
l_int|0
)paren
suffix:semicolon
op_decrement
id|count
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  When seeking backwards from&n;&t;&t;&t;&t; *  end-of-tape the number of erased&n;&t;&t;&t;&t; *  gaps found seems to be higher than&n;&t;&t;&t;&t; *  expected.  Therefor the drive must&n;&t;&t;&t;&t; *  skip some more segments than&n;&t;&t;&t;&t; *  calculated, but we don&squot;t know how&n;&t;&t;&t;&t; *  many.  Thus we will prevent the&n;&t;&t;&t;&t; *  re-calculation of offset and&n;&t;&t;&t;&t; *  overshoot when seeking backwards.&n;&t;&t;&t;&t; */
id|inhibit_correction
op_assign
l_int|1
suffix:semicolon
id|count
op_add_assign
l_int|3
suffix:semicolon
multiline_comment|/* best guess */
)brace
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;warning: zero or negative count: %d&quot;
comma
id|count
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|nibbles
op_assign
id|count
OG
l_int|255
ques
c_cond
l_int|3
suffix:colon
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|4095
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;skipping clipped at 4095 segment&quot;
)paren
suffix:semicolon
id|count
op_assign
l_int|4095
suffix:semicolon
)brace
multiline_comment|/* Issue this tape command first. */
r_if
c_cond
(paren
op_logical_neg
id|reverse
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;skipping %d segment(s)&quot;
comma
id|count
)paren
suffix:semicolon
id|result
op_assign
id|ftape_command
c_func
(paren
id|nibbles
op_eq
l_int|3
ques
c_cond
id|QIC_SKIP_EXTENDED_FORWARD
suffix:colon
id|QIC_SKIP_FORWARD
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;backing up %d segment(s)&quot;
comma
id|count
)paren
suffix:semicolon
id|result
op_assign
id|ftape_command
c_func
(paren
id|nibbles
op_eq
l_int|3
ques
c_cond
id|QIC_SKIP_EXTENDED_REVERSE
suffix:colon
id|QIC_SKIP_REVERSE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Skip command failed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
op_decrement
id|count
suffix:semicolon
multiline_comment|/* 0 means one gap etc. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nibbles
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_parameter
c_func
(paren
id|count
op_amp
l_int|15
)paren
suffix:semicolon
id|count
op_div_assign
l_int|16
suffix:semicolon
)brace
)brace
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|ftape_timeout.rewind
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|ftape_tape_running
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|validate
r_static
r_int
id|validate
c_func
(paren
r_int
id|id
)paren
(brace
multiline_comment|/* Check to see if position found is off-track as reported&n;&t; *  once.  Because all tracks in one direction lie next to&n;&t; *  each other, if off-track the error will be approximately&n;&t; *  2 * ft_segments_per_track.&n;&t; */
r_if
c_cond
(paren
id|ft_location.track
op_eq
op_minus
l_int|1
)paren
(brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* unforseen situation, don&squot;t generate error */
)brace
r_else
(brace
multiline_comment|/* Use margin of ft_segments_per_track on both sides&n;&t;&t; * because ftape needs some margin and the error we&squot;re&n;&t;&t; * looking for is much larger !&n;&t;&t; */
r_int
id|lo
op_assign
(paren
id|ft_location.track
op_minus
l_int|1
)paren
op_star
id|ft_segments_per_track
suffix:semicolon
r_int
id|hi
op_assign
(paren
id|ft_location.track
op_plus
l_int|2
)paren
op_star
id|ft_segments_per_track
suffix:semicolon
r_return
(paren
id|id
op_ge
id|lo
op_logical_and
id|id
OL
id|hi
)paren
suffix:semicolon
)brace
)brace
DECL|function|seek_forward
r_static
r_int
id|seek_forward
c_func
(paren
r_int
id|segment_id
comma
r_int
id|fast
)paren
(brace
r_int
id|failures
op_assign
l_int|0
suffix:semicolon
r_int
id|count
suffix:semicolon
r_static
r_int
id|margin
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* fixed: stop this before target */
r_static
r_int
id|overshoot
op_assign
l_int|1
suffix:semicolon
r_static
r_int
id|min_count
op_assign
l_int|8
suffix:semicolon
r_int
id|expected
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|target
op_assign
id|segment_id
op_minus
id|margin
suffix:semicolon
r_int
id|fast_seeking
suffix:semicolon
r_int
id|prev_segment
op_assign
id|ft_location.segment
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ft_location.known
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;fatal: cannot seek from unknown location&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|validate
c_func
(paren
id|segment_id
)paren
)paren
(brace
id|ftape_sleep
c_func
(paren
l_int|1
op_star
id|FT_SECOND
)paren
suffix:semicolon
id|ft_failure
op_assign
l_int|1
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;fatal: head off track (bad hardware?)&quot;
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;from %d/%d to %d/0 - %d&quot;
comma
id|ft_location.segment
comma
id|ft_location.sector
comma
id|segment_id
comma
id|margin
)paren
suffix:semicolon
id|count
op_assign
id|target
op_minus
id|ft_location.segment
op_minus
id|overshoot
suffix:semicolon
id|fast_seeking
op_assign
(paren
id|fast
op_logical_and
id|count
OG
(paren
id|min_count
op_plus
(paren
id|ft_location.bot
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fast_seeking
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;fast skipping %d segments&quot;
comma
id|count
)paren
suffix:semicolon
id|expected
op_assign
id|segment_id
op_minus
id|margin
suffix:semicolon
id|fast_seek
c_func
(paren
id|count
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ftape_tape_running
)paren
(brace
id|logical_forward
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|ft_location.segment
OL
id|segment_id
)paren
(brace
multiline_comment|/*  This requires at least one sector in a (bad) segment to&n;&t;&t; *  have a valid and readable sector id !&n;&t;&t; *  It looks like this is not guaranteed, so we must try&n;&t;&t; *  to find a way to skip an EMPTY_SEGMENT. !!! FIXME !!!&n;&t;&t; */
r_if
c_cond
(paren
id|ftape_read_id
c_func
(paren
)paren
OL
l_int|0
op_logical_or
op_logical_neg
id|ft_location.known
op_logical_or
id|sigtestsetmask
c_func
(paren
op_amp
id|current-&gt;pending.signal
comma
id|_DONT_BLOCK
)paren
)paren
(brace
id|ft_location.known
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ftape_tape_running
op_logical_or
op_increment
id|failures
OG
id|FT_SECTORS_PER_SEGMENT
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;read_id failed completely&quot;
)paren
suffix:semicolon
)brace
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;read_id failed, retry (%d)&quot;
comma
id|failures
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fast_seeking
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;ended at %d/%d (%d,%d)&quot;
comma
id|ft_location.segment
comma
id|ft_location.sector
comma
id|overshoot
comma
id|inhibit_correction
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inhibit_correction
op_logical_and
(paren
id|ft_location.segment
template_param
id|expected
op_plus
id|margin
)paren
)paren
(brace
r_int
id|error
op_assign
id|ft_location.segment
op_minus
id|expected
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;adjusting overshoot from %d to %d&quot;
comma
id|overshoot
comma
id|overshoot
op_plus
id|error
)paren
suffix:semicolon
id|overshoot
op_add_assign
id|error
suffix:semicolon
multiline_comment|/*  All overshoots have the same&n;&t;&t;&t;&t; *  direction, so it should never&n;&t;&t;&t;&t; *  become negative, but who knows.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|overshoot
template_param
id|OVERSHOOT_LIMIT
)paren
(brace
r_if
c_cond
(paren
id|overshoot
OL
l_int|0
)paren
(brace
multiline_comment|/* keep sane value */
id|overshoot
op_assign
op_minus
l_int|5
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* keep sane value */
id|overshoot
op_assign
id|OVERSHOOT_LIMIT
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;clipped overshoot to %d&quot;
comma
id|overshoot
)paren
suffix:semicolon
)brace
)brace
id|fast_seeking
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_location.known
)paren
(brace
r_if
c_cond
(paren
id|ft_location.segment
OG
id|prev_segment
op_plus
l_int|1
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;missed segment %d while skipping&quot;
comma
id|prev_segment
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|prev_segment
op_assign
id|ft_location.segment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ft_location.segment
OG
id|segment_id
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_noise
comma
l_string|&quot;failed: skip ended at segment %d/%d&quot;
comma
id|ft_location.segment
comma
id|ft_location.sector
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|skip_reverse
r_static
r_int
id|skip_reverse
c_func
(paren
r_int
id|segment_id
comma
r_int
op_star
id|pstatus
)paren
(brace
r_int
id|failures
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|overshoot
op_assign
l_int|1
suffix:semicolon
r_static
r_int
id|min_rewind
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* 1 + overshoot */
r_static
r_const
r_int
id|margin
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* stop this before target */
r_int
id|expected
op_assign
l_int|0
suffix:semicolon
r_int
id|count
op_assign
l_int|1
suffix:semicolon
r_int
id|short_seek
suffix:semicolon
r_int
id|target
op_assign
id|segment_id
op_minus
id|margin
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_location.known
op_logical_and
op_logical_neg
id|validate
c_func
(paren
id|segment_id
)paren
)paren
(brace
id|ftape_sleep
c_func
(paren
l_int|1
op_star
id|FT_SECOND
)paren
suffix:semicolon
id|ft_failure
op_assign
l_int|1
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;fatal: head off track (bad hardware?)&quot;
)paren
suffix:semicolon
)brace
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
id|ft_location.known
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;warning: location not known&quot;
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;from %d/%d to %d/0 - %d&quot;
comma
id|ft_location.segment
comma
id|ft_location.sector
comma
id|segment_id
comma
id|margin
)paren
suffix:semicolon
multiline_comment|/*  min_rewind == 1 + overshoot_when_doing_minimum_rewind&n;&t;&t; *  overshoot  == overshoot_when_doing_larger_rewind&n;&t;&t; *  Initially min_rewind == 1 + overshoot, optimization&n;&t;&t; *  of both values will be done separately.&n;&t;&t; *  overshoot and min_rewind can be negative as both are&n;&t;&t; *  sums of three components:&n;&t;&t; *  any_overshoot == rewind_overshoot - &n;&t;&t; *                   stop_overshoot   -&n;&t;&t; *                   start_overshoot&n;&t;&t; */
r_if
c_cond
(paren
id|ft_location.segment
op_minus
id|target
op_minus
(paren
id|min_rewind
op_minus
l_int|1
)paren
OL
l_int|1
)paren
(brace
id|short_seek
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|count
op_assign
id|ft_location.segment
op_minus
id|target
op_minus
id|overshoot
suffix:semicolon
id|short_seek
op_assign
(paren
id|count
OL
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|short_seek
)paren
(brace
id|count
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* do shortest rewind */
id|expected
op_assign
id|ft_location.segment
op_minus
id|min_rewind
suffix:semicolon
r_if
c_cond
(paren
id|expected
op_div
id|ft_segments_per_track
op_ne
id|ft_location.track
)paren
(brace
id|expected
op_assign
(paren
id|ft_location.track
op_star
id|ft_segments_per_track
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|expected
op_assign
id|target
suffix:semicolon
)brace
id|fast_seek
c_func
(paren
id|count
comma
l_int|1
)paren
suffix:semicolon
id|logical_forward
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_read_id
c_func
(paren
)paren
OL
l_int|0
op_logical_or
op_logical_neg
id|ft_location.known
op_logical_or
(paren
id|sigtestsetmask
c_func
(paren
op_amp
id|current-&gt;pending.signal
comma
id|_DONT_BLOCK
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|ftape_tape_running
op_logical_and
op_logical_neg
id|ft_location.known
)paren
op_logical_or
op_increment
id|failures
OG
id|FT_SECTORS_PER_SEGMENT
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;read_id failed completely&quot;
)paren
suffix:semicolon
)brace
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_report_drive_status
c_func
(paren
id|pstatus
)paren
comma
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;ftape_read_id failed, retry (%d)&quot;
comma
id|failures
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;ended at %d/%d (%d,%d,%d)&quot;
comma
id|ft_location.segment
comma
id|ft_location.sector
comma
id|min_rewind
comma
id|overshoot
comma
id|inhibit_correction
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inhibit_correction
op_logical_and
(paren
id|ft_location.segment
template_param
id|expected
op_plus
id|margin
)paren
)paren
(brace
r_int
id|error
op_assign
id|expected
op_minus
id|ft_location.segment
suffix:semicolon
r_if
c_cond
(paren
id|short_seek
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;adjusting min_rewind from %d to %d&quot;
comma
id|min_rewind
comma
id|min_rewind
op_plus
id|error
)paren
suffix:semicolon
id|min_rewind
op_add_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|min_rewind
OL
op_minus
l_int|5
)paren
(brace
multiline_comment|/* is this right ? FIXME ! */
multiline_comment|/* keep sane value */
id|min_rewind
op_assign
op_minus
l_int|5
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;clipped min_rewind to %d&quot;
comma
id|min_rewind
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;adjusting overshoot from %d to %d&quot;
comma
id|overshoot
comma
id|overshoot
op_plus
id|error
)paren
suffix:semicolon
id|overshoot
op_add_assign
id|error
suffix:semicolon
r_if
c_cond
(paren
id|overshoot
template_param
id|OVERSHOOT_LIMIT
)paren
(brace
r_if
c_cond
(paren
id|overshoot
OL
l_int|0
)paren
(brace
multiline_comment|/* keep sane value */
id|overshoot
op_assign
op_minus
l_int|5
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* keep sane value */
id|overshoot
op_assign
id|OVERSHOOT_LIMIT
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;clipped overshoot to %d&quot;
comma
id|overshoot
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
r_while
c_loop
(paren
id|ft_location.segment
OG
id|segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_location.known
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;current location: %d/%d&quot;
comma
id|ft_location.segment
comma
id|ft_location.sector
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|determine_position
r_static
r_int
id|determine_position
c_func
(paren
r_void
)paren
(brace
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ftape_tape_running
)paren
(brace
multiline_comment|/*  This should only happen if tape is stopped by isr.&n;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;waiting for tape stop&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_ready_wait
c_func
(paren
id|ftape_timeout.pause
comma
op_amp
id|status
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;drive still running (fatal)&quot;
)paren
suffix:semicolon
id|ftape_tape_running
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* ? */
)brace
)brace
r_else
(brace
id|ftape_report_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
(brace
multiline_comment|/*  Drive must be ready to check error state !&n;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;drive is ready&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
(brace
r_int
r_int
id|error
suffix:semicolon
id|qic117_cmd_t
id|command
suffix:semicolon
multiline_comment|/*  Report and clear error state, try to continue.&n;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;error status set&quot;
)paren
suffix:semicolon
id|ftape_report_error
c_func
(paren
op_amp
id|error
comma
op_amp
id|command
comma
l_int|1
)paren
suffix:semicolon
id|ftape_ready_wait
c_func
(paren
id|ftape_timeout.reset
comma
op_amp
id|status
)paren
suffix:semicolon
id|ftape_tape_running
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ? */
)brace
r_if
c_cond
(paren
id|check_bot_eot
c_func
(paren
id|status
)paren
)paren
(brace
r_if
c_cond
(paren
id|ft_location.bot
)paren
(brace
r_if
c_cond
(paren
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* tape moving away from&n;&t;&t;&t;&t;&t; * bot/eot, let&squot;s see if we&n;&t;&t;&t;&t;&t; * can catch up with the first&n;&t;&t;&t;&t;&t; * segment on this track.&n;&t;&t;&t;&t;&t; */
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;start tape from logical bot&quot;
)paren
suffix:semicolon
id|logical_forward
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* start moving */
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;waiting for logical end of track&quot;
)paren
suffix:semicolon
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|ftape_timeout.reset
comma
op_amp
id|status
)paren
suffix:semicolon
multiline_comment|/* error handling needed ? */
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;tape at logical end of track&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;start tape&quot;
)paren
suffix:semicolon
id|logical_forward
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* start moving */
id|ft_location.known
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not cleared by logical forward ! */
)brace
)brace
multiline_comment|/* tape should be moving now, start reading id&squot;s&n;&t; */
r_while
c_loop
(paren
op_logical_neg
id|ft_location.known
op_logical_and
id|retry
op_increment
OL
id|FT_SECTORS_PER_SEGMENT
op_logical_and
(paren
id|result
op_assign
id|ftape_read_id
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;location unknown&quot;
)paren
suffix:semicolon
multiline_comment|/* exit on signal&n;&t;&t; */
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
multiline_comment|/*  read-id somehow failed, tape may&n;&t;&t; *  have reached end or some other&n;&t;&t; *  error happened.&n;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;read-id failed&quot;
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_report_drive_status
c_func
(paren
op_amp
id|status
)paren
comma
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;ftape_report_drive_status: 0x%02x&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
(brace
id|ftape_tape_running
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;tape stopped for unknown reason! &quot;
l_string|&quot;status = 0x%02x&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_ERROR
op_logical_or
op_logical_neg
id|check_bot_eot
c_func
(paren
id|status
)paren
)paren
(brace
multiline_comment|/* oops, tape stopped but not at end!&n;&t;&t;&t;&t; */
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
)brace
)brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;tape is positioned at segment %d&quot;
comma
id|ft_location.segment
)paren
suffix:semicolon
id|TRACE_EXIT
id|ft_location.known
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*      Get the tape running and position it just before the&n; *      requested segment.&n; *      Seek tape-track and reposition as needed.&n; */
DECL|function|ftape_start_tape
r_int
id|ftape_start_tape
c_func
(paren
r_int
id|segment_id
comma
r_int
id|sector_offset
)paren
(brace
r_int
id|track
op_assign
id|segment_id
op_div
id|ft_segments_per_track
suffix:semicolon
r_int
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_int
id|status
suffix:semicolon
r_static
r_int
id|last_segment
op_assign
op_minus
l_int|1
suffix:semicolon
r_static
r_int
id|bad_bus_timing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of segments passing the head between starting the tape&n;&t; * and being able to access the first sector.&n;&t; */
r_static
r_int
id|start_offset
op_assign
l_int|1
suffix:semicolon
r_int
id|retry
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
multiline_comment|/* If sector_offset &gt; 0, seek into wanted segment instead of&n;&t; * into previous.&n;&t; * This allows error recovery if a part of the segment is bad&n;&t; * (erased) causing the tape drive to generate an index pulse&n;&t; * thus causing a no-data error before the requested sector&n;&t; * is reached.&n;&t; */
id|ftape_tape_running
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;target segment: %d/%d%s&quot;
comma
id|segment_id
comma
id|sector_offset
comma
id|ft_buffer
(braket
id|ft_head
)braket
op_member_access_from_pointer
id|retry
OG
l_int|0
ques
c_cond
l_string|&quot; retry&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_buffer
(braket
id|ft_head
)braket
op_member_access_from_pointer
id|retry
OG
l_int|0
)paren
(brace
multiline_comment|/* this is a retry */
r_int
id|dist
op_assign
id|segment_id
op_minus
id|last_segment
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|ft_history.overrun_errors
OL
id|overrun_count_offset
)paren
(brace
id|overrun_count_offset
op_assign
id|ft_history.overrun_errors
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|dist
template_param
l_int|50
)paren
(brace
id|overrun_count_offset
op_assign
id|ft_history.overrun_errors
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ft_history.overrun_errors
op_minus
id|overrun_count_offset
)paren
op_ge
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|ftape_increase_threshold
c_func
(paren
)paren
op_ge
l_int|0
)paren
(brace
op_decrement
id|ft_buffer
(braket
id|ft_head
)braket
op_member_access_from_pointer
id|retry
suffix:semicolon
id|overrun_count_offset
op_assign
id|ft_history.overrun_errors
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;increased threshold because &quot;
l_string|&quot;of excessive overrun errors&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|bad_bus_timing
op_logical_and
id|ft_data_rate
op_ge
l_int|1000
)paren
(brace
id|ftape_half_data_rate
c_func
(paren
)paren
suffix:semicolon
op_decrement
id|ft_buffer
(braket
id|ft_head
)braket
op_member_access_from_pointer
id|retry
suffix:semicolon
id|bad_bus_timing
op_assign
l_int|1
suffix:semicolon
id|overrun_count_offset
op_assign
id|ft_history.overrun_errors
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;reduced datarate because &quot;
l_string|&quot;of excessive overrun errors&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
id|last_segment
op_assign
id|segment_id
suffix:semicolon
r_if
c_cond
(paren
id|ft_location.track
op_ne
id|track
op_logical_or
(paren
id|ftape_might_be_off_track
op_logical_and
id|ft_buffer
(braket
id|ft_head
)braket
op_member_access_from_pointer
id|retry
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* current track unknown or not equal to destination&n;&t;&t; */
id|ftape_ready_wait
c_func
(paren
id|ftape_timeout.seek
comma
op_amp
id|status
)paren
suffix:semicolon
id|ftape_seek_head_to_track
c_func
(paren
id|track
)paren
suffix:semicolon
multiline_comment|/* overrun_count_offset = ft_history.overrun_errors; */
)brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
id|retry
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|result
OL
l_int|0
op_logical_and
id|retry
op_increment
op_le
l_int|5
op_logical_and
op_logical_neg
id|ft_failure
op_logical_and
op_logical_neg
(paren
id|sigtestsetmask
c_func
(paren
op_amp
id|current-&gt;pending.signal
comma
id|_DONT_BLOCK
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|retry
op_logical_and
id|start_offset
OL
l_int|5
)paren
(brace
id|start_offset
op_increment
suffix:semicolon
)brace
multiline_comment|/*  Check if we are able to catch the requested&n;&t;&t; *  segment in time.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|ft_location.known
op_logical_or
(paren
id|determine_position
c_func
(paren
)paren
op_eq
l_int|0
)paren
)paren
op_logical_and
id|ft_location.segment
op_ge
(paren
id|segment_id
op_minus
(paren
(paren
id|ftape_tape_running
op_logical_or
id|ft_location.bot
)paren
ques
c_cond
l_int|0
suffix:colon
id|start_offset
)paren
)paren
)paren
(brace
multiline_comment|/*  Too far ahead (in or past target segment).&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ftape_tape_running
)paren
(brace
r_if
c_cond
(paren
(paren
id|result
op_assign
id|ftape_stop_tape
c_func
(paren
op_amp
id|status
)paren
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;stop tape failed with code %d&quot;
comma
id|result
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;tape stopped&quot;
)paren
suffix:semicolon
id|ftape_tape_running
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;repositioning&quot;
)paren
suffix:semicolon
op_increment
id|ft_history.rewinds
suffix:semicolon
r_if
c_cond
(paren
id|segment_id
op_mod
id|ft_segments_per_track
OL
id|start_offset
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;end of track condition&bslash;n&quot;
id|KERN_INFO
l_string|&quot;segment_id        : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;ft_segments_per_track: %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;start_offset      : %d&quot;
comma
id|segment_id
comma
id|ft_segments_per_track
comma
id|start_offset
)paren
suffix:semicolon
multiline_comment|/*  If seeking to first segments on&n;&t;&t;&t;&t; *  track better do a complete rewind&n;&t;&t;&t;&t; *  to logical begin of track to get a&n;&t;&t;&t;&t; *  more steady tape motion.  &n;&t;&t;&t;&t; */
id|result
op_assign
id|ftape_command_wait
c_func
(paren
(paren
id|ft_location.track
op_amp
l_int|1
)paren
ques
c_cond
id|QIC_PHYSICAL_FORWARD
suffix:colon
id|QIC_PHYSICAL_REVERSE
comma
id|ftape_timeout.rewind
comma
op_amp
id|status
)paren
suffix:semicolon
id|check_bot_eot
c_func
(paren
id|status
)paren
suffix:semicolon
multiline_comment|/* update location */
)brace
r_else
(brace
id|result
op_assign
id|skip_reverse
c_func
(paren
id|segment_id
op_minus
id|start_offset
comma
op_amp
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|ft_location.known
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;panic: location not known&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* while() will check for failure */
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;current segment: %d/%d&quot;
comma
id|ft_location.segment
comma
id|ft_location.sector
)paren
suffix:semicolon
multiline_comment|/*  We&squot;re on the right track somewhere before the&n;&t;&t; *  wanted segment.  Start tape movement if needed and&n;&t;&t; *  skip to just before or inside the requested&n;&t;&t; *  segment. Keep tape running.  &n;&t;&t; */
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ft_location.segment
OL
(paren
id|segment_id
op_minus
(paren
(paren
id|ftape_tape_running
op_logical_or
id|ft_location.bot
)paren
ques
c_cond
l_int|0
suffix:colon
id|start_offset
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|sector_offset
OG
l_int|0
)paren
(brace
id|result
op_assign
id|seek_forward
c_func
(paren
id|segment_id
comma
id|retry
op_le
l_int|3
)paren
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
id|seek_forward
c_func
(paren
id|segment_id
op_minus
l_int|1
comma
id|retry
op_le
l_int|3
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_and
id|ft_location.segment
op_ne
(paren
id|segment_id
op_minus
(paren
id|sector_offset
OG
l_int|0
ques
c_cond
l_int|0
suffix:colon
l_int|1
)paren
)paren
)paren
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;failed to reposition&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|ft_runner_status
op_assign
id|running
suffix:semicolon
)brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
eof
