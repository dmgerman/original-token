multiline_comment|/*&n; * Copyright (C) 1993-1996 Bas Laarhoven,&n; *           (C) 1996-1997 Claus-Justus Heine.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/lowlevel/fdc-io.c,v $&n; * $Revision: 1.7.4.2 $&n; * $Date: 1997/11/16 14:48:17 $&n; *&n; *      This file contains the low-level floppy disk interface code&n; *      for the QIC-40/80/3010/3020 floppy-tape driver &quot;ftape&quot; for&n; *      Linux.&n; */
macro_line|#include &lt;linux/config.h&gt; /* for CONFIG_FT_* */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;linux/qic117.h&gt;
macro_line|#include &quot;../lowlevel/ftape-tracing.h&quot;
macro_line|#include &quot;../lowlevel/fdc-io.h&quot;
macro_line|#include &quot;../lowlevel/fdc-isr.h&quot;
macro_line|#include &quot;../lowlevel/ftape-io.h&quot;
macro_line|#include &quot;../lowlevel/ftape-rw.h&quot;
macro_line|#include &quot;../lowlevel/ftape-ctl.h&quot;
macro_line|#include &quot;../lowlevel/ftape-calibr.h&quot;
macro_line|#include &quot;../lowlevel/fc-10.h&quot;
multiline_comment|/*      Global vars.&n; */
DECL|variable|ftape_motor
r_int
id|ftape_motor
suffix:semicolon
DECL|variable|ftape_current_cylinder
r_volatile
r_int
id|ftape_current_cylinder
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|fdc_mode
r_volatile
id|fdc_mode_enum
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
DECL|variable|fdc
id|fdc_config_info
id|fdc
suffix:semicolon
DECL|variable|ftape_wait_intr
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|ftape_wait_intr
)paren
suffix:semicolon
DECL|variable|ft_fdc_base
r_int
r_int
id|ft_fdc_base
op_assign
id|CONFIG_FT_FDC_BASE
suffix:semicolon
DECL|variable|ft_fdc_irq
r_int
r_int
id|ft_fdc_irq
op_assign
id|CONFIG_FT_FDC_IRQ
suffix:semicolon
DECL|variable|ft_fdc_dma
r_int
r_int
id|ft_fdc_dma
op_assign
id|CONFIG_FT_FDC_DMA
suffix:semicolon
DECL|variable|ft_fdc_threshold
r_int
r_int
id|ft_fdc_threshold
op_assign
id|CONFIG_FT_FDC_THR
suffix:semicolon
multiline_comment|/* bytes */
DECL|variable|ft_fdc_rate_limit
r_int
r_int
id|ft_fdc_rate_limit
op_assign
id|CONFIG_FT_FDC_MAX_RATE
suffix:semicolon
multiline_comment|/* bits/sec */
DECL|variable|ft_probe_fc10
r_int
id|ft_probe_fc10
op_assign
id|CONFIG_FT_PROBE_FC10
suffix:semicolon
DECL|variable|ft_mach2
r_int
id|ft_mach2
op_assign
id|CONFIG_FT_MACH2
suffix:semicolon
multiline_comment|/*      Local vars.&n; */
DECL|variable|fdc_calibr_count
r_static
r_int
r_int
id|fdc_calibr_count
suffix:semicolon
DECL|variable|fdc_calibr_time
r_static
r_int
r_int
id|fdc_calibr_time
suffix:semicolon
DECL|variable|fdc_status
r_static
r_int
id|fdc_status
suffix:semicolon
DECL|variable|fdc_head
r_volatile
id|__u8
id|fdc_head
suffix:semicolon
multiline_comment|/* FDC head from sector id */
DECL|variable|fdc_cyl
r_volatile
id|__u8
id|fdc_cyl
suffix:semicolon
multiline_comment|/* FDC track from sector id */
DECL|variable|fdc_sect
r_volatile
id|__u8
id|fdc_sect
suffix:semicolon
multiline_comment|/* FDC sector from sector id */
DECL|variable|fdc_data_rate
r_static
r_int
id|fdc_data_rate
op_assign
l_int|500
suffix:semicolon
multiline_comment|/* data rate (Kbps) */
DECL|variable|fdc_rate_code
r_static
r_int
id|fdc_rate_code
suffix:semicolon
multiline_comment|/* data rate code (0 == 500 Kbps) */
DECL|variable|fdc_seek_rate
r_static
r_int
id|fdc_seek_rate
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* step rate (msec) */
DECL|variable|do_ftape
r_static
r_void
(paren
op_star
id|do_ftape
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|variable|fdc_fifo_state
r_static
r_int
id|fdc_fifo_state
suffix:semicolon
multiline_comment|/* original fifo setting - fifo enabled */
DECL|variable|fdc_fifo_thr
r_static
r_int
id|fdc_fifo_thr
suffix:semicolon
multiline_comment|/* original fifo setting - threshold */
DECL|variable|fdc_lock_state
r_static
r_int
id|fdc_lock_state
suffix:semicolon
multiline_comment|/* original lock setting - locked */
DECL|variable|fdc_fifo_locked
r_static
r_int
id|fdc_fifo_locked
suffix:semicolon
multiline_comment|/* has fifo &amp;&amp; lock set ? */
DECL|variable|fdc_precomp
r_static
id|__u8
id|fdc_precomp
suffix:semicolon
multiline_comment|/* default precomp. value (nsec) */
DECL|variable|fdc_prec_code
r_static
id|__u8
id|fdc_prec_code
suffix:semicolon
multiline_comment|/* fdc precomp. select code */
DECL|variable|ftape_id
r_static
r_char
id|ftape_id
(braket
)braket
op_assign
l_string|&quot;ftape&quot;
suffix:semicolon
multiline_comment|/* used by request irq and free irq */
DECL|function|fdc_catch_stray_interrupts
r_void
id|fdc_catch_stray_interrupts
c_func
(paren
r_int
id|count
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|ft_expected_stray_interrupts
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ft_expected_stray_interrupts
op_add_assign
id|count
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*  Wait during a timeout period for a given FDC status.&n; *  If usecs == 0 then just test status, else wait at least for usecs.&n; *  Returns -ETIME on timeout. Function must be calibrated first !&n; */
DECL|function|fdc_wait
r_int
id|fdc_wait
c_func
(paren
r_int
r_int
id|usecs
comma
id|__u8
id|mask
comma
id|__u8
id|state
)paren
(brace
r_int
id|count_1
op_assign
(paren
id|fdc_calibr_count
op_star
id|usecs
op_plus
id|fdc_calibr_count
op_minus
l_int|1
)paren
op_div
id|fdc_calibr_time
suffix:semicolon
r_do
(brace
id|fdc_status
op_assign
id|inb_p
c_func
(paren
id|fdc.msr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fdc_status
op_amp
id|mask
)paren
op_eq
id|state
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|count_1
op_decrement
op_ge
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|ETIME
suffix:semicolon
)brace
DECL|function|fdc_ready_wait
r_int
id|fdc_ready_wait
c_func
(paren
r_int
r_int
id|usecs
)paren
(brace
r_return
id|fdc_wait
c_func
(paren
id|usecs
comma
id|FDC_DATA_READY
op_or
id|FDC_BUSY
comma
id|FDC_DATA_READY
)paren
suffix:semicolon
)brace
multiline_comment|/* Why can&squot;t we just use udelay()?&n; */
DECL|function|fdc_usec_wait
r_static
r_void
id|fdc_usec_wait
c_func
(paren
r_int
r_int
id|usecs
)paren
(brace
id|fdc_wait
c_func
(paren
id|usecs
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* will always timeout ! */
)brace
DECL|function|fdc_ready_out_wait
r_int
id|fdc_ready_out_wait
c_func
(paren
r_int
r_int
id|usecs
)paren
(brace
id|fdc_usec_wait
c_func
(paren
id|FT_RQM_DELAY
)paren
suffix:semicolon
multiline_comment|/* wait for valid RQM status */
r_return
id|fdc_wait
c_func
(paren
id|usecs
comma
id|FDC_DATA_OUT_READY
comma
id|FDC_DATA_OUT_READY
)paren
suffix:semicolon
)brace
DECL|function|fdc_ready_in_wait
r_int
id|fdc_ready_in_wait
c_func
(paren
r_int
r_int
id|usecs
)paren
(brace
id|fdc_usec_wait
c_func
(paren
id|FT_RQM_DELAY
)paren
suffix:semicolon
multiline_comment|/* wait for valid RQM status */
r_return
id|fdc_wait
c_func
(paren
id|usecs
comma
id|FDC_DATA_OUT_READY
comma
id|FDC_DATA_IN_READY
)paren
suffix:semicolon
)brace
DECL|function|fdc_wait_calibrate
r_void
id|fdc_wait_calibrate
c_func
(paren
r_void
)paren
(brace
id|ftape_calibrate
c_func
(paren
l_string|&quot;fdc_wait&quot;
comma
id|fdc_usec_wait
comma
op_amp
id|fdc_calibr_count
comma
op_amp
id|fdc_calibr_time
)paren
suffix:semicolon
)brace
multiline_comment|/*  Wait for a (short) while for the FDC to become ready&n; *  and transfer the next command byte.&n; *  Return -ETIME on timeout on getting ready (depends on hardware!).&n; */
DECL|function|fdc_write
r_static
r_int
id|fdc_write
c_func
(paren
r_const
id|__u8
id|data
)paren
(brace
id|fdc_usec_wait
c_func
(paren
id|FT_RQM_DELAY
)paren
suffix:semicolon
multiline_comment|/* wait for valid RQM status */
r_if
c_cond
(paren
id|fdc_wait
c_func
(paren
l_int|150
comma
id|FDC_DATA_READY_MASK
comma
id|FDC_DATA_IN_READY
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ETIME
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|data
comma
id|fdc.fifo
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*  Wait for a (short) while for the FDC to become ready&n; *  and transfer the next result byte.&n; *  Return -ETIME if timeout on getting ready (depends on hardware!).&n; */
DECL|function|fdc_read
r_static
r_int
id|fdc_read
c_func
(paren
id|__u8
op_star
id|data
)paren
(brace
id|fdc_usec_wait
c_func
(paren
id|FT_RQM_DELAY
)paren
suffix:semicolon
multiline_comment|/* wait for valid RQM status */
r_if
c_cond
(paren
id|fdc_wait
c_func
(paren
l_int|150
comma
id|FDC_DATA_READY_MASK
comma
id|FDC_DATA_OUT_READY
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ETIME
suffix:semicolon
)brace
r_else
(brace
op_star
id|data
op_assign
id|inb
c_func
(paren
id|fdc.fifo
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*  Output a cmd_len long command string to the FDC.&n; *  The FDC should be ready to receive a new command or&n; *  an error (EBUSY or ETIME) will occur.&n; */
DECL|function|fdc_command
r_int
id|fdc_command
c_func
(paren
r_const
id|__u8
op_star
id|cmd_data
comma
r_int
id|cmd_len
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|count
op_assign
id|cmd_len
suffix:semicolon
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef TESTING
r_static
r_int
r_int
id|last_time
suffix:semicolon
r_int
r_int
id|time
suffix:semicolon
macro_line|#endif
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|fdc_usec_wait
c_func
(paren
id|FT_RQM_DELAY
)paren
suffix:semicolon
multiline_comment|/* wait for valid RQM status */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,1,30)
r_if
c_cond
(paren
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
)paren
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|intr_count
)paren
macro_line|#endif
multiline_comment|/* Yes, I know, too much comments inside this function&n;&t;&t; * ...&n;&t;&t; * &n;&t;&t; * Yet another bug in the original driver. All that&n;&t;&t; * havoc is caused by the fact that the isr() sends&n;&t;&t; * itself a command to the floppy tape driver (pause,&n;&t;&t; * micro step pause).  Now, the problem is that&n;&t;&t; * commands are transmitted via the fdc_seek&n;&t;&t; * command. But: the fdc performs seeks in the&n;&t;&t; * background i.e. it doesn&squot;t signal busy while&n;&t;&t; * sending the step pulses to the drive. Therefore the&n;&t;&t; * non-interrupt level driver has no chance to tell&n;&t;&t; * whether the isr() just has issued a seek. Therefore&n;&t;&t; * we HAVE TO have a look at the ft_hide_interrupt&n;&t;&t; * flag: it signals the non-interrupt level part of&n;&t;&t; * the driver that it has to wait for the fdc until it&n;&t;&t; * has completet seeking.&n;&t;&t; *&n;&t;&t; * THIS WAS PRESUMABLY THE REASON FOR ALL THAT&n;&t;&t; * &quot;fdc_read timeout&quot; errors, I HOPE :-)&n;&t;&t; */
r_if
c_cond
(paren
id|ft_hide_interrupt
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;Waiting for the isr() completing fdc_seek()&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc_interrupt_wait
c_func
(paren
l_int|2
op_star
id|FT_SECOND
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Warning: timeout waiting for isr() seek to complete&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_hide_interrupt
op_logical_or
op_logical_neg
id|ft_seek_completed
)paren
(brace
multiline_comment|/* There cannot be another&n;&t;&t;&t;&t; * interrupt. The isr() only stops&n;&t;&t;&t;&t; * the tape and the next interrupt&n;&t;&t;&t;&t; * won&squot;t come until we have send our&n;&t;&t;&t;&t; * command to the drive.&n;&t;&t;&t;&t; */
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_bug
comma
l_string|&quot;BUG? isr() is still seeking?&bslash;n&quot;
id|KERN_INFO
l_string|&quot;hide: %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;seek: %d&quot;
comma
id|ft_hide_interrupt
comma
id|ft_seek_completed
)paren
suffix:semicolon
)brace
id|fdc_usec_wait
c_func
(paren
id|FT_RQM_DELAY
)paren
suffix:semicolon
multiline_comment|/* wait for valid RQM status */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|fdc_status
op_assign
id|inb
c_func
(paren
id|fdc.msr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fdc_status
op_amp
id|FDC_DATA_READY_MASK
)paren
op_ne
id|FDC_DATA_IN_READY
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EBUSY
comma
id|ft_t_err
comma
l_string|&quot;fdc not ready&quot;
)paren
suffix:semicolon
)brace
id|fdc_mode
op_assign
op_star
id|cmd_data
suffix:semicolon
multiline_comment|/* used by isr */
macro_line|#ifdef TESTING
r_if
c_cond
(paren
id|fdc_mode
op_eq
id|FDC_SEEK
)paren
(brace
id|time
op_assign
id|ftape_timediff
c_func
(paren
id|last_time
comma
id|ftape_timestamp
c_func
(paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time
OL
l_int|6000
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;Warning: short timeout between seek commands: %d&quot;
comma
id|time
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,1,30)
r_if
c_cond
(paren
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* shouldn&squot;t be cleared if called from isr&n;&t;&t; */
id|ft_interrupt_seen
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|intr_count
)paren
(brace
multiline_comment|/* shouldn&squot;t be cleared if called from isr&n;&t;&t; */
id|ft_interrupt_seen
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_while
c_loop
(paren
id|count
)paren
(brace
id|result
op_assign
id|fdc_write
c_func
(paren
op_star
id|cmd_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;fdc_mode = %02x, status = %02x at index %d&quot;
comma
(paren
r_int
)paren
id|fdc_mode
comma
(paren
r_int
)paren
id|fdc_status
comma
id|cmd_len
op_minus
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|retry
op_le
l_int|3
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;fdc_write timeout, retry&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;fdc_write timeout, fatal&quot;
)paren
suffix:semicolon
multiline_comment|/* recover ??? */
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
op_decrement
id|count
suffix:semicolon
op_increment
id|cmd_data
suffix:semicolon
)brace
)brace
macro_line|#ifdef TESTING
r_if
c_cond
(paren
id|fdc_mode
op_eq
id|FDC_SEEK
)paren
(brace
id|last_time
op_assign
id|ftape_timestamp
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*  Input a res_len long result string from the FDC.&n; *  The FDC should be ready to send the result or an error&n; *  (EBUSY or ETIME) will occur.&n; */
DECL|function|fdc_result
r_int
id|fdc_result
c_func
(paren
id|__u8
op_star
id|res_data
comma
r_int
id|res_len
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|count
op_assign
id|res_len
suffix:semicolon
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|fdc_status
op_assign
id|inb
c_func
(paren
id|fdc.msr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fdc_status
op_amp
id|FDC_DATA_READY_MASK
)paren
op_ne
id|FDC_DATA_OUT_READY
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;fdc not ready&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
r_while
c_loop
(paren
id|count
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fdc_status
op_amp
id|FDC_BUSY
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;premature end of result phase&quot;
)paren
suffix:semicolon
)brace
id|result
op_assign
id|fdc_read
c_func
(paren
id|res_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;fdc_mode = %02x, status = %02x at index %d&quot;
comma
(paren
r_int
)paren
id|fdc_mode
comma
(paren
r_int
)paren
id|fdc_status
comma
id|res_len
op_minus
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|retry
op_le
l_int|3
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;fdc_read timeout, retry&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;fdc_read timeout, fatal&quot;
)paren
suffix:semicolon
multiline_comment|/* recover ??? */
r_break
suffix:semicolon
op_increment
id|retry
suffix:semicolon
)brace
)brace
r_else
(brace
op_decrement
id|count
suffix:semicolon
op_increment
id|res_data
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|fdc_usec_wait
c_func
(paren
id|FT_RQM_DELAY
)paren
suffix:semicolon
multiline_comment|/* allow FDC to negate BSY */
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*      Handle command and result phases for&n; *      commands without data phase.&n; */
DECL|function|fdc_issue_command
r_int
id|fdc_issue_command
c_func
(paren
r_const
id|__u8
op_star
id|out_data
comma
r_int
id|out_count
comma
id|__u8
op_star
id|in_data
comma
r_int
id|in_count
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|out_count
OG
l_int|0
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|fdc_command
c_func
(paren
id|out_data
comma
id|out_count
)paren
comma
)paren
suffix:semicolon
)brace
multiline_comment|/* will take 24 - 30 usec for fdc_sense_drive_status and&n;&t; * fdc_sense_interrupt_status commands.&n;&t; *    35 fails sometimes (5/9/93 SJL)&n;&t; * On a loaded system it incidentally takes longer than&n;&t; * this for the fdc to get ready ! ?????? WHY ??????&n;&t; * So until we know what&squot;s going on use a very long timeout.&n;&t; */
id|TRACE_CATCH
c_func
(paren
id|fdc_ready_out_wait
c_func
(paren
l_int|500
multiline_comment|/* usec */
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|in_count
OG
l_int|0
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|fdc_result
c_func
(paren
id|in_data
comma
id|in_count
)paren
comma
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;result phase aborted&quot;
)paren
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      Wait for FDC interrupt with timeout (in milliseconds).&n; *      Signals are blocked so the wait will not be aborted.&n; *      Note: interrupts must be enabled ! (23/05/93 SJL)&n; */
DECL|function|fdc_interrupt_wait
r_int
id|fdc_interrupt_wait
c_func
(paren
r_int
r_int
id|time
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|sigset_t
id|old_sigmask
suffix:semicolon
r_static
r_int
id|resetting
suffix:semicolon
r_int
id|timeout
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_fdc_dma
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,0,16)
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|ftape_wait_intr
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;error: nested call&quot;
)paren
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|ftape_wait_intr
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;error: nested call&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* timeout time will be up to USPT microseconds too long ! */
id|timeout
op_assign
(paren
l_int|1000
op_star
id|time
op_plus
id|FT_USPT
op_minus
l_int|1
)paren
op_div
id|FT_USPT
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|old_sigmask
op_assign
id|current-&gt;blocked
suffix:semicolon
id|sigfillset
c_func
(paren
op_amp
id|current-&gt;blocked
)paren
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|ftape_wait_intr
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|ft_interrupt_seen
op_logical_and
(paren
id|current-&gt;state
op_eq
id|TASK_INTERRUPTIBLE
)paren
)paren
(brace
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
)brace
id|spin_lock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|current-&gt;blocked
op_assign
id|old_sigmask
suffix:semicolon
id|recalc_sigpending
c_func
(paren
id|current
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|current-&gt;sigmask_lock
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|ftape_wait_intr
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/*  the following IS necessary. True: as well&n;&t; *  wake_up_interruptible() as the schedule() set TASK_RUNNING&n;&t; *  when they wakeup a task, BUT: it may very well be that&n;&t; *  ft_interrupt_seen is already set to 1 when we enter here&n;&t; *  in which case schedule() gets never called, and&n;&t; *  TASK_RUNNING never set. This has the funny effect that we&n;&t; *  execute all the code until we leave kernel space, but then&n;&t; *  the task is stopped (a task CANNOT be preempted while in&n;&t; *  kernel mode. Sending a pair of SIGSTOP/SIGCONT to the&n;&t; *  tasks wakes it up again. Funny! :-)&n;&t; */
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|ft_interrupt_seen
)paren
(brace
multiline_comment|/* woken up by interrupt */
id|ft_interrupt_seen
op_assign
l_int|0
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  Original comment:&n;&t; *  In first instance, next statement seems unnecessary since&n;&t; *  it will be cleared in fdc_command. However, a small part of&n;&t; *  the software seems to rely on this being cleared here&n;&t; *  (ftape_close might fail) so stick to it until things get fixed !&n;&t; */
multiline_comment|/*  My deeply sought of knowledge:&n;&t; *  Behold NO! It is obvious. fdc_reset() doesn&squot;t call fdc_command()&n;&t; *  but nevertheless uses fdc_interrupt_wait(). OF COURSE this needs to&n;&t; *  be reset here.&n;&t; */
id|ft_interrupt_seen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear for next call */
r_if
c_cond
(paren
op_logical_neg
id|resetting
)paren
(brace
id|resetting
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* break infinite recursion if reset fails */
id|TRACE
c_func
(paren
id|ft_t_any
comma
l_string|&quot;cleanup reset&quot;
)paren
suffix:semicolon
id|fdc_reset
c_func
(paren
)paren
suffix:semicolon
id|resetting
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
ques
c_cond
op_minus
id|EINTR
suffix:colon
op_minus
id|ETIME
suffix:semicolon
)brace
multiline_comment|/*      Start/stop drive motor. Enable DMA mode.&n; */
DECL|function|fdc_motor
r_void
id|fdc_motor
c_func
(paren
r_int
id|motor
)paren
(brace
r_int
id|unit
op_assign
id|ft_drive_sel
suffix:semicolon
r_int
id|data
op_assign
id|unit
op_or
id|FDC_RESET_NOT
op_or
id|FDC_DMA_MODE
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|ftape_motor
op_assign
id|motor
suffix:semicolon
r_if
c_cond
(paren
id|ftape_motor
)paren
(brace
id|data
op_or_assign
id|FDC_MOTOR_0
op_lshift
id|unit
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;turning motor %d on&quot;
comma
id|unit
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;turning motor %d off&quot;
comma
id|unit
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_mach2
)paren
(brace
id|outb_p
c_func
(paren
id|data
comma
id|fdc.dor2
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb_p
c_func
(paren
id|data
comma
id|fdc.dor
)paren
suffix:semicolon
)brace
id|ftape_sleep
c_func
(paren
l_int|10
op_star
id|FT_MILLISECOND
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|fdc_update_dsr
r_static
r_void
id|fdc_update_dsr
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;rate = %d Kbps, precomp = %d ns&quot;
comma
id|fdc_data_rate
comma
id|fdc_precomp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc.type
op_ge
id|i82077
)paren
(brace
id|outb_p
c_func
(paren
(paren
id|fdc_rate_code
op_amp
l_int|0x03
)paren
op_or
id|fdc_prec_code
comma
id|fdc.dsr
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb_p
c_func
(paren
id|fdc_rate_code
op_amp
l_int|0x03
comma
id|fdc.ccr
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|fdc_set_write_precomp
r_void
id|fdc_set_write_precomp
c_func
(paren
r_int
id|precomp
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;New precomp: %d nsec&quot;
comma
id|precomp
)paren
suffix:semicolon
id|fdc_precomp
op_assign
id|precomp
suffix:semicolon
multiline_comment|/*  write precompensation can be set in multiples of 41.67 nsec.&n;&t; *  round the parameter to the nearest multiple and convert it&n;&t; *  into a fdc setting. Note that 0 means default to the fdc,&n;&t; *  7 is used instead of that.&n;&t; */
id|fdc_prec_code
op_assign
(paren
(paren
id|fdc_precomp
op_plus
l_int|21
)paren
op_div
l_int|42
)paren
op_lshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|fdc_prec_code
op_eq
l_int|0
op_logical_or
id|fdc_prec_code
OG
(paren
l_int|6
op_lshift
l_int|2
)paren
)paren
(brace
id|fdc_prec_code
op_assign
l_int|7
op_lshift
l_int|2
suffix:semicolon
)brace
id|fdc_update_dsr
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*  Reprogram the 82078 registers to use Data Rate Table 1 on all drives.&n; */
DECL|function|fdc_set_drive_specs
r_void
id|fdc_set_drive_specs
c_func
(paren
r_void
)paren
(brace
id|__u8
id|cmd
(braket
)braket
op_assign
(brace
id|FDC_DRIVE_SPEC
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xc0
)brace
suffix:semicolon
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;Setting of drive specs called&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc.type
op_ge
id|i82078_1
)paren
(brace
id|cmd
(braket
l_int|1
)braket
op_assign
(paren
l_int|0
op_lshift
l_int|5
)paren
op_or
(paren
l_int|2
op_lshift
l_int|2
)paren
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
(paren
l_int|1
op_lshift
l_int|5
)paren
op_or
(paren
l_int|2
op_lshift
l_int|2
)paren
suffix:semicolon
id|cmd
(braket
l_int|3
)braket
op_assign
(paren
l_int|2
op_lshift
l_int|5
)paren
op_or
(paren
l_int|2
op_lshift
l_int|2
)paren
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
(paren
l_int|3
op_lshift
l_int|5
)paren
op_or
(paren
l_int|2
op_lshift
l_int|2
)paren
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|cmd
comma
id|NR_ITEMS
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;Setting of drive specs failed&quot;
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/* Select clock for fdc, must correspond with tape drive setting !&n; * This also influences the fdc timing so we must adjust some values.&n; */
DECL|function|fdc_set_data_rate
r_int
id|fdc_set_data_rate
c_func
(paren
r_int
id|rate
)paren
(brace
r_int
id|bad_rate
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/* Select clock for fdc, must correspond with tape drive setting !&n;&t; * This also influences the fdc timing so we must adjust some values.&n;&t; */
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;new rate = %d&quot;
comma
id|rate
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rate
)paren
(brace
r_case
l_int|250
suffix:colon
id|fdc_rate_code
op_assign
id|fdc_data_rate_250
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|500
suffix:colon
id|fdc_rate_code
op_assign
id|fdc_data_rate_500
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1000
suffix:colon
r_if
c_cond
(paren
id|fdc.type
OL
id|i82077
)paren
(brace
id|bad_rate
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|fdc_rate_code
op_assign
id|fdc_data_rate_1000
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|2000
suffix:colon
r_if
c_cond
(paren
id|fdc.type
OL
id|i82078_1
)paren
(brace
id|bad_rate
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|fdc_rate_code
op_assign
id|fdc_data_rate_2000
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|bad_rate
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bad_rate
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_fdc_dma
comma
l_string|&quot;%d is not a valid data rate&quot;
comma
id|rate
)paren
suffix:semicolon
)brace
id|fdc_data_rate
op_assign
id|rate
suffix:semicolon
id|fdc_update_dsr
c_func
(paren
)paren
suffix:semicolon
id|fdc_set_seek_rate
c_func
(paren
id|fdc_seek_rate
)paren
suffix:semicolon
multiline_comment|/* clock changed! */
id|ftape_udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  keep the unit select if keep_select is != 0,&n; */
DECL|function|fdc_dor_reset
r_static
r_void
id|fdc_dor_reset
c_func
(paren
r_int
id|keep_select
)paren
(brace
id|__u8
id|fdc_ctl
op_assign
id|ft_drive_sel
suffix:semicolon
r_if
c_cond
(paren
id|keep_select
op_ne
l_int|0
)paren
(brace
id|fdc_ctl
op_or_assign
id|FDC_DMA_MODE
suffix:semicolon
r_if
c_cond
(paren
id|ftape_motor
)paren
(brace
id|fdc_ctl
op_or_assign
id|FDC_MOTOR_0
op_lshift
id|ft_drive_sel
suffix:semicolon
)brace
)brace
id|ftape_udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* ??? but seems to be necessary */
r_if
c_cond
(paren
id|ft_mach2
)paren
(brace
id|outb_p
c_func
(paren
id|fdc_ctl
op_amp
l_int|0x0f
comma
id|fdc.dor
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|fdc_ctl
comma
id|fdc.dor2
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb_p
c_func
(paren
id|fdc_ctl
comma
id|fdc.dor
)paren
suffix:semicolon
)brace
id|fdc_usec_wait
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* delay &gt;= 14 fdc clocks */
r_if
c_cond
(paren
id|keep_select
op_eq
l_int|0
)paren
(brace
id|fdc_ctl
op_assign
l_int|0
suffix:semicolon
)brace
id|fdc_ctl
op_or_assign
id|FDC_RESET_NOT
suffix:semicolon
r_if
c_cond
(paren
id|ft_mach2
)paren
(brace
id|outb_p
c_func
(paren
id|fdc_ctl
op_amp
l_int|0x0f
comma
id|fdc.dor
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|fdc_ctl
comma
id|fdc.dor2
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb_p
c_func
(paren
id|fdc_ctl
comma
id|fdc.dor
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*      Reset the floppy disk controller. Leave the ftape_unit selected.&n; */
DECL|function|fdc_reset
r_void
id|fdc_reset
c_func
(paren
r_void
)paren
(brace
r_int
id|st0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|dummy
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|fdc_dor_reset
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* keep unit selected */
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
multiline_comment|/*  maybe the cli()/sti() pair is not necessary, BUT:&n;&t; *  the following line MUST be here. Otherwise fdc_interrupt_wait()&n;&t; *  won&squot;t wait. Note that fdc_reset() is called from &n;&t; *  ftape_dumb_stop() when the fdc is busy transferring data. In this&n;&t; *  case fdc_isr() MOST PROBABLY sets ft_interrupt_seen, and tries&n;&t; *  to get the result bytes from the fdc etc. CLASH.&n;&t; */
id|ft_interrupt_seen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*  Program data rate&n;&t; */
id|fdc_update_dsr
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* restore data rate and precomp */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;         *&t;Wait for first polling cycle to complete&n;&t; */
r_if
c_cond
(paren
id|fdc_interrupt_wait
c_func
(paren
l_int|1
op_star
id|FT_SECOND
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;no drive polling interrupt!&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* clear all disk-changed statuses */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|fdc_sense_interrupt_status
c_func
(paren
op_amp
id|st0
comma
op_amp
id|dummy
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;sense failed for %d&quot;
comma
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
id|ft_drive_sel
)paren
(brace
id|ftape_current_cylinder
op_assign
id|dummy
suffix:semicolon
)brace
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;drive polling completed&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         *&t;SPECIFY COMMAND&n;&t; */
id|fdc_set_seek_rate
c_func
(paren
id|fdc_seek_rate
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;DRIVE SPECIFICATION COMMAND (if fdc type known)&n;&t; */
r_if
c_cond
(paren
id|fdc.type
op_ge
id|i82078_1
)paren
(brace
id|fdc_set_drive_specs
c_func
(paren
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
macro_line|#if !defined(CLK_48MHZ)
DECL|macro|CLK_48MHZ
macro_line|# define CLK_48MHZ 1
macro_line|#endif
multiline_comment|/*  When we&squot;re done, put the fdc into reset mode so that the regular&n; *  floppy disk driver will figure out that something is wrong and&n; *  initialize the controller the way it wants.&n; */
DECL|function|fdc_disable
r_void
id|fdc_disable
c_func
(paren
r_void
)paren
(brace
id|__u8
id|cmd1
(braket
)braket
op_assign
(brace
id|FDC_CONFIGURE
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|__u8
id|cmd2
(braket
)braket
op_assign
(brace
id|FDC_LOCK
)brace
suffix:semicolon
id|__u8
id|cmd3
(braket
)braket
op_assign
(brace
id|FDC_UNLOCK
)brace
suffix:semicolon
id|__u8
id|stat
(braket
l_int|1
)braket
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fdc_fifo_locked
)paren
(brace
id|fdc_reset
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdc_issue_command
c_func
(paren
id|cmd3
comma
l_int|1
comma
id|stat
comma
l_int|1
)paren
OL
l_int|0
op_logical_or
id|stat
(braket
l_int|0
)braket
op_ne
l_int|0x00
)paren
(brace
id|fdc_dor_reset
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
multiline_comment|/**/
comma
id|ft_t_bug
comma
l_string|&quot;couldn&squot;t unlock fifo, configuration remains changed&quot;
)paren
suffix:semicolon
)brace
id|fdc_fifo_locked
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|CLK_48MHZ
op_logical_and
id|fdc.type
op_ge
id|i82078
)paren
(brace
id|cmd1
(braket
l_int|0
)braket
op_or_assign
id|FDC_CLK48_BIT
suffix:semicolon
)brace
id|cmd1
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|fdc_fifo_state
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x20
)paren
op_plus
(paren
id|fdc_fifo_thr
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc_command
c_func
(paren
id|cmd1
comma
id|NR_ITEMS
c_func
(paren
id|cmd1
)paren
)paren
OL
l_int|0
)paren
(brace
id|fdc_dor_reset
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
multiline_comment|/**/
comma
id|ft_t_bug
comma
l_string|&quot;couldn&squot;t reconfigure fifo to old state&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdc_lock_state
op_logical_and
id|fdc_issue_command
c_func
(paren
id|cmd2
comma
l_int|1
comma
id|stat
comma
l_int|1
)paren
OL
l_int|0
)paren
(brace
id|fdc_dor_reset
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
multiline_comment|/**/
comma
id|ft_t_bug
comma
l_string|&quot;couldn&squot;t lock old state again&quot;
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;fifo restored: %sabled, thr. %d, %slocked&quot;
comma
id|fdc_fifo_state
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
comma
id|fdc_fifo_thr
comma
(paren
id|fdc_lock_state
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;not &quot;
)paren
suffix:semicolon
id|fdc_dor_reset
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*      Specify FDC seek-rate (milliseconds)&n; */
DECL|function|fdc_set_seek_rate
r_int
id|fdc_set_seek_rate
c_func
(paren
r_int
id|seek_rate
)paren
(brace
multiline_comment|/* set step rate, dma mode, and minimal head load and unload times&n;&t; */
id|__u8
id|in
(braket
l_int|3
)braket
op_assign
(brace
id|FDC_SPECIFY
comma
l_int|1
comma
(paren
l_int|1
op_lshift
l_int|1
)paren
)brace
suffix:semicolon
id|fdc_seek_rate
op_assign
id|seek_rate
suffix:semicolon
id|in
(braket
l_int|1
)braket
op_or_assign
(paren
l_int|16
op_minus
(paren
id|fdc_data_rate
op_star
id|fdc_seek_rate
)paren
op_div
l_int|500
)paren
op_lshift
l_int|4
suffix:semicolon
r_return
id|fdc_command
c_func
(paren
id|in
comma
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/*      Sense drive status: get unit&squot;s drive status (ST3)&n; */
DECL|function|fdc_sense_drive_status
r_int
id|fdc_sense_drive_status
c_func
(paren
r_int
op_star
id|st3
)paren
(brace
id|__u8
id|out
(braket
l_int|2
)braket
suffix:semicolon
id|__u8
id|in
(braket
l_int|1
)braket
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|out
(braket
l_int|0
)braket
op_assign
id|FDC_SENSED
suffix:semicolon
id|out
(braket
l_int|1
)braket
op_assign
id|ft_drive_sel
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_issue_command
c_func
(paren
id|out
comma
l_int|2
comma
id|in
comma
l_int|1
)paren
comma
)paren
suffix:semicolon
op_star
id|st3
op_assign
id|in
(braket
l_int|0
)braket
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      Sense Interrupt Status command:&n; *      should be issued at the end of each seek.&n; *      get ST0 and current cylinder.&n; */
DECL|function|fdc_sense_interrupt_status
r_int
id|fdc_sense_interrupt_status
c_func
(paren
r_int
op_star
id|st0
comma
r_int
op_star
id|current_cylinder
)paren
(brace
id|__u8
id|out
(braket
l_int|1
)braket
suffix:semicolon
id|__u8
id|in
(braket
l_int|2
)braket
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|out
(braket
l_int|0
)braket
op_assign
id|FDC_SENSEI
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_issue_command
c_func
(paren
id|out
comma
l_int|1
comma
id|in
comma
l_int|2
)paren
comma
)paren
suffix:semicolon
op_star
id|st0
op_assign
id|in
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|current_cylinder
op_assign
id|in
(braket
l_int|1
)braket
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      step to track&n; */
DECL|function|fdc_seek
r_int
id|fdc_seek
c_func
(paren
r_int
id|track
)paren
(brace
id|__u8
id|out
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|st0
comma
id|pcn
suffix:semicolon
macro_line|#ifdef TESTING
r_int
r_int
id|time
suffix:semicolon
macro_line|#endif
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|out
(braket
l_int|0
)braket
op_assign
id|FDC_SEEK
suffix:semicolon
id|out
(braket
l_int|1
)braket
op_assign
id|ft_drive_sel
suffix:semicolon
id|out
(braket
l_int|2
)braket
op_assign
id|track
suffix:semicolon
macro_line|#ifdef TESTING
id|time
op_assign
id|ftape_timestamp
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*  We really need this command to work !&n;&t; */
id|ft_seek_completed
op_assign
l_int|0
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_command
c_func
(paren
id|out
comma
l_int|3
)paren
comma
id|fdc_reset
c_func
(paren
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;destination was: %d, resetting FDC...&quot;
comma
id|track
)paren
)paren
suffix:semicolon
multiline_comment|/*    Handle interrupts until ft_seek_completed or timeout.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|fdc_interrupt_wait
c_func
(paren
l_int|2
op_star
id|FT_SECOND
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_seek_completed
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|fdc_sense_interrupt_status
c_func
(paren
op_amp
id|st0
comma
op_amp
id|pcn
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st0
op_amp
id|ST0_SEEK_END
)paren
op_eq
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;no seek-end after seek completion !??&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
macro_line|#ifdef TESTING
id|time
op_assign
id|ftape_timediff
c_func
(paren
id|time
comma
id|ftape_timestamp
c_func
(paren
)paren
)paren
op_div
id|ABS
c_func
(paren
id|track
op_minus
id|ftape_current_cylinder
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|time
template_param
l_int|3100
)paren
op_logical_and
id|ABS
c_func
(paren
id|track
op_minus
id|ftape_current_cylinder
)paren
OG
l_int|5
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Wrong FDC STEP interval: %d usecs (%d)&quot;
comma
id|time
comma
id|track
op_minus
id|ftape_current_cylinder
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*    Verify whether we issued the right tape command.&n;&t; */
multiline_comment|/* Verify that we seek to the proper track. */
r_if
c_cond
(paren
id|pcn
op_ne
id|track
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;bad seek..&quot;
)paren
suffix:semicolon
)brace
id|ftape_current_cylinder
op_assign
id|track
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      Recalibrate and wait until home.&n; */
DECL|function|fdc_recalibrate
r_int
id|fdc_recalibrate
c_func
(paren
r_void
)paren
(brace
id|__u8
id|out
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|st0
suffix:semicolon
r_int
id|pcn
suffix:semicolon
r_int
id|retry
suffix:semicolon
r_int
id|old_seek_rate
op_assign
id|fdc_seek_rate
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_set_seek_rate
c_func
(paren
l_int|6
)paren
comma
)paren
suffix:semicolon
id|out
(braket
l_int|0
)braket
op_assign
id|FDC_RECAL
suffix:semicolon
id|out
(braket
l_int|1
)braket
op_assign
id|ft_drive_sel
suffix:semicolon
id|ft_seek_completed
op_assign
l_int|0
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_command
c_func
(paren
id|out
comma
l_int|2
)paren
comma
)paren
suffix:semicolon
multiline_comment|/*    Handle interrupts until ft_seek_completed or timeout.&n;&t; */
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
op_increment
id|retry
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|fdc_interrupt_wait
c_func
(paren
l_int|2
op_star
id|FT_SECOND
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_seek_completed
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|fdc_sense_interrupt_status
c_func
(paren
op_amp
id|st0
comma
op_amp
id|pcn
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st0
op_amp
id|ST0_SEEK_END
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retry
OL
l_int|1
)paren
(brace
r_continue
suffix:semicolon
multiline_comment|/* some drives/fdc&squot;s&n;&t;&t;&t;&t;&t;&t;   * give an extra interrupt&n;&t;&t;&t;&t;&t;&t;   */
)brace
r_else
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;no seek-end after seek completion !??&quot;
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
)brace
id|ftape_current_cylinder
op_assign
id|pcn
suffix:semicolon
r_if
c_cond
(paren
id|pcn
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;failed: resulting track = %d&quot;
comma
id|pcn
)paren
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|fdc_set_seek_rate
c_func
(paren
id|old_seek_rate
)paren
comma
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|variable|perpend_mode
r_static
r_int
id|perpend_mode
suffix:semicolon
multiline_comment|/* set if fdc is in perpendicular mode */
DECL|function|perpend_off
r_static
r_int
id|perpend_off
c_func
(paren
r_void
)paren
(brace
id|__u8
id|perpend
(braket
)braket
op_assign
(brace
id|FDC_PERPEND
comma
l_int|0x00
)brace
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|perpend_mode
)paren
(brace
multiline_comment|/* Turn off perpendicular mode */
id|perpend
(braket
l_int|1
)braket
op_assign
l_int|0x80
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_command
c_func
(paren
id|perpend
comma
l_int|2
)paren
comma
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;Perpendicular mode exit failed!&quot;
)paren
)paren
suffix:semicolon
id|perpend_mode
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|handle_perpend
r_static
r_int
id|handle_perpend
c_func
(paren
r_int
id|segment_id
)paren
(brace
id|__u8
id|perpend
(braket
)braket
op_assign
(brace
id|FDC_PERPEND
comma
l_int|0x00
)brace
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/* When writing QIC-3020 tapes, turn on perpendicular mode&n;&t; * if tape is moving in forward direction (even tracks).&n;&t; */
r_if
c_cond
(paren
id|ft_qic_std
op_eq
id|QIC_TAPE_QIC3020
op_logical_and
(paren
(paren
id|segment_id
op_div
id|ft_segments_per_track
)paren
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*  FIXME: some i82077 seem to support perpendicular mode as&n; *  well. &n; */
macro_line|#if 0
r_if
c_cond
(paren
id|fdc.type
OL
id|i82077AA
)paren
(brace
)brace
macro_line|#else
r_if
c_cond
(paren
id|fdc.type
OL
id|i82077
op_logical_and
id|ft_data_rate
OL
l_int|1000
)paren
(brace
macro_line|#endif
multiline_comment|/*  fdc does not support perpendicular mode: complain &n;&t;&t;&t; */
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;Your FDC does not support QIC-3020.&quot;
)paren
suffix:semicolon
)brace
id|perpend
(braket
l_int|1
)braket
op_assign
l_int|0x03
multiline_comment|/* 0x83 + (0x4 &lt;&lt; ft_drive_sel) */
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_command
c_func
(paren
id|perpend
comma
l_int|2
)paren
comma
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;Perpendicular mode entry failed!&quot;
)paren
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;Perpendicular mode set&quot;
)paren
suffix:semicolon
id|perpend_mode
op_assign
l_int|1
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
id|perpend_off
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fdc_setup_dma
r_static
r_inline
r_void
id|fdc_setup_dma
c_func
(paren
r_char
id|mode
comma
r_volatile
r_void
op_star
id|addr
comma
r_int
r_int
id|count
)paren
(brace
multiline_comment|/* Program the DMA controller.&n;&t; */
id|disable_dma
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|fdc.dma
comma
id|mode
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|fdc.dma
comma
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
id|addr
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|fdc.dma
comma
id|count
)paren
suffix:semicolon
macro_line|#ifdef GCC_2_4_5_BUG
multiline_comment|/*  This seemingly stupid construction confuses the gcc-2.4.5&n;&t; *  code generator enough to create correct code.&n;&t; */
r_if
c_cond
(paren
l_int|1
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ftape_udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|enable_dma
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
)brace
multiline_comment|/*  Setup fdc and dma for formatting the next segment&n; */
DECL|function|fdc_setup_formatting
r_int
id|fdc_setup_formatting
c_func
(paren
id|buffer_struct
op_star
id|buff
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__u8
id|out
(braket
l_int|6
)braket
op_assign
(brace
id|FDC_FORMAT
comma
l_int|0x00
comma
l_int|3
comma
l_int|4
op_star
id|FT_SECTORS_PER_SEGMENT
comma
l_int|0x00
comma
l_int|0x6b
)brace
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|handle_perpend
c_func
(paren
id|buff-&gt;segment_id
)paren
comma
)paren
suffix:semicolon
multiline_comment|/* Program the DMA controller.&n;&t; */
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;phys. addr. = %lx&quot;
comma
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
id|buff-&gt;ptr
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* could be called from ISR ! */
id|fdc_setup_dma
c_func
(paren
id|DMA_MODE_WRITE
comma
id|buff-&gt;ptr
comma
id|FT_SECTORS_PER_SEGMENT
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Issue FDC command to start reading/writing.&n;&t; */
id|out
(braket
l_int|1
)braket
op_assign
id|ft_drive_sel
suffix:semicolon
id|out
(braket
l_int|4
)braket
op_assign
id|buff-&gt;gap3
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_setup_error
op_assign
id|fdc_command
c_func
(paren
id|out
comma
r_sizeof
(paren
id|out
)paren
)paren
comma
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      Setup Floppy Disk Controller and DMA to read or write the next cluster&n; *      of good sectors from or to the current segment.&n; */
DECL|function|fdc_setup_read_write
r_int
id|fdc_setup_read_write
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
id|__u8
id|operation
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|__u8
id|out
(braket
l_int|9
)braket
suffix:semicolon
r_int
id|dma_mode
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|operation
)paren
(brace
r_case
id|FDC_VERIFY
suffix:colon
r_if
c_cond
(paren
id|fdc.type
OL
id|i82077
)paren
(brace
id|operation
op_assign
id|FDC_READ
suffix:semicolon
)brace
r_case
id|FDC_READ
suffix:colon
r_case
id|FDC_READ_DELETED
suffix:colon
id|dma_mode
op_assign
id|DMA_MODE_READ
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;xfer %d sectors to 0x%p&quot;
comma
id|buff-&gt;sector_count
comma
id|buff-&gt;ptr
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|perpend_off
c_func
(paren
)paren
comma
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDC_WRITE_DELETED
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;deleting segment %d&quot;
comma
id|buff-&gt;segment_id
)paren
suffix:semicolon
r_case
id|FDC_WRITE
suffix:colon
id|dma_mode
op_assign
id|DMA_MODE_WRITE
suffix:semicolon
multiline_comment|/* When writing QIC-3020 tapes, turn on perpendicular mode&n;&t;&t; * if tape is moving in forward direction (even tracks).&n;&t;&t; */
id|TRACE_CATCH
c_func
(paren
id|handle_perpend
c_func
(paren
id|buff-&gt;segment_id
)paren
comma
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;xfer %d sectors from 0x%p&quot;
comma
id|buff-&gt;sector_count
comma
id|buff-&gt;ptr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_bug
comma
l_string|&quot;bug: illegal operation parameter&quot;
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;phys. addr. = %lx&quot;
comma
id|virt_to_bus
c_func
(paren
(paren
r_void
op_star
)paren
id|buff-&gt;ptr
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* could be called from ISR ! */
r_if
c_cond
(paren
id|operation
op_ne
id|FDC_VERIFY
)paren
(brace
id|fdc_setup_dma
c_func
(paren
id|dma_mode
comma
id|buff-&gt;ptr
comma
id|FT_SECTOR_SIZE
op_star
id|buff-&gt;sector_count
)paren
suffix:semicolon
)brace
multiline_comment|/* Issue FDC command to start reading/writing.&n;&t; */
id|out
(braket
l_int|0
)braket
op_assign
id|operation
suffix:semicolon
id|out
(braket
l_int|1
)braket
op_assign
id|ft_drive_sel
suffix:semicolon
id|out
(braket
l_int|2
)braket
op_assign
id|buff-&gt;cyl
suffix:semicolon
id|out
(braket
l_int|3
)braket
op_assign
id|buff-&gt;head
suffix:semicolon
id|out
(braket
l_int|4
)braket
op_assign
id|buff-&gt;sect
op_plus
id|buff-&gt;sector_offset
suffix:semicolon
id|out
(braket
l_int|5
)braket
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* Sector size of 1K. */
id|out
(braket
l_int|6
)braket
op_assign
id|out
(braket
l_int|4
)braket
op_plus
id|buff-&gt;sector_count
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* last sector */
id|out
(braket
l_int|7
)braket
op_assign
l_int|109
suffix:semicolon
multiline_comment|/* Gap length. */
id|out
(braket
l_int|8
)braket
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* No limit to transfer size. */
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;C: 0x%02x, H: 0x%02x, R: 0x%02x, cnt: 0x%02x&quot;
comma
id|out
(braket
l_int|2
)braket
comma
id|out
(braket
l_int|3
)braket
comma
id|out
(braket
l_int|4
)braket
comma
id|out
(braket
l_int|6
)braket
op_minus
id|out
(braket
l_int|4
)braket
op_plus
l_int|1
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_setup_error
op_assign
id|fdc_command
c_func
(paren
id|out
comma
l_int|9
)paren
comma
id|fdc_mode
op_assign
id|fdc_idle
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|fdc_fifo_threshold
r_int
id|fdc_fifo_threshold
c_func
(paren
id|__u8
id|threshold
comma
r_int
op_star
id|fifo_state
comma
r_int
op_star
id|lock_state
comma
r_int
op_star
id|fifo_thr
)paren
(brace
r_const
id|__u8
id|cmd0
(braket
)braket
op_assign
(brace
id|FDC_DUMPREGS
)brace
suffix:semicolon
id|__u8
id|cmd1
(braket
)braket
op_assign
(brace
id|FDC_CONFIGURE
comma
l_int|0
comma
(paren
l_int|0x0f
op_amp
(paren
id|threshold
op_minus
l_int|1
)paren
)paren
comma
l_int|0
)brace
suffix:semicolon
r_const
id|__u8
id|cmd2
(braket
)braket
op_assign
(brace
id|FDC_LOCK
)brace
suffix:semicolon
r_const
id|__u8
id|cmd3
(braket
)braket
op_assign
(brace
id|FDC_UNLOCK
)brace
suffix:semicolon
id|__u8
id|reg
(braket
l_int|10
)braket
suffix:semicolon
id|__u8
id|stat
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CLK_48MHZ
op_logical_and
id|fdc.type
op_ge
id|i82078
)paren
(brace
id|cmd1
(braket
l_int|0
)braket
op_or_assign
id|FDC_CLK48_BIT
suffix:semicolon
)brace
multiline_comment|/*  Dump fdc internal registers for examination&n;&t; */
id|TRACE_CATCH
c_func
(paren
id|fdc_command
c_func
(paren
id|cmd0
comma
id|NR_ITEMS
c_func
(paren
id|cmd0
)paren
)paren
comma
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;dumpreg cmd failed, fifo unchanged&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*  Now read fdc internal registers from fifo&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
r_int
)paren
id|NR_ITEMS
c_func
(paren
id|reg
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|fdc_read
c_func
(paren
op_amp
id|reg
(braket
id|i
)braket
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_fdc_dma
comma
l_string|&quot;Register %d = 0x%02x&quot;
comma
id|i
comma
id|reg
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fifo_state
op_logical_and
id|lock_state
op_logical_and
id|fifo_thr
)paren
(brace
op_star
id|fifo_state
op_assign
(paren
id|reg
(braket
l_int|8
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0
suffix:semicolon
op_star
id|lock_state
op_assign
id|reg
(braket
l_int|7
)braket
op_amp
l_int|0x80
suffix:semicolon
op_star
id|fifo_thr
op_assign
l_int|1
op_plus
(paren
id|reg
(braket
l_int|8
)braket
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;original fifo state: %sabled, threshold %d, %slocked&quot;
comma
(paren
(paren
id|reg
(braket
l_int|8
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
comma
l_int|1
op_plus
(paren
id|reg
(braket
l_int|8
)braket
op_amp
l_int|0x0f
)paren
comma
(paren
id|reg
(braket
l_int|7
)braket
op_amp
l_int|0x80
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;not &quot;
)paren
suffix:semicolon
multiline_comment|/*  If fdc is already locked, unlock it first ! */
r_if
c_cond
(paren
id|reg
(braket
l_int|7
)braket
op_amp
l_int|0x80
)paren
(brace
id|fdc_ready_wait
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_issue_command
c_func
(paren
id|cmd3
comma
id|NR_ITEMS
c_func
(paren
id|cmd3
)paren
comma
op_amp
id|stat
comma
l_int|1
)paren
comma
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;FDC unlock command failed, &quot;
l_string|&quot;configuration unchanged&quot;
)paren
)paren
suffix:semicolon
)brace
id|fdc_fifo_locked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*  Enable fifo and set threshold at xx bytes to allow a&n;&t; *  reasonably large latency and reduce number of dma bursts.&n;&t; */
id|fdc_ready_wait
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
op_assign
id|fdc_command
c_func
(paren
id|cmd1
comma
id|NR_ITEMS
c_func
(paren
id|cmd1
)paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;configure cmd failed, fifo unchanged&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*  Now lock configuration so reset will not change it&n;&t; */
r_if
c_cond
(paren
id|fdc_issue_command
c_func
(paren
id|cmd2
comma
id|NR_ITEMS
c_func
(paren
id|cmd2
)paren
comma
op_amp
id|stat
comma
l_int|1
)paren
OL
l_int|0
op_logical_or
id|stat
op_ne
l_int|0x10
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_bug
comma
l_string|&quot;FDC lock command failed, stat = 0x%02x&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
id|fdc_fifo_locked
op_assign
l_int|1
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|fdc_fifo_enable
r_static
r_int
id|fdc_fifo_enable
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc_fifo_locked
)paren
(brace
id|TRACE_ABORT
c_func
(paren
l_int|0
comma
id|ft_t_warn
comma
l_string|&quot;Fifo not enabled because locked&quot;
)paren
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|fdc_fifo_threshold
c_func
(paren
id|ft_fdc_threshold
multiline_comment|/* bytes */
comma
op_amp
id|fdc_fifo_state
comma
op_amp
id|fdc_lock_state
comma
op_amp
id|fdc_fifo_thr
)paren
comma
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_fifo_threshold
c_func
(paren
id|ft_fdc_threshold
multiline_comment|/* bytes */
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
comma
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*   Determine fd controller type &n; */
DECL|variable|fdc_save_state
r_static
id|__u8
id|fdc_save_state
(braket
l_int|2
)braket
suffix:semicolon
DECL|function|fdc_probe
r_int
id|fdc_probe
c_func
(paren
r_void
)paren
(brace
id|__u8
id|cmd
(braket
l_int|1
)braket
suffix:semicolon
id|__u8
id|stat
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* must be able to hold dumpregs &amp; save results */
r_int
id|i
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/*  Try to find out what kind of fd controller we have to deal with&n;&t; *  Scheme borrowed from floppy driver:&n;&t; *  first try if FDC_DUMPREGS command works&n;&t; *  (this indicates that we have a 82072 or better)&n;&t; *  then try the FDC_VERSION command (82072 doesn&squot;t support this)&n;&t; *  then try the FDC_UNLOCK command (some older 82077&squot;s don&squot;t support this)&n;&t; *  then try the FDC_PARTID command (82078&squot;s support this)&n;&t; */
id|cmd
(braket
l_int|0
)braket
op_assign
id|FDC_DUMPREGS
suffix:semicolon
r_if
c_cond
(paren
id|fdc_issue_command
c_func
(paren
id|cmd
comma
l_int|1
comma
id|stat
comma
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
id|no_fdc
comma
id|ft_t_bug
comma
l_string|&quot;No FDC found&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
(brace
multiline_comment|/* invalid command: must be pre 82072 */
id|TRACE_ABORT
c_func
(paren
id|i8272
comma
id|ft_t_warn
comma
l_string|&quot;Type 8272A/765A compatible FDC found&quot;
)paren
suffix:semicolon
)brace
id|fdc_result
c_func
(paren
op_amp
id|stat
(braket
l_int|1
)braket
comma
l_int|9
)paren
suffix:semicolon
id|fdc_save_state
(braket
l_int|0
)braket
op_assign
id|stat
(braket
l_int|7
)braket
suffix:semicolon
id|fdc_save_state
(braket
l_int|1
)braket
op_assign
id|stat
(braket
l_int|8
)braket
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|FDC_VERSION
suffix:semicolon
r_if
c_cond
(paren
id|fdc_issue_command
c_func
(paren
id|cmd
comma
l_int|1
comma
id|stat
comma
l_int|1
)paren
OL
l_int|0
op_logical_or
id|stat
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
(brace
id|TRACE_ABORT
c_func
(paren
id|i8272
comma
id|ft_t_warn
comma
l_string|&quot;Type 82072 FDC found&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|stat
op_ne
l_int|0x90
)paren
(brace
id|TRACE_ABORT
c_func
(paren
id|i8272
comma
id|ft_t_warn
comma
l_string|&quot;Unknown FDC found&quot;
)paren
suffix:semicolon
)brace
id|cmd
(braket
l_int|0
)braket
op_assign
id|FDC_UNLOCK
suffix:semicolon
r_if
c_cond
(paren
id|fdc_issue_command
c_func
(paren
id|cmd
comma
l_int|1
comma
id|stat
comma
l_int|1
)paren
OL
l_int|0
op_logical_or
id|stat
(braket
l_int|0
)braket
op_ne
l_int|0x00
)paren
(brace
id|TRACE_ABORT
c_func
(paren
id|i8272
comma
id|ft_t_warn
comma
l_string|&quot;Type pre-1991 82077 FDC found, &quot;
l_string|&quot;treating it like a 82072&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdc_save_state
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
(brace
multiline_comment|/* was locked */
id|cmd
(braket
l_int|0
)braket
op_assign
id|FDC_LOCK
suffix:semicolon
multiline_comment|/* restore lock */
(paren
r_void
)paren
id|fdc_issue_command
c_func
(paren
id|cmd
comma
l_int|1
comma
id|stat
comma
l_int|1
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;FDC is already locked&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Test for a i82078 FDC */
id|cmd
(braket
l_int|0
)braket
op_assign
id|FDC_PARTID
suffix:semicolon
r_if
c_cond
(paren
id|fdc_issue_command
c_func
(paren
id|cmd
comma
l_int|1
comma
id|stat
comma
l_int|1
)paren
OL
l_int|0
op_logical_or
id|stat
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
(brace
multiline_comment|/* invalid command: not a i82078xx type FDC */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
id|outb_p
c_func
(paren
id|i
comma
id|fdc.tdr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
id|fdc.tdr
)paren
op_amp
l_int|0x03
)paren
op_ne
id|i
)paren
(brace
id|TRACE_ABORT
c_func
(paren
id|i82077
comma
id|ft_t_warn
comma
l_string|&quot;Type 82077 FDC found&quot;
)paren
suffix:semicolon
)brace
)brace
id|TRACE_ABORT
c_func
(paren
id|i82077AA
comma
id|ft_t_warn
comma
l_string|&quot;Type 82077AA FDC found&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* FDC_PARTID cmd succeeded */
r_switch
c_cond
(paren
id|stat
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
(brace
r_case
l_int|0x0
suffix:colon
multiline_comment|/* i82078SL or i82078-1.  The SL part cannot run at&n;&t;&t; * 2Mbps (the SL and -1 dies are identical; they are&n;&t;&t; * speed graded after production, according to Intel).&n;&t;&t; * Some SL&squot;s can be detected by doing a SAVE cmd and&n;&t;&t; * look at bit 7 of the first byte (the SEL3V# bit).&n;&t;&t; * If it is 0, the part runs off 3Volts, and hence it&n;&t;&t; * is a SL.&n;&t;&t; */
id|cmd
(braket
l_int|0
)braket
op_assign
id|FDC_SAVE
suffix:semicolon
r_if
c_cond
(paren
id|fdc_issue_command
c_func
(paren
id|cmd
comma
l_int|1
comma
id|stat
comma
l_int|16
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;FDC_SAVE failed. Dunno why&quot;
)paren
suffix:semicolon
multiline_comment|/* guess we better claim the fdc to be a i82078 */
id|TRACE_ABORT
c_func
(paren
id|i82078
comma
id|ft_t_warn
comma
l_string|&quot;Type i82078 FDC (i suppose) found&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stat
(braket
l_int|0
)braket
op_amp
id|FDC_SEL3V_BIT
)paren
)paren
(brace
multiline_comment|/* fdc running off 5Volts; Pray that it&squot;s a i82078-1&n;&t;&t;&t; */
id|TRACE_ABORT
c_func
(paren
id|i82078_1
comma
id|ft_t_warn
comma
l_string|&quot;Type i82078-1 or 5Volt i82078SL FDC found&quot;
)paren
suffix:semicolon
)brace
id|TRACE_ABORT
c_func
(paren
id|i82078
comma
id|ft_t_warn
comma
l_string|&quot;Type 3Volt i82078SL FDC (1Mbps) found&quot;
)paren
suffix:semicolon
r_case
l_int|0x1
suffix:colon
r_case
l_int|0x2
suffix:colon
multiline_comment|/* S82078B  */
multiline_comment|/* The &squot;78B  isn&squot;t &squot;78 compatible.  Detect it as a &squot;77AA */
id|TRACE_ABORT
c_func
(paren
id|i82077AA
comma
id|ft_t_warn
comma
l_string|&quot;Type i82077AA FDC found&quot;
)paren
suffix:semicolon
r_case
l_int|0x3
suffix:colon
multiline_comment|/* NSC PC8744 core; used in several super-IO chips */
id|TRACE_ABORT
c_func
(paren
id|i82077AA
comma
id|ft_t_warn
comma
l_string|&quot;Type 82077AA compatible FDC found&quot;
)paren
suffix:semicolon
r_default
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;A previously undetected FDC found&quot;
)paren
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
id|i82077AA
comma
id|ft_t_warn
comma
l_string|&quot;Treating it as a 82077AA. Please report partid= %d&quot;
comma
id|stat
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* switch(stat[ 0] &gt;&gt; 5) */
id|TRACE_EXIT
id|no_fdc
suffix:semicolon
)brace
DECL|function|fdc_request_regions
r_static
r_int
id|fdc_request_regions
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_mach2
op_logical_or
id|ft_probe_fc10
)paren
(brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|fdc.sra
comma
l_int|8
)paren
OL
l_int|0
)paren
(brace
macro_line|#ifndef BROKEN_FLOPPY_DRIVER
id|TRACE_EXIT
op_minus
id|EBUSY
suffix:semicolon
macro_line|#else
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;address 0x%03x occupied (by floppy driver?), using it anyway&quot;
comma
id|fdc.sra
)paren
suffix:semicolon
macro_line|#endif
)brace
id|request_region
c_func
(paren
id|fdc.sra
comma
l_int|8
comma
l_string|&quot;fdc (ft)&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|fdc.sra
comma
l_int|6
)paren
OL
l_int|0
op_logical_or
id|check_region
c_func
(paren
id|fdc.dir
comma
l_int|1
)paren
OL
l_int|0
)paren
(brace
macro_line|#ifndef BROKEN_FLOPPY_DRIVER
id|TRACE_EXIT
op_minus
id|EBUSY
suffix:semicolon
macro_line|#else
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;address 0x%03x occupied (by floppy driver?), using it anyway&quot;
comma
id|fdc.sra
)paren
suffix:semicolon
macro_line|#endif
)brace
id|request_region
c_func
(paren
id|fdc.sra
comma
l_int|6
comma
l_string|&quot;fdc (ft)&quot;
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|fdc.sra
op_plus
l_int|7
comma
l_int|1
comma
l_string|&quot;fdc (ft)&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|fdc_release_regions
r_void
id|fdc_release_regions
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc.sra
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|fdc.dor2
op_ne
l_int|0
)paren
(brace
id|release_region
c_func
(paren
id|fdc.sra
comma
l_int|8
)paren
suffix:semicolon
)brace
r_else
(brace
id|release_region
c_func
(paren
id|fdc.sra
comma
l_int|6
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|fdc.dir
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|fdc_config_regs
r_static
r_int
id|fdc_config_regs
c_func
(paren
r_int
r_int
id|fdc_base
comma
r_int
r_int
id|fdc_irq
comma
r_int
r_int
id|fdc_dma
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|fdc.irq
op_assign
id|fdc_irq
suffix:semicolon
id|fdc.dma
op_assign
id|fdc_dma
suffix:semicolon
id|fdc.sra
op_assign
id|fdc_base
suffix:semicolon
id|fdc.srb
op_assign
id|fdc_base
op_plus
l_int|1
suffix:semicolon
id|fdc.dor
op_assign
id|fdc_base
op_plus
l_int|2
suffix:semicolon
id|fdc.tdr
op_assign
id|fdc_base
op_plus
l_int|3
suffix:semicolon
id|fdc.msr
op_assign
id|fdc.dsr
op_assign
id|fdc_base
op_plus
l_int|4
suffix:semicolon
id|fdc.fifo
op_assign
id|fdc_base
op_plus
l_int|5
suffix:semicolon
id|fdc.dir
op_assign
id|fdc.ccr
op_assign
id|fdc_base
op_plus
l_int|7
suffix:semicolon
id|fdc.dor2
op_assign
(paren
id|ft_mach2
op_logical_or
id|ft_probe_fc10
)paren
ques
c_cond
id|fdc_base
op_plus
l_int|6
suffix:colon
l_int|0
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_request_regions
c_func
(paren
)paren
comma
id|fdc.sra
op_assign
l_int|0
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|fdc_config
r_static
r_int
id|fdc_config
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|already_done
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|already_done
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|fdc_request_regions
c_func
(paren
)paren
comma
)paren
suffix:semicolon
op_star
(paren
id|fdc.hook
)paren
op_assign
id|fdc_isr
suffix:semicolon
multiline_comment|/* hook our handler in */
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_probe_fc10
)paren
(brace
r_int
id|fc_type
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_config_regs
c_func
(paren
id|ft_fdc_base
comma
id|ft_fdc_irq
comma
id|ft_fdc_dma
)paren
comma
)paren
suffix:semicolon
id|fc_type
op_assign
id|fc10_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fc_type
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;FC-%c0 controller found&quot;
comma
l_char|&squot;0&squot;
op_plus
id|fc_type
)paren
suffix:semicolon
id|fdc.type
op_assign
id|fc10
suffix:semicolon
id|fdc.hook
op_assign
op_amp
id|do_ftape
suffix:semicolon
op_star
(paren
id|fdc.hook
)paren
op_assign
id|fdc_isr
suffix:semicolon
multiline_comment|/* hook our handler in */
id|already_done
op_assign
l_int|1
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;FC-10/20 controller not found&quot;
)paren
suffix:semicolon
id|fdc_release_regions
c_func
(paren
)paren
suffix:semicolon
id|fdc.type
op_assign
id|no_fdc
suffix:semicolon
id|ft_probe_fc10
op_assign
l_int|0
suffix:semicolon
id|ft_fdc_base
op_assign
l_int|0x3f0
suffix:semicolon
id|ft_fdc_irq
op_assign
l_int|6
suffix:semicolon
id|ft_fdc_dma
op_assign
l_int|2
suffix:semicolon
)brace
)brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;fdc base: 0x%x, irq: %d, dma: %d&quot;
comma
id|ft_fdc_base
comma
id|ft_fdc_irq
comma
id|ft_fdc_dma
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_config_regs
c_func
(paren
id|ft_fdc_base
comma
id|ft_fdc_irq
comma
id|ft_fdc_dma
)paren
comma
)paren
suffix:semicolon
id|fdc.hook
op_assign
op_amp
id|do_ftape
suffix:semicolon
op_star
(paren
id|fdc.hook
)paren
op_assign
id|fdc_isr
suffix:semicolon
multiline_comment|/* hook our handler in */
id|already_done
op_assign
l_int|1
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_interrupt
r_static
r_void
id|ftape_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
)paren
op_assign
op_star
id|fdc.hook
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
op_star
id|fdc.hook
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|handler
)paren
(brace
id|handler
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;Unexpected ftape interrupt&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|fdc_grab_irq_and_dma
r_int
id|fdc_grab_irq_and_dma
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc.hook
op_eq
op_amp
id|do_ftape
)paren
(brace
multiline_comment|/*  Get fast interrupt handler.&n;&t;&t; */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|fdc.irq
comma
id|ftape_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;ft&quot;
comma
id|ftape_id
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_bug
comma
l_string|&quot;Unable to grab IRQ%d for ftape driver&quot;
comma
id|fdc.irq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|fdc.dma
comma
id|ftape_id
)paren
)paren
(brace
id|free_irq
c_func
(paren
id|fdc.irq
comma
id|ftape_id
)paren
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_bug
comma
l_string|&quot;Unable to grab DMA%d for ftape driver&quot;
comma
id|fdc.dma
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ft_fdc_base
op_ne
l_int|0x3f0
op_logical_and
(paren
id|ft_fdc_dma
op_eq
l_int|2
op_logical_or
id|ft_fdc_irq
op_eq
l_int|6
)paren
)paren
(brace
multiline_comment|/* Using same dma channel or irq as standard fdc, need&n;&t;&t; * to disable the dma-gate on the std fdc. This&n;&t;&t; * couldn&squot;t be done in the floppy driver as some&n;&t;&t; * laptops are using the dma-gate to enter a low power&n;&t;&t; * or even suspended state :-(&n;&t;&t; */
id|outb_p
c_func
(paren
id|FDC_RESET_NOT
comma
l_int|0x3f2
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;DMA-gate on standard fdc disabled&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|fdc_release_irq_and_dma
r_int
id|fdc_release_irq_and_dma
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc.hook
op_eq
op_amp
id|do_ftape
)paren
(brace
id|disable_dma
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
multiline_comment|/* just in case... */
id|free_dma
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|fdc.irq
comma
id|ftape_id
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ft_fdc_base
op_ne
l_int|0x3f0
op_logical_and
(paren
id|ft_fdc_dma
op_eq
l_int|2
op_logical_or
id|ft_fdc_irq
op_eq
l_int|6
)paren
)paren
(brace
multiline_comment|/* Using same dma channel as standard fdc, need to&n;&t;&t; * disable the dma-gate on the std fdc. This couldn&squot;t&n;&t;&t; * be done in the floppy driver as some laptops are&n;&t;&t; * using the dma-gate to enter a low power or even&n;&t;&t; * suspended state :-(&n;&t;&t; */
id|outb_p
c_func
(paren
id|FDC_RESET_NOT
op_or
id|FDC_DMA_MODE
comma
l_int|0x3f2
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;DMA-gate on standard fdc enabled again&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|fdc_init
r_int
id|fdc_init
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/* find a FDC to use */
id|TRACE_CATCH
c_func
(paren
id|fdc_config
c_func
(paren
)paren
comma
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_grab_irq_and_dma
c_func
(paren
)paren
comma
id|fdc_release_regions
c_func
(paren
)paren
)paren
suffix:semicolon
id|ftape_motor
op_assign
l_int|0
suffix:semicolon
id|fdc_catch_stray_interrupts
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* clear number of awainted&n;&t;&t;&t;&t;&t; * stray interrupte &n;&t;&t;&t;&t;&t; */
id|fdc_catch_stray_interrupts
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* one always comes (?) */
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;resetting fdc&quot;
)paren
suffix:semicolon
id|fdc_set_seek_rate
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* use nominal QIC step rate */
id|fdc_reset
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* init fdc &amp; clear track counters */
r_if
c_cond
(paren
id|fdc.type
op_eq
id|no_fdc
)paren
(brace
multiline_comment|/* no FC-10 or FC-20 found */
id|fdc.type
op_assign
id|fdc_probe
c_func
(paren
)paren
suffix:semicolon
id|fdc_reset
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* update with new knowledge */
)brace
r_if
c_cond
(paren
id|fdc.type
op_eq
id|no_fdc
)paren
(brace
id|fdc_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
id|fdc_release_regions
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdc.type
op_ge
id|i82077
)paren
(brace
r_if
c_cond
(paren
id|fdc_fifo_enable
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;couldn&squot;t enable fdc fifo !&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;fdc fifo enabled and locked&quot;
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
eof
