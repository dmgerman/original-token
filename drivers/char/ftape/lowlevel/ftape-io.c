multiline_comment|/*&n; *      Copyright (C) 1993-1996 Bas Laarhoven,&n; *                (C) 1996      Kai Harrekilde-Petersen,&n; *                (C) 1997      Claus-Justus Heine.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/lowlevel/ftape-io.c,v $&n; * $Revision: 1.4 $&n; * $Date: 1997/11/11 14:02:36 $&n; *&n; *      This file contains the general control functions for the&n; *      QIC-40/80/3010/3020 floppy-tape driver &quot;ftape&quot; for Linux.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/mtio.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;linux/qic117.h&gt;
macro_line|#include &quot;../lowlevel/ftape-tracing.h&quot;
macro_line|#include &quot;../lowlevel/fdc-io.h&quot;
macro_line|#include &quot;../lowlevel/ftape-io.h&quot;
macro_line|#include &quot;../lowlevel/ftape-ctl.h&quot;
macro_line|#include &quot;../lowlevel/ftape-rw.h&quot;
macro_line|#include &quot;../lowlevel/ftape-write.h&quot;
macro_line|#include &quot;../lowlevel/ftape-read.h&quot;
macro_line|#include &quot;../lowlevel/ftape-init.h&quot;
macro_line|#include &quot;../lowlevel/ftape-calibr.h&quot;
multiline_comment|/*      Global vars.&n; */
multiline_comment|/* NOTE: sectors start numbering at 1, all others at 0 ! */
DECL|variable|ftape_timeout
id|ft_timeout_table
id|ftape_timeout
suffix:semicolon
DECL|variable|ftape_tape_len
r_int
r_int
id|ftape_tape_len
suffix:semicolon
DECL|variable|ftape_current_command
r_volatile
id|qic117_cmd_t
id|ftape_current_command
suffix:semicolon
DECL|variable|qic117_cmds
r_const
r_struct
id|qic117_command_table
id|qic117_cmds
(braket
)braket
op_assign
id|QIC117_COMMANDS
suffix:semicolon
DECL|variable|ftape_might_be_off_track
r_int
id|ftape_might_be_off_track
suffix:semicolon
multiline_comment|/*      Local vars.&n; */
DECL|variable|diagnostic_mode
r_static
r_int
id|diagnostic_mode
suffix:semicolon
DECL|variable|ftape_udelay_count
r_static
r_int
r_int
id|ftape_udelay_count
suffix:semicolon
DECL|variable|ftape_udelay_time
r_static
r_int
r_int
id|ftape_udelay_time
suffix:semicolon
DECL|function|ftape_udelay
r_void
id|ftape_udelay
c_func
(paren
r_int
r_int
id|usecs
)paren
(brace
r_volatile
r_int
id|count
op_assign
(paren
id|ftape_udelay_count
op_star
id|usecs
op_plus
id|ftape_udelay_count
op_minus
l_int|1
)paren
op_div
id|ftape_udelay_time
suffix:semicolon
r_volatile
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
)brace
)brace
DECL|function|ftape_udelay_calibrate
r_void
id|ftape_udelay_calibrate
c_func
(paren
r_void
)paren
(brace
id|ftape_calibrate
c_func
(paren
l_string|&quot;ftape_udelay&quot;
comma
id|ftape_udelay
comma
op_amp
id|ftape_udelay_count
comma
op_amp
id|ftape_udelay_time
)paren
suffix:semicolon
)brace
multiline_comment|/*      Delay (msec) routine.&n; */
DECL|function|ftape_sleep
r_void
id|ftape_sleep
c_func
(paren
r_int
r_int
id|time
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|time
op_mul_assign
l_int|1000
suffix:semicolon
multiline_comment|/* msecs -&gt; usecs */
r_if
c_cond
(paren
id|time
OL
id|FT_USPT
)paren
(brace
multiline_comment|/*  Time too small for scheduler, do a busy wait ! */
id|ftape_udelay
c_func
(paren
id|time
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|timeout
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|ticks
op_assign
(paren
id|time
op_plus
id|FT_USPT
op_minus
l_int|1
)paren
op_div
id|FT_USPT
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_any
comma
l_string|&quot;%d msec, %d ticks&quot;
comma
id|time
op_div
l_int|1000
comma
id|ticks
)paren
suffix:semicolon
id|timeout
op_assign
id|ticks
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/*  Mmm. Isn&squot;t current-&gt;blocked == 0xffffffff ?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;awoken by non-blocked signal :-(&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* exit on signal */
)brace
r_while
c_loop
(paren
id|current-&gt;state
op_ne
id|TASK_RUNNING
)paren
(brace
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|timeout
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*  send a command or parameter to the drive&n; *  Generates # of step pulses.&n; */
DECL|function|ft_send_to_drive
r_static
r_inline
r_int
id|ft_send_to_drive
c_func
(paren
r_int
id|arg
)paren
(brace
multiline_comment|/*  Always wait for a command_timeout period to separate&n;&t; *  individuals commands and/or parameters.&n;&t; */
id|ftape_sleep
c_func
(paren
l_int|3
op_star
id|FT_MILLISECOND
)paren
suffix:semicolon
multiline_comment|/*  Keep cylinder nr within range, step towards home if possible.&n;&t; */
r_if
c_cond
(paren
id|ftape_current_cylinder
op_ge
id|arg
)paren
(brace
r_return
id|fdc_seek
c_func
(paren
id|ftape_current_cylinder
op_minus
id|arg
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
id|fdc_seek
c_func
(paren
id|ftape_current_cylinder
op_plus
id|arg
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* forward */
r_int
id|ftape_report_raw_drive_status
c_func
(paren
r_int
op_star
id|status
)paren
suffix:semicolon
DECL|function|ft_check_cmd_restrictions
r_static
r_int
id|ft_check_cmd_restrictions
c_func
(paren
id|qic117_cmd_t
id|command
)paren
(brace
r_int
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;%s&quot;
comma
id|qic117_cmds
(braket
id|command
)braket
dot
id|name
)paren
suffix:semicolon
multiline_comment|/* A new motion command during an uninterruptible (motion)&n;&t; *  command requires a ready status before the new command can&n;&t; *  be issued. Otherwise a new motion command needs to be&n;&t; *  checked against required status.&n;&t; */
r_if
c_cond
(paren
id|qic117_cmds
(braket
id|command
)braket
dot
id|cmd_type
op_eq
id|motion
op_logical_and
id|qic117_cmds
(braket
id|ftape_current_command
)braket
dot
id|non_intr
)paren
(brace
id|ftape_report_raw_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;motion cmd (%d) during non-intr cmd (%d)&quot;
comma
id|command
comma
id|ftape_current_command
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;waiting until drive gets ready&quot;
)paren
suffix:semicolon
id|ftape_ready_wait
c_func
(paren
id|ftape_timeout.seek
comma
op_amp
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|qic117_cmds
(braket
id|command
)braket
dot
id|mask
op_ne
l_int|0
)paren
(brace
id|__u8
id|difference
suffix:semicolon
multiline_comment|/*  Some commands do require a certain status:&n;&t;&t; */
r_if
c_cond
(paren
id|status
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* not yet set */
id|ftape_report_raw_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
)brace
id|difference
op_assign
(paren
(paren
id|status
op_xor
id|qic117_cmds
(braket
id|command
)braket
dot
id|state
)paren
op_amp
id|qic117_cmds
(braket
id|command
)braket
dot
id|mask
)paren
suffix:semicolon
multiline_comment|/*  Wait until the drive gets&n;&t;&t; *  ready. This may last forever if&n;&t;&t; *  the drive never gets ready... &n;&t;&t; */
r_while
c_loop
(paren
(paren
id|difference
op_amp
id|QIC_STATUS_READY
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;command %d issued while not ready&quot;
comma
id|command
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;waiting until drive gets ready&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_ready_wait
c_func
(paren
id|ftape_timeout.seek
comma
op_amp
id|status
)paren
op_eq
op_minus
id|EINTR
)paren
(brace
multiline_comment|/*  Bail out on signal !&n;&t;&t;&t;&t; */
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINTR
comma
id|ft_t_warn
comma
l_string|&quot;interrupted by non-blockable signal&quot;
)paren
suffix:semicolon
)brace
id|difference
op_assign
(paren
(paren
id|status
op_xor
id|qic117_cmds
(braket
id|command
)braket
dot
id|state
)paren
op_amp
id|qic117_cmds
(braket
id|command
)braket
dot
id|mask
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|difference
op_amp
id|QIC_STATUS_ERROR
)paren
op_ne
l_int|0
)paren
(brace
r_int
id|err
suffix:semicolon
id|qic117_cmd_t
id|cmd
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;command %d issued while error pending&quot;
comma
id|command
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;clearing error status&quot;
)paren
suffix:semicolon
id|ftape_report_error
c_func
(paren
op_amp
id|err
comma
op_amp
id|cmd
comma
l_int|1
)paren
suffix:semicolon
id|ftape_report_raw_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
id|difference
op_assign
(paren
(paren
id|status
op_xor
id|qic117_cmds
(braket
id|command
)braket
dot
id|state
)paren
op_amp
id|qic117_cmds
(braket
id|command
)braket
dot
id|mask
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|difference
op_amp
id|QIC_STATUS_ERROR
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*  Bail out on fatal signal !&n;&t;&t;&t;&t; */
id|FT_SIGNAL_EXIT
c_func
(paren
id|_NEVER_BLOCK
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|difference
)paren
(brace
multiline_comment|/*  Any remaining difference can&squot;t be solved&n;&t;&t;&t; *  here.  &n;&t;&t;&t; */
r_if
c_cond
(paren
id|difference
op_amp
(paren
id|QIC_STATUS_CARTRIDGE_PRESENT
op_or
id|QIC_STATUS_NEW_CARTRIDGE
op_or
id|QIC_STATUS_REFERENCED
)paren
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Fatal: tape removed or reinserted !&quot;
)paren
suffix:semicolon
id|ft_failure
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;wrong state: 0x%02x should be: 0x%02x&quot;
comma
id|status
op_amp
id|qic117_cmds
(braket
id|command
)braket
dot
id|mask
comma
id|qic117_cmds
(braket
id|command
)braket
dot
id|state
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_complement
id|status
op_amp
id|QIC_STATUS_READY
op_amp
id|qic117_cmds
(braket
id|command
)braket
dot
id|mask
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EBUSY
comma
id|ft_t_err
comma
l_string|&quot;Bad: still busy!&quot;
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      Issue a tape command:&n; */
DECL|function|ftape_command
r_int
id|ftape_command
c_func
(paren
id|qic117_cmd_t
id|command
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|level
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|command
OG
id|NR_ITEMS
c_func
(paren
id|qic117_cmds
)paren
)paren
(brace
multiline_comment|/*  This is a bug we&squot;ll want to know about too.&n;&t;&t; */
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_bug
comma
l_string|&quot;bug - bad command: %d&quot;
comma
id|command
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|level
OG
l_int|5
)paren
(brace
multiline_comment|/*  This is a bug we&squot;ll want to know about. */
op_decrement
id|level
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_bug
comma
l_string|&quot;bug - recursion for command: %d&quot;
comma
id|command
)paren
suffix:semicolon
)brace
multiline_comment|/*  disable logging and restriction check for some commands,&n;&t; *  check all other commands that have a prescribed starting&n;&t; *  status.&n;&t; */
r_if
c_cond
(paren
id|diagnostic_mode
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;diagnostic command %d&quot;
comma
id|command
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|command
op_eq
id|QIC_REPORT_DRIVE_STATUS
op_logical_or
id|command
op_eq
id|QIC_REPORT_NEXT_BIT
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_any
comma
l_string|&quot;%s&quot;
comma
id|qic117_cmds
(braket
id|command
)braket
dot
id|name
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE_CATCH
c_func
(paren
id|ft_check_cmd_restrictions
c_func
(paren
id|command
)paren
comma
op_decrement
id|level
)paren
suffix:semicolon
)brace
multiline_comment|/*  Now all conditions are met or result was &lt; 0.&n;&t; */
id|result
op_assign
id|ft_send_to_drive
c_func
(paren
(paren
r_int
r_int
)paren
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qic117_cmds
(braket
id|command
)braket
dot
id|cmd_type
op_eq
id|motion
op_logical_and
id|command
op_ne
id|QIC_LOGICAL_FORWARD
op_logical_and
id|command
op_ne
id|QIC_STOP_TAPE
)paren
(brace
id|ft_location.known
op_assign
l_int|0
suffix:semicolon
)brace
id|ftape_current_command
op_assign
id|command
suffix:semicolon
op_decrement
id|level
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*      Send a tape command parameter:&n; *      Generates command # of step pulses.&n; *      Skips tape-status call !&n; */
DECL|function|ftape_parameter
r_int
id|ftape_parameter
c_func
(paren
r_int
r_int
id|parameter
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;called with parameter = %d&quot;
comma
id|parameter
)paren
suffix:semicolon
id|TRACE_EXIT
id|ft_send_to_drive
c_func
(paren
id|parameter
op_plus
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*      Wait for the drive to get ready.&n; *      timeout time in milli-seconds&n; *      Returned status is valid if result != -EIO&n; *&n; *      Should we allow to be killed by SIGINT?  (^C)&n; *      Would be nice at least for large timeouts.&n; */
DECL|function|ftape_ready_wait
r_int
id|ftape_ready_wait
c_func
(paren
r_int
r_int
id|timeout
comma
r_int
op_star
id|status
)paren
(brace
r_int
r_int
id|t0
suffix:semicolon
r_int
r_int
id|poll_delay
suffix:semicolon
r_int
id|signal_retries
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/*  the following ** REALLY ** reduces the system load when&n;&t; *  e.g. one simply rewinds or retensions. The tape is slow &n;&t; *  anyway. It is really not necessary to detect error &n;&t; *  conditions with 1/10 seconds granularity&n;&t; *&n;&t; *  On my AMD 133MHZ 486: 100 ms: 23% system load&n;&t; *                        1  sec:  5%&n;&t; *                        5  sec:  0.6%, yeah&n;&t; */
r_if
c_cond
(paren
id|timeout
op_le
id|FT_SECOND
)paren
(brace
id|poll_delay
op_assign
l_int|100
op_star
id|FT_MILLISECOND
suffix:semicolon
id|signal_retries
op_assign
l_int|20
suffix:semicolon
multiline_comment|/* two seconds */
)brace
r_else
r_if
c_cond
(paren
id|timeout
OL
l_int|20
op_star
id|FT_SECOND
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;setting poll delay to 1 second&quot;
)paren
suffix:semicolon
id|poll_delay
op_assign
id|FT_SECOND
suffix:semicolon
id|signal_retries
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* two seconds */
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;setting poll delay to 5 seconds&quot;
)paren
suffix:semicolon
id|poll_delay
op_assign
l_int|5
op_star
id|FT_SECOND
suffix:semicolon
id|signal_retries
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* five seconds */
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|t0
op_assign
id|jiffies
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_report_raw_drive_status
c_func
(paren
id|status
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|status
op_amp
id|QIC_STATUS_READY
)paren
(brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|signal_retries
op_decrement
)paren
(brace
id|FT_SIGNAL_EXIT
c_func
(paren
id|_NEVER_BLOCK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|timeout
op_ge
l_int|0
)paren
(brace
multiline_comment|/* this will fail when jiffies wraps around about&n;&t;&t;&t; * once every year :-)&n;&t;&t;&t; */
id|timeout
op_sub_assign
(paren
(paren
id|jiffies
op_minus
id|t0
)paren
op_star
id|FT_SECOND
)paren
op_div
id|HZ
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_le
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|ETIME
comma
id|ft_t_err
comma
l_string|&quot;timeout&quot;
)paren
suffix:semicolon
)brace
id|ftape_sleep
c_func
(paren
id|poll_delay
)paren
suffix:semicolon
id|timeout
op_sub_assign
id|poll_delay
suffix:semicolon
)brace
r_else
(brace
id|ftape_sleep
c_func
(paren
id|poll_delay
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
op_minus
id|ETIME
suffix:semicolon
)brace
multiline_comment|/*      Issue command and wait up to timeout milli seconds for drive ready&n; */
DECL|function|ftape_command_wait
r_int
id|ftape_command_wait
c_func
(paren
id|qic117_cmd_t
id|command
comma
r_int
r_int
id|timeout
comma
r_int
op_star
id|status
)paren
(brace
r_int
id|result
suffix:semicolon
multiline_comment|/* Drive should be ready, issue command&n;&t; */
id|result
op_assign
id|ftape_command
c_func
(paren
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|timeout
comma
id|status
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
DECL|function|ftape_parameter_wait
r_int
id|ftape_parameter_wait
c_func
(paren
r_int
r_int
id|parm
comma
r_int
r_int
id|timeout
comma
r_int
op_star
id|status
)paren
(brace
r_int
id|result
suffix:semicolon
multiline_comment|/* Drive should be ready, issue command&n;&t; */
id|result
op_assign
id|ftape_parameter
c_func
(paren
id|parm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|timeout
comma
id|status
)paren
suffix:semicolon
)brace
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*--------------------------------------------------------------------------&n; *      Report operations&n; */
multiline_comment|/* Query the drive about its status.  The command is sent and&n;   result_length bits of status are returned (2 extra bits are read&n;   for start and stop). */
DECL|function|ftape_report_operation
r_int
id|ftape_report_operation
c_func
(paren
r_int
op_star
id|status
comma
id|qic117_cmd_t
id|command
comma
r_int
id|result_length
)paren
(brace
r_int
id|i
comma
id|st3
suffix:semicolon
r_int
r_int
id|t0
suffix:semicolon
r_int
r_int
id|dt
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_command
c_func
(paren
id|command
)paren
comma
)paren
suffix:semicolon
id|t0
op_assign
id|ftape_timestamp
c_func
(paren
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
op_increment
id|i
suffix:semicolon
id|ftape_sleep
c_func
(paren
l_int|3
op_star
id|FT_MILLISECOND
)paren
suffix:semicolon
multiline_comment|/* see remark below */
id|TRACE_CATCH
c_func
(paren
id|fdc_sense_drive_status
c_func
(paren
op_amp
id|st3
)paren
comma
)paren
suffix:semicolon
id|dt
op_assign
id|ftape_timediff
c_func
(paren
id|t0
comma
id|ftape_timestamp
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/*  Ack should be asserted within Ttimout + Tack = 6 msec.&n;&t;&t; *  Looks like some drives fail to do this so extend this&n;&t;&t; *  period to 300 msec.&n;&t;&t; */
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|st3
op_amp
id|ST3_TRACK_0
)paren
op_logical_and
id|dt
OL
l_int|300000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|st3
op_amp
id|ST3_TRACK_0
)paren
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;No acknowledge after %u msec. (%i iter)&quot;
comma
id|dt
op_div
l_int|1000
comma
id|i
)paren
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;timeout on Acknowledge&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*  dt may be larger than expected because of other tasks&n;&t; *  scheduled while we were sleeping.&n;&t; */
r_if
c_cond
(paren
id|i
OG
l_int|1
op_logical_and
id|dt
OG
l_int|6000
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;Acknowledge after %u msec. (%i iter)&quot;
comma
id|dt
op_div
l_int|1000
comma
id|i
)paren
suffix:semicolon
)brace
op_star
id|status
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|result_length
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|TRACE_CATCH
c_func
(paren
id|ftape_command
c_func
(paren
id|QIC_REPORT_NEXT_BIT
)paren
comma
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|fdc_sense_drive_status
c_func
(paren
op_amp
id|st3
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|result_length
)paren
(brace
op_star
id|status
op_or_assign
(paren
(paren
id|st3
op_amp
id|ST3_TRACK_0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
op_lshift
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|st3
op_amp
id|ST3_TRACK_0
)paren
op_eq
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;missing status stop bit&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* this command will put track zero and index back into normal state */
(paren
r_void
)paren
id|ftape_command
c_func
(paren
id|QIC_REPORT_NEXT_BIT
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Report the current drive status. */
DECL|function|ftape_report_raw_drive_status
r_int
id|ftape_report_raw_drive_status
c_func
(paren
r_int
op_star
id|status
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_do
(brace
id|result
op_assign
id|ftape_report_operation
c_func
(paren
id|status
comma
id|QIC_REPORT_DRIVE_STATUS
comma
l_int|8
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|result
OL
l_int|0
op_logical_and
op_increment
id|count
op_le
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;report_operation failed after %d trials&quot;
comma
id|count
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_star
id|status
op_amp
l_int|0xff
)paren
op_eq
l_int|0xff
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;impossible drive status 0xff&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|status
op_amp
id|QIC_STATUS_READY
)paren
(brace
id|ftape_current_command
op_assign
id|QIC_NO_COMMAND
suffix:semicolon
multiline_comment|/* completed */
)brace
id|ft_last_status.status.drive_status
op_assign
(paren
id|__u8
)paren
(paren
op_star
id|status
op_amp
l_int|0xff
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_report_drive_status
r_int
id|ftape_report_drive_status
c_func
(paren
r_int
op_star
id|status
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_report_raw_drive_status
c_func
(paren
id|status
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|status
op_amp
id|QIC_STATUS_NEW_CARTRIDGE
op_logical_or
op_logical_neg
(paren
op_star
id|status
op_amp
id|QIC_STATUS_CARTRIDGE_PRESENT
)paren
)paren
(brace
id|ft_failure
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* will inhibit further operations */
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|status
op_amp
id|QIC_STATUS_READY
op_logical_and
op_star
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
(brace
multiline_comment|/*  Let caller handle all errors */
id|TRACE_ABORT
c_func
(paren
l_int|1
comma
id|ft_t_warn
comma
l_string|&quot;warning: error status set!&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_report_error
r_int
id|ftape_report_error
c_func
(paren
r_int
r_int
op_star
id|error
comma
id|qic117_cmd_t
op_star
id|command
comma
r_int
id|report
)paren
(brace
r_static
r_const
id|ftape_error
id|ftape_errors
(braket
)braket
op_assign
id|QIC117_ERRORS
suffix:semicolon
r_int
id|code
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_report_operation
c_func
(paren
op_amp
id|code
comma
id|QIC_REPORT_ERROR_CODE
comma
l_int|16
)paren
comma
)paren
suffix:semicolon
op_star
id|error
op_assign
(paren
r_int
r_int
)paren
(paren
id|code
op_amp
l_int|0xff
)paren
suffix:semicolon
op_star
id|command
op_assign
(paren
id|qic117_cmd_t
)paren
(paren
(paren
id|code
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/*  remember hardware status, maybe useful for status ioctls&n;&t; */
id|ft_last_error.error.command
op_assign
(paren
id|__u8
)paren
op_star
id|command
suffix:semicolon
id|ft_last_error.error.error
op_assign
(paren
id|__u8
)paren
op_star
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|report
)paren
(brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|error
op_eq
l_int|0
)paren
(brace
id|TRACE_ABORT
c_func
(paren
l_int|0
comma
id|ft_t_info
comma
l_string|&quot;No error&quot;
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;errorcode: %d&quot;
comma
op_star
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|error
OL
id|NR_ITEMS
c_func
(paren
id|ftape_errors
)paren
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;%sFatal ERROR:&quot;
comma
(paren
id|ftape_errors
(braket
op_star
id|error
)braket
dot
id|fatal
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;Non-&quot;
)paren
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;%s ...&quot;
comma
id|ftape_errors
(braket
op_star
id|error
)braket
dot
id|message
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Unknown ERROR !&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
op_star
id|command
OL
id|NR_ITEMS
c_func
(paren
id|qic117_cmds
)paren
op_logical_and
id|qic117_cmds
(braket
op_star
id|command
)braket
dot
id|name
op_ne
l_int|NULL
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;... caused by command &bslash;&squot;%s&bslash;&squot;&quot;
comma
id|qic117_cmds
(braket
op_star
id|command
)braket
dot
id|name
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;... caused by unknown command %d&quot;
comma
op_star
id|command
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_in_error_state
r_int
id|ftape_in_error_state
c_func
(paren
r_int
id|status
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|QIC_STATUS_READY
)paren
op_logical_and
(paren
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
l_int|1
comma
id|ft_t_warn
comma
l_string|&quot;warning: error status set!&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_report_configuration
r_int
id|ftape_report_configuration
c_func
(paren
id|qic_model
op_star
id|model
comma
r_int
r_int
op_star
id|rate
comma
r_int
op_star
id|qic_std
comma
r_int
op_star
id|tape_len
)paren
(brace
r_int
id|result
suffix:semicolon
r_int
id|config
suffix:semicolon
r_int
id|status
suffix:semicolon
r_static
r_const
r_int
r_int
id|qic_rates
(braket
l_int|4
)braket
op_assign
(brace
l_int|250
comma
l_int|2000
comma
l_int|500
comma
l_int|1000
)brace
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|result
op_assign
id|ftape_report_operation
c_func
(paren
op_amp
id|config
comma
id|QIC_REPORT_DRIVE_CONFIGURATION
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|ft_last_status.status.drive_config
op_assign
(paren
id|__u8
)paren
l_int|0x00
suffix:semicolon
op_star
id|model
op_assign
id|prehistoric
suffix:semicolon
op_star
id|rate
op_assign
l_int|500
suffix:semicolon
op_star
id|qic_std
op_assign
id|QIC_TAPE_QIC40
suffix:semicolon
op_star
id|tape_len
op_assign
l_int|205
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ft_last_status.status.drive_config
op_assign
(paren
id|__u8
)paren
(paren
id|config
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
op_star
id|rate
op_assign
id|qic_rates
(braket
(paren
id|config
op_amp
id|QIC_CONFIG_RATE_MASK
)paren
op_rshift
id|QIC_CONFIG_RATE_SHIFT
)braket
suffix:semicolon
id|result
op_assign
id|ftape_report_operation
c_func
(paren
op_amp
id|status
comma
id|QIC_REPORT_TAPE_STATUS
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|ft_last_status.status.tape_status
op_assign
(paren
id|__u8
)paren
l_int|0x00
suffix:semicolon
multiline_comment|/* pre- QIC117 rev C spec. drive, QIC_CONFIG_80 bit is valid.&n;&t;&t; */
op_star
id|qic_std
op_assign
(paren
id|config
op_amp
id|QIC_CONFIG_80
)paren
ques
c_cond
id|QIC_TAPE_QIC80
suffix:colon
id|QIC_TAPE_QIC40
suffix:semicolon
multiline_comment|/* ?? how&squot;s about 425ft tapes? */
op_star
id|tape_len
op_assign
(paren
id|config
op_amp
id|QIC_CONFIG_LONG
)paren
ques
c_cond
l_int|307
suffix:colon
l_int|0
suffix:semicolon
op_star
id|model
op_assign
id|pre_qic117c
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ft_last_status.status.tape_status
op_assign
(paren
id|__u8
)paren
(paren
id|status
op_amp
l_int|0xff
)paren
suffix:semicolon
op_star
id|model
op_assign
id|post_qic117b
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_any
comma
l_string|&quot;report tape status result = %02x&quot;
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* post- QIC117 rev C spec. drive, QIC_CONFIG_80 bit is&n;&t;&t; * invalid. &n;&t;&t; */
r_switch
c_cond
(paren
id|status
op_amp
id|QIC_TAPE_STD_MASK
)paren
(brace
r_case
id|QIC_TAPE_QIC40
suffix:colon
r_case
id|QIC_TAPE_QIC80
suffix:colon
r_case
id|QIC_TAPE_QIC3020
suffix:colon
r_case
id|QIC_TAPE_QIC3010
suffix:colon
op_star
id|qic_std
op_assign
id|status
op_amp
id|QIC_TAPE_STD_MASK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|qic_std
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|status
op_amp
id|QIC_TAPE_LEN_MASK
)paren
(brace
r_case
id|QIC_TAPE_205FT
suffix:colon
multiline_comment|/* 205 or 425+ ft 550 Oe tape */
op_star
id|tape_len
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_307FT
suffix:colon
multiline_comment|/* 307.5 ft 550 Oe Extended Length (XL) tape */
op_star
id|tape_len
op_assign
l_int|307
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_VARIABLE
suffix:colon
multiline_comment|/* Variable length 550 Oe tape */
op_star
id|tape_len
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_1100FT
suffix:colon
multiline_comment|/* 1100 ft 550 Oe tape */
op_star
id|tape_len
op_assign
l_int|1100
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_FLEX
suffix:colon
multiline_comment|/* Variable length 900 Oe tape */
op_star
id|tape_len
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
op_star
id|tape_len
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|qic_std
op_eq
op_minus
l_int|1
op_logical_or
op_star
id|tape_len
op_eq
op_minus
l_int|1
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_any
comma
l_string|&quot;post qic-117b spec drive with unknown tape&quot;
)paren
suffix:semicolon
)brace
id|result
op_assign
op_star
id|tape_len
op_eq
op_minus
l_int|1
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|QIC_TAPE_WIDE
)paren
(brace
r_switch
c_cond
(paren
op_star
id|qic_std
)paren
(brace
r_case
id|QIC_TAPE_QIC80
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;TR-1 tape detected&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_QIC3010
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;TR-2 tape detected&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_QIC3020
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;TR-3 tape detected&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Unknown Travan tape type detected&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|TRACE_EXIT
(paren
id|result
OL
l_int|0
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_report_rom_version
r_int
id|ftape_report_rom_version
c_func
(paren
r_int
op_star
id|version
)paren
(brace
r_if
c_cond
(paren
id|ftape_report_operation
c_func
(paren
id|version
comma
id|QIC_REPORT_ROM_VERSION
comma
l_int|8
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|ftape_report_signature
r_int
id|ftape_report_signature
c_func
(paren
r_int
op_star
id|signature
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
id|ftape_command
c_func
(paren
l_int|28
)paren
suffix:semicolon
id|result
op_assign
id|ftape_report_operation
c_func
(paren
id|signature
comma
l_int|9
comma
l_int|8
)paren
suffix:semicolon
id|result
op_assign
id|ftape_command
c_func
(paren
l_int|30
)paren
suffix:semicolon
r_return
(paren
id|result
OL
l_int|0
)paren
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_report_vendor_id
r_void
id|ftape_report_vendor_id
c_func
(paren
r_int
r_int
op_star
id|id
)paren
(brace
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/* We&squot;ll try to get a vendor id from the drive.  First&n;&t; * according to the QIC-117 spec, a 16-bit id is requested.&n;&t; * If that fails we&squot;ll try an 8-bit version, otherwise we&squot;ll&n;&t; * try an undocumented query.&n;&t; */
id|result
op_assign
id|ftape_report_operation
c_func
(paren
(paren
r_int
op_star
)paren
id|id
comma
id|QIC_REPORT_VENDOR_ID
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|result
op_assign
id|ftape_report_operation
c_func
(paren
(paren
r_int
op_star
)paren
id|id
comma
id|QIC_REPORT_VENDOR_ID
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
multiline_comment|/* The following is an undocumented call found&n;&t;&t;&t; * in the CMS code.&n;&t;&t;&t; */
id|result
op_assign
id|ftape_report_operation
c_func
(paren
(paren
r_int
op_star
)paren
id|id
comma
l_int|24
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
op_star
id|id
op_assign
id|UNKNOWN_VENDOR
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;got old 8 bit id: %04x&quot;
comma
op_star
id|id
)paren
suffix:semicolon
op_star
id|id
op_or_assign
l_int|0x20000
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;got 8 bit id: %04x&quot;
comma
op_star
id|id
)paren
suffix:semicolon
op_star
id|id
op_or_assign
l_int|0x10000
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;got 16 bit id: %04x&quot;
comma
op_star
id|id
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|id
op_eq
l_int|0x0047
)paren
(brace
r_int
id|version
suffix:semicolon
r_int
id|sign
suffix:semicolon
r_if
c_cond
(paren
id|ftape_report_rom_version
c_func
(paren
op_amp
id|version
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;report rom version failed&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;CMS rom version: %d&quot;
comma
id|version
)paren
suffix:semicolon
id|ftape_command
c_func
(paren
id|QIC_ENTER_DIAGNOSTIC_1
)paren
suffix:semicolon
id|ftape_command
c_func
(paren
id|QIC_ENTER_DIAGNOSTIC_1
)paren
suffix:semicolon
id|diagnostic_mode
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ftape_report_operation
c_func
(paren
op_amp
id|sign
comma
l_int|9
comma
l_int|8
)paren
OL
l_int|0
)paren
(brace
r_int
r_int
id|error
suffix:semicolon
id|qic117_cmd_t
id|command
suffix:semicolon
id|ftape_report_error
c_func
(paren
op_amp
id|error
comma
op_amp
id|command
comma
l_int|1
)paren
suffix:semicolon
id|ftape_command
c_func
(paren
id|QIC_ENTER_PRIMARY_MODE
)paren
suffix:semicolon
id|diagnostic_mode
op_assign
l_int|0
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
multiline_comment|/* failure ! */
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;CMS signature: %02x&quot;
comma
id|sign
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sign
op_eq
l_int|0xa5
)paren
(brace
id|result
op_assign
id|ftape_report_operation
c_func
(paren
op_amp
id|sign
comma
l_int|37
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|version
op_ge
l_int|63
)paren
(brace
op_star
id|id
op_assign
l_int|0x8880
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;This is an Iomega drive !&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|id
op_assign
l_int|0x0047
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;This is a real CMS drive !&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|id
op_assign
l_int|0x0047
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;CMS status: %d&quot;
comma
id|sign
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|id
op_assign
id|UNKNOWN_VENDOR
suffix:semicolon
)brace
id|ftape_command
c_func
(paren
id|QIC_ENTER_PRIMARY_MODE
)paren
suffix:semicolon
id|diagnostic_mode
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|qic_rate_code
r_static
r_int
id|qic_rate_code
c_func
(paren
r_int
r_int
id|rate
)paren
(brace
r_switch
c_cond
(paren
id|rate
)paren
(brace
r_case
l_int|250
suffix:colon
r_return
id|QIC_CONFIG_RATE_250
suffix:semicolon
r_case
l_int|500
suffix:colon
r_return
id|QIC_CONFIG_RATE_500
suffix:semicolon
r_case
l_int|1000
suffix:colon
r_return
id|QIC_CONFIG_RATE_1000
suffix:semicolon
r_case
l_int|2000
suffix:colon
r_return
id|QIC_CONFIG_RATE_2000
suffix:semicolon
r_default
suffix:colon
r_return
id|QIC_CONFIG_RATE_500
suffix:semicolon
)brace
)brace
DECL|function|ftape_set_rate_test
r_static
r_int
id|ftape_set_rate_test
c_func
(paren
r_int
r_int
op_star
id|max_rate
)paren
(brace
r_int
r_int
id|error
suffix:semicolon
id|qic117_cmd_t
id|command
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|supported
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/*  Check if the drive does support the select rate command&n;&t; *  by testing all different settings. If any one is accepted&n;&t; *  we assume the command is supported, else not.&n;&t; */
r_for
c_loop
(paren
op_star
id|max_rate
op_assign
l_int|2000
suffix:semicolon
op_star
id|max_rate
op_ge
l_int|250
suffix:semicolon
op_star
id|max_rate
op_div_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|ftape_command
c_func
(paren
id|QIC_SELECT_RATE
)paren
OL
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ftape_parameter_wait
c_func
(paren
id|qic_rate_code
c_func
(paren
op_star
id|max_rate
)paren
comma
l_int|1
op_star
id|FT_SECOND
comma
op_amp
id|status
)paren
OL
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
(brace
id|ftape_report_error
c_func
(paren
op_amp
id|error
comma
op_amp
id|command
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|supported
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* did accept a request */
r_break
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Select Rate command is%s supported&quot;
comma
id|supported
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot; not&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
id|supported
suffix:semicolon
)brace
DECL|function|ftape_set_data_rate
r_int
id|ftape_set_data_rate
c_func
(paren
r_int
r_int
id|new_rate
multiline_comment|/* Kbps */
comma
r_int
r_int
id|qic_std
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|data_rate
op_assign
id|new_rate
suffix:semicolon
r_static
r_int
id|supported
suffix:semicolon
r_int
id|rate_changed
op_assign
l_int|0
suffix:semicolon
id|qic_model
id|dummy_model
suffix:semicolon
r_int
r_int
id|dummy_qic_std
comma
id|dummy_tape_len
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_drive_max_rate
op_eq
l_int|0
)paren
(brace
multiline_comment|/* first time */
id|supported
op_assign
id|ftape_set_rate_test
c_func
(paren
op_amp
id|ft_drive_max_rate
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|supported
)paren
(brace
id|ftape_command
c_func
(paren
id|QIC_SELECT_RATE
)paren
suffix:semicolon
id|result
op_assign
id|ftape_parameter_wait
c_func
(paren
id|qic_rate_code
c_func
(paren
id|new_rate
)paren
comma
l_int|1
op_star
id|FT_SECOND
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
op_logical_and
op_logical_neg
(paren
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
)paren
(brace
id|rate_changed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|TRACE_CATCH
c_func
(paren
id|result
op_assign
id|ftape_report_configuration
c_func
(paren
op_amp
id|dummy_model
comma
op_amp
id|data_rate
comma
op_amp
id|dummy_qic_std
comma
op_amp
id|dummy_tape_len
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data_rate
op_ne
id|new_rate
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|supported
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Rate change not supported!&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rate_changed
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Requested: %d, got %d&quot;
comma
id|new_rate
comma
id|data_rate
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Rate change failed!&quot;
)paren
suffix:semicolon
)brace
id|result
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Set data rate and write precompensation as specified:&n;&t; *&n;&t; *            |  QIC-40/80  | QIC-3010/3020&n;&t; *   rate     |   precomp   |    precomp&n;&t; *  ----------+-------------+--------------&n;&t; *  250 Kbps. |   250 ns.   |     0 ns.&n;&t; *  500 Kbps. |   125 ns.   |     0 ns.&n;&t; *    1 Mbps. |    42 ns.   |     0 ns.&n;&t; *    2 Mbps  |      N/A    |     0 ns.&n;&t; */
r_if
c_cond
(paren
(paren
id|qic_std
op_eq
id|QIC_TAPE_QIC40
op_logical_and
id|data_rate
OG
l_int|500
)paren
op_logical_or
(paren
id|qic_std
op_eq
id|QIC_TAPE_QIC80
op_logical_and
id|data_rate
OG
l_int|1000
)paren
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_warn
comma
l_string|&quot;Datarate too high for QIC-mode&quot;
)paren
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|fdc_set_data_rate
c_func
(paren
id|data_rate
)paren
comma
id|_res
op_assign
op_minus
id|EINVAL
)paren
suffix:semicolon
id|ft_data_rate
op_assign
id|data_rate
suffix:semicolon
r_if
c_cond
(paren
id|qic_std
op_eq
id|QIC_TAPE_QIC40
op_logical_or
id|qic_std
op_eq
id|QIC_TAPE_QIC80
)paren
(brace
r_switch
c_cond
(paren
id|data_rate
)paren
(brace
r_case
l_int|250
suffix:colon
id|fdc_set_write_precomp
c_func
(paren
l_int|250
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
l_int|500
suffix:colon
id|fdc_set_write_precomp
c_func
(paren
l_int|125
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1000
suffix:colon
id|fdc_set_write_precomp
c_func
(paren
l_int|42
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|fdc_set_write_precomp
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*  The next two functions are used to cope with excessive overrun errors&n; */
DECL|function|ftape_increase_threshold
r_int
id|ftape_increase_threshold
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc.type
OL
id|i82077
op_logical_or
id|ft_fdc_threshold
op_ge
l_int|12
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;cannot increase fifo threshold&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdc_fifo_threshold
c_func
(paren
op_increment
id|ft_fdc_threshold
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;cannot increase fifo threshold&quot;
)paren
suffix:semicolon
id|ft_fdc_threshold
op_decrement
suffix:semicolon
id|fdc_reset
c_func
(paren
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;New FIFO threshold: %d&quot;
comma
id|ft_fdc_threshold
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_half_data_rate
r_int
id|ftape_half_data_rate
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|ft_data_rate
OL
l_int|500
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ftape_set_data_rate
c_func
(paren
id|ft_data_rate
op_div
l_int|2
comma
id|ft_qic_std
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|ftape_calc_timeouts
c_func
(paren
id|ft_qic_std
comma
id|ft_data_rate
comma
id|ftape_tape_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      Seek the head to the specified track.&n; */
DECL|function|ftape_seek_head_to_track
r_int
id|ftape_seek_head_to_track
c_func
(paren
r_int
r_int
id|track
)paren
(brace
r_int
id|status
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
id|ft_location.track
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* remains set in case of error */
r_if
c_cond
(paren
id|track
op_ge
id|ft_tracks_per_tape
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EINVAL
comma
id|ft_t_bug
comma
l_string|&quot;track out of bounds&quot;
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;seeking track %d&quot;
comma
id|track
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_command
c_func
(paren
id|QIC_SEEK_HEAD_TO_TRACK
)paren
comma
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_parameter_wait
c_func
(paren
id|track
comma
id|ftape_timeout.head_seek
comma
op_amp
id|status
)paren
comma
)paren
suffix:semicolon
id|ft_location.track
op_assign
id|track
suffix:semicolon
id|ftape_might_be_off_track
op_assign
l_int|0
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_wakeup_drive
r_int
id|ftape_wakeup_drive
c_func
(paren
id|wake_up_types
id|method
)paren
(brace
r_int
id|status
suffix:semicolon
r_int
id|motor_on
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|method
)paren
(brace
r_case
id|wake_up_colorado
suffix:colon
id|TRACE_CATCH
c_func
(paren
id|ftape_command
c_func
(paren
id|QIC_PHANTOM_SELECT
)paren
comma
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|ftape_parameter
c_func
(paren
l_int|0
multiline_comment|/* ft_drive_sel ?? */
)paren
comma
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|wake_up_mountain
suffix:colon
id|TRACE_CATCH
c_func
(paren
id|ftape_command
c_func
(paren
id|QIC_SOFT_SELECT
)paren
comma
)paren
suffix:semicolon
id|ftape_sleep
c_func
(paren
id|FT_MILLISECOND
)paren
suffix:semicolon
multiline_comment|/* NEEDED */
id|TRACE_CATCH
c_func
(paren
id|ftape_parameter
c_func
(paren
l_int|18
)paren
comma
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|wake_up_insight
suffix:colon
id|ftape_sleep
c_func
(paren
l_int|100
op_star
id|FT_MILLISECOND
)paren
suffix:semicolon
id|motor_on
op_assign
l_int|1
suffix:semicolon
id|fdc_motor
c_func
(paren
id|motor_on
)paren
suffix:semicolon
multiline_comment|/* enable is done by motor-on */
r_case
id|no_wake_up
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|TRACE_EXIT
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* unknown wakeup method */
r_break
suffix:semicolon
)brace
multiline_comment|/*  If wakeup succeeded we shouldn&squot;t get an error here..&n;&t; */
id|TRACE_CATCH
c_func
(paren
id|ftape_report_raw_drive_status
c_func
(paren
op_amp
id|status
)paren
comma
r_if
(paren
id|motor_on
)paren
(brace
id|fdc_motor
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_put_drive_to_sleep
r_int
id|ftape_put_drive_to_sleep
c_func
(paren
id|wake_up_types
id|method
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|method
)paren
(brace
r_case
id|wake_up_colorado
suffix:colon
id|TRACE_CATCH
c_func
(paren
id|ftape_command
c_func
(paren
id|QIC_PHANTOM_DESELECT
)paren
comma
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|wake_up_mountain
suffix:colon
id|TRACE_CATCH
c_func
(paren
id|ftape_command
c_func
(paren
id|QIC_SOFT_DESELECT
)paren
comma
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|wake_up_insight
suffix:colon
id|fdc_motor
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* enable is done by motor-on */
r_case
id|no_wake_up
suffix:colon
multiline_comment|/* no wakeup / no sleep ! */
r_break
suffix:semicolon
r_default
suffix:colon
id|TRACE_EXIT
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* unknown wakeup method */
)brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_reset_drive
r_int
id|ftape_reset_drive
c_func
(paren
r_void
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
r_int
id|err_code
suffix:semicolon
id|qic117_cmd_t
id|err_command
suffix:semicolon
r_int
id|i
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_any
)paren
suffix:semicolon
multiline_comment|/*  We want to re-establish contact with our drive.  Fire a&n;&t; *  number of reset commands (single step pulses) and pray for&n;&t; *  success.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
op_increment
id|i
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;Resetting fdc&quot;
)paren
suffix:semicolon
id|fdc_reset
c_func
(paren
)paren
suffix:semicolon
id|ftape_sleep
c_func
(paren
l_int|10
op_star
id|FT_MILLISECOND
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;Reset command to drive&quot;
)paren
suffix:semicolon
id|result
op_assign
id|ftape_command
c_func
(paren
id|QIC_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
id|ftape_sleep
c_func
(paren
l_int|1
op_star
id|FT_SECOND
)paren
suffix:semicolon
multiline_comment|/*  drive not&n;&t;&t;&t;&t;&t;&t;     *  accessible&n;&t;&t;&t;&t;&t;&t;     *  during 1 second&n;&t;&t;&t;&t;&t;&t;     */
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;Re-selecting drive&quot;
)paren
suffix:semicolon
multiline_comment|/* Strange, the QIC-117 specs don&squot;t mention&n;&t;&t;&t; * this but the drive gets deselected after a&n;&t;&t;&t; * soft reset !  So we need to enable it&n;&t;&t;&t; * again.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ftape_wakeup_drive
c_func
(paren
id|ft_drive_type.wake_up
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;Wakeup failed !&quot;
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_flow
comma
l_string|&quot;Waiting until drive gets ready&quot;
)paren
suffix:semicolon
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|ftape_timeout.reset
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_and
(paren
id|status
op_amp
id|QIC_STATUS_ERROR
)paren
)paren
(brace
id|result
op_assign
id|ftape_report_error
c_func
(paren
op_amp
id|err_code
comma
op_amp
id|err_command
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_and
id|err_code
op_eq
l_int|27
)paren
(brace
multiline_comment|/*  Okay, drive saw reset&n;&t;&t;&t;&t;&t; *  command and responded as it&n;&t;&t;&t;&t;&t; *  should&n;&t;&t;&t;&t;&t; */
r_break
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_else
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_err
comma
l_string|&quot;General failure to reset tape drive&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  Restore correct settings: keep original rate &n;&t;&t; */
id|ftape_set_data_rate
c_func
(paren
id|ft_data_rate
comma
id|ft_qic_std
)paren
suffix:semicolon
)brace
id|ftape_init_drive_needed
op_assign
l_int|1
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
eof
