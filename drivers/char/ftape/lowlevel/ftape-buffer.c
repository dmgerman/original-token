multiline_comment|/*&n; *      Copyright (C) 1997 Claus-Justus Heine&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; *&n; * $Source: /homes/cvs/ftape-stacked/ftape/lowlevel/ftape-buffer.c,v $&n; * $Revision: 1.3 $&n; * $Date: 1997/10/16 23:33:11 $&n; *&n; *  This file contains the allocator/dealloctor for ftape&squot;s dynamic dma&n; *  buffer.&n; */
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/wrapper.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &quot;../lowlevel/ftape-rw.h&quot;
macro_line|#include &quot;../lowlevel/ftape-read.h&quot;
macro_line|#include &quot;../lowlevel/ftape-tracing.h&quot;
multiline_comment|/*  DMA&squot;able memory allocation stuff.&n; */
DECL|function|dmaalloc
r_static
r_inline
r_void
op_star
id|dmaalloc
c_func
(paren
r_int
id|size
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|addr
op_assign
id|__get_dma_pages
c_func
(paren
id|GFP_KERNEL
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
id|addr
)paren
suffix:semicolon
id|page
OL
id|virt_to_page
c_func
(paren
id|addr
op_plus
id|size
)paren
suffix:semicolon
id|page
op_increment
)paren
id|mem_map_reserve
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
r_return
(paren
r_void
op_star
)paren
id|addr
suffix:semicolon
)brace
DECL|function|dmafree
r_static
r_inline
r_void
id|dmafree
c_func
(paren
r_void
op_star
id|addr
comma
r_int
id|size
)paren
(brace
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
(brace
r_struct
id|page
op_star
id|page
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
id|virt_to_page
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
)paren
suffix:semicolon
id|page
OL
id|virt_to_page
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
op_plus
id|size
)paren
suffix:semicolon
id|page
op_increment
)paren
id|mem_map_unreserve
c_func
(paren
id|page
)paren
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|addr
comma
id|get_order
c_func
(paren
id|size
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|add_one_buffer
r_static
r_int
id|add_one_buffer
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_nr_buffers
op_ge
id|FT_MAX_NR_BUFFERS
)paren
(brace
id|TRACE_EXIT
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ft_buffer
(braket
id|ft_nr_buffers
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|buffer_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_buffer
(braket
id|ft_nr_buffers
)braket
op_eq
l_int|NULL
)paren
(brace
id|TRACE_EXIT
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ft_buffer
(braket
id|ft_nr_buffers
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|buffer_struct
)paren
)paren
suffix:semicolon
id|ft_buffer
(braket
id|ft_nr_buffers
)braket
op_member_access_from_pointer
id|address
op_assign
id|dmaalloc
c_func
(paren
id|FT_BUFF_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_buffer
(braket
id|ft_nr_buffers
)braket
op_member_access_from_pointer
id|address
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|ft_buffer
(braket
id|ft_nr_buffers
)braket
)paren
suffix:semicolon
id|ft_buffer
(braket
id|ft_nr_buffers
)braket
op_assign
l_int|NULL
suffix:semicolon
id|TRACE_EXIT
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|ft_nr_buffers
op_increment
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;buffer nr #%d @ %p, dma area @ %p&quot;
comma
id|ft_nr_buffers
comma
id|ft_buffer
(braket
id|ft_nr_buffers
op_minus
l_int|1
)braket
comma
id|ft_buffer
(braket
id|ft_nr_buffers
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|address
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|del_one_buffer
r_static
r_void
id|del_one_buffer
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ft_nr_buffers
OG
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;releasing buffer nr #%d @ %p, dma area @ %p&quot;
comma
id|ft_nr_buffers
comma
id|ft_buffer
(braket
id|ft_nr_buffers
op_minus
l_int|1
)braket
comma
id|ft_buffer
(braket
id|ft_nr_buffers
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|address
)paren
suffix:semicolon
id|ft_nr_buffers
op_decrement
suffix:semicolon
id|dmafree
c_func
(paren
id|ft_buffer
(braket
id|ft_nr_buffers
)braket
op_member_access_from_pointer
id|address
comma
id|FT_BUFF_SIZE
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ft_buffer
(braket
id|ft_nr_buffers
)braket
)paren
suffix:semicolon
id|ft_buffer
(braket
id|ft_nr_buffers
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|ftape_set_nr_buffers
r_int
id|ftape_set_nr_buffers
c_func
(paren
r_int
id|cnt
)paren
(brace
r_int
id|delta
op_assign
id|cnt
op_minus
id|ft_nr_buffers
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta
OG
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|delta
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|add_one_buffer
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
id|TRACE_EXIT
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|delta
OL
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|delta
op_increment
)paren
(brace
id|del_one_buffer
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|ftape_zap_read_buffers
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
eof
