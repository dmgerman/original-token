multiline_comment|/* Yo, Emacs! we&squot;re -*- Linux-C -*-&n; *&n; *      Copyright (C) 1993-1995 Bas Laarhoven.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; *&n; *      This file contains the low-level floppy disk interface code&n; *      for the QIC-40/80 tape streamer device driver.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &quot;tracing.h&quot;
macro_line|#include &quot;fdc-io.h&quot;
macro_line|#include &quot;fdc-isr.h&quot;
macro_line|#include &quot;ftape-io.h&quot;
macro_line|#include &quot;ftape-rw.h&quot;
macro_line|#include &quot;calibr.h&quot;
macro_line|#include &quot;fc-10.h&quot;
macro_line|#include &quot;qic117.h&quot;
multiline_comment|/*      Global vars.&n; */
DECL|variable|ftape_unit
r_int
id|ftape_unit
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|ftape_motor
r_int
id|ftape_motor
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_cylinder
r_int
id|current_cylinder
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|fdc_mode
id|fdc_mode_enum
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
DECL|variable|fdc
id|fdc_config_info
id|fdc
op_assign
(brace
l_int|0
)brace
suffix:semicolon
multiline_comment|/*      Local vars.&n; */
DECL|variable|fdc_calibr_count
r_static
r_int
id|fdc_calibr_count
suffix:semicolon
DECL|variable|fdc_calibr_time
r_static
r_int
id|fdc_calibr_time
suffix:semicolon
DECL|variable|fdc_confused
r_static
r_int
id|fdc_confused
op_assign
l_int|0
suffix:semicolon
DECL|variable|fdc_status
r_static
r_int
id|fdc_status
suffix:semicolon
DECL|variable|fdc_head
r_volatile
id|byte
id|fdc_head
suffix:semicolon
multiline_comment|/* FDC head */
DECL|variable|fdc_cyl
r_volatile
id|byte
id|fdc_cyl
suffix:semicolon
multiline_comment|/* FDC track */
DECL|variable|fdc_sect
r_volatile
id|byte
id|fdc_sect
suffix:semicolon
multiline_comment|/* FDC sector */
DECL|variable|fdc_data_rate
r_static
r_int
id|fdc_data_rate
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default rate = 500 Kbps */
DECL|variable|fdc_seek_rate
r_static
r_int
id|fdc_seek_rate
op_assign
l_int|14
suffix:semicolon
multiline_comment|/* default rate = 2 msec @ 500 Kbps */
DECL|variable|do_ftape
r_static
r_void
(paren
op_star
id|do_ftape
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|variable|fdc_fifo_state
r_static
r_int
id|fdc_fifo_state
suffix:semicolon
multiline_comment|/* original fifo setting - fifo enabled */
DECL|variable|fdc_fifo_thr
r_static
r_int
id|fdc_fifo_thr
suffix:semicolon
multiline_comment|/* original fifo setting - thresshold */
DECL|variable|fdc_lock_state
r_static
r_int
id|fdc_lock_state
suffix:semicolon
multiline_comment|/* original lock setting - locked */
DECL|variable|fdc_fifo_locked
r_static
r_int
id|fdc_fifo_locked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* has fifo &amp;&amp; lock set ? */
DECL|variable|fdc_precomp
r_static
id|byte
id|fdc_precomp
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* sets fdc to default precomp. value */
DECL|variable|fdc_drv_spec
r_static
id|byte
id|fdc_drv_spec
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* drive specification bytes for i82078 */
DECL|variable|perpend_mode
r_static
r_int
id|perpend_mode
suffix:semicolon
multiline_comment|/* true if fdc is in perpendicular mode */
DECL|variable|ftape_id
r_static
r_char
id|ftape_id
(braket
)braket
op_assign
l_string|&quot;ftape&quot;
suffix:semicolon
multiline_comment|/* used by request irq and free irq */
DECL|function|fdc_catch_stray_interrupts
r_void
id|fdc_catch_stray_interrupts
c_func
(paren
r_int
id|count
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|expected_stray_interrupts
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|expected_stray_interrupts
op_add_assign
id|count
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*  Wait during a timeout period for a given FDC status.&n; *  If usecs == 0 then just test status, else wait at least for usecs.&n; *  Returns -ETIME on timeout. Function must be calibrated first !&n; */
DECL|function|fdc_wait
r_int
id|fdc_wait
c_func
(paren
r_int
id|usecs
comma
id|byte
id|mask
comma
id|byte
id|state
)paren
(brace
r_int
id|count_1
op_assign
(paren
id|fdc_calibr_count
op_star
id|usecs
op_minus
l_int|1
)paren
op_div
id|fdc_calibr_time
suffix:semicolon
r_do
(brace
id|fdc_status
op_assign
id|inb_p
c_func
(paren
id|fdc.msr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fdc_status
op_amp
id|mask
)paren
op_eq
id|state
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|count_1
op_decrement
op_ge
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|ETIME
suffix:semicolon
)brace
DECL|function|fdc_ready_wait
r_int
id|fdc_ready_wait
c_func
(paren
r_int
id|usecs
)paren
(brace
r_return
id|fdc_wait
c_func
(paren
id|usecs
comma
id|FDC_DATA_READY
comma
id|FDC_DATA_READY
)paren
suffix:semicolon
)brace
DECL|function|fdc_usec_wait
r_static
r_void
id|fdc_usec_wait
c_func
(paren
r_int
id|usecs
)paren
(brace
id|fdc_wait
c_func
(paren
id|usecs
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* will always timeout ! */
)brace
DECL|function|fdc_ready_out_wait
r_int
id|fdc_ready_out_wait
c_func
(paren
r_int
id|usecs
)paren
(brace
id|fdc_usec_wait
c_func
(paren
id|RQM_DELAY
)paren
suffix:semicolon
multiline_comment|/* wait for valid RQM status */
r_return
id|fdc_wait
c_func
(paren
id|usecs
comma
id|FDC_DATA_OUT_READY
comma
id|FDC_DATA_OUT_READY
)paren
suffix:semicolon
)brace
DECL|function|fdc_ready_in_wait
r_int
id|fdc_ready_in_wait
c_func
(paren
r_int
id|usecs
)paren
(brace
id|fdc_usec_wait
c_func
(paren
id|RQM_DELAY
)paren
suffix:semicolon
multiline_comment|/* wait for valid RQM status */
r_return
id|fdc_wait
c_func
(paren
id|usecs
comma
id|FDC_DATA_OUT_READY
comma
id|FDC_DATA_IN_READY
)paren
suffix:semicolon
)brace
DECL|function|fdc_wait_calibrate
r_int
id|fdc_wait_calibrate
c_func
(paren
r_void
)paren
(brace
r_return
id|calibrate
c_func
(paren
l_string|&quot;fdc_wait&quot;
comma
id|fdc_usec_wait
comma
op_amp
id|fdc_calibr_count
comma
op_amp
id|fdc_calibr_time
)paren
suffix:semicolon
)brace
multiline_comment|/*  Wait for a (short) while for the FDC to become ready&n; *  and transfer the next command byte.&n; *  Return -ETIME on timeout on getting ready (depends on hardware!).&n; */
DECL|function|fdc_write
r_int
id|fdc_write
c_func
(paren
id|byte
id|data
)paren
(brace
id|fdc_usec_wait
c_func
(paren
id|RQM_DELAY
)paren
suffix:semicolon
multiline_comment|/* wait for valid RQM status */
r_if
c_cond
(paren
id|fdc_wait
c_func
(paren
l_int|150
comma
id|FDC_DATA_READY_MASK
comma
id|FDC_DATA_IN_READY
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ETIME
suffix:semicolon
)brace
r_else
(brace
id|outb
c_func
(paren
id|data
comma
id|fdc.fifo
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*  Wait for a (short) while for the FDC to become ready&n; *  and transfer the next result byte.&n; *  Return -ETIME if timeout on getting ready (depends on hardware!).&n; */
DECL|function|fdc_read
r_int
id|fdc_read
c_func
(paren
id|byte
op_star
id|data
)paren
(brace
id|fdc_usec_wait
c_func
(paren
id|RQM_DELAY
)paren
suffix:semicolon
multiline_comment|/* wait for valid RQM status */
r_if
c_cond
(paren
id|fdc_wait
c_func
(paren
l_int|150
comma
id|FDC_DATA_READY_MASK
comma
id|FDC_DATA_OUT_READY
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ETIME
suffix:semicolon
)brace
r_else
(brace
op_star
id|data
op_assign
id|inb
c_func
(paren
id|fdc.fifo
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*  Output a cmd_len long command string to the FDC.&n; *  The FDC should be ready to receive a new command or&n; *  an error (EBUSY) will occur.&n; */
DECL|function|fdc_command
r_int
id|fdc_command
c_func
(paren
id|byte
op_star
id|cmd_data
comma
r_int
id|cmd_len
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_command&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|count
op_assign
id|cmd_len
suffix:semicolon
id|fdc_usec_wait
c_func
(paren
id|RQM_DELAY
)paren
suffix:semicolon
multiline_comment|/* wait for valid RQM status */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|fdc_status
op_assign
id|inb
c_func
(paren
id|fdc.msr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fdc_status
op_amp
id|FDC_DATA_READY_MASK
)paren
op_eq
id|FDC_DATA_IN_READY
)paren
(brace
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
id|fdc_mode
op_assign
op_star
id|cmd_data
suffix:semicolon
multiline_comment|/* used by isr */
id|interrupt_seen
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|result
op_assign
id|fdc_write
c_func
(paren
op_star
id|cmd_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACEx3
c_func
(paren
l_int|6
comma
l_string|&quot;fdc_mode = %02x, status = %02x at index %d&quot;
comma
(paren
r_int
)paren
id|fdc_mode
comma
(paren
r_int
)paren
id|fdc_status
comma
id|cmd_len
op_minus
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|retry
op_le
l_int|3
)paren
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;fdc_write timeout, retry&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_write timeout, fatal&quot;
)paren
suffix:semicolon
id|fdc_confused
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* recover ??? */
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
op_decrement
id|count
suffix:semicolon
op_increment
id|cmd_data
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fdc not ready&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*  Input a res_len long result string from the FDC.&n; *  The FDC should be ready to send the result or an error&n; *  (EBUSY) will occur.&n; */
DECL|function|fdc_result
r_int
id|fdc_result
c_func
(paren
id|byte
op_star
id|res_data
comma
r_int
id|res_len
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_result&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|count
op_assign
id|res_len
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|fdc_status
op_assign
id|inb
c_func
(paren
id|fdc.msr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fdc_status
op_amp
id|FDC_DATA_READY_MASK
)paren
op_eq
id|FDC_DATA_OUT_READY
)paren
(brace
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|fdc_status
op_amp
id|FDC_BUSY
)paren
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;premature end of result phase&quot;
)paren
suffix:semicolon
)brace
id|result
op_assign
id|fdc_read
c_func
(paren
id|res_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACEx3
c_func
(paren
l_int|6
comma
l_string|&quot;fdc_mode = %02x, status = %02x at index %d&quot;
comma
(paren
r_int
)paren
id|fdc_mode
comma
(paren
r_int
)paren
id|fdc_status
comma
id|res_len
op_minus
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|retry
op_le
l_int|3
)paren
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;fdc_read timeout, retry&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_read timeout, fatal&quot;
)paren
suffix:semicolon
id|fdc_confused
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* recover ??? */
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
op_decrement
id|count
suffix:semicolon
op_increment
id|res_data
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fdc not ready&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|fdc_usec_wait
c_func
(paren
id|RQM_DELAY
)paren
suffix:semicolon
multiline_comment|/* allow FDC to negate BSY */
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*      Handle command and result phases for&n; *      commands without data phase.&n; */
DECL|function|fdc_issue_command
r_int
id|fdc_issue_command
c_func
(paren
id|byte
op_star
id|out_data
comma
r_int
id|out_count
comma
id|byte
op_star
id|in_data
comma
r_int
id|in_count
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_issue_command&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|t0
comma
id|t1
suffix:semicolon
r_if
c_cond
(paren
id|out_count
OG
l_int|0
)paren
(brace
id|result
op_assign
id|fdc_command
c_func
(paren
id|out_data
comma
id|out_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_command failed&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
)brace
multiline_comment|/* will take 24 - 30 usec for fdc_sense_drive_status and&n;&t; * fdc_sense_interrupt_status commands.&n;&t; *    35 fails sometimes (5/9/93 SJL)&n;&t; * On a loaded system it incidentally takes longer than&n;&t; * this for the fdc to get ready ! ?????? WHY ??????&n;&t; * So until we know what&squot;s going on use a very long timeout.&n;&t; */
id|t0
op_assign
id|timestamp
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
id|fdc_ready_out_wait
c_func
(paren
l_int|500
multiline_comment|/* usec */
)paren
suffix:semicolon
id|t1
op_assign
id|timestamp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACEi
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_ready_out_wait failed after:&quot;
comma
id|timediff
c_func
(paren
id|t0
comma
id|t1
)paren
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
id|in_count
OG
l_int|0
)paren
(brace
id|result
op_assign
id|fdc_result
c_func
(paren
id|in_data
comma
id|in_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;result phase aborted&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      Wait for FDC interrupt with timeout.&n; *      Signals are blocked so the wait will not be aborted.&n; *      Note: interrupts must be enabled ! (23/05/93 SJL)&n; */
DECL|function|fdc_interrupt_wait
r_int
id|fdc_interrupt_wait
c_func
(paren
r_int
id|time
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_interrupt_wait&quot;
)paren
suffix:semicolon
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_int
id|result
op_assign
op_minus
id|ETIME
suffix:semicolon
r_int
id|need_cleanup
op_assign
l_int|0
suffix:semicolon
r_int
id|current_blocked
op_assign
id|current-&gt;blocked
suffix:semicolon
r_static
r_int
id|resetting
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|wait_intr
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;error: nested call&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* return error... */
)brace
r_if
c_cond
(paren
id|interrupt_seen
op_eq
l_int|0
)paren
(brace
multiline_comment|/* timeout time will be between 0 and MSPT milliseconds too long !&n;&t;&t; */
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
l_int|1
op_plus
(paren
id|time
op_plus
id|MSPT
op_minus
l_int|1
)paren
op_div
id|MSPT
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;blocked
op_assign
id|_BLOCK_ALL
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|wait_intr
comma
op_amp
id|wait
)paren
suffix:semicolon
r_do
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* sets TASK_RUNNING on timeout */
)brace
r_while
c_loop
(paren
op_logical_neg
id|interrupt_seen
op_logical_and
id|current-&gt;state
op_ne
id|TASK_RUNNING
)paren
suffix:semicolon
id|current-&gt;blocked
op_assign
id|current_blocked
suffix:semicolon
multiline_comment|/* restore */
id|remove_wait_queue
c_func
(paren
op_amp
id|wait_intr
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|interrupt_seen
)paren
(brace
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* interrupt hasn&squot;t cleared this */
id|result
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
macro_line|#if 1
multiline_comment|/*** remove me when sure this doesn&squot;t happen ***/
r_if
c_cond
(paren
id|current-&gt;timeout
OG
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;*** BUG: unexpected schedule exit ***&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;caused by signal ?&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|result
op_assign
op_minus
id|EINTR
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
op_minus
id|ETIME
suffix:semicolon
)brace
id|need_cleanup
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* missing interrupt, reset fdc. */
)brace
)brace
r_else
(brace
id|result
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  In first instance, next statement seems unnecessary since&n;&t; *  it will be cleared in fdc_command. However, a small part of&n;&t; *  the software seems to rely on this being cleared here&n;&t; *  (ftape_close might fail) so stick to it until things get fixed !&n;&t; */
id|interrupt_seen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear for next call */
r_if
c_cond
(paren
id|need_cleanup
op_amp
op_logical_neg
id|resetting
)paren
(brace
id|resetting
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* break infinite recursion if reset fails */
id|TRACE
c_func
(paren
l_int|8
comma
l_string|&quot;cleanup reset&quot;
)paren
suffix:semicolon
id|fdc_reset
c_func
(paren
)paren
suffix:semicolon
id|resetting
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*      Start/stop drive motor. Enable DMA mode.&n; */
DECL|function|fdc_motor
r_void
id|fdc_motor
c_func
(paren
r_int
id|motor
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_motor&quot;
)paren
suffix:semicolon
r_int
id|unit
op_assign
id|FTAPE_UNIT
suffix:semicolon
r_int
id|data
op_assign
id|unit
op_or
id|FDC_RESET_NOT
op_or
id|FDC_DMA_MODE
suffix:semicolon
id|ftape_motor
op_assign
id|motor
suffix:semicolon
r_if
c_cond
(paren
id|ftape_motor
)paren
(brace
id|data
op_or_assign
id|FDC_MOTOR_0
op_lshift
id|unit
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;turning motor %d on&quot;
comma
id|unit
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;turning motor %d off&quot;
comma
id|unit
)paren
suffix:semicolon
)brace
macro_line|#ifdef MACH2
id|outb_p
c_func
(paren
id|data
comma
id|fdc.dor2
)paren
suffix:semicolon
macro_line|#else
id|outb_p
c_func
(paren
id|data
comma
id|fdc.dor
)paren
suffix:semicolon
macro_line|#endif
id|ftape_sleep
c_func
(paren
l_int|10
op_star
id|MILLISECOND
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|fdc_update_dsr
r_static
r_void
id|fdc_update_dsr
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_update_dsr&quot;
)paren
suffix:semicolon
id|TRACEx2
c_func
(paren
l_int|5
comma
l_string|&quot;rate = %d, precomp = %d&quot;
comma
id|fdc_data_rate
comma
id|fdc_precomp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc.type
op_ge
id|i82077
)paren
(brace
id|outb_p
c_func
(paren
(paren
id|fdc_data_rate
op_amp
l_int|0x03
)paren
op_or
id|fdc_precomp
comma
id|fdc.dsr
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb_p
c_func
(paren
id|fdc_data_rate
comma
id|fdc.ccr
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|fdc_set_write_precomp
r_void
id|fdc_set_write_precomp
c_func
(paren
r_int
id|precomp
)paren
(brace
multiline_comment|/*  write precompensation can be set in multiples of 41.67 nsec.&n;&t; *  round the parameter to the nearest multiple and convert it&n;&t; *  into a fdc setting. Note that 0 means default to the fdc,&n;&t; *  7 is used instead of that.&n;&t; */
id|fdc_precomp
op_assign
(paren
(paren
id|precomp
op_plus
l_int|21
)paren
op_div
l_int|42
)paren
op_lshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|fdc_precomp
op_eq
l_int|0
)paren
(brace
id|fdc_precomp
op_assign
l_int|7
op_lshift
l_int|2
suffix:semicolon
)brace
id|fdc_update_dsr
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Read back the Drive Specification regs on a i82078, so that we&n; * are able to restore them later&n; */
DECL|function|fdc_save_drive_specs
r_void
id|fdc_save_drive_specs
c_func
(paren
r_void
)paren
(brace
id|byte
id|cmd1
(braket
)braket
op_assign
(brace
id|FDC_DRIVE_SPEC
comma
l_int|0x80
)brace
suffix:semicolon
id|byte
id|cmd2
(braket
)braket
op_assign
(brace
id|FDC_DRIVE_SPEC
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xc0
)brace
suffix:semicolon
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_save_drive_specs&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc.type
op_ge
id|i82078_1
)paren
(brace
id|result
op_assign
id|fdc_issue_command
c_func
(paren
id|cmd1
comma
id|NR_ITEMS
c_func
(paren
id|cmd1
)paren
comma
id|fdc_drv_spec
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|cmd2
(braket
l_int|1
)braket
op_assign
(paren
id|fdc_drv_spec
(braket
l_int|0
)braket
op_amp
l_int|0x03
)paren
op_or
l_int|0x04
suffix:semicolon
id|cmd2
(braket
l_int|2
)braket
op_assign
(paren
id|fdc_drv_spec
(braket
l_int|1
)braket
op_amp
l_int|0x03
)paren
op_or
l_int|0x24
suffix:semicolon
id|cmd2
(braket
l_int|3
)braket
op_assign
(paren
id|fdc_drv_spec
(braket
l_int|2
)braket
op_amp
l_int|0x03
)paren
op_or
l_int|0x44
suffix:semicolon
id|cmd2
(braket
l_int|4
)braket
op_assign
(paren
id|fdc_drv_spec
(braket
l_int|3
)braket
op_amp
l_int|0x03
)paren
op_or
l_int|0x64
suffix:semicolon
id|fdc_command
c_func
(paren
id|cmd2
comma
id|NR_ITEMS
c_func
(paren
id|cmd2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;Setting of drive specs failed&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Save of drive specs failed&quot;
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/* Restore the previously saved Drive Specification values */
DECL|function|fdc_restore_drive_specs
r_void
id|fdc_restore_drive_specs
c_func
(paren
r_void
)paren
(brace
id|byte
id|cmd
(braket
)braket
op_assign
(brace
id|FDC_DRIVE_SPEC
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xc0
)brace
suffix:semicolon
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_restore_drive_specs&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc.type
OG
id|i82078_1
)paren
(brace
id|cmd
(braket
l_int|1
)braket
op_assign
(paren
id|fdc_drv_spec
(braket
l_int|0
)braket
op_amp
l_int|0x1f
)paren
op_or
l_int|0x00
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
(paren
id|fdc_drv_spec
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
op_or
l_int|0x20
suffix:semicolon
id|cmd
(braket
l_int|3
)braket
op_assign
(paren
id|fdc_drv_spec
(braket
l_int|2
)braket
op_amp
l_int|0x1f
)paren
op_or
l_int|0x40
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
(paren
id|fdc_drv_spec
(braket
l_int|3
)braket
op_amp
l_int|0x1f
)paren
op_or
l_int|0x60
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|cmd
comma
id|NR_ITEMS
c_func
(paren
id|cmd
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Restoration of drive specs failed&quot;
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/* Select clock for fdc, must correspond with tape drive setting !&n; * This also influences the fdc timing so we must adjust some values.&n; */
DECL|function|fdc_set_data_rate
r_void
id|fdc_set_data_rate
c_func
(paren
r_int
id|rate
)paren
(brace
multiline_comment|/* Select clock for fdc, must correspond with tape drive setting !&n;&t; * This also influences the fdc timing so we must adjust some values.&n;&t; */
id|fdc_data_rate
op_assign
id|rate
suffix:semicolon
id|fdc_update_dsr
c_func
(paren
)paren
suffix:semicolon
id|fdc_set_seek_rate
c_func
(paren
id|fdc_seek_rate
)paren
suffix:semicolon
multiline_comment|/* re-adjust for changed clock */
)brace
multiline_comment|/*      Reset the floppy disk controller. Leave the ftape_unit selected.&n; */
DECL|function|fdc_reset
r_void
id|fdc_reset
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_reset&quot;
)paren
suffix:semicolon
r_int
id|unit
op_assign
id|FTAPE_UNIT
suffix:semicolon
id|byte
id|fdc_ctl
op_assign
id|unit
op_or
id|FDC_DMA_MODE
suffix:semicolon
r_int
id|st0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|dummy
suffix:semicolon
r_if
c_cond
(paren
id|ftape_motor
)paren
(brace
id|fdc_ctl
op_or_assign
id|FDC_MOTOR_0
op_lshift
id|unit
suffix:semicolon
)brace
macro_line|#ifdef MACH2
id|outb_p
c_func
(paren
id|fdc_ctl
op_amp
l_int|0x0f
comma
id|fdc.dor
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|fdc_ctl
comma
id|fdc.dor2
)paren
suffix:semicolon
macro_line|#else
id|outb_p
c_func
(paren
id|fdc_ctl
comma
id|fdc.dor
)paren
suffix:semicolon
multiline_comment|/* assert reset, keep unit selected */
macro_line|#endif
id|fdc_usec_wait
c_func
(paren
l_int|10
multiline_comment|/* usec */
)paren
suffix:semicolon
multiline_comment|/* delay &gt;= 14 fdc clocks */
id|fdc_ctl
op_or_assign
id|FDC_RESET_NOT
suffix:semicolon
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
macro_line|#ifdef MACH2
id|outb_p
c_func
(paren
id|fdc_ctl
op_amp
l_int|0x0f
comma
id|fdc.dor
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|fdc_ctl
comma
id|fdc.dor2
)paren
suffix:semicolon
macro_line|#else
id|outb_p
c_func
(paren
id|fdc_ctl
comma
id|fdc.dor
)paren
suffix:semicolon
multiline_comment|/* release reset */
macro_line|#endif
id|result
op_assign
id|fdc_interrupt_wait
c_func
(paren
l_int|1
op_star
id|SECOND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;missing interrupt after reset&quot;
)paren
suffix:semicolon
)brace
id|fdc_set_data_rate
c_func
(paren
id|fdc_data_rate
)paren
suffix:semicolon
multiline_comment|/* keep original setting */
id|fdc_usec_wait
c_func
(paren
l_int|1000
multiline_comment|/* usec */
)paren
suffix:semicolon
multiline_comment|/* don&squot;t know why, but needed */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/* clear disk-change status */
id|fdc_sense_interrupt_status
c_func
(paren
op_amp
id|st0
comma
op_amp
id|dummy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|unit
)paren
(brace
id|current_cylinder
op_assign
id|dummy
suffix:semicolon
)brace
)brace
id|fdc_set_seek_rate
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/* When we&squot;re done, put the fdc into reset mode so that the regular&n;   floppy disk driver will figure out that something is wrong and&n;   initialize the controller the way it wants. */
DECL|function|fdc_disable
r_void
id|fdc_disable
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_disable&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
id|byte
id|cmd1
(braket
)braket
op_assign
(brace
id|FDC_CONFIGURE
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|byte
id|cmd2
(braket
)braket
op_assign
(brace
id|FDC_LOCK
)brace
suffix:semicolon
id|byte
id|cmd3
(braket
)braket
op_assign
(brace
id|FDC_UNLOCK
)brace
suffix:semicolon
id|byte
id|stat
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|CLK_48MHZ
op_logical_and
id|fdc.type
op_ge
id|i82078
)paren
id|cmd1
(braket
l_int|0
)braket
op_or_assign
id|FDC_CLK48_BIT
suffix:semicolon
r_if
c_cond
(paren
id|fdc_fifo_locked
)paren
(brace
id|result
op_assign
id|fdc_issue_command
c_func
(paren
id|cmd3
comma
l_int|1
comma
id|stat
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
op_logical_or
id|stat
(braket
l_int|0
)braket
op_ne
l_int|0x00
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;couldn&squot;t unlock fifo, configuration remains changed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|cmd1
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|fdc_fifo_state
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x20
)paren
op_plus
(paren
id|fdc_fifo_thr
op_minus
l_int|1
)paren
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|cmd1
comma
id|NR_ITEMS
c_func
(paren
id|cmd1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;couldn&squot;t reconfigure fifo to old state&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|fdc_lock_state
)paren
(brace
id|result
op_assign
id|fdc_issue_command
c_func
(paren
id|cmd2
comma
l_int|1
comma
id|stat
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;couldn&squot;t lock old state again&quot;
)paren
suffix:semicolon
)brace
)brace
id|TRACEx3
c_func
(paren
l_int|5
comma
l_string|&quot;fifo restored: %sabled, thr. %d, %slocked&quot;
comma
id|fdc_fifo_state
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
comma
id|fdc_fifo_thr
comma
(paren
id|fdc_lock_state
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;not &quot;
)paren
suffix:semicolon
)brace
id|fdc_fifo_locked
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MACH2
id|outb_p
c_func
(paren
id|FTAPE_UNIT
op_amp
l_int|0x0f
comma
id|fdc.dor
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|FTAPE_UNIT
comma
id|fdc.dor2
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|FDC_RESET_NOT
op_amp
l_int|0x0f
comma
id|fdc.dor
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|FDC_RESET_NOT
comma
id|fdc.dor2
)paren
suffix:semicolon
macro_line|#else
id|outb_p
c_func
(paren
id|FTAPE_UNIT
comma
id|fdc.dor
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|FDC_RESET_NOT
comma
id|fdc.dor
)paren
suffix:semicolon
macro_line|#endif
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*      Specify FDC seek-rate&n; */
DECL|function|fdc_set_seek_rate
r_int
id|fdc_set_seek_rate
c_func
(paren
r_int
id|seek_rate
)paren
(brace
id|byte
id|in
(braket
l_int|3
)braket
suffix:semicolon
r_const
r_int
id|hut
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* minimize head unload time */
r_const
r_int
id|hlt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* minimize head load time */
r_const
r_int
id|rates
(braket
)braket
op_assign
(brace
l_int|250
comma
l_int|2000
comma
l_int|500
comma
l_int|1000
)brace
suffix:semicolon
id|in
(braket
l_int|0
)braket
op_assign
id|FDC_SPECIFY
suffix:semicolon
id|in
(braket
l_int|1
)braket
op_assign
(paren
(paren
(paren
l_int|16
op_minus
(paren
id|rates
(braket
id|fdc_data_rate
op_amp
l_int|0x03
)braket
op_star
id|seek_rate
)paren
op_div
l_int|500
)paren
op_lshift
l_int|4
)paren
op_or
id|hut
)paren
suffix:semicolon
id|in
(braket
l_int|2
)braket
op_assign
(paren
id|hlt
op_lshift
l_int|1
)paren
op_or
l_int|0
suffix:semicolon
id|fdc_seek_rate
op_assign
id|seek_rate
suffix:semicolon
r_return
id|fdc_command
c_func
(paren
id|in
comma
l_int|3
)paren
suffix:semicolon
)brace
multiline_comment|/*      Sense drive status: get unit&squot;s drive status (ST3)&n; */
DECL|function|fdc_sense_drive_status
r_int
id|fdc_sense_drive_status
c_func
(paren
r_int
op_star
id|st3
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_sense_drive_status&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
id|byte
id|out
(braket
l_int|2
)braket
suffix:semicolon
id|byte
id|in
(braket
l_int|1
)braket
suffix:semicolon
id|out
(braket
l_int|0
)braket
op_assign
id|FDC_SENSED
suffix:semicolon
id|out
(braket
l_int|1
)braket
op_assign
id|FTAPE_UNIT
suffix:semicolon
id|result
op_assign
id|fdc_issue_command
c_func
(paren
id|out
comma
l_int|2
comma
id|in
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;issue_command failed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|st3
op_assign
id|in
(braket
l_int|0
)braket
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*      Sense Interrupt Status command:&n; *      should be issued at the end of each seek.&n; *      get ST0 and current cylinder.&n; */
DECL|function|fdc_sense_interrupt_status
r_int
id|fdc_sense_interrupt_status
c_func
(paren
r_int
op_star
id|st0
comma
r_int
op_star
id|current_cylinder
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_sense_interrupt_status&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
id|byte
id|out
(braket
l_int|1
)braket
suffix:semicolon
id|byte
id|in
(braket
l_int|2
)braket
suffix:semicolon
id|out
(braket
l_int|0
)braket
op_assign
id|FDC_SENSEI
suffix:semicolon
id|result
op_assign
id|fdc_issue_command
c_func
(paren
id|out
comma
l_int|1
comma
id|in
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;issue_command failed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|st0
op_assign
id|in
(braket
l_int|0
)braket
suffix:semicolon
op_star
id|current_cylinder
op_assign
id|in
(braket
l_int|1
)braket
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*      step to track&n; */
DECL|function|fdc_seek
r_int
id|fdc_seek
c_func
(paren
r_int
id|track
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_seek&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
id|byte
id|out
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|st0
comma
id|pcn
suffix:semicolon
id|out
(braket
l_int|0
)braket
op_assign
id|FDC_SEEK
suffix:semicolon
id|out
(braket
l_int|1
)braket
op_assign
id|FTAPE_UNIT
suffix:semicolon
id|out
(braket
l_int|2
)braket
op_assign
id|track
suffix:semicolon
id|seek_completed
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|out
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|TRACEi
c_func
(paren
l_int|1
comma
l_string|&quot;failed, status =&quot;
comma
id|result
)paren
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;destination was: %d, resetting FDC...&quot;
comma
id|track
)paren
suffix:semicolon
multiline_comment|/*  We really need this command to work !&n;&t;&t; */
id|fdc_reset
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*    Handle interrupts until seek_completed or timeout.&n;&t; */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|result
op_assign
id|fdc_interrupt_wait
c_func
(paren
l_int|2
op_star
id|SECOND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACEi
c_func
(paren
l_int|2
comma
l_string|&quot;fdc_interrupt_wait timeout, status =&quot;
comma
id|result
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|seek_completed
)paren
(brace
id|result
op_assign
id|fdc_sense_interrupt_status
c_func
(paren
op_amp
id|st0
comma
op_amp
id|pcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|TRACEi
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_sense_interrupt_status failed, status =&quot;
comma
id|result
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|st0
op_amp
id|ST0_SEEK_END
)paren
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;no seek-end after seek completion !??&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*    Verify whether we issued the right tape command.&n;&t; */
multiline_comment|/* Verify that we seek to the proper track. */
r_if
c_cond
(paren
id|pcn
op_ne
id|track
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;bad seek..&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|current_cylinder
op_assign
id|pcn
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      Recalibrate and wait until home.&n; */
DECL|function|fdc_recalibrate
r_int
id|fdc_recalibrate
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_recalibrate&quot;
)paren
suffix:semicolon
r_int
id|result
suffix:semicolon
id|byte
id|out
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|st0
suffix:semicolon
r_int
id|pcn
suffix:semicolon
r_int
id|retry
suffix:semicolon
id|result
op_assign
id|fdc_set_seek_rate
c_func
(paren
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|TRACEi
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_set_seek_rate failed, status =&quot;
comma
id|result
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|out
(braket
l_int|0
)braket
op_assign
id|FDC_RECAL
suffix:semicolon
id|out
(braket
l_int|1
)braket
op_assign
id|FTAPE_UNIT
suffix:semicolon
id|seek_completed
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|out
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|TRACEi
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_command failed, status =&quot;
comma
id|result
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*    Handle interrupts until seek_completed or timeout.&n;&t; */
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
op_increment
id|retry
)paren
(brace
id|result
op_assign
id|fdc_interrupt_wait
c_func
(paren
l_int|2
op_star
id|SECOND
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_interrupt_wait failed&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_and
id|seek_completed
)paren
(brace
id|result
op_assign
id|fdc_sense_interrupt_status
c_func
(paren
op_amp
id|st0
comma
op_amp
id|pcn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|TRACEi
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_sense_interrupt_status failed, status =&quot;
comma
id|result
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|st0
op_amp
id|ST0_SEEK_END
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|retry
OL
l_int|1
)paren
(brace
r_continue
suffix:semicolon
multiline_comment|/* some drives/fdc&squot;s give an extra interrupt */
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;no seek-end after seek completion !??&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
)brace
id|current_cylinder
op_assign
id|pcn
suffix:semicolon
r_if
c_cond
(paren
id|pcn
op_ne
l_int|0
)paren
(brace
id|TRACEi
c_func
(paren
l_int|1
comma
l_string|&quot;failed: resulting track =&quot;
comma
id|pcn
)paren
suffix:semicolon
)brace
id|result
op_assign
id|fdc_set_seek_rate
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|TRACEi
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_set_seek_rate failed, status =&quot;
comma
id|result
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      Setup Floppy Disk Controller and DMA to read or write the next cluster&n; *      of good sectors from or to the current segment.&n; */
DECL|function|setup_fdc_and_dma
r_int
id|setup_fdc_and_dma
c_func
(paren
id|buffer_struct
op_star
id|buff
comma
r_int
r_char
id|operation
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;setup_fdc_and_dma&quot;
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|byte
id|perpend
(braket
)braket
op_assign
(brace
id|FDC_PERPEND
comma
l_int|0x00
)brace
suffix:semicolon
r_int
r_char
id|out
(braket
l_int|9
)braket
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|dma_mode
suffix:semicolon
r_if
c_cond
(paren
id|operation
op_eq
id|FDC_READ
op_logical_or
id|operation
op_eq
id|FDC_READ_DELETED
)paren
(brace
id|dma_mode
op_assign
id|DMA_MODE_READ
suffix:semicolon
r_if
c_cond
(paren
id|qic_std
op_eq
id|QIC_TAPE_QIC3020
)paren
(brace
r_if
c_cond
(paren
id|fdc.type
OL
id|i82077AA
)paren
(brace
multiline_comment|/* fdc does not support perpendicular mode. complain */
id|TRACE
c_func
(paren
l_int|0
comma
l_string|&quot;Your FDC does not support QIC-3020.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* enable perpendicular mode */
id|perpend
(braket
l_int|1
)braket
op_assign
l_int|0x83
op_plus
(paren
l_int|0x04
op_lshift
id|FTAPE_UNIT
)paren
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|perpend
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;Perpendicular mode entry failed!&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;Perpendicular mode entered&quot;
)paren
suffix:semicolon
id|perpend_mode
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|perpend_mode
)paren
(brace
multiline_comment|/* Turn off perpendicular mode */
id|perpend
(braket
l_int|1
)braket
op_assign
l_int|0x80
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|perpend
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;Perpendicular mode exit failed!&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;Perpendicular mode exited&quot;
)paren
suffix:semicolon
id|perpend_mode
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|TRACEx2
c_func
(paren
l_int|5
comma
l_string|&quot;xfer %d sectors to 0x%p&quot;
comma
id|buff-&gt;sector_count
comma
id|buff-&gt;ptr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|operation
op_eq
id|FDC_WRITE
op_logical_or
id|operation
op_eq
id|FDC_WRITE_DELETED
)paren
(brace
id|dma_mode
op_assign
id|DMA_MODE_WRITE
suffix:semicolon
multiline_comment|/* When writing QIC-3020 tapes, turn on perpendicular mode.&n;&t;&t; */
r_if
c_cond
(paren
id|qic_std
op_eq
id|QIC_TAPE_QIC3020
)paren
(brace
r_if
c_cond
(paren
id|fdc.type
OL
id|i82077AA
)paren
(brace
multiline_comment|/* fdc does not support perpendicular mode: complain */
id|TRACE
c_func
(paren
l_int|0
comma
l_string|&quot;Your FDC does not support QIC-3020.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|perpend
(braket
l_int|1
)braket
op_assign
l_int|0x83
op_plus
(paren
l_int|0x4
op_lshift
id|FTAPE_UNIT
)paren
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|perpend
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;Perpendicular mode entry failed!&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;Perpendicular mode entered&quot;
)paren
suffix:semicolon
id|perpend_mode
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|perpend_mode
)paren
(brace
id|perpend
(braket
l_int|1
)braket
op_assign
l_int|0x80
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|perpend
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;Perpendicular mode exit failed!&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;Perpendicular mode exited&quot;
)paren
suffix:semicolon
id|perpend_mode
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|TRACEx2
c_func
(paren
l_int|5
comma
l_string|&quot;xfer %d sectors from 0x%p&quot;
comma
id|buff-&gt;sector_count
comma
id|buff-&gt;ptr
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;bug: illegal operation parameter&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Program the DMA controller.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* could be called from ISR ! */
id|disable_dma
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|fdc.dma
comma
id|dma_mode
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|fdc.dma
comma
(paren
r_int
)paren
id|buff-&gt;ptr
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|fdc.dma
comma
id|SECTOR_SIZE
op_star
id|buff-&gt;sector_count
)paren
suffix:semicolon
macro_line|#ifdef GCC_2_4_5_BUG
multiline_comment|/*  This seemingly stupid construction confuses the gcc-2.4.5&n;&t; *  code generater enough to create correct code.&n;&t; */
r_if
c_cond
(paren
l_int|1
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1
suffix:semicolon
op_increment
id|i
)paren
(brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|enable_dma
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
multiline_comment|/* Issue FDC command to start reading/writing.&n;&t; */
id|out
(braket
l_int|0
)braket
op_assign
id|operation
suffix:semicolon
id|out
(braket
l_int|1
)braket
op_assign
id|FTAPE_UNIT
suffix:semicolon
id|out
(braket
l_int|2
)braket
op_assign
id|buff-&gt;cyl
suffix:semicolon
id|out
(braket
l_int|3
)braket
op_assign
id|buff-&gt;head
suffix:semicolon
id|out
(braket
l_int|4
)braket
op_assign
id|buff-&gt;sect
op_plus
id|buff-&gt;sector_offset
suffix:semicolon
id|out
(braket
l_int|5
)braket
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* Sector size of 1K. */
id|out
(braket
l_int|6
)braket
op_assign
id|out
(braket
l_int|4
)braket
op_plus
id|buff-&gt;sector_count
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* last sector */
id|out
(braket
l_int|7
)braket
op_assign
l_int|109
suffix:semicolon
multiline_comment|/* Gap length. */
id|out
(braket
l_int|8
)braket
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* No limit to transfer size. */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|TRACEx4
c_func
(paren
l_int|6
comma
l_string|&quot;C: 0x%02x, H: 0x%02x, R: 0x%02x, cnt: 0x%02x&quot;
comma
id|out
(braket
l_int|2
)braket
comma
id|out
(braket
l_int|3
)braket
comma
id|out
(braket
l_int|4
)braket
comma
id|out
(braket
l_int|6
)braket
op_minus
id|out
(braket
l_int|4
)braket
op_plus
l_int|1
)paren
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|out
comma
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ne
l_int|0
)paren
(brace
id|fdc_mode
op_assign
id|fdc_idle
suffix:semicolon
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;fdc_command failed&quot;
)paren
suffix:semicolon
)brace
id|fdc_setup_error
op_assign
id|result
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|fdc_fifo_enable
r_int
id|fdc_fifo_enable
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_fifo_enable&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|byte
id|cmd0
(braket
)braket
op_assign
(brace
id|FDC_DUMPREGS
)brace
suffix:semicolon
id|byte
id|cmd1
(braket
)braket
op_assign
(brace
id|FDC_CONFIGURE
comma
l_int|0
comma
l_int|0x07
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* enable fifo, thr = 8 */
id|byte
id|cmd2
(braket
)braket
op_assign
(brace
id|FDC_LOCK
)brace
suffix:semicolon
id|byte
id|cmd3
(braket
)braket
op_assign
(brace
id|FDC_UNLOCK
)brace
suffix:semicolon
id|byte
id|stat
suffix:semicolon
id|byte
id|reg
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|CLK_48MHZ
op_logical_and
id|fdc.type
op_ge
id|i82078
)paren
id|cmd1
(braket
l_int|0
)braket
op_or_assign
id|FDC_CLK48_BIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fdc_fifo_locked
)paren
(brace
multiline_comment|/*  Dump fdc internal registers for examination&n;&t;&t; */
id|result
op_assign
id|fdc_command
c_func
(paren
id|cmd0
comma
id|NR_ITEMS
c_func
(paren
id|cmd0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;FDC dumpreg command failed, fifo unchanged&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  Now read fdc internal registers from fifo&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_ITEMS
c_func
(paren
id|reg
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|fdc_read
c_func
(paren
op_amp
id|reg
(braket
id|i
)braket
)paren
suffix:semicolon
id|TRACEx2
c_func
(paren
l_int|6
comma
l_string|&quot;Register %d = 0x%02x&quot;
comma
id|i
comma
id|reg
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|fdc_fifo_state
op_assign
(paren
id|reg
(braket
l_int|8
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0
suffix:semicolon
id|fdc_lock_state
op_assign
id|reg
(braket
l_int|7
)braket
op_amp
l_int|0x80
suffix:semicolon
id|fdc_fifo_thr
op_assign
l_int|1
op_plus
(paren
id|reg
(braket
l_int|8
)braket
op_amp
l_int|0x0f
)paren
suffix:semicolon
id|TRACEx3
c_func
(paren
l_int|5
comma
l_string|&quot;original fifo state: %sabled, thresshold %d, %slocked&quot;
comma
(paren
id|fdc_fifo_state
)paren
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
comma
id|fdc_fifo_thr
comma
(paren
id|fdc_lock_state
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;not &quot;
)paren
suffix:semicolon
multiline_comment|/*  If fdc is already locked, unlock it first !&n;&t;&t;&t; */
r_if
c_cond
(paren
id|fdc_lock_state
)paren
(brace
id|fdc_ready_wait
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|cmd3
comma
id|NR_ITEMS
c_func
(paren
id|cmd3
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;FDC unlock command failed, configuration unchanged&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
multiline_comment|/*  Enable fifo and set thresshold at xx bytes to allow a&n;&t;&t;&t; *  reasonably large latency and reduce number of dma bursts.&n;&t;&t;&t; */
id|fdc_ready_wait
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|result
op_assign
id|fdc_command
c_func
(paren
id|cmd1
comma
id|NR_ITEMS
c_func
(paren
id|cmd1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;FDC configure command failed, fifo unchanged&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*  Now lock configuration so reset will not change it&n;&t;&t;&t;&t; */
id|result
op_assign
id|fdc_issue_command
c_func
(paren
id|cmd2
comma
id|NR_ITEMS
c_func
(paren
id|cmd2
)paren
comma
op_amp
id|stat
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
op_logical_or
id|stat
op_ne
l_int|0x10
)paren
(brace
id|TRACEx1
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;FDC lock command failed, stat = 0x%02x&quot;
comma
id|stat
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|fdc_fifo_locked
op_assign
l_int|1
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Fifo not enabled because locked&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*   Determine fd controller type &n; */
DECL|variable|fdc_save_state
r_static
id|byte
id|fdc_save_state
(braket
l_int|2
)braket
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|function|fdc_probe
r_int
id|fdc_probe
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_probe&quot;
)paren
suffix:semicolon
id|byte
id|cmd
(braket
l_int|1
)braket
suffix:semicolon
id|byte
id|stat
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* must be able to hold dumpregs &amp; save results */
r_int
id|result
suffix:semicolon
multiline_comment|/*  Try to find out what kind of fd controller we have to deal with&n;&t; *  Scheme borrowed from floppy driver:&n;&t; *  first try if FDC_DUMPREGS command works&n;&t; *  (this indicates that we have a 82072 or better)&n;&t; *  then try the FDC_VERSION command (82072 doesn&squot;t support this)&n;&t; *  then try the FDC_UNLOCK command (some older 82077&squot;s don&squot;t support this)&n;&t; *  then try the FDC_PARTID command (82078&squot;s support this)&n;&t; */
id|cmd
(braket
l_int|0
)braket
op_assign
id|FDC_DUMPREGS
suffix:semicolon
id|result
op_assign
id|fdc_issue_command
c_func
(paren
id|cmd
comma
l_int|1
comma
id|stat
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|stat
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
(brace
multiline_comment|/* invalid command: must be pre 82072&n;&t;&t;&t; */
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Type 8272A/765A compatible FDC found&quot;
)paren
suffix:semicolon
id|result
op_assign
id|i8272
suffix:semicolon
)brace
r_else
(brace
id|fdc_result
c_func
(paren
op_amp
id|stat
(braket
l_int|1
)braket
comma
l_int|9
)paren
suffix:semicolon
id|fdc_save_state
(braket
l_int|0
)braket
op_assign
id|stat
(braket
l_int|7
)braket
suffix:semicolon
id|fdc_save_state
(braket
l_int|1
)braket
op_assign
id|stat
(braket
l_int|8
)braket
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|FDC_VERSION
suffix:semicolon
id|result
op_assign
id|fdc_issue_command
c_func
(paren
id|cmd
comma
l_int|1
comma
id|stat
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
op_logical_or
id|stat
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Type 82072 FDC found&quot;
)paren
suffix:semicolon
id|result
op_assign
id|i8272
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|stat
op_eq
l_int|0x90
)paren
(brace
id|cmd
(braket
l_int|0
)braket
op_assign
id|FDC_UNLOCK
suffix:semicolon
id|result
op_assign
id|fdc_issue_command
c_func
(paren
id|cmd
comma
l_int|1
comma
id|stat
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
op_logical_or
id|stat
(braket
l_int|0
)braket
op_ne
l_int|0x00
)paren
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Type pre-1991 82077 FDC found, treating it like a 82072&quot;
)paren
suffix:semicolon
id|result
op_assign
id|i8272
suffix:semicolon
)brace
r_else
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|fdc_save_state
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
(brace
multiline_comment|/* was locked */
id|cmd
(braket
l_int|0
)braket
op_assign
id|FDC_LOCK
suffix:semicolon
multiline_comment|/* restore lock */
id|result
op_assign
id|fdc_issue_command
c_func
(paren
id|cmd
comma
l_int|1
comma
id|stat
comma
l_int|1
)paren
suffix:semicolon
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;FDC is already locked&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Test for a i82078 FDC */
id|cmd
(braket
l_int|0
)braket
op_assign
id|FDC_PARTID
suffix:semicolon
id|result
op_assign
id|fdc_issue_command
c_func
(paren
id|cmd
comma
l_int|1
comma
id|stat
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
op_logical_or
id|stat
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
(brace
multiline_comment|/* invalid command: not a i82078xx type FDC */
id|result
op_assign
id|no_fdc
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
id|outb_p
c_func
(paren
id|i
comma
id|fdc.tdr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
id|fdc.tdr
)paren
op_amp
l_int|0x03
)paren
op_ne
id|i
)paren
(brace
id|result
op_assign
id|i82077
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
op_eq
id|no_fdc
)paren
(brace
id|result
op_assign
id|i82077AA
suffix:semicolon
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Type 82077AA FDC found&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Type 82077 FDC found&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* FDC_PARTID cmd succeeded */
r_switch
c_cond
(paren
id|stat
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
(brace
r_case
l_int|0x0
suffix:colon
multiline_comment|/* i82078SL or i82078-1.  The SL part cannot run at 2Mbps (the&n;&t;&t;&t;&t;&t;&t;&t; * SL and -1 dies are identical; they are speed graded after&n;&t;&t;&t;&t;&t;&t;&t; * production, according to Intel).  Some SL&squot;s can be detected&n;&t;&t;&t;&t;&t;&t;&t; * by doing a SAVE cmd and look at bit 7 of the first byte (the&n;&t;&t;&t;&t;&t;&t;&t; * SEL3V# bit).  If it is 0, the part runs off 3Volts, and hence&n;&t;&t;&t;&t;&t;&t;&t; * it is a SL.&n;&t;&t;&t;&t;&t;&t;&t; */
id|cmd
(braket
l_int|0
)braket
op_assign
id|FDC_SAVE
suffix:semicolon
id|result
op_assign
id|fdc_issue_command
c_func
(paren
id|cmd
comma
l_int|1
comma
id|stat
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;FDC_SAVE failed. Dunno why&quot;
)paren
suffix:semicolon
multiline_comment|/* guess we better claim the fdc to be a i82078 */
id|result
op_assign
id|i82078
suffix:semicolon
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Type i82078 FDC (i suppose) found&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|stat
(braket
l_int|0
)braket
op_amp
id|FDC_SEL3V_BIT
)paren
)paren
(brace
multiline_comment|/* fdc running off 5Volts; Pray that it&squot;s a i82078-1&n;&t;&t;&t;&t;&t;&t;&t;&t;&t; */
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Type i82078-1 or 5Volt i82078SL FDC found&quot;
)paren
suffix:semicolon
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Treating it as an i82078-1 (2Mbps) FDC&quot;
)paren
suffix:semicolon
id|result
op_assign
id|i82078_1
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Type 3Volt i82078SL FDC (1Mbps) found&quot;
)paren
suffix:semicolon
id|result
op_assign
id|i82078
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_int|0x1
suffix:colon
r_case
l_int|0x2
suffix:colon
multiline_comment|/* S82078B (?!) */
multiline_comment|/* 44pin i82078 found */
id|result
op_assign
id|i82078
suffix:semicolon
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Type i82078 FDC found&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x3
suffix:colon
multiline_comment|/* NSC PC8744 core; used in several super-IO chips */
id|result
op_assign
id|i82077AA
suffix:semicolon
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Type 82077AA compatible FDC found&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;A previously undetected FDC found&quot;
)paren
suffix:semicolon
id|TRACEi
c_func
(paren
l_int|2
comma
l_string|&quot;Treating it as a 82077AA. Please report partid=&quot;
comma
id|stat
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|result
op_assign
id|i82077AA
suffix:semicolon
)brace
multiline_comment|/* switch(stat[ 0] &gt;&gt; 5) */
)brace
multiline_comment|/* if (result &lt; 0 || stat[ 0] == 0x80) */
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Unknown FDC found&quot;
)paren
suffix:semicolon
id|result
op_assign
id|i8272
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;No FDC found&quot;
)paren
suffix:semicolon
id|result
op_assign
id|no_fdc
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|fdc_config_regs
r_void
id|fdc_config_regs
c_func
(paren
r_int
id|fdc_base
comma
r_int
id|fdc_irq
comma
r_int
id|fdc_dma
)paren
(brace
id|fdc.irq
op_assign
id|fdc_irq
suffix:semicolon
id|fdc.dma
op_assign
id|fdc_dma
suffix:semicolon
id|fdc.sra
op_assign
id|fdc_base
suffix:semicolon
id|fdc.srb
op_assign
id|fdc_base
op_plus
l_int|1
suffix:semicolon
id|fdc.dor
op_assign
id|fdc_base
op_plus
l_int|2
suffix:semicolon
id|fdc.tdr
op_assign
id|fdc_base
op_plus
l_int|3
suffix:semicolon
id|fdc.msr
op_assign
id|fdc.dsr
op_assign
id|fdc_base
op_plus
l_int|4
suffix:semicolon
id|fdc.fifo
op_assign
id|fdc_base
op_plus
l_int|5
suffix:semicolon
macro_line|#if defined MACH2 || defined PROBE_FC10
id|fdc.dor2
op_assign
id|fdc_base
op_plus
l_int|6
suffix:semicolon
macro_line|#endif
id|fdc.dir
op_assign
id|fdc.ccr
op_assign
id|fdc_base
op_plus
l_int|7
suffix:semicolon
)brace
multiline_comment|/*  If probing for a FC-10/20 controller the fdc base address, interrupt&n; *  and dma channel must be specified.&n; *  If using an alternate fdc controller, base address, interrupt and&n; *  dma channel must be specified.&n; */
macro_line|#if defined PROBE_FC10 &amp;&amp; !defined FDC_BASE
macro_line|#error No FDC base address (FDC_BASE) specified in Makefile!
macro_line|#endif
macro_line|#if defined FDC_BASE &amp;&amp; !defined FDC_IRQ
macro_line|#error No interrupt (FDC_IRQ) specified in Makefile!
macro_line|#endif
macro_line|#if defined FDC_BASE &amp;&amp; !defined FDC_DMA
macro_line|#error No dma channel (FDC_DMA) specified in Makefile!
macro_line|#endif
DECL|function|fdc_config
r_void
id|fdc_config
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_config&quot;
)paren
suffix:semicolon
r_static
r_int
id|already_done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|already_done
)paren
(brace
macro_line|#ifdef PROBE_FC10
r_int
id|fc_type
suffix:semicolon
id|fdc_config_regs
c_func
(paren
id|FDC_BASE
comma
id|FDC_IRQ
comma
id|FDC_DMA
)paren
suffix:semicolon
id|fc_type
op_assign
id|fc10_enable
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fc_type
op_ne
l_int|0
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|2
comma
l_string|&quot;FC-%c0 controller found&quot;
comma
l_char|&squot;0&squot;
op_plus
id|fc_type
)paren
suffix:semicolon
id|fdc.type
op_assign
id|fc10
suffix:semicolon
id|fdc.hook
op_assign
op_amp
id|do_ftape
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;FC-10/20 controller not found&quot;
)paren
suffix:semicolon
id|fdc.type
op_assign
id|no_fdc
suffix:semicolon
id|fdc.dor2
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not used with std fdc */
id|fdc_config_regs
c_func
(paren
l_int|0x3f0
comma
l_int|6
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* back to std fdc again */
id|fdc.hook
op_assign
op_amp
id|do_ftape
suffix:semicolon
)brace
macro_line|#else
macro_line|#ifdef FDC_BASE
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Using fdc controller at alternate address&quot;
)paren
suffix:semicolon
id|fdc_config_regs
c_func
(paren
id|FDC_BASE
comma
id|FDC_IRQ
comma
id|FDC_DMA
)paren
suffix:semicolon
id|fdc.hook
op_assign
op_amp
id|do_ftape
suffix:semicolon
macro_line|#else
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;Using the standard fdc controller&quot;
)paren
suffix:semicolon
id|fdc_config_regs
c_func
(paren
l_int|0x3f0
comma
l_int|6
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* std fdc */
id|fdc.hook
op_assign
op_amp
id|do_ftape
suffix:semicolon
macro_line|#endif /* !FDC_BASE */
macro_line|#endif /* !PROBE_FC10 */
)brace
op_star
(paren
id|fdc.hook
)paren
op_assign
id|fdc_isr
suffix:semicolon
multiline_comment|/* hook our handler in */
id|already_done
op_assign
l_int|1
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|ftape_interrupt
r_static
r_void
id|ftape_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_interrupt&quot;
)paren
suffix:semicolon
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
)paren
op_assign
op_star
id|fdc.hook
suffix:semicolon
op_star
id|fdc.hook
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|handler
)paren
(brace
id|handler
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;Unexpected ftape interrupt&quot;
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|fdc_grab_irq_and_dma
r_int
id|fdc_grab_irq_and_dma
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_grab_irq_and_dma&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fdc.hook
op_eq
op_amp
id|do_ftape
)paren
(brace
multiline_comment|/*  Get fast interrupt handler.&n;&t;&t; */
id|result
op_assign
id|request_irq
c_func
(paren
id|fdc.irq
comma
id|ftape_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;ftape&quot;
comma
id|ftape_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|TRACEx1
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;Unable to grab IRQ%d for ftape driver&quot;
comma
id|fdc.irq
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
id|request_dma
c_func
(paren
id|fdc.dma
comma
id|ftape_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|TRACEx1
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;Unable to grab DMA%d for ftape driver&quot;
comma
id|fdc.dma
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|fdc.irq
comma
id|ftape_id
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|enable_irq
c_func
(paren
id|fdc.irq
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef FDC_DMA
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_and
id|FDC_DMA
op_eq
l_int|2
)paren
(brace
multiline_comment|/*  Using same dma channel as standard fdc, need to disable the&n;&t;&t; *  dma-gate on the std fdc. This couldn&squot;t be done in the floppy&n;&t;&t; *  driver as some laptops are using the dma-gate to enter a&n;&t;&t; *  low power or even suspended state :-(&n;&t;&t; */
id|outb_p
c_func
(paren
id|FDC_RESET_NOT
comma
l_int|0x3f2
)paren
suffix:semicolon
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;DMA-gate on standard fdc disabled&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|fdc_release_irq_and_dma
r_int
id|fdc_release_irq_and_dma
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_grab_irq_and_dma&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fdc.hook
op_eq
op_amp
id|do_ftape
)paren
(brace
id|disable_dma
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
multiline_comment|/* just in case... */
id|free_dma
c_func
(paren
id|fdc.dma
)paren
suffix:semicolon
id|disable_irq
c_func
(paren
id|fdc.irq
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|fdc.irq
comma
id|ftape_id
)paren
suffix:semicolon
)brace
macro_line|#ifdef FDC_DMA
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_and
id|FDC_DMA
op_eq
l_int|2
)paren
(brace
multiline_comment|/*  Using same dma channel as standard fdc, need to disable the&n;&t;&t; *  dma-gate on the std fdc. This couldn&squot;t be done in the floppy&n;&t;&t; *  driver as some laptops are using the dma-gate to enter a&n;&t;&t; *  low power or even suspended state :-(&n;&t;&t; */
id|outb_p
c_func
(paren
id|FDC_RESET_NOT
op_or
id|FDC_DMA_MODE
comma
l_int|0x3f2
)paren
suffix:semicolon
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;DMA-gate on standard fdc enabled again&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|fdc_uninit
r_int
id|fdc_uninit
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_uninit&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fdc.sra
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|fdc.dor2
op_eq
l_int|0
)paren
(brace
id|release_region
c_func
(paren
id|fdc.sra
comma
l_int|6
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|fdc.sra
op_plus
l_int|7
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|release_region
c_func
(paren
id|fdc.sra
comma
l_int|8
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|fdc_init
r_int
id|fdc_init
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;fdc_init&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|fdc_config
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc_grab_irq_and_dma
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
id|result
op_assign
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
id|ftape_motor
op_assign
l_int|0
suffix:semicolon
id|fdc_catch_stray_interrupts
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* one always comes */
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;resetting fdc&quot;
)paren
suffix:semicolon
id|fdc_reset
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* init fdc &amp; clear track counters */
r_if
c_cond
(paren
id|fdc.type
op_eq
id|no_fdc
)paren
(brace
multiline_comment|/* default, means no FC-10 or 20 found */
id|fdc.type
op_assign
id|fdc_probe
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdc.type
op_ne
id|no_fdc
)paren
(brace
r_if
c_cond
(paren
id|fdc.type
op_ge
id|i82077
)paren
(brace
r_if
c_cond
(paren
id|fdc_fifo_enable
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;couldn&squot;t enable fdc fifo !&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;fdc fifo enabled and locked&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|fdc_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|fdc.dor2
op_eq
l_int|0
)paren
(brace
id|request_region
c_func
(paren
id|fdc.sra
comma
l_int|6
comma
l_string|&quot;fdc (ftape)&quot;
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|fdc.sra
op_plus
l_int|7
comma
l_int|1
comma
l_string|&quot;fdc (ftape)&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|request_region
c_func
(paren
id|fdc.sra
comma
l_int|8
comma
l_string|&quot;fdc (ftape)&quot;
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
eof
