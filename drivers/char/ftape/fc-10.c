multiline_comment|/* Yo, Emacs! we&squot;re -*- Linux-C -*-&n; *&n; &n;   Copyright (C) 1993,1994 Jon Tombs.&n;&n;   This program is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;   GNU General Public License for more details.&n;&n;   The entire guts of this program was written by dosemu, modified to&n;   record reads and writes to the ports in the 0x180-0x188 address space,&n;   while running the CMS program TAPE.EXE V2.0.5 supplied with the drive.&n;&n;   Modified to use an array of addresses and generally cleaned up (made&n;   much shorter) 4 June 94, dosemu isn&squot;t that good at writing short code it&n;   would seem :-). Made independant of 0x180, but I doubt it will work&n;   at any other address.&n;&n;   Modified for distribution with ftape source. 21 June 94, SJL.&n;&n;   Modifications on 20 October 95, by Daniel Cohen (catman@wpi.edu):&n;   Modified to support different DMA, IRQ, and IO Ports.  Borland&squot;s&n;   Turbo Debugger in virtual 8086 mode (TD386.EXE with hardware breakpoints&n;   provided by the TDH386.SYS Device Driver) was used on the CMS program&n;   TAPE V4.0.5.  I set breakpoints on I/O to ports 0x180-0x187.  Note that&n;   CMS&squot;s program will not successfully configure the tape drive if you set&n;   breakpoints on IO Reads, but you can set them on IO Writes without problems.&n;   Known problems:&n;   - You can not use DMA Channels 5 or 7.&n;&n;   Modification on 29 January 96, by Daniel Cohen (catman@wpi.edu):&n;   Modified to only accept IRQs 3 - 7, or 9.  Since we can only send a 3 bit&n;   number representing the IRQ to the card, special handling is required when&n;   IRQ 9 is selected.  IRQ 2 and 9 are the same, and we should request IRQ 9&n;   from the kernel while telling the card to use IRQ 2.  Thanks to Greg&n;   Crider (gcrider@iclnet.org) for finding and locating this bug, as well as&n;   testing the patch.&n;&n; *&n; *      This file contains code for the CMS FC-10/FC-20 card.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;tracing.h&quot;
macro_line|#include &quot;fdc-io.h&quot;
macro_line|#include &quot;fc-10.h&quot;
macro_line|#ifdef PROBE_FC10
multiline_comment|/*  This code will only work if the FC-10 (or FC-20) is set to&n; *  use DMA channels 1, 2, or 3.  DMA channels 5 and 7 seem to be &n; *  initialized by the same command as channels 1 and 3, respectively.&n; */
macro_line|#if (FDC_DMA &gt; 3)
macro_line|#error : The FC-10/20 must be set to use DMA channels 1, 2, or 3!
macro_line|#endif
multiline_comment|/*  Only allow the FC-10/20 to use IRQ 3-7, or 9.  Note that CMS&squot;s program&n; *  only accepts IRQ&squot;s 2-7, but in linux, IRQ 2 is the same as IRQ 9.&n; */
macro_line|#if (FDC_IRQ &lt; 3 || FDC_IRQ == 8 || FDC_IRQ &gt; 9)
macro_line|#error : The FC-10/20 must be set to use IRQ levels 3 - 7, or 9!
macro_line|#error :              Note IRQ 9 is the same as IRQ 2
macro_line|#endif
DECL|variable|inbs_magic
r_int
r_int
id|inbs_magic
(braket
)braket
op_assign
(brace
l_int|0x3
comma
l_int|0x3
comma
l_int|0x0
comma
l_int|0x4
comma
l_int|0x7
comma
l_int|0x2
comma
l_int|0x5
comma
l_int|0x3
comma
l_int|0x1
comma
l_int|0x4
comma
l_int|0x3
comma
l_int|0x5
comma
l_int|0x2
comma
l_int|0x0
comma
l_int|0x3
comma
l_int|0x7
comma
l_int|0x4
comma
l_int|0x2
comma
l_int|0x0
comma
l_int|0x1
comma
l_int|0x2
comma
l_int|0x3
comma
l_int|0x4
comma
l_int|0x5
comma
l_int|0x6
comma
l_int|0x7
)brace
suffix:semicolon
DECL|variable|fc10_ports
r_int
r_int
id|fc10_ports
(braket
)braket
op_assign
(brace
l_int|0x180
comma
l_int|0x210
comma
l_int|0x2A0
comma
l_int|0x300
comma
l_int|0x330
comma
l_int|0x340
comma
l_int|0x370
)brace
suffix:semicolon
DECL|function|fc10_enable
r_int
id|fc10_enable
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|byte
id|cardConfig
op_assign
l_int|0x00
suffix:semicolon
id|byte
id|x
suffix:semicolon
multiline_comment|/*  Clear state machine ???&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_ITEMS
c_func
(paren
id|inbs_magic
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|inb
c_func
(paren
id|FDC_BASE
op_plus
id|inbs_magic
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x0
comma
id|FDC_BASE
)paren
suffix:semicolon
id|x
op_assign
id|inb
c_func
(paren
id|FDC_BASE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
op_eq
l_int|0x13
op_logical_or
id|x
op_eq
l_int|0x93
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|FDC_BASE
op_plus
id|i
)paren
op_ne
id|x
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x8
comma
id|FDC_BASE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|FDC_BASE
op_plus
id|i
)paren
op_ne
l_int|0x0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|outb
c_func
(paren
l_int|0x10
comma
id|FDC_BASE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|FDC_BASE
op_plus
id|i
)paren
op_ne
l_int|0xff
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*  Okay, we found a FC-10 card ! ???&n;&t; */
id|outb
c_func
(paren
l_int|0x0
comma
id|fdc.ccr
)paren
suffix:semicolon
multiline_comment|/*  Clear state machine again ???&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_ITEMS
c_func
(paren
id|inbs_magic
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|inb
c_func
(paren
id|FDC_BASE
op_plus
id|inbs_magic
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Send io port */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_ITEMS
c_func
(paren
id|fc10_ports
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|FDC_BASE
op_eq
id|fc10_ports
(braket
id|i
)braket
)paren
id|cardConfig
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cardConfig
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Invalid I/O Port */
multiline_comment|/* and IRQ - If using IRQ 9, tell the FC card it is actually IRQ 2 */
r_if
c_cond
(paren
id|FDC_IRQ
op_ne
l_int|9
)paren
id|cardConfig
op_or_assign
id|FDC_IRQ
op_lshift
l_int|3
suffix:semicolon
r_else
id|cardConfig
op_or_assign
l_int|2
op_lshift
l_int|3
suffix:semicolon
multiline_comment|/* and finally DMA Channel */
id|cardConfig
op_or_assign
id|FDC_DMA
op_lshift
l_int|6
suffix:semicolon
id|outb
c_func
(paren
id|cardConfig
comma
id|FDC_BASE
)paren
suffix:semicolon
multiline_comment|/* DMA [2 bits]/IRQ [3 bits]/BASE [3 bits] */
multiline_comment|/*  Enable FC-10 ???&n;&t; */
id|outb
c_func
(paren
l_int|0
comma
id|fdc.ccr
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|FDC_BASE
op_plus
l_int|0x6
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|8
comma
id|fdc.dor
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|8
comma
id|fdc.dor
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|FDC_BASE
op_plus
l_int|0x6
)paren
suffix:semicolon
multiline_comment|/*  Initialize fdc, select drive B:&n;&t; */
id|outb
c_func
(paren
l_int|0x08
comma
id|fdc.dor
)paren
suffix:semicolon
multiline_comment|/* assert reset, dma &amp; irq enabled */
id|outb
c_func
(paren
l_int|0x0c
comma
id|fdc.dor
)paren
suffix:semicolon
multiline_comment|/* release reset */
id|outb
c_func
(paren
l_int|0x2d
comma
id|fdc.dor
)paren
suffix:semicolon
multiline_comment|/* select drive 1 */
r_return
(paren
id|x
op_eq
l_int|0x93
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* CMS_FC10_CONTROLLER */
eof
