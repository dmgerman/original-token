multiline_comment|/*&n; *      Copyright (C) 1993-1995 Bas Laarhoven.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; $Source: /home/bas/distr/ftape-2.03b/RCS/ftape-read.c,v $&n; $Author: bas $&n; *&n; $Revision: 1.30 $&n; $Date: 1995/05/27 08:54:21 $&n; $State: Beta $&n; *&n; *      This file contains the reading code&n; *      for the QIC-117 floppy-tape driver for Linux.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &quot;tracing.h&quot;
macro_line|#include &quot;ftape-read.h&quot;
macro_line|#include &quot;qic117.h&quot;
macro_line|#include &quot;ftape-io.h&quot;
macro_line|#include &quot;ftape-ctl.h&quot;
macro_line|#include &quot;ftape-rw.h&quot;
macro_line|#include &quot;ftape-write.h&quot;
macro_line|#include &quot;ftape-eof.h&quot;
macro_line|#include &quot;ecc.h&quot;
macro_line|#include &quot;ftape-bsm.h&quot;
multiline_comment|/*      Global vars.&n; */
multiline_comment|/*      Local vars.&n; */
DECL|variable|buf_pos_rd
r_int
id|buf_pos_rd
op_assign
l_int|0
suffix:semicolon
DECL|variable|buf_len_rd
r_int
id|buf_len_rd
op_assign
l_int|0
suffix:semicolon
DECL|function|ftape_zap_read_buffers
r_void
id|ftape_zap_read_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_BUFFERS
suffix:semicolon
op_increment
id|i
)paren
(brace
multiline_comment|/*&n;&t;&t; * changed to &quot;fit&quot; with dynamic allocation of tape_buffer. --khp&n;&t;&t; */
id|buffer
(braket
id|i
)braket
dot
id|address
op_assign
id|tape_buffer
(braket
id|i
)braket
suffix:semicolon
id|buffer
(braket
id|i
)braket
dot
id|status
op_assign
id|waiting
suffix:semicolon
id|buffer
(braket
id|i
)braket
dot
id|bytes
op_assign
l_int|0
suffix:semicolon
id|buffer
(braket
id|i
)braket
dot
id|skip
op_assign
l_int|0
suffix:semicolon
id|buffer
(braket
id|i
)braket
dot
id|retry
op_assign
l_int|0
suffix:semicolon
)brace
id|buf_len_rd
op_assign
l_int|0
suffix:semicolon
id|buf_pos_rd
op_assign
l_int|0
suffix:semicolon
id|eof_mark
op_assign
l_int|0
suffix:semicolon
id|ftape_state
op_assign
id|idle
suffix:semicolon
)brace
DECL|function|convert_sector_map
r_static
r_int
r_int
id|convert_sector_map
c_func
(paren
id|buffer_struct
op_star
id|buff
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;convert_sector_map&quot;
)paren
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|bad_map
op_assign
id|get_bad_sector_entry
c_func
(paren
id|buff-&gt;segment_id
)paren
suffix:semicolon
r_int
r_int
id|src_map
op_assign
id|buff-&gt;soft_error_map
op_or
id|buff-&gt;hard_error_map
suffix:semicolon
r_int
r_int
id|dst_map
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bad_map
op_logical_or
id|src_map
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;bad_map = 0x%08lx&quot;
comma
id|bad_map
)paren
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;src_map = 0x%08lx&quot;
comma
id|src_map
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|bad_map
)paren
(brace
r_while
c_loop
(paren
(paren
id|bad_map
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|src_map
op_amp
l_int|1
)paren
(brace
id|dst_map
op_or_assign
(paren
l_int|1
op_lshift
id|i
)paren
suffix:semicolon
)brace
id|src_map
op_rshift_assign
l_int|1
suffix:semicolon
id|bad_map
op_rshift_assign
l_int|1
suffix:semicolon
op_increment
id|i
suffix:semicolon
)brace
multiline_comment|/* (bad_map &amp; 1) == 1 */
id|src_map
op_rshift_assign
l_int|1
suffix:semicolon
id|bad_map
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|src_map
)paren
(brace
id|dst_map
op_or_assign
(paren
id|src_map
op_lshift
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dst_map
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;dst_map = 0x%08lx&quot;
comma
id|dst_map
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|dst_map
suffix:semicolon
)brace
DECL|function|correct_and_copy
r_int
id|correct_and_copy
c_func
(paren
r_int
r_int
id|tail
comma
id|byte
op_star
id|destination
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;correct_and_copy&quot;
)paren
suffix:semicolon
r_struct
id|memory_segment
id|mseg
suffix:semicolon
r_int
id|result
suffix:semicolon
id|BAD_SECTOR
id|read_bad
suffix:semicolon
id|mseg.read_bad
op_assign
id|convert_sector_map
c_func
(paren
op_amp
id|buffer
(braket
id|tail
)braket
)paren
suffix:semicolon
id|mseg.marked_bad
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not used... */
id|mseg.blocks
op_assign
id|buffer
(braket
id|tail
)braket
dot
id|bytes
op_div
id|SECTOR_SIZE
suffix:semicolon
id|mseg.data
op_assign
id|buffer
(braket
id|tail
)braket
dot
id|address
suffix:semicolon
multiline_comment|/*    If there are no data sectors we can skip this segment.&n;&t; */
r_if
c_cond
(paren
id|mseg.blocks
op_le
l_int|3
)paren
(brace
id|TRACE
c_func
(paren
l_int|4
comma
l_string|&quot;empty segment&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|read_bad
op_assign
id|mseg.read_bad
suffix:semicolon
id|history.crc_errors
op_add_assign
id|count_ones
c_func
(paren
id|read_bad
)paren
suffix:semicolon
id|result
op_assign
id|ecc_correct_data
c_func
(paren
op_amp
id|mseg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_bad
op_ne
l_int|0
op_logical_or
id|mseg.corrected
op_ne
l_int|0
)paren
(brace
id|TRACElx
c_func
(paren
l_int|4
comma
l_string|&quot;crc error map:&quot;
comma
id|read_bad
)paren
suffix:semicolon
id|TRACElx
c_func
(paren
l_int|4
comma
l_string|&quot;corrected map:&quot;
comma
id|mseg.corrected
)paren
suffix:semicolon
id|history.corrected
op_add_assign
id|count_ones
c_func
(paren
id|mseg.corrected
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_eq
id|ECC_CORRECTED
op_logical_or
id|result
op_eq
id|ECC_OK
)paren
(brace
r_if
c_cond
(paren
id|result
op_eq
id|ECC_CORRECTED
)paren
(brace
id|TRACEi
c_func
(paren
l_int|3
comma
l_string|&quot;ecc corrected segment:&quot;
comma
id|buffer
(braket
id|tail
)braket
dot
id|segment_id
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|destination
comma
id|mseg.data
comma
(paren
id|mseg.blocks
op_minus
l_int|3
)paren
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|read_bad
op_xor
id|mseg.corrected
)paren
op_amp
id|mseg.corrected
)paren
(brace
multiline_comment|/* sectors corrected without crc errors set */
id|history.crc_failures
op_increment
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
(paren
id|mseg.blocks
op_minus
l_int|3
)paren
op_star
id|SECTOR_SIZE
suffix:semicolon
)brace
r_else
(brace
id|TRACEi
c_func
(paren
l_int|1
comma
l_string|&quot;ecc failure on segment&quot;
comma
id|buffer
(braket
id|tail
)braket
dot
id|segment_id
)paren
suffix:semicolon
id|history.ecc_failures
op_increment
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
multiline_comment|/* should retry */
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*      Read given segment into buffer at address.&n; */
DECL|function|read_segment
r_int
id|read_segment
c_func
(paren
r_int
id|segment_id
comma
id|byte
op_star
id|address
comma
r_int
op_star
id|eof_mark
comma
r_int
id|read_ahead
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;read_segment&quot;
)paren
suffix:semicolon
r_int
id|read_done
op_assign
l_int|0
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|bytes_read
op_assign
l_int|0
suffix:semicolon
r_int
id|retry
op_assign
l_int|0
suffix:semicolon
id|TRACEi
c_func
(paren
l_int|5
comma
l_string|&quot;segment_id =&quot;
comma
id|segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_state
op_ne
id|reading
)paren
(brace
r_if
c_cond
(paren
id|ftape_state
op_eq
id|writing
)paren
(brace
id|ftape_flush_buffers
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* flush write buffer */
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;calling ftape_abort_operation&quot;
)paren
suffix:semicolon
id|result
op_assign
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;ftape_abort_operation failed&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* clear remaining read buffers */
id|ftape_zap_read_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
id|ftape_state
op_assign
id|reading
suffix:semicolon
)brace
r_if
c_cond
(paren
id|segment_id
op_ge
id|segments_per_track
op_star
id|tracks_per_tape
)paren
(brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;reading past end of tape&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/*    Search all full buffers for the first matching the wanted segment.&n;&t;&t; *    Clear other buffers on the fly.&n;&t;&t; */
r_while
c_loop
(paren
op_logical_neg
id|read_done
op_logical_and
id|buffer
(braket
id|tail
)braket
dot
id|status
op_eq
id|done
)paren
(brace
r_if
c_cond
(paren
id|buffer
(braket
id|tail
)braket
dot
id|segment_id
op_eq
id|segment_id
)paren
(brace
r_int
id|eof_sector
suffix:semicolon
r_int
id|sector_count
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|bsm
op_assign
id|get_bad_sector_entry
c_func
(paren
id|segment_id
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*        If out buffer is already full, return its contents.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|buffer
(braket
id|tail
)braket
dot
id|deleted
)paren
(brace
id|TRACEi
c_func
(paren
l_int|5
comma
l_string|&quot;found segment in cache :&quot;
comma
id|segment_id
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
multiline_comment|/*  Return a value that read_header_segment understands.&n;&t;&t;&t;&t;&t; *  As this should only occur when searching for the header&n;&t;&t;&t;&t;&t; *  segments it shouldn&squot;t be misinterpreted elsewhere.&n;&t;&t;&t;&t;&t; */
r_return
l_int|0
suffix:semicolon
)brace
id|TRACEi
c_func
(paren
l_int|5
comma
l_string|&quot;found segment in cache :&quot;
comma
id|segment_id
)paren
suffix:semicolon
id|eof_sector
op_assign
id|check_for_eof
c_func
(paren
id|segment_id
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eof_sector
OG
l_int|0
)paren
(brace
id|TRACEi
c_func
(paren
l_int|5
comma
l_string|&quot;end of file mark in sector:&quot;
comma
id|eof_sector
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|eof_sector
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|bsm
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
op_increment
id|sector_count
suffix:semicolon
)brace
id|bsm
op_rshift_assign
l_int|1
suffix:semicolon
)brace
op_star
id|eof_mark
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eof_sector
op_ne
l_int|1
)paren
(brace
multiline_comment|/* not found or gt 1 */
id|result
op_assign
id|correct_and_copy
c_func
(paren
id|tail
comma
id|address
)paren
suffix:semicolon
id|TRACEi
c_func
(paren
l_int|5
comma
l_string|&quot;segment contains (bytes) :&quot;
comma
id|result
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|result
op_ne
op_minus
id|EAGAIN
)paren
(brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* keep read_done == 0, will trigger ftape_abort_operation&n;&t;&t;&t;&t;&t;&t; * because reading wrong segment.&n;&t;&t;&t;&t;&t;&t; */
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;ecc failed, retry&quot;
)paren
suffix:semicolon
op_increment
id|retry
suffix:semicolon
)brace
r_else
(brace
id|read_done
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|read_done
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eof_sector
OG
l_int|0
)paren
(brace
id|bytes_read
op_assign
id|sector_count
op_star
id|SECTOR_SIZE
suffix:semicolon
id|TRACEi
c_func
(paren
l_int|5
comma
l_string|&quot;partial read count:&quot;
comma
id|bytes_read
)paren
suffix:semicolon
)brace
r_else
(brace
id|bytes_read
op_assign
id|result
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACEi
c_func
(paren
l_int|5
comma
l_string|&quot;zapping segment in cache :&quot;
comma
id|buffer
(braket
id|tail
)braket
dot
id|segment_id
)paren
suffix:semicolon
)brace
id|buffer
(braket
id|tail
)braket
dot
id|status
op_assign
id|waiting
suffix:semicolon
id|next_buffer
c_func
(paren
op_amp
id|tail
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|read_done
op_logical_and
id|buffer
(braket
id|tail
)braket
dot
id|status
op_eq
id|reading
)paren
(brace
r_if
c_cond
(paren
id|buffer
(braket
id|tail
)braket
dot
id|segment_id
op_eq
id|segment_id
)paren
(brace
r_int
id|result
op_assign
id|wait_segment
c_func
(paren
id|reading
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EINTR
)paren
(brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;wait_segment failed while reading&quot;
)paren
suffix:semicolon
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*        We&squot;re reading the wrong segment, stop runner.&n;&t;&t;&t;&t; */
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*    if just passed the last segment on a track, wait for BOT or EOT mark.&n;&t;&t; */
r_if
c_cond
(paren
id|runner_status
op_eq
id|logical_eot
)paren
(brace
r_int
id|status
suffix:semicolon
id|result
op_assign
id|ftape_ready_wait
c_func
(paren
id|timeout.seek
comma
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;ftape_ready_wait waiting for eot/bot failed&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_amp
(paren
id|QIC_STATUS_AT_BOT
op_or
id|QIC_STATUS_AT_EOT
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;eot/bot not reached&quot;
)paren
suffix:semicolon
)brace
id|runner_status
op_assign
id|end_of_tape
suffix:semicolon
)brace
multiline_comment|/*    should runner stop ?&n;&t;&t; */
r_if
c_cond
(paren
id|runner_status
op_eq
id|aborting
op_logical_or
id|runner_status
op_eq
id|buffer_overrun
op_logical_or
id|runner_status
op_eq
id|end_of_tape
)paren
(brace
r_if
c_cond
(paren
id|runner_status
op_ne
id|end_of_tape
op_logical_and
op_logical_neg
(paren
id|runner_status
op_eq
id|aborting
op_logical_and
op_logical_neg
id|tape_running
)paren
)paren
(brace
id|ftape_dumb_stop
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|runner_status
op_eq
id|aborting
)paren
(brace
r_if
c_cond
(paren
id|buffer
(braket
id|head
)braket
dot
id|status
op_eq
id|reading
op_logical_or
id|buffer
(braket
id|head
)braket
dot
id|status
op_eq
id|error
)paren
(brace
r_if
c_cond
(paren
id|buffer
(braket
id|head
)braket
dot
id|status
op_eq
id|error
)paren
(brace
id|history.defects
op_add_assign
id|count_ones
c_func
(paren
id|buffer
(braket
id|head
)braket
dot
id|hard_error_map
)paren
suffix:semicolon
)brace
id|buffer
(braket
id|head
)braket
dot
id|status
op_assign
id|waiting
suffix:semicolon
)brace
)brace
id|runner_status
op_assign
id|idle
suffix:semicolon
multiline_comment|/* aborted ? */
)brace
multiline_comment|/*    If segment to read is empty, do not start runner for it,&n;&t;&t; *    but wait for next read call.&n;&t;&t; */
r_if
c_cond
(paren
id|get_bad_sector_entry
c_func
(paren
id|segment_id
)paren
op_eq
id|EMPTY_SEGMENT
)paren
(brace
id|bytes_read
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* flag empty segment */
id|read_done
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*  Allow escape from this loop on signal !&n;&t;&t; */
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
id|_DONT_BLOCK
)paren
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;interrupted by non-blockable signal&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
multiline_comment|/*    If we got a segment: quit, or else retry up to limit.&n;&t;&t; */
r_if
c_cond
(paren
id|read_done
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retry
OG
id|RETRIES_ON_ECC_ERROR
)paren
(brace
id|history.defects
op_increment
suffix:semicolon
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;too many retries on ecc failure&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|ENODATA
suffix:semicolon
)brace
multiline_comment|/*    Now at least one buffer is empty !&n;&t;&t; *    Restart runner &amp; tape if needed.&n;&t;&t; */
id|TRACEx3
c_func
(paren
l_int|8
comma
l_string|&quot;head: %d, tail: %d, runner_status: %d&quot;
comma
id|head
comma
id|tail
comma
id|runner_status
)paren
suffix:semicolon
id|TRACEx2
c_func
(paren
l_int|8
comma
l_string|&quot;buffer[].status, [head]: %d, [tail]: %d&quot;
comma
id|buffer
(braket
id|head
)braket
dot
id|status
comma
id|buffer
(braket
id|tail
)braket
dot
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
(braket
id|tail
)braket
dot
id|status
op_eq
id|waiting
)paren
(brace
id|setup_new_segment
c_func
(paren
op_amp
id|buffer
(braket
id|head
)braket
comma
id|segment_id
comma
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|read_ahead
)paren
(brace
id|buffer
(braket
id|head
)braket
dot
id|next_segment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* disable read-ahead */
)brace
id|calc_next_cluster
c_func
(paren
op_amp
id|buffer
(braket
id|head
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|runner_status
op_eq
id|idle
)paren
(brace
id|result
op_assign
id|ftape_start_tape
c_func
(paren
id|segment_id
comma
id|buffer
(braket
id|head
)braket
dot
id|sector_offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|1
comma
l_string|&quot;Error: segment %d unreachable&quot;
comma
id|segment_id
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
id|runner_status
op_assign
id|running
suffix:semicolon
)brace
id|buffer
(braket
id|head
)braket
dot
id|status
op_assign
id|reading
suffix:semicolon
id|setup_fdc_and_dma
c_func
(paren
op_amp
id|buffer
(braket
id|head
)braket
comma
id|FDC_READ
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|read_done
)paren
(brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|bytes_read
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;too many retries&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
DECL|function|read_header_segment
r_int
id|read_header_segment
c_func
(paren
id|byte
op_star
id|address
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;read_header_segment&quot;
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|header_segment
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
r_int
id|max_floppy_side
suffix:semicolon
r_int
r_int
id|max_floppy_track
suffix:semicolon
r_int
r_int
id|max_floppy_sector
suffix:semicolon
r_int
id|first_failed
op_assign
l_int|0
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|new_tape_len
suffix:semicolon
id|result
op_assign
id|ftape_report_drive_status
c_func
(paren
op_amp
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;error: error_status or report failure&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;reading...&quot;
)paren
suffix:semicolon
id|ftape_last_segment.id
op_assign
l_int|68
suffix:semicolon
multiline_comment|/* will allow us to read the header ! */
multiline_comment|/*  We&squot;re looking for the first header segment.&n;&t; *  A header segment cannot contain bad sectors, therefor at the&n;&t; *  tape start, segments with bad sectors are (according to QIC-40/80)&n;&t; *  written with deleted data marks and must be skipped.&n;&t; */
id|used_header_segment
op_assign
op_minus
l_int|1
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|header_segment
op_assign
l_int|0
suffix:semicolon
id|header_segment
OL
id|ftape_last_segment.id
op_logical_and
id|result
op_eq
l_int|0
suffix:semicolon
op_increment
id|header_segment
)paren
(brace
multiline_comment|/*  Set no read-ahead, the isr will force read-ahead whenever&n;&t;&t; *  it encounters deleted data !&n;&t;&t; */
id|result
op_assign
id|read_segment
c_func
(paren
id|header_segment
comma
id|address
comma
op_amp
id|status
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
op_logical_and
op_logical_neg
id|first_failed
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;header segment damaged, trying backup&quot;
)paren
suffix:semicolon
id|first_failed
op_assign
l_int|1
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* force read of next (backup) segment */
)brace
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
op_logical_or
id|header_segment
op_ge
id|ftape_last_segment.id
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;no readable header segment found&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|result
op_assign
id|ftape_abort_operation
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;ftape_abort_operation failed&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GET4
c_func
(paren
id|address
comma
l_int|0
)paren
op_ne
l_int|0xaa55aa55
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;wrong signature in header segment&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|header_segment_1
op_assign
id|GET2
c_func
(paren
id|address
comma
l_int|6
)paren
suffix:semicolon
id|header_segment_2
op_assign
id|GET2
c_func
(paren
id|address
comma
l_int|8
)paren
suffix:semicolon
id|TRACEx2
c_func
(paren
l_int|2
comma
l_string|&quot;header segments are %d and %d&quot;
comma
id|header_segment_1
comma
id|header_segment_2
)paren
suffix:semicolon
id|used_header_segment
op_assign
(paren
id|first_failed
)paren
ques
c_cond
id|header_segment_2
suffix:colon
id|header_segment_1
suffix:semicolon
multiline_comment|/*    Verify tape parameters...&n;&t; *    QIC-40/80 spec:                 tape_parameters:&n;&t; *&n;&t; *    segments-per-track              segments_per_track&n;&t; *    tracks-per-cartridge            tracks_per_tape&n;&t; *    max-floppy-side                 (segments_per_track *&n;&t; *                                    tracks_per_tape - 1) /&n;&t; *                                    segments_per_head&n;&t; *    max-floppy-track                segments_per_head /&n;&t; *                                    segments_per_cylinder - 1&n;&t; *    max-floppy-sector               segments_per_cylinder *&n;&t; *                                    SECTORS_PER_SEGMENT&n;&t; */
id|format_code
op_assign
(paren
id|format_type
)paren
op_star
(paren
id|address
op_plus
l_int|4
)paren
suffix:semicolon
id|segments_per_track
op_assign
id|GET2
c_func
(paren
id|address
comma
l_int|24
)paren
suffix:semicolon
id|tracks_per_tape
op_assign
op_star
(paren
id|address
op_plus
l_int|26
)paren
suffix:semicolon
id|max_floppy_side
op_assign
op_star
(paren
id|address
op_plus
l_int|27
)paren
suffix:semicolon
id|max_floppy_track
op_assign
op_star
(paren
id|address
op_plus
l_int|28
)paren
suffix:semicolon
id|max_floppy_sector
op_assign
op_star
(paren
id|address
op_plus
l_int|29
)paren
suffix:semicolon
id|TRACEx6
c_func
(paren
l_int|4
comma
l_string|&quot;(fmt/spt/tpc/fhm/ftm/fsm) = %d/%d/%d/%d/%d/%d&quot;
comma
id|format_code
comma
id|segments_per_track
comma
id|tracks_per_tape
comma
id|max_floppy_side
comma
id|max_floppy_track
comma
id|max_floppy_sector
)paren
suffix:semicolon
id|new_tape_len
op_assign
id|tape_len
suffix:semicolon
r_switch
c_cond
(paren
id|format_code
)paren
(brace
r_case
id|fmt_425ft
suffix:colon
id|new_tape_len
op_assign
l_int|425
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fmt_normal
suffix:colon
r_if
c_cond
(paren
id|tape_len
op_eq
l_int|0
)paren
(brace
multiline_comment|/* otherwise 307 ft */
id|new_tape_len
op_assign
l_int|205
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|fmt_1100ft
suffix:colon
id|new_tape_len
op_assign
l_int|1100
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fmt_wide
suffix:colon
(brace
r_int
id|segments_per_1000_inch
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* non-zero default for switch */
r_switch
c_cond
(paren
id|qic_std
)paren
(brace
r_case
id|QIC_TAPE_QIC40
suffix:colon
id|segments_per_1000_inch
op_assign
l_int|332
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_QIC80
suffix:colon
id|segments_per_1000_inch
op_assign
l_int|488
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_QIC3010
suffix:colon
id|segments_per_1000_inch
op_assign
l_int|730
suffix:semicolon
r_break
suffix:semicolon
r_case
id|QIC_TAPE_QIC3020
suffix:colon
id|segments_per_1000_inch
op_assign
l_int|1430
suffix:semicolon
r_break
suffix:semicolon
)brace
id|new_tape_len
op_assign
(paren
l_int|1000
op_star
id|segments_per_track
op_plus
(paren
id|segments_per_1000_inch
op_minus
l_int|1
)paren
)paren
op_div
id|segments_per_1000_inch
suffix:semicolon
r_break
suffix:semicolon
)brace
r_default
suffix:colon
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;unknown tape format, please report !&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_tape_len
op_ne
id|tape_len
)paren
(brace
id|tape_len
op_assign
id|new_tape_len
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|1
comma
l_string|&quot;calculated tape length is %d ft&quot;
comma
id|tape_len
)paren
suffix:semicolon
id|ftape_calc_timeouts
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|segments_per_track
op_eq
l_int|0
op_logical_and
id|tracks_per_tape
op_eq
l_int|0
op_logical_and
id|max_floppy_side
op_eq
l_int|0
op_logical_and
id|max_floppy_track
op_eq
l_int|0
op_logical_and
id|max_floppy_sector
op_eq
l_int|0
)paren
(brace
multiline_comment|/*  QIC-40 Rev E and earlier has no values in the header.&n;&t;&t; */
id|segments_per_track
op_assign
l_int|68
suffix:semicolon
id|tracks_per_tape
op_assign
l_int|20
suffix:semicolon
id|max_floppy_side
op_assign
l_int|1
suffix:semicolon
id|max_floppy_track
op_assign
l_int|169
suffix:semicolon
id|max_floppy_sector
op_assign
l_int|128
suffix:semicolon
)brace
multiline_comment|/*  This test will compensate for the wrong parameter on tapes&n;&t; *  formatted by Conner software.&n;&t; */
r_if
c_cond
(paren
id|segments_per_track
op_eq
l_int|150
op_logical_and
id|tracks_per_tape
op_eq
l_int|28
op_logical_and
id|max_floppy_side
op_eq
l_int|7
op_logical_and
id|max_floppy_track
op_eq
l_int|149
op_logical_and
id|max_floppy_sector
op_eq
l_int|128
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;the famous CONNER bug: max_floppy_side off by one !&quot;
)paren
suffix:semicolon
id|max_floppy_side
op_assign
l_int|6
suffix:semicolon
)brace
multiline_comment|/*  This test will compensate for the wrong parameter on tapes&n;&t; *  formatted by Colorado Windows software.&n;&t; */
r_if
c_cond
(paren
id|segments_per_track
op_eq
l_int|150
op_logical_and
id|tracks_per_tape
op_eq
l_int|28
op_logical_and
id|max_floppy_side
op_eq
l_int|6
op_logical_and
id|max_floppy_track
op_eq
l_int|150
op_logical_and
id|max_floppy_sector
op_eq
l_int|128
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;the famous Colorado bug: max_floppy_track off by one !&quot;
)paren
suffix:semicolon
id|max_floppy_track
op_assign
l_int|149
suffix:semicolon
)brace
id|segments_per_head
op_assign
(paren
(paren
id|max_floppy_sector
op_div
id|SECTORS_PER_SEGMENT
)paren
op_star
(paren
id|max_floppy_track
op_plus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *    Verify drive_configuration with tape parameters&n;&t; */
r_if
c_cond
(paren
id|segments_per_head
op_eq
l_int|0
op_logical_or
id|segments_per_cylinder
op_eq
l_int|0
op_logical_or
(paren
(paren
id|segments_per_track
op_star
id|tracks_per_tape
op_minus
l_int|1
)paren
op_div
id|segments_per_head
op_ne
id|max_floppy_side
)paren
op_logical_or
(paren
id|segments_per_head
op_div
id|segments_per_cylinder
op_minus
l_int|1
op_ne
id|max_floppy_track
)paren
op_logical_or
(paren
id|segments_per_cylinder
op_star
id|SECTORS_PER_SEGMENT
op_ne
id|max_floppy_sector
)paren
macro_line|#ifdef TESTING
op_logical_or
(paren
id|format_code
op_eq
l_int|4
op_logical_and
(paren
id|max_floppy_track
op_ne
l_int|254
op_logical_or
id|max_floppy_sector
op_ne
l_int|128
)paren
)paren
macro_line|#endif
)paren
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;Tape parameters inconsistency, please report&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|first_data_segment
op_assign
id|GET2
c_func
(paren
id|address
comma
l_int|10
)paren
suffix:semicolon
multiline_comment|/* first data segment */
id|TRACEi
c_func
(paren
l_int|4
comma
l_string|&quot;first data segment:&quot;
comma
id|first_data_segment
)paren
suffix:semicolon
id|extract_bad_sector_map
c_func
(paren
id|address
)paren
suffix:semicolon
multiline_comment|/*  Find the highest segment id that allows still one full&n;&t; *  deblock_buffer to be written to tape.&n;&t; */
id|ftape_last_segment.size
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|segments_per_track
op_star
id|tracks_per_tape
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
(brace
r_int
id|space
op_assign
id|SECTORS_PER_SEGMENT
op_minus
l_int|3
op_minus
id|count_ones
c_func
(paren
id|get_bad_sector_entry
c_func
(paren
id|i
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|space
OG
l_int|0
)paren
(brace
id|ftape_last_segment.size
op_add_assign
id|space
suffix:semicolon
multiline_comment|/* sectors free */
id|ftape_last_segment.free
op_assign
(paren
id|ftape_last_segment.size
op_minus
r_sizeof
(paren
id|deblock_buffer
)paren
op_div
id|SECTOR_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_last_segment.free
op_ge
l_int|0
)paren
(brace
id|ftape_last_segment.id
op_assign
id|i
suffix:semicolon
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;`last&squot; segment is %d, %d Kb&quot;
comma
id|ftape_last_segment.id
comma
id|ftape_last_segment.size
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Copy the failed sector log into our local buffer.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|ftape_validate_label
c_func
(paren
op_amp
id|deblock_buffer
(braket
l_int|30
)braket
)paren
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;This tape has no `Linux raw format&squot; label,&bslash;n&quot;
l_string|&quot;***** Use `mt&squot; to erase this tape if you want to use file marks !&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|extract_file_marks
c_func
(paren
id|address
)paren
suffix:semicolon
)brace
id|ftape_reset_position
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|_ftape_read
r_int
id|_ftape_read
c_func
(paren
r_char
op_star
id|buff
comma
r_int
id|req_len
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;_ftape_read&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_int
id|to_do
op_assign
id|req_len
suffix:semicolon
r_static
r_int
id|remaining
suffix:semicolon
r_int
id|bytes_read
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ftape_offline
op_logical_or
op_logical_neg
id|formatted
op_logical_or
id|no_tape
)paren
(brace
id|TRACEx3
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;offline = %d, formatted = %d, no_tape = %d&quot;
comma
id|ftape_offline
comma
id|formatted
comma
id|no_tape
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|history.used
op_or_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|first_data_segment
op_eq
op_minus
l_int|1
)paren
(brace
id|result
op_assign
id|read_header_segment
c_func
(paren
id|deblock_buffer
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*  As GNU tar doesn&squot;t accept partial read counts when the multiple&n;&t; *  volume flag is set, we make sure to return the requested amount&n;&t; *  of data. Except, of course, at the end of the tape or file mark.&n;&t; */
r_while
c_loop
(paren
id|to_do
OG
l_int|0
)paren
(brace
multiline_comment|/* don&squot;t return with a partial count ! */
multiline_comment|/*  If we&squot;re reading the `last&squot; segment(s) on tape, make sure we don&squot;t&n;&t;&t; *  get more than 29 Kb from it (As it only contains this much).&n;&t;&t; *  This works only for sequential access, so random access should&n;&t;&t; *  stay away from this `last&squot; segment.&n;&t;&t; *  Note: ftape_seg_pos points to the next segment what will be&n;&t;&t; *        read, so it&squot;s one too hight here!&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|eof_mark
op_logical_and
id|ftape_seg_pos
op_minus
l_int|1
op_ge
id|ftape_last_segment.id
)paren
(brace
id|TRACEi
c_func
(paren
l_int|5
comma
l_string|&quot;remaining of last segment:&quot;
comma
id|remaining
)paren
suffix:semicolon
r_if
c_cond
(paren
id|to_do
OG
id|remaining
)paren
(brace
id|to_do
op_assign
id|remaining
suffix:semicolon
multiline_comment|/* fake a smaller request */
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;clipped request to remaining&quot;
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_logical_neg
id|eof_mark
op_logical_and
id|buf_len_rd
op_eq
l_int|0
)paren
(brace
multiline_comment|/*  When starting to read the `last&squot; segment, set remaining&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ftape_seg_pos
op_eq
id|ftape_last_segment.id
)paren
(brace
id|remaining
op_assign
r_sizeof
(paren
id|deblock_buffer
)paren
suffix:semicolon
id|TRACEi
c_func
(paren
l_int|5
comma
l_string|&quot;remaining set to:&quot;
comma
id|remaining
)paren
suffix:semicolon
)brace
id|result
op_assign
id|read_segment
c_func
(paren
id|ftape_seg_pos
comma
id|deblock_buffer
comma
op_amp
id|eof_mark
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|ENODATA
)paren
(brace
multiline_comment|/*  Unable to recover tape data, return error and skip bad spot.&n;&t;&t;&t;&t;&t; */
op_increment
id|ftape_seg_pos
suffix:semicolon
)brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;read_segment result: %d&quot;
comma
id|result
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*  Allow escape from this loop on signal !&n;&t;&t;&t; */
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
id|_DONT_BLOCK
)paren
(brace
id|TRACE
c_func
(paren
l_int|2
comma
l_string|&quot;interrupted by non-blockable signal&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|buf_pos_rd
op_assign
l_int|0
suffix:semicolon
id|buf_len_rd
op_assign
id|result
suffix:semicolon
op_increment
id|ftape_seg_pos
suffix:semicolon
)brace
multiline_comment|/*  Take as much as we can use&n;&t;&t; */
id|cnt
op_assign
(paren
id|buf_len_rd
OL
id|to_do
)paren
ques
c_cond
id|buf_len_rd
suffix:colon
id|to_do
suffix:semicolon
id|TRACEi
c_func
(paren
l_int|7
comma
l_string|&quot;nr bytes just read:&quot;
comma
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
l_int|0
)paren
(brace
id|result
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|buff
comma
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|1
comma
l_string|&quot;verify_area failed, exitcode = %d&quot;
comma
id|result
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|memcpy_tofs
c_func
(paren
id|buff
comma
id|deblock_buffer
op_plus
id|buf_pos_rd
comma
id|cnt
)paren
suffix:semicolon
id|buff
op_add_assign
id|cnt
suffix:semicolon
id|to_do
op_sub_assign
id|cnt
suffix:semicolon
multiline_comment|/* what&squot;s left from req_len */
id|remaining
op_sub_assign
id|cnt
suffix:semicolon
multiline_comment|/* what remains on this tape */
id|bytes_read
op_add_assign
id|cnt
suffix:semicolon
multiline_comment|/* what we got so far */
id|buf_pos_rd
op_add_assign
id|cnt
suffix:semicolon
multiline_comment|/* index in buffer */
id|buf_len_rd
op_sub_assign
id|cnt
suffix:semicolon
multiline_comment|/* remaining bytes in buffer */
)brace
r_if
c_cond
(paren
id|eof_mark
op_logical_and
id|buf_len_rd
op_eq
l_int|0
)paren
(brace
multiline_comment|/* nothing left */
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;partial count because of eof mark&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes_read
op_eq
l_int|0
)paren
(brace
id|eof_mark
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no need for mark next read */
)brace
r_break
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|bytes_read
suffix:semicolon
)brace
eof
