multiline_comment|/*&n; *      Copyright (C) 1994-1995 Bas Laarhoven.&n;&n; This program is free software; you can redistribute it and/or modify&n; it under the terms of the GNU General Public License as published by&n; the Free Software Foundation; either version 2, or (at your option)&n; any later version.&n;&n; This program is distributed in the hope that it will be useful,&n; but WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; GNU General Public License for more details.&n;&n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n; $Source: /home/bas/distr/ftape-2.03b/RCS/ftape-eof.c,v $&n; $Author: bas $&n; *&n; $Revision: 1.21 $&n; $Date: 1995/05/27 08:54:21 $&n; $State: Beta $&n; *&n; *      This file contains the eof mark handling code&n; *      for the QIC-40/80 floppy-tape driver for Linux.&n; */
macro_line|#include &lt;linux/ftape.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &quot;tracing.h&quot;
macro_line|#include &quot;ftape-eof.h&quot;
macro_line|#include &quot;ftape-write.h&quot;
macro_line|#include &quot;ftape-read.h&quot;
macro_line|#include &quot;ftape-rw.h&quot;
macro_line|#include &quot;ftape-ctl.h&quot;
macro_line|#include &quot;ftape-bsm.h&quot;
multiline_comment|/*      Global vars.&n; */
DECL|variable|failed_sector_log_changed
r_int
id|failed_sector_log_changed
op_assign
l_int|0
suffix:semicolon
DECL|variable|eof_mark
r_int
id|eof_mark
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*      Local vars.&n; */
DECL|struct|failed_sector_entry
r_static
r_struct
id|failed_sector_entry
(brace
DECL|member|segment
r_int
r_int
id|segment
suffix:semicolon
DECL|member|sector
r_int
r_int
id|sector
suffix:semicolon
DECL|variable|eof_mark_ptr
)brace
op_star
id|eof_mark_ptr
suffix:semicolon
r_typedef
r_union
(brace
DECL|member|mark
r_struct
id|failed_sector_entry
id|mark
suffix:semicolon
DECL|member|entry
r_int
r_int
id|entry
suffix:semicolon
DECL|typedef|eof_mark_union
)brace
id|eof_mark_union
suffix:semicolon
multiline_comment|/*  a copy of the failed sector log from the header segment.&n; */
DECL|variable|eof_map
r_static
id|eof_mark_union
id|eof_map
(braket
(paren
l_int|2048
op_minus
l_int|256
)paren
op_div
l_int|4
)braket
suffix:semicolon
multiline_comment|/*  index into eof_map table pointing to last found eof mark.&n; */
DECL|variable|eof_index
r_static
r_int
id|eof_index
suffix:semicolon
multiline_comment|/*  number of eof marks (entries in bad sector log) on tape.&n; */
DECL|variable|nr_of_eof_marks
r_static
r_int
id|nr_of_eof_marks
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|linux_tape_label
r_static
r_char
id|linux_tape_label
(braket
)braket
op_assign
l_string|&quot;Linux raw format V&quot;
suffix:semicolon
r_enum
(brace
DECL|enumerator|min_fmt_version
DECL|enumerator|max_fmt_version
id|min_fmt_version
op_assign
l_int|1
comma
id|max_fmt_version
op_assign
l_int|2
)brace
suffix:semicolon
DECL|variable|ftape_fmt_version
r_static
r_int
id|ftape_fmt_version
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*  Ftape (mis)uses the bad sector log to record end-of-file marks.&n; *  Initially (when the tape is erased) all entries in the bad sector&n; *  log are added to the tape&squot;s bad sector map. The bad sector log&n; *  then is cleared.&n; *&n; *  The bad sector log normally contains entries of the form:&n; *  even 16-bit word: segment number of bad sector&n; *   odd 16-bit word: encoded date&n; *  There can be a total of 448 entries (1792 bytes).&n; *&n; *  My guess is that no program is using this bad sector log (the&n; *  format seems useless as there is no indication of the bad sector&n; *  itself, only the segment)&n; *  However, if any program does use the bad sector log, the format&n; *  used by ftape will let the program think there are some bad sectors&n; *  and no harm is done.&n; *  &n; *  The eof mark entries that ftape stores in the bad sector log:&n; *  even 16-bit word: segment number of eof mark&n; *   odd 16-bit word: sector number of eof mark [1..32]&n; *  &n; *  The eof_map as maintained is a sorted list of eof mark entries.&n; *&n; *&n; *  The tape name field in the header segments is used to store a&n; *  linux tape identification string and a version number.&n; *  This way the tape can be recognized as a Linux raw format&n; *  tape when using tools under other OS&squot;s.&n; *&n; *  &squot;Wide&squot; QIC tapes (format code 4) don&squot;t have a failed sector list&n; *  anymore. That space is used for the (longer) bad sector map that&n; *  now is a variable length list too.&n; *  We now store our end-of-file marker list after the bad-sector-map&n; *  on tape. The list is delimited by a (long) 0 entry.&n; */
DECL|function|ftape_validate_label
r_int
id|ftape_validate_label
c_func
(paren
r_char
op_star
id|label
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;ftape_validate_label&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;tape  label = `%s&squot;&quot;
comma
id|label
)paren
suffix:semicolon
id|ftape_fmt_version
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|label
comma
id|linux_tape_label
comma
id|strlen
c_func
(paren
id|linux_tape_label
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|pos
op_assign
id|strlen
c_func
(paren
id|linux_tape_label
)paren
suffix:semicolon
r_while
c_loop
(paren
id|label
(braket
id|pos
)braket
op_ge
l_char|&squot;0&squot;
op_logical_and
id|label
(braket
id|pos
)braket
op_le
l_char|&squot;9&squot;
)paren
(brace
id|ftape_fmt_version
op_mul_assign
l_int|10
suffix:semicolon
id|ftape_fmt_version
op_assign
id|label
(braket
id|pos
op_increment
)braket
op_minus
l_char|&squot;0&squot;
suffix:semicolon
)brace
id|result
op_assign
(paren
id|ftape_fmt_version
op_ge
id|min_fmt_version
op_logical_and
id|ftape_fmt_version
op_le
id|max_fmt_version
)paren
suffix:semicolon
)brace
id|TRACEx1
c_func
(paren
l_int|4
comma
l_string|&quot;format version = %d&quot;
comma
id|ftape_fmt_version
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
r_static
id|byte
op_star
DECL|function|find_end_of_eof_list
id|find_end_of_eof_list
c_func
(paren
id|byte
op_star
id|ptr
comma
id|byte
op_star
id|limit
)paren
(brace
r_while
c_loop
(paren
id|ptr
op_plus
l_int|3
OL
id|limit
)paren
(brace
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
id|ptr
)paren
(brace
op_increment
(paren
r_int
r_int
op_star
)paren
id|ptr
suffix:semicolon
)brace
r_else
(brace
r_return
id|ptr
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|reset_eof_list
r_void
id|reset_eof_list
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;reset_eof_list&quot;
)paren
suffix:semicolon
id|eof_mark_ptr
op_assign
op_amp
id|eof_map
(braket
l_int|0
)braket
dot
id|mark
suffix:semicolon
id|eof_index
op_assign
l_int|0
suffix:semicolon
id|eof_mark
op_assign
l_int|0
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*  Test if `segment&squot; has an eof mark set (optimized for sequential access).&n; *  return 0 if not eof mark or sector number (&gt; 0) if eof mark set.&n; */
DECL|function|check_for_eof
r_int
id|check_for_eof
c_func
(paren
r_int
id|segment
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;check_for_eof&quot;
)paren
suffix:semicolon
r_static
r_int
id|last_reference
op_assign
id|INT_MAX
suffix:semicolon
r_int
id|result
suffix:semicolon
r_if
c_cond
(paren
id|segment
OL
id|last_reference
)paren
(brace
id|reset_eof_list
c_func
(paren
)paren
suffix:semicolon
)brace
id|last_reference
op_assign
id|segment
suffix:semicolon
r_while
c_loop
(paren
id|eof_index
template_param
id|eof_mark_ptr-&gt;segment
)paren
(brace
op_increment
id|eof_mark_ptr
suffix:semicolon
op_increment
id|eof_index
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eof_index
OL
id|nr_of_eof_marks
op_logical_and
id|segment
op_eq
id|eof_mark_ptr-&gt;segment
)paren
(brace
id|TRACEx3
c_func
(paren
l_int|5
comma
l_string|&quot;hit mark %d/%d at index %d&quot;
comma
id|eof_map
(braket
id|eof_index
)braket
dot
id|mark.segment
comma
id|eof_map
(braket
id|eof_index
)braket
dot
id|mark.sector
comma
id|eof_index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eof_mark_ptr-&gt;sector
op_ge
id|SECTORS_PER_SEGMENT
)paren
(brace
id|TRACEx2
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;Bad file mark detected: %d/%d&quot;
comma
id|eof_mark_ptr-&gt;segment
comma
id|eof_mark_ptr-&gt;sector
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* return bogus (but valid) value */
)brace
r_else
(brace
id|result
op_assign
id|eof_mark_ptr-&gt;sector
suffix:semicolon
)brace
)brace
r_else
(brace
id|result
op_assign
l_int|0
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|clear_eof_mark_if_set
r_void
id|clear_eof_mark_if_set
c_func
(paren
r_int
id|segment
comma
r_int
id|byte_count
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;clear_eof_mark_if_set&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_fmt_version
op_ne
l_int|0
op_logical_and
id|check_for_eof
c_func
(paren
id|segment
)paren
OG
l_int|0
op_logical_and
id|byte_count
op_ge
id|eof_mark_ptr-&gt;sector
op_star
id|SECTOR_SIZE
)paren
(brace
id|TRACEx3
c_func
(paren
l_int|5
comma
l_string|&quot;clearing mark %d/%d at index %d&quot;
comma
id|eof_mark_ptr-&gt;segment
comma
id|eof_mark_ptr-&gt;sector
comma
id|eof_index
)paren
suffix:semicolon
id|memmove
c_func
(paren
op_amp
id|eof_map
(braket
id|eof_index
)braket
comma
op_amp
id|eof_map
(braket
id|eof_index
op_plus
l_int|1
)braket
comma
(paren
id|nr_of_eof_marks
op_minus
id|eof_index
)paren
op_star
r_sizeof
(paren
op_star
id|eof_map
)paren
)paren
suffix:semicolon
op_decrement
id|nr_of_eof_marks
suffix:semicolon
id|failed_sector_log_changed
op_assign
l_int|1
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|put_file_mark_in_map
r_void
id|put_file_mark_in_map
c_func
(paren
r_int
id|segment
comma
r_int
id|sector
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;put_file_mark_in_map&quot;
)paren
suffix:semicolon
id|eof_mark_union
r_new
suffix:semicolon
r_int
id|index
suffix:semicolon
id|eof_mark_union
op_star
id|ptr
suffix:semicolon
r_if
c_cond
(paren
id|ftape_fmt_version
op_ne
l_int|0
)paren
(brace
r_new
dot
id|mark.segment
op_assign
id|segment
suffix:semicolon
r_new
dot
id|mark.sector
op_assign
id|sector
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
comma
id|ptr
op_assign
op_amp
id|eof_map
(braket
l_int|0
)braket
suffix:semicolon
id|index
OL
id|nr_of_eof_marks
op_logical_and
id|ptr-&gt;mark.segment
OL
id|segment
suffix:semicolon
op_increment
id|index
comma
op_increment
id|ptr
)paren
(brace
)brace
r_if
c_cond
(paren
id|index
OL
id|nr_of_eof_marks
)paren
(brace
r_if
c_cond
(paren
id|ptr-&gt;mark.segment
op_eq
id|segment
)paren
(brace
multiline_comment|/* overwrite */
r_if
c_cond
(paren
id|ptr-&gt;mark.sector
op_eq
id|sector
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|5
comma
l_string|&quot;mark %d/%d already exists&quot;
comma
r_new
dot
id|mark.segment
comma
r_new
dot
id|mark.sector
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACEx5
c_func
(paren
l_int|5
comma
l_string|&quot;overwriting %d/%d at index %d with %d/%d&quot;
comma
id|ptr-&gt;mark.segment
comma
id|ptr-&gt;mark.sector
comma
id|index
comma
r_new
dot
id|mark.segment
comma
r_new
dot
id|mark.sector
)paren
suffix:semicolon
id|ptr-&gt;entry
op_assign
r_new
dot
id|entry
suffix:semicolon
id|failed_sector_log_changed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* insert */
id|TRACEx5
c_func
(paren
l_int|5
comma
l_string|&quot;inserting %d/%d at index %d before %d/%d&quot;
comma
r_new
dot
id|mark.segment
comma
r_new
dot
id|mark.sector
comma
id|index
comma
id|ptr-&gt;mark.segment
comma
id|ptr-&gt;mark.sector
)paren
suffix:semicolon
id|memmove
c_func
(paren
id|ptr
op_plus
l_int|1
comma
id|ptr
comma
(paren
id|nr_of_eof_marks
op_minus
id|index
)paren
op_star
r_sizeof
(paren
op_star
id|eof_map
)paren
)paren
suffix:semicolon
id|ptr-&gt;entry
op_assign
r_new
dot
id|entry
suffix:semicolon
op_increment
id|nr_of_eof_marks
suffix:semicolon
id|failed_sector_log_changed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* append */
id|TRACEx3
c_func
(paren
l_int|5
comma
l_string|&quot;appending %d/%d at index %d&quot;
comma
r_new
dot
id|mark.segment
comma
r_new
dot
id|mark.sector
comma
id|index
)paren
suffix:semicolon
id|ptr-&gt;entry
op_assign
r_new
dot
id|entry
suffix:semicolon
op_increment
id|nr_of_eof_marks
suffix:semicolon
id|failed_sector_log_changed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*  Write count file marks to tape starting at first non-bad&n; *  sector following the given segment and sector.&n; *  sector = base 1 !&n; */
DECL|function|ftape_weof
r_int
id|ftape_weof
c_func
(paren
r_int
id|count
comma
r_int
id|segment
comma
r_int
id|sector
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;ftape_weof&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|mask
op_assign
id|get_bad_sector_entry
c_func
(paren
id|segment
)paren
suffix:semicolon
r_int
id|sector_nr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ftape_fmt_version
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sector
template_param
l_int|29
op_logical_or
id|segment
op_plus
id|count
op_ge
id|ftape_last_segment.id
)paren
(brace
id|TRACEx3
c_func
(paren
l_int|5
comma
l_string|&quot;parameter out of range: %d, %d, %d&quot;
comma
id|count
comma
id|segment
comma
id|sector
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
id|count
op_decrement
OG
l_int|0
)paren
(brace
r_do
(brace
multiline_comment|/* count logical sectors */
r_do
(brace
multiline_comment|/* skip until good sector */
r_while
c_loop
(paren
id|mask
op_amp
l_int|1
)paren
(brace
multiline_comment|/* skip bad sectors */
op_increment
id|sector_nr
suffix:semicolon
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sector_nr
op_ge
l_int|29
)paren
(brace
r_if
c_cond
(paren
op_increment
id|segment
op_ge
id|ftape_last_segment.id
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;segment out of range: %d&quot;
comma
id|segment
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
id|mask
op_assign
id|get_bad_sector_entry
c_func
(paren
id|segment
)paren
suffix:semicolon
id|sector_nr
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|mask
op_amp
l_int|1
)paren
suffix:semicolon
op_increment
id|sector_nr
suffix:semicolon
multiline_comment|/* point to good sector */
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|sector
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|5
comma
l_string|&quot;writing filemark %d/%d&quot;
comma
id|segment
comma
id|sector_nr
)paren
suffix:semicolon
id|put_file_mark_in_map
c_func
(paren
id|segment
comma
id|sector_nr
)paren
suffix:semicolon
op_increment
id|segment
suffix:semicolon
multiline_comment|/* next segment */
id|sector_nr
op_assign
l_int|0
suffix:semicolon
id|sector
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* first sector */
)brace
)brace
)brace
)brace
r_else
(brace
id|result
op_assign
op_minus
id|EPERM
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ftape_erase
r_int
id|ftape_erase
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;ftape_erase&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|now
op_assign
l_int|0
suffix:semicolon
id|byte
op_star
id|buffer
op_assign
id|deblock_buffer
suffix:semicolon
r_if
c_cond
(paren
id|write_protected
)paren
(brace
id|result
op_assign
op_minus
id|EROFS
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
id|read_header_segment
c_func
(paren
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_ge
l_int|0
)paren
(brace
multiline_comment|/*  Copy entries from bad-sector-log into bad-sector-map&n;&t;&t;&t; */
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;old label: `%s&squot;&quot;
comma
(paren
r_char
op_star
)paren
(paren
id|buffer
op_plus
l_int|30
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ftape_validate_label
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|buffer
(braket
l_int|30
)braket
)paren
)paren
(brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;invalid label, overwriting with new&quot;
)paren
suffix:semicolon
id|memset
c_func
(paren
id|buffer
op_plus
l_int|30
comma
l_int|0
comma
l_int|44
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|buffer
op_plus
l_int|30
comma
id|linux_tape_label
comma
id|strlen
c_func
(paren
id|linux_tape_label
)paren
)paren
suffix:semicolon
id|buffer
(braket
l_int|30
op_plus
id|strlen
c_func
(paren
id|linux_tape_label
)paren
)braket
op_assign
l_char|&squot;2&squot;
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;new label: `%s&squot;&quot;
comma
(paren
r_char
op_star
)paren
(paren
id|buffer
op_plus
l_int|30
)paren
)paren
suffix:semicolon
id|PUT4
c_func
(paren
id|buffer
comma
l_int|74
comma
id|now
)paren
suffix:semicolon
r_if
c_cond
(paren
id|format_code
op_ne
l_int|4
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_of_eof_marks
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
id|failing_segment
op_assign
id|eof_map
(braket
id|i
)braket
dot
id|mark.segment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|valid_segment_no
c_func
(paren
id|failing_segment
)paren
)paren
(brace
id|TRACEi
c_func
(paren
l_int|4
comma
l_string|&quot;bad entry in failed sector log:&quot;
comma
id|failing_segment
)paren
suffix:semicolon
)brace
r_else
(brace
id|put_bad_sector_entry
c_func
(paren
id|failing_segment
comma
id|EMPTY_SEGMENT
)paren
suffix:semicolon
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;moved entry %d from failed sector log (%d)&quot;
comma
id|i
comma
id|failing_segment
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*  Clear failed sector log: remove all tape marks&n;&t;&t;&t; */
id|failed_sector_log_changed
op_assign
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|eof_map
comma
l_int|0
comma
r_sizeof
(paren
id|eof_map
)paren
)paren
suffix:semicolon
id|nr_of_eof_marks
op_assign
l_int|0
suffix:semicolon
id|ftape_fmt_version
op_assign
id|max_fmt_version
suffix:semicolon
macro_line|#if 0
id|fix_tape
c_func
(paren
id|buffer
)paren
suffix:semicolon
multiline_comment|/* see ftape-bsm.c ! */
macro_line|#endif
id|result
op_assign
id|ftape_update_header_segments
c_func
(paren
id|buffer
comma
l_int|1
)paren
suffix:semicolon
id|prevent_flush
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* prevent flush_buffers writing file marks */
id|reset_eof_list
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|extract_file_marks
r_void
id|extract_file_marks
c_func
(paren
id|byte
op_star
id|address
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;extract_file_marks&quot;
)paren
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|format_code
op_eq
l_int|4
)paren
(brace
id|byte
op_star
id|end
suffix:semicolon
id|byte
op_star
id|start
op_assign
id|find_end_of_bsm_list
c_func
(paren
id|address
op_plus
l_int|256
comma
id|address
op_plus
l_int|29
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|memset
c_func
(paren
id|eof_map
comma
l_int|0
comma
r_sizeof
(paren
id|eof_map
)paren
)paren
suffix:semicolon
id|nr_of_eof_marks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|start
)paren
(brace
id|start
op_add_assign
l_int|3
suffix:semicolon
multiline_comment|/* skip end of list mark */
id|end
op_assign
id|find_end_of_eof_list
c_func
(paren
id|start
comma
id|address
op_plus
l_int|29
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|end
op_logical_and
id|end
op_minus
id|start
op_le
r_sizeof
(paren
id|eof_map
)paren
)paren
(brace
id|nr_of_eof_marks
op_assign
(paren
id|end
op_minus
id|start
)paren
op_div
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|eof_map
comma
id|start
comma
id|end
op_minus
id|start
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;File Mark List is too long or damaged !&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|1
comma
l_string|&quot;Bad Sector List is too long or damaged !&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|eof_map
comma
id|address
op_plus
l_int|256
comma
r_sizeof
(paren
id|eof_map
)paren
)paren
suffix:semicolon
id|nr_of_eof_marks
op_assign
id|GET2
c_func
(paren
id|address
comma
l_int|144
)paren
suffix:semicolon
)brace
id|TRACEi
c_func
(paren
l_int|4
comma
l_string|&quot;number of file marks:&quot;
comma
id|nr_of_eof_marks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_fmt_version
op_eq
l_int|1
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;swapping version 1 fields&quot;
)paren
suffix:semicolon
multiline_comment|/*  version 1 format uses swapped sector and segment fields, correct that !&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_of_eof_marks
suffix:semicolon
op_increment
id|i
)paren
(brace
r_int
r_int
id|tmp
op_assign
id|eof_map
(braket
id|i
)braket
dot
id|mark.segment
suffix:semicolon
id|eof_map
(braket
id|i
)braket
dot
id|mark.segment
op_assign
id|eof_map
(braket
id|i
)braket
dot
id|mark.sector
suffix:semicolon
id|eof_map
(braket
id|i
)braket
dot
id|mark.sector
op_assign
id|tmp
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_of_eof_marks
suffix:semicolon
op_increment
id|i
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;eof mark: %5d/%2d&quot;
comma
id|eof_map
(braket
id|i
)braket
dot
id|mark.segment
comma
id|eof_map
(braket
id|i
)braket
dot
id|mark.sector
)paren
suffix:semicolon
)brace
id|reset_eof_list
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|update_failed_sector_log
r_int
id|update_failed_sector_log
c_func
(paren
id|byte
op_star
id|buffer
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|8
comma
l_string|&quot;update_failed_sector_log&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_fmt_version
op_ne
l_int|0
op_logical_and
id|failed_sector_log_changed
)paren
(brace
r_if
c_cond
(paren
id|ftape_fmt_version
op_eq
l_int|1
)paren
(brace
id|TRACE
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;upgrading version 1 format to version 2&quot;
)paren
suffix:semicolon
multiline_comment|/*  version 1 will be upgraded to version 2 when written.&n;&t;&t;&t; */
id|buffer
(braket
l_int|30
op_plus
id|strlen
c_func
(paren
id|linux_tape_label
)paren
)braket
op_assign
l_char|&squot;2&squot;
suffix:semicolon
id|ftape_fmt_version
op_assign
l_int|2
suffix:semicolon
id|TRACEx1
c_func
(paren
op_minus
l_int|1
comma
l_string|&quot;new tape label = &bslash;&quot;%s&bslash;&quot;&quot;
comma
op_amp
id|buffer
(braket
l_int|30
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|format_code
op_eq
l_int|4
)paren
(brace
id|byte
op_star
id|dest
op_assign
id|find_end_of_bsm_list
c_func
(paren
id|buffer
op_plus
l_int|256
comma
id|buffer
op_plus
l_int|29
op_star
id|SECTOR_SIZE
)paren
op_plus
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|dest
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;eof_map at byte offset %6d, size %d&quot;
comma
id|dest
op_minus
id|buffer
op_minus
l_int|256
comma
id|nr_of_eof_marks
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dest
comma
id|eof_map
comma
id|nr_of_eof_marks
op_star
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
id|PUT4
c_func
(paren
id|dest
comma
id|nr_of_eof_marks
op_star
r_sizeof
(paren
r_int
r_int
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|memcpy
c_func
(paren
id|buffer
op_plus
l_int|256
comma
id|eof_map
comma
r_sizeof
(paren
id|eof_map
)paren
)paren
suffix:semicolon
id|PUT2
c_func
(paren
id|buffer
comma
l_int|144
comma
id|nr_of_eof_marks
)paren
suffix:semicolon
)brace
id|failed_sector_log_changed
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ftape_seek_eom
r_int
id|ftape_seek_eom
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;ftape_seek_eom&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|eom
suffix:semicolon
r_if
c_cond
(paren
id|first_data_segment
op_eq
op_minus
l_int|1
)paren
(brace
id|result
op_assign
id|read_header_segment
c_func
(paren
id|deblock_buffer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ge
l_int|0
op_logical_and
id|ftape_fmt_version
op_ne
l_int|0
)paren
(brace
id|eom
op_assign
id|first_data_segment
suffix:semicolon
id|eof_index
op_assign
l_int|0
suffix:semicolon
id|eof_mark_ptr
op_assign
op_amp
id|eof_map
(braket
l_int|0
)braket
dot
id|mark
suffix:semicolon
multiline_comment|/*  If fresh tape, count should be zero but we don&squot;t&n;&t;&t; *  want to worry about the case it&squot;s one.&n;&t;&t; */
r_for
c_loop
(paren
id|eof_index
op_assign
l_int|1
comma
id|eof_mark_ptr
op_assign
op_amp
id|eof_map
(braket
l_int|1
)braket
dot
id|mark
suffix:semicolon
id|eof_index
OL
id|nr_of_eof_marks
suffix:semicolon
op_increment
id|eof_index
comma
op_increment
id|eof_mark_ptr
)paren
(brace
multiline_comment|/*  The eom is recorded as two eof marks in succeeding segments&n;&t;&t;&t; *  where the second one is always at segment number 1.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|eof_mark_ptr-&gt;sector
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|eof_mark_ptr-&gt;segment
op_eq
(paren
id|eof_mark_ptr
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|segment
op_plus
l_int|1
)paren
(brace
id|eom
op_assign
id|eof_mark_ptr-&gt;segment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|ftape_seg_pos
op_assign
id|eom
suffix:semicolon
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;eom found at segment %d&quot;
comma
id|eom
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;Couldn&squot;t get eof mark table&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ftape_seek_eof
r_int
id|ftape_seek_eof
c_func
(paren
r_int
id|count
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;ftape_seek_eof&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_enum
(brace
op_logical_neg
op_assign
l_int|0
comma
id|begin
comma
id|end
)brace
id|bad_seek
op_assign
op_logical_neg
suffix:semicolon
r_if
c_cond
(paren
id|first_data_segment
op_eq
op_minus
l_int|1
)paren
(brace
id|result
op_assign
id|read_header_segment
c_func
(paren
id|deblock_buffer
)paren
suffix:semicolon
)brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;tape positioned at segment %d&quot;
comma
id|ftape_seg_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftape_fmt_version
op_eq
l_int|0
)paren
(brace
id|result
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
op_ge
l_int|0
op_logical_and
id|count
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|eof_index
op_assign
l_int|0
suffix:semicolon
id|eof_index
op_le
id|nr_of_eof_marks
suffix:semicolon
op_increment
id|eof_index
)paren
(brace
r_if
c_cond
(paren
id|eof_index
op_eq
id|nr_of_eof_marks
op_logical_or
multiline_comment|/* start seeking after last mark */
id|ftape_seg_pos
op_le
id|eof_map
(braket
id|eof_index
)braket
dot
id|mark.segment
)paren
(brace
id|eof_index
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|eof_index
OL
l_int|1
)paren
(brace
multiline_comment|/* begin of tape */
id|ftape_seg_pos
op_assign
id|first_data_segment
suffix:semicolon
r_if
c_cond
(paren
id|eof_index
OL
l_int|0
)paren
(brace
multiline_comment|/* `before&squot; begin of tape */
id|eof_index
op_assign
l_int|0
suffix:semicolon
id|bad_seek
op_assign
id|begin
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|eof_index
op_ge
id|nr_of_eof_marks
)paren
(brace
multiline_comment|/* `after&squot; end of tape */
id|ftape_seg_pos
op_assign
id|segments_per_track
op_star
id|tracks_per_tape
suffix:semicolon
r_if
c_cond
(paren
id|eof_index
OG
id|nr_of_eof_marks
)paren
(brace
id|eof_index
op_assign
id|nr_of_eof_marks
suffix:semicolon
id|bad_seek
op_assign
id|end
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* after requested file mark */
id|ftape_seg_pos
op_assign
id|eof_map
(braket
id|eof_index
op_minus
l_int|1
)braket
dot
id|mark.segment
op_plus
l_int|1
suffix:semicolon
)brace
id|eof_mark_ptr
op_assign
op_amp
id|eof_map
(braket
id|eof_index
)braket
dot
id|mark
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
l_int|5
comma
l_string|&quot;Couldn&squot;t get eof mark table&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|bad_seek
op_ne
op_logical_neg
)paren
(brace
id|TRACEx1
c_func
(paren
l_int|1
comma
l_string|&quot;seek reached %s of tape&quot;
comma
(paren
id|bad_seek
op_eq
id|begin
)paren
ques
c_cond
l_string|&quot;begin&quot;
suffix:colon
l_string|&quot;end&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
r_else
(brace
id|TRACEx1
c_func
(paren
l_int|5
comma
l_string|&quot;tape repositioned to segment %d&quot;
comma
id|ftape_seg_pos
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|ftape_file_no
r_int
id|ftape_file_no
c_func
(paren
id|daddr_t
op_star
id|f_no
comma
id|daddr_t
op_star
id|b_no
)paren
(brace
id|TRACE_FUN
c_func
(paren
l_int|5
comma
l_string|&quot;ftape_file_no&quot;
)paren
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
op_star
id|f_no
op_assign
id|eof_index
suffix:semicolon
op_star
id|b_no
op_assign
id|ftape_seg_pos
suffix:semicolon
id|TRACEi
c_func
(paren
l_int|4
comma
l_string|&quot;number of file marks:&quot;
comma
id|nr_of_eof_marks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_of_eof_marks
suffix:semicolon
op_increment
id|i
)paren
(brace
id|TRACEx2
c_func
(paren
l_int|4
comma
l_string|&quot;eof mark: %5d/%2d&quot;
comma
id|eof_map
(braket
id|i
)braket
dot
id|mark.segment
comma
id|eof_map
(braket
id|i
)braket
dot
id|mark.sector
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
eof
