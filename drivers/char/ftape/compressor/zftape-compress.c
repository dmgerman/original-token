multiline_comment|/*&n; *      Copyright (C) 1994-1997 Claus-Justus Heine&n;&n; This program is free software; you can redistribute it and/or&n; modify it under the terms of the GNU General Public License as&n; published by the Free Software Foundation; either version 2, or (at&n; your option) any later version.&n; &n; This program is distributed in the hope that it will be useful, but&n; WITHOUT ANY WARRANTY; without even the implied warranty of&n; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; General Public License for more details.&n; &n; You should have received a copy of the GNU General Public License&n; along with this program; see the file COPYING.  If not, write to&n; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139,&n; USA.&n; &n; *&n; *     This file implements a &quot;generic&quot; interface between the *&n; *     zftape-driver and a compression-algorithm. The *&n; *     compression-algorithm currently used is a LZ77. I use the *&n; *     implementation lzrw3 by Ross N. Williams (Renaissance *&n; *     Software). The compression program itself is in the file&n; *     lzrw3.c * and lzrw3.h.  To adopt another compression algorithm&n; *     the functions * zft_compress() and zft_uncompress() must be&n; *     changed * appropriately. See below.&n; */
DECL|variable|zftc_src
r_char
id|zftc_src
(braket
)braket
op_assign
l_string|&quot;$Source: /homes/cvs/ftape-stacked/ftape/compressor/zftape-compress.c,v $&quot;
suffix:semicolon
DECL|variable|zftc_rev
r_char
id|zftc_rev
(braket
)braket
op_assign
l_string|&quot;$Revision: 1.1.6.1 $&quot;
suffix:semicolon
DECL|variable|zftc_dat
r_char
id|zftc_dat
(braket
)braket
op_assign
l_string|&quot;$Date: 1997/11/16 15:15:56 $&quot;
suffix:semicolon
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/zftape.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,1,6)
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#else
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#endif
macro_line|#include &quot;../zftape/zftape-init.h&quot;
macro_line|#include &quot;../zftape/zftape-eof.h&quot;
macro_line|#include &quot;../zftape/zftape-ctl.h&quot;
macro_line|#include &quot;../zftape/zftape-write.h&quot;
macro_line|#include &quot;../zftape/zftape-read.h&quot;
macro_line|#include &quot;../zftape/zftape-rw.h&quot;
macro_line|#include &quot;../compressor/zftape-compress.h&quot;
macro_line|#include &quot;../zftape/zftape-vtbl.h&quot;
macro_line|#include &quot;../compressor/lzrw3.h&quot;
multiline_comment|/*&n; *   global variables&n; */
multiline_comment|/* I handle the allocation of this buffer as a special case, because&n; * it&squot;s size varies depending on the tape length inserted.&n; */
multiline_comment|/* local variables &n; */
DECL|variable|keep_module_locked
r_static
r_int
id|keep_module_locked
op_assign
l_int|1
suffix:semicolon
DECL|variable|zftc_wrk_mem
r_static
r_void
op_star
id|zftc_wrk_mem
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|zftc_buf
r_static
id|__u8
op_star
id|zftc_buf
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|zftc_scratch_buf
r_static
r_void
op_star
id|zftc_scratch_buf
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* compression statistics &n; */
DECL|variable|zftc_wr_uncompressed
r_static
r_int
r_int
id|zftc_wr_uncompressed
op_assign
l_int|0
suffix:semicolon
DECL|variable|zftc_wr_compressed
r_static
r_int
r_int
id|zftc_wr_compressed
op_assign
l_int|0
suffix:semicolon
DECL|variable|zftc_rd_uncompressed
r_static
r_int
r_int
id|zftc_rd_uncompressed
op_assign
l_int|0
suffix:semicolon
DECL|variable|zftc_rd_compressed
r_static
r_int
r_int
id|zftc_rd_compressed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* forward */
r_static
r_int
id|zftc_write
c_func
(paren
r_int
op_star
id|write_cnt
comma
id|__u8
op_star
id|dst_buf
comma
r_const
r_int
id|seg_sz
comma
r_const
id|__u8
op_star
id|src_buf
comma
r_const
r_int
id|req_len
comma
r_const
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
)paren
suffix:semicolon
r_static
r_int
id|zftc_read
c_func
(paren
r_int
op_star
id|read_cnt
comma
id|__u8
op_star
id|dst_buf
comma
r_const
r_int
id|to_do
comma
r_const
id|__u8
op_star
id|src_buf
comma
r_const
r_int
id|seg_sz
comma
r_const
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
)paren
suffix:semicolon
r_static
r_int
id|zftc_seek
c_func
(paren
r_int
r_int
id|new_block_pos
comma
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
comma
id|__u8
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_void
id|zftc_lock
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|zftc_reset
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|zftc_cleanup
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|zftc_stats
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* compressed segment. This conforms to QIC-80-MC, Revision K.&n; * &n; * Rev. K applies to tapes with `fixed length format&squot; which is&n; * indicated by format code 2,3 and 5. See below for format code 4 and 6&n; *&n; * 2 bytes: offset of compression segment structure&n; *          29k &gt; offset &gt;= 29k-18: data from previous segment ens in this&n; *                                  segment and no compressed block starts&n; *                                  in this segment&n; *                     offset == 0: data from previous segment occupies entire&n; *                                  segment and continues in next segment&n; * n bytes: remainder from previous segment&n; * &n; * Rev. K:  &n; * 4 bytes: 4 bytes: files set byte offset&n; * Post Rev. K and QIC-3020/3020:&n; * 8 bytes: 8 bytes: files set byte offset&n; * 2 bytes: byte count N (amount of data following)&n; *          bit 15 is set if data is compressed, bit 15 is not&n; *          set if data is uncompressed&n; * N bytes: data (as much as specified in the byte count)&n; * 2 bytes: byte count N_1 of next cluster&n; * N_1 bytes: data of next cluset&n; * 2 bytes: byte count N_2 of next cluster&n; * N_2 bytes: ...  &n; *&n; * Note that the `N&squot; byte count accounts only for the bytes that in the&n; * current segment if the cluster spans to the next segment.&n; */
r_typedef
r_struct
(brace
DECL|member|cmpr_pos
r_int
id|cmpr_pos
suffix:semicolon
multiline_comment|/* actual position in compression buffer */
DECL|member|cmpr_sz
r_int
id|cmpr_sz
suffix:semicolon
multiline_comment|/* what is left in the compression buffer&n;&t;&t;&t;&t;   * when copying the compressed data to the&n;&t;&t;&t;&t;   * deblock buffer&n;&t;&t;&t;&t;   */
DECL|member|first_block
r_int
r_int
id|first_block
suffix:semicolon
multiline_comment|/* location of header information in&n;&t;&t;&t;&t;   * this segment&n;&t;&t;&t;&t;   */
DECL|member|count
r_int
r_int
id|count
suffix:semicolon
multiline_comment|/* amount of data of current block&n;&t;&t;&t;&t;   * contained in current segment &n;&t;&t;&t;&t;   */
DECL|member|offset
r_int
r_int
id|offset
suffix:semicolon
multiline_comment|/* offset in current segment */
DECL|member|spans
r_int
r_int
id|spans
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* might continue in next segment */
DECL|member|uncmpr
r_int
r_int
id|uncmpr
suffix:semicolon
multiline_comment|/* 0x8000 if this block contains&n;&t;&t;&t;&t;   * uncompressed data &n;&t;&t;&t;&t;   */
DECL|member|foffs
id|__s64
id|foffs
suffix:semicolon
multiline_comment|/* file set byte offset, same as in &n;&t;&t;&t;&t;   * compression map segment&n;&t;&t;&t;&t;   */
DECL|typedef|cmpr_info
)brace
id|cmpr_info
suffix:semicolon
DECL|variable|cseg
r_static
id|cmpr_info
id|cseg
suffix:semicolon
multiline_comment|/* static data. Must be kept uptodate and shared by &n;&t;&t;&t;* read, write and seek functions&n;&t;&t;&t;*/
DECL|macro|DUMP_CMPR_INFO
mdefine_line|#define DUMP_CMPR_INFO(level, msg, info)&t;&t;&t;&t;&bslash;&n;&t;TRACE(level, msg &quot;&bslash;n&quot;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;      KERN_INFO &quot;cmpr_pos   : %d&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;      KERN_INFO &quot;cmpr_sz    : %d&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;      KERN_INFO &quot;first_block: %d&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;      KERN_INFO &quot;count      : %d&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;      KERN_INFO &quot;offset     : %d&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;      KERN_INFO &quot;spans      : %d&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;      KERN_INFO &quot;uncmpr     : 0x%04x&bslash;n&quot;&t;&t;&t;&t;&bslash;&n;&t;      KERN_INFO &quot;foffs      : &quot; LL_X,&t;&t;&t;&t;&bslash;&n;&t;      (info)-&gt;cmpr_pos, (info)-&gt;cmpr_sz, (info)-&gt;first_block,&t;&bslash;&n;&t;      (info)-&gt;count, (info)-&gt;offset, (info)-&gt;spans == 1,&t;&bslash;&n;&t;      (info)-&gt;uncmpr, LL((info)-&gt;foffs))
multiline_comment|/*   dispatch compression segment info, return error code&n; *  &n; *   afterwards, cseg-&gt;offset points to start of data of the NEXT&n; *   compressed block, and cseg-&gt;count contains the amount of data&n; *   left in the actual compressed block. cseg-&gt;spans is set to 1 if&n; *   the block is continued in the following segment. Otherwise it is&n; *   set to 0. &n; */
DECL|function|get_cseg
r_static
r_int
id|get_cseg
(paren
id|cmpr_info
op_star
id|cinfo
comma
r_const
id|__u8
op_star
id|buff
comma
r_const
r_int
r_int
id|seg_sz
comma
r_const
id|zft_volinfo
op_star
id|volume
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|cinfo-&gt;first_block
op_assign
id|GET2
c_func
(paren
id|buff
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cinfo-&gt;first_block
op_eq
l_int|0
)paren
(brace
multiline_comment|/* data spans to next segment */
id|cinfo-&gt;count
op_assign
id|seg_sz
op_minus
r_sizeof
(paren
id|__u16
)paren
suffix:semicolon
id|cinfo-&gt;offset
op_assign
id|seg_sz
suffix:semicolon
id|cinfo-&gt;spans
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* cluster definetely ends in this segment */
r_if
c_cond
(paren
id|cinfo-&gt;first_block
OG
id|seg_sz
)paren
(brace
multiline_comment|/* data corrupted */
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;corrupted data:&bslash;n&quot;
id|KERN_INFO
l_string|&quot;segment size: %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;first block : %d&quot;
comma
id|seg_sz
comma
id|cinfo-&gt;first_block
)paren
suffix:semicolon
)brace
id|cinfo-&gt;count
op_assign
id|cinfo-&gt;first_block
op_minus
r_sizeof
(paren
id|__u16
)paren
suffix:semicolon
id|cinfo-&gt;offset
op_assign
id|cinfo-&gt;first_block
suffix:semicolon
id|cinfo-&gt;spans
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* now get the offset the first block should have in the&n;&t; * uncompressed data stream.&n;&t; *&n;&t; * For this magic `18&squot; refer to CRF-3 standard or QIC-80MC,&n;&t; * Rev. K.  &n;&t; */
r_if
c_cond
(paren
(paren
id|seg_sz
op_minus
id|cinfo-&gt;offset
)paren
OG
l_int|18
)paren
(brace
r_if
c_cond
(paren
id|volume-&gt;qic113
)paren
(brace
multiline_comment|/* &gt; revision K */
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;New QIC-113 compliance&quot;
)paren
suffix:semicolon
id|cinfo-&gt;foffs
op_assign
id|GET8
c_func
(paren
id|buff
comma
id|cinfo-&gt;offset
)paren
suffix:semicolon
id|cinfo-&gt;offset
op_add_assign
r_sizeof
(paren
id|__s64
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
multiline_comment|/* ft_t_data_flow */
id|ft_t_noise
comma
l_string|&quot;pre QIC-113 version&quot;
)paren
suffix:semicolon
id|cinfo-&gt;foffs
op_assign
(paren
id|__s64
)paren
id|GET4
c_func
(paren
id|buff
comma
id|cinfo-&gt;offset
)paren
suffix:semicolon
id|cinfo-&gt;offset
op_add_assign
r_sizeof
(paren
id|__u32
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cinfo-&gt;foffs
OG
id|volume-&gt;size
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;Inconsistency:&bslash;n&quot;
id|KERN_INFO
l_string|&quot;offset in current volume: %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;size of current volume  : %d&quot;
comma
(paren
r_int
)paren
(paren
id|cinfo-&gt;foffs
op_rshift
l_int|10
)paren
comma
(paren
r_int
)paren
(paren
id|volume-&gt;size
op_rshift
l_int|10
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cinfo-&gt;cmpr_pos
op_plus
id|cinfo-&gt;count
OG
id|volume-&gt;blk_sz
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_err
comma
l_string|&quot;Inconsistency:&bslash;n&quot;
id|KERN_INFO
l_string|&quot;block size : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;data record: %d&quot;
comma
id|volume-&gt;blk_sz
comma
id|cinfo-&gt;cmpr_pos
op_plus
id|cinfo-&gt;count
)paren
suffix:semicolon
)brace
id|DUMP_CMPR_INFO
c_func
(paren
id|ft_t_noise
multiline_comment|/* ft_t_any */
comma
l_string|&quot;&quot;
comma
id|cinfo
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  This one is called, when a new cluster starts in same segment.&n; *  &n; *  Note: if this is the first cluster in the current segment, we must&n; *  not check whether there are more than 18 bytes available because&n; *  this have already been done in get_cseg() and there may be less&n; *  than 18 bytes available due to header information.&n; * &n; */
DECL|function|get_next_cluster
r_static
r_void
id|get_next_cluster
c_func
(paren
id|cmpr_info
op_star
id|cluster
comma
r_const
id|__u8
op_star
id|buff
comma
r_const
r_int
id|seg_sz
comma
r_const
r_int
id|finish
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|seg_sz
op_minus
id|cluster-&gt;offset
OG
l_int|18
op_logical_or
id|cluster-&gt;foffs
op_ne
l_int|0
)paren
(brace
id|cluster-&gt;count
op_assign
id|GET2
c_func
(paren
id|buff
comma
id|cluster-&gt;offset
)paren
suffix:semicolon
id|cluster-&gt;uncmpr
op_assign
id|cluster-&gt;count
op_amp
l_int|0x8000
suffix:semicolon
id|cluster-&gt;count
op_sub_assign
id|cluster-&gt;uncmpr
suffix:semicolon
id|cluster-&gt;offset
op_add_assign
r_sizeof
(paren
id|__u16
)paren
suffix:semicolon
id|cluster-&gt;foffs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cluster-&gt;offset
op_plus
id|cluster-&gt;count
)paren
OL
id|seg_sz
)paren
(brace
id|cluster-&gt;spans
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cluster-&gt;offset
op_plus
id|cluster-&gt;count
op_eq
id|seg_sz
)paren
(brace
id|cluster-&gt;spans
op_assign
op_logical_neg
id|finish
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* either an error or a volume written by an &n;&t;&t;&t; * old version. If this is a data error, then we&squot;ll&n;&t;&t;&t; * catch it later.&n;&t;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;Either error or old volume&quot;
)paren
suffix:semicolon
id|cluster-&gt;spans
op_assign
l_int|1
suffix:semicolon
id|cluster-&gt;count
op_assign
id|seg_sz
op_minus
id|cluster-&gt;offset
suffix:semicolon
)brace
)brace
r_else
(brace
id|cluster-&gt;count
op_assign
l_int|0
suffix:semicolon
id|cluster-&gt;spans
op_assign
l_int|0
suffix:semicolon
id|cluster-&gt;foffs
op_assign
l_int|0
suffix:semicolon
)brace
id|DUMP_CMPR_INFO
c_func
(paren
id|ft_t_noise
multiline_comment|/* ft_t_any */
comma
l_string|&quot;&quot;
comma
id|cluster
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|function|zftc_lock
r_static
r_void
id|zftc_lock
c_func
(paren
r_void
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VER(2,1,18)
r_if
c_cond
(paren
op_logical_neg
id|MOD_IN_USE
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
)brace
macro_line|#else
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/*  sets MOD_VISITED and MOD_USED_ONCE,&n;&t;&t;&t;    *  locking is done with can_unload()&n;&t;&t;&t;    */
macro_line|#endif
id|keep_module_locked
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*  this function is needed for zftape_reset_position in zftape-io.c &n; */
DECL|function|zftc_reset
r_static
r_void
id|zftc_reset
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|cseg
comma
l_char|&squot;&bslash;0&squot;
comma
r_sizeof
(paren
id|cseg
)paren
)paren
suffix:semicolon
id|zftc_stats
c_func
(paren
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VER(2,1,18)
r_if
c_cond
(paren
id|MOD_IN_USE
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
macro_line|#endif
id|keep_module_locked
op_assign
l_int|0
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
DECL|variable|cmpr_mem_initialized
r_static
r_int
id|cmpr_mem_initialized
op_assign
l_int|0
suffix:semicolon
DECL|variable|alloc_blksz
r_static
r_int
r_int
id|alloc_blksz
op_assign
l_int|0
suffix:semicolon
DECL|function|zft_allocate_cmpr_mem
r_static
r_int
id|zft_allocate_cmpr_mem
c_func
(paren
r_int
r_int
id|blksz
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmpr_mem_initialized
op_logical_and
id|blksz
op_eq
id|alloc_blksz
)paren
(brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
id|TRACE_CATCH
c_func
(paren
id|zft_vmalloc_once
c_func
(paren
op_amp
id|zftc_wrk_mem
comma
id|CMPR_WRK_MEM_SIZE
)paren
comma
id|zftc_cleanup
c_func
(paren
)paren
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|zft_vmalloc_always
c_func
(paren
op_amp
id|zftc_buf
comma
id|blksz
op_plus
id|CMPR_OVERRUN
)paren
comma
id|zftc_cleanup
c_func
(paren
)paren
)paren
suffix:semicolon
id|alloc_blksz
op_assign
id|blksz
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|zft_vmalloc_always
c_func
(paren
op_amp
id|zftc_scratch_buf
comma
id|blksz
op_plus
id|CMPR_OVERRUN
)paren
comma
id|zftc_cleanup
c_func
(paren
)paren
)paren
suffix:semicolon
id|cmpr_mem_initialized
op_assign
l_int|1
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
DECL|function|zftc_cleanup
r_static
r_void
id|zftc_cleanup
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|zft_vfree
c_func
(paren
op_amp
id|zftc_wrk_mem
comma
id|CMPR_WRK_MEM_SIZE
)paren
suffix:semicolon
id|zft_vfree
c_func
(paren
op_amp
id|zftc_buf
comma
id|alloc_blksz
op_plus
id|CMPR_OVERRUN
)paren
suffix:semicolon
id|zft_vfree
c_func
(paren
op_amp
id|zftc_scratch_buf
comma
id|alloc_blksz
op_plus
id|CMPR_OVERRUN
)paren
suffix:semicolon
id|cmpr_mem_initialized
op_assign
id|alloc_blksz
op_assign
l_int|0
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *                                                                           *&n; *  The following two functions &quot;ftape_compress()&quot; and                       *&n; *  &quot;ftape_uncompress()&quot; are the interface to the actual compression         *&n; *  algorithm (i.e. they are calling the &quot;compress()&quot; function from          *&n; *  the lzrw3 package for now). These routines could quite easily be         *&n; *  changed to adopt another compression algorithm instead of lzrw3,         *&n; *  which currently is used.                                                 *&n; *                                                                           *&n; *****************************************************************************/
multiline_comment|/* called by zft_compress_write() to perform the compression. Must&n; * return the size of the compressed data.&n; *&n; * NOTE: The size of the compressed data should not exceed the size of&n; *       the uncompressed data. Most compression algorithms have means&n; *       to store data unchanged if the &quot;compressed&quot; data amount would&n; *       exceed the original one. Mostly this is done by storing some&n; *       flag-bytes in front of the compressed data to indicate if it&n; *       is compressed or not. Thus the worst compression result&n; *       length is the original length plus those flag-bytes.&n; *&n; *       We don&squot;t want that, as the QIC-80 standard provides a means&n; *       of marking uncompressed blocks by simply setting bit 15 of&n; *       the compressed block&squot;s length. Thus a compessed block can&n; *       have at most a length of 2^15-1 bytes. The QIC-80 standard&n; *       restricts the block-length even further, allowing only 29k -&n; *       6 bytes.&n; *&n; *       Currently, the maximum blocksize used by zftape is 28k.&n; *&n; *       In short: don&squot;t exceed the length of the input-package, set&n; *       bit 15 of the compressed size to 1 if you have copied data&n; *       instead of compressing it.&n; */
DECL|function|zft_compress
r_static
r_int
id|zft_compress
c_func
(paren
id|__u8
op_star
id|in_buffer
comma
r_int
r_int
id|in_sz
comma
id|__u8
op_star
id|out_buffer
)paren
(brace
id|__s32
id|compressed_sz
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|lzrw3_compress
c_func
(paren
id|COMPRESS_ACTION_COMPRESS
comma
id|zftc_wrk_mem
comma
id|in_buffer
comma
id|in_sz
comma
id|out_buffer
comma
op_amp
id|compressed_sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TRACE_LEVEL
op_ge
id|ft_t_info
)paren
(brace
multiline_comment|/*  the compiler will optimize this away when&n;&t;&t; *  compiled with NO_TRACE_AT_ALL option&n;&t;&t; */
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;before compression: %d bytes&bslash;n&quot;
id|KERN_INFO
l_string|&quot;after compresison : %d bytes&quot;
comma
id|in_sz
comma
(paren
r_int
)paren
(paren
id|compressed_sz
OL
l_int|0
ques
c_cond
op_minus
id|compressed_sz
suffix:colon
id|compressed_sz
)paren
)paren
suffix:semicolon
multiline_comment|/*  for statistical purposes&n;&t;&t; */
id|zftc_wr_compressed
op_add_assign
(paren
id|compressed_sz
OL
l_int|0
ques
c_cond
op_minus
id|compressed_sz
suffix:colon
id|compressed_sz
)paren
suffix:semicolon
id|zftc_wr_uncompressed
op_add_assign
id|in_sz
suffix:semicolon
)brace
id|TRACE_EXIT
(paren
r_int
)paren
id|compressed_sz
suffix:semicolon
)brace
multiline_comment|/* called by zft_compress_read() to decompress the data. Must&n; * return the size of the decompressed data for sanity checks&n; * (compared with zft_blk_sz)&n; *&n; * NOTE: Read the note for zft_compress() above!  If bit 15 of the&n; *       parameter in_sz is set, then the data in in_buffer isn&squot;t&n; *       compressed, which must be handled by the un-compression&n; *       algorithm. (I changed lzrw3 to handle this.)&n; *&n; *  The parameter max_out_sz is needed to prevent buffer overruns when &n; *  uncompressing corrupt data.&n; */
DECL|function|zft_uncompress
r_static
r_int
r_int
id|zft_uncompress
c_func
(paren
id|__u8
op_star
id|in_buffer
comma
r_int
id|in_sz
comma
id|__u8
op_star
id|out_buffer
comma
r_int
r_int
id|max_out_sz
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|lzrw3_compress
c_func
(paren
id|COMPRESS_ACTION_DECOMPRESS
comma
id|zftc_wrk_mem
comma
id|in_buffer
comma
(paren
id|__s32
)paren
id|in_sz
comma
id|out_buffer
comma
(paren
id|__u32
op_star
)paren
op_amp
id|max_out_sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TRACE_LEVEL
op_ge
id|ft_t_info
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;before decompression: %d bytes&bslash;n&quot;
id|KERN_INFO
l_string|&quot;after decompression : %d bytes&quot;
comma
id|in_sz
OL
l_int|0
ques
c_cond
op_minus
id|in_sz
suffix:colon
id|in_sz
comma
(paren
r_int
)paren
id|max_out_sz
)paren
suffix:semicolon
multiline_comment|/*  for statistical purposes&n;&t;&t; */
id|zftc_rd_compressed
op_add_assign
id|in_sz
OL
l_int|0
ques
c_cond
op_minus
id|in_sz
suffix:colon
id|in_sz
suffix:semicolon
id|zftc_rd_uncompressed
op_add_assign
id|max_out_sz
suffix:semicolon
)brace
id|TRACE_EXIT
(paren
r_int
r_int
)paren
id|max_out_sz
suffix:semicolon
)brace
multiline_comment|/* print some statistics about the efficiency of the compression to&n; * the kernel log &n; */
DECL|function|zftc_stats
r_static
r_void
id|zftc_stats
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TRACE_LEVEL
OL
id|ft_t_info
)paren
(brace
id|TRACE_EXIT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zftc_wr_uncompressed
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|zftc_wr_compressed
OG
(paren
l_int|1
op_lshift
l_int|14
)paren
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;compression statistics (writing):&bslash;n&quot;
id|KERN_INFO
l_string|&quot; compr./uncmpr.   : %3d %%&quot;
comma
(paren
(paren
(paren
id|zftc_wr_compressed
op_rshift
l_int|10
)paren
op_star
l_int|100
)paren
op_div
(paren
id|zftc_wr_uncompressed
op_rshift
l_int|10
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;compression statistics (writing):&bslash;n&quot;
id|KERN_INFO
l_string|&quot; compr./uncmpr.   : %3d %%&quot;
comma
(paren
(paren
id|zftc_wr_compressed
op_star
l_int|100
)paren
op_div
id|zftc_wr_uncompressed
)paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|zftc_rd_uncompressed
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|zftc_rd_compressed
OG
(paren
l_int|1
op_lshift
l_int|14
)paren
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;compression statistics (reading):&bslash;n&quot;
id|KERN_INFO
l_string|&quot; compr./uncmpr.   : %3d %%&quot;
comma
(paren
(paren
(paren
id|zftc_rd_compressed
op_rshift
l_int|10
)paren
op_star
l_int|100
)paren
op_div
(paren
id|zftc_rd_uncompressed
op_rshift
l_int|10
)paren
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;compression statistics (reading):&bslash;n&quot;
id|KERN_INFO
l_string|&quot; compr./uncmpr.   : %3d %%&quot;
comma
(paren
(paren
id|zftc_rd_compressed
op_star
l_int|100
)paren
op_div
id|zftc_rd_uncompressed
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* only print it once: */
id|zftc_wr_uncompressed
op_assign
id|zftc_wr_compressed
op_assign
id|zftc_rd_uncompressed
op_assign
id|zftc_rd_compressed
op_assign
l_int|0
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
multiline_comment|/* start new compressed block &n; */
DECL|function|start_new_cseg
r_static
r_int
id|start_new_cseg
c_func
(paren
id|cmpr_info
op_star
id|cluster
comma
r_char
op_star
id|dst_buf
comma
r_const
id|zft_position
op_star
id|pos
comma
r_const
r_int
r_int
id|blk_sz
comma
r_const
r_char
op_star
id|src_buf
comma
r_const
r_int
id|this_segs_sz
comma
r_const
r_int
id|qic113
)paren
(brace
r_int
id|size_left
suffix:semicolon
r_int
id|cp_cnt
suffix:semicolon
r_int
id|buf_pos
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|size_left
op_assign
id|this_segs_sz
op_minus
r_sizeof
(paren
id|__u16
)paren
op_minus
id|cluster-&gt;cmpr_sz
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;segment size   : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;compressed_sz: %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;size_left      : %d&quot;
comma
id|this_segs_sz
comma
id|cluster-&gt;cmpr_sz
comma
id|size_left
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size_left
OG
l_int|18
)paren
(brace
multiline_comment|/* start a new cluseter */
id|cp_cnt
op_assign
id|cluster-&gt;cmpr_sz
suffix:semicolon
id|cluster-&gt;cmpr_sz
op_assign
l_int|0
suffix:semicolon
id|buf_pos
op_assign
id|cp_cnt
op_plus
r_sizeof
(paren
id|__u16
)paren
suffix:semicolon
id|PUT2
c_func
(paren
id|dst_buf
comma
l_int|0
comma
id|buf_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qic113
)paren
(brace
id|__s64
id|foffs
op_assign
id|pos-&gt;volume_pos
suffix:semicolon
r_if
c_cond
(paren
id|cp_cnt
)paren
id|foffs
op_add_assign
(paren
id|__s64
)paren
id|blk_sz
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;new style QIC-113 header&quot;
)paren
suffix:semicolon
id|PUT8
c_func
(paren
id|dst_buf
comma
id|buf_pos
comma
id|foffs
)paren
suffix:semicolon
id|buf_pos
op_add_assign
r_sizeof
(paren
id|__s64
)paren
suffix:semicolon
)brace
r_else
(brace
id|__u32
id|foffs
op_assign
(paren
id|__u32
)paren
id|pos-&gt;volume_pos
suffix:semicolon
r_if
c_cond
(paren
id|cp_cnt
)paren
id|foffs
op_add_assign
(paren
id|__u32
)paren
id|blk_sz
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;old style QIC-80MC header&quot;
)paren
suffix:semicolon
id|PUT4
c_func
(paren
id|dst_buf
comma
id|buf_pos
comma
id|foffs
)paren
suffix:semicolon
id|buf_pos
op_add_assign
r_sizeof
(paren
id|__u32
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|size_left
op_ge
l_int|0
)paren
(brace
id|cp_cnt
op_assign
id|cluster-&gt;cmpr_sz
suffix:semicolon
id|cluster-&gt;cmpr_sz
op_assign
l_int|0
suffix:semicolon
id|buf_pos
op_assign
id|cp_cnt
op_plus
r_sizeof
(paren
id|__u16
)paren
suffix:semicolon
id|PUT2
c_func
(paren
id|dst_buf
comma
l_int|0
comma
id|buf_pos
)paren
suffix:semicolon
multiline_comment|/* zero unused part of segment. */
id|memset
c_func
(paren
id|dst_buf
op_plus
id|buf_pos
comma
l_char|&squot;&bslash;0&squot;
comma
id|size_left
)paren
suffix:semicolon
id|buf_pos
op_assign
id|this_segs_sz
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* need entire segment and more space */
id|PUT2
c_func
(paren
id|dst_buf
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|cp_cnt
op_assign
id|this_segs_sz
op_minus
r_sizeof
(paren
id|__u16
)paren
suffix:semicolon
id|cluster-&gt;cmpr_sz
op_sub_assign
id|cp_cnt
suffix:semicolon
id|buf_pos
op_assign
id|this_segs_sz
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|dst_buf
op_plus
r_sizeof
(paren
id|__u16
)paren
comma
id|src_buf
op_plus
id|cluster-&gt;cmpr_pos
comma
id|cp_cnt
)paren
suffix:semicolon
id|cluster-&gt;cmpr_pos
op_add_assign
id|cp_cnt
suffix:semicolon
id|TRACE_EXIT
id|buf_pos
suffix:semicolon
)brace
multiline_comment|/* return-value: the number of bytes removed from the user-buffer&n; *               `src_buf&squot; or error code&n; *&n; *  int *write_cnt           : how much actually has been moved to the&n; *                             dst_buf. Need not be initialized when&n; *                             function returns with an error code&n; *                             (negativ return value) &n; *  __u8 *dst_buf            : kernel space buffer where the has to be&n; *                             copied to. The contents of this buffers&n; *                             goes to a specific segment.&n; *  const int seg_sz         : the size of the segment dst_buf will be&n; *                             copied to.&n; *  const zft_position *pos  : struct containing the coordinates in&n; *                             the current volume (byte position,&n; *                             segment id of current segment etc)&n; *  const zft_volinfo *volume: information about the current volume,&n; *                             size etc.&n; *  const __u8 *src_buf      : user space buffer that contains the&n; *                             data the user wants to be written to&n; *                             tape.&n; *  const int req_len        : the amount of data the user wants to be&n; *                             written to tape.&n; */
DECL|function|zftc_write
r_static
r_int
id|zftc_write
c_func
(paren
r_int
op_star
id|write_cnt
comma
id|__u8
op_star
id|dst_buf
comma
r_const
r_int
id|seg_sz
comma
r_const
id|__u8
op_star
id|src_buf
comma
r_const
r_int
id|req_len
comma
r_const
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
)paren
(brace
r_int
id|req_len_left
op_assign
id|req_len
suffix:semicolon
r_int
id|result
suffix:semicolon
r_int
id|len_left
suffix:semicolon
r_int
id|buf_pos_write
op_assign
id|pos-&gt;seg_byte_pos
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|keep_module_locked
op_assign
l_int|1
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,1,18)
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/*  sets MOD_VISITED and MOD_USED_ONCE,&n;&t;&t;&t;    *  locking is done with can_unload()&n;&t;&t;&t;    */
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|MOD_IN_USE
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Note: we do not unlock the module because&n;&t; * there are some values cached in that `cseg&squot; variable.  We&n;&t; * don&squot;t don&squot;t want to use this information when being&n;&t; * unloaded by kerneld even when the tape is full or when we&n;&t; * cannot allocate enough memory.&n;&t; */
r_if
c_cond
(paren
id|pos-&gt;tape_pos
OG
(paren
id|volume-&gt;size
op_minus
id|volume-&gt;blk_sz
op_minus
id|ZFT_CMPR_OVERHEAD
)paren
)paren
(brace
id|TRACE_EXIT
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_if
c_cond
(paren
id|zft_allocate_cmpr_mem
c_func
(paren
id|volume-&gt;blk_sz
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* should we unlock the module? But it shouldn&squot;t &n;&t;&t; * be locked anyway ...&n;&t;&t; */
id|TRACE_EXIT
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buf_pos_write
op_eq
l_int|0
)paren
(brace
multiline_comment|/* fill a new segment */
op_star
id|write_cnt
op_assign
id|buf_pos_write
op_assign
id|start_new_cseg
c_func
(paren
op_amp
id|cseg
comma
id|dst_buf
comma
id|pos
comma
id|volume-&gt;blk_sz
comma
id|zftc_buf
comma
id|seg_sz
comma
id|volume-&gt;qic113
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cseg.cmpr_sz
op_eq
l_int|0
op_logical_and
id|cseg.cmpr_pos
op_ne
l_int|0
)paren
(brace
id|req_len_left
op_sub_assign
id|result
op_assign
id|volume-&gt;blk_sz
suffix:semicolon
id|cseg.cmpr_pos
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|result
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|write_cnt
op_assign
id|result
op_assign
l_int|0
suffix:semicolon
)brace
id|len_left
op_assign
id|seg_sz
op_minus
id|buf_pos_write
suffix:semicolon
r_while
c_loop
(paren
(paren
id|req_len_left
OG
l_int|0
)paren
op_logical_and
(paren
id|len_left
OG
l_int|18
)paren
)paren
(brace
multiline_comment|/* now we have some size left for a new compressed&n;&t;&t; * block.  We know, that the compression buffer is&n;&t;&t; * empty (else there wouldn&squot;t be any space left).  &n;&t;&t; */
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VER(2,1,3)
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|zftc_scratch_buf
comma
id|src_buf
op_plus
id|result
comma
id|volume-&gt;blk_sz
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE_EXIT
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#else
id|TRACE_CATCH
c_func
(paren
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|src_buf
op_plus
id|result
comma
id|volume-&gt;blk_sz
)paren
comma
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|zftc_scratch_buf
comma
id|src_buf
op_plus
id|result
comma
id|volume-&gt;blk_sz
)paren
suffix:semicolon
macro_line|#endif
id|req_len_left
op_sub_assign
id|volume-&gt;blk_sz
suffix:semicolon
id|cseg.cmpr_sz
op_assign
id|zft_compress
c_func
(paren
id|zftc_scratch_buf
comma
id|volume-&gt;blk_sz
comma
id|zftc_buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cseg.cmpr_sz
OL
l_int|0
)paren
(brace
id|cseg.uncmpr
op_assign
l_int|0x8000
suffix:semicolon
id|cseg.cmpr_sz
op_assign
op_minus
id|cseg.cmpr_sz
suffix:semicolon
)brace
r_else
(brace
id|cseg.uncmpr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* increment &quot;result&quot; iff we copied the entire&n;&t;&t; * compressed block to the zft_deblock_buf &n;&t;&t; */
id|len_left
op_sub_assign
r_sizeof
(paren
id|__u16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len_left
op_ge
id|cseg.cmpr_sz
)paren
(brace
id|len_left
op_sub_assign
id|cseg.count
op_assign
id|cseg.cmpr_sz
suffix:semicolon
id|cseg.cmpr_pos
op_assign
id|cseg.cmpr_sz
op_assign
l_int|0
suffix:semicolon
id|result
op_add_assign
id|volume-&gt;blk_sz
suffix:semicolon
)brace
r_else
(brace
id|cseg.cmpr_sz
op_sub_assign
id|cseg.cmpr_pos
op_assign
id|cseg.count
op_assign
id|len_left
suffix:semicolon
id|len_left
op_assign
l_int|0
suffix:semicolon
)brace
id|PUT2
c_func
(paren
id|dst_buf
comma
id|buf_pos_write
comma
id|cseg.uncmpr
op_or
id|cseg.count
)paren
suffix:semicolon
id|buf_pos_write
op_add_assign
r_sizeof
(paren
id|__u16
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|dst_buf
op_plus
id|buf_pos_write
comma
id|zftc_buf
comma
id|cseg.count
)paren
suffix:semicolon
id|buf_pos_write
op_add_assign
id|cseg.count
suffix:semicolon
op_star
id|write_cnt
op_add_assign
id|cseg.count
op_plus
r_sizeof
(paren
id|__u16
)paren
suffix:semicolon
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
)brace
multiline_comment|/* erase the remainder of the segment if less than 18 bytes&n;&t; * left (18 bytes is due to the QIC-80 standard) &n;&t; */
r_if
c_cond
(paren
id|len_left
op_le
l_int|18
)paren
(brace
id|memset
c_func
(paren
id|dst_buf
op_plus
id|buf_pos_write
comma
l_char|&squot;&bslash;0&squot;
comma
id|len_left
)paren
suffix:semicolon
(paren
op_star
id|write_cnt
)paren
op_add_assign
id|len_left
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;returning %d&quot;
comma
id|result
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/* out:&n; *&n; * int *read_cnt: the number of bytes we removed from the zft_deblock_buf&n; *                (result)&n; * int *to_do   : the remaining size of the read-request.&n; *&n; * in:&n; *&n; * char *buff          : buff is the address of the upper part of the user&n; *                       buffer, that hasn&squot;t been filled with data yet.&n;&n; * int buf_pos_read    : copy of from _ftape_read()&n; * int buf_len_read    : copy of buf_len_rd from _ftape_read()&n; * char *zft_deblock_buf: zft_deblock_buf&n; * unsigned short blk_sz: the block size valid for this volume, may differ&n; *                            from zft_blk_sz.&n; * int finish: if != 0 means that this is the last segment belonging&n; *  to this volume&n; * returns the amount of data actually copied to the user-buffer&n; *&n; * to_do MUST NOT SHRINK except to indicate an EOF. In this case *to_do has to&n; * be set to 0 &n; */
DECL|function|zftc_read
r_static
r_int
id|zftc_read
(paren
r_int
op_star
id|read_cnt
comma
id|__u8
op_star
id|dst_buf
comma
r_const
r_int
id|to_do
comma
r_const
id|__u8
op_star
id|src_buf
comma
r_const
r_int
id|seg_sz
comma
r_const
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
)paren
(brace
r_int
id|uncompressed_sz
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|remaining
op_assign
id|to_do
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|keep_module_locked
op_assign
l_int|1
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,1,18)
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/*  sets MOD_VISITED and MOD_USED_ONCE,&n;&t;&t;&t;    *  locking is done with can_unload()&n;&t;&t;&t;    */
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|MOD_IN_USE
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
)brace
macro_line|#endif
id|TRACE_CATCH
c_func
(paren
id|zft_allocate_cmpr_mem
c_func
(paren
id|volume-&gt;blk_sz
)paren
comma
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pos-&gt;seg_byte_pos
op_eq
l_int|0
)paren
(brace
multiline_comment|/* new segment just read&n;&t;&t; */
id|TRACE_CATCH
c_func
(paren
id|get_cseg
c_func
(paren
op_amp
id|cseg
comma
id|src_buf
comma
id|seg_sz
comma
id|volume
)paren
comma
op_star
id|read_cnt
op_assign
l_int|0
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|zftc_buf
op_plus
id|cseg.cmpr_pos
comma
id|src_buf
op_plus
r_sizeof
(paren
id|__u16
)paren
comma
id|cseg.count
)paren
suffix:semicolon
id|cseg.cmpr_pos
op_add_assign
id|cseg.count
suffix:semicolon
op_star
id|read_cnt
op_assign
id|cseg.offset
suffix:semicolon
id|DUMP_CMPR_INFO
c_func
(paren
id|ft_t_noise
multiline_comment|/* ft_t_any */
comma
l_string|&quot;&quot;
comma
op_amp
id|cseg
)paren
suffix:semicolon
)brace
r_else
(brace
op_star
id|read_cnt
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* loop and uncompress until user buffer full or&n;&t; * deblock-buffer empty &n;&t; */
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;compressed_sz: %d, compos : %d, *read_cnt: %d&quot;
comma
id|cseg.cmpr_sz
comma
id|cseg.cmpr_pos
comma
op_star
id|read_cnt
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cseg.spans
op_eq
l_int|0
)paren
op_logical_and
(paren
id|remaining
OG
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|cseg.cmpr_pos
op_ne
l_int|0
)paren
(brace
multiline_comment|/* cmpr buf is not empty */
id|uncompressed_sz
op_assign
id|zft_uncompress
c_func
(paren
id|zftc_buf
comma
id|cseg.uncmpr
op_eq
l_int|0x8000
ques
c_cond
op_minus
id|cseg.cmpr_pos
suffix:colon
id|cseg.cmpr_pos
comma
id|zftc_scratch_buf
comma
id|volume-&gt;blk_sz
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uncompressed_sz
op_ne
id|volume-&gt;blk_sz
)paren
(brace
op_star
id|read_cnt
op_assign
l_int|0
suffix:semicolon
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_warn
comma
l_string|&quot;Uncompressed blk (%d) != blk size (%d)&quot;
comma
id|uncompressed_sz
comma
id|volume-&gt;blk_sz
)paren
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt; KERNEL_VER(2,1,3)
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|dst_buf
op_plus
id|result
comma
id|zftc_scratch_buf
comma
id|uncompressed_sz
)paren
op_ne
l_int|0
)paren
(brace
id|TRACE_EXIT
op_minus
id|EFAULT
suffix:semicolon
)brace
macro_line|#else
id|memcpy_tofs
c_func
(paren
id|dst_buf
op_plus
id|result
comma
id|zftc_scratch_buf
comma
id|uncompressed_sz
)paren
suffix:semicolon
macro_line|#endif
id|remaining
op_sub_assign
id|uncompressed_sz
suffix:semicolon
id|result
op_add_assign
id|uncompressed_sz
suffix:semicolon
id|cseg.cmpr_pos
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|remaining
OG
l_int|0
)paren
(brace
id|get_next_cluster
c_func
(paren
op_amp
id|cseg
comma
id|src_buf
comma
id|seg_sz
comma
id|volume-&gt;end_seg
op_eq
id|pos-&gt;seg_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cseg.count
op_ne
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
id|zftc_buf
comma
id|src_buf
op_plus
id|cseg.offset
comma
id|cseg.count
)paren
suffix:semicolon
id|cseg.cmpr_pos
op_assign
id|cseg.count
suffix:semicolon
id|cseg.offset
op_add_assign
id|cseg.count
suffix:semicolon
op_star
id|read_cnt
op_add_assign
id|cseg.count
op_plus
r_sizeof
(paren
id|__u16
)paren
suffix:semicolon
)brace
r_else
(brace
id|remaining
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;compressed_sz: %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;compos       : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;*read_cnt    : %d&quot;
comma
id|cseg.cmpr_sz
comma
id|cseg.cmpr_pos
comma
op_star
id|read_cnt
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|seg_sz
op_minus
id|cseg.offset
op_le
l_int|18
)paren
(brace
op_star
id|read_cnt
op_add_assign
id|seg_sz
op_minus
id|cseg.offset
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;expanding read cnt to: %d&quot;
comma
op_star
id|read_cnt
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;segment size   : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;read count     : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;buf_pos_read   : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;remaining      : %d&quot;
comma
id|seg_sz
comma
op_star
id|read_cnt
comma
id|pos-&gt;seg_byte_pos
comma
id|seg_sz
op_minus
op_star
id|read_cnt
op_minus
id|pos-&gt;seg_byte_pos
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_data_flow
comma
l_string|&quot;returning: %d&quot;
comma
id|result
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/* seeks to the new data-position. Reads sometimes a segment.&n; *  &n; * start_seg and end_seg give the boundaries of the current volume&n; * blk_sz is the blk_sz of the current volume as stored in the&n; * volume label&n; *&n; * We don&squot;t allow blocksizes less than 1024 bytes, therefore we don&squot;t need&n; * a 64 bit argument for new_block_pos.&n; */
r_static
r_int
id|seek_in_segment
c_func
(paren
r_const
r_int
r_int
id|to_do
comma
id|cmpr_info
op_star
id|c_info
comma
r_const
r_char
op_star
id|src_buf
comma
r_const
r_int
id|seg_sz
comma
r_const
r_int
id|seg_pos
comma
r_const
id|zft_volinfo
op_star
id|volume
)paren
suffix:semicolon
r_static
r_int
id|slow_seek_forward_until_error
c_func
(paren
r_const
r_int
r_int
id|distance
comma
id|cmpr_info
op_star
id|c_info
comma
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
comma
id|__u8
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|search_valid_segment
c_func
(paren
r_int
r_int
id|segment
comma
r_const
r_int
r_int
id|end_seg
comma
r_const
r_int
r_int
id|max_foffs
comma
id|zft_position
op_star
id|pos
comma
id|cmpr_info
op_star
id|c_info
comma
r_const
id|zft_volinfo
op_star
id|volume
comma
id|__u8
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|slow_seek_forward
c_func
(paren
r_int
r_int
id|dest
comma
id|cmpr_info
op_star
id|c_info
comma
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
comma
id|__u8
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|compute_seg_pos
c_func
(paren
r_int
r_int
id|dest
comma
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
)paren
suffix:semicolon
DECL|macro|ZFT_SLOW_SEEK_THRESHOLD
mdefine_line|#define ZFT_SLOW_SEEK_THRESHOLD  10 /* segments */
DECL|macro|ZFT_FAST_SEEK_MAX_TRIALS
mdefine_line|#define ZFT_FAST_SEEK_MAX_TRIALS 10 /* times */
DECL|macro|ZFT_FAST_SEEK_BACKUP
mdefine_line|#define ZFT_FAST_SEEK_BACKUP     10 /* segments */
DECL|function|zftc_seek
r_static
r_int
id|zftc_seek
c_func
(paren
r_int
r_int
id|new_block_pos
comma
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
comma
id|__u8
op_star
id|buf
)paren
(brace
r_int
r_int
id|dest
suffix:semicolon
r_int
id|limit
suffix:semicolon
r_int
id|distance
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|seg_dist
suffix:semicolon
r_int
id|new_seg
suffix:semicolon
r_int
id|old_seg
op_assign
l_int|0
suffix:semicolon
r_int
id|fast_seek_trials
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|keep_module_locked
op_assign
l_int|1
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,1,18)
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/*  sets MOD_VISITED and MOD_USED_ONCE,&n;&t;&t;&t;    *  locking is done with can_unload()&n;&t;&t;&t;    */
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|MOD_IN_USE
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|new_block_pos
op_eq
l_int|0
)paren
(brace
id|pos-&gt;seg_pos
op_assign
id|volume-&gt;start_seg
suffix:semicolon
id|pos-&gt;seg_byte_pos
op_assign
l_int|0
suffix:semicolon
id|pos-&gt;volume_pos
op_assign
l_int|0
suffix:semicolon
id|zftc_reset
c_func
(paren
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
id|dest
op_assign
id|new_block_pos
op_star
(paren
id|volume-&gt;blk_sz
op_rshift
l_int|10
)paren
suffix:semicolon
id|distance
op_assign
id|dest
op_minus
(paren
id|pos-&gt;volume_pos
op_rshift
l_int|10
)paren
suffix:semicolon
r_while
c_loop
(paren
id|distance
op_ne
l_int|0
)paren
(brace
id|seg_dist
op_assign
id|compute_seg_pos
c_func
(paren
id|dest
comma
id|pos
comma
id|volume
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;seg_dist: %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;distance: %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;dest    : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;vpos    : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;seg_pos : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;trials  : %d&quot;
comma
id|seg_dist
comma
id|distance
comma
id|dest
comma
(paren
r_int
r_int
)paren
(paren
id|pos-&gt;volume_pos
op_rshift
l_int|10
)paren
comma
id|pos-&gt;seg_pos
comma
id|fast_seek_trials
)paren
suffix:semicolon
r_if
c_cond
(paren
id|distance
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|seg_dist
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;BUG: distance %d &gt; 0, &quot;
l_string|&quot;segment difference %d &lt; 0&quot;
comma
id|distance
comma
id|seg_dist
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
id|new_seg
op_assign
id|pos-&gt;seg_pos
op_plus
id|seg_dist
suffix:semicolon
r_if
c_cond
(paren
id|new_seg
OG
id|volume-&gt;end_seg
)paren
(brace
id|new_seg
op_assign
id|volume-&gt;end_seg
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old_seg
op_eq
id|new_seg
op_logical_or
multiline_comment|/* loop */
id|seg_dist
op_le
id|ZFT_SLOW_SEEK_THRESHOLD
op_logical_or
id|fast_seek_trials
op_ge
id|ZFT_FAST_SEEK_MAX_TRIALS
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;starting slow seek:&bslash;n&quot;
id|KERN_INFO
l_string|&quot;fast seek failed too often: %s&bslash;n&quot;
id|KERN_INFO
l_string|&quot;near target position      : %s&bslash;n&quot;
id|KERN_INFO
l_string|&quot;looping between two segs  : %s&quot;
comma
(paren
id|fast_seek_trials
op_ge
id|ZFT_FAST_SEEK_MAX_TRIALS
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
(paren
id|seg_dist
op_le
id|ZFT_SLOW_SEEK_THRESHOLD
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
(paren
id|old_seg
op_eq
id|new_seg
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
id|result
op_assign
id|slow_seek_forward
c_func
(paren
id|dest
comma
op_amp
id|cseg
comma
id|pos
comma
id|volume
comma
id|buf
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|old_seg
op_assign
id|new_seg
suffix:semicolon
id|limit
op_assign
id|volume-&gt;end_seg
suffix:semicolon
id|fast_seek_trials
op_increment
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|result
op_assign
id|search_valid_segment
c_func
(paren
id|new_seg
comma
id|limit
comma
id|volume-&gt;size
comma
id|pos
comma
op_amp
id|cseg
comma
id|volume
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_or
id|result
op_eq
op_minus
id|EINTR
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_seg
op_eq
id|volume-&gt;start_seg
)paren
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* set errror &n;&t;&t;&t;&t;&t;&t;&t;* condition&n;&t;&t;&t;&t;&t;&t;&t;*/
r_break
suffix:semicolon
)brace
id|limit
op_assign
id|new_seg
suffix:semicolon
id|new_seg
op_sub_assign
id|ZFT_FAST_SEEK_BACKUP
suffix:semicolon
r_if
c_cond
(paren
id|new_seg
OL
id|volume-&gt;start_seg
)paren
(brace
id|new_seg
op_assign
id|volume-&gt;start_seg
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Couldn&squot;t find a readable segment&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* if (distance &lt; 0) */
(brace
r_if
c_cond
(paren
id|seg_dist
OG
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_bug
comma
l_string|&quot;BUG: distance %d &lt; 0, &quot;
l_string|&quot;segment difference %d &gt;0&quot;
comma
id|distance
comma
id|seg_dist
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
id|new_seg
op_assign
id|pos-&gt;seg_pos
op_plus
id|seg_dist
suffix:semicolon
r_if
c_cond
(paren
id|fast_seek_trials
OG
l_int|0
op_logical_and
id|seg_dist
op_eq
l_int|0
)paren
(brace
multiline_comment|/* this avoids sticking to the same&n;&t;&t;&t;&t; * segment all the time. On the other hand:&n;&t;&t;&t;&t; * if we got here for the first time, and the&n;&t;&t;&t;&t; * deblock_buffer still contains a valid&n;&t;&t;&t;&t; * segment, then there is no need to skip to &n;&t;&t;&t;&t; * the previous segment if the desired position&n;&t;&t;&t;&t; * is inside this segment.&n;&t;&t;&t;&t; */
id|new_seg
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_seg
OL
id|volume-&gt;start_seg
)paren
(brace
id|new_seg
op_assign
id|volume-&gt;start_seg
suffix:semicolon
)brace
id|limit
op_assign
id|pos-&gt;seg_pos
suffix:semicolon
id|fast_seek_trials
op_increment
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|result
op_assign
id|search_valid_segment
c_func
(paren
id|new_seg
comma
id|limit
comma
id|pos-&gt;volume_pos
comma
id|pos
comma
op_amp
id|cseg
comma
id|volume
comma
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
op_logical_or
id|result
op_eq
op_minus
id|EINTR
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|new_seg
op_eq
id|volume-&gt;start_seg
)paren
(brace
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* set errror &n;&t;&t;&t;&t;&t;&t;&t;* condition&n;&t;&t;&t;&t;&t;&t;&t;*/
r_break
suffix:semicolon
)brace
id|limit
op_assign
id|new_seg
suffix:semicolon
id|new_seg
op_sub_assign
id|ZFT_FAST_SEEK_BACKUP
suffix:semicolon
r_if
c_cond
(paren
id|new_seg
OL
id|volume-&gt;start_seg
)paren
(brace
id|new_seg
op_assign
id|volume-&gt;start_seg
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|result
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_warn
comma
l_string|&quot;Couldn&squot;t find a readable segment&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|distance
op_assign
id|dest
op_minus
(paren
id|pos-&gt;volume_pos
op_rshift
l_int|10
)paren
suffix:semicolon
)brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
multiline_comment|/*  advance inside the given segment at most to_do bytes.&n; *  of kilobytes moved&n; */
DECL|function|seek_in_segment
r_static
r_int
id|seek_in_segment
c_func
(paren
r_const
r_int
r_int
id|to_do
comma
id|cmpr_info
op_star
id|c_info
comma
r_const
r_char
op_star
id|src_buf
comma
r_const
r_int
id|seg_sz
comma
r_const
r_int
id|seg_pos
comma
r_const
id|zft_volinfo
op_star
id|volume
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
id|blk_sz
op_assign
id|volume-&gt;blk_sz
op_rshift
l_int|10
suffix:semicolon
r_int
id|remaining
op_assign
id|to_do
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c_info-&gt;offset
op_eq
l_int|0
)paren
(brace
multiline_comment|/* new segment just read&n;&t;&t; */
id|TRACE_CATCH
c_func
(paren
id|get_cseg
c_func
(paren
id|c_info
comma
id|src_buf
comma
id|seg_sz
comma
id|volume
)paren
comma
)paren
suffix:semicolon
id|c_info-&gt;cmpr_pos
op_add_assign
id|c_info-&gt;count
suffix:semicolon
id|DUMP_CMPR_INFO
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;&quot;
comma
id|c_info
)paren
suffix:semicolon
)brace
multiline_comment|/* loop and uncompress until user buffer full or&n;&t; * deblock-buffer empty &n;&t; */
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;compressed_sz: %d, compos : %d&quot;
comma
id|c_info-&gt;cmpr_sz
comma
id|c_info-&gt;cmpr_pos
)paren
suffix:semicolon
r_while
c_loop
(paren
id|c_info-&gt;spans
op_eq
l_int|0
op_logical_and
id|remaining
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|c_info-&gt;cmpr_pos
op_ne
l_int|0
)paren
(brace
multiline_comment|/* cmpr buf is not empty */
id|result
op_add_assign
id|blk_sz
suffix:semicolon
id|remaining
op_sub_assign
id|blk_sz
suffix:semicolon
id|c_info-&gt;cmpr_pos
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|remaining
OG
l_int|0
)paren
(brace
id|get_next_cluster
c_func
(paren
id|c_info
comma
id|src_buf
comma
id|seg_sz
comma
id|volume-&gt;end_seg
op_eq
id|seg_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c_info-&gt;count
op_ne
l_int|0
)paren
(brace
id|c_info-&gt;cmpr_pos
op_assign
id|c_info-&gt;count
suffix:semicolon
id|c_info-&gt;offset
op_add_assign
id|c_info-&gt;count
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*  Allow escape from this loop on signal!&n;&t;&t; */
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
id|DUMP_CMPR_INFO
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;&quot;
comma
id|c_info
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;to_do: %d&quot;
comma
id|remaining
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|seg_sz
op_minus
id|c_info-&gt;offset
op_le
l_int|18
)paren
(brace
id|c_info-&gt;offset
op_assign
id|seg_sz
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;segment size   : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;buf_pos_read   : %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;remaining      : %d&quot;
comma
id|seg_sz
comma
id|c_info-&gt;offset
comma
id|seg_sz
op_minus
id|c_info-&gt;offset
)paren
suffix:semicolon
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|slow_seek_forward_until_error
r_static
r_int
id|slow_seek_forward_until_error
c_func
(paren
r_const
r_int
r_int
id|distance
comma
id|cmpr_info
op_star
id|c_info
comma
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
comma
id|__u8
op_star
id|buf
)paren
(brace
r_int
r_int
id|remaining
op_assign
id|distance
suffix:semicolon
r_int
id|seg_sz
suffix:semicolon
r_int
id|seg_pos
suffix:semicolon
r_int
id|result
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|seg_pos
op_assign
id|pos-&gt;seg_pos
suffix:semicolon
r_do
(brace
id|TRACE_CATCH
c_func
(paren
id|seg_sz
op_assign
id|zft_fetch_segment
c_func
(paren
id|seg_pos
comma
id|buf
comma
id|FT_RD_AHEAD
)paren
comma
)paren
suffix:semicolon
multiline_comment|/* now we have the contents of the actual segment in&n;&t;&t; * the deblock buffer&n;&t;&t; */
id|TRACE_CATCH
c_func
(paren
id|result
op_assign
id|seek_in_segment
c_func
(paren
id|remaining
comma
id|c_info
comma
id|buf
comma
id|seg_sz
comma
id|seg_pos
comma
id|volume
)paren
comma
)paren
suffix:semicolon
id|remaining
op_sub_assign
id|result
suffix:semicolon
id|pos-&gt;volume_pos
op_add_assign
id|result
op_lshift
l_int|10
suffix:semicolon
id|pos-&gt;seg_pos
op_assign
id|seg_pos
suffix:semicolon
id|pos-&gt;seg_byte_pos
op_assign
id|c_info-&gt;offset
suffix:semicolon
id|seg_pos
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|seg_pos
op_le
id|volume-&gt;end_seg
op_logical_and
id|c_info-&gt;offset
op_eq
id|seg_sz
)paren
(brace
id|pos-&gt;seg_pos
op_increment
suffix:semicolon
id|pos-&gt;seg_byte_pos
op_assign
l_int|0
suffix:semicolon
id|c_info-&gt;offset
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*  Allow escape from this loop on signal!&n;&t;&t; */
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;remaining:  %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;seg_pos:    %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;end_seg:    %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;result:     %d&quot;
comma
id|remaining
comma
id|seg_pos
comma
id|volume-&gt;end_seg
comma
id|result
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|remaining
OG
l_int|0
op_logical_and
id|seg_pos
op_le
id|volume-&gt;end_seg
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
multiline_comment|/* return segment id of next segment containing valid data, -EIO otherwise&n; */
DECL|function|search_valid_segment
r_static
r_int
id|search_valid_segment
c_func
(paren
r_int
r_int
id|segment
comma
r_const
r_int
r_int
id|end_seg
comma
r_const
r_int
r_int
id|max_foffs
comma
id|zft_position
op_star
id|pos
comma
id|cmpr_info
op_star
id|c_info
comma
r_const
id|zft_volinfo
op_star
id|volume
comma
id|__u8
op_star
id|buf
)paren
(brace
id|cmpr_info
id|tmp_info
suffix:semicolon
r_int
id|seg_sz
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tmp_info
comma
l_int|0
comma
r_sizeof
(paren
id|cmpr_info
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|segment
op_le
id|end_seg
)paren
(brace
id|FT_SIGNAL_EXIT
c_func
(paren
id|_DONT_BLOCK
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;Searching readable segment between %d and %d&quot;
comma
id|segment
comma
id|end_seg
)paren
suffix:semicolon
id|seg_sz
op_assign
id|zft_fetch_segment
c_func
(paren
id|segment
comma
id|buf
comma
id|FT_RD_AHEAD
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|seg_sz
OG
l_int|0
)paren
op_logical_and
(paren
id|get_cseg
(paren
op_amp
id|tmp_info
comma
id|buf
comma
id|seg_sz
comma
id|volume
)paren
op_ge
l_int|0
)paren
op_logical_and
(paren
id|tmp_info.foffs
op_ne
l_int|0
op_logical_or
id|segment
op_eq
id|volume-&gt;start_seg
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|tmp_info.foffs
op_rshift
l_int|10
)paren
OG
id|max_foffs
)paren
(brace
id|TRACE_ABORT
c_func
(paren
op_minus
id|EIO
comma
id|ft_t_noise
comma
l_string|&quot;&bslash;n&quot;
id|KERN_INFO
l_string|&quot;cseg.foff: %d&bslash;n&quot;
id|KERN_INFO
l_string|&quot;dest     : %d&quot;
comma
(paren
r_int
)paren
(paren
id|tmp_info.foffs
op_rshift
l_int|10
)paren
comma
id|max_foffs
)paren
suffix:semicolon
)brace
id|DUMP_CMPR_INFO
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;&quot;
comma
op_amp
id|tmp_info
)paren
suffix:semicolon
op_star
id|c_info
op_assign
id|tmp_info
suffix:semicolon
id|pos-&gt;seg_pos
op_assign
id|segment
suffix:semicolon
id|pos-&gt;volume_pos
op_assign
id|c_info-&gt;foffs
suffix:semicolon
id|pos-&gt;seg_byte_pos
op_assign
id|c_info-&gt;offset
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;found segment at %d&quot;
comma
id|segment
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
id|segment
op_increment
suffix:semicolon
)brace
id|TRACE_EXIT
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|slow_seek_forward
r_static
r_int
id|slow_seek_forward
c_func
(paren
r_int
r_int
id|dest
comma
id|cmpr_info
op_star
id|c_info
comma
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
comma
id|__u8
op_star
id|buf
)paren
(brace
r_int
r_int
id|distance
suffix:semicolon
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
id|distance
op_assign
id|dest
op_minus
(paren
id|pos-&gt;volume_pos
op_rshift
l_int|10
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|distance
OG
l_int|0
)paren
op_logical_and
(paren
id|result
op_assign
id|slow_seek_forward_until_error
c_func
(paren
id|distance
comma
id|c_info
comma
id|pos
comma
id|volume
comma
id|buf
)paren
)paren
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|result
op_eq
op_minus
id|EINTR
)paren
(brace
r_break
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;seg_pos: %d&quot;
comma
id|pos-&gt;seg_pos
)paren
suffix:semicolon
multiline_comment|/* the failing segment is either pos-&gt;seg_pos or&n;&t;&t; * pos-&gt;seg_pos + 1. There is no need to further try&n;&t;&t; * that segment, because ftape_read_segment() already&n;&t;&t; * has tried very much to read it. So we start with&n;&t;&t; * following segment, which is pos-&gt;seg_pos + 1&n;&t;&t; */
r_if
c_cond
(paren
id|search_valid_segment
c_func
(paren
id|pos-&gt;seg_pos
op_plus
l_int|1
comma
id|volume-&gt;end_seg
comma
id|dest
comma
id|pos
comma
id|c_info
comma
id|volume
comma
id|buf
)paren
OL
l_int|0
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;search_valid_segment() failed&quot;
)paren
suffix:semicolon
id|result
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
id|distance
op_assign
id|dest
op_minus
(paren
id|pos-&gt;volume_pos
op_rshift
l_int|10
)paren
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;segment: %d&quot;
comma
id|pos-&gt;seg_pos
)paren
suffix:semicolon
multiline_comment|/* found valid segment, retry the seek */
)brace
id|TRACE_EXIT
id|result
suffix:semicolon
)brace
DECL|function|compute_seg_pos
r_static
r_int
id|compute_seg_pos
c_func
(paren
r_const
r_int
r_int
id|dest
comma
id|zft_position
op_star
id|pos
comma
r_const
id|zft_volinfo
op_star
id|volume
)paren
(brace
r_int
id|segment
suffix:semicolon
r_int
id|distance
op_assign
id|dest
op_minus
(paren
id|pos-&gt;volume_pos
op_rshift
l_int|10
)paren
suffix:semicolon
r_int
r_int
id|raw_size
suffix:semicolon
r_int
r_int
id|virt_size
suffix:semicolon
r_int
r_int
id|factor
suffix:semicolon
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|distance
op_ge
l_int|0
)paren
(brace
id|raw_size
op_assign
id|volume-&gt;end_seg
op_minus
id|pos-&gt;seg_pos
op_plus
l_int|1
suffix:semicolon
id|virt_size
op_assign
(paren
(paren
r_int
r_int
)paren
(paren
id|volume-&gt;size
op_rshift
l_int|10
)paren
op_minus
(paren
r_int
r_int
)paren
(paren
id|pos-&gt;volume_pos
op_rshift
l_int|10
)paren
op_plus
id|FT_SECTORS_PER_SEGMENT
op_minus
id|FT_ECC_SECTORS
op_minus
l_int|1
)paren
suffix:semicolon
id|virt_size
op_div_assign
id|FT_SECTORS_PER_SEGMENT
op_minus
id|FT_ECC_SECTORS
suffix:semicolon
r_if
c_cond
(paren
id|virt_size
op_eq
l_int|0
op_logical_or
id|raw_size
op_eq
l_int|0
)paren
(brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raw_size
op_ge
(paren
l_int|1
op_lshift
l_int|25
)paren
)paren
(brace
id|factor
op_assign
id|raw_size
op_div
(paren
id|virt_size
op_rshift
l_int|7
)paren
suffix:semicolon
)brace
r_else
(brace
id|factor
op_assign
(paren
id|raw_size
op_lshift
l_int|7
)paren
op_div
id|virt_size
suffix:semicolon
)brace
id|segment
op_assign
id|distance
op_div
(paren
id|FT_SECTORS_PER_SEGMENT
op_minus
id|FT_ECC_SECTORS
)paren
suffix:semicolon
id|segment
op_assign
(paren
id|segment
op_star
id|factor
)paren
op_rshift
l_int|7
suffix:semicolon
)brace
r_else
(brace
id|raw_size
op_assign
id|pos-&gt;seg_pos
op_minus
id|volume-&gt;start_seg
op_plus
l_int|1
suffix:semicolon
id|virt_size
op_assign
(paren
(paren
r_int
r_int
)paren
(paren
id|pos-&gt;volume_pos
op_rshift
l_int|10
)paren
op_plus
id|FT_SECTORS_PER_SEGMENT
op_minus
id|FT_ECC_SECTORS
op_minus
l_int|1
)paren
suffix:semicolon
id|virt_size
op_div_assign
id|FT_SECTORS_PER_SEGMENT
op_minus
id|FT_ECC_SECTORS
suffix:semicolon
r_if
c_cond
(paren
id|virt_size
op_eq
l_int|0
op_logical_or
id|raw_size
op_eq
l_int|0
)paren
(brace
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raw_size
op_ge
(paren
l_int|1
op_lshift
l_int|25
)paren
)paren
(brace
id|factor
op_assign
id|raw_size
op_div
(paren
id|virt_size
op_rshift
l_int|7
)paren
suffix:semicolon
)brace
r_else
(brace
id|factor
op_assign
(paren
id|raw_size
op_lshift
l_int|7
)paren
op_div
id|virt_size
suffix:semicolon
)brace
id|segment
op_assign
id|distance
op_div
(paren
id|FT_SECTORS_PER_SEGMENT
op_minus
id|FT_ECC_SECTORS
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
id|ft_t_noise
comma
l_string|&quot;factor: %d/%d&quot;
comma
id|factor
comma
l_int|1
op_lshift
l_int|7
)paren
suffix:semicolon
id|TRACE_EXIT
id|segment
suffix:semicolon
)brace
DECL|variable|cmpr_ops
r_static
r_struct
id|zft_cmpr_ops
id|cmpr_ops
op_assign
(brace
id|zftc_write
comma
id|zftc_read
comma
id|zftc_seek
comma
id|zftc_lock
comma
id|zftc_reset
comma
id|zftc_cleanup
)brace
suffix:semicolon
DECL|function|zft_compressor_init
r_int
id|zft_compressor_init
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
macro_line|#ifdef MODULE
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;zftape compressor v1.00a 970514 for &quot;
id|FTAPE_VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TRACE_LEVEL
op_ge
id|ft_t_info
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;(c) 1997 Claus-Justus Heine (claus@momo.math.rwth-aachen.de)&bslash;n&quot;
id|KERN_INFO
l_string|&quot;Compressor for zftape (lzrw3 algorithm)&bslash;n&quot;
id|KERN_INFO
l_string|&quot;Compiled for kernel version %s&quot;
macro_line|#ifdef MODVERSIONS
l_string|&quot; with versioned symbols&quot;
macro_line|#endif
l_string|&quot;&bslash;n&quot;
comma
id|UTS_RELEASE
)paren
suffix:semicolon
)brace
macro_line|#else /* !MODULE */
multiline_comment|/* print a short no-nonsense boot message */
id|printk
c_func
(paren
l_string|&quot;zftape compressor v1.00a 970514 for Linux &quot;
id|UTS_RELEASE
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;For use with &quot;
id|FTAPE_VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* MODULE */
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;zft_compressor_init @ 0x%p&quot;
comma
id|zft_compressor_init
)paren
suffix:semicolon
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;installing compressor for zftape ...&quot;
)paren
suffix:semicolon
id|TRACE_CATCH
c_func
(paren
id|zft_cmpr_register
c_func
(paren
op_amp
id|cmpr_ops
)paren
comma
)paren
suffix:semicolon
id|TRACE_EXIT
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,1,18)
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;(c) 1996, 1997 Claus-Justus Heine (claus@momo.math.rwth-aachen.de&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Compression routines for zftape. Uses the lzrw3 algorithm by Ross Williams&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VER(2,1,18)
DECL|function|can_unload
r_static
r_int
id|can_unload
c_func
(paren
r_void
)paren
(brace
r_return
id|keep_module_locked
ques
c_cond
op_minus
id|EBUSY
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Called by modules package when installing the driver&n; */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|result
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; KERNEL_VER(2,1,18)
id|register_symtab
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* remove global ftape symbols */
macro_line|#else
r_if
c_cond
(paren
op_logical_neg
id|mod_member_present
c_func
(paren
op_amp
id|__this_module
comma
id|can_unload
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|__this_module.can_unload
op_assign
id|can_unload
suffix:semicolon
id|EXPORT_NO_SYMBOLS
suffix:semicolon
macro_line|#endif
id|result
op_assign
id|zft_compressor_init
c_func
(paren
)paren
suffix:semicolon
id|keep_module_locked
op_assign
l_int|0
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* Called by modules package when removing the driver &n; */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|TRACE_FUN
c_func
(paren
id|ft_t_flow
)paren
suffix:semicolon
r_if
c_cond
(paren
id|zft_cmpr_unregister
c_func
(paren
)paren
op_ne
op_amp
id|cmpr_ops
)paren
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;failed&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|TRACE
c_func
(paren
id|ft_t_info
comma
l_string|&quot;successful&quot;
)paren
suffix:semicolon
)brace
id|zftc_cleanup
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;zft-compressor successfully unloaded.&bslash;n&quot;
)paren
suffix:semicolon
id|TRACE_EXIT
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
