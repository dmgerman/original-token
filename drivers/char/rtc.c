multiline_comment|/*&n; *&t;Real Time Clock interface for Linux&t;&n; *&n; *&t;Copyright (C) 1996 Paul Gortmaker&n; *&n; *&t;This driver allows use of the real time clock (built into&n; *&t;nearly all computers) from user space. It exports the /dev/rtc&n; *&t;interface supporting various ioctl() and also the&n; *&t;/proc/driver/rtc pseudo-file for status information.&n; *&n; *&t;The ioctls can be used to set the interrupt behaviour and&n; *&t;generation rate from the RTC via IRQ 8. Then the /dev/rtc&n; *&t;interface can be used to make use of these timer interrupts,&n; *&t;be they interval or alarm based.&n; *&n; *&t;The /dev/rtc interface will block on reads until an interrupt&n; *&t;has been received. If a RTC interrupt has already happened,&n; *&t;it will output an unsigned long and then block. The output value&n; *&t;contains the interrupt status in the low byte and the number of&n; *&t;interrupts since the last read in the remaining high bytes. The &n; *&t;/dev/rtc interface can also be used with the select(2) call.&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;Based on other minimal char device drivers, like Alan&squot;s&n; *&t;watchdog, Ted&squot;s random, etc. etc.&n; *&n; *&t;1.07&t;Paul Gortmaker.&n; *&t;1.08&t;Miquel van Smoorenburg: disallow certain things on the&n; *&t;&t;DEC Alpha as the CMOS clock is also used for other things.&n; *&t;1.09&t;Nikita Schmidt: epoch support and some Alpha cleanup.&n; *&t;1.09a&t;Pete Zaitcev: Sun SPARC&n; *&t;1.09b&t;Jeff Garzik: Modularize, init cleanup&n; *&t;1.09c&t;Jeff Garzik: SMP cleanup&n; *&t;1.10    Paul Barton-Davis: add support for async I/O&n; *&t;1.10a&t;Andrea Arcangeli: Alpha updates&n; *&t;1.10b&t;Andrew Morton: SMP lock fix&n; *&t;1.10c&t;Cesar Barros: SMP locking fixes and cleanup&n; *&t;1.10d&t;Paul Gortmaker: delete paranoia check in rtc_exit&n; */
DECL|macro|RTC_VERSION
mdefine_line|#define RTC_VERSION&t;&t;&quot;1.10d&quot;
DECL|macro|RTC_IO_EXTENT
mdefine_line|#define RTC_IO_EXTENT&t;0x10&t;/* Only really two ports, but...&t;*/
multiline_comment|/*&n; *&t;Note that *all* calls to CMOS_READ and CMOS_WRITE are done with&n; *&t;interrupts disabled. Due to the index-port/data-port (0x70/0x71)&n; *&t;design of the RTC, we don&squot;t want two different things trying to&n; *&t;get to it at once. (e.g. the periodic 11 min sync from time.c vs.&n; *&t;this driver.)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/mc146818rtc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#ifdef __sparc__
macro_line|#include &lt;asm/ebus.h&gt;
DECL|variable|rtc_port
r_static
r_int
r_int
id|rtc_port
suffix:semicolon
DECL|variable|rtc_irq
r_static
r_int
id|rtc_irq
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;We sponge a minor off of the misc major. No need slurping&n; *&t;up another valuable major dev number for this. If you add&n; *&t;an ioctl, make sure you don&squot;t conflict with SPARC&squot;s RTC&n; *&t;ioctls.&n; */
DECL|variable|rtc_async_queue
r_static
r_struct
id|fasync_struct
op_star
id|rtc_async_queue
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|rtc_wait
)paren
suffix:semicolon
DECL|variable|rtc_irq_timer
r_static
r_struct
id|timer_list
id|rtc_irq_timer
suffix:semicolon
r_static
id|loff_t
id|rtc_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
suffix:semicolon
r_static
id|ssize_t
id|rtc_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
r_int
id|rtc_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
macro_line|#if RTC_IRQ
r_static
r_int
r_int
id|rtc_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|get_rtc_time
(paren
r_struct
id|rtc_time
op_star
id|rtc_tm
)paren
suffix:semicolon
r_static
r_void
id|get_rtc_alm_time
(paren
r_struct
id|rtc_time
op_star
id|alm_tm
)paren
suffix:semicolon
macro_line|#if RTC_IRQ
r_static
r_void
id|rtc_dropped_irq
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|set_rtc_irq_bit
c_func
(paren
r_int
r_char
id|bit
)paren
suffix:semicolon
r_static
r_void
id|mask_rtc_irq_bit
c_func
(paren
r_int
r_char
id|bit
)paren
suffix:semicolon
macro_line|#endif
r_static
r_inline
r_int
r_char
id|rtc_is_updating
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|rtc_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Bits in rtc_status. (6 bits of room for future expansion)&n; */
DECL|macro|RTC_IS_OPEN
mdefine_line|#define RTC_IS_OPEN&t;&t;0x01&t;/* means /dev/rtc is in use&t;*/
DECL|macro|RTC_TIMER_ON
mdefine_line|#define RTC_TIMER_ON&t;&t;0x02&t;/* missed irq timer active&t;*/
multiline_comment|/*&n; * rtc_status is never changed by rtc_interrupt, and ioctl/open/close is&n; * protected by the big kernel lock. However, ioctl can still disable the timer&n; * in rtc_status and then with del_timer after the interrupt has read&n; * rtc_status but before mod_timer is called, which would then reenable the&n; * timer (but you would need to have an awful timing before you&squot;d trip on it)&n; */
DECL|variable|rtc_status
r_static
r_int
r_int
id|rtc_status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bitmapped status byte.&t;*/
DECL|variable|rtc_freq
r_static
r_int
r_int
id|rtc_freq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Current periodic IRQ rate&t;*/
DECL|variable|rtc_irq_data
r_static
r_int
r_int
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* our output to the world&t;*/
multiline_comment|/*&n; *&t;If this driver ever becomes modularised, it will be really nice&n; *&t;to make the epoch retain its value across module reload...&n; */
DECL|variable|epoch
r_static
r_int
r_int
id|epoch
op_assign
l_int|1900
suffix:semicolon
multiline_comment|/* year corresponding to 0x00&t;*/
DECL|variable|days_in_mo
r_static
r_const
r_int
r_char
id|days_in_mo
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|31
comma
l_int|28
comma
l_int|31
comma
l_int|30
comma
l_int|31
comma
l_int|30
comma
l_int|31
comma
l_int|31
comma
l_int|30
comma
l_int|31
comma
l_int|30
comma
l_int|31
)brace
suffix:semicolon
macro_line|#if RTC_IRQ
multiline_comment|/*&n; *&t;A very tiny interrupt handler. It runs with SA_INTERRUPT set,&n; *&t;but there is possibility of conflicting with the set_rtc_mmss()&n; *&t;call (the rtc irq and the timer irq can easily run at the same&n; *&t;time in two different CPUs). So we need to serializes&n; *&t;accesses to the chip with the rtc_lock spinlock that each&n; *&t;architecture should implement in the timer code.&n; *&t;(See ./arch/XXXX/kernel/time.c for the set_rtc_mmss() function.)&n; */
DECL|function|rtc_interrupt
r_static
r_void
id|rtc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/*&n;&t; *&t;Can be an alarm interrupt, update complete interrupt,&n;&t; *&t;or a periodic interrupt. We store the status in the&n;&t; *&t;low byte and the number of interrupts received since&n;&t; *&t;the last read in the remainder of rtc_irq_data.&n;&t; */
id|spin_lock
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|rtc_irq_data
op_add_assign
l_int|0x100
suffix:semicolon
id|rtc_irq_data
op_and_assign
op_complement
l_int|0xff
suffix:semicolon
id|rtc_irq_data
op_or_assign
(paren
id|CMOS_READ
c_func
(paren
id|RTC_INTR_FLAGS
)paren
op_amp
l_int|0xF0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtc_status
op_amp
id|RTC_TIMER_ON
)paren
id|mod_timer
c_func
(paren
op_amp
id|rtc_irq_timer
comma
id|jiffies
op_plus
id|HZ
op_div
id|rtc_freq
op_plus
l_int|2
op_star
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
multiline_comment|/* Now do the rest of the actions */
id|wake_up_interruptible
c_func
(paren
op_amp
id|rtc_wait
)paren
suffix:semicolon
id|kill_fasync
(paren
op_amp
id|rtc_async_queue
comma
id|SIGIO
comma
id|POLL_IN
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *&t;Now all the various file operations that we export.&n; */
DECL|function|rtc_llseek
r_static
id|loff_t
id|rtc_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
DECL|function|rtc_read
r_static
id|ssize_t
id|rtc_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
macro_line|#if !RTC_IRQ
r_return
op_minus
id|EIO
suffix:semicolon
macro_line|#else
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
id|ssize_t
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
r_sizeof
(paren
r_int
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|rtc_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_do
(brace
multiline_comment|/* First make it right. Then make it fast. Putting this whole&n;&t;&t; * block within the parentheses of a while would be too&n;&t;&t; * confusing. And no, xchg() is not the answer. */
id|spin_lock_irq
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|data
op_assign
id|rtc_irq_data
suffix:semicolon
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_ne
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
id|retval
op_assign
id|put_user
c_func
(paren
id|data
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
id|out
suffix:colon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|rtc_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
macro_line|#endif
)brace
DECL|function|rtc_ioctl
r_static
r_int
id|rtc_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|rtc_time
id|wtime
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
macro_line|#if RTC_IRQ
r_case
id|RTC_AIE_OFF
suffix:colon
multiline_comment|/* Mask alarm int. enab. bit&t;*/
(brace
id|mask_rtc_irq_bit
c_func
(paren
id|RTC_AIE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|RTC_AIE_ON
suffix:colon
multiline_comment|/* Allow alarm interrupts.&t;*/
(brace
id|set_rtc_irq_bit
c_func
(paren
id|RTC_AIE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|RTC_PIE_OFF
suffix:colon
multiline_comment|/* Mask periodic int. enab. bit&t;*/
(brace
id|mask_rtc_irq_bit
c_func
(paren
id|RTC_PIE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtc_status
op_amp
id|RTC_TIMER_ON
)paren
(brace
id|spin_lock_irq
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|rtc_status
op_and_assign
op_complement
id|RTC_TIMER_ON
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|rtc_irq_timer
)paren
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|RTC_PIE_ON
suffix:colon
multiline_comment|/* Allow periodic ints&t;&t;*/
(brace
multiline_comment|/*&n;&t;&t; * We don&squot;t really want Joe User enabling more&n;&t;&t; * than 64Hz of interrupts on a multi-user machine.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rtc_freq
OG
l_int|64
)paren
op_logical_and
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RESOURCE
)paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rtc_status
op_amp
id|RTC_TIMER_ON
)paren
)paren
(brace
id|spin_lock_irq
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|rtc_irq_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
id|rtc_freq
op_plus
l_int|2
op_star
id|HZ
op_div
l_int|100
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|rtc_irq_timer
)paren
suffix:semicolon
id|rtc_status
op_or_assign
id|RTC_TIMER_ON
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
)brace
id|set_rtc_irq_bit
c_func
(paren
id|RTC_PIE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|RTC_UIE_OFF
suffix:colon
multiline_comment|/* Mask ints from RTC updates.&t;*/
(brace
id|mask_rtc_irq_bit
c_func
(paren
id|RTC_UIE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|RTC_UIE_ON
suffix:colon
multiline_comment|/* Allow ints for RTC updates.&t;*/
(brace
id|set_rtc_irq_bit
c_func
(paren
id|RTC_UIE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_case
id|RTC_ALM_READ
suffix:colon
multiline_comment|/* Read the present alarm time */
(brace
multiline_comment|/*&n;&t;&t; * This returns a struct rtc_time. Reading &gt;= 0xc0&n;&t;&t; * means &quot;don&squot;t care&quot; or &quot;match all&quot;. Only the tm_hour,&n;&t;&t; * tm_min, and tm_sec values are filled in.&n;&t;&t; */
id|get_rtc_alm_time
c_func
(paren
op_amp
id|wtime
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|RTC_ALM_SET
suffix:colon
multiline_comment|/* Store a time into the alarm */
(brace
multiline_comment|/*&n;&t;&t; * This expects a struct rtc_time. Writing 0xff means&n;&t;&t; * &quot;don&squot;t care&quot; or &quot;match all&quot;. Only the tm_hour,&n;&t;&t; * tm_min and tm_sec are used.&n;&t;&t; */
r_int
r_char
id|hrs
comma
id|min
comma
id|sec
suffix:semicolon
r_struct
id|rtc_time
id|alm_tm
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|alm_tm
comma
(paren
r_struct
id|rtc_time
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|rtc_time
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|hrs
op_assign
id|alm_tm.tm_hour
suffix:semicolon
id|min
op_assign
id|alm_tm.tm_min
suffix:semicolon
id|sec
op_assign
id|alm_tm.tm_sec
suffix:semicolon
r_if
c_cond
(paren
id|hrs
op_ge
l_int|24
)paren
id|hrs
op_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|min
op_ge
l_int|60
)paren
id|min
op_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|sec
op_ge
l_int|60
)paren
id|sec
op_assign
l_int|0xff
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
op_amp
id|RTC_DM_BINARY
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
(brace
id|BIN_TO_BCD
c_func
(paren
id|sec
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|min
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|hrs
)paren
suffix:semicolon
)brace
id|CMOS_WRITE
c_func
(paren
id|hrs
comma
id|RTC_HOURS_ALARM
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|min
comma
id|RTC_MINUTES_ALARM
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|sec
comma
id|RTC_SECONDS_ALARM
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|RTC_RD_TIME
suffix:colon
multiline_comment|/* Read the time/date from RTC&t;*/
(brace
id|get_rtc_time
c_func
(paren
op_amp
id|wtime
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|RTC_SET_TIME
suffix:colon
multiline_comment|/* Set the RTC */
(brace
r_struct
id|rtc_time
id|rtc_tm
suffix:semicolon
r_int
r_char
id|mon
comma
id|day
comma
id|hrs
comma
id|min
comma
id|sec
comma
id|leap_yr
suffix:semicolon
r_int
r_char
id|save_control
comma
id|save_freq_select
suffix:semicolon
r_int
r_int
id|yrs
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_TIME
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|rtc_tm
comma
(paren
r_struct
id|rtc_time
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|rtc_time
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|yrs
op_assign
id|rtc_tm.tm_year
op_plus
l_int|1900
suffix:semicolon
id|mon
op_assign
id|rtc_tm.tm_mon
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* tm_mon starts at zero */
id|day
op_assign
id|rtc_tm.tm_mday
suffix:semicolon
id|hrs
op_assign
id|rtc_tm.tm_hour
suffix:semicolon
id|min
op_assign
id|rtc_tm.tm_min
suffix:semicolon
id|sec
op_assign
id|rtc_tm.tm_sec
suffix:semicolon
r_if
c_cond
(paren
id|yrs
OL
l_int|1970
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|leap_yr
op_assign
(paren
(paren
op_logical_neg
(paren
id|yrs
op_mod
l_int|4
)paren
op_logical_and
(paren
id|yrs
op_mod
l_int|100
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|yrs
op_mod
l_int|400
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mon
OG
l_int|12
)paren
op_logical_or
(paren
id|day
op_eq
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|day
OG
(paren
id|days_in_mo
(braket
id|mon
)braket
op_plus
(paren
(paren
id|mon
op_eq
l_int|2
)paren
op_logical_and
id|leap_yr
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hrs
op_ge
l_int|24
)paren
op_logical_or
(paren
id|min
op_ge
l_int|60
)paren
op_logical_or
(paren
id|sec
op_ge
l_int|60
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|yrs
op_sub_assign
id|epoch
)paren
OG
l_int|255
)paren
multiline_comment|/* They are unsigned */
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
op_amp
id|RTC_DM_BINARY
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
(brace
r_if
c_cond
(paren
id|yrs
OG
l_int|169
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|yrs
op_ge
l_int|100
)paren
id|yrs
op_sub_assign
l_int|100
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|sec
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|min
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|hrs
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|day
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|mon
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|yrs
)paren
suffix:semicolon
)brace
id|save_control
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
(paren
id|save_control
op_or
id|RTC_SET
)paren
comma
id|RTC_CONTROL
)paren
suffix:semicolon
id|save_freq_select
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_FREQ_SELECT
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
(paren
id|save_freq_select
op_or
id|RTC_DIV_RESET2
)paren
comma
id|RTC_FREQ_SELECT
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|yrs
comma
id|RTC_YEAR
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|mon
comma
id|RTC_MONTH
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|day
comma
id|RTC_DAY_OF_MONTH
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|hrs
comma
id|RTC_HOURS
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|min
comma
id|RTC_MINUTES
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|sec
comma
id|RTC_SECONDS
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|save_control
comma
id|RTC_CONTROL
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|save_freq_select
comma
id|RTC_FREQ_SELECT
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if RTC_IRQ
r_case
id|RTC_IRQP_READ
suffix:colon
multiline_comment|/* Read the periodic IRQ rate.&t;*/
(brace
r_return
id|put_user
c_func
(paren
id|rtc_freq
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_case
id|RTC_IRQP_SET
suffix:colon
multiline_comment|/* Set periodic IRQ rate.&t;*/
(brace
r_int
id|tmp
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
multiline_comment|/* &n;&t;&t; * The max we can do is 8192Hz.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|arg
OL
l_int|2
)paren
op_logical_or
(paren
id|arg
OG
l_int|8192
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We don&squot;t really want Joe User generating more&n;&t;&t; * than 64Hz of interrupts on a multi-user machine.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|arg
OG
l_int|64
)paren
op_logical_and
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RESOURCE
)paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_while
c_loop
(paren
id|arg
OG
(paren
l_int|1
op_lshift
id|tmp
)paren
)paren
id|tmp
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Check that the input was really a power of 2.&n;&t;&t; */
r_if
c_cond
(paren
id|arg
op_ne
(paren
l_int|1
op_lshift
id|tmp
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|rtc_freq
op_assign
id|arg
suffix:semicolon
id|val
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_FREQ_SELECT
)paren
op_amp
l_int|0xf0
suffix:semicolon
id|val
op_or_assign
(paren
l_int|16
op_minus
id|tmp
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|val
comma
id|RTC_FREQ_SELECT
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#elif !defined(CONFIG_DECSTATION)
r_case
id|RTC_EPOCH_READ
suffix:colon
multiline_comment|/* Read the epoch.&t;*/
(brace
r_return
id|put_user
(paren
id|epoch
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_case
id|RTC_EPOCH_SET
suffix:colon
multiline_comment|/* Set the epoch.&t;*/
(brace
multiline_comment|/* &n;&t;&t; * There were no RTC clocks before 1900.&n;&t;&t; */
r_if
c_cond
(paren
id|arg
OL
l_int|1900
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_TIME
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|epoch
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|wtime
comma
r_sizeof
id|wtime
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;We enforce only one user at a time here with the open/close.&n; *&t;Also clear the previous interrupt data on an open, and clean&n; *&t;up things on a close.&n; */
multiline_comment|/* We use rtc_lock to protect against concurrent opens. So the BKL is not&n; * needed here. Or anywhere else in this driver. */
DECL|function|rtc_open
r_static
r_int
id|rtc_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|spin_lock_irq
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtc_status
op_amp
id|RTC_IS_OPEN
)paren
(brace
r_goto
id|out_busy
suffix:semicolon
)brace
id|rtc_status
op_or_assign
id|RTC_IS_OPEN
suffix:semicolon
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|out_busy
suffix:colon
id|spin_unlock_irq
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
DECL|function|rtc_fasync
r_static
r_int
id|rtc_fasync
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
)paren
(brace
r_return
id|fasync_helper
(paren
id|fd
comma
id|filp
comma
id|on
comma
op_amp
id|rtc_async_queue
)paren
suffix:semicolon
)brace
DECL|function|rtc_release
r_static
r_int
id|rtc_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
macro_line|#if RTC_IRQ
multiline_comment|/*&n;&t; * Turn off all interrupts once the device is no longer&n;&t; * in use, and clear the data.&n;&t; */
r_int
r_char
id|tmp
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|tmp
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|RTC_PIE
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|RTC_AIE
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|RTC_UIE
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|tmp
comma
id|RTC_CONTROL
)paren
suffix:semicolon
id|CMOS_READ
c_func
(paren
id|RTC_INTR_FLAGS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtc_status
op_amp
id|RTC_TIMER_ON
)paren
(brace
id|rtc_status
op_and_assign
op_complement
id|RTC_TIMER_ON
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|rtc_irq_timer
)paren
suffix:semicolon
)brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|FASYNC
)paren
(brace
id|rtc_fasync
(paren
op_minus
l_int|1
comma
id|file
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
id|spin_lock_irq
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
multiline_comment|/* No need for locking -- nobody else can do anything until this rmw is&n;&t; * committed, and no timer is running. */
id|rtc_status
op_and_assign
op_complement
id|RTC_IS_OPEN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if RTC_IRQ
multiline_comment|/* Called without the kernel lock - fine */
DECL|function|rtc_poll
r_static
r_int
r_int
id|rtc_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
r_int
id|l
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|rtc_wait
comma
id|wait
)paren
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|l
op_assign
id|rtc_irq_data
suffix:semicolon
id|spin_unlock_irq
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l
op_ne
l_int|0
)paren
r_return
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *&t;The various file operations we support.&n; */
DECL|variable|rtc_fops
r_static
r_struct
id|file_operations
id|rtc_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|rtc_llseek
comma
id|read
suffix:colon
id|rtc_read
comma
macro_line|#if RTC_IRQ
id|poll
suffix:colon
id|rtc_poll
comma
macro_line|#endif
id|ioctl
suffix:colon
id|rtc_ioctl
comma
id|open
suffix:colon
id|rtc_open
comma
id|release
suffix:colon
id|rtc_release
comma
id|fasync
suffix:colon
id|rtc_fasync
comma
)brace
suffix:semicolon
DECL|variable|rtc_dev
r_static
r_struct
id|miscdevice
id|rtc_dev
op_assign
(brace
id|RTC_MINOR
comma
l_string|&quot;rtc&quot;
comma
op_amp
id|rtc_fops
)brace
suffix:semicolon
DECL|function|rtc_init
r_static
r_int
id|__init
id|rtc_init
c_func
(paren
r_void
)paren
(brace
macro_line|#if defined(__alpha__) || defined(__mips__)
r_int
r_int
id|year
comma
id|ctrl
suffix:semicolon
r_int
r_int
id|uip_watchdog
suffix:semicolon
r_char
op_star
id|guess
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif
macro_line|#ifdef __sparc__
r_struct
id|linux_ebus
op_star
id|ebus
suffix:semicolon
r_struct
id|linux_ebus_device
op_star
id|edev
suffix:semicolon
macro_line|#endif
macro_line|#ifdef __sparc__
id|for_each_ebus
c_func
(paren
id|ebus
)paren
(brace
id|for_each_ebusdev
c_func
(paren
id|edev
comma
id|ebus
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|edev-&gt;prom_name
comma
l_string|&quot;rtc&quot;
)paren
op_eq
l_int|0
)paren
(brace
r_goto
id|found
suffix:semicolon
)brace
)brace
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rtc_init: no PC rtc found&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
id|found
suffix:colon
id|rtc_port
op_assign
id|edev-&gt;resource
(braket
l_int|0
)braket
dot
id|start
suffix:semicolon
id|rtc_irq
op_assign
id|edev-&gt;irqs
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * XXX Interrupt pin #7 in Espresso is shared between RTC and&n;&t; * PCI Slot 2 INTA# (and some INTx# in Slot 1). SA_INTERRUPT here&n;&t; * is asking for trouble with add-on boards. Change to SA_SHIRQ.&n;&t; */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|rtc_irq
comma
id|rtc_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;rtc&quot;
comma
(paren
r_void
op_star
)paren
op_amp
id|rtc_port
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Standard way for sparc to print irq&squot;s is to use&n;&t;&t; * __irq_itoa(). I think for EBus it&squot;s ok to use %d.&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rtc: cannot register IRQ %d&bslash;n&quot;
comma
id|rtc_irq
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#else
r_if
c_cond
(paren
id|check_region
(paren
id|RTC_PORT
(paren
l_int|0
)paren
comma
id|RTC_IO_EXTENT
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rtc: I/O port %d is not free.&bslash;n&quot;
comma
id|RTC_PORT
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#if RTC_IRQ
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|RTC_IRQ
comma
id|rtc_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;rtc&quot;
comma
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Yeah right, seeing as irq 8 doesn&squot;t even hit the bus. */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rtc: IRQ %d is not free.&bslash;n&quot;
comma
id|RTC_IRQ
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#endif
id|request_region
c_func
(paren
id|RTC_PORT
c_func
(paren
l_int|0
)paren
comma
id|RTC_IO_EXTENT
comma
l_string|&quot;rtc&quot;
)paren
suffix:semicolon
macro_line|#endif /* __sparc__ vs. others */
id|misc_register
c_func
(paren
op_amp
id|rtc_dev
)paren
suffix:semicolon
id|create_proc_read_entry
(paren
l_string|&quot;driver/rtc&quot;
comma
l_int|0
comma
l_int|0
comma
id|rtc_read_proc
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#if defined(__alpha__) || defined(__mips__)
id|rtc_freq
op_assign
id|HZ
suffix:semicolon
multiline_comment|/* Each operating system on an Alpha uses its own epoch.&n;&t;   Let&squot;s try to guess which one we are using now. */
id|uip_watchdog
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|rtc_is_updating
c_func
(paren
)paren
op_ne
l_int|0
)paren
r_while
c_loop
(paren
id|jiffies
op_minus
id|uip_watchdog
OL
l_int|2
op_star
id|HZ
op_div
l_int|100
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|year
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_YEAR
)paren
suffix:semicolon
id|ctrl
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctrl
op_amp
id|RTC_DM_BINARY
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
id|BCD_TO_BIN
c_func
(paren
id|year
)paren
suffix:semicolon
multiline_comment|/* This should never happen... */
r_if
c_cond
(paren
id|year
op_ge
l_int|20
op_logical_and
id|year
OL
l_int|48
)paren
(brace
id|epoch
op_assign
l_int|1980
suffix:semicolon
id|guess
op_assign
l_string|&quot;ARC console&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|year
op_ge
l_int|48
op_logical_and
id|year
OL
l_int|70
)paren
(brace
id|epoch
op_assign
l_int|1952
suffix:semicolon
id|guess
op_assign
l_string|&quot;Digital UNIX&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|year
op_ge
l_int|70
op_logical_and
id|year
OL
l_int|100
)paren
(brace
id|epoch
op_assign
l_int|1928
suffix:semicolon
id|guess
op_assign
l_string|&quot;Digital DECstation&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|guess
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;rtc: %s epoch (%lu) detected&bslash;n&quot;
comma
id|guess
comma
id|epoch
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if RTC_IRQ
id|init_timer
c_func
(paren
op_amp
id|rtc_irq_timer
)paren
suffix:semicolon
id|rtc_irq_timer.function
op_assign
id|rtc_dropped_irq
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
multiline_comment|/* Initialize periodic freq. to CMOS reset default, which is 1024Hz */
id|CMOS_WRITE
c_func
(paren
(paren
(paren
id|CMOS_READ
c_func
(paren
id|RTC_FREQ_SELECT
)paren
op_amp
l_int|0xF0
)paren
op_or
l_int|0x06
)paren
comma
id|RTC_FREQ_SELECT
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|rtc_freq
op_assign
l_int|1024
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Real Time Clock Driver v&quot;
id|RTC_VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rtc_exit
r_static
r_void
id|__exit
id|rtc_exit
(paren
r_void
)paren
(brace
id|remove_proc_entry
(paren
l_string|&quot;driver/rtc&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|misc_deregister
c_func
(paren
op_amp
id|rtc_dev
)paren
suffix:semicolon
macro_line|#ifdef __sparc__
id|free_irq
(paren
id|rtc_irq
comma
op_amp
id|rtc_port
)paren
suffix:semicolon
macro_line|#else
id|release_region
(paren
id|RTC_PORT
(paren
l_int|0
)paren
comma
id|RTC_IO_EXTENT
)paren
suffix:semicolon
macro_line|#if RTC_IRQ
id|free_irq
(paren
id|RTC_IRQ
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif /* __sparc__ */
)brace
DECL|variable|rtc_init
id|module_init
c_func
(paren
id|rtc_init
)paren
suffix:semicolon
DECL|variable|rtc_exit
id|module_exit
c_func
(paren
id|rtc_exit
)paren
suffix:semicolon
id|EXPORT_NO_SYMBOLS
suffix:semicolon
macro_line|#if RTC_IRQ
multiline_comment|/*&n; * &t;At IRQ rates &gt;= 4096Hz, an interrupt may get lost altogether.&n; *&t;(usually during an IDE disk interrupt, with IRQ unmasking off)&n; *&t;Since the interrupt handler doesn&squot;t get called, the IRQ status&n; *&t;byte doesn&squot;t get read, and the RTC stops generating interrupts.&n; *&t;A timer is set, and will call this function if/when that happens.&n; *&t;To get it out of this stalled state, we just read the status.&n; *&t;At least a jiffy of interrupts (rtc_freq/HZ) will have been lost.&n; *&t;(You *really* shouldn&squot;t be trying to use a non-realtime system &n; *&t;for something that requires a steady &gt; 1KHz signal anyways.)&n; */
DECL|function|rtc_dropped_irq
r_static
r_void
id|rtc_dropped_irq
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|freq
suffix:semicolon
id|spin_lock_irq
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
multiline_comment|/* Just in case someone disabled the timer from behind our back... */
r_if
c_cond
(paren
id|rtc_status
op_amp
id|RTC_TIMER_ON
)paren
id|mod_timer
c_func
(paren
op_amp
id|rtc_irq_timer
comma
id|jiffies
op_plus
id|HZ
op_div
id|rtc_freq
op_plus
l_int|2
op_star
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
id|rtc_irq_data
op_add_assign
(paren
(paren
id|rtc_freq
op_div
id|HZ
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|rtc_irq_data
op_and_assign
op_complement
l_int|0xff
suffix:semicolon
id|rtc_irq_data
op_or_assign
(paren
id|CMOS_READ
c_func
(paren
id|RTC_INTR_FLAGS
)paren
op_amp
l_int|0xF0
)paren
suffix:semicolon
multiline_comment|/* restart */
id|freq
op_assign
id|rtc_freq
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;rtc: lost some interrupts at %ldHz.&bslash;n&quot;
comma
id|freq
)paren
suffix:semicolon
multiline_comment|/* Now we have new data */
id|wake_up_interruptible
c_func
(paren
op_amp
id|rtc_wait
)paren
suffix:semicolon
id|kill_fasync
(paren
op_amp
id|rtc_async_queue
comma
id|SIGIO
comma
id|POLL_IN
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; *&t;Info exported via &quot;/proc/driver/rtc&quot;.&n; */
DECL|function|rtc_proc_output
r_static
r_int
id|rtc_proc_output
(paren
r_char
op_star
id|buf
)paren
(brace
DECL|macro|YN
mdefine_line|#define YN(bit) ((ctrl &amp; bit) ? &quot;yes&quot; : &quot;no&quot;)
DECL|macro|NY
mdefine_line|#define NY(bit) ((ctrl &amp; bit) ? &quot;no&quot; : &quot;yes&quot;)
r_char
op_star
id|p
suffix:semicolon
r_struct
id|rtc_time
id|tm
suffix:semicolon
r_int
r_char
id|batt
comma
id|ctrl
suffix:semicolon
r_int
r_int
id|freq
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|batt
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_VALID
)paren
op_amp
id|RTC_VRT
suffix:semicolon
id|ctrl
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|freq
op_assign
id|rtc_freq
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|p
op_assign
id|buf
suffix:semicolon
id|get_rtc_time
c_func
(paren
op_amp
id|tm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There is no way to tell if the luser has the RTC set for local&n;&t; * time or for Universal Standard Time (GMT). Probably local though.&n;&t; */
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;rtc_time&bslash;t: %02d:%02d:%02d&bslash;n&quot;
l_string|&quot;rtc_date&bslash;t: %04d-%02d-%02d&bslash;n&quot;
l_string|&quot;rtc_epoch&bslash;t: %04lu&bslash;n&quot;
comma
id|tm.tm_hour
comma
id|tm.tm_min
comma
id|tm.tm_sec
comma
id|tm.tm_year
op_plus
l_int|1900
comma
id|tm.tm_mon
op_plus
l_int|1
comma
id|tm.tm_mday
comma
id|epoch
)paren
suffix:semicolon
id|get_rtc_alm_time
c_func
(paren
op_amp
id|tm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We implicitly assume 24hr mode here. Alarm values &gt;= 0xc0 will&n;&t; * match any value for that particular field. Values that are&n;&t; * greater than a valid time, but less than 0xc0 shouldn&squot;t appear.&n;&t; */
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;alarm&bslash;t&bslash;t: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tm.tm_hour
op_le
l_int|24
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%02d:&quot;
comma
id|tm.tm_hour
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;**:&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tm.tm_min
op_le
l_int|59
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%02d:&quot;
comma
id|tm.tm_min
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;**:&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tm.tm_sec
op_le
l_int|59
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%02d&bslash;n&quot;
comma
id|tm.tm_sec
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;**&bslash;n&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;DST_enable&bslash;t: %s&bslash;n&quot;
l_string|&quot;BCD&bslash;t&bslash;t: %s&bslash;n&quot;
l_string|&quot;24hr&bslash;t&bslash;t: %s&bslash;n&quot;
l_string|&quot;square_wave&bslash;t: %s&bslash;n&quot;
l_string|&quot;alarm_IRQ&bslash;t: %s&bslash;n&quot;
l_string|&quot;update_IRQ&bslash;t: %s&bslash;n&quot;
l_string|&quot;periodic_IRQ&bslash;t: %s&bslash;n&quot;
l_string|&quot;periodic_freq&bslash;t: %ld&bslash;n&quot;
l_string|&quot;batt_status&bslash;t: %s&bslash;n&quot;
comma
id|YN
c_func
(paren
id|RTC_DST_EN
)paren
comma
id|NY
c_func
(paren
id|RTC_DM_BINARY
)paren
comma
id|YN
c_func
(paren
id|RTC_24H
)paren
comma
id|YN
c_func
(paren
id|RTC_SQWE
)paren
comma
id|YN
c_func
(paren
id|RTC_AIE
)paren
comma
id|YN
c_func
(paren
id|RTC_UIE
)paren
comma
id|YN
c_func
(paren
id|RTC_PIE
)paren
comma
id|freq
comma
id|batt
ques
c_cond
l_string|&quot;okay&quot;
suffix:colon
l_string|&quot;dead&quot;
)paren
suffix:semicolon
r_return
id|p
op_minus
id|buf
suffix:semicolon
DECL|macro|YN
macro_line|#undef YN
DECL|macro|NY
macro_line|#undef NY
)brace
DECL|function|rtc_read_proc
r_static
r_int
id|rtc_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
id|rtc_proc_output
(paren
id|page
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|off
op_plus
id|count
)paren
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
id|off
suffix:semicolon
id|len
op_sub_assign
id|off
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|count
)paren
id|len
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
l_int|0
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns true if a clock update is in progress&n; */
multiline_comment|/* FIXME shouldn&squot;t this be above rtc_init to make it fully inlined? */
DECL|function|rtc_is_updating
r_static
r_inline
r_int
r_char
id|rtc_is_updating
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|uip
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|uip
op_assign
(paren
id|CMOS_READ
c_func
(paren
id|RTC_FREQ_SELECT
)paren
op_amp
id|RTC_UIP
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_return
id|uip
suffix:semicolon
)brace
DECL|function|get_rtc_time
r_static
r_void
id|get_rtc_time
c_func
(paren
r_struct
id|rtc_time
op_star
id|rtc_tm
)paren
(brace
r_int
r_int
id|uip_watchdog
op_assign
id|jiffies
suffix:semicolon
r_int
r_char
id|ctrl
suffix:semicolon
multiline_comment|/*&n;&t; * read RTC once any update in progress is done. The update&n;&t; * can take just over 2ms. We wait 10 to 20ms. There is no need to&n;&t; * to poll-wait (up to 1s - eeccch) for the falling edge of RTC_UIP.&n;&t; * If you need to know *exactly* when a second has started, enable&n;&t; * periodic update complete interrupts, (via ioctl) and then &n;&t; * immediately read /dev/rtc which will block until you get the IRQ.&n;&t; * Once the read clears, read the RTC time (again via ioctl). Easy.&n;&t; */
r_if
c_cond
(paren
id|rtc_is_updating
c_func
(paren
)paren
op_ne
l_int|0
)paren
r_while
c_loop
(paren
id|jiffies
op_minus
id|uip_watchdog
OL
l_int|2
op_star
id|HZ
op_div
l_int|100
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Only the values that we read from the RTC are set. We leave&n;&t; * tm_wday, tm_yday and tm_isdst untouched. Even though the&n;&t; * RTC has RTC_DAY_OF_WEEK, we ignore it, as it is only updated&n;&t; * by the RTC when initially set to a non-zero value.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|rtc_tm-&gt;tm_sec
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_SECONDS
)paren
suffix:semicolon
id|rtc_tm-&gt;tm_min
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_MINUTES
)paren
suffix:semicolon
id|rtc_tm-&gt;tm_hour
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_HOURS
)paren
suffix:semicolon
id|rtc_tm-&gt;tm_mday
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_DAY_OF_MONTH
)paren
suffix:semicolon
id|rtc_tm-&gt;tm_mon
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_MONTH
)paren
suffix:semicolon
id|rtc_tm-&gt;tm_year
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_YEAR
)paren
suffix:semicolon
id|ctrl
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctrl
op_amp
id|RTC_DM_BINARY
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
(brace
id|BCD_TO_BIN
c_func
(paren
id|rtc_tm-&gt;tm_sec
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|rtc_tm-&gt;tm_min
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|rtc_tm-&gt;tm_hour
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|rtc_tm-&gt;tm_mday
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|rtc_tm-&gt;tm_mon
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|rtc_tm-&gt;tm_year
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Account for differences between how the RTC uses the values&n;&t; * and how they are defined in a struct rtc_time;&n;&t; */
r_if
c_cond
(paren
(paren
id|rtc_tm-&gt;tm_year
op_add_assign
(paren
id|epoch
op_minus
l_int|1900
)paren
)paren
op_le
l_int|69
)paren
id|rtc_tm-&gt;tm_year
op_add_assign
l_int|100
suffix:semicolon
id|rtc_tm-&gt;tm_mon
op_decrement
suffix:semicolon
)brace
DECL|function|get_rtc_alm_time
r_static
r_void
id|get_rtc_alm_time
c_func
(paren
r_struct
id|rtc_time
op_star
id|alm_tm
)paren
(brace
r_int
r_char
id|ctrl
suffix:semicolon
multiline_comment|/*&n;&t; * Only the values that we read from the RTC are set. That&n;&t; * means only tm_hour, tm_min, and tm_sec.&n;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|alm_tm-&gt;tm_sec
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_SECONDS_ALARM
)paren
suffix:semicolon
id|alm_tm-&gt;tm_min
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_MINUTES_ALARM
)paren
suffix:semicolon
id|alm_tm-&gt;tm_hour
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_HOURS_ALARM
)paren
suffix:semicolon
id|ctrl
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctrl
op_amp
id|RTC_DM_BINARY
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
(brace
id|BCD_TO_BIN
c_func
(paren
id|alm_tm-&gt;tm_sec
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|alm_tm-&gt;tm_min
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|alm_tm-&gt;tm_hour
)paren
suffix:semicolon
)brace
)brace
macro_line|#if RTC_IRQ
multiline_comment|/*&n; * Used to disable/enable interrupts for any one of UIE, AIE, PIE.&n; * Rumour has it that if you frob the interrupt enable/disable&n; * bits in RTC_CONTROL, you should read RTC_INTR_FLAGS, to&n; * ensure you actually start getting interrupts. Probably for&n; * compatibility with older/broken chipset RTC implementations.&n; * We also clear out any old irq data after an ioctl() that&n; * meddles with the interrupt enable/disable bits.&n; */
DECL|function|mask_rtc_irq_bit
r_static
r_void
id|mask_rtc_irq_bit
c_func
(paren
r_int
r_char
id|bit
)paren
(brace
r_int
r_char
id|val
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|val
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|val
op_and_assign
op_complement
id|bit
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|val
comma
id|RTC_CONTROL
)paren
suffix:semicolon
id|CMOS_READ
c_func
(paren
id|RTC_INTR_FLAGS
)paren
suffix:semicolon
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
)brace
DECL|function|set_rtc_irq_bit
r_static
r_void
id|set_rtc_irq_bit
c_func
(paren
r_int
r_char
id|bit
)paren
(brace
r_int
r_char
id|val
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
id|val
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|val
op_or_assign
id|bit
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|val
comma
id|RTC_CONTROL
)paren
suffix:semicolon
id|CMOS_READ
c_func
(paren
id|RTC_INTR_FLAGS
)paren
suffix:semicolon
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|rtc_lock
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
