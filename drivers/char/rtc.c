multiline_comment|/*&n; *&t;Real Time Clock interface for Linux&t;&n; *&n; *&t;Copyright (C) 1996 Paul Gortmaker&n; *&n; *&t;This driver allows use of the real time clock (built into&n; *&t;nearly all computers) from user space. It exports the /dev/rtc&n; *&t;interface supporting various ioctl() and also the /proc/rtc&n; *&t;pseudo-file for status information.&n; *&n; *&t;The ioctls can be used to set the interrupt behaviour and&n; *&t;generation rate from the RTC via IRQ 8. Then the /dev/rtc&n; *&t;interface can be used to make use of these timer interrupts,&n; *&t;be they interval or alarm based.&n; *&n; *&t;The /dev/rtc interface will block on reads until an interrupt&n; *&t;has been received. If a RTC interrupt has already happened,&n; *&t;it will output an unsigned long and then block. The output value&n; *&t;contains the interrupt status in the low byte and the number of&n; *&t;interrupts since the last read in the remaining high bytes. The &n; *&t;/dev/rtc interface can also be used with the select(2) call.&n; *&n; *&t;This program is free software; you can redistribute it and/or&n; *&t;modify it under the terms of the GNU General Public License&n; *&t;as published by the Free Software Foundation; either version&n; *&t;2 of the License, or (at your option) any later version.&n; *&n; *&t;Based on other minimal char device drivers, like Alan&squot;s&n; *&t;watchdog, Ted&squot;s random, etc. etc.&n; *&n; */
DECL|macro|RTC_VERSION
mdefine_line|#define RTC_VERSION&t;&t;&quot;1.07&quot;
DECL|macro|RTC_IRQ
mdefine_line|#define RTC_IRQ &t;8&t;/* Can&squot;t see this changing soon.&t;*/
DECL|macro|RTC_IO_EXTENT
mdefine_line|#define RTC_IO_EXTENT&t;0x10&t;/* Only really two ports, but...&t;*/
multiline_comment|/*&n; *&t;Note that *all* calls to CMOS_READ and CMOS_WRITE are done with&n; *&t;interrupts disabled. Due to the index-port/data-port (0x70/0x71)&n; *&t;design of the RTC, we don&squot;t want two different things trying to&n; *&t;get to it at once. (e.g. the periodic 11 min sync from time.c vs.&n; *&t;this driver.)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/mc146818rtc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/poll.h&gt;
multiline_comment|/* Adjust starting epoch if ARC console time is being used */
macro_line|#ifdef CONFIG_RTC_ARC
DECL|macro|ARCFUDGE
mdefine_line|#define ARCFUDGE 20 
macro_line|#else
DECL|macro|ARCFUDGE
mdefine_line|#define ARCFUDGE 0
macro_line|#endif
multiline_comment|/*&n; *&t;We sponge a minor off of the misc major. No need slurping&n; *&t;up another valuable major dev number for this. If you add&n; *&t;an ioctl, make sure you don&squot;t conflict with SPARC&squot;s RTC&n; *&t;ioctls.&n; */
DECL|variable|rtc_wait
r_static
r_struct
id|wait_queue
op_star
id|rtc_wait
suffix:semicolon
DECL|variable|rtc_irq_timer
r_static
r_struct
id|timer_list
id|rtc_irq_timer
suffix:semicolon
r_static
r_int
r_int
id|rtc_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
suffix:semicolon
r_static
r_int
id|rtc_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
suffix:semicolon
r_static
r_int
id|rtc_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
r_int
id|rtc_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
suffix:semicolon
r_void
id|get_rtc_time
(paren
r_struct
id|rtc_time
op_star
id|rtc_tm
)paren
suffix:semicolon
r_void
id|get_rtc_alm_time
(paren
r_struct
id|rtc_time
op_star
id|alm_tm
)paren
suffix:semicolon
r_void
id|rtc_dropped_irq
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_void
id|set_rtc_irq_bit
c_func
(paren
r_int
r_char
id|bit
)paren
suffix:semicolon
r_void
id|mask_rtc_irq_bit
c_func
(paren
r_int
r_char
id|bit
)paren
suffix:semicolon
r_static
r_inline
r_int
r_char
id|rtc_is_updating
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Bits in rtc_status. (7 bits of room for future expansion)&n; */
DECL|macro|RTC_IS_OPEN
mdefine_line|#define RTC_IS_OPEN&t;&t;0x01&t;/* means /dev/rtc is in use&t;*/
DECL|macro|RTC_TIMER_ON
mdefine_line|#define RTC_TIMER_ON&t;&t;0x02&t;/* missed irq timer active&t;*/
DECL|variable|rtc_status
r_int
r_char
id|rtc_status
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bitmapped status byte.&t;*/
DECL|variable|rtc_freq
r_int
r_int
id|rtc_freq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Current periodic IRQ rate&t;*/
DECL|variable|rtc_irq_data
r_int
r_int
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* our output to the world&t;*/
DECL|variable|days_in_mo
r_int
r_char
id|days_in_mo
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|31
comma
l_int|28
comma
l_int|31
comma
l_int|30
comma
l_int|31
comma
l_int|30
comma
l_int|31
comma
l_int|31
comma
l_int|30
comma
l_int|31
comma
l_int|30
comma
l_int|31
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;A very tiny interrupt handler. It runs with SA_INTERRUPT set,&n; *&t;so that there is no possibility of conflicting with the&n; *&t;set_rtc_mmss() call that happens during some timer interrupts.&n; *&t;(See ./arch/XXXX/kernel/time.c for the set_rtc_mmss() function.)&n; */
DECL|function|rtc_interrupt
r_static
r_void
id|rtc_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
multiline_comment|/*&n;&t; *&t;Can be an alarm interrupt, update complete interrupt,&n;&t; *&t;or a periodic interrupt. We store the status in the&n;&t; *&t;low byte and the number of interrupts received since&n;&t; *&t;the last read in the remainder of rtc_irq_data.&n;&t; */
id|rtc_irq_data
op_add_assign
l_int|0x100
suffix:semicolon
id|rtc_irq_data
op_and_assign
op_complement
l_int|0xff
suffix:semicolon
id|rtc_irq_data
op_or_assign
(paren
id|CMOS_READ
c_func
(paren
id|RTC_INTR_FLAGS
)paren
op_amp
l_int|0xF0
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|rtc_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtc_status
op_amp
id|RTC_TIMER_ON
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|rtc_irq_timer
)paren
suffix:semicolon
id|rtc_irq_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
id|rtc_freq
op_plus
l_int|2
op_star
id|HZ
op_div
l_int|100
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|rtc_irq_timer
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Now all the various file operations that we export.&n; */
DECL|function|rtc_llseek
r_static
r_int
r_int
id|rtc_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
DECL|function|rtc_read
r_static
r_int
id|rtc_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
r_sizeof
(paren
r_int
r_int
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|rtc_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_while
c_loop
(paren
id|rtc_irq_data
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retval
op_eq
l_int|0
)paren
(brace
r_int
r_int
id|data
comma
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|data
op_assign
id|rtc_irq_data
suffix:semicolon
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|retval
op_assign
id|put_user
c_func
(paren
id|data
comma
(paren
r_int
r_int
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|rtc_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|rtc_ioctl
r_static
r_int
id|rtc_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|rtc_time
id|wtime
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|RTC_AIE_OFF
suffix:colon
multiline_comment|/* Mask alarm int. enab. bit&t;*/
(brace
id|mask_rtc_irq_bit
c_func
(paren
id|RTC_AIE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|RTC_AIE_ON
suffix:colon
multiline_comment|/* Allow alarm interrupts.&t;*/
(brace
id|set_rtc_irq_bit
c_func
(paren
id|RTC_AIE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|RTC_PIE_OFF
suffix:colon
multiline_comment|/* Mask periodic int. enab. bit&t;*/
(brace
id|mask_rtc_irq_bit
c_func
(paren
id|RTC_PIE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtc_status
op_amp
id|RTC_TIMER_ON
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|rtc_irq_timer
)paren
suffix:semicolon
id|rtc_status
op_and_assign
op_complement
id|RTC_TIMER_ON
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|RTC_PIE_ON
suffix:colon
multiline_comment|/* Allow periodic ints&t;&t;*/
(brace
multiline_comment|/*&n;&t;&t;&t; * We don&squot;t really want Joe User enabling more&n;&t;&t;&t; * than 64Hz of interrupts on a multi-user machine.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|rtc_freq
OG
l_int|64
)paren
op_logical_and
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rtc_status
op_amp
id|RTC_TIMER_ON
)paren
)paren
(brace
id|rtc_status
op_or_assign
id|RTC_TIMER_ON
suffix:semicolon
id|rtc_irq_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
id|rtc_freq
op_plus
l_int|2
op_star
id|HZ
op_div
l_int|100
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|rtc_irq_timer
)paren
suffix:semicolon
)brace
id|set_rtc_irq_bit
c_func
(paren
id|RTC_PIE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|RTC_UIE_OFF
suffix:colon
multiline_comment|/* Mask ints from RTC updates.&t;*/
(brace
id|mask_rtc_irq_bit
c_func
(paren
id|RTC_UIE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|RTC_UIE_ON
suffix:colon
multiline_comment|/* Allow ints for RTC updates.&t;*/
(brace
id|set_rtc_irq_bit
c_func
(paren
id|RTC_UIE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|RTC_ALM_READ
suffix:colon
multiline_comment|/* Read the present alarm time */
(brace
multiline_comment|/*&n;&t;&t;&t; * This returns a struct rtc_time. Reading &gt;= 0xc0&n;&t;&t;&t; * means &quot;don&squot;t care&quot; or &quot;match all&quot;. Only the tm_hour,&n;&t;&t;&t; * tm_min, and tm_sec values are filled in.&n;&t;&t;&t; */
id|get_rtc_alm_time
c_func
(paren
op_amp
id|wtime
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|RTC_ALM_SET
suffix:colon
multiline_comment|/* Store a time into the alarm */
(brace
multiline_comment|/*&n;&t;&t;&t; * This expects a struct rtc_time. Writing 0xff means&n;&t;&t;&t; * &quot;don&squot;t care&quot; or &quot;match all&quot;. Only the tm_hour,&n;&t;&t;&t; * tm_min and tm_sec are used.&n;&t;&t;&t; */
r_int
r_char
id|hrs
comma
id|min
comma
id|sec
suffix:semicolon
r_struct
id|rtc_time
id|alm_tm
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|alm_tm
comma
(paren
r_struct
id|rtc_time
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|rtc_time
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|hrs
op_assign
id|alm_tm.tm_hour
suffix:semicolon
id|min
op_assign
id|alm_tm.tm_min
suffix:semicolon
id|sec
op_assign
id|alm_tm.tm_sec
suffix:semicolon
r_if
c_cond
(paren
id|hrs
op_ge
l_int|24
)paren
id|hrs
op_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|min
op_ge
l_int|60
)paren
id|min
op_assign
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|sec
op_ge
l_int|60
)paren
id|sec
op_assign
l_int|0xff
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
op_amp
id|RTC_DM_BINARY
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
(brace
id|BIN_TO_BCD
c_func
(paren
id|sec
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|min
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|hrs
)paren
suffix:semicolon
)brace
id|CMOS_WRITE
c_func
(paren
id|hrs
comma
id|RTC_HOURS_ALARM
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|min
comma
id|RTC_MINUTES_ALARM
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|sec
comma
id|RTC_SECONDS_ALARM
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|RTC_RD_TIME
suffix:colon
multiline_comment|/* Read the time/date from RTC&t;*/
(brace
id|get_rtc_time
c_func
(paren
op_amp
id|wtime
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|RTC_SET_TIME
suffix:colon
multiline_comment|/* Set the RTC */
(brace
r_struct
id|rtc_time
id|rtc_tm
suffix:semicolon
r_int
r_char
id|mon
comma
id|day
comma
id|hrs
comma
id|min
comma
id|sec
comma
id|leap_yr
suffix:semicolon
r_int
r_char
id|save_control
comma
id|save_freq_select
suffix:semicolon
r_int
r_int
id|yrs
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|rtc_tm
comma
(paren
r_struct
id|rtc_time
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|rtc_time
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|yrs
op_assign
id|rtc_tm.tm_year
op_plus
l_int|1900
op_plus
id|ARCFUDGE
suffix:semicolon
id|mon
op_assign
id|rtc_tm.tm_mon
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* tm_mon starts at zero */
id|day
op_assign
id|rtc_tm.tm_mday
suffix:semicolon
id|hrs
op_assign
id|rtc_tm.tm_hour
suffix:semicolon
id|min
op_assign
id|rtc_tm.tm_min
suffix:semicolon
id|sec
op_assign
id|rtc_tm.tm_sec
suffix:semicolon
r_if
c_cond
(paren
(paren
id|yrs
OL
l_int|1970
)paren
op_logical_or
(paren
id|yrs
OG
l_int|2069
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|leap_yr
op_assign
(paren
(paren
op_logical_neg
(paren
id|yrs
op_mod
l_int|4
)paren
op_logical_and
(paren
id|yrs
op_mod
l_int|100
)paren
)paren
op_logical_or
op_logical_neg
(paren
id|yrs
op_mod
l_int|400
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mon
OG
l_int|12
)paren
op_logical_or
(paren
id|day
op_eq
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|day
OG
(paren
id|days_in_mo
(braket
id|mon
)braket
op_plus
(paren
(paren
id|mon
op_eq
l_int|2
)paren
op_logical_and
id|leap_yr
)paren
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hrs
op_ge
l_int|24
)paren
op_logical_or
(paren
id|min
op_ge
l_int|60
)paren
op_logical_or
(paren
id|sec
op_ge
l_int|60
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|yrs
op_ge
l_int|2000
)paren
id|yrs
op_sub_assign
l_int|2000
suffix:semicolon
multiline_comment|/* RTC (0, 1, ... 69) */
r_else
id|yrs
op_sub_assign
l_int|1900
suffix:semicolon
multiline_comment|/* RTC (70, 71, ... 99) */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
op_amp
id|RTC_DM_BINARY
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
(brace
id|BIN_TO_BCD
c_func
(paren
id|sec
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|min
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|hrs
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|day
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|mon
)paren
suffix:semicolon
id|BIN_TO_BCD
c_func
(paren
id|yrs
)paren
suffix:semicolon
)brace
id|save_control
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
(paren
id|save_control
op_or
id|RTC_SET
)paren
comma
id|RTC_CONTROL
)paren
suffix:semicolon
id|save_freq_select
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_FREQ_SELECT
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
(paren
id|save_freq_select
op_or
id|RTC_DIV_RESET2
)paren
comma
id|RTC_FREQ_SELECT
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|yrs
comma
id|RTC_YEAR
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|mon
comma
id|RTC_MONTH
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|day
comma
id|RTC_DAY_OF_MONTH
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|hrs
comma
id|RTC_HOURS
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|min
comma
id|RTC_MINUTES
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|sec
comma
id|RTC_SECONDS
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|save_control
comma
id|RTC_CONTROL
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|save_freq_select
comma
id|RTC_FREQ_SELECT
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|RTC_IRQP_READ
suffix:colon
multiline_comment|/* Read the periodic IRQ rate.&t;*/
(brace
r_return
id|put_user
c_func
(paren
id|rtc_freq
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_case
id|RTC_IRQP_SET
suffix:colon
multiline_comment|/* Set periodic IRQ rate.&t;*/
(brace
r_int
id|tmp
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
multiline_comment|/* &n;&t;&t;&t; * The max we can do is 8192Hz.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|arg
OL
l_int|2
)paren
op_logical_or
(paren
id|arg
OG
l_int|8192
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * We don&squot;t really want Joe User generating more&n;&t;&t;&t; * than 64Hz of interrupts on a multi-user machine.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|arg
OG
l_int|64
)paren
op_logical_and
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_while
c_loop
(paren
id|arg
OG
(paren
l_int|1
op_lshift
id|tmp
)paren
)paren
id|tmp
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Check that the input was really a power of 2.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|arg
op_ne
(paren
l_int|1
op_lshift
id|tmp
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|rtc_freq
op_assign
id|arg
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_FREQ_SELECT
)paren
op_amp
l_int|0xf0
suffix:semicolon
id|val
op_or_assign
(paren
l_int|16
op_minus
id|tmp
)paren
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|val
comma
id|RTC_FREQ_SELECT
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|wtime
comma
r_sizeof
id|wtime
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;We enforce only one user at a time here with the open/close.&n; *&t;Also clear the previous interrupt data on an open, and clean&n; *&t;up things on a close.&n; */
DECL|function|rtc_open
r_static
r_int
id|rtc_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_if
c_cond
(paren
id|rtc_status
op_amp
id|RTC_IS_OPEN
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|rtc_status
op_or_assign
id|RTC_IS_OPEN
suffix:semicolon
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rtc_release
r_static
r_int
id|rtc_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
multiline_comment|/*&n;&t; * Turn off all interrupts once the device is no longer&n;&t; * in use, and clear the data.&n;&t; */
r_int
r_char
id|tmp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tmp
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|RTC_PIE
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|RTC_AIE
suffix:semicolon
id|tmp
op_and_assign
op_complement
id|RTC_UIE
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|tmp
comma
id|RTC_CONTROL
)paren
suffix:semicolon
id|CMOS_READ
c_func
(paren
id|RTC_INTR_FLAGS
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtc_status
op_amp
id|RTC_TIMER_ON
)paren
(brace
id|rtc_status
op_and_assign
op_complement
id|RTC_TIMER_ON
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|rtc_irq_timer
)paren
suffix:semicolon
)brace
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
id|rtc_status
op_and_assign
op_complement
id|RTC_IS_OPEN
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rtc_poll
r_static
r_int
r_int
id|rtc_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
id|poll_wait
c_func
(paren
op_amp
id|rtc_wait
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rtc_irq_data
op_ne
l_int|0
)paren
r_return
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The various file operations we support.&n; */
DECL|variable|rtc_fops
r_static
r_struct
id|file_operations
id|rtc_fops
op_assign
(brace
id|rtc_llseek
comma
id|rtc_read
comma
l_int|NULL
comma
multiline_comment|/* No write */
l_int|NULL
comma
multiline_comment|/* No readdir */
id|rtc_poll
comma
id|rtc_ioctl
comma
l_int|NULL
comma
multiline_comment|/* No mmap */
id|rtc_open
comma
id|rtc_release
)brace
suffix:semicolon
DECL|variable|rtc_dev
r_static
r_struct
id|miscdevice
id|rtc_dev
op_assign
(brace
id|RTC_MINOR
comma
l_string|&quot;rtc&quot;
comma
op_amp
id|rtc_fops
)brace
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|rtc_init
c_func
(paren
r_void
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Real Time Clock Driver v%s&bslash;n&quot;
comma
id|RTC_VERSION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|RTC_IRQ
comma
id|rtc_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;rtc&quot;
comma
l_int|NULL
)paren
)paren
(brace
multiline_comment|/* Yeah right, seeing as irq 8 doesn&squot;t even hit the bus. */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rtc: IRQ %d is not free.&bslash;n&quot;
comma
id|RTC_IRQ
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|misc_register
c_func
(paren
op_amp
id|rtc_dev
)paren
suffix:semicolon
multiline_comment|/* Check region? Naaah! Just snarf it up. */
id|request_region
c_func
(paren
id|RTC_PORT
c_func
(paren
l_int|0
)paren
comma
id|RTC_IO_EXTENT
comma
l_string|&quot;rtc&quot;
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|rtc_irq_timer
)paren
suffix:semicolon
id|rtc_irq_timer.function
op_assign
id|rtc_dropped_irq
suffix:semicolon
id|rtc_wait
op_assign
l_int|NULL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Initialize periodic freq. to CMOS reset default, which is 1024Hz */
id|CMOS_WRITE
c_func
(paren
(paren
(paren
id|CMOS_READ
c_func
(paren
id|RTC_FREQ_SELECT
)paren
op_amp
l_int|0xF0
)paren
op_or
l_int|0x06
)paren
comma
id|RTC_FREQ_SELECT
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|rtc_freq
op_assign
l_int|1024
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;At IRQ rates &gt;= 4096Hz, an interrupt may get lost altogether.&n; *&t;(usually during an IDE disk interrupt, with IRQ unmasking off)&n; *&t;Since the interrupt handler doesn&squot;t get called, the IRQ status&n; *&t;byte doesn&squot;t get read, and the RTC stops generating interrupts.&n; *&t;A timer is set, and will call this function if/when that happens.&n; *&t;To get it out of this stalled state, we just read the status.&n; *&t;At least a jiffy of interrupts (rtc_freq/HZ) will have been lost.&n; *&t;(You *really* shouldn&squot;t be trying to use a non-realtime system &n; *&t;for something that requires a steady &gt; 1KHz signal anyways.)&n; */
DECL|function|rtc_dropped_irq
r_void
id|rtc_dropped_irq
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;rtc: lost some interrupts at %ldHz.&bslash;n&quot;
comma
id|rtc_freq
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|rtc_irq_timer
)paren
suffix:semicolon
id|rtc_irq_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
id|rtc_freq
op_plus
l_int|2
op_star
id|HZ
op_div
l_int|100
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|rtc_irq_timer
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|rtc_irq_data
op_add_assign
(paren
(paren
id|rtc_freq
op_div
id|HZ
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|rtc_irq_data
op_and_assign
op_complement
l_int|0xff
suffix:semicolon
id|rtc_irq_data
op_or_assign
(paren
id|CMOS_READ
c_func
(paren
id|RTC_INTR_FLAGS
)paren
op_amp
l_int|0xF0
)paren
suffix:semicolon
multiline_comment|/* restart */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Info exported via &quot;/proc/rtc&quot;.&n; */
DECL|function|get_rtc_status
r_int
id|get_rtc_status
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_struct
id|rtc_time
id|tm
suffix:semicolon
r_int
r_char
id|batt
comma
id|ctrl
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|batt
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_VALID
)paren
op_amp
id|RTC_VRT
suffix:semicolon
id|ctrl
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|p
op_assign
id|buf
suffix:semicolon
id|get_rtc_time
c_func
(paren
op_amp
id|tm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * There is no way to tell if the luser has the RTC set for local&n;&t; * time or for Universal Standard Time (GMT). Probably local though.&n;&t; */
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;rtc_time&bslash;t: %02d:%02d:%02d&bslash;n&quot;
l_string|&quot;rtc_date&bslash;t: %04d-%02d-%02d&bslash;n&quot;
comma
id|tm.tm_hour
comma
id|tm.tm_min
comma
id|tm.tm_sec
comma
id|tm.tm_year
op_plus
l_int|1900
comma
id|tm.tm_mon
op_plus
l_int|1
comma
id|tm.tm_mday
)paren
suffix:semicolon
id|get_rtc_alm_time
c_func
(paren
op_amp
id|tm
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We implicitly assume 24hr mode here. Alarm values &gt;= 0xc0 will&n;&t; * match any value for that particular field. Values that are&n;&t; * greater than a valid time, but less than 0xc0 shouldn&squot;t appear.&n;&t; */
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;alarm&bslash;t&bslash;t: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tm.tm_hour
op_le
l_int|24
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%02d:&quot;
comma
id|tm.tm_hour
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;**:&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tm.tm_min
op_le
l_int|59
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%02d:&quot;
comma
id|tm.tm_min
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;**:&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tm.tm_sec
op_le
l_int|59
)paren
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;%02d&bslash;n&quot;
comma
id|tm.tm_sec
)paren
suffix:semicolon
r_else
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;**&bslash;n&quot;
)paren
suffix:semicolon
id|p
op_add_assign
id|sprintf
c_func
(paren
id|p
comma
l_string|&quot;DST_enable&bslash;t: %s&bslash;n&quot;
l_string|&quot;BCD&bslash;t&bslash;t: %s&bslash;n&quot;
l_string|&quot;24hr&bslash;t&bslash;t: %s&bslash;n&quot;
l_string|&quot;square_wave&bslash;t: %s&bslash;n&quot;
l_string|&quot;alarm_IRQ&bslash;t: %s&bslash;n&quot;
l_string|&quot;update_IRQ&bslash;t: %s&bslash;n&quot;
l_string|&quot;periodic_IRQ&bslash;t: %s&bslash;n&quot;
l_string|&quot;periodic_freq&bslash;t: %ld&bslash;n&quot;
l_string|&quot;batt_status&bslash;t: %s&bslash;n&quot;
comma
(paren
id|ctrl
op_amp
id|RTC_DST_EN
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
(paren
id|ctrl
op_amp
id|RTC_DM_BINARY
)paren
ques
c_cond
l_string|&quot;no&quot;
suffix:colon
l_string|&quot;yes&quot;
comma
(paren
id|ctrl
op_amp
id|RTC_24H
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
(paren
id|ctrl
op_amp
id|RTC_SQWE
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
(paren
id|ctrl
op_amp
id|RTC_AIE
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
(paren
id|ctrl
op_amp
id|RTC_UIE
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
(paren
id|ctrl
op_amp
id|RTC_PIE
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
comma
id|rtc_freq
comma
id|batt
ques
c_cond
l_string|&quot;okay&quot;
suffix:colon
l_string|&quot;dead&quot;
)paren
suffix:semicolon
r_return
id|p
op_minus
id|buf
suffix:semicolon
)brace
multiline_comment|/*&n; * Returns true if a clock update is in progress&n; */
DECL|function|rtc_is_updating
r_static
r_inline
r_int
r_char
id|rtc_is_updating
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|uip
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|uip
op_assign
(paren
id|CMOS_READ
c_func
(paren
id|RTC_FREQ_SELECT
)paren
op_amp
id|RTC_UIP
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|uip
suffix:semicolon
)brace
DECL|function|get_rtc_time
r_void
id|get_rtc_time
c_func
(paren
r_struct
id|rtc_time
op_star
id|rtc_tm
)paren
(brace
r_int
r_int
id|flags
comma
id|uip_watchdog
op_assign
id|jiffies
suffix:semicolon
r_int
r_char
id|ctrl
suffix:semicolon
multiline_comment|/*&n;&t; * read RTC once any update in progress is done. The update&n;&t; * can take just over 2ms. We wait 10 to 20ms. There is no need to&n;&t; * to poll-wait (up to 1s - eeccch) for the falling edge of RTC_UIP.&n;&t; * If you need to know *exactly* when a second has started, enable&n;&t; * periodic update complete interrupts, (via ioctl) and then &n;&t; * immediately read /dev/rtc which will block until you get the IRQ.&n;&t; * Once the read clears, read the RTC time (again via ioctl). Easy.&n;&t; */
r_if
c_cond
(paren
id|rtc_is_updating
c_func
(paren
)paren
op_ne
l_int|0
)paren
r_while
c_loop
(paren
id|jiffies
op_minus
id|uip_watchdog
OL
l_int|2
op_star
id|HZ
op_div
l_int|100
)paren
id|barrier
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Only the values that we read from the RTC are set. We leave&n;&t; * tm_wday, tm_yday and tm_isdst untouched. Even though the&n;&t; * RTC has RTC_DAY_OF_WEEK, we ignore it, as it is only updated&n;&t; * by the RTC when initially set to a non-zero value.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|rtc_tm-&gt;tm_sec
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_SECONDS
)paren
suffix:semicolon
id|rtc_tm-&gt;tm_min
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_MINUTES
)paren
suffix:semicolon
id|rtc_tm-&gt;tm_hour
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_HOURS
)paren
suffix:semicolon
id|rtc_tm-&gt;tm_mday
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_DAY_OF_MONTH
)paren
suffix:semicolon
id|rtc_tm-&gt;tm_mon
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_MONTH
)paren
suffix:semicolon
id|rtc_tm-&gt;tm_year
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_YEAR
)paren
suffix:semicolon
id|ctrl
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctrl
op_amp
id|RTC_DM_BINARY
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
(brace
id|BCD_TO_BIN
c_func
(paren
id|rtc_tm-&gt;tm_sec
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|rtc_tm-&gt;tm_min
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|rtc_tm-&gt;tm_hour
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|rtc_tm-&gt;tm_mday
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|rtc_tm-&gt;tm_mon
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|rtc_tm-&gt;tm_year
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Account for differences between how the RTC uses the values&n;&t; * and how they are defined in a struct rtc_time;&n;&t; */
r_if
c_cond
(paren
id|rtc_tm-&gt;tm_year
op_le
l_int|69
)paren
id|rtc_tm-&gt;tm_year
op_add_assign
l_int|100
suffix:semicolon
multiline_comment|/* if ARCFUDGE == 0, the optimizer should do away with this */
id|rtc_tm-&gt;tm_year
op_sub_assign
id|ARCFUDGE
suffix:semicolon
id|rtc_tm-&gt;tm_mon
op_decrement
suffix:semicolon
)brace
DECL|function|get_rtc_alm_time
r_void
id|get_rtc_alm_time
c_func
(paren
r_struct
id|rtc_time
op_star
id|alm_tm
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|ctrl
suffix:semicolon
multiline_comment|/*&n;&t; * Only the values that we read from the RTC are set. That&n;&t; * means only tm_hour, tm_min, and tm_sec.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|alm_tm-&gt;tm_sec
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_SECONDS_ALARM
)paren
suffix:semicolon
id|alm_tm-&gt;tm_min
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_MINUTES_ALARM
)paren
suffix:semicolon
id|alm_tm-&gt;tm_hour
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_HOURS_ALARM
)paren
suffix:semicolon
id|ctrl
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ctrl
op_amp
id|RTC_DM_BINARY
)paren
op_logical_or
id|RTC_ALWAYS_BCD
)paren
(brace
id|BCD_TO_BIN
c_func
(paren
id|alm_tm-&gt;tm_sec
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|alm_tm-&gt;tm_min
)paren
suffix:semicolon
id|BCD_TO_BIN
c_func
(paren
id|alm_tm-&gt;tm_hour
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Used to disable/enable interrupts for any one of UIE, AIE, PIE.&n; * Rumour has it that if you frob the interrupt enable/disable&n; * bits in RTC_CONTROL, you should read RTC_INTR_FLAGS, to&n; * ensure you actually start getting interrupts. Probably for&n; * compatibility with older/broken chipset RTC implementations.&n; * We also clear out any old irq data after an ioctl() that&n; * meddles with the interrupt enable/disable bits.&n; */
DECL|function|mask_rtc_irq_bit
r_void
id|mask_rtc_irq_bit
c_func
(paren
r_int
r_char
id|bit
)paren
(brace
r_int
r_char
id|val
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|val
op_and_assign
op_complement
id|bit
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|val
comma
id|RTC_CONTROL
)paren
suffix:semicolon
id|CMOS_READ
c_func
(paren
id|RTC_INTR_FLAGS
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|set_rtc_irq_bit
r_void
id|set_rtc_irq_bit
c_func
(paren
r_int
r_char
id|bit
)paren
(brace
r_int
r_char
id|val
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|val
op_assign
id|CMOS_READ
c_func
(paren
id|RTC_CONTROL
)paren
suffix:semicolon
id|val
op_or_assign
id|bit
suffix:semicolon
id|CMOS_WRITE
c_func
(paren
id|val
comma
id|RTC_CONTROL
)paren
suffix:semicolon
id|CMOS_READ
c_func
(paren
id|RTC_INTR_FLAGS
)paren
suffix:semicolon
id|rtc_irq_data
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
eof
