multiline_comment|/*&n;&n; &n;&t;Copyright (C) 1996  Digi International.&n; &n;&t;For technical support please email digiLinux@dgii.com or&n;&t;call Digi tech support at (612) 912-3456&n;&n;&t;Much of this design and code came from epca.c which was &n;&t;copyright (C) 1994, 1995 Troy De Jongh, and subsquently &n;&t;modified by David Nugent, Christoph Lameter, Mike McLagan. &n; &n; &t;This program is free software; you can redistribute it and/or modify&n; &t;it under the terms of the GNU General Public License as published by&n; &t;the Free Software Foundation; either version 2 of the License, or&n; &t;(at your option) any later version.&n;&n; &t;This program is distributed in the hope that it will be useful,&n; &t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n; &t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; &t;GNU General Public License for more details.&n;&n; &t;You should have received a copy of the GNU General Public License&n; &t;along with this program; if not, write to the Free Software&n; &t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;--------------------------------------------------------------------------- */
multiline_comment|/* See README.epca for change history --DAT*/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#ifdef CONFIG_PCI
DECL|macro|ENABLE_PCI
mdefine_line|#define ENABLE_PCI
macro_line|#endif /* CONFIG_PCI */
DECL|macro|putUser
mdefine_line|#define putUser(arg1, arg2) put_user(arg1, (unsigned long *)arg2)
DECL|macro|getUser
mdefine_line|#define getUser(arg1, arg2) get_user(arg1, (unsigned int *)arg2)
macro_line|#ifdef ENABLE_PCI
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &quot;digiPCI.h&quot;
macro_line|#endif /* ENABLE_PCI */
macro_line|#include &quot;digi1.h&quot;
macro_line|#include &quot;digiFep1.h&quot;
macro_line|#include &quot;epca.h&quot;
macro_line|#include &quot;epcaconfig.h&quot;
multiline_comment|/* ---------------------- Begin defines ------------------------ */
DECL|macro|VERSION
mdefine_line|#define VERSION            &quot;1.3.0.1-LK&quot;
multiline_comment|/* This major needs to be submitted to Linux to join the majors list */
DECL|macro|DIGIINFOMAJOR
mdefine_line|#define DIGIINFOMAJOR       35  /* For Digi specific ioctl */ 
DECL|macro|MIN
mdefine_line|#define MIN(a,b)&t;((a) &lt; (b) ? (a) : (b))
DECL|macro|MAXCARDS
mdefine_line|#define MAXCARDS 7
DECL|macro|epcaassert
mdefine_line|#define epcaassert(x, msg)  if (!(x)) epca_error(__LINE__, msg)
DECL|macro|PFX
mdefine_line|#define PFX &quot;epca: &quot;
multiline_comment|/* ----------------- Begin global definitions ------------------- */
DECL|variable|mesg
r_static
r_char
id|mesg
(braket
l_int|100
)braket
suffix:semicolon
DECL|variable|pc_refcount
DECL|variable|nbdevs
DECL|variable|num_cards
DECL|variable|liloconfig
r_static
r_int
id|pc_refcount
comma
id|nbdevs
comma
id|num_cards
comma
id|liloconfig
suffix:semicolon
DECL|variable|digi_poller_inhibited
r_static
r_int
id|digi_poller_inhibited
op_assign
l_int|1
suffix:semicolon
DECL|variable|setup_error_code
r_static
r_int
id|setup_error_code
suffix:semicolon
DECL|variable|invalid_lilo_config
r_static
r_int
id|invalid_lilo_config
suffix:semicolon
multiline_comment|/* -----------------------------------------------------------------------&n;&t;MAXBOARDS is typically 12, but ISA and EISA cards are restricted to &n;&t;7 below.&n;--------------------------------------------------------------------------*/
DECL|variable|boards
r_static
r_struct
id|board_info
id|boards
(braket
id|MAXBOARDS
)braket
suffix:semicolon
multiline_comment|/* ------------- Begin structures used for driver registeration ---------- */
DECL|variable|pc_driver
r_struct
id|tty_driver
id|pc_driver
suffix:semicolon
DECL|variable|pc_callout
r_struct
id|tty_driver
id|pc_callout
suffix:semicolon
DECL|variable|pc_info
r_struct
id|tty_driver
id|pc_info
suffix:semicolon
multiline_comment|/* The below structures are used to initialize the tty_driver structures. */
multiline_comment|/*&t;-------------------------------------------------------------------------&n;&t;Note : MAX_ALLOC is currently limited to 0x100.  This restriction is &n;&t;placed on us by Linux not Digi.&n;----------------------------------------------------------------------------*/
DECL|variable|pc_table
r_static
r_struct
id|tty_struct
op_star
id|pc_table
(braket
id|MAX_ALLOC
)braket
suffix:semicolon
DECL|variable|pc_termios
r_static
r_struct
id|termios
op_star
id|pc_termios
(braket
id|MAX_ALLOC
)braket
suffix:semicolon
DECL|variable|pc_termios_locked
r_static
r_struct
id|termios
op_star
id|pc_termios_locked
(braket
id|MAX_ALLOC
)braket
suffix:semicolon
multiline_comment|/* ------------------ Begin Digi specific structures -------------------- */
multiline_comment|/* ------------------------------------------------------------------------&n;&t;digi_channels represents an array of structures that keep track of&n;&t;each channel of the Digi product.  Information such as transmit and&n;&t;receive pointers, termio data, and signal definitions (DTR, CTS, etc ...)&n;&t;are stored here.  This structure is NOT used to overlay the cards &n;&t;physical channel structure.&n;-------------------------------------------------------------------------- */
DECL|variable|digi_channels
r_static
r_struct
id|channel
id|digi_channels
(braket
id|MAX_ALLOC
)braket
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------------&n;&t;card_ptr is an array used to hold the address of the&n;&t;first channel structure of each card.  This array will hold&n;&t;the addresses of various channels located in digi_channels.&n;-------------------------------------------------------------------------- */
DECL|variable|card_ptr
r_static
r_struct
id|channel
op_star
id|card_ptr
(braket
id|MAXCARDS
)braket
suffix:semicolon
DECL|variable|epca_timer
r_static
r_struct
id|timer_list
id|epca_timer
suffix:semicolon
multiline_comment|/* ---------------------- Begin function prototypes --------------------- */
multiline_comment|/* ----------------------------------------------------------------------&n;&t;Begin generic memory functions.  These functions will be alias&n;&t;(point at) more specific functions dependent on the board being&n;&t;configured.&n;----------------------------------------------------------------------- */
macro_line|#ifdef MODULE
r_int
id|init_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* MODULE */
r_static
r_inline
r_void
id|memwinon
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
suffix:semicolon
r_static
r_inline
r_void
id|memwinoff
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
suffix:semicolon
r_static
r_inline
r_void
id|globalwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|rxwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|txwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|memoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|assertgwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|assertmemoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
multiline_comment|/* ---- Begin more &squot;specific&squot; memory functions for cx_like products --- */
r_static
r_inline
r_void
id|pcxem_memwinon
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxem_memwinoff
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxem_globalwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxem_rxwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxem_txwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxem_memoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
multiline_comment|/* ------ Begin more &squot;specific&squot; memory functions for the pcxe ------- */
r_static
r_inline
r_void
id|pcxe_memwinon
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxe_memwinoff
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxe_globalwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxe_rxwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxe_txwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxe_memoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
multiline_comment|/* ---- Begin more &squot;specific&squot; memory functions for the pc64xe and pcxi ---- */
multiline_comment|/* Note : pc64xe and pcxi share the same windowing routines */
r_static
r_inline
r_void
id|pcxi_memwinon
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxi_memwinoff
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxi_globalwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxi_rxwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxi_txwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pcxi_memoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
multiline_comment|/* - Begin &squot;specific&squot; do nothing memory functions needed for some cards - */
r_static
r_inline
r_void
id|dummy_memwinon
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
suffix:semicolon
r_static
r_inline
r_void
id|dummy_memwinoff
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
suffix:semicolon
r_static
r_inline
r_void
id|dummy_globalwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|dummy_rxwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|dummy_txwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|dummy_memoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|dummy_assertgwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_static
r_inline
r_void
id|dummy_assertmemoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
multiline_comment|/* ------------------- Begin declare functions ----------------------- */
r_static
r_inline
r_struct
id|channel
op_star
id|verifyChannel
c_func
(paren
r_register
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_inline
r_void
id|pc_sched_event
c_func
(paren
r_struct
id|channel
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|epca_error
c_func
(paren
r_int
comma
r_char
op_star
)paren
suffix:semicolon
r_static
r_void
id|pc_close
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_void
id|shutdown
c_func
(paren
r_struct
id|channel
op_star
)paren
suffix:semicolon
r_static
r_void
id|pc_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_void
id|pc_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_int
r_char
)paren
suffix:semicolon
r_static
r_int
id|pc_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_int
id|pc_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_void
id|pc_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_void
id|pc_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_int
id|block_til_ready
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
comma
r_struct
id|channel
op_star
)paren
suffix:semicolon
r_static
r_int
id|pc_open
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_void
id|post_fep_init
c_func
(paren
r_int
r_int
id|crd
)paren
suffix:semicolon
r_static
r_void
id|epcapoll
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|doevent
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|fepcmd
c_func
(paren
r_struct
id|channel
op_star
comma
r_int
comma
r_int
comma
r_int
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|termios2digi_h
c_func
(paren
r_struct
id|channel
op_star
id|ch
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|termios2digi_i
c_func
(paren
r_struct
id|channel
op_star
id|ch
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|termios2digi_c
c_func
(paren
r_struct
id|channel
op_star
id|ch
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|epcaparam
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|channel
op_star
)paren
suffix:semicolon
r_static
r_void
id|receive_data
c_func
(paren
r_struct
id|channel
op_star
)paren
suffix:semicolon
r_static
r_int
id|pc_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|pc_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|termios
op_star
)paren
suffix:semicolon
r_static
r_void
id|do_softint
c_func
(paren
r_void
op_star
)paren
suffix:semicolon
r_static
r_void
id|pc_stop
c_func
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_void
id|pc_start
c_func
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_void
id|pc_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|pc_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|digi_send_break
c_func
(paren
r_struct
id|channel
op_star
id|ch
comma
r_int
id|msec
)paren
suffix:semicolon
r_static
r_void
id|setup_empty_event
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|channel
op_star
id|ch
)paren
suffix:semicolon
r_void
id|epca_setup
c_func
(paren
r_char
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_void
id|console_print
c_func
(paren
r_const
r_char
op_star
)paren
suffix:semicolon
r_static
r_int
id|get_termio
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|termio
op_star
)paren
suffix:semicolon
r_static
r_int
id|pc_write
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_int
comma
r_const
r_int
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_int
id|pc_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef ENABLE_PCI
r_static
r_int
id|init_PCI
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif /* ENABLE_PCI */
multiline_comment|/* ------------------------------------------------------------------&n;&t;Table of functions for each board to handle memory.  Mantaining &n;&t;parallelism is a *very* good idea here.  The idea is for the &n;&t;runtime code to blindly call these functions, not knowing/caring    &n;&t;about the underlying hardware.  This stuff should contain no&n;&t;conditionals; if more functionality is needed a different entry&n;&t;should be established.  These calls are the interface calls and &n;&t;are the only functions that should be accessed.  Anyone caught&n;&t;making direct calls deserves what they get.&n;-------------------------------------------------------------------- */
DECL|function|memwinon
r_static
r_inline
r_void
id|memwinon
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
(brace
(paren
id|b-&gt;memwinon
)paren
(paren
id|b
comma
id|win
)paren
suffix:semicolon
)brace
DECL|function|memwinoff
r_static
r_inline
r_void
id|memwinoff
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
(brace
(paren
id|b-&gt;memwinoff
)paren
(paren
id|b
comma
id|win
)paren
suffix:semicolon
)brace
DECL|function|globalwinon
r_static
r_inline
r_void
id|globalwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
(paren
id|ch-&gt;board-&gt;globalwinon
)paren
(paren
id|ch
)paren
suffix:semicolon
)brace
DECL|function|rxwinon
r_static
r_inline
r_void
id|rxwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
(paren
id|ch-&gt;board-&gt;rxwinon
)paren
(paren
id|ch
)paren
suffix:semicolon
)brace
DECL|function|txwinon
r_static
r_inline
r_void
id|txwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
(paren
id|ch-&gt;board-&gt;txwinon
)paren
(paren
id|ch
)paren
suffix:semicolon
)brace
DECL|function|memoff
r_static
r_inline
r_void
id|memoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
(paren
id|ch-&gt;board-&gt;memoff
)paren
(paren
id|ch
)paren
suffix:semicolon
)brace
DECL|function|assertgwinon
r_static
r_inline
r_void
id|assertgwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
(paren
id|ch-&gt;board-&gt;assertgwinon
)paren
(paren
id|ch
)paren
suffix:semicolon
)brace
DECL|function|assertmemoff
r_static
r_inline
r_void
id|assertmemoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
(paren
id|ch-&gt;board-&gt;assertmemoff
)paren
(paren
id|ch
)paren
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------&n;&t;PCXEM windowing is the same as that used in the PCXR &n;&t;and CX series cards.&n;------------------------------------------------------------ */
DECL|function|pcxem_memwinon
r_static
r_inline
r_void
id|pcxem_memwinon
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
(brace
id|outb_p
c_func
(paren
id|FEPWIN
op_or
id|win
comma
(paren
r_int
)paren
id|b-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|pcxem_memwinoff
r_static
r_inline
r_void
id|pcxem_memwinoff
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
(brace
id|outb_p
c_func
(paren
l_int|0
comma
(paren
r_int
)paren
id|b-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|pcxem_globalwinon
r_static
r_inline
r_void
id|pcxem_globalwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
id|outb_p
c_func
(paren
id|FEPWIN
comma
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|pcxem_rxwinon
r_static
r_inline
r_void
id|pcxem_rxwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
id|outb_p
c_func
(paren
id|ch-&gt;rxwin
comma
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|pcxem_txwinon
r_static
r_inline
r_void
id|pcxem_txwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
id|outb_p
c_func
(paren
id|ch-&gt;txwin
comma
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|pcxem_memoff
r_static
r_inline
r_void
id|pcxem_memoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
id|outb_p
c_func
(paren
l_int|0
comma
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* ----------------- Begin pcxe memory window stuff ------------------ */
DECL|function|pcxe_memwinon
r_static
r_inline
r_void
id|pcxe_memwinon
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
(brace
id|outb_p
c_func
(paren
id|FEPWIN
op_or
id|win
comma
(paren
r_int
)paren
id|b-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|pcxe_memwinoff
r_static
r_inline
r_void
id|pcxe_memwinoff
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
(brace
id|outb_p
c_func
(paren
id|inb
c_func
(paren
(paren
r_int
)paren
id|b-&gt;port
)paren
op_amp
op_complement
id|FEPMEM
comma
(paren
r_int
)paren
id|b-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
(paren
r_int
)paren
id|b-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|pcxe_globalwinon
r_static
r_inline
r_void
id|pcxe_globalwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
id|outb_p
c_func
(paren
id|FEPWIN
comma
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|pcxe_rxwinon
r_static
r_inline
r_void
id|pcxe_rxwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
id|outb_p
c_func
(paren
id|ch-&gt;rxwin
comma
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|pcxe_txwinon
r_static
r_inline
r_void
id|pcxe_txwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
id|outb_p
c_func
(paren
id|ch-&gt;txwin
comma
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|pcxe_memoff
r_static
r_inline
r_void
id|pcxe_memoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
id|outb_p
c_func
(paren
l_int|0
comma
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
op_plus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* ------------- Begin pc64xe and pcxi memory window stuff -------------- */
DECL|function|pcxi_memwinon
r_static
r_inline
r_void
id|pcxi_memwinon
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
(brace
id|outb_p
c_func
(paren
id|inb
c_func
(paren
(paren
r_int
)paren
id|b-&gt;port
)paren
op_or
id|FEPMEM
comma
(paren
r_int
)paren
id|b-&gt;port
)paren
suffix:semicolon
)brace
DECL|function|pcxi_memwinoff
r_static
r_inline
r_void
id|pcxi_memwinoff
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
(brace
id|outb_p
c_func
(paren
id|inb
c_func
(paren
(paren
r_int
)paren
id|b-&gt;port
)paren
op_amp
op_complement
id|FEPMEM
comma
(paren
r_int
)paren
id|b-&gt;port
)paren
suffix:semicolon
)brace
DECL|function|pcxi_globalwinon
r_static
r_inline
r_void
id|pcxi_globalwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
id|outb_p
c_func
(paren
id|FEPMEM
comma
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
)paren
suffix:semicolon
)brace
DECL|function|pcxi_rxwinon
r_static
r_inline
r_void
id|pcxi_rxwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
id|outb_p
c_func
(paren
id|FEPMEM
comma
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
)paren
suffix:semicolon
)brace
DECL|function|pcxi_txwinon
r_static
r_inline
r_void
id|pcxi_txwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
id|outb_p
c_func
(paren
id|FEPMEM
comma
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
)paren
suffix:semicolon
)brace
DECL|function|pcxi_memoff
r_static
r_inline
r_void
id|pcxi_memoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
id|outb_p
c_func
(paren
l_int|0
comma
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
)paren
suffix:semicolon
)brace
DECL|function|pcxi_assertgwinon
r_static
r_inline
r_void
id|pcxi_assertgwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
id|epcaassert
c_func
(paren
id|inb
c_func
(paren
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
)paren
op_amp
id|FEPMEM
comma
l_string|&quot;Global memory off&quot;
)paren
suffix:semicolon
)brace
DECL|function|pcxi_assertmemoff
r_static
r_inline
r_void
id|pcxi_assertmemoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
id|epcaassert
c_func
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
(paren
r_int
)paren
id|ch-&gt;board-&gt;port
)paren
op_amp
id|FEPMEM
)paren
comma
l_string|&quot;Memory on&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* ----------------------------------------------------------------------&n;&t;Not all of the cards need specific memory windowing routines.  Some&n;&t;cards (Such as PCI) needs no windowing routines at all.  We provide&n;&t;these do nothing routines so that the same code base can be used.&n;&t;The driver will ALWAYS call a windowing routine if it thinks it needs&n;&t;to; regardless of the card.  However, dependent on the card the routine&n;&t;may or may not do anything.&n;---------------------------------------------------------------------------*/
DECL|function|dummy_memwinon
r_static
r_inline
r_void
id|dummy_memwinon
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
(brace
)brace
DECL|function|dummy_memwinoff
r_static
r_inline
r_void
id|dummy_memwinoff
c_func
(paren
r_struct
id|board_info
op_star
id|b
comma
r_int
r_int
id|win
)paren
(brace
)brace
DECL|function|dummy_globalwinon
r_static
r_inline
r_void
id|dummy_globalwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
)brace
DECL|function|dummy_rxwinon
r_static
r_inline
r_void
id|dummy_rxwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
)brace
DECL|function|dummy_txwinon
r_static
r_inline
r_void
id|dummy_txwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
)brace
DECL|function|dummy_memoff
r_static
r_inline
r_void
id|dummy_memoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
)brace
DECL|function|dummy_assertgwinon
r_static
r_inline
r_void
id|dummy_assertgwinon
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
)brace
DECL|function|dummy_assertmemoff
r_static
r_inline
r_void
id|dummy_assertmemoff
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
)brace
multiline_comment|/* ----------------- Begin verifyChannel function ----------------------- */
DECL|function|verifyChannel
r_static
r_inline
r_struct
id|channel
op_star
id|verifyChannel
c_func
(paren
r_register
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* Begin verifyChannel */
multiline_comment|/* --------------------------------------------------------------------&n;&t;&t;This routine basically provides a sanity check.  It insures that&n;&t;&t;the channel returned is within the proper range of addresses as&n;&t;&t;well as properly initialized.  If some bogus info gets passed in&n;&t;&t;through tty-&gt;driver_data this should catch it.&n;&t;--------------------------------------------------------------------- */
r_if
c_cond
(paren
id|tty
)paren
(brace
multiline_comment|/* Begin if tty */
r_register
r_struct
id|channel
op_star
id|ch
op_assign
(paren
r_struct
id|channel
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch
op_ge
op_amp
id|digi_channels
(braket
l_int|0
)braket
)paren
op_logical_and
(paren
id|ch
OL
op_amp
id|digi_channels
(braket
id|nbdevs
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
id|ch-&gt;magic
op_eq
id|EPCA_MAGIC
)paren
r_return
id|ch
suffix:semicolon
)brace
)brace
multiline_comment|/* End if tty */
multiline_comment|/* Else return a NULL for invalid */
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* End verifyChannel */
multiline_comment|/* ------------------ Begin pc_sched_event ------------------------- */
DECL|function|pc_sched_event
r_static
r_inline
r_void
id|pc_sched_event
c_func
(paren
r_struct
id|channel
op_star
id|ch
comma
r_int
id|event
)paren
(brace
multiline_comment|/* Begin pc_sched_event */
multiline_comment|/* ----------------------------------------------------------------------&n;&t;&t;We call this to schedule interrupt processing on some event.  The &n;&t;&t;kernel sees our request and calls the related routine in OUR driver.&n;&t;-------------------------------------------------------------------------*/
id|ch-&gt;event
op_or_assign
l_int|1
op_lshift
id|event
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|schedule_task
c_func
(paren
op_amp
id|ch-&gt;tqueue
)paren
op_eq
l_int|0
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/* End pc_sched_event */
multiline_comment|/* ------------------ Begin epca_error ------------------------- */
DECL|function|epca_error
r_static
r_void
id|epca_error
c_func
(paren
r_int
id|line
comma
r_char
op_star
id|msg
)paren
(brace
multiline_comment|/* Begin epca_error */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;epca_error (Digi): line = %d %s&bslash;n&quot;
comma
id|line
comma
id|msg
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* End epca_error */
multiline_comment|/* ------------------ Begin pc_close ------------------------- */
DECL|function|pc_close
r_static
r_void
id|pc_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
multiline_comment|/* Begin pc_close */
r_struct
id|channel
op_star
id|ch
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_INFO
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------&n;&t;&t;verifyChannel returns the channel from the tty struct&n;&t;&t;if it is valid.  This serves as a sanity check.&n;&t;------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|verifyChannel
c_func
(paren
id|tty
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Begin if ch != NULL */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check to see if the channel is open more than once */
r_if
c_cond
(paren
id|ch-&gt;count
op_decrement
OG
l_int|1
)paren
(brace
multiline_comment|/* Begin channel is open more than once */
multiline_comment|/* -------------------------------------------------------------&n;&t;&t;&t;&t;Return without doing anything.  Someone might still be using&n;&t;&t;&t;&t;the channel.&n;&t;&t;&t;---------------------------------------------------------------- */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* End channel is open more than once */
multiline_comment|/* Port open only once go ahead with shutdown &amp; reset */
r_if
c_cond
(paren
id|ch-&gt;count
OL
l_int|0
)paren
(brace
id|ch-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------------&n;&t;&t;&t;Let the rest of the driver know the channel is being closed.&n;&t;&t;&t;This becomes important if an open is attempted before close &n;&t;&t;&t;is finished.&n;&t;&t;------------------------------------------------------------------ */
id|ch-&gt;asyncflags
op_or_assign
id|ASYNC_CLOSING
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------&n;&t;&t;&t;Save the termios structure, since this port may have&n;&t;&t;&t;separate termios for callout and dialin.&n;&t;&t;--------------------------------------------------------------- */
r_if
c_cond
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
id|ch-&gt;normal_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
id|ch-&gt;callout_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_INITIALIZED
)paren
(brace
multiline_comment|/* Setup an event to indicate when the transmit buffer empties */
id|setup_empty_event
c_func
(paren
id|tty
comma
id|ch
)paren
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|3000
)paren
suffix:semicolon
multiline_comment|/* 30 seconds timeout */
)brace
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|shutdown
c_func
(paren
id|ch
)paren
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;event
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;blocked_open
)paren
(brace
multiline_comment|/* Begin if blocked_open */
r_if
c_cond
(paren
id|ch-&gt;close_delay
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|ch-&gt;close_delay
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|ch-&gt;open_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* End if blocked_open */
id|ch-&gt;asyncflags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_INITIALIZED
op_or
id|ASYNC_CALLOUT_ACTIVE
op_or
id|ASYNC_CLOSING
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|ch-&gt;close_wait
)paren
suffix:semicolon
macro_line|#ifdef MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* End if ch != NULL */
)brace
multiline_comment|/* End pc_close */
multiline_comment|/* ------------------ Begin shutdown  ------------------------- */
DECL|function|shutdown
r_static
r_void
id|shutdown
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
multiline_comment|/* Begin shutdown */
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_volatile
r_struct
id|board_chan
op_star
id|bc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|bc
op_assign
id|ch-&gt;brdchan
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------&n;&t;&t;In order for an event to be generated on the receipt of data the&n;&t;&t;idata flag must be set. Since we are shutting down, this is not &n;&t;&t;necessary clear this flag.&n;&t;--------------------------------------------------------------------- */
r_if
c_cond
(paren
id|bc
)paren
id|bc-&gt;idata
op_assign
l_int|0
suffix:semicolon
id|tty
op_assign
id|ch-&gt;tty
suffix:semicolon
multiline_comment|/* ----------------------------------------------------------------&n;&t;   If we&squot;re a modem control device and HUPCL is on, drop RTS &amp; DTR.&n; &t;------------------------------------------------------------------ */
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
(brace
id|ch-&gt;omodem
op_and_assign
op_complement
(paren
id|ch-&gt;m_rts
op_or
id|ch-&gt;m_dtr
)paren
suffix:semicolon
id|fepcmd
c_func
(paren
id|ch
comma
id|SETMODEM
comma
l_int|0
comma
id|ch-&gt;m_dtr
op_or
id|ch-&gt;m_rts
comma
l_int|10
comma
l_int|1
)paren
suffix:semicolon
)brace
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------&n;&t;&t;The channel has officialy been closed.  The next time it is opened&n;&t;&t;it will have to reinitialized.  Set a flag to indicate this.&n;&t;---------------------------------------------------------------------- */
multiline_comment|/* Prevent future Digi programmed interrupts from coming active */
id|ch-&gt;asyncflags
op_and_assign
op_complement
id|ASYNC_INITIALIZED
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* End shutdown */
multiline_comment|/* ------------------ Begin pc_hangup  ------------------------- */
DECL|function|pc_hangup
r_static
r_void
id|pc_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* Begin pc_hangup */
r_struct
id|channel
op_star
id|ch
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------&n;&t;&t;verifyChannel returns the channel from the tty struct&n;&t;&t;if it is valid.  This serves as a sanity check.&n;&t;------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|verifyChannel
c_func
(paren
id|tty
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Begin if ch != NULL */
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|shutdown
c_func
(paren
id|ch
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|ch-&gt;count
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif /* MODULE */
id|ch-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|ch-&gt;event
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;count
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ch-&gt;asyncflags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_INITIALIZED
op_or
id|ASYNC_CALLOUT_ACTIVE
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|ch-&gt;open_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* End if ch != NULL */
)brace
multiline_comment|/* End pc_hangup */
multiline_comment|/* ------------------ Begin pc_write  ------------------------- */
DECL|function|pc_write
r_static
r_int
id|pc_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|bytesAvailable
)paren
(brace
multiline_comment|/* Begin pc_write */
r_register
r_int
r_int
id|head
comma
id|tail
suffix:semicolon
r_register
r_int
id|dataLen
suffix:semicolon
r_register
r_int
id|size
suffix:semicolon
r_register
r_int
id|amountCopied
suffix:semicolon
r_struct
id|channel
op_star
id|ch
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|remain
suffix:semicolon
r_volatile
r_struct
id|board_chan
op_star
id|bc
suffix:semicolon
multiline_comment|/* ----------------------------------------------------------------&n;&t;&t;pc_write is primarily called directly by the kernel routine&n;&t;&t;tty_write (Though it can also be called by put_char) found in&n;&t;&t;tty_io.c.  pc_write is passed a line discipline buffer where &n;&t;&t;the data to be written out is stored.  The line discipline &n;&t;&t;implementation itself is done at the kernel level and is not &n;&t;&t;brought into the driver.  &n;&t;------------------------------------------------------------------- */
multiline_comment|/* Stop users from hurting themselves on control minor */
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_INFO
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------&n;&t;&t;verifyChannel returns the channel from the tty struct&n;&t;&t;if it is valid.  This serves as a sanity check.&n;&t;------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|verifyChannel
c_func
(paren
id|tty
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Make a pointer to the channel data structure found on the board. */
id|bc
op_assign
id|ch-&gt;brdchan
suffix:semicolon
id|size
op_assign
id|ch-&gt;txbufsize
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
(brace
multiline_comment|/* Begin from_user */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/* -----------------------------------------------------------------&t;&n;&t;&t;&t;Anding against size will wrap the pointer back to its begining &n;&t;&t;&t;position if it is necessary.  This will only work if size is&n;&t;&t;&t;a power of 2 which should always be the case.  Size is determined &n;&t;&t;&t;by the cards on board FEP/OS.&n;&t;&t;-------------------------------------------------------------------- */
multiline_comment|/* head refers to the next empty location in which data may be stored */
id|head
op_assign
id|bc-&gt;tin
op_amp
(paren
id|size
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* tail refers to the next data byte to be transmitted */
id|tail
op_assign
id|bc-&gt;tout
suffix:semicolon
multiline_comment|/* Consider changing this to a do statement to make sure */
r_if
c_cond
(paren
id|tail
op_ne
id|bc-&gt;tout
)paren
id|tail
op_assign
id|bc-&gt;tout
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------&t;&n;&t;&t;&t;Anding against size will wrap the pointer back to its begining &n;&t;&t;&t;position if it is necessary.  This will only work if size is&n;&t;&t;&t;a power of 2 which should always be the case.  Size is determined &n;&t;&t;&t;by the cards on board FEP/OS.&n;&t;&t;--------------------------------------------------------------------- */
id|tail
op_and_assign
(paren
id|size
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* -----------------------------------------------------------------&n;&t;&t;&t;Two situations can affect how space in the transmit buffer&n;&t;&t;&t;is calculated.  You can have a situation where the transmit&n;&t;&t;&t;in pointer (tin) head has wrapped around and actually has a &n;&t;&t;&t;lower address than the transmit out pointer (tout) tail; or&n;&t;&t;&t;the transmit in pointer (tin) head will not be wrapped around&n;&t;&t;&t;yet, and have a higher address than the transmit out pointer&n;&t;&t;&t;(tout) tail.  Obviously space available in the transmit buffer&n;&t;&t;&t;is calculated differently for each case.&n;&n;&t;&t;&t;Example 1:&n;&t;&t;&t;&n;&t;&t;&t;Consider a 10 byte buffer where head is a pointer to the next&n;&t;&t;&t;empty location in the buffer and tail is a pointer to the next &n;&t;&t;&t;byte to transmit.  In this example head will not have wrapped &n;&t;&t;&t;around and therefore head &gt; tail.  &n;&n;&t;&t;&t;0      1      2      3      4      5      6      7      8      9   &n;&t;&t;                tail                               head&n;&n;&t;&t;&t;The above diagram shows that buffer locations 2,3,4,5 and 6 have&n;&t;&t;&t;data to be transmited, while head points at the next empty&n;&t;&t;&t;location.  To calculate how much space is available first we have&n;&t;&t;&t;to determine if the head pointer (tin) has wrapped.  To do this&n;&t;&t;&t;compare the head pointer to the tail pointer,  If head is equal&n;&t;&t;&t;or greater than tail; then it has not wrapped; and the space may&n;&t;&t;&t;be calculated by subtracting tail from head and then subtracting&n;&t;&t;&t;that value from the buffers size.  A one is subtracted from the&n;&t;&t;&t;new value to indicate how much space is available between the &n;&t;&t;&t;head pointer and end of buffer; as well as the space between the&n;&t;&t;&t;begining of the buffer and the tail.  If the head is not greater&n;&t;&t;&t;or equal to the tail this indicates that the head has wrapped&n;&t;&t;&t;around to the begining of the buffer.  To calculate the space &n;&t;&t;&t;available in this case simply subtract head from tail.  This new &n;&t;&t;&t;value minus one represents the space available betwwen the head &n;&t;&t;&t;and tail pointers.  In this example head (7) is greater than tail (2)&n;&t;&t;&t;and therefore has not wrapped around.  We find the space by first&n;&t;&t;&t;subtracting tail from head (7-2=5).  We then subtract this value&n;&t;&t;&t;from the buffer size of ten and subtract one (10-5-1=4).  The space&n;&t;&t;&t;remaining is 4 bytes. &n;&n;&t;&t;&t;Example 2:&n;&t;&t;&t;&n;&t;&t;&t;Consider a 10 byte buffer where head is a pointer to the next&n;&t;&t;&t;empty location in the buffer and tail is a pointer to the next &n;&t;&t;&t;byte to transmit.  In this example head will wrapped around and &n;&t;&t;&t;therefore head &lt; tail.  &n;&n;&t;&t;&t;0      1      2      3      4      5      6      7      8      9   &n;&t;&t;                head                               tail&n;&n;&t;&t;&t;The above diagram shows that buffer locations 7,8,9,0 and 1 have&n;&t;&t;&t;data to be transmited, while head points at the next empty&n;&t;&t;&t;location.  To find the space available we compare head to tail.  If&n;&t;&t;&t;head is not equal to, or greater than tail this indicates that head&n;&t;&t;&t;has wrapped around. In this case head (2) is not equal to, or&n;&t;&t;&t;greater than tail (7) and therefore has already wrapped around.  To&n;&t;&t;&t;calculate the available space between the two pointers we subtract&n;&t;&t;&t;head from tail (7-2=5).  We then subtract one from this new value&n;&t;&t;&t;(5-1=4).  We have 5 bytes empty remaining in the buffer.  Unlike the&n;&t;&t;&t;previous example these five bytes are located between the head and&n;&t;&t;&t;tail pointers. &n;&n;&t;&t;----------------------------------------------------------------------- */
id|dataLen
op_assign
(paren
id|head
op_ge
id|tail
)paren
ques
c_cond
(paren
id|size
op_minus
(paren
id|head
op_minus
id|tail
)paren
op_minus
l_int|1
)paren
suffix:colon
(paren
id|tail
op_minus
id|head
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* ----------------------------------------------------------------------&n;&t;&t;&t;In this case bytesAvailable has been passed into pc_write and&n;&t;&t;&t;represents the amount of data that needs to be written.  dataLen&n;&t;&t;&t;represents the amount of space available on the card.  Whichever&n;&t;&t;&t;value is smaller will be the amount actually written. &n;&t;&t;&t;bytesAvailable will then take on this newly calculated value.&n;&t;&t;---------------------------------------------------------------------- */
id|bytesAvailable
op_assign
id|MIN
c_func
(paren
id|dataLen
comma
id|bytesAvailable
)paren
suffix:semicolon
multiline_comment|/* First we read the data in from the file system into a temp buffer */
r_if
c_cond
(paren
id|bytesAvailable
)paren
(brace
multiline_comment|/* Begin bytesAvailable */
multiline_comment|/* Can the user buffer be accessed at the moment ? */
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|buf
comma
id|bytesAvailable
)paren
)paren
id|bytesAvailable
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Can&squot;t do; try again later */
r_else
multiline_comment|/* Evidently it can, began transmission */
(brace
multiline_comment|/* Begin if area verified */
multiline_comment|/* ---------------------------------------------------------------&n;&t;&t;&t;&t;&t;The below function reads data from user memory.  This routine&n;&t;&t;&t;&t;&t;can not be used in an interrupt routine. (Because it may &n;&t;&t;&t;&t;&t;generate a page fault)  It can only be called while we can the&n;&t;&t;&t;&t;&t;user context is accessible. &n;&n;&t;&t;&t;&t;&t;The prototype is :&n;&t;&t;&t;&t;&t;inline void copy_from_user(void * to, const void * from,&n;&t;&t;&t;&t;&t;                          unsigned long count);&n;&n;&t;&t;&t;&t;&t;You must include &lt;asm/segment.h&gt;&n;&t;&t;&t;&t;&t;I also think (Check hackers guide) that optimization must&n;&t;&t;&t;&t;&t;be turned ON.  (Which sounds strange to me...)&n;&t;&n;&t;&t;&t;&t;&t;Remember copy_from_user WILL generate a page fault if the&n;&t;&t;&t;&t;&t;user memory being accessed has been swapped out.  This can&n;&t;&t;&t;&t;&t;cause this routine to temporarily sleep while this page&n;&t;&t;&t;&t;&t;fault is occuring.&n;&t;&t;&t;&t;&n;&t;&t;&t;&t;----------------------------------------------------------------- */
id|copy_from_user
c_func
(paren
id|ch-&gt;tmp_buf
comma
id|buf
comma
id|bytesAvailable
)paren
suffix:semicolon
)brace
multiline_comment|/* End if area verified */
)brace
multiline_comment|/* End bytesAvailable */
multiline_comment|/* ------------------------------------------------------------------ &n;&t;&t;&t;Set buf to this address for the moment.  tmp_buf was allocated in&n;&t;&t;&t;post_fep_init.&n;&t;&t;--------------------------------------------------------------------- */
id|buf
op_assign
id|ch-&gt;tmp_buf
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* End from_user */
multiline_comment|/* All data is now local */
id|amountCopied
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|head
op_assign
id|bc-&gt;tin
op_amp
(paren
id|size
op_minus
l_int|1
)paren
suffix:semicolon
id|tail
op_assign
id|bc-&gt;tout
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_ne
id|bc-&gt;tout
)paren
id|tail
op_assign
id|bc-&gt;tout
suffix:semicolon
id|tail
op_and_assign
(paren
id|size
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&t;If head &gt;= tail, head has not wrapped around. */
r_if
c_cond
(paren
id|head
op_ge
id|tail
)paren
(brace
multiline_comment|/* Begin head has not wrapped */
multiline_comment|/* ---------------------------------------------------------------&n;&t;&t;&t;remain (much like dataLen above) represents the total amount of&n;&t;&t;&t;space available on the card for data.  Here dataLen represents&n;&t;&t;&t;the space existing between the head pointer and the end of &n;&t;&t;&t;buffer.  This is important because a memcpy cannot be told to&n;&t;&t;&t;automatically wrap around when it hits the buffer end.&n;&t;&t;------------------------------------------------------------------ */
id|dataLen
op_assign
id|size
op_minus
id|head
suffix:semicolon
id|remain
op_assign
id|size
op_minus
(paren
id|head
op_minus
id|tail
)paren
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* End head has not wrapped */
r_else
(brace
multiline_comment|/* Begin head has wrapped around */
id|remain
op_assign
id|tail
op_minus
id|head
op_minus
l_int|1
suffix:semicolon
id|dataLen
op_assign
id|remain
suffix:semicolon
)brace
multiline_comment|/* End head has wrapped around */
multiline_comment|/* -------------------------------------------------------------------&n;&t;&t;&t;Check the space on the card.  If we have more data than &n;&t;&t;&t;space; reduce the amount of data to fit the space.&n;&t;---------------------------------------------------------------------- */
id|bytesAvailable
op_assign
id|MIN
c_func
(paren
id|remain
comma
id|bytesAvailable
)paren
suffix:semicolon
id|txwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
r_while
c_loop
(paren
id|bytesAvailable
OG
l_int|0
)paren
(brace
multiline_comment|/* Begin while there is data to copy onto card */
multiline_comment|/* -----------------------------------------------------------------&n;&t;&t;&t;If head is not wrapped, the below will make sure the first &n;&t;&t;&t;data copy fills to the end of card buffer.&n;&t;&t;------------------------------------------------------------------- */
id|dataLen
op_assign
id|MIN
c_func
(paren
id|bytesAvailable
comma
id|dataLen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ch-&gt;txptr
op_plus
id|head
comma
id|buf
comma
id|dataLen
)paren
suffix:semicolon
id|buf
op_add_assign
id|dataLen
suffix:semicolon
id|head
op_add_assign
id|dataLen
suffix:semicolon
id|amountCopied
op_add_assign
id|dataLen
suffix:semicolon
id|bytesAvailable
op_sub_assign
id|dataLen
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ge
id|size
)paren
(brace
id|head
op_assign
l_int|0
suffix:semicolon
id|dataLen
op_assign
id|tail
suffix:semicolon
)brace
)brace
multiline_comment|/* End while there is data to copy onto card */
id|ch-&gt;statusflags
op_or_assign
id|TXBUSY
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|bc-&gt;tin
op_assign
id|head
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch-&gt;statusflags
op_amp
id|LOWWAIT
)paren
op_eq
l_int|0
)paren
(brace
id|ch-&gt;statusflags
op_or_assign
id|LOWWAIT
suffix:semicolon
id|bc-&gt;ilow
op_assign
l_int|1
suffix:semicolon
)brace
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|amountCopied
suffix:semicolon
)brace
multiline_comment|/* End pc_write */
multiline_comment|/* ------------------ Begin pc_put_char  ------------------------- */
DECL|function|pc_put_char
r_static
r_void
id|pc_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|c
)paren
(brace
multiline_comment|/* Begin pc_put_char */
id|pc_write
c_func
(paren
id|tty
comma
l_int|0
comma
op_amp
id|c
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* End pc_put_char */
multiline_comment|/* ------------------ Begin pc_write_room  ------------------------- */
DECL|function|pc_write_room
r_static
r_int
id|pc_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* Begin pc_write_room */
r_int
id|remain
suffix:semicolon
r_struct
id|channel
op_star
id|ch
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|head
comma
id|tail
suffix:semicolon
r_volatile
r_struct
id|board_chan
op_star
id|bc
suffix:semicolon
id|remain
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------&n;&t;&t;verifyChannel returns the channel from the tty struct&n;&t;&t;if it is valid.  This serves as a sanity check.&n;&t;------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|verifyChannel
c_func
(paren
id|tty
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|bc
op_assign
id|ch-&gt;brdchan
suffix:semicolon
id|head
op_assign
id|bc-&gt;tin
op_amp
(paren
id|ch-&gt;txbufsize
op_minus
l_int|1
)paren
suffix:semicolon
id|tail
op_assign
id|bc-&gt;tout
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_ne
id|bc-&gt;tout
)paren
id|tail
op_assign
id|bc-&gt;tout
suffix:semicolon
multiline_comment|/* Wrap tail if necessary */
id|tail
op_and_assign
(paren
id|ch-&gt;txbufsize
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|remain
op_assign
id|tail
op_minus
id|head
op_minus
l_int|1
)paren
OL
l_int|0
)paren
id|remain
op_add_assign
id|ch-&gt;txbufsize
suffix:semicolon
r_if
c_cond
(paren
id|remain
op_logical_and
(paren
id|ch-&gt;statusflags
op_amp
id|LOWWAIT
)paren
op_eq
l_int|0
)paren
(brace
id|ch-&gt;statusflags
op_or_assign
id|LOWWAIT
suffix:semicolon
id|bc-&gt;ilow
op_assign
l_int|1
suffix:semicolon
)brace
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Return how much room is left on card */
r_return
id|remain
suffix:semicolon
)brace
multiline_comment|/* End pc_write_room */
multiline_comment|/* ------------------ Begin pc_chars_in_buffer  ---------------------- */
DECL|function|pc_chars_in_buffer
r_static
r_int
id|pc_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* Begin pc_chars_in_buffer */
r_int
id|chars
suffix:semicolon
r_int
r_int
id|ctail
comma
id|head
comma
id|tail
suffix:semicolon
r_int
id|remain
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|channel
op_star
id|ch
suffix:semicolon
r_volatile
r_struct
id|board_chan
op_star
id|bc
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------&n;&t;&t;verifyChannel returns the channel from the tty struct&n;&t;&t;if it is valid.  This serves as a sanity check.&n;&t;------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|verifyChannel
c_func
(paren
id|tty
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|bc
op_assign
id|ch-&gt;brdchan
suffix:semicolon
id|tail
op_assign
id|bc-&gt;tout
suffix:semicolon
id|head
op_assign
id|bc-&gt;tin
suffix:semicolon
id|ctail
op_assign
id|ch-&gt;mailbox-&gt;cout
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_eq
id|head
op_logical_and
id|ch-&gt;mailbox-&gt;cin
op_eq
id|ctail
op_logical_and
id|bc-&gt;tbusy
op_eq
l_int|0
)paren
id|chars
op_assign
l_int|0
suffix:semicolon
r_else
(brace
multiline_comment|/* Begin if some space on the card has been used */
id|head
op_assign
id|bc-&gt;tin
op_amp
(paren
id|ch-&gt;txbufsize
op_minus
l_int|1
)paren
suffix:semicolon
id|tail
op_and_assign
(paren
id|ch-&gt;txbufsize
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*  --------------------------------------------------------------&n;&t;&t;&t;The logic here is basically opposite of the above pc_write_room&n;&t;&t;&t;here we are finding the amount of bytes in the buffer filled.&n;&t;&t;&t;Not the amount of bytes empty.&n;&t;&t;------------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|remain
op_assign
id|tail
op_minus
id|head
op_minus
l_int|1
)paren
OL
l_int|0
)paren
id|remain
op_add_assign
id|ch-&gt;txbufsize
suffix:semicolon
id|chars
op_assign
(paren
r_int
)paren
(paren
id|ch-&gt;txbufsize
op_minus
id|remain
)paren
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------  &n;&t;&t;&t;Make it possible to wakeup anything waiting for output&n;&t;&t;&t;in tty_ioctl.c, etc.&n;&n;&t;&t;&t;If not already set.  Setup an event to indicate when the&n;&t;&t;&t;transmit buffer empties &n;&t;&t;----------------------------------------------------------------- */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ch-&gt;statusflags
op_amp
id|EMPTYWAIT
)paren
)paren
id|setup_empty_event
c_func
(paren
id|tty
comma
id|ch
)paren
suffix:semicolon
)brace
multiline_comment|/* End if some space on the card has been used */
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Return number of characters residing on card. */
r_return
id|chars
suffix:semicolon
)brace
multiline_comment|/* End pc_chars_in_buffer */
multiline_comment|/* ------------------ Begin pc_flush_buffer  ---------------------- */
DECL|function|pc_flush_buffer
r_static
r_void
id|pc_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* Begin pc_flush_buffer */
r_int
r_int
id|tail
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|channel
op_star
id|ch
suffix:semicolon
r_volatile
r_struct
id|board_chan
op_star
id|bc
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------&n;&t;&t;verifyChannel returns the channel from the tty struct&n;&t;&t;if it is valid.  This serves as a sanity check.&n;&t;------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|verifyChannel
c_func
(paren
id|tty
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|bc
op_assign
id|ch-&gt;brdchan
suffix:semicolon
id|tail
op_assign
id|bc-&gt;tout
suffix:semicolon
multiline_comment|/* Have FEP move tout pointer; effectively flushing transmit buffer */
id|fepcmd
c_func
(paren
id|ch
comma
id|STOUT
comma
(paren
r_int
)paren
id|tail
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* End pc_flush_buffer */
multiline_comment|/* ------------------ Begin pc_flush_chars  ---------------------- */
DECL|function|pc_flush_chars
r_static
r_void
id|pc_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* Begin pc_flush_chars */
r_struct
id|channel
op_star
id|ch
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------&n;&t;&t;verifyChannel returns the channel from the tty struct&n;&t;&t;if it is valid.  This serves as a sanity check.&n;&t;------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|verifyChannel
c_func
(paren
id|tty
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ----------------------------------------------------------------&n;&t;&t;&t;If not already set and the transmitter is busy setup an event&n;&t;&t;&t;to indicate when the transmit empties.&n;&t;&t;------------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|ch-&gt;statusflags
op_amp
id|TXBUSY
)paren
op_logical_and
op_logical_neg
(paren
id|ch-&gt;statusflags
op_amp
id|EMPTYWAIT
)paren
)paren
id|setup_empty_event
c_func
(paren
id|tty
comma
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* End pc_flush_chars */
multiline_comment|/* ------------------ Begin block_til_ready  ---------------------- */
DECL|function|block_til_ready
r_static
r_int
id|block_til_ready
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
r_struct
id|channel
op_star
id|ch
)paren
(brace
multiline_comment|/* Begin block_til_ready */
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
id|retval
comma
id|do_clocal
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
r_if
c_cond
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_else
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* ----------------------------------------------------------------- &n;&t;&t;If the device is in the middle of being closed, then block&n;&t;&t;until it&squot;s done, and then try again.&n;&t;-------------------------------------------------------------------- */
r_if
c_cond
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_CLOSING
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|ch-&gt;close_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_else
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
multiline_comment|/* ----------------------------------------------------------------- &n;&t;   If this is a callout device, then just make sure the normal&n;&t;   device isn&squot;t being used.&n;&t;-------------------------------------------------------------------- */
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_CALLOUT
)paren
(brace
multiline_comment|/* A cud device has been opened */
r_if
c_cond
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_SESSION_LOCKOUT
)paren
op_logical_and
(paren
id|ch-&gt;session
op_ne
id|current-&gt;session
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_PGRP_LOCKOUT
)paren
op_logical_and
(paren
id|ch-&gt;pgrp
op_ne
id|current-&gt;pgrp
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|ch-&gt;asyncflags
op_or_assign
id|ASYNC_CALLOUT_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* End a cud device has been opened */
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
multiline_comment|/* ----------------------------------------------------------------- &n;&t;  &t; If non-blocking mode is set, then make the check up front&n;&t;  &t; and then exit.&n;&t;&t;-------------------------------------------------------------------- */
r_if
c_cond
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|ch-&gt;asyncflags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
(brace
r_if
c_cond
(paren
id|ch-&gt;normal_termios.c_cflag
op_amp
id|CLOCAL
)paren
id|do_clocal
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
id|do_clocal
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Block waiting for the carrier detect and the line to become free */
id|retval
op_assign
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|ch-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* We dec count so that pc_close will know when to free things */
r_if
c_cond
(paren
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
id|ch-&gt;count
op_decrement
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ch-&gt;blocked_open
op_increment
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* Begin forever while  */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
op_logical_neg
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
(brace
r_if
c_cond
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_else
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_CLOSING
)paren
op_logical_and
op_logical_neg
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|do_clocal
op_logical_or
(paren
id|ch-&gt;imodem
op_amp
id|ch-&gt;dcd
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------------&n;&t;&t;&t;Allow someone else to be scheduled.  We will occasionaly go&n;&t;&t;&t;through this loop until one of the above conditions change.&n;&t;&t;&t;The below schedule call will allow other processes to enter and&n;&t;&t;&t;prevent this loop from hogging the cpu.&n;&t;&t;------------------------------------------------------------------ */
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* End forever while  */
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|ch-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
id|ch-&gt;count
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ch-&gt;blocked_open
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|ch-&gt;asyncflags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* End block_til_ready */
multiline_comment|/* ------------------ Begin pc_open  ---------------------- */
DECL|function|pc_open
r_static
r_int
id|pc_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
multiline_comment|/* Begin pc_open */
r_struct
id|channel
op_star
id|ch
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|line
comma
id|retval
comma
id|boardnum
suffix:semicolon
r_volatile
r_struct
id|board_chan
op_star
id|bc
suffix:semicolon
r_volatile
r_int
r_int
id|head
suffix:semicolon
multiline_comment|/* Nothing &quot;real&quot; happens in open of control device */
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_INFO
)paren
(brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|line
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
suffix:semicolon
r_if
c_cond
(paren
id|line
OL
l_int|0
op_logical_or
id|line
op_ge
id|nbdevs
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - pc_open : line out of range in pc_open&bslash;n&quot;
)paren
suffix:semicolon
id|tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#ifdef MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
id|ch
op_assign
op_amp
id|digi_channels
(braket
id|line
)braket
suffix:semicolon
id|boardnum
op_assign
id|ch-&gt;boardnum
suffix:semicolon
multiline_comment|/* Check status of board configured in system.  */
multiline_comment|/* -----------------------------------------------------------------&n;&t;&t;I check to see if the epca_setup routine detected an user error.  &n;&t;&t;It might be better to put this in pc_init, but for the moment it&n;&t;&t;goes here.&n;&t;---------------------------------------------------------------------- */
r_if
c_cond
(paren
id|invalid_lilo_config
)paren
(brace
r_if
c_cond
(paren
id|setup_error_code
op_amp
id|INVALID_BOARD_TYPE
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - pc_open: Invalid board type specified in LILO command&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setup_error_code
op_amp
id|INVALID_NUM_PORTS
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - pc_open: Invalid number of ports specified in LILO command&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setup_error_code
op_amp
id|INVALID_MEM_BASE
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - pc_open: Invalid board memory address specified in LILO command&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setup_error_code
op_amp
id|INVALID_PORT_BASE
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - pc_open: Invalid board port address specified in LILO command&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setup_error_code
op_amp
id|INVALID_BOARD_STATUS
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - pc_open: Invalid board status specified in LILO command&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|setup_error_code
op_amp
id|INVALID_ALTPIN
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - pc_open: Invalid board altpin specified in LILO command&bslash;n&quot;
)paren
suffix:semicolon
id|tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Mark this device as &squot;down&squot; */
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|boardnum
op_ge
id|num_cards
)paren
op_logical_or
(paren
id|boards
(braket
id|boardnum
)braket
dot
id|status
op_eq
id|DISABLED
)paren
)paren
(brace
id|tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Mark this device as &squot;down&squot; */
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bc
op_assign
id|ch-&gt;brdchan
)paren
op_eq
l_int|0
)paren
(brace
id|tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------------&n;&t;&t;Every time a channel is opened, increment a counter.  This is &n;&t;&t;necessary because we do not wish to flush and shutdown the channel&n;&t;&t;until the last app holding the channel open, closes it.&t; &t;&n;&t;--------------------------------------------------------------------- */
id|ch-&gt;count
op_increment
suffix:semicolon
multiline_comment|/* ----------------------------------------------------------------&n;&t;&t;Set a kernel structures pointer to our local channel &n;&t;&t;structure.  This way we can get to it when passed only&n;&t;&t;a tty struct.&n;&t;------------------------------------------------------------------ */
id|tty-&gt;driver_data
op_assign
id|ch
suffix:semicolon
multiline_comment|/* ----------------------------------------------------------------&n;&t;&t;If this is the first time the channel has been opened, initialize&n;&t;&t;the tty-&gt;termios struct otherwise let pc_close handle it.&n;&t;-------------------------------------------------------------------- */
multiline_comment|/* Should this be here except for SPLIT termios ? */
r_if
c_cond
(paren
id|ch-&gt;count
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_NORMAL
)paren
op_star
id|tty-&gt;termios
op_assign
id|ch-&gt;normal_termios
suffix:semicolon
r_else
op_star
id|tty-&gt;termios
op_assign
id|ch-&gt;callout_termios
suffix:semicolon
)brace
id|ch-&gt;session
op_assign
id|current-&gt;session
suffix:semicolon
id|ch-&gt;pgrp
op_assign
id|current-&gt;pgrp
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|ch-&gt;statusflags
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Save boards current modem status */
id|ch-&gt;imodem
op_assign
id|bc-&gt;mstat
suffix:semicolon
multiline_comment|/* ----------------------------------------------------------------&n;&t;   Set receive head and tail ptrs to each other.  This indicates&n;&t;   no data available to read.&n;&t;----------------------------------------------------------------- */
id|head
op_assign
id|bc-&gt;rin
suffix:semicolon
id|bc-&gt;rout
op_assign
id|head
suffix:semicolon
multiline_comment|/* Set the channels associated tty structure */
id|ch-&gt;tty
op_assign
id|tty
suffix:semicolon
multiline_comment|/* -----------------------------------------------------------------&n;&t;&t;The below routine generally sets up parity, baud, flow control &n;&t;&t;issues, etc.... It effect both control flags and input flags.&n;&t;-------------------------------------------------------------------- */
id|epcaparam
c_func
(paren
id|tty
comma
id|ch
)paren
suffix:semicolon
id|ch-&gt;asyncflags
op_or_assign
id|ASYNC_INITIALIZED
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|retval
op_assign
id|block_til_ready
c_func
(paren
id|tty
comma
id|filp
comma
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* -------------------------------------------------------------&n;&t;&t;Set this again in case a hangup set it to zero while this &n;&t;&t;open() was waiting for the line...&n;&t;--------------------------------------------------------------- */
id|ch-&gt;tty
op_assign
id|tty
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/* Enable Digi Data events */
id|bc-&gt;idata
op_assign
l_int|1
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* End pc_open */
macro_line|#ifdef MODULE
multiline_comment|/* -------------------- Begin init_module ---------------------- */
DECL|function|init_module
r_int
id|__init
id|init_module
c_func
(paren
)paren
(brace
multiline_comment|/* Begin init_module */
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|pc_init
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* End init_module */
macro_line|#endif
macro_line|#ifdef ENABLE_PCI
DECL|variable|epca_driver
r_static
r_struct
id|pci_driver
id|epca_driver
suffix:semicolon
macro_line|#endif
macro_line|#ifdef MODULE
multiline_comment|/* -------------------- Begin cleanup_module  ---------------------- */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
)paren
(brace
multiline_comment|/* Begin cleanup_module */
r_int
id|count
comma
id|crd
suffix:semicolon
r_struct
id|board_info
op_star
id|bd
suffix:semicolon
r_struct
id|channel
op_star
id|ch
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|epca_timer
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty_unregister_driver
c_func
(paren
op_amp
id|pc_driver
)paren
)paren
op_logical_or
(paren
id|tty_unregister_driver
c_func
(paren
op_amp
id|pc_callout
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;&lt;Error&gt; - DIGI : cleanup_module failed to un-register tty driver&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|crd
op_assign
l_int|0
suffix:semicolon
id|crd
OL
id|num_cards
suffix:semicolon
id|crd
op_increment
)paren
(brace
multiline_comment|/* Begin for each card */
id|bd
op_assign
op_amp
id|boards
(braket
id|crd
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bd
)paren
(brace
multiline_comment|/* Begin sanity check */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - Digi : cleanup_module failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* End sanity check */
id|ch
op_assign
id|card_ptr
(braket
id|crd
)braket
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|bd-&gt;numports
suffix:semicolon
id|count
op_increment
comma
id|ch
op_increment
)paren
(brace
multiline_comment|/* Begin for each port */
r_if
c_cond
(paren
id|ch
)paren
(brace
r_if
c_cond
(paren
id|ch-&gt;tty
)paren
id|tty_hangup
c_func
(paren
id|ch-&gt;tty
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ch-&gt;tmp_buf
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* End for each port */
)brace
multiline_comment|/* End for each card */
macro_line|#ifdef ENABLE_PCI
id|pci_unregister_driver
(paren
op_amp
id|epca_driver
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* End cleanup_module */
macro_line|#endif /* MODULE */
multiline_comment|/* ------------------ Begin pc_init  ---------------------- */
DECL|function|pc_init
r_int
id|__init
id|pc_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Begin pc_init */
multiline_comment|/* ----------------------------------------------------------------&n;&t;&t;pc_init is called by the operating system during boot up prior to&n;&t;&t;any open calls being made.  In the older versions of Linux (Prior&n;&t;&t;to 2.0.0) an entry is made into tty_io.c.  A pointer to the last&n;&t;&t;memory location (from kernel space) used (kmem_start) is passed&n;&t;&t;to pc_init.  It is pc_inits responsibility to modify this value &n;&t;&t;for any memory that the Digi driver might need and then return&n;&t;&t;this value to the operating system.  For example if the driver&n;&t;&t;wishes to allocate 1K of kernel memory, pc_init would return &n;&t;&t;(kmem_start + 1024).  This memory (Between kmem_start and kmem_start&n;&t;&t;+ 1024) would then be available for use exclusively by the driver.  &n;&t;&t;In this case our driver does not allocate any of this kernel &n;&t;&t;memory.&n;&t;------------------------------------------------------------------*/
id|ulong
id|flags
suffix:semicolon
r_int
id|crd
suffix:semicolon
r_struct
id|board_info
op_star
id|bd
suffix:semicolon
r_int
r_char
id|board_id
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef ENABLE_PCI
r_int
id|pci_boards_found
comma
id|pci_count
suffix:semicolon
id|pci_count
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* ENABLE_PCI */
multiline_comment|/* -----------------------------------------------------------------------&n;&t;&t;If epca_setup has not been ran by LILO set num_cards to defaults; copy&n;&t;&t;board structure defined by digiConfig into drivers board structure.&n;&t;&t;Note : If LILO has ran epca_setup then epca_setup will handle defining&n;&t;&t;num_cards as well as copying the data into the board structure.&n;&t;-------------------------------------------------------------------------- */
r_if
c_cond
(paren
op_logical_neg
id|liloconfig
)paren
(brace
multiline_comment|/* Begin driver has been configured via. epcaconfig */
id|nbdevs
op_assign
id|NBDEVS
suffix:semicolon
id|num_cards
op_assign
id|NUMCARDS
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|boards
comma
(paren
r_void
op_star
)paren
op_amp
id|static_boards
comma
(paren
r_sizeof
(paren
r_struct
id|board_info
)paren
op_star
id|NUMCARDS
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* End driver has been configured via. epcaconfig */
multiline_comment|/* -----------------------------------------------------------------&n;&t;&t;Note : If lilo was used to configure the driver and the &n;&t;&t;ignore epcaconfig option was choosen (digiepca=2) then &n;&t;&t;nbdevs and num_cards will equal 0 at this point.  This is&n;&t;&t;okay; PCI cards will still be picked up if detected.&n;&t;--------------------------------------------------------------------- */
multiline_comment|/*  -----------------------------------------------------------&n;&t;&t;Set up interrupt, we will worry about memory allocation in&n;&t;&t;post_fep_init. &n;&t;--------------------------------------------------------------- */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;DIGI epca driver version %s loaded.&bslash;n&quot;
comma
id|VERSION
)paren
suffix:semicolon
macro_line|#ifdef ENABLE_PCI
multiline_comment|/* ------------------------------------------------------------------&n;&t;&t;NOTE : This code assumes that the number of ports found in &n;&t;&t;       the boards array is correct.  This could be wrong if&n;&t;&t;       the card in question is PCI (And therefore has no ports &n;&t;&t;       entry in the boards structure.)  The rest of the &n;&t;&t;       information will be valid for PCI because the begining&n;&t;&t;       of pc_init scans for PCI and determines i/o and base&n;&t;&t;       memory addresses.  I am not sure if it is possible to &n;&t;&t;       read the number of ports supported by the card prior to&n;&t;&t;       it being booted (Since that is the state it is in when &n;&t;&t;       pc_init is run).  Because it is not possible to query the&n;&t;&t;       number of supported ports until after the card has booted;&n;&t;&t;       we are required to calculate the card_ptrs as the card is&t; &n;&t;&t;       is initialized (Inside post_fep_init).  The negative thing&n;&t;&t;       about this approach is that digiDload&squot;s call to GET_INFO&n;&t;&t;       will have a bad port value.  (Since this is called prior&n;&t;&t;       to post_fep_init.)&n;&n;&t;--------------------------------------------------------------------- */
id|pci_boards_found
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pci_present
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|num_cards
OL
id|MAXBOARDS
)paren
(brace
id|pci_boards_found
op_add_assign
id|init_PCI
c_func
(paren
)paren
suffix:semicolon
)brace
id|num_cards
op_add_assign
id|pci_boards_found
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - No PCI BIOS found&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* ENABLE_PCI */
id|memset
c_func
(paren
op_amp
id|pc_driver
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pc_callout
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pc_info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|pc_driver.magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
id|pc_driver.name
op_assign
l_string|&quot;ttyD&quot;
suffix:semicolon
id|pc_driver.major
op_assign
id|DIGI_MAJOR
suffix:semicolon
id|pc_driver.minor_start
op_assign
l_int|0
suffix:semicolon
id|pc_driver.num
op_assign
id|MAX_ALLOC
suffix:semicolon
id|pc_driver.type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
id|pc_driver.subtype
op_assign
id|SERIAL_TYPE_NORMAL
suffix:semicolon
id|pc_driver.init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|pc_driver.init_termios.c_iflag
op_assign
l_int|0
suffix:semicolon
id|pc_driver.init_termios.c_oflag
op_assign
l_int|0
suffix:semicolon
id|pc_driver.init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|CLOCAL
op_or
id|HUPCL
suffix:semicolon
id|pc_driver.init_termios.c_lflag
op_assign
l_int|0
suffix:semicolon
id|pc_driver.flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
id|pc_driver.refcount
op_assign
op_amp
id|pc_refcount
suffix:semicolon
id|pc_driver.table
op_assign
id|pc_table
suffix:semicolon
multiline_comment|/* pc_termios is an array of pointers pointing at termios structs */
multiline_comment|/* The below should get the first pointer */
id|pc_driver.termios
op_assign
id|pc_termios
suffix:semicolon
id|pc_driver.termios_locked
op_assign
id|pc_termios_locked
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------&n;&t;&t;Setup entry points for the driver.  These are primarily called by &n;&t;&t;the kernel in tty_io.c and n_tty.c&n;&t;--------------------------------------------------------------------- */
id|pc_driver.open
op_assign
id|pc_open
suffix:semicolon
id|pc_driver.close
op_assign
id|pc_close
suffix:semicolon
id|pc_driver.write
op_assign
id|pc_write
suffix:semicolon
id|pc_driver.write_room
op_assign
id|pc_write_room
suffix:semicolon
id|pc_driver.flush_buffer
op_assign
id|pc_flush_buffer
suffix:semicolon
id|pc_driver.chars_in_buffer
op_assign
id|pc_chars_in_buffer
suffix:semicolon
id|pc_driver.flush_chars
op_assign
id|pc_flush_chars
suffix:semicolon
id|pc_driver.put_char
op_assign
id|pc_put_char
suffix:semicolon
id|pc_driver.ioctl
op_assign
id|pc_ioctl
suffix:semicolon
id|pc_driver.set_termios
op_assign
id|pc_set_termios
suffix:semicolon
id|pc_driver.stop
op_assign
id|pc_stop
suffix:semicolon
id|pc_driver.start
op_assign
id|pc_start
suffix:semicolon
id|pc_driver.throttle
op_assign
id|pc_throttle
suffix:semicolon
id|pc_driver.unthrottle
op_assign
id|pc_unthrottle
suffix:semicolon
id|pc_driver.hangup
op_assign
id|pc_hangup
suffix:semicolon
id|pc_callout
op_assign
id|pc_driver
suffix:semicolon
id|pc_callout.name
op_assign
l_string|&quot;cud&quot;
suffix:semicolon
id|pc_callout.major
op_assign
id|DIGICU_MAJOR
suffix:semicolon
id|pc_callout.minor_start
op_assign
l_int|0
suffix:semicolon
id|pc_callout.init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|CLOCAL
op_or
id|HUPCL
suffix:semicolon
id|pc_callout.subtype
op_assign
id|SERIAL_TYPE_CALLOUT
suffix:semicolon
id|pc_info
op_assign
id|pc_driver
suffix:semicolon
id|pc_info.name
op_assign
l_string|&quot;digi_ctl&quot;
suffix:semicolon
id|pc_info.major
op_assign
id|DIGIINFOMAJOR
suffix:semicolon
id|pc_info.minor_start
op_assign
l_int|0
suffix:semicolon
id|pc_info.num
op_assign
l_int|1
suffix:semicolon
id|pc_info.init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
suffix:semicolon
id|pc_info.subtype
op_assign
id|SERIAL_TYPE_INFO
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|crd
op_assign
l_int|0
suffix:semicolon
id|crd
OL
id|num_cards
suffix:semicolon
id|crd
op_increment
)paren
(brace
multiline_comment|/* Begin for each card */
multiline_comment|/*  ------------------------------------------------------------------&n;&t;&t;&t;This is where the appropriate memory handlers for the hardware is&n;&t;&t;&t;set.  Everything at runtime blindly jumps through these vectors.&n;&t;&t;---------------------------------------------------------------------- */
multiline_comment|/* defined in epcaconfig.h */
id|bd
op_assign
op_amp
id|boards
(braket
id|crd
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|bd-&gt;type
)paren
(brace
multiline_comment|/* Begin switch on bd-&gt;type {board type} */
r_case
id|PCXEM
suffix:colon
r_case
id|EISAXEM
suffix:colon
id|bd-&gt;memwinon
op_assign
id|pcxem_memwinon
suffix:semicolon
id|bd-&gt;memwinoff
op_assign
id|pcxem_memwinoff
suffix:semicolon
id|bd-&gt;globalwinon
op_assign
id|pcxem_globalwinon
suffix:semicolon
id|bd-&gt;txwinon
op_assign
id|pcxem_txwinon
suffix:semicolon
id|bd-&gt;rxwinon
op_assign
id|pcxem_rxwinon
suffix:semicolon
id|bd-&gt;memoff
op_assign
id|pcxem_memoff
suffix:semicolon
id|bd-&gt;assertgwinon
op_assign
id|dummy_assertgwinon
suffix:semicolon
id|bd-&gt;assertmemoff
op_assign
id|dummy_assertmemoff
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCIXEM
suffix:colon
r_case
id|PCIXRJ
suffix:colon
r_case
id|PCIXR
suffix:colon
id|bd-&gt;memwinon
op_assign
id|dummy_memwinon
suffix:semicolon
id|bd-&gt;memwinoff
op_assign
id|dummy_memwinoff
suffix:semicolon
id|bd-&gt;globalwinon
op_assign
id|dummy_globalwinon
suffix:semicolon
id|bd-&gt;txwinon
op_assign
id|dummy_txwinon
suffix:semicolon
id|bd-&gt;rxwinon
op_assign
id|dummy_rxwinon
suffix:semicolon
id|bd-&gt;memoff
op_assign
id|dummy_memoff
suffix:semicolon
id|bd-&gt;assertgwinon
op_assign
id|dummy_assertgwinon
suffix:semicolon
id|bd-&gt;assertmemoff
op_assign
id|dummy_assertmemoff
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCXE
suffix:colon
r_case
id|PCXEVE
suffix:colon
id|bd-&gt;memwinon
op_assign
id|pcxe_memwinon
suffix:semicolon
id|bd-&gt;memwinoff
op_assign
id|pcxe_memwinoff
suffix:semicolon
id|bd-&gt;globalwinon
op_assign
id|pcxe_globalwinon
suffix:semicolon
id|bd-&gt;txwinon
op_assign
id|pcxe_txwinon
suffix:semicolon
id|bd-&gt;rxwinon
op_assign
id|pcxe_rxwinon
suffix:semicolon
id|bd-&gt;memoff
op_assign
id|pcxe_memoff
suffix:semicolon
id|bd-&gt;assertgwinon
op_assign
id|dummy_assertgwinon
suffix:semicolon
id|bd-&gt;assertmemoff
op_assign
id|dummy_assertmemoff
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCXI
suffix:colon
r_case
id|PC64XE
suffix:colon
id|bd-&gt;memwinon
op_assign
id|pcxi_memwinon
suffix:semicolon
id|bd-&gt;memwinoff
op_assign
id|pcxi_memwinoff
suffix:semicolon
id|bd-&gt;globalwinon
op_assign
id|pcxi_globalwinon
suffix:semicolon
id|bd-&gt;txwinon
op_assign
id|pcxi_txwinon
suffix:semicolon
id|bd-&gt;rxwinon
op_assign
id|pcxi_rxwinon
suffix:semicolon
id|bd-&gt;memoff
op_assign
id|pcxi_memoff
suffix:semicolon
id|bd-&gt;assertgwinon
op_assign
id|pcxi_assertgwinon
suffix:semicolon
id|bd-&gt;assertmemoff
op_assign
id|pcxi_assertmemoff
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* End switch on bd-&gt;type */
multiline_comment|/* ---------------------------------------------------------------&n;&t;&t;&t;Some cards need a memory segment to be defined for use in &n;&t;&t;&t;transmit and receive windowing operations.  These boards&n;&t;&t;&t;are listed in the below switch.  In the case of the XI the&n;&t;&t;&t;amount of memory on the board is variable so the memory_seg&n;&t;&t;&t;is also variable.  This code determines what they segment &n;&t;&t;&t;should be.&n;&t;&t;----------------------------------------------------------------- */
r_switch
c_cond
(paren
id|bd-&gt;type
)paren
(brace
multiline_comment|/* Begin switch on bd-&gt;type {board type} */
r_case
id|PCXE
suffix:colon
r_case
id|PCXEVE
suffix:colon
r_case
id|PC64XE
suffix:colon
id|bd-&gt;memory_seg
op_assign
l_int|0xf000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCXI
suffix:colon
id|board_id
op_assign
id|inb
c_func
(paren
(paren
r_int
)paren
id|bd-&gt;port
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|board_id
op_amp
l_int|0x1
)paren
op_eq
l_int|0x1
)paren
(brace
multiline_comment|/* Begin its an XI card */
multiline_comment|/* Is it a 64K board */
r_if
c_cond
(paren
(paren
id|board_id
op_amp
l_int|0x30
)paren
op_eq
l_int|0
)paren
id|bd-&gt;memory_seg
op_assign
l_int|0xf000
suffix:semicolon
multiline_comment|/* Is it a 128K board */
r_if
c_cond
(paren
(paren
id|board_id
op_amp
l_int|0x30
)paren
op_eq
l_int|0x10
)paren
id|bd-&gt;memory_seg
op_assign
l_int|0xe000
suffix:semicolon
multiline_comment|/* Is is a 256K board */
r_if
c_cond
(paren
(paren
id|board_id
op_amp
l_int|0x30
)paren
op_eq
l_int|0x20
)paren
id|bd-&gt;memory_seg
op_assign
l_int|0xc000
suffix:semicolon
multiline_comment|/* Is it a 512K board */
r_if
c_cond
(paren
(paren
id|board_id
op_amp
l_int|0x30
)paren
op_eq
l_int|0x30
)paren
id|bd-&gt;memory_seg
op_assign
l_int|0x8000
suffix:semicolon
)brace
multiline_comment|/* End it is an XI card */
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - Board at 0x%x doesn&squot;t appear to be an XI&bslash;n&quot;
comma
(paren
r_int
)paren
id|bd-&gt;port
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* End switch on bd-&gt;type */
)brace
multiline_comment|/* End for each card */
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|pc_driver
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t register Digi PC/ driver&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|pc_callout
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t register Digi PC/ callout&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|pc_info
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t register Digi PC/ info &quot;
)paren
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------------&n;&t;   Start up the poller to check for events on all enabled boards&n;&t;---------------------------------------------------------------------- */
id|init_timer
c_func
(paren
op_amp
id|epca_timer
)paren
suffix:semicolon
id|epca_timer.function
op_assign
id|epcapoll
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|epca_timer
comma
id|jiffies
op_plus
id|HZ
op_div
l_int|25
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* End pc_init */
multiline_comment|/* ------------------ Begin post_fep_init  ---------------------- */
DECL|function|post_fep_init
r_static
r_void
id|post_fep_init
c_func
(paren
r_int
r_int
id|crd
)paren
(brace
multiline_comment|/* Begin post_fep_init */
r_int
id|i
suffix:semicolon
id|unchar
op_star
id|memaddr
suffix:semicolon
r_volatile
r_struct
id|global_data
op_star
id|gd
suffix:semicolon
r_struct
id|board_info
op_star
id|bd
suffix:semicolon
r_volatile
r_struct
id|board_chan
op_star
id|bc
suffix:semicolon
r_struct
id|channel
op_star
id|ch
suffix:semicolon
r_int
id|shrinkmem
op_assign
l_int|0
comma
id|lowwater
suffix:semicolon
multiline_comment|/*  -------------------------------------------------------------&n;&t;&t;This call is made by the user via. the ioctl call DIGI_INIT.&n;&t;&t;It is resposible for setting up all the card specific stuff.&n;&t;---------------------------------------------------------------- */
id|bd
op_assign
op_amp
id|boards
(braket
id|crd
)braket
suffix:semicolon
multiline_comment|/* -----------------------------------------------------------------&n;&t;&t;If this is a PCI board, get the port info.  Remember PCI cards&n;&t;&t;do not have entries into the epcaconfig.h file, so we can&squot;t get &n;&t;&t;the number of ports from it.  Unfortunetly, this means that anyone&n;&t;&t;doing a DIGI_GETINFO before the board has booted will get an invalid&n;&t;&t;number of ports returned (It should return 0).  Calls to DIGI_GETINFO&n;&t;&t;after DIGI_INIT has been called will return the proper values. &n;&t;------------------------------------------------------------------- */
r_if
c_cond
(paren
id|bd-&gt;type
op_ge
id|PCIXEM
)paren
multiline_comment|/* If the board in question is PCI */
(brace
multiline_comment|/* Begin get PCI number of ports */
multiline_comment|/* --------------------------------------------------------------------&n;&t;&t;&t;Below we use XEMPORTS as a memory offset regardless of which PCI&n;&t;&t;&t;card it is.  This is because all of the supported PCI cards have&n;&t;&t;&t;the same memory offset for the channel data.  This will have to be&n;&t;&t;&t;changed if we ever develop a PCI/XE card.  NOTE : The FEP manual&n;&t;&t;&t;states that the port offset is 0xC22 as opposed to 0xC02.  This is&n;&t;&t;&t;only true for PC/XE, and PC/XI cards; not for the XEM, or CX series.&n;&t;&t;&t;On the PCI cards the number of ports is determined by reading a &n;&t;&t;&t;ID PROM located in the box attached to the card.  The card can then&n;&t;&t;&t;determine the index the id to determine the number of ports available.&n;&t;&t;&t;(FYI - The id should be located at 0x1ac (And may use up to 4 bytes&n;&t;&t;&t;if the box in question is a XEM or CX)).  &n;&t;&t;------------------------------------------------------------------------ */
id|bd-&gt;numports
op_assign
(paren
r_int
r_int
)paren
op_star
(paren
r_int
r_char
op_star
)paren
id|bus_to_virt
c_func
(paren
(paren
r_int
r_int
)paren
(paren
id|bd-&gt;re_map_membase
op_plus
id|XEMPORTS
)paren
)paren
suffix:semicolon
id|epcaassert
c_func
(paren
id|bd-&gt;numports
op_le
l_int|64
comma
l_string|&quot;PCI returned a invalid number of ports&quot;
)paren
suffix:semicolon
id|nbdevs
op_add_assign
(paren
id|bd-&gt;numports
)paren
suffix:semicolon
)brace
multiline_comment|/* End get PCI number of ports */
r_if
c_cond
(paren
id|crd
op_ne
l_int|0
)paren
id|card_ptr
(braket
id|crd
)braket
op_assign
id|card_ptr
(braket
id|crd
op_minus
l_int|1
)braket
op_plus
id|boards
(braket
id|crd
op_minus
l_int|1
)braket
dot
id|numports
suffix:semicolon
r_else
id|card_ptr
(braket
id|crd
)braket
op_assign
op_amp
id|digi_channels
(braket
id|crd
)braket
suffix:semicolon
multiline_comment|/* &lt;- For card 0 only */
id|ch
op_assign
id|card_ptr
(braket
id|crd
)braket
suffix:semicolon
id|epcaassert
c_func
(paren
id|ch
op_le
op_amp
id|digi_channels
(braket
id|nbdevs
op_minus
l_int|1
)braket
comma
l_string|&quot;ch out of range&quot;
)paren
suffix:semicolon
id|memaddr
op_assign
(paren
id|unchar
op_star
)paren
id|bd-&gt;re_map_membase
suffix:semicolon
multiline_comment|/* &n;&t;   The below command is necessary because newer kernels (2.1.x and&n;&t;   up) do not have a 1:1 virtual to physical mapping.  The below&n;&t;   call adjust for that.&n;&t;*/
id|memaddr
op_assign
(paren
r_int
r_char
op_star
)paren
id|bus_to_virt
c_func
(paren
(paren
r_int
r_int
)paren
id|memaddr
)paren
suffix:semicolon
multiline_comment|/* -----------------------------------------------------------------&n;&t;&t;The below assignment will set bc to point at the BEGINING of&n;&t;&t;the cards channel structures.  For 1 card there will be between&n;&t;&t;8 and 64 of these structures.&n;&t;-------------------------------------------------------------------- */
id|bc
op_assign
(paren
r_volatile
r_struct
id|board_chan
op_star
)paren
(paren
(paren
id|ulong
)paren
id|memaddr
op_plus
id|CHANSTRUCT
)paren
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------------&n;&t;&t;The below assignment will set gd to point at the BEGINING of&n;&t;&t;global memory address 0xc00.  The first data in that global&n;&t;&t;memory actually starts at address 0xc1a.  The command in &n;&t;&t;pointer begins at 0xd10.&n;&t;---------------------------------------------------------------------- */
id|gd
op_assign
(paren
r_volatile
r_struct
id|global_data
op_star
)paren
(paren
(paren
id|ulong
)paren
id|memaddr
op_plus
id|GLOBAL
)paren
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------&n;&t;&t;XEPORTS (address 0xc22) points at the number of channels the&n;&t;&t;card supports. (For 64XE, XI, XEM, and XR use 0xc02)&n;&t;----------------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
(paren
id|bd-&gt;type
op_eq
id|PCXEVE
)paren
op_or
(paren
id|bd-&gt;type
op_eq
id|PCXE
)paren
)paren
op_logical_and
(paren
op_star
(paren
id|ushort
op_star
)paren
(paren
(paren
id|ulong
)paren
id|memaddr
op_plus
id|XEPORTS
)paren
OL
l_int|3
)paren
)paren
id|shrinkmem
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bd-&gt;type
OL
id|PCIXEM
)paren
id|request_region
c_func
(paren
(paren
r_int
)paren
id|bd-&gt;port
comma
l_int|4
comma
id|board_desc
(braket
id|bd-&gt;type
)braket
)paren
suffix:semicolon
id|memwinon
c_func
(paren
id|bd
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*  --------------------------------------------------------------------&n;&t;&t;Remember ch is the main drivers channels structure, while bc is &n;&t;   the cards channel structure.&n;&t;------------------------------------------------------------------------ */
multiline_comment|/* For every port on the card do ..... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bd-&gt;numports
suffix:semicolon
id|i
op_increment
comma
id|ch
op_increment
comma
id|bc
op_increment
)paren
(brace
multiline_comment|/* Begin for each port */
id|ch-&gt;brdchan
op_assign
id|bc
suffix:semicolon
id|ch-&gt;mailbox
op_assign
id|gd
suffix:semicolon
id|ch-&gt;tqueue.routine
op_assign
id|do_softint
suffix:semicolon
id|ch-&gt;tqueue.data
op_assign
id|ch
suffix:semicolon
id|ch-&gt;board
op_assign
op_amp
id|boards
(braket
id|crd
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|bd-&gt;type
)paren
(brace
multiline_comment|/* Begin switch bd-&gt;type */
multiline_comment|/* ----------------------------------------------------------------&n;&t;&t;&t;&t;Since some of the boards use different bitmaps for their&n;&t;&t;&t;&t;control signals we cannot hard code these values and retain&n;&t;&t;&t;&t;portability.  We virtualize this data here.&n;&t;&t;&t;------------------------------------------------------------------- */
r_case
id|EISAXEM
suffix:colon
r_case
id|PCXEM
suffix:colon
r_case
id|PCIXEM
suffix:colon
r_case
id|PCIXRJ
suffix:colon
r_case
id|PCIXR
suffix:colon
id|ch-&gt;m_rts
op_assign
l_int|0x02
suffix:semicolon
id|ch-&gt;m_dcd
op_assign
l_int|0x80
suffix:semicolon
id|ch-&gt;m_dsr
op_assign
l_int|0x20
suffix:semicolon
id|ch-&gt;m_cts
op_assign
l_int|0x10
suffix:semicolon
id|ch-&gt;m_ri
op_assign
l_int|0x40
suffix:semicolon
id|ch-&gt;m_dtr
op_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCXE
suffix:colon
r_case
id|PCXEVE
suffix:colon
r_case
id|PCXI
suffix:colon
r_case
id|PC64XE
suffix:colon
id|ch-&gt;m_rts
op_assign
l_int|0x02
suffix:semicolon
id|ch-&gt;m_dcd
op_assign
l_int|0x08
suffix:semicolon
id|ch-&gt;m_dsr
op_assign
l_int|0x10
suffix:semicolon
id|ch-&gt;m_cts
op_assign
l_int|0x20
suffix:semicolon
id|ch-&gt;m_ri
op_assign
l_int|0x40
suffix:semicolon
id|ch-&gt;m_dtr
op_assign
l_int|0x80
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* End switch bd-&gt;type */
r_if
c_cond
(paren
id|boards
(braket
id|crd
)braket
dot
id|altpin
)paren
(brace
id|ch-&gt;dsr
op_assign
id|ch-&gt;m_dcd
suffix:semicolon
id|ch-&gt;dcd
op_assign
id|ch-&gt;m_dsr
suffix:semicolon
id|ch-&gt;digiext.digi_flags
op_or_assign
id|DIGI_ALTPIN
suffix:semicolon
)brace
r_else
(brace
id|ch-&gt;dcd
op_assign
id|ch-&gt;m_dcd
suffix:semicolon
id|ch-&gt;dsr
op_assign
id|ch-&gt;m_dsr
suffix:semicolon
)brace
id|ch-&gt;boardnum
op_assign
id|crd
suffix:semicolon
id|ch-&gt;channelnum
op_assign
id|i
suffix:semicolon
id|ch-&gt;magic
op_assign
id|EPCA_MAGIC
suffix:semicolon
id|ch-&gt;tty
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|shrinkmem
)paren
(brace
id|fepcmd
c_func
(paren
id|ch
comma
id|SETBUFFER
comma
l_int|32
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|shrinkmem
op_assign
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|bd-&gt;type
)paren
(brace
multiline_comment|/* Begin switch bd-&gt;type */
r_case
id|PCIXEM
suffix:colon
r_case
id|PCIXRJ
suffix:colon
r_case
id|PCIXR
suffix:colon
multiline_comment|/* Cover all the 2MEG cards */
id|ch-&gt;txptr
op_assign
id|memaddr
op_plus
(paren
(paren
(paren
id|bc-&gt;tseg
)paren
op_lshift
l_int|4
)paren
op_amp
l_int|0x1fffff
)paren
suffix:semicolon
id|ch-&gt;rxptr
op_assign
id|memaddr
op_plus
(paren
(paren
(paren
id|bc-&gt;rseg
)paren
op_lshift
l_int|4
)paren
op_amp
l_int|0x1fffff
)paren
suffix:semicolon
id|ch-&gt;txwin
op_assign
id|FEPWIN
op_or
(paren
(paren
id|bc-&gt;tseg
)paren
op_rshift
l_int|11
)paren
suffix:semicolon
id|ch-&gt;rxwin
op_assign
id|FEPWIN
op_or
(paren
(paren
id|bc-&gt;rseg
)paren
op_rshift
l_int|11
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCXEM
suffix:colon
r_case
id|EISAXEM
suffix:colon
multiline_comment|/* Cover all the 32K windowed cards */
multiline_comment|/* Mask equal to window size - 1 */
id|ch-&gt;txptr
op_assign
id|memaddr
op_plus
(paren
(paren
(paren
id|bc-&gt;tseg
)paren
op_lshift
l_int|4
)paren
op_amp
l_int|0x7fff
)paren
suffix:semicolon
id|ch-&gt;rxptr
op_assign
id|memaddr
op_plus
(paren
(paren
(paren
id|bc-&gt;rseg
)paren
op_lshift
l_int|4
)paren
op_amp
l_int|0x7fff
)paren
suffix:semicolon
id|ch-&gt;txwin
op_assign
id|FEPWIN
op_or
(paren
(paren
id|bc-&gt;tseg
)paren
op_rshift
l_int|11
)paren
suffix:semicolon
id|ch-&gt;rxwin
op_assign
id|FEPWIN
op_or
(paren
(paren
id|bc-&gt;rseg
)paren
op_rshift
l_int|11
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCXEVE
suffix:colon
r_case
id|PCXE
suffix:colon
id|ch-&gt;txptr
op_assign
id|memaddr
op_plus
(paren
(paren
(paren
id|bc-&gt;tseg
op_minus
id|bd-&gt;memory_seg
)paren
op_lshift
l_int|4
)paren
op_amp
l_int|0x1fff
)paren
suffix:semicolon
id|ch-&gt;txwin
op_assign
id|FEPWIN
op_or
(paren
(paren
id|bc-&gt;tseg
op_minus
id|bd-&gt;memory_seg
)paren
op_rshift
l_int|9
)paren
suffix:semicolon
id|ch-&gt;rxptr
op_assign
id|memaddr
op_plus
(paren
(paren
(paren
id|bc-&gt;rseg
op_minus
id|bd-&gt;memory_seg
)paren
op_lshift
l_int|4
)paren
op_amp
l_int|0x1fff
)paren
suffix:semicolon
id|ch-&gt;rxwin
op_assign
id|FEPWIN
op_or
(paren
(paren
id|bc-&gt;rseg
op_minus
id|bd-&gt;memory_seg
)paren
op_rshift
l_int|9
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PCXI
suffix:colon
r_case
id|PC64XE
suffix:colon
id|ch-&gt;txptr
op_assign
id|memaddr
op_plus
(paren
(paren
id|bc-&gt;tseg
op_minus
id|bd-&gt;memory_seg
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
id|ch-&gt;rxptr
op_assign
id|memaddr
op_plus
(paren
(paren
id|bc-&gt;rseg
op_minus
id|bd-&gt;memory_seg
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
id|ch-&gt;txwin
op_assign
id|ch-&gt;rxwin
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* End switch bd-&gt;type */
id|ch-&gt;txbufhead
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;txbufsize
op_assign
id|bc-&gt;tmax
op_plus
l_int|1
suffix:semicolon
id|ch-&gt;rxbufhead
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;rxbufsize
op_assign
id|bc-&gt;rmax
op_plus
l_int|1
suffix:semicolon
id|lowwater
op_assign
id|ch-&gt;txbufsize
op_ge
l_int|2000
ques
c_cond
l_int|1024
suffix:colon
(paren
id|ch-&gt;txbufsize
op_div
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Set transmitter low water mark */
id|fepcmd
c_func
(paren
id|ch
comma
id|STXLWATER
comma
id|lowwater
comma
l_int|0
comma
l_int|10
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Set receiver low water mark */
id|fepcmd
c_func
(paren
id|ch
comma
id|SRXLWATER
comma
(paren
id|ch-&gt;rxbufsize
op_div
l_int|4
)paren
comma
l_int|0
comma
l_int|10
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Set receiver high water mark */
id|fepcmd
c_func
(paren
id|ch
comma
id|SRXHWATER
comma
(paren
l_int|3
op_star
id|ch-&gt;rxbufsize
op_div
l_int|4
)paren
comma
l_int|0
comma
l_int|10
comma
l_int|0
)paren
suffix:semicolon
id|bc-&gt;edelay
op_assign
l_int|100
suffix:semicolon
id|bc-&gt;idata
op_assign
l_int|1
suffix:semicolon
id|ch-&gt;startc
op_assign
id|bc-&gt;startc
suffix:semicolon
id|ch-&gt;stopc
op_assign
id|bc-&gt;stopc
suffix:semicolon
id|ch-&gt;startca
op_assign
id|bc-&gt;startca
suffix:semicolon
id|ch-&gt;stopca
op_assign
id|bc-&gt;stopca
suffix:semicolon
id|ch-&gt;fepcflag
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;fepiflag
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;fepoflag
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;fepstartc
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;fepstopc
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;fepstartca
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;fepstopca
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;close_delay
op_assign
l_int|50
suffix:semicolon
id|ch-&gt;count
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;blocked_open
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;callout_termios
op_assign
id|pc_callout.init_termios
suffix:semicolon
id|ch-&gt;normal_termios
op_assign
id|pc_driver.init_termios
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ch-&gt;open_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|ch-&gt;close_wait
)paren
suffix:semicolon
id|ch-&gt;tmp_buf
op_assign
id|kmalloc
c_func
(paren
id|ch-&gt;txbufsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ch-&gt;tmp_buf
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;POST FEP INIT : kmalloc failed for port 0x%x&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|ch-&gt;tmp_buf
comma
l_int|0
comma
id|ch-&gt;txbufsize
)paren
suffix:semicolon
)brace
multiline_comment|/* End for each port */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Digi PC/Xx Driver V%s:  %s I/O = 0x%lx Mem = 0x%lx Ports = %d&bslash;n&quot;
comma
id|VERSION
comma
id|board_desc
(braket
id|bd-&gt;type
)braket
comma
(paren
r_int
)paren
id|bd-&gt;port
comma
(paren
r_int
)paren
id|bd-&gt;membase
comma
id|bd-&gt;numports
)paren
suffix:semicolon
id|sprintf
c_func
(paren
id|mesg
comma
l_string|&quot;Digi PC/Xx Driver V%s:  %s I/O = 0x%lx Mem = 0x%lx Ports = %d&bslash;n&quot;
comma
id|VERSION
comma
id|board_desc
(braket
id|bd-&gt;type
)braket
comma
(paren
r_int
)paren
id|bd-&gt;port
comma
(paren
r_int
)paren
id|bd-&gt;membase
comma
id|bd-&gt;numports
)paren
suffix:semicolon
id|console_print
c_func
(paren
id|mesg
)paren
suffix:semicolon
id|memwinoff
c_func
(paren
id|bd
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* End post_fep_init */
multiline_comment|/* --------------------- Begin epcapoll  ------------------------ */
DECL|function|epcapoll
r_static
r_void
id|epcapoll
c_func
(paren
r_int
r_int
id|ignored
)paren
(brace
multiline_comment|/* Begin epcapoll */
r_int
r_int
id|flags
suffix:semicolon
r_int
id|crd
suffix:semicolon
r_volatile
r_int
r_int
id|head
comma
id|tail
suffix:semicolon
r_struct
id|channel
op_star
id|ch
suffix:semicolon
r_struct
id|board_info
op_star
id|bd
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------------&n;&t;&t;This routine is called upon every timer interrupt.  Even though&n;&t;&t;the Digi series cards are capable of generating interupts this &n;&t;&t;method of non-looping polling is more efficient.  This routine&n;&t;&t;checks for card generated events (Such as receive data, are transmit&n;&t;&t;buffer empty) and acts on those events.&n;&t;----------------------------------------------------------------------- */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|crd
op_assign
l_int|0
suffix:semicolon
id|crd
OL
id|num_cards
suffix:semicolon
id|crd
op_increment
)paren
(brace
multiline_comment|/* Begin for each card */
id|bd
op_assign
op_amp
id|boards
(braket
id|crd
)braket
suffix:semicolon
id|ch
op_assign
id|card_ptr
(braket
id|crd
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bd-&gt;status
op_eq
id|DISABLED
)paren
op_logical_or
id|digi_poller_inhibited
)paren
r_continue
suffix:semicolon
multiline_comment|/* Begin loop next interation */
multiline_comment|/* -----------------------------------------------------------&n;&t;&t;&t;assertmemoff is not needed here; indeed it is an empty subroutine.&n;&t;&t;&t;It is being kept because future boards may need this as well as&n;&t;&t;&t;some legacy boards.&n;&t;&t;---------------------------------------------------------------- */
id|assertmemoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------------&n;&t;&t;&t;In this case head and tail actually refer to the event queue not&n;&t;&t;&t;the transmit or receive queue.&n;&t;&t;------------------------------------------------------------------- */
id|head
op_assign
id|ch-&gt;mailbox-&gt;ein
suffix:semicolon
id|tail
op_assign
id|ch-&gt;mailbox-&gt;eout
suffix:semicolon
multiline_comment|/* If head isn&squot;t equal to tail we have an event */
r_if
c_cond
(paren
id|head
op_ne
id|tail
)paren
id|doevent
c_func
(paren
id|crd
)paren
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
multiline_comment|/* End for each card */
id|mod_timer
c_func
(paren
op_amp
id|epca_timer
comma
id|jiffies
op_plus
(paren
id|HZ
op_div
l_int|25
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* End epcapoll */
multiline_comment|/* --------------------- Begin doevent  ------------------------ */
DECL|function|doevent
r_static
r_void
id|doevent
c_func
(paren
r_int
id|crd
)paren
(brace
multiline_comment|/* Begin doevent */
r_volatile
id|unchar
op_star
id|eventbuf
suffix:semicolon
r_struct
id|channel
op_star
id|ch
comma
op_star
id|chan0
suffix:semicolon
r_static
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_volatile
r_struct
id|board_info
op_star
id|bd
suffix:semicolon
r_volatile
r_struct
id|board_chan
op_star
id|bc
suffix:semicolon
r_register
r_volatile
r_int
r_int
id|tail
comma
id|head
suffix:semicolon
r_register
r_int
id|event
comma
id|channel
suffix:semicolon
r_register
r_int
id|mstat
comma
id|lstat
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------------&n;&t;&t;This subroutine is called by epcapoll when an event is detected &n;&t;&t;in the event queue.  This routine responds to those events.&n;&t;--------------------------------------------------------------------- */
id|bd
op_assign
op_amp
id|boards
(braket
id|crd
)braket
suffix:semicolon
id|chan0
op_assign
id|card_ptr
(braket
id|crd
)braket
suffix:semicolon
id|epcaassert
c_func
(paren
id|chan0
op_le
op_amp
id|digi_channels
(braket
id|nbdevs
op_minus
l_int|1
)braket
comma
l_string|&quot;ch out of range&quot;
)paren
suffix:semicolon
id|assertgwinon
c_func
(paren
id|chan0
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|tail
op_assign
id|chan0-&gt;mailbox-&gt;eout
)paren
op_ne
(paren
id|head
op_assign
id|chan0-&gt;mailbox-&gt;ein
)paren
)paren
(brace
multiline_comment|/* Begin while something in event queue */
id|assertgwinon
c_func
(paren
id|chan0
)paren
suffix:semicolon
id|eventbuf
op_assign
(paren
r_volatile
id|unchar
op_star
)paren
id|bus_to_virt
c_func
(paren
(paren
id|ulong
)paren
(paren
id|bd-&gt;re_map_membase
op_plus
id|tail
op_plus
id|ISTART
)paren
)paren
suffix:semicolon
multiline_comment|/* Get the channel the event occurred on */
id|channel
op_assign
id|eventbuf
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Get the actual event code that occurred */
id|event
op_assign
id|eventbuf
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/*  ----------------------------------------------------------------&n;&t;&t;&t;The two assignments below get the current modem status (mstat)&n;&t;&t;&t;and the previous modem status (lstat).  These are useful becuase&n;&t;&t;&t;an event could signal a change in modem signals itself.&n;&t;&t;------------------------------------------------------------------- */
id|mstat
op_assign
id|eventbuf
(braket
l_int|2
)braket
suffix:semicolon
id|lstat
op_assign
id|eventbuf
(braket
l_int|3
)braket
suffix:semicolon
id|ch
op_assign
id|chan0
op_plus
id|channel
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|channel
op_ge
id|bd-&gt;numports
op_logical_or
op_logical_neg
id|ch
)paren
(brace
r_if
c_cond
(paren
id|channel
op_ge
id|bd-&gt;numports
)paren
id|ch
op_assign
id|chan0
suffix:semicolon
id|bc
op_assign
id|ch-&gt;brdchan
suffix:semicolon
r_goto
id|next
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|bc
op_assign
id|ch-&gt;brdchan
)paren
op_eq
l_int|NULL
)paren
r_goto
id|next
suffix:semicolon
r_if
c_cond
(paren
id|event
op_amp
id|DATA_IND
)paren
(brace
multiline_comment|/* Begin DATA_IND */
id|receive_data
c_func
(paren
id|ch
)paren
suffix:semicolon
id|assertgwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
multiline_comment|/* End DATA_IND */
multiline_comment|/* else */
multiline_comment|/* Fix for DCD transition missed bug */
r_if
c_cond
(paren
id|event
op_amp
id|MODEMCHG_IND
)paren
(brace
multiline_comment|/* Begin MODEMCHG_IND */
multiline_comment|/* A modem signal change has been indicated */
id|ch-&gt;imodem
op_assign
id|mstat
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;asyncflags
op_amp
id|ASYNC_CHECK_CD
)paren
(brace
r_if
c_cond
(paren
id|mstat
op_amp
id|ch-&gt;dcd
)paren
multiline_comment|/* We are now receiving dcd */
id|wake_up_interruptible
c_func
(paren
op_amp
id|ch-&gt;open_wait
)paren
suffix:semicolon
r_else
id|pc_sched_event
c_func
(paren
id|ch
comma
id|EPCA_EVENT_HANGUP
)paren
suffix:semicolon
multiline_comment|/* No dcd; hangup */
)brace
)brace
multiline_comment|/* End MODEMCHG_IND */
id|tty
op_assign
id|ch-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
id|tty
)paren
(brace
multiline_comment|/* Begin if valid tty */
r_if
c_cond
(paren
id|event
op_amp
id|BREAK_IND
)paren
(brace
multiline_comment|/* Begin if BREAK_IND */
multiline_comment|/* A break has been indicated */
id|tty-&gt;flip.count
op_increment
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_BREAK
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
l_int|0
suffix:semicolon
id|tty_schedule_flip
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* End if BREAK_IND */
r_else
r_if
c_cond
(paren
id|event
op_amp
id|LOWTX_IND
)paren
(brace
multiline_comment|/* Begin LOWTX_IND */
r_if
c_cond
(paren
id|ch-&gt;statusflags
op_amp
id|LOWWAIT
)paren
(brace
multiline_comment|/* Begin if LOWWAIT */
id|ch-&gt;statusflags
op_and_assign
op_complement
id|LOWWAIT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* End if LOWWAIT */
)brace
multiline_comment|/* End LOWTX_IND */
r_else
r_if
c_cond
(paren
id|event
op_amp
id|EMPTYTX_IND
)paren
(brace
multiline_comment|/* Begin EMPTYTX_IND */
multiline_comment|/* This event is generated by setup_empty_event */
id|ch-&gt;statusflags
op_and_assign
op_complement
id|TXBUSY
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;statusflags
op_amp
id|EMPTYWAIT
)paren
(brace
multiline_comment|/* Begin if EMPTYWAIT */
id|ch-&gt;statusflags
op_and_assign
op_complement
id|EMPTYWAIT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* End if EMPTYWAIT */
)brace
multiline_comment|/* End EMPTYTX_IND */
)brace
multiline_comment|/* End if valid tty */
id|next
suffix:colon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - bc == NULL in doevent!&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|bc-&gt;idata
op_assign
l_int|1
suffix:semicolon
id|chan0-&gt;mailbox-&gt;eout
op_assign
(paren
id|tail
op_plus
l_int|4
)paren
op_amp
(paren
id|IMAX
op_minus
id|ISTART
op_minus
l_int|4
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|chan0
)paren
suffix:semicolon
)brace
multiline_comment|/* End while something in event queue */
)brace
multiline_comment|/* End doevent */
multiline_comment|/* --------------------- Begin fepcmd  ------------------------ */
DECL|function|fepcmd
r_static
r_void
id|fepcmd
c_func
(paren
r_struct
id|channel
op_star
id|ch
comma
r_int
id|cmd
comma
r_int
id|word_or_byte
comma
r_int
id|byte2
comma
r_int
id|ncmds
comma
r_int
id|bytecmd
)paren
(brace
multiline_comment|/* Begin fepcmd */
id|unchar
op_star
id|memaddr
suffix:semicolon
r_int
r_int
id|head
comma
id|cmdTail
comma
id|cmdStart
comma
id|cmdMax
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|n
suffix:semicolon
multiline_comment|/* This is the routine in which commands may be passed to the card. */
r_if
c_cond
(paren
id|ch-&gt;board-&gt;status
op_eq
id|DISABLED
)paren
(brace
r_return
suffix:semicolon
)brace
id|assertgwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/* Remember head (As well as max) is just an offset not a base addr */
id|head
op_assign
id|ch-&gt;mailbox-&gt;cin
suffix:semicolon
multiline_comment|/* cmdStart is a base address */
id|cmdStart
op_assign
id|ch-&gt;mailbox-&gt;cstart
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------&n;&t;&t;We do the addition below because we do not want a max pointer &n;&t;&t;relative to cmdStart.  We want a max pointer that points at the &n;&t;&t;physical end of the command queue.&n;&t;-------------------------------------------------------------------- */
id|cmdMax
op_assign
(paren
id|cmdStart
op_plus
l_int|4
op_plus
(paren
id|ch-&gt;mailbox-&gt;cmax
)paren
)paren
suffix:semicolon
id|memaddr
op_assign
id|ch-&gt;board-&gt;re_map_membase
suffix:semicolon
multiline_comment|/* &n;&t;   The below command is necessary because newer kernels (2.1.x and&n;&t;   up) do not have a 1:1 virtual to physical mapping.  The below&n;&t;   call adjust for that.&n;&t;*/
id|memaddr
op_assign
(paren
r_int
r_char
op_star
)paren
id|bus_to_virt
c_func
(paren
(paren
r_int
r_int
)paren
id|memaddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ge
(paren
id|cmdMax
op_minus
id|cmdStart
)paren
op_logical_or
(paren
id|head
op_amp
l_int|03
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;line %d: Out of range, cmd = %x, head = %x&bslash;n&quot;
comma
id|__LINE__
comma
id|cmd
comma
id|head
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;line %d: Out of range, cmdMax = %x, cmdStart = %x&bslash;n&quot;
comma
id|__LINE__
comma
id|cmdMax
comma
id|cmdStart
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bytecmd
)paren
(brace
op_star
(paren
r_volatile
id|unchar
op_star
)paren
(paren
id|memaddr
op_plus
id|head
op_plus
id|cmdStart
op_plus
l_int|0
)paren
op_assign
(paren
id|unchar
)paren
id|cmd
suffix:semicolon
op_star
(paren
r_volatile
id|unchar
op_star
)paren
(paren
id|memaddr
op_plus
id|head
op_plus
id|cmdStart
op_plus
l_int|1
)paren
op_assign
(paren
id|unchar
)paren
id|ch-&gt;channelnum
suffix:semicolon
multiline_comment|/* Below word_or_byte is bits to set */
op_star
(paren
r_volatile
id|unchar
op_star
)paren
(paren
id|memaddr
op_plus
id|head
op_plus
id|cmdStart
op_plus
l_int|2
)paren
op_assign
(paren
id|unchar
)paren
id|word_or_byte
suffix:semicolon
multiline_comment|/* Below byte2 is bits to reset */
op_star
(paren
r_volatile
id|unchar
op_star
)paren
(paren
id|memaddr
op_plus
id|head
op_plus
id|cmdStart
op_plus
l_int|3
)paren
op_assign
(paren
id|unchar
)paren
id|byte2
suffix:semicolon
)brace
r_else
(brace
op_star
(paren
r_volatile
id|unchar
op_star
)paren
(paren
id|memaddr
op_plus
id|head
op_plus
id|cmdStart
op_plus
l_int|0
)paren
op_assign
(paren
id|unchar
)paren
id|cmd
suffix:semicolon
op_star
(paren
r_volatile
id|unchar
op_star
)paren
(paren
id|memaddr
op_plus
id|head
op_plus
id|cmdStart
op_plus
l_int|1
)paren
op_assign
(paren
id|unchar
)paren
id|ch-&gt;channelnum
suffix:semicolon
op_star
(paren
r_volatile
id|ushort
op_star
)paren
(paren
id|memaddr
op_plus
id|head
op_plus
id|cmdStart
op_plus
l_int|2
)paren
op_assign
(paren
id|ushort
)paren
id|word_or_byte
suffix:semicolon
)brace
id|head
op_assign
(paren
id|head
op_plus
l_int|4
)paren
op_amp
(paren
id|cmdMax
op_minus
id|cmdStart
op_minus
l_int|4
)paren
suffix:semicolon
id|ch-&gt;mailbox-&gt;cin
op_assign
id|head
suffix:semicolon
id|count
op_assign
id|FEPTIMEOUT
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Begin forever loop */
id|count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - Fep not responding in fepcmd()&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|head
op_assign
id|ch-&gt;mailbox-&gt;cin
suffix:semicolon
id|cmdTail
op_assign
id|ch-&gt;mailbox-&gt;cout
suffix:semicolon
id|n
op_assign
(paren
id|head
op_minus
id|cmdTail
)paren
op_amp
(paren
id|cmdMax
op_minus
id|cmdStart
op_minus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* ----------------------------------------------------------&n;&t;&t;&t;Basically this will break when the FEP acknowledges the &n;&t;&t;&t;command by incrementing cmdTail (Making it equal to head).&n;&t;&t;------------------------------------------------------------- */
r_if
c_cond
(paren
id|n
op_le
id|ncmds
op_star
(paren
r_sizeof
(paren
r_int
)paren
op_star
l_int|4
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* Well nearly forever :-) */
)brace
multiline_comment|/* End forever loop */
)brace
multiline_comment|/* End fepcmd */
multiline_comment|/* ---------------------------------------------------------------------&n;&t;Digi products use fields in their channels structures that are very&n;&t;similar to the c_cflag and c_iflag fields typically found in UNIX&n;&t;termios structures.  The below three routines allow mappings &n;&t;between these hardware &quot;flags&quot; and their respective Linux flags.&n;------------------------------------------------------------------------- */
multiline_comment|/* --------------------- Begin termios2digi_h -------------------- */
DECL|function|termios2digi_h
r_static
r_int
id|termios2digi_h
c_func
(paren
r_struct
id|channel
op_star
id|ch
comma
r_int
id|cflag
)paren
(brace
multiline_comment|/* Begin termios2digi_h */
r_int
id|res
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
(brace
id|ch-&gt;digiext.digi_flags
op_or_assign
(paren
id|RTSPACE
op_or
id|CTSPACE
)paren
suffix:semicolon
id|res
op_or_assign
(paren
(paren
id|ch-&gt;m_cts
)paren
op_or
(paren
id|ch-&gt;m_rts
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch-&gt;digiext.digi_flags
op_amp
id|RTSPACE
)paren
id|res
op_or_assign
id|ch-&gt;m_rts
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;digiext.digi_flags
op_amp
id|DTRPACE
)paren
id|res
op_or_assign
id|ch-&gt;m_dtr
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;digiext.digi_flags
op_amp
id|CTSPACE
)paren
id|res
op_or_assign
id|ch-&gt;m_cts
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;digiext.digi_flags
op_amp
id|DSRPACE
)paren
id|res
op_or_assign
id|ch-&gt;dsr
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;digiext.digi_flags
op_amp
id|DCDPACE
)paren
id|res
op_or_assign
id|ch-&gt;dcd
suffix:semicolon
r_if
c_cond
(paren
id|res
op_amp
(paren
id|ch-&gt;m_rts
)paren
)paren
id|ch-&gt;digiext.digi_flags
op_or_assign
id|RTSPACE
suffix:semicolon
r_if
c_cond
(paren
id|res
op_amp
(paren
id|ch-&gt;m_cts
)paren
)paren
id|ch-&gt;digiext.digi_flags
op_or_assign
id|CTSPACE
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* End termios2digi_h */
multiline_comment|/* --------------------- Begin termios2digi_i -------------------- */
DECL|function|termios2digi_i
r_static
r_int
id|termios2digi_i
c_func
(paren
r_struct
id|channel
op_star
id|ch
comma
r_int
id|iflag
)paren
(brace
multiline_comment|/* Begin termios2digi_i */
r_int
id|res
op_assign
id|iflag
op_amp
(paren
id|IGNBRK
op_or
id|BRKINT
op_or
id|IGNPAR
op_or
id|PARMRK
op_or
id|INPCK
op_or
id|ISTRIP
op_or
id|IXON
op_or
id|IXANY
op_or
id|IXOFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;digiext.digi_flags
op_amp
id|DIGI_AIXON
)paren
id|res
op_or_assign
id|IAIXON
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* End termios2digi_i */
multiline_comment|/* --------------------- Begin termios2digi_c -------------------- */
DECL|function|termios2digi_c
r_static
r_int
id|termios2digi_c
c_func
(paren
r_struct
id|channel
op_star
id|ch
comma
r_int
id|cflag
)paren
(brace
multiline_comment|/* Begin termios2digi_c */
r_int
id|res
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SPEED_HACK
multiline_comment|/* CL: HACK to force 115200 at 38400 and 57600 at 19200 Baud */
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CBAUD
)paren
op_eq
id|B38400
)paren
id|cflag
op_assign
id|cflag
op_minus
id|B38400
op_plus
id|B115200
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cflag
op_amp
id|CBAUD
)paren
op_eq
id|B19200
)paren
id|cflag
op_assign
id|cflag
op_minus
id|B19200
op_plus
id|B57600
suffix:semicolon
macro_line|#endif /* SPEED_HACK */
r_if
c_cond
(paren
id|cflag
op_amp
id|CBAUDEX
)paren
(brace
multiline_comment|/* Begin detected CBAUDEX */
id|ch-&gt;digiext.digi_flags
op_or_assign
id|DIGI_FAST
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------&n;&t;&t;   HUPCL bit is used by FEP to indicate fast baud&n;&t;&t;   table is to be used.&n;&t;&t;----------------------------------------------------------------- */
id|res
op_or_assign
id|FEP_HUPCL
suffix:semicolon
)brace
multiline_comment|/* End detected CBAUDEX */
r_else
id|ch-&gt;digiext.digi_flags
op_and_assign
op_complement
id|DIGI_FAST
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------------&n;&t;&t;CBAUD has bit position 0x1000 set these days to indicate Linux&n;&t;&t;baud rate remap.  Digi hardware can&squot;t handle the bit assignment.&n;&t;&t;(We use a different bit assignment for high speed.).  Clear this&n;&t;&t;bit out.&n;&t;---------------------------------------------------------------------- */
id|res
op_or_assign
id|cflag
op_amp
(paren
(paren
id|CBAUD
op_xor
id|CBAUDEX
)paren
op_or
id|PARODD
op_or
id|PARENB
op_or
id|CSTOPB
op_or
id|CSIZE
)paren
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------&n;&t;&t;This gets a little confusing.  The Digi cards have their own&n;&t;&t;representation of c_cflags controling baud rate.  For the most&n;&t;&t;part this is identical to the Linux implementation.  However;&n;&t;&t;Digi supports one rate (76800) that Linux doesn&squot;t.  This means &n;&t;&t;that the c_cflag entry that would normally mean 76800 for Digi&n;&t;&t;actually means 115200 under Linux.  Without the below mapping,&n;&t;&t;a stty 115200 would only drive the board at 76800.  Since &n;&t;&t;the rate 230400 is also found after 76800, the same problem afflicts&t;&n;&t;&t;us when we choose a rate of 230400.  Without the below modificiation&n;&t;&t;stty 230400 would actually give us 115200.&n;&n;&t;&t;There are two additional differences.  The Linux value for CLOCAL&n;&t;&t;(0x800; 0004000) has no meaning to the Digi hardware.  Also in &n;&t;&t;later releases of Linux; the CBAUD define has CBAUDEX (0x1000;&n;&t;&t;0010000) ored into it (CBAUD = 0x100f as opposed to 0xf). CBAUDEX&n;&t;&t;should be checked for a screened out prior to termios2digi_c &n;&t;&t;returning.  Since CLOCAL isn&squot;t used by the board this can be&n;&t;&t;ignored as long as the returned value is used only by Digi hardware. &n;&t;----------------------------------------------------------------- */
r_if
c_cond
(paren
id|cflag
op_amp
id|CBAUDEX
)paren
(brace
multiline_comment|/* -------------------------------------------------------------&n;&t;&t;&t;The below code is trying to guarantee that only baud rates&n;&t;&t;&t;115200 and 230400 are remapped.  We use exclusive or because&n;&t;&t;&t;the various baud rates share common bit positions and therefore&n;&t;&t;&t;can&squot;t be tested for easily.&n;&t;&t;----------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
(paren
id|cflag
op_amp
l_int|0x7
)paren
op_xor
(paren
id|B115200
op_amp
op_complement
id|CBAUDEX
)paren
)paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
(paren
id|cflag
op_amp
l_int|0x7
)paren
op_xor
(paren
id|B230400
op_amp
op_complement
id|CBAUDEX
)paren
)paren
)paren
)paren
(brace
id|res
op_add_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
id|res
suffix:semicolon
)brace
multiline_comment|/* End termios2digi_c */
multiline_comment|/* --------------------- Begin epcaparam  ----------------------- */
DECL|function|epcaparam
r_static
r_void
id|epcaparam
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|channel
op_star
id|ch
)paren
(brace
multiline_comment|/* Begin epcaparam */
r_int
r_int
id|cmdHead
suffix:semicolon
r_struct
id|termios
op_star
id|ts
suffix:semicolon
r_volatile
r_struct
id|board_chan
op_star
id|bc
suffix:semicolon
r_int
id|mval
comma
id|hflow
comma
id|cflag
comma
id|iflag
suffix:semicolon
id|bc
op_assign
id|ch-&gt;brdchan
suffix:semicolon
id|epcaassert
c_func
(paren
id|bc
op_ne
l_int|0
comma
l_string|&quot;bc out of range&quot;
)paren
suffix:semicolon
id|assertgwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|ts
op_assign
id|tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ts-&gt;c_cflag
op_amp
id|CBAUD
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Begin CBAUD detected */
id|cmdHead
op_assign
id|bc-&gt;rin
suffix:semicolon
id|bc-&gt;rout
op_assign
id|cmdHead
suffix:semicolon
id|cmdHead
op_assign
id|bc-&gt;tin
suffix:semicolon
multiline_comment|/* Changing baud in mid-stream transmission can be wonderful */
multiline_comment|/* ---------------------------------------------------------------&n;&t;&t;&t;Flush current transmit buffer by setting cmdTail pointer (tout)&n;&t;&t;&t;to cmdHead pointer (tin).  Hopefully the transmit buffer is empty.&n;&t;&t;----------------------------------------------------------------- */
id|fepcmd
c_func
(paren
id|ch
comma
id|STOUT
comma
(paren
r_int
)paren
id|cmdHead
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|mval
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* End CBAUD detected */
r_else
(brace
multiline_comment|/* Begin CBAUD not detected */
multiline_comment|/* -------------------------------------------------------------------&n;&t;&t;&t;c_cflags have changed but that change had nothing to do with BAUD.&n;&t;&t;&t;Propagate the change to the card.&n;&t;&t;---------------------------------------------------------------------- */
id|cflag
op_assign
id|termios2digi_c
c_func
(paren
id|ch
comma
id|ts-&gt;c_cflag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cflag
op_ne
id|ch-&gt;fepcflag
)paren
(brace
id|ch-&gt;fepcflag
op_assign
id|cflag
suffix:semicolon
multiline_comment|/* Set baud rate, char size, stop bits, parity */
id|fepcmd
c_func
(paren
id|ch
comma
id|SETCTRLFLAGS
comma
(paren
r_int
)paren
id|cflag
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* ----------------------------------------------------------------&n;&t;&t;&t;If the user has not forced CLOCAL and if the device is not a &n;&t;&t;&t;CALLOUT device (Which is always CLOCAL) we set flags such that&n;&t;&t;&t;the driver will wait on carrier detect.&n;&t;&t;------------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|ts-&gt;c_cflag
op_amp
id|CLOCAL
)paren
op_logical_or
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_CALLOUT
)paren
)paren
(brace
multiline_comment|/* Begin it is a cud device or a ttyD device with CLOCAL on */
id|ch-&gt;asyncflags
op_and_assign
op_complement
id|ASYNC_CHECK_CD
suffix:semicolon
)brace
multiline_comment|/* End it is a cud device or a ttyD device with CLOCAL on */
r_else
(brace
multiline_comment|/* Begin it is a ttyD device */
id|ch-&gt;asyncflags
op_or_assign
id|ASYNC_CHECK_CD
suffix:semicolon
)brace
multiline_comment|/* End it is a ttyD device */
id|mval
op_assign
id|ch-&gt;m_dtr
op_or
id|ch-&gt;m_rts
suffix:semicolon
)brace
multiline_comment|/* End CBAUD not detected */
id|iflag
op_assign
id|termios2digi_i
c_func
(paren
id|ch
comma
id|ts-&gt;c_iflag
)paren
suffix:semicolon
multiline_comment|/* Check input mode flags */
r_if
c_cond
(paren
id|iflag
op_ne
id|ch-&gt;fepiflag
)paren
(brace
id|ch-&gt;fepiflag
op_assign
id|iflag
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------------&n;&t;&t;&t;Command sets channels iflag structure on the board. Such things &n;&t;&t;&t;as input soft flow control, handeling of parity errors, and&n;&t;&t;&t;break handeling are all set here.&n;&t;&t;------------------------------------------------------------------- */
multiline_comment|/* break handeling, parity handeling, input stripping, flow control chars */
id|fepcmd
c_func
(paren
id|ch
comma
id|SETIFLAGS
comma
(paren
r_int
r_int
)paren
id|ch-&gt;fepiflag
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------------&n;&t;&t;Set the board mint value for this channel.  This will cause hardware&n;&t;&t;events to be generated each time the DCD signal (Described in mint) &n;&t;&t;changes.&t;&n;&t;------------------------------------------------------------------- */
id|bc-&gt;mint
op_assign
id|ch-&gt;dcd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ts-&gt;c_cflag
op_amp
id|CLOCAL
)paren
op_logical_or
(paren
id|ch-&gt;digiext.digi_flags
op_amp
id|DIGI_FORCEDCD
)paren
)paren
r_if
c_cond
(paren
id|ch-&gt;digiext.digi_flags
op_amp
id|DIGI_FORCEDCD
)paren
id|bc-&gt;mint
op_assign
l_int|0
suffix:semicolon
id|ch-&gt;imodem
op_assign
id|bc-&gt;mstat
suffix:semicolon
id|hflow
op_assign
id|termios2digi_h
c_func
(paren
id|ch
comma
id|ts-&gt;c_cflag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hflow
op_ne
id|ch-&gt;hflow
)paren
(brace
id|ch-&gt;hflow
op_assign
id|hflow
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------&n;&t;&t;&t;Hard flow control has been selected but the board is not&n;&t;&t;&t;using it.  Activate hard flow control now.&n;&t;&t;----------------------------------------------------------------- */
id|fepcmd
c_func
(paren
id|ch
comma
id|SETHFLOW
comma
id|hflow
comma
l_int|0xff
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
id|mval
op_xor_assign
id|ch-&gt;modemfake
op_amp
(paren
id|mval
op_xor
id|ch-&gt;modem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;omodem
op_xor
id|mval
)paren
(brace
id|ch-&gt;omodem
op_assign
id|mval
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------&n;&t;&t;&t;The below command sets the DTR and RTS mstat structure.  If&n;&t;&t;&t;hard flow control is NOT active these changes will drive the&n;&t;&t;&t;output of the actual DTR and RTS lines.  If hard flow control &n;&t;&t;&t;is active, the changes will be saved in the mstat structure and&n;&t;&t;&t;only asserted when hard flow control is turned off. &n;&t;&t;----------------------------------------------------------------- */
multiline_comment|/* First reset DTR &amp; RTS; then set them */
id|fepcmd
c_func
(paren
id|ch
comma
id|SETMODEM
comma
l_int|0
comma
(paren
(paren
id|ch-&gt;m_dtr
)paren
op_or
(paren
id|ch-&gt;m_rts
)paren
)paren
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|fepcmd
c_func
(paren
id|ch
comma
id|SETMODEM
comma
id|mval
comma
l_int|0
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch-&gt;startc
op_ne
id|ch-&gt;fepstartc
op_logical_or
id|ch-&gt;stopc
op_ne
id|ch-&gt;fepstopc
)paren
(brace
id|ch-&gt;fepstartc
op_assign
id|ch-&gt;startc
suffix:semicolon
id|ch-&gt;fepstopc
op_assign
id|ch-&gt;stopc
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------&n;&t;&t;&t;The XON / XOFF characters have changed; propogate these&n;&t;&t;&t;changes to the card.&t;&n;&t;&t;--------------------------------------------------------------- */
id|fepcmd
c_func
(paren
id|ch
comma
id|SONOFFC
comma
id|ch-&gt;fepstartc
comma
id|ch-&gt;fepstopc
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch-&gt;startca
op_ne
id|ch-&gt;fepstartca
op_logical_or
id|ch-&gt;stopca
op_ne
id|ch-&gt;fepstopca
)paren
(brace
id|ch-&gt;fepstartca
op_assign
id|ch-&gt;startca
suffix:semicolon
id|ch-&gt;fepstopca
op_assign
id|ch-&gt;stopca
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------------&n;&t;&t;&t;Similar to the above, this time the auxilarly XON / XOFF &n;&t;&t;&t;characters have changed; propogate these changes to the card.&n;&t;&t;------------------------------------------------------------------ */
id|fepcmd
c_func
(paren
id|ch
comma
id|SAUXONOFFC
comma
id|ch-&gt;fepstartca
comma
id|ch-&gt;fepstopca
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* End epcaparam */
multiline_comment|/* --------------------- Begin receive_data  ----------------------- */
DECL|function|receive_data
r_static
r_void
id|receive_data
c_func
(paren
r_struct
id|channel
op_star
id|ch
)paren
(brace
multiline_comment|/* Begin receive_data */
id|unchar
op_star
id|rptr
suffix:semicolon
r_struct
id|termios
op_star
id|ts
op_assign
l_int|0
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_volatile
r_struct
id|board_chan
op_star
id|bc
suffix:semicolon
r_register
r_int
id|dataToRead
comma
id|wrapgap
comma
id|bytesAvailable
suffix:semicolon
r_register
r_int
r_int
id|tail
comma
id|head
suffix:semicolon
r_int
r_int
id|wrapmask
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------------&n;&t;&t;This routine is called by doint when a receive data event &n;&t;&t;has taken place.&n;&t;------------------------------------------------------------------- */
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;statusflags
op_amp
id|RXSTOPPED
)paren
r_return
suffix:semicolon
id|tty
op_assign
id|ch-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
id|tty
)paren
id|ts
op_assign
id|tty-&gt;termios
suffix:semicolon
id|bc
op_assign
id|ch-&gt;brdchan
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - bc is NULL in receive_data!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|wrapmask
op_assign
id|ch-&gt;rxbufsize
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- &n;&t;&t;Get the head and tail pointers to the receiver queue.  Wrap the &n;&t;&t;head pointer if it has reached the end of the buffer.&n;&t;------------------------------------------------------------------------ */
id|head
op_assign
id|bc-&gt;rin
suffix:semicolon
id|head
op_and_assign
id|wrapmask
suffix:semicolon
id|tail
op_assign
id|bc-&gt;rout
op_amp
id|wrapmask
suffix:semicolon
id|bytesAvailable
op_assign
(paren
id|head
op_minus
id|tail
)paren
op_amp
id|wrapmask
suffix:semicolon
r_if
c_cond
(paren
id|bytesAvailable
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------&n;&t;   If CREAD bit is off or device not open, set TX tail to head&n;&t;--------------------------------------------------------------------- */
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
op_logical_neg
id|ts
op_logical_or
op_logical_neg
(paren
id|ts-&gt;c_cflag
op_amp
id|CREAD
)paren
)paren
(brace
id|bc-&gt;rout
op_assign
id|head
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;flip.count
op_eq
id|TTY_FLIPBUF_SIZE
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;orun
)paren
(brace
id|bc-&gt;orun
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;overrun! DigiBoard device minor = %d&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
)brace
id|rxwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|rptr
op_assign
id|tty-&gt;flip.char_buf_ptr
suffix:semicolon
id|rc
op_assign
id|tty-&gt;flip.count
suffix:semicolon
r_while
c_loop
(paren
id|bytesAvailable
OG
l_int|0
)paren
(brace
multiline_comment|/* Begin while there is data on the card */
id|wrapgap
op_assign
(paren
id|head
op_ge
id|tail
)paren
ques
c_cond
id|head
op_minus
id|tail
suffix:colon
id|ch-&gt;rxbufsize
op_minus
id|tail
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------------&n;&t;&t;&t;Even if head has wrapped around only report the amount of&n;&t;&t;&t;data to be equal to the size - tail.  Remember memcpy can&squot;t&n;&t;&t;&t;automaticly wrap around the receive buffer.&n;&t;&t;----------------------------------------------------------------- */
id|dataToRead
op_assign
(paren
id|wrapgap
OL
id|bytesAvailable
)paren
ques
c_cond
id|wrapgap
suffix:colon
id|bytesAvailable
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------&n;&t;&t;   Make sure we don&squot;t overflow the buffer&n;&t;&t;----------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|rc
op_plus
id|dataToRead
)paren
OG
id|TTY_FLIPBUF_SIZE
)paren
id|dataToRead
op_assign
id|TTY_FLIPBUF_SIZE
op_minus
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|dataToRead
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------------&n;&t;&t;&t;Move data read from our card into the line disciplines buffer&n;&t;&t;&t;for translation if necessary.&n;&t;&t;------------------------------------------------------------------ */
r_if
c_cond
(paren
(paren
id|memcpy
c_func
(paren
id|rptr
comma
id|ch-&gt;rxptr
op_plus
id|tail
comma
id|dataToRead
)paren
)paren
op_ne
id|rptr
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - receive_data : memcpy failed&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_add_assign
id|dataToRead
suffix:semicolon
id|rptr
op_add_assign
id|dataToRead
suffix:semicolon
id|tail
op_assign
(paren
id|tail
op_plus
id|dataToRead
)paren
op_amp
id|wrapmask
suffix:semicolon
id|bytesAvailable
op_sub_assign
id|dataToRead
suffix:semicolon
)brace
multiline_comment|/* End while there is data on the card */
id|tty-&gt;flip.count
op_assign
id|rc
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_assign
id|rptr
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|bc-&gt;rout
op_assign
id|tail
suffix:semicolon
multiline_comment|/* Must be called with global data */
id|tty_schedule_flip
c_func
(paren
id|ch-&gt;tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* End receive_data */
multiline_comment|/* --------------------- Begin pc_ioctl  ----------------------- */
DECL|function|pc_ioctl
r_static
r_int
id|pc_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
multiline_comment|/* Begin pc_ioctl */
id|digiflow_t
id|dflow
suffix:semicolon
r_int
id|retval
comma
id|error
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|mflag
comma
id|mstat
suffix:semicolon
r_int
r_char
id|startc
comma
id|stopc
suffix:semicolon
r_volatile
r_struct
id|board_chan
op_star
id|bc
suffix:semicolon
r_struct
id|channel
op_star
id|ch
op_assign
(paren
r_struct
id|channel
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
multiline_comment|/* The control device has it&squot;s own set of commands */
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_INFO
)paren
(brace
multiline_comment|/* Begin if subtype is the control device */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/* Begin switch cmd */
r_case
id|DIGI_GETINFO
suffix:colon
(brace
multiline_comment|/* Begin case DIGI_GETINFO */
r_struct
id|digi_info
id|di
suffix:semicolon
r_int
id|brd
suffix:semicolon
id|getUser
c_func
(paren
id|brd
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|di
)paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;DIGI_GETINFO : verify area size 0x%x failed&bslash;n&quot;
comma
r_sizeof
(paren
id|di
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|brd
OL
l_int|0
)paren
op_logical_or
(paren
id|brd
op_ge
id|num_cards
)paren
op_logical_or
(paren
id|num_cards
op_eq
l_int|0
)paren
)paren
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|di
comma
l_int|0
comma
r_sizeof
(paren
id|di
)paren
)paren
suffix:semicolon
id|di.board
op_assign
id|brd
suffix:semicolon
id|di.status
op_assign
id|boards
(braket
id|brd
)braket
dot
id|status
suffix:semicolon
id|di.type
op_assign
id|boards
(braket
id|brd
)braket
dot
id|type
suffix:semicolon
id|di.numports
op_assign
id|boards
(braket
id|brd
)braket
dot
id|numports
suffix:semicolon
id|di.port
op_assign
id|boards
(braket
id|brd
)braket
dot
id|port
suffix:semicolon
id|di.membase
op_assign
id|boards
(braket
id|brd
)braket
dot
id|membase
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
op_amp
id|di
comma
r_sizeof
(paren
id|di
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* End case DIGI_GETINFO */
r_case
id|DIGI_POLLER
suffix:colon
(brace
multiline_comment|/* Begin case DIGI_POLLER */
r_int
id|brd
op_assign
id|arg
op_amp
l_int|0xff000000
op_rshift
l_int|16
suffix:semicolon
r_int
r_char
id|state
op_assign
id|arg
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
(paren
id|brd
OL
l_int|0
)paren
op_logical_or
(paren
id|brd
op_ge
id|num_cards
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - DIGI POLLER : brd not valid!&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENODEV
)paren
suffix:semicolon
)brace
id|digi_poller_inhibited
op_assign
id|state
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* End case DIGI_POLLER */
r_case
id|DIGI_INIT
suffix:colon
(brace
multiline_comment|/* Begin case DIGI_INIT */
multiline_comment|/* ------------------------------------------------------------&n;&t;&t;&t;&t;&t;This call is made by the apps to complete the initilization&n;&t;&t;&t;&t;&t;of the board(s).  This routine is responsible for setting&n;&t;&t;&t;&t;&t;the card to its initial state and setting the drivers control&n;&t;&t;&t;&t;&t;fields to the sutianle settings for the card in question.&n;&t;&t;&t;&t;---------------------------------------------------------------- */
r_int
id|crd
suffix:semicolon
r_for
c_loop
(paren
id|crd
op_assign
l_int|0
suffix:semicolon
id|crd
OL
id|num_cards
suffix:semicolon
id|crd
op_increment
)paren
id|post_fep_init
(paren
id|crd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* End case DIGI_INIT */
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
multiline_comment|/* End switch cmd */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* End if subtype is the control device */
r_if
c_cond
(paren
id|ch
)paren
id|bc
op_assign
id|ch-&gt;brdchan
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - ch is NULL in pc_ioctl!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------------&n;&t;&t;For POSIX compliance we need to add more ioctls.  See tty_ioctl.c&n;&t;&t;in /usr/src/linux/drivers/char for a good example.  In particular &n;&t;&t;think about adding TCSETAF, TCSETAW, TCSETA, TCSETSF, TCSETSW, TCSETS.&n;&t;---------------------------------------------------------------------- */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/* Begin switch cmd */
r_case
id|TCGETS
suffix:colon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_struct
id|termios
op_star
)paren
id|arg
comma
id|tty-&gt;termios
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCGETA
suffix:colon
r_return
id|get_termio
c_func
(paren
id|tty
comma
(paren
r_struct
id|termio
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|TCSBRK
suffix:colon
multiline_comment|/* SVID version: non-zero arg --&gt; no break */
id|retval
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
multiline_comment|/* Setup an event to indicate when the transmit buffer empties */
id|setup_empty_event
c_func
(paren
id|tty
comma
id|ch
)paren
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
id|digi_send_break
c_func
(paren
id|ch
comma
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
multiline_comment|/* 1/4 second */
r_return
l_int|0
suffix:semicolon
r_case
id|TCSBRKP
suffix:colon
multiline_comment|/* support for POSIX tcsendbreak() */
id|retval
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
multiline_comment|/* Setup an event to indicate when the transmit buffer empties */
id|setup_empty_event
c_func
(paren
id|tty
comma
id|ch
)paren
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
id|digi_send_break
c_func
(paren
id|ch
comma
id|arg
ques
c_cond
id|arg
op_star
(paren
id|HZ
op_div
l_int|10
)paren
suffix:colon
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCGSOFTCAR
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|putUser
c_func
(paren
id|C_CLOCAL
c_func
(paren
id|tty
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCSSOFTCAR
suffix:colon
multiline_comment|/*RONNIE PUT VERIFY_READ (See above) check here */
(brace
r_int
r_int
id|value
suffix:semicolon
id|getUser
c_func
(paren
id|value
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|tty-&gt;termios-&gt;c_cflag
op_assign
(paren
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
op_complement
id|CLOCAL
)paren
op_or
(paren
id|value
ques
c_cond
id|CLOCAL
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|TIOCMODG
suffix:colon
r_case
id|TIOCMGET
suffix:colon
id|mflag
op_assign
l_int|0
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|mstat
op_assign
id|bc-&gt;mstat
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mstat
op_amp
id|ch-&gt;m_dtr
)paren
id|mflag
op_or_assign
id|TIOCM_DTR
suffix:semicolon
r_if
c_cond
(paren
id|mstat
op_amp
id|ch-&gt;m_rts
)paren
id|mflag
op_or_assign
id|TIOCM_RTS
suffix:semicolon
r_if
c_cond
(paren
id|mstat
op_amp
id|ch-&gt;m_cts
)paren
id|mflag
op_or_assign
id|TIOCM_CTS
suffix:semicolon
r_if
c_cond
(paren
id|mstat
op_amp
id|ch-&gt;dsr
)paren
id|mflag
op_or_assign
id|TIOCM_DSR
suffix:semicolon
r_if
c_cond
(paren
id|mstat
op_amp
id|ch-&gt;m_ri
)paren
id|mflag
op_or_assign
id|TIOCM_RI
suffix:semicolon
r_if
c_cond
(paren
id|mstat
op_amp
id|ch-&gt;dcd
)paren
id|mflag
op_or_assign
id|TIOCM_CD
suffix:semicolon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|putUser
c_func
(paren
id|mflag
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
r_case
id|TIOCMBIC
suffix:colon
r_case
id|TIOCMODS
suffix:colon
r_case
id|TIOCMSET
suffix:colon
id|getUser
c_func
(paren
id|mstat
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|mflag
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mstat
op_amp
id|TIOCM_DTR
)paren
id|mflag
op_or_assign
id|ch-&gt;m_dtr
suffix:semicolon
r_if
c_cond
(paren
id|mstat
op_amp
id|TIOCM_RTS
)paren
id|mflag
op_or_assign
id|ch-&gt;m_rts
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/* Begin switch cmd */
r_case
id|TIOCMODS
suffix:colon
r_case
id|TIOCMSET
suffix:colon
id|ch-&gt;modemfake
op_assign
id|ch-&gt;m_dtr
op_or
id|ch-&gt;m_rts
suffix:semicolon
id|ch-&gt;modem
op_assign
id|mflag
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
id|ch-&gt;modemfake
op_or_assign
id|mflag
suffix:semicolon
id|ch-&gt;modem
op_or_assign
id|mflag
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMBIC
suffix:colon
id|ch-&gt;modemfake
op_or_assign
id|mflag
suffix:semicolon
id|ch-&gt;modem
op_and_assign
op_complement
id|mflag
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* End switch cmd */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/*  --------------------------------------------------------------&n;&t;&t;&t;&t;The below routine generally sets up parity, baud, flow control &n;&t;&t;&t;&t;issues, etc.... It effect both control flags and input flags.&n;&t;&t;&t;------------------------------------------------------------------ */
id|epcaparam
c_func
(paren
id|tty
comma
id|ch
)paren
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSDTR
suffix:colon
id|ch-&gt;omodem
op_or_assign
id|ch-&gt;m_dtr
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|fepcmd
c_func
(paren
id|ch
comma
id|SETMODEM
comma
id|ch-&gt;m_dtr
comma
l_int|0
comma
l_int|10
comma
l_int|1
)paren
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCCDTR
suffix:colon
id|ch-&gt;omodem
op_and_assign
op_complement
id|ch-&gt;m_dtr
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|fepcmd
c_func
(paren
id|ch
comma
id|SETMODEM
comma
l_int|0
comma
id|ch-&gt;m_dtr
comma
l_int|10
comma
l_int|1
)paren
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIGI_GETA
suffix:colon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|digi_t
)paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - Digi GETA failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
op_amp
id|ch-&gt;digiext
comma
r_sizeof
(paren
id|digi_t
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIGI_SETAW
suffix:colon
r_case
id|DIGI_SETAF
suffix:colon
r_if
c_cond
(paren
(paren
id|cmd
)paren
op_eq
(paren
id|DIGI_SETAW
)paren
)paren
(brace
multiline_comment|/* Setup an event to indicate when the transmit buffer empties */
id|setup_empty_event
c_func
(paren
id|tty
comma
id|ch
)paren
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* Fall Thru */
r_case
id|DIGI_SETA
suffix:colon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|digi_t
)paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|ch-&gt;digiext
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|digi_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;digiext.digi_flags
op_amp
id|DIGI_ALTPIN
)paren
(brace
id|ch-&gt;dcd
op_assign
id|ch-&gt;m_dsr
suffix:semicolon
id|ch-&gt;dsr
op_assign
id|ch-&gt;m_dcd
suffix:semicolon
)brace
r_else
(brace
id|ch-&gt;dcd
op_assign
id|ch-&gt;m_dcd
suffix:semicolon
id|ch-&gt;dsr
op_assign
id|ch-&gt;m_dsr
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/* -----------------------------------------------------------------&n;&t;&t;&t;&t;The below routine generally sets up parity, baud, flow control &n;&t;&t;&t;&t;issues, etc.... It effect both control flags and input flags.&n;&t;&t;&t;------------------------------------------------------------------- */
id|epcaparam
c_func
(paren
id|tty
comma
id|ch
)paren
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIGI_GETFLOW
suffix:colon
r_case
id|DIGI_GETAFLOW
suffix:colon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
)paren
op_eq
(paren
id|DIGI_GETFLOW
)paren
)paren
(brace
id|dflow.startc
op_assign
id|bc-&gt;startc
suffix:semicolon
id|dflow.stopc
op_assign
id|bc-&gt;stopc
suffix:semicolon
)brace
r_else
(brace
id|dflow.startc
op_assign
id|bc-&gt;startca
suffix:semicolon
id|dflow.stopc
op_assign
id|bc-&gt;stopca
suffix:semicolon
)brace
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|dflow
)paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
op_amp
id|dflow
comma
r_sizeof
(paren
id|dflow
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DIGI_SETAFLOW
suffix:colon
r_case
id|DIGI_SETFLOW
suffix:colon
r_if
c_cond
(paren
(paren
id|cmd
)paren
op_eq
(paren
id|DIGI_SETFLOW
)paren
)paren
(brace
id|startc
op_assign
id|ch-&gt;startc
suffix:semicolon
id|stopc
op_assign
id|ch-&gt;stopc
suffix:semicolon
)brace
r_else
(brace
id|startc
op_assign
id|ch-&gt;startca
suffix:semicolon
id|stopc
op_assign
id|ch-&gt;stopca
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|dflow
)paren
)paren
)paren
)paren
r_return
id|error
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|dflow
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|dflow
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dflow.startc
op_ne
id|startc
op_logical_or
id|dflow.stopc
op_ne
id|stopc
)paren
(brace
multiline_comment|/* Begin  if setflow toggled */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
)paren
op_eq
(paren
id|DIGI_SETFLOW
)paren
)paren
(brace
id|ch-&gt;fepstartc
op_assign
id|ch-&gt;startc
op_assign
id|dflow.startc
suffix:semicolon
id|ch-&gt;fepstopc
op_assign
id|ch-&gt;stopc
op_assign
id|dflow.stopc
suffix:semicolon
id|fepcmd
c_func
(paren
id|ch
comma
id|SONOFFC
comma
id|ch-&gt;fepstartc
comma
id|ch-&gt;fepstopc
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|ch-&gt;fepstartca
op_assign
id|ch-&gt;startca
op_assign
id|dflow.startc
suffix:semicolon
id|ch-&gt;fepstopca
op_assign
id|ch-&gt;stopca
op_assign
id|dflow.stopc
suffix:semicolon
id|fepcmd
c_func
(paren
id|ch
comma
id|SAUXONOFFC
comma
id|ch-&gt;fepstartca
comma
id|ch-&gt;fepstopca
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ch-&gt;statusflags
op_amp
id|TXSTOPPED
)paren
id|pc_start
c_func
(paren
id|tty
)paren
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* End if setflow toggled */
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
multiline_comment|/* End switch cmd */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* End pc_ioctl */
multiline_comment|/* --------------------- Begin pc_set_termios  ----------------------- */
DECL|function|pc_set_termios
r_static
r_void
id|pc_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
multiline_comment|/* Begin pc_set_termios */
r_struct
id|channel
op_star
id|ch
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------&n;&t;&t;verifyChannel returns the channel from the tty struct&n;&t;&t;if it is valid.  This serves as a sanity check.&n;&t;------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|verifyChannel
c_func
(paren
id|tty
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Begin if channel valid */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|epcaparam
c_func
(paren
id|tty
comma
id|ch
)paren
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
op_logical_and
(paren
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
op_eq
l_int|0
)paren
)paren
id|tty-&gt;hw_stopped
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
op_logical_and
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|ch-&gt;open_wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* End if channel valid */
)brace
multiline_comment|/* End pc_set_termios */
multiline_comment|/* --------------------- Begin do_softint  ----------------------- */
DECL|function|do_softint
r_static
r_void
id|do_softint
c_func
(paren
r_void
op_star
id|private_
)paren
(brace
multiline_comment|/* Begin do_softint */
r_struct
id|channel
op_star
id|ch
op_assign
(paren
r_struct
id|channel
op_star
)paren
id|private_
suffix:semicolon
multiline_comment|/* Called in response to a modem change event */
r_if
c_cond
(paren
id|ch
op_logical_and
id|ch-&gt;magic
op_eq
id|EPCA_MAGIC
)paren
(brace
multiline_comment|/* Begin EPCA_MAGIC */
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|ch-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_logical_and
id|tty-&gt;driver_data
)paren
(brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|EPCA_EVENT_HANGUP
comma
op_amp
id|ch-&gt;event
)paren
)paren
(brace
multiline_comment|/* Begin if clear_bit */
id|tty_hangup
c_func
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/* FIXME: module removal race here - AKPM */
id|wake_up_interruptible
c_func
(paren
op_amp
id|ch-&gt;open_wait
)paren
suffix:semicolon
id|ch-&gt;asyncflags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
)paren
suffix:semicolon
)brace
multiline_comment|/* End if clear_bit */
)brace
)brace
multiline_comment|/* End EPCA_MAGIC */
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/* End do_softint */
multiline_comment|/* ------------------------------------------------------------&n;&t;pc_stop and pc_start provide software flow control to the &n;&t;routine and the pc_ioctl routine.&n;---------------------------------------------------------------- */
multiline_comment|/* --------------------- Begin pc_stop  ----------------------- */
DECL|function|pc_stop
r_static
r_void
id|pc_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* Begin pc_stop */
r_struct
id|channel
op_star
id|ch
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------&n;&t;&t;verifyChannel returns the channel from the tty struct&n;&t;&t;if it is valid.  This serves as a sanity check.&n;&t;------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|verifyChannel
c_func
(paren
id|tty
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Begin if valid channel */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch-&gt;statusflags
op_amp
id|TXSTOPPED
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Begin if transmit stop requested */
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/* STOP transmitting now !! */
id|fepcmd
c_func
(paren
id|ch
comma
id|PAUSETX
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ch-&gt;statusflags
op_or_assign
id|TXSTOPPED
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
multiline_comment|/* End if transmit stop requested */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* End if valid channel */
)brace
multiline_comment|/* End pc_stop */
multiline_comment|/* --------------------- Begin pc_start  ----------------------- */
DECL|function|pc_start
r_static
r_void
id|pc_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* Begin pc_start */
r_struct
id|channel
op_star
id|ch
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------&n;&t;&t;verifyChannel returns the channel from the tty struct&n;&t;&t;if it is valid.  This serves as a sanity check.&n;&t;------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|verifyChannel
c_func
(paren
id|tty
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Begin if channel valid */
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Just in case output was resumed because of a change in Digi-flow */
r_if
c_cond
(paren
id|ch-&gt;statusflags
op_amp
id|TXSTOPPED
)paren
(brace
multiline_comment|/* Begin transmit resume requested */
r_volatile
r_struct
id|board_chan
op_star
id|bc
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|bc
op_assign
id|ch-&gt;brdchan
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;statusflags
op_amp
id|LOWWAIT
)paren
id|bc-&gt;ilow
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Okay, you can start transmitting again... */
id|fepcmd
c_func
(paren
id|ch
comma
id|RESUMETX
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ch-&gt;statusflags
op_and_assign
op_complement
id|TXSTOPPED
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
multiline_comment|/* End transmit resume requested */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* End if channel valid */
)brace
multiline_comment|/* End pc_start */
multiline_comment|/* ------------------------------------------------------------------&n;&t;The below routines pc_throttle and pc_unthrottle are used &n;&t;to slow (And resume) the receipt of data into the kernels&n;&t;receive buffers.  The exact occurence of this depends on the&n;&t;size of the kernels receive buffer and what the &squot;watermarks&squot;&n;&t;are set to for that buffer.  See the n_ttys.c file for more&n;&t;details. &n;______________________________________________________________________ */
multiline_comment|/* --------------------- Begin throttle  ----------------------- */
DECL|function|pc_throttle
r_static
r_void
id|pc_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* Begin pc_throttle */
r_struct
id|channel
op_star
id|ch
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------&n;&t;&t;verifyChannel returns the channel from the tty struct&n;&t;&t;if it is valid.  This serves as a sanity check.&n;&t;------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|verifyChannel
c_func
(paren
id|tty
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Begin if channel valid */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ch-&gt;statusflags
op_amp
id|RXSTOPPED
)paren
op_eq
l_int|0
)paren
(brace
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|fepcmd
c_func
(paren
id|ch
comma
id|PAUSERX
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ch-&gt;statusflags
op_or_assign
id|RXSTOPPED
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* End if channel valid */
)brace
multiline_comment|/* End pc_throttle */
multiline_comment|/* --------------------- Begin unthrottle  ----------------------- */
DECL|function|pc_unthrottle
r_static
r_void
id|pc_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* Begin pc_unthrottle */
r_struct
id|channel
op_star
id|ch
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_volatile
r_struct
id|board_chan
op_star
id|bc
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------&n;&t;&t;verifyChannel returns the channel from the tty struct&n;&t;&t;if it is valid.  This serves as a sanity check.&n;&t;------------------------------------------------------------- */
r_if
c_cond
(paren
(paren
id|ch
op_assign
id|verifyChannel
c_func
(paren
id|tty
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Begin if channel valid */
multiline_comment|/* Just in case output was resumed because of a change in Digi-flow */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch-&gt;statusflags
op_amp
id|RXSTOPPED
)paren
(brace
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|bc
op_assign
id|ch-&gt;brdchan
suffix:semicolon
id|fepcmd
c_func
(paren
id|ch
comma
id|RESUMERX
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|ch-&gt;statusflags
op_and_assign
op_complement
id|RXSTOPPED
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* End if channel valid */
)brace
multiline_comment|/* End pc_unthrottle */
multiline_comment|/* --------------------- Begin digi_send_break  ----------------------- */
DECL|function|digi_send_break
r_void
id|digi_send_break
c_func
(paren
r_struct
id|channel
op_star
id|ch
comma
r_int
id|msec
)paren
(brace
multiline_comment|/* Begin digi_send_break */
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
multiline_comment|/* -------------------------------------------------------------------- &n;&t;   Maybe I should send an infinite break here, schedule() for&n;&t;   msec amount of time, and then stop the break.  This way,&n;&t;   the user can&squot;t screw up the FEP by causing digi_send_break()&n;&t;   to be called (i.e. via an ioctl()) more than once in msec amount &n;&t;   of time.  Try this for now...&n;&t;------------------------------------------------------------------------ */
id|fepcmd
c_func
(paren
id|ch
comma
id|SENDBREAK
comma
id|msec
comma
l_int|0
comma
l_int|10
comma
l_int|0
)paren
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* End digi_send_break */
multiline_comment|/* --------------------- Begin setup_empty_event  ----------------------- */
DECL|function|setup_empty_event
r_static
r_void
id|setup_empty_event
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|channel
op_star
id|ch
)paren
(brace
multiline_comment|/* Begin setup_empty_event */
r_volatile
r_struct
id|board_chan
op_star
id|bc
op_assign
id|ch-&gt;brdchan
suffix:semicolon
r_int
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|globalwinon
c_func
(paren
id|ch
)paren
suffix:semicolon
id|ch-&gt;statusflags
op_or_assign
id|EMPTYWAIT
suffix:semicolon
multiline_comment|/* ------------------------------------------------------------------&n;&t;&t;When set the iempty flag request a event to be generated when the &n;&t;&t;transmit buffer is empty (If there is no BREAK in progress).&n;&t;--------------------------------------------------------------------- */
id|bc-&gt;iempty
op_assign
l_int|1
suffix:semicolon
id|memoff
c_func
(paren
id|ch
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* End setup_empty_event */
multiline_comment|/* --------------------- Begin get_termio ----------------------- */
DECL|function|get_termio
r_static
r_int
id|get_termio
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termio
op_star
id|termio
)paren
(brace
multiline_comment|/* Begin get_termio */
r_int
id|error
suffix:semicolon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|termio
comma
r_sizeof
(paren
r_struct
id|termio
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|kernel_termios_to_user_termio
c_func
(paren
id|termio
comma
id|tty-&gt;termios
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* End get_termio */
multiline_comment|/* ---------------------- Begin epca_setup  -------------------------- */
DECL|function|epca_setup
r_void
id|epca_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
multiline_comment|/* Begin epca_setup */
r_struct
id|board_info
id|board
suffix:semicolon
r_int
id|index
comma
id|loop
comma
id|last
suffix:semicolon
r_char
op_star
id|temp
comma
op_star
id|t2
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* ----------------------------------------------------------------------&n;&t;&t;If this routine looks a little strange it is because it is only called&n;&t;&t;if a LILO append command is given to boot the kernel with parameters.  &n;&t;&t;In this way, we can provide the user a method of changing his board&n;&t;&t;configuration without rebuilding the kernel.&n;&t;----------------------------------------------------------------------- */
r_if
c_cond
(paren
op_logical_neg
id|liloconfig
)paren
id|liloconfig
op_assign
l_int|1
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|board
comma
l_int|0
comma
r_sizeof
(paren
id|board
)paren
)paren
suffix:semicolon
multiline_comment|/* Assume the data is int first, later we can change it */
multiline_comment|/* I think that array position 0 of ints holds the number of args */
r_for
c_loop
(paren
id|last
op_assign
l_int|0
comma
id|index
op_assign
l_int|1
suffix:semicolon
id|index
op_le
id|ints
(braket
l_int|0
)braket
suffix:semicolon
id|index
op_increment
)paren
r_switch
c_cond
(paren
id|index
)paren
(brace
multiline_comment|/* Begin parse switch */
r_case
l_int|1
suffix:colon
id|board.status
op_assign
id|ints
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------&n;&t;&t;&t;&t;&t;We check for 2 (As opposed to 1; because 2 is a flag&n;&t;&t;&t;&t;&t;instructing the driver to ignore epcaconfig.)  For this&n;&t;&t;&t;&t;&t;reason we check for 2.&n;&t;&t;&t;&t;------------------------------------------------------------ */
r_if
c_cond
(paren
id|board.status
op_eq
l_int|2
)paren
(brace
multiline_comment|/* Begin ignore epcaconfig as well as lilo cmd line */
id|nbdevs
op_assign
l_int|0
suffix:semicolon
id|num_cards
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* End ignore epcaconfig as well as lilo cmd line */
r_if
c_cond
(paren
id|board.status
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - epca_setup: Invalid board status 0x%x&bslash;n&quot;
comma
id|board.status
)paren
suffix:semicolon
id|invalid_lilo_config
op_assign
l_int|1
suffix:semicolon
id|setup_error_code
op_or_assign
id|INVALID_BOARD_STATUS
suffix:semicolon
r_return
suffix:semicolon
)brace
id|last
op_assign
id|index
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|board.type
op_assign
id|ints
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|board.type
op_ge
id|PCIXEM
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - epca_setup: Invalid board type 0x%x&bslash;n&quot;
comma
id|board.type
)paren
suffix:semicolon
id|invalid_lilo_config
op_assign
l_int|1
suffix:semicolon
id|setup_error_code
op_or_assign
id|INVALID_BOARD_TYPE
suffix:semicolon
r_return
suffix:semicolon
)brace
id|last
op_assign
id|index
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|board.altpin
op_assign
id|ints
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|board.altpin
OG
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - epca_setup: Invalid board altpin 0x%x&bslash;n&quot;
comma
id|board.altpin
)paren
suffix:semicolon
id|invalid_lilo_config
op_assign
l_int|1
suffix:semicolon
id|setup_error_code
op_or_assign
id|INVALID_ALTPIN
suffix:semicolon
r_return
suffix:semicolon
)brace
id|last
op_assign
id|index
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|board.numports
op_assign
id|ints
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|board.numports
OL
l_int|2
)paren
op_logical_or
(paren
id|board.numports
OG
l_int|256
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - epca_setup: Invalid board numports 0x%x&bslash;n&quot;
comma
id|board.numports
)paren
suffix:semicolon
id|invalid_lilo_config
op_assign
l_int|1
suffix:semicolon
id|setup_error_code
op_or_assign
id|INVALID_NUM_PORTS
suffix:semicolon
r_return
suffix:semicolon
)brace
id|nbdevs
op_add_assign
id|board.numports
suffix:semicolon
id|last
op_assign
id|index
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|board.port
op_assign
(paren
r_int
r_char
op_star
)paren
id|ints
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|board.port
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - epca_setup: Invalid io port 0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|board.port
)paren
suffix:semicolon
id|invalid_lilo_config
op_assign
l_int|1
suffix:semicolon
id|setup_error_code
op_or_assign
id|INVALID_PORT_BASE
suffix:semicolon
r_return
suffix:semicolon
)brace
id|last
op_assign
id|index
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|board.membase
op_assign
(paren
r_int
r_char
op_star
)paren
id|ints
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|board.membase
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - epca_setup: Invalid memory base 0x%x&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|board.membase
)paren
suffix:semicolon
id|invalid_lilo_config
op_assign
l_int|1
suffix:semicolon
id|setup_error_code
op_or_assign
id|INVALID_MEM_BASE
suffix:semicolon
r_return
suffix:semicolon
)brace
id|last
op_assign
id|index
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - epca_setup: Too many integer parms&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* End parse switch */
r_while
c_loop
(paren
id|str
op_logical_and
op_star
id|str
)paren
(brace
multiline_comment|/* Begin while there is a string arg */
multiline_comment|/* find the next comma or terminator */
id|temp
op_assign
id|str
suffix:semicolon
multiline_comment|/* While string is not null, and a comma hasn&squot;t been found */
r_while
c_loop
(paren
op_star
id|temp
op_logical_and
(paren
op_star
id|temp
op_ne
l_char|&squot;,&squot;
)paren
)paren
id|temp
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|temp
)paren
id|temp
op_assign
l_int|NULL
suffix:semicolon
r_else
op_star
id|temp
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set index to the number of args + 1 */
id|index
op_assign
id|last
op_plus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|index
)paren
(brace
r_case
l_int|1
suffix:colon
id|len
op_assign
id|strlen
c_func
(paren
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
l_string|&quot;Disable&quot;
comma
id|str
comma
id|len
)paren
op_eq
l_int|0
)paren
id|board.status
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
l_string|&quot;Enable&quot;
comma
id|str
comma
id|len
)paren
op_eq
l_int|0
)paren
id|board.status
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - epca_setup: Invalid status %s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
id|invalid_lilo_config
op_assign
l_int|1
suffix:semicolon
id|setup_error_code
op_or_assign
id|INVALID_BOARD_STATUS
suffix:semicolon
r_return
suffix:semicolon
)brace
id|last
op_assign
id|index
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_for
c_loop
(paren
id|loop
op_assign
l_int|0
suffix:semicolon
id|loop
OL
id|EPCA_NUM_TYPES
suffix:semicolon
id|loop
op_increment
)paren
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|board_desc
(braket
id|loop
)braket
comma
id|str
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------------&n;&t;&t;&t;&t;&t;If the index incremented above refers to a legitamate board &n;&t;&t;&t;&t;&t;type set it here. &n;&t;&t;&t;&t;------------------------------------------------------------------*/
r_if
c_cond
(paren
id|index
OL
id|EPCA_NUM_TYPES
)paren
id|board.type
op_assign
id|loop
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - epca_setup: Invalid board type: %s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
id|invalid_lilo_config
op_assign
l_int|1
suffix:semicolon
id|setup_error_code
op_or_assign
id|INVALID_BOARD_TYPE
suffix:semicolon
r_return
suffix:semicolon
)brace
id|last
op_assign
id|index
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|len
op_assign
id|strlen
c_func
(paren
id|str
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
c_func
(paren
l_string|&quot;Disable&quot;
comma
id|str
comma
id|len
)paren
op_eq
l_int|0
)paren
id|board.altpin
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strncmp
c_func
(paren
l_string|&quot;Enable&quot;
comma
id|str
comma
id|len
)paren
op_eq
l_int|0
)paren
id|board.altpin
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - epca_setup: Invalid altpin %s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
id|invalid_lilo_config
op_assign
l_int|1
suffix:semicolon
id|setup_error_code
op_or_assign
id|INVALID_ALTPIN
suffix:semicolon
r_return
suffix:semicolon
)brace
id|last
op_assign
id|index
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|t2
op_assign
id|str
suffix:semicolon
r_while
c_loop
(paren
id|isdigit
c_func
(paren
op_star
id|t2
)paren
)paren
id|t2
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|t2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - epca_setup: Invalid port count %s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
id|invalid_lilo_config
op_assign
l_int|1
suffix:semicolon
id|setup_error_code
op_or_assign
id|INVALID_NUM_PORTS
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* ------------------------------------------------------------&n;&t;&t;&t;&t;&t;There is not a man page for simple_strtoul but the code can be &n;&t;&t;&t;&t;&t;found in vsprintf.c.  The first argument is the string to &n;&t;&t;&t;&t;&t;translate (To an unsigned long obviously),  the second argument&n;&t;&t;&t;&t;&t;can be the address of any character variable or a NULL.  If a&n;&t;&t;&t;&t;&t;variable is given, the end pointer of the string will be stored &n;&t;&t;&t;&t;&t;in that variable; if a NULL is given the end pointer will &n;&t;&t;&t;&t;&t;not be returned.  The last argument is the base to use.  If &n;&t;&t;&t;&t;&t;a 0 is indicated, the routine will attempt to determine the &n;&t;&t;&t;&t;&t;proper base by looking at the values prefix (A &squot;0&squot; for octal,&n;&t;&t;&t;&t;&t;a &squot;x&squot; for hex, etc ...  If a value is given it will use that &n;&t;&t;&t;&t;&t;value as the base. &n;&t;&t;&t;&t;---------------------------------------------------------------- */
id|board.numports
op_assign
id|simple_strtoul
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
id|nbdevs
op_add_assign
id|board.numports
suffix:semicolon
id|last
op_assign
id|index
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|t2
op_assign
id|str
suffix:semicolon
r_while
c_loop
(paren
id|isxdigit
c_func
(paren
op_star
id|t2
)paren
)paren
id|t2
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|t2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - epca_setup: Invalid i/o address %s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
id|invalid_lilo_config
op_assign
l_int|1
suffix:semicolon
id|setup_error_code
op_or_assign
id|INVALID_PORT_BASE
suffix:semicolon
r_return
suffix:semicolon
)brace
id|board.port
op_assign
(paren
r_int
r_char
op_star
)paren
id|simple_strtoul
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
id|last
op_assign
id|index
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|t2
op_assign
id|str
suffix:semicolon
r_while
c_loop
(paren
id|isxdigit
c_func
(paren
op_star
id|t2
)paren
)paren
id|t2
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|t2
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;&lt;Error&gt; - epca_setup: Invalid memory base %s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
id|invalid_lilo_config
op_assign
l_int|1
suffix:semicolon
id|setup_error_code
op_or_assign
id|INVALID_MEM_BASE
suffix:semicolon
r_return
suffix:semicolon
)brace
id|board.membase
op_assign
(paren
r_int
r_char
op_star
)paren
id|simple_strtoul
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
id|last
op_assign
id|index
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PC/Xx: Too many string parms&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|str
op_assign
id|temp
suffix:semicolon
)brace
multiline_comment|/* End while there is a string arg */
r_if
c_cond
(paren
id|last
OL
l_int|6
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;PC/Xx: Insufficient parms specified&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* I should REALLY validate the stuff here */
multiline_comment|/* Copies our local copy of board into boards */
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|boards
(braket
id|num_cards
)braket
comma
(paren
r_void
op_star
)paren
op_amp
id|board
comma
r_sizeof
(paren
id|board
)paren
)paren
suffix:semicolon
multiline_comment|/* Does this get called once per lilo arg are what ? */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;PC/Xx: Added board %i, %s %i ports at 0x%4.4X base 0x%6.6X&bslash;n&quot;
comma
id|num_cards
comma
id|board_desc
(braket
id|board.type
)braket
comma
id|board.numports
comma
(paren
r_int
)paren
id|board.port
comma
(paren
r_int
r_int
)paren
id|board.membase
)paren
suffix:semicolon
id|num_cards
op_increment
suffix:semicolon
)brace
multiline_comment|/* End epca_setup */
macro_line|#ifdef ENABLE_PCI
multiline_comment|/* ------------------------ Begin init_PCI  --------------------------- */
DECL|enum|epic_board_types
r_enum
id|epic_board_types
(brace
DECL|enumerator|brd_xr
id|brd_xr
op_assign
l_int|0
comma
DECL|enumerator|brd_xem
id|brd_xem
comma
DECL|enumerator|brd_cx
id|brd_cx
comma
DECL|enumerator|brd_xrj
id|brd_xrj
comma
)brace
suffix:semicolon
multiline_comment|/* indexed directly by epic_board_types enum */
r_static
r_struct
(brace
DECL|member|board_type
r_int
r_char
id|board_type
suffix:semicolon
DECL|member|bar_idx
r_int
id|bar_idx
suffix:semicolon
multiline_comment|/* PCI base address region */
DECL|variable|epca_info_tbl
)brace
id|epca_info_tbl
(braket
)braket
op_assign
(brace
(brace
id|PCIXR
comma
l_int|0
comma
)brace
comma
(brace
id|PCIXEM
comma
l_int|0
comma
)brace
comma
(brace
id|PCICX
comma
l_int|0
comma
)brace
comma
(brace
id|PCIXRJ
comma
l_int|2
comma
)brace
comma
)brace
suffix:semicolon
DECL|function|epca_init_one
r_static
r_int
id|__init
id|epca_init_one
(paren
r_struct
id|pci_dev
op_star
id|pdev
comma
r_const
r_struct
id|pci_device_id
op_star
id|ent
)paren
(brace
r_static
r_int
id|board_num
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|board_idx
comma
id|info_idx
op_assign
id|ent-&gt;driver_data
suffix:semicolon
r_int
r_int
id|addr
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|board_num
op_increment
suffix:semicolon
id|board_idx
op_assign
id|board_num
op_plus
id|num_cards
suffix:semicolon
r_if
c_cond
(paren
id|board_idx
op_ge
id|MAXBOARDS
)paren
r_goto
id|err_out
suffix:semicolon
id|addr
op_assign
id|pci_resource_start
(paren
id|pdev
comma
id|epca_info_tbl
(braket
id|info_idx
)braket
dot
id|bar_idx
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|addr
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|PFX
l_string|&quot;PCI region #%d not available (size 0)&bslash;n&quot;
comma
id|epca_info_tbl
(braket
id|info_idx
)braket
dot
id|bar_idx
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|boards
(braket
id|board_idx
)braket
dot
id|status
op_assign
id|ENABLED
suffix:semicolon
id|boards
(braket
id|board_idx
)braket
dot
id|type
op_assign
id|epca_info_tbl
(braket
id|info_idx
)braket
dot
id|board_type
suffix:semicolon
id|boards
(braket
id|board_idx
)braket
dot
id|numports
op_assign
l_int|0x0
suffix:semicolon
id|boards
(braket
id|board_idx
)braket
dot
id|port
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|addr
op_plus
id|PCI_IO_OFFSET
)paren
suffix:semicolon
id|boards
(braket
id|board_idx
)braket
dot
id|membase
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|addr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_mem_region
(paren
id|addr
op_plus
id|PCI_IO_OFFSET
comma
l_int|0x200000
comma
l_string|&quot;epca&quot;
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|PFX
l_string|&quot;resource 0x%x @ 0x%lx unavailable&bslash;n&quot;
comma
l_int|0x200000
comma
id|addr
op_plus
id|PCI_IO_OFFSET
)paren
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
id|boards
(braket
id|board_idx
)braket
dot
id|re_map_port
op_assign
id|ioremap
c_func
(paren
id|addr
op_plus
id|PCI_IO_OFFSET
comma
l_int|0x200000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|boards
(braket
id|board_idx
)braket
dot
id|re_map_port
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|PFX
l_string|&quot;cannot map 0x%x @ 0x%lx&bslash;n&quot;
comma
l_int|0x200000
comma
id|addr
op_plus
id|PCI_IO_OFFSET
)paren
suffix:semicolon
r_goto
id|err_out_free_pciio
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|request_mem_region
(paren
id|addr
comma
l_int|0x200000
comma
l_string|&quot;epca&quot;
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|PFX
l_string|&quot;resource 0x%x @ 0x%lx unavailable&bslash;n&quot;
comma
l_int|0x200000
comma
id|addr
)paren
suffix:semicolon
r_goto
id|err_out_free_iounmap
suffix:semicolon
)brace
id|boards
(braket
id|board_idx
)braket
dot
id|re_map_membase
op_assign
id|ioremap
c_func
(paren
id|addr
comma
l_int|0x200000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|boards
(braket
id|board_idx
)braket
dot
id|re_map_membase
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|PFX
l_string|&quot;cannot map 0x%x @ 0x%lx&bslash;n&quot;
comma
l_int|0x200000
comma
id|addr
op_plus
id|PCI_IO_OFFSET
)paren
suffix:semicolon
r_goto
id|err_out_free_memregion
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------&n;&t;&t;I don&squot;t know what the below does, but the hardware guys say&n;&t;&t;its required on everything except PLX (In this case XRJ).&n;&t;---------------------------------------------------------------- */
r_if
c_cond
(paren
id|info_idx
op_ne
id|brd_xrj
)paren
(brace
id|pci_write_config_byte
c_func
(paren
id|pdev
comma
l_int|0x40
comma
l_int|0
)paren
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|pdev
comma
l_int|0x46
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|err_out_free_memregion
suffix:colon
id|release_mem_region
(paren
id|addr
comma
l_int|0x200000
)paren
suffix:semicolon
id|err_out_free_iounmap
suffix:colon
id|iounmap
(paren
id|boards
(braket
id|board_idx
)braket
dot
id|re_map_port
)paren
suffix:semicolon
id|err_out_free_pciio
suffix:colon
id|release_mem_region
(paren
id|addr
op_plus
id|PCI_IO_OFFSET
comma
l_int|0x200000
)paren
suffix:semicolon
id|err_out
suffix:colon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
DECL|variable|__initdata
r_static
r_struct
id|pci_device_id
id|epca_pci_tbl
(braket
)braket
id|__initdata
op_assign
(brace
(brace
id|PCI_VENDOR_DIGI
comma
id|PCI_DEVICE_XR
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|brd_xr
)brace
comma
(brace
id|PCI_VENDOR_DIGI
comma
id|PCI_DEVICE_XEM
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|brd_xem
)brace
comma
(brace
id|PCI_VENDOR_DIGI
comma
id|PCI_DEVICE_CX
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|brd_cx
)brace
comma
(brace
id|PCI_VENDOR_DIGI
comma
id|PCI_DEVICE_XRJ
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
l_int|0
comma
l_int|0
comma
id|brd_xrj
)brace
comma
(brace
l_int|0
comma
)brace
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|epca_pci_tbl
)paren
suffix:semicolon
DECL|function|init_PCI
r_int
id|__init
id|init_PCI
(paren
r_void
)paren
(brace
multiline_comment|/* Begin init_PCI */
r_int
id|pci_count
suffix:semicolon
id|memset
(paren
op_amp
id|epca_driver
comma
l_int|0
comma
r_sizeof
(paren
id|epca_driver
)paren
)paren
suffix:semicolon
id|epca_driver.name
op_assign
l_string|&quot;epca&quot;
suffix:semicolon
id|epca_driver.id_table
op_assign
id|epca_pci_tbl
suffix:semicolon
id|epca_driver.probe
op_assign
id|epca_init_one
suffix:semicolon
id|pci_count
op_assign
id|pci_register_driver
(paren
op_amp
id|epca_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_count
op_le
l_int|0
)paren
(brace
id|pci_unregister_driver
(paren
op_amp
id|epca_driver
)paren
suffix:semicolon
id|pci_count
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|pci_count
suffix:semicolon
)brace
multiline_comment|/* End init_PCI */
macro_line|#endif /* ENABLE_PCI */
eof
