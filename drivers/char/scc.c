DECL|macro|RCS_ID
mdefine_line|#define RCS_ID &quot;$Id: scc.c,v 1.41 1995/12/17 22:36:40 jreuter Exp jreuter $&quot;
DECL|macro|BANNER
mdefine_line|#define BANNER &quot;Z8530 SCC driver version 2.01.dl1bke (alpha) by DL1BKE&bslash;n&quot;
multiline_comment|/*&n;&n;   ********************************************************************&n;   *   SCC.C - Linux driver for Z8530 based HDLC cards for AX.25      *&n;   ********************************************************************&n;&n;&n;   ********************************************************************&n;&n;&t;Copyright (c) 1993, 1995 Joerg Reuter DL1BKE&n;&n;&t;portions (c) 1993 Guido ten Dolle PE1NNZ&n;&n;   ********************************************************************&n;   &n;   The driver and the programs in the archive are UNDER CONSTRUCTION.&n;   The code is likely to fail, and so your kernel could --- even &n;   a whole network. &n;&n;   This driver is intended for Amateur Radio use. If you are running it&n;   for commercial purposes, please drop me a note. I am nosy...&n;&n;   ...BUT:&n; &n;   ! You  m u s t  recognize the appropriate legislations of your country !&n;   ! before you connect a radio to the SCC board and start to transmit or !&n;   ! receive. The GPL allows you to use the  d r i v e r,  NOT the RADIO! !&n;&n;   For non-Amateur-Radio use please note that you might need a special&n;   allowance/licence from the designer of the SCC Board and/or the&n;   MODEM. &n;&n;   This program is free software; you can redistribute it and/or modify &n;   it under the terms of the (modified) GNU General Public License &n;   delivered with the LinuX kernel source.&n;   &n;   This program is distributed in the hope that it will be useful,&n;   but WITHOUT ANY WARRANTY; without even the implied warranty of&n;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;   GNU General Public License for more details.&n;&n;   You should find a copy of the GNU General Public License in &n;   /usr/src/linux/COPYING; &n;   &n;   ******************************************************************** &n;&n;&n;   ...If you find any portions of the code that are copyrighted to you,&n;   and you don&squot;t want to see in here, please send me a private (!) &n;   message to my internet site. I will change it as soon as possible. &n;   Please don&squot;t flame to the tcp-group or anywhere else. Thanks!&n;&n;   Joerg Reuter&t;ampr-net: dl1bke@db0pra.ampr.org&n;&t;&t;AX-25   : DL1BKE @ DB0ACH.#NRW.DEU.EU&n;&t;&t;Internet: jreuter@lykos.tng.oche.de&n;&t;&t;&n;&t;&t;&n;   Incomplete history of z8530drv:&n;   -------------------------------&n;&n;   940913&t;- started to write the driver, rescued most of my own&n;&t;&t;  code (and Hans Alblas&squot; memory buffer pool concept) from &n;&t;&t;  an earlier project &quot;sccdrv&quot; which was initiated by &n;&t;&t;  Guido ten Dolle. Not much of the old driver survived, &n;&t;&t;  though. The first version I put my hands on was sccdrv1.3&n;&t;&t;  from August 1993. The memory buffer pool concept&n;&t;&t;  appeared in an unauthorized sccdrv version (1.5) from&n;&t;&t;  August 1994.&n;&n;   950131&t;- changed copyright notice to GPL without limitations.&n;   &n;     .&n;     .&n;     .&n;      &n;   950922&t;- using kernel timer chain&n;   &n;   951002&t;- splitting timer routine, adding support for throttle/&n;   &t;&t;  unthrottle calls, removed typo in kiss decoder,&n;   &t;&t;  corrected termios settings.&n;   &t;&t;  &n;   951011&t;- at last found one (the?) problem which caused the &n;   &t;&t;  driver to mess up buffers on heavy load pe1ayx was&n;   &t;&t;  complaining about. Quite simple to reproduce:&n;   &t;&t;  set a 9k6 port into audio loopback, add a route&n;   &t;&t;  to 44.99.99.99 on that route and do a &n;   &t;&t;  ping -f 44.99.99.99&n;   &t;&t;  &n;   951013&t;- it still does not survive a flood ping...&n;   &n;   951107&t;- axattach w/o &quot;-s&quot; option (or setting an invalid &n;   &t;&t;  baudrate) does not produce &quot;division by zero&quot; faults &n;   &t;&t;  anymore.&n;   &t;&t;  &n;   951114&t;- rewrote memory management, took first steps to allow&n;&t;&t;  compilation as a module. Well, it looks like a whole&n;&t;&t;  new driver now. BTW: It  d o e s  survive the flood&n;&t;&t;  ping at last...&n;&t;&t;  &n;   951116&t;- scc_config.h is gone -- the driver will be initialized&n;   &t;&t;  through ioctl-commands. Use sccinit.c for this purpose.&n;   &t;&t;  &n;   951117&t;- Well --- what should I say: You can compile it as a&n;   &t;&t;  module now. And I solved the problem with slip.c...&n;   &t;&t;  &n;   951120&t;- most ioctl() routines may be called w/o suser()&n;   &t;&t;  permissions, check if you&squot;ve set the permissions of&n;   &t;&t;  /dev/scc* right! NOT 0666, you know it&squot;s evil ;-)&n;   &t;&t;  &n;   951217&t;- found silly bug in init_channel(), some bugfixes&n;   &t;&t;  for the &quot;standalone&quot; module&n;&n;&n;   Thanks to:&n;   ----------&n;   &n;   PE1CHL Rob&t;- for a lot of good ideas from his SCC driver for DOS&n;   PE1NNZ Guido - for his port of the original driver to Linux&n;   KA9Q   Phil  - from whom we stole the mbuf-structure&n;   PA3AYX Hans  - for some useful changes&n;   DL8MBT Flori - for support&n;   DG0FT  Rene  - for the BayCom USCC support&n;   PA3AOU Harry - for ESCC testing, information supply and support&n;   &n;   PE1KOX Rob, DG1RTF Thomas, ON5QK Roland, G4XYW Andy, Linus,&n;   EI9GL Paul,&n;   &n;   and all who sent me bug reports and ideas... &n;   &n;   &n;   NB -- if you find errors, change something, please let me know&n;      &t; first before you distribute it... And please don&squot;t touch&n;   &t; the version number. Just replace my callsign in&n;   &t; &quot;v2.01.dl1bke&quot; with your own. Just to avoid confusion...&n;   &t; &n;   If you want to add your modification to the linux distribution&n;   please (!) contact me first.&n;   &t;  &n;   J&#xfffd;rg Reuter DL1BKE&n;  &n;*/
multiline_comment|/* ----------------------------------------------------------------------- */
DECL|macro|DEBUG_BUFFERS
mdefine_line|#define DEBUG_BUFFERS&t;/* keep defined unless it is really stable... */
DECL|macro|SCC_DELAY
macro_line|#undef  SCC_DELAY &t;/* perhaps a 486DX2 is a *bit* too fast */
DECL|macro|SCC_LDELAY
macro_line|#undef  SCC_LDELAY 5&t;/* slow it even a bit more down */
DECL|macro|DONT_CHECK
macro_line|#undef  DONT_CHECK&t;/* don&squot;t look if the SCCs you specified are available */
DECL|macro|MAXSCC
mdefine_line|#define MAXSCC          4       /* number of max. supported chips */
DECL|macro|RXBUFFERS
mdefine_line|#define RXBUFFERS       8       /* default number of RX buffers */
DECL|macro|TXBUFFERS
mdefine_line|#define TXBUFFERS       8       /* default number of TX buffers */
DECL|macro|BUFSIZE
mdefine_line|#define BUFSIZE         384     /* must not exceed 4096-sizeof(mbuf) */
DECL|macro|TPS
mdefine_line|#define TPS             25      /* scc_tx_timer():  Ticks Per Second */
DECL|macro|DEFAULT_CLOCK
mdefine_line|#define DEFAULT_CLOCK&t;4915200 /* default pclock if nothing is specified */
multiline_comment|/* ----------------------------------------------------------------------- */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_driver.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/scc.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;ctype.h&gt;
macro_line|#include &lt;time.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#ifdef MODULE
r_int
id|init_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifndef Z8530_MAJOR
DECL|macro|Z8530_MAJOR
mdefine_line|#define Z8530_MAJOR 34
macro_line|#endif
r_int
id|scc_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_struct
id|mbuf
op_star
id|scc_enqueue_buffer
c_func
(paren
r_struct
id|mbuf
op_star
op_star
id|queue
comma
r_struct
id|mbuf
op_star
id|buffer
)paren
suffix:semicolon
r_static
r_struct
id|mbuf
op_star
id|scc_dequeue_buffer
c_func
(paren
r_struct
id|mbuf
op_star
op_star
id|queue
)paren
suffix:semicolon
r_static
r_void
id|alloc_buffer_pool
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
suffix:semicolon
r_static
r_void
id|free_buffer_pool
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
suffix:semicolon
r_static
r_struct
id|mbuf
op_star
id|scc_get_buffer
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_char
id|type
)paren
suffix:semicolon
r_int
id|scc_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|scc_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_int
id|scc_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_void
id|scc_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
suffix:semicolon
r_static
r_void
id|scc_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|scc_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|scc_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|scc_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|scc_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|scc_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old_termios
)paren
suffix:semicolon
r_static
r_void
id|scc_set_ldisc
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|scc_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|scc_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|scc_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|scc_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|z8530_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|scc_change_speed
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
suffix:semicolon
r_static
r_void
id|kiss_encode
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
suffix:semicolon
r_static
r_void
id|init_channel
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
suffix:semicolon
r_static
r_void
id|scc_key_trx
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_char
id|tx
)paren
suffix:semicolon
r_static
r_void
id|scc_txint
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
suffix:semicolon
r_static
r_void
id|scc_exint
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
suffix:semicolon
r_static
r_void
id|scc_rxint
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
suffix:semicolon
r_static
r_void
id|scc_spint
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
suffix:semicolon
r_static
r_void
id|scc_isr
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|scc_tx_timer
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|scc_rx_timer
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|scc_init_timer
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
suffix:semicolon
multiline_comment|/* from serial.c */
DECL|variable|baud_table
r_static
r_int
id|baud_table
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|50
comma
l_int|75
comma
l_int|110
comma
l_int|134
comma
l_int|150
comma
l_int|200
comma
l_int|300
comma
l_int|600
comma
l_int|1200
comma
l_int|1800
comma
l_int|2400
comma
l_int|4800
comma
l_int|9600
comma
l_int|19200
comma
l_int|38400
comma
l_int|57600
comma
l_int|115200
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|scc_driver
r_struct
id|tty_driver
id|scc_driver
suffix:semicolon
DECL|variable|scc_refcount
r_static
r_int
id|scc_refcount
suffix:semicolon
DECL|variable|scc_table
r_static
r_struct
id|tty_struct
op_star
id|scc_table
(braket
l_int|2
op_star
id|MAXSCC
)braket
suffix:semicolon
DECL|variable|scc_termios
r_static
r_struct
id|termios
id|scc_termios
(braket
l_int|2
op_star
id|MAXSCC
)braket
suffix:semicolon
DECL|variable|scc_termios_locked
r_static
r_struct
id|termios
id|scc_termios_locked
(braket
l_int|2
op_star
id|MAXSCC
)braket
suffix:semicolon
DECL|struct|irqflags
DECL|member|used
DECL|variable|Ivec
r_struct
id|irqflags
(brace
r_int
r_char
id|used
suffix:colon
l_int|1
suffix:semicolon
)brace
id|Ivec
(braket
l_int|16
)braket
suffix:semicolon
DECL|variable|SCC_Info
r_struct
id|scc_channel
id|SCC_Info
(braket
l_int|2
op_star
id|MAXSCC
)braket
suffix:semicolon
multiline_comment|/* information per channel */
DECL|variable|SCC_ctrl
id|io_port
id|SCC_ctrl
(braket
l_int|2
op_star
id|MAXSCC
)braket
suffix:semicolon
multiline_comment|/* Control ports */
DECL|variable|Random
r_int
r_char
id|Random
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* random number for p-persist */
DECL|variable|Driver_Initialized
r_int
r_char
id|Driver_Initialized
op_assign
l_int|0
suffix:semicolon
DECL|variable|Nchips
r_int
id|Nchips
op_assign
l_int|0
suffix:semicolon
DECL|variable|Vector_Latch
id|io_port
id|Vector_Latch
op_assign
l_int|0
suffix:semicolon
DECL|variable|scc_sem
r_struct
id|semaphore
id|scc_sem
op_assign
id|MUTEX
suffix:semicolon
DECL|variable|scc_wbuf
r_int
r_char
id|scc_wbuf
(braket
id|BUFSIZE
)braket
suffix:semicolon
DECL|variable|scc_std_termios
r_static
r_struct
id|termios
id|scc_std_termios
suffix:semicolon
multiline_comment|/* ******************************************************************** */
multiline_comment|/* *&t;&t;&t;Port Access Functions&t;&t;&t;      * */
multiline_comment|/* ******************************************************************** */
r_static
r_inline
r_int
r_char
DECL|function|InReg
id|InReg
c_func
(paren
r_register
id|io_port
id|port
comma
r_register
r_int
r_char
id|reg
)paren
(brace
macro_line|#ifdef SCC_LDELAY
r_register
r_int
r_char
id|r
suffix:semicolon
id|Outb
c_func
(paren
id|port
comma
id|reg
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|SCC_LDELAY
)paren
suffix:semicolon
id|r
op_assign
id|Inb
c_func
(paren
id|port
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|SCC_LDELAY
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
macro_line|#else
id|Outb
c_func
(paren
id|port
comma
id|reg
)paren
suffix:semicolon
r_return
id|Inb
c_func
(paren
id|port
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_inline
r_void
DECL|function|OutReg
id|OutReg
c_func
(paren
r_register
id|io_port
id|port
comma
r_register
r_int
r_char
id|reg
comma
r_register
r_int
r_char
id|val
)paren
(brace
macro_line|#ifdef SCC_LDELAY
id|Outb
c_func
(paren
id|port
comma
id|reg
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|SCC_LDELAY
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|port
comma
id|val
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|SCC_LDELAY
)paren
suffix:semicolon
macro_line|#else
id|Outb
c_func
(paren
id|port
comma
id|reg
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|port
comma
id|val
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_inline
r_void
DECL|function|wr
id|wr
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
comma
r_register
r_int
r_char
id|reg
comma
r_register
r_int
r_char
id|val
)paren
(brace
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|reg
comma
(paren
id|scc-&gt;wreg
(braket
id|reg
)braket
op_assign
id|val
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|or
op_logical_or
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
comma
r_register
r_int
r_char
id|reg
comma
r_register
r_int
r_char
id|val
)paren
(brace
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|reg
comma
(paren
id|scc-&gt;wreg
(braket
id|reg
)braket
op_or_assign
id|val
)paren
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|cl
id|cl
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
comma
r_register
r_int
r_char
id|reg
comma
r_register
r_int
r_char
id|val
)paren
(brace
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|reg
comma
(paren
id|scc-&gt;wreg
(braket
id|reg
)braket
op_and_assign
op_complement
id|val
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* * &t;&t;&t;Memory Buffer Management&t;&t;&t;*/
multiline_comment|/* ******************************************************************** */
multiline_comment|/*&n; * The new buffer scheme uses a ring chain of buffers. This has the&n; * advantage to access both, first and last element of the list, very&n; * fast. It has the disadvantage to mess things up double if something&n; * is wrong.&n; *&n; * Every scc channel has its own buffer pool now with an adjustable&n; * number of buffers for transmit and receive buffers. The buffer&n; * size remains the same for each AX.25 frame, but is (as a semi-&n; * undocumented feature) adjustable within a range of 512 and 4096&n; * to benefit experiments with higher frame lengths. If you need&n; * larger frames... Well, you&squot;d better choose a whole new concept&n; * for that, like a DMA capable I/O card and a block device driver...&n; *&n; */
multiline_comment|/* ------ Management of buffer queues ------ */
multiline_comment|/* Insert a buffer at the &quot;end&quot; of the chain */
r_static
r_struct
id|mbuf
op_star
DECL|function|scc_enqueue_buffer
id|scc_enqueue_buffer
c_func
(paren
r_struct
id|mbuf
op_star
op_star
id|queue
comma
r_struct
id|mbuf
op_star
id|buffer
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|mbuf
op_star
id|anchor
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* do not disturb! */
macro_line|#ifdef DEBUG_BUFFERS&t;&t;&t;
r_if
c_cond
(paren
id|queue
op_eq
id|NULLBUFP
)paren
multiline_comment|/* called with illegal parameters, notify the user */
(brace
id|printk
c_func
(paren
l_string|&quot;z8530drv: Pointer to queue anchor is NULL pointer [enq]&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|NULLBUF
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer
op_eq
id|NULLBUF
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;z8530drv: can&squot;t enqueue a NULL pointer&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|NULLBUF
suffix:semicolon
)brace
macro_line|#endif
id|anchor
op_assign
op_star
id|queue
suffix:semicolon
multiline_comment|/* the anchor is the &quot;start&quot; of the chain */
r_if
c_cond
(paren
id|anchor
op_eq
id|NULLBUF
)paren
multiline_comment|/* found an empty list */
(brace
op_star
id|queue
op_assign
id|buffer
suffix:semicolon
multiline_comment|/* new anchor */
id|buffer-&gt;next
op_assign
id|buffer-&gt;prev
op_assign
id|NULLBUF
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|anchor-&gt;prev
op_eq
id|NULLBUF
)paren
multiline_comment|/* list has one member only */
(brace
macro_line|#ifdef DEBUG_BUFFERS
r_if
c_cond
(paren
id|anchor-&gt;prev
op_ne
id|NULLBUF
)paren
multiline_comment|/* oops?! */
id|printk
c_func
(paren
l_string|&quot;weird --- anchor-&gt;prev is NULL but not anchor-&gt;next [enq]&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;
id|anchor-&gt;next
op_assign
id|anchor-&gt;prev
op_assign
id|buffer
suffix:semicolon
id|buffer-&gt;next
op_assign
id|buffer-&gt;prev
op_assign
id|anchor
suffix:semicolon
)brace
r_else
macro_line|#ifdef DEBUG_BUFFERS&t;
r_if
c_cond
(paren
id|anchor-&gt;next
op_eq
id|NULLBUF
)paren
multiline_comment|/* this has to be an error. Okay, make the best out of it */
(brace
id|printk
c_func
(paren
l_string|&quot;z8530drv: weird --- anchor-&gt;next is NULL but not anchor-&gt;prev [enq]&bslash;n&quot;
)paren
suffix:semicolon
id|anchor-&gt;next
op_assign
id|anchor-&gt;prev
op_assign
id|buffer
suffix:semicolon
id|buffer-&gt;next
op_assign
id|buffer-&gt;prev
op_assign
id|anchor
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
multiline_comment|/* every other case */
id|buffer-&gt;prev
op_assign
id|anchor-&gt;prev
suffix:semicolon
multiline_comment|/* self explaining, isn&squot;t it? */
id|buffer-&gt;next
op_assign
id|anchor
suffix:semicolon
id|anchor-&gt;prev-&gt;next
op_assign
id|buffer
suffix:semicolon
id|anchor-&gt;prev
op_assign
id|buffer
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_star
id|queue
suffix:semicolon
multiline_comment|/* return &quot;start&quot; of chain */
)brace
multiline_comment|/* Remove a buffer from the &quot;start&quot; of the chain an return it */
r_static
r_struct
id|mbuf
op_star
DECL|function|scc_dequeue_buffer
id|scc_dequeue_buffer
c_func
(paren
r_struct
id|mbuf
op_star
op_star
id|queue
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|mbuf
op_star
id|buffer
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG_BUFFERS&t;&t;&t;
r_if
c_cond
(paren
id|queue
op_eq
id|NULLBUFP
)paren
multiline_comment|/* called with illegal parameter */
(brace
id|printk
c_func
(paren
l_string|&quot;z8530drv: Pointer to queue anchor is NULL pointer [deq]&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|NULLBUF
suffix:semicolon
)brace
macro_line|#endif
id|buffer
op_assign
op_star
id|queue
suffix:semicolon
multiline_comment|/* head of the chain */
r_if
c_cond
(paren
id|buffer
op_ne
id|NULLBUF
)paren
multiline_comment|/* not an empty list? */
(brace
r_if
c_cond
(paren
id|buffer-&gt;prev
op_ne
id|NULLBUF
)paren
multiline_comment|/* not last buffer? */
(brace
macro_line|#ifdef DEBUG_BUFFERS
r_if
c_cond
(paren
id|buffer-&gt;next
op_eq
id|NULLBUF
)paren
(brace
multiline_comment|/* what?! */
id|printk
c_func
(paren
l_string|&quot;z8530drv: weird --- buffer-&gt;next is NULL but not buffer-&gt;prev [deq]&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
r_if
c_cond
(paren
id|buffer-&gt;prev-&gt;next
op_eq
id|buffer-&gt;prev-&gt;prev
)paren
(brace
multiline_comment|/* only one buffer remaining... */
id|buffer-&gt;next-&gt;prev
op_assign
id|NULLBUF
suffix:semicolon
id|buffer-&gt;next-&gt;next
op_assign
id|NULLBUF
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* the one remaining situation... */
id|buffer-&gt;next-&gt;prev
op_assign
id|buffer-&gt;prev
suffix:semicolon
id|buffer-&gt;prev-&gt;next
op_assign
id|buffer-&gt;next
suffix:semicolon
)brace
)brace
macro_line|#ifdef DEBUG_BUFFERS
r_else
r_if
c_cond
(paren
id|buffer-&gt;next
op_ne
id|NULLBUF
)paren
id|printk
c_func
(paren
l_string|&quot;z8530drv: weird --- buffer-&gt;prev is NULL but not buffer-&gt;next [deq]&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
op_star
id|queue
op_assign
id|buffer-&gt;next
suffix:semicolon
multiline_comment|/* new head of chain */
id|buffer-&gt;next
op_assign
id|NULLBUF
suffix:semicolon
multiline_comment|/* for securety only... */
id|buffer-&gt;prev
op_assign
id|NULLBUF
suffix:semicolon
id|buffer-&gt;rw_ptr
op_assign
id|buffer-&gt;data
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|buffer
suffix:semicolon
multiline_comment|/* give it away... */
)brace
multiline_comment|/* ------ buffer pool management ------ */
multiline_comment|/* allocate buffer pool&t;for a channel */
r_static
r_void
DECL|function|alloc_buffer_pool
id|alloc_buffer_pool
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_int
id|k
suffix:semicolon
r_struct
id|mbuf
op_star
id|bptr
suffix:semicolon
r_int
id|buflen
suffix:semicolon
id|buflen
op_assign
r_sizeof
(paren
r_struct
id|mbuf
)paren
op_plus
id|scc-&gt;stat.bufsize
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;stat.bufsize
OL
l_int|336
)paren
id|scc-&gt;stat.bufsize
op_assign
l_int|336
suffix:semicolon
r_if
c_cond
(paren
id|buflen
OG
l_int|4096
)paren
(brace
id|scc-&gt;stat.bufsize
op_assign
l_int|4096
op_minus
r_sizeof
(paren
r_struct
id|mbuf
)paren
suffix:semicolon
id|buflen
op_assign
l_int|4096
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scc-&gt;stat.rxbuffers
OL
l_int|4
)paren
id|scc-&gt;stat.rxbuffers
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;stat.txbuffers
OL
l_int|4
)paren
id|scc-&gt;stat.txbuffers
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* allocate receive buffers for this channel */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|scc-&gt;stat.rxbuffers
suffix:semicolon
id|k
op_increment
)paren
(brace
multiline_comment|/* allocate memory for the struct and the buffer */
id|bptr
op_assign
(paren
r_struct
id|mbuf
op_star
)paren
id|kmalloc
c_func
(paren
id|buflen
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/* should not happen, but who knows? */
r_if
c_cond
(paren
id|bptr
op_eq
id|NULLBUF
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;z8530drv: %s: can&squot;t allocate memory for rx buffer pool&quot;
comma
id|kdevname
c_func
(paren
id|scc-&gt;tty-&gt;device
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* clear memory */
id|memset
c_func
(paren
id|bptr
comma
l_int|0
comma
id|buflen
)paren
suffix:semicolon
multiline_comment|/* initialize structure */
id|bptr-&gt;rw_ptr
op_assign
id|bptr-&gt;data
suffix:semicolon
multiline_comment|/* and append the buffer to the pool */
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_buffer_pool
comma
id|bptr
)paren
suffix:semicolon
)brace
multiline_comment|/* now do the same for the transmit buffers */
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|scc-&gt;stat.txbuffers
suffix:semicolon
id|k
op_increment
)paren
(brace
id|bptr
op_assign
(paren
r_struct
id|mbuf
op_star
)paren
id|kmalloc
c_func
(paren
id|buflen
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bptr
op_eq
id|NULLBUF
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;z8530drv: %s: can&squot;t allocate memory for tx buffer pool&quot;
comma
id|kdevname
c_func
(paren
id|scc-&gt;tty-&gt;device
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
id|bptr
comma
l_int|0
comma
id|buflen
)paren
suffix:semicolon
id|bptr-&gt;rw_ptr
op_assign
id|bptr-&gt;data
suffix:semicolon
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
comma
id|bptr
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* remove buffer pool */
r_static
r_void
DECL|function|free_buffer_pool
id|free_buffer_pool
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_struct
id|mbuf
op_star
id|bptr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cnt
suffix:semicolon
multiline_comment|/* this one is a bit tricky and probably dangerous. */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* esp. to free the buffers currently in use by ISR */
id|bptr
op_assign
id|scc-&gt;rx_bp
suffix:semicolon
r_if
c_cond
(paren
id|bptr
op_ne
id|NULLBUF
)paren
(brace
id|scc-&gt;rx_bp
op_assign
id|NULLBUF
suffix:semicolon
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_buffer_pool
comma
id|bptr
)paren
suffix:semicolon
)brace
id|bptr
op_assign
id|scc-&gt;tx_bp
suffix:semicolon
r_if
c_cond
(paren
id|bptr
op_ne
id|NULLBUF
)paren
(brace
id|scc-&gt;tx_bp
op_assign
id|NULLBUF
suffix:semicolon
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
comma
id|bptr
)paren
suffix:semicolon
)brace
id|bptr
op_assign
id|scc-&gt;kiss_decode_bp
suffix:semicolon
r_if
c_cond
(paren
id|bptr
op_ne
id|NULLBUF
)paren
(brace
id|scc-&gt;kiss_decode_bp
op_assign
id|NULLBUF
suffix:semicolon
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
comma
id|bptr
)paren
suffix:semicolon
)brace
id|bptr
op_assign
id|scc-&gt;kiss_encode_bp
suffix:semicolon
r_if
c_cond
(paren
id|bptr
op_ne
id|NULLBUF
)paren
(brace
id|scc-&gt;kiss_encode_bp
op_assign
id|NULLBUF
suffix:semicolon
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_buffer_pool
comma
id|bptr
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|scc-&gt;rx_queue
op_ne
id|NULLBUF
)paren
(brace
id|bptr
op_assign
id|scc_dequeue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_queue
)paren
suffix:semicolon
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_buffer_pool
comma
id|bptr
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|scc-&gt;tx_queue
op_ne
id|NULLBUF
)paren
(brace
id|bptr
op_assign
id|scc_dequeue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_queue
)paren
suffix:semicolon
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
comma
id|bptr
)paren
suffix:semicolon
)brace
multiline_comment|/* you want to know why we move every buffer back to the&n;&t;   buffer pool? Well, good question... ;-) &n;&t; */
id|cnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Probably because we just want a central position in the&n;&t;   code were we actually call free()?&n;&t; */
r_while
c_loop
(paren
id|scc-&gt;rx_buffer_pool
op_ne
id|NULLBUF
)paren
(brace
id|bptr
op_assign
id|scc_dequeue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_buffer_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bptr
op_ne
id|NULLBUF
)paren
(brace
id|cnt
op_increment
suffix:semicolon
id|kfree
c_func
(paren
id|bptr
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cnt
OL
id|scc-&gt;stat.rxbuffers
)paren
multiline_comment|/* hmm... hmm... :-( */
id|printk
c_func
(paren
l_string|&quot;z8530drv: oops, deallocated only %d of %d rx buffers&bslash;n&quot;
comma
id|cnt
comma
id|scc-&gt;stat.rxbuffers
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|scc-&gt;stat.rxbuffers
)paren
multiline_comment|/* WHAT?!! */
id|printk
c_func
(paren
l_string|&quot;z8530drv: oops, deallocated %d instead of %d rx buffers. Very strange.&bslash;n&quot;
comma
id|cnt
comma
id|scc-&gt;stat.rxbuffers
)paren
suffix:semicolon
id|cnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|scc-&gt;tx_buffer_pool
op_ne
id|NULLBUF
)paren
(brace
id|bptr
op_assign
id|scc_dequeue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bptr
op_ne
id|NULLBUF
)paren
(brace
id|cnt
op_increment
suffix:semicolon
id|kfree
c_func
(paren
id|bptr
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cnt
OL
id|scc-&gt;stat.txbuffers
)paren
id|printk
c_func
(paren
l_string|&quot;z8530drv: oops, deallocated only %d of %d tx buffers&bslash;n&quot;
comma
id|cnt
comma
id|scc-&gt;stat.txbuffers
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OG
id|scc-&gt;stat.txbuffers
)paren
id|printk
c_func
(paren
l_string|&quot;z8530drv: oops, deallocated %d instead of %d tx buffers. Very strange.&bslash;n&quot;
comma
id|cnt
comma
id|scc-&gt;stat.txbuffers
)paren
suffix:semicolon
)brace
multiline_comment|/* ------ rx/tx buffer management ------ */
multiline_comment|/* &n;   get a fresh buffer from the pool if possible; if not: get one from&n;   the queue. We will remove the oldest frame from the queue and hope&n;   it was a good idea... ;-)&n;   &n; */
r_static
r_struct
id|mbuf
op_star
DECL|function|scc_get_buffer
id|scc_get_buffer
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_char
id|type
)paren
(brace
r_struct
id|mbuf
op_star
id|bptr
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|BT_TRANSMIT
)paren
(brace
id|bptr
op_assign
id|scc_dequeue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
)paren
suffix:semicolon
multiline_comment|/* no free buffers in the pool anymore? */
r_if
c_cond
(paren
id|bptr
op_eq
id|NULLBUF
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;z8530drv: scc_get_buffer(%s): tx buffer pool empty&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|scc-&gt;tty-&gt;device
)paren
)paren
suffix:semicolon
multiline_comment|/* use the oldest from the queue instead */
id|bptr
op_assign
id|scc_dequeue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_queue
)paren
suffix:semicolon
multiline_comment|/* this should never, ever happen... */
r_if
c_cond
(paren
id|bptr
op_eq
id|NULLBUF
)paren
id|printk
c_func
(paren
l_string|&quot;z8530drv: scc_get_buffer(): panic - even no buffer found in tx queue&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|bptr
op_assign
id|scc_dequeue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_buffer_pool
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bptr
op_eq
id|NULLBUF
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;z8530drv: scc_get_buffer(%s): rx buffer pool empty&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|scc-&gt;tty-&gt;device
)paren
)paren
suffix:semicolon
id|bptr
op_assign
id|scc_dequeue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bptr
op_eq
id|NULLBUF
)paren
id|printk
c_func
(paren
l_string|&quot;z8530drv: scc_get_buffer(): panic - even no buffer found in rx queue&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bptr
op_ne
id|NULLBUF
)paren
(brace
id|bptr-&gt;rw_ptr
op_assign
id|bptr-&gt;data
suffix:semicolon
id|bptr-&gt;cnt
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|bptr
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* *&t;&t;&t;Interrupt Service Routines&t;&t;      * */
multiline_comment|/* ******************************************************************** */
multiline_comment|/* ----&gt; interrupt service routine for the 8530 &lt;---- */
multiline_comment|/* it&squot;s recommendet to keep this function &quot;inline&quot; ;-) */
r_static
r_inline
r_void
DECL|function|scc_isr_dispatch
id|scc_isr_dispatch
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
comma
r_register
r_int
id|vector
)paren
(brace
r_switch
c_cond
(paren
id|vector
op_amp
id|VECTOR_MASK
)paren
(brace
r_case
id|TXINT
suffix:colon
id|scc_txint
c_func
(paren
id|scc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXINT
suffix:colon
id|scc_exint
c_func
(paren
id|scc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RXINT
suffix:colon
id|scc_rxint
c_func
(paren
id|scc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPINT
suffix:colon
id|scc_spint
c_func
(paren
id|scc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;scc_isr(): unknown interrupt status (addr %4.4x, state %2.2x)&bslash;n&quot;
comma
id|scc-&gt;ctrl
comma
id|vector
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* If the card has a latch for the interrupt vector (like the PA0HZP card)&n;   use it to get the number of the chip that generated the int.&n;   If not: poll all defined chips.&n; */
r_static
r_void
DECL|function|scc_isr
id|scc_isr
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_register
r_int
r_char
id|vector
suffix:semicolon
r_register
r_struct
id|scc_channel
op_star
id|scc
suffix:semicolon
r_register
id|io_port
id|q
suffix:semicolon
r_register
id|io_port
op_star
id|p
suffix:semicolon
r_register
r_int
id|k
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Vector_Latch
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
multiline_comment|/* forever...? */
(brace
id|Outb
c_func
(paren
id|Vector_Latch
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Generate INTACK */
multiline_comment|/* Read the vector */
r_if
c_cond
(paren
(paren
id|vector
op_assign
id|Inb
c_func
(paren
id|Vector_Latch
)paren
)paren
op_ge
l_int|16
op_star
id|Nchips
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* ...not forever! */
multiline_comment|/* Extract channel number and status from vector. */
multiline_comment|/* Isolate channel nummer */
multiline_comment|/* Call handler */
r_if
c_cond
(paren
id|vector
op_amp
l_int|0x01
)paren
r_break
suffix:semicolon
id|scc
op_assign
op_amp
id|SCC_Info
(braket
(paren
(paren
(paren
id|vector
op_rshift
l_int|1
)paren
op_amp
l_int|0x7c
)paren
op_xor
l_int|0x04
)paren
op_rshift
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;tty
)paren
r_break
suffix:semicolon
id|scc_isr_dispatch
c_func
(paren
id|scc
comma
id|vector
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
l_int|0x38
)paren
suffix:semicolon
multiline_comment|/* Reset Highest IUS&quot; opcode to WR0 */
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Find the SCC generating the interrupt by polling all attached SCCs&n;&t; * reading RR3A (the interrupt pending register)&n;&t; */
id|k
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|SCC_ctrl
suffix:semicolon
r_while
c_loop
(paren
id|k
op_increment
OL
id|Nchips
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|q
op_assign
op_star
id|p
op_increment
)paren
)paren
r_break
suffix:semicolon
id|Outb
c_func
(paren
id|q
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Inb
c_func
(paren
id|q
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|q
op_assign
op_star
id|p
op_increment
)paren
)paren
r_break
suffix:semicolon
id|Outb
c_func
(paren
id|q
comma
l_int|2
)paren
suffix:semicolon
id|vector
op_assign
id|Inb
c_func
(paren
id|q
)paren
suffix:semicolon
multiline_comment|/* Read the vector */
multiline_comment|/* Extract channel number and status from vector. */
multiline_comment|/* Isolate channel nummer */
multiline_comment|/* Call handler */
r_if
c_cond
(paren
id|vector
op_amp
l_int|1
)paren
r_break
suffix:semicolon
id|scc
op_assign
op_amp
id|SCC_Info
(braket
(paren
(paren
(paren
id|vector
op_rshift
l_int|1
)paren
op_amp
l_int|0x7c
)paren
op_xor
l_int|0x04
)paren
op_rshift
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;tty
)paren
r_break
suffix:semicolon
multiline_comment|/* Isolate status info from vector, call handler */
id|scc_isr_dispatch
c_func
(paren
id|scc
comma
id|vector
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
id|p
op_assign
id|SCC_ctrl
suffix:semicolon
)brace
r_else
id|p
op_increment
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* ----&gt; four different interrupt handlers for Tx, Rx, changing of&t;*/
multiline_comment|/*       DCD/CTS and Rx/Tx errors&t;&t;&t;&t;&t;*/
multiline_comment|/* Transmitter interrupt handler */
r_static
r_void
DECL|function|scc_txint
id|scc_txint
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_register
r_struct
id|mbuf
op_star
id|bp
suffix:semicolon
id|scc-&gt;stat.txints
op_increment
suffix:semicolon
id|bp
op_assign
id|scc-&gt;tx_bp
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
id|NULLBUF
)paren
(brace
r_do
(brace
r_if
c_cond
(paren
id|bp
op_ne
id|NULLBUF
)paren
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
comma
id|bp
)paren
suffix:semicolon
id|bp
op_assign
id|scc_dequeue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_queue
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
id|NULLBUF
)paren
(brace
id|scc-&gt;stat.tx_state
op_assign
id|TXS_BUSY
suffix:semicolon
id|scc-&gt;t_tail
op_assign
id|scc-&gt;kiss.tailtime
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_Tx_P
)paren
suffix:semicolon
multiline_comment|/* clear int */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scc-&gt;kiss.not_slip
op_logical_and
(paren
id|bp-&gt;cnt
OG
l_int|0
)paren
)paren
(brace
id|bp-&gt;rw_ptr
op_increment
suffix:semicolon
id|bp-&gt;cnt
op_decrement
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|bp-&gt;cnt
OL
l_int|1
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_Tx_CRC
)paren
suffix:semicolon
multiline_comment|/* reset CRC generator */
op_logical_or
(paren
id|scc
comma
id|R10
comma
id|ABUNDER
)paren
suffix:semicolon
multiline_comment|/* re-install underrun protection */
id|Outb
c_func
(paren
id|scc-&gt;data
comma
op_star
id|bp-&gt;rw_ptr
)paren
suffix:semicolon
multiline_comment|/* send byte */
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;enhanced
)paren
multiline_comment|/* reset EOM latch */
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_EOM_L
)paren
suffix:semicolon
id|scc-&gt;tx_bp
op_assign
id|bp
suffix:semicolon
id|scc-&gt;stat.tx_state
op_assign
id|TXS_ACTIVE
suffix:semicolon
multiline_comment|/* next byte... */
)brace
r_else
r_if
c_cond
(paren
id|bp-&gt;cnt
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|scc-&gt;stat.tx_queued
OL
l_int|0
)paren
id|scc-&gt;stat.tx_queued
op_assign
l_int|0
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_Tx_P
)paren
suffix:semicolon
multiline_comment|/* reset pending int */
id|cl
c_func
(paren
id|scc
comma
id|R10
comma
id|ABUNDER
)paren
suffix:semicolon
multiline_comment|/* send CRC */
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
comma
id|bp
)paren
suffix:semicolon
id|scc-&gt;tx_bp
op_assign
id|NULLBUF
suffix:semicolon
id|scc-&gt;stat.tx_state
op_assign
id|TXS_NEWFRAME
suffix:semicolon
multiline_comment|/* next frame... */
r_return
suffix:semicolon
)brace
r_else
(brace
id|Outb
c_func
(paren
id|scc-&gt;data
comma
op_star
id|bp-&gt;rw_ptr
)paren
suffix:semicolon
)brace
id|bp-&gt;rw_ptr
op_increment
suffix:semicolon
multiline_comment|/* increment pointer */
id|bp-&gt;cnt
op_decrement
suffix:semicolon
multiline_comment|/* decrease byte count */
)brace
r_static
r_inline
r_void
DECL|function|flush_FIFO
id|flush_FIFO
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_register
r_int
id|k
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|3
suffix:semicolon
id|k
op_increment
)paren
id|Inb
c_func
(paren
id|scc-&gt;data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;rx_bp
op_ne
id|NULLBUF
)paren
multiline_comment|/* did we receive something? */
(brace
id|scc-&gt;stat.rxerrs
op_increment
suffix:semicolon
multiline_comment|/* then count it as an error */
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_buffer_pool
comma
id|scc-&gt;rx_bp
)paren
suffix:semicolon
id|scc-&gt;rx_bp
op_assign
id|NULLBUF
suffix:semicolon
)brace
)brace
multiline_comment|/* External/Status interrupt handler */
r_static
r_void
DECL|function|scc_exint
id|scc_exint
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_register
r_int
r_char
id|status
comma
id|changes
comma
id|chg_and_stat
suffix:semicolon
id|scc-&gt;stat.exints
op_increment
suffix:semicolon
id|status
op_assign
id|InReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R0
)paren
suffix:semicolon
id|changes
op_assign
id|status
op_xor
id|scc-&gt;status
suffix:semicolon
id|chg_and_stat
op_assign
id|changes
op_amp
id|status
suffix:semicolon
multiline_comment|/* ABORT: generated whenever DCD drops while receiving */
r_if
c_cond
(paren
id|chg_and_stat
op_amp
id|BRK_ABRT
)paren
multiline_comment|/* Received an ABORT */
id|flush_FIFO
c_func
(paren
id|scc
)paren
suffix:semicolon
multiline_comment|/* DCD: on = start to receive packet, off = ABORT condition */
multiline_comment|/* (a successfully received packet generates a special condition int) */
r_if
c_cond
(paren
id|changes
op_amp
id|DCD
)paren
multiline_comment|/* DCD input changed state */
(brace
r_if
c_cond
(paren
id|status
op_amp
id|DCD
)paren
multiline_comment|/* DCD is now ON */
(brace
r_if
c_cond
(paren
id|scc-&gt;modem.clocksrc
op_ne
id|CLK_EXTERNAL
)paren
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R14
comma
id|SEARCH
op_or
id|scc-&gt;wreg
(braket
id|R14
)braket
)paren
suffix:semicolon
multiline_comment|/* DPLL: enter search mode */
op_logical_or
(paren
id|scc
comma
id|R3
comma
id|ENT_HM
op_or
id|RxENABLE
)paren
suffix:semicolon
multiline_comment|/* enable the receiver, hunt mode */
)brace
r_else
(brace
multiline_comment|/* DCD is now OFF */
id|cl
c_func
(paren
id|scc
comma
id|R3
comma
id|ENT_HM
op_or
id|RxENABLE
)paren
suffix:semicolon
multiline_comment|/* disable the receiver */
id|flush_FIFO
c_func
(paren
id|scc
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef notdef
multiline_comment|/* CTS: use external TxDelay (what&squot;s that good for?!) */
r_if
c_cond
(paren
id|chg_and_stat
op_amp
id|CTS
)paren
multiline_comment|/* CTS is now ON */
(brace
r_if
c_cond
(paren
op_logical_neg
id|Running
c_func
(paren
id|t_txdel
)paren
op_logical_and
id|scc-&gt;kiss.txdelay
op_eq
l_int|0
)paren
multiline_comment|/* zero TXDELAY = wait for CTS */
id|scc-&gt;t_txdel
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* kick it! */
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|status
op_amp
id|TxEOM
)paren
op_logical_and
(paren
id|scc-&gt;stat.tx_state
op_eq
id|TXS_ACTIVE
)paren
)paren
(brace
id|scc-&gt;stat.tx_under
op_increment
suffix:semicolon
multiline_comment|/* oops, an underrun! count &squot;em */
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_Tx_P
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_EXT_INT
)paren
suffix:semicolon
multiline_comment|/* reset ext/status interrupts */
id|scc-&gt;t_maxk
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;tx_bp
op_ne
id|NULLBUF
)paren
(brace
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
comma
id|scc-&gt;tx_bp
)paren
suffix:semicolon
id|scc-&gt;tx_bp
op_assign
id|NULLBUF
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|scc-&gt;stat.tx_queued
OL
l_int|0
)paren
id|scc-&gt;stat.tx_queued
op_assign
l_int|0
suffix:semicolon
op_logical_or
(paren
id|scc
comma
id|R10
comma
id|ABUNDER
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|ZCOUNT
)paren
multiline_comment|/* Oops? */
(brace
id|scc-&gt;stat.tx_under
op_assign
l_int|9999
suffix:semicolon
multiline_comment|/* errr... yes. */
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_Tx_P
)paren
suffix:semicolon
multiline_comment|/* just to be sure */
id|scc-&gt;t_maxk
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;tx_bp
op_ne
id|NULLBUF
)paren
(brace
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
comma
id|scc-&gt;tx_bp
)paren
suffix:semicolon
id|scc-&gt;tx_bp
op_assign
id|NULLBUF
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|scc-&gt;stat.tx_queued
OL
l_int|0
)paren
id|scc-&gt;stat.tx_queued
op_assign
l_int|0
suffix:semicolon
id|scc-&gt;kiss.tx_inhibit
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* don&squot;t try it again! */
)brace
id|scc-&gt;status
op_assign
id|status
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_EXT_INT
)paren
suffix:semicolon
)brace
multiline_comment|/* Receiver interrupt handler */
r_static
r_void
DECL|function|scc_rxint
id|scc_rxint
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_register
r_struct
id|mbuf
op_star
id|bp
suffix:semicolon
id|scc-&gt;stat.rxints
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|Running
c_func
(paren
id|t_maxk
)paren
op_logical_and
op_logical_neg
(paren
id|scc-&gt;kiss.fulldup
)paren
)paren
(brace
id|Inb
c_func
(paren
id|scc-&gt;data
)paren
suffix:semicolon
multiline_comment|/* discard char */
op_logical_or
(paren
id|scc
comma
id|R3
comma
id|ENT_HM
)paren
suffix:semicolon
multiline_comment|/* enter hunt mode for next flag */
r_return
suffix:semicolon
)brace
id|bp
op_assign
id|scc-&gt;rx_bp
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
id|NULLBUF
)paren
(brace
id|bp
op_assign
id|scc_get_buffer
c_func
(paren
id|scc
comma
id|BT_RECEIVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
id|NULLBUF
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;scc_rxint(): panic --- cannot get a buffer&bslash;n&quot;
)paren
suffix:semicolon
id|Inb
c_func
(paren
id|scc-&gt;data
)paren
suffix:semicolon
op_logical_or
(paren
id|scc
comma
id|R3
comma
id|ENT_HM
)paren
suffix:semicolon
id|scc-&gt;stat.nospace
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|scc-&gt;rx_bp
op_assign
id|bp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp-&gt;cnt
OG
id|scc-&gt;stat.bufsize
)paren
(brace
macro_line|#ifdef notdef
id|printk
c_func
(paren
l_string|&quot;scc_rxint(): oops, received huge frame...&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_buffer_pool
comma
id|bp
)paren
suffix:semicolon
id|scc-&gt;rx_bp
op_assign
id|NULLBUF
suffix:semicolon
id|Inb
c_func
(paren
id|scc-&gt;data
)paren
suffix:semicolon
op_logical_or
(paren
id|scc
comma
id|R3
comma
id|ENT_HM
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* now, we have a buffer. read character and store it */
op_star
id|bp-&gt;rw_ptr
op_assign
id|Inb
c_func
(paren
id|scc-&gt;data
)paren
suffix:semicolon
id|bp-&gt;rw_ptr
op_increment
suffix:semicolon
id|bp-&gt;cnt
op_increment
suffix:semicolon
)brace
multiline_comment|/* kick rx_timer (try to send received frame or part of it ASAP) */
multiline_comment|/* of course we could define a &quot;bottom half&quot; routine to do the job,&n;   but since its structures are saved in an array instead of a linked&n;   list we would get in trouble if it clashes with another driver or&n;   when we try to modularize the driver. IMHO we are fast enough&n;   with a timer routine called on the next timer-INT... Your opinions?&n; */
r_static
r_inline
r_void
DECL|function|kick_rx_timer
id|kick_rx_timer
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_if
c_cond
(paren
id|scc-&gt;rx_t.next
)paren
id|del_timer
c_func
(paren
op_amp
(paren
id|scc-&gt;rx_t
)paren
)paren
suffix:semicolon
id|scc-&gt;rx_t.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|scc-&gt;rx_t.function
op_assign
id|scc_rx_timer
suffix:semicolon
id|scc-&gt;rx_t.data
op_assign
(paren
r_int
r_int
)paren
id|scc
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|scc-&gt;rx_t
)paren
suffix:semicolon
)brace
multiline_comment|/* Receive Special Condition interrupt handler */
r_static
r_void
DECL|function|scc_spint
id|scc_spint
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_register
r_int
r_char
id|status
suffix:semicolon
r_register
r_struct
id|mbuf
op_star
id|bp
suffix:semicolon
id|scc-&gt;stat.spints
op_increment
suffix:semicolon
id|status
op_assign
id|InReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R1
)paren
suffix:semicolon
multiline_comment|/* read receiver status */
id|Inb
c_func
(paren
id|scc-&gt;data
)paren
suffix:semicolon
multiline_comment|/* throw away Rx byte */
id|bp
op_assign
id|scc-&gt;rx_bp
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|Rx_OVR
)paren
multiline_comment|/* receiver overrun */
(brace
id|scc-&gt;stat.rx_over
op_increment
suffix:semicolon
multiline_comment|/* count them */
op_logical_or
(paren
id|scc
comma
id|R3
comma
id|ENT_HM
)paren
suffix:semicolon
multiline_comment|/* enter hunt mode for next flag */
r_if
c_cond
(paren
id|bp
)paren
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_buffer_pool
comma
id|bp
)paren
suffix:semicolon
id|scc-&gt;rx_bp
op_assign
id|NULLBUF
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|END_FR
op_logical_and
id|bp
op_ne
id|NULLBUF
)paren
multiline_comment|/* end of frame */
(brace
multiline_comment|/* CRC okay, frame ends on 8 bit boundary and received something ? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|CRC_ERR
)paren
op_logical_and
(paren
id|status
op_amp
l_int|0xe
)paren
op_eq
id|RES8
op_logical_and
id|bp-&gt;cnt
)paren
(brace
multiline_comment|/* ignore last received byte (first of the CRC bytes) */
id|bp-&gt;cnt
op_decrement
suffix:semicolon
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_queue
comma
id|bp
)paren
suffix:semicolon
id|scc-&gt;rx_bp
op_assign
id|NULLBUF
suffix:semicolon
id|scc-&gt;stat.rxframes
op_increment
suffix:semicolon
id|scc-&gt;stat.rx_queued
op_increment
suffix:semicolon
id|kick_rx_timer
c_func
(paren
id|scc
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* a bad frame */
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_buffer_pool
comma
id|bp
)paren
suffix:semicolon
id|scc-&gt;rx_bp
op_assign
id|NULLBUF
suffix:semicolon
id|scc-&gt;stat.rxerrs
op_increment
suffix:semicolon
)brace
)brace
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|ERR_RES
)paren
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* *&t;&t;&t;Init Channel&t;&t;&t;&t;&t;*/
multiline_comment|/* ******************************************************************** */
multiline_comment|/* ----&gt; set SCC channel speed &lt;---- */
DECL|function|set_brg
r_static
r_inline
r_void
id|set_brg
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
comma
r_int
r_int
id|tc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* 2-step register accesses... */
id|cl
c_func
(paren
id|scc
comma
id|R14
comma
id|BRENABL
)paren
suffix:semicolon
multiline_comment|/* disable baudrate generator */
id|wr
c_func
(paren
id|scc
comma
id|R12
comma
id|tc
op_amp
l_int|255
)paren
suffix:semicolon
multiline_comment|/* brg rate LOW */
id|wr
c_func
(paren
id|scc
comma
id|R13
comma
id|tc
op_rshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* brg rate HIGH */
op_logical_or
(paren
id|scc
comma
id|R14
comma
id|BRENABL
)paren
suffix:semicolon
multiline_comment|/* enable baudrate generator */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|set_speed
r_static
r_inline
r_void
id|set_speed
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_if
c_cond
(paren
id|scc-&gt;modem.speed
OG
l_int|0
)paren
multiline_comment|/* paranoia... */
id|set_brg
c_func
(paren
id|scc
comma
(paren
r_int
)paren
(paren
id|scc-&gt;clock
op_div
(paren
id|scc-&gt;modem.speed
op_star
l_int|64
)paren
)paren
op_minus
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* ----&gt; initialize a SCC channel &lt;---- */
DECL|function|init_brg
r_static
r_inline
r_void
id|init_brg
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
id|wr
c_func
(paren
id|scc
comma
id|R14
comma
id|BRSRC
)paren
suffix:semicolon
multiline_comment|/* BRG source = PCLK */
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R14
comma
id|SSBR
op_or
id|scc-&gt;wreg
(braket
id|R14
)braket
)paren
suffix:semicolon
multiline_comment|/* DPLL source = BRG */
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R14
comma
id|SNRZI
op_or
id|scc-&gt;wreg
(braket
id|R14
)braket
)paren
suffix:semicolon
multiline_comment|/* DPLL NRZI mode */
)brace
multiline_comment|/*&n; * Initalization according to the Z8530 manual (SGS-Thomson&squot;s version):&n; *&n; * 1. Modes and constants&n; *&n; * WR9&t;11000000&t;chip reset&n; * WR4&t;XXXXXXXX&t;Tx/Rx control, async or sync mode&n; * WR1&t;0XX00X00&t;select W/REQ (optional)&n; * WR2&t;XXXXXXXX&t;program interrupt vector&n; * WR3&t;XXXXXXX0&t;select Rx control&n; * WR5&t;XXXX0XXX&t;select Tx control&n; * WR6&t;XXXXXXXX&t;sync character&n; * WR7&t;XXXXXXXX&t;sync character&n; * WR9&t;000X0XXX&t;select interrupt control&n; * WR10&t;XXXXXXXX&t;miscellaneous control (optional)&n; * WR11&t;XXXXXXXX&t;clock control&n; * WR12&t;XXXXXXXX&t;time constant lower byte (optional)&n; * WR13&t;XXXXXXXX&t;time constant upper byte (optional)&n; * WR14&t;XXXXXXX0&t;miscellaneous control&n; * WR14&t;XXXSSSSS&t;commands (optional)&n; *&n; * 2. Enables&n; *&n; * WR14&t;000SSSS1&t;baud rate enable&n; * WR3&t;SSSSSSS1&t;Rx enable&n; * WR5&t;SSSS1SSS&t;Tx enable&n; * WR0&t;10000000&t;reset Tx CRG (optional)&n; * WR1&t;XSS00S00&t;DMA enable (optional)&n; *&n; * 3. Interrupt status&n; *&n; * WR15&t;XXXXXXXX&t;enable external/status&n; * WR0&t;00010000&t;reset external status&n; * WR0&t;00010000&t;reset external status twice&n; * WR1&t;SSSXXSXX&t;enable Rx, Tx and Ext/status&n; * WR9&t;000SXSSS&t;enable master interrupt enable&n; *&n; * 1 = set to one, 0 = reset to zero&n; * X = user defined, S = same as previous init&n; *&n; *&n; * Note that the implementation differs in some points from above scheme.&n; *&n; */
r_static
r_void
DECL|function|init_channel
id|init_channel
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;rx_t.next
)paren
id|del_timer
c_func
(paren
op_amp
(paren
id|scc-&gt;rx_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;tx_t.next
)paren
id|del_timer
c_func
(paren
op_amp
(paren
id|scc-&gt;tx_t
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|wr
c_func
(paren
id|scc
comma
id|R4
comma
id|X1CLK
op_or
id|SDLC
)paren
suffix:semicolon
multiline_comment|/* *1 clock, SDLC mode */
id|wr
c_func
(paren
id|scc
comma
id|R1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* no W/REQ operation */
id|wr
c_func
(paren
id|scc
comma
id|R3
comma
id|Rx8
op_or
id|RxCRC_ENAB
)paren
suffix:semicolon
multiline_comment|/* RX 8 bits/char, CRC, disabled */
id|wr
c_func
(paren
id|scc
comma
id|R5
comma
id|Tx8
op_or
id|DTR
op_or
id|TxCRC_ENAB
)paren
suffix:semicolon
multiline_comment|/* TX 8 bits/char, disabled, DTR */
id|wr
c_func
(paren
id|scc
comma
id|R6
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* SDLC address zero (not used) */
id|wr
c_func
(paren
id|scc
comma
id|R7
comma
id|FLAG
)paren
suffix:semicolon
multiline_comment|/* SDLC flag value */
id|wr
c_func
(paren
id|scc
comma
id|R9
comma
id|VIS
)paren
suffix:semicolon
multiline_comment|/* vector includes status */
id|wr
c_func
(paren
id|scc
comma
id|R10
comma
(paren
id|scc-&gt;modem.nrz
ques
c_cond
id|NRZ
suffix:colon
id|NRZI
)paren
op_or
id|CRCPS
op_or
id|ABUNDER
)paren
suffix:semicolon
multiline_comment|/* abort on underrun, preset CRC generator, NRZ(I) */
id|wr
c_func
(paren
id|scc
comma
id|R14
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* set clock sources:&n;&n;   CLK_DPLL: normal halfduplex operation&n;   &n;&t;&t;RxClk: use DPLL&n;&t;&t;TxClk: use DPLL&n;&t;&t;TRxC mode DPLL output&n;&t;&t;&n;   CLK_EXTERNAL: external clocking (G3RUH or DF9IC modem)&n;   &n;  &t;        BayCom: &t;&t;others:&n;  &t;        &n;  &t;        TxClk = pin RTxC&t;TxClk = pin TRxC&n;  &t;        RxClk = pin TRxC &t;RxClk = pin RTxC&n;  &t;     &n;&n;   CLK_DIVIDER:&n;   &t;&t;RxClk = use DPLL&n;   &t;&t;TxClk = pin RTxC&n;   &t;&t;&n;   &t;&t;BayCom:&t;&t;&t;others:&n;   &t;&t;pin TRxC = DPLL&t;&t;pin TRxC = BRG&n;   &t;&t;(RxClk * 1)&t;&t;(RxClk * 32)&n;*/
r_switch
c_cond
(paren
id|scc-&gt;modem.clocksrc
)paren
(brace
r_case
id|CLK_DPLL
suffix:colon
id|wr
c_func
(paren
id|scc
comma
id|R11
comma
id|RCDPLL
op_or
id|TCDPLL
op_or
id|TRxCOI
op_or
id|TRxCDP
)paren
suffix:semicolon
id|init_brg
c_func
(paren
id|scc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLK_DIVIDER
suffix:colon
id|wr
c_func
(paren
id|scc
comma
id|R11
comma
(paren
(paren
id|scc-&gt;brand
op_amp
id|BAYCOM
)paren
ques
c_cond
id|TRxCDP
suffix:colon
id|TRxCBR
)paren
op_or
id|RCDPLL
op_or
id|TCRTxCP
op_or
id|TRxCOI
)paren
suffix:semicolon
id|init_brg
c_func
(paren
id|scc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CLK_EXTERNAL
suffix:colon
id|wr
c_func
(paren
id|scc
comma
id|R11
comma
(paren
id|scc-&gt;brand
op_amp
id|BAYCOM
)paren
ques
c_cond
id|RCTRxCP
op_or
id|TCRTxCP
suffix:colon
id|RCRTxCP
op_or
id|TCTRxCP
)paren
suffix:semicolon
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R14
comma
id|DISDPLL
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|set_speed
c_func
(paren
id|scc
)paren
suffix:semicolon
multiline_comment|/* set baudrate */
r_if
c_cond
(paren
id|scc-&gt;enhanced
)paren
(brace
op_logical_or
(paren
id|scc
comma
id|R15
comma
id|SHDLCE
op_or
id|FIFOE
)paren
suffix:semicolon
multiline_comment|/* enable FIFO, SDLC/HDLC Enhancements (From now R7 is R7&squot;) */
id|wr
c_func
(paren
id|scc
comma
id|R7
comma
id|AUTOEOM
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|InReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R0
)paren
)paren
op_amp
id|DCD
)paren
multiline_comment|/* DCD is now ON */
(brace
r_if
c_cond
(paren
id|scc-&gt;modem.clocksrc
op_ne
id|CLK_EXTERNAL
)paren
op_logical_or
(paren
id|scc
comma
id|R14
comma
id|SEARCH
)paren
suffix:semicolon
op_logical_or
(paren
id|scc
comma
id|R3
comma
id|ENT_HM
op_or
id|RxENABLE
)paren
suffix:semicolon
multiline_comment|/* enable the receiver, hunt mode */
)brace
multiline_comment|/* enable CTS (not for Baycom), ABORT &amp; DCD interrupts */
id|wr
c_func
(paren
id|scc
comma
id|R15
comma
(paren
(paren
id|scc-&gt;brand
op_amp
id|BAYCOM
)paren
ques
c_cond
l_int|0
suffix:colon
id|CTSIE
)paren
op_or
id|BRKIE
op_or
id|DCDIE
op_or
id|TxUIE
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_EXT_INT
)paren
suffix:semicolon
multiline_comment|/* reset ext/status interrupts */
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
id|RES_EXT_INT
)paren
suffix:semicolon
multiline_comment|/* must be done twice */
op_logical_or
(paren
id|scc
comma
id|R1
comma
id|INT_ALL_Rx
op_or
id|TxINT_ENAB
op_or
id|EXT_INT_ENAB
)paren
suffix:semicolon
multiline_comment|/* enable interrupts */
id|scc-&gt;status
op_assign
id|InReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R0
)paren
suffix:semicolon
multiline_comment|/* read initial status */
op_logical_or
(paren
id|scc
comma
id|R9
comma
id|MIE
)paren
suffix:semicolon
multiline_comment|/* master interrupt enable */
id|scc_init_timer
c_func
(paren
id|scc
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* *&t;&t;&t;SCC timer functions&t;&t;&t;      * */
multiline_comment|/* ******************************************************************** */
multiline_comment|/* ----&gt; scc_key_trx sets the time constant for the baudrate &n;         generator and keys the transmitter&t;&t;     &lt;---- */
r_static
r_void
DECL|function|scc_key_trx
id|scc_key_trx
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_char
id|tx
)paren
(brace
r_int
r_int
id|time_const
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;modem.speed
OL
id|baud_table
(braket
l_int|1
)braket
)paren
id|scc-&gt;modem.speed
op_assign
l_int|1200
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;brand
op_amp
id|PRIMUS
)paren
id|Outb
c_func
(paren
id|scc-&gt;ctrl
op_plus
l_int|4
comma
id|scc-&gt;option
op_or
(paren
id|tx
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|time_const
op_assign
(paren
r_int
)paren
(paren
id|scc-&gt;clock
op_div
(paren
id|scc-&gt;modem.speed
op_star
(paren
id|tx
ques
c_cond
l_int|2
suffix:colon
l_int|64
)paren
)paren
)paren
op_minus
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;modem.clocksrc
op_eq
id|CLK_DPLL
)paren
(brace
multiline_comment|/* simplex operation */
r_if
c_cond
(paren
id|tx
)paren
(brace
id|cl
c_func
(paren
id|scc
comma
id|R3
comma
id|RxENABLE
op_or
id|ENT_HM
)paren
suffix:semicolon
multiline_comment|/* then switch off receiver */
id|set_brg
c_func
(paren
id|scc
comma
id|time_const
)paren
suffix:semicolon
multiline_comment|/* reprogram baudrate generator */
multiline_comment|/* DPLL -&gt; Rx clk, BRG -&gt; Tx CLK, TRxC mode output, TRxC = BRG */
id|wr
c_func
(paren
id|scc
comma
id|R11
comma
id|RCDPLL
op_or
id|TCBR
op_or
id|TRxCOI
op_or
id|TRxCBR
)paren
suffix:semicolon
op_logical_or
(paren
id|scc
comma
id|R5
comma
id|RTS
op_or
id|TxENAB
)paren
suffix:semicolon
multiline_comment|/* set the RTS line and enable TX */
)brace
r_else
(brace
id|cl
c_func
(paren
id|scc
comma
id|R5
comma
id|RTS
op_or
id|TxENAB
)paren
suffix:semicolon
id|set_brg
c_func
(paren
id|scc
comma
id|time_const
)paren
suffix:semicolon
multiline_comment|/* reprogram baudrate generator */
multiline_comment|/* DPLL -&gt; Rx clk, DPLL -&gt; Tx CLK, TRxC mode output, TRxC = DPLL */
id|wr
c_func
(paren
id|scc
comma
id|R11
comma
id|RCDPLL
op_or
id|TCDPLL
op_or
id|TRxCOI
op_or
id|TRxCDP
)paren
suffix:semicolon
op_logical_or
(paren
id|scc
comma
id|R3
comma
id|RxENABLE
op_or
id|ENT_HM
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|tx
)paren
op_logical_or
(paren
id|scc
comma
id|R5
comma
id|RTS
op_or
id|TxENAB
)paren
suffix:semicolon
multiline_comment|/* enable tx */
r_else
id|cl
c_func
(paren
id|scc
comma
id|R5
comma
id|RTS
op_or
id|TxENAB
)paren
suffix:semicolon
multiline_comment|/* disable tx */
)brace
)brace
multiline_comment|/* ----&gt; SCC timer interrupt handler and friends. Will be called every 1/TPS s &lt;---- */
DECL|variable|Rand
r_static
r_int
r_char
id|Rand
op_assign
l_int|17
suffix:semicolon
DECL|function|is_grouped
r_static
r_inline
r_int
id|is_grouped
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_int
id|k
suffix:semicolon
r_struct
id|scc_channel
op_star
id|scc2
suffix:semicolon
r_int
r_char
id|grp1
comma
id|grp2
suffix:semicolon
id|grp1
op_assign
id|scc-&gt;kiss.group
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
(paren
id|Nchips
op_star
l_int|2
)paren
suffix:semicolon
id|k
op_increment
)paren
(brace
id|scc2
op_assign
op_amp
id|SCC_Info
(braket
id|k
)braket
suffix:semicolon
id|grp2
op_assign
id|scc2-&gt;kiss.group
suffix:semicolon
r_if
c_cond
(paren
id|scc2
op_eq
id|scc
op_logical_or
op_logical_neg
(paren
id|scc2-&gt;tty
op_logical_and
id|grp2
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|grp1
op_amp
l_int|0x3f
)paren
op_eq
(paren
id|grp2
op_amp
l_int|0x3f
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|grp1
op_amp
id|TXGROUP
)paren
op_logical_and
(paren
id|scc2-&gt;wreg
(braket
id|R5
)braket
op_amp
id|RTS
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|grp1
op_amp
id|RXGROUP
)paren
op_logical_and
(paren
id|scc2-&gt;status
op_amp
id|DCD
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dw_slot_timeout
r_static
r_inline
r_void
id|dw_slot_timeout
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
id|scc-&gt;t_dwait
op_assign
id|TIMER_STOPPED
suffix:semicolon
id|scc-&gt;t_slot
op_assign
id|TIMER_STOPPED
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;kiss.fulldup
)paren
(brace
id|Rand
op_assign
id|Rand
op_star
l_int|17
op_plus
l_int|31
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scc-&gt;kiss.softdcd
ques
c_cond
op_logical_neg
(paren
id|scc-&gt;status
op_amp
id|SYNC_HUNT
)paren
suffix:colon
(paren
id|scc-&gt;status
op_amp
id|DCD
)paren
)paren
op_logical_or
(paren
id|scc-&gt;kiss.persist
)paren
OL
id|Rand
op_logical_or
(paren
id|scc-&gt;kiss.group
op_logical_and
id|is_grouped
c_func
(paren
id|scc
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|scc-&gt;t_mbusy
op_eq
id|TIMER_STOPPED
)paren
id|scc-&gt;t_mbusy
op_assign
id|TPS
op_star
id|scc-&gt;kiss.maxdefer
suffix:semicolon
id|scc-&gt;t_slot
op_assign
id|scc-&gt;kiss.slottime
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|scc-&gt;wreg
(braket
id|R5
)braket
op_amp
id|RTS
)paren
)paren
(brace
id|scc-&gt;t_txdel
op_assign
id|scc-&gt;kiss.txdelay
suffix:semicolon
id|scc_key_trx
c_func
(paren
id|scc
comma
id|TX_ON
)paren
suffix:semicolon
)brace
r_else
(brace
id|scc-&gt;t_txdel
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|txdel_timeout
r_static
r_inline
r_void
id|txdel_timeout
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
id|scc-&gt;t_txdel
op_assign
id|TIMER_STOPPED
suffix:semicolon
id|scc-&gt;t_maxk
op_assign
id|TPS
op_star
id|scc-&gt;kiss.maxkeyup
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;tx_bp
op_eq
id|NULLBUF
)paren
id|scc_txint
c_func
(paren
id|scc
)paren
suffix:semicolon
)brace
DECL|function|tail_timeout
r_static
r_inline
r_void
id|tail_timeout
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
id|scc-&gt;t_tail
op_assign
id|TIMER_STOPPED
suffix:semicolon
multiline_comment|/* when fulldup is 0 or 1, switch off the transmitter.&n;&t; * when frames are still queued (because of transmit time limit),&n;&t; * restart the procedure to get the channel after MINTIME.&n;&t; * when fulldup is 2, the transmitter remains keyed and we&n;&t; * continue sending after waiting for waittime. IDLETIME is an &n;&t; * idle timeout in this case.&n;&t; */
r_if
c_cond
(paren
id|scc-&gt;kiss.fulldup
OL
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|scc-&gt;tx_bp
)paren
multiline_comment|/* we had a timeout? */
(brace
id|scc-&gt;stat.tx_state
op_assign
id|TXS_BUSY
suffix:semicolon
id|scc-&gt;t_dwait
op_assign
id|TPS
op_star
id|scc-&gt;kiss.mintime
suffix:semicolon
multiline_comment|/* try again */
)brace
id|scc-&gt;stat.tx_state
op_assign
id|TXS_IDLE
suffix:semicolon
id|scc-&gt;t_maxk
op_assign
id|TIMER_STOPPED
suffix:semicolon
id|scc_key_trx
c_func
(paren
id|scc
comma
id|TX_OFF
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scc-&gt;tx_bp
)paren
multiline_comment|/* maxkeyup expired */
multiline_comment|/* ?! */
(brace
id|scc-&gt;stat.tx_state
op_assign
id|TXS_BUSY
suffix:semicolon
id|scc-&gt;t_txdel
op_assign
id|TPS
op_star
id|scc-&gt;kiss.waittime
suffix:semicolon
)brace
r_else
id|scc-&gt;t_idle
op_assign
id|TPS
op_star
id|scc-&gt;kiss.idletime
suffix:semicolon
)brace
DECL|function|busy_timeout
r_static
r_inline
r_void
id|busy_timeout
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
macro_line|#ifdef&t;THROW_AWAY_AFTER_BUSY_TIMEOUT
r_register
r_struct
id|mbuf
op_star
id|bp
suffix:semicolon
multiline_comment|/* not tested */
r_while
c_loop
(paren
id|bp
op_assign
id|scc_dequeue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_queue
)paren
)paren
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
comma
id|bp
)paren
suffix:semicolon
id|scc-&gt;tx_queue
op_assign
id|NULLBUF
suffix:semicolon
id|scc-&gt;stat.tx_state
op_assign
id|TXS_IDLE
suffix:semicolon
macro_line|#else
id|scc-&gt;t_txdel
op_assign
id|scc-&gt;kiss.txdelay
suffix:semicolon
multiline_comment|/* brute force ... */
macro_line|#endif
id|scc-&gt;t_mbusy
op_assign
id|TIMER_STOPPED
suffix:semicolon
)brace
DECL|function|maxk_idle_timeout
r_static
r_inline
r_void
id|maxk_idle_timeout
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
id|scc-&gt;t_maxk
op_assign
id|TIMER_STOPPED
suffix:semicolon
id|scc-&gt;t_idle
op_assign
id|TIMER_STOPPED
suffix:semicolon
id|scc-&gt;stat.tx_state
op_assign
id|TXS_BUSY
suffix:semicolon
id|scc-&gt;t_tail
op_assign
id|scc-&gt;kiss.tailtime
suffix:semicolon
)brace
r_static
r_void
DECL|function|scc_tx_timer
id|scc_tx_timer
c_func
(paren
r_int
r_int
id|channel
)paren
(brace
r_register
r_struct
id|scc_channel
op_star
id|scc
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|scc
op_assign
(paren
r_struct
id|scc_channel
op_star
)paren
id|channel
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;tty
op_logical_and
id|scc-&gt;init
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* KISS-TNC emulation */
r_if
c_cond
(paren
id|Expired
c_func
(paren
id|t_dwait
)paren
)paren
id|dw_slot_timeout
c_func
(paren
id|scc
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Expired
c_func
(paren
id|t_slot
)paren
)paren
id|dw_slot_timeout
c_func
(paren
id|scc
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Expired
c_func
(paren
id|t_txdel
)paren
)paren
id|txdel_timeout
c_func
(paren
id|scc
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|Expired
c_func
(paren
id|t_tail
)paren
)paren
id|tail_timeout
c_func
(paren
id|scc
)paren
suffix:semicolon
multiline_comment|/* watchdogs */
r_if
c_cond
(paren
id|Expired
c_func
(paren
id|t_mbusy
)paren
)paren
id|busy_timeout
c_func
(paren
id|scc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Expired
c_func
(paren
id|t_maxk
)paren
)paren
id|maxk_idle_timeout
c_func
(paren
id|scc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Expired
c_func
(paren
id|t_idle
)paren
)paren
id|maxk_idle_timeout
c_func
(paren
id|scc
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|scc-&gt;tx_t.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
id|TPS
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|scc-&gt;tx_t
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|scc_rx_timer
id|scc_rx_timer
c_func
(paren
r_int
r_int
id|channel
)paren
(brace
r_register
r_struct
id|scc_channel
op_star
id|scc
suffix:semicolon
id|scc
op_assign
(paren
r_struct
id|scc_channel
op_star
)paren
id|channel
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;rx_queue
op_logical_and
id|scc-&gt;throttled
)paren
(brace
id|scc-&gt;rx_t.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
id|TPS
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|scc-&gt;rx_t
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kiss_encode
c_func
(paren
id|scc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;rx_queue
op_logical_and
op_logical_neg
id|scc-&gt;throttled
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;z8530drv: warning: %s should be throttled&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|scc-&gt;tty-&gt;device
)paren
)paren
suffix:semicolon
id|scc-&gt;rx_t.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
id|TPS
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|scc-&gt;rx_t
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|scc_init_timer
id|scc_init_timer
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|Stop_Timer
c_func
(paren
id|t_dwait
)paren
suffix:semicolon
id|Stop_Timer
c_func
(paren
id|t_slot
)paren
suffix:semicolon
id|Stop_Timer
c_func
(paren
id|t_txdel
)paren
suffix:semicolon
id|Stop_Timer
c_func
(paren
id|t_tail
)paren
suffix:semicolon
id|Stop_Timer
c_func
(paren
id|t_mbusy
)paren
suffix:semicolon
id|Stop_Timer
c_func
(paren
id|t_maxk
)paren
suffix:semicolon
id|Stop_Timer
c_func
(paren
id|t_idle
)paren
suffix:semicolon
id|scc-&gt;stat.tx_state
op_assign
id|TXS_IDLE
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;tx_t.next
)paren
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_t
)paren
suffix:semicolon
id|scc-&gt;tx_t.data
op_assign
(paren
r_int
r_int
)paren
id|scc
suffix:semicolon
id|scc-&gt;tx_t.function
op_assign
id|scc_tx_timer
suffix:semicolon
id|scc-&gt;tx_t.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
id|TPS
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|scc-&gt;tx_t
)paren
suffix:semicolon
id|scc-&gt;rx_t.data
op_assign
(paren
r_int
r_int
)paren
id|scc
suffix:semicolon
id|scc-&gt;rx_t.function
op_assign
id|scc_rx_timer
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* *&t;&t;&t;KISS interpreter&t;&t;&t;      * */
multiline_comment|/* ******************************************************************** */
multiline_comment|/*&n; * this will set the &quot;kiss&quot; parameters through kiss itself&n; */
r_static
r_void
DECL|function|kiss_set_param
id|kiss_set_param
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_char
id|cmd
comma
r_int
r_int
id|val
)paren
(brace
DECL|macro|VAL
mdefine_line|#define  VAL val=val*TPS/100
DECL|macro|SVAL
mdefine_line|#define SVAL val? val:TIMER_STOPPED
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PARAM_TXDELAY
suffix:colon
id|scc-&gt;kiss.txdelay
op_assign
id|VAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_PERSIST
suffix:colon
id|scc-&gt;kiss.persist
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_SLOTTIME
suffix:colon
id|scc-&gt;kiss.slottime
op_assign
id|VAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_TXTAIL
suffix:colon
id|scc-&gt;kiss.tailtime
op_assign
id|VAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_FULLDUP
suffix:colon
id|scc-&gt;kiss.fulldup
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_WAIT
suffix:colon
id|scc-&gt;kiss.waittime
op_assign
id|VAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_MAXKEY
suffix:colon
id|scc-&gt;kiss.maxkeyup
op_assign
id|SVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_MIN
suffix:colon
id|scc-&gt;kiss.mintime
op_assign
id|SVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_IDLE
suffix:colon
id|scc-&gt;kiss.idletime
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_MAXDEFER
suffix:colon
id|scc-&gt;kiss.maxdefer
op_assign
id|SVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_GROUP
suffix:colon
id|scc-&gt;kiss.group
op_assign
id|val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_TX
suffix:colon
id|scc-&gt;kiss.tx_inhibit
op_assign
id|val
suffix:semicolon
r_case
id|PARAM_SOFTDCD
suffix:colon
id|scc-&gt;kiss.softdcd
op_assign
id|val
suffix:semicolon
)brace
r_return
suffix:semicolon
DECL|macro|VAL
macro_line|#undef  VAL
DECL|macro|SVAL
macro_line|#undef SVAL
)brace
multiline_comment|/* interpret frame: strip CRC and decode KISS */
DECL|function|kiss_interpret_frame
r_static
r_void
id|kiss_interpret_frame
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_int
r_char
id|kisscmd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|mbuf
op_star
id|bp
suffix:semicolon
id|bp
op_assign
id|scc-&gt;kiss_decode_bp
suffix:semicolon
id|bp-&gt;rw_ptr
op_assign
id|bp-&gt;data
suffix:semicolon
macro_line|#ifdef DEBUG_BUFFERS
r_if
c_cond
(paren
id|bp
op_eq
id|NULLBUF
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;kiss_interpret_frame(): weird --- nothing to do.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|bp-&gt;cnt
OL
l_int|2
)paren
(brace
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
comma
id|bp
)paren
suffix:semicolon
id|scc-&gt;kiss_decode_bp
op_assign
id|NULLBUF
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scc-&gt;kiss.not_slip
)paren
(brace
id|kisscmd
op_assign
op_star
id|bp-&gt;rw_ptr
suffix:semicolon
id|bp-&gt;rw_ptr
op_increment
suffix:semicolon
)brace
r_else
(brace
id|kisscmd
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kisscmd
op_amp
l_int|0xa0
)paren
(brace
r_if
c_cond
(paren
id|bp-&gt;cnt
OG
l_int|3
)paren
id|bp-&gt;cnt
op_sub_assign
l_int|2
suffix:semicolon
r_else
(brace
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
comma
id|bp
)paren
suffix:semicolon
id|scc-&gt;kiss_decode_bp
op_assign
id|NULLBUF
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|kisscmd
op_and_assign
l_int|0x1f
suffix:semicolon
r_if
c_cond
(paren
id|kisscmd
)paren
(brace
id|kiss_set_param
c_func
(paren
id|scc
comma
id|kisscmd
comma
op_star
id|bp-&gt;rw_ptr
)paren
suffix:semicolon
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
comma
id|bp
)paren
suffix:semicolon
id|scc-&gt;kiss_decode_bp
op_assign
id|NULLBUF
suffix:semicolon
r_return
suffix:semicolon
)brace
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_queue
comma
id|bp
)paren
suffix:semicolon
multiline_comment|/* enqueue frame */
id|scc-&gt;stat.txframes
op_increment
suffix:semicolon
id|scc-&gt;stat.tx_queued
op_increment
suffix:semicolon
id|scc-&gt;kiss_decode_bp
op_assign
id|NULLBUF
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;stat.tx_state
op_eq
id|TXS_IDLE
)paren
(brace
multiline_comment|/* when transmitter is idle */
id|scc-&gt;stat.tx_state
op_assign
id|TXS_BUSY
suffix:semicolon
id|scc-&gt;t_dwait
op_assign
(paren
id|scc-&gt;kiss.fulldup
ques
c_cond
l_int|0
suffix:colon
id|scc-&gt;kiss.waittime
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|kiss_store_byte
r_static
r_inline
r_void
id|kiss_store_byte
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_int
r_char
id|ch
)paren
(brace
r_register
r_struct
id|mbuf
op_star
id|bp
op_assign
id|scc-&gt;kiss_decode_bp
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_ne
id|NULLBUF
)paren
(brace
r_if
c_cond
(paren
id|bp-&gt;cnt
OG
id|scc-&gt;stat.bufsize
)paren
id|printk
c_func
(paren
l_string|&quot;kiss_decode(): frame too long&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
op_star
id|bp-&gt;rw_ptr
op_assign
id|ch
suffix:semicolon
id|bp-&gt;rw_ptr
op_increment
suffix:semicolon
id|bp-&gt;cnt
op_increment
suffix:semicolon
)brace
)brace
)brace
DECL|function|kiss_decode
r_static
r_inline
r_int
id|kiss_decode
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
r_int
r_char
id|ch
)paren
(brace
r_switch
c_cond
(paren
id|scc-&gt;stat.tx_kiss_state
)paren
(brace
r_case
id|KISS_IDLE
suffix:colon
r_if
c_cond
(paren
id|ch
op_eq
id|FEND
)paren
(brace
id|scc-&gt;kiss_decode_bp
op_assign
id|scc_get_buffer
c_func
(paren
id|scc
comma
id|BT_TRANSMIT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;kiss_decode_bp
op_eq
id|NULLBUF
)paren
r_return
l_int|1
suffix:semicolon
id|scc-&gt;stat.tx_kiss_state
op_assign
id|KISS_DATA
suffix:semicolon
)brace
r_else
id|scc-&gt;stat.txerrs
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KISS_DATA
suffix:colon
r_if
c_cond
(paren
id|ch
op_eq
id|FESC
)paren
id|scc-&gt;stat.tx_kiss_state
op_assign
id|KISS_ESCAPE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ch
op_eq
id|FEND
)paren
(brace
id|kiss_interpret_frame
c_func
(paren
id|scc
)paren
suffix:semicolon
id|scc-&gt;stat.tx_kiss_state
op_assign
id|KISS_IDLE
suffix:semicolon
)brace
r_else
id|kiss_store_byte
c_func
(paren
id|scc
comma
id|ch
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KISS_ESCAPE
suffix:colon
r_if
c_cond
(paren
id|ch
op_eq
id|TFEND
)paren
(brace
id|kiss_store_byte
c_func
(paren
id|scc
comma
id|FEND
)paren
suffix:semicolon
id|scc-&gt;stat.tx_kiss_state
op_assign
id|KISS_DATA
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ch
op_eq
id|TFESC
)paren
(brace
id|kiss_store_byte
c_func
(paren
id|scc
comma
id|FESC
)paren
suffix:semicolon
id|scc-&gt;stat.tx_kiss_state
op_assign
id|KISS_DATA
suffix:semicolon
)brace
r_else
(brace
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;tx_buffer_pool
comma
id|scc-&gt;kiss_decode_bp
)paren
suffix:semicolon
id|scc-&gt;kiss_decode_bp
op_assign
id|NULLBUF
suffix:semicolon
id|scc-&gt;stat.txerrs
op_increment
suffix:semicolon
id|scc-&gt;stat.tx_kiss_state
op_assign
id|KISS_IDLE
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/* switch */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ----&gt; Encode received data and write it to the flip-buffer  &lt;---- */
r_static
r_void
DECL|function|kiss_encode
id|kiss_encode
c_func
(paren
r_register
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_struct
id|mbuf
op_star
id|bp
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|scc-&gt;tty
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
id|bp
op_assign
id|scc-&gt;kiss_encode_bp
suffix:semicolon
multiline_comment|/* worst case: FEND 0 FESC TFEND -&gt; 4 bytes */
r_while
c_loop
(paren
id|tty-&gt;flip.count
OL
id|TTY_FLIPBUF_SIZE
op_minus
l_int|4
)paren
(brace
r_if
c_cond
(paren
id|bp
op_eq
id|NULLBUF
)paren
(brace
id|bp
op_assign
id|scc_dequeue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_queue
)paren
suffix:semicolon
id|scc-&gt;kiss_encode_bp
op_assign
id|bp
suffix:semicolon
r_if
c_cond
(paren
id|bp
op_eq
id|NULLBUF
)paren
(brace
id|scc-&gt;stat.rx_kiss_state
op_assign
id|KISS_IDLE
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bp-&gt;cnt
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|scc-&gt;stat.rx_queued
OL
l_int|0
)paren
id|scc-&gt;stat.rx_queued
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;stat.rx_kiss_state
op_eq
id|KISS_RXFRAME
)paren
multiline_comment|/* new packet? */
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|FEND
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* send FEND for old frame */
id|scc-&gt;stat.rx_kiss_state
op_assign
id|KISS_IDLE
suffix:semicolon
multiline_comment|/* generate FEND for new frame */
)brace
id|scc_enqueue_buffer
c_func
(paren
op_amp
id|scc-&gt;rx_buffer_pool
comma
id|bp
)paren
suffix:semicolon
id|bp
op_assign
id|scc-&gt;kiss_encode_bp
op_assign
id|NULLBUF
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scc-&gt;stat.rx_kiss_state
op_eq
id|KISS_IDLE
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|FEND
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;kiss.not_slip
)paren
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|scc-&gt;stat.rx_kiss_state
op_assign
id|KISS_RXFRAME
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|ch
op_assign
op_star
id|bp-&gt;rw_ptr
)paren
(brace
r_case
id|FEND
suffix:colon
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|FESC
comma
l_int|0
)paren
suffix:semicolon
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|TFEND
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FESC
suffix:colon
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|FESC
comma
l_int|0
)paren
suffix:semicolon
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|TFESC
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|ch
comma
l_int|0
)paren
suffix:semicolon
)brace
id|bp-&gt;rw_ptr
op_increment
suffix:semicolon
id|bp-&gt;cnt
op_decrement
suffix:semicolon
)brace
id|queue_task
c_func
(paren
op_amp
id|tty-&gt;flip.tqueue
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
multiline_comment|/* kick it... */
)brace
multiline_comment|/* ******************************************************************* */
multiline_comment|/* *&t;&t;Init channel structures, special HW, etc...&t;     * */
multiline_comment|/* ******************************************************************* */
r_static
r_void
DECL|function|z8530_init
id|z8530_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
suffix:semicolon
r_int
id|chip
comma
id|k
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_char
op_star
id|flag
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Init Z8530 driver: %u channels, IRQ&quot;
comma
id|Nchips
op_star
l_int|2
)paren
suffix:semicolon
id|flag
op_assign
l_string|&quot; &quot;
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|16
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|Ivec
(braket
id|k
)braket
dot
id|used
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s%d&quot;
comma
id|flag
comma
id|k
)paren
suffix:semicolon
id|flag
op_assign
l_string|&quot;,&quot;
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* reset and pre-init all chips in the system */
r_for
c_loop
(paren
id|chip
op_assign
l_int|0
suffix:semicolon
id|chip
OL
id|Nchips
suffix:semicolon
id|chip
op_increment
)paren
(brace
id|scc
op_assign
op_amp
id|SCC_Info
(braket
l_int|2
op_star
id|chip
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;ctrl
)paren
r_continue
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* because of 2-step accesses */
multiline_comment|/* Special SCC cards */
r_if
c_cond
(paren
id|scc-&gt;brand
op_amp
id|EAGLE
)paren
(brace
multiline_comment|/* this is an EAGLE card */
id|Outb
c_func
(paren
id|scc-&gt;special
comma
l_int|0x08
)paren
suffix:semicolon
)brace
multiline_comment|/* enable interrupt on the board */
r_if
c_cond
(paren
id|scc-&gt;brand
op_amp
(paren
id|PC100
op_or
id|PRIMUS
)paren
)paren
(brace
multiline_comment|/* this is a PC100/EAGLE card */
id|Outb
c_func
(paren
id|scc-&gt;special
comma
id|scc-&gt;option
)paren
suffix:semicolon
)brace
multiline_comment|/* set the MODEM mode (0x22) */
multiline_comment|/* Init SCC */
multiline_comment|/* some general init we can do now */
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
l_int|0
)paren
suffix:semicolon
id|OutReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R9
comma
id|FHWRES
)paren
suffix:semicolon
multiline_comment|/* force hardware reset */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* give it &squot;a bit&squot; more time than required */
id|wr
c_func
(paren
id|scc
comma
id|R2
comma
id|chip
op_star
l_int|16
)paren
suffix:semicolon
multiline_comment|/* interrupt vector */
id|wr
c_func
(paren
id|scc
comma
id|R9
comma
id|VIS
)paren
suffix:semicolon
multiline_comment|/* vector includes status */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
id|Driver_Initialized
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* * &t;Filesystem Routines: open, close, ioctl, settermios, etc      * */
multiline_comment|/* ******************************************************************** */
multiline_comment|/* scc_paranoia_check(): warn user if something went wrong&t;&t;*/
DECL|function|scc_paranoia_check
r_static
r_inline
r_int
id|scc_paranoia_check
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
comma
id|kdev_t
id|device
comma
r_const
r_char
op_star
id|routine
)paren
(brace
macro_line|#ifdef SCC_PARANOIA_CHECK
r_static
r_const
r_char
op_star
id|badmagic
op_assign
l_string|&quot;Warning: bad magic number for Z8530 SCC struct (%s) in %s&bslash;n&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|badinfo
op_assign
l_string|&quot;Warning: Z8530 not found for (%s) in %s&bslash;n&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;init
)paren
(brace
id|printk
c_func
(paren
id|badinfo
comma
id|kdevname
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scc-&gt;magic
op_ne
id|SCC_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|badmagic
comma
id|kdevname
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ----&gt; this one is called whenever you open the device &lt;---- */
DECL|function|scc_open
r_int
id|scc_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
suffix:semicolon
r_int
id|chan
suffix:semicolon
id|chan
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
suffix:semicolon
r_if
c_cond
(paren
id|Driver_Initialized
)paren
(brace
r_if
c_cond
(paren
(paren
id|chan
OL
l_int|0
)paren
op_logical_or
(paren
id|chan
op_ge
(paren
id|Nchips
op_star
l_int|2
)paren
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
id|tty-&gt;driver_data
op_assign
op_amp
id|SCC_Info
(braket
l_int|0
)braket
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|scc
op_assign
op_amp
id|SCC_Info
(braket
id|chan
)braket
suffix:semicolon
id|tty-&gt;driver_data
op_assign
id|scc
suffix:semicolon
id|tty-&gt;termios-&gt;c_cflag
op_and_assign
op_complement
id|CBAUD
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;magic
op_ne
id|SCC_MAGIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ERROR: scc_open(): bad magic number for device (%s)&quot;
comma
id|kdevname
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;tty
op_ne
l_int|NULL
)paren
(brace
id|scc-&gt;tty_opened
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|scc-&gt;tty
op_assign
id|tty
suffix:semicolon
id|alloc_buffer_pool
c_func
(paren
id|scc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;init
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|scc-&gt;throttled
op_assign
l_int|0
suffix:semicolon
id|scc-&gt;stat.tx_kiss_state
op_assign
id|KISS_IDLE
suffix:semicolon
multiline_comment|/* don&squot;t change this... */
id|scc-&gt;stat.rx_kiss_state
op_assign
id|KISS_IDLE
suffix:semicolon
multiline_comment|/* ...or this */
id|init_channel
c_func
(paren
id|scc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ----&gt; and this whenever you close the device &lt;---- */
r_static
r_void
DECL|function|scc_close
id|scc_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scc
op_logical_or
(paren
id|scc-&gt;magic
op_ne
id|SCC_MAGIC
)paren
)paren
r_return
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;tty_opened
)paren
(brace
id|scc-&gt;tty_opened
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
id|tty-&gt;driver_data
op_assign
id|NULLBUF
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Driver_Initialized
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|scc-&gt;ctrl
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Make sure pointer is written */
id|wr
c_func
(paren
id|scc
comma
id|R1
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* disable interrupts */
id|wr
c_func
(paren
id|scc
comma
id|R3
comma
l_int|0
)paren
suffix:semicolon
id|scc-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;tx_t
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|scc-&gt;rx_t
)paren
suffix:semicolon
id|free_buffer_pool
c_func
(paren
id|scc
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|scc-&gt;throttled
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;stopped
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * change scc_speed&n; */
r_static
r_void
DECL|function|scc_change_speed
id|scc_change_speed
c_func
(paren
r_struct
id|scc_channel
op_star
id|scc
)paren
(brace
r_int
id|speed
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;tty
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|speed
op_assign
id|baud_table
(braket
id|scc-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|CBAUD
)braket
suffix:semicolon
r_if
c_cond
(paren
id|speed
OG
l_int|0
)paren
id|scc-&gt;modem.speed
op_assign
id|speed
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;stat.tx_state
op_eq
l_int|0
)paren
multiline_comment|/* only switch baudrate on rx... ;-) */
id|set_speed
c_func
(paren
id|scc
)paren
suffix:semicolon
)brace
multiline_comment|/* ----&gt; ioctl-routine of the driver &lt;---- */
multiline_comment|/* perform ioctl on SCC (sdlc) channel&n; * this is used for AX.25 mode, and will set the &quot;kiss&quot; parameters&n; */
multiline_comment|/* TIOCMGET &t;- get modem status&t;arg: (unsigned long *) arg&n; * TIOCMBIS &t;- set PTT&t;&t;arg: ---&n; * TIOCMBIC &t;- reset PTT&t;&t;arg: ---&n; * TIOCMBIC &t;- set PTT&t;&t;arg: ---&n; * TIOCSCCINI&t;- initialize driver&t;arg: ---&n; * TIOCCHANINI&t;- initialize channel&t;arg: (struct scc_modem *) arg&n; * TIOCGKISS&t;- get level 1 parameter&t;arg: (struct ioctl_command *) arg&n; * TIOCSKISS&t;- set level 1 parameter arg: (struct ioctl_command *) arg&n; * TIOCSCCSTAT  - get driver status&t;arg: (struct scc_stat *) arg&n; */
r_static
r_int
DECL|function|scc_ioctl
id|scc_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
comma
id|r
suffix:semicolon
r_int
r_int
id|result
suffix:semicolon
r_int
r_int
id|value
suffix:semicolon
r_struct
id|ioctl_command
id|kiss_cmd
suffix:semicolon
r_struct
id|scc_mem_config
id|memcfg
suffix:semicolon
r_struct
id|scc_hw_config
id|hwcfg
suffix:semicolon
r_int
id|error
comma
id|chan
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;magic
op_ne
id|SCC_MAGIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ERROR: scc_ioctl(): bad magic number for device %s&quot;
comma
id|kdevname
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|r
op_assign
id|NO_SUCH_PARAM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Driver_Initialized
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
id|TIOCSCCCFG
)paren
(brace
r_int
id|found
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|Nchips
op_ge
id|MAXSCC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|hwcfg
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|hwcfg
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwcfg.irq
op_eq
l_int|2
)paren
id|hwcfg.irq
op_assign
l_int|9
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Ivec
(braket
id|hwcfg.irq
)braket
dot
id|used
op_logical_and
id|hwcfg.irq
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|hwcfg.irq
comma
id|scc_isr
comma
id|SA_INTERRUPT
comma
l_string|&quot;AX.25 SCC&quot;
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;z8530drv: Warning --- could not get IRQ %d&bslash;n&quot;
comma
id|hwcfg.irq
)paren
suffix:semicolon
r_else
id|Ivec
(braket
id|hwcfg.irq
)braket
dot
id|used
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwcfg.vector_latch
)paren
id|Vector_Latch
op_assign
id|hwcfg.vector_latch
suffix:semicolon
r_if
c_cond
(paren
id|hwcfg.clock
op_eq
l_int|0
)paren
id|hwcfg.clock
op_assign
id|DEFAULT_CLOCK
suffix:semicolon
macro_line|#ifndef DONT_CHECK
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|check_region
c_func
(paren
id|scc-&gt;ctrl
comma
l_int|1
)paren
suffix:semicolon
id|Outb
c_func
(paren
id|hwcfg.ctrl_a
comma
l_int|0
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|OutReg
c_func
(paren
id|hwcfg.ctrl_a
comma
id|R13
comma
l_int|0x55
)paren
suffix:semicolon
multiline_comment|/* is this chip really there? */
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
id|InReg
c_func
(paren
id|hwcfg.ctrl_a
comma
id|R13
)paren
op_ne
l_int|0x55
)paren
id|found
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|found
)paren
(brace
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
)braket
dot
id|ctrl
op_assign
id|hwcfg.ctrl_a
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
)braket
dot
id|data
op_assign
id|hwcfg.data_a
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
l_int|1
)braket
dot
id|ctrl
op_assign
id|hwcfg.ctrl_b
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
l_int|1
)braket
dot
id|data
op_assign
id|hwcfg.data_b
suffix:semicolon
id|SCC_ctrl
(braket
l_int|2
op_star
id|Nchips
)braket
op_assign
id|hwcfg.ctrl_a
suffix:semicolon
id|SCC_ctrl
(braket
l_int|2
op_star
id|Nchips
op_plus
l_int|1
)braket
op_assign
id|hwcfg.ctrl_b
suffix:semicolon
)brace
r_for
c_loop
(paren
id|chan
op_assign
l_int|0
suffix:semicolon
id|chan
OL
l_int|2
suffix:semicolon
id|chan
op_increment
)paren
(brace
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|special
op_assign
id|hwcfg.special
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|clock
op_assign
id|hwcfg.clock
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|brand
op_assign
id|hwcfg.brand
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|option
op_assign
id|hwcfg.option
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|enhanced
op_assign
id|hwcfg.escc
suffix:semicolon
macro_line|#ifdef DONT_CHECK
id|printk
c_func
(paren
l_string|&quot;%s%i: data port = 0x%3.3x  control port = 0x%3.3x&bslash;n&quot;
comma
id|scc_driver.name
comma
l_int|2
op_star
id|Nchips
op_plus
id|chan
comma
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|data
comma
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|ctrl
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;%s%i: data port = 0x%3.3x  control port = 0x%3.3x -- %s&bslash;n&quot;
comma
id|scc_driver.name
comma
l_int|2
op_star
id|Nchips
op_plus
id|chan
comma
id|chan
ques
c_cond
id|hwcfg.data_b
suffix:colon
id|hwcfg.data_a
comma
id|chan
ques
c_cond
id|hwcfg.ctrl_b
suffix:colon
id|hwcfg.ctrl_a
comma
id|found
ques
c_cond
l_string|&quot;found&quot;
suffix:colon
l_string|&quot;missing&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|found
)paren
(brace
id|request_region
c_func
(paren
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|ctrl
comma
l_int|1
comma
l_string|&quot;scc ctrl&quot;
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|SCC_Info
(braket
l_int|2
op_star
id|Nchips
op_plus
id|chan
)braket
dot
id|data
comma
l_int|1
comma
l_string|&quot;scc data&quot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|found
)paren
id|Nchips
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|TIOCSCCINI
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|Nchips
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|z8530_init
c_func
(paren
)paren
suffix:semicolon
id|scc-&gt;tty
op_assign
id|tty
suffix:semicolon
id|alloc_buffer_pool
c_func
(paren
id|scc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* confuse the user */
)brace
r_if
c_cond
(paren
op_logical_neg
id|scc-&gt;init
)paren
(brace
r_if
c_cond
(paren
id|cmd
op_eq
id|TIOCCHANINI
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|scc-&gt;modem
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|scc_modem
)paren
)paren
suffix:semicolon
multiline_comment|/* default KISS Params */
r_if
c_cond
(paren
id|scc-&gt;modem.speed
OL
l_int|4800
)paren
(brace
id|scc-&gt;kiss.txdelay
op_assign
l_int|36
op_star
id|TPS
op_div
l_int|100
suffix:semicolon
multiline_comment|/* 360 ms */
id|scc-&gt;kiss.persist
op_assign
l_int|42
suffix:semicolon
multiline_comment|/* 25% persistence */
multiline_comment|/* was 25 */
id|scc-&gt;kiss.slottime
op_assign
l_int|16
op_star
id|TPS
op_div
l_int|100
suffix:semicolon
multiline_comment|/* 160 ms */
id|scc-&gt;kiss.tailtime
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* minimal reasonable value */
id|scc-&gt;kiss.fulldup
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* CSMA */
id|scc-&gt;kiss.waittime
op_assign
l_int|50
op_star
id|TPS
op_div
l_int|100
suffix:semicolon
multiline_comment|/* 500 ms */
id|scc-&gt;kiss.maxkeyup
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* 10 s */
id|scc-&gt;kiss.mintime
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 3 s */
id|scc-&gt;kiss.idletime
op_assign
l_int|30
suffix:semicolon
multiline_comment|/* 30 s */
id|scc-&gt;kiss.maxdefer
op_assign
l_int|120
suffix:semicolon
multiline_comment|/* 2 min */
id|scc-&gt;kiss.not_slip
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* KISS mode */
id|scc-&gt;kiss.softdcd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* hardware dcd */
)brace
r_else
(brace
id|scc-&gt;kiss.txdelay
op_assign
l_int|10
op_star
id|TPS
op_div
l_int|100
suffix:semicolon
multiline_comment|/* 100 ms */
id|scc-&gt;kiss.persist
op_assign
l_int|64
suffix:semicolon
multiline_comment|/* 25% persistence */
multiline_comment|/* was 25 */
id|scc-&gt;kiss.slottime
op_assign
l_int|8
op_star
id|TPS
op_div
l_int|100
suffix:semicolon
multiline_comment|/* 160 ms */
id|scc-&gt;kiss.tailtime
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* minimal reasonable value */
id|scc-&gt;kiss.fulldup
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* CSMA */
id|scc-&gt;kiss.waittime
op_assign
l_int|50
op_star
id|TPS
op_div
l_int|100
suffix:semicolon
multiline_comment|/* 500 ms */
id|scc-&gt;kiss.maxkeyup
op_assign
l_int|7
suffix:semicolon
multiline_comment|/* 7 s */
id|scc-&gt;kiss.mintime
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* 3 s */
id|scc-&gt;kiss.idletime
op_assign
l_int|30
suffix:semicolon
multiline_comment|/* 30 s */
id|scc-&gt;kiss.maxdefer
op_assign
l_int|120
suffix:semicolon
multiline_comment|/* 2 min */
id|scc-&gt;kiss.not_slip
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* KISS mode */
id|scc-&gt;kiss.softdcd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* hardware dcd */
)brace
id|scc-&gt;init
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TCSBRK
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCMGET
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
(paren
(paren
id|scc-&gt;wreg
(braket
id|R5
)braket
op_amp
id|RTS
)paren
ques
c_cond
id|TIOCM_RTS
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|scc-&gt;wreg
(braket
id|R5
)braket
op_amp
id|DTR
)paren
ques
c_cond
id|TIOCM_DTR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|InReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R0
)paren
op_amp
id|DCD
)paren
ques
c_cond
id|TIOCM_CAR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|InReg
c_func
(paren
id|scc-&gt;ctrl
comma
id|R0
)paren
op_amp
id|CTS
)paren
ques
c_cond
id|TIOCM_CTS
suffix:colon
l_int|0
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|result
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
r_case
id|TIOCMBIC
suffix:colon
r_case
id|TIOCMSET
suffix:colon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMBIS
suffix:colon
id|scc-&gt;wreg
(braket
id|R5
)braket
op_or_assign
id|DTR
suffix:semicolon
id|scc-&gt;wreg
(braket
id|R5
)braket
op_or_assign
id|RTS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMBIC
suffix:colon
id|scc-&gt;wreg
(braket
id|R5
)braket
op_and_assign
op_complement
id|DTR
suffix:semicolon
id|scc-&gt;wreg
(braket
id|R5
)braket
op_and_assign
op_complement
id|RTS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
id|value
op_assign
id|get_user
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_amp
id|TIOCM_DTR
)paren
(brace
id|scc-&gt;wreg
(braket
id|R5
)braket
op_or_assign
id|DTR
suffix:semicolon
)brace
r_else
id|scc-&gt;wreg
(braket
id|R5
)braket
op_and_assign
op_complement
id|DTR
suffix:semicolon
r_if
c_cond
(paren
id|value
op_amp
id|TIOCM_RTS
)paren
(brace
id|scc-&gt;wreg
(braket
id|R5
)braket
op_or_assign
id|RTS
suffix:semicolon
)brace
r_else
id|scc-&gt;wreg
(braket
id|R5
)braket
op_and_assign
op_complement
id|RTS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;stat.tx_state
op_eq
id|TXS_IDLE
op_logical_and
op_logical_neg
id|Running
c_func
(paren
id|t_idle
)paren
)paren
(brace
id|maxk_idle_timeout
c_func
(paren
id|scc
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCGETS
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|scc-&gt;tty-&gt;termios
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TCSETS
suffix:colon
r_case
id|TCSETSF
suffix:colon
multiline_comment|/* should flush first, but... */
r_case
id|TCSETSW
suffix:colon
multiline_comment|/* should wait &squot;till flush, but... */
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|scc-&gt;tty-&gt;termios
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
id|scc_change_speed
c_func
(paren
id|scc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCCHANMEM
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|memcfg
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|scc_mem_config
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|free_buffer_pool
c_func
(paren
id|scc
)paren
suffix:semicolon
id|scc-&gt;stat.rxbuffers
op_assign
id|memcfg.rxbuffers
suffix:semicolon
id|scc-&gt;stat.txbuffers
op_assign
id|memcfg.txbuffers
suffix:semicolon
id|scc-&gt;stat.bufsize
op_assign
id|memcfg.bufsize
suffix:semicolon
id|alloc_buffer_pool
c_func
(paren
id|scc
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCSCCSTAT
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|scc_stat
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|scc-&gt;stat
comma
r_sizeof
(paren
r_struct
id|scc_stat
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
DECL|macro|TICKS
mdefine_line|#define TICKS (100/TPS)
DECL|macro|CAST
mdefine_line|#define CAST(x) (unsigned long)(x)
DECL|macro|Val
mdefine_line|#define  Val&t;kiss_cmd.param
DECL|macro|VAL
mdefine_line|#define  VAL&t;kiss_cmd.param*TPS/100
DECL|macro|SVAL
mdefine_line|#define SVAL&t;kiss_cmd.param? kiss_cmd.param:TIMER_STOPPED
r_case
id|TIOCGKISS
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|ioctl_command
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|kiss_cmd
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|ioctl_command
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|kiss_cmd.command
)paren
(brace
r_case
id|PARAM_TXDELAY
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
id|scc-&gt;kiss.txdelay
op_star
id|TICKS
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_PERSIST
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
id|scc-&gt;kiss.persist
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_SLOTTIME
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
id|scc-&gt;kiss.slottime
op_star
id|TICKS
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_TXTAIL
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
id|scc-&gt;kiss.tailtime
op_star
id|TICKS
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_FULLDUP
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
id|scc-&gt;kiss.fulldup
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_SOFTDCD
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
id|scc-&gt;kiss.softdcd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_DTR
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
(paren
id|scc-&gt;wreg
(braket
id|R5
)braket
op_amp
id|DTR
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_RTS
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
(paren
id|scc-&gt;wreg
(braket
id|R5
)braket
op_amp
id|RTS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_SPEED
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
id|scc-&gt;modem.speed
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_GROUP
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
id|scc-&gt;kiss.group
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_IDLE
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
id|scc-&gt;kiss.idletime
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_MIN
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
id|scc-&gt;kiss.mintime
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_MAXKEY
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
id|scc-&gt;kiss.maxkeyup
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_WAIT
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
id|scc-&gt;kiss.waittime
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_MAXDEFER
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
id|scc-&gt;kiss.maxdefer
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_TX
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
id|scc-&gt;kiss.tx_inhibit
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_SLIP
suffix:colon
id|r
op_assign
id|CAST
c_func
(paren
op_logical_neg
id|scc-&gt;kiss.not_slip
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|r
op_assign
id|NO_SUCH_PARAM
suffix:semicolon
)brace
id|kiss_cmd.param
op_assign
id|r
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|kiss_cmd
comma
r_sizeof
(paren
r_struct
id|ioctl_command
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSKISS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|kiss_cmd
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|ioctl_command
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|kiss_cmd.command
)paren
(brace
r_case
id|PARAM_TXDELAY
suffix:colon
id|scc-&gt;kiss.txdelay
op_assign
id|VAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_PERSIST
suffix:colon
id|scc-&gt;kiss.persist
op_assign
id|Val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_SLOTTIME
suffix:colon
id|scc-&gt;kiss.slottime
op_assign
id|VAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_TXTAIL
suffix:colon
id|scc-&gt;kiss.tailtime
op_assign
id|VAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_FULLDUP
suffix:colon
id|scc-&gt;kiss.fulldup
op_assign
id|Val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_SOFTDCD
suffix:colon
id|scc-&gt;kiss.softdcd
op_assign
id|Val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_DTR
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* does someone need this? */
r_case
id|PARAM_RTS
suffix:colon
r_break
suffix:semicolon
multiline_comment|/* or this? */
r_case
id|PARAM_SPEED
suffix:colon
id|scc-&gt;modem.speed
op_assign
id|Val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_GROUP
suffix:colon
id|scc-&gt;kiss.group
op_assign
id|Val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_IDLE
suffix:colon
id|scc-&gt;kiss.idletime
op_assign
id|Val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_MIN
suffix:colon
id|scc-&gt;kiss.mintime
op_assign
id|SVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_MAXKEY
suffix:colon
id|scc-&gt;kiss.maxkeyup
op_assign
id|SVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_WAIT
suffix:colon
id|scc-&gt;kiss.waittime
op_assign
id|Val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_MAXDEFER
suffix:colon
id|scc-&gt;kiss.maxdefer
op_assign
id|SVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_TX
suffix:colon
id|scc-&gt;kiss.tx_inhibit
op_assign
id|Val
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PARAM_SLIP
suffix:colon
id|scc-&gt;kiss.not_slip
op_assign
op_logical_neg
id|Val
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
DECL|macro|TICKS
macro_line|#undef TICKS
DECL|macro|CAST
macro_line|#undef CAST
DECL|macro|VAL
macro_line|#undef VAL
DECL|macro|SVAL
macro_line|#undef SVAL
DECL|macro|Val
macro_line|#undef Val
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
)brace
multiline_comment|/* ----&gt; tx routine: decode KISS data and scc_enqueue it &lt;---- */
multiline_comment|/* send raw frame to SCC. used for AX.25 */
DECL|function|scc_write
r_int
id|scc_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|cnt
comma
id|cnt2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
id|count
suffix:semicolon
r_if
c_cond
(paren
id|scc_paranoia_check
c_func
(paren
id|scc
comma
id|tty-&gt;device
comma
l_string|&quot;scc_write&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|scc-&gt;kiss.tx_inhibit
)paren
r_return
id|count
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|cnt2
op_assign
id|count
suffix:semicolon
r_while
c_loop
(paren
id|cnt2
)paren
(brace
id|cnt
op_assign
id|cnt2
OG
id|BUFSIZE
ques
c_cond
id|BUFSIZE
suffix:colon
id|cnt2
suffix:semicolon
id|cnt2
op_sub_assign
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
(brace
id|down
c_func
(paren
op_amp
id|scc_sem
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|scc_wbuf
comma
id|buf
comma
id|cnt
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|scc_sem
)paren
suffix:semicolon
)brace
r_else
id|memcpy
c_func
(paren
id|scc_wbuf
comma
id|buf
comma
id|cnt
)paren
suffix:semicolon
multiline_comment|/* Strange thing. The timeout of the slip driver is */
multiline_comment|/* very small, thus we&squot;ll wake him up now. &t;    */
r_if
c_cond
(paren
id|cnt2
op_eq
l_int|0
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
r_else
id|buf
op_add_assign
id|cnt
suffix:semicolon
id|p
op_assign
id|scc_wbuf
suffix:semicolon
r_while
c_loop
(paren
id|cnt
op_decrement
)paren
r_if
c_cond
(paren
id|kiss_decode
c_func
(paren
id|scc
comma
op_star
id|p
op_increment
)paren
)paren
(brace
id|scc-&gt;stat.nospace
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* while cnt2 */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* put a single char into the buffer */
DECL|function|scc_put_char
r_static
r_void
id|scc_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_char
id|ch2
suffix:semicolon
r_if
c_cond
(paren
id|scc_paranoia_check
c_func
(paren
id|scc
comma
id|tty-&gt;device
comma
l_string|&quot;scc_put_char&quot;
)paren
)paren
r_return
suffix:semicolon
id|ch2
op_assign
id|ch
suffix:semicolon
id|scc_write
c_func
(paren
id|tty
comma
l_int|0
comma
op_amp
id|ch2
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* that&squot;s all */
)brace
DECL|function|scc_flush_chars
r_static
r_void
id|scc_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
id|tty-&gt;driver_data
suffix:semicolon
id|scc_paranoia_check
c_func
(paren
id|scc
comma
id|tty-&gt;device
comma
l_string|&quot;scc_flush_chars&quot;
)paren
suffix:semicolon
multiline_comment|/* just to annoy the user... */
r_return
suffix:semicolon
multiline_comment|/* no flush needed */
)brace
DECL|function|scc_write_room
r_static
r_int
id|scc_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|scc_paranoia_check
c_func
(paren
id|scc
comma
id|tty-&gt;device
comma
l_string|&quot;scc_write_room&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|BUFSIZE
suffix:semicolon
)brace
DECL|function|scc_chars_in_buffer
r_static
r_int
id|scc_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|scc
op_logical_and
id|scc-&gt;kiss_decode_bp
)paren
r_return
id|scc-&gt;kiss_decode_bp-&gt;cnt
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|scc_flush_buffer
r_static
r_void
id|scc_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|scc_paranoia_check
c_func
(paren
id|scc
comma
id|tty-&gt;device
comma
l_string|&quot;scc_flush_buffer&quot;
)paren
)paren
r_return
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|scc_throttle
r_static
r_void
id|scc_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|scc_paranoia_check
c_func
(paren
id|scc
comma
id|tty-&gt;device
comma
l_string|&quot;scc_throttle&quot;
)paren
)paren
r_return
suffix:semicolon
macro_line|#ifdef DEBUG&t;&t;
id|printk
c_func
(paren
l_string|&quot;scc: scc_throttle() called for device %d&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
macro_line|#endif
id|scc-&gt;throttled
op_assign
l_int|1
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
(paren
id|scc-&gt;rx_t
)paren
)paren
suffix:semicolon
id|scc-&gt;rx_t.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
id|TPS
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|scc-&gt;rx_t
)paren
suffix:semicolon
)brace
DECL|function|scc_unthrottle
r_static
r_void
id|scc_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|scc_paranoia_check
c_func
(paren
id|scc
comma
id|tty-&gt;device
comma
l_string|&quot;scc_unthrottle&quot;
)paren
)paren
r_return
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;scc: scc_unthrottle() called for device %d&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
macro_line|#endif&t;&t;
id|scc-&gt;throttled
op_assign
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
(paren
id|scc-&gt;rx_t
)paren
)paren
suffix:semicolon
id|scc_tx_timer
c_func
(paren
id|scc-&gt;rx_t.data
)paren
suffix:semicolon
)brace
multiline_comment|/* experimental, the easiest way to stop output is a fake scc_throttle */
DECL|function|scc_start
r_static
r_void
id|scc_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|scc_paranoia_check
c_func
(paren
id|scc
comma
id|tty-&gt;device
comma
l_string|&quot;scc_start&quot;
)paren
)paren
r_return
suffix:semicolon
id|scc_unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|scc_stop
r_static
r_void
id|scc_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|scc_paranoia_check
c_func
(paren
id|scc
comma
id|tty-&gt;device
comma
l_string|&quot;scc_stop&quot;
)paren
)paren
r_return
suffix:semicolon
id|scc_throttle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|scc_set_termios
id|scc_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|scc_paranoia_check
c_func
(paren
id|scc
comma
id|tty-&gt;device
comma
l_string|&quot;scc_set_termios&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|old_termios
op_logical_and
(paren
id|tty-&gt;termios-&gt;c_cflag
op_eq
id|old_termios-&gt;c_cflag
)paren
)paren
r_return
suffix:semicolon
id|scc_change_speed
c_func
(paren
id|scc
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|scc_set_ldisc
id|scc_set_ldisc
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|scc_channel
op_star
id|scc
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|scc_paranoia_check
c_func
(paren
id|scc
comma
id|tty-&gt;device
comma
l_string|&quot;scc_set_ldisc&quot;
)paren
)paren
r_return
suffix:semicolon
id|scc_change_speed
c_func
(paren
id|scc
)paren
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* * &t;&t;&t;Init SCC driver &t;&t;&t;      * */
multiline_comment|/* ******************************************************************** */
DECL|function|scc_init
r_int
id|scc_init
(paren
r_void
)paren
(brace
r_int
id|chip
comma
id|chan
comma
id|k
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|scc_std_termios
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|scc_driver
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|scc_driver.magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
id|scc_driver.name
op_assign
l_string|&quot;scc&quot;
suffix:semicolon
id|scc_driver.major
op_assign
id|Z8530_MAJOR
suffix:semicolon
id|scc_driver.minor_start
op_assign
l_int|0
suffix:semicolon
id|scc_driver.num
op_assign
id|MAXSCC
op_star
l_int|2
suffix:semicolon
id|scc_driver.type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
id|scc_driver.subtype
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* not needed */
id|scc_driver.init_termios
op_assign
id|scc_std_termios
suffix:semicolon
id|scc_driver.init_termios.c_cflag
op_assign
id|B9600
op_or
id|CREAD
op_or
id|CS8
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
id|scc_driver.init_termios.c_iflag
op_assign
id|IGNBRK
op_or
id|IGNPAR
suffix:semicolon
id|scc_driver.flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
id|scc_driver.refcount
op_assign
op_amp
id|scc_refcount
suffix:semicolon
id|scc_driver.table
op_assign
id|scc_table
suffix:semicolon
id|scc_driver.termios
op_assign
(paren
r_struct
id|termios
op_star
op_star
)paren
id|scc_termios
suffix:semicolon
id|scc_driver.termios_locked
op_assign
(paren
r_struct
id|termios
op_star
op_star
)paren
id|scc_termios_locked
suffix:semicolon
id|scc_driver.open
op_assign
id|scc_open
suffix:semicolon
id|scc_driver.close
op_assign
id|scc_close
suffix:semicolon
id|scc_driver.write
op_assign
id|scc_write
suffix:semicolon
id|scc_driver.start
op_assign
id|scc_start
suffix:semicolon
id|scc_driver.stop
op_assign
id|scc_stop
suffix:semicolon
id|scc_driver.put_char
op_assign
id|scc_put_char
suffix:semicolon
id|scc_driver.flush_chars
op_assign
id|scc_flush_chars
suffix:semicolon
id|scc_driver.write_room
op_assign
id|scc_write_room
suffix:semicolon
id|scc_driver.chars_in_buffer
op_assign
id|scc_chars_in_buffer
suffix:semicolon
id|scc_driver.flush_buffer
op_assign
id|scc_flush_buffer
suffix:semicolon
id|scc_driver.throttle
op_assign
id|scc_throttle
suffix:semicolon
id|scc_driver.unthrottle
op_assign
id|scc_unthrottle
suffix:semicolon
id|scc_driver.ioctl
op_assign
id|scc_ioctl
suffix:semicolon
id|scc_driver.set_termios
op_assign
id|scc_set_termios
suffix:semicolon
id|scc_driver.set_ldisc
op_assign
id|scc_set_ldisc
suffix:semicolon
id|printk
c_func
(paren
id|BANNER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|scc_driver
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failed to register Z8530 SCC driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* pre-init channel information */
r_for
c_loop
(paren
id|chip
op_assign
l_int|0
suffix:semicolon
id|chip
OL
id|MAXSCC
suffix:semicolon
id|chip
op_increment
)paren
(brace
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|SCC_Info
(braket
l_int|2
op_star
id|chip
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|scc_channel
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|SCC_Info
(braket
l_int|2
op_star
id|chip
op_plus
l_int|1
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|scc_channel
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|chan
op_assign
l_int|0
suffix:semicolon
id|chan
OL
l_int|2
suffix:semicolon
id|chan
op_increment
)paren
(brace
id|SCC_Info
(braket
l_int|2
op_star
id|chip
op_plus
id|chan
)braket
dot
id|magic
op_assign
id|SCC_MAGIC
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|chip
op_plus
id|chan
)braket
dot
id|stat.rxbuffers
op_assign
id|RXBUFFERS
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|chip
op_plus
id|chan
)braket
dot
id|stat.txbuffers
op_assign
id|TXBUFFERS
suffix:semicolon
id|SCC_Info
(braket
l_int|2
op_star
id|chip
op_plus
id|chan
)braket
dot
id|stat.bufsize
op_assign
id|BUFSIZE
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|16
suffix:semicolon
id|k
op_increment
)paren
id|Ivec
(braket
id|k
)braket
dot
id|used
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ******************************************************************** */
multiline_comment|/* *&t;&t;&t;    Module support &t;&t;&t;      * */
multiline_comment|/* ******************************************************************** */
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|result
op_assign
l_int|0
suffix:semicolon
id|result
op_assign
id|scc_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;Copyright 1993,1995 Joerg Reuter DL1BKE (jreuter@lykos.tng.oche.de)&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|flags
suffix:semicolon
id|io_port
id|ctrl
suffix:semicolon
r_int
id|k
comma
id|errno
suffix:semicolon
r_struct
id|scc_channel
op_star
id|scc
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|errno
op_assign
id|tty_unregister_driver
c_func
(paren
op_amp
id|scc_driver
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failed to unregister Z8530 SCC driver (%d)&quot;
comma
op_minus
id|errno
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|Nchips
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
(paren
id|ctrl
op_assign
id|SCC_ctrl
(braket
id|k
op_star
l_int|2
)braket
)paren
)paren
(brace
id|Outb
c_func
(paren
id|ctrl
comma
l_int|0
)paren
suffix:semicolon
id|OutReg
c_func
(paren
id|ctrl
comma
id|R9
comma
id|FHWRES
)paren
suffix:semicolon
multiline_comment|/* force hardware reset */
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|Nchips
op_star
l_int|2
suffix:semicolon
id|k
op_increment
)paren
(brace
id|scc
op_assign
op_amp
id|SCC_Info
(braket
id|k
)braket
suffix:semicolon
r_if
c_cond
(paren
id|scc
)paren
(brace
id|release_region
c_func
(paren
id|scc-&gt;ctrl
comma
l_int|1
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|scc-&gt;data
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|16
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|Ivec
(braket
id|k
)braket
dot
id|used
)paren
id|free_irq
c_func
(paren
id|k
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
