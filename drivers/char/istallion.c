multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;istallion.c  -- stallion intelligent multiport serial driver.&n; *&n; *&t;Copyright (C) 1996-1999  Stallion Technologies (support@stallion.oz.au).&n; *&t;Copyright (C) 1994-1996  Greg Ungerer.&n; *&n; *&t;This code is loosely based on the Linux serial driver, written by&n; *&t;Linus Torvalds, Theodore T&squot;so and others.&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;This program is distributed in the hope that it will be useful,&n; *&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *&t;GNU General Public License for more details.&n; *&n; *&t;You should have received a copy of the GNU General Public License&n; *&t;along with this program; if not, write to the Free Software&n; *&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
multiline_comment|/*****************************************************************************/
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/cdk.h&gt;
macro_line|#include &lt;linux/comstats.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/istallion.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifdef CONFIG_PCI
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#endif
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Define different board types. Not all of the following board types&n; *&t;are supported by this driver. But I will use the standard &quot;assigned&quot;&n; *&t;board numbers. Currently supported boards are abbreviated as:&n; *&t;ECP = EasyConnection 8/64, ONB = ONboard, BBY = Brumby and&n; *&t;STAL = Stallion.&n; */
DECL|macro|BRD_UNKNOWN
mdefine_line|#define&t;BRD_UNKNOWN&t;0
DECL|macro|BRD_STALLION
mdefine_line|#define&t;BRD_STALLION&t;1
DECL|macro|BRD_BRUMBY4
mdefine_line|#define&t;BRD_BRUMBY4&t;2
DECL|macro|BRD_ONBOARD2
mdefine_line|#define&t;BRD_ONBOARD2&t;3
DECL|macro|BRD_ONBOARD
mdefine_line|#define&t;BRD_ONBOARD&t;4
DECL|macro|BRD_BRUMBY8
mdefine_line|#define&t;BRD_BRUMBY8&t;5
DECL|macro|BRD_BRUMBY16
mdefine_line|#define&t;BRD_BRUMBY16&t;6
DECL|macro|BRD_ONBOARDE
mdefine_line|#define&t;BRD_ONBOARDE&t;7
DECL|macro|BRD_ONBOARD32
mdefine_line|#define&t;BRD_ONBOARD32&t;9
DECL|macro|BRD_ONBOARD2_32
mdefine_line|#define&t;BRD_ONBOARD2_32&t;10
DECL|macro|BRD_ONBOARDRS
mdefine_line|#define&t;BRD_ONBOARDRS&t;11
DECL|macro|BRD_EASYIO
mdefine_line|#define&t;BRD_EASYIO&t;20
DECL|macro|BRD_ECH
mdefine_line|#define&t;BRD_ECH&t;&t;21
DECL|macro|BRD_ECHMC
mdefine_line|#define&t;BRD_ECHMC&t;22
DECL|macro|BRD_ECP
mdefine_line|#define&t;BRD_ECP&t;&t;23
DECL|macro|BRD_ECPE
mdefine_line|#define BRD_ECPE&t;24
DECL|macro|BRD_ECPMC
mdefine_line|#define&t;BRD_ECPMC&t;25
DECL|macro|BRD_ECHPCI
mdefine_line|#define&t;BRD_ECHPCI&t;26
DECL|macro|BRD_ECH64PCI
mdefine_line|#define&t;BRD_ECH64PCI&t;27
DECL|macro|BRD_EASYIOPCI
mdefine_line|#define&t;BRD_EASYIOPCI&t;28
DECL|macro|BRD_ECPPCI
mdefine_line|#define&t;BRD_ECPPCI&t;29
DECL|macro|BRD_BRUMBY
mdefine_line|#define&t;BRD_BRUMBY&t;BRD_BRUMBY4
multiline_comment|/*&n; *&t;Define a configuration structure to hold the board configuration.&n; *&t;Need to set this up in the code (for now) with the boards that are&n; *&t;to be configured into the system. This is what needs to be modified&n; *&t;when adding/removing/modifying boards. Each line entry in the&n; *&t;stli_brdconf[] array is a board. Each line contains io/irq/memory&n; *&t;ranges for that board (as well as what type of board it is).&n; *&t;Some examples:&n; *&t;&t;{ BRD_ECP, 0x2a0, 0, 0xcc000, 0, 0 },&n; *&t;This line will configure an EasyConnection 8/64 at io address 2a0,&n; *&t;and shared memory address of cc000. Multiple EasyConnection 8/64&n; *&t;boards can share the same shared memory address space. No interrupt&n; *&t;is required for this board type.&n; *&t;Another example:&n; *&t;&t;{ BRD_ECPE, 0x5000, 0, 0x80000000, 0, 0 },&n; *&t;This line will configure an EasyConnection 8/64 EISA in slot 5 and&n; *&t;shared memory address of 0x80000000 (2 GByte). Multiple&n; *&t;EasyConnection 8/64 EISA boards can share the same shared memory&n; *&t;address space. No interrupt is required for this board type.&n; *&t;Another example:&n; *&t;&t;{ BRD_ONBOARD, 0x240, 0, 0xd0000, 0, 0 },&n; *&t;This line will configure an ONboard (ISA type) at io address 240,&n; *&t;and shared memory address of d0000. Multiple ONboards can share&n; *&t;the same shared memory address space. No interrupt required.&n; *&t;Another example:&n; *&t;&t;{ BRD_BRUMBY4, 0x360, 0, 0xc8000, 0, 0 },&n; *&t;This line will configure a Brumby board (any number of ports!) at&n; *&t;io address 360 and shared memory address of c8000. All Brumby boards&n; *&t;configured into a system must have their own separate io and memory&n; *&t;addresses. No interrupt is required.&n; *&t;Another example:&n; *&t;&t;{ BRD_STALLION, 0x330, 0, 0xd0000, 0, 0 },&n; *&t;This line will configure an original Stallion board at io address 330&n; *&t;and shared memory address d0000 (this would only be valid for a &quot;V4.0&quot;&n; *&t;or Rev.O Stallion board). All Stallion boards configured into the&n; *&t;system must have their own separate io and memory addresses. No&n; *&t;interrupt is required.&n; */
r_typedef
r_struct
(brace
DECL|member|brdtype
r_int
id|brdtype
suffix:semicolon
DECL|member|ioaddr1
r_int
id|ioaddr1
suffix:semicolon
DECL|member|ioaddr2
r_int
id|ioaddr2
suffix:semicolon
DECL|member|memaddr
r_int
r_int
id|memaddr
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|irqtype
r_int
id|irqtype
suffix:semicolon
DECL|typedef|stlconf_t
)brace
id|stlconf_t
suffix:semicolon
DECL|variable|stli_brdconf
r_static
id|stlconf_t
id|stli_brdconf
(braket
)braket
op_assign
(brace
multiline_comment|/*{ BRD_ECP, 0x2a0, 0, 0xcc000, 0, 0 },*/
)brace
suffix:semicolon
DECL|variable|stli_nrbrds
r_static
r_int
id|stli_nrbrds
op_assign
r_sizeof
(paren
id|stli_brdconf
)paren
op_div
r_sizeof
(paren
id|stlconf_t
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;There is some experimental EISA board detection code in this driver.&n; *&t;By default it is disabled, but for those that want to try it out,&n; *&t;then set the define below to be 1.&n; */
DECL|macro|STLI_EISAPROBE
mdefine_line|#define&t;STLI_EISAPROBE&t;0
DECL|variable|devfs_handle
r_static
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Define some important driver characteristics. Device major numbers&n; *&t;allocated as per Linux Device Registry.&n; */
macro_line|#ifndef&t;STL_SIOMEMMAJOR
DECL|macro|STL_SIOMEMMAJOR
mdefine_line|#define&t;STL_SIOMEMMAJOR&t;&t;28
macro_line|#endif
macro_line|#ifndef&t;STL_SERIALMAJOR
DECL|macro|STL_SERIALMAJOR
mdefine_line|#define&t;STL_SERIALMAJOR&t;&t;24
macro_line|#endif
macro_line|#ifndef&t;STL_CALLOUTMAJOR
DECL|macro|STL_CALLOUTMAJOR
mdefine_line|#define&t;STL_CALLOUTMAJOR&t;25
macro_line|#endif
DECL|macro|STL_DRVTYPSERIAL
mdefine_line|#define&t;STL_DRVTYPSERIAL&t;1
DECL|macro|STL_DRVTYPCALLOUT
mdefine_line|#define&t;STL_DRVTYPCALLOUT&t;2
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Define our local driver identity first. Set up stuff to deal with&n; *&t;all the local structures required by a serial tty driver.&n; */
DECL|variable|stli_drvtitle
r_static
r_char
op_star
id|stli_drvtitle
op_assign
l_string|&quot;Stallion Intelligent Multiport Serial Driver&quot;
suffix:semicolon
DECL|variable|stli_drvname
r_static
r_char
op_star
id|stli_drvname
op_assign
l_string|&quot;istallion&quot;
suffix:semicolon
DECL|variable|stli_drvversion
r_static
r_char
op_star
id|stli_drvversion
op_assign
l_string|&quot;5.6.0&quot;
suffix:semicolon
DECL|variable|stli_serialname
r_static
r_char
op_star
id|stli_serialname
op_assign
l_string|&quot;ttyE&quot;
suffix:semicolon
DECL|variable|stli_calloutname
r_static
r_char
op_star
id|stli_calloutname
op_assign
l_string|&quot;cue&quot;
suffix:semicolon
DECL|variable|stli_serial
r_static
r_struct
id|tty_driver
id|stli_serial
suffix:semicolon
DECL|variable|stli_callout
r_static
r_struct
id|tty_driver
id|stli_callout
suffix:semicolon
DECL|variable|stli_ttys
r_static
r_struct
id|tty_struct
op_star
id|stli_ttys
(braket
id|STL_MAXDEVS
)braket
suffix:semicolon
DECL|variable|stli_termios
r_static
r_struct
id|termios
op_star
id|stli_termios
(braket
id|STL_MAXDEVS
)braket
suffix:semicolon
DECL|variable|stli_termioslocked
r_static
r_struct
id|termios
op_star
id|stli_termioslocked
(braket
id|STL_MAXDEVS
)braket
suffix:semicolon
DECL|variable|stli_refcount
r_static
r_int
id|stli_refcount
suffix:semicolon
multiline_comment|/*&n; *&t;We will need to allocate a temporary write buffer for chars that&n; *&t;come direct from user space. The problem is that a copy from user&n; *&t;space might cause a page fault (typically on a system that is&n; *&t;swapping!). All ports will share one buffer - since if the system&n; *&t;is already swapping a shared buffer won&squot;t make things any worse.&n; */
DECL|variable|stli_tmpwritebuf
r_static
r_char
op_star
id|stli_tmpwritebuf
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|stli_tmpwritesem
)paren
suffix:semicolon
DECL|macro|STLI_TXBUFSIZE
mdefine_line|#define&t;STLI_TXBUFSIZE&t;&t;4096
multiline_comment|/*&n; *&t;Use a fast local buffer for cooked characters. Typically a whole&n; *&t;bunch of cooked characters come in for a port, 1 at a time. So we&n; *&t;save those up into a local buffer, then write out the whole lot&n; *&t;with a large memcpy. Just use 1 buffer for all ports, since its&n; *&t;use it is only need for short periods of time by each port.&n; */
DECL|variable|stli_txcookbuf
r_static
r_char
op_star
id|stli_txcookbuf
suffix:semicolon
DECL|variable|stli_txcooksize
r_static
r_int
id|stli_txcooksize
suffix:semicolon
DECL|variable|stli_txcookrealsize
r_static
r_int
id|stli_txcookrealsize
suffix:semicolon
DECL|variable|stli_txcooktty
r_static
r_struct
id|tty_struct
op_star
id|stli_txcooktty
suffix:semicolon
multiline_comment|/*&n; *&t;Define a local default termios struct. All ports will be created&n; *&t;with this termios initially. Basically all it defines is a raw port&n; *&t;at 9600 baud, 8 data bits, no parity, 1 stop bit.&n; */
DECL|variable|stli_deftermios
r_static
r_struct
id|termios
id|stli_deftermios
op_assign
(brace
l_int|0
comma
l_int|0
comma
(paren
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
)paren
comma
l_int|0
comma
l_int|0
comma
id|INIT_C_CC
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Define global stats structures. Not used often, and can be&n; *&t;re-used for each stats call.&n; */
DECL|variable|stli_comstats
r_static
id|comstats_t
id|stli_comstats
suffix:semicolon
DECL|variable|stli_brdstats
r_static
id|combrd_t
id|stli_brdstats
suffix:semicolon
DECL|variable|stli_cdkstats
r_static
id|asystats_t
id|stli_cdkstats
suffix:semicolon
DECL|variable|stli_dummybrd
r_static
id|stlibrd_t
id|stli_dummybrd
suffix:semicolon
DECL|variable|stli_dummyport
r_static
id|stliport_t
id|stli_dummyport
suffix:semicolon
multiline_comment|/*****************************************************************************/
DECL|variable|stli_brds
r_static
id|stlibrd_t
op_star
id|stli_brds
(braket
id|STL_MAXBRDS
)braket
suffix:semicolon
DECL|variable|stli_shared
r_static
r_int
id|stli_shared
suffix:semicolon
multiline_comment|/*&n; *&t;Per board state flags. Used with the state field of the board struct.&n; *&t;Not really much here... All we need to do is keep track of whether&n; *&t;the board has been detected, and whether it is actually running a slave&n; *&t;or not.&n; */
DECL|macro|BST_FOUND
mdefine_line|#define&t;BST_FOUND&t;0x1
DECL|macro|BST_STARTED
mdefine_line|#define&t;BST_STARTED&t;0x2
multiline_comment|/*&n; *&t;Define the set of port state flags. These are marked for internal&n; *&t;state purposes only, usually to do with the state of communications&n; *&t;with the slave. Most of them need to be updated atomically, so always&n; *&t;use the bit setting operations (unless protected by cli/sti).&n; */
DECL|macro|ST_INITIALIZING
mdefine_line|#define&t;ST_INITIALIZING&t;1
DECL|macro|ST_OPENING
mdefine_line|#define&t;ST_OPENING&t;2
DECL|macro|ST_CLOSING
mdefine_line|#define&t;ST_CLOSING&t;3
DECL|macro|ST_CMDING
mdefine_line|#define&t;ST_CMDING&t;4
DECL|macro|ST_TXBUSY
mdefine_line|#define&t;ST_TXBUSY&t;5
DECL|macro|ST_RXING
mdefine_line|#define&t;ST_RXING&t;6
DECL|macro|ST_DOFLUSHRX
mdefine_line|#define&t;ST_DOFLUSHRX&t;7
DECL|macro|ST_DOFLUSHTX
mdefine_line|#define&t;ST_DOFLUSHTX&t;8
DECL|macro|ST_DOSIGS
mdefine_line|#define&t;ST_DOSIGS&t;9
DECL|macro|ST_RXSTOP
mdefine_line|#define&t;ST_RXSTOP&t;10
DECL|macro|ST_GETSIGS
mdefine_line|#define&t;ST_GETSIGS&t;11
multiline_comment|/*&n; *&t;Define an array of board names as printable strings. Handy for&n; *&t;referencing boards when printing trace and stuff.&n; */
DECL|variable|stli_brdnames
r_static
r_char
op_star
id|stli_brdnames
(braket
)braket
op_assign
(brace
l_string|&quot;Unknown&quot;
comma
l_string|&quot;Stallion&quot;
comma
l_string|&quot;Brumby&quot;
comma
l_string|&quot;ONboard-MC&quot;
comma
l_string|&quot;ONboard&quot;
comma
l_string|&quot;Brumby&quot;
comma
l_string|&quot;Brumby&quot;
comma
l_string|&quot;ONboard-EI&quot;
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
l_string|&quot;ONboard&quot;
comma
l_string|&quot;ONboard-MC&quot;
comma
l_string|&quot;ONboard-MC&quot;
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
(paren
r_char
op_star
)paren
l_int|NULL
comma
l_string|&quot;EasyIO&quot;
comma
l_string|&quot;EC8/32-AT&quot;
comma
l_string|&quot;EC8/32-MC&quot;
comma
l_string|&quot;EC8/64-AT&quot;
comma
l_string|&quot;EC8/64-EI&quot;
comma
l_string|&quot;EC8/64-MC&quot;
comma
l_string|&quot;EC8/32-PCI&quot;
comma
l_string|&quot;EC8/64-PCI&quot;
comma
l_string|&quot;EasyIO-PCI&quot;
comma
l_string|&quot;EC/RA-PCI&quot;
comma
)brace
suffix:semicolon
multiline_comment|/*****************************************************************************/
macro_line|#ifdef MODULE
multiline_comment|/*&n; *&t;Define some string labels for arguments passed from the module&n; *&t;load line. These allow for easy board definitions, and easy&n; *&t;modification of the io, memory and irq resoucres.&n; */
DECL|variable|board0
r_static
r_char
op_star
id|board0
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|board1
r_static
r_char
op_star
id|board1
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|board2
r_static
r_char
op_star
id|board2
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|board3
r_static
r_char
op_star
id|board3
(braket
l_int|8
)braket
suffix:semicolon
DECL|variable|stli_brdsp
r_static
r_char
op_star
op_star
id|stli_brdsp
(braket
)braket
op_assign
(brace
(paren
r_char
op_star
op_star
)paren
op_amp
id|board0
comma
(paren
r_char
op_star
op_star
)paren
op_amp
id|board1
comma
(paren
r_char
op_star
op_star
)paren
op_amp
id|board2
comma
(paren
r_char
op_star
op_star
)paren
op_amp
id|board3
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Define a set of common board names, and types. This is used to&n; *&t;parse any module arguments.&n; */
DECL|struct|stlibrdtype
r_typedef
r_struct
id|stlibrdtype
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|typedef|stlibrdtype_t
)brace
id|stlibrdtype_t
suffix:semicolon
DECL|variable|stli_brdstr
r_static
id|stlibrdtype_t
id|stli_brdstr
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;stallion&quot;
comma
id|BRD_STALLION
)brace
comma
(brace
l_string|&quot;1&quot;
comma
id|BRD_STALLION
)brace
comma
(brace
l_string|&quot;brumby&quot;
comma
id|BRD_BRUMBY
)brace
comma
(brace
l_string|&quot;brumby4&quot;
comma
id|BRD_BRUMBY
)brace
comma
(brace
l_string|&quot;brumby/4&quot;
comma
id|BRD_BRUMBY
)brace
comma
(brace
l_string|&quot;brumby-4&quot;
comma
id|BRD_BRUMBY
)brace
comma
(brace
l_string|&quot;brumby8&quot;
comma
id|BRD_BRUMBY
)brace
comma
(brace
l_string|&quot;brumby/8&quot;
comma
id|BRD_BRUMBY
)brace
comma
(brace
l_string|&quot;brumby-8&quot;
comma
id|BRD_BRUMBY
)brace
comma
(brace
l_string|&quot;brumby16&quot;
comma
id|BRD_BRUMBY
)brace
comma
(brace
l_string|&quot;brumby/16&quot;
comma
id|BRD_BRUMBY
)brace
comma
(brace
l_string|&quot;brumby-16&quot;
comma
id|BRD_BRUMBY
)brace
comma
(brace
l_string|&quot;2&quot;
comma
id|BRD_BRUMBY
)brace
comma
(brace
l_string|&quot;onboard2&quot;
comma
id|BRD_ONBOARD2
)brace
comma
(brace
l_string|&quot;onboard-2&quot;
comma
id|BRD_ONBOARD2
)brace
comma
(brace
l_string|&quot;onboard/2&quot;
comma
id|BRD_ONBOARD2
)brace
comma
(brace
l_string|&quot;onboard-mc&quot;
comma
id|BRD_ONBOARD2
)brace
comma
(brace
l_string|&quot;onboard/mc&quot;
comma
id|BRD_ONBOARD2
)brace
comma
(brace
l_string|&quot;onboard-mca&quot;
comma
id|BRD_ONBOARD2
)brace
comma
(brace
l_string|&quot;onboard/mca&quot;
comma
id|BRD_ONBOARD2
)brace
comma
(brace
l_string|&quot;3&quot;
comma
id|BRD_ONBOARD2
)brace
comma
(brace
l_string|&quot;onboard&quot;
comma
id|BRD_ONBOARD
)brace
comma
(brace
l_string|&quot;onboardat&quot;
comma
id|BRD_ONBOARD
)brace
comma
(brace
l_string|&quot;4&quot;
comma
id|BRD_ONBOARD
)brace
comma
(brace
l_string|&quot;onboarde&quot;
comma
id|BRD_ONBOARDE
)brace
comma
(brace
l_string|&quot;onboard-e&quot;
comma
id|BRD_ONBOARDE
)brace
comma
(brace
l_string|&quot;onboard/e&quot;
comma
id|BRD_ONBOARDE
)brace
comma
(brace
l_string|&quot;onboard-ei&quot;
comma
id|BRD_ONBOARDE
)brace
comma
(brace
l_string|&quot;onboard/ei&quot;
comma
id|BRD_ONBOARDE
)brace
comma
(brace
l_string|&quot;7&quot;
comma
id|BRD_ONBOARDE
)brace
comma
(brace
l_string|&quot;ecp&quot;
comma
id|BRD_ECP
)brace
comma
(brace
l_string|&quot;ecpat&quot;
comma
id|BRD_ECP
)brace
comma
(brace
l_string|&quot;ec8/64&quot;
comma
id|BRD_ECP
)brace
comma
(brace
l_string|&quot;ec8/64-at&quot;
comma
id|BRD_ECP
)brace
comma
(brace
l_string|&quot;ec8/64-isa&quot;
comma
id|BRD_ECP
)brace
comma
(brace
l_string|&quot;23&quot;
comma
id|BRD_ECP
)brace
comma
(brace
l_string|&quot;ecpe&quot;
comma
id|BRD_ECPE
)brace
comma
(brace
l_string|&quot;ecpei&quot;
comma
id|BRD_ECPE
)brace
comma
(brace
l_string|&quot;ec8/64-e&quot;
comma
id|BRD_ECPE
)brace
comma
(brace
l_string|&quot;ec8/64-ei&quot;
comma
id|BRD_ECPE
)brace
comma
(brace
l_string|&quot;24&quot;
comma
id|BRD_ECPE
)brace
comma
(brace
l_string|&quot;ecpmc&quot;
comma
id|BRD_ECPMC
)brace
comma
(brace
l_string|&quot;ec8/64-mc&quot;
comma
id|BRD_ECPMC
)brace
comma
(brace
l_string|&quot;ec8/64-mca&quot;
comma
id|BRD_ECPMC
)brace
comma
(brace
l_string|&quot;25&quot;
comma
id|BRD_ECPMC
)brace
comma
(brace
l_string|&quot;ecppci&quot;
comma
id|BRD_ECPPCI
)brace
comma
(brace
l_string|&quot;ec/ra&quot;
comma
id|BRD_ECPPCI
)brace
comma
(brace
l_string|&quot;ec/ra-pc&quot;
comma
id|BRD_ECPPCI
)brace
comma
(brace
l_string|&quot;ec/ra-pci&quot;
comma
id|BRD_ECPPCI
)brace
comma
(brace
l_string|&quot;29&quot;
comma
id|BRD_ECPPCI
)brace
comma
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;Define the module agruments.&n; */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Greg Ungerer&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Stallion Intelligent Multiport Serial Driver&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|board0
comma
l_string|&quot;1-3s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|board0
comma
l_string|&quot;Board 0 config -&gt; name[,ioaddr[,memaddr]&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|board1
comma
l_string|&quot;1-3s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|board1
comma
l_string|&quot;Board 1 config -&gt; name[,ioaddr[,memaddr]&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|board2
comma
l_string|&quot;1-3s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|board2
comma
l_string|&quot;Board 2 config -&gt; name[,ioaddr[,memaddr]&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|board3
comma
l_string|&quot;1-3s&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|board3
comma
l_string|&quot;Board 3 config -&gt; name[,ioaddr[,memaddr]&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;Set up a default memory address table for EISA board probing.&n; *&t;The default addresses are all bellow 1Mbyte, which has to be the&n; *&t;case anyway. They should be safe, since we only read values from&n; *&t;them, and interrupts are disabled while we do it. If the higher&n; *&t;memory support is compiled in then we also try probing around&n; *&t;the 1Gb, 2Gb and 3Gb areas as well...&n; */
DECL|variable|stli_eisamemprobeaddrs
r_static
r_int
r_int
id|stli_eisamemprobeaddrs
(braket
)braket
op_assign
(brace
l_int|0xc0000
comma
l_int|0xd0000
comma
l_int|0xe0000
comma
l_int|0xf0000
comma
l_int|0x80000000
comma
l_int|0x80010000
comma
l_int|0x80020000
comma
l_int|0x80030000
comma
l_int|0x40000000
comma
l_int|0x40010000
comma
l_int|0x40020000
comma
l_int|0x40030000
comma
l_int|0xc0000000
comma
l_int|0xc0010000
comma
l_int|0xc0020000
comma
l_int|0xc0030000
comma
l_int|0xff000000
comma
l_int|0xff010000
comma
l_int|0xff020000
comma
l_int|0xff030000
comma
)brace
suffix:semicolon
DECL|variable|stli_eisamempsize
r_static
r_int
id|stli_eisamempsize
op_assign
r_sizeof
(paren
id|stli_eisamemprobeaddrs
)paren
op_div
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|stli_eisaprobe
r_int
id|stli_eisaprobe
op_assign
id|STLI_EISAPROBE
suffix:semicolon
multiline_comment|/*&n; *&t;Define the Stallion PCI vendor and device IDs.&n; */
macro_line|#ifdef CONFIG_PCI
macro_line|#ifndef&t;PCI_VENDOR_ID_STALLION
DECL|macro|PCI_VENDOR_ID_STALLION
mdefine_line|#define&t;PCI_VENDOR_ID_STALLION&t;&t;0x124d
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_ECRA
DECL|macro|PCI_DEVICE_ID_ECRA
mdefine_line|#define&t;PCI_DEVICE_ID_ECRA&t;&t;0x0004
macro_line|#endif
macro_line|#endif
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Hardware configuration info for ECP boards. These defines apply&n; *&t;to the directly accessible io ports of the ECP. There is a set of&n; *&t;defines for each ECP board type, ISA, EISA, MCA and PCI.&n; */
DECL|macro|ECP_IOSIZE
mdefine_line|#define&t;ECP_IOSIZE&t;4
DECL|macro|ECP_MEMSIZE
mdefine_line|#define&t;ECP_MEMSIZE&t;(128 * 1024)
DECL|macro|ECP_PCIMEMSIZE
mdefine_line|#define&t;ECP_PCIMEMSIZE&t;(256 * 1024)
DECL|macro|ECP_ATPAGESIZE
mdefine_line|#define&t;ECP_ATPAGESIZE&t;(4 * 1024)
DECL|macro|ECP_MCPAGESIZE
mdefine_line|#define&t;ECP_MCPAGESIZE&t;(4 * 1024)
DECL|macro|ECP_EIPAGESIZE
mdefine_line|#define&t;ECP_EIPAGESIZE&t;(64 * 1024)
DECL|macro|ECP_PCIPAGESIZE
mdefine_line|#define&t;ECP_PCIPAGESIZE&t;(64 * 1024)
DECL|macro|STL_EISAID
mdefine_line|#define&t;STL_EISAID&t;0x8c4e
multiline_comment|/*&n; *&t;Important defines for the ISA class of ECP board.&n; */
DECL|macro|ECP_ATIREG
mdefine_line|#define&t;ECP_ATIREG&t;0
DECL|macro|ECP_ATCONFR
mdefine_line|#define&t;ECP_ATCONFR&t;1
DECL|macro|ECP_ATMEMAR
mdefine_line|#define&t;ECP_ATMEMAR&t;2
DECL|macro|ECP_ATMEMPR
mdefine_line|#define&t;ECP_ATMEMPR&t;3
DECL|macro|ECP_ATSTOP
mdefine_line|#define&t;ECP_ATSTOP&t;0x1
DECL|macro|ECP_ATINTENAB
mdefine_line|#define&t;ECP_ATINTENAB&t;0x10
DECL|macro|ECP_ATENABLE
mdefine_line|#define&t;ECP_ATENABLE&t;0x20
DECL|macro|ECP_ATDISABLE
mdefine_line|#define&t;ECP_ATDISABLE&t;0x00
DECL|macro|ECP_ATADDRMASK
mdefine_line|#define&t;ECP_ATADDRMASK&t;0x3f000
DECL|macro|ECP_ATADDRSHFT
mdefine_line|#define&t;ECP_ATADDRSHFT&t;12
multiline_comment|/*&n; *&t;Important defines for the EISA class of ECP board.&n; */
DECL|macro|ECP_EIIREG
mdefine_line|#define&t;ECP_EIIREG&t;0
DECL|macro|ECP_EIMEMARL
mdefine_line|#define&t;ECP_EIMEMARL&t;1
DECL|macro|ECP_EICONFR
mdefine_line|#define&t;ECP_EICONFR&t;2
DECL|macro|ECP_EIMEMARH
mdefine_line|#define&t;ECP_EIMEMARH&t;3
DECL|macro|ECP_EIENABLE
mdefine_line|#define&t;ECP_EIENABLE&t;0x1
DECL|macro|ECP_EIDISABLE
mdefine_line|#define&t;ECP_EIDISABLE&t;0x0
DECL|macro|ECP_EISTOP
mdefine_line|#define&t;ECP_EISTOP&t;0x4
DECL|macro|ECP_EIEDGE
mdefine_line|#define&t;ECP_EIEDGE&t;0x00
DECL|macro|ECP_EILEVEL
mdefine_line|#define&t;ECP_EILEVEL&t;0x80
DECL|macro|ECP_EIADDRMASKL
mdefine_line|#define&t;ECP_EIADDRMASKL&t;0x00ff0000
DECL|macro|ECP_EIADDRSHFTL
mdefine_line|#define&t;ECP_EIADDRSHFTL&t;16
DECL|macro|ECP_EIADDRMASKH
mdefine_line|#define&t;ECP_EIADDRMASKH&t;0xff000000
DECL|macro|ECP_EIADDRSHFTH
mdefine_line|#define&t;ECP_EIADDRSHFTH&t;24
DECL|macro|ECP_EIBRDENAB
mdefine_line|#define&t;ECP_EIBRDENAB&t;0xc84
DECL|macro|ECP_EISAID
mdefine_line|#define&t;ECP_EISAID&t;0x4
multiline_comment|/*&n; *&t;Important defines for the Micro-channel class of ECP board.&n; *&t;(It has a lot in common with the ISA boards.)&n; */
DECL|macro|ECP_MCIREG
mdefine_line|#define&t;ECP_MCIREG&t;0
DECL|macro|ECP_MCCONFR
mdefine_line|#define&t;ECP_MCCONFR&t;1
DECL|macro|ECP_MCSTOP
mdefine_line|#define&t;ECP_MCSTOP&t;0x20
DECL|macro|ECP_MCENABLE
mdefine_line|#define&t;ECP_MCENABLE&t;0x80
DECL|macro|ECP_MCDISABLE
mdefine_line|#define&t;ECP_MCDISABLE&t;0x00
multiline_comment|/*&n; *&t;Important defines for the PCI class of ECP board.&n; *&t;(It has a lot in common with the other ECP boards.)&n; */
DECL|macro|ECP_PCIIREG
mdefine_line|#define&t;ECP_PCIIREG&t;0
DECL|macro|ECP_PCICONFR
mdefine_line|#define&t;ECP_PCICONFR&t;1
DECL|macro|ECP_PCISTOP
mdefine_line|#define&t;ECP_PCISTOP&t;0x01
multiline_comment|/*&n; *&t;Hardware configuration info for ONboard and Brumby boards. These&n; *&t;defines apply to the directly accessible io ports of these boards.&n; */
DECL|macro|ONB_IOSIZE
mdefine_line|#define&t;ONB_IOSIZE&t;16
DECL|macro|ONB_MEMSIZE
mdefine_line|#define&t;ONB_MEMSIZE&t;(64 * 1024)
DECL|macro|ONB_ATPAGESIZE
mdefine_line|#define&t;ONB_ATPAGESIZE&t;(64 * 1024)
DECL|macro|ONB_MCPAGESIZE
mdefine_line|#define&t;ONB_MCPAGESIZE&t;(64 * 1024)
DECL|macro|ONB_EIMEMSIZE
mdefine_line|#define&t;ONB_EIMEMSIZE&t;(128 * 1024)
DECL|macro|ONB_EIPAGESIZE
mdefine_line|#define&t;ONB_EIPAGESIZE&t;(64 * 1024)
multiline_comment|/*&n; *&t;Important defines for the ISA class of ONboard board.&n; */
DECL|macro|ONB_ATIREG
mdefine_line|#define&t;ONB_ATIREG&t;0
DECL|macro|ONB_ATMEMAR
mdefine_line|#define&t;ONB_ATMEMAR&t;1
DECL|macro|ONB_ATCONFR
mdefine_line|#define&t;ONB_ATCONFR&t;2
DECL|macro|ONB_ATSTOP
mdefine_line|#define&t;ONB_ATSTOP&t;0x4
DECL|macro|ONB_ATENABLE
mdefine_line|#define&t;ONB_ATENABLE&t;0x01
DECL|macro|ONB_ATDISABLE
mdefine_line|#define&t;ONB_ATDISABLE&t;0x00
DECL|macro|ONB_ATADDRMASK
mdefine_line|#define&t;ONB_ATADDRMASK&t;0xff0000
DECL|macro|ONB_ATADDRSHFT
mdefine_line|#define&t;ONB_ATADDRSHFT&t;16
DECL|macro|ONB_MEMENABLO
mdefine_line|#define&t;ONB_MEMENABLO&t;0
DECL|macro|ONB_MEMENABHI
mdefine_line|#define&t;ONB_MEMENABHI&t;0x02
multiline_comment|/*&n; *&t;Important defines for the EISA class of ONboard board.&n; */
DECL|macro|ONB_EIIREG
mdefine_line|#define&t;ONB_EIIREG&t;0
DECL|macro|ONB_EIMEMARL
mdefine_line|#define&t;ONB_EIMEMARL&t;1
DECL|macro|ONB_EICONFR
mdefine_line|#define&t;ONB_EICONFR&t;2
DECL|macro|ONB_EIMEMARH
mdefine_line|#define&t;ONB_EIMEMARH&t;3
DECL|macro|ONB_EIENABLE
mdefine_line|#define&t;ONB_EIENABLE&t;0x1
DECL|macro|ONB_EIDISABLE
mdefine_line|#define&t;ONB_EIDISABLE&t;0x0
DECL|macro|ONB_EISTOP
mdefine_line|#define&t;ONB_EISTOP&t;0x4
DECL|macro|ONB_EIEDGE
mdefine_line|#define&t;ONB_EIEDGE&t;0x00
DECL|macro|ONB_EILEVEL
mdefine_line|#define&t;ONB_EILEVEL&t;0x80
DECL|macro|ONB_EIADDRMASKL
mdefine_line|#define&t;ONB_EIADDRMASKL&t;0x00ff0000
DECL|macro|ONB_EIADDRSHFTL
mdefine_line|#define&t;ONB_EIADDRSHFTL&t;16
DECL|macro|ONB_EIADDRMASKH
mdefine_line|#define&t;ONB_EIADDRMASKH&t;0xff000000
DECL|macro|ONB_EIADDRSHFTH
mdefine_line|#define&t;ONB_EIADDRSHFTH&t;24
DECL|macro|ONB_EIBRDENAB
mdefine_line|#define&t;ONB_EIBRDENAB&t;0xc84
DECL|macro|ONB_EISAID
mdefine_line|#define&t;ONB_EISAID&t;0x1
multiline_comment|/*&n; *&t;Important defines for the Brumby boards. They are pretty simple,&n; *&t;there is not much that is programmably configurable.&n; */
DECL|macro|BBY_IOSIZE
mdefine_line|#define&t;BBY_IOSIZE&t;16
DECL|macro|BBY_MEMSIZE
mdefine_line|#define&t;BBY_MEMSIZE&t;(64 * 1024)
DECL|macro|BBY_PAGESIZE
mdefine_line|#define&t;BBY_PAGESIZE&t;(16 * 1024)
DECL|macro|BBY_ATIREG
mdefine_line|#define&t;BBY_ATIREG&t;0
DECL|macro|BBY_ATCONFR
mdefine_line|#define&t;BBY_ATCONFR&t;1
DECL|macro|BBY_ATSTOP
mdefine_line|#define&t;BBY_ATSTOP&t;0x4
multiline_comment|/*&n; *&t;Important defines for the Stallion boards. They are pretty simple,&n; *&t;there is not much that is programmably configurable.&n; */
DECL|macro|STAL_IOSIZE
mdefine_line|#define&t;STAL_IOSIZE&t;16
DECL|macro|STAL_MEMSIZE
mdefine_line|#define&t;STAL_MEMSIZE&t;(64 * 1024)
DECL|macro|STAL_PAGESIZE
mdefine_line|#define&t;STAL_PAGESIZE&t;(64 * 1024)
multiline_comment|/*&n; *&t;Define the set of status register values for EasyConnection panels.&n; *&t;The signature will return with the status value for each panel. From&n; *&t;this we can determine what is attached to the board - before we have&n; *&t;actually down loaded any code to it.&n; */
DECL|macro|ECH_PNLSTATUS
mdefine_line|#define&t;ECH_PNLSTATUS&t;2
DECL|macro|ECH_PNL16PORT
mdefine_line|#define&t;ECH_PNL16PORT&t;0x20
DECL|macro|ECH_PNLIDMASK
mdefine_line|#define&t;ECH_PNLIDMASK&t;0x07
DECL|macro|ECH_PNLXPID
mdefine_line|#define&t;ECH_PNLXPID&t;0x40
DECL|macro|ECH_PNLINTRPEND
mdefine_line|#define&t;ECH_PNLINTRPEND&t;0x80
multiline_comment|/*&n; *&t;Define some macros to do things to the board. Even those these boards&n; *&t;are somewhat related there is often significantly different ways of&n; *&t;doing some operation on it (like enable, paging, reset, etc). So each&n; *&t;board class has a set of functions which do the commonly required&n; *&t;operations. The macros below basically just call these functions,&n; *&t;generally checking for a NULL function - which means that the board&n; *&t;needs nothing done to it to achieve this operation!&n; */
DECL|macro|EBRDINIT
mdefine_line|#define&t;EBRDINIT(brdp)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (brdp-&gt;init != NULL)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;(* brdp-&gt;init)(brdp)
DECL|macro|EBRDENABLE
mdefine_line|#define&t;EBRDENABLE(brdp)&t;&t;&t;&t;&t;&bslash;&n;&t;if (brdp-&gt;enable != NULL)&t;&t;&t;&t;&bslash;&n;&t;&t;(* brdp-&gt;enable)(brdp);
DECL|macro|EBRDDISABLE
mdefine_line|#define&t;EBRDDISABLE(brdp)&t;&t;&t;&t;&t;&bslash;&n;&t;if (brdp-&gt;disable != NULL)&t;&t;&t;&t;&bslash;&n;&t;&t;(* brdp-&gt;disable)(brdp);
DECL|macro|EBRDINTR
mdefine_line|#define&t;EBRDINTR(brdp)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (brdp-&gt;intr != NULL)&t;&t;&t;&t;&t;&bslash;&n;&t;&t;(* brdp-&gt;intr)(brdp);
DECL|macro|EBRDRESET
mdefine_line|#define&t;EBRDRESET(brdp)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (brdp-&gt;reset != NULL)&t;&t;&t;&t;&bslash;&n;&t;&t;(* brdp-&gt;reset)(brdp);
DECL|macro|EBRDGETMEMPTR
mdefine_line|#define&t;EBRDGETMEMPTR(brdp,offset)&t;&t;&t;&t;&bslash;&n;&t;(* brdp-&gt;getmemptr)(brdp, offset, __LINE__)
multiline_comment|/*&n; *&t;Define the maximal baud rate, and the default baud base for ports.&n; */
DECL|macro|STL_MAXBAUD
mdefine_line|#define&t;STL_MAXBAUD&t;460800
DECL|macro|STL_BAUDBASE
mdefine_line|#define&t;STL_BAUDBASE&t;115200
DECL|macro|STL_CLOSEDELAY
mdefine_line|#define&t;STL_CLOSEDELAY&t;(5 * HZ / 10)
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Define macros to extract a brd or port number from a minor number.&n; */
DECL|macro|MINOR2BRD
mdefine_line|#define&t;MINOR2BRD(min)&t;&t;(((min) &amp; 0xc0) &gt;&gt; 6)
DECL|macro|MINOR2PORT
mdefine_line|#define&t;MINOR2PORT(min)&t;&t;((min) &amp; 0x3f)
multiline_comment|/*&n; *&t;Define a baud rate table that converts termios baud rate selector&n; *&t;into the actual baud rate value. All baud rate calculations are based&n; *&t;on the actual baud rate required.&n; */
DECL|variable|stli_baudrates
r_static
r_int
r_int
id|stli_baudrates
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|50
comma
l_int|75
comma
l_int|110
comma
l_int|134
comma
l_int|150
comma
l_int|200
comma
l_int|300
comma
l_int|600
comma
l_int|1200
comma
l_int|1800
comma
l_int|2400
comma
l_int|4800
comma
l_int|9600
comma
l_int|19200
comma
l_int|38400
comma
l_int|57600
comma
l_int|115200
comma
l_int|230400
comma
l_int|460800
comma
l_int|921600
)brace
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Define some handy local macros...&n; */
DECL|macro|MIN
macro_line|#undef MIN
DECL|macro|MIN
mdefine_line|#define&t;MIN(a,b)&t;(((a) &lt;= (b)) ? (a) : (b))
DECL|macro|TOLOWER
macro_line|#undef&t;TOLOWER
DECL|macro|TOLOWER
mdefine_line|#define&t;TOLOWER(x)&t;((((x) &gt;= &squot;A&squot;) &amp;&amp; ((x) &lt;= &squot;Z&squot;)) ? ((x) + 0x20) : (x))
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Prototype all functions in this driver!&n; */
macro_line|#ifdef MODULE
r_int
id|init_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|stli_argbrds
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|stli_parsebrd
c_func
(paren
id|stlconf_t
op_star
id|confp
comma
r_char
op_star
op_star
id|argp
)paren
suffix:semicolon
r_static
r_int
r_int
id|stli_atol
c_func
(paren
r_char
op_star
id|str
)paren
suffix:semicolon
macro_line|#endif
r_int
id|stli_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|stli_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|stli_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_int
id|stli_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_void
id|stli_putchar
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
suffix:semicolon
r_static
r_void
id|stli_flushchars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|stli_writeroom
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|stli_charsinbuffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|stli_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|stli_settermios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old
)paren
suffix:semicolon
r_static
r_void
id|stli_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|stli_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|stli_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|stli_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|stli_flushbuffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|stli_breakctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|state
)paren
suffix:semicolon
r_static
r_void
id|stli_waituntilsent
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|timeout
)paren
suffix:semicolon
r_static
r_void
id|stli_sendxchar
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_char
id|ch
)paren
suffix:semicolon
r_static
r_void
id|stli_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|stli_portinfo
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
comma
r_int
id|portnr
comma
r_char
op_star
id|pos
)paren
suffix:semicolon
r_static
r_int
id|stli_brdinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_int
id|stli_startbrd
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
id|ssize_t
id|stli_memread
c_func
(paren
r_struct
id|file
op_star
id|fp
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|offp
)paren
suffix:semicolon
r_static
id|ssize_t
id|stli_memwrite
c_func
(paren
r_struct
id|file
op_star
id|fp
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|offp
)paren
suffix:semicolon
r_static
r_int
id|stli_memioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|stli_brdpoll
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_volatile
id|cdkhdr_t
op_star
id|hdrp
)paren
suffix:semicolon
r_static
r_void
id|stli_poll
c_func
(paren
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|stli_hostcmd
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
)paren
suffix:semicolon
r_static
r_int
id|stli_initopen
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
)paren
suffix:semicolon
r_static
r_int
id|stli_rawopen
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
comma
r_int
r_int
id|arg
comma
r_int
id|wait
)paren
suffix:semicolon
r_static
r_int
id|stli_rawclose
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
comma
r_int
r_int
id|arg
comma
r_int
id|wait
)paren
suffix:semicolon
r_static
r_int
id|stli_waitcarrier
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|stli_dohangup
c_func
(paren
r_void
op_star
id|arg
)paren
suffix:semicolon
r_static
r_void
id|stli_delay
c_func
(paren
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|stli_setport
c_func
(paren
id|stliport_t
op_star
id|portp
)paren
suffix:semicolon
r_static
r_int
id|stli_cmdwait
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
comma
r_int
id|size
comma
r_int
id|copyback
)paren
suffix:semicolon
r_static
r_void
id|stli_sendcmd
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
comma
r_int
id|size
comma
r_int
id|copyback
)paren
suffix:semicolon
r_static
r_void
id|stli_dodelaycmd
c_func
(paren
id|stliport_t
op_star
id|portp
comma
r_volatile
id|cdkctrl_t
op_star
id|cp
)paren
suffix:semicolon
r_static
r_void
id|stli_mkasyport
c_func
(paren
id|stliport_t
op_star
id|portp
comma
id|asyport_t
op_star
id|pp
comma
r_struct
id|termios
op_star
id|tiosp
)paren
suffix:semicolon
r_static
r_void
id|stli_mkasysigs
c_func
(paren
id|asysigs_t
op_star
id|sp
comma
r_int
id|dtr
comma
r_int
id|rts
)paren
suffix:semicolon
r_static
r_int
id|stli_mktiocm
c_func
(paren
r_int
r_int
id|sigvalue
)paren
suffix:semicolon
r_static
r_void
id|stli_read
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
)paren
suffix:semicolon
r_static
r_void
id|stli_getserial
c_func
(paren
id|stliport_t
op_star
id|portp
comma
r_struct
id|serial_struct
op_star
id|sp
)paren
suffix:semicolon
r_static
r_int
id|stli_setserial
c_func
(paren
id|stliport_t
op_star
id|portp
comma
r_struct
id|serial_struct
op_star
id|sp
)paren
suffix:semicolon
r_static
r_int
id|stli_getbrdstats
c_func
(paren
id|combrd_t
op_star
id|bp
)paren
suffix:semicolon
r_static
r_int
id|stli_getportstats
c_func
(paren
id|stliport_t
op_star
id|portp
comma
id|comstats_t
op_star
id|cp
)paren
suffix:semicolon
r_static
r_int
id|stli_portcmdstats
c_func
(paren
id|stliport_t
op_star
id|portp
)paren
suffix:semicolon
r_static
r_int
id|stli_clrportstats
c_func
(paren
id|stliport_t
op_star
id|portp
comma
id|comstats_t
op_star
id|cp
)paren
suffix:semicolon
r_static
r_int
id|stli_getportstruct
c_func
(paren
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|stli_getbrdstruct
c_func
(paren
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
op_star
id|stli_memalloc
c_func
(paren
r_int
id|len
)paren
suffix:semicolon
r_static
id|stlibrd_t
op_star
id|stli_allocbrd
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|stli_ecpinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_ecpenable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_ecpdisable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_char
op_star
id|stli_ecpgetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
suffix:semicolon
r_static
r_void
id|stli_ecpreset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_ecpintr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_ecpeiinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_ecpeienable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_ecpeidisable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_char
op_star
id|stli_ecpeigetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
suffix:semicolon
r_static
r_void
id|stli_ecpeireset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_ecpmcenable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_ecpmcdisable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_char
op_star
id|stli_ecpmcgetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
suffix:semicolon
r_static
r_void
id|stli_ecpmcreset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_ecppciinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_char
op_star
id|stli_ecppcigetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
suffix:semicolon
r_static
r_void
id|stli_ecppcireset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_onbinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_onbenable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_onbdisable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_char
op_star
id|stli_onbgetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
suffix:semicolon
r_static
r_void
id|stli_onbreset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_onbeinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_onbeenable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_onbedisable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_char
op_star
id|stli_onbegetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
suffix:semicolon
r_static
r_void
id|stli_onbereset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_bbyinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_char
op_star
id|stli_bbygetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
suffix:semicolon
r_static
r_void
id|stli_bbyreset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_void
id|stli_stalinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_char
op_star
id|stli_stalgetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
suffix:semicolon
r_static
r_void
id|stli_stalreset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
id|stliport_t
op_star
id|stli_getport
c_func
(paren
r_int
id|brdnr
comma
r_int
id|panelnr
comma
r_int
id|portnr
)paren
suffix:semicolon
r_static
r_inline
r_int
id|stli_initbrds
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_inline
r_int
id|stli_initecp
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_inline
r_int
id|stli_initonb
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_inline
r_int
id|stli_findeisabrds
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_inline
r_int
id|stli_eisamemprobe
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_inline
r_int
id|stli_initports
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
suffix:semicolon
r_static
r_inline
r_int
id|stli_getbrdnr
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef&t;CONFIG_PCI
r_static
r_inline
r_int
id|stli_findpcibrds
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_inline
r_int
id|stli_initpcibrd
c_func
(paren
r_int
id|brdtype
comma
r_struct
id|pci_dev
op_star
id|devp
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Define the driver info for a user level shared memory device. This&n; *&t;device will work sort of like the /dev/kmem device - except that it&n; *&t;will give access to the shared memory on the Stallion intelligent&n; *&t;board. This is also a very useful debugging tool.&n; */
DECL|variable|stli_fsiomem
r_static
r_struct
id|file_operations
id|stli_fsiomem
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|read
suffix:colon
id|stli_memread
comma
id|write
suffix:colon
id|stli_memwrite
comma
id|ioctl
suffix:colon
id|stli_memioctl
comma
)brace
suffix:semicolon
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Define a timer_list entry for our poll routine. The slave board&n; *&t;is polled every so often to see if anything needs doing. This is&n; *&t;much cheaper on host cpu than using interrupts. It turns out to&n; *&t;not increase character latency by much either...&n; */
DECL|variable|stli_timerlist
r_static
r_struct
id|timer_list
id|stli_timerlist
op_assign
(brace
id|function
suffix:colon
id|stli_poll
)brace
suffix:semicolon
DECL|variable|stli_timeron
r_static
r_int
id|stli_timeron
suffix:semicolon
multiline_comment|/*&n; *&t;Define the calculation for the timeout routine.&n; */
DECL|macro|STLI_TIMEOUT
mdefine_line|#define&t;STLI_TIMEOUT&t;(jiffies + 1)
multiline_comment|/*****************************************************************************/
macro_line|#ifdef MODULE
multiline_comment|/*&n; *&t;Loadable module initialization stuff.&n; */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;init_module()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|stli_init
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
id|stliport_t
op_star
id|portp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;cleanup_module()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Unloading %s: version %s&bslash;n&quot;
comma
id|stli_drvtitle
comma
id|stli_drvversion
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Free up all allocated resources used by the ports. This includes&n; *&t;memory and interrupts.&n; */
r_if
c_cond
(paren
id|stli_timeron
)paren
(brace
id|stli_timeron
op_assign
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|stli_timerlist
)paren
suffix:semicolon
)brace
id|i
op_assign
id|tty_unregister_driver
c_func
(paren
op_amp
id|stli_serial
)paren
suffix:semicolon
id|j
op_assign
id|tty_unregister_driver
c_func
(paren
op_amp
id|stli_callout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_logical_or
id|j
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: failed to un-register tty driver, &quot;
l_string|&quot;errno=%d,%d&bslash;n&quot;
comma
op_minus
id|i
comma
op_minus
id|j
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|devfs_unregister
(paren
id|devfs_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|devfs_unregister_chrdev
c_func
(paren
id|STL_SIOMEMMAJOR
comma
l_string|&quot;staliomem&quot;
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;STALLION: failed to un-register serial memory device, &quot;
l_string|&quot;errno=%d&bslash;n&quot;
comma
op_minus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stli_tmpwritebuf
op_ne
(paren
r_char
op_star
)paren
l_int|NULL
)paren
id|kfree
c_func
(paren
id|stli_tmpwritebuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stli_txcookbuf
op_ne
(paren
r_char
op_star
)paren
l_int|NULL
)paren
id|kfree
c_func
(paren
id|stli_txcookbuf
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|stli_nrbrds
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|brdp
op_assign
id|stli_brds
(braket
id|i
)braket
)paren
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
(paren
id|j
OL
id|STL_MAXPORTS
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
id|portp
op_assign
id|brdp-&gt;ports
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_ne
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|portp-&gt;tty
op_ne
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
id|tty_hangup
c_func
(paren
id|portp-&gt;tty
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|portp
)paren
suffix:semicolon
)brace
)brace
id|iounmap
c_func
(paren
id|brdp-&gt;membase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;iosize
OG
l_int|0
)paren
id|release_region
c_func
(paren
id|brdp-&gt;iobase
comma
id|brdp-&gt;iosize
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|stli_brds
(braket
id|i
)braket
op_assign
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Check for any arguments passed in on the module load command line.&n; */
DECL|function|stli_argbrds
r_static
r_void
id|stli_argbrds
c_func
(paren
)paren
(brace
id|stlconf_t
id|conf
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
id|nrargs
comma
id|i
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_argbrds()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|nrargs
op_assign
r_sizeof
(paren
id|stli_brdsp
)paren
op_div
r_sizeof
(paren
r_char
op_star
op_star
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|stli_nrbrds
suffix:semicolon
(paren
id|i
OL
id|nrargs
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|memset
c_func
(paren
op_amp
id|conf
comma
l_int|0
comma
r_sizeof
(paren
id|conf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stli_parsebrd
c_func
(paren
op_amp
id|conf
comma
id|stli_brdsp
(braket
id|i
)braket
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|brdp
op_assign
id|stli_allocbrd
c_func
(paren
)paren
)paren
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_continue
suffix:semicolon
id|stli_nrbrds
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|brdp-&gt;brdnr
op_assign
id|i
suffix:semicolon
id|brdp-&gt;brdtype
op_assign
id|conf.brdtype
suffix:semicolon
id|brdp-&gt;iobase
op_assign
id|conf.ioaddr1
suffix:semicolon
id|brdp-&gt;memaddr
op_assign
id|conf.memaddr
suffix:semicolon
id|stli_brdinit
c_func
(paren
id|brdp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Convert an ascii string number into an unsigned long.&n; */
DECL|function|stli_atol
r_static
r_int
r_int
id|stli_atol
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_int
id|base
comma
id|c
suffix:semicolon
r_char
op_star
id|sp
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
id|sp
op_assign
id|str
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|sp
op_eq
l_char|&squot;0&squot;
)paren
op_logical_and
(paren
op_star
(paren
id|sp
op_plus
l_int|1
)paren
op_eq
l_char|&squot;x&squot;
)paren
)paren
(brace
id|base
op_assign
l_int|16
suffix:semicolon
id|sp
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|sp
op_eq
l_char|&squot;0&squot;
)paren
(brace
id|base
op_assign
l_int|8
suffix:semicolon
id|sp
op_increment
suffix:semicolon
)brace
r_else
(brace
id|base
op_assign
l_int|10
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
(paren
op_star
id|sp
op_ne
l_int|0
)paren
suffix:semicolon
id|sp
op_increment
)paren
(brace
id|c
op_assign
(paren
op_star
id|sp
OG
l_char|&squot;9&squot;
)paren
ques
c_cond
(paren
id|TOLOWER
c_func
(paren
op_star
id|sp
)paren
op_minus
l_char|&squot;a&squot;
op_plus
l_int|10
)paren
suffix:colon
(paren
op_star
id|sp
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
OL
l_int|0
)paren
op_logical_or
(paren
id|c
op_ge
id|base
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: invalid argument %s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|val
op_assign
(paren
id|val
op_star
id|base
)paren
op_plus
id|c
suffix:semicolon
)brace
r_return
id|val
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Parse the supplied argument string, into the board conf struct.&n; */
DECL|function|stli_parsebrd
r_static
r_int
id|stli_parsebrd
c_func
(paren
id|stlconf_t
op_star
id|confp
comma
r_char
op_star
op_star
id|argp
)paren
(brace
r_char
op_star
id|sp
suffix:semicolon
r_int
id|nrbrdnames
comma
id|i
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_parsebrd(confp=%x,argp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|confp
comma
(paren
r_int
)paren
id|argp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|argp
(braket
l_int|0
)braket
op_eq
(paren
r_char
op_star
)paren
l_int|NULL
)paren
op_logical_or
(paren
op_star
id|argp
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|sp
op_assign
id|argp
(braket
l_int|0
)braket
comma
id|i
op_assign
l_int|0
suffix:semicolon
(paren
(paren
op_star
id|sp
op_ne
l_int|0
)paren
op_logical_and
(paren
id|i
OL
l_int|25
)paren
)paren
suffix:semicolon
id|sp
op_increment
comma
id|i
op_increment
)paren
op_star
id|sp
op_assign
id|TOLOWER
c_func
(paren
op_star
id|sp
)paren
suffix:semicolon
id|nrbrdnames
op_assign
r_sizeof
(paren
id|stli_brdstr
)paren
op_div
r_sizeof
(paren
id|stlibrdtype_t
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|nrbrdnames
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|stli_brdstr
(braket
id|i
)braket
dot
id|name
comma
id|argp
(braket
l_int|0
)braket
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_ge
id|nrbrdnames
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: unknown board name, %s?&bslash;n&quot;
comma
id|argp
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|confp-&gt;brdtype
op_assign
id|stli_brdstr
(braket
id|i
)braket
dot
id|type
suffix:semicolon
r_if
c_cond
(paren
(paren
id|argp
(braket
l_int|1
)braket
op_ne
(paren
r_char
op_star
)paren
l_int|NULL
)paren
op_logical_and
(paren
op_star
id|argp
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
)paren
id|confp-&gt;ioaddr1
op_assign
id|stli_atol
c_func
(paren
id|argp
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|argp
(braket
l_int|2
)braket
op_ne
(paren
r_char
op_star
)paren
l_int|NULL
)paren
op_logical_and
(paren
op_star
id|argp
(braket
l_int|2
)braket
op_ne
l_int|0
)paren
)paren
id|confp-&gt;memaddr
op_assign
id|stli_atol
c_func
(paren
id|argp
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Local driver kernel malloc routine.&n; */
DECL|function|stli_memalloc
r_static
r_void
op_star
id|stli_memalloc
c_func
(paren
r_int
id|len
)paren
(brace
r_return
(paren
r_void
op_star
)paren
id|kmalloc
c_func
(paren
id|len
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_open
r_static
r_int
id|stli_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
id|stliport_t
op_star
id|portp
suffix:semicolon
r_int
r_int
id|minordev
suffix:semicolon
r_int
id|brdnr
comma
id|portnr
comma
id|rc
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_open(tty=%x,filp=%x): device=%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
comma
(paren
r_int
)paren
id|filp
comma
id|tty-&gt;device
)paren
suffix:semicolon
macro_line|#endif
id|minordev
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
suffix:semicolon
id|brdnr
op_assign
id|MINOR2BRD
c_func
(paren
id|minordev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brdnr
op_ge
id|stli_nrbrds
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|brdp-&gt;state
op_amp
id|BST_STARTED
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|portnr
op_assign
id|MINOR2PORT
c_func
(paren
id|minordev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portnr
OL
l_int|0
)paren
op_logical_or
(paren
id|portnr
OG
id|brdp-&gt;nrports
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|portp
op_assign
id|brdp-&gt;ports
(braket
id|portnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;devnr
OL
l_int|1
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/*&n; *&t;Check if this port is in the middle of closing. If so then wait&n; *&t;until it is closed then return error status based on flag settings.&n; *&t;The sleep here does not need interrupt protection since the wakeup&n; *&t;for it is done with the same context.&n; */
r_if
c_cond
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|portp-&gt;close_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;On the first open of the device setup the port hardware, and&n; *&t;initialize the per port data structure. Since initializing the port&n; *&t;requires several commands to the board we will need to wait for any&n; *&t;other open that is already initializing the port.&n; */
id|portp-&gt;tty
op_assign
id|tty
suffix:semicolon
id|tty-&gt;driver_data
op_assign
id|portp
suffix:semicolon
id|portp-&gt;refcount
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|ST_INITIALIZING
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|portp-&gt;raw_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
op_eq
l_int|0
)paren
(brace
id|set_bit
c_func
(paren
id|ST_INITIALIZING
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|stli_initopen
c_func
(paren
id|brdp
comma
id|portp
)paren
)paren
op_ge
l_int|0
)paren
(brace
id|portp-&gt;flags
op_or_assign
id|ASYNC_INITIALIZED
suffix:semicolon
id|clear_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|ST_INITIALIZING
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|portp-&gt;raw_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Check if this port is in the middle of closing. If so then wait&n; *&t;until it is closed then return error status, based on flag settings.&n; *&t;The sleep here does not need interrupt protection since the wakeup&n; *&t;for it is done with the same context.&n; */
r_if
c_cond
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|portp-&gt;close_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Based on type of open being done check if it can overlap with any&n; *&t;previous opens still in effect. If we are a normal serial device&n; *&t;then also we might have to wait for carrier.&n; */
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|STL_DRVTYPCALLOUT
)paren
(brace
r_if
c_cond
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
(brace
r_if
c_cond
(paren
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_SESSION_LOCKOUT
)paren
op_logical_and
(paren
id|portp-&gt;session
op_ne
id|current-&gt;session
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_PGRP_LOCKOUT
)paren
op_logical_and
(paren
id|portp-&gt;pgrp
op_ne
id|current-&gt;pgrp
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|portp-&gt;flags
op_or_assign
id|ASYNC_CALLOUT_ACTIVE
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|stli_waitcarrier
c_func
(paren
id|brdp
comma
id|portp
comma
id|filp
)paren
)paren
op_ne
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
id|portp-&gt;flags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|portp-&gt;refcount
op_eq
l_int|1
)paren
op_logical_and
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_SPLIT_TERMIOS
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|STL_DRVTYPSERIAL
)paren
op_star
id|tty-&gt;termios
op_assign
id|portp-&gt;normaltermios
suffix:semicolon
r_else
op_star
id|tty-&gt;termios
op_assign
id|portp-&gt;callouttermios
suffix:semicolon
id|stli_setport
c_func
(paren
id|portp
)paren
suffix:semicolon
)brace
id|portp-&gt;session
op_assign
id|current-&gt;session
suffix:semicolon
id|portp-&gt;pgrp
op_assign
id|current-&gt;pgrp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_close
r_static
r_void
id|stli_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
id|stliport_t
op_star
id|portp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_close(tty=%x,filp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
comma
(paren
r_int
)paren
id|filp
)paren
suffix:semicolon
macro_line|#endif
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tty-&gt;count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|portp-&gt;refcount
op_ne
l_int|1
)paren
)paren
id|portp-&gt;refcount
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;refcount
op_decrement
OG
l_int|1
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|portp-&gt;flags
op_or_assign
id|ASYNC_CLOSING
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
id|portp-&gt;normaltermios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
id|portp-&gt;callouttermios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
multiline_comment|/*&n; *&t;May want to wait for data to drain before closing. The BUSY flag&n; *&t;keeps track of whether we are still transmitting or not. It is&n; *&t;updated by messages from the slave - indicating when all chars&n; *&t;really have drained.&n; */
r_if
c_cond
(paren
id|tty
op_eq
id|stli_txcooktty
)paren
id|stli_flushchars
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;closing_wait
op_ne
id|ASYNC_CLOSING_WAIT_NONE
)paren
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
id|portp-&gt;closing_wait
)paren
suffix:semicolon
id|portp-&gt;flags
op_and_assign
op_complement
id|ASYNC_INITIALIZED
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
id|stli_rawclose
c_func
(paren
id|brdp
comma
id|portp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
(brace
id|stli_mkasysigs
c_func
(paren
op_amp
id|portp-&gt;asig
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_CMDING
comma
op_amp
id|portp-&gt;state
)paren
)paren
id|set_bit
c_func
(paren
id|ST_DOSIGS
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
r_else
id|stli_sendcmd
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_SETSIGNALS
comma
op_amp
id|portp-&gt;asig
comma
r_sizeof
(paren
id|asysigs_t
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|ST_TXBUSY
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|ST_RXSTOP
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
(paren
id|tty
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|ST_DOFLUSHRX
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|stli_flushbuffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|0
suffix:semicolon
id|portp-&gt;tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;openwaitcnt
)paren
(brace
r_if
c_cond
(paren
id|portp-&gt;close_delay
)paren
id|stli_delay
c_func
(paren
id|portp-&gt;close_delay
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|portp-&gt;open_wait
)paren
suffix:semicolon
)brace
id|portp-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_CALLOUT_ACTIVE
op_or
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CLOSING
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|portp-&gt;close_wait
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Carry out first open operations on a port. This involves a number of&n; *&t;commands to be sent to the slave. We need to open the port, set the&n; *&t;notification events, set the initial port settings, get and set the&n; *&t;initial signal values. We sleep and wait in between each one. But&n; *&t;this still all happens pretty quickly.&n; */
DECL|function|stli_initopen
r_static
r_int
id|stli_initopen
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|asynotify_t
id|nt
suffix:semicolon
id|asyport_t
id|aport
suffix:semicolon
r_int
id|rc
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_initopen(brdp=%x,portp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
(paren
r_int
)paren
id|portp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|stli_rawopen
c_func
(paren
id|brdp
comma
id|portp
comma
l_int|0
comma
l_int|1
)paren
)paren
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|nt
comma
l_int|0
comma
r_sizeof
(paren
id|asynotify_t
)paren
)paren
suffix:semicolon
id|nt.data
op_assign
(paren
id|DT_TXLOW
op_or
id|DT_TXEMPTY
op_or
id|DT_RXBUSY
op_or
id|DT_RXBREAK
)paren
suffix:semicolon
id|nt.signal
op_assign
id|SG_DCD
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_SETNOTIFY
comma
op_amp
id|nt
comma
r_sizeof
(paren
id|asynotify_t
)paren
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
id|tty
op_assign
id|portp-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|stli_mkasyport
c_func
(paren
id|portp
comma
op_amp
id|aport
comma
id|tty-&gt;termios
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_SETPORT
comma
op_amp
id|aport
comma
r_sizeof
(paren
id|asyport_t
)paren
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
id|set_bit
c_func
(paren
id|ST_GETSIGS
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_GETSIGNALS
comma
op_amp
id|portp-&gt;asig
comma
r_sizeof
(paren
id|asysigs_t
)paren
comma
l_int|1
)paren
)paren
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|ST_GETSIGS
comma
op_amp
id|portp-&gt;state
)paren
)paren
id|portp-&gt;sigs
op_assign
id|stli_mktiocm
c_func
(paren
id|portp-&gt;asig.sigvalue
)paren
suffix:semicolon
id|stli_mkasysigs
c_func
(paren
op_amp
id|portp-&gt;asig
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_SETSIGNALS
comma
op_amp
id|portp-&gt;asig
comma
r_sizeof
(paren
id|asysigs_t
)paren
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Send an open message to the slave. This will sleep waiting for the&n; *&t;acknowledgement, so must have user context. We need to co-ordinate&n; *&t;with close events here, since we don&squot;t want open and close events&n; *&t;to overlap.&n; */
DECL|function|stli_rawopen
r_static
r_int
id|stli_rawopen
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
comma
r_int
r_int
id|arg
comma
r_int
id|wait
)paren
(brace
r_volatile
id|cdkhdr_t
op_star
id|hdrp
suffix:semicolon
r_volatile
id|cdkctrl_t
op_star
id|cp
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|bits
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_rawopen(brdp=%x,portp=%x,arg=%x,wait=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
(paren
r_int
)paren
id|portp
comma
(paren
r_int
)paren
id|arg
comma
id|wait
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;Send a message to the slave to open this port.&n; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Slave is already closing this port. This can happen if a hangup&n; *&t;occurs on this port. So we must wait until it is complete. The&n; *&t;order of opens and closes may not be preserved across shared&n; *&t;memory, so we must wait until it is complete.&n; */
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|ST_CLOSING
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|portp-&gt;raw_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Everything is ready now, so write the open message into shared&n; *&t;memory. Once the message is in set the service bits to say that&n; *&t;this port wants service.&n; */
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|cp
op_assign
op_amp
(paren
(paren
r_volatile
id|cdkasy_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;addr
)paren
)paren
op_member_access_from_pointer
id|ctrl
suffix:semicolon
id|cp-&gt;openarg
op_assign
id|arg
suffix:semicolon
id|cp-&gt;open
op_assign
l_int|1
suffix:semicolon
id|hdrp
op_assign
(paren
r_volatile
id|cdkhdr_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|CDK_CDKADDR
)paren
suffix:semicolon
id|bits
op_assign
(paren
(paren
r_volatile
r_int
r_char
op_star
)paren
id|hdrp
)paren
op_plus
id|brdp-&gt;slaveoffset
op_plus
id|portp-&gt;portidx
suffix:semicolon
op_star
id|bits
op_or_assign
id|portp-&gt;portbit
suffix:semicolon
id|EBRDDISABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
op_eq
l_int|0
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Slave is in action, so now we must wait for the open acknowledgment&n; *&t;to come back.&n; */
id|rc
op_assign
l_int|0
suffix:semicolon
id|set_bit
c_func
(paren
id|ST_OPENING
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|ST_OPENING
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|portp-&gt;raw_wait
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_eq
l_int|0
)paren
op_logical_and
(paren
id|portp-&gt;rc
op_ne
l_int|0
)paren
)paren
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Send a close message to the slave. Normally this will sleep waiting&n; *&t;for the acknowledgement, but if wait parameter is 0 it will not. If&n; *&t;wait is true then must have user context (to sleep).&n; */
DECL|function|stli_rawclose
r_static
r_int
id|stli_rawclose
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
comma
r_int
r_int
id|arg
comma
r_int
id|wait
)paren
(brace
r_volatile
id|cdkhdr_t
op_star
id|hdrp
suffix:semicolon
r_volatile
id|cdkctrl_t
op_star
id|cp
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|bits
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_rawclose(brdp=%x,portp=%x,arg=%x,wait=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
(paren
r_int
)paren
id|portp
comma
(paren
r_int
)paren
id|arg
comma
id|wait
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Slave is already closing this port. This can happen if a hangup&n; *&t;occurs on this port.&n; */
r_if
c_cond
(paren
id|wait
)paren
(brace
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|ST_CLOSING
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|portp-&gt;raw_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Write the close command into shared memory.&n; */
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|cp
op_assign
op_amp
(paren
(paren
r_volatile
id|cdkasy_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;addr
)paren
)paren
op_member_access_from_pointer
id|ctrl
suffix:semicolon
id|cp-&gt;closearg
op_assign
id|arg
suffix:semicolon
id|cp-&gt;close
op_assign
l_int|1
suffix:semicolon
id|hdrp
op_assign
(paren
r_volatile
id|cdkhdr_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|CDK_CDKADDR
)paren
suffix:semicolon
id|bits
op_assign
(paren
(paren
r_volatile
r_int
r_char
op_star
)paren
id|hdrp
)paren
op_plus
id|brdp-&gt;slaveoffset
op_plus
id|portp-&gt;portidx
suffix:semicolon
op_star
id|bits
op_or_assign
id|portp-&gt;portbit
suffix:semicolon
id|EBRDDISABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|ST_CLOSING
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait
op_eq
l_int|0
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Slave is in action, so now we must wait for the open acknowledgment&n; *&t;to come back.&n; */
id|rc
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|ST_CLOSING
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|portp-&gt;raw_wait
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_eq
l_int|0
)paren
op_logical_and
(paren
id|portp-&gt;rc
op_ne
l_int|0
)paren
)paren
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Send a command to the slave and wait for the response. This must&n; *&t;have user context (it sleeps). This routine is generic in that it&n; *&t;can send any type of command. Its purpose is to wait for that command&n; *&t;to complete (as opposed to initiating the command then returning).&n; */
DECL|function|stli_cmdwait
r_static
r_int
id|stli_cmdwait
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
comma
r_int
id|size
comma
r_int
id|copyback
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_cmdwait(brdp=%x,portp=%x,cmd=%x,arg=%x,size=%d,&quot;
l_string|&quot;copyback=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
(paren
r_int
)paren
id|portp
comma
(paren
r_int
)paren
id|cmd
comma
(paren
r_int
)paren
id|arg
comma
id|size
comma
id|copyback
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|ST_CMDING
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|portp-&gt;raw_wait
)paren
suffix:semicolon
)brace
id|stli_sendcmd
c_func
(paren
id|brdp
comma
id|portp
comma
id|cmd
comma
id|arg
comma
id|size
comma
id|copyback
)paren
suffix:semicolon
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|ST_CMDING
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|portp-&gt;raw_wait
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;rc
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Send the termios settings for this port to the slave. This sleeps&n; *&t;waiting for the command to complete - so must have user context.&n; */
DECL|function|stli_setport
r_static
r_int
id|stli_setport
c_func
(paren
id|stliport_t
op_star
id|portp
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
id|asyport_t
id|aport
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_setport(portp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|portp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;brdnr
OL
l_int|0
)paren
op_logical_and
(paren
id|portp-&gt;brdnr
op_ge
id|stli_nrbrds
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|stli_mkasyport
c_func
(paren
id|portp
comma
op_amp
id|aport
comma
id|portp-&gt;tty-&gt;termios
)paren
suffix:semicolon
r_return
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_SETPORT
comma
op_amp
id|aport
comma
r_sizeof
(paren
id|asyport_t
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Wait for a specified delay period, this is not a busy-loop. It will&n; *&t;give up the processor while waiting. Unfortunately this has some&n; *&t;rather intimate knowledge of the process management stuff.&n; */
DECL|function|stli_delay
r_static
r_void
id|stli_delay
c_func
(paren
r_int
id|len
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_delay(len=%d)&bslash;n&quot;
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|len
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
)brace
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Possibly need to wait for carrier (DCD signal) to come high. Say&n; *&t;maybe because if we are clocal then we don&squot;t need to wait...&n; */
DECL|function|stli_waitcarrier
r_static
r_int
id|stli_waitcarrier
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
comma
id|doclocal
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_waitcarrier(brdp=%x,portp=%x,filp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
(paren
r_int
)paren
id|portp
comma
(paren
r_int
)paren
id|filp
)paren
suffix:semicolon
macro_line|#endif
id|rc
op_assign
l_int|0
suffix:semicolon
id|doclocal
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
(brace
r_if
c_cond
(paren
id|portp-&gt;normaltermios.c_cflag
op_amp
id|CLOCAL
)paren
id|doclocal
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|portp-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
id|doclocal
op_increment
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|portp-&gt;openwaitcnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
id|portp-&gt;refcount
op_decrement
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_eq
l_int|0
)paren
(brace
id|stli_mkasysigs
c_func
(paren
op_amp
id|portp-&gt;asig
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_SETSIGNALS
comma
op_amp
id|portp-&gt;asig
comma
r_sizeof
(paren
id|asysigs_t
)paren
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
(paren
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_else
id|rc
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|doclocal
op_logical_or
(paren
id|portp-&gt;sigs
op_amp
id|TIOCM_CD
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|portp-&gt;open_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
id|portp-&gt;refcount
op_increment
suffix:semicolon
id|portp-&gt;openwaitcnt
op_decrement
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Write routine. Take the data and put it in the shared memory ring&n; *&t;queue. If port is not already sending chars then need to mark the&n; *&t;service bits for this port.&n; */
DECL|function|stli_write
r_static
r_int
id|stli_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_volatile
id|cdkasy_t
op_star
id|ap
suffix:semicolon
r_volatile
id|cdkhdr_t
op_star
id|hdrp
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|bits
suffix:semicolon
r_int
r_char
op_star
id|shbuf
comma
op_star
id|chbuf
suffix:semicolon
id|stliport_t
op_star
id|portp
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
r_int
id|len
comma
id|stlen
comma
id|head
comma
id|tail
comma
id|size
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_write(tty=%x,from_user=%d,buf=%x,count=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
comma
id|from_user
comma
(paren
r_int
)paren
id|buf
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
op_logical_or
(paren
id|stli_tmpwritebuf
op_eq
(paren
r_char
op_star
)paren
l_int|NULL
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_eq
id|stli_txcooktty
)paren
id|stli_flushchars
c_func
(paren
id|tty
)paren
suffix:semicolon
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;brdnr
OL
l_int|0
)paren
op_logical_or
(paren
id|portp-&gt;brdnr
op_ge
id|stli_nrbrds
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|chbuf
op_assign
(paren
r_int
r_char
op_star
)paren
id|buf
suffix:semicolon
multiline_comment|/*&n; *&t;If copying direct from user space we need to be able to handle page&n; *&t;faults while we are copying. To do this copy as much as we can now&n; *&t;into a kernel buffer. From there we copy it into shared memory. The&n; *&t;big problem is that we do not want shared memory enabled when we are&n; *&t;sleeping (other boards may be serviced while asleep). Something else&n; *&t;to note here is the reading of the tail twice. Since the boards&n; *&t;shared memory can be on an 8-bit bus then we need to be very careful&n; *&t;reading 16 bit quantities - since both the board (slave) and host&n; *&t;could be writing and reading at the same time.&n; */
r_if
c_cond
(paren
id|from_user
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|ap
op_assign
(paren
r_volatile
id|cdkasy_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;addr
)paren
suffix:semicolon
id|head
op_assign
(paren
r_int
r_int
)paren
id|ap-&gt;txq.head
suffix:semicolon
id|tail
op_assign
(paren
r_int
r_int
)paren
id|ap-&gt;txq.tail
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_ne
(paren
(paren
r_int
r_int
)paren
id|ap-&gt;txq.tail
)paren
)paren
id|tail
op_assign
(paren
r_int
r_int
)paren
id|ap-&gt;txq.tail
suffix:semicolon
id|len
op_assign
(paren
id|head
op_ge
id|tail
)paren
ques
c_cond
(paren
id|portp-&gt;txsize
op_minus
(paren
id|head
op_minus
id|tail
)paren
op_minus
l_int|1
)paren
suffix:colon
(paren
id|tail
op_minus
id|head
op_minus
l_int|1
)paren
suffix:semicolon
id|count
op_assign
id|MIN
c_func
(paren
id|len
comma
id|count
)paren
suffix:semicolon
id|EBRDDISABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|stli_tmpwritesem
)paren
suffix:semicolon
id|copy_from_user
c_func
(paren
id|stli_tmpwritebuf
comma
id|chbuf
comma
id|count
)paren
suffix:semicolon
id|chbuf
op_assign
op_amp
id|stli_tmpwritebuf
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;All data is now local, shove as much as possible into shared memory.&n; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|ap
op_assign
(paren
r_volatile
id|cdkasy_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;addr
)paren
suffix:semicolon
id|head
op_assign
(paren
r_int
r_int
)paren
id|ap-&gt;txq.head
suffix:semicolon
id|tail
op_assign
(paren
r_int
r_int
)paren
id|ap-&gt;txq.tail
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_ne
(paren
(paren
r_int
r_int
)paren
id|ap-&gt;txq.tail
)paren
)paren
id|tail
op_assign
(paren
r_int
r_int
)paren
id|ap-&gt;txq.tail
suffix:semicolon
id|size
op_assign
id|portp-&gt;txsize
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ge
id|tail
)paren
(brace
id|len
op_assign
id|size
op_minus
(paren
id|head
op_minus
id|tail
)paren
op_minus
l_int|1
suffix:semicolon
id|stlen
op_assign
id|size
op_minus
id|head
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
id|tail
op_minus
id|head
op_minus
l_int|1
suffix:semicolon
id|stlen
op_assign
id|len
suffix:semicolon
)brace
id|len
op_assign
id|MIN
c_func
(paren
id|len
comma
id|count
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|shbuf
op_assign
(paren
r_char
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;txoffset
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|stlen
op_assign
id|MIN
c_func
(paren
id|len
comma
id|stlen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
id|shbuf
op_plus
id|head
)paren
comma
id|chbuf
comma
id|stlen
)paren
suffix:semicolon
id|chbuf
op_add_assign
id|stlen
suffix:semicolon
id|len
op_sub_assign
id|stlen
suffix:semicolon
id|count
op_add_assign
id|stlen
suffix:semicolon
id|head
op_add_assign
id|stlen
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ge
id|size
)paren
(brace
id|head
op_assign
l_int|0
suffix:semicolon
id|stlen
op_assign
id|tail
suffix:semicolon
)brace
)brace
id|ap
op_assign
(paren
r_volatile
id|cdkasy_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;addr
)paren
suffix:semicolon
id|ap-&gt;txq.head
op_assign
id|head
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_TXBUSY
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;changed.data
op_amp
id|DT_TXEMPTY
)paren
id|ap-&gt;changed.data
op_and_assign
op_complement
id|DT_TXEMPTY
suffix:semicolon
)brace
id|hdrp
op_assign
(paren
r_volatile
id|cdkhdr_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|CDK_CDKADDR
)paren
suffix:semicolon
id|bits
op_assign
(paren
(paren
r_volatile
r_int
r_char
op_star
)paren
id|hdrp
)paren
op_plus
id|brdp-&gt;slaveoffset
op_plus
id|portp-&gt;portidx
suffix:semicolon
op_star
id|bits
op_or_assign
id|portp-&gt;portbit
suffix:semicolon
id|set_bit
c_func
(paren
id|ST_TXBUSY
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|EBRDDISABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
id|up
c_func
(paren
op_amp
id|stli_tmpwritesem
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Output a single character. We put it into a temporary local buffer&n; *&t;(for speed) then write out that buffer when the flushchars routine&n; *&t;is called. There is a safety catch here so that if some other port&n; *&t;writes chars before the current buffer has been, then we write them&n; *&t;first them do the new ports.&n; */
DECL|function|stli_putchar
r_static
r_void
id|stli_putchar
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_putchar(tty=%x,ch=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
comma
(paren
r_int
)paren
id|ch
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_ne
id|stli_txcooktty
)paren
(brace
r_if
c_cond
(paren
id|stli_txcooktty
op_ne
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
id|stli_flushchars
c_func
(paren
id|stli_txcooktty
)paren
suffix:semicolon
id|stli_txcooktty
op_assign
id|tty
suffix:semicolon
)brace
id|stli_txcookbuf
(braket
id|stli_txcooksize
op_increment
)braket
op_assign
id|ch
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Transfer characters from the local TX cooking buffer to the board.&n; *&t;We sort of ignore the tty that gets passed in here. We rely on the&n; *&t;info stored with the TX cook buffer to tell us which port to flush&n; *&t;the data on. In any case we clean out the TX cook buffer, for re-use&n; *&t;by someone else.&n; */
DECL|function|stli_flushchars
r_static
r_void
id|stli_flushchars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_volatile
id|cdkhdr_t
op_star
id|hdrp
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|bits
suffix:semicolon
r_volatile
id|cdkasy_t
op_star
id|ap
suffix:semicolon
r_struct
id|tty_struct
op_star
id|cooktty
suffix:semicolon
id|stliport_t
op_star
id|portp
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
r_int
id|len
comma
id|stlen
comma
id|head
comma
id|tail
comma
id|size
comma
id|count
comma
id|cooksize
suffix:semicolon
r_int
r_char
op_star
id|buf
comma
op_star
id|shbuf
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_flushchars(tty=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
)paren
suffix:semicolon
macro_line|#endif
id|cooksize
op_assign
id|stli_txcooksize
suffix:semicolon
id|cooktty
op_assign
id|stli_txcooktty
suffix:semicolon
id|stli_txcooksize
op_assign
l_int|0
suffix:semicolon
id|stli_txcookrealsize
op_assign
l_int|0
suffix:semicolon
id|stli_txcooktty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|cooktty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_ne
id|cooktty
)paren
id|tty
op_assign
id|cooktty
suffix:semicolon
r_if
c_cond
(paren
id|cooksize
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;brdnr
OL
l_int|0
)paren
op_logical_or
(paren
id|portp-&gt;brdnr
op_ge
id|stli_nrbrds
)paren
)paren
r_return
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|ap
op_assign
(paren
r_volatile
id|cdkasy_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;addr
)paren
suffix:semicolon
id|head
op_assign
(paren
r_int
r_int
)paren
id|ap-&gt;txq.head
suffix:semicolon
id|tail
op_assign
(paren
r_int
r_int
)paren
id|ap-&gt;txq.tail
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_ne
(paren
(paren
r_int
r_int
)paren
id|ap-&gt;txq.tail
)paren
)paren
id|tail
op_assign
(paren
r_int
r_int
)paren
id|ap-&gt;txq.tail
suffix:semicolon
id|size
op_assign
id|portp-&gt;txsize
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ge
id|tail
)paren
(brace
id|len
op_assign
id|size
op_minus
(paren
id|head
op_minus
id|tail
)paren
op_minus
l_int|1
suffix:semicolon
id|stlen
op_assign
id|size
op_minus
id|head
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
id|tail
op_minus
id|head
op_minus
l_int|1
suffix:semicolon
id|stlen
op_assign
id|len
suffix:semicolon
)brace
id|len
op_assign
id|MIN
c_func
(paren
id|len
comma
id|cooksize
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|shbuf
op_assign
(paren
r_char
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;txoffset
)paren
suffix:semicolon
id|buf
op_assign
id|stli_txcookbuf
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|stlen
op_assign
id|MIN
c_func
(paren
id|len
comma
id|stlen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
id|shbuf
op_plus
id|head
)paren
comma
id|buf
comma
id|stlen
)paren
suffix:semicolon
id|buf
op_add_assign
id|stlen
suffix:semicolon
id|len
op_sub_assign
id|stlen
suffix:semicolon
id|count
op_add_assign
id|stlen
suffix:semicolon
id|head
op_add_assign
id|stlen
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ge
id|size
)paren
(brace
id|head
op_assign
l_int|0
suffix:semicolon
id|stlen
op_assign
id|tail
suffix:semicolon
)brace
)brace
id|ap
op_assign
(paren
r_volatile
id|cdkasy_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;addr
)paren
suffix:semicolon
id|ap-&gt;txq.head
op_assign
id|head
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_TXBUSY
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
id|ap-&gt;changed.data
op_amp
id|DT_TXEMPTY
)paren
id|ap-&gt;changed.data
op_and_assign
op_complement
id|DT_TXEMPTY
suffix:semicolon
)brace
id|hdrp
op_assign
(paren
r_volatile
id|cdkhdr_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|CDK_CDKADDR
)paren
suffix:semicolon
id|bits
op_assign
(paren
(paren
r_volatile
r_int
r_char
op_star
)paren
id|hdrp
)paren
op_plus
id|brdp-&gt;slaveoffset
op_plus
id|portp-&gt;portidx
suffix:semicolon
op_star
id|bits
op_or_assign
id|portp-&gt;portbit
suffix:semicolon
id|set_bit
c_func
(paren
id|ST_TXBUSY
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|EBRDDISABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_writeroom
r_static
r_int
id|stli_writeroom
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_volatile
id|cdkasyrq_t
op_star
id|rp
suffix:semicolon
id|stliport_t
op_star
id|portp
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
r_int
id|head
comma
id|tail
comma
id|len
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_writeroom(tty=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_eq
id|stli_txcooktty
)paren
(brace
r_if
c_cond
(paren
id|stli_txcookrealsize
op_ne
l_int|0
)paren
(brace
id|len
op_assign
id|stli_txcookrealsize
op_minus
id|stli_txcooksize
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
)brace
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;brdnr
OL
l_int|0
)paren
op_logical_or
(paren
id|portp-&gt;brdnr
op_ge
id|stli_nrbrds
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|rp
op_assign
op_amp
(paren
(paren
r_volatile
id|cdkasy_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;addr
)paren
)paren
op_member_access_from_pointer
id|txq
suffix:semicolon
id|head
op_assign
(paren
r_int
r_int
)paren
id|rp-&gt;head
suffix:semicolon
id|tail
op_assign
(paren
r_int
r_int
)paren
id|rp-&gt;tail
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_ne
(paren
(paren
r_int
r_int
)paren
id|rp-&gt;tail
)paren
)paren
id|tail
op_assign
(paren
r_int
r_int
)paren
id|rp-&gt;tail
suffix:semicolon
id|len
op_assign
(paren
id|head
op_ge
id|tail
)paren
ques
c_cond
(paren
id|portp-&gt;txsize
op_minus
(paren
id|head
op_minus
id|tail
)paren
)paren
suffix:colon
(paren
id|tail
op_minus
id|head
)paren
suffix:semicolon
id|len
op_decrement
suffix:semicolon
id|EBRDDISABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_eq
id|stli_txcooktty
)paren
(brace
id|stli_txcookrealsize
op_assign
id|len
suffix:semicolon
id|len
op_sub_assign
id|stli_txcooksize
suffix:semicolon
)brace
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Return the number of characters in the transmit buffer. Normally we&n; *&t;will return the number of chars in the shared memory ring queue.&n; *&t;We need to kludge around the case where the shared memory buffer is&n; *&t;empty but not all characters have drained yet, for this case just&n; *&t;return that there is 1 character in the buffer!&n; */
DECL|function|stli_charsinbuffer
r_static
r_int
id|stli_charsinbuffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_volatile
id|cdkasyrq_t
op_star
id|rp
suffix:semicolon
id|stliport_t
op_star
id|portp
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
r_int
id|head
comma
id|tail
comma
id|len
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_charsinbuffer(tty=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_eq
id|stli_txcooktty
)paren
id|stli_flushchars
c_func
(paren
id|tty
)paren
suffix:semicolon
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;brdnr
OL
l_int|0
)paren
op_logical_or
(paren
id|portp-&gt;brdnr
op_ge
id|stli_nrbrds
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|rp
op_assign
op_amp
(paren
(paren
r_volatile
id|cdkasy_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;addr
)paren
)paren
op_member_access_from_pointer
id|txq
suffix:semicolon
id|head
op_assign
(paren
r_int
r_int
)paren
id|rp-&gt;head
suffix:semicolon
id|tail
op_assign
(paren
r_int
r_int
)paren
id|rp-&gt;tail
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_ne
(paren
(paren
r_int
r_int
)paren
id|rp-&gt;tail
)paren
)paren
id|tail
op_assign
(paren
r_int
r_int
)paren
id|rp-&gt;tail
suffix:semicolon
id|len
op_assign
(paren
id|head
op_ge
id|tail
)paren
ques
c_cond
(paren
id|head
op_minus
id|tail
)paren
suffix:colon
(paren
id|portp-&gt;txsize
op_minus
(paren
id|tail
op_minus
id|head
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
op_eq
l_int|0
)paren
op_logical_and
id|test_bit
c_func
(paren
id|ST_TXBUSY
comma
op_amp
id|portp-&gt;state
)paren
)paren
id|len
op_assign
l_int|1
suffix:semicolon
id|EBRDDISABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Generate the serial struct info.&n; */
DECL|function|stli_getserial
r_static
r_void
id|stli_getserial
c_func
(paren
id|stliport_t
op_star
id|portp
comma
r_struct
id|serial_struct
op_star
id|sp
)paren
(brace
r_struct
id|serial_struct
id|sio
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_getserial(portp=%x,sp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|portp
comma
(paren
r_int
)paren
id|sp
)paren
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
op_amp
id|sio
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
suffix:semicolon
id|sio.type
op_assign
id|PORT_UNKNOWN
suffix:semicolon
id|sio.line
op_assign
id|portp-&gt;portnr
suffix:semicolon
id|sio.irq
op_assign
l_int|0
suffix:semicolon
id|sio.flags
op_assign
id|portp-&gt;flags
suffix:semicolon
id|sio.baud_base
op_assign
id|portp-&gt;baud_base
suffix:semicolon
id|sio.close_delay
op_assign
id|portp-&gt;close_delay
suffix:semicolon
id|sio.closing_wait
op_assign
id|portp-&gt;closing_wait
suffix:semicolon
id|sio.custom_divisor
op_assign
id|portp-&gt;custom_divisor
suffix:semicolon
id|sio.xmit_fifo_size
op_assign
l_int|0
suffix:semicolon
id|sio.hub6
op_assign
l_int|0
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_ne
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
id|sio.port
op_assign
id|brdp-&gt;iobase
suffix:semicolon
id|copy_to_user
c_func
(paren
id|sp
comma
op_amp
id|sio
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Set port according to the serial struct info.&n; *&t;At this point we do not do any auto-configure stuff, so we will&n; *&t;just quietly ignore any requests to change irq, etc.&n; */
DECL|function|stli_setserial
r_static
r_int
id|stli_setserial
c_func
(paren
id|stliport_t
op_star
id|portp
comma
r_struct
id|serial_struct
op_star
id|sp
)paren
(brace
r_struct
id|serial_struct
id|sio
suffix:semicolon
r_int
id|rc
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_setserial(portp=%x,sp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|portp
comma
(paren
r_int
)paren
id|sp
)paren
suffix:semicolon
macro_line|#endif
id|copy_from_user
c_func
(paren
op_amp
id|sio
comma
id|sp
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|sio.baud_base
op_ne
id|portp-&gt;baud_base
)paren
op_logical_or
(paren
id|sio.close_delay
op_ne
id|portp-&gt;close_delay
)paren
op_logical_or
(paren
(paren
id|sio.flags
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
op_ne
(paren
id|portp-&gt;flags
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|portp-&gt;flags
op_assign
(paren
id|portp-&gt;flags
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
op_or
(paren
id|sio.flags
op_amp
id|ASYNC_USR_MASK
)paren
suffix:semicolon
id|portp-&gt;baud_base
op_assign
id|sio.baud_base
suffix:semicolon
id|portp-&gt;close_delay
op_assign
id|sio.close_delay
suffix:semicolon
id|portp-&gt;closing_wait
op_assign
id|sio.closing_wait
suffix:semicolon
id|portp-&gt;custom_divisor
op_assign
id|sio.custom_divisor
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|stli_setport
c_func
(paren
id|portp
)paren
)paren
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ioctl
r_static
r_int
id|stli_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|stliport_t
op_star
id|portp
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
r_int
id|lval
suffix:semicolon
r_int
r_int
id|ival
suffix:semicolon
r_int
id|rc
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_ioctl(tty=%x,file=%x,cmd=%x,arg=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
comma
(paren
r_int
)paren
id|file
comma
id|cmd
comma
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;brdnr
OL
l_int|0
)paren
op_logical_or
(paren
id|portp-&gt;brdnr
op_ge
id|stli_nrbrds
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_ne
id|TIOCGSERIAL
)paren
op_logical_and
(paren
id|cmd
op_ne
id|TIOCSSERIAL
)paren
op_logical_and
(paren
id|cmd
op_ne
id|COM_GETPORTSTATS
)paren
op_logical_and
(paren
id|cmd
op_ne
id|COM_CLRPORTSTATS
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|rc
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCGSOFTCAR
suffix:colon
id|rc
op_assign
id|put_user
c_func
(paren
(paren
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSSOFTCAR
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|get_user
c_func
(paren
id|ival
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|tty-&gt;termios-&gt;c_cflag
op_assign
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
op_complement
id|CLOCAL
)paren
op_or
(paren
id|ival
ques
c_cond
id|CLOCAL
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMGET
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_GETSIGNALS
comma
op_amp
id|portp-&gt;asig
comma
r_sizeof
(paren
id|asysigs_t
)paren
comma
l_int|1
)paren
)paren
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
id|lval
op_assign
id|stli_mktiocm
c_func
(paren
id|portp-&gt;asig.sigvalue
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|lval
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|get_user
c_func
(paren
id|ival
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|stli_mkasysigs
c_func
(paren
op_amp
id|portp-&gt;asig
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
l_int|1
suffix:colon
op_minus
l_int|1
)paren
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
l_int|1
suffix:colon
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_SETSIGNALS
comma
op_amp
id|portp-&gt;asig
comma
r_sizeof
(paren
id|asysigs_t
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMBIC
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|get_user
c_func
(paren
id|ival
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|stli_mkasysigs
c_func
(paren
op_amp
id|portp-&gt;asig
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
)paren
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_SETSIGNALS
comma
op_amp
id|portp-&gt;asig
comma
r_sizeof
(paren
id|asysigs_t
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|get_user
c_func
(paren
id|ival
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|stli_mkasysigs
c_func
(paren
op_amp
id|portp-&gt;asig
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|rc
op_assign
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_SETSIGNALS
comma
op_amp
id|portp-&gt;asig
comma
r_sizeof
(paren
id|asysigs_t
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCGSERIAL
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|stli_getserial
c_func
(paren
id|portp
comma
(paren
r_struct
id|serial_struct
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSSERIAL
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|rc
op_assign
id|stli_setserial
c_func
(paren
id|portp
comma
(paren
r_struct
id|serial_struct
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STL_GETPFLAG
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|put_user
c_func
(paren
id|portp-&gt;pflag
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STL_SETPFLAG
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|get_user
c_func
(paren
id|portp-&gt;pflag
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|stli_setport
c_func
(paren
id|portp
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|COM_GETPORTSTATS
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|comstats_t
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|rc
op_assign
id|stli_getportstats
c_func
(paren
id|portp
comma
(paren
id|comstats_t
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COM_CLRPORTSTATS
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|comstats_t
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|rc
op_assign
id|stli_clrportstats
c_func
(paren
id|portp
comma
(paren
id|comstats_t
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSERCONFIG
suffix:colon
r_case
id|TIOCSERGWILD
suffix:colon
r_case
id|TIOCSERSWILD
suffix:colon
r_case
id|TIOCSERGETLSR
suffix:colon
r_case
id|TIOCSERGSTRUCT
suffix:colon
r_case
id|TIOCSERGETMULTI
suffix:colon
r_case
id|TIOCSERSETMULTI
suffix:colon
r_default
suffix:colon
id|rc
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;This routine assumes that we have user context and can sleep.&n; *&t;Looks like it is true for the current ttys implementation..!!&n; */
DECL|function|stli_settermios
r_static
r_void
id|stli_settermios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old
)paren
(brace
id|stliport_t
op_star
id|portp
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_struct
id|termios
op_star
id|tiosp
suffix:semicolon
id|asyport_t
id|aport
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_settermios(tty=%x,old=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
comma
(paren
r_int
)paren
id|old
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;brdnr
OL
l_int|0
)paren
op_logical_or
(paren
id|portp-&gt;brdnr
op_ge
id|stli_nrbrds
)paren
)paren
r_return
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|tiosp
op_assign
id|tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tiosp-&gt;c_cflag
op_eq
id|old-&gt;c_cflag
)paren
op_logical_and
(paren
id|tiosp-&gt;c_iflag
op_eq
id|old-&gt;c_iflag
)paren
)paren
r_return
suffix:semicolon
id|stli_mkasyport
c_func
(paren
id|portp
comma
op_amp
id|aport
comma
id|tiosp
)paren
suffix:semicolon
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_SETPORT
comma
op_amp
id|aport
comma
r_sizeof
(paren
id|asyport_t
)paren
comma
l_int|0
)paren
suffix:semicolon
id|stli_mkasysigs
c_func
(paren
op_amp
id|portp-&gt;asig
comma
(paren
(paren
id|tiosp-&gt;c_cflag
op_amp
id|CBAUD
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_SETSIGNALS
comma
op_amp
id|portp-&gt;asig
comma
r_sizeof
(paren
id|asysigs_t
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
op_logical_and
(paren
(paren
id|tiosp-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
op_eq
l_int|0
)paren
)paren
id|tty-&gt;hw_stopped
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|old-&gt;c_cflag
op_amp
id|CLOCAL
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|tiosp-&gt;c_cflag
op_amp
id|CLOCAL
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|portp-&gt;open_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Attempt to flow control who ever is sending us data. We won&squot;t really&n; *&t;do any flow control action here. We can&squot;t directly, and even if we&n; *&t;wanted to we would have to send a command to the slave. The slave&n; *&t;knows how to flow control, and will do so when its buffers reach its&n; *&t;internal high water marks. So what we will do is set a local state&n; *&t;bit that will stop us sending any RX data up from the poll routine&n; *&t;(which is the place where RX data from the slave is handled).&n; */
DECL|function|stli_throttle
r_static
r_void
id|stli_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|stliport_t
op_star
id|portp
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_throttle(tty=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|set_bit
c_func
(paren
id|ST_RXSTOP
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Unflow control the device sending us data... That means that all&n; *&t;we have to do is clear the RXSTOP state bit. The next poll call&n; *&t;will then be able to pass the RX data back up.&n; */
DECL|function|stli_unthrottle
r_static
r_void
id|stli_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|stliport_t
op_star
id|portp
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_unthrottle(tty=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|clear_bit
c_func
(paren
id|ST_RXSTOP
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Stop the transmitter. Basically to do this we will just turn TX&n; *&t;interrupts off.&n; */
DECL|function|stli_stop
r_static
r_void
id|stli_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
id|stliport_t
op_star
id|portp
suffix:semicolon
id|asyctrl_t
id|actrl
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_stop(tty=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;brdnr
OL
l_int|0
)paren
op_logical_or
(paren
id|portp-&gt;brdnr
op_ge
id|stli_nrbrds
)paren
)paren
r_return
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|actrl
comma
l_int|0
comma
r_sizeof
(paren
id|asyctrl_t
)paren
)paren
suffix:semicolon
id|actrl.txctrl
op_assign
id|CT_STOPFLOW
suffix:semicolon
macro_line|#if 0
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_PORTCTRL
comma
op_amp
id|actrl
comma
r_sizeof
(paren
id|asyctrl_t
)paren
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Start the transmitter again. Just turn TX interrupts back on.&n; */
DECL|function|stli_start
r_static
r_void
id|stli_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|stliport_t
op_star
id|portp
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
id|asyctrl_t
id|actrl
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_start(tty=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;brdnr
OL
l_int|0
)paren
op_logical_or
(paren
id|portp-&gt;brdnr
op_ge
id|stli_nrbrds
)paren
)paren
r_return
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|actrl
comma
l_int|0
comma
r_sizeof
(paren
id|asyctrl_t
)paren
)paren
suffix:semicolon
id|actrl.txctrl
op_assign
id|CT_STARTFLOW
suffix:semicolon
macro_line|#if 0
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_PORTCTRL
comma
op_amp
id|actrl
comma
r_sizeof
(paren
id|asyctrl_t
)paren
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Scheduler called hang up routine. This is called from the scheduler,&n; *&t;not direct from the driver &quot;poll&quot; routine. We can&squot;t call it there&n; *&t;since the real local hangup code will enable/disable the board and&n; *&t;other things that we can&squot;t do while handling the poll. Much easier&n; *&t;to deal with it some time later (don&squot;t really care when, hangups&n; *&t;aren&squot;t that time critical).&n; */
DECL|function|stli_dohangup
r_static
r_void
id|stli_dohangup
c_func
(paren
r_void
op_star
id|arg
)paren
(brace
id|stliport_t
op_star
id|portp
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_dohangup(portp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * FIXME: There&squot;s a module removal race here: tty_hangup&n;&t; * calls schedule_task which will call into this&n;&t; * driver later.&n;&t; */
id|portp
op_assign
(paren
id|stliport_t
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_ne
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|portp-&gt;tty
op_ne
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
(brace
id|tty_hangup
c_func
(paren
id|portp-&gt;tty
)paren
suffix:semicolon
)brace
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Hangup this port. This is pretty much like closing the port, only&n; *&t;a little more brutal. No waiting for data to drain. Shutdown the&n; *&t;port and maybe drop signals. This is rather tricky really. We want&n; *&t;to close the port as well.&n; */
DECL|function|stli_hangup
r_static
r_void
id|stli_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|stliport_t
op_star
id|portp
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_hangup(tty=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;brdnr
OL
l_int|0
)paren
op_logical_or
(paren
id|portp-&gt;brdnr
op_ge
id|stli_nrbrds
)paren
)paren
r_return
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|portp-&gt;flags
op_and_assign
op_complement
id|ASYNC_INITIALIZED
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|ST_CLOSING
comma
op_amp
id|portp-&gt;state
)paren
)paren
id|stli_rawclose
c_func
(paren
id|brdp
comma
id|portp
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
(brace
id|stli_mkasysigs
c_func
(paren
op_amp
id|portp-&gt;asig
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_CMDING
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|ST_DOSIGS
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|ST_DOFLUSHTX
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|ST_DOFLUSHRX
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
)brace
r_else
(brace
id|stli_sendcmd
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_SETSIGNALSF
comma
op_amp
id|portp-&gt;asig
comma
r_sizeof
(paren
id|asysigs_t
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|ST_TXBUSY
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|ST_RXSTOP
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|portp-&gt;tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
suffix:semicolon
id|portp-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
)paren
suffix:semicolon
id|portp-&gt;refcount
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|portp-&gt;open_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Flush characters from the lower buffer. We may not have user context&n; *&t;so we cannot sleep waiting for it to complete. Also we need to check&n; *&t;if there is chars for this port in the TX cook buffer, and flush them&n; *&t;as well.&n; */
DECL|function|stli_flushbuffer
r_static
r_void
id|stli_flushbuffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|stliport_t
op_star
id|portp
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
r_int
id|ftype
comma
id|flags
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_flushbuffer(tty=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;brdnr
OL
l_int|0
)paren
op_logical_or
(paren
id|portp-&gt;brdnr
op_ge
id|stli_nrbrds
)paren
)paren
r_return
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_eq
id|stli_txcooktty
)paren
(brace
id|stli_txcooktty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
suffix:semicolon
id|stli_txcooksize
op_assign
l_int|0
suffix:semicolon
id|stli_txcookrealsize
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_CMDING
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|ST_DOFLUSHTX
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
)brace
r_else
(brace
id|ftype
op_assign
id|FLUSHTX
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_DOFLUSHRX
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
id|ftype
op_or_assign
id|FLUSHRX
suffix:semicolon
id|clear_bit
c_func
(paren
id|ST_DOFLUSHRX
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
)brace
id|stli_sendcmd
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_FLUSH
comma
op_amp
id|ftype
comma
r_sizeof
(paren
r_int
r_int
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_breakctl
r_static
r_void
id|stli_breakctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|state
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
id|stliport_t
op_star
id|portp
suffix:semicolon
r_int
id|arg
suffix:semicolon
multiline_comment|/* long savestate, savetime; */
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_breakctl(tty=%x,state=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
comma
id|state
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;brdnr
OL
l_int|0
)paren
op_logical_or
(paren
id|portp-&gt;brdnr
op_ge
id|stli_nrbrds
)paren
)paren
r_return
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/*&n; *&t;Due to a bug in the tty send_break() code we need to preserve&n; *&t;the current process state and timeout...&n;&t;savetime = current-&gt;timeout;&n;&t;savestate = current-&gt;state;&n; */
id|arg
op_assign
(paren
id|state
op_eq
op_minus
l_int|1
)paren
ques
c_cond
id|BREAKON
suffix:colon
id|BREAKOFF
suffix:semicolon
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_BREAK
comma
op_amp
id|arg
comma
r_sizeof
(paren
r_int
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n; *&n;&t;current-&gt;timeout = savetime;&n;&t;current-&gt;state = savestate;&n; */
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_waituntilsent
r_static
r_void
id|stli_waituntilsent
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|timeout
)paren
(brace
id|stliport_t
op_star
id|portp
suffix:semicolon
r_int
r_int
id|tend
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_waituntilsent(tty=%x,timeout=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
comma
id|timeout
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_eq
l_int|0
)paren
id|timeout
op_assign
id|HZ
suffix:semicolon
id|tend
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
r_while
c_loop
(paren
id|test_bit
c_func
(paren
id|ST_TXBUSY
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
id|stli_delay
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|tend
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_sendxchar
r_static
r_void
id|stli_sendxchar
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_char
id|ch
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
id|stliport_t
op_star
id|portp
suffix:semicolon
id|asyctrl_t
id|actrl
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_sendxchar(tty=%x,ch=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|tty
comma
id|ch
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|portp
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;brdnr
OL
l_int|0
)paren
op_logical_or
(paren
id|portp-&gt;brdnr
op_ge
id|stli_nrbrds
)paren
)paren
r_return
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|actrl
comma
l_int|0
comma
r_sizeof
(paren
id|asyctrl_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
id|STOP_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
id|actrl.rxctrl
op_assign
id|CT_STOPFLOW
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ch
op_eq
id|START_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
id|actrl.rxctrl
op_assign
id|CT_STARTFLOW
suffix:semicolon
)brace
r_else
(brace
id|actrl.txctrl
op_assign
id|CT_SENDCHR
suffix:semicolon
id|actrl.tximdch
op_assign
id|ch
suffix:semicolon
)brace
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_PORTCTRL
comma
op_amp
id|actrl
comma
r_sizeof
(paren
id|asyctrl_t
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|macro|MAXLINE
mdefine_line|#define&t;MAXLINE&t;&t;80
multiline_comment|/*&n; *&t;Format info for a specified port. The line is deliberately limited&n; *&t;to 80 characters. (If it is too long it will be truncated, if too&n; *&t;short then padded with spaces).&n; */
DECL|function|stli_portinfo
r_static
r_int
id|stli_portinfo
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
comma
r_int
id|portnr
comma
r_char
op_star
id|pos
)paren
(brace
r_char
op_star
id|sp
comma
op_star
id|uart
suffix:semicolon
r_int
id|rc
comma
id|cnt
suffix:semicolon
id|rc
op_assign
id|stli_portcmdstats
c_func
(paren
id|portp
)paren
suffix:semicolon
id|uart
op_assign
l_string|&quot;UNKNOWN&quot;
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;state
op_amp
id|BST_STARTED
)paren
(brace
r_switch
c_cond
(paren
id|stli_comstats.hwid
)paren
(brace
r_case
l_int|0
suffix:colon
id|uart
op_assign
l_string|&quot;2681&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|uart
op_assign
l_string|&quot;SC26198&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|uart
op_assign
l_string|&quot;CD1400&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|sp
op_assign
id|pos
suffix:semicolon
id|sp
op_add_assign
id|sprintf
c_func
(paren
id|sp
comma
l_string|&quot;%d: uart:%s &quot;
comma
id|portnr
comma
id|uart
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|brdp-&gt;state
op_amp
id|BST_STARTED
)paren
op_logical_and
(paren
id|rc
op_ge
l_int|0
)paren
)paren
(brace
id|sp
op_add_assign
id|sprintf
c_func
(paren
id|sp
comma
l_string|&quot;tx:%d rx:%d&quot;
comma
(paren
r_int
)paren
id|stli_comstats.txtotal
comma
(paren
r_int
)paren
id|stli_comstats.rxtotal
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stli_comstats.rxframing
)paren
id|sp
op_add_assign
id|sprintf
c_func
(paren
id|sp
comma
l_string|&quot; fe:%d&quot;
comma
(paren
r_int
)paren
id|stli_comstats.rxframing
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stli_comstats.rxparity
)paren
id|sp
op_add_assign
id|sprintf
c_func
(paren
id|sp
comma
l_string|&quot; pe:%d&quot;
comma
(paren
r_int
)paren
id|stli_comstats.rxparity
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stli_comstats.rxbreaks
)paren
id|sp
op_add_assign
id|sprintf
c_func
(paren
id|sp
comma
l_string|&quot; brk:%d&quot;
comma
(paren
r_int
)paren
id|stli_comstats.rxbreaks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stli_comstats.rxoverrun
)paren
id|sp
op_add_assign
id|sprintf
c_func
(paren
id|sp
comma
l_string|&quot; oe:%d&quot;
comma
(paren
r_int
)paren
id|stli_comstats.rxoverrun
)paren
suffix:semicolon
id|cnt
op_assign
id|sprintf
c_func
(paren
id|sp
comma
l_string|&quot;%s%s%s%s%s &quot;
comma
(paren
id|stli_comstats.signals
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
l_string|&quot;|RTS&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|stli_comstats.signals
op_amp
id|TIOCM_CTS
)paren
ques
c_cond
l_string|&quot;|CTS&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|stli_comstats.signals
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
l_string|&quot;|DTR&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|stli_comstats.signals
op_amp
id|TIOCM_CD
)paren
ques
c_cond
l_string|&quot;|DCD&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|stli_comstats.signals
op_amp
id|TIOCM_DSR
)paren
ques
c_cond
l_string|&quot;|DSR&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
op_star
id|sp
op_assign
l_char|&squot; &squot;
suffix:semicolon
id|sp
op_add_assign
id|cnt
suffix:semicolon
)brace
r_for
c_loop
(paren
id|cnt
op_assign
(paren
id|sp
op_minus
id|pos
)paren
suffix:semicolon
(paren
id|cnt
OL
(paren
id|MAXLINE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|cnt
op_increment
)paren
op_star
id|sp
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_ge
id|MAXLINE
)paren
id|pos
(braket
(paren
id|MAXLINE
op_minus
l_int|2
)paren
)braket
op_assign
l_char|&squot;+&squot;
suffix:semicolon
id|pos
(braket
(paren
id|MAXLINE
op_minus
l_int|1
)paren
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_return
id|MAXLINE
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Port info, read from the /proc file system.&n; */
DECL|function|stli_readproc
r_static
r_int
id|stli_readproc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
id|stliport_t
op_star
id|portp
suffix:semicolon
r_int
id|brdnr
comma
id|portnr
comma
id|totalport
suffix:semicolon
r_int
id|curoff
comma
id|maxoff
suffix:semicolon
r_char
op_star
id|pos
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_readproc(page=%x,start=%x,off=%x,count=%d,eof=%x,&quot;
l_string|&quot;data=%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|page
comma
(paren
r_int
)paren
id|start
comma
(paren
r_int
)paren
id|off
comma
id|count
comma
(paren
r_int
)paren
id|eof
comma
(paren
r_int
)paren
id|data
)paren
suffix:semicolon
macro_line|#endif
id|pos
op_assign
id|page
suffix:semicolon
id|totalport
op_assign
l_int|0
suffix:semicolon
id|curoff
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|off
op_eq
l_int|0
)paren
(brace
id|pos
op_add_assign
id|sprintf
c_func
(paren
id|pos
comma
l_string|&quot;%s: version %s&quot;
comma
id|stli_drvtitle
comma
id|stli_drvversion
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pos
OL
(paren
id|page
op_plus
id|MAXLINE
op_minus
l_int|1
)paren
)paren
op_star
id|pos
op_increment
op_assign
l_char|&squot; &squot;
suffix:semicolon
op_star
id|pos
op_increment
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
id|curoff
op_assign
id|MAXLINE
suffix:semicolon
multiline_comment|/*&n; *&t;We scan through for each board, panel and port. The offset is&n; *&t;calculated on the fly, and irrelevant ports are skipped.&n; */
r_for
c_loop
(paren
id|brdnr
op_assign
l_int|0
suffix:semicolon
(paren
id|brdnr
OL
id|stli_nrbrds
)paren
suffix:semicolon
id|brdnr
op_increment
)paren
(brace
id|brdp
op_assign
id|stli_brds
(braket
id|brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;state
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|maxoff
op_assign
id|curoff
op_plus
(paren
id|brdp-&gt;nrports
op_star
id|MAXLINE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|off
op_ge
id|maxoff
)paren
(brace
id|curoff
op_assign
id|maxoff
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|totalport
op_assign
id|brdnr
op_star
id|STL_MAXPORTS
suffix:semicolon
r_for
c_loop
(paren
id|portnr
op_assign
l_int|0
suffix:semicolon
(paren
id|portnr
OL
id|brdp-&gt;nrports
)paren
suffix:semicolon
id|portnr
op_increment
comma
id|totalport
op_increment
)paren
(brace
id|portp
op_assign
id|brdp-&gt;ports
(braket
id|portnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|off
op_ge
(paren
id|curoff
op_add_assign
id|MAXLINE
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pos
op_minus
id|page
op_plus
id|MAXLINE
)paren
OG
id|count
)paren
r_goto
id|stli_readdone
suffix:semicolon
id|pos
op_add_assign
id|stli_portinfo
c_func
(paren
id|brdp
comma
id|portp
comma
id|totalport
comma
id|pos
)paren
suffix:semicolon
)brace
)brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
id|stli_readdone
suffix:colon
op_star
id|start
op_assign
id|page
suffix:semicolon
r_return
id|pos
op_minus
id|page
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Generic send command routine. This will send a message to the slave,&n; *&t;of the specified type with the specified argument. Must be very&n; *&t;careful of data that will be copied out from shared memory -&n; *&t;containing command results. The command completion is all done from&n; *&t;a poll routine that does not have user context. Therefore you cannot&n; *&t;copy back directly into user space, or to the kernel stack of a&n; *&t;process. This routine does not sleep, so can be called from anywhere.&n; */
DECL|function|stli_sendcmd
r_static
r_void
id|stli_sendcmd
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
comma
r_int
id|size
comma
r_int
id|copyback
)paren
(brace
r_volatile
id|cdkhdr_t
op_star
id|hdrp
suffix:semicolon
r_volatile
id|cdkctrl_t
op_star
id|cp
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|bits
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_sendcmd(brdp=%x,portp=%x,cmd=%x,arg=%x,size=%d,&quot;
l_string|&quot;copyback=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
(paren
r_int
)paren
id|portp
comma
(paren
r_int
)paren
id|cmd
comma
(paren
r_int
)paren
id|arg
comma
id|size
comma
id|copyback
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_CMDING
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: command already busy, cmd=%x!&bslash;n&quot;
comma
(paren
r_int
)paren
id|cmd
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|cp
op_assign
op_amp
(paren
(paren
r_volatile
id|cdkasy_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;addr
)paren
)paren
op_member_access_from_pointer
id|ctrl
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
(brace
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
(paren
id|cp-&gt;args
(braket
l_int|0
)braket
)paren
comma
id|arg
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copyback
)paren
(brace
id|portp-&gt;argp
op_assign
id|arg
suffix:semicolon
id|portp-&gt;argsize
op_assign
id|size
suffix:semicolon
)brace
)brace
id|cp-&gt;status
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|hdrp
op_assign
(paren
r_volatile
id|cdkhdr_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|CDK_CDKADDR
)paren
suffix:semicolon
id|bits
op_assign
(paren
(paren
r_volatile
r_int
r_char
op_star
)paren
id|hdrp
)paren
op_plus
id|brdp-&gt;slaveoffset
op_plus
id|portp-&gt;portidx
suffix:semicolon
op_star
id|bits
op_or_assign
id|portp-&gt;portbit
suffix:semicolon
id|set_bit
c_func
(paren
id|ST_CMDING
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|EBRDDISABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Read data from shared memory. This assumes that the shared memory&n; *&t;is enabled and that interrupts are off. Basically we just empty out&n; *&t;the shared memory buffer into the tty buffer. Must be careful to&n; *&t;handle the case where we fill up the tty buffer, but still have&n; *&t;more chars to unload.&n; */
DECL|function|stli_read
r_static
r_inline
r_void
id|stli_read
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
)paren
(brace
r_volatile
id|cdkasyrq_t
op_star
id|rp
suffix:semicolon
r_volatile
r_char
op_star
id|shbuf
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
r_int
id|head
comma
id|tail
comma
id|size
suffix:semicolon
r_int
r_int
id|len
comma
id|stlen
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_read(brdp=%x,portp=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
(paren
r_int
)paren
id|portp
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_RXSTOP
comma
op_amp
id|portp-&gt;state
)paren
)paren
r_return
suffix:semicolon
id|tty
op_assign
id|portp-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_eq
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
r_return
suffix:semicolon
id|rp
op_assign
op_amp
(paren
(paren
r_volatile
id|cdkasy_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;addr
)paren
)paren
op_member_access_from_pointer
id|rxq
suffix:semicolon
id|head
op_assign
(paren
r_int
r_int
)paren
id|rp-&gt;head
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ne
(paren
(paren
r_int
r_int
)paren
id|rp-&gt;head
)paren
)paren
id|head
op_assign
(paren
r_int
r_int
)paren
id|rp-&gt;head
suffix:semicolon
id|tail
op_assign
(paren
r_int
r_int
)paren
id|rp-&gt;tail
suffix:semicolon
id|size
op_assign
id|portp-&gt;rxsize
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ge
id|tail
)paren
(brace
id|len
op_assign
id|head
op_minus
id|tail
suffix:semicolon
id|stlen
op_assign
id|len
suffix:semicolon
)brace
r_else
(brace
id|len
op_assign
id|size
op_minus
(paren
id|tail
op_minus
id|head
)paren
suffix:semicolon
id|stlen
op_assign
id|size
op_minus
id|tail
suffix:semicolon
)brace
id|len
op_assign
id|MIN
c_func
(paren
id|len
comma
(paren
id|TTY_FLIPBUF_SIZE
op_minus
id|tty-&gt;flip.count
)paren
)paren
suffix:semicolon
id|shbuf
op_assign
(paren
r_volatile
r_char
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;rxoffset
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
id|stlen
op_assign
id|MIN
c_func
(paren
id|len
comma
id|stlen
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tty-&gt;flip.char_buf_ptr
comma
(paren
r_char
op_star
)paren
(paren
id|shbuf
op_plus
id|tail
)paren
comma
id|stlen
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tty-&gt;flip.flag_buf_ptr
comma
l_int|0
comma
id|stlen
)paren
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_add_assign
id|stlen
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_add_assign
id|stlen
suffix:semicolon
id|tty-&gt;flip.count
op_add_assign
id|stlen
suffix:semicolon
id|len
op_sub_assign
id|stlen
suffix:semicolon
id|tail
op_add_assign
id|stlen
suffix:semicolon
r_if
c_cond
(paren
id|tail
op_ge
id|size
)paren
(brace
id|tail
op_assign
l_int|0
suffix:semicolon
id|stlen
op_assign
id|head
suffix:semicolon
)brace
)brace
id|rp
op_assign
op_amp
(paren
(paren
r_volatile
id|cdkasy_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;addr
)paren
)paren
op_member_access_from_pointer
id|rxq
suffix:semicolon
id|rp-&gt;tail
op_assign
id|tail
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ne
id|tail
)paren
id|set_bit
c_func
(paren
id|ST_RXING
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|tty_schedule_flip
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Set up and carry out any delayed commands. There is only a small set&n; *&t;of slave commands that can be done &quot;off-level&quot;. So it is not too&n; *&t;difficult to deal with them here.&n; */
DECL|function|stli_dodelaycmd
r_static
r_inline
r_void
id|stli_dodelaycmd
c_func
(paren
id|stliport_t
op_star
id|portp
comma
r_volatile
id|cdkctrl_t
op_star
id|cp
)paren
(brace
r_int
id|cmd
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_DOSIGS
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_DOFLUSHTX
comma
op_amp
id|portp-&gt;state
)paren
op_logical_and
id|test_bit
c_func
(paren
id|ST_DOFLUSHRX
comma
op_amp
id|portp-&gt;state
)paren
)paren
id|cmd
op_assign
id|A_SETSIGNALSF
suffix:semicolon
r_else
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_DOFLUSHTX
comma
op_amp
id|portp-&gt;state
)paren
)paren
id|cmd
op_assign
id|A_SETSIGNALSFTX
suffix:semicolon
r_else
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_DOFLUSHRX
comma
op_amp
id|portp-&gt;state
)paren
)paren
id|cmd
op_assign
id|A_SETSIGNALSFRX
suffix:semicolon
r_else
id|cmd
op_assign
id|A_SETSIGNALS
suffix:semicolon
id|clear_bit
c_func
(paren
id|ST_DOFLUSHTX
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|ST_DOFLUSHRX
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|ST_DOSIGS
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
(paren
id|cp-&gt;args
(braket
l_int|0
)braket
)paren
comma
(paren
r_void
op_star
)paren
op_amp
id|portp-&gt;asig
comma
r_sizeof
(paren
id|asysigs_t
)paren
)paren
suffix:semicolon
id|cp-&gt;status
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|set_bit
c_func
(paren
id|ST_CMDING
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_DOFLUSHTX
comma
op_amp
id|portp-&gt;state
)paren
op_logical_or
id|test_bit
c_func
(paren
id|ST_DOFLUSHRX
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
id|cmd
op_assign
(paren
(paren
id|test_bit
c_func
(paren
id|ST_DOFLUSHTX
comma
op_amp
id|portp-&gt;state
)paren
)paren
ques
c_cond
id|FLUSHTX
suffix:colon
l_int|0
)paren
suffix:semicolon
id|cmd
op_or_assign
(paren
(paren
id|test_bit
c_func
(paren
id|ST_DOFLUSHRX
comma
op_amp
id|portp-&gt;state
)paren
)paren
ques
c_cond
id|FLUSHRX
suffix:colon
l_int|0
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|ST_DOFLUSHTX
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|ST_DOFLUSHRX
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|memcpy
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
(paren
id|cp-&gt;args
(braket
l_int|0
)braket
)paren
comma
(paren
r_void
op_star
)paren
op_amp
id|cmd
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
id|cp-&gt;status
op_assign
l_int|0
suffix:semicolon
id|cp-&gt;cmd
op_assign
id|A_FLUSH
suffix:semicolon
id|set_bit
c_func
(paren
id|ST_CMDING
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Host command service checking. This handles commands or messages&n; *&t;coming from the slave to the host. Must have board shared memory&n; *&t;enabled and interrupts off when called. Notice that by servicing the&n; *&t;read data last we don&squot;t need to change the shared memory pointer&n; *&t;during processing (which is a slow IO operation).&n; *&t;Return value indicates if this port is still awaiting actions from&n; *&t;the slave (like open, command, or even TX data being sent). If 0&n; *&t;then port is still busy, otherwise no longer busy.&n; */
DECL|function|stli_hostcmd
r_static
r_inline
r_int
id|stli_hostcmd
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
id|stliport_t
op_star
id|portp
)paren
(brace
r_volatile
id|cdkasy_t
op_star
id|ap
suffix:semicolon
r_volatile
id|cdkctrl_t
op_star
id|cp
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|asynotify_t
id|nt
suffix:semicolon
r_int
r_int
id|oldsigs
suffix:semicolon
r_int
id|rc
comma
id|donerx
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_hostcmd(brdp=%x,channr=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
id|channr
)paren
suffix:semicolon
macro_line|#endif
id|ap
op_assign
(paren
r_volatile
id|cdkasy_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;addr
)paren
suffix:semicolon
id|cp
op_assign
op_amp
id|ap-&gt;ctrl
suffix:semicolon
multiline_comment|/*&n; *&t;Check if we are waiting for an open completion message.&n; */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_OPENING
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
id|rc
op_assign
(paren
r_int
)paren
id|cp-&gt;openarg
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cp-&gt;open
op_eq
l_int|0
)paren
op_logical_and
(paren
id|rc
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|rc
OG
l_int|0
)paren
id|rc
op_decrement
suffix:semicolon
id|cp-&gt;openarg
op_assign
l_int|0
suffix:semicolon
id|portp-&gt;rc
op_assign
id|rc
suffix:semicolon
id|clear_bit
c_func
(paren
id|ST_OPENING
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|portp-&gt;raw_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Check if we are waiting for a close completion message.&n; */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_CLOSING
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
id|rc
op_assign
(paren
r_int
)paren
id|cp-&gt;closearg
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cp-&gt;close
op_eq
l_int|0
)paren
op_logical_and
(paren
id|rc
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|rc
OG
l_int|0
)paren
id|rc
op_decrement
suffix:semicolon
id|cp-&gt;closearg
op_assign
l_int|0
suffix:semicolon
id|portp-&gt;rc
op_assign
id|rc
suffix:semicolon
id|clear_bit
c_func
(paren
id|ST_CLOSING
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|portp-&gt;raw_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Check if we are waiting for a command completion message. We may&n; *&t;need to copy out the command results associated with this command.&n; */
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|ST_CMDING
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
id|rc
op_assign
id|cp-&gt;status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cp-&gt;cmd
op_eq
l_int|0
)paren
op_logical_and
(paren
id|rc
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|rc
OG
l_int|0
)paren
id|rc
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;argp
op_ne
(paren
r_void
op_star
)paren
l_int|NULL
)paren
(brace
id|memcpy
c_func
(paren
id|portp-&gt;argp
comma
(paren
r_void
op_star
)paren
op_amp
(paren
id|cp-&gt;args
(braket
l_int|0
)braket
)paren
comma
id|portp-&gt;argsize
)paren
suffix:semicolon
id|portp-&gt;argp
op_assign
(paren
r_void
op_star
)paren
l_int|NULL
suffix:semicolon
)brace
id|cp-&gt;status
op_assign
l_int|0
suffix:semicolon
id|portp-&gt;rc
op_assign
id|rc
suffix:semicolon
id|clear_bit
c_func
(paren
id|ST_CMDING
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|stli_dodelaycmd
c_func
(paren
id|portp
comma
id|cp
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|portp-&gt;raw_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Check for any notification messages ready. This includes lots of&n; *&t;different types of events - RX chars ready, RX break received,&n; *&t;TX data low or empty in the slave, modem signals changed state.&n; */
id|donerx
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ap-&gt;notify
)paren
(brace
id|nt
op_assign
id|ap-&gt;changed
suffix:semicolon
id|ap-&gt;notify
op_assign
l_int|0
suffix:semicolon
id|tty
op_assign
id|portp-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
id|nt.signal
op_amp
id|SG_DCD
)paren
(brace
id|oldsigs
op_assign
id|portp-&gt;sigs
suffix:semicolon
id|portp-&gt;sigs
op_assign
id|stli_mktiocm
c_func
(paren
id|nt.sigvalue
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|ST_GETSIGS
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portp-&gt;sigs
op_amp
id|TIOCM_CD
)paren
op_logical_and
(paren
(paren
id|oldsigs
op_amp
id|TIOCM_CD
)paren
op_eq
l_int|0
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|portp-&gt;open_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|oldsigs
op_amp
id|TIOCM_CD
)paren
op_logical_and
(paren
(paren
id|portp-&gt;sigs
op_amp
id|TIOCM_CD
)paren
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_CHECK_CD
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_CALLOUT_NOHUP
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty
op_ne
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
(brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|schedule_task
c_func
(paren
op_amp
id|portp-&gt;tqhangup
)paren
op_eq
l_int|0
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|nt.data
op_amp
id|DT_TXEMPTY
)paren
id|clear_bit
c_func
(paren
id|ST_TXBUSY
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nt.data
op_amp
(paren
id|DT_TXEMPTY
op_or
id|DT_TXLOW
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty
op_ne
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(brace
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|nt.data
op_amp
id|DT_RXBREAK
)paren
op_logical_and
(paren
id|portp-&gt;rxmarkmsk
op_amp
id|BRKINT
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty
op_ne
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;flip.count
OL
id|TTY_FLIPBUF_SIZE
)paren
(brace
id|tty-&gt;flip.count
op_increment
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_BREAK
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_SAK
)paren
(brace
id|do_SAK
c_func
(paren
id|tty
)paren
suffix:semicolon
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
)brace
id|tty_schedule_flip
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|nt.data
op_amp
id|DT_RXBUSY
)paren
(brace
id|donerx
op_increment
suffix:semicolon
id|stli_read
c_func
(paren
id|brdp
comma
id|portp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;It might seem odd that we are checking for more RX chars here.&n; *&t;But, we need to handle the case where the tty buffer was previously&n; *&t;filled, but we had more characters to pass up. The slave will not&n; *&t;send any more RX notify messages until the RX buffer has been emptied.&n; *&t;But it will leave the service bits on (since the buffer is not empty).&n; *&t;So from here we can try to process more RX chars.&n; */
r_if
c_cond
(paren
(paren
op_logical_neg
id|donerx
)paren
op_logical_and
id|test_bit
c_func
(paren
id|ST_RXING
comma
op_amp
id|portp-&gt;state
)paren
)paren
(brace
id|clear_bit
c_func
(paren
id|ST_RXING
comma
op_amp
id|portp-&gt;state
)paren
suffix:semicolon
id|stli_read
c_func
(paren
id|brdp
comma
id|portp
)paren
suffix:semicolon
)brace
r_return
(paren
id|test_bit
c_func
(paren
id|ST_OPENING
comma
op_amp
id|portp-&gt;state
)paren
op_logical_or
id|test_bit
c_func
(paren
id|ST_CLOSING
comma
op_amp
id|portp-&gt;state
)paren
op_logical_or
id|test_bit
c_func
(paren
id|ST_CMDING
comma
op_amp
id|portp-&gt;state
)paren
op_logical_or
id|test_bit
c_func
(paren
id|ST_TXBUSY
comma
op_amp
id|portp-&gt;state
)paren
op_logical_or
id|test_bit
c_func
(paren
id|ST_RXING
comma
op_amp
id|portp-&gt;state
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Service all ports on a particular board. Assumes that the boards&n; *&t;shared memory is enabled, and that the page pointer is pointed&n; *&t;at the cdk header structure.&n; */
DECL|function|stli_brdpoll
r_static
r_inline
r_void
id|stli_brdpoll
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_volatile
id|cdkhdr_t
op_star
id|hdrp
)paren
(brace
id|stliport_t
op_star
id|portp
suffix:semicolon
r_int
r_char
id|hostbits
(braket
(paren
id|STL_MAXCHANS
op_div
l_int|8
)paren
op_plus
l_int|1
)braket
suffix:semicolon
r_int
r_char
id|slavebits
(braket
(paren
id|STL_MAXCHANS
op_div
l_int|8
)paren
op_plus
l_int|1
)braket
suffix:semicolon
r_int
r_char
op_star
id|slavep
suffix:semicolon
r_int
id|bitpos
comma
id|bitat
comma
id|bitsize
suffix:semicolon
r_int
id|channr
comma
id|nrdevs
comma
id|slavebitchange
suffix:semicolon
id|bitsize
op_assign
id|brdp-&gt;bitsize
suffix:semicolon
id|nrdevs
op_assign
id|brdp-&gt;nrdevs
suffix:semicolon
multiline_comment|/*&n; *&t;Check if slave wants any service. Basically we try to do as&n; *&t;little work as possible here. There are 2 levels of service&n; *&t;bits. So if there is nothing to do we bail early. We check&n; *&t;8 service bits at a time in the inner loop, so we can bypass&n; *&t;the lot if none of them want service.&n; */
id|memcpy
c_func
(paren
op_amp
id|hostbits
(braket
l_int|0
)braket
comma
(paren
(paren
(paren
r_int
r_char
op_star
)paren
id|hdrp
)paren
op_plus
id|brdp-&gt;hostoffset
)paren
comma
id|bitsize
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|slavebits
(braket
l_int|0
)braket
comma
l_int|0
comma
id|bitsize
)paren
suffix:semicolon
id|slavebitchange
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|bitpos
op_assign
l_int|0
suffix:semicolon
(paren
id|bitpos
OL
id|bitsize
)paren
suffix:semicolon
id|bitpos
op_increment
)paren
(brace
r_if
c_cond
(paren
id|hostbits
(braket
id|bitpos
)braket
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|channr
op_assign
id|bitpos
op_star
l_int|8
suffix:semicolon
r_for
c_loop
(paren
id|bitat
op_assign
l_int|0x1
suffix:semicolon
(paren
id|channr
OL
id|nrdevs
)paren
suffix:semicolon
id|channr
op_increment
comma
id|bitat
op_lshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|hostbits
(braket
id|bitpos
)braket
op_amp
id|bitat
)paren
(brace
id|portp
op_assign
id|brdp-&gt;ports
(braket
(paren
id|channr
op_minus
l_int|1
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|stli_hostcmd
c_func
(paren
id|brdp
comma
id|portp
)paren
)paren
(brace
id|slavebitchange
op_increment
suffix:semicolon
id|slavebits
(braket
id|bitpos
)braket
op_or_assign
id|bitat
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; *&t;If any of the ports are no longer busy then update them in the&n; *&t;slave request bits. We need to do this after, since a host port&n; *&t;service may initiate more slave requests.&n; */
r_if
c_cond
(paren
id|slavebitchange
)paren
(brace
id|hdrp
op_assign
(paren
r_volatile
id|cdkhdr_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|CDK_CDKADDR
)paren
suffix:semicolon
id|slavep
op_assign
(paren
(paren
r_int
r_char
op_star
)paren
id|hdrp
)paren
op_plus
id|brdp-&gt;slaveoffset
suffix:semicolon
r_for
c_loop
(paren
id|bitpos
op_assign
l_int|0
suffix:semicolon
(paren
id|bitpos
OL
id|bitsize
)paren
suffix:semicolon
id|bitpos
op_increment
)paren
(brace
r_if
c_cond
(paren
id|slavebits
(braket
id|bitpos
)braket
)paren
id|slavep
(braket
id|bitpos
)braket
op_and_assign
op_complement
id|slavebits
(braket
id|bitpos
)braket
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Driver poll routine. This routine polls the boards in use and passes&n; *&t;messages back up to host when necessary. This is actually very&n; *&t;CPU efficient, since we will always have the kernel poll clock, it&n; *&t;adds only a few cycles when idle (since board service can be&n; *&t;determined very easily), but when loaded generates no interrupts&n; *&t;(with their expensive associated context change).&n; */
DECL|function|stli_poll
r_static
r_void
id|stli_poll
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_volatile
id|cdkhdr_t
op_star
id|hdrp
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
id|brdnr
suffix:semicolon
id|stli_timerlist.expires
op_assign
id|STLI_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|stli_timerlist
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Check each board and do any servicing required.&n; */
r_for
c_loop
(paren
id|brdnr
op_assign
l_int|0
suffix:semicolon
(paren
id|brdnr
OL
id|stli_nrbrds
)paren
suffix:semicolon
id|brdnr
op_increment
)paren
(brace
id|brdp
op_assign
id|stli_brds
(braket
id|brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|brdp-&gt;state
op_amp
id|BST_STARTED
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|hdrp
op_assign
(paren
r_volatile
id|cdkhdr_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|CDK_CDKADDR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hdrp-&gt;hostreq
)paren
id|stli_brdpoll
c_func
(paren
id|brdp
comma
id|hdrp
)paren
suffix:semicolon
id|EBRDDISABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Translate the termios settings into the port setting structure of&n; *&t;the slave.&n; */
DECL|function|stli_mkasyport
r_static
r_void
id|stli_mkasyport
c_func
(paren
id|stliport_t
op_star
id|portp
comma
id|asyport_t
op_star
id|pp
comma
r_struct
id|termios
op_star
id|tiosp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_mkasyport(portp=%x,pp=%x,tiosp=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|portp
comma
(paren
r_int
)paren
id|pp
comma
(paren
r_int
)paren
id|tiosp
)paren
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
id|pp
comma
l_int|0
comma
r_sizeof
(paren
id|asyport_t
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Start of by setting the baud, char size, parity and stop bit info.&n; */
id|pp-&gt;baudout
op_assign
id|tiosp-&gt;c_cflag
op_amp
id|CBAUD
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;baudout
op_amp
id|CBAUDEX
)paren
(brace
id|pp-&gt;baudout
op_and_assign
op_complement
id|CBAUDEX
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pp-&gt;baudout
OL
l_int|1
)paren
op_logical_or
(paren
id|pp-&gt;baudout
OG
l_int|4
)paren
)paren
id|tiosp-&gt;c_cflag
op_and_assign
op_complement
id|CBAUDEX
suffix:semicolon
r_else
id|pp-&gt;baudout
op_add_assign
l_int|15
suffix:semicolon
)brace
id|pp-&gt;baudout
op_assign
id|stli_baudrates
(braket
id|pp-&gt;baudout
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tiosp-&gt;c_cflag
op_amp
id|CBAUD
)paren
op_eq
id|B38400
)paren
(brace
r_if
c_cond
(paren
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_HI
)paren
id|pp-&gt;baudout
op_assign
l_int|57600
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_VHI
)paren
id|pp-&gt;baudout
op_assign
l_int|115200
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_SHI
)paren
id|pp-&gt;baudout
op_assign
l_int|230400
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_WARP
)paren
id|pp-&gt;baudout
op_assign
l_int|460800
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|portp-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_CUST
)paren
id|pp-&gt;baudout
op_assign
(paren
id|portp-&gt;baud_base
op_div
id|portp-&gt;custom_divisor
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pp-&gt;baudout
OG
id|STL_MAXBAUD
)paren
id|pp-&gt;baudout
op_assign
id|STL_MAXBAUD
suffix:semicolon
id|pp-&gt;baudin
op_assign
id|pp-&gt;baudout
suffix:semicolon
r_switch
c_cond
(paren
id|tiosp-&gt;c_cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|pp-&gt;csize
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|pp-&gt;csize
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|pp-&gt;csize
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|pp-&gt;csize
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tiosp-&gt;c_cflag
op_amp
id|CSTOPB
)paren
id|pp-&gt;stopbs
op_assign
id|PT_STOP2
suffix:semicolon
r_else
id|pp-&gt;stopbs
op_assign
id|PT_STOP1
suffix:semicolon
r_if
c_cond
(paren
id|tiosp-&gt;c_cflag
op_amp
id|PARENB
)paren
(brace
r_if
c_cond
(paren
id|tiosp-&gt;c_cflag
op_amp
id|PARODD
)paren
id|pp-&gt;parity
op_assign
id|PT_ODDPARITY
suffix:semicolon
r_else
id|pp-&gt;parity
op_assign
id|PT_EVENPARITY
suffix:semicolon
)brace
r_else
(brace
id|pp-&gt;parity
op_assign
id|PT_NOPARITY
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Set up any flow control options enabled.&n; */
r_if
c_cond
(paren
id|tiosp-&gt;c_iflag
op_amp
id|IXON
)paren
(brace
id|pp-&gt;flow
op_or_assign
id|F_IXON
suffix:semicolon
r_if
c_cond
(paren
id|tiosp-&gt;c_iflag
op_amp
id|IXANY
)paren
id|pp-&gt;flow
op_or_assign
id|F_IXANY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tiosp-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
id|pp-&gt;flow
op_or_assign
(paren
id|F_RTSFLOW
op_or
id|F_CTSFLOW
)paren
suffix:semicolon
id|pp-&gt;startin
op_assign
id|tiosp-&gt;c_cc
(braket
id|VSTART
)braket
suffix:semicolon
id|pp-&gt;stopin
op_assign
id|tiosp-&gt;c_cc
(braket
id|VSTOP
)braket
suffix:semicolon
id|pp-&gt;startout
op_assign
id|tiosp-&gt;c_cc
(braket
id|VSTART
)braket
suffix:semicolon
id|pp-&gt;stopout
op_assign
id|tiosp-&gt;c_cc
(braket
id|VSTOP
)braket
suffix:semicolon
multiline_comment|/*&n; *&t;Set up the RX char marking mask with those RX error types we must&n; *&t;catch. We can get the slave to help us out a little here, it will&n; *&t;ignore parity errors and breaks for us, and mark parity errors in&n; *&t;the data stream.&n; */
r_if
c_cond
(paren
id|tiosp-&gt;c_iflag
op_amp
id|IGNPAR
)paren
id|pp-&gt;iflag
op_or_assign
id|FI_IGNRXERRS
suffix:semicolon
r_if
c_cond
(paren
id|tiosp-&gt;c_iflag
op_amp
id|IGNBRK
)paren
id|pp-&gt;iflag
op_or_assign
id|FI_IGNBREAK
suffix:semicolon
id|portp-&gt;rxmarkmsk
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tiosp-&gt;c_iflag
op_amp
(paren
id|INPCK
op_or
id|PARMRK
)paren
)paren
id|pp-&gt;iflag
op_or_assign
id|FI_1MARKRXERRS
suffix:semicolon
r_if
c_cond
(paren
id|tiosp-&gt;c_iflag
op_amp
id|BRKINT
)paren
id|portp-&gt;rxmarkmsk
op_or_assign
id|BRKINT
suffix:semicolon
multiline_comment|/*&n; *&t;Set up clocal processing as required.&n; */
r_if
c_cond
(paren
id|tiosp-&gt;c_cflag
op_amp
id|CLOCAL
)paren
id|portp-&gt;flags
op_and_assign
op_complement
id|ASYNC_CHECK_CD
suffix:semicolon
r_else
id|portp-&gt;flags
op_or_assign
id|ASYNC_CHECK_CD
suffix:semicolon
multiline_comment|/*&n; *&t;Transfer any persistent flags into the asyport structure.&n; */
id|pp-&gt;pflag
op_assign
(paren
id|portp-&gt;pflag
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|pp-&gt;vmin
op_assign
(paren
id|portp-&gt;pflag
op_amp
id|P_RXIMIN
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|pp-&gt;vtime
op_assign
(paren
id|portp-&gt;pflag
op_amp
id|P_RXITIME
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|pp-&gt;cc
(braket
l_int|1
)braket
op_assign
(paren
id|portp-&gt;pflag
op_amp
id|P_RXTHOLD
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Construct a slave signals structure for setting the DTR and RTS&n; *&t;signals as specified.&n; */
DECL|function|stli_mkasysigs
r_static
r_void
id|stli_mkasysigs
c_func
(paren
id|asysigs_t
op_star
id|sp
comma
r_int
id|dtr
comma
r_int
id|rts
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_mkasysigs(sp=%x,dtr=%d,rts=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|sp
comma
id|dtr
comma
id|rts
)paren
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
id|sp
comma
l_int|0
comma
r_sizeof
(paren
id|asysigs_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dtr
op_ge
l_int|0
)paren
(brace
id|sp-&gt;signal
op_or_assign
id|SG_DTR
suffix:semicolon
id|sp-&gt;sigvalue
op_or_assign
(paren
(paren
id|dtr
OG
l_int|0
)paren
ques
c_cond
id|SG_DTR
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rts
op_ge
l_int|0
)paren
(brace
id|sp-&gt;signal
op_or_assign
id|SG_RTS
suffix:semicolon
id|sp-&gt;sigvalue
op_or_assign
(paren
(paren
id|rts
OG
l_int|0
)paren
ques
c_cond
id|SG_RTS
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Convert the signals returned from the slave into a local TIOCM type&n; *&t;signals value. We keep them locally in TIOCM format.&n; */
DECL|function|stli_mktiocm
r_static
r_int
id|stli_mktiocm
c_func
(paren
r_int
r_int
id|sigvalue
)paren
(brace
r_int
id|tiocm
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_mktiocm(sigvalue=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|sigvalue
)paren
suffix:semicolon
macro_line|#endif
id|tiocm
op_assign
l_int|0
suffix:semicolon
id|tiocm
op_or_assign
(paren
(paren
id|sigvalue
op_amp
id|SG_DCD
)paren
ques
c_cond
id|TIOCM_CD
suffix:colon
l_int|0
)paren
suffix:semicolon
id|tiocm
op_or_assign
(paren
(paren
id|sigvalue
op_amp
id|SG_CTS
)paren
ques
c_cond
id|TIOCM_CTS
suffix:colon
l_int|0
)paren
suffix:semicolon
id|tiocm
op_or_assign
(paren
(paren
id|sigvalue
op_amp
id|SG_RI
)paren
ques
c_cond
id|TIOCM_RI
suffix:colon
l_int|0
)paren
suffix:semicolon
id|tiocm
op_or_assign
(paren
(paren
id|sigvalue
op_amp
id|SG_DSR
)paren
ques
c_cond
id|TIOCM_DSR
suffix:colon
l_int|0
)paren
suffix:semicolon
id|tiocm
op_or_assign
(paren
(paren
id|sigvalue
op_amp
id|SG_DTR
)paren
ques
c_cond
id|TIOCM_DTR
suffix:colon
l_int|0
)paren
suffix:semicolon
id|tiocm
op_or_assign
(paren
(paren
id|sigvalue
op_amp
id|SG_RTS
)paren
ques
c_cond
id|TIOCM_RTS
suffix:colon
l_int|0
)paren
suffix:semicolon
r_return
id|tiocm
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;All panels and ports actually attached have been worked out. All&n; *&t;we need to do here is set up the appropriate per port data structures.&n; */
DECL|function|stli_initports
r_static
r_inline
r_int
id|stli_initports
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
id|stliport_t
op_star
id|portp
suffix:semicolon
r_int
id|i
comma
id|panelnr
comma
id|panelport
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_initports(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|panelnr
op_assign
l_int|0
comma
id|panelport
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|brdp-&gt;nrports
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|portp
op_assign
(paren
id|stliport_t
op_star
)paren
id|stli_memalloc
c_func
(paren
r_sizeof
(paren
id|stliport_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: failed to allocate port structure&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|memset
c_func
(paren
id|portp
comma
l_int|0
comma
r_sizeof
(paren
id|stliport_t
)paren
)paren
suffix:semicolon
id|portp-&gt;magic
op_assign
id|STLI_PORTMAGIC
suffix:semicolon
id|portp-&gt;portnr
op_assign
id|i
suffix:semicolon
id|portp-&gt;brdnr
op_assign
id|brdp-&gt;brdnr
suffix:semicolon
id|portp-&gt;panelnr
op_assign
id|panelnr
suffix:semicolon
id|portp-&gt;baud_base
op_assign
id|STL_BAUDBASE
suffix:semicolon
id|portp-&gt;close_delay
op_assign
id|STL_CLOSEDELAY
suffix:semicolon
id|portp-&gt;closing_wait
op_assign
l_int|30
op_star
id|HZ
suffix:semicolon
id|portp-&gt;tqhangup.routine
op_assign
id|stli_dohangup
suffix:semicolon
id|portp-&gt;tqhangup.data
op_assign
id|portp
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|portp-&gt;open_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|portp-&gt;close_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|portp-&gt;raw_wait
)paren
suffix:semicolon
id|portp-&gt;normaltermios
op_assign
id|stli_deftermios
suffix:semicolon
id|portp-&gt;callouttermios
op_assign
id|stli_deftermios
suffix:semicolon
id|panelport
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|panelport
op_ge
id|brdp-&gt;panels
(braket
id|panelnr
)braket
)paren
(brace
id|panelport
op_assign
l_int|0
suffix:semicolon
id|panelnr
op_increment
suffix:semicolon
)brace
id|brdp-&gt;ports
(braket
id|i
)braket
op_assign
id|portp
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;All the following routines are board specific hardware operations.&n; */
DECL|function|stli_ecpinit
r_static
r_void
id|stli_ecpinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
r_int
r_int
id|memconf
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_ecpinit(brdp=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|ECP_ATSTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_ATCONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ECP_ATDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_ATCONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|memconf
op_assign
(paren
id|brdp-&gt;memaddr
op_amp
id|ECP_ATADDRMASK
)paren
op_rshift
id|ECP_ATADDRSHFT
suffix:semicolon
id|outb
c_func
(paren
id|memconf
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_ATMEMAR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ecpenable
r_static
r_void
id|stli_ecpenable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_ecpenable(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|ECP_ATENABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_ATCONFR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ecpdisable
r_static
r_void
id|stli_ecpdisable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_ecpdisable(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|ECP_ATDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_ATCONFR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ecpgetmemptr
r_static
r_char
op_star
id|stli_ecpgetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
(brace
r_void
op_star
id|ptr
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_ecpgetmemptr(brdp=%x,offset=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
(paren
r_int
)paren
id|offset
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|offset
OG
id|brdp-&gt;memsize
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: shared memory pointer=%x out of range at &quot;
l_string|&quot;line=%d(%d), brd=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|offset
comma
id|line
comma
id|__LINE__
comma
id|brdp-&gt;brdnr
)paren
suffix:semicolon
id|ptr
op_assign
l_int|0
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
id|brdp-&gt;membase
op_plus
(paren
id|offset
op_mod
id|ECP_ATPAGESIZE
)paren
suffix:semicolon
id|val
op_assign
(paren
r_int
r_char
)paren
(paren
id|offset
op_div
id|ECP_ATPAGESIZE
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|val
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_ATMEMPR
)paren
)paren
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ecpreset
r_static
r_void
id|stli_ecpreset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_ecpreset(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|ECP_ATSTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_ATCONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ECP_ATDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_ATCONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ecpintr
r_static
r_void
id|stli_ecpintr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_ecpintr(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|0x1
comma
id|brdp-&gt;iobase
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;The following set of functions act on ECP EISA boards.&n; */
DECL|function|stli_ecpeiinit
r_static
r_void
id|stli_ecpeiinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
r_int
r_int
id|memconf
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_ecpeiinit(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|0x1
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_EIBRDENAB
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ECP_EISTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_EICONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ECP_EIDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_EICONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
id|memconf
op_assign
(paren
id|brdp-&gt;memaddr
op_amp
id|ECP_EIADDRMASKL
)paren
op_rshift
id|ECP_EIADDRSHFTL
suffix:semicolon
id|outb
c_func
(paren
id|memconf
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_EIMEMARL
)paren
)paren
suffix:semicolon
id|memconf
op_assign
(paren
id|brdp-&gt;memaddr
op_amp
id|ECP_EIADDRMASKH
)paren
op_rshift
id|ECP_EIADDRSHFTH
suffix:semicolon
id|outb
c_func
(paren
id|memconf
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_EIMEMARH
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ecpeienable
r_static
r_void
id|stli_ecpeienable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
id|outb
c_func
(paren
id|ECP_EIENABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_EICONFR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ecpeidisable
r_static
r_void
id|stli_ecpeidisable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
id|outb
c_func
(paren
id|ECP_EIDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_EICONFR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ecpeigetmemptr
r_static
r_char
op_star
id|stli_ecpeigetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
(brace
r_void
op_star
id|ptr
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_ecpeigetmemptr(brdp=%x,offset=%x,line=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
(paren
r_int
)paren
id|offset
comma
id|line
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|offset
OG
id|brdp-&gt;memsize
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: shared memory pointer=%x out of range at &quot;
l_string|&quot;line=%d(%d), brd=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|offset
comma
id|line
comma
id|__LINE__
comma
id|brdp-&gt;brdnr
)paren
suffix:semicolon
id|ptr
op_assign
l_int|0
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
id|brdp-&gt;membase
op_plus
(paren
id|offset
op_mod
id|ECP_EIPAGESIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
id|ECP_EIPAGESIZE
)paren
id|val
op_assign
id|ECP_EIENABLE
suffix:semicolon
r_else
id|val
op_assign
id|ECP_EIENABLE
op_or
l_int|0x40
suffix:semicolon
)brace
id|outb
c_func
(paren
id|val
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_EICONFR
)paren
)paren
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ecpeireset
r_static
r_void
id|stli_ecpeireset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
id|outb
c_func
(paren
id|ECP_EISTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_EICONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ECP_EIDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_EICONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;The following set of functions act on ECP MCA boards.&n; */
DECL|function|stli_ecpmcenable
r_static
r_void
id|stli_ecpmcenable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
id|outb
c_func
(paren
id|ECP_MCENABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_MCCONFR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ecpmcdisable
r_static
r_void
id|stli_ecpmcdisable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
id|outb
c_func
(paren
id|ECP_MCDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_MCCONFR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ecpmcgetmemptr
r_static
r_char
op_star
id|stli_ecpmcgetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
(brace
r_void
op_star
id|ptr
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
r_if
c_cond
(paren
id|offset
OG
id|brdp-&gt;memsize
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: shared memory pointer=%x out of range at &quot;
l_string|&quot;line=%d(%d), brd=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|offset
comma
id|line
comma
id|__LINE__
comma
id|brdp-&gt;brdnr
)paren
suffix:semicolon
id|ptr
op_assign
l_int|0
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
id|brdp-&gt;membase
op_plus
(paren
id|offset
op_mod
id|ECP_MCPAGESIZE
)paren
suffix:semicolon
id|val
op_assign
(paren
(paren
r_int
r_char
)paren
(paren
id|offset
op_div
id|ECP_MCPAGESIZE
)paren
)paren
op_or
id|ECP_MCENABLE
suffix:semicolon
)brace
id|outb
c_func
(paren
id|val
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_MCCONFR
)paren
)paren
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ecpmcreset
r_static
r_void
id|stli_ecpmcreset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
id|outb
c_func
(paren
id|ECP_MCSTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_MCCONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ECP_MCDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_MCCONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;The following set of functions act on ECP PCI boards.&n; */
DECL|function|stli_ecppciinit
r_static
r_void
id|stli_ecppciinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_ecppciinit(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|ECP_PCISTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_PCICONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_PCICONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ecppcigetmemptr
r_static
r_char
op_star
id|stli_ecppcigetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
(brace
r_void
op_star
id|ptr
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_ecppcigetmemptr(brdp=%x,offset=%x,line=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
(paren
r_int
)paren
id|offset
comma
id|line
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|offset
OG
id|brdp-&gt;memsize
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: shared memory pointer=%x out of range at &quot;
l_string|&quot;line=%d(%d), board=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|offset
comma
id|line
comma
id|__LINE__
comma
id|brdp-&gt;brdnr
)paren
suffix:semicolon
id|ptr
op_assign
l_int|0
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
id|brdp-&gt;membase
op_plus
(paren
id|offset
op_mod
id|ECP_PCIPAGESIZE
)paren
suffix:semicolon
id|val
op_assign
(paren
id|offset
op_div
id|ECP_PCIPAGESIZE
)paren
op_lshift
l_int|1
suffix:semicolon
)brace
id|outb
c_func
(paren
id|val
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_PCICONFR
)paren
)paren
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_ecppcireset
r_static
r_void
id|stli_ecppcireset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
id|outb
c_func
(paren
id|ECP_PCISTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_PCICONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_PCICONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;The following routines act on ONboards.&n; */
DECL|function|stli_onbinit
r_static
r_void
id|stli_onbinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
r_int
r_int
id|memconf
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_onbinit(brdp=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|ONB_ATSTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_ATCONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ONB_ATDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_ATCONFR
)paren
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|memconf
op_assign
(paren
id|brdp-&gt;memaddr
op_amp
id|ONB_ATADDRMASK
)paren
op_rshift
id|ONB_ATADDRSHFT
suffix:semicolon
id|outb
c_func
(paren
id|memconf
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_ATMEMAR
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x1
comma
id|brdp-&gt;iobase
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_onbenable
r_static
r_void
id|stli_onbenable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_onbenable(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
(paren
id|brdp-&gt;enabval
op_or
id|ONB_ATENABLE
)paren
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_ATCONFR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_onbdisable
r_static
r_void
id|stli_onbdisable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_onbdisable(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
(paren
id|brdp-&gt;enabval
op_or
id|ONB_ATDISABLE
)paren
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_ATCONFR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_onbgetmemptr
r_static
r_char
op_star
id|stli_onbgetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
(brace
r_void
op_star
id|ptr
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_onbgetmemptr(brdp=%x,offset=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
(paren
r_int
)paren
id|offset
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|offset
OG
id|brdp-&gt;memsize
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: shared memory pointer=%x out of range at &quot;
l_string|&quot;line=%d(%d), brd=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|offset
comma
id|line
comma
id|__LINE__
comma
id|brdp-&gt;brdnr
)paren
suffix:semicolon
id|ptr
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
id|brdp-&gt;membase
op_plus
(paren
id|offset
op_mod
id|ONB_ATPAGESIZE
)paren
suffix:semicolon
)brace
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_onbreset
r_static
r_void
id|stli_onbreset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_onbreset(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|ONB_ATSTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_ATCONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ONB_ATDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_ATCONFR
)paren
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;The following routines act on ONboard EISA.&n; */
DECL|function|stli_onbeinit
r_static
r_void
id|stli_onbeinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
r_int
r_int
id|memconf
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_onbeinit(brdp=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|0x1
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_EIBRDENAB
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ONB_EISTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_EICONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ONB_EIDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_EICONFR
)paren
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|memconf
op_assign
(paren
id|brdp-&gt;memaddr
op_amp
id|ONB_EIADDRMASKL
)paren
op_rshift
id|ONB_EIADDRSHFTL
suffix:semicolon
id|outb
c_func
(paren
id|memconf
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_EIMEMARL
)paren
)paren
suffix:semicolon
id|memconf
op_assign
(paren
id|brdp-&gt;memaddr
op_amp
id|ONB_EIADDRMASKH
)paren
op_rshift
id|ONB_EIADDRSHFTH
suffix:semicolon
id|outb
c_func
(paren
id|memconf
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_EIMEMARH
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x1
comma
id|brdp-&gt;iobase
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_onbeenable
r_static
r_void
id|stli_onbeenable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_onbeenable(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|ONB_EIENABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_EICONFR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_onbedisable
r_static
r_void
id|stli_onbedisable
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_onbedisable(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|ONB_EIDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_EICONFR
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_onbegetmemptr
r_static
r_char
op_star
id|stli_onbegetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
(brace
r_void
op_star
id|ptr
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_onbegetmemptr(brdp=%x,offset=%x,line=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
(paren
r_int
)paren
id|offset
comma
id|line
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|offset
OG
id|brdp-&gt;memsize
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: shared memory pointer=%x out of range at &quot;
l_string|&quot;line=%d(%d), brd=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|offset
comma
id|line
comma
id|__LINE__
comma
id|brdp-&gt;brdnr
)paren
suffix:semicolon
id|ptr
op_assign
l_int|0
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
id|brdp-&gt;membase
op_plus
(paren
id|offset
op_mod
id|ONB_EIPAGESIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
OL
id|ONB_EIPAGESIZE
)paren
id|val
op_assign
id|ONB_EIENABLE
suffix:semicolon
r_else
id|val
op_assign
id|ONB_EIENABLE
op_or
l_int|0x40
suffix:semicolon
)brace
id|outb
c_func
(paren
id|val
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_EICONFR
)paren
)paren
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_onbereset
r_static
r_void
id|stli_onbereset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_onbereset(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|ONB_EISTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_EICONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ONB_EIDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_EICONFR
)paren
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;The following routines act on Brumby boards.&n; */
DECL|function|stli_bbyinit
r_static
r_void
id|stli_bbyinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_bbyinit(brdp=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|BBY_ATSTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|BBY_ATCONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
(paren
id|brdp-&gt;iobase
op_plus
id|BBY_ATCONFR
)paren
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x1
comma
id|brdp-&gt;iobase
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_bbygetmemptr
r_static
r_char
op_star
id|stli_bbygetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
(brace
r_void
op_star
id|ptr
suffix:semicolon
r_int
r_char
id|val
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_bbygetmemptr(brdp=%x,offset=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
(paren
r_int
)paren
id|offset
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|offset
OG
id|brdp-&gt;memsize
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: shared memory pointer=%x out of range at &quot;
l_string|&quot;line=%d(%d), brd=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|offset
comma
id|line
comma
id|__LINE__
comma
id|brdp-&gt;brdnr
)paren
suffix:semicolon
id|ptr
op_assign
l_int|0
suffix:semicolon
id|val
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
id|brdp-&gt;membase
op_plus
(paren
id|offset
op_mod
id|BBY_PAGESIZE
)paren
suffix:semicolon
id|val
op_assign
(paren
r_int
r_char
)paren
(paren
id|offset
op_div
id|BBY_PAGESIZE
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|val
comma
(paren
id|brdp-&gt;iobase
op_plus
id|BBY_ATCONFR
)paren
)paren
suffix:semicolon
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_bbyreset
r_static
r_void
id|stli_bbyreset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_bbyreset(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|BBY_ATSTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|BBY_ATCONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
(paren
id|brdp-&gt;iobase
op_plus
id|BBY_ATCONFR
)paren
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;The following routines act on original old Stallion boards.&n; */
DECL|function|stli_stalinit
r_static
r_void
id|stli_stalinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_stalinit(brdp=%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
l_int|0x1
comma
id|brdp-&gt;iobase
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_stalgetmemptr
r_static
r_char
op_star
id|stli_stalgetmemptr
c_func
(paren
id|stlibrd_t
op_star
id|brdp
comma
r_int
r_int
id|offset
comma
r_int
id|line
)paren
(brace
r_void
op_star
id|ptr
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_stalgetmemptr(brdp=%x,offset=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
comma
(paren
r_int
)paren
id|offset
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|offset
OG
id|brdp-&gt;memsize
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: shared memory pointer=%x out of range at &quot;
l_string|&quot;line=%d(%d), brd=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|offset
comma
id|line
comma
id|__LINE__
comma
id|brdp-&gt;brdnr
)paren
suffix:semicolon
id|ptr
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|ptr
op_assign
id|brdp-&gt;membase
op_plus
(paren
id|offset
op_mod
id|STAL_PAGESIZE
)paren
suffix:semicolon
)brace
r_return
id|ptr
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_stalreset
r_static
r_void
id|stli_stalreset
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
r_volatile
r_int
r_int
op_star
id|vecp
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_stalreset(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|vecp
op_assign
(paren
r_volatile
r_int
r_int
op_star
)paren
(paren
id|brdp-&gt;membase
op_plus
l_int|0x30
)paren
suffix:semicolon
op_star
id|vecp
op_assign
l_int|0xffff0000
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|brdp-&gt;iobase
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Try to find an ECP board and initialize it. This handles only ECP&n; *&t;board types.&n; */
DECL|function|stli_initecp
r_static
r_inline
r_int
id|stli_initecp
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
id|cdkecpsig_t
id|sig
suffix:semicolon
id|cdkecpsig_t
op_star
id|sigsp
suffix:semicolon
r_int
r_int
id|status
comma
id|nxtid
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_int
id|panelnr
comma
id|nrports
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_initecp(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;Do a basic sanity check on the IO and memory addresses.&n; */
r_if
c_cond
(paren
(paren
id|brdp-&gt;iobase
op_eq
l_int|0
)paren
op_logical_or
(paren
id|brdp-&gt;memaddr
op_eq
l_int|0
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|brdp-&gt;iosize
op_assign
id|ECP_IOSIZE
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|brdp-&gt;iobase
comma
id|brdp-&gt;iosize
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;STALLION: Warning, board %d I/O address %x conflicts &quot;
l_string|&quot;with another device&bslash;n&quot;
comma
id|brdp-&gt;brdnr
comma
id|brdp-&gt;iobase
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Based on the specific board type setup the common vars to access&n; *&t;and enable shared memory. Set all board specific information now&n; *&t;as well.&n; */
r_switch
c_cond
(paren
id|brdp-&gt;brdtype
)paren
(brace
r_case
id|BRD_ECP
suffix:colon
id|brdp-&gt;membase
op_assign
(paren
r_void
op_star
)paren
id|brdp-&gt;memaddr
suffix:semicolon
id|brdp-&gt;memsize
op_assign
id|ECP_MEMSIZE
suffix:semicolon
id|brdp-&gt;pagesize
op_assign
id|ECP_ATPAGESIZE
suffix:semicolon
id|brdp-&gt;init
op_assign
id|stli_ecpinit
suffix:semicolon
id|brdp-&gt;enable
op_assign
id|stli_ecpenable
suffix:semicolon
id|brdp-&gt;reenable
op_assign
id|stli_ecpenable
suffix:semicolon
id|brdp-&gt;disable
op_assign
id|stli_ecpdisable
suffix:semicolon
id|brdp-&gt;getmemptr
op_assign
id|stli_ecpgetmemptr
suffix:semicolon
id|brdp-&gt;intr
op_assign
id|stli_ecpintr
suffix:semicolon
id|brdp-&gt;reset
op_assign
id|stli_ecpreset
suffix:semicolon
id|name
op_assign
l_string|&quot;serial(EC8/64)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRD_ECPE
suffix:colon
id|brdp-&gt;membase
op_assign
(paren
r_void
op_star
)paren
id|brdp-&gt;memaddr
suffix:semicolon
id|brdp-&gt;memsize
op_assign
id|ECP_MEMSIZE
suffix:semicolon
id|brdp-&gt;pagesize
op_assign
id|ECP_EIPAGESIZE
suffix:semicolon
id|brdp-&gt;init
op_assign
id|stli_ecpeiinit
suffix:semicolon
id|brdp-&gt;enable
op_assign
id|stli_ecpeienable
suffix:semicolon
id|brdp-&gt;reenable
op_assign
id|stli_ecpeienable
suffix:semicolon
id|brdp-&gt;disable
op_assign
id|stli_ecpeidisable
suffix:semicolon
id|brdp-&gt;getmemptr
op_assign
id|stli_ecpeigetmemptr
suffix:semicolon
id|brdp-&gt;intr
op_assign
id|stli_ecpintr
suffix:semicolon
id|brdp-&gt;reset
op_assign
id|stli_ecpeireset
suffix:semicolon
id|name
op_assign
l_string|&quot;serial(EC8/64-EI)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRD_ECPMC
suffix:colon
id|brdp-&gt;membase
op_assign
(paren
r_void
op_star
)paren
id|brdp-&gt;memaddr
suffix:semicolon
id|brdp-&gt;memsize
op_assign
id|ECP_MEMSIZE
suffix:semicolon
id|brdp-&gt;pagesize
op_assign
id|ECP_MCPAGESIZE
suffix:semicolon
id|brdp-&gt;init
op_assign
l_int|NULL
suffix:semicolon
id|brdp-&gt;enable
op_assign
id|stli_ecpmcenable
suffix:semicolon
id|brdp-&gt;reenable
op_assign
id|stli_ecpmcenable
suffix:semicolon
id|brdp-&gt;disable
op_assign
id|stli_ecpmcdisable
suffix:semicolon
id|brdp-&gt;getmemptr
op_assign
id|stli_ecpmcgetmemptr
suffix:semicolon
id|brdp-&gt;intr
op_assign
id|stli_ecpintr
suffix:semicolon
id|brdp-&gt;reset
op_assign
id|stli_ecpmcreset
suffix:semicolon
id|name
op_assign
l_string|&quot;serial(EC8/64-MCA)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRD_ECPPCI
suffix:colon
id|brdp-&gt;membase
op_assign
(paren
r_void
op_star
)paren
id|brdp-&gt;memaddr
suffix:semicolon
id|brdp-&gt;memsize
op_assign
id|ECP_PCIMEMSIZE
suffix:semicolon
id|brdp-&gt;pagesize
op_assign
id|ECP_PCIPAGESIZE
suffix:semicolon
id|brdp-&gt;init
op_assign
id|stli_ecppciinit
suffix:semicolon
id|brdp-&gt;enable
op_assign
l_int|NULL
suffix:semicolon
id|brdp-&gt;reenable
op_assign
l_int|NULL
suffix:semicolon
id|brdp-&gt;disable
op_assign
l_int|NULL
suffix:semicolon
id|brdp-&gt;getmemptr
op_assign
id|stli_ecppcigetmemptr
suffix:semicolon
id|brdp-&gt;intr
op_assign
id|stli_ecpintr
suffix:semicolon
id|brdp-&gt;reset
op_assign
id|stli_ecppcireset
suffix:semicolon
id|name
op_assign
l_string|&quot;serial(EC/RA-PCI)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The per-board operations structure is all set up, so now let&squot;s go&n; *&t;and get the board operational. Firstly initialize board configuration&n; *&t;registers. Set the memory mapping info so we can get at the boards&n; *&t;shared memory.&n; */
id|EBRDINIT
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|brdp-&gt;membase
op_assign
id|ioremap
c_func
(paren
id|brdp-&gt;memaddr
comma
id|brdp-&gt;memsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;membase
op_eq
(paren
r_void
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*&n; *&t;Now that all specific code is set up, enable the shared memory and&n; *&t;look for the a signature area that will tell us exactly what board&n; *&t;this is, and what it is connected to it.&n; */
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|sigsp
op_assign
(paren
id|cdkecpsig_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|CDK_SIGADDR
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sig
comma
id|sigsp
comma
r_sizeof
(paren
id|cdkecpsig_t
)paren
)paren
suffix:semicolon
id|EBRDDISABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;%s(%d): sig-&gt; magic=%x rom=%x panel=%x,%x,%x,%x,%x,%x,%x,%x&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
(paren
r_int
)paren
id|sig.magic
comma
id|sig.romver
comma
id|sig.panelid
(braket
l_int|0
)braket
comma
(paren
r_int
)paren
id|sig.panelid
(braket
l_int|1
)braket
comma
(paren
r_int
)paren
id|sig.panelid
(braket
l_int|2
)braket
comma
(paren
r_int
)paren
id|sig.panelid
(braket
l_int|3
)braket
comma
(paren
r_int
)paren
id|sig.panelid
(braket
l_int|4
)braket
comma
(paren
r_int
)paren
id|sig.panelid
(braket
l_int|5
)braket
comma
(paren
r_int
)paren
id|sig.panelid
(braket
l_int|6
)braket
comma
(paren
r_int
)paren
id|sig.panelid
(braket
l_int|7
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sig.magic
op_ne
id|ECP_MAGIC
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n; *&t;Scan through the signature looking at the panels connected to the&n; *&t;board. Calculate the total number of ports as we go.&n; */
r_for
c_loop
(paren
id|panelnr
op_assign
l_int|0
comma
id|nxtid
op_assign
l_int|0
suffix:semicolon
(paren
id|panelnr
OL
id|STL_MAXPANELS
)paren
suffix:semicolon
id|panelnr
op_increment
)paren
(brace
id|status
op_assign
id|sig.panelid
(braket
id|nxtid
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|ECH_PNLIDMASK
)paren
op_ne
id|nxtid
)paren
r_break
suffix:semicolon
id|brdp-&gt;panelids
(braket
id|panelnr
)braket
op_assign
id|status
suffix:semicolon
id|nrports
op_assign
(paren
id|status
op_amp
id|ECH_PNL16PORT
)paren
ques
c_cond
l_int|16
suffix:colon
l_int|8
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nrports
op_eq
l_int|16
)paren
op_logical_and
(paren
(paren
id|status
op_amp
id|ECH_PNLXPID
)paren
op_eq
l_int|0
)paren
)paren
id|nxtid
op_increment
suffix:semicolon
id|brdp-&gt;panels
(braket
id|panelnr
)braket
op_assign
id|nrports
suffix:semicolon
id|brdp-&gt;nrports
op_add_assign
id|nrports
suffix:semicolon
id|nxtid
op_increment
suffix:semicolon
id|brdp-&gt;nrpanels
op_increment
suffix:semicolon
)brace
id|request_region
c_func
(paren
id|brdp-&gt;iobase
comma
id|brdp-&gt;iosize
comma
id|name
)paren
suffix:semicolon
id|brdp-&gt;state
op_or_assign
id|BST_FOUND
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Try to find an ONboard, Brumby or Stallion board and initialize it.&n; *&t;This handles only these board types.&n; */
DECL|function|stli_initonb
r_static
r_inline
r_int
id|stli_initonb
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
id|cdkonbsig_t
id|sig
suffix:semicolon
id|cdkonbsig_t
op_star
id|sigsp
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_initonb(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;Do a basic sanity check on the IO and memory addresses.&n; */
r_if
c_cond
(paren
(paren
id|brdp-&gt;iobase
op_eq
l_int|0
)paren
op_logical_or
(paren
id|brdp-&gt;memaddr
op_eq
l_int|0
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|brdp-&gt;iosize
op_assign
id|ONB_IOSIZE
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|brdp-&gt;iobase
comma
id|brdp-&gt;iosize
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;STALLION: Warning, board %d I/O address %x conflicts &quot;
l_string|&quot;with another device&bslash;n&quot;
comma
id|brdp-&gt;brdnr
comma
id|brdp-&gt;iobase
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Based on the specific board type setup the common vars to access&n; *&t;and enable shared memory. Set all board specific information now&n; *&t;as well.&n; */
r_switch
c_cond
(paren
id|brdp-&gt;brdtype
)paren
(brace
r_case
id|BRD_ONBOARD
suffix:colon
r_case
id|BRD_ONBOARD32
suffix:colon
r_case
id|BRD_ONBOARD2
suffix:colon
r_case
id|BRD_ONBOARD2_32
suffix:colon
r_case
id|BRD_ONBOARDRS
suffix:colon
id|brdp-&gt;membase
op_assign
(paren
r_void
op_star
)paren
id|brdp-&gt;memaddr
suffix:semicolon
id|brdp-&gt;memsize
op_assign
id|ONB_MEMSIZE
suffix:semicolon
id|brdp-&gt;pagesize
op_assign
id|ONB_ATPAGESIZE
suffix:semicolon
id|brdp-&gt;init
op_assign
id|stli_onbinit
suffix:semicolon
id|brdp-&gt;enable
op_assign
id|stli_onbenable
suffix:semicolon
id|brdp-&gt;reenable
op_assign
id|stli_onbenable
suffix:semicolon
id|brdp-&gt;disable
op_assign
id|stli_onbdisable
suffix:semicolon
id|brdp-&gt;getmemptr
op_assign
id|stli_onbgetmemptr
suffix:semicolon
id|brdp-&gt;intr
op_assign
id|stli_ecpintr
suffix:semicolon
id|brdp-&gt;reset
op_assign
id|stli_onbreset
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;memaddr
OG
l_int|0x100000
)paren
id|brdp-&gt;enabval
op_assign
id|ONB_MEMENABHI
suffix:semicolon
r_else
id|brdp-&gt;enabval
op_assign
id|ONB_MEMENABLO
suffix:semicolon
id|name
op_assign
l_string|&quot;serial(ONBoard)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRD_ONBOARDE
suffix:colon
id|brdp-&gt;membase
op_assign
(paren
r_void
op_star
)paren
id|brdp-&gt;memaddr
suffix:semicolon
id|brdp-&gt;memsize
op_assign
id|ONB_EIMEMSIZE
suffix:semicolon
id|brdp-&gt;pagesize
op_assign
id|ONB_EIPAGESIZE
suffix:semicolon
id|brdp-&gt;init
op_assign
id|stli_onbeinit
suffix:semicolon
id|brdp-&gt;enable
op_assign
id|stli_onbeenable
suffix:semicolon
id|brdp-&gt;reenable
op_assign
id|stli_onbeenable
suffix:semicolon
id|brdp-&gt;disable
op_assign
id|stli_onbedisable
suffix:semicolon
id|brdp-&gt;getmemptr
op_assign
id|stli_onbegetmemptr
suffix:semicolon
id|brdp-&gt;intr
op_assign
id|stli_ecpintr
suffix:semicolon
id|brdp-&gt;reset
op_assign
id|stli_onbereset
suffix:semicolon
id|name
op_assign
l_string|&quot;serial(ONBoard/E)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRD_BRUMBY4
suffix:colon
r_case
id|BRD_BRUMBY8
suffix:colon
r_case
id|BRD_BRUMBY16
suffix:colon
id|brdp-&gt;membase
op_assign
(paren
r_void
op_star
)paren
id|brdp-&gt;memaddr
suffix:semicolon
id|brdp-&gt;memsize
op_assign
id|BBY_MEMSIZE
suffix:semicolon
id|brdp-&gt;pagesize
op_assign
id|BBY_PAGESIZE
suffix:semicolon
id|brdp-&gt;init
op_assign
id|stli_bbyinit
suffix:semicolon
id|brdp-&gt;enable
op_assign
l_int|NULL
suffix:semicolon
id|brdp-&gt;reenable
op_assign
l_int|NULL
suffix:semicolon
id|brdp-&gt;disable
op_assign
l_int|NULL
suffix:semicolon
id|brdp-&gt;getmemptr
op_assign
id|stli_bbygetmemptr
suffix:semicolon
id|brdp-&gt;intr
op_assign
id|stli_ecpintr
suffix:semicolon
id|brdp-&gt;reset
op_assign
id|stli_bbyreset
suffix:semicolon
id|name
op_assign
l_string|&quot;serial(Brumby)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRD_STALLION
suffix:colon
id|brdp-&gt;membase
op_assign
(paren
r_void
op_star
)paren
id|brdp-&gt;memaddr
suffix:semicolon
id|brdp-&gt;memsize
op_assign
id|STAL_MEMSIZE
suffix:semicolon
id|brdp-&gt;pagesize
op_assign
id|STAL_PAGESIZE
suffix:semicolon
id|brdp-&gt;init
op_assign
id|stli_stalinit
suffix:semicolon
id|brdp-&gt;enable
op_assign
l_int|NULL
suffix:semicolon
id|brdp-&gt;reenable
op_assign
l_int|NULL
suffix:semicolon
id|brdp-&gt;disable
op_assign
l_int|NULL
suffix:semicolon
id|brdp-&gt;getmemptr
op_assign
id|stli_stalgetmemptr
suffix:semicolon
id|brdp-&gt;intr
op_assign
id|stli_ecpintr
suffix:semicolon
id|brdp-&gt;reset
op_assign
id|stli_stalreset
suffix:semicolon
id|name
op_assign
l_string|&quot;serial(Stallion)&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;The per-board operations structure is all set up, so now let&squot;s go&n; *&t;and get the board operational. Firstly initialize board configuration&n; *&t;registers. Set the memory mapping info so we can get at the boards&n; *&t;shared memory.&n; */
id|EBRDINIT
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|brdp-&gt;membase
op_assign
id|ioremap
c_func
(paren
id|brdp-&gt;memaddr
comma
id|brdp-&gt;memsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;membase
op_eq
(paren
r_void
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*&n; *&t;Now that all specific code is set up, enable the shared memory and&n; *&t;look for the a signature area that will tell us exactly what board&n; *&t;this is, and how many ports.&n; */
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|sigsp
op_assign
(paren
id|cdkonbsig_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|CDK_SIGADDR
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|sig
comma
id|sigsp
comma
r_sizeof
(paren
id|cdkonbsig_t
)paren
)paren
suffix:semicolon
id|EBRDDISABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;%s(%d): sig-&gt; magic=%x:%x:%x:%x romver=%x amask=%x:%x:%x&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|sig.magic0
comma
id|sig.magic1
comma
id|sig.magic2
comma
id|sig.magic3
comma
id|sig.romver
comma
id|sig.amask0
comma
id|sig.amask1
comma
id|sig.amask2
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|sig.magic0
op_ne
id|ONB_MAGIC0
)paren
op_logical_or
(paren
id|sig.magic1
op_ne
id|ONB_MAGIC1
)paren
op_logical_or
(paren
id|sig.magic2
op_ne
id|ONB_MAGIC2
)paren
op_logical_or
(paren
id|sig.magic3
op_ne
id|ONB_MAGIC3
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n; *&t;Scan through the signature alive mask and calculate how many ports&n; *&t;there are on this board.&n; */
id|brdp-&gt;nrpanels
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sig.amask1
)paren
(brace
id|brdp-&gt;nrports
op_assign
l_int|32
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
l_int|16
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|sig.amask0
op_lshift
id|i
)paren
op_amp
l_int|0x8000
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|brdp-&gt;nrports
op_assign
id|i
suffix:semicolon
)brace
id|brdp-&gt;panels
(braket
l_int|0
)braket
op_assign
id|brdp-&gt;nrports
suffix:semicolon
id|request_region
c_func
(paren
id|brdp-&gt;iobase
comma
id|brdp-&gt;iosize
comma
id|name
)paren
suffix:semicolon
id|brdp-&gt;state
op_or_assign
id|BST_FOUND
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Start up a running board. This routine is only called after the&n; *&t;code has been down loaded to the board and is operational. It will&n; *&t;read in the memory map, and get the show on the road...&n; */
DECL|function|stli_startbrd
r_static
r_int
id|stli_startbrd
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
r_volatile
id|cdkhdr_t
op_star
id|hdrp
suffix:semicolon
r_volatile
id|cdkmem_t
op_star
id|memp
suffix:semicolon
r_volatile
id|cdkasy_t
op_star
id|ap
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|stliport_t
op_star
id|portp
suffix:semicolon
r_int
id|portnr
comma
id|nrdevs
comma
id|i
comma
id|rc
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_startbrd(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|rc
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|hdrp
op_assign
(paren
r_volatile
id|cdkhdr_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|CDK_CDKADDR
)paren
suffix:semicolon
id|nrdevs
op_assign
id|hdrp-&gt;nrdevs
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;%s(%d): CDK version %d.%d.%d --&gt; &quot;
l_string|&quot;nrdevs=%d memp=%x hostp=%x slavep=%x&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|hdrp-&gt;ver_release
comma
id|hdrp-&gt;ver_modification
comma
id|hdrp-&gt;ver_fix
comma
id|nrdevs
comma
(paren
r_int
)paren
id|hdrp-&gt;memp
comma
(paren
r_int
)paren
id|hdrp-&gt;hostp
comma
(paren
r_int
)paren
id|hdrp-&gt;slavep
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|nrdevs
OL
(paren
id|brdp-&gt;nrports
op_plus
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: slave failed to allocate memory for all &quot;
l_string|&quot;devices, devices=%d&bslash;n&quot;
comma
id|nrdevs
)paren
suffix:semicolon
id|brdp-&gt;nrports
op_assign
id|nrdevs
op_minus
l_int|1
suffix:semicolon
)brace
id|brdp-&gt;nrdevs
op_assign
id|nrdevs
suffix:semicolon
id|brdp-&gt;hostoffset
op_assign
id|hdrp-&gt;hostp
op_minus
id|CDK_CDKADDR
suffix:semicolon
id|brdp-&gt;slaveoffset
op_assign
id|hdrp-&gt;slavep
op_minus
id|CDK_CDKADDR
suffix:semicolon
id|brdp-&gt;bitsize
op_assign
(paren
id|nrdevs
op_plus
l_int|7
)paren
op_div
l_int|8
suffix:semicolon
id|memp
op_assign
(paren
r_volatile
id|cdkmem_t
op_star
)paren
id|hdrp-&gt;memp
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|memp
)paren
OG
id|brdp-&gt;memsize
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: corrupted shared memory region?&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|stli_donestartup
suffix:semicolon
)brace
id|memp
op_assign
(paren
r_volatile
id|cdkmem_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
(paren
r_int
r_int
)paren
id|memp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memp-&gt;dtype
op_ne
id|TYP_ASYNCTRL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: no slave control device found&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|stli_donestartup
suffix:semicolon
)brace
id|memp
op_increment
suffix:semicolon
multiline_comment|/*&n; *&t;Cycle through memory allocation of each port. We are guaranteed to&n; *&t;have all ports inside the first page of slave window, so no need to&n; *&t;change pages while reading memory map.&n; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|portnr
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|nrdevs
)paren
suffix:semicolon
id|i
op_increment
comma
id|portnr
op_increment
comma
id|memp
op_increment
)paren
(brace
r_if
c_cond
(paren
id|memp-&gt;dtype
op_ne
id|TYP_ASYNC
)paren
r_break
suffix:semicolon
id|portp
op_assign
id|brdp-&gt;ports
(braket
id|portnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_break
suffix:semicolon
id|portp-&gt;devnr
op_assign
id|i
suffix:semicolon
id|portp-&gt;addr
op_assign
id|memp-&gt;offset
suffix:semicolon
id|portp-&gt;reqbit
op_assign
(paren
r_int
r_char
)paren
(paren
l_int|0x1
op_lshift
(paren
id|i
op_star
l_int|8
op_div
id|nrdevs
)paren
)paren
suffix:semicolon
id|portp-&gt;portidx
op_assign
(paren
r_int
r_char
)paren
(paren
id|i
op_div
l_int|8
)paren
suffix:semicolon
id|portp-&gt;portbit
op_assign
(paren
r_int
r_char
)paren
(paren
l_int|0x1
op_lshift
(paren
id|i
op_mod
l_int|8
)paren
)paren
suffix:semicolon
)brace
id|hdrp-&gt;slavereq
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/*&n; *&t;For each port setup a local copy of the RX and TX buffer offsets&n; *&t;and sizes. We do this separate from the above, because we need to&n; *&t;move the shared memory page...&n; */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|portnr
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|nrdevs
)paren
suffix:semicolon
id|i
op_increment
comma
id|portnr
op_increment
)paren
(brace
id|portp
op_assign
id|brdp-&gt;ports
(braket
id|portnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;addr
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|ap
op_assign
(paren
r_volatile
id|cdkasy_t
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|portp-&gt;addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ap
op_ne
(paren
r_volatile
id|cdkasy_t
op_star
)paren
l_int|NULL
)paren
(brace
id|portp-&gt;rxsize
op_assign
id|ap-&gt;rxq.size
suffix:semicolon
id|portp-&gt;txsize
op_assign
id|ap-&gt;txq.size
suffix:semicolon
id|portp-&gt;rxoffset
op_assign
id|ap-&gt;rxq.offset
suffix:semicolon
id|portp-&gt;txoffset
op_assign
id|ap-&gt;txq.offset
suffix:semicolon
)brace
)brace
id|stli_donestartup
suffix:colon
id|EBRDDISABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|brdp-&gt;state
op_or_assign
id|BST_STARTED
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stli_timeron
)paren
(brace
id|stli_timeron
op_increment
suffix:semicolon
id|stli_timerlist.expires
op_assign
id|STLI_TIMEOUT
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|stli_timerlist
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Probe and initialize the specified board.&n; */
DECL|function|stli_brdinit
r_static
r_int
id|__init
id|stli_brdinit
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_brdinit(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
id|stli_brds
(braket
id|brdp-&gt;brdnr
)braket
op_assign
id|brdp
suffix:semicolon
r_switch
c_cond
(paren
id|brdp-&gt;brdtype
)paren
(brace
r_case
id|BRD_ECP
suffix:colon
r_case
id|BRD_ECPE
suffix:colon
r_case
id|BRD_ECPMC
suffix:colon
r_case
id|BRD_ECPPCI
suffix:colon
id|stli_initecp
c_func
(paren
id|brdp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRD_ONBOARD
suffix:colon
r_case
id|BRD_ONBOARDE
suffix:colon
r_case
id|BRD_ONBOARD2
suffix:colon
r_case
id|BRD_ONBOARD32
suffix:colon
r_case
id|BRD_ONBOARD2_32
suffix:colon
r_case
id|BRD_ONBOARDRS
suffix:colon
r_case
id|BRD_BRUMBY4
suffix:colon
r_case
id|BRD_BRUMBY8
suffix:colon
r_case
id|BRD_BRUMBY16
suffix:colon
r_case
id|BRD_STALLION
suffix:colon
id|stli_initonb
c_func
(paren
id|brdp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BRD_EASYIO
suffix:colon
r_case
id|BRD_ECH
suffix:colon
r_case
id|BRD_ECHMC
suffix:colon
r_case
id|BRD_ECHPCI
suffix:colon
id|printk
c_func
(paren
l_string|&quot;STALLION: %s board type not supported in this driver&bslash;n&quot;
comma
id|stli_brdnames
(braket
id|brdp-&gt;brdtype
)braket
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;STALLION: board=%d is unknown board type=%d&bslash;n&quot;
comma
id|brdp-&gt;brdnr
comma
id|brdp-&gt;brdtype
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|brdp-&gt;state
op_amp
id|BST_FOUND
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: %s board not found, board=%d io=%x mem=%x&bslash;n&quot;
comma
id|stli_brdnames
(braket
id|brdp-&gt;brdtype
)braket
comma
id|brdp-&gt;brdnr
comma
id|brdp-&gt;iobase
comma
(paren
r_int
)paren
id|brdp-&gt;memaddr
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
id|stli_initports
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;STALLION: %s found, board=%d io=%x mem=%x &quot;
l_string|&quot;nrpanels=%d nrports=%d&bslash;n&quot;
comma
id|stli_brdnames
(braket
id|brdp-&gt;brdtype
)braket
comma
id|brdp-&gt;brdnr
comma
id|brdp-&gt;iobase
comma
(paren
r_int
)paren
id|brdp-&gt;memaddr
comma
id|brdp-&gt;nrpanels
comma
id|brdp-&gt;nrports
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Probe around trying to find where the EISA boards shared memory&n; *&t;might be. This is a bit if hack, but it is the best we can do.&n; */
DECL|function|stli_eisamemprobe
r_static
r_inline
r_int
id|stli_eisamemprobe
c_func
(paren
id|stlibrd_t
op_star
id|brdp
)paren
(brace
id|cdkecpsig_t
id|ecpsig
comma
op_star
id|ecpsigp
suffix:semicolon
id|cdkonbsig_t
id|onbsig
comma
op_star
id|onbsigp
suffix:semicolon
r_int
id|i
comma
id|foundit
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_eisamemprobe(brdp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|brdp
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;First up we reset the board, to get it into a known state. There&n; *&t;is only 2 board types here we need to worry about. Don;t use the&n; *&t;standard board init routine here, it programs up the shared&n; *&t;memory address, and we don&squot;t know it yet...&n; */
r_if
c_cond
(paren
id|brdp-&gt;brdtype
op_eq
id|BRD_ECPE
)paren
(brace
id|outb
c_func
(paren
l_int|0x1
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_EIBRDENAB
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ECP_EISTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_EICONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ECP_EIDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ECP_EICONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
id|stli_ecpeienable
c_func
(paren
id|brdp
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|brdp-&gt;brdtype
op_eq
id|BRD_ONBOARDE
)paren
(brace
id|outb
c_func
(paren
l_int|0x1
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_EIBRDENAB
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ONB_EISTOP
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_EICONFR
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ONB_EIDISABLE
comma
(paren
id|brdp-&gt;iobase
op_plus
id|ONB_EICONFR
)paren
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x1
comma
id|brdp-&gt;iobase
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|stli_onbeenable
c_func
(paren
id|brdp
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|foundit
op_assign
l_int|0
suffix:semicolon
id|brdp-&gt;memsize
op_assign
id|ECP_MEMSIZE
suffix:semicolon
multiline_comment|/*&n; *&t;Board shared memory is enabled, so now we have a poke around and&n; *&t;see if we can find it.&n; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|stli_eisamempsize
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|brdp-&gt;memaddr
op_assign
id|stli_eisamemprobeaddrs
(braket
id|i
)braket
suffix:semicolon
id|brdp-&gt;membase
op_assign
(paren
r_void
op_star
)paren
id|brdp-&gt;memaddr
suffix:semicolon
id|brdp-&gt;membase
op_assign
id|ioremap
c_func
(paren
id|brdp-&gt;memaddr
comma
id|brdp-&gt;memsize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;membase
op_eq
(paren
r_void
op_star
)paren
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;brdtype
op_eq
id|BRD_ECPE
)paren
(brace
id|ecpsigp
op_assign
(paren
id|cdkecpsig_t
op_star
)paren
id|stli_ecpeigetmemptr
c_func
(paren
id|brdp
comma
id|CDK_SIGADDR
comma
id|__LINE__
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|ecpsig
comma
id|ecpsigp
comma
r_sizeof
(paren
id|cdkecpsig_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ecpsig.magic
op_eq
id|ECP_MAGIC
)paren
id|foundit
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|onbsigp
op_assign
(paren
id|cdkonbsig_t
op_star
)paren
id|stli_onbegetmemptr
c_func
(paren
id|brdp
comma
id|CDK_SIGADDR
comma
id|__LINE__
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|onbsig
comma
id|onbsigp
comma
r_sizeof
(paren
id|cdkonbsig_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|onbsig.magic0
op_eq
id|ONB_MAGIC0
)paren
op_logical_and
(paren
id|onbsig.magic1
op_eq
id|ONB_MAGIC1
)paren
op_logical_and
(paren
id|onbsig.magic2
op_eq
id|ONB_MAGIC2
)paren
op_logical_and
(paren
id|onbsig.magic3
op_eq
id|ONB_MAGIC3
)paren
)paren
id|foundit
op_assign
l_int|1
suffix:semicolon
)brace
id|iounmap
c_func
(paren
id|brdp-&gt;membase
)paren
suffix:semicolon
r_if
c_cond
(paren
id|foundit
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Regardless of whether we found the shared memory or not we must&n; *&t;disable the region. After that return success or failure.&n; */
r_if
c_cond
(paren
id|brdp-&gt;brdtype
op_eq
id|BRD_ECPE
)paren
id|stli_ecpeidisable
c_func
(paren
id|brdp
)paren
suffix:semicolon
r_else
id|stli_onbedisable
c_func
(paren
id|brdp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|foundit
)paren
(brace
id|brdp-&gt;memaddr
op_assign
l_int|0
suffix:semicolon
id|brdp-&gt;membase
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;STALLION: failed to probe shared memory region for &quot;
l_string|&quot;%s in EISA slot=%d&bslash;n&quot;
comma
id|stli_brdnames
(braket
id|brdp-&gt;brdtype
)braket
comma
(paren
id|brdp-&gt;iobase
op_rshift
l_int|12
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Probe around and try to find any EISA boards in system. The biggest&n; *&t;problem here is finding out what memory address is associated with&n; *&t;an EISA board after it is found. The registers of the ECPE and&n; *&t;ONboardE are not readable - so we can&squot;t read them from there. We&n; *&t;don&squot;t have access to the EISA CMOS (or EISA BIOS) so we don&squot;t&n; *&t;actually have any way to find out the real value. The best we can&n; *&t;do is go probing around in the usual places hoping we can find it.&n; */
DECL|function|stli_findeisabrds
r_static
r_inline
r_int
id|stli_findeisabrds
c_func
(paren
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
r_int
id|iobase
comma
id|eid
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_findeisabrds()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;Firstly check if this is an EISA system. Do this by probing for&n; *&t;the system board EISA ID. If this is not an EISA system then&n; *&t;don&squot;t bother going any further!&n; */
id|outb
c_func
(paren
l_int|0xff
comma
l_int|0xc80
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
l_int|0xc80
)paren
op_eq
l_int|0xff
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n; *&t;Looks like an EISA system, so go searching for EISA boards.&n; */
r_for
c_loop
(paren
id|iobase
op_assign
l_int|0x1000
suffix:semicolon
(paren
id|iobase
op_le
l_int|0xc000
)paren
suffix:semicolon
id|iobase
op_add_assign
l_int|0x1000
)paren
(brace
id|outb
c_func
(paren
l_int|0xff
comma
(paren
id|iobase
op_plus
l_int|0xc80
)paren
)paren
suffix:semicolon
id|eid
op_assign
id|inb
c_func
(paren
id|iobase
op_plus
l_int|0xc80
)paren
suffix:semicolon
id|eid
op_or_assign
id|inb
c_func
(paren
id|iobase
op_plus
l_int|0xc81
)paren
op_lshift
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|eid
op_ne
id|STL_EISAID
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n; *&t;&t;We have found a board. Need to check if this board was&n; *&t;&t;statically configured already (just in case!).&n; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|STL_MAXBRDS
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|brdp
op_assign
id|stli_brds
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;iobase
op_eq
id|iobase
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|STL_MAXBRDS
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n; *&t;&t;We have found a Stallion board and it is not configured already.&n; *&t;&t;Allocate a board structure and initialize it.&n; */
r_if
c_cond
(paren
(paren
id|brdp
op_assign
id|stli_allocbrd
c_func
(paren
)paren
)paren
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|brdp-&gt;brdnr
op_assign
id|stli_getbrdnr
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|eid
op_assign
id|inb
c_func
(paren
id|iobase
op_plus
l_int|0xc82
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eid
op_eq
id|ECP_EISAID
)paren
id|brdp-&gt;brdtype
op_assign
id|BRD_ECPE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|eid
op_eq
id|ONB_EISAID
)paren
id|brdp-&gt;brdtype
op_assign
id|BRD_ONBOARDE
suffix:semicolon
r_else
id|brdp-&gt;brdtype
op_assign
id|BRD_UNKNOWN
suffix:semicolon
id|brdp-&gt;iobase
op_assign
id|iobase
suffix:semicolon
id|outb
c_func
(paren
l_int|0x1
comma
(paren
id|iobase
op_plus
l_int|0xc84
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stli_eisamemprobe
c_func
(paren
id|brdp
)paren
)paren
id|outb
c_func
(paren
l_int|0
comma
(paren
id|iobase
op_plus
l_int|0xc84
)paren
)paren
suffix:semicolon
id|stli_brdinit
c_func
(paren
id|brdp
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Find the next available board number that is free.&n; */
DECL|function|stli_getbrdnr
r_static
r_inline
r_int
id|stli_getbrdnr
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|STL_MAXBRDS
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|stli_brds
(braket
id|i
)braket
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|i
op_ge
id|stli_nrbrds
)paren
id|stli_nrbrds
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
macro_line|#ifdef&t;CONFIG_PCI
multiline_comment|/*&n; *&t;We have a Stallion board. Allocate a board structure and&n; *&t;initialize it. Read its IO and MEMORY resources from PCI&n; *&t;configuration space.&n; */
DECL|function|stli_initpcibrd
r_static
r_inline
r_int
id|stli_initpcibrd
c_func
(paren
r_int
id|brdtype
comma
r_struct
id|pci_dev
op_star
id|devp
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_initpcibrd(brdtype=%d,busnr=%x,devnr=%x)&bslash;n&quot;
comma
id|brdtype
comma
id|dev-&gt;bus-&gt;number
comma
id|dev-&gt;devfn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|devp
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|brdp
op_assign
id|stli_allocbrd
c_func
(paren
)paren
)paren
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
(paren
id|brdp-&gt;brdnr
op_assign
id|stli_getbrdnr
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: too many boards found, &quot;
l_string|&quot;maximum supported %d&bslash;n&quot;
comma
id|STL_MAXBRDS
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|brdp-&gt;brdtype
op_assign
id|brdtype
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;%s(%d): BAR[]=%lx,%lx,%lx,%lx&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|pci_resource_start
c_func
(paren
id|devp
comma
l_int|0
)paren
comma
id|pci_resource_start
c_func
(paren
id|devp
comma
l_int|1
)paren
comma
id|pci_resource_start
c_func
(paren
id|devp
comma
l_int|2
)paren
comma
id|pci_resource_start
c_func
(paren
id|devp
comma
l_int|3
)paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;We have all resources from the board, so lets setup the actual&n; *&t;board structure now.&n; */
id|brdp-&gt;iobase
op_assign
id|pci_resource_start
c_func
(paren
id|devp
comma
l_int|3
)paren
suffix:semicolon
id|brdp-&gt;memaddr
op_assign
id|pci_resource_start
c_func
(paren
id|devp
comma
l_int|2
)paren
suffix:semicolon
id|stli_brdinit
c_func
(paren
id|brdp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Find all Stallion PCI boards that might be installed. Initialize each&n; *&t;one as it is found.&n; */
DECL|function|stli_findpcibrds
r_static
r_inline
r_int
id|stli_findpcibrds
c_func
(paren
)paren
(brace
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rc
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_findpcibrds()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_STALLION
comma
id|PCI_DEVICE_ID_ECRA
comma
id|dev
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|stli_initpcibrd
c_func
(paren
id|BRD_ECPPCI
comma
id|dev
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Allocate a new board structure. Fill out the basic info in it.&n; */
DECL|function|stli_allocbrd
r_static
id|stlibrd_t
op_star
id|stli_allocbrd
c_func
(paren
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
id|brdp
op_assign
(paren
id|stlibrd_t
op_star
)paren
id|stli_memalloc
c_func
(paren
r_sizeof
(paren
id|stlibrd_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: failed to allocate memory (size=%d)&bslash;n&quot;
comma
r_sizeof
(paren
id|stlibrd_t
)paren
)paren
suffix:semicolon
r_return
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|brdp
comma
l_int|0
comma
r_sizeof
(paren
id|stlibrd_t
)paren
)paren
suffix:semicolon
id|brdp-&gt;magic
op_assign
id|STLI_BOARDMAGIC
suffix:semicolon
r_return
id|brdp
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Scan through all the boards in the configuration and see what we&n; *&t;can find.&n; */
DECL|function|stli_initbrds
r_static
r_inline
r_int
id|stli_initbrds
c_func
(paren
)paren
(brace
id|stlibrd_t
op_star
id|brdp
comma
op_star
id|nxtbrdp
suffix:semicolon
id|stlconf_t
op_star
id|confp
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_initbrds()&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|stli_nrbrds
OG
id|STL_MAXBRDS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;STALLION: too many boards in configuration table, &quot;
l_string|&quot;truncating to %d&bslash;n&quot;
comma
id|STL_MAXBRDS
)paren
suffix:semicolon
id|stli_nrbrds
op_assign
id|STL_MAXBRDS
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Firstly scan the list of static boards configured. Allocate&n; *&t;resources and initialize the boards as found. If this is a&n; *&t;module then let the module args override static configuration.&n; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|stli_nrbrds
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|confp
op_assign
op_amp
id|stli_brdconf
(braket
id|i
)braket
suffix:semicolon
macro_line|#ifdef MODULE
id|stli_parsebrd
c_func
(paren
id|confp
comma
id|stli_brdsp
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|brdp
op_assign
id|stli_allocbrd
c_func
(paren
)paren
)paren
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|brdp-&gt;brdnr
op_assign
id|i
suffix:semicolon
id|brdp-&gt;brdtype
op_assign
id|confp-&gt;brdtype
suffix:semicolon
id|brdp-&gt;iobase
op_assign
id|confp-&gt;ioaddr1
suffix:semicolon
id|brdp-&gt;memaddr
op_assign
id|confp-&gt;memaddr
suffix:semicolon
id|stli_brdinit
c_func
(paren
id|brdp
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Static configuration table done, so now use dynamic methods to&n; *&t;see if any more boards should be configured.&n; */
macro_line|#ifdef MODULE
id|stli_argbrds
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|stli_eisaprobe
)paren
id|stli_findeisabrds
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
id|stli_findpcibrds
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;All found boards are initialized. Now for a little optimization, if&n; *&t;no boards are sharing the &quot;shared memory&quot; regions then we can just&n; *&t;leave them all enabled. This is in fact the usual case.&n; */
id|stli_shared
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|stli_nrbrds
OG
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|stli_nrbrds
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|brdp
op_assign
id|stli_brds
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
(paren
id|j
OL
id|stli_nrbrds
)paren
suffix:semicolon
id|j
op_increment
)paren
(brace
id|nxtbrdp
op_assign
id|stli_brds
(braket
id|j
)braket
suffix:semicolon
r_if
c_cond
(paren
id|nxtbrdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|brdp-&gt;membase
op_ge
id|nxtbrdp-&gt;membase
)paren
op_logical_and
(paren
id|brdp-&gt;membase
op_le
(paren
id|nxtbrdp-&gt;membase
op_plus
id|nxtbrdp-&gt;memsize
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|stli_shared
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
r_if
c_cond
(paren
id|stli_shared
op_eq
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|stli_nrbrds
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|brdp
op_assign
id|stli_brds
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;state
op_amp
id|BST_FOUND
)paren
(brace
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|brdp-&gt;enable
op_assign
l_int|NULL
suffix:semicolon
id|brdp-&gt;disable
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Code to handle an &quot;staliomem&quot; read operation. This device is the &n; *&t;contents of the board shared memory. It is used for down loading&n; *&t;the slave image (and debugging :-)&n; */
DECL|function|stli_memread
r_static
id|ssize_t
id|stli_memread
c_func
(paren
r_struct
id|file
op_star
id|fp
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|offp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_void
op_star
id|memptr
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
id|brdnr
comma
id|size
comma
id|n
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_memread(fp=%x,buf=%x,count=%x,offp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|fp
comma
(paren
r_int
)paren
id|buf
comma
id|count
comma
(paren
r_int
)paren
id|offp
)paren
suffix:semicolon
macro_line|#endif
id|brdnr
op_assign
id|MINOR
c_func
(paren
id|fp-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brdnr
op_ge
id|stli_nrbrds
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;state
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;f_pos
op_ge
id|brdp-&gt;memsize
)paren
r_return
l_int|0
suffix:semicolon
id|size
op_assign
id|MIN
c_func
(paren
id|count
comma
(paren
id|brdp-&gt;memsize
op_minus
id|fp-&gt;f_pos
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|memptr
op_assign
(paren
r_void
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|fp-&gt;f_pos
)paren
suffix:semicolon
id|n
op_assign
id|MIN
c_func
(paren
id|size
comma
(paren
id|brdp-&gt;pagesize
op_minus
(paren
(paren
(paren
r_int
r_int
)paren
id|fp-&gt;f_pos
)paren
op_mod
id|brdp-&gt;pagesize
)paren
)paren
)paren
suffix:semicolon
id|copy_to_user
c_func
(paren
id|buf
comma
id|memptr
comma
id|n
)paren
suffix:semicolon
id|fp-&gt;f_pos
op_add_assign
id|n
suffix:semicolon
id|buf
op_add_assign
id|n
suffix:semicolon
id|size
op_sub_assign
id|n
suffix:semicolon
)brace
id|EBRDDISABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Code to handle an &quot;staliomem&quot; write operation. This device is the &n; *&t;contents of the board shared memory. It is used for down loading&n; *&t;the slave image (and debugging :-)&n; */
DECL|function|stli_memwrite
r_static
id|ssize_t
id|stli_memwrite
c_func
(paren
r_struct
id|file
op_star
id|fp
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|offp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_void
op_star
id|memptr
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_char
op_star
id|chbuf
suffix:semicolon
r_int
id|brdnr
comma
id|size
comma
id|n
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_memwrite(fp=%x,buf=%x,count=%x,offp=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|fp
comma
(paren
r_int
)paren
id|buf
comma
id|count
comma
(paren
r_int
)paren
id|offp
)paren
suffix:semicolon
macro_line|#endif
id|brdnr
op_assign
id|MINOR
c_func
(paren
id|fp-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brdnr
op_ge
id|stli_nrbrds
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;state
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|fp-&gt;f_pos
op_ge
id|brdp-&gt;memsize
)paren
r_return
l_int|0
suffix:semicolon
id|chbuf
op_assign
(paren
r_char
op_star
)paren
id|buf
suffix:semicolon
id|size
op_assign
id|MIN
c_func
(paren
id|count
comma
(paren
id|brdp-&gt;memsize
op_minus
id|fp-&gt;f_pos
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|EBRDENABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
r_while
c_loop
(paren
id|size
OG
l_int|0
)paren
(brace
id|memptr
op_assign
(paren
r_void
op_star
)paren
id|EBRDGETMEMPTR
c_func
(paren
id|brdp
comma
id|fp-&gt;f_pos
)paren
suffix:semicolon
id|n
op_assign
id|MIN
c_func
(paren
id|size
comma
(paren
id|brdp-&gt;pagesize
op_minus
(paren
(paren
(paren
r_int
r_int
)paren
id|fp-&gt;f_pos
)paren
op_mod
id|brdp-&gt;pagesize
)paren
)paren
)paren
suffix:semicolon
id|copy_from_user
c_func
(paren
id|memptr
comma
id|chbuf
comma
id|n
)paren
suffix:semicolon
id|fp-&gt;f_pos
op_add_assign
id|n
suffix:semicolon
id|chbuf
op_add_assign
id|n
suffix:semicolon
id|size
op_sub_assign
id|n
suffix:semicolon
)brace
id|EBRDDISABLE
c_func
(paren
id|brdp
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Return the board stats structure to user app.&n; */
DECL|function|stli_getbrdstats
r_static
r_int
id|stli_getbrdstats
c_func
(paren
id|combrd_t
op_star
id|bp
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
id|i
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|stli_brdstats
comma
id|bp
comma
r_sizeof
(paren
id|combrd_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stli_brdstats.brd
op_ge
id|STL_MAXBRDS
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|stli_brdstats.brd
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stli_brdstats
comma
l_int|0
comma
r_sizeof
(paren
id|combrd_t
)paren
)paren
suffix:semicolon
id|stli_brdstats.brd
op_assign
id|brdp-&gt;brdnr
suffix:semicolon
id|stli_brdstats.type
op_assign
id|brdp-&gt;brdtype
suffix:semicolon
id|stli_brdstats.hwid
op_assign
l_int|0
suffix:semicolon
id|stli_brdstats.state
op_assign
id|brdp-&gt;state
suffix:semicolon
id|stli_brdstats.ioaddr
op_assign
id|brdp-&gt;iobase
suffix:semicolon
id|stli_brdstats.memaddr
op_assign
id|brdp-&gt;memaddr
suffix:semicolon
id|stli_brdstats.nrpanels
op_assign
id|brdp-&gt;nrpanels
suffix:semicolon
id|stli_brdstats.nrports
op_assign
id|brdp-&gt;nrports
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|brdp-&gt;nrpanels
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|stli_brdstats.panels
(braket
id|i
)braket
dot
id|panel
op_assign
id|i
suffix:semicolon
id|stli_brdstats.panels
(braket
id|i
)braket
dot
id|hwid
op_assign
id|brdp-&gt;panelids
(braket
id|i
)braket
suffix:semicolon
id|stli_brdstats.panels
(braket
id|i
)braket
dot
id|nrports
op_assign
id|brdp-&gt;panels
(braket
id|i
)braket
suffix:semicolon
)brace
id|copy_to_user
c_func
(paren
id|bp
comma
op_amp
id|stli_brdstats
comma
r_sizeof
(paren
id|combrd_t
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Resolve the referenced port number into a port struct pointer.&n; */
DECL|function|stli_getport
r_static
id|stliport_t
op_star
id|stli_getport
c_func
(paren
r_int
id|brdnr
comma
r_int
id|panelnr
comma
r_int
id|portnr
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|brdnr
OL
l_int|0
)paren
op_logical_or
(paren
id|brdnr
op_ge
id|STL_MAXBRDS
)paren
)paren
r_return
(paren
id|stliport_t
op_star
)paren
l_int|NULL
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
(paren
id|stliport_t
op_star
)paren
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|panelnr
)paren
suffix:semicolon
id|i
op_increment
)paren
id|portnr
op_add_assign
id|brdp-&gt;panels
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|portnr
OL
l_int|0
)paren
op_logical_or
(paren
id|portnr
op_ge
id|brdp-&gt;nrports
)paren
)paren
r_return
(paren
id|stliport_t
op_star
)paren
l_int|NULL
suffix:semicolon
r_return
id|brdp-&gt;ports
(braket
id|portnr
)braket
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Return the port stats structure to user app. A NULL port struct&n; *&t;pointer passed in means that we need to find out from the app&n; *&t;what port to get stats for (used through board control device).&n; */
DECL|function|stli_portcmdstats
r_static
r_int
id|stli_portcmdstats
c_func
(paren
id|stliport_t
op_star
id|portp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stli_comstats
comma
l_int|0
comma
r_sizeof
(paren
id|comstats_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;state
op_amp
id|BST_STARTED
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_GETSTATS
comma
op_amp
id|stli_cdkstats
comma
r_sizeof
(paren
id|asystats_t
)paren
comma
l_int|1
)paren
)paren
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
op_amp
id|stli_cdkstats
comma
l_int|0
comma
r_sizeof
(paren
id|asystats_t
)paren
)paren
suffix:semicolon
)brace
id|stli_comstats.brd
op_assign
id|portp-&gt;brdnr
suffix:semicolon
id|stli_comstats.panel
op_assign
id|portp-&gt;panelnr
suffix:semicolon
id|stli_comstats.port
op_assign
id|portp-&gt;portnr
suffix:semicolon
id|stli_comstats.state
op_assign
id|portp-&gt;state
suffix:semicolon
id|stli_comstats.flags
op_assign
id|portp-&gt;flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;tty
op_ne
(paren
r_struct
id|tty_struct
op_star
)paren
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|portp-&gt;tty-&gt;driver_data
op_eq
id|portp
)paren
(brace
id|stli_comstats.ttystate
op_assign
id|portp-&gt;tty-&gt;flags
suffix:semicolon
id|stli_comstats.rxbuffered
op_assign
id|portp-&gt;tty-&gt;flip.count
suffix:semicolon
r_if
c_cond
(paren
id|portp-&gt;tty-&gt;termios
op_ne
(paren
r_struct
id|termios
op_star
)paren
l_int|NULL
)paren
(brace
id|stli_comstats.cflags
op_assign
id|portp-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
id|stli_comstats.iflags
op_assign
id|portp-&gt;tty-&gt;termios-&gt;c_iflag
suffix:semicolon
id|stli_comstats.oflags
op_assign
id|portp-&gt;tty-&gt;termios-&gt;c_oflag
suffix:semicolon
id|stli_comstats.lflags
op_assign
id|portp-&gt;tty-&gt;termios-&gt;c_lflag
suffix:semicolon
)brace
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|stli_comstats.txtotal
op_assign
id|stli_cdkstats.txchars
suffix:semicolon
id|stli_comstats.rxtotal
op_assign
id|stli_cdkstats.rxchars
op_plus
id|stli_cdkstats.ringover
suffix:semicolon
id|stli_comstats.txbuffered
op_assign
id|stli_cdkstats.txringq
suffix:semicolon
id|stli_comstats.rxbuffered
op_add_assign
id|stli_cdkstats.rxringq
suffix:semicolon
id|stli_comstats.rxoverrun
op_assign
id|stli_cdkstats.overruns
suffix:semicolon
id|stli_comstats.rxparity
op_assign
id|stli_cdkstats.parity
suffix:semicolon
id|stli_comstats.rxframing
op_assign
id|stli_cdkstats.framing
suffix:semicolon
id|stli_comstats.rxlost
op_assign
id|stli_cdkstats.ringover
suffix:semicolon
id|stli_comstats.rxbreaks
op_assign
id|stli_cdkstats.rxbreaks
suffix:semicolon
id|stli_comstats.txbreaks
op_assign
id|stli_cdkstats.txbreaks
suffix:semicolon
id|stli_comstats.txxon
op_assign
id|stli_cdkstats.txstart
suffix:semicolon
id|stli_comstats.txxoff
op_assign
id|stli_cdkstats.txstop
suffix:semicolon
id|stli_comstats.rxxon
op_assign
id|stli_cdkstats.rxstart
suffix:semicolon
id|stli_comstats.rxxoff
op_assign
id|stli_cdkstats.rxstop
suffix:semicolon
id|stli_comstats.rxrtsoff
op_assign
id|stli_cdkstats.rtscnt
op_div
l_int|2
suffix:semicolon
id|stli_comstats.rxrtson
op_assign
id|stli_cdkstats.rtscnt
op_minus
id|stli_comstats.rxrtsoff
suffix:semicolon
id|stli_comstats.modem
op_assign
id|stli_cdkstats.dcdcnt
suffix:semicolon
id|stli_comstats.hwid
op_assign
id|stli_cdkstats.hwid
suffix:semicolon
id|stli_comstats.signals
op_assign
id|stli_mktiocm
c_func
(paren
id|stli_cdkstats.signals
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Return the port stats structure to user app. A NULL port struct&n; *&t;pointer passed in means that we need to find out from the app&n; *&t;what port to get stats for (used through board control device).&n; */
DECL|function|stli_getportstats
r_static
r_int
id|stli_getportstats
c_func
(paren
id|stliport_t
op_star
id|portp
comma
id|comstats_t
op_star
id|cp
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
(brace
id|copy_from_user
c_func
(paren
op_amp
id|stli_comstats
comma
id|cp
comma
r_sizeof
(paren
id|comstats_t
)paren
)paren
suffix:semicolon
id|portp
op_assign
id|stli_getport
c_func
(paren
id|stli_comstats.brd
comma
id|stli_comstats.panel
comma
id|stli_comstats.port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|stli_portcmdstats
c_func
(paren
id|portp
)paren
)paren
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
id|copy_to_user
c_func
(paren
id|cp
comma
op_amp
id|stli_comstats
comma
r_sizeof
(paren
id|comstats_t
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Clear the port stats structure. We also return it zeroed out...&n; */
DECL|function|stli_clrportstats
r_static
r_int
id|stli_clrportstats
c_func
(paren
id|stliport_t
op_star
id|portp
comma
id|comstats_t
op_star
id|cp
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
(brace
id|copy_from_user
c_func
(paren
op_amp
id|stli_comstats
comma
id|cp
comma
r_sizeof
(paren
id|comstats_t
)paren
)paren
suffix:semicolon
id|portp
op_assign
id|stli_getport
c_func
(paren
id|stli_comstats.brd
comma
id|stli_comstats.panel
comma
id|stli_comstats.port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|brdp
op_assign
id|stli_brds
(braket
id|portp-&gt;brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;state
op_amp
id|BST_STARTED
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|stli_cmdwait
c_func
(paren
id|brdp
comma
id|portp
comma
id|A_CLEARSTATS
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
)paren
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|stli_comstats
comma
l_int|0
comma
r_sizeof
(paren
id|comstats_t
)paren
)paren
suffix:semicolon
id|stli_comstats.brd
op_assign
id|portp-&gt;brdnr
suffix:semicolon
id|stli_comstats.panel
op_assign
id|portp-&gt;panelnr
suffix:semicolon
id|stli_comstats.port
op_assign
id|portp-&gt;portnr
suffix:semicolon
id|copy_to_user
c_func
(paren
id|cp
comma
op_amp
id|stli_comstats
comma
r_sizeof
(paren
id|comstats_t
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Return the entire driver ports structure to a user app.&n; */
DECL|function|stli_getportstruct
r_static
r_int
id|stli_getportstruct
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
id|stliport_t
op_star
id|portp
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|stli_dummyport
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|stliport_t
)paren
)paren
suffix:semicolon
id|portp
op_assign
id|stli_getport
c_func
(paren
id|stli_dummyport.brdnr
comma
id|stli_dummyport.panelnr
comma
id|stli_dummyport.portnr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|portp
op_eq
(paren
id|stliport_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|portp
comma
r_sizeof
(paren
id|stliport_t
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;Return the entire driver board structure to a user app.&n; */
DECL|function|stli_getbrdstruct
r_static
r_int
id|stli_getbrdstruct
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|stli_dummybrd
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|stlibrd_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stli_dummybrd.brdnr
OL
l_int|0
)paren
op_logical_or
(paren
id|stli_dummybrd.brdnr
op_ge
id|STL_MAXBRDS
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|stli_dummybrd.brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|brdp
comma
r_sizeof
(paren
id|stlibrd_t
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;The &quot;staliomem&quot; device is also required to do some special operations on&n; *&t;the board. We need to be able to send an interrupt to the board,&n; *&t;reset it, and start/stop it.&n; */
DECL|function|stli_memioctl
r_static
r_int
id|stli_memioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|stlibrd_t
op_star
id|brdp
suffix:semicolon
r_int
id|brdnr
comma
id|rc
comma
id|done
suffix:semicolon
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;stli_memioctl(ip=%x,fp=%x,cmd=%x,arg=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|ip
comma
(paren
r_int
)paren
id|fp
comma
id|cmd
comma
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *&t;First up handle the board independent ioctls.&n; */
id|done
op_assign
l_int|0
suffix:semicolon
id|rc
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|COM_GETPORTSTATS
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|comstats_t
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|rc
op_assign
id|stli_getportstats
c_func
(paren
(paren
id|stliport_t
op_star
)paren
l_int|NULL
comma
(paren
id|comstats_t
op_star
)paren
id|arg
)paren
suffix:semicolon
id|done
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COM_CLRPORTSTATS
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|comstats_t
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|rc
op_assign
id|stli_clrportstats
c_func
(paren
(paren
id|stliport_t
op_star
)paren
l_int|NULL
comma
(paren
id|comstats_t
op_star
)paren
id|arg
)paren
suffix:semicolon
id|done
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COM_GETBRDSTATS
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|combrd_t
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|rc
op_assign
id|stli_getbrdstats
c_func
(paren
(paren
id|combrd_t
op_star
)paren
id|arg
)paren
suffix:semicolon
id|done
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COM_READPORT
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|stliport_t
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|rc
op_assign
id|stli_getportstruct
c_func
(paren
id|arg
)paren
suffix:semicolon
id|done
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COM_READBOARD
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|stlibrd_t
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|rc
op_assign
id|stli_getbrdstruct
c_func
(paren
id|arg
)paren
suffix:semicolon
id|done
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|done
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/*&n; *&t;Now handle the board specific ioctls. These all depend on the&n; *&t;minor number of the device they were called from.&n; */
id|brdnr
op_assign
id|MINOR
c_func
(paren
id|ip-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|brdnr
op_ge
id|STL_MAXBRDS
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|brdp
op_assign
id|stli_brds
(braket
id|brdnr
)braket
suffix:semicolon
r_if
c_cond
(paren
id|brdp
op_eq
(paren
id|stlibrd_t
op_star
)paren
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|brdp-&gt;state
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|STL_BINTR
suffix:colon
id|EBRDINTR
c_func
(paren
id|brdp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STL_BSTART
suffix:colon
id|rc
op_assign
id|stli_startbrd
c_func
(paren
id|brdp
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STL_BSTOP
suffix:colon
id|brdp-&gt;state
op_and_assign
op_complement
id|BST_STARTED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STL_BRESET
suffix:colon
id|brdp-&gt;state
op_and_assign
op_complement
id|BST_STARTED
suffix:semicolon
id|EBRDRESET
c_func
(paren
id|brdp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stli_shared
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|brdp-&gt;reenable
op_ne
l_int|NULL
)paren
(paren
op_star
id|brdp-&gt;reenable
)paren
(paren
id|brdp
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|rc
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
DECL|function|stli_init
r_int
id|__init
id|stli_init
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: version %s&bslash;n&quot;
comma
id|stli_drvtitle
comma
id|stli_drvversion
)paren
suffix:semicolon
id|stli_initbrds
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Allocate a temporary write buffer.&n; */
id|stli_tmpwritebuf
op_assign
(paren
r_char
op_star
)paren
id|stli_memalloc
c_func
(paren
id|STLI_TXBUFSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stli_tmpwritebuf
op_eq
(paren
r_char
op_star
)paren
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;STALLION: failed to allocate memory (size=%d)&bslash;n&quot;
comma
id|STLI_TXBUFSIZE
)paren
suffix:semicolon
id|stli_txcookbuf
op_assign
(paren
r_char
op_star
)paren
id|stli_memalloc
c_func
(paren
id|STLI_TXBUFSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stli_txcookbuf
op_eq
(paren
r_char
op_star
)paren
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;STALLION: failed to allocate memory (size=%d)&bslash;n&quot;
comma
id|STLI_TXBUFSIZE
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Set up a character driver for the shared memory region. We need this&n; *&t;to down load the slave code image. Also it is a useful debugging tool.&n; */
r_if
c_cond
(paren
id|devfs_register_chrdev
c_func
(paren
id|STL_SIOMEMMAJOR
comma
l_string|&quot;staliomem&quot;
comma
op_amp
id|stli_fsiomem
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;STALLION: failed to register serial memory device&bslash;n&quot;
)paren
suffix:semicolon
id|devfs_handle
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;staliomem&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register_series
(paren
id|devfs_handle
comma
l_string|&quot;%u&quot;
comma
l_int|4
comma
id|DEVFS_FL_DEFAULT
comma
id|STL_SIOMEMMAJOR
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|stli_fsiomem
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Set up the tty driver structure and register us as a driver.&n; *&t;Also setup the callout tty device.&n; */
id|memset
c_func
(paren
op_amp
id|stli_serial
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|stli_serial.magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
id|stli_serial.driver_name
op_assign
id|stli_drvname
suffix:semicolon
id|stli_serial.name
op_assign
id|stli_serialname
suffix:semicolon
id|stli_serial.major
op_assign
id|STL_SERIALMAJOR
suffix:semicolon
id|stli_serial.minor_start
op_assign
l_int|0
suffix:semicolon
id|stli_serial.num
op_assign
id|STL_MAXBRDS
op_star
id|STL_MAXPORTS
suffix:semicolon
id|stli_serial.type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
id|stli_serial.subtype
op_assign
id|STL_DRVTYPSERIAL
suffix:semicolon
id|stli_serial.init_termios
op_assign
id|stli_deftermios
suffix:semicolon
id|stli_serial.flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
id|stli_serial.refcount
op_assign
op_amp
id|stli_refcount
suffix:semicolon
id|stli_serial.table
op_assign
id|stli_ttys
suffix:semicolon
id|stli_serial.termios
op_assign
id|stli_termios
suffix:semicolon
id|stli_serial.termios_locked
op_assign
id|stli_termioslocked
suffix:semicolon
id|stli_serial.open
op_assign
id|stli_open
suffix:semicolon
id|stli_serial.close
op_assign
id|stli_close
suffix:semicolon
id|stli_serial.write
op_assign
id|stli_write
suffix:semicolon
id|stli_serial.put_char
op_assign
id|stli_putchar
suffix:semicolon
id|stli_serial.flush_chars
op_assign
id|stli_flushchars
suffix:semicolon
id|stli_serial.write_room
op_assign
id|stli_writeroom
suffix:semicolon
id|stli_serial.chars_in_buffer
op_assign
id|stli_charsinbuffer
suffix:semicolon
id|stli_serial.ioctl
op_assign
id|stli_ioctl
suffix:semicolon
id|stli_serial.set_termios
op_assign
id|stli_settermios
suffix:semicolon
id|stli_serial.throttle
op_assign
id|stli_throttle
suffix:semicolon
id|stli_serial.unthrottle
op_assign
id|stli_unthrottle
suffix:semicolon
id|stli_serial.stop
op_assign
id|stli_stop
suffix:semicolon
id|stli_serial.start
op_assign
id|stli_start
suffix:semicolon
id|stli_serial.hangup
op_assign
id|stli_hangup
suffix:semicolon
id|stli_serial.flush_buffer
op_assign
id|stli_flushbuffer
suffix:semicolon
id|stli_serial.break_ctl
op_assign
id|stli_breakctl
suffix:semicolon
id|stli_serial.wait_until_sent
op_assign
id|stli_waituntilsent
suffix:semicolon
id|stli_serial.send_xchar
op_assign
id|stli_sendxchar
suffix:semicolon
id|stli_serial.read_proc
op_assign
id|stli_readproc
suffix:semicolon
id|stli_callout
op_assign
id|stli_serial
suffix:semicolon
id|stli_callout.name
op_assign
id|stli_calloutname
suffix:semicolon
id|stli_callout.major
op_assign
id|STL_CALLOUTMAJOR
suffix:semicolon
id|stli_callout.subtype
op_assign
id|STL_DRVTYPCALLOUT
suffix:semicolon
id|stli_callout.read_proc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|stli_serial
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;STALLION: failed to register serial driver&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|stli_callout
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;STALLION: failed to register callout driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
eof
