multiline_comment|/*&n; * linux/drivers/char/serial167.c&n; *&n; * Driver for MVME166/7 board serial ports, which are via a CD2401.&n; * Based very much on cyclades.c.&n; *&n; * MVME166/7 work by Richard Hirst [richard@sleepie.demon.co.uk]&n; *&n; * ==============================================================&n; *&n; * static char rcsid[] =&n; * &quot;$Revision: 1.36.1.4 $$Date: 1995/03/29 06:14:14 $&quot;;&n; *&n; *  linux/kernel/cyclades.c&n; *&n; * Maintained by Marcio Saito (cyclades@netcom.com) and&n; * Randolph Bentson (bentson@grieg.seaslug.org)&n; *&n; * Much of the design and some of the code came from serial.c&n; * which was copyright (C) 1991, 1992  Linus Torvalds.  It was&n; * extensively rewritten by Theodore Ts&squot;o, 8/16/92 -- 9/14/92,&n; * and then fixed as suggested by Michael K. Johnson 12/12/92.&n; *&n; * This version does not support shared irq&squot;s.&n; *&n; * This module exports the following rs232 io functions:&n; *   int cy_init(void);&n; *   int  cy_open(struct tty_struct *tty, struct file *filp);&n; *&n; * $Log: cyclades.c,v $&n; * Revision 1.36.1.4  1995/03/29  06:14:14  bentson&n; * disambiguate between Cyclom-16Y and Cyclom-32Ye;&n; *&n; * Changes:&n; *&n; * 200 lines of changes record removed - RGH 11-10-95, starting work on&n; * converting this to drive serial ports on mvme166 (cd2401).&n; *&n; * Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt; - 2000/08/25&n; * - get rid of verify_area&n; * - use get_user to access memory from userspace in set_threshold,&n; *   set_default_threshold and set_timeout&n; * - don&squot;t use the panic function in serial167_init&n; * - do resource release on failure on serial167_init&n; * - include missing restore_flags in mvme167_serial_console_setup&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/serialP.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/serial167.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/mvme16xhw.h&gt;
macro_line|#include &lt;asm/bootinfo.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/init.h&gt;
DECL|macro|SERIAL_PARANOIA_CHECK
mdefine_line|#define SERIAL_PARANOIA_CHECK
DECL|macro|SERIAL_DEBUG_OPEN
macro_line|#undef  SERIAL_DEBUG_OPEN
DECL|macro|SERIAL_DEBUG_THROTTLE
macro_line|#undef  SERIAL_DEBUG_THROTTLE
DECL|macro|SERIAL_DEBUG_OTHER
macro_line|#undef  SERIAL_DEBUG_OTHER
DECL|macro|SERIAL_DEBUG_IO
macro_line|#undef  SERIAL_DEBUG_IO
DECL|macro|SERIAL_DEBUG_COUNT
macro_line|#undef  SERIAL_DEBUG_COUNT
DECL|macro|SERIAL_DEBUG_DTR
macro_line|#undef  SERIAL_DEBUG_DTR
DECL|macro|CYCLOM_16Y_HACK
macro_line|#undef  CYCLOM_16Y_HACK
DECL|macro|CYCLOM_ENABLE_MONITORING
mdefine_line|#define  CYCLOM_ENABLE_MONITORING
macro_line|#ifndef MIN
DECL|macro|MIN
mdefine_line|#define MIN(a,b)&t;((a) &lt; (b) ? (a) : (b))
macro_line|#endif
DECL|macro|WAKEUP_CHARS
mdefine_line|#define WAKEUP_CHARS 256
DECL|macro|STD_COM_FLAGS
mdefine_line|#define STD_COM_FLAGS (0)
DECL|macro|SERIAL_TYPE_NORMAL
mdefine_line|#define SERIAL_TYPE_NORMAL  1
DECL|macro|SERIAL_TYPE_CALLOUT
mdefine_line|#define SERIAL_TYPE_CALLOUT 2
DECL|variable|tq_cyclades
id|DECLARE_TASK_QUEUE
c_func
(paren
id|tq_cyclades
)paren
suffix:semicolon
DECL|variable|cy_serial_driver
DECL|variable|cy_callout_driver
r_struct
id|tty_driver
id|cy_serial_driver
comma
id|cy_callout_driver
suffix:semicolon
r_extern
r_int
id|serial_console
suffix:semicolon
DECL|variable|serial_console_info
r_static
r_struct
id|cyclades_port
op_star
id|serial_console_info
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|serial_console_cflag
r_static
r_int
r_int
id|serial_console_cflag
op_assign
l_int|0
suffix:semicolon
DECL|variable|initial_console_speed
id|u_char
id|initial_console_speed
suffix:semicolon
multiline_comment|/* Base address of cd2401 chip on mvme166/7 */
DECL|macro|BASE_ADDR
mdefine_line|#define BASE_ADDR (0xfff45000)
DECL|macro|pcc2chip
mdefine_line|#define pcc2chip&t;((volatile u_char *)0xfff42000)
DECL|macro|PccSCCMICR
mdefine_line|#define PccSCCMICR&t;0x1d
DECL|macro|PccSCCTICR
mdefine_line|#define PccSCCTICR&t;0x1e
DECL|macro|PccSCCRICR
mdefine_line|#define PccSCCRICR&t;0x1f
DECL|macro|PccTPIACKR
mdefine_line|#define PccTPIACKR&t;0x25
DECL|macro|PccRPIACKR
mdefine_line|#define PccRPIACKR&t;0x27
DECL|macro|PccIMLR
mdefine_line|#define PccIMLR&t;&t;0x3f
multiline_comment|/* This is the per-port data structure */
DECL|variable|cy_port
r_struct
id|cyclades_port
id|cy_port
(braket
)braket
op_assign
(brace
multiline_comment|/* CARD#  */
(brace
op_minus
l_int|1
)brace
comma
multiline_comment|/* ttyS0 */
(brace
op_minus
l_int|1
)brace
comma
multiline_comment|/* ttyS1 */
(brace
op_minus
l_int|1
)brace
comma
multiline_comment|/* ttyS2 */
(brace
op_minus
l_int|1
)brace
comma
multiline_comment|/* ttyS3 */
)brace
suffix:semicolon
DECL|macro|NR_PORTS
mdefine_line|#define NR_PORTS        (sizeof(cy_port)/sizeof(struct cyclades_port))
DECL|variable|serial_refcount
r_static
r_int
id|serial_refcount
suffix:semicolon
DECL|variable|serial_table
r_static
r_struct
id|tty_struct
op_star
id|serial_table
(braket
id|NR_PORTS
)braket
suffix:semicolon
DECL|variable|serial_termios
r_static
r_struct
id|termios
op_star
id|serial_termios
(braket
id|NR_PORTS
)braket
suffix:semicolon
DECL|variable|serial_termios_locked
r_static
r_struct
id|termios
op_star
id|serial_termios_locked
(braket
id|NR_PORTS
)braket
suffix:semicolon
multiline_comment|/*&n; * tmp_buf is used as a temporary buffer by serial_write.  We need to&n; * lock it in case the copy_from_user blocks while swapping in a page,&n; * and some other program tries to do a serial write at the same time.&n; * Since the lock will only come under contention when the system is&n; * swapping and available memory is low, it makes sense to share one&n; * buffer across all the serial ports, since it significantly saves&n; * memory if large numbers of serial ports are open.&n; */
DECL|variable|tmp_buf
r_static
r_int
r_char
op_star
id|tmp_buf
op_assign
l_int|0
suffix:semicolon
DECL|variable|tmp_buf_sem
id|DECLARE_MUTEX
c_func
(paren
id|tmp_buf_sem
)paren
suffix:semicolon
multiline_comment|/*&n; * This is used to look up the divisor speeds and the timeouts&n; * We&squot;re normally limited to 15 distinct baud rates.  The extra&n; * are accessed via settings in info-&gt;flags.&n; *         0,     1,     2,     3,     4,     5,     6,     7,     8,     9,&n; *        10,    11,    12,    13,    14,    15,    16,    17,    18,    19,&n; *                                                  HI            VHI&n; */
DECL|variable|baud_table
r_static
r_int
id|baud_table
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|50
comma
l_int|75
comma
l_int|110
comma
l_int|134
comma
l_int|150
comma
l_int|200
comma
l_int|300
comma
l_int|600
comma
l_int|1200
comma
l_int|1800
comma
l_int|2400
comma
l_int|4800
comma
l_int|9600
comma
l_int|19200
comma
l_int|38400
comma
l_int|57600
comma
l_int|76800
comma
l_int|115200
comma
l_int|150000
comma
l_int|0
)brace
suffix:semicolon
macro_line|#if 0
r_static
r_char
id|baud_co
(braket
)braket
op_assign
(brace
multiline_comment|/* 25 MHz clock option table */
multiline_comment|/* value =&gt;    00    01   02    03    04 */
multiline_comment|/* divide by    8    32   128   512  2048 */
l_int|0x00
comma
l_int|0x04
comma
l_int|0x04
comma
l_int|0x04
comma
l_int|0x04
comma
l_int|0x04
comma
l_int|0x03
comma
l_int|0x03
comma
l_int|0x03
comma
l_int|0x02
comma
l_int|0x02
comma
l_int|0x02
comma
l_int|0x01
comma
l_int|0x01
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
r_static
r_char
id|baud_bpr
(braket
)braket
op_assign
(brace
multiline_comment|/* 25 MHz baud rate period table */
l_int|0x00
comma
l_int|0xf5
comma
l_int|0xa3
comma
l_int|0x6f
comma
l_int|0x5c
comma
l_int|0x51
comma
l_int|0xf5
comma
l_int|0xa3
comma
l_int|0x51
comma
l_int|0xa3
comma
l_int|0x6d
comma
l_int|0x51
comma
l_int|0xa3
comma
l_int|0x51
comma
l_int|0xa3
comma
l_int|0x51
comma
l_int|0x36
comma
l_int|0x29
comma
l_int|0x1b
comma
l_int|0x15
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/* I think 166 brd clocks 2401 at 20MHz.... */
multiline_comment|/* These values are written directly to tcor, and &gt;&gt; 5 for writing to rcor */
DECL|variable|baud_co
r_static
id|u_char
id|baud_co
(braket
)braket
op_assign
(brace
multiline_comment|/* 20 MHz clock option table */
l_int|0x00
comma
l_int|0x80
comma
l_int|0x80
comma
l_int|0x80
comma
l_int|0x80
comma
l_int|0x80
comma
l_int|0x80
comma
l_int|0x60
comma
l_int|0x60
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x40
comma
l_int|0x20
comma
l_int|0x20
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
multiline_comment|/* These values written directly to tbpr/rbpr */
DECL|variable|baud_bpr
r_static
id|u_char
id|baud_bpr
(braket
)braket
op_assign
(brace
multiline_comment|/* 20 MHz baud rate period table */
l_int|0x00
comma
l_int|0xc0
comma
l_int|0x80
comma
l_int|0x58
comma
l_int|0x6c
comma
l_int|0x40
comma
l_int|0xc0
comma
l_int|0x81
comma
l_int|0x40
comma
l_int|0x81
comma
l_int|0x57
comma
l_int|0x40
comma
l_int|0x81
comma
l_int|0x40
comma
l_int|0x81
comma
l_int|0x40
comma
l_int|0x2b
comma
l_int|0x20
comma
l_int|0x15
comma
l_int|0x10
)brace
suffix:semicolon
DECL|variable|baud_cor4
r_static
id|u_char
id|baud_cor4
(braket
)braket
op_assign
(brace
multiline_comment|/* receive threshold */
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x09
comma
l_int|0x09
comma
l_int|0x08
comma
l_int|0x08
comma
l_int|0x08
comma
l_int|0x08
comma
l_int|0x07
)brace
suffix:semicolon
r_static
r_void
id|shutdown
c_func
(paren
r_struct
id|cyclades_port
op_star
)paren
suffix:semicolon
r_static
r_int
id|startup
(paren
r_struct
id|cyclades_port
op_star
)paren
suffix:semicolon
r_static
r_void
id|cy_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_void
id|cy_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_void
id|config_setup
c_func
(paren
r_struct
id|cyclades_port
op_star
)paren
suffix:semicolon
r_extern
r_void
id|console_print
c_func
(paren
r_const
r_char
op_star
)paren
suffix:semicolon
macro_line|#ifdef CYCLOM_SHOW_STATUS
r_static
r_void
id|show_status
c_func
(paren
r_int
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_REMOTE_DEBUG
r_static
r_void
id|debug_setup
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|queueDebugChar
(paren
r_int
id|c
)paren
suffix:semicolon
r_int
id|getDebugChar
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|DEBUG_PORT
mdefine_line|#define DEBUG_PORT&t;1
DECL|macro|DEBUG_LEN
mdefine_line|#define DEBUG_LEN&t;256
r_typedef
r_struct
(brace
DECL|member|in
r_int
id|in
suffix:semicolon
DECL|member|out
r_int
id|out
suffix:semicolon
DECL|member|buf
r_int
r_char
id|buf
(braket
id|DEBUG_LEN
)braket
suffix:semicolon
DECL|typedef|debugq
)brace
id|debugq
suffix:semicolon
DECL|variable|debugiq
id|debugq
id|debugiq
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * I have my own version of udelay(), as it is needed when initialising&n; * the chip, before the delay loop has been calibrated.  Should probably&n; * reference one of the vmechip2 or pccchip2 counter for an accurate&n; * delay, but this wild guess will do for now.&n; */
DECL|function|my_udelay
r_void
id|my_udelay
(paren
r_int
id|us
)paren
(brace
id|u_char
id|x
suffix:semicolon
r_volatile
id|u_char
op_star
id|p
op_assign
op_amp
id|x
suffix:semicolon
r_int
id|i
suffix:semicolon
r_while
c_loop
(paren
id|us
op_decrement
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|100
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
id|x
op_or_assign
op_star
id|p
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|serial_paranoia_check
id|serial_paranoia_check
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
id|dev_t
id|device
comma
r_const
r_char
op_star
id|routine
)paren
(brace
macro_line|#ifdef SERIAL_PARANOIA_CHECK
r_static
r_const
r_char
op_star
id|badmagic
op_assign
l_string|&quot;Warning: bad magic number for serial struct (%d, %d) in %s&bslash;n&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|badinfo
op_assign
l_string|&quot;Warning: null cyclades_port for (%d, %d) in %s&bslash;n&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|badrange
op_assign
l_string|&quot;Warning: cyclades_port out of range for (%d, %d) in %s&bslash;n&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|printk
c_func
(paren
id|badinfo
comma
id|MAJOR
c_func
(paren
id|device
)paren
comma
id|MINOR
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|info
OL
(paren
r_int
)paren
(paren
op_amp
id|cy_port
(braket
l_int|0
)braket
)paren
op_logical_or
(paren
r_int
)paren
(paren
op_amp
id|cy_port
(braket
id|NR_PORTS
)braket
)paren
OL
(paren
r_int
)paren
id|info
)paren
(brace
id|printk
c_func
(paren
id|badrange
comma
id|MAJOR
c_func
(paren
id|device
)paren
comma
id|MINOR
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;magic
op_ne
id|CYCLADES_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|badmagic
comma
id|MAJOR
c_func
(paren
id|device
)paren
comma
id|MINOR
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* serial_paranoia_check */
macro_line|#if 0
multiline_comment|/* The following diagnostic routines allow the driver to spew&n;   information on the screen, even (especially!) during interrupts.&n; */
r_void
(def_block
id|SP
c_func
(paren
r_char
op_star
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|console_print
c_func
(paren
id|data
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)def_block
r_char
id|scrn
(braket
l_int|2
)braket
suffix:semicolon
r_void
(def_block
id|CP
c_func
(paren
r_char
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|scrn
(braket
l_int|0
)braket
op_assign
id|data
suffix:semicolon
id|console_print
c_func
(paren
id|scrn
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/* CP */
r_void
id|CP1
c_func
(paren
r_int
id|data
)paren
(brace
(paren
id|data
OL
l_int|10
)paren
ques
c_cond
id|CP
c_func
(paren
id|data
op_plus
l_char|&squot;0&squot;
)paren
suffix:colon
id|CP
c_func
(paren
id|data
op_plus
l_char|&squot;A&squot;
op_minus
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/* CP1 */
r_void
id|CP2
c_func
(paren
r_int
id|data
)paren
(brace
id|CP1
c_func
(paren
(paren
id|data
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
id|CP1
c_func
(paren
id|data
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
multiline_comment|/* CP2 */
r_void
id|CP4
c_func
(paren
r_int
id|data
)paren
(brace
id|CP2
c_func
(paren
(paren
id|data
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|CP2
c_func
(paren
id|data
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
multiline_comment|/* CP4 */
r_void
id|CP8
c_func
(paren
r_int
id|data
)paren
(brace
id|CP4
c_func
(paren
(paren
id|data
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|CP4
c_func
(paren
id|data
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
multiline_comment|/* CP8 */
macro_line|#endif
multiline_comment|/* This routine waits up to 1000 micro-seconds for the previous&n;   command to the Cirrus chip to complete and then issues the&n;   new command.  An error is returned if the previous command&n;   didn&squot;t finish within the time limit.&n; */
id|u_short
DECL|function|write_cy_cmd
id|write_cy_cmd
c_func
(paren
r_volatile
id|u_char
op_star
id|base_addr
comma
id|u_char
id|cmd
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_volatile
r_int
id|i
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Check to see that the previous command has completed */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|base_addr
(braket
id|CyCCR
)braket
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|my_udelay
c_func
(paren
l_int|10L
)paren
suffix:semicolon
)brace
multiline_comment|/* if the CCR never cleared, the previous command&n;&t;    didn&squot;t finish within the &quot;reasonable time&quot; */
r_if
c_cond
(paren
id|i
op_eq
l_int|10
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Issue the new command */
id|base_addr
(braket
id|CyCCR
)braket
op_assign
id|cmd
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* write_cy_cmd */
multiline_comment|/* cy_start and cy_stop provide software output flow control as a&n;   function of XON/XOFF, software CTS, and other such stuff. */
r_static
r_void
DECL|function|cy_stop
id|cy_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_stop ttyS%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_stop&quot;
)paren
)paren
r_return
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
(paren
id|channel
)paren
suffix:semicolon
multiline_comment|/* index channel */
id|base_addr
(braket
id|CyIER
)braket
op_and_assign
op_complement
(paren
id|CyTxMpty
op_or
id|CyTxRdy
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* cy_stop */
r_static
r_void
DECL|function|cy_start
id|cy_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_start ttyS%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_start&quot;
)paren
)paren
r_return
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
(paren
id|channel
)paren
suffix:semicolon
id|base_addr
(braket
id|CyIER
)braket
op_or_assign
id|CyTxMpty
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* cy_start */
multiline_comment|/*&n; * This routine is used by the interrupt handler to schedule&n; * processing in the software interrupt portion of the driver&n; * (also known as the &quot;bottom half&quot;).  This can be called any&n; * number of times for any channel without harm.&n; */
r_static
r_inline
r_void
DECL|function|cy_sched_event
id|cy_sched_event
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
id|event
)paren
(brace
id|info-&gt;event
op_or_assign
l_int|1
op_lshift
id|event
suffix:semicolon
multiline_comment|/* remember what kind of event and who */
id|queue_task
c_func
(paren
op_amp
id|info-&gt;tqueue
comma
op_amp
id|tq_cyclades
)paren
suffix:semicolon
multiline_comment|/* it belongs to */
id|mark_bh
c_func
(paren
id|CYCLADES_BH
)paren
suffix:semicolon
multiline_comment|/* then trigger event */
)brace
multiline_comment|/* cy_sched_event */
multiline_comment|/* The real interrupt service routines are called&n;   whenever the card wants its hand held--chars&n;   received, out buffer empty, modem change, etc.&n; */
r_static
r_void
DECL|function|cd2401_rxerr_interrupt
id|cd2401_rxerr_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_struct
id|cyclades_port
op_star
id|info
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
r_char
id|err
comma
id|rfoc
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_char
id|data
suffix:semicolon
multiline_comment|/* determine the channel and change to that context */
id|channel
op_assign
(paren
id|u_short
)paren
(paren
id|base_addr
(braket
id|CyLICR
)braket
op_rshift
l_int|2
)paren
suffix:semicolon
id|info
op_assign
op_amp
id|cy_port
(braket
id|channel
)braket
suffix:semicolon
id|info-&gt;last_active
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|base_addr
(braket
id|CyRISR
)braket
)paren
op_amp
id|CyTIMEOUT
)paren
(brace
multiline_comment|/* This is a receive timeout interrupt, ignore it */
id|base_addr
(braket
id|CyREOIR
)braket
op_assign
id|CyNOTRANS
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Read a byte of data if there is any - assume the error&n;     * is associated with this character */
r_if
c_cond
(paren
(paren
id|rfoc
op_assign
id|base_addr
(braket
id|CyRFOC
)braket
)paren
op_ne
l_int|0
)paren
id|data
op_assign
id|base_addr
(braket
id|CyRDR
)braket
suffix:semicolon
r_else
id|data
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* if there is nowhere to put the data, discard it */
r_if
c_cond
(paren
id|info-&gt;tty
op_eq
l_int|0
)paren
(brace
id|base_addr
(braket
id|CyREOIR
)braket
op_assign
id|rfoc
ques
c_cond
l_int|0
suffix:colon
id|CyNOTRANS
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* there is an open port for this data */
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|info-&gt;ignore_status_mask
)paren
(brace
id|base_addr
(braket
id|CyREOIR
)braket
op_assign
id|rfoc
ques
c_cond
l_int|0
suffix:colon
id|CyNOTRANS
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;flip.count
OL
id|TTY_FLIPBUF_SIZE
)paren
(brace
id|tty-&gt;flip.count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|info-&gt;read_status_mask
)paren
(brace
r_if
c_cond
(paren
id|err
op_amp
id|CyBREAK
)paren
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_BREAK
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SAK
)paren
(brace
id|do_SAK
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|err
op_amp
id|CyFRAME
)paren
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_FRAME
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
id|data
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|err
op_amp
id|CyPARITY
)paren
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_PARITY
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
id|data
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|err
op_amp
id|CyOVERRUN
)paren
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_OVERRUN
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;       If the flip buffer itself is&n;&t;&t;       overflowing, we still loose&n;&t;&t;       the next incoming character.&n;&t;&t;     */
r_if
c_cond
(paren
id|tty-&gt;flip.count
OL
id|TTY_FLIPBUF_SIZE
)paren
(brace
id|tty-&gt;flip.count
op_increment
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_NORMAL
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
id|data
suffix:semicolon
)brace
multiline_comment|/* These two conditions may imply */
multiline_comment|/* a normal read should be done. */
multiline_comment|/* else if(data &amp; CyTIMEOUT) */
multiline_comment|/* else if(data &amp; CySPECHAR) */
)brace
r_else
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
l_int|0
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
l_int|0
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* there was a software buffer overrun&n;&t;       and nothing could be done about it!!! */
)brace
)brace
id|queue_task
c_func
(paren
op_amp
id|tty-&gt;flip.tqueue
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
multiline_comment|/* end of service */
id|base_addr
(braket
id|CyREOIR
)braket
op_assign
id|rfoc
ques
c_cond
l_int|0
suffix:colon
id|CyNOTRANS
suffix:semicolon
)brace
multiline_comment|/* cy_rxerr_interrupt */
r_static
r_void
DECL|function|cd2401_modem_interrupt
id|cd2401_modem_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
id|mdm_change
suffix:semicolon
r_int
id|mdm_status
suffix:semicolon
multiline_comment|/* determine the channel and change to that context */
id|channel
op_assign
(paren
id|u_short
)paren
(paren
id|base_addr
(braket
id|CyLICR
)braket
op_rshift
l_int|2
)paren
suffix:semicolon
id|info
op_assign
op_amp
id|cy_port
(braket
id|channel
)braket
suffix:semicolon
id|info-&gt;last_active
op_assign
id|jiffies
suffix:semicolon
id|mdm_change
op_assign
id|base_addr
(braket
id|CyMISR
)braket
suffix:semicolon
id|mdm_status
op_assign
id|base_addr
(braket
id|CyMSVR1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
op_eq
l_int|0
)paren
(brace
multiline_comment|/* nowhere to put the data, ignore it */
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|mdm_change
op_amp
id|CyDCD
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CHECK_CD
)paren
)paren
(brace
r_if
c_cond
(paren
id|mdm_status
op_amp
id|CyDCD
)paren
(brace
multiline_comment|/* CP(&squot;!&squot;); */
id|cy_sched_event
c_func
(paren
id|info
comma
id|Cy_EVENT_OPEN_WAKEUP
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_NOHUP
)paren
)paren
)paren
(brace
multiline_comment|/* CP(&squot;@&squot;); */
id|cy_sched_event
c_func
(paren
id|info
comma
id|Cy_EVENT_HANGUP
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|mdm_change
op_amp
id|CyCTS
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CTS_FLOW
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;tty-&gt;stopped
)paren
(brace
r_if
c_cond
(paren
id|mdm_status
op_amp
id|CyCTS
)paren
(brace
multiline_comment|/* !!! cy_start isn&squot;t used because... */
id|info-&gt;tty-&gt;stopped
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyIER
)braket
op_or_assign
id|CyTxMpty
suffix:semicolon
id|cy_sched_event
c_func
(paren
id|info
comma
id|Cy_EVENT_WRITE_WAKEUP
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mdm_status
op_amp
id|CyCTS
)paren
)paren
(brace
multiline_comment|/* !!! cy_stop isn&squot;t used because... */
id|info-&gt;tty-&gt;stopped
op_assign
l_int|1
suffix:semicolon
id|base_addr
(braket
id|CyIER
)braket
op_and_assign
op_complement
(paren
id|CyTxMpty
op_or
id|CyTxRdy
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|mdm_status
op_amp
id|CyDSR
)paren
(brace
)brace
)brace
id|base_addr
(braket
id|CyMEOIR
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* cy_modem_interrupt */
r_static
r_void
DECL|function|cd2401_tx_interrupt
id|cd2401_tx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
id|char_count
comma
id|saved_cnt
suffix:semicolon
r_int
id|outch
suffix:semicolon
multiline_comment|/* determine the channel and change to that context */
id|channel
op_assign
(paren
id|u_short
)paren
(paren
id|base_addr
(braket
id|CyLICR
)braket
op_rshift
l_int|2
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_REMOTE_DEBUG
r_if
c_cond
(paren
id|channel
op_eq
id|DEBUG_PORT
)paren
(brace
id|panic
(paren
l_string|&quot;TxInt on debug port!!!&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|info
op_assign
op_amp
id|cy_port
(braket
id|channel
)braket
suffix:semicolon
multiline_comment|/* validate the port number (as configured and open) */
r_if
c_cond
(paren
(paren
id|channel
OL
l_int|0
)paren
op_logical_or
(paren
id|NR_PORTS
op_le
id|channel
)paren
)paren
(brace
id|base_addr
(braket
id|CyIER
)braket
op_and_assign
op_complement
(paren
id|CyTxMpty
op_or
id|CyTxRdy
)paren
suffix:semicolon
id|base_addr
(braket
id|CyTEOIR
)braket
op_assign
id|CyNOTRANS
suffix:semicolon
r_return
suffix:semicolon
)brace
id|info-&gt;last_active
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
op_eq
l_int|0
)paren
(brace
id|base_addr
(braket
id|CyIER
)braket
op_and_assign
op_complement
(paren
id|CyTxMpty
op_or
id|CyTxRdy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
OL
id|WAKEUP_CHARS
)paren
(brace
id|cy_sched_event
c_func
(paren
id|info
comma
id|Cy_EVENT_WRITE_WAKEUP
)paren
suffix:semicolon
)brace
id|base_addr
(braket
id|CyTEOIR
)braket
op_assign
id|CyNOTRANS
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* load the on-chip space available for outbound data */
id|saved_cnt
op_assign
id|char_count
op_assign
id|base_addr
(braket
id|CyTFTC
)braket
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;x_char
)paren
(brace
multiline_comment|/* send special char */
id|outch
op_assign
id|info-&gt;x_char
suffix:semicolon
id|base_addr
(braket
id|CyTDR
)braket
op_assign
id|outch
suffix:semicolon
id|char_count
op_decrement
suffix:semicolon
id|info-&gt;x_char
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;x_break
)paren
(brace
multiline_comment|/*  The Cirrus chip requires the &quot;Embedded Transmit&n;&t;    Commands&quot; of start break, delay, and end break&n;&t;    sequences to be sent.  The duration of the&n;&t;    break is given in TICs, which runs at HZ&n;&t;    (typically 100) and the PPR runs at 200 Hz,&n;&t;    so the delay is duration * 200/HZ, and thus a&n;&t;    break can run from 1/100 sec to about 5/4 sec.&n;&t;    Need to check these values - RGH 141095.&n;&t; */
id|base_addr
(braket
id|CyTDR
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* start break */
id|base_addr
(braket
id|CyTDR
)braket
op_assign
l_int|0x81
suffix:semicolon
id|base_addr
(braket
id|CyTDR
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* delay a bit */
id|base_addr
(braket
id|CyTDR
)braket
op_assign
l_int|0x82
suffix:semicolon
id|base_addr
(braket
id|CyTDR
)braket
op_assign
id|info-&gt;x_break
op_star
l_int|200
op_div
id|HZ
suffix:semicolon
id|base_addr
(braket
id|CyTDR
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* terminate break */
id|base_addr
(braket
id|CyTDR
)braket
op_assign
l_int|0x83
suffix:semicolon
id|char_count
op_sub_assign
l_int|7
suffix:semicolon
id|info-&gt;x_break
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|char_count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;xmit_cnt
)paren
(brace
id|base_addr
(braket
id|CyIER
)braket
op_and_assign
op_complement
(paren
id|CyTxMpty
op_or
id|CyTxRdy
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;xmit_buf
op_eq
l_int|0
)paren
(brace
id|base_addr
(braket
id|CyIER
)braket
op_and_assign
op_complement
(paren
id|CyTxMpty
op_or
id|CyTxRdy
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;tty-&gt;stopped
op_logical_or
id|info-&gt;tty-&gt;hw_stopped
)paren
(brace
id|base_addr
(braket
id|CyIER
)braket
op_and_assign
op_complement
(paren
id|CyTxMpty
op_or
id|CyTxRdy
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Because the Embedded Transmit Commands have been&n;&t;   enabled, we must check to see if the escape&n;&t;   character, NULL, is being sent.  If it is, we&n;&t;   must ensure that there is room for it to be&n;&t;   doubled in the output stream.  Therefore we&n;&t;   no longer advance the pointer when the character&n;&t;   is fetched, but rather wait until after the check&n;&t;   for a NULL output character. (This is necessary&n;&t;   because there may not be room for the two chars&n;&t;   needed to send a NULL.&n;&t; */
id|outch
op_assign
id|info-&gt;xmit_buf
(braket
id|info-&gt;xmit_tail
)braket
suffix:semicolon
r_if
c_cond
(paren
id|outch
)paren
(brace
id|info-&gt;xmit_cnt
op_decrement
suffix:semicolon
id|info-&gt;xmit_tail
op_assign
(paren
id|info-&gt;xmit_tail
op_plus
l_int|1
)paren
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|base_addr
(braket
id|CyTDR
)braket
op_assign
id|outch
suffix:semicolon
id|char_count
op_decrement
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|char_count
OG
l_int|1
)paren
(brace
id|info-&gt;xmit_cnt
op_decrement
suffix:semicolon
id|info-&gt;xmit_tail
op_assign
(paren
id|info-&gt;xmit_tail
op_plus
l_int|1
)paren
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|base_addr
(braket
id|CyTDR
)braket
op_assign
id|outch
suffix:semicolon
id|base_addr
(braket
id|CyTDR
)braket
op_assign
l_int|0
suffix:semicolon
id|char_count
op_decrement
suffix:semicolon
id|char_count
op_decrement
suffix:semicolon
)brace
r_else
(brace
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
OL
id|WAKEUP_CHARS
)paren
(brace
id|cy_sched_event
c_func
(paren
id|info
comma
id|Cy_EVENT_WRITE_WAKEUP
)paren
suffix:semicolon
)brace
id|base_addr
(braket
id|CyTEOIR
)braket
op_assign
(paren
id|char_count
op_ne
id|saved_cnt
)paren
ques
c_cond
l_int|0
suffix:colon
id|CyNOTRANS
suffix:semicolon
)brace
multiline_comment|/* cy_tx_interrupt */
r_static
r_void
DECL|function|cd2401_rx_interrupt
id|cd2401_rx_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_struct
id|cyclades_port
op_star
id|info
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_char
id|data
suffix:semicolon
r_int
id|char_count
suffix:semicolon
r_int
id|save_cnt
suffix:semicolon
multiline_comment|/* determine the channel and change to that context */
id|channel
op_assign
(paren
id|u_short
)paren
(paren
id|base_addr
(braket
id|CyLICR
)braket
op_rshift
l_int|2
)paren
suffix:semicolon
id|info
op_assign
op_amp
id|cy_port
(braket
id|channel
)braket
suffix:semicolon
id|info-&gt;last_active
op_assign
id|jiffies
suffix:semicolon
id|save_cnt
op_assign
id|char_count
op_assign
id|base_addr
(braket
id|CyRFOC
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_REMOTE_DEBUG
r_if
c_cond
(paren
id|channel
op_eq
id|DEBUG_PORT
)paren
(brace
r_while
c_loop
(paren
id|char_count
op_decrement
)paren
(brace
id|data
op_assign
id|base_addr
(braket
id|CyRDR
)braket
suffix:semicolon
id|queueDebugChar
c_func
(paren
id|data
)paren
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif
multiline_comment|/* if there is nowhere to put the data, discard it */
r_if
c_cond
(paren
id|info-&gt;tty
op_eq
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|char_count
op_decrement
)paren
(brace
id|data
op_assign
id|base_addr
(braket
id|CyRDR
)braket
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* there is an open port for this data */
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
multiline_comment|/* load # characters available from the chip */
macro_line|#ifdef CYCLOM_ENABLE_MONITORING
op_increment
id|info-&gt;mon.int_count
suffix:semicolon
id|info-&gt;mon.char_count
op_add_assign
id|char_count
suffix:semicolon
r_if
c_cond
(paren
id|char_count
OG
id|info-&gt;mon.char_max
)paren
id|info-&gt;mon.char_max
op_assign
id|char_count
suffix:semicolon
id|info-&gt;mon.char_last
op_assign
id|char_count
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|char_count
op_decrement
)paren
(brace
id|data
op_assign
id|base_addr
(braket
id|CyRDR
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
(brace
r_continue
suffix:semicolon
)brace
id|tty-&gt;flip.count
op_increment
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_NORMAL
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
id|data
suffix:semicolon
macro_line|#ifdef CYCLOM_16Y_HACK
id|udelay
c_func
(paren
l_int|10L
)paren
suffix:semicolon
macro_line|#endif
)brace
id|queue_task
c_func
(paren
op_amp
id|tty-&gt;flip.tqueue
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* end of service */
id|base_addr
(braket
id|CyREOIR
)braket
op_assign
id|save_cnt
ques
c_cond
l_int|0
suffix:colon
id|CyNOTRANS
suffix:semicolon
)brace
multiline_comment|/* cy_rx_interrupt */
multiline_comment|/*&n; * This routine is used to handle the &quot;bottom half&quot; processing for the&n; * serial driver, known also the &quot;software interrupt&quot; processing.&n; * This processing is done at the kernel interrupt level, after the&n; * cy_interrupt() has returned, BUT WITH INTERRUPTS TURNED ON.  This&n; * is where time-consuming activities which can not be done in the&n; * interrupt driver proper are done; the interrupt driver schedules&n; * them using cy_sched_event(), and they get done here.&n; *&n; * This is done through one level of indirection--the task queue.&n; * When a hardware interrupt service routine wants service by the&n; * driver&squot;s bottom half, it enqueues the appropriate tq_struct (one&n; * per port) to the tq_cyclades work queue and sets a request flag&n; * via mark_bh for processing that queue.  When the time is right,&n; * do_cyclades_bh is called (because of the mark_bh) and it requests&n; * that the work queue be processed.&n; *&n; * Although this may seem unwieldy, it gives the system a way to&n; * pass an argument (in this case the pointer to the cyclades_port&n; * structure) to the bottom half of the driver.  Previous kernels&n; * had to poll every port to see if that port needed servicing.&n; */
r_static
r_void
DECL|function|do_cyclades_bh
id|do_cyclades_bh
c_func
(paren
r_void
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_cyclades
)paren
suffix:semicolon
)brace
multiline_comment|/* do_cyclades_bh */
r_static
r_void
DECL|function|do_softint
id|do_softint
c_func
(paren
r_void
op_star
id|private_
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|private_
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|Cy_EVENT_HANGUP
comma
op_amp
id|info-&gt;event
)paren
)paren
(brace
id|tty_hangup
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|Cy_EVENT_OPEN_WAKEUP
comma
op_amp
id|info-&gt;event
)paren
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|Cy_EVENT_WRITE_WAKEUP
comma
op_amp
id|info-&gt;event
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(brace
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* do_softint */
multiline_comment|/* This is called whenever a port becomes active;&n;   interrupts are enabled and DTR &amp; RTS are turned on.&n; */
r_static
r_int
DECL|function|startup
id|startup
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;type
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;tty
)paren
(brace
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;xmit_buf
)paren
(brace
id|info-&gt;xmit_buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|get_free_page
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;xmit_buf
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|config_setup
c_func
(paren
id|info
)paren
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;startup channel %d&bslash;n&quot;
comma
id|channel
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|write_cy_cmd
c_func
(paren
id|base_addr
comma
id|CyENB_RCVR
op_or
id|CyENB_XMTR
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
multiline_comment|/* !!! Is this needed? */
id|base_addr
(braket
id|CyMSVR1
)braket
op_assign
id|CyRTS
suffix:semicolon
multiline_comment|/* CP(&squot;S&squot;);CP(&squot;1&squot;); */
id|base_addr
(braket
id|CyMSVR2
)braket
op_assign
id|CyDTR
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: raising DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
)braket
comma
id|base_addr
(braket
id|CyMSVR2
)braket
)paren
suffix:semicolon
macro_line|#endif
id|base_addr
(braket
id|CyIER
)braket
op_or_assign
id|CyRxData
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|ASYNC_INITIALIZED
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
)paren
(brace
id|clear_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
)brace
id|info-&gt;xmit_cnt
op_assign
id|info-&gt;xmit_head
op_assign
id|info-&gt;xmit_tail
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot; done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* startup */
r_void
DECL|function|start_xmit
id|start_xmit
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyIER
)braket
op_or_assign
id|CyTxMpty
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* start_xmit */
multiline_comment|/*&n; * This routine shuts down a serial port; interrupts are disabled,&n; * and DTR is dropped if the hangup on close termio flag is on.&n; */
r_static
r_void
DECL|function|shutdown
id|shutdown
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
(brace
multiline_comment|/* CP(&squot;$&squot;); */
r_return
suffix:semicolon
)brace
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;shutdown channel %d&bslash;n&quot;
comma
id|channel
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* !!! REALLY MUST WAIT FOR LAST CHARACTER TO BE&n;       SENT BEFORE DROPPING THE LINE !!!  (Perhaps&n;       set some flag that is read when XMTY happens.)&n;       Other choices are to delay some fixed interval&n;       or schedule some later processing.&n;     */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;xmit_buf
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|info-&gt;xmit_buf
)paren
suffix:semicolon
id|info-&gt;xmit_buf
op_assign
l_int|0
suffix:semicolon
)brace
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tty
op_logical_or
(paren
id|info-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
)paren
(brace
id|base_addr
(braket
id|CyMSVR1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* CP(&squot;C&squot;);CP(&squot;1&squot;); */
id|base_addr
(braket
id|CyMSVR2
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: dropping DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
)braket
comma
id|base_addr
(braket
id|CyMSVR2
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
id|write_cy_cmd
c_func
(paren
id|base_addr
comma
id|CyDIS_RCVR
)paren
suffix:semicolon
multiline_comment|/* it may be appropriate to clear _XMIT at&n;           some later date (after testing)!!! */
r_if
c_cond
(paren
id|info-&gt;tty
)paren
(brace
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
)brace
id|info-&gt;flags
op_and_assign
op_complement
id|ASYNC_INITIALIZED
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot; done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* shutdown */
multiline_comment|/*&n; * This routine finds or computes the various line characteristics.&n; */
r_static
r_void
DECL|function|config_setup
id|config_setup
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
id|cflag
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_char
id|ti
comma
id|need_init_chan
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tty
op_logical_or
op_logical_neg
id|info-&gt;tty-&gt;termios
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;line
op_eq
op_minus
l_int|1
)paren
(brace
r_return
suffix:semicolon
)brace
id|cflag
op_assign
id|info-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
multiline_comment|/* baud rate */
id|i
op_assign
id|cflag
op_amp
id|CBAUD
suffix:semicolon
macro_line|#ifdef CBAUDEX
multiline_comment|/* Starting with kernel 1.1.65, there is direct support for&n;   higher baud rates.  The following code supports those&n;   changes.  The conditional aspect allows this driver to be&n;   used for earlier as well as later kernel versions.  (The&n;   mapping is slightly different from serial.c because there&n;   is still the possibility of supporting 75 kbit/sec with&n;   the Cyclades board.)&n; */
r_if
c_cond
(paren
id|i
op_amp
id|CBAUDEX
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|B57600
)paren
id|i
op_assign
l_int|16
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
op_eq
id|B115200
)paren
(brace
id|i
op_assign
l_int|18
suffix:semicolon
)brace
macro_line|#ifdef B78600
r_else
r_if
c_cond
(paren
id|i
op_eq
id|B78600
)paren
(brace
id|i
op_assign
l_int|17
suffix:semicolon
)brace
macro_line|#endif
r_else
id|info-&gt;tty-&gt;termios-&gt;c_cflag
op_and_assign
op_complement
id|CBAUDEX
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|i
op_eq
l_int|15
)paren
(brace
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_HI
)paren
id|i
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_VHI
)paren
id|i
op_add_assign
l_int|3
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t ever change the speed of the console port.  It will&n;     * run at the speed specified in bootinfo, or at 19.2K */
multiline_comment|/* Actually, it should run at whatever speed 166Bug was using */
multiline_comment|/* Note info-&gt;timeout isn&squot;t used at present */
r_if
c_cond
(paren
id|info
op_ne
id|serial_console_info
)paren
(brace
id|info-&gt;tbpr
op_assign
id|baud_bpr
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Tx BPR */
id|info-&gt;tco
op_assign
id|baud_co
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Tx CO */
id|info-&gt;rbpr
op_assign
id|baud_bpr
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Rx BPR */
id|info-&gt;rco
op_assign
id|baud_co
(braket
id|i
)braket
op_rshift
l_int|5
suffix:semicolon
multiline_comment|/* Rx CO */
r_if
c_cond
(paren
id|baud_table
(braket
id|i
)braket
op_eq
l_int|134
)paren
(brace
id|info-&gt;timeout
op_assign
(paren
id|info-&gt;xmit_fifo_size
op_star
id|HZ
op_star
l_int|30
op_div
l_int|269
)paren
op_plus
l_int|2
suffix:semicolon
multiline_comment|/* get it right for 134.5 baud */
)brace
r_else
r_if
c_cond
(paren
id|baud_table
(braket
id|i
)braket
)paren
(brace
id|info-&gt;timeout
op_assign
(paren
id|info-&gt;xmit_fifo_size
op_star
id|HZ
op_star
l_int|15
op_div
id|baud_table
(braket
id|i
)braket
)paren
op_plus
l_int|2
suffix:semicolon
multiline_comment|/* this needs to be propagated into the card info */
)brace
r_else
(brace
id|info-&gt;timeout
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* By tradition (is it a standard?) a baud rate of zero&n;       implies the line should be/has been closed.  A bit&n;       later in this routine such a test is performed. */
multiline_comment|/* byte size and parity */
id|info-&gt;cor7
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cor6
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cor5
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cor4
op_assign
(paren
id|info-&gt;default_threshold
ques
c_cond
id|info-&gt;default_threshold
suffix:colon
id|baud_cor4
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* receive threshold */
multiline_comment|/* Following two lines added 101295, RGH. */
multiline_comment|/* It is obviously wrong to access CyCORx, and not info-&gt;corx here,&n;     * try and remember to fix it later! */
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
r_if
c_cond
(paren
id|C_CLOCAL
c_func
(paren
id|info-&gt;tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|base_addr
(braket
id|CyIER
)braket
op_amp
id|CyMdmCh
)paren
id|base_addr
(braket
id|CyIER
)braket
op_and_assign
op_complement
id|CyMdmCh
suffix:semicolon
multiline_comment|/* without modem intr */
multiline_comment|/* ignore 1-&gt;0 modem transitions */
r_if
c_cond
(paren
id|base_addr
(braket
id|CyCOR4
)braket
op_amp
(paren
id|CyDSR
op_or
id|CyCTS
op_or
id|CyDCD
)paren
)paren
id|base_addr
(braket
id|CyCOR4
)braket
op_and_assign
op_complement
(paren
id|CyDSR
op_or
id|CyCTS
op_or
id|CyDCD
)paren
suffix:semicolon
multiline_comment|/* ignore 0-&gt;1 modem transitions */
r_if
c_cond
(paren
id|base_addr
(braket
id|CyCOR5
)braket
op_amp
(paren
id|CyDSR
op_or
id|CyCTS
op_or
id|CyDCD
)paren
)paren
id|base_addr
(braket
id|CyCOR5
)braket
op_and_assign
op_complement
(paren
id|CyDSR
op_or
id|CyCTS
op_or
id|CyDCD
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|base_addr
(braket
id|CyIER
)braket
op_amp
id|CyMdmCh
)paren
op_ne
id|CyMdmCh
)paren
id|base_addr
(braket
id|CyIER
)braket
op_or_assign
id|CyMdmCh
suffix:semicolon
multiline_comment|/* with modem intr */
multiline_comment|/* act on 1-&gt;0 modem transitions */
r_if
c_cond
(paren
(paren
id|base_addr
(braket
id|CyCOR4
)braket
op_amp
(paren
id|CyDSR
op_or
id|CyCTS
op_or
id|CyDCD
)paren
)paren
op_ne
(paren
id|CyDSR
op_or
id|CyCTS
op_or
id|CyDCD
)paren
)paren
id|base_addr
(braket
id|CyCOR4
)braket
op_or_assign
id|CyDSR
op_or
id|CyCTS
op_or
id|CyDCD
suffix:semicolon
multiline_comment|/* act on 0-&gt;1 modem transitions */
r_if
c_cond
(paren
(paren
id|base_addr
(braket
id|CyCOR5
)braket
op_amp
(paren
id|CyDSR
op_or
id|CyCTS
op_or
id|CyDCD
)paren
)paren
op_ne
(paren
id|CyDSR
op_or
id|CyCTS
op_or
id|CyDCD
)paren
)paren
id|base_addr
(braket
id|CyCOR5
)braket
op_or_assign
id|CyDSR
op_or
id|CyCTS
op_or
id|CyDCD
suffix:semicolon
)brace
id|info-&gt;cor3
op_assign
(paren
id|cflag
op_amp
id|CSTOPB
)paren
ques
c_cond
id|Cy_2_STOP
suffix:colon
id|Cy_1_STOP
suffix:semicolon
id|info-&gt;cor2
op_assign
id|CyETC
suffix:semicolon
r_switch
c_cond
(paren
id|cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|info-&gt;cor1
op_assign
id|Cy_5_BITS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|info-&gt;cor1
op_assign
id|Cy_6_BITS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|info-&gt;cor1
op_assign
id|Cy_7_BITS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS8
suffix:colon
id|info-&gt;cor1
op_assign
id|Cy_8_BITS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|PARENB
)paren
(brace
r_if
c_cond
(paren
id|cflag
op_amp
id|PARODD
)paren
(brace
id|info-&gt;cor1
op_or_assign
id|CyPARITY_O
suffix:semicolon
)brace
r_else
(brace
id|info-&gt;cor1
op_or_assign
id|CyPARITY_E
suffix:semicolon
)brace
)brace
r_else
(brace
id|info-&gt;cor1
op_or_assign
id|CyPARITY_NONE
suffix:semicolon
)brace
multiline_comment|/* CTS flow control flag */
macro_line|#if 0
multiline_comment|/* Don&squot;t complcate matters for now! RGH 141095 */
r_if
c_cond
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
(brace
id|info-&gt;flags
op_or_assign
id|ASYNC_CTS_FLOW
suffix:semicolon
id|info-&gt;cor2
op_or_assign
id|CyCtsAE
suffix:semicolon
)brace
r_else
(brace
id|info-&gt;flags
op_and_assign
op_complement
id|ASYNC_CTS_FLOW
suffix:semicolon
id|info-&gt;cor2
op_and_assign
op_complement
id|CyCtsAE
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|cflag
op_amp
id|CLOCAL
)paren
id|info-&gt;flags
op_and_assign
op_complement
id|ASYNC_CHECK_CD
suffix:semicolon
r_else
id|info-&gt;flags
op_or_assign
id|ASYNC_CHECK_CD
suffix:semicolon
multiline_comment|/***********************************************&n;&t;The hardware option, CyRtsAO, presents RTS when&n;&t;the chip has characters to send.  Since most modems&n;&t;use RTS as reverse (inbound) flow control, this&n;&t;option is not used.  If inbound flow control is&n;&t;necessary, DTR can be programmed to provide the&n;&t;appropriate signals for use with a non-standard&n;&t;cable.  Contact Marcio Saito for details.&n;     ***********************************************/
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
multiline_comment|/* CyCMR set once only in mvme167_init_serial() */
r_if
c_cond
(paren
id|base_addr
(braket
id|CyLICR
)braket
op_ne
id|channel
op_lshift
l_int|2
)paren
id|base_addr
(braket
id|CyLICR
)braket
op_assign
id|channel
op_lshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyLIVR
)braket
op_ne
l_int|0x5c
)paren
id|base_addr
(braket
id|CyLIVR
)braket
op_assign
l_int|0x5c
suffix:semicolon
multiline_comment|/* tx and rx baud rate */
r_if
c_cond
(paren
id|base_addr
(braket
id|CyCOR1
)braket
op_ne
id|info-&gt;cor1
)paren
id|need_init_chan
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyTCOR
)braket
op_ne
id|info-&gt;tco
)paren
id|base_addr
(braket
id|CyTCOR
)braket
op_assign
id|info-&gt;tco
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyTBPR
)braket
op_ne
id|info-&gt;tbpr
)paren
id|base_addr
(braket
id|CyTBPR
)braket
op_assign
id|info-&gt;tbpr
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyRCOR
)braket
op_ne
id|info-&gt;rco
)paren
id|base_addr
(braket
id|CyRCOR
)braket
op_assign
id|info-&gt;rco
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyRBPR
)braket
op_ne
id|info-&gt;rbpr
)paren
id|base_addr
(braket
id|CyRBPR
)braket
op_assign
id|info-&gt;rbpr
suffix:semicolon
multiline_comment|/* set line characteristics  according configuration */
r_if
c_cond
(paren
id|base_addr
(braket
id|CySCHR1
)braket
op_ne
id|START_CHAR
c_func
(paren
id|info-&gt;tty
)paren
)paren
id|base_addr
(braket
id|CySCHR1
)braket
op_assign
id|START_CHAR
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CySCHR2
)braket
op_ne
id|STOP_CHAR
c_func
(paren
id|info-&gt;tty
)paren
)paren
id|base_addr
(braket
id|CySCHR2
)braket
op_assign
id|STOP_CHAR
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CySCRL
)braket
op_ne
id|START_CHAR
c_func
(paren
id|info-&gt;tty
)paren
)paren
id|base_addr
(braket
id|CySCRL
)braket
op_assign
id|START_CHAR
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CySCRH
)braket
op_ne
id|START_CHAR
c_func
(paren
id|info-&gt;tty
)paren
)paren
id|base_addr
(braket
id|CySCRH
)braket
op_assign
id|START_CHAR
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyCOR1
)braket
op_ne
id|info-&gt;cor1
)paren
id|base_addr
(braket
id|CyCOR1
)braket
op_assign
id|info-&gt;cor1
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyCOR2
)braket
op_ne
id|info-&gt;cor2
)paren
id|base_addr
(braket
id|CyCOR2
)braket
op_assign
id|info-&gt;cor2
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyCOR3
)braket
op_ne
id|info-&gt;cor3
)paren
id|base_addr
(braket
id|CyCOR3
)braket
op_assign
id|info-&gt;cor3
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyCOR4
)braket
op_ne
id|info-&gt;cor4
)paren
id|base_addr
(braket
id|CyCOR4
)braket
op_assign
id|info-&gt;cor4
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyCOR5
)braket
op_ne
id|info-&gt;cor5
)paren
id|base_addr
(braket
id|CyCOR5
)braket
op_assign
id|info-&gt;cor5
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyCOR6
)braket
op_ne
id|info-&gt;cor6
)paren
id|base_addr
(braket
id|CyCOR6
)braket
op_assign
id|info-&gt;cor6
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyCOR7
)braket
op_ne
id|info-&gt;cor7
)paren
id|base_addr
(braket
id|CyCOR7
)braket
op_assign
id|info-&gt;cor7
suffix:semicolon
r_if
c_cond
(paren
id|need_init_chan
)paren
id|write_cy_cmd
c_func
(paren
id|base_addr
comma
id|CyINIT_CHAN
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
multiline_comment|/* !!! Is this needed? */
multiline_comment|/* 2ms default rx timeout */
id|ti
op_assign
id|info-&gt;default_timeout
ques
c_cond
id|info-&gt;default_timeout
suffix:colon
l_int|0x02
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyRTPRL
)braket
op_ne
id|ti
)paren
id|base_addr
(braket
id|CyRTPRL
)braket
op_assign
id|ti
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyRTPRH
)braket
op_ne
l_int|0
)paren
id|base_addr
(braket
id|CyRTPRH
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set up RTS here also ????? RGH 141095 */
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
multiline_comment|/* baud rate is zero, turn off line */
r_if
c_cond
(paren
(paren
id|base_addr
(braket
id|CyMSVR2
)braket
op_amp
id|CyDTR
)paren
op_eq
id|CyDTR
)paren
id|base_addr
(braket
id|CyMSVR2
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: dropping DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
)braket
comma
id|base_addr
(braket
id|CyMSVR2
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|base_addr
(braket
id|CyMSVR2
)braket
op_amp
id|CyDTR
)paren
op_ne
id|CyDTR
)paren
id|base_addr
(braket
id|CyMSVR2
)braket
op_assign
id|CyDTR
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: raising DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
)braket
comma
id|base_addr
(braket
id|CyMSVR2
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|info-&gt;tty
)paren
(brace
id|clear_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* config_setup */
r_static
r_void
DECL|function|cy_put_char
id|cy_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;cy_put_char ttyS%d(0x%02x)&bslash;n&quot;
comma
id|info-&gt;line
comma
id|ch
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_put_char&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
op_logical_neg
id|info-&gt;xmit_buf
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
op_ge
id|PAGE_SIZE
op_minus
l_int|1
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|info-&gt;xmit_buf
(braket
id|info-&gt;xmit_head
op_increment
)braket
op_assign
id|ch
suffix:semicolon
id|info-&gt;xmit_head
op_and_assign
id|PAGE_SIZE
op_minus
l_int|1
suffix:semicolon
id|info-&gt;xmit_cnt
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* cy_put_char */
r_static
r_void
DECL|function|cy_flush_chars
id|cy_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;cy_flush_chars ttyS%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_flush_chars&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
op_le
l_int|0
op_logical_or
id|tty-&gt;stopped
op_logical_or
id|tty-&gt;hw_stopped
op_logical_or
op_logical_neg
id|info-&gt;xmit_buf
)paren
r_return
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyIER
)braket
op_or_assign
id|CyTxMpty
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* cy_flush_chars */
multiline_comment|/* This routine gets called when tty_write has put something into&n;    the write_queue.  If the port is not already transmitting stuff,&n;    start it off by enabling interrupts.  The interrupt service&n;    routine will then ensure that the characters are sent.  If the&n;    port is already active, there is no need to kick it.&n; */
r_static
r_int
DECL|function|cy_write
id|cy_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|c
comma
id|total
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;cy_write ttyS%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_write&quot;
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
op_logical_neg
id|info-&gt;xmit_buf
op_logical_or
op_logical_neg
id|tmp_buf
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|c
op_assign
id|MIN
c_func
(paren
id|count
comma
id|MIN
c_func
(paren
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_cnt
op_minus
l_int|1
comma
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_head
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|from_user
)paren
(brace
id|down
c_func
(paren
op_amp
id|tmp_buf_sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|tmp_buf
comma
id|buf
comma
id|c
)paren
)paren
(brace
id|up
c_func
(paren
op_amp
id|tmp_buf_sem
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|c
op_assign
id|MIN
c_func
(paren
id|c
comma
id|MIN
c_func
(paren
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_cnt
op_minus
l_int|1
comma
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_head
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|info-&gt;xmit_buf
op_plus
id|info-&gt;xmit_head
comma
id|tmp_buf
comma
id|c
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|tmp_buf_sem
)paren
suffix:semicolon
)brace
r_else
id|memcpy
c_func
(paren
id|info-&gt;xmit_buf
op_plus
id|info-&gt;xmit_head
comma
id|buf
comma
id|c
)paren
suffix:semicolon
id|info-&gt;xmit_head
op_assign
(paren
id|info-&gt;xmit_head
op_plus
id|c
)paren
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|info-&gt;xmit_cnt
op_add_assign
id|c
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|buf
op_add_assign
id|c
suffix:semicolon
id|count
op_sub_assign
id|c
suffix:semicolon
id|total
op_add_assign
id|c
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
op_logical_and
op_logical_neg
id|tty-&gt;stopped
op_logical_and
op_logical_neg
id|tty-&gt;hw_stopped
)paren
(brace
id|start_xmit
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
r_return
id|total
suffix:semicolon
)brace
multiline_comment|/* cy_write */
r_static
r_int
DECL|function|cy_write_room
id|cy_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|ret
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;cy_write_room ttyS%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_write_room&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|ret
op_assign
id|PAGE_SIZE
op_minus
id|info-&gt;xmit_cnt
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* cy_write_room */
r_static
r_int
DECL|function|cy_chars_in_buffer
id|cy_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;cy_chars_in_buffer ttyS%d %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;xmit_cnt
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_chars_in_buffer&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|info-&gt;xmit_cnt
suffix:semicolon
)brace
multiline_comment|/* cy_chars_in_buffer */
r_static
r_void
DECL|function|cy_flush_buffer
id|cy_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;cy_flush_buffer ttyS%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_flush_buffer&quot;
)paren
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|info-&gt;xmit_cnt
op_assign
id|info-&gt;xmit_head
op_assign
id|info-&gt;xmit_tail
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* cy_flush_buffer */
multiline_comment|/* This routine is called by the upper-layer tty layer to signal&n;   that incoming characters should be throttled or that the&n;   throttle should be released.&n; */
r_static
r_void
DECL|function|cy_throttle
id|cy_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_THROTTLE
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;throttle %s: %d....&bslash;n&quot;
comma
id|_tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
comma
id|tty-&gt;ldisc
dot
id|chars_in_buffer
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cy_throttle ttyS%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_nthrottle&quot;
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
(brace
id|info-&gt;x_char
op_assign
id|STOP_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/* Should use the &quot;Send Special Character&quot; feature!!! */
)brace
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
)braket
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* cy_throttle */
r_static
r_void
DECL|function|cy_unthrottle
id|cy_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_THROTTLE
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;throttle %s: %d....&bslash;n&quot;
comma
id|_tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
comma
id|tty-&gt;ldisc
dot
id|chars_in_buffer
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cy_unthrottle ttyS%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_nthrottle&quot;
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
(brace
id|info-&gt;x_char
op_assign
id|START_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/* Should use the &quot;Send Special Character&quot; feature!!! */
)brace
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
)braket
op_assign
id|CyRTS
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* cy_unthrottle */
r_static
r_int
DECL|function|get_serial_info
id|get_serial_info
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_struct
id|serial_struct
op_star
id|retinfo
)paren
(brace
r_struct
id|serial_struct
id|tmp
suffix:semicolon
multiline_comment|/* CP(&squot;g&squot;); */
r_if
c_cond
(paren
op_logical_neg
id|retinfo
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|tmp.type
op_assign
id|info-&gt;type
suffix:semicolon
id|tmp.line
op_assign
id|info-&gt;line
suffix:semicolon
id|tmp.port
op_assign
id|info-&gt;line
suffix:semicolon
id|tmp.irq
op_assign
l_int|0
suffix:semicolon
id|tmp.flags
op_assign
id|info-&gt;flags
suffix:semicolon
id|tmp.baud_base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*!!!*/
id|tmp.close_delay
op_assign
id|info-&gt;close_delay
suffix:semicolon
id|tmp.custom_divisor
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*!!!*/
id|tmp.hub6
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*!!!*/
r_return
id|copy_to_user
c_func
(paren
id|retinfo
comma
op_amp
id|tmp
comma
r_sizeof
(paren
op_star
id|retinfo
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* get_serial_info */
r_static
r_int
DECL|function|set_serial_info
id|set_serial_info
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_struct
id|serial_struct
op_star
id|new_info
)paren
(brace
r_struct
id|serial_struct
id|new_serial
suffix:semicolon
r_struct
id|cyclades_port
id|old_info
suffix:semicolon
multiline_comment|/* CP(&squot;s&squot;); */
r_if
c_cond
(paren
op_logical_neg
id|new_info
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|new_serial
comma
id|new_info
comma
r_sizeof
(paren
id|new_serial
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|old_info
op_assign
op_star
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|new_serial.close_delay
op_ne
id|info-&gt;close_delay
)paren
op_logical_or
(paren
(paren
id|new_serial.flags
op_amp
id|ASYNC_FLAGS
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
op_ne
(paren
id|info-&gt;flags
op_amp
id|ASYNC_FLAGS
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|info-&gt;flags
op_assign
(paren
(paren
id|info-&gt;flags
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
op_or
(paren
id|new_serial.flags
op_amp
id|ASYNC_USR_MASK
)paren
)paren
suffix:semicolon
r_goto
id|check_and_exit
suffix:semicolon
)brace
multiline_comment|/*&n;     * OK, past this point, all the error checking has been done.&n;     * At this point, we start making changes.....&n;     */
id|info-&gt;flags
op_assign
(paren
(paren
id|info-&gt;flags
op_amp
op_complement
id|ASYNC_FLAGS
)paren
op_or
(paren
id|new_serial.flags
op_amp
id|ASYNC_FLAGS
)paren
)paren
suffix:semicolon
id|info-&gt;close_delay
op_assign
id|new_serial.close_delay
suffix:semicolon
id|check_and_exit
suffix:colon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
(brace
id|config_setup
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_return
id|startup
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* set_serial_info */
r_static
r_int
DECL|function|get_modem_info
id|get_modem_info
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
id|channel
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
r_int
id|result
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|status
op_assign
id|base_addr
(braket
id|CyMSVR1
)braket
op_or
id|base_addr
(braket
id|CyMSVR2
)braket
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|result
op_assign
(paren
(paren
id|status
op_amp
id|CyRTS
)paren
ques
c_cond
id|TIOCM_RTS
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
id|CyDTR
)paren
ques
c_cond
id|TIOCM_DTR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
id|CyDCD
)paren
ques
c_cond
id|TIOCM_CAR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
id|CyDSR
)paren
ques
c_cond
id|TIOCM_DSR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
id|CyCTS
)paren
ques
c_cond
id|TIOCM_CTS
suffix:colon
l_int|0
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|result
comma
(paren
r_int
r_int
op_star
)paren
id|value
)paren
suffix:semicolon
)brace
multiline_comment|/* get_modem_info */
r_static
r_int
DECL|function|set_modem_info
id|set_modem_info
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
id|cmd
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
id|channel
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|arg
comma
(paren
r_int
r_int
op_star
)paren
id|value
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMBIS
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
)braket
op_assign
id|CyRTS
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
multiline_comment|/* CP(&squot;S&squot;);CP(&squot;2&squot;); */
id|base_addr
(braket
id|CyMSVR2
)braket
op_assign
id|CyDTR
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: raising DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
)braket
comma
id|base_addr
(braket
id|CyMSVR2
)braket
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMBIC
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
)braket
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
multiline_comment|/* CP(&squot;C&squot;);CP(&squot;2&squot;); */
id|base_addr
(braket
id|CyMSVR2
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: dropping DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
)braket
comma
id|base_addr
(braket
id|CyMSVR2
)braket
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
)braket
op_assign
id|CyRTS
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
)braket
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
multiline_comment|/* CP(&squot;S&squot;);CP(&squot;3&squot;); */
id|base_addr
(braket
id|CyMSVR2
)braket
op_assign
id|CyDTR
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: raising DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
)braket
comma
id|base_addr
(braket
id|CyMSVR2
)braket
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
multiline_comment|/* CP(&squot;C&squot;);CP(&squot;3&squot;); */
id|base_addr
(braket
id|CyMSVR2
)braket
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: dropping DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
)braket
comma
id|base_addr
(braket
id|CyMSVR2
)braket
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set_modem_info */
r_static
r_void
DECL|function|send_break
id|send_break
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
id|duration
)paren
(brace
multiline_comment|/* Let the transmit ISR take care of this (since it&n;     requires stuffing characters into the output stream).&n;   */
id|info-&gt;x_break
op_assign
id|duration
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;xmit_cnt
)paren
(brace
id|start_xmit
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* send_break */
r_static
r_int
DECL|function|get_mon_info
id|get_mon_info
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_struct
id|cyclades_monitor
op_star
id|mon
)paren
(brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|mon
comma
op_amp
id|info-&gt;mon
comma
r_sizeof
(paren
r_struct
id|cyclades_monitor
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|info-&gt;mon.int_count
op_assign
l_int|0
suffix:semicolon
id|info-&gt;mon.char_count
op_assign
l_int|0
suffix:semicolon
id|info-&gt;mon.char_max
op_assign
l_int|0
suffix:semicolon
id|info-&gt;mon.char_last
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_threshold
id|set_threshold
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
op_star
id|arg
)paren
(brace
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
r_int
id|value
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|value
comma
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
id|info-&gt;cor4
op_and_assign
op_complement
id|CyREC_FIFO
suffix:semicolon
id|info-&gt;cor4
op_or_assign
id|value
op_amp
id|CyREC_FIFO
suffix:semicolon
id|base_addr
(braket
id|CyCOR4
)braket
op_assign
id|info-&gt;cor4
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|get_threshold
id|get_threshold
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
id|tmp
op_assign
id|base_addr
(braket
id|CyCOR4
)braket
op_amp
id|CyREC_FIFO
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|tmp
comma
id|value
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_default_threshold
id|set_default_threshold
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
op_star
id|arg
)paren
(brace
r_int
r_int
id|value
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|value
comma
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|info-&gt;default_threshold
op_assign
id|value
op_amp
l_int|0x0f
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|get_default_threshold
id|get_default_threshold
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_return
id|put_user
c_func
(paren
id|info-&gt;default_threshold
comma
id|value
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_timeout
id|set_timeout
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
op_star
id|arg
)paren
(brace
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
r_int
id|value
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|value
comma
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
id|base_addr
(braket
id|CyRTPRL
)braket
op_assign
id|value
op_amp
l_int|0xff
suffix:semicolon
id|base_addr
(braket
id|CyRTPRH
)braket
op_assign
(paren
id|value
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|get_timeout
id|get_timeout
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
id|tmp
op_assign
id|base_addr
(braket
id|CyRTPRL
)braket
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|tmp
comma
id|value
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_default_timeout
id|set_default_timeout
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
id|value
)paren
(brace
id|info-&gt;default_timeout
op_assign
id|value
op_amp
l_int|0xff
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|get_default_timeout
id|get_default_timeout
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_return
id|put_user
c_func
(paren
id|info-&gt;default_timeout
comma
id|value
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cy_ioctl
id|cy_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|val
suffix:semicolon
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|ret_val
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_ioctl ttyS%d, cmd = %x arg = %lx&bslash;n&quot;
comma
id|info-&gt;line
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CYGETMON
suffix:colon
id|ret_val
op_assign
id|get_mon_info
c_func
(paren
id|info
comma
(paren
r_struct
id|cyclades_monitor
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYGETTHRESH
suffix:colon
id|ret_val
op_assign
id|get_threshold
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYSETTHRESH
suffix:colon
id|ret_val
op_assign
id|set_threshold
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYGETDEFTHRESH
suffix:colon
id|ret_val
op_assign
id|get_default_threshold
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYSETDEFTHRESH
suffix:colon
id|ret_val
op_assign
id|set_default_threshold
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYGETTIMEOUT
suffix:colon
id|ret_val
op_assign
id|get_timeout
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYSETTIMEOUT
suffix:colon
id|ret_val
op_assign
id|set_timeout
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYGETDEFTIMEOUT
suffix:colon
id|ret_val
op_assign
id|get_default_timeout
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYSETDEFTIMEOUT
suffix:colon
id|ret_val
op_assign
id|set_default_timeout
c_func
(paren
id|info
comma
(paren
r_int
r_int
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCSBRK
suffix:colon
multiline_comment|/* SVID version: non-zero arg --&gt; no break */
id|ret_val
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
)paren
r_break
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
id|send_break
c_func
(paren
id|info
comma
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
multiline_comment|/* 1/4 second */
r_break
suffix:semicolon
r_case
id|TCSBRKP
suffix:colon
multiline_comment|/* support for POSIX tcsendbreak() */
id|ret_val
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
)paren
r_break
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
id|send_break
c_func
(paren
id|info
comma
id|arg
ques
c_cond
id|arg
op_star
(paren
id|HZ
op_div
l_int|10
)paren
suffix:colon
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
r_case
id|TIOCMBIC
suffix:colon
r_case
id|TIOCMSET
suffix:colon
id|ret_val
op_assign
id|set_modem_info
c_func
(paren
id|info
comma
id|cmd
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* The following commands are incompletely implemented!!! */
r_case
id|TIOCGSOFTCAR
suffix:colon
id|ret_val
op_assign
id|put_user
c_func
(paren
id|C_CLOCAL
c_func
(paren
id|tty
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSSOFTCAR
suffix:colon
id|ret_val
op_assign
id|get_user
c_func
(paren
id|val
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
)paren
r_break
suffix:semicolon
id|tty-&gt;termios-&gt;c_cflag
op_assign
(paren
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
op_complement
id|CLOCAL
)paren
op_or
(paren
id|val
ques
c_cond
id|CLOCAL
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMGET
suffix:colon
id|ret_val
op_assign
id|get_modem_info
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCGSERIAL
suffix:colon
id|ret_val
op_assign
id|get_serial_info
c_func
(paren
id|info
comma
(paren
r_struct
id|serial_struct
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSSERIAL
suffix:colon
id|ret_val
op_assign
id|set_serial_info
c_func
(paren
id|info
comma
(paren
r_struct
id|serial_struct
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret_val
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_ioctl done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* cy_ioctl */
r_static
r_void
DECL|function|cy_set_termios
id|cy_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_set_termios ttyS%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_eq
id|old_termios-&gt;c_cflag
)paren
r_return
suffix:semicolon
id|config_setup
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
op_logical_and
op_logical_neg
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
)paren
(brace
id|tty-&gt;stopped
op_assign
l_int|0
suffix:semicolon
id|cy_start
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
macro_line|#ifdef tytso_patch_94Nov25_1726
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
op_logical_and
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* cy_set_termios */
r_static
r_void
DECL|function|cy_close
id|cy_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
multiline_comment|/* CP(&squot;C&squot;); */
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_close ttyS%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|info
op_logical_or
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_close&quot;
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;cy_close ttyS%d, count = %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|tty-&gt;count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|info-&gt;count
op_ne
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t; * Uh, oh.  tty-&gt;count is 1, which means that the tty&n;&t; * structure will be freed.  Info-&gt;count should always&n;&t; * be one in these conditions.  If it&squot;s greater than&n;&t; * one, we&squot;ve got real problems, since it means the&n;&t; * serial port won&squot;t be shutdown.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;cy_close: bad serial port count; tty-&gt;count is 1, &quot;
l_string|&quot;info-&gt;count is %d&bslash;n&quot;
comma
id|info-&gt;count
)paren
suffix:semicolon
id|info-&gt;count
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_COUNT
id|printk
c_func
(paren
l_string|&quot;cyc: %d: decrementing count to %d&bslash;n&quot;
comma
id|__LINE__
comma
id|info-&gt;count
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_decrement
id|info-&gt;count
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cy_close: bad serial port count for ttys%d: %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_COUNT
id|printk
c_func
(paren
l_string|&quot;cyc: %d: setting count to 0&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;count
)paren
r_return
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|ASYNC_CLOSING
suffix:semicolon
multiline_comment|/*&n;     * Save the termios structure, since this port may have&n;     * separate termios for callout and dialin.&n;     */
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
id|info-&gt;normal_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
id|info-&gt;callout_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|3000
)paren
suffix:semicolon
multiline_comment|/* 30 seconds timeout */
id|shutdown
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|info-&gt;event
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tty
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.num
op_ne
id|ldiscs
(braket
id|N_TTY
)braket
dot
id|num
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;ldisc.close
)paren
(paren
id|tty-&gt;ldisc.close
)paren
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;ldisc
op_assign
id|ldiscs
(braket
id|N_TTY
)braket
suffix:semicolon
id|tty-&gt;termios-&gt;c_line
op_assign
id|N_TTY
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.open
)paren
(paren
id|tty-&gt;ldisc.open
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;blocked_open
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;close_delay
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|info-&gt;close_delay
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
)brace
id|info-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
op_or
id|ASYNC_CLOSING
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_close done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* cy_close */
multiline_comment|/*&n; * cy_hangup() --- called by tty_hangup() when a hangup is signaled.&n; */
r_void
DECL|function|cy_hangup
id|cy_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_hangup ttyS%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_hangup&quot;
)paren
)paren
r_return
suffix:semicolon
id|shutdown
c_func
(paren
id|info
)paren
suffix:semicolon
macro_line|#if 0
id|info-&gt;event
op_assign
l_int|0
suffix:semicolon
id|info-&gt;count
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_COUNT
id|printk
c_func
(paren
l_string|&quot;cyc: %d: setting count to 0&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;tty
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|info-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* cy_hangup */
multiline_comment|/*&n; * ------------------------------------------------------------&n; * cy_open() and friends&n; * ------------------------------------------------------------&n; */
r_static
r_int
DECL|function|block_til_ready
id|block_til_ready
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
r_struct
id|cyclades_port
op_star
id|info
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_volatile
id|u_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
multiline_comment|/*&n;     * If the device is in the middle of being closed, then block&n;     * until it&squot;s done, and then try again.&n;     */
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
(brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * If this is a callout device, then just make sure the normal&n;     * device isn&squot;t being used.&n;     */
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_CALLOUT
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SESSION_LOCKOUT
)paren
op_logical_and
(paren
id|info-&gt;session
op_ne
id|current-&gt;session
)paren
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_PGRP_LOCKOUT
)paren
op_logical_and
(paren
id|info-&gt;pgrp
op_ne
id|current-&gt;pgrp
)paren
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|info-&gt;flags
op_or_assign
id|ASYNC_CALLOUT_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * If non-blocking mode is set, then make the check up front&n;     * and then exit.&n;     */
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|info-&gt;flags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * Block waiting for the carrier detect and the line to become&n;     * free (i.e., not in use by the callout).  While we are in&n;     * this loop, info-&gt;count is dropped by one, so that&n;     * cy_close() knows when to free things.  We restore it upon&n;     * exit, either normal or abnormal.&n;     */
id|retval
op_assign
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|info-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;block_til_ready before block: ttyS%d, count = %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
multiline_comment|/**/
macro_line|#endif
id|info-&gt;count
op_decrement
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_COUNT
id|printk
c_func
(paren
l_string|&quot;cyc: %d: decrementing count to %d&bslash;n&quot;
comma
id|__LINE__
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;blocked_open
op_increment
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
)paren
(brace
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
)braket
op_assign
id|CyRTS
suffix:semicolon
multiline_comment|/* CP(&squot;S&squot;);CP(&squot;4&squot;); */
id|base_addr
(braket
id|CyMSVR2
)braket
op_assign
id|CyDTR
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: raising DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
)braket
comma
id|base_addr
(braket
id|CyMSVR2
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
multiline_comment|/* CP(&squot;L&squot;);CP1(1 &amp;&amp; C_CLOCAL(tty)); CP1(1 &amp;&amp; (base_addr[CyMSVR1] &amp; CyDCD) ); */
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
op_logical_and
(paren
id|C_CLOCAL
c_func
(paren
id|tty
)paren
op_logical_or
(paren
id|base_addr
(braket
id|CyMSVR1
)braket
op_amp
id|CyDCD
)paren
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;block_til_ready blocking: ttyS%d, count = %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
multiline_comment|/**/
macro_line|#endif
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|info-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|info-&gt;count
op_increment
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_COUNT
id|printk
c_func
(paren
l_string|&quot;cyc: %d: incrementing count to %d&bslash;n&quot;
comma
id|__LINE__
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
)brace
id|info-&gt;blocked_open
op_decrement
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;block_til_ready after blocking: ttyS%d, count = %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
multiline_comment|/**/
macro_line|#endif
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* block_til_ready */
multiline_comment|/*&n; * This routine is called whenever a serial port is opened.  It&n; * performs the serial-specific initialization for the tty structure.&n; */
r_int
DECL|function|cy_open
id|cy_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
suffix:semicolon
r_int
id|retval
comma
id|line
suffix:semicolon
multiline_comment|/* CP(&squot;O&squot;); */
id|line
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
suffix:semicolon
r_if
c_cond
(paren
(paren
id|line
OL
l_int|0
)paren
op_logical_or
(paren
id|NR_PORTS
op_le
id|line
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|info
op_assign
op_amp
id|cy_port
(braket
id|line
)braket
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;line
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_open ttyS%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_open&quot;
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;cy_open ttyS%d, count = %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
multiline_comment|/**/
macro_line|#endif
id|info-&gt;count
op_increment
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_COUNT
id|printk
c_func
(paren
l_string|&quot;cyc: %d: incrementing count to %d&bslash;n&quot;
comma
id|__LINE__
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
id|tty-&gt;driver_data
op_assign
id|info
suffix:semicolon
id|info-&gt;tty
op_assign
id|tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_buf
)paren
(brace
id|tmp_buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_buf
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|info-&gt;count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SPLIT_TERMIOS
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_NORMAL
)paren
op_star
id|tty-&gt;termios
op_assign
id|info-&gt;normal_termios
suffix:semicolon
r_else
op_star
id|tty-&gt;termios
op_assign
id|info-&gt;callout_termios
suffix:semicolon
)brace
multiline_comment|/*&n;     * Start up serial port&n;     */
id|retval
op_assign
id|startup
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
r_return
id|retval
suffix:semicolon
)brace
id|retval
op_assign
id|block_til_ready
c_func
(paren
id|tty
comma
id|filp
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;cy_open returning after block_til_ready with %d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
macro_line|#endif
r_return
id|retval
suffix:semicolon
)brace
id|info-&gt;session
op_assign
id|current-&gt;session
suffix:semicolon
id|info-&gt;pgrp
op_assign
id|current-&gt;pgrp
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;cy_open done&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/**/
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* cy_open */
multiline_comment|/*&n; * ---------------------------------------------------------------------&n; * serial167_init() and friends&n; *&n; * serial167_init() is called at boot-time to initialize the serial driver.&n; * ---------------------------------------------------------------------&n; */
multiline_comment|/*&n; * This routine prints out the appropriate serial driver version&n; * number, and identifies which options were configured into this&n; * driver.&n; */
r_static
r_void
DECL|function|show_version
id|show_version
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;MVME166/167 cd2401 driver&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* show_version */
multiline_comment|/* initialize chips on card -- return number of valid&n;   chips (which is number of ports/4) */
multiline_comment|/*&n; * This initialises the hardware to a reasonable state.  It should&n; * probe the chip first so as to copy 166-Bug setup as a default for&n; * port 0.  It initialises CMR to CyASYNC; that is never done again, so&n; * as to limit the number of CyINIT_CHAN commands in normal running.&n; *&n; * ... I wonder what I should do if this fails ...&n; */
r_void
DECL|function|mvme167_serial_console_setup
id|mvme167_serial_console_setup
c_func
(paren
r_int
id|cflag
)paren
(brace
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|ch
suffix:semicolon
id|u_char
id|spd
suffix:semicolon
id|u_char
id|rcor
comma
id|rbpr
comma
id|badspeed
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First probe channel zero of the chip, to see what speed has&n;&t; * been selected.&n;&t; */
id|base_addr
(braket
id|CyCAR
)braket
op_assign
l_int|0
suffix:semicolon
id|rcor
op_assign
id|base_addr
(braket
id|CyRCOR
)braket
op_lshift
l_int|5
suffix:semicolon
id|rbpr
op_assign
id|base_addr
(braket
id|CyRBPR
)braket
suffix:semicolon
r_for
c_loop
(paren
id|spd
op_assign
l_int|0
suffix:semicolon
id|spd
OL
r_sizeof
(paren
id|baud_bpr
)paren
suffix:semicolon
id|spd
op_increment
)paren
r_if
c_cond
(paren
id|rbpr
op_eq
id|baud_bpr
(braket
id|spd
)braket
op_logical_and
id|rcor
op_eq
id|baud_co
(braket
id|spd
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|spd
op_ge
r_sizeof
(paren
id|baud_bpr
)paren
)paren
(brace
id|spd
op_assign
l_int|14
suffix:semicolon
multiline_comment|/* 19200 */
id|badspeed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Failed to identify speed */
)brace
id|initial_console_speed
op_assign
id|spd
suffix:semicolon
multiline_comment|/* OK, we have chosen a speed, now reset and reinitialise */
id|my_udelay
c_func
(paren
l_int|20000L
)paren
suffix:semicolon
multiline_comment|/* Allow time for any active o/p to complete */
r_if
c_cond
(paren
id|base_addr
(braket
id|CyCCR
)braket
op_ne
l_int|0x00
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* printk(&quot; chip is never idle (CCR != 0)&bslash;n&quot;); */
r_return
suffix:semicolon
)brace
id|base_addr
(braket
id|CyCCR
)braket
op_assign
id|CyCHIP_RESET
suffix:semicolon
multiline_comment|/* Reset the chip */
id|my_udelay
c_func
(paren
l_int|1000L
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyGFRCR
)braket
op_eq
l_int|0x00
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* printk(&quot; chip is not responding (GFRCR stayed 0)&bslash;n&quot;); */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * System clock is 20Mhz, divided by 2048, so divide by 10 for a 1.0ms&n;&t; * tick&n;&t; */
id|base_addr
(braket
id|CyTPR
)braket
op_assign
l_int|10
suffix:semicolon
id|base_addr
(braket
id|CyPILR1
)braket
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* Interrupt level for modem change */
id|base_addr
(braket
id|CyPILR2
)braket
op_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* Interrupt level for tx ints */
id|base_addr
(braket
id|CyPILR3
)braket
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* Interrupt level for rx ints */
multiline_comment|/*&n;&t; * Attempt to set up all channels to something reasonable, and&n;&t; * bang out a INIT_CHAN command.  We should then be able to limit&n;&t; * the ammount of fiddling we have to do in normal running.&n;&t; */
r_for
c_loop
(paren
id|ch
op_assign
l_int|3
suffix:semicolon
id|ch
op_ge
l_int|0
suffix:semicolon
id|ch
op_decrement
)paren
(brace
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|ch
suffix:semicolon
id|base_addr
(braket
id|CyIER
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyCMR
)braket
op_assign
id|CyASYNC
suffix:semicolon
id|base_addr
(braket
id|CyLICR
)braket
op_assign
(paren
id|u_char
)paren
id|ch
op_lshift
l_int|2
suffix:semicolon
id|base_addr
(braket
id|CyLIVR
)braket
op_assign
l_int|0x5c
suffix:semicolon
id|base_addr
(braket
id|CyTCOR
)braket
op_assign
id|baud_co
(braket
id|spd
)braket
suffix:semicolon
id|base_addr
(braket
id|CyTBPR
)braket
op_assign
id|baud_bpr
(braket
id|spd
)braket
suffix:semicolon
id|base_addr
(braket
id|CyRCOR
)braket
op_assign
id|baud_co
(braket
id|spd
)braket
op_rshift
l_int|5
suffix:semicolon
id|base_addr
(braket
id|CyRBPR
)braket
op_assign
id|baud_bpr
(braket
id|spd
)braket
suffix:semicolon
id|base_addr
(braket
id|CySCHR1
)braket
op_assign
l_char|&squot;Q&squot;
op_amp
l_int|0x1f
suffix:semicolon
id|base_addr
(braket
id|CySCHR2
)braket
op_assign
l_char|&squot;X&squot;
op_amp
l_int|0x1f
suffix:semicolon
id|base_addr
(braket
id|CySCRL
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CySCRH
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyCOR1
)braket
op_assign
id|Cy_8_BITS
op_or
id|CyPARITY_NONE
suffix:semicolon
id|base_addr
(braket
id|CyCOR2
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyCOR3
)braket
op_assign
id|Cy_1_STOP
suffix:semicolon
id|base_addr
(braket
id|CyCOR4
)braket
op_assign
id|baud_cor4
(braket
id|spd
)braket
suffix:semicolon
id|base_addr
(braket
id|CyCOR5
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyCOR6
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyCOR7
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyRTPRL
)braket
op_assign
l_int|2
suffix:semicolon
id|base_addr
(braket
id|CyRTPRH
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyMSVR2
)braket
op_assign
l_int|0
suffix:semicolon
id|write_cy_cmd
c_func
(paren
id|base_addr
comma
id|CyINIT_CHAN
op_or
id|CyDIS_RCVR
op_or
id|CyDIS_XMTR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now do specials for channel zero....&n;&t; */
id|base_addr
(braket
id|CyMSVR1
)braket
op_assign
id|CyRTS
suffix:semicolon
id|base_addr
(braket
id|CyMSVR2
)braket
op_assign
id|CyDTR
suffix:semicolon
id|base_addr
(braket
id|CyIER
)braket
op_assign
id|CyRxData
suffix:semicolon
id|write_cy_cmd
c_func
(paren
id|base_addr
comma
id|CyENB_RCVR
op_or
id|CyENB_XMTR
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|my_udelay
c_func
(paren
l_int|20000L
)paren
suffix:semicolon
multiline_comment|/* Let it all settle down */
id|printk
c_func
(paren
l_string|&quot;CD2401 initialised,  chip is rev 0x%02x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyGFRCR
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|badspeed
)paren
id|printk
c_func
(paren
l_string|&quot;  WARNING:  Failed to identify line speed, rcor=%02x,rbpr=%02x&bslash;n&quot;
comma
id|rcor
op_rshift
l_int|5
comma
id|rbpr
)paren
suffix:semicolon
)brace
multiline_comment|/* serial_console_init */
multiline_comment|/* The serial driver boot-time initialization code!&n;    Hardware I/O ports are mapped to character special devices on a&n;    first found, first allocated manner.  That is, this code searches&n;    for Cyclom cards in the system.  As each is found, it is probed&n;    to discover how many chips (and thus how many ports) are present.&n;    These ports are mapped to the tty ports 64 and upward in monotonic&n;    fashion.  If an 8-port card is replaced with a 16-port card, the&n;    port mapping on a following card will shift.&n;&n;    This approach is different from what is used in the other serial&n;    device driver because the Cyclom is more properly a multiplexer,&n;    not just an aggregation of serial ports on one card.&n;&n;    If there are more cards with more ports than have been statically&n;    allocated above, a warning is printed and the extra ports are ignored.&n; */
r_int
DECL|function|serial167_init
id|serial167_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_int
id|good_ports
op_assign
l_int|0
suffix:semicolon
r_int
id|port_num
op_assign
l_int|0
suffix:semicolon
r_int
id|index
suffix:semicolon
r_int
id|DefSpeed
suffix:semicolon
macro_line|#ifdef notyet
r_struct
id|sigaction
id|sa
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|mvme16x_config
op_amp
id|MVME16x_CONFIG_GOT_CD2401
)paren
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#if 0
id|scrn
(braket
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
macro_line|#endif
id|show_version
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Has &quot;console=0,9600n8&quot; been used in bootinfo to change speed? */
r_if
c_cond
(paren
id|serial_console_cflag
)paren
id|DefSpeed
op_assign
id|serial_console_cflag
op_amp
l_int|0017
suffix:semicolon
r_else
(brace
id|DefSpeed
op_assign
id|initial_console_speed
suffix:semicolon
id|serial_console_info
op_assign
op_amp
id|cy_port
(braket
l_int|0
)braket
suffix:semicolon
id|serial_console_cflag
op_assign
id|DefSpeed
op_or
id|CS8
suffix:semicolon
macro_line|#if 0
id|serial_console
op_assign
l_int|64
suffix:semicolon
multiline_comment|/*callout_driver.minor_start*/
macro_line|#endif
)brace
multiline_comment|/* Initialize the tty_driver structure */
id|memset
c_func
(paren
op_amp
id|cy_serial_driver
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|cy_serial_driver.magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
id|cy_serial_driver.name
op_assign
l_string|&quot;ttyS&quot;
suffix:semicolon
id|cy_serial_driver.major
op_assign
id|TTY_MAJOR
suffix:semicolon
id|cy_serial_driver.minor_start
op_assign
l_int|64
suffix:semicolon
id|cy_serial_driver.num
op_assign
id|NR_PORTS
suffix:semicolon
id|cy_serial_driver.type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
id|cy_serial_driver.subtype
op_assign
id|SERIAL_TYPE_NORMAL
suffix:semicolon
id|cy_serial_driver.init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|cy_serial_driver.init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
id|cy_serial_driver.flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
id|cy_serial_driver.refcount
op_assign
op_amp
id|serial_refcount
suffix:semicolon
id|cy_serial_driver.table
op_assign
id|serial_table
suffix:semicolon
id|cy_serial_driver.termios
op_assign
id|serial_termios
suffix:semicolon
id|cy_serial_driver.termios_locked
op_assign
id|serial_termios_locked
suffix:semicolon
id|cy_serial_driver.open
op_assign
id|cy_open
suffix:semicolon
id|cy_serial_driver.close
op_assign
id|cy_close
suffix:semicolon
id|cy_serial_driver.write
op_assign
id|cy_write
suffix:semicolon
id|cy_serial_driver.put_char
op_assign
id|cy_put_char
suffix:semicolon
id|cy_serial_driver.flush_chars
op_assign
id|cy_flush_chars
suffix:semicolon
id|cy_serial_driver.write_room
op_assign
id|cy_write_room
suffix:semicolon
id|cy_serial_driver.chars_in_buffer
op_assign
id|cy_chars_in_buffer
suffix:semicolon
id|cy_serial_driver.flush_buffer
op_assign
id|cy_flush_buffer
suffix:semicolon
id|cy_serial_driver.ioctl
op_assign
id|cy_ioctl
suffix:semicolon
id|cy_serial_driver.throttle
op_assign
id|cy_throttle
suffix:semicolon
id|cy_serial_driver.unthrottle
op_assign
id|cy_unthrottle
suffix:semicolon
id|cy_serial_driver.set_termios
op_assign
id|cy_set_termios
suffix:semicolon
id|cy_serial_driver.stop
op_assign
id|cy_stop
suffix:semicolon
id|cy_serial_driver.start
op_assign
id|cy_start
suffix:semicolon
id|cy_serial_driver.hangup
op_assign
id|cy_hangup
suffix:semicolon
multiline_comment|/*&n;     * The callout device is just like normal device except for&n;     * major number and the subtype code.&n;     */
id|cy_callout_driver
op_assign
id|cy_serial_driver
suffix:semicolon
id|cy_callout_driver.name
op_assign
l_string|&quot;cua&quot;
suffix:semicolon
id|cy_callout_driver.major
op_assign
id|TTYAUX_MAJOR
suffix:semicolon
id|cy_callout_driver.subtype
op_assign
id|SERIAL_TYPE_CALLOUT
suffix:semicolon
id|ret
op_assign
id|tty_register_driver
c_func
(paren
op_amp
id|cy_serial_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Couldn&squot;t register MVME166/7 serial driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|ret
op_assign
id|tty_register_driver
c_func
(paren
op_amp
id|cy_callout_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Couldn&squot;t register MVME166/7 callout driver&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_serial_driver
suffix:semicolon
)brace
id|init_bh
c_func
(paren
id|CYCLADES_BH
comma
id|do_cyclades_bh
)paren
suffix:semicolon
id|port_num
op_assign
l_int|0
suffix:semicolon
id|info
op_assign
id|cy_port
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
l_int|1
suffix:semicolon
id|index
op_increment
)paren
(brace
id|good_ports
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|port_num
OL
id|NR_PORTS
)paren
(brace
r_while
c_loop
(paren
id|good_ports
op_decrement
op_logical_and
id|port_num
OL
id|NR_PORTS
)paren
(brace
multiline_comment|/*** initialize port ***/
id|info-&gt;magic
op_assign
id|CYCLADES_MAGIC
suffix:semicolon
id|info-&gt;type
op_assign
id|PORT_CIRRUS
suffix:semicolon
id|info-&gt;card
op_assign
id|index
suffix:semicolon
id|info-&gt;line
op_assign
id|port_num
suffix:semicolon
id|info-&gt;flags
op_assign
id|STD_COM_FLAGS
suffix:semicolon
id|info-&gt;tty
op_assign
l_int|0
suffix:semicolon
id|info-&gt;xmit_fifo_size
op_assign
l_int|12
suffix:semicolon
id|info-&gt;cor1
op_assign
id|CyPARITY_NONE
op_or
id|Cy_8_BITS
suffix:semicolon
id|info-&gt;cor2
op_assign
id|CyETC
suffix:semicolon
id|info-&gt;cor3
op_assign
id|Cy_1_STOP
suffix:semicolon
id|info-&gt;cor4
op_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* _very_ small receive threshold */
id|info-&gt;cor5
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cor6
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cor7
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tbpr
op_assign
id|baud_bpr
(braket
id|DefSpeed
)braket
suffix:semicolon
multiline_comment|/* Tx BPR */
id|info-&gt;tco
op_assign
id|baud_co
(braket
id|DefSpeed
)braket
suffix:semicolon
multiline_comment|/* Tx CO */
id|info-&gt;rbpr
op_assign
id|baud_bpr
(braket
id|DefSpeed
)braket
suffix:semicolon
multiline_comment|/* Rx BPR */
id|info-&gt;rco
op_assign
id|baud_co
(braket
id|DefSpeed
)braket
op_rshift
l_int|5
suffix:semicolon
multiline_comment|/* Rx CO */
id|info-&gt;close_delay
op_assign
l_int|0
suffix:semicolon
id|info-&gt;x_char
op_assign
l_int|0
suffix:semicolon
id|info-&gt;event
op_assign
l_int|0
suffix:semicolon
id|info-&gt;count
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_COUNT
id|printk
c_func
(paren
l_string|&quot;cyc: %d: setting count to 0&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;blocked_open
op_assign
l_int|0
suffix:semicolon
id|info-&gt;default_threshold
op_assign
l_int|0
suffix:semicolon
id|info-&gt;default_timeout
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tqueue.routine
op_assign
id|do_softint
suffix:semicolon
id|info-&gt;tqueue.data
op_assign
id|info
suffix:semicolon
id|info-&gt;callout_termios
op_assign
id|cy_callout_driver.init_termios
suffix:semicolon
id|info-&gt;normal_termios
op_assign
id|cy_serial_driver.init_termios
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
multiline_comment|/* info-&gt;session */
multiline_comment|/* info-&gt;pgrp */
multiline_comment|/*** !!!!!!!! this may expose new bugs !!!!!!!!! *********/
id|info-&gt;read_status_mask
op_assign
id|CyTIMEOUT
op_or
id|CySPECHAR
op_or
id|CyBREAK
op_or
id|CyPARITY
op_or
id|CyFRAME
op_or
id|CyOVERRUN
suffix:semicolon
multiline_comment|/* info-&gt;timeout */
id|printk
c_func
(paren
l_string|&quot;ttyS%1d &quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
id|port_num
op_increment
suffix:semicolon
id|info
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|port_num
op_amp
l_int|7
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n               &quot;
)paren
suffix:semicolon
)brace
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|port_num
OL
id|NR_PORTS
)paren
(brace
id|info-&gt;line
op_assign
op_minus
l_int|1
suffix:semicolon
id|port_num
op_increment
suffix:semicolon
id|info
op_increment
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_REMOTE_DEBUG
id|debug_setup
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|ret
op_assign
id|request_irq
c_func
(paren
id|MVME167_IRQ_SER_ERR
comma
id|cd2401_rxerr_interrupt
comma
l_int|0
comma
l_string|&quot;cd2401_errors&quot;
comma
id|cd2401_rxerr_interrupt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Could&squot;t get cd2401_errors IRQ&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_callout_driver
suffix:semicolon
)brace
id|ret
op_assign
id|request_irq
c_func
(paren
id|MVME167_IRQ_SER_MODEM
comma
id|cd2401_modem_interrupt
comma
l_int|0
comma
l_string|&quot;cd2401_modem&quot;
comma
id|cd2401_modem_interrupt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Could&squot;t get cd2401_modem IRQ&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_irq_cd2401_errors
suffix:semicolon
)brace
id|ret
op_assign
id|request_irq
c_func
(paren
id|MVME167_IRQ_SER_TX
comma
id|cd2401_tx_interrupt
comma
l_int|0
comma
l_string|&quot;cd2401_txints&quot;
comma
id|cd2401_tx_interrupt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Could&squot;t get cd2401_txints IRQ&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_irq_cd2401_modem
suffix:semicolon
)brace
id|ret
op_assign
id|request_irq
c_func
(paren
id|MVME167_IRQ_SER_RX
comma
id|cd2401_rx_interrupt
comma
l_int|0
comma
l_string|&quot;cd2401_rxints&quot;
comma
id|cd2401_rx_interrupt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Could&squot;t get cd2401_rxints IRQ&quot;
)paren
suffix:semicolon
r_goto
id|cleanup_irq_cd2401_txints
suffix:semicolon
)brace
multiline_comment|/* Now we have registered the interrupt handlers, allow the interrupts */
id|pcc2chip
(braket
id|PccSCCMICR
)braket
op_assign
l_int|0x15
suffix:semicolon
multiline_comment|/* Serial ints are level 5 */
id|pcc2chip
(braket
id|PccSCCTICR
)braket
op_assign
l_int|0x15
suffix:semicolon
id|pcc2chip
(braket
id|PccSCCRICR
)braket
op_assign
l_int|0x15
suffix:semicolon
id|pcc2chip
(braket
id|PccIMLR
)braket
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* Allow PCC2 ints above 3!? */
r_return
l_int|0
suffix:semicolon
id|cleanup_irq_cd2401_txints
suffix:colon
id|free_irq
c_func
(paren
id|MVME167_IRQ_SER_TX
comma
id|cd2401_tx_interrupt
)paren
suffix:semicolon
id|cleanup_irq_cd2401_modem
suffix:colon
id|free_irq
c_func
(paren
id|MVME167_IRQ_SER_MODEM
comma
id|cd2401_modem_interrupt
)paren
suffix:semicolon
id|cleanup_irq_cd2401_errors
suffix:colon
id|free_irq
c_func
(paren
id|MVME167_IRQ_SER_ERR
comma
id|cd2401_rxerr_interrupt
)paren
suffix:semicolon
id|cleanup_callout_driver
suffix:colon
r_if
c_cond
(paren
id|tty_unregister_driver
c_func
(paren
op_amp
id|cy_callout_driver
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Couldn&squot;t unregister MVME166/7 callout driver&bslash;n&quot;
)paren
suffix:semicolon
id|cleanup_serial_driver
suffix:colon
r_if
c_cond
(paren
id|tty_unregister_driver
c_func
(paren
op_amp
id|cy_serial_driver
)paren
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Couldn&squot;t unregister MVME166/7 serial driver&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* serial167_init */
macro_line|#ifdef CYCLOM_SHOW_STATUS
r_static
r_void
DECL|function|show_status
id|show_status
c_func
(paren
r_int
id|line_num
)paren
(brace
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_struct
id|cyclades_port
op_star
id|info
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|info
op_assign
op_amp
id|cy_port
(braket
id|line_num
)braket
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  channel %d&bslash;n&quot;
comma
id|channel
)paren
suffix:semicolon
multiline_comment|/**/
id|printk
c_func
(paren
l_string|&quot; cy_port&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  card line flags = %d %d %x&bslash;n&quot;
comma
id|info-&gt;card
comma
id|info-&gt;line
comma
id|info-&gt;flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  *tty read_status_mask timeout xmit_fifo_size = %lx %x %x %x&bslash;n&quot;
comma
(paren
r_int
)paren
id|info-&gt;tty
comma
id|info-&gt;read_status_mask
comma
id|info-&gt;timeout
comma
id|info-&gt;xmit_fifo_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  cor1,cor2,cor3,cor4,cor5,cor6,cor7 = %x %x %x %x %x %x %x&bslash;n&quot;
comma
id|info-&gt;cor1
comma
id|info-&gt;cor2
comma
id|info-&gt;cor3
comma
id|info-&gt;cor4
comma
id|info-&gt;cor5
comma
id|info-&gt;cor6
comma
id|info-&gt;cor7
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  tbpr,tco,rbpr,rco = %d %d %d %d&bslash;n&quot;
comma
id|info-&gt;tbpr
comma
id|info-&gt;tco
comma
id|info-&gt;rbpr
comma
id|info-&gt;rco
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  close_delay event count = %d %d %d&bslash;n&quot;
comma
id|info-&gt;close_delay
comma
id|info-&gt;event
comma
id|info-&gt;count
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  x_char blocked_open = %x %x&bslash;n&quot;
comma
id|info-&gt;x_char
comma
id|info-&gt;blocked_open
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  session pgrp open_wait = %lx %lx %lx&bslash;n&quot;
comma
id|info-&gt;session
comma
id|info-&gt;pgrp
comma
(paren
r_int
)paren
id|info-&gt;open_wait
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Global Registers */
id|printk
c_func
(paren
l_string|&quot; CyGFRCR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyGFRCR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyCAR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCAR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyRISR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRISR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyTISR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyTISR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMISR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMISR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyRIR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRIR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyTIR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyTIR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMIR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMIR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyTPR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyTPR
)braket
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
multiline_comment|/* Virtual Registers */
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot; CyRIVR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRIVR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyTIVR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyTIVR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMIVR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMIVR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMISR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMISR
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Channel Registers */
id|printk
c_func
(paren
l_string|&quot; CyCCR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCCR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyIER %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyIER
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyCOR1 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCOR1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyCOR2 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCOR2
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyCOR3 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCOR3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyCOR4 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCOR4
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyCOR5 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCOR5
)braket
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot; CyCCSR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCCSR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyRDCR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRDCR
)braket
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot; CySCHR1 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CySCHR1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CySCHR2 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CySCHR2
)braket
)paren
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot; CySCHR3 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CySCHR3
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CySCHR4 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CySCHR4
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CySCRL %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CySCRL
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CySCRH %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CySCRH
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyLNC %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyLNC
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMCOR1 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMCOR1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMCOR2 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMCOR2
)braket
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot; CyRTPRL %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRTPRL
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyRTPRH %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRTPRH
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMSVR1 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMSVR2 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR2
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyRBPR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRBPR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyRCOR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRCOR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyTBPR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyTBPR
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyTCOR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyTCOR
)braket
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* show_status */
macro_line|#endif
macro_line|#if 0
multiline_comment|/* Dummy routine in mvme16x/config.c for now */
multiline_comment|/* Serial console setup. Called from linux/init/main.c */
r_void
id|console_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_char
op_star
id|s
suffix:semicolon
r_int
id|baud
comma
id|bits
comma
id|parity
suffix:semicolon
r_int
id|cflag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Sanity check. */
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|3
op_logical_or
id|ints
(braket
l_int|1
)braket
OG
l_int|3
)paren
r_return
suffix:semicolon
multiline_comment|/* Get baud, bits and parity */
id|baud
op_assign
l_int|2400
suffix:semicolon
id|bits
op_assign
l_int|8
suffix:semicolon
id|parity
op_assign
l_char|&squot;n&squot;
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|2
)braket
)paren
id|baud
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s
op_assign
id|strchr
c_func
(paren
id|str
comma
l_char|&squot;,&squot;
)paren
)paren
)paren
(brace
r_do
(brace
id|s
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|s
op_ge
l_char|&squot;0&squot;
op_logical_and
op_star
id|s
op_le
l_char|&squot;9&squot;
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|s
)paren
id|parity
op_assign
op_star
id|s
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
)paren
id|bits
op_assign
op_star
id|s
op_minus
l_char|&squot;0&squot;
suffix:semicolon
)brace
multiline_comment|/* Now construct a cflag setting. */
r_switch
c_cond
(paren
id|baud
)paren
(brace
r_case
l_int|1200
suffix:colon
id|cflag
op_or_assign
id|B1200
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9600
suffix:colon
id|cflag
op_or_assign
id|B9600
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|19200
suffix:colon
id|cflag
op_or_assign
id|B19200
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|38400
suffix:colon
id|cflag
op_or_assign
id|B38400
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2400
suffix:colon
r_default
suffix:colon
id|cflag
op_or_assign
id|B2400
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|bits
)paren
(brace
r_case
l_int|7
suffix:colon
id|cflag
op_or_assign
id|CS7
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_case
l_int|8
suffix:colon
id|cflag
op_or_assign
id|CS8
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|parity
)paren
(brace
r_case
l_char|&squot;o&squot;
suffix:colon
r_case
l_char|&squot;O&squot;
suffix:colon
id|cflag
op_or_assign
id|PARODD
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;e&squot;
suffix:colon
r_case
l_char|&squot;E&squot;
suffix:colon
id|cflag
op_or_assign
id|PARENB
suffix:semicolon
r_break
suffix:semicolon
)brace
id|serial_console_info
op_assign
op_amp
id|cy_port
(braket
id|ints
(braket
l_int|1
)braket
)braket
suffix:semicolon
id|serial_console_cflag
op_assign
id|cflag
suffix:semicolon
id|serial_console
op_assign
id|ints
(braket
l_int|1
)braket
op_plus
l_int|64
suffix:semicolon
multiline_comment|/*callout_driver.minor_start*/
)brace
macro_line|#endif
multiline_comment|/*&n; * The following is probably out of date for 2.1.x serial console stuff.&n; *&n; * The console is registered early on from arch/m68k/kernel/setup.c, and&n; * it therefore relies on the chip being setup correctly by 166-Bug.  This&n; * seems reasonable, as the serial port has been used to invoke the system&n; * boot.  It also means that this function must not rely on any data&n; * initialisation performed by serial167_init() etc.&n; *&n; * Of course, once the console has been registered, we had better ensure&n; * that serial167_init() doesn&squot;t leave the chip non-functional.&n; *&n; * The console_lock must be held when we get here.&n; */
DECL|function|serial167_console_write
r_void
id|serial167_console_write
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_const
r_char
op_star
id|str
comma
r_int
id|count
)paren
(brace
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_volatile
id|u_char
id|sink
suffix:semicolon
id|u_char
id|ier
suffix:semicolon
r_int
id|port
suffix:semicolon
id|u_char
id|do_lf
op_assign
l_int|0
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Ensure transmitter is enabled! */
id|port
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|port
suffix:semicolon
r_while
c_loop
(paren
id|base_addr
(braket
id|CyCCR
)braket
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCCR
)braket
op_assign
id|CyENB_XMTR
suffix:semicolon
id|ier
op_assign
id|base_addr
(braket
id|CyIER
)braket
suffix:semicolon
id|base_addr
(braket
id|CyIER
)braket
op_assign
id|CyTxMpty
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|pcc2chip
(braket
id|PccSCCTICR
)braket
op_amp
l_int|0x20
)paren
(brace
multiline_comment|/* We have a Tx int. Acknowledge it */
id|sink
op_assign
id|pcc2chip
(braket
id|PccTPIACKR
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base_addr
(braket
id|CyLICR
)braket
op_rshift
l_int|2
)paren
op_eq
id|port
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|count
)paren
(brace
multiline_comment|/* Last char of string is now output */
id|base_addr
(braket
id|CyTEOIR
)braket
op_assign
id|CyNOTRANS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_lf
)paren
(brace
id|base_addr
(braket
id|CyTDR
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|str
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
id|do_lf
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|str
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
id|base_addr
(braket
id|CyTDR
)braket
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
id|do_lf
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|base_addr
(braket
id|CyTDR
)braket
op_assign
op_star
id|str
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
id|base_addr
(braket
id|CyTEOIR
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|base_addr
(braket
id|CyTEOIR
)braket
op_assign
id|CyNOTRANS
suffix:semicolon
)brace
)brace
id|base_addr
(braket
id|CyIER
)braket
op_assign
id|ier
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* This is a hack; if there are multiple chars waiting in the chip we&n; * discard all but the last one, and return that.  The cd2401 is not really&n; * designed to be driven in polled mode.&n; */
DECL|function|serial167_console_wait_key
r_int
id|serial167_console_wait_key
c_func
(paren
r_struct
id|console
op_star
id|co
)paren
(brace
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_volatile
id|u_char
id|sink
suffix:semicolon
id|u_char
id|ier
suffix:semicolon
r_int
id|port
suffix:semicolon
r_int
id|keypress
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Ensure receiver is enabled! */
id|port
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|port
suffix:semicolon
r_while
c_loop
(paren
id|base_addr
(braket
id|CyCCR
)braket
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCCR
)braket
op_assign
id|CyENB_RCVR
suffix:semicolon
id|ier
op_assign
id|base_addr
(braket
id|CyIER
)braket
suffix:semicolon
id|base_addr
(braket
id|CyIER
)braket
op_assign
id|CyRxData
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|keypress
)paren
(brace
r_if
c_cond
(paren
id|pcc2chip
(braket
id|PccSCCRICR
)braket
op_amp
l_int|0x20
)paren
(brace
multiline_comment|/* We have an Rx int. Acknowledge it */
id|sink
op_assign
id|pcc2chip
(braket
id|PccRPIACKR
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base_addr
(braket
id|CyLICR
)braket
op_rshift
l_int|2
)paren
op_eq
id|port
)paren
(brace
r_int
id|cnt
op_assign
id|base_addr
(braket
id|CyRFOC
)braket
suffix:semicolon
r_while
c_loop
(paren
id|cnt
op_decrement
OG
l_int|0
)paren
(brace
id|keypress
op_assign
id|base_addr
(braket
id|CyRDR
)braket
suffix:semicolon
)brace
id|base_addr
(braket
id|CyREOIR
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|base_addr
(braket
id|CyREOIR
)braket
op_assign
id|CyNOTRANS
suffix:semicolon
)brace
)brace
id|base_addr
(braket
id|CyIER
)braket
op_assign
id|ier
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|keypress
suffix:semicolon
)brace
DECL|function|serial167_console_device
r_static
id|kdev_t
id|serial167_console_device
c_func
(paren
r_struct
id|console
op_star
id|c
)paren
(brace
r_return
id|MKDEV
c_func
(paren
id|TTY_MAJOR
comma
l_int|64
op_plus
id|c-&gt;index
)paren
suffix:semicolon
)brace
DECL|function|serial167_console_setup
r_static
r_int
id|__init
id|serial167_console_setup
c_func
(paren
r_struct
id|console
op_star
id|co
comma
r_char
op_star
id|options
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sercons
r_static
r_struct
id|console
id|sercons
op_assign
(brace
id|name
suffix:colon
l_string|&quot;ttyS&quot;
comma
id|write
suffix:colon
id|serial167_console_write
comma
id|device
suffix:colon
id|serial167_console_device
comma
id|wait_key
suffix:colon
id|serial167_console_wait_key
comma
id|setup
suffix:colon
id|serial167_console_setup
comma
id|flags
suffix:colon
id|CON_PRINTBUFFER
comma
id|index
suffix:colon
op_minus
l_int|1
comma
)brace
suffix:semicolon
DECL|function|serial167_console_init
r_void
id|__init
id|serial167_console_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|vme_brdtype
op_eq
id|VME_TYPE_MVME166
op_logical_or
id|vme_brdtype
op_eq
id|VME_TYPE_MVME167
op_logical_or
id|vme_brdtype
op_eq
id|VME_TYPE_MVME177
)paren
(brace
id|mvme167_serial_console_setup
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|register_console
c_func
(paren
op_amp
id|sercons
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_REMOTE_DEBUG
DECL|function|putDebugChar
r_void
id|putDebugChar
(paren
r_int
id|c
)paren
(brace
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_volatile
id|u_char
id|sink
suffix:semicolon
id|u_char
id|ier
suffix:semicolon
r_int
id|port
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Ensure transmitter is enabled! */
id|port
op_assign
id|DEBUG_PORT
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|port
suffix:semicolon
r_while
c_loop
(paren
id|base_addr
(braket
id|CyCCR
)braket
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCCR
)braket
op_assign
id|CyENB_XMTR
suffix:semicolon
id|ier
op_assign
id|base_addr
(braket
id|CyIER
)braket
suffix:semicolon
id|base_addr
(braket
id|CyIER
)braket
op_assign
id|CyTxMpty
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|pcc2chip
(braket
id|PccSCCTICR
)braket
op_amp
l_int|0x20
)paren
(brace
multiline_comment|/* We have a Tx int. Acknowledge it */
id|sink
op_assign
id|pcc2chip
(braket
id|PccTPIACKR
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base_addr
(braket
id|CyLICR
)braket
op_rshift
l_int|2
)paren
op_eq
id|port
)paren
(brace
id|base_addr
(braket
id|CyTDR
)braket
op_assign
id|c
suffix:semicolon
id|base_addr
(braket
id|CyTEOIR
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
id|base_addr
(braket
id|CyTEOIR
)braket
op_assign
id|CyNOTRANS
suffix:semicolon
)brace
)brace
id|base_addr
(braket
id|CyIER
)braket
op_assign
id|ier
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|getDebugChar
r_int
id|getDebugChar
c_func
(paren
)paren
(brace
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_volatile
id|u_char
id|sink
suffix:semicolon
id|u_char
id|ier
suffix:semicolon
r_int
id|port
suffix:semicolon
r_int
id|i
comma
id|c
suffix:semicolon
id|i
op_assign
id|debugiq.out
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|debugiq.in
)paren
(brace
id|c
op_assign
id|debugiq.buf
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
op_eq
id|DEBUG_LEN
)paren
id|i
op_assign
l_int|0
suffix:semicolon
id|debugiq.out
op_assign
id|i
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
multiline_comment|/* OK, nothing in queue, wait in poll loop */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Ensure receiver is enabled! */
id|port
op_assign
id|DEBUG_PORT
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
(paren
id|u_char
)paren
id|port
suffix:semicolon
macro_line|#if 0
r_while
c_loop
(paren
id|base_addr
(braket
id|CyCCR
)braket
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCCR
)braket
op_assign
id|CyENB_RCVR
suffix:semicolon
macro_line|#endif
id|ier
op_assign
id|base_addr
(braket
id|CyIER
)braket
suffix:semicolon
id|base_addr
(braket
id|CyIER
)braket
op_assign
id|CyRxData
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|pcc2chip
(braket
id|PccSCCRICR
)braket
op_amp
l_int|0x20
)paren
(brace
multiline_comment|/* We have a Rx int. Acknowledge it */
id|sink
op_assign
id|pcc2chip
(braket
id|PccRPIACKR
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base_addr
(braket
id|CyLICR
)braket
op_rshift
l_int|2
)paren
op_eq
id|port
)paren
(brace
r_int
id|cnt
op_assign
id|base_addr
(braket
id|CyRFOC
)braket
suffix:semicolon
r_while
c_loop
(paren
id|cnt
op_decrement
OG
l_int|0
)paren
(brace
id|c
op_assign
id|base_addr
(braket
id|CyRDR
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|0
)paren
id|printk
(paren
l_string|&quot;!! debug char is null (cnt=%d) !!&quot;
comma
id|cnt
)paren
suffix:semicolon
r_else
id|queueDebugChar
(paren
id|c
)paren
suffix:semicolon
)brace
id|base_addr
(braket
id|CyREOIR
)braket
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|debugiq.out
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|debugiq.in
)paren
id|panic
(paren
l_string|&quot;Debug input queue empty!&quot;
)paren
suffix:semicolon
id|c
op_assign
id|debugiq.buf
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
op_eq
id|DEBUG_LEN
)paren
id|i
op_assign
l_int|0
suffix:semicolon
id|debugiq.out
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
id|base_addr
(braket
id|CyREOIR
)braket
op_assign
id|CyNOTRANS
suffix:semicolon
)brace
)brace
id|base_addr
(braket
id|CyIER
)braket
op_assign
id|ier
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|c
)paren
suffix:semicolon
)brace
DECL|function|queueDebugChar
r_void
id|queueDebugChar
(paren
r_int
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|debugiq.in
suffix:semicolon
id|debugiq.buf
(braket
id|i
)braket
op_assign
id|c
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|i
op_eq
id|DEBUG_LEN
)paren
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ne
id|debugiq.out
)paren
id|debugiq.in
op_assign
id|i
suffix:semicolon
)brace
r_static
r_void
DECL|function|debug_setup
id|debug_setup
c_func
(paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
op_assign
(paren
id|u_char
op_star
)paren
id|BASE_ADDR
suffix:semicolon
r_int
id|i
comma
id|cflag
suffix:semicolon
id|cflag
op_assign
id|B19200
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|base_addr
(braket
id|CyCAR
)braket
op_assign
id|i
suffix:semicolon
id|base_addr
(braket
id|CyLICR
)braket
op_assign
id|i
op_lshift
l_int|2
suffix:semicolon
)brace
id|debugiq.in
op_assign
id|debugiq.out
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
id|DEBUG_PORT
suffix:semicolon
multiline_comment|/* baud rate */
id|i
op_assign
id|cflag
op_amp
id|CBAUD
suffix:semicolon
id|base_addr
(braket
id|CyIER
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyCMR
)braket
op_assign
id|CyASYNC
suffix:semicolon
id|base_addr
(braket
id|CyLICR
)braket
op_assign
id|DEBUG_PORT
op_lshift
l_int|2
suffix:semicolon
id|base_addr
(braket
id|CyLIVR
)braket
op_assign
l_int|0x5c
suffix:semicolon
multiline_comment|/* tx and rx baud rate */
id|base_addr
(braket
id|CyTCOR
)braket
op_assign
id|baud_co
(braket
id|i
)braket
suffix:semicolon
id|base_addr
(braket
id|CyTBPR
)braket
op_assign
id|baud_bpr
(braket
id|i
)braket
suffix:semicolon
id|base_addr
(braket
id|CyRCOR
)braket
op_assign
id|baud_co
(braket
id|i
)braket
op_rshift
l_int|5
suffix:semicolon
id|base_addr
(braket
id|CyRBPR
)braket
op_assign
id|baud_bpr
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* set line characteristics  according configuration */
id|base_addr
(braket
id|CySCHR1
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CySCHR2
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CySCRL
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CySCRH
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyCOR1
)braket
op_assign
id|Cy_8_BITS
op_or
id|CyPARITY_NONE
suffix:semicolon
id|base_addr
(braket
id|CyCOR2
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyCOR3
)braket
op_assign
id|Cy_1_STOP
suffix:semicolon
id|base_addr
(braket
id|CyCOR4
)braket
op_assign
id|baud_cor4
(braket
id|i
)braket
suffix:semicolon
id|base_addr
(braket
id|CyCOR5
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyCOR6
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyCOR7
)braket
op_assign
l_int|0
suffix:semicolon
id|write_cy_cmd
c_func
(paren
id|base_addr
comma
id|CyINIT_CHAN
)paren
suffix:semicolon
id|write_cy_cmd
c_func
(paren
id|base_addr
comma
id|CyENB_RCVR
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
)braket
op_assign
id|DEBUG_PORT
suffix:semicolon
multiline_comment|/* !!! Is this needed? */
id|base_addr
(braket
id|CyRTPRL
)braket
op_assign
l_int|2
suffix:semicolon
id|base_addr
(braket
id|CyRTPRH
)braket
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
)braket
op_assign
id|CyRTS
suffix:semicolon
id|base_addr
(braket
id|CyMSVR2
)braket
op_assign
id|CyDTR
suffix:semicolon
id|base_addr
(braket
id|CyIER
)braket
op_assign
id|CyRxData
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* debug_setup */
macro_line|#endif
eof
