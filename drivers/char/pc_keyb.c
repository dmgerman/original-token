multiline_comment|/*&n; * linux/drivers/char/pc_keyb.c&n; *&n; * Separation of the PC low-level part by Geert Uytterhoeven, May 1997&n; * See keyboard.c for the whole history.&n; *&n; * Major cleanup by Martin Mares, May 1997&n; *&n; * Combined the keyboard and PS/2 mouse handling into one file,&n; * because they share the same hardware.&n; * Johan Myreen &lt;jem@iki.fi&gt; 1998-10-08.&n; *&n; * Code fixes to handle mouse ACKs properly.&n; * C. Scott Ananian &lt;cananian@alumni.princeton.edu&gt; 1999-01-29.&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kbd_ll.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/kbd_kern.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/keyboard.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
multiline_comment|/* Some configuration switches are present in the include file... */
macro_line|#include &lt;linux/pc_keyb.h&gt;
multiline_comment|/* Simple translation table for the SysRq keys */
macro_line|#ifdef CONFIG_MAGIC_SYSRQ
DECL|variable|pckbd_sysrq_xlate
r_int
r_char
id|pckbd_sysrq_xlate
(braket
l_int|128
)braket
op_assign
l_string|&quot;&bslash;000&bslash;0331234567890-=&bslash;177&bslash;t&quot;
multiline_comment|/* 0x00 - 0x0f */
l_string|&quot;qwertyuiop[]&bslash;r&bslash;000as&quot;
multiline_comment|/* 0x10 - 0x1f */
l_string|&quot;dfghjkl;&squot;`&bslash;000&bslash;&bslash;zxcv&quot;
multiline_comment|/* 0x20 - 0x2f */
l_string|&quot;bnm,./&bslash;000*&bslash;000 &bslash;000&bslash;201&bslash;202&bslash;203&bslash;204&bslash;205&quot;
multiline_comment|/* 0x30 - 0x3f */
l_string|&quot;&bslash;206&bslash;207&bslash;210&bslash;211&bslash;212&bslash;000&bslash;000789-456+1&quot;
multiline_comment|/* 0x40 - 0x4f */
l_string|&quot;230&bslash;177&bslash;000&bslash;000&bslash;213&bslash;214&bslash;000&bslash;000&bslash;000&bslash;000&bslash;000&bslash;000&bslash;000&bslash;000&bslash;000&bslash;000&quot;
multiline_comment|/* 0x50 - 0x5f */
l_string|&quot;&bslash;r&bslash;000/&quot;
suffix:semicolon
multiline_comment|/* 0x60 - 0x6f */
macro_line|#endif
r_static
r_void
id|kbd_write_command_w
c_func
(paren
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|kbd_write_output_w
c_func
(paren
r_int
id|data
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PSMOUSE
r_static
r_void
id|aux_write_ack
c_func
(paren
r_int
id|val
)paren
suffix:semicolon
r_static
r_void
id|__aux_write_ack
c_func
(paren
r_int
id|val
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|kbd_controller_lock
r_static
id|spinlock_t
id|kbd_controller_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
r_static
r_int
r_char
id|handle_kbd_event
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* used only by send_data - set by keyboard_interrupt */
DECL|variable|reply_expected
r_static
r_volatile
r_int
r_char
id|reply_expected
suffix:semicolon
DECL|variable|acknowledge
r_static
r_volatile
r_int
r_char
id|acknowledge
suffix:semicolon
DECL|variable|resend
r_static
r_volatile
r_int
r_char
id|resend
suffix:semicolon
macro_line|#if defined CONFIG_PSMOUSE
multiline_comment|/*&n; *&t;PS/2 Auxiliary Device&n; */
r_static
r_int
id|__init
id|psaux_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|AUX_RECONNECT
mdefine_line|#define AUX_RECONNECT 170 /* scancode when ps2 device is plugged (back) in */
DECL|variable|queue
r_static
r_struct
id|aux_queue
op_star
id|queue
suffix:semicolon
multiline_comment|/* Mouse data buffer. */
DECL|variable|aux_count
r_static
r_int
id|aux_count
suffix:semicolon
multiline_comment|/* used when we send commands to the mouse that expect an ACK. */
DECL|variable|mouse_reply_expected
r_static
r_int
r_char
id|mouse_reply_expected
suffix:semicolon
DECL|macro|AUX_INTS_OFF
mdefine_line|#define AUX_INTS_OFF (KBD_MODE_KCC | KBD_MODE_DISABLE_MOUSE | KBD_MODE_SYS | KBD_MODE_KBD_INT)
DECL|macro|AUX_INTS_ON
mdefine_line|#define AUX_INTS_ON  (KBD_MODE_KCC | KBD_MODE_SYS | KBD_MODE_MOUSE_INT | KBD_MODE_KBD_INT)
DECL|macro|MAX_RETRIES
mdefine_line|#define MAX_RETRIES&t;60&t;&t;/* some aux operations take long time*/
macro_line|#endif /* CONFIG_PSMOUSE */
multiline_comment|/*&n; * Wait for keyboard controller input buffer to drain.&n; *&n; * Don&squot;t use &squot;jiffies&squot; so that we don&squot;t depend on&n; * interrupts..&n; *&n; * Quote from PS/2 System Reference Manual:&n; *&n; * &quot;Address hex 0060 and address hex 0064 should be written only when&n; * the input-buffer-full bit and output-buffer-full bit in the&n; * Controller Status register are set 0.&quot;&n; */
DECL|function|kb_wait
r_static
r_void
id|kb_wait
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|timeout
op_assign
id|KBC_TIMEOUT
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * &quot;handle_kbd_event()&quot; will handle any incoming events&n;&t;&t; * while we wait - keypresses or mouse movement.&n;&t;&t; */
r_int
r_char
id|status
op_assign
id|handle_kbd_event
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|KBD_STAT_IBF
)paren
)paren
r_return
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|timeout
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
id|timeout
)paren
suffix:semicolon
macro_line|#ifdef KBD_REPORT_TIMEOUTS
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Keyboard timed out[1]&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Translation of escaped scancodes to keycodes.&n; * This is now user-settable.&n; * The keycodes 1-88,96-111,119 are fairly standard, and&n; * should probably not be changed - changing might confuse X.&n; * X also interprets scancode 0x5d (KEY_Begin).&n; *&n; * For 1-88 keycode equals scancode.&n; */
DECL|macro|E0_KPENTER
mdefine_line|#define E0_KPENTER 96
DECL|macro|E0_RCTRL
mdefine_line|#define E0_RCTRL   97
DECL|macro|E0_KPSLASH
mdefine_line|#define E0_KPSLASH 98
DECL|macro|E0_PRSCR
mdefine_line|#define E0_PRSCR   99
DECL|macro|E0_RALT
mdefine_line|#define E0_RALT    100
DECL|macro|E0_BREAK
mdefine_line|#define E0_BREAK   101  /* (control-pause) */
DECL|macro|E0_HOME
mdefine_line|#define E0_HOME    102
DECL|macro|E0_UP
mdefine_line|#define E0_UP      103
DECL|macro|E0_PGUP
mdefine_line|#define E0_PGUP    104
DECL|macro|E0_LEFT
mdefine_line|#define E0_LEFT    105
DECL|macro|E0_RIGHT
mdefine_line|#define E0_RIGHT   106
DECL|macro|E0_END
mdefine_line|#define E0_END     107
DECL|macro|E0_DOWN
mdefine_line|#define E0_DOWN    108
DECL|macro|E0_PGDN
mdefine_line|#define E0_PGDN    109
DECL|macro|E0_INS
mdefine_line|#define E0_INS     110
DECL|macro|E0_DEL
mdefine_line|#define E0_DEL     111
DECL|macro|E1_PAUSE
mdefine_line|#define E1_PAUSE   119
multiline_comment|/*&n; * The keycodes below are randomly located in 89-95,112-118,120-127.&n; * They could be thrown away (and all occurrences below replaced by 0),&n; * but that would force many users to use the `setkeycodes&squot; utility, where&n; * they needed not before. It does not matter that there are duplicates, as&n; * long as no duplication occurs for any single keyboard.&n; */
DECL|macro|SC_LIM
mdefine_line|#define SC_LIM 89
DECL|macro|FOCUS_PF1
mdefine_line|#define FOCUS_PF1 85           /* actual code! */
DECL|macro|FOCUS_PF2
mdefine_line|#define FOCUS_PF2 89
DECL|macro|FOCUS_PF3
mdefine_line|#define FOCUS_PF3 90
DECL|macro|FOCUS_PF4
mdefine_line|#define FOCUS_PF4 91
DECL|macro|FOCUS_PF5
mdefine_line|#define FOCUS_PF5 92
DECL|macro|FOCUS_PF6
mdefine_line|#define FOCUS_PF6 93
DECL|macro|FOCUS_PF7
mdefine_line|#define FOCUS_PF7 94
DECL|macro|FOCUS_PF8
mdefine_line|#define FOCUS_PF8 95
DECL|macro|FOCUS_PF9
mdefine_line|#define FOCUS_PF9 120
DECL|macro|FOCUS_PF10
mdefine_line|#define FOCUS_PF10 121
DECL|macro|FOCUS_PF11
mdefine_line|#define FOCUS_PF11 122
DECL|macro|FOCUS_PF12
mdefine_line|#define FOCUS_PF12 123
DECL|macro|JAP_86
mdefine_line|#define JAP_86     124
multiline_comment|/* tfj@olivia.ping.dk:&n; * The four keys are located over the numeric keypad, and are&n; * labelled A1-A4. It&squot;s an rc930 keyboard, from&n; * Regnecentralen/RC International, Now ICL.&n; * Scancodes: 59, 5a, 5b, 5c.&n; */
DECL|macro|RGN1
mdefine_line|#define RGN1 124
DECL|macro|RGN2
mdefine_line|#define RGN2 125
DECL|macro|RGN3
mdefine_line|#define RGN3 126
DECL|macro|RGN4
mdefine_line|#define RGN4 127
DECL|variable|high_keys
r_static
r_int
r_char
id|high_keys
(braket
l_int|128
op_minus
id|SC_LIM
)braket
op_assign
(brace
id|RGN1
comma
id|RGN2
comma
id|RGN3
comma
id|RGN4
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x59-0x5f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x60-0x67 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|FOCUS_PF11
comma
l_int|0
comma
id|FOCUS_PF12
comma
multiline_comment|/* 0x68-0x6f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|FOCUS_PF2
comma
id|FOCUS_PF9
comma
l_int|0
comma
l_int|0
comma
id|FOCUS_PF3
comma
multiline_comment|/* 0x70-0x77 */
id|FOCUS_PF4
comma
id|FOCUS_PF5
comma
id|FOCUS_PF6
comma
id|FOCUS_PF7
comma
multiline_comment|/* 0x78-0x7b */
id|FOCUS_PF8
comma
id|JAP_86
comma
id|FOCUS_PF10
comma
l_int|0
multiline_comment|/* 0x7c-0x7f */
)brace
suffix:semicolon
multiline_comment|/* BTC */
DECL|macro|E0_MACRO
mdefine_line|#define E0_MACRO   112
multiline_comment|/* LK450 */
DECL|macro|E0_F13
mdefine_line|#define E0_F13     113
DECL|macro|E0_F14
mdefine_line|#define E0_F14     114
DECL|macro|E0_HELP
mdefine_line|#define E0_HELP    115
DECL|macro|E0_DO
mdefine_line|#define E0_DO      116
DECL|macro|E0_F17
mdefine_line|#define E0_F17     117
DECL|macro|E0_KPMINPLUS
mdefine_line|#define E0_KPMINPLUS 118
multiline_comment|/*&n; * My OmniKey generates e0 4c for  the &quot;OMNI&quot; key and the&n; * right alt key does nada. [kkoller@nyx10.cs.du.edu]&n; */
DECL|macro|E0_OK
mdefine_line|#define E0_OK&t;124
multiline_comment|/*&n; * New microsoft keyboard is rumoured to have&n; * e0 5b (left window button), e0 5c (right window button),&n; * e0 5d (menu button). [or: LBANNER, RBANNER, RMENU]&n; * [or: Windows_L, Windows_R, TaskMan]&n; */
DECL|macro|E0_MSLW
mdefine_line|#define E0_MSLW&t;125
DECL|macro|E0_MSRW
mdefine_line|#define E0_MSRW&t;126
DECL|macro|E0_MSTM
mdefine_line|#define E0_MSTM&t;127
DECL|variable|e0_keys
r_static
r_int
r_char
id|e0_keys
(braket
l_int|128
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x00-0x07 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x08-0x0f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x10-0x17 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_KPENTER
comma
id|E0_RCTRL
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x18-0x1f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x20-0x27 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x28-0x2f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_KPSLASH
comma
l_int|0
comma
id|E0_PRSCR
comma
multiline_comment|/* 0x30-0x37 */
id|E0_RALT
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_F13
comma
id|E0_F14
comma
id|E0_HELP
comma
multiline_comment|/* 0x38-0x3f */
id|E0_DO
comma
id|E0_F17
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_BREAK
comma
id|E0_HOME
comma
multiline_comment|/* 0x40-0x47 */
id|E0_UP
comma
id|E0_PGUP
comma
l_int|0
comma
id|E0_LEFT
comma
id|E0_OK
comma
id|E0_RIGHT
comma
id|E0_KPMINPLUS
comma
id|E0_END
comma
multiline_comment|/* 0x48-0x4f */
id|E0_DOWN
comma
id|E0_PGDN
comma
id|E0_INS
comma
id|E0_DEL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x50-0x57 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_MSLW
comma
id|E0_MSRW
comma
id|E0_MSTM
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x58-0x5f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x60-0x67 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_MACRO
comma
multiline_comment|/* 0x68-0x6f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x70-0x77 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
multiline_comment|/* 0x78-0x7f */
)brace
suffix:semicolon
DECL|function|pckbd_setkeycode
r_int
id|pckbd_setkeycode
c_func
(paren
r_int
r_int
id|scancode
comma
r_int
r_int
id|keycode
)paren
(brace
r_if
c_cond
(paren
id|scancode
template_param
l_int|255
op_logical_or
id|keycode
OG
l_int|127
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|scancode
OL
l_int|128
)paren
id|high_keys
(braket
id|scancode
op_minus
id|SC_LIM
)braket
op_assign
id|keycode
suffix:semicolon
r_else
id|e0_keys
(braket
id|scancode
op_minus
l_int|128
)braket
op_assign
id|keycode
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pckbd_getkeycode
r_int
id|pckbd_getkeycode
c_func
(paren
r_int
r_int
id|scancode
)paren
(brace
r_return
(paren
id|scancode
template_param
l_int|255
)paren
ques
c_cond
op_minus
id|EINVAL
suffix:colon
(paren
id|scancode
OL
l_int|128
)paren
ques
c_cond
id|high_keys
(braket
id|scancode
op_minus
id|SC_LIM
)braket
suffix:colon
id|e0_keys
(braket
id|scancode
op_minus
l_int|128
)braket
suffix:semicolon
)brace
DECL|function|do_acknowledge
r_static
r_int
id|do_acknowledge
c_func
(paren
r_int
r_char
id|scancode
)paren
(brace
r_if
c_cond
(paren
id|reply_expected
)paren
(brace
multiline_comment|/* Unfortunately, we must recognise these codes only if we know they&n;&t;   * are known to be valid (i.e., after sending a command), because there&n;&t;   * are some brain-damaged keyboards (yes, FOCUS 9000 again) which have&n;&t;   * keys with such codes :(&n;&t;   */
r_if
c_cond
(paren
id|scancode
op_eq
id|KBD_REPLY_ACK
)paren
(brace
id|acknowledge
op_assign
l_int|1
suffix:semicolon
id|reply_expected
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scancode
op_eq
id|KBD_REPLY_RESEND
)paren
(brace
id|resend
op_assign
l_int|1
suffix:semicolon
id|reply_expected
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Should not happen... */
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;keyboard reply expected - got %02x&bslash;n&quot;
comma
id|scancode
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|pckbd_translate
r_int
id|pckbd_translate
c_func
(paren
r_int
r_char
id|scancode
comma
r_int
r_char
op_star
id|keycode
comma
r_char
id|raw_mode
)paren
(brace
r_static
r_int
id|prev_scancode
suffix:semicolon
multiline_comment|/* special prefix scancodes.. */
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xe0
op_logical_or
id|scancode
op_eq
l_int|0xe1
)paren
(brace
id|prev_scancode
op_assign
id|scancode
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 0xFF is sent by a few keyboards, ignore it. 0x00 is error */
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0x00
op_logical_or
id|scancode
op_eq
l_int|0xff
)paren
(brace
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|scancode
op_and_assign
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|prev_scancode
)paren
(brace
multiline_comment|/*&n;&t;   * usually it will be 0xe0, but a Pause key generates&n;&t;   * e1 1d 45 e1 9d c5 when pressed, and nothing when released&n;&t;   */
r_if
c_cond
(paren
id|prev_scancode
op_ne
l_int|0xe0
)paren
(brace
r_if
c_cond
(paren
id|prev_scancode
op_eq
l_int|0xe1
op_logical_and
id|scancode
op_eq
l_int|0x1d
)paren
(brace
id|prev_scancode
op_assign
l_int|0x100
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|prev_scancode
op_eq
l_int|0x100
op_logical_and
id|scancode
op_eq
l_int|0x45
)paren
(brace
op_star
id|keycode
op_assign
id|E1_PAUSE
suffix:semicolon
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef KBD_REPORT_UNKN
r_if
c_cond
(paren
op_logical_neg
id|raw_mode
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;keyboard: unknown e1 escape sequence&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;       *  The keyboard maintains its own internal caps lock and&n;&t;       *  num lock statuses. In caps lock mode E0 AA precedes make&n;&t;       *  code and E0 2A follows break code. In num lock mode,&n;&t;       *  E0 2A precedes make code and E0 AA follows break code.&n;&t;       *  We do our own book-keeping, so we will just ignore these.&n;&t;       */
multiline_comment|/*&n;&t;       *  For my keyboard there is no caps lock mode, but there are&n;&t;       *  both Shift-L and Shift-R modes. The former mode generates&n;&t;       *  E0 2A / E0 AA pairs, the latter E0 B6 / E0 36 pairs.&n;&t;       *  So, we should also ignore the latter. - aeb@cwi.nl&n;&t;       */
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0x2a
op_logical_or
id|scancode
op_eq
l_int|0x36
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|e0_keys
(braket
id|scancode
)braket
)paren
op_star
id|keycode
op_assign
id|e0_keys
(braket
id|scancode
)braket
suffix:semicolon
r_else
(brace
macro_line|#ifdef KBD_REPORT_UNKN
r_if
c_cond
(paren
op_logical_neg
id|raw_mode
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;keyboard: unknown scancode e0 %02x&bslash;n&quot;
comma
id|scancode
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|scancode
op_ge
id|SC_LIM
)paren
(brace
multiline_comment|/* This happens with the FOCUS 9000 keyboard&n;&t;       Its keys PF1..PF12 are reported to generate&n;&t;       55 73 77 78 79 7a 7b 7c 74 7e 6d 6f&n;&t;       Moreover, unless repeated, they do not generate&n;&t;       key-down events, so we have to zero up_flag below */
multiline_comment|/* Also, Japanese 86/106 keyboards are reported to&n;&t;       generate 0x73 and 0x7d for &bslash; - and &bslash; | respectively. */
multiline_comment|/* Also, some Brazilian keyboard is reported to produce&n;&t;       0x73 and 0x7e for &bslash; ? and KP-dot, respectively. */
op_star
id|keycode
op_assign
id|high_keys
(braket
id|scancode
op_minus
id|SC_LIM
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|keycode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|raw_mode
)paren
(brace
macro_line|#ifdef KBD_REPORT_UNKN
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;keyboard: unrecognized scancode (%02x)&quot;
l_string|&quot; - ignored&bslash;n&quot;
comma
id|scancode
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
op_star
id|keycode
op_assign
id|scancode
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|pckbd_unexpected_up
r_char
id|pckbd_unexpected_up
c_func
(paren
r_int
r_char
id|keycode
)paren
(brace
multiline_comment|/* unexpected, but this can happen: maybe this was a key release for a&n;&t;   FOCUS 9000 PF key; if we want to see it, we have to clear up_flag */
r_if
c_cond
(paren
id|keycode
op_ge
id|SC_LIM
op_logical_or
id|keycode
op_eq
l_int|85
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
l_int|0200
suffix:semicolon
)brace
DECL|function|handle_mouse_event
r_static
r_inline
r_void
id|handle_mouse_event
c_func
(paren
r_int
r_char
id|scancode
)paren
(brace
macro_line|#ifdef CONFIG_PSMOUSE
r_if
c_cond
(paren
id|mouse_reply_expected
)paren
(brace
r_if
c_cond
(paren
id|scancode
op_eq
id|AUX_ACK
)paren
(brace
id|mouse_reply_expected
op_decrement
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mouse_reply_expected
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scancode
op_eq
id|AUX_RECONNECT
)paren
(brace
id|queue-&gt;head
op_assign
id|queue-&gt;tail
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Flush input queue */
id|__aux_write_ack
c_func
(paren
id|AUX_ENABLE_DEV
)paren
suffix:semicolon
multiline_comment|/* ping the mouse :) */
r_return
suffix:semicolon
)brace
id|add_mouse_randomness
c_func
(paren
id|scancode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aux_count
)paren
(brace
r_int
id|head
op_assign
id|queue-&gt;head
suffix:semicolon
id|queue-&gt;buf
(braket
id|head
)braket
op_assign
id|scancode
suffix:semicolon
id|head
op_assign
(paren
id|head
op_plus
l_int|1
)paren
op_amp
(paren
id|AUX_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|head
op_ne
id|queue-&gt;tail
)paren
(brace
id|queue-&gt;head
op_assign
id|head
suffix:semicolon
id|kill_fasync
c_func
(paren
op_amp
id|queue-&gt;fasync
comma
id|SIGIO
comma
id|POLL_IN
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|queue-&gt;proc_list
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
DECL|variable|kbd_exists
r_static
r_int
r_char
id|kbd_exists
op_assign
l_int|1
suffix:semicolon
DECL|function|handle_keyboard_event
r_static
r_inline
r_void
id|handle_keyboard_event
c_func
(paren
r_int
r_char
id|scancode
)paren
(brace
macro_line|#ifdef CONFIG_VT
id|kbd_exists
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|do_acknowledge
c_func
(paren
id|scancode
)paren
)paren
id|handle_scancode
c_func
(paren
id|scancode
comma
op_logical_neg
(paren
id|scancode
op_amp
l_int|0x80
)paren
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;
id|tasklet_schedule
c_func
(paren
op_amp
id|keyboard_tasklet
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This reads the keyboard status port, and does the&n; * appropriate action.&n; *&n; * It requires that we hold the keyboard controller&n; * spinlock.&n; */
DECL|function|handle_kbd_event
r_static
r_int
r_char
id|handle_kbd_event
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|status
op_assign
id|kbd_read_status
c_func
(paren
)paren
suffix:semicolon
r_int
r_int
id|work
op_assign
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
(paren
op_decrement
id|work
OG
l_int|0
)paren
op_logical_and
(paren
id|status
op_amp
id|KBD_STAT_OBF
)paren
)paren
(brace
r_int
r_char
id|scancode
suffix:semicolon
id|scancode
op_assign
id|kbd_read_input
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Error bytes must be ignored to make the &n;&t;&t;   Synaptics touchpads compaq use work */
macro_line|#if 1
multiline_comment|/* Ignore error bytes */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
(paren
id|KBD_STAT_GTO
op_or
id|KBD_STAT_PERR
)paren
)paren
)paren
macro_line|#endif
(brace
r_if
c_cond
(paren
id|status
op_amp
id|KBD_STAT_MOUSE_OBF
)paren
id|handle_mouse_event
c_func
(paren
id|scancode
)paren
suffix:semicolon
r_else
id|handle_keyboard_event
c_func
(paren
id|scancode
)paren
suffix:semicolon
)brace
id|status
op_assign
id|kbd_read_status
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|work
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;pc_keyb: controller jammed (0x%02X).&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|keyboard_interrupt
r_static
r_void
id|keyboard_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
macro_line|#ifdef CONFIG_VT
id|kbd_pt_regs
op_assign
id|regs
suffix:semicolon
macro_line|#endif
id|spin_lock_irq
c_func
(paren
op_amp
id|kbd_controller_lock
)paren
suffix:semicolon
id|handle_kbd_event
c_func
(paren
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|kbd_controller_lock
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * send_data sends a character to the keyboard and waits&n; * for an acknowledge, possibly retrying if asked to. Returns&n; * the success status.&n; *&n; * Don&squot;t use &squot;jiffies&squot;, so that we don&squot;t depend on interrupts&n; */
DECL|function|send_data
r_static
r_int
id|send_data
c_func
(paren
r_int
r_char
id|data
)paren
(brace
r_int
id|retries
op_assign
l_int|3
suffix:semicolon
r_do
(brace
r_int
r_int
id|timeout
op_assign
id|KBD_TIMEOUT
suffix:semicolon
id|acknowledge
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Set by interrupt routine on receipt of ACK. */
id|resend
op_assign
l_int|0
suffix:semicolon
id|reply_expected
op_assign
l_int|1
suffix:semicolon
id|kbd_write_output_w
c_func
(paren
id|data
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|acknowledge
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|resend
)paren
r_break
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|timeout
)paren
(brace
macro_line|#ifdef KBD_REPORT_TIMEOUTS
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;keyboard: Timeout - AT keyboard not present?&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|retries
op_decrement
OG
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef KBD_REPORT_TIMEOUTS
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;keyboard: Too many NACKs -- noisy kbd cable?&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pckbd_leds
r_void
id|pckbd_leds
c_func
(paren
r_int
r_char
id|leds
)paren
(brace
r_if
c_cond
(paren
id|kbd_exists
op_logical_and
(paren
op_logical_neg
id|send_data
c_func
(paren
id|KBD_CMD_SET_LEDS
)paren
op_logical_or
op_logical_neg
id|send_data
c_func
(paren
id|leds
)paren
)paren
)paren
(brace
id|send_data
c_func
(paren
id|KBD_CMD_ENABLE
)paren
suffix:semicolon
multiline_comment|/* re-enable kbd if any errors */
id|kbd_exists
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * In case we run on a non-x86 hardware we need to initialize both the&n; * keyboard controller and the keyboard.  On a x86, the BIOS will&n; * already have initialized them.&n; *&n; * Some x86 BIOSes do not correctly initialize the keyboard, so the&n; * &quot;kbd-reset&quot; command line options can be given to force a reset.&n; * [Ranger]&n; */
macro_line|#ifdef __i386__
DECL|variable|__initdata
r_int
id|kbd_startup_reset
id|__initdata
op_assign
l_int|0
suffix:semicolon
macro_line|#else
DECL|variable|__initdata
r_int
id|kbd_startup_reset
id|__initdata
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* for &quot;kbd-reset&quot; cmdline param */
DECL|function|kbd_reset_setup
r_static
r_int
id|__init
id|kbd_reset_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|kbd_startup_reset
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;kbd-reset&quot;
comma
id|kbd_reset_setup
)paren
suffix:semicolon
DECL|macro|KBD_NO_DATA
mdefine_line|#define KBD_NO_DATA&t;(-1)&t;/* No data */
DECL|macro|KBD_BAD_DATA
mdefine_line|#define KBD_BAD_DATA&t;(-2)&t;/* Parity or other error */
DECL|function|kbd_read_data
r_static
r_int
id|__init
id|kbd_read_data
c_func
(paren
r_void
)paren
(brace
r_int
id|retval
op_assign
id|KBD_NO_DATA
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
id|status
op_assign
id|kbd_read_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|KBD_STAT_OBF
)paren
(brace
r_int
r_char
id|data
op_assign
id|kbd_read_input
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
id|data
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|KBD_STAT_GTO
op_or
id|KBD_STAT_PERR
)paren
)paren
id|retval
op_assign
id|KBD_BAD_DATA
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|kbd_clear_input
r_static
r_void
id|__init
id|kbd_clear_input
c_func
(paren
r_void
)paren
(brace
r_int
id|maxread
op_assign
l_int|100
suffix:semicolon
multiline_comment|/* Random number */
r_do
(brace
r_if
c_cond
(paren
id|kbd_read_data
c_func
(paren
)paren
op_eq
id|KBD_NO_DATA
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|maxread
)paren
suffix:semicolon
)brace
DECL|function|kbd_wait_for_input
r_static
r_int
id|__init
id|kbd_wait_for_input
c_func
(paren
r_void
)paren
(brace
r_int
id|timeout
op_assign
id|KBD_INIT_TIMEOUT
suffix:semicolon
r_do
(brace
r_int
id|retval
op_assign
id|kbd_read_data
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ge
l_int|0
)paren
r_return
id|retval
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|timeout
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|kbd_write_command_w
r_static
r_void
id|kbd_write_command_w
c_func
(paren
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|kbd_controller_lock
comma
id|flags
)paren
suffix:semicolon
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|kbd_write_command
c_func
(paren
id|data
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|kbd_controller_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|kbd_write_output_w
r_static
r_void
id|kbd_write_output_w
c_func
(paren
r_int
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|kbd_controller_lock
comma
id|flags
)paren
suffix:semicolon
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|kbd_write_output
c_func
(paren
id|data
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|kbd_controller_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#if defined CONFIG_PSMOUSE
DECL|function|kbd_write_cmd
r_static
r_void
id|kbd_write_cmd
c_func
(paren
r_int
id|cmd
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|kbd_controller_lock
comma
id|flags
)paren
suffix:semicolon
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|kbd_write_command
c_func
(paren
id|KBD_CCMD_WRITE_MODE
)paren
suffix:semicolon
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|kbd_write_output
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|kbd_controller_lock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PSMOUSE */
DECL|function|initialize_kbd
r_static
r_char
op_star
id|__init
id|initialize_kbd
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
multiline_comment|/*&n;&t; * Test the keyboard interface.&n;&t; * This seems to be the only way to get it going.&n;&t; * If the test is successful a x55 is placed in the input buffer.&n;&t; */
id|kbd_write_command_w
c_func
(paren
id|KBD_CCMD_SELF_TEST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_wait_for_input
c_func
(paren
)paren
op_ne
l_int|0x55
)paren
r_return
l_string|&quot;Keyboard failed self test&quot;
suffix:semicolon
multiline_comment|/*&n;&t; * Perform a keyboard interface test.  This causes the controller&n;&t; * to test the keyboard clock and data lines.  The results of the&n;&t; * test are placed in the input buffer.&n;&t; */
id|kbd_write_command_w
c_func
(paren
id|KBD_CCMD_KBD_TEST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_wait_for_input
c_func
(paren
)paren
op_ne
l_int|0x00
)paren
r_return
l_string|&quot;Keyboard interface failed self test&quot;
suffix:semicolon
multiline_comment|/*&n;&t; * Enable the keyboard by allowing the keyboard clock to run.&n;&t; */
id|kbd_write_command_w
c_func
(paren
id|KBD_CCMD_KBD_ENABLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset keyboard. If the read times out&n;&t; * then the assumption is that no keyboard is&n;&t; * plugged into the machine.&n;&t; * This defaults the keyboard to scan-code set 2.&n;&t; *&n;&t; * Set up to try again if the keyboard asks for RESEND.&n;&t; */
r_do
(brace
id|kbd_write_output_w
c_func
(paren
id|KBD_CMD_RESET
)paren
suffix:semicolon
id|status
op_assign
id|kbd_wait_for_input
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|KBD_REPLY_ACK
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|KBD_REPLY_RESEND
)paren
r_return
l_string|&quot;Keyboard reset failed, no ACK&quot;
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_wait_for_input
c_func
(paren
)paren
op_ne
id|KBD_REPLY_POR
)paren
r_return
l_string|&quot;Keyboard reset failed, no POR&quot;
suffix:semicolon
multiline_comment|/*&n;&t; * Set keyboard controller mode. During this, the keyboard should be&n;&t; * in the disabled state.&n;&t; *&n;&t; * Set up to try again if the keyboard asks for RESEND.&n;&t; */
r_do
(brace
id|kbd_write_output_w
c_func
(paren
id|KBD_CMD_DISABLE
)paren
suffix:semicolon
id|status
op_assign
id|kbd_wait_for_input
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|KBD_REPLY_ACK
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
id|KBD_REPLY_RESEND
)paren
r_return
l_string|&quot;Disable keyboard: no ACK&quot;
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
id|kbd_write_command_w
c_func
(paren
id|KBD_CCMD_WRITE_MODE
)paren
suffix:semicolon
id|kbd_write_output_w
c_func
(paren
id|KBD_MODE_KBD_INT
op_or
id|KBD_MODE_SYS
op_or
id|KBD_MODE_DISABLE_MOUSE
op_or
id|KBD_MODE_KCC
)paren
suffix:semicolon
multiline_comment|/* ibm powerpc portables need this to use scan-code set 1 -- Cort */
id|kbd_write_command_w
c_func
(paren
id|KBD_CCMD_READ_MODE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|kbd_wait_for_input
c_func
(paren
)paren
op_amp
id|KBD_MODE_KCC
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the controller does not support conversion,&n;&t;&t; * Set the keyboard to scan-code set 1.&n;&t;&t; */
id|kbd_write_output_w
c_func
(paren
l_int|0xF0
)paren
suffix:semicolon
id|kbd_wait_for_input
c_func
(paren
)paren
suffix:semicolon
id|kbd_write_output_w
c_func
(paren
l_int|0x01
)paren
suffix:semicolon
id|kbd_wait_for_input
c_func
(paren
)paren
suffix:semicolon
)brace
id|kbd_write_output_w
c_func
(paren
id|KBD_CMD_ENABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_wait_for_input
c_func
(paren
)paren
op_ne
id|KBD_REPLY_ACK
)paren
r_return
l_string|&quot;Enable keyboard: no ACK&quot;
suffix:semicolon
multiline_comment|/*&n;&t; * Finally, set the typematic rate to maximum.&n;&t; */
id|kbd_write_output_w
c_func
(paren
id|KBD_CMD_SET_RATE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_wait_for_input
c_func
(paren
)paren
op_ne
id|KBD_REPLY_ACK
)paren
r_return
l_string|&quot;Set rate: no ACK&quot;
suffix:semicolon
id|kbd_write_output_w
c_func
(paren
l_int|0x00
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_wait_for_input
c_func
(paren
)paren
op_ne
id|KBD_REPLY_ACK
)paren
r_return
l_string|&quot;Set rate: no ACK&quot;
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|pckbd_init_hw
r_void
id|__init
id|pckbd_init_hw
c_func
(paren
r_void
)paren
(brace
id|kbd_request_region
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Flush any pending input. */
id|kbd_clear_input
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_startup_reset
)paren
(brace
r_char
op_star
id|msg
op_assign
id|initialize_kbd
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;initialize_kbd: %s&bslash;n&quot;
comma
id|msg
)paren
suffix:semicolon
)brace
macro_line|#if defined CONFIG_PSMOUSE
id|psaux_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Ok, finally allocate the IRQ, and off we go.. */
id|kbd_request_irq
c_func
(paren
id|keyboard_interrupt
)paren
suffix:semicolon
)brace
macro_line|#if defined CONFIG_PSMOUSE
multiline_comment|/*&n; * Check if this is a dual port controller.&n; */
DECL|function|detect_auxiliary_port
r_static
r_int
id|__init
id|detect_auxiliary_port
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|loops
op_assign
l_int|10
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Check if the BIOS detected a device on the auxiliary port. */
r_if
c_cond
(paren
id|aux_device_present
op_eq
l_int|0xaa
)paren
r_return
l_int|1
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|kbd_controller_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Put the value 0x5A in the output buffer using the &quot;Write&n;&t; * Auxiliary Device Output Buffer&quot; command (0xD3). Poll the&n;&t; * Status Register for a while to see if the value really&n;&t; * turns up in the Data Register. If the KBD_STAT_MOUSE_OBF&n;&t; * bit is also set to 1 in the Status Register, we assume this&n;&t; * controller has an Auxiliary Port (a.k.a. Mouse Port).&n;&t; */
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|kbd_write_command
c_func
(paren
id|KBD_CCMD_WRITE_AUX_OBUF
)paren
suffix:semicolon
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|kbd_write_output
c_func
(paren
l_int|0x5a
)paren
suffix:semicolon
multiline_comment|/* 0x5a is a random dummy value. */
r_do
(brace
r_int
r_char
id|status
op_assign
id|kbd_read_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|KBD_STAT_OBF
)paren
(brace
(paren
r_void
)paren
id|kbd_read_input
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|KBD_STAT_MOUSE_OBF
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Detected PS/2 Mouse Port.&bslash;n&quot;
)paren
suffix:semicolon
id|retval
op_assign
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|loops
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|kbd_controller_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a byte to the mouse.&n; */
DECL|function|aux_write_dev
r_static
r_void
id|aux_write_dev
c_func
(paren
r_int
id|val
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|kbd_controller_lock
comma
id|flags
)paren
suffix:semicolon
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|kbd_write_command
c_func
(paren
id|KBD_CCMD_WRITE_MOUSE
)paren
suffix:semicolon
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|kbd_write_output
c_func
(paren
id|val
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|kbd_controller_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a byte to the mouse &amp; handle returned ack&n; */
DECL|function|__aux_write_ack
r_static
r_void
id|__aux_write_ack
c_func
(paren
r_int
id|val
)paren
(brace
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|kbd_write_command
c_func
(paren
id|KBD_CCMD_WRITE_MOUSE
)paren
suffix:semicolon
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|kbd_write_output
c_func
(paren
id|val
)paren
suffix:semicolon
multiline_comment|/* we expect an ACK in response. */
id|mouse_reply_expected
op_increment
suffix:semicolon
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|aux_write_ack
r_static
r_void
id|aux_write_ack
c_func
(paren
r_int
id|val
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|kbd_controller_lock
comma
id|flags
)paren
suffix:semicolon
id|__aux_write_ack
c_func
(paren
id|val
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|kbd_controller_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|get_from_queue
r_static
r_int
r_char
id|get_from_queue
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|result
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|kbd_controller_lock
comma
id|flags
)paren
suffix:semicolon
id|result
op_assign
id|queue-&gt;buf
(braket
id|queue-&gt;tail
)braket
suffix:semicolon
id|queue-&gt;tail
op_assign
(paren
id|queue-&gt;tail
op_plus
l_int|1
)paren
op_amp
(paren
id|AUX_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|kbd_controller_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
DECL|function|queue_empty
r_static
r_inline
r_int
id|queue_empty
c_func
(paren
r_void
)paren
(brace
r_return
id|queue-&gt;head
op_eq
id|queue-&gt;tail
suffix:semicolon
)brace
DECL|function|fasync_aux
r_static
r_int
id|fasync_aux
c_func
(paren
r_int
id|fd
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
)paren
(brace
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|fasync_helper
c_func
(paren
id|fd
comma
id|filp
comma
id|on
comma
op_amp
id|queue-&gt;fasync
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Random magic cookie for the aux device&n; */
DECL|macro|AUX_DEV
mdefine_line|#define AUX_DEV ((void *)queue)
DECL|function|release_aux
r_static
r_int
id|release_aux
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|fasync_aux
c_func
(paren
op_minus
l_int|1
comma
id|file
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|aux_count
)paren
(brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|kbd_write_cmd
c_func
(paren
id|AUX_INTS_OFF
)paren
suffix:semicolon
multiline_comment|/* Disable controller ints */
id|kbd_write_command_w
c_func
(paren
id|KBD_CCMD_MOUSE_DISABLE
)paren
suffix:semicolon
id|aux_free_irq
c_func
(paren
id|AUX_DEV
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Install interrupt handler.&n; * Enable auxiliary device.&n; */
DECL|function|open_aux
r_static
r_int
id|open_aux
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_if
c_cond
(paren
id|aux_count
op_increment
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|queue-&gt;head
op_assign
id|queue-&gt;tail
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Flush input queue */
r_if
c_cond
(paren
id|aux_request_irq
c_func
(paren
id|keyboard_interrupt
comma
id|AUX_DEV
)paren
)paren
(brace
id|aux_count
op_decrement
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|kbd_write_command_w
c_func
(paren
id|KBD_CCMD_MOUSE_ENABLE
)paren
suffix:semicolon
multiline_comment|/* Enable the&n;&t;&t;&t;&t;&t;&t;&t;   auxiliary port on&n;&t;&t;&t;&t;&t;&t;&t;   controller. */
id|aux_write_ack
c_func
(paren
id|AUX_ENABLE_DEV
)paren
suffix:semicolon
multiline_comment|/* Enable aux device */
id|kbd_write_cmd
c_func
(paren
id|AUX_INTS_ON
)paren
suffix:semicolon
multiline_comment|/* Enable controller ints */
id|send_data
c_func
(paren
id|KBD_CMD_ENABLE
)paren
suffix:semicolon
multiline_comment|/* try to workaround toshiba4030cdt problem */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Put bytes from input queue to buffer.&n; */
DECL|function|read_aux
r_static
id|ssize_t
id|read_aux
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|ssize_t
id|i
op_assign
id|count
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
id|queue_empty
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|queue-&gt;proc_list
comma
op_amp
id|wait
)paren
suffix:semicolon
id|repeat
suffix:colon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|queue_empty
c_func
(paren
)paren
op_logical_and
op_logical_neg
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|queue-&gt;proc_list
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|i
OG
l_int|0
op_logical_and
op_logical_neg
id|queue_empty
c_func
(paren
)paren
)paren
(brace
id|c
op_assign
id|get_from_queue
c_func
(paren
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|c
comma
id|buffer
op_increment
)paren
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_minus
id|i
)paren
(brace
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_atime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_return
id|count
op_minus
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Write to the aux device.&n; */
DECL|function|write_aux
r_static
id|ssize_t
id|write_aux
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
id|ssize_t
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
id|ssize_t
id|written
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
l_int|32
)paren
id|count
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* Limit to 32 bytes. */
r_do
(brace
r_char
id|c
suffix:semicolon
id|get_user
c_func
(paren
id|c
comma
id|buffer
op_increment
)paren
suffix:semicolon
id|aux_write_dev
c_func
(paren
id|c
)paren
suffix:semicolon
id|written
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|count
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|written
)paren
(brace
id|retval
op_assign
id|written
suffix:semicolon
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* No kernel lock held - fine */
DECL|function|aux_poll
r_static
r_int
r_int
id|aux_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|queue-&gt;proc_list
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|queue_empty
c_func
(paren
)paren
)paren
r_return
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|psaux_fops
r_struct
id|file_operations
id|psaux_fops
op_assign
(brace
id|read
suffix:colon
id|read_aux
comma
id|write
suffix:colon
id|write_aux
comma
id|poll
suffix:colon
id|aux_poll
comma
id|open
suffix:colon
id|open_aux
comma
id|release
suffix:colon
id|release_aux
comma
id|fasync
suffix:colon
id|fasync_aux
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Initialize driver.&n; */
DECL|variable|psaux_mouse
r_static
r_struct
id|miscdevice
id|psaux_mouse
op_assign
(brace
id|PSMOUSE_MINOR
comma
l_string|&quot;psaux&quot;
comma
op_amp
id|psaux_fops
)brace
suffix:semicolon
DECL|function|psaux_init
r_static
r_int
id|__init
id|psaux_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|detect_auxiliary_port
c_func
(paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|misc_register
c_func
(paren
op_amp
id|psaux_mouse
)paren
suffix:semicolon
id|queue
op_assign
(paren
r_struct
id|aux_queue
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|queue
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|queue
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|queue
)paren
)paren
suffix:semicolon
id|queue-&gt;head
op_assign
id|queue-&gt;tail
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|queue-&gt;proc_list
)paren
suffix:semicolon
macro_line|#ifdef INITIALIZE_MOUSE
id|kbd_write_command_w
c_func
(paren
id|KBD_CCMD_MOUSE_ENABLE
)paren
suffix:semicolon
multiline_comment|/* Enable Aux. */
id|aux_write_ack
c_func
(paren
id|AUX_SET_SAMPLE
)paren
suffix:semicolon
id|aux_write_ack
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* 100 samples/sec */
id|aux_write_ack
c_func
(paren
id|AUX_SET_RES
)paren
suffix:semicolon
id|aux_write_ack
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* 8 counts per mm */
id|aux_write_ack
c_func
(paren
id|AUX_SET_SCALE21
)paren
suffix:semicolon
multiline_comment|/* 2:1 scaling */
macro_line|#endif /* INITIALIZE_MOUSE */
id|kbd_write_command
c_func
(paren
id|KBD_CCMD_MOUSE_DISABLE
)paren
suffix:semicolon
multiline_comment|/* Disable aux device. */
id|kbd_write_cmd
c_func
(paren
id|AUX_INTS_OFF
)paren
suffix:semicolon
multiline_comment|/* Disable controller ints. */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PSMOUSE */
eof
