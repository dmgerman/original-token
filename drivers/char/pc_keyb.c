multiline_comment|/*&n; * linux/drivers/char/pc_keyb.c&n; *&n; * Written for linux by Johan Myreen as a translation from&n; * the assembly version by Linus (with diacriticals added)&n; *&n; * Some additional features added by Christoph Niemann (ChN), March 1993&n; *&n; * Loadable keymaps by Risto Kankkunen, May 1993&n; *&n; * Diacriticals redone &amp; other small changes, aeb@cwi.nl, June 1993&n; * Added decr/incr_console, dynamic keymaps, Unicode support,&n; * dynamic function/string keys, led setting,  Sept 1994&n; * `Sticky&squot; modifier keys, 951006.&n; * 11-11-96: SAK should now work in the raw mode (Martin Mares)&n; * &n; * Separation of the PC low-level part by Geert Uytterhoeven, May 1997&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/keyboard.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
multiline_comment|/*&n; * On non-x86 hardware we do a full keyboard controller&n; * initialization, in case the bootup software hasn&squot;t done&n; * it. On a x86, the BIOS will already have initialized the&n; * keyboard.&n; */
macro_line|#ifdef INIT_KBD
r_static
r_int
id|initialize_kbd
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
DECL|variable|kbd_read_mask
r_int
r_char
id|kbd_read_mask
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* modified by psaux.c */
multiline_comment|/* used only by send_data - set by keyboard_interrupt */
DECL|variable|reply_expected
r_static
r_volatile
r_int
r_char
id|reply_expected
op_assign
l_int|0
suffix:semicolon
DECL|variable|acknowledge
r_static
r_volatile
r_int
r_char
id|acknowledge
op_assign
l_int|0
suffix:semicolon
DECL|variable|resend
r_static
r_volatile
r_int
r_char
id|resend
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* pt_regs - set by keyboard_interrupt(), used by show_ptregs() */
DECL|function|kb_wait
r_static
r_inline
r_void
id|kb_wait
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x100000
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
l_int|0x64
)paren
op_amp
l_int|0x02
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Keyboard timed out&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_extern
r_struct
id|pt_regs
op_star
id|pt_regs
suffix:semicolon
r_extern
r_void
id|handle_scancode
c_func
(paren
r_int
r_char
id|scancode
)paren
suffix:semicolon
multiline_comment|/*&n; * Translation of escaped scancodes to keycodes.&n; * This is now user-settable.&n; * The keycodes 1-88,96-111,119 are fairly standard, and&n; * should probably not be changed - changing might confuse X.&n; * X also interprets scancode 0x5d (KEY_Begin).&n; *&n; * For 1-88 keycode equals scancode.&n; */
DECL|macro|E0_KPENTER
mdefine_line|#define E0_KPENTER 96
DECL|macro|E0_RCTRL
mdefine_line|#define E0_RCTRL   97
DECL|macro|E0_KPSLASH
mdefine_line|#define E0_KPSLASH 98
DECL|macro|E0_PRSCR
mdefine_line|#define E0_PRSCR   99
DECL|macro|E0_RALT
mdefine_line|#define E0_RALT    100
DECL|macro|E0_BREAK
mdefine_line|#define E0_BREAK   101  /* (control-pause) */
DECL|macro|E0_HOME
mdefine_line|#define E0_HOME    102
DECL|macro|E0_UP
mdefine_line|#define E0_UP      103
DECL|macro|E0_PGUP
mdefine_line|#define E0_PGUP    104
DECL|macro|E0_LEFT
mdefine_line|#define E0_LEFT    105
DECL|macro|E0_RIGHT
mdefine_line|#define E0_RIGHT   106
DECL|macro|E0_END
mdefine_line|#define E0_END     107
DECL|macro|E0_DOWN
mdefine_line|#define E0_DOWN    108
DECL|macro|E0_PGDN
mdefine_line|#define E0_PGDN    109
DECL|macro|E0_INS
mdefine_line|#define E0_INS     110
DECL|macro|E0_DEL
mdefine_line|#define E0_DEL     111
DECL|macro|E1_PAUSE
mdefine_line|#define E1_PAUSE   119
multiline_comment|/*&n; * The keycodes below are randomly located in 89-95,112-118,120-127.&n; * They could be thrown away (and all occurrences below replaced by 0),&n; * but that would force many users to use the `setkeycodes&squot; utility, where&n; * they needed not before. It does not matter that there are duplicates, as&n; * long as no duplication occurs for any single keyboard.&n; */
DECL|macro|SC_LIM
mdefine_line|#define SC_LIM 89
DECL|macro|FOCUS_PF1
mdefine_line|#define FOCUS_PF1 85           /* actual code! */
DECL|macro|FOCUS_PF2
mdefine_line|#define FOCUS_PF2 89
DECL|macro|FOCUS_PF3
mdefine_line|#define FOCUS_PF3 90
DECL|macro|FOCUS_PF4
mdefine_line|#define FOCUS_PF4 91
DECL|macro|FOCUS_PF5
mdefine_line|#define FOCUS_PF5 92
DECL|macro|FOCUS_PF6
mdefine_line|#define FOCUS_PF6 93
DECL|macro|FOCUS_PF7
mdefine_line|#define FOCUS_PF7 94
DECL|macro|FOCUS_PF8
mdefine_line|#define FOCUS_PF8 95
DECL|macro|FOCUS_PF9
mdefine_line|#define FOCUS_PF9 120
DECL|macro|FOCUS_PF10
mdefine_line|#define FOCUS_PF10 121
DECL|macro|FOCUS_PF11
mdefine_line|#define FOCUS_PF11 122
DECL|macro|FOCUS_PF12
mdefine_line|#define FOCUS_PF12 123
DECL|macro|JAP_86
mdefine_line|#define JAP_86     124
multiline_comment|/* tfj@olivia.ping.dk:&n; * The four keys are located over the numeric keypad, and are&n; * labelled A1-A4. It&squot;s an rc930 keyboard, from&n; * Regnecentralen/RC International, Now ICL.&n; * Scancodes: 59, 5a, 5b, 5c.&n; */
DECL|macro|RGN1
mdefine_line|#define RGN1 124
DECL|macro|RGN2
mdefine_line|#define RGN2 125
DECL|macro|RGN3
mdefine_line|#define RGN3 126
DECL|macro|RGN4
mdefine_line|#define RGN4 127
DECL|variable|high_keys
r_static
r_int
r_char
id|high_keys
(braket
l_int|128
op_minus
id|SC_LIM
)braket
op_assign
(brace
id|RGN1
comma
id|RGN2
comma
id|RGN3
comma
id|RGN4
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x59-0x5f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x60-0x67 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|FOCUS_PF11
comma
l_int|0
comma
id|FOCUS_PF12
comma
multiline_comment|/* 0x68-0x6f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|FOCUS_PF2
comma
id|FOCUS_PF9
comma
l_int|0
comma
l_int|0
comma
id|FOCUS_PF3
comma
multiline_comment|/* 0x70-0x77 */
id|FOCUS_PF4
comma
id|FOCUS_PF5
comma
id|FOCUS_PF6
comma
id|FOCUS_PF7
comma
multiline_comment|/* 0x78-0x7b */
id|FOCUS_PF8
comma
id|JAP_86
comma
id|FOCUS_PF10
comma
l_int|0
multiline_comment|/* 0x7c-0x7f */
)brace
suffix:semicolon
multiline_comment|/* BTC */
DECL|macro|E0_MACRO
mdefine_line|#define E0_MACRO   112
multiline_comment|/* LK450 */
DECL|macro|E0_F13
mdefine_line|#define E0_F13     113
DECL|macro|E0_F14
mdefine_line|#define E0_F14     114
DECL|macro|E0_HELP
mdefine_line|#define E0_HELP    115
DECL|macro|E0_DO
mdefine_line|#define E0_DO      116
DECL|macro|E0_F17
mdefine_line|#define E0_F17     117
DECL|macro|E0_KPMINPLUS
mdefine_line|#define E0_KPMINPLUS 118
multiline_comment|/*&n; * My OmniKey generates e0 4c for  the &quot;OMNI&quot; key and the&n; * right alt key does nada. [kkoller@nyx10.cs.du.edu]&n; */
DECL|macro|E0_OK
mdefine_line|#define E0_OK&t;124
multiline_comment|/*&n; * New microsoft keyboard is rumoured to have&n; * e0 5b (left window button), e0 5c (right window button),&n; * e0 5d (menu button). [or: LBANNER, RBANNER, RMENU]&n; * [or: Windows_L, Windows_R, TaskMan]&n; */
DECL|macro|E0_MSLW
mdefine_line|#define E0_MSLW&t;125
DECL|macro|E0_MSRW
mdefine_line|#define E0_MSRW&t;126
DECL|macro|E0_MSTM
mdefine_line|#define E0_MSTM&t;127
DECL|variable|e0_keys
r_static
r_int
r_char
id|e0_keys
(braket
l_int|128
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x00-0x07 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x08-0x0f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x10-0x17 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_KPENTER
comma
id|E0_RCTRL
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x18-0x1f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x20-0x27 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x28-0x2f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_KPSLASH
comma
l_int|0
comma
id|E0_PRSCR
comma
multiline_comment|/* 0x30-0x37 */
id|E0_RALT
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_F13
comma
id|E0_F14
comma
id|E0_HELP
comma
multiline_comment|/* 0x38-0x3f */
id|E0_DO
comma
id|E0_F17
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_BREAK
comma
id|E0_HOME
comma
multiline_comment|/* 0x40-0x47 */
id|E0_UP
comma
id|E0_PGUP
comma
l_int|0
comma
id|E0_LEFT
comma
id|E0_OK
comma
id|E0_RIGHT
comma
id|E0_KPMINPLUS
comma
id|E0_END
comma
multiline_comment|/* 0x48-0x4f */
id|E0_DOWN
comma
id|E0_PGDN
comma
id|E0_INS
comma
id|E0_DEL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x50-0x57 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_MSLW
comma
id|E0_MSRW
comma
id|E0_MSTM
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x58-0x5f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x60-0x67 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_MACRO
comma
multiline_comment|/* 0x68-0x6f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x70-0x77 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
multiline_comment|/* 0x78-0x7f */
)brace
suffix:semicolon
DECL|variable|prev_scancode
r_static
r_int
r_int
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* remember E0, E1 */
DECL|function|pckbd_setkeycode
r_int
id|pckbd_setkeycode
c_func
(paren
r_int
r_int
id|scancode
comma
r_int
r_int
id|keycode
)paren
(brace
r_if
c_cond
(paren
id|scancode
template_param
l_int|255
op_logical_or
id|keycode
OG
l_int|127
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|scancode
OL
l_int|128
)paren
id|high_keys
(braket
id|scancode
op_minus
id|SC_LIM
)braket
op_assign
id|keycode
suffix:semicolon
r_else
id|e0_keys
(braket
id|scancode
op_minus
l_int|128
)braket
op_assign
id|keycode
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pckbd_getkeycode
r_int
id|pckbd_getkeycode
c_func
(paren
r_int
r_int
id|scancode
)paren
(brace
r_return
(paren
id|scancode
template_param
l_int|255
)paren
ques
c_cond
op_minus
id|EINVAL
suffix:colon
(paren
id|scancode
OL
l_int|128
)paren
ques
c_cond
id|high_keys
(braket
id|scancode
op_minus
id|SC_LIM
)braket
suffix:colon
id|e0_keys
(braket
id|scancode
op_minus
l_int|128
)braket
suffix:semicolon
)brace
macro_line|#if DISABLE_KBD_DURING_INTERRUPTS
DECL|function|send_cmd
r_static
r_inline
r_void
id|send_cmd
c_func
(paren
r_int
r_char
id|c
)paren
(brace
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|c
comma
l_int|0x64
)paren
suffix:semicolon
)brace
DECL|macro|disable_keyboard
mdefine_line|#define disable_keyboard()&t;do { send_cmd(0xAD); kb_wait(); } while (0)
DECL|macro|enable_keyboard
mdefine_line|#define enable_keyboard()&t;send_cmd(0xAE)
macro_line|#else
DECL|macro|disable_keyboard
mdefine_line|#define disable_keyboard()&t;/* nothing */
DECL|macro|enable_keyboard
mdefine_line|#define enable_keyboard()&t;/* nothing */
macro_line|#endif
DECL|function|do_acknowledge
r_static
r_int
id|do_acknowledge
c_func
(paren
r_int
r_char
id|scancode
)paren
(brace
r_if
c_cond
(paren
id|reply_expected
)paren
(brace
multiline_comment|/* 0xfa, 0xfe only mean &quot;acknowledge&quot;, &quot;resend&quot; for most keyboards */
multiline_comment|/* but they are the key-up scancodes for PF6, PF10 on a FOCUS 9000 */
id|reply_expected
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xfa
)paren
(brace
id|acknowledge
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xfe
)paren
(brace
id|resend
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* strange ... */
id|reply_expected
op_assign
l_int|1
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;keyboard reply expected - got %02x&bslash;n&quot;
comma
id|scancode
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef KBD_REPORT_ERR
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;keyboard buffer overflow&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|pckbd_pretranslate
r_int
id|pckbd_pretranslate
c_func
(paren
r_int
r_char
id|scancode
comma
r_char
id|raw_mode
)paren
(brace
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xff
)paren
(brace
multiline_comment|/* in scancode mode 1, my ESC key generates 0xff */
multiline_comment|/* the calculator keys on a FOCUS 9000 generate 0xff */
macro_line|#ifndef KBD_IS_FOCUS_9000
macro_line|#ifdef KBD_REPORT_ERR
r_if
c_cond
(paren
op_logical_neg
id|raw_mode
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;keyboard error&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xe0
op_logical_or
id|scancode
op_eq
l_int|0xe1
)paren
(brace
id|prev_scancode
op_assign
id|scancode
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|pckbd_translate
r_int
id|pckbd_translate
c_func
(paren
r_int
r_char
id|scancode
comma
r_int
r_char
op_star
id|keycode
comma
r_char
id|raw_mode
)paren
(brace
r_if
c_cond
(paren
id|prev_scancode
)paren
(brace
multiline_comment|/*&n;&t;   * usually it will be 0xe0, but a Pause key generates&n;&t;   * e1 1d 45 e1 9d c5 when pressed, and nothing when released&n;&t;   */
r_if
c_cond
(paren
id|prev_scancode
op_ne
l_int|0xe0
)paren
(brace
r_if
c_cond
(paren
id|prev_scancode
op_eq
l_int|0xe1
op_logical_and
id|scancode
op_eq
l_int|0x1d
)paren
(brace
id|prev_scancode
op_assign
l_int|0x100
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|prev_scancode
op_eq
l_int|0x100
op_logical_and
id|scancode
op_eq
l_int|0x45
)paren
(brace
op_star
id|keycode
op_assign
id|E1_PAUSE
suffix:semicolon
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef KBD_REPORT_UNKN
r_if
c_cond
(paren
op_logical_neg
id|raw_mode
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;keyboard: unknown e1 escape sequence&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;       *  The keyboard maintains its own internal caps lock and&n;&t;       *  num lock statuses. In caps lock mode E0 AA precedes make&n;&t;       *  code and E0 2A follows break code. In num lock mode,&n;&t;       *  E0 2A precedes make code and E0 AA follows break code.&n;&t;       *  We do our own book-keeping, so we will just ignore these.&n;&t;       */
multiline_comment|/*&n;&t;       *  For my keyboard there is no caps lock mode, but there are&n;&t;       *  both Shift-L and Shift-R modes. The former mode generates&n;&t;       *  E0 2A / E0 AA pairs, the latter E0 B6 / E0 36 pairs.&n;&t;       *  So, we should also ignore the latter. - aeb@cwi.nl&n;&t;       */
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0x2a
op_logical_or
id|scancode
op_eq
l_int|0x36
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|e0_keys
(braket
id|scancode
)braket
)paren
op_star
id|keycode
op_assign
id|e0_keys
(braket
id|scancode
)braket
suffix:semicolon
r_else
(brace
macro_line|#ifdef KBD_REPORT_UNKN
r_if
c_cond
(paren
op_logical_neg
id|raw_mode
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;keyboard: unknown scancode e0 %02x&bslash;n&quot;
comma
id|scancode
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|scancode
op_ge
id|SC_LIM
)paren
(brace
multiline_comment|/* This happens with the FOCUS 9000 keyboard&n;&t;       Its keys PF1..PF12 are reported to generate&n;&t;       55 73 77 78 79 7a 7b 7c 74 7e 6d 6f&n;&t;       Moreover, unless repeated, they do not generate&n;&t;       key-down events, so we have to zero up_flag below */
multiline_comment|/* Also, Japanese 86/106 keyboards are reported to&n;&t;       generate 0x73 and 0x7d for &bslash; - and &bslash; | respectively. */
multiline_comment|/* Also, some Brazilian keyboard is reported to produce&n;&t;       0x73 and 0x7e for &bslash; ? and KP-dot, respectively. */
op_star
id|keycode
op_assign
id|high_keys
(braket
id|scancode
op_minus
id|SC_LIM
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|keycode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|raw_mode
)paren
(brace
macro_line|#ifdef KBD_REPORT_UNKN
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;keyboard: unrecognized scancode (%02x)&quot;
l_string|&quot; - ignored&bslash;n&quot;
comma
id|scancode
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
op_star
id|keycode
op_assign
id|scancode
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|pckbd_unexpected_up
r_char
id|pckbd_unexpected_up
c_func
(paren
r_int
r_char
id|keycode
)paren
(brace
multiline_comment|/* unexpected, but this can happen: maybe this was a key release for a&n;&t;   FOCUS 9000 PF key; if we want to see it, we have to clear up_flag */
r_if
c_cond
(paren
id|keycode
op_ge
id|SC_LIM
op_logical_or
id|keycode
op_eq
l_int|85
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
l_int|0200
suffix:semicolon
)brace
DECL|function|keyboard_interrupt
r_static
r_void
id|keyboard_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
id|pt_regs
op_assign
id|regs
suffix:semicolon
id|disable_keyboard
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|inb_p
c_func
(paren
l_int|0x64
)paren
suffix:semicolon
r_do
(brace
r_int
r_char
id|scancode
suffix:semicolon
multiline_comment|/* mouse data? */
r_if
c_cond
(paren
id|status
op_amp
id|kbd_read_mask
op_amp
l_int|0x20
)paren
r_break
suffix:semicolon
id|scancode
op_assign
id|inb
c_func
(paren
l_int|0x60
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x01
)paren
op_logical_and
id|do_acknowledge
c_func
(paren
id|scancode
)paren
)paren
id|handle_scancode
c_func
(paren
id|scancode
)paren
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
l_int|0x64
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|status
op_amp
l_int|0x01
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|KEYBOARD_BH
)paren
suffix:semicolon
id|enable_keyboard
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * send_data sends a character to the keyboard and waits&n; * for an acknowledge, possibly retrying if asked to. Returns&n; * the success status.&n; */
DECL|function|send_data
r_static
r_int
id|send_data
c_func
(paren
r_int
r_char
id|data
)paren
(brace
r_int
id|retries
op_assign
l_int|3
suffix:semicolon
r_int
id|i
suffix:semicolon
r_do
(brace
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|acknowledge
op_assign
l_int|0
suffix:semicolon
id|resend
op_assign
l_int|0
suffix:semicolon
id|reply_expected
op_assign
l_int|1
suffix:semicolon
id|outb_p
c_func
(paren
id|data
comma
l_int|0x60
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x200000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|inb_p
c_func
(paren
l_int|0x64
)paren
suffix:semicolon
multiline_comment|/* just as a delay */
r_if
c_cond
(paren
id|acknowledge
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|resend
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|resend
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retries
op_decrement
OG
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pckbd_leds
r_void
id|pckbd_leds
c_func
(paren
r_int
r_char
id|leds
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|send_data
c_func
(paren
l_int|0xed
)paren
op_logical_or
op_logical_neg
id|send_data
c_func
(paren
id|leds
)paren
)paren
id|send_data
c_func
(paren
l_int|0xf4
)paren
suffix:semicolon
multiline_comment|/* re-enable kbd if any errors */
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|pckbd_init_hw
c_func
(paren
r_void
)paren
)paren
(brace
id|request_irq
c_func
(paren
id|KEYBOARD_IRQ
comma
id|keyboard_interrupt
comma
l_int|0
comma
l_string|&quot;keyboard&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|request_region
c_func
(paren
l_int|0x60
comma
l_int|16
comma
l_string|&quot;keyboard&quot;
)paren
suffix:semicolon
macro_line|#ifdef INIT_KBD
id|initialize_kbd
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef INIT_KBD
multiline_comment|/*&n; * keyboard controller registers&n; */
DECL|macro|KBD_STATUS_REG
mdefine_line|#define KBD_STATUS_REG      (unsigned int) 0x64
DECL|macro|KBD_CNTL_REG
mdefine_line|#define KBD_CNTL_REG        (unsigned int) 0x64
DECL|macro|KBD_DATA_REG
mdefine_line|#define KBD_DATA_REG&t;    (unsigned int) 0x60
multiline_comment|/*&n; * controller commands&n; */
DECL|macro|KBD_READ_MODE
mdefine_line|#define KBD_READ_MODE&t;    (unsigned int) 0x20
DECL|macro|KBD_WRITE_MODE
mdefine_line|#define KBD_WRITE_MODE&t;    (unsigned int) 0x60
DECL|macro|KBD_SELF_TEST
mdefine_line|#define KBD_SELF_TEST&t;    (unsigned int) 0xAA
DECL|macro|KBD_SELF_TEST2
mdefine_line|#define KBD_SELF_TEST2&t;    (unsigned int) 0xAB
DECL|macro|KBD_CNTL_ENABLE
mdefine_line|#define KBD_CNTL_ENABLE&t;    (unsigned int) 0xAE
multiline_comment|/*&n; * keyboard commands&n; */
DECL|macro|KBD_ENABLE
mdefine_line|#define KBD_ENABLE&t;    (unsigned int) 0xF4
DECL|macro|KBD_DISABLE
mdefine_line|#define KBD_DISABLE&t;    (unsigned int) 0xF5
DECL|macro|KBD_RESET
mdefine_line|#define KBD_RESET&t;    (unsigned int) 0xFF
multiline_comment|/*&n; * keyboard replies&n; */
DECL|macro|KBD_ACK
mdefine_line|#define KBD_ACK&t;&t;    (unsigned int) 0xFA
DECL|macro|KBD_POR
mdefine_line|#define KBD_POR&t;&t;    (unsigned int) 0xAA
multiline_comment|/*&n; * status register bits&n; */
DECL|macro|KBD_OBF
mdefine_line|#define KBD_OBF&t;&t;    (unsigned int) 0x01
DECL|macro|KBD_IBF
mdefine_line|#define KBD_IBF&t;&t;    (unsigned int) 0x02
DECL|macro|KBD_GTO
mdefine_line|#define KBD_GTO&t;&t;    (unsigned int) 0x40
DECL|macro|KBD_PERR
mdefine_line|#define KBD_PERR&t;    (unsigned int) 0x80
multiline_comment|/*&n; * keyboard controller mode register bits&n; */
DECL|macro|KBD_EKI
mdefine_line|#define KBD_EKI&t;&t;    (unsigned int) 0x01
DECL|macro|KBD_SYS
mdefine_line|#define KBD_SYS&t;&t;    (unsigned int) 0x04
DECL|macro|KBD_DMS
mdefine_line|#define KBD_DMS&t;&t;    (unsigned int) 0x20
DECL|macro|KBD_KCC
mdefine_line|#define KBD_KCC&t;&t;    (unsigned int) 0x40
DECL|macro|TIMEOUT_CONST
mdefine_line|#define TIMEOUT_CONST&t;    500000
DECL|function|kbd_wait_for_input
r_static
r_int
id|kbd_wait_for_input
c_func
(paren
r_void
)paren
(brace
r_int
id|n
suffix:semicolon
r_int
id|status
comma
id|data
suffix:semicolon
id|n
op_assign
id|TIMEOUT_CONST
suffix:semicolon
r_do
(brace
id|status
op_assign
id|inb
c_func
(paren
id|KBD_STATUS_REG
)paren
suffix:semicolon
multiline_comment|/*&n;                 * Wait for input data to become available.  This bit will&n;                 * then be cleared by the following read of the DATA&n;                 * register.&n;                 */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|KBD_OBF
)paren
)paren
r_continue
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|KBD_DATA_REG
)paren
suffix:semicolon
multiline_comment|/*&n;                 * Check to see if a timeout error has occurred.  This means&n;                 * that transmission was started but did not complete in the&n;                 * normal time cycle.  PERR is set when a parity error occurred&n;                 * in the last transmission.&n;                 */
r_if
c_cond
(paren
id|status
op_amp
(paren
id|KBD_GTO
op_or
id|KBD_PERR
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_return
(paren
id|data
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|n
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* timed-out if fell through to here... */
)brace
DECL|function|kbd_write
r_static
r_void
id|kbd_write
c_func
(paren
r_int
id|address
comma
r_int
id|data
)paren
(brace
r_int
id|status
suffix:semicolon
r_do
(brace
id|status
op_assign
id|inb
c_func
(paren
id|KBD_STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* spin until input buffer empty*/
)brace
r_while
c_loop
(paren
id|status
op_amp
id|KBD_IBF
)paren
suffix:semicolon
id|outb
c_func
(paren
id|data
comma
id|address
)paren
suffix:semicolon
multiline_comment|/* write out the data*/
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|initialize_kbd
c_func
(paren
r_void
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Flush any pending input. */
r_while
c_loop
(paren
id|kbd_wait_for_input
c_func
(paren
)paren
op_ne
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t; * Test the keyboard interface.&n;&t; * This seems to be the only way to get it going.&n;&t; * If the test is successful a x55 is placed in the input buffer.&n;&t; */
id|kbd_write
c_func
(paren
id|KBD_CNTL_REG
comma
id|KBD_SELF_TEST
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_wait_for_input
c_func
(paren
)paren
op_ne
l_int|0x55
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;initialize_kbd: &quot;
l_string|&quot;keyboard failed self test.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Perform a keyboard interface test.  This causes the controller&n;&t; * to test the keyboard clock and data lines.  The results of the&n;&t; * test are placed in the input buffer.&n;&t; */
id|kbd_write
c_func
(paren
id|KBD_CNTL_REG
comma
id|KBD_SELF_TEST2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_wait_for_input
c_func
(paren
)paren
op_ne
l_int|0x00
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;initialize_kbd: &quot;
l_string|&quot;keyboard failed self test 2.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Enable the keyboard by allowing the keyboard clock to run. */
id|kbd_write
c_func
(paren
id|KBD_CNTL_REG
comma
id|KBD_CNTL_ENABLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset keyboard. If the read times out&n;&t; * then the assumption is that no keyboard is&n;&t; * plugged into the machine.&n;&t; * This defaults the keyboard to scan-code set 2.&n;&t; */
id|kbd_write
c_func
(paren
id|KBD_DATA_REG
comma
id|KBD_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_wait_for_input
c_func
(paren
)paren
op_ne
id|KBD_ACK
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;initialize_kbd: &quot;
l_string|&quot;reset kbd failed, no ACK.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kbd_wait_for_input
c_func
(paren
)paren
op_ne
id|KBD_POR
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;initialize_kbd: &quot;
l_string|&quot;reset kbd failed, not POR.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * now do a DEFAULTS_DISABLE always&n;&t; */
id|kbd_write
c_func
(paren
id|KBD_DATA_REG
comma
id|KBD_DISABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_wait_for_input
c_func
(paren
)paren
op_ne
id|KBD_ACK
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;initialize_kbd: &quot;
l_string|&quot;disable kbd failed, no ACK.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Enable keyboard interrupt, operate in &quot;sys&quot; mode,&n;&t; *  enable keyboard (by clearing the disable keyboard bit),&n;&t; *  disable mouse, do conversion of keycodes.&n;&t; */
id|kbd_write
c_func
(paren
id|KBD_CNTL_REG
comma
id|KBD_WRITE_MODE
)paren
suffix:semicolon
id|kbd_write
c_func
(paren
id|KBD_DATA_REG
comma
id|KBD_EKI
op_or
id|KBD_SYS
op_or
id|KBD_DMS
op_or
id|KBD_KCC
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now ENABLE the keyboard to set it scanning...&n;&t; */
id|kbd_write
c_func
(paren
id|KBD_DATA_REG
comma
id|KBD_ENABLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_wait_for_input
c_func
(paren
)paren
op_ne
id|KBD_ACK
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;initialize_kbd: &quot;
l_string|&quot;keyboard enable failed.&bslash;n&quot;
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif /* INIT_KBD */
eof
