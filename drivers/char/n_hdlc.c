multiline_comment|/* generic HDLC line discipline for Linux&n; *&n; * Written by Paul Fulghum paulkf@microgate.com&n; * for Microgate Corporation&n; *&n; * Microgate and SyncLink are registered trademarks of Microgate Corporation&n; *&n; * Adapted from ppp.c, written by Michael Callahan &lt;callahan@maths.ox.ac.uk&gt;,&n; *&t;Al Longyear &lt;longyear@netcom.com&gt;, Paul Mackerras &lt;Paul.Mackerras@cs.anu.edu.au&gt;&n; *&n; * Original release 01/11/99&n; * $Id: n_hdlc.c,v 3.2 2000/11/06 22:34:38 paul Exp $&n; *&n; * This code is released under the GNU General Public License (GPL)&n; *&n; * This module implements the tty line discipline N_HDLC for use with&n; * tty device drivers that support bit-synchronous HDLC communications.&n; *&n; * All HDLC data is frame oriented which means:&n; *&n; * 1. tty write calls represent one complete transmit frame of data&n; *    The device driver should accept the complete frame or none of &n; *    the frame (busy) in the write method. Each write call should have&n; *    a byte count in the range of 2-65535 bytes (2 is min HDLC frame&n; *    with 1 addr byte and 1 ctrl byte). The max byte count of 65535&n; *    should include any crc bytes required. For example, when using&n; *    CCITT CRC32, 4 crc bytes are required, so the maximum size frame&n; *    the application may transmit is limited to 65531 bytes. For CCITT&n; *    CRC16, the maximum application frame size would be 65533.&n; *&n; *&n; * 2. receive callbacks from the device driver represents&n; *    one received frame. The device driver should bypass&n; *    the tty flip buffer and call the line discipline receive&n; *    callback directly to avoid fragmenting or concatenating&n; *    multiple frames into a single receive callback.&n; *&n; *    The HDLC line discipline queues the receive frames in seperate&n; *    buffers so complete receive frames can be returned by the&n; *    tty read calls.&n; *&n; * 3. tty read calls returns an entire frame of data or nothing.&n; *    &n; * 4. all send and receive data is considered raw. No processing&n; *    or translation is performed by the line discipline, regardless&n; *    of the tty flags&n; *&n; * 5. When line discipline is queried for the amount of receive&n; *    data available (FIOC), 0 is returned if no data available,&n; *    otherwise the count of the next available frame is returned.&n; *    (instead of the sum of all received frame counts).&n; *&n; * These conventions allow the standard tty programming interface&n; * to be used for synchronous HDLC applications when used with&n; * this line discipline (or another line discipline that is frame&n; * oriented such as N_PPP).&n; *&n; * The SyncLink driver (synclink.c) implements both asynchronous&n; * (using standard line discipline N_TTY) and synchronous HDLC&n; * (using N_HDLC) communications, with the latter using the above&n; * conventions.&n; *&n; * This implementation is very basic and does not maintain&n; * any statistics. The main point is to enforce the raw data&n; * and frame orientation of HDLC communications.&n; *&n; * THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES&n; * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&n; * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,&n; * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES&n; * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR&n; * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,&n; * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)&n; * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED&n; * OF THE POSSIBILITY OF SUCH DAMAGE.&n; */
DECL|macro|HDLC_MAGIC
mdefine_line|#define HDLC_MAGIC 0x239e
DECL|macro|HDLC_VERSION
mdefine_line|#define HDLC_VERSION &quot;3.2&quot;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
DECL|macro|VERSION
macro_line|#undef VERSION
DECL|macro|VERSION
mdefine_line|#define VERSION(major,minor,patch) (((((major)&lt;&lt;8)+(minor))&lt;&lt;8)+(patch))
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;linux/in.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;&t;/* used in new tty drivers */
macro_line|#include &lt;linux/signal.h&gt;&t;/* used in new tty drivers */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/termios.h&gt;
macro_line|#include &lt;linux/if.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#ifdef CONFIG_KERNELD
macro_line|#include &lt;linux/kerneld.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|GET_USER
mdefine_line|#define GET_USER(error,value,addr) error = get_user(value,addr)
DECL|macro|COPY_FROM_USER
mdefine_line|#define COPY_FROM_USER(error,dest,src,size) error = copy_from_user(dest,src,size) ? -EFAULT : 0
DECL|macro|PUT_USER
mdefine_line|#define PUT_USER(error,value,addr) error = put_user(value,addr)
DECL|macro|COPY_TO_USER
mdefine_line|#define COPY_TO_USER(error,dest,src,size) error = copy_to_user(dest,src,size) ? -EFAULT : 0
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|typedef|rw_ret_t
r_typedef
id|ssize_t
id|rw_ret_t
suffix:semicolon
DECL|typedef|rw_count_t
r_typedef
r_int
id|rw_count_t
suffix:semicolon
multiline_comment|/*&n; * Buffers for individual HDLC frames&n; */
DECL|macro|MAX_HDLC_FRAME_SIZE
mdefine_line|#define MAX_HDLC_FRAME_SIZE 65535 
DECL|macro|DEFAULT_RX_BUF_COUNT
mdefine_line|#define DEFAULT_RX_BUF_COUNT 10
DECL|macro|MAX_RX_BUF_COUNT
mdefine_line|#define MAX_RX_BUF_COUNT 60
DECL|macro|DEFAULT_TX_BUF_COUNT
mdefine_line|#define DEFAULT_TX_BUF_COUNT 1
DECL|struct|_n_hdlc_buf
r_typedef
r_struct
id|_n_hdlc_buf
(brace
DECL|member|link
r_struct
id|_n_hdlc_buf
op_star
id|link
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|buf
r_char
id|buf
(braket
l_int|1
)braket
suffix:semicolon
DECL|typedef|N_HDLC_BUF
)brace
id|N_HDLC_BUF
suffix:semicolon
DECL|macro|N_HDLC_BUF_SIZE
mdefine_line|#define&t;N_HDLC_BUF_SIZE&t;(sizeof(N_HDLC_BUF)+maxframe)
DECL|struct|_n_hdlc_buf_list
r_typedef
r_struct
id|_n_hdlc_buf_list
(brace
DECL|member|head
id|N_HDLC_BUF
op_star
id|head
suffix:semicolon
DECL|member|tail
id|N_HDLC_BUF
op_star
id|tail
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
DECL|member|spinlock
id|spinlock_t
id|spinlock
suffix:semicolon
DECL|typedef|N_HDLC_BUF_LIST
)brace
id|N_HDLC_BUF_LIST
suffix:semicolon
multiline_comment|/*&n; * Per device instance data structure&n; */
DECL|struct|n_hdlc
r_struct
id|n_hdlc
(brace
DECL|member|magic
r_int
id|magic
suffix:semicolon
multiline_comment|/* magic value for structure&t;*/
DECL|member|flags
id|__u32
id|flags
suffix:semicolon
multiline_comment|/* miscellaneous control flags&t;*/
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
multiline_comment|/* ptr to TTY structure&t;*/
DECL|member|backup_tty
r_struct
id|tty_struct
op_star
id|backup_tty
suffix:semicolon
multiline_comment|/* TTY to use if tty gets closed */
multiline_comment|/* Queues for select() functionality */
DECL|member|read_wait
id|wait_queue_head_t
id|read_wait
suffix:semicolon
DECL|member|write_wait
id|wait_queue_head_t
id|write_wait
suffix:semicolon
DECL|member|poll_wait
id|wait_queue_head_t
id|poll_wait
suffix:semicolon
DECL|member|tbusy
r_int
id|tbusy
suffix:semicolon
multiline_comment|/* reentrancy flag for tx wakeup code */
DECL|member|woke_up
r_int
id|woke_up
suffix:semicolon
DECL|member|tbuf
id|N_HDLC_BUF
op_star
id|tbuf
suffix:semicolon
multiline_comment|/* currently transmitting tx buffer */
DECL|member|tx_buf_list
id|N_HDLC_BUF_LIST
id|tx_buf_list
suffix:semicolon
multiline_comment|/* list of pending transmit frame buffers */
DECL|member|rx_buf_list
id|N_HDLC_BUF_LIST
id|rx_buf_list
suffix:semicolon
multiline_comment|/* list of received frame buffers */
DECL|member|tx_free_buf_list
id|N_HDLC_BUF_LIST
id|tx_free_buf_list
suffix:semicolon
multiline_comment|/* list unused transmit frame buffers */
DECL|member|rx_free_buf_list
id|N_HDLC_BUF_LIST
id|rx_free_buf_list
suffix:semicolon
multiline_comment|/* list unused received frame buffers */
)brace
suffix:semicolon
multiline_comment|/*&n; * HDLC buffer list manipulation functions&n; */
r_void
id|n_hdlc_buf_list_init
c_func
(paren
id|N_HDLC_BUF_LIST
op_star
id|list
)paren
suffix:semicolon
r_void
id|n_hdlc_buf_put
c_func
(paren
id|N_HDLC_BUF_LIST
op_star
id|list
comma
id|N_HDLC_BUF
op_star
id|buf
)paren
suffix:semicolon
id|N_HDLC_BUF
op_star
id|n_hdlc_buf_get
c_func
(paren
id|N_HDLC_BUF_LIST
op_star
id|list
)paren
suffix:semicolon
multiline_comment|/* Local functions */
r_static
r_struct
id|n_hdlc
op_star
id|n_hdlc_alloc
(paren
r_void
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debuglevel
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|maxframe
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/* debug level can be set by insmod for debugging purposes */
DECL|macro|DEBUG_LEVEL_INFO
mdefine_line|#define DEBUG_LEVEL_INFO&t;1
DECL|variable|debuglevel
r_int
id|debuglevel
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* max frame size for memory allocations */
DECL|variable|maxframe
id|ssize_t
id|maxframe
op_assign
l_int|4096
suffix:semicolon
multiline_comment|/* TTY callbacks */
r_static
id|rw_ret_t
id|n_hdlc_tty_read
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
comma
id|__u8
op_star
comma
id|rw_count_t
)paren
suffix:semicolon
r_static
id|rw_ret_t
id|n_hdlc_tty_write
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
comma
r_const
id|__u8
op_star
comma
id|rw_count_t
)paren
suffix:semicolon
r_static
r_int
id|n_hdlc_tty_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
r_int
id|n_hdlc_tty_poll
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
id|poll_table
op_star
id|wait
)paren
suffix:semicolon
r_static
r_int
id|n_hdlc_tty_open
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_void
id|n_hdlc_tty_close
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_int
id|n_hdlc_tty_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_void
id|n_hdlc_tty_receive
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
id|__u8
op_star
id|cp
comma
r_char
op_star
id|fp
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_void
id|n_hdlc_tty_wakeup
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
DECL|macro|bset
mdefine_line|#define bset(p,b)&t;((p)[(b) &gt;&gt; 5] |= (1 &lt;&lt; ((b) &amp; 0x1f)))
DECL|macro|tty2n_hdlc
mdefine_line|#define tty2n_hdlc(tty)&t;((struct n_hdlc *) ((tty)-&gt;disc_data))
DECL|macro|n_hdlc2tty
mdefine_line|#define n_hdlc2tty(n_hdlc)&t;((n_hdlc)-&gt;tty)
multiline_comment|/* Define this string only once for all macro invocations */
DECL|variable|szVersion
r_static
r_char
id|szVersion
(braket
)braket
op_assign
id|HDLC_VERSION
suffix:semicolon
multiline_comment|/* n_hdlc_release()&n; *&n; *&t;release an n_hdlc per device line discipline info structure&n; *&n; */
DECL|function|n_hdlc_release
r_static
r_void
id|n_hdlc_release
(paren
r_struct
id|n_hdlc
op_star
id|n_hdlc
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|n_hdlc2tty
(paren
id|n_hdlc
)paren
suffix:semicolon
id|N_HDLC_BUF
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_release() called&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
multiline_comment|/* Ensure that the n_hdlcd process is not hanging on select()/poll() */
id|wake_up_interruptible
(paren
op_amp
id|n_hdlc-&gt;read_wait
)paren
suffix:semicolon
id|wake_up_interruptible
(paren
op_amp
id|n_hdlc-&gt;poll_wait
)paren
suffix:semicolon
id|wake_up_interruptible
(paren
op_amp
id|n_hdlc-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_ne
l_int|NULL
op_logical_and
id|tty-&gt;disc_data
op_eq
id|n_hdlc
)paren
id|tty-&gt;disc_data
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Break the tty-&gt;n_hdlc link */
multiline_comment|/* Release transmit and receive buffers */
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|buf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_free_buf_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|buf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_free_buf_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|buf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_buf_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|buf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
(brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|n_hdlc
)paren
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_release() */
multiline_comment|/* n_hdlc_tty_close()&n; *&n; *&t;Called when the line discipline is changed to something&n; *&t;else, the tty is closed, or the tty detects a hangup.&n; */
DECL|function|n_hdlc_tty_close
r_static
r_void
id|n_hdlc_tty_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_close() called&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|n_hdlc-&gt;magic
op_ne
id|HDLC_MAGIC
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;n_hdlc: trying to close unopened tty!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if defined(TTY_NO_WRITE_SPLIT)
id|clear_bit
c_func
(paren
id|TTY_NO_WRITE_SPLIT
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
macro_line|#endif
id|tty-&gt;disc_data
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_eq
id|n_hdlc-&gt;backup_tty
)paren
id|n_hdlc-&gt;backup_tty
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_ne
id|n_hdlc-&gt;tty
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc-&gt;backup_tty
)paren
(brace
id|n_hdlc-&gt;tty
op_assign
id|n_hdlc-&gt;backup_tty
suffix:semicolon
)brace
r_else
(brace
id|n_hdlc_release
(paren
id|n_hdlc
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_close() success&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_close() */
multiline_comment|/* n_hdlc_tty_open&n; * &n; * &t;called when line discipline changed to n_hdlc&n; * &t;&n; * Arguments:&t;tty&t;pointer to tty info structure&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|n_hdlc_tty_open
r_static
r_int
id|n_hdlc_tty_open
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_open() called (major=%u,minor=%u)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|MAJOR
c_func
(paren
id|tty-&gt;device
)paren
comma
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
multiline_comment|/* There should not be an existing table for this slot. */
r_if
c_cond
(paren
id|n_hdlc
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;n_hdlc_tty_open:tty already associated!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EEXIST
suffix:semicolon
)brace
id|n_hdlc
op_assign
id|n_hdlc_alloc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;n_hdlc_alloc failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENFILE
suffix:semicolon
)brace
id|tty-&gt;disc_data
op_assign
id|n_hdlc
suffix:semicolon
id|n_hdlc-&gt;tty
op_assign
id|tty
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#if defined(TTY_NO_WRITE_SPLIT)
multiline_comment|/* change tty_io write() to not split large writes into 8K chunks */
id|set_bit
c_func
(paren
id|TTY_NO_WRITE_SPLIT
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Flush any pending characters in the driver and discipline. */
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc.flush_buffer
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver.flush_buffer
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_open() success&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of n_tty_hdlc_open() */
multiline_comment|/* n_hdlc_send_frames()&n; * &n; * &t;send frames on pending send buffer list until the&n; * &t;driver does not accept a frame (busy)&n; * &t;this function is called after adding a frame to the&n; * &t;send buffer list and by the tty wakeup callback&n; * &t;&n; * Arguments:&t;&t;n_hdlc&t;&t;pointer to ldisc instance data&n; * &t;&t;&t;tty&t;&t;pointer to tty instance data&n; * Return Value:&t;None&n; */
DECL|function|n_hdlc_send_frames
r_static
r_void
id|n_hdlc_send_frames
(paren
r_struct
id|n_hdlc
op_star
id|n_hdlc
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_register
r_int
id|actual
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|N_HDLC_BUF
op_star
id|tbuf
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_send_frames() called&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
id|check_again
suffix:colon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc-&gt;tbusy
)paren
(brace
id|n_hdlc-&gt;woke_up
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|n_hdlc-&gt;tbusy
op_assign
l_int|1
suffix:semicolon
id|n_hdlc-&gt;woke_up
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* get current transmit buffer or get new transmit */
multiline_comment|/* buffer from list of pending transmit buffers */
id|tbuf
op_assign
id|n_hdlc-&gt;tbuf
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tbuf
)paren
id|tbuf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tbuf
)paren
(brace
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)sending frame %p, count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tbuf
comma
id|tbuf-&gt;count
)paren
suffix:semicolon
multiline_comment|/* Send the next block of data to device */
id|tty-&gt;flags
op_or_assign
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
id|actual
op_assign
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
id|tbuf-&gt;buf
comma
id|tbuf-&gt;count
)paren
suffix:semicolon
multiline_comment|/* if transmit error, throw frame away by */
multiline_comment|/* pretending it was accepted by driver */
r_if
c_cond
(paren
id|actual
OL
l_int|0
)paren
id|actual
op_assign
id|tbuf-&gt;count
suffix:semicolon
r_if
c_cond
(paren
id|actual
op_eq
id|tbuf-&gt;count
)paren
(brace
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)frame %p completed&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tbuf
)paren
suffix:semicolon
multiline_comment|/* free current transmit buffer */
id|n_hdlc_buf_put
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_free_buf_list
comma
id|tbuf
)paren
suffix:semicolon
multiline_comment|/* this tx buffer is done */
id|n_hdlc-&gt;tbuf
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* wait up sleeping writers */
id|wake_up_interruptible
c_func
(paren
op_amp
id|n_hdlc-&gt;write_wait
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|n_hdlc-&gt;poll_wait
)paren
suffix:semicolon
multiline_comment|/* get next pending transmit buffer */
id|tbuf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)frame %p pending&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tbuf
)paren
suffix:semicolon
multiline_comment|/* buffer not accepted by driver */
multiline_comment|/* set this buffer as pending buffer */
id|n_hdlc-&gt;tbuf
op_assign
id|tbuf
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|tbuf
)paren
id|tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
multiline_comment|/* Clear the re-entry flag */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|n_hdlc-&gt;tbusy
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc-&gt;woke_up
)paren
r_goto
id|check_again
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_send_frames() exit&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_send_frames() */
multiline_comment|/* n_hdlc_tty_wakeup()&n; *&n; *&t;Callback for transmit wakeup. Called when low level&n; *&t;device driver can accept more send data.&n; *&n; * Arguments:&t;&t;tty&t;pointer to associated tty instance data&n; * Return Value:&t;None&n; */
DECL|function|n_hdlc_tty_wakeup
r_static
r_void
id|n_hdlc_tty_wakeup
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_wakeup() called&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tty
op_ne
id|n_hdlc-&gt;tty
)paren
(brace
id|tty-&gt;flags
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|n_hdlc_send_frames
(paren
id|n_hdlc
comma
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_wakeup() */
multiline_comment|/* n_hdlc_tty_room()&n; * &n; *&t;Callback function from tty driver. Return the amount of &n; *&t;space left in the receiver&squot;s buffer to decide if remote&n; *&t;transmitter is to be throttled.&n; *&n; * Arguments:&t;&t;tty&t;pointer to associated tty instance data&n; * Return Value:&t;number of bytes left in receive buffer&n; */
DECL|function|n_hdlc_tty_room
r_static
r_int
id|n_hdlc_tty_room
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_room() called&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
multiline_comment|/* always return a larger number to prevent */
multiline_comment|/* throttling of remote transmitter. */
r_return
l_int|65536
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_root() */
multiline_comment|/* n_hdlc_tty_receive()&n; * &n; * &t;Called by tty low level driver when receive data is&n; * &t;available. Data is interpreted as one HDLC frame.&n; * &t;&n; * Arguments:&t; &t;tty&t;&t;pointer to tty isntance data&n; * &t;&t;&t;data&t;&t;pointer to received data&n; * &t;&t;&t;flags&t;&t;pointer to flags for data&n; * &t;&t;&t;count&t;&t;count of received data in bytes&n; * &t;&n; * Return Value:&t;None&n; */
DECL|function|n_hdlc_tty_receive
r_static
r_void
id|n_hdlc_tty_receive
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
id|__u8
op_star
id|data
comma
r_char
op_star
id|flags
comma
r_int
id|count
)paren
(brace
r_register
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_register
id|N_HDLC_BUF
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_receive() called count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* This can happen if stuff comes in on the backup tty */
r_if
c_cond
(paren
id|n_hdlc
op_eq
l_int|0
op_logical_or
id|tty
op_ne
id|n_hdlc-&gt;tty
)paren
r_return
suffix:semicolon
multiline_comment|/* verify line is using HDLC discipline */
r_if
c_cond
(paren
id|n_hdlc-&gt;magic
op_ne
id|HDLC_MAGIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d) line not using HDLC discipline&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
id|maxframe
)paren
(brace
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d) rx count&gt;maxframesize, data discarded&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* get a free HDLC buffer */
id|buf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_free_buf_list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
multiline_comment|/* no buffers in free list, attempt to allocate another rx buffer */
multiline_comment|/* unless the maximum count has been reached */
r_if
c_cond
(paren
id|n_hdlc-&gt;rx_buf_list.count
OL
id|MAX_RX_BUF_COUNT
)paren
id|buf
op_assign
(paren
id|N_HDLC_BUF
op_star
)paren
id|kmalloc
c_func
(paren
id|N_HDLC_BUF_SIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
(brace
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d) no more rx buffers, data discarded&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* copy received data to HDLC buffer */
id|memcpy
c_func
(paren
id|buf-&gt;buf
comma
id|data
comma
id|count
)paren
suffix:semicolon
id|buf-&gt;count
op_assign
id|count
suffix:semicolon
multiline_comment|/* add HDLC buffer to list of received frames */
id|n_hdlc_buf_put
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_buf_list
comma
id|buf
)paren
suffix:semicolon
multiline_comment|/* wake up any blocked reads and perform async signalling */
id|wake_up_interruptible
(paren
op_amp
id|n_hdlc-&gt;read_wait
)paren
suffix:semicolon
id|wake_up_interruptible
(paren
op_amp
id|n_hdlc-&gt;poll_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc-&gt;tty-&gt;fasync
op_ne
l_int|NULL
)paren
id|kill_fasync
(paren
op_amp
id|n_hdlc-&gt;tty-&gt;fasync
comma
id|SIGIO
comma
id|POLL_IN
)paren
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_receive() */
multiline_comment|/* n_hdlc_tty_read()&n; * &n; * &t;Called to retreive one frame of data (if available)&n; * &t;&n; * Arguments:&n; * &n; * &t;tty&t;&t;pointer to tty instance data&n; * &t;file&t;&t;pointer to open file object&n; * &t;buf&t;&t;pointer to returned data buffer&n; * &t;nr&t;&t;size of returned data buffer&n; * &t;&n; * Return Value:&n; * &n; * &t;Number of bytes returned or error code&n; */
DECL|function|n_hdlc_tty_read
r_static
id|rw_ret_t
id|n_hdlc_tty_read
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
id|__u8
op_star
id|buf
comma
id|rw_count_t
id|nr
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
c_func
(paren
id|tty
)paren
suffix:semicolon
r_int
id|error
suffix:semicolon
id|rw_ret_t
id|ret
suffix:semicolon
id|N_HDLC_BUF
op_star
id|rbuf
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_read() called&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
multiline_comment|/* Validate the pointers */
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* verify user access to buffer */
id|error
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s(%d) n_hdlc_tty_read() can&squot;t verify user &quot;
l_string|&quot;buffer&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
(paren
id|error
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
op_logical_or
id|n_hdlc-&gt;magic
op_ne
id|HDLC_MAGIC
op_logical_or
id|tty
op_ne
id|n_hdlc-&gt;tty
)paren
r_return
l_int|0
suffix:semicolon
id|rbuf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_buf_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rbuf
)paren
r_break
suffix:semicolon
multiline_comment|/* no data */
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|interruptible_sleep_on
(paren
op_amp
id|n_hdlc-&gt;read_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rbuf-&gt;count
OG
id|nr
)paren
(brace
multiline_comment|/* frame too large for caller&squot;s buffer (discard frame) */
id|ret
op_assign
(paren
id|rw_ret_t
)paren
op_minus
id|EOVERFLOW
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Copy the data to the caller&squot;s buffer */
id|COPY_TO_USER
c_func
(paren
id|error
comma
id|buf
comma
id|rbuf-&gt;buf
comma
id|rbuf-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
id|ret
op_assign
(paren
id|rw_ret_t
)paren
id|error
suffix:semicolon
r_else
id|ret
op_assign
(paren
id|rw_ret_t
)paren
id|rbuf-&gt;count
suffix:semicolon
)brace
multiline_comment|/* return HDLC buffer to free list unless the free list */
multiline_comment|/* count has exceeded the default value, in which case the */
multiline_comment|/* buffer is freed back to the OS to conserve memory */
r_if
c_cond
(paren
id|n_hdlc-&gt;rx_free_buf_list.count
OG
id|DEFAULT_RX_BUF_COUNT
)paren
id|kfree
c_func
(paren
id|rbuf
)paren
suffix:semicolon
r_else
id|n_hdlc_buf_put
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_free_buf_list
comma
id|rbuf
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_read() */
multiline_comment|/* n_hdlc_tty_write()&n; * &n; * &t;write a single frame of data to device&n; * &t;&n; * Arguments:&t;tty&t;pointer to associated tty device instance data&n; * &t;&t;file&t;pointer to file object data&n; * &t;&t;data&t;pointer to transmit data (one frame)&n; * &t;&t;count&t;size of transmit frame in bytes&n; * &t;&t;&n; * Return Value:&t;number of bytes written (or error code)&n; */
DECL|function|n_hdlc_tty_write
r_static
id|rw_ret_t
id|n_hdlc_tty_write
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_const
id|__u8
op_star
id|data
comma
id|rw_count_t
id|count
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|N_HDLC_BUF
op_star
id|tbuf
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_write() called count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|count
)paren
suffix:semicolon
multiline_comment|/* Verify pointers */
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc-&gt;magic
op_ne
id|HDLC_MAGIC
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* verify frame size */
r_if
c_cond
(paren
id|count
OG
id|maxframe
)paren
(brace
r_if
c_cond
(paren
id|debuglevel
op_amp
id|DEBUG_LEVEL_INFO
)paren
id|printk
(paren
id|KERN_WARNING
l_string|&quot;n_hdlc_tty_write: truncating user packet &quot;
l_string|&quot;from %lu to %d&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|count
comma
id|maxframe
)paren
suffix:semicolon
id|count
op_assign
id|maxframe
suffix:semicolon
)brace
id|add_wait_queue
c_func
(paren
op_amp
id|n_hdlc-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
multiline_comment|/* Allocate transmit buffer */
multiline_comment|/* sleep until transmit buffer available */
r_while
c_loop
(paren
op_logical_neg
(paren
id|tbuf
op_assign
id|n_hdlc_buf_get
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_free_buf_list
)paren
)paren
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
op_logical_or
id|n_hdlc-&gt;magic
op_ne
id|HDLC_MAGIC
op_logical_or
id|tty
op_ne
id|n_hdlc-&gt;tty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;n_hdlc_tty_write: %p invalid after wait!&bslash;n&quot;
comma
id|n_hdlc
)paren
suffix:semicolon
id|error
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|error
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|n_hdlc-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
multiline_comment|/* Retrieve the user&squot;s buffer */
id|COPY_FROM_USER
(paren
id|error
comma
id|tbuf-&gt;buf
comma
id|data
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
multiline_comment|/* return tx buffer to free list */
id|n_hdlc_buf_put
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_free_buf_list
comma
id|tbuf
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Send the data */
id|tbuf-&gt;count
op_assign
id|error
op_assign
id|count
suffix:semicolon
id|n_hdlc_buf_put
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list
comma
id|tbuf
)paren
suffix:semicolon
id|n_hdlc_send_frames
c_func
(paren
id|n_hdlc
comma
id|tty
)paren
suffix:semicolon
)brace
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_write() */
multiline_comment|/* n_hdlc_tty_ioctl()&n; *&n; *&t;Process IOCTL system call for the tty device.&n; *&n; * Arguments:&n; *&n; *&t;tty&t;&t;pointer to tty instance data&n; *&t;file&t;&t;pointer to open file object for device&n; *&t;cmd&t;&t;IOCTL command code&n; *&t;arg&t;&t;argument for IOCTL call (cmd dependent)&n; *&n; * Return Value:&t;Command dependent&n; */
DECL|function|n_hdlc_tty_ioctl
r_static
r_int
id|n_hdlc_tty_ioctl
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_ioctl() called %d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* Verify the status of the device */
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
op_logical_or
id|n_hdlc-&gt;magic
op_ne
id|HDLC_MAGIC
)paren
r_return
op_minus
id|EBADF
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FIONREAD
suffix:colon
multiline_comment|/* report count of read data available */
multiline_comment|/* in next available frame (if any) */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_buf_list.spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc-&gt;rx_buf_list.head
)paren
id|count
op_assign
id|n_hdlc-&gt;rx_buf_list.head-&gt;count
suffix:semicolon
r_else
id|count
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_buf_list.spinlock
comma
id|flags
)paren
suffix:semicolon
id|PUT_USER
(paren
id|error
comma
id|count
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCOUTQ
suffix:colon
multiline_comment|/* get the pending tx byte count in the driver */
id|count
op_assign
id|tty-&gt;driver.chars_in_buffer
ques
c_cond
id|tty-&gt;driver
dot
id|chars_in_buffer
c_func
(paren
id|tty
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* add size of next output frame in queue */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list.spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc-&gt;tx_buf_list.head
)paren
id|count
op_add_assign
id|n_hdlc-&gt;tx_buf_list.head-&gt;count
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list.spinlock
comma
id|flags
)paren
suffix:semicolon
id|PUT_USER
(paren
id|error
comma
id|count
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|error
op_assign
id|n_tty_ioctl
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_ioctl() */
multiline_comment|/* n_hdlc_tty_poll()&n; * &n; * &t;TTY callback for poll system call. Determine which &n; * &t;operations (read/write) will not block and return&n; * &t;info to caller.&n; * &t;&n; * Arguments:&n; * &n; * &t;tty&t;&t;pointer to tty instance data&n; * &t;filp&t;&t;pointer to open file object for device&n; * &t;poll_table&t;wait queue for operations&n; * &n; * Return Value:&n; * &n; * &t;bit mask containing info on which ops will not block&n; */
DECL|function|n_hdlc_tty_poll
r_static
r_int
r_int
id|n_hdlc_tty_poll
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
op_assign
id|tty2n_hdlc
(paren
id|tty
)paren
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_tty_poll() called&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n_hdlc
op_logical_and
id|n_hdlc-&gt;magic
op_eq
id|HDLC_MAGIC
op_logical_and
id|tty
op_eq
id|n_hdlc-&gt;tty
)paren
(brace
multiline_comment|/* queue current process into any wait queue that */
multiline_comment|/* may awaken in the future (read and write) */
id|poll_wait
c_func
(paren
id|filp
comma
op_amp
id|n_hdlc-&gt;poll_wait
comma
id|wait
)paren
suffix:semicolon
multiline_comment|/* set bits for operations that wont block */
r_if
c_cond
(paren
id|n_hdlc-&gt;rx_buf_list.head
)paren
(brace
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
multiline_comment|/* readable */
r_if
c_cond
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_OTHER_CLOSED
)paren
)paren
(brace
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|n_hdlc-&gt;tx_free_buf_list.head
)paren
(brace
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
multiline_comment|/* writable */
)brace
r_return
id|mask
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_tty_poll() */
multiline_comment|/* n_hdlc_alloc()&n; * &n; * &t;Allocate an n_hdlc instance data structure&n; *&n; * Arguments:&t;&t;None&n; * Return Value:&t;pointer to structure if success, otherwise 0&t;&n; */
DECL|function|n_hdlc_alloc
r_static
r_struct
id|n_hdlc
op_star
id|n_hdlc_alloc
(paren
r_void
)paren
(brace
r_struct
id|n_hdlc
op_star
id|n_hdlc
suffix:semicolon
id|N_HDLC_BUF
op_star
id|buf
suffix:semicolon
r_int
id|i
suffix:semicolon
id|n_hdlc
op_assign
(paren
r_struct
id|n_hdlc
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|n_hdlc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n_hdlc
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|n_hdlc
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|n_hdlc
)paren
)paren
suffix:semicolon
id|n_hdlc_buf_list_init
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_free_buf_list
)paren
suffix:semicolon
id|n_hdlc_buf_list_init
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_free_buf_list
)paren
suffix:semicolon
id|n_hdlc_buf_list_init
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_buf_list
)paren
suffix:semicolon
id|n_hdlc_buf_list_init
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_buf_list
)paren
suffix:semicolon
multiline_comment|/* allocate free rx buffer list */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEFAULT_RX_BUF_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
op_assign
(paren
id|N_HDLC_BUF
op_star
)paren
id|kmalloc
c_func
(paren
id|N_HDLC_BUF_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
id|n_hdlc_buf_put
c_func
(paren
op_amp
id|n_hdlc-&gt;rx_free_buf_list
comma
id|buf
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_alloc(), kalloc() failed for rx buffer %d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* allocate free tx buffer list */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|DEFAULT_TX_BUF_COUNT
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
op_assign
(paren
id|N_HDLC_BUF
op_star
)paren
id|kmalloc
c_func
(paren
id|N_HDLC_BUF_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
id|n_hdlc_buf_put
c_func
(paren
op_amp
id|n_hdlc-&gt;tx_free_buf_list
comma
id|buf
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|debuglevel
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d)n_hdlc_alloc(), kalloc() failed for tx buffer %d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize the control block */
id|n_hdlc-&gt;magic
op_assign
id|HDLC_MAGIC
suffix:semicolon
id|n_hdlc-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|n_hdlc-&gt;read_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|n_hdlc-&gt;poll_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|n_hdlc-&gt;write_wait
)paren
suffix:semicolon
r_return
id|n_hdlc
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_alloc() */
multiline_comment|/* n_hdlc_buf_list_init()&n; * &n; * &t;initialize specified HDLC buffer list&n; * &t;&n; * Arguments:&t; &t;list&t;pointer to buffer list&n; * Return Value:&t;None&t;&n; */
DECL|function|n_hdlc_buf_list_init
r_void
id|n_hdlc_buf_list_init
c_func
(paren
id|N_HDLC_BUF_LIST
op_star
id|list
)paren
(brace
id|memset
c_func
(paren
id|list
comma
l_int|0
comma
r_sizeof
(paren
id|N_HDLC_BUF_LIST
)paren
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|list-&gt;spinlock
)paren
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_buf_list_init() */
multiline_comment|/* n_hdlc_buf_put()&n; * &n; * &t;add specified HDLC buffer to tail of specified list&n; * &t;&n; * Arguments:&n; * &n; * &t;list&t;pointer to buffer list&n; * &t;buf&t;pointer to buffer&n; * &n; * Return Value:&t;None&t;&n; */
DECL|function|n_hdlc_buf_put
r_void
id|n_hdlc_buf_put
c_func
(paren
id|N_HDLC_BUF_LIST
op_star
id|list
comma
id|N_HDLC_BUF
op_star
id|buf
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|list-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
id|buf-&gt;link
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|list-&gt;tail
)paren
(brace
id|list-&gt;tail-&gt;link
op_assign
id|buf
suffix:semicolon
)brace
r_else
id|list-&gt;head
op_assign
id|buf
suffix:semicolon
id|list-&gt;tail
op_assign
id|buf
suffix:semicolon
(paren
id|list-&gt;count
)paren
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|list-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_buf_put() */
multiline_comment|/* n_hdlc_buf_get()&n; * &n; * &t;remove and return an HDLC buffer from the&n; * &t;head of the specified HDLC buffer list&n; * &t;&n; * Arguments:&n; * &n; * &t;list&t;pointer to HDLC buffer list&n; * &t;&n; * Return Value:&n; * &n; * &t;pointer to HDLC buffer if available, otherwise NULL&n; */
DECL|function|n_hdlc_buf_get
id|N_HDLC_BUF
op_star
id|n_hdlc_buf_get
c_func
(paren
id|N_HDLC_BUF_LIST
op_star
id|list
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|N_HDLC_BUF
op_star
id|buf
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|list-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
id|buf
op_assign
id|list-&gt;head
suffix:semicolon
r_if
c_cond
(paren
id|buf
)paren
(brace
id|list-&gt;head
op_assign
id|buf-&gt;link
suffix:semicolon
(paren
id|list-&gt;count
)paren
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|list-&gt;head
)paren
id|list-&gt;tail
op_assign
l_int|NULL
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|list-&gt;spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
multiline_comment|/* end of n_hdlc_buf_get() */
DECL|function|n_hdlc_init
r_static
r_int
id|__init
id|n_hdlc_init
c_func
(paren
r_void
)paren
(brace
r_static
r_struct
id|tty_ldisc
id|n_hdlc_ldisc
suffix:semicolon
r_int
id|status
suffix:semicolon
multiline_comment|/* range check maxframe arg */
r_if
c_cond
(paren
id|maxframe
OL
l_int|4096
)paren
id|maxframe
op_assign
l_int|4096
suffix:semicolon
r_else
r_if
c_cond
(paren
id|maxframe
OG
l_int|65535
)paren
id|maxframe
op_assign
l_int|65535
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;HDLC line discipline: version %s, maxframe=%u&bslash;n&quot;
comma
id|szVersion
comma
id|maxframe
)paren
suffix:semicolon
multiline_comment|/* Register the tty discipline */
id|memset
c_func
(paren
op_amp
id|n_hdlc_ldisc
comma
l_int|0
comma
r_sizeof
(paren
id|n_hdlc_ldisc
)paren
)paren
suffix:semicolon
id|n_hdlc_ldisc.magic
op_assign
id|TTY_LDISC_MAGIC
suffix:semicolon
id|n_hdlc_ldisc.name
op_assign
l_string|&quot;hdlc&quot;
suffix:semicolon
id|n_hdlc_ldisc.open
op_assign
id|n_hdlc_tty_open
suffix:semicolon
id|n_hdlc_ldisc.close
op_assign
id|n_hdlc_tty_close
suffix:semicolon
id|n_hdlc_ldisc.read
op_assign
id|n_hdlc_tty_read
suffix:semicolon
id|n_hdlc_ldisc.write
op_assign
id|n_hdlc_tty_write
suffix:semicolon
id|n_hdlc_ldisc.ioctl
op_assign
id|n_hdlc_tty_ioctl
suffix:semicolon
id|n_hdlc_ldisc.poll
op_assign
id|n_hdlc_tty_poll
suffix:semicolon
id|n_hdlc_ldisc.receive_room
op_assign
id|n_hdlc_tty_room
suffix:semicolon
id|n_hdlc_ldisc.receive_buf
op_assign
id|n_hdlc_tty_receive
suffix:semicolon
id|n_hdlc_ldisc.write_wakeup
op_assign
id|n_hdlc_tty_wakeup
suffix:semicolon
id|status
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_HDLC
comma
op_amp
id|n_hdlc_ldisc
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;N_HDLC line discipline registered.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
id|KERN_ERR
l_string|&quot;error registering line discipline: %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;N_HDLC: init failure %d&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* end of init_module() */
DECL|function|n_hdlc_exit
r_static
r_void
id|__exit
id|n_hdlc_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
multiline_comment|/* Release tty registration of line discipline */
r_if
c_cond
(paren
(paren
id|status
op_assign
id|tty_register_ldisc
c_func
(paren
id|N_HDLC
comma
l_int|NULL
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;N_HDLC: can&squot;t unregister line discipline (err = %d)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;N_HDLC: line discipline unregistered&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|n_hdlc_init
id|module_init
c_func
(paren
id|n_hdlc_init
)paren
suffix:semicolon
DECL|variable|n_hdlc_exit
id|module_exit
c_func
(paren
id|n_hdlc_exit
)paren
suffix:semicolon
eof
