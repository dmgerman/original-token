multiline_comment|/*&n; *  generic_serial.c&n; *&n; *  Copyright (C) 1998/1999 R.E.Wolff@BitWizard.nl&n; *&n; *  written for the SX serial driver.&n; *     Contains the code that should be shared over all the serial drivers.&n; *&n; *  Credit for the idea to do it this way might go to Alan Cox. &n; *&n; *&n; *  Version 0.1 -- December, 1998. Initial version.&n; *  Version 0.2 -- March, 1999.    Some more routines. Bugfixes. Etc.&n; *  Version 0.5 -- August, 1999.   Some more fixes. Reformat for Linus.&n; *&n; *  BitWizard is actively maintaining this file. We sometimes find&n; *  that someone submitted changes to this file. We really appreciate&n; *  your help, but please submit changes through us. We&squot;re doing our&n; *  best to be responsive.  -- REW&n; * */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/generic_serial.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|DEBUG
mdefine_line|#define DEBUG 
DECL|variable|tmp_buf
r_static
r_char
op_star
id|tmp_buf
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|tmp_buf_sem
)paren
suffix:semicolon
DECL|variable|gs_debug
r_static
r_int
id|gs_debug
suffix:semicolon
macro_line|#ifdef DEBUG
DECL|macro|gs_dprintk
mdefine_line|#define gs_dprintk(f, str...) if (gs_debug &amp; f) printk (str)
macro_line|#else
DECL|macro|gs_dprintk
mdefine_line|#define gs_dprintk(f, str...) /* nothing */
macro_line|#endif
DECL|macro|func_enter
mdefine_line|#define func_enter() gs_dprintk (GS_DEBUG_FLOW, &quot;gs: enter &quot; __FUNCTION__ &quot;&bslash;n&quot;)
DECL|macro|func_exit
mdefine_line|#define func_exit()  gs_dprintk (GS_DEBUG_FLOW, &quot;gs: exit  &quot; __FUNCTION__ &quot;&bslash;n&quot;)
macro_line|#if NEW_WRITE_LOCKING
DECL|macro|DECL
mdefine_line|#define DECL      /* Nothing */
DECL|macro|LOCKIT
mdefine_line|#define LOCKIT    down (&amp; port-&gt;port_write_sem);
DECL|macro|RELEASEIT
mdefine_line|#define RELEASEIT up (&amp;port-&gt;port_write_sem);
macro_line|#else
DECL|macro|DECL
mdefine_line|#define DECL      unsigned long flags;
DECL|macro|LOCKIT
mdefine_line|#define LOCKIT    save_flags (flags);cli ()
DECL|macro|RELEASEIT
mdefine_line|#define RELEASEIT restore_flags (flags)
macro_line|#endif
DECL|macro|RS_EVENT_WRITE_WAKEUP
mdefine_line|#define RS_EVENT_WRITE_WAKEUP&t;1
id|MODULE_PARM
c_func
(paren
id|gs_debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|function|gs_put_char
r_void
id|gs_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
id|DECL
id|func_enter
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|port-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Take a lock on the serial tranmit buffer! */
id|LOCKIT
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;xmit_cnt
op_ge
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
(brace
multiline_comment|/* Sorry, buffer is full, drop character. Update statistics???? -- REW */
id|RELEASEIT
suffix:semicolon
r_return
suffix:semicolon
)brace
id|port-&gt;xmit_buf
(braket
id|port-&gt;xmit_head
op_increment
)braket
op_assign
id|ch
suffix:semicolon
id|port-&gt;xmit_head
op_and_assign
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
suffix:semicolon
id|port-&gt;xmit_cnt
op_increment
suffix:semicolon
multiline_comment|/* Characters in buffer */
id|RELEASEIT
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef NEW_WRITE_LOCKING
multiline_comment|/*&n;&gt; Problems to take into account are:&n;&gt;       -1- Interrupts that empty part of the buffer.&n;&gt;       -2- page faults on the access to userspace. &n;&gt;       -3- Other processes that are also trying to do a &quot;write&quot;. &n;*/
DECL|function|gs_write
r_int
id|gs_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
r_int
id|c
comma
id|total
op_assign
l_int|0
suffix:semicolon
r_int
id|t
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
l_int|0
suffix:semicolon
id|port
op_assign
id|tty-&gt;driver
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|port-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* get exclusive &quot;write&quot; access to this port (problem 3) */
multiline_comment|/* This is not a spinlock because we can have a disk access (page &n;&t;&t; fault) in copy_from_user */
id|down
(paren
op_amp
id|port-&gt;port_write_sem
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|c
op_assign
id|count
suffix:semicolon
multiline_comment|/* This is safe because we &quot;OWN&quot; the &quot;head&quot;. Noone else can &n;&t;&t;   change the &quot;head&quot;: we own the port_write_sem. */
multiline_comment|/* Don&squot;t overrun the end of the buffer */
id|t
op_assign
id|SERIAL_XMIT_SIZE
op_minus
id|port-&gt;xmit_head
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
id|c
)paren
id|c
op_assign
id|t
suffix:semicolon
multiline_comment|/* This is safe because the xmit_cnt can only decrease. This &n;&t;&t;   would increase &quot;t&quot;, so we might copy too little chars. */
multiline_comment|/* Don&squot;t copy past the &quot;head&quot; of the buffer */
id|t
op_assign
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
op_minus
id|port-&gt;xmit_cnt
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
id|c
)paren
id|c
op_assign
id|t
suffix:semicolon
multiline_comment|/* Can&squot;t copy more? break out! */
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
id|copy_from_user
(paren
id|port-&gt;xmit_buf
op_plus
id|port-&gt;xmit_head
comma
id|buf
comma
id|c
)paren
suffix:semicolon
r_else
id|memcpy
(paren
id|port-&gt;xmit_buf
op_plus
id|port-&gt;xmit_head
comma
id|buf
comma
id|c
)paren
suffix:semicolon
id|port
op_member_access_from_pointer
id|xmit_cnt
op_add_assign
id|c
suffix:semicolon
id|port
op_member_access_from_pointer
id|xmit_head
op_assign
(paren
id|port-&gt;xmit_head
op_plus
id|c
)paren
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|buf
op_add_assign
id|c
suffix:semicolon
id|count
op_sub_assign
id|c
suffix:semicolon
id|total
op_add_assign
id|c
suffix:semicolon
)brace
id|up
(paren
op_amp
id|port-&gt;port_write_sem
)paren
suffix:semicolon
id|gs_dprintk
(paren
id|GS_DEBUG_WRITE
comma
l_string|&quot;write: interrupts are %s&bslash;n&quot;
comma
(paren
id|port-&gt;flags
op_amp
id|GS_TX_INTEN
)paren
ques
c_cond
l_string|&quot;enabled&quot;
suffix:colon
l_string|&quot;disabled&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;xmit_cnt
op_logical_and
op_logical_neg
id|tty-&gt;stopped
op_logical_and
op_logical_neg
id|tty-&gt;hw_stopped
op_logical_and
op_logical_neg
(paren
id|port-&gt;flags
op_amp
id|GS_TX_INTEN
)paren
)paren
(brace
id|port-&gt;flags
op_or_assign
id|GS_TX_INTEN
suffix:semicolon
id|port-&gt;rd-&gt;enable_tx_interrupts
(paren
id|port
)paren
suffix:semicolon
)brace
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|total
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*&n;&gt; Problems to take into account are:&n;&gt;       -1- Interrupts that empty part of the buffer.&n;&gt;       -2- page faults on the access to userspace. &n;&gt;       -3- Other processes that are also trying to do a &quot;write&quot;. &n;*/
DECL|function|gs_write
r_int
id|gs_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
r_int
id|c
comma
id|total
op_assign
l_int|0
suffix:semicolon
r_int
id|t
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
multiline_comment|/* The standard serial driver returns 0 in this case. &n;&t;   That sounds to me as &quot;No error, I just didn&squot;t get to writing any&n;&t;   bytes. Feel free to try again.&quot; &n;&t;   The &quot;official&quot; way to write n bytes from buf is:&n;&n;&t;&t; for (nwritten = 0;nwritten &lt; n;nwritten += rv) {&n;&t;&t;&t; rv = write (fd, buf+nwritten, n-nwritten);&n;&t;&t;&t; if (rv &lt; 0) break; // Error: bail out. //&n;&t;&t; } &n;&n;&t;   which will loop endlessly in this case. The manual page for write&n;&t;   agrees with me. In practise almost everybody writes &n;&t;   &quot;write (fd, buf,n);&quot; but some people might have had to deal with &n;&t;   incomplete writes in the past and correctly implemented it by now... &n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
op_logical_or
op_logical_neg
id|port-&gt;xmit_buf
op_logical_or
op_logical_neg
id|tmp_buf
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
(brace
id|down
c_func
(paren
op_amp
id|tmp_buf_sem
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|c
op_assign
id|count
suffix:semicolon
multiline_comment|/* This is safe because we &quot;OWN&quot; the &quot;head&quot;. Noone else can &n;&t;&t;&t;   change the &quot;head&quot;: we own the port_write_sem. */
multiline_comment|/* Don&squot;t overrun the end of the buffer */
id|t
op_assign
id|SERIAL_XMIT_SIZE
op_minus
id|port-&gt;xmit_head
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
id|c
)paren
id|c
op_assign
id|t
suffix:semicolon
multiline_comment|/* This is safe because the xmit_cnt can only decrease. This &n;&t;&t;&t;   would increase &quot;t&quot;, so we might copy too little chars. */
multiline_comment|/* Don&squot;t copy past the &quot;head&quot; of the buffer */
id|t
op_assign
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
op_minus
id|port-&gt;xmit_cnt
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
id|c
)paren
id|c
op_assign
id|t
suffix:semicolon
multiline_comment|/* Can&squot;t copy more? break out! */
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|c
op_sub_assign
id|copy_from_user
c_func
(paren
id|tmp_buf
comma
id|buf
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|total
)paren
id|total
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|t
op_assign
id|SERIAL_XMIT_SIZE
op_minus
id|port-&gt;xmit_head
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
id|c
)paren
id|c
op_assign
id|t
suffix:semicolon
id|t
op_assign
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
op_minus
id|port-&gt;xmit_cnt
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
id|c
)paren
id|c
op_assign
id|t
suffix:semicolon
id|memcpy
c_func
(paren
id|port-&gt;xmit_buf
op_plus
id|port-&gt;xmit_head
comma
id|tmp_buf
comma
id|c
)paren
suffix:semicolon
id|port-&gt;xmit_head
op_assign
(paren
(paren
id|port-&gt;xmit_head
op_plus
id|c
)paren
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|port-&gt;xmit_cnt
op_add_assign
id|c
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|buf
op_add_assign
id|c
suffix:semicolon
id|count
op_sub_assign
id|c
suffix:semicolon
id|total
op_add_assign
id|c
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|tmp_buf_sem
)paren
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|c
op_assign
id|count
suffix:semicolon
multiline_comment|/* This is safe because we &quot;OWN&quot; the &quot;head&quot;. Noone else can &n;&t;&t;&t;   change the &quot;head&quot;: we own the port_write_sem. */
multiline_comment|/* Don&squot;t overrun the end of the buffer */
id|t
op_assign
id|SERIAL_XMIT_SIZE
op_minus
id|port-&gt;xmit_head
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
id|c
)paren
id|c
op_assign
id|t
suffix:semicolon
multiline_comment|/* This is safe because the xmit_cnt can only decrease. This &n;&t;&t;&t;   would increase &quot;t&quot;, so we might copy too little chars. */
multiline_comment|/* Don&squot;t copy past the &quot;head&quot; of the buffer */
id|t
op_assign
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
op_minus
id|port-&gt;xmit_cnt
suffix:semicolon
r_if
c_cond
(paren
id|t
OL
id|c
)paren
id|c
op_assign
id|t
suffix:semicolon
multiline_comment|/* Can&squot;t copy more? break out! */
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|port-&gt;xmit_buf
op_plus
id|port-&gt;xmit_head
comma
id|buf
comma
id|c
)paren
suffix:semicolon
id|port-&gt;xmit_head
op_assign
(paren
(paren
id|port-&gt;xmit_head
op_plus
id|c
)paren
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|port-&gt;xmit_cnt
op_add_assign
id|c
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|buf
op_add_assign
id|c
suffix:semicolon
id|count
op_sub_assign
id|c
suffix:semicolon
id|total
op_add_assign
id|c
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|port-&gt;xmit_cnt
op_logical_and
op_logical_neg
id|tty-&gt;stopped
op_logical_and
op_logical_neg
id|tty-&gt;hw_stopped
op_logical_and
op_logical_neg
(paren
id|port-&gt;flags
op_amp
id|GS_TX_INTEN
)paren
)paren
(brace
id|port-&gt;flags
op_or_assign
id|GS_TX_INTEN
suffix:semicolon
id|port-&gt;rd-&gt;enable_tx_interrupts
(paren
id|port
)paren
suffix:semicolon
)brace
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|total
suffix:semicolon
)brace
macro_line|#endif
DECL|function|gs_write_room
r_int
id|gs_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|gs_port
op_star
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
id|ret
op_assign
id|SERIAL_XMIT_SIZE
op_minus
id|port-&gt;xmit_cnt
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|gs_chars_in_buffer
r_int
id|gs_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|gs_port
op_star
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|port-&gt;xmit_cnt
suffix:semicolon
)brace
DECL|function|gs_real_chars_in_buffer
r_int
id|gs_real_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
l_int|0
suffix:semicolon
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;rd
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;rd-&gt;chars_in_buffer
)paren
r_return
l_int|0
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|port-&gt;xmit_cnt
op_plus
id|port-&gt;rd-&gt;chars_in_buffer
(paren
id|port
)paren
suffix:semicolon
)brace
DECL|function|gs_wait_tx_flushed
r_static
r_int
id|gs_wait_tx_flushed
(paren
r_void
op_star
id|ptr
comma
r_int
id|timeout
)paren
(brace
r_struct
id|gs_port
op_star
id|port
op_assign
id|ptr
suffix:semicolon
r_int
id|end_jiffies
suffix:semicolon
r_int
id|jiffies_to_transmit
comma
id|charsleft
op_assign
l_int|0
comma
id|rv
op_assign
l_int|0
suffix:semicolon
r_int
id|to
comma
id|rcib
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|gs_dprintk
(paren
id|GS_DEBUG_FLUSH
comma
l_string|&quot;port=%p.&bslash;n&quot;
comma
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port
)paren
(brace
id|gs_dprintk
(paren
id|GS_DEBUG_FLUSH
comma
l_string|&quot;xmit_cnt=%x, xmit_buf=%p, tty=%p.&bslash;n&quot;
comma
id|port-&gt;xmit_cnt
comma
id|port-&gt;xmit_buf
comma
id|port-&gt;tty
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|port
op_logical_or
id|port-&gt;xmit_cnt
OL
l_int|0
op_logical_or
op_logical_neg
id|port-&gt;xmit_buf
)paren
(brace
id|gs_dprintk
(paren
id|GS_DEBUG_FLUSH
comma
l_string|&quot;ERROR: !port, !port-&gt;xmit_buf or prot-&gt;xmit_cnt &lt; 0.&bslash;n&quot;
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* This is an error which we don&squot;t know how to handle. */
)brace
id|rcib
op_assign
id|gs_real_chars_in_buffer
c_func
(paren
id|port-&gt;tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rcib
op_le
l_int|0
)paren
(brace
id|gs_dprintk
(paren
id|GS_DEBUG_FLUSH
comma
l_string|&quot;nothing to wait for.&bslash;n&quot;
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* stop trying: now + twice the time it would normally take +  seconds */
id|end_jiffies
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_ne
id|MAX_SCHEDULE_TIMEOUT
)paren
id|end_jiffies
op_add_assign
id|port-&gt;baud
ques
c_cond
(paren
l_int|2
op_star
id|rcib
op_star
l_int|10
op_star
id|HZ
op_div
id|port-&gt;baud
)paren
suffix:colon
l_int|0
suffix:semicolon
id|end_jiffies
op_add_assign
id|timeout
suffix:semicolon
id|gs_dprintk
(paren
id|GS_DEBUG_FLUSH
comma
l_string|&quot;now=%lx, end=%lx (%ld).&bslash;n&quot;
comma
id|jiffies
comma
id|end_jiffies
comma
id|end_jiffies
op_minus
id|jiffies
)paren
suffix:semicolon
id|to
op_assign
l_int|100
suffix:semicolon
multiline_comment|/* the expression is actually jiffies &lt; end_jiffies, but that won&squot;t&n;&t;   work around the wraparound. Tricky eh? */
r_while
c_loop
(paren
id|to
op_decrement
op_logical_and
(paren
id|charsleft
op_assign
id|gs_real_chars_in_buffer
(paren
id|port-&gt;tty
)paren
)paren
op_logical_and
id|time_after
(paren
id|end_jiffies
comma
id|jiffies
)paren
)paren
(brace
multiline_comment|/* Units check: &n;&t;&t;   chars * (bits/char) * (jiffies /sec) / (bits/sec) = jiffies!&n;&t;&t;   check! */
id|charsleft
op_add_assign
l_int|16
suffix:semicolon
multiline_comment|/* Allow 16 chars more to be transmitted ... */
id|jiffies_to_transmit
op_assign
id|port-&gt;baud
ques
c_cond
(paren
l_int|1
op_plus
id|charsleft
op_star
l_int|10
op_star
id|HZ
op_div
id|port-&gt;baud
)paren
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*                                ^^^ Round up.... */
r_if
c_cond
(paren
id|jiffies_to_transmit
op_le
l_int|0
)paren
id|jiffies_to_transmit
op_assign
l_int|1
suffix:semicolon
id|gs_dprintk
(paren
id|GS_DEBUG_FLUSH
comma
l_string|&quot;Expect to finish in %d jiffies &quot;
l_string|&quot;(%d chars).&bslash;n&quot;
comma
id|jiffies_to_transmit
comma
id|charsleft
)paren
suffix:semicolon
id|set_current_state
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|jiffies_to_transmit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
(brace
id|gs_dprintk
(paren
id|GS_DEBUG_FLUSH
comma
l_string|&quot;Signal pending. Bombing out: &quot;
)paren
suffix:semicolon
id|rv
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|gs_dprintk
(paren
id|GS_DEBUG_FLUSH
comma
l_string|&quot;charsleft = %d.&bslash;n&quot;
comma
id|charsleft
)paren
suffix:semicolon
id|set_current_state
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|gs_flush_buffer
r_void
id|gs_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
multiline_comment|/* XXX Would the write semaphore do? */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|port-&gt;xmit_cnt
op_assign
id|port-&gt;xmit_head
op_assign
id|port-&gt;xmit_tail
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|function|gs_flush_chars
r_void
id|gs_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;xmit_cnt
op_le
l_int|0
op_logical_or
id|tty-&gt;stopped
op_logical_or
id|tty-&gt;hw_stopped
op_logical_or
op_logical_neg
id|port-&gt;xmit_buf
)paren
(brace
id|func_exit
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Beats me -- REW */
id|port-&gt;flags
op_or_assign
id|GS_TX_INTEN
suffix:semicolon
id|port-&gt;rd-&gt;enable_tx_interrupts
(paren
id|port
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|function|gs_stop
r_void
id|gs_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;xmit_cnt
op_logical_and
id|port-&gt;xmit_buf
op_logical_and
(paren
id|port-&gt;flags
op_amp
id|GS_TX_INTEN
)paren
)paren
(brace
id|port-&gt;flags
op_and_assign
op_complement
id|GS_TX_INTEN
suffix:semicolon
id|port-&gt;rd-&gt;disable_tx_interrupts
(paren
id|port
)paren
suffix:semicolon
)brace
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|function|gs_start
r_void
id|gs_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;xmit_cnt
op_logical_and
id|port-&gt;xmit_buf
op_logical_and
op_logical_neg
(paren
id|port-&gt;flags
op_amp
id|GS_TX_INTEN
)paren
)paren
(brace
id|port-&gt;flags
op_or_assign
id|GS_TX_INTEN
suffix:semicolon
id|port-&gt;rd-&gt;enable_tx_interrupts
(paren
id|port
)paren
suffix:semicolon
)brace
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|function|gs_shutdown_port
r_void
id|gs_shutdown_port
(paren
r_struct
id|gs_port
op_star
id|port
)paren
(brace
r_int
id|flags
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|port-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
r_return
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;xmit_buf
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|port-&gt;xmit_buf
)paren
suffix:semicolon
id|port-&gt;xmit_buf
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;tty
)paren
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|port-&gt;tty-&gt;flags
)paren
suffix:semicolon
id|port-&gt;rd-&gt;shutdown_port
(paren
id|port
)paren
suffix:semicolon
id|port-&gt;flags
op_and_assign
op_complement
id|ASYNC_INITIALIZED
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|gs_hangup
r_void
id|gs_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
id|tty
op_assign
id|port-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|gs_shutdown_port
(paren
id|port
)paren
suffix:semicolon
id|port-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
op_or
id|GS_ACTIVE
)paren
suffix:semicolon
id|port-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|port-&gt;count
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|port-&gt;open_wait
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|function|gs_do_softint
r_void
id|gs_do_softint
c_func
(paren
r_void
op_star
id|private_
)paren
(brace
r_struct
id|gs_port
op_star
id|port
op_assign
id|private_
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
id|tty
op_assign
id|port-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|RS_EVENT_WRITE_WAKEUP
comma
op_amp
id|port-&gt;event
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|function|gs_block_til_ready
r_int
id|gs_block_til_ready
c_func
(paren
r_void
op_star
id|port_
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|gs_port
op_star
id|port
op_assign
id|port_
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|do_clocal
op_assign
l_int|0
suffix:semicolon
r_int
id|CD
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
l_int|0
suffix:semicolon
id|tty
op_assign
id|port-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
l_int|0
suffix:semicolon
id|gs_dprintk
(paren
id|GS_DEBUG_BTR
comma
l_string|&quot;Entering gs_block_till_ready.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If the device is in the middle of being closed, then block&n;&t; * until it&squot;s done, and then try again.&n;&t; */
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
id|port-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|port-&gt;close_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_else
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|gs_dprintk
(paren
id|GS_DEBUG_BTR
comma
l_string|&quot;after hung up&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this is a callout device, then just make sure the normal&n;&t; * device isn&squot;t being used.&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|GS_TYPE_CALLOUT
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|port-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|port-&gt;flags
op_amp
id|ASYNC_SESSION_LOCKOUT
)paren
op_logical_and
(paren
id|port-&gt;session
op_ne
id|current-&gt;session
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|port-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|port-&gt;flags
op_amp
id|ASYNC_PGRP_LOCKOUT
)paren
op_logical_and
(paren
id|port-&gt;pgrp
op_ne
id|current-&gt;pgrp
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|port-&gt;flags
op_or_assign
id|ASYNC_CALLOUT_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|gs_dprintk
(paren
id|GS_DEBUG_BTR
comma
l_string|&quot;after subtype&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If non-blocking mode is set, or the port is not enabled,&n;&t; * then make the check up front and then exit.&n;&t; */
r_if
c_cond
(paren
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
op_logical_or
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|port-&gt;flags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|gs_dprintk
(paren
id|GS_DEBUG_BTR
comma
l_string|&quot;after nonblock&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;normal_termios.c_cflag
op_amp
id|CLOCAL
)paren
id|do_clocal
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|C_CLOCAL
c_func
(paren
id|tty
)paren
)paren
id|do_clocal
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Block waiting for the carrier detect and the line to become&n;&t; * free (i.e., not in use by the callout).  While we are in&n;&t; * this loop, port-&gt;count is dropped by one, so that&n;&t; * rs_close() knows when to free things.  We restore it upon&n;&t; * exit, either normal or abnormal.&n;&t; */
id|retval
op_assign
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|port-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|gs_dprintk
(paren
id|GS_DEBUG_BTR
comma
l_string|&quot;after add waitq.&bslash;n&quot;
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
id|port-&gt;count
op_decrement
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|port-&gt;blocked_open
op_increment
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|CD
op_assign
id|port-&gt;rd-&gt;get_CD
(paren
id|port
)paren
suffix:semicolon
id|gs_dprintk
(paren
id|GS_DEBUG_BTR
comma
l_string|&quot;CD is now %d.&bslash;n&quot;
comma
id|CD
)paren
suffix:semicolon
id|set_current_state
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
op_logical_neg
(paren
id|port-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_else
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|port-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
op_logical_neg
(paren
id|port-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
op_logical_and
(paren
id|do_clocal
op_logical_or
id|CD
)paren
)paren
r_break
suffix:semicolon
id|gs_dprintk
(paren
id|GS_DEBUG_BTR
comma
l_string|&quot;signal_pending is now: %d (%lx)&bslash;n&quot;
comma
(paren
r_int
)paren
id|signal_pending
(paren
id|current
)paren
comma
op_star
(paren
r_int
op_star
)paren
(paren
op_amp
id|current-&gt;blocked
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|gs_dprintk
(paren
id|GS_DEBUG_BTR
comma
l_string|&quot;Got out of the loop. (%d)&bslash;n&quot;
comma
id|port-&gt;blocked_open
)paren
suffix:semicolon
id|set_current_state
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|port-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
id|port-&gt;count
op_increment
suffix:semicolon
id|port-&gt;blocked_open
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|port-&gt;flags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gs_close
r_void
id|gs_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|port
op_assign
(paren
r_struct
id|gs_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;tty
)paren
(brace
multiline_comment|/* This seems to happen when this is called from vhangup. */
id|gs_dprintk
(paren
id|GS_DEBUG_CLOSE
comma
l_string|&quot;gs: Odd: port-&gt;tty is NULL&bslash;n&quot;
)paren
suffix:semicolon
id|port-&gt;tty
op_assign
id|tty
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|port-&gt;rd-&gt;hungup
(paren
id|port
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tty-&gt;count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|port-&gt;count
op_ne
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs: gs_close: bad port count;&quot;
l_string|&quot; tty-&gt;count is 1, port count is %d&bslash;n&quot;
comma
id|port-&gt;count
)paren
suffix:semicolon
id|port-&gt;count
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|port-&gt;count
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;gs: gs_close: bad port count: %d&bslash;n&quot;
comma
id|port-&gt;count
)paren
suffix:semicolon
id|port-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;count
)paren
(brace
id|gs_dprintk
c_func
(paren
id|GS_DEBUG_CLOSE
comma
l_string|&quot;gs_close: count: %d&bslash;n&quot;
comma
id|port-&gt;count
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|port-&gt;flags
op_or_assign
id|ASYNC_CLOSING
suffix:semicolon
multiline_comment|/*&n;&t; * Save the termios structure, since this port may have&n;&t; * separate termios for callout and dialin.&n;&t; */
r_if
c_cond
(paren
id|port-&gt;flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
id|port-&gt;normal_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
id|port-&gt;callout_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
multiline_comment|/*&n;&t; * Now we wait for the transmit buffer to clear; and we notify &n;&t; * the line discipline to only process XON/XOFF characters.&n;&t; */
id|tty-&gt;closing
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* if (port-&gt;closing_wait != ASYNC_CLOSING_WAIT_NONE)&n;&t;   tty_wait_until_sent(tty, port-&gt;closing_wait); */
multiline_comment|/*&n;&t; * At this point we stop accepting input.  To do this, we&n;&t; * disable the receive line status interrupts, and tell the&n;&t; * interrupt driver to stop checking the data ready bit in the&n;&t; * line status register.&n;&t; */
id|port-&gt;rd-&gt;disable_rx_interrupts
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* close has no way of returning &quot;EINTR&quot;, so discard return value */
r_if
c_cond
(paren
id|port-&gt;closing_wait
op_ne
id|ASYNC_CLOSING_WAIT_NONE
)paren
id|gs_wait_tx_flushed
(paren
id|port
comma
id|port-&gt;closing_wait
)paren
suffix:semicolon
id|port-&gt;flags
op_and_assign
op_complement
id|GS_ACTIVE
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|0
suffix:semicolon
id|port-&gt;event
op_assign
l_int|0
suffix:semicolon
id|port-&gt;rd-&gt;close
(paren
id|port
)paren
suffix:semicolon
id|port-&gt;rd-&gt;shutdown_port
(paren
id|port
)paren
suffix:semicolon
id|port-&gt;tty
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;blocked_open
)paren
(brace
r_if
c_cond
(paren
id|port-&gt;close_delay
)paren
(brace
id|set_current_state
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|port-&gt;close_delay
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|port-&gt;open_wait
)paren
suffix:semicolon
)brace
id|port-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
op_or
id|ASYNC_CLOSING
op_or
id|ASYNC_INITIALIZED
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|port-&gt;close_wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|variable|gs_baudrates
r_static
r_int
r_int
id|gs_baudrates
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|50
comma
l_int|75
comma
l_int|110
comma
l_int|134
comma
l_int|150
comma
l_int|200
comma
l_int|300
comma
l_int|600
comma
l_int|1200
comma
l_int|1800
comma
l_int|2400
comma
l_int|4800
comma
l_int|9600
comma
l_int|19200
comma
l_int|38400
comma
l_int|57600
comma
l_int|115200
comma
l_int|230400
comma
l_int|460800
comma
l_int|921600
)brace
suffix:semicolon
DECL|function|gs_set_termios
r_void
id|gs_set_termios
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|gs_port
op_star
id|port
suffix:semicolon
r_int
id|baudrate
comma
id|tmp
comma
id|rv
suffix:semicolon
r_struct
id|termios
op_star
id|tiosp
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
r_return
suffix:semicolon
id|tiosp
op_assign
id|tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
id|gs_debug
op_amp
id|GS_DEBUG_TERMIOS
)paren
(brace
id|gs_dprintk
(paren
id|GS_DEBUG_TERMIOS
comma
l_string|&quot;termios structure (%p):&bslash;n&quot;
comma
id|tiosp
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* This is an optimization that is only allowed for dumb cards */
multiline_comment|/* Smart cards require knowledge of iflags and oflags too: that &n;&t;   might change hardware cooking mode.... */
macro_line|#endif
r_if
c_cond
(paren
id|old_termios
)paren
(brace
r_if
c_cond
(paren
(paren
id|tiosp-&gt;c_iflag
op_eq
id|old_termios-&gt;c_iflag
)paren
op_logical_and
(paren
id|tiosp-&gt;c_oflag
op_eq
id|old_termios-&gt;c_oflag
)paren
op_logical_and
(paren
id|tiosp-&gt;c_cflag
op_eq
id|old_termios-&gt;c_cflag
)paren
op_logical_and
(paren
id|tiosp-&gt;c_lflag
op_eq
id|old_termios-&gt;c_lflag
)paren
op_logical_and
(paren
id|tiosp-&gt;c_line
op_eq
id|old_termios-&gt;c_line
)paren
op_logical_and
(paren
id|memcmp
c_func
(paren
id|tiosp-&gt;c_cc
comma
id|old_termios-&gt;c_cc
comma
id|NCC
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|gs_dprintk
c_func
(paren
id|GS_DEBUG_TERMIOS
comma
l_string|&quot;gs_set_termios: optimized away&bslash;n&quot;
)paren
suffix:semicolon
r_return
multiline_comment|/* 0 */
suffix:semicolon
)brace
)brace
r_else
id|gs_dprintk
c_func
(paren
id|GS_DEBUG_TERMIOS
comma
l_string|&quot;gs_set_termios: no old_termios: &quot;
l_string|&quot;no optimization&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_termios
op_logical_and
(paren
id|gs_debug
op_amp
id|GS_DEBUG_TERMIOS
)paren
)paren
(brace
r_if
c_cond
(paren
id|tiosp-&gt;c_iflag
op_ne
id|old_termios-&gt;c_iflag
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;c_iflag changed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tiosp-&gt;c_oflag
op_ne
id|old_termios-&gt;c_oflag
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;c_oflag changed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tiosp-&gt;c_cflag
op_ne
id|old_termios-&gt;c_cflag
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;c_cflag changed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tiosp-&gt;c_lflag
op_ne
id|old_termios-&gt;c_lflag
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;c_lflag changed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tiosp-&gt;c_line
op_ne
id|old_termios-&gt;c_line
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;c_line changed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|memcmp
c_func
(paren
id|tiosp-&gt;c_cc
comma
id|old_termios-&gt;c_cc
comma
id|NCC
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;c_cc changed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
id|baudrate
op_assign
id|tiosp-&gt;c_cflag
op_amp
id|CBAUD
suffix:semicolon
r_if
c_cond
(paren
id|baudrate
op_amp
id|CBAUDEX
)paren
(brace
id|baudrate
op_and_assign
op_complement
id|CBAUDEX
suffix:semicolon
r_if
c_cond
(paren
(paren
id|baudrate
OL
l_int|1
)paren
op_logical_or
(paren
id|baudrate
OG
l_int|4
)paren
)paren
id|tiosp-&gt;c_cflag
op_and_assign
op_complement
id|CBAUDEX
suffix:semicolon
r_else
id|baudrate
op_add_assign
l_int|15
suffix:semicolon
)brace
id|baudrate
op_assign
id|gs_baudrates
(braket
id|baudrate
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tiosp-&gt;c_cflag
op_amp
id|CBAUD
)paren
op_eq
id|B38400
)paren
(brace
r_if
c_cond
(paren
(paren
id|port-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_HI
)paren
id|baudrate
op_assign
l_int|57600
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|port-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_VHI
)paren
id|baudrate
op_assign
l_int|115200
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|port-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_SHI
)paren
id|baudrate
op_assign
l_int|230400
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|port-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_WARP
)paren
id|baudrate
op_assign
l_int|460800
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|port-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_CUST
)paren
id|baudrate
op_assign
(paren
id|port-&gt;baud_base
op_div
id|port-&gt;custom_divisor
)paren
suffix:semicolon
)brace
multiline_comment|/* I recommend using THIS instead of the mess in termios (and&n;&t;   duplicating the above code). Next we should create a clean&n;&t;   interface towards this variable. If your card supports arbitrary&n;&t;   baud rates, (e.g. CD1400 or 16550 based cards) then everything&n;&t;   will be very easy..... */
id|port-&gt;baud
op_assign
id|baudrate
suffix:semicolon
multiline_comment|/* Two timer ticks seems enough to wakeup something like SLIP driver */
multiline_comment|/* Baudrate/10 is cps. Divide by HZ to get chars per tick. */
id|tmp
op_assign
(paren
id|baudrate
op_div
l_int|10
op_div
id|HZ
)paren
op_star
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|0
)paren
id|tmp
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ge
id|SERIAL_XMIT_SIZE
)paren
id|tmp
op_assign
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
suffix:semicolon
id|port-&gt;wakeup_chars
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* We should really wait for the characters to be all sent before&n;&t;   changing the settings. -- CAL */
id|rv
op_assign
id|gs_wait_tx_flushed
(paren
id|port
comma
id|MAX_SCHEDULE_TIMEOUT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
OL
l_int|0
)paren
r_return
multiline_comment|/* rv */
suffix:semicolon
id|rv
op_assign
id|port-&gt;rd
op_member_access_from_pointer
id|set_real_termios
c_func
(paren
id|port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rv
OL
l_int|0
)paren
r_return
multiline_comment|/* rv */
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|old_termios
op_logical_or
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|tiosp-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
)paren
(brace
id|tty-&gt;stopped
op_assign
l_int|0
suffix:semicolon
id|gs_start
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
macro_line|#ifdef tytso_patch_94Nov25_1726
multiline_comment|/* This &quot;makes sense&quot;, Why is it commented out? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
op_logical_and
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
macro_line|#endif
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
multiline_comment|/* 0 */
suffix:semicolon
)brace
multiline_comment|/* Must be called with interrupts enabled */
DECL|function|gs_init_port
r_int
id|gs_init_port
c_func
(paren
r_struct
id|gs_port
op_star
id|port
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_buf
)paren
(brace
id|page
op_assign
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t expect this to make a difference. */
r_if
c_cond
(paren
id|tmp_buf
)paren
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_else
id|tmp_buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|page
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_buf
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|port-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;xmit_buf
)paren
(brace
multiline_comment|/* We may sleep in get_free_page() */
r_int
r_int
id|tmp
suffix:semicolon
id|tmp
op_assign
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* Spinlock? */
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;xmit_buf
)paren
id|free_page
(paren
id|tmp
)paren
suffix:semicolon
r_else
id|port-&gt;xmit_buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|tmp
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;xmit_buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;tty
)paren
id|clear_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|port-&gt;tty-&gt;flags
)paren
suffix:semicolon
id|port-&gt;xmit_cnt
op_assign
id|port-&gt;xmit_head
op_assign
id|port-&gt;xmit_tail
op_assign
l_int|0
suffix:semicolon
id|gs_set_termios
c_func
(paren
id|port-&gt;tty
comma
l_int|NULL
)paren
suffix:semicolon
id|port-&gt;flags
op_or_assign
id|ASYNC_INITIALIZED
suffix:semicolon
id|port-&gt;flags
op_and_assign
op_complement
id|GS_TX_INTEN
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|gs_setserial
r_int
id|gs_setserial
c_func
(paren
r_struct
id|gs_port
op_star
id|port
comma
r_struct
id|serial_struct
op_star
id|sp
)paren
(brace
r_struct
id|serial_struct
id|sio
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|sio
comma
id|sp
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|sio.baud_base
op_ne
id|port-&gt;baud_base
)paren
op_logical_or
(paren
id|sio.close_delay
op_ne
id|port-&gt;close_delay
)paren
op_logical_or
(paren
(paren
id|sio.flags
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
op_ne
(paren
id|port-&gt;flags
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|port-&gt;flags
op_assign
(paren
id|port-&gt;flags
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
op_or
(paren
id|sio.flags
op_amp
id|ASYNC_USR_MASK
)paren
suffix:semicolon
id|port-&gt;baud_base
op_assign
id|sio.baud_base
suffix:semicolon
id|port-&gt;close_delay
op_assign
id|sio.close_delay
suffix:semicolon
id|port-&gt;closing_wait
op_assign
id|sio.closing_wait
suffix:semicolon
id|port-&gt;custom_divisor
op_assign
id|sio.custom_divisor
suffix:semicolon
id|gs_set_termios
(paren
id|port-&gt;tty
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *      Generate the serial struct info.&n; */
DECL|function|gs_getserial
r_void
id|gs_getserial
c_func
(paren
r_struct
id|gs_port
op_star
id|port
comma
r_struct
id|serial_struct
op_star
id|sp
)paren
(brace
r_struct
id|serial_struct
id|sio
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|sio
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
suffix:semicolon
id|sio.flags
op_assign
id|port-&gt;flags
suffix:semicolon
id|sio.baud_base
op_assign
id|port-&gt;baud_base
suffix:semicolon
id|sio.close_delay
op_assign
id|port-&gt;close_delay
suffix:semicolon
id|sio.closing_wait
op_assign
id|port-&gt;closing_wait
suffix:semicolon
id|sio.custom_divisor
op_assign
id|port-&gt;custom_divisor
suffix:semicolon
id|sio.hub6
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If you want you can override these. */
id|sio.type
op_assign
id|PORT_UNKNOWN
suffix:semicolon
id|sio.xmit_fifo_size
op_assign
op_minus
l_int|1
suffix:semicolon
id|sio.line
op_assign
op_minus
l_int|1
suffix:semicolon
id|sio.port
op_assign
op_minus
l_int|1
suffix:semicolon
id|sio.irq
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;rd-&gt;getserial
)paren
id|port-&gt;rd-&gt;getserial
(paren
id|port
comma
op_amp
id|sio
)paren
suffix:semicolon
id|copy_to_user
c_func
(paren
id|sp
comma
op_amp
id|sio
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
suffix:semicolon
)brace
DECL|variable|gs_put_char
id|EXPORT_SYMBOL
c_func
(paren
id|gs_put_char
)paren
suffix:semicolon
DECL|variable|gs_write
id|EXPORT_SYMBOL
c_func
(paren
id|gs_write
)paren
suffix:semicolon
DECL|variable|gs_write_room
id|EXPORT_SYMBOL
c_func
(paren
id|gs_write_room
)paren
suffix:semicolon
DECL|variable|gs_chars_in_buffer
id|EXPORT_SYMBOL
c_func
(paren
id|gs_chars_in_buffer
)paren
suffix:semicolon
DECL|variable|gs_flush_buffer
id|EXPORT_SYMBOL
c_func
(paren
id|gs_flush_buffer
)paren
suffix:semicolon
DECL|variable|gs_flush_chars
id|EXPORT_SYMBOL
c_func
(paren
id|gs_flush_chars
)paren
suffix:semicolon
DECL|variable|gs_stop
id|EXPORT_SYMBOL
c_func
(paren
id|gs_stop
)paren
suffix:semicolon
DECL|variable|gs_start
id|EXPORT_SYMBOL
c_func
(paren
id|gs_start
)paren
suffix:semicolon
DECL|variable|gs_hangup
id|EXPORT_SYMBOL
c_func
(paren
id|gs_hangup
)paren
suffix:semicolon
DECL|variable|gs_do_softint
id|EXPORT_SYMBOL
c_func
(paren
id|gs_do_softint
)paren
suffix:semicolon
DECL|variable|gs_block_til_ready
id|EXPORT_SYMBOL
c_func
(paren
id|gs_block_til_ready
)paren
suffix:semicolon
DECL|variable|gs_close
id|EXPORT_SYMBOL
c_func
(paren
id|gs_close
)paren
suffix:semicolon
DECL|variable|gs_set_termios
id|EXPORT_SYMBOL
c_func
(paren
id|gs_set_termios
)paren
suffix:semicolon
DECL|variable|gs_init_port
id|EXPORT_SYMBOL
c_func
(paren
id|gs_init_port
)paren
suffix:semicolon
DECL|variable|gs_setserial
id|EXPORT_SYMBOL
c_func
(paren
id|gs_setserial
)paren
suffix:semicolon
DECL|variable|gs_getserial
id|EXPORT_SYMBOL
c_func
(paren
id|gs_getserial
)paren
suffix:semicolon
eof
