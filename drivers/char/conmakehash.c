multiline_comment|/*&n; * conmakehash.c&n; *&n; * Create a pre-initialized kernel Unicode hash table&n; *&n; * Copyright (C) 1995 H. Peter Anvin&n; *&n; * This program may be freely copied under the terms of the GNU&n; * General Public License (GPL), version 2, or at your option&n; * any later version.&n; *&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;sysexits.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;ctype.h&gt;
DECL|typedef|unicode
r_typedef
r_int
r_int
id|unicode
suffix:semicolon
DECL|struct|unipair
r_struct
id|unipair
(brace
DECL|member|glyph
r_int
r_int
id|glyph
suffix:semicolon
multiline_comment|/* Glyph code */
DECL|member|uc
id|unicode
id|uc
suffix:semicolon
multiline_comment|/* Unicode listed */
)brace
suffix:semicolon
DECL|function|usage
r_void
id|usage
c_func
(paren
r_char
op_star
id|argv0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Usage: &bslash;n&quot;
l_string|&quot;        %s chartable [hashsize] [hashstep] [maxhashlevel]&bslash;n&quot;
comma
id|argv0
)paren
suffix:semicolon
m_exit
(paren
id|EX_USAGE
)paren
suffix:semicolon
)brace
DECL|function|getunicode
r_int
id|getunicode
c_func
(paren
r_char
op_star
op_star
id|p0
)paren
(brace
r_char
op_star
id|p
op_assign
op_star
id|p0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;U&squot;
op_logical_or
id|p
(braket
l_int|1
)braket
op_ne
l_char|&squot;+&squot;
op_logical_or
op_logical_neg
id|isxdigit
c_func
(paren
id|p
(braket
l_int|2
)braket
)paren
op_logical_or
op_logical_neg
id|isxdigit
c_func
(paren
id|p
(braket
l_int|3
)braket
)paren
op_logical_or
op_logical_neg
id|isxdigit
c_func
(paren
id|p
(braket
l_int|4
)braket
)paren
op_logical_or
op_logical_neg
id|isxdigit
c_func
(paren
id|p
(braket
l_int|5
)braket
)paren
op_logical_or
id|isxdigit
c_func
(paren
id|p
(braket
l_int|6
)braket
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
op_star
id|p0
op_assign
id|p
op_plus
l_int|6
suffix:semicolon
r_return
id|strtol
c_func
(paren
id|p
op_plus
l_int|2
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
)brace
DECL|variable|hashtable
r_struct
id|unipair
op_star
id|hashtable
suffix:semicolon
DECL|variable|hashsize
r_int
id|hashsize
op_assign
l_int|641
suffix:semicolon
multiline_comment|/* Size of hash table */
DECL|variable|hashstep
r_int
id|hashstep
op_assign
l_int|189
suffix:semicolon
multiline_comment|/* Hash stepping */
DECL|variable|maxhashlevel
r_int
id|maxhashlevel
op_assign
l_int|6
suffix:semicolon
multiline_comment|/* Maximum hash depth */
DECL|variable|hashlevel
r_int
id|hashlevel
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Actual hash depth */
DECL|function|addpair
r_void
id|addpair
c_func
(paren
r_int
id|fp
comma
r_int
id|un
)paren
(brace
r_int
id|i
comma
id|lct
suffix:semicolon
id|unicode
id|hu
suffix:semicolon
r_if
c_cond
(paren
id|un
op_le
l_int|0xFFFE
)paren
(brace
multiline_comment|/* Add to hash table */
id|i
op_assign
id|un
op_mod
id|hashsize
suffix:semicolon
id|lct
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
id|hu
op_assign
id|hashtable
(braket
id|i
)braket
dot
id|uc
)paren
op_ne
l_int|0xffff
op_logical_and
id|hu
op_ne
id|un
)paren
(brace
r_if
c_cond
(paren
id|lct
op_increment
op_ge
id|maxhashlevel
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;ERROR: Hash table overflow&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
id|i
op_add_assign
id|hashstep
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|hashsize
)paren
id|i
op_sub_assign
id|hashsize
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lct
OG
id|hashlevel
)paren
id|hashlevel
op_assign
id|lct
suffix:semicolon
id|hashtable
(braket
id|i
)braket
dot
id|uc
op_assign
id|un
suffix:semicolon
id|hashtable
(braket
id|i
)braket
dot
id|glyph
op_assign
id|fp
suffix:semicolon
)brace
multiline_comment|/* otherwise: ignore */
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
id|FILE
op_star
id|ctbl
suffix:semicolon
r_char
op_star
id|tblname
suffix:semicolon
r_char
id|buffer
(braket
l_int|65536
)braket
suffix:semicolon
r_int
id|fontlen
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|fp0
comma
id|fp1
comma
id|un0
comma
id|un1
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|p1
suffix:semicolon
r_if
c_cond
(paren
id|argc
template_param
l_int|5
)paren
id|usage
c_func
(paren
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-&quot;
)paren
)paren
(brace
id|ctbl
op_assign
id|stdin
suffix:semicolon
id|tblname
op_assign
l_string|&quot;stdin&quot;
suffix:semicolon
)brace
r_else
(brace
id|ctbl
op_assign
id|fopen
c_func
(paren
id|tblname
op_assign
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctbl
)paren
(brace
id|perror
c_func
(paren
id|tblname
)paren
suffix:semicolon
m_exit
(paren
id|EX_NOINPUT
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|argc
OG
l_int|2
)paren
(brace
id|hashsize
op_assign
id|atoi
c_func
(paren
id|argv
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hashsize
template_param
l_int|2048
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Illegal hash size&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
id|EX_USAGE
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|argc
OG
l_int|3
)paren
(brace
id|hashstep
op_assign
id|atoi
c_func
(paren
id|argv
(braket
l_int|3
)braket
)paren
op_mod
id|hashsize
suffix:semicolon
r_if
c_cond
(paren
id|hashstep
OL
l_int|0
)paren
id|hashstep
op_add_assign
id|hashsize
suffix:semicolon
r_if
c_cond
(paren
id|hashstep
OL
l_int|16
op_logical_or
id|hashstep
op_ge
id|hashsize
op_minus
l_int|16
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Bad hash step&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
id|EX_USAGE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Warn the user in case the hashstep and hashsize are not relatively&n;     prime -- this algorithm could be massively improved */
r_for
c_loop
(paren
id|i
op_assign
id|hashstep
suffix:semicolon
id|i
OG
l_int|1
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|hashstep
op_mod
id|i
op_eq
l_int|0
op_logical_and
id|hashsize
op_mod
id|i
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Found GCD */
)brace
r_if
c_cond
(paren
id|i
OG
l_int|1
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;WARNING: hashsize and hashstep have common factors (gcd = %d)&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argc
OG
l_int|4
)paren
(brace
id|maxhashlevel
op_assign
id|atoi
c_func
(paren
id|argv
(braket
l_int|4
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|maxhashlevel
template_param
id|hashsize
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Illegal max hash level&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
id|EX_USAGE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* For now we assume the default font is always 256 characters */
id|fontlen
op_assign
l_int|256
suffix:semicolon
multiline_comment|/* Initialize hash table */
id|hashtable
op_assign
id|malloc
c_func
(paren
id|hashsize
op_star
r_sizeof
(paren
r_struct
id|unipair
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hashtable
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Could not allocate memory for hash table&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
id|EX_OSERR
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hashsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hashtable
(braket
id|i
)braket
dot
id|uc
op_assign
l_int|0xffff
suffix:semicolon
id|hashtable
(braket
id|i
)braket
dot
id|glyph
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Now we come to the tricky part.  Parse the input table. */
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
id|ctbl
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|strchr
c_func
(paren
id|buffer
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_star
id|p
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Warning: line too long&bslash;n&quot;
comma
id|tblname
)paren
suffix:semicolon
id|p
op_assign
id|buffer
suffix:semicolon
multiline_comment|/*&n; * Syntax accepted:&n; *&t;&lt;fontpos&gt;&t;&lt;unicode&gt; &lt;unicode&gt; ...&n; *&t;&lt;range&gt;&t;&t;idem&n; *&t;&lt;range&gt;&t;&t;&lt;unicode range&gt;&n; *&n; * where &lt;range&gt; ::= &lt;fontpos&gt;-&lt;fontpos&gt;&n; * and &lt;unicode&gt; ::= U+&lt;h&gt;&lt;h&gt;&lt;h&gt;&lt;h&gt;&n; * and &lt;h&gt; ::= &lt;hexadecimal digit&gt;&n; */
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|p
op_logical_or
op_star
id|p
op_eq
l_char|&squot;#&squot;
)paren
r_continue
suffix:semicolon
multiline_comment|/* skip comment or blank line */
id|fp0
op_assign
id|strtol
c_func
(paren
id|p
comma
op_amp
id|p1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p1
op_eq
id|p
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Bad input line: %s&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
id|p
op_assign
id|p1
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|p
op_increment
suffix:semicolon
id|fp1
op_assign
id|strtol
c_func
(paren
id|p
comma
op_amp
id|p1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p1
op_eq
id|p
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Bad input line: %s&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
id|p
op_assign
id|p1
suffix:semicolon
)brace
r_else
id|fp1
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fp0
OL
l_int|0
op_logical_or
id|fp0
op_ge
id|fontlen
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Glyph number (0x%x) larger than font length&bslash;n&quot;
comma
id|tblname
comma
id|fp0
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fp1
op_logical_and
(paren
id|fp1
OL
id|fp0
op_logical_or
id|fp1
op_ge
id|fontlen
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Bad end of range (0x%x)&bslash;n&quot;
comma
id|tblname
comma
id|fp1
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fp1
)paren
(brace
multiline_comment|/* we have a range; expect the word &quot;idem&quot; or a Unicode range of the&n;&t;     same length */
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|p
comma
l_string|&quot;idem&quot;
comma
l_int|4
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|fp0
suffix:semicolon
id|i
op_le
id|fp1
suffix:semicolon
id|i
op_increment
)paren
id|addpair
c_func
(paren
id|i
comma
id|i
)paren
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|un0
op_assign
id|getunicode
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;-&squot;
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Corresponding to a range of font positions, there should be a Unicode range&bslash;n&quot;
comma
id|tblname
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
id|un1
op_assign
id|getunicode
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|un0
OL
l_int|0
op_logical_or
id|un1
OL
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Bad Unicode range corresponding to font position range 0x%x-0x%x&bslash;n&quot;
comma
id|tblname
comma
id|fp0
comma
id|fp1
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|un1
op_minus
id|un0
op_ne
id|fp1
op_minus
id|fp0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Unicode range U+%x-U+%x not of the same length as font position range 0x%x-0x%x&bslash;n&quot;
comma
id|tblname
comma
id|un0
comma
id|un1
comma
id|fp0
comma
id|fp1
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|fp0
suffix:semicolon
id|i
op_le
id|fp1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|addpair
c_func
(paren
id|i
comma
id|un0
op_minus
id|fp0
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* no range; expect a list of unicode values for a single font position */
r_while
c_loop
(paren
(paren
id|un0
op_assign
id|getunicode
c_func
(paren
op_amp
id|p
)paren
)paren
op_ge
l_int|0
)paren
id|addpair
c_func
(paren
id|fp0
comma
id|un0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_logical_and
op_star
id|p
op_ne
l_char|&squot;#&squot;
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: trailing junk (%s) ignored&bslash;n&quot;
comma
id|tblname
comma
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/* Okay, we hit EOF, now output hash table */
id|fclose
c_func
(paren
id|ctbl
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;&n;/*&bslash;n&bslash;&n; * uni_hash.tbl&bslash;n&bslash;&n; *&bslash;n&bslash;&n; * Do not edit this file; it was automatically generated by&bslash;n&bslash;&n; *&bslash;n&bslash;&n; * conmakehash %s %d %d %d &gt; uni_hash.tbl&bslash;n&bslash;&n; *&bslash;n&bslash;&n; */&bslash;n&bslash;&n;&bslash;n&bslash;&n;#include &lt;linux/kd.h&gt;&bslash;n&bslash;&n;&bslash;n&bslash;&n;#define HASHSIZE      %d&bslash;n&bslash;&n;#define HASHSTEP      %d&bslash;n&bslash;&n;#define MAXHASHLEVEL  %d&bslash;n&bslash;&n;#define DEF_HASHLEVEL %d&bslash;n&bslash;&n;&bslash;n&bslash;&n;static unsigned int hashsize     = HASHSIZE;&bslash;n&bslash;&n;static unsigned int hashstep     = HASHSTEP;&bslash;n&bslash;&n;static unsigned int maxhashlevel = MAXHASHLEVEL;&bslash;n&bslash;&n;static unsigned int hashlevel    = DEF_HASHLEVEL;&bslash;n&bslash;&n;&bslash;n&bslash;&n;static struct unipair hashtable[HASHSIZE] =&bslash;n&bslash;&n;{&bslash;n&bslash;t&quot;
comma
id|argv
(braket
l_int|1
)braket
comma
id|hashsize
comma
id|hashstep
comma
id|maxhashlevel
comma
id|hashsize
comma
id|hashstep
comma
id|maxhashlevel
comma
id|hashlevel
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hashsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;{0x%04x,0x%02x}&quot;
comma
id|hashtable
(braket
id|i
)braket
dot
id|uc
comma
id|hashtable
(braket
id|i
)braket
dot
id|glyph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|hashsize
op_minus
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;n};&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
op_mod
l_int|4
op_eq
l_int|3
)paren
id|printf
c_func
(paren
l_string|&quot;,&bslash;n&bslash;t&quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;, &quot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n&bslash;&n;#ifdef NEED_BACKUP_HASHTABLE&bslash;n&bslash;&n;&bslash;n&bslash;&n;static const struct unipair backup_hashtable[HASHSIZE] = &bslash;n{&bslash;n&bslash;t&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hashsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;{0x%04x,0x%02x}&quot;
comma
id|hashtable
(braket
id|i
)braket
dot
id|uc
comma
id|hashtable
(braket
id|i
)braket
dot
id|glyph
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|hashsize
op_minus
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;n};&bslash;n#endif&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
op_mod
l_int|4
op_eq
l_int|3
)paren
id|printf
c_func
(paren
l_string|&quot;,&bslash;n&bslash;t&quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;, &quot;
)paren
suffix:semicolon
)brace
m_exit
(paren
id|EX_OK
)paren
suffix:semicolon
)brace
eof
