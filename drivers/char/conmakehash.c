multiline_comment|/*&n; * conmakehash.c&n; *&n; * Create arrays for initializing the kernel folded tables (using a hash&n; * table turned out to be to limiting...)  Unfortunately we can&squot;t simply&n; * preinitialize the tables at compile time since kfree() cannot accept&n; * memory not allocated by kmalloc(), and doing our own memory management&n; * just for this seems like massive overkill.&n; *&n; * Copyright (C) 1995-1997 H. Peter Anvin&n; *&n; * This program is a part of the Linux kernel, and may be freely&n; * copied under the terms of the GNU General Public License (GPL),&n; * version 2, or at your option any later version.&n; */
macro_line|#include &lt;stdio.h&gt;
macro_line|#include &lt;stdlib.h&gt;
macro_line|#include &lt;sysexits.h&gt;
macro_line|#include &lt;string.h&gt;
macro_line|#include &lt;ctype.h&gt;
DECL|macro|MAX_FONTLEN
mdefine_line|#define MAX_FONTLEN 256
DECL|typedef|unicode
r_typedef
r_int
r_int
id|unicode
suffix:semicolon
DECL|function|usage
r_void
id|usage
c_func
(paren
r_char
op_star
id|argv0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Usage: &bslash;n&quot;
l_string|&quot;        %s chartable [hashsize] [hashstep] [maxhashlevel]&bslash;n&quot;
comma
id|argv0
)paren
suffix:semicolon
m_exit
(paren
id|EX_USAGE
)paren
suffix:semicolon
)brace
DECL|function|getunicode
r_int
id|getunicode
c_func
(paren
r_char
op_star
op_star
id|p0
)paren
(brace
r_char
op_star
id|p
op_assign
op_star
id|p0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;U&squot;
op_logical_or
id|p
(braket
l_int|1
)braket
op_ne
l_char|&squot;+&squot;
op_logical_or
op_logical_neg
id|isxdigit
c_func
(paren
id|p
(braket
l_int|2
)braket
)paren
op_logical_or
op_logical_neg
id|isxdigit
c_func
(paren
id|p
(braket
l_int|3
)braket
)paren
op_logical_or
op_logical_neg
id|isxdigit
c_func
(paren
id|p
(braket
l_int|4
)braket
)paren
op_logical_or
op_logical_neg
id|isxdigit
c_func
(paren
id|p
(braket
l_int|5
)braket
)paren
op_logical_or
id|isxdigit
c_func
(paren
id|p
(braket
l_int|6
)braket
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
op_star
id|p0
op_assign
id|p
op_plus
l_int|6
suffix:semicolon
r_return
id|strtol
c_func
(paren
id|p
op_plus
l_int|2
comma
l_int|0
comma
l_int|16
)paren
suffix:semicolon
)brace
DECL|variable|unitable
id|unicode
id|unitable
(braket
id|MAX_FONTLEN
)braket
(braket
l_int|255
)braket
suffix:semicolon
multiline_comment|/* Massive overkill, but who cares? */
DECL|variable|unicount
r_int
id|unicount
(braket
id|MAX_FONTLEN
)braket
suffix:semicolon
DECL|function|addpair
r_void
id|addpair
c_func
(paren
r_int
id|fp
comma
r_int
id|un
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|un
op_le
l_int|0xfffe
)paren
(brace
multiline_comment|/* Check it isn&squot;t a duplicate */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|unicount
(braket
id|fp
)braket
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|unitable
(braket
id|fp
)braket
(braket
id|i
)braket
op_eq
id|un
)paren
r_return
suffix:semicolon
multiline_comment|/* Add to list */
r_if
c_cond
(paren
id|unicount
(braket
id|fp
)braket
OG
l_int|254
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;ERROR: Only 255 unicodes/glyph permitted!&bslash;n&quot;
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
id|unitable
(braket
id|fp
)braket
(braket
id|unicount
(braket
id|fp
)braket
)braket
op_assign
id|un
suffix:semicolon
id|unicount
(braket
id|fp
)braket
op_increment
suffix:semicolon
)brace
multiline_comment|/* otherwise: ignore */
)brace
DECL|function|main
r_int
id|main
c_func
(paren
r_int
id|argc
comma
r_char
op_star
id|argv
(braket
)braket
)paren
(brace
id|FILE
op_star
id|ctbl
suffix:semicolon
r_char
op_star
id|tblname
suffix:semicolon
r_char
id|buffer
(braket
l_int|65536
)braket
suffix:semicolon
r_int
id|fontlen
suffix:semicolon
r_int
id|i
comma
id|nuni
comma
id|nent
suffix:semicolon
r_int
id|fp0
comma
id|fp1
comma
id|un0
comma
id|un1
suffix:semicolon
r_char
op_star
id|p
comma
op_star
id|p1
suffix:semicolon
r_if
c_cond
(paren
id|argc
template_param
l_int|5
)paren
id|usage
c_func
(paren
id|argv
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;-&quot;
)paren
)paren
(brace
id|ctbl
op_assign
id|stdin
suffix:semicolon
id|tblname
op_assign
l_string|&quot;stdin&quot;
suffix:semicolon
)brace
r_else
(brace
id|ctbl
op_assign
id|fopen
c_func
(paren
id|tblname
op_assign
id|argv
(braket
l_int|1
)braket
comma
l_string|&quot;r&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ctbl
)paren
(brace
id|perror
c_func
(paren
id|tblname
)paren
suffix:semicolon
m_exit
(paren
id|EX_NOINPUT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* For now we assume the default font is always 256 characters. */
id|fontlen
op_assign
l_int|256
suffix:semicolon
multiline_comment|/* Initialize table */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fontlen
suffix:semicolon
id|i
op_increment
)paren
id|unicount
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Now we come to the tricky part.  Parse the input table. */
r_while
c_loop
(paren
id|fgets
c_func
(paren
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
id|ctbl
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|p
op_assign
id|strchr
c_func
(paren
id|buffer
comma
l_char|&squot;&bslash;n&squot;
)paren
)paren
op_ne
l_int|NULL
)paren
op_star
id|p
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_else
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Warning: line too long&bslash;n&quot;
comma
id|tblname
)paren
suffix:semicolon
id|p
op_assign
id|buffer
suffix:semicolon
multiline_comment|/*&n; * Syntax accepted:&n; *&t;&lt;fontpos&gt;&t;&lt;unicode&gt; &lt;unicode&gt; ...&n; *&t;&lt;range&gt;&t;&t;idem&n; *&t;&lt;range&gt;&t;&t;&lt;unicode range&gt;&n; *&n; * where &lt;range&gt; ::= &lt;fontpos&gt;-&lt;fontpos&gt;&n; * and &lt;unicode&gt; ::= U+&lt;h&gt;&lt;h&gt;&lt;h&gt;&lt;h&gt;&n; * and &lt;h&gt; ::= &lt;hexadecimal digit&gt;&n; */
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|p
op_logical_or
op_star
id|p
op_eq
l_char|&squot;#&squot;
)paren
r_continue
suffix:semicolon
multiline_comment|/* skip comment or blank line */
id|fp0
op_assign
id|strtol
c_func
(paren
id|p
comma
op_amp
id|p1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p1
op_eq
id|p
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Bad input line: %s&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
id|p
op_assign
id|p1
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_eq
l_char|&squot;-&squot;
)paren
(brace
id|p
op_increment
suffix:semicolon
id|fp1
op_assign
id|strtol
c_func
(paren
id|p
comma
op_amp
id|p1
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p1
op_eq
id|p
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;Bad input line: %s&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
id|p
op_assign
id|p1
suffix:semicolon
)brace
r_else
id|fp1
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|fp0
OL
l_int|0
op_logical_or
id|fp0
op_ge
id|fontlen
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Glyph number (0x%x) larger than font length&bslash;n&quot;
comma
id|tblname
comma
id|fp0
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fp1
op_logical_and
(paren
id|fp1
OL
id|fp0
op_logical_or
id|fp1
op_ge
id|fontlen
)paren
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Bad end of range (0x%x)&bslash;n&quot;
comma
id|tblname
comma
id|fp1
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fp1
)paren
(brace
multiline_comment|/* we have a range; expect the word &quot;idem&quot; or a Unicode range of the&n;&t;     same length */
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|p
comma
l_string|&quot;idem&quot;
comma
l_int|4
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|fp0
suffix:semicolon
id|i
op_le
id|fp1
suffix:semicolon
id|i
op_increment
)paren
id|addpair
c_func
(paren
id|i
comma
id|i
)paren
suffix:semicolon
id|p
op_add_assign
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|un0
op_assign
id|getunicode
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_ne
l_char|&squot;-&squot;
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Corresponding to a range of font positions, there should be a Unicode range&bslash;n&quot;
comma
id|tblname
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
id|un1
op_assign
id|getunicode
c_func
(paren
op_amp
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|un0
OL
l_int|0
op_logical_or
id|un1
OL
l_int|0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Bad Unicode range corresponding to font position range 0x%x-0x%x&bslash;n&quot;
comma
id|tblname
comma
id|fp0
comma
id|fp1
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|un1
op_minus
id|un0
op_ne
id|fp1
op_minus
id|fp0
)paren
(brace
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: Unicode range U+%x-U+%x not of the same length as font position range 0x%x-0x%x&bslash;n&quot;
comma
id|tblname
comma
id|un0
comma
id|un1
comma
id|fp0
comma
id|fp1
)paren
suffix:semicolon
m_exit
(paren
id|EX_DATAERR
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
id|fp0
suffix:semicolon
id|i
op_le
id|fp1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|addpair
c_func
(paren
id|i
comma
id|un0
op_minus
id|fp0
op_plus
id|i
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* no range; expect a list of unicode values for a single font position */
r_while
c_loop
(paren
(paren
id|un0
op_assign
id|getunicode
c_func
(paren
op_amp
id|p
)paren
)paren
op_ge
l_int|0
)paren
id|addpair
c_func
(paren
id|fp0
comma
id|un0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_star
id|p
op_eq
l_char|&squot; &squot;
op_logical_or
op_star
id|p
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|p
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|p
op_logical_and
op_star
id|p
op_ne
l_char|&squot;#&squot;
)paren
id|fprintf
c_func
(paren
id|stderr
comma
l_string|&quot;%s: trailing junk (%s) ignored&bslash;n&quot;
comma
id|tblname
comma
id|p
)paren
suffix:semicolon
)brace
multiline_comment|/* Okay, we hit EOF, now output hash table */
id|fclose
c_func
(paren
id|ctbl
)paren
suffix:semicolon
multiline_comment|/* Compute total size of Unicode list */
id|nuni
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fontlen
suffix:semicolon
id|i
op_increment
)paren
id|nuni
op_add_assign
id|unicount
(braket
id|i
)braket
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;&n;/*&bslash;n&bslash;&n; * Do not edit this file; it was automatically generated by&bslash;n&bslash;&n; *&bslash;n&bslash;&n; * conmakehash %s &gt; [this file]&bslash;n&bslash;&n; *&bslash;n&bslash;&n; */&bslash;n&bslash;&n;&bslash;n&bslash;&n;#include &lt;linux/types.h&gt;&bslash;n&bslash;&n;&bslash;n&bslash;&n;u8 dfont_unicount[%d] = &bslash;n&bslash;&n;{&bslash;n&bslash;t&quot;
comma
id|argv
(braket
l_int|1
)braket
comma
id|fontlen
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|fontlen
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;%3d&quot;
comma
id|unicount
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|fontlen
op_minus
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;n};&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
op_mod
l_int|8
op_eq
l_int|7
)paren
id|printf
c_func
(paren
l_string|&quot;,&bslash;n&bslash;t&quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;, &quot;
)paren
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;&bslash;nu16 dfont_unitable[%d] = &bslash;n{&bslash;n&bslash;t&quot;
comma
id|nuni
)paren
suffix:semicolon
id|fp0
op_assign
l_int|0
suffix:semicolon
id|nent
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nuni
suffix:semicolon
id|i
op_increment
)paren
(brace
r_while
c_loop
(paren
id|nent
op_ge
id|unicount
(braket
id|fp0
)braket
)paren
(brace
id|fp0
op_increment
suffix:semicolon
id|nent
op_assign
l_int|0
suffix:semicolon
)brace
id|printf
c_func
(paren
l_string|&quot;0x%04x&quot;
comma
id|unitable
(braket
id|fp0
)braket
(braket
id|nent
op_increment
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|nuni
op_minus
l_int|1
)paren
id|printf
c_func
(paren
l_string|&quot;&bslash;n};&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
op_mod
l_int|8
op_eq
l_int|7
)paren
id|printf
c_func
(paren
l_string|&quot;,&bslash;n&bslash;t&quot;
)paren
suffix:semicolon
r_else
id|printf
c_func
(paren
l_string|&quot;, &quot;
)paren
suffix:semicolon
)brace
m_exit
(paren
id|EX_OK
)paren
suffix:semicolon
)brace
eof
