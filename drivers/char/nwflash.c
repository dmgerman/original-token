multiline_comment|/*&n; * Flash memory interface rev.5 driver for the Intel&n; * Flash chips used on the NetWinder.&n; *&n; * 20/08/2000&t;RMK&t;use __ioremap to map flash into virtual memory&n; *&t;&t;&t;make a few more places use &quot;volatile&quot;&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/hardware/dec21285.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/leds.h&gt;
macro_line|#include &lt;asm/mach-types.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*****************************************************************************/
macro_line|#include &lt;asm/nwflash.h&gt;
singleline_comment|//#define MINIKERNEL 1          //export flash write, erase routines for MiniKernel
macro_line|#ifndef MINIKERNEL
DECL|macro|MSTATIC
mdefine_line|#define MSTATIC static
macro_line|#else
DECL|macro|MSTATIC
mdefine_line|#define MSTATIC
macro_line|#endif
DECL|macro|NWFLASH_VERSION
mdefine_line|#define&t;NWFLASH_VERSION &quot;6.3&quot;
id|MSTATIC
r_void
id|kick_open
c_func
(paren
r_void
)paren
suffix:semicolon
id|MSTATIC
r_int
id|get_flash_id
c_func
(paren
r_void
)paren
suffix:semicolon
id|MSTATIC
r_int
id|erase_block
c_func
(paren
r_int
id|nBlock
)paren
suffix:semicolon
id|MSTATIC
r_int
id|write_block
c_func
(paren
r_int
r_int
id|p
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_int
id|open_flash
c_func
(paren
r_struct
id|inode
op_star
id|inodep
comma
r_struct
id|file
op_star
id|filep
)paren
suffix:semicolon
r_static
r_int
id|flash_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inodep
comma
r_struct
id|file
op_star
id|filep
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
id|ssize_t
id|flash_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
id|ssize_t
id|flash_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
r_int
r_int
id|flash_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|offset
comma
r_int
id|orig
)paren
suffix:semicolon
DECL|macro|KFLASH_SIZE
mdefine_line|#define KFLASH_SIZE&t;1024*1024&t;
singleline_comment|//1 Meg
DECL|macro|KFLASH_SIZE4
mdefine_line|#define KFLASH_SIZE4&t;4*1024*1024&t;
singleline_comment|//4 Meg
DECL|macro|KFLASH_ID
mdefine_line|#define KFLASH_ID&t;0x89A6&t;&t;
singleline_comment|//Intel flash
DECL|macro|KFLASH_ID4
mdefine_line|#define KFLASH_ID4&t;0xB0D4&t;&t;
singleline_comment|//Intel flash 4Meg
DECL|variable|flashdebug
r_static
r_int
id|flashdebug
suffix:semicolon
singleline_comment|//if set - we will display progress msgs
DECL|variable|gbWriteEnable
r_static
r_int
id|gbWriteEnable
suffix:semicolon
DECL|variable|gbWriteBase64Enable
r_static
r_int
id|gbWriteBase64Enable
suffix:semicolon
DECL|variable|FLASH_BASE
r_static
r_volatile
r_int
r_char
op_star
id|FLASH_BASE
suffix:semicolon
DECL|variable|gbFlashSize
id|MSTATIC
r_int
id|gbFlashSize
op_assign
id|KFLASH_SIZE
suffix:semicolon
r_extern
id|spinlock_t
id|gpio_lock
suffix:semicolon
DECL|variable|flash_fops
r_static
r_struct
id|file_operations
id|flash_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|flash_llseek
comma
id|read
suffix:colon
id|flash_read
comma
id|write
suffix:colon
id|flash_write
comma
id|ioctl
suffix:colon
id|flash_ioctl
comma
id|open
suffix:colon
id|open_flash
comma
)brace
suffix:semicolon
DECL|variable|flash_miscdev
r_static
r_struct
id|miscdevice
id|flash_miscdev
op_assign
(brace
id|FLASH_MINOR
comma
l_string|&quot;nwflash&quot;
comma
op_amp
id|flash_fops
)brace
suffix:semicolon
multiline_comment|/*&n; * the delay routine - it is often required to let the flash &quot;breeze&quot;...&n; */
DECL|function|flash_wait
r_void
id|flash_wait
c_func
(paren
r_int
id|timeout
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
)brace
DECL|function|get_flash_id
id|MSTATIC
r_int
id|get_flash_id
c_func
(paren
r_void
)paren
(brace
r_volatile
r_int
r_int
id|c1
comma
id|c2
suffix:semicolon
multiline_comment|/*&n;&t; * try to get flash chip ID&n;&t; */
id|kick_open
c_func
(paren
)paren
suffix:semicolon
id|c2
op_assign
id|inb
c_func
(paren
l_int|0x80
)paren
suffix:semicolon
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
op_assign
l_int|0x90
suffix:semicolon
id|udelay
c_func
(paren
l_int|15
)paren
suffix:semicolon
id|c1
op_assign
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
id|FLASH_BASE
suffix:semicolon
id|c2
op_assign
id|inb
c_func
(paren
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * on 4 Meg flash the second byte is actually at offset 2...&n;&t; */
r_if
c_cond
(paren
id|c1
op_eq
l_int|0xB0
)paren
id|c2
op_assign
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|2
)paren
suffix:semicolon
r_else
id|c2
op_assign
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|1
)paren
suffix:semicolon
id|c2
op_add_assign
(paren
id|c1
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * set it back to read mode&n;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
op_assign
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|c2
op_eq
id|KFLASH_ID4
)paren
id|gbFlashSize
op_assign
id|KFLASH_SIZE4
suffix:semicolon
r_return
id|c2
suffix:semicolon
)brace
DECL|function|open_flash
r_static
r_int
id|open_flash
c_func
(paren
r_struct
id|inode
op_star
id|inodep
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
r_int
id|id
suffix:semicolon
id|id
op_assign
id|get_flash_id
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id
op_ne
id|KFLASH_ID
)paren
op_logical_and
(paren
id|id
op_ne
id|KFLASH_ID4
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Flash: incorrect ID 0x%04X.&bslash;n&quot;
comma
id|id
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|flash_ioctl
r_static
r_int
id|flash_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inodep
comma
r_struct
id|file
op_star
id|filep
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
singleline_comment|//      printk(&quot;Flash_ioctl: cmd = 0x%X.&bslash;n&quot;,cmd);
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CMD_WRITE_DISABLE
suffix:colon
id|gbWriteBase64Enable
op_assign
l_int|0
suffix:semicolon
id|gbWriteEnable
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_WRITE_ENABLE
suffix:colon
id|gbWriteEnable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_WRITE_BASE64K_ENABLE
suffix:colon
id|gbWriteBase64Enable
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|gbWriteBase64Enable
op_assign
l_int|0
suffix:semicolon
id|gbWriteEnable
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|flash_read
r_static
id|ssize_t
id|flash_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
r_int
id|p
op_assign
id|file-&gt;f_pos
suffix:semicolon
r_int
id|read
suffix:semicolon
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
l_string|&quot;Flash_dev: flash_read: offset=0x%X, buffer=0x%X, count=0x%X.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|p
comma
(paren
r_int
r_int
)paren
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|gbFlashSize
op_minus
id|p
)paren
id|count
op_assign
id|gbFlashSize
op_minus
id|p
suffix:semicolon
id|read
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
(paren
r_void
op_star
)paren
(paren
id|FLASH_BASE
op_plus
id|p
)paren
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|read
op_add_assign
id|count
suffix:semicolon
id|file-&gt;f_pos
op_add_assign
id|read
suffix:semicolon
r_return
id|read
suffix:semicolon
)brace
DECL|function|flash_write
r_static
id|ssize_t
id|flash_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
r_int
id|p
op_assign
id|file-&gt;f_pos
suffix:semicolon
r_int
id|written
suffix:semicolon
r_int
id|nBlock
comma
id|temp
comma
id|rc
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
l_string|&quot;flash_write: offset=0x%lX, buffer=0x%p, count=0x%X.&bslash;n&quot;
comma
id|p
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|gbWriteEnable
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|p
OL
l_int|64
op_star
l_int|1024
op_logical_and
(paren
op_logical_neg
id|gbWriteBase64Enable
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t; * if byte count is -ve or to big - error!&n;&t; */
r_if
c_cond
(paren
id|count
template_param
id|gbFlashSize
op_minus
id|p
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|buf
comma
id|count
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/*&n;&t; * We now should lock around writes.  Really, we shouldn&squot;t&n;&t; * allow the flash to be opened more than once in write&n;&t; * mode though (note that you can&squot;t stop two processes having&n;&t; * it open even then). --rmk&n;&t; */
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|written
op_assign
l_int|0
suffix:semicolon
id|leds_event
c_func
(paren
id|led_claim
)paren
suffix:semicolon
id|leds_event
c_func
(paren
id|led_green_on
)paren
suffix:semicolon
id|nBlock
op_assign
(paren
r_int
)paren
id|p
op_rshift
l_int|16
suffix:semicolon
singleline_comment|//block # of 64K bytes
multiline_comment|/*&n;&t; * # of 64K blocks to erase and write&n;&t; */
id|temp
op_assign
(paren
(paren
r_int
)paren
(paren
id|p
op_plus
id|count
)paren
op_rshift
l_int|16
)paren
op_minus
id|nBlock
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * write ends at exactly 64k boundry?&n;&t; */
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
(paren
id|p
op_plus
id|count
)paren
op_amp
l_int|0xFFFF
)paren
op_eq
l_int|0
)paren
id|temp
op_sub_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
l_string|&quot;FlashWrite: writing %d block(s) starting at %d.&bslash;n&quot;
comma
id|temp
comma
id|nBlock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|temp
suffix:semicolon
id|temp
op_decrement
comma
id|nBlock
op_increment
)paren
(brace
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
l_string|&quot;FlashWrite: erasing block %d.&bslash;n&quot;
comma
id|nBlock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * first we have to erase the block(s), where we will write...&n;&t;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
id|RetryBlock
suffix:colon
r_do
(brace
id|rc
op_assign
id|erase_block
c_func
(paren
id|nBlock
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|rc
op_logical_and
id|i
OL
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
l_string|&quot;FlashWrite: erase error %X. Aborting...&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
l_string|&quot;FlashWrite: writing offset %X, from buf %X, bytes left %X.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|p
comma
(paren
r_int
r_int
)paren
id|buf
comma
id|count
op_minus
id|written
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * write_block will limit write to space left in this block&n;&t;&t; */
id|rc
op_assign
id|write_block
c_func
(paren
id|p
comma
id|buf
comma
id|count
op_minus
id|written
)paren
suffix:semicolon
id|j
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if somehow write verify failed? Can&squot;t happen??&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * retry up to 10 times&n;&t;&t;&t; */
r_if
c_cond
(paren
id|j
OL
l_int|10
)paren
r_goto
id|RetryBlock
suffix:semicolon
r_else
multiline_comment|/*&n;&t;&t;&t;&t; * else quit with error...&n;&t;&t;&t;&t; */
id|rc
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
l_string|&quot;FlashWrite: write error %X. Aborting...&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|p
op_add_assign
id|rc
suffix:semicolon
id|buf
op_add_assign
id|rc
suffix:semicolon
id|written
op_add_assign
id|rc
suffix:semicolon
id|file-&gt;f_pos
op_add_assign
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
l_string|&quot;FlashWrite: written 0x%X bytes OK.&bslash;n&quot;
comma
id|written
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * restore reg on exit&n;&t; */
id|leds_event
c_func
(paren
id|led_release
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|inode-&gt;i_sem
)paren
suffix:semicolon
r_return
id|written
suffix:semicolon
)brace
multiline_comment|/*&n; * The memory devices use the full 32/64 bits of the offset, and so we cannot&n; * check against negative addresses: they are ok. The return value is weird,&n; * though, in that case (0).&n; *&n; * also note that seeking relative to the &quot;end of file&quot; isn&squot;t supported:&n; * it has no meaning, so it returns -EINVAL.&n; */
DECL|function|flash_llseek
r_static
r_int
r_int
id|flash_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|offset
comma
r_int
id|orig
)paren
(brace
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
l_string|&quot;Flash_dev: flash_lseek, offset=0x%X, orig=0x%X.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|offset
comma
(paren
r_int
r_int
)paren
id|orig
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|orig
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
id|offset
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|offset
OG
id|gbFlashSize
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|file-&gt;f_pos
op_assign
(paren
r_int
r_int
)paren
id|offset
suffix:semicolon
r_return
id|file-&gt;f_pos
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
(paren
id|file-&gt;f_pos
op_plus
id|offset
)paren
OG
id|gbFlashSize
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file-&gt;f_pos
op_plus
id|offset
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|file-&gt;f_pos
op_add_assign
id|offset
suffix:semicolon
r_return
id|file-&gt;f_pos
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * assume that main Write routine did the parameter checking...&n; * so just go ahead and erase, what requested!&n; */
DECL|function|erase_block
id|MSTATIC
r_int
id|erase_block
c_func
(paren
r_int
id|nBlock
)paren
(brace
r_volatile
r_int
r_int
id|c1
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|pWritePtr
suffix:semicolon
r_int
id|temp
comma
id|temp1
suffix:semicolon
multiline_comment|/*&n;&t; * orange LED == erase&n;&t; */
id|leds_event
c_func
(paren
id|led_amber_on
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * reset footbridge to the correct offset 0 (...0..3)&n;&t; */
op_star
id|CSR_ROMWRITEREG
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * dummy ROM read&n;&t; */
id|c1
op_assign
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
suffix:semicolon
id|kick_open
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * reset status if old errors&n;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
op_assign
l_int|0x50
suffix:semicolon
multiline_comment|/*&n;&t; * erase a block...&n;&t; * aim at the middle of a current block...&n;&t; */
id|pWritePtr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
op_plus
(paren
id|nBlock
op_lshift
l_int|16
)paren
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * dummy read&n;&t; */
id|c1
op_assign
op_star
id|pWritePtr
suffix:semicolon
id|kick_open
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * erase&n;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
id|pWritePtr
op_assign
l_int|0x20
suffix:semicolon
multiline_comment|/*&n;&t; * confirm&n;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
id|pWritePtr
op_assign
l_int|0xD0
suffix:semicolon
multiline_comment|/*&n;&t; * wait 10 ms&n;&t; */
id|flash_wait
c_func
(paren
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * wait while erasing in process (up to 10 sec)&n;&t; */
id|temp
op_assign
id|jiffies
op_plus
l_int|10
op_star
id|HZ
suffix:semicolon
id|c1
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|c1
op_amp
l_int|0x80
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|temp
)paren
)paren
(brace
id|flash_wait
c_func
(paren
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * read any address&n;&t;&t; */
id|c1
op_assign
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|pWritePtr
)paren
suffix:semicolon
singleline_comment|//              printk(&quot;Flash_erase: status=%X.&bslash;n&quot;,c1);
)brace
multiline_comment|/*&n;&t; * set flash for normal read access&n;&t; */
id|kick_open
c_func
(paren
)paren
suffix:semicolon
singleline_comment|//      *(volatile unsigned char*)(FLASH_BASE+0x8000) = 0xFF;
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
id|pWritePtr
op_assign
l_int|0xFF
suffix:semicolon
singleline_comment|//back to normal operation
multiline_comment|/*&n;&t; * check if erase errors were reported&n;&t; */
r_if
c_cond
(paren
id|c1
op_amp
l_int|0x20
)paren
(brace
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
l_string|&quot;Flash_erase: err at %X.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|pWritePtr
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * reset error&n;&t;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
op_assign
l_int|0x50
suffix:semicolon
r_return
op_minus
l_int|2
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * just to make sure - verify if erased OK...&n;&t; */
id|flash_wait
c_func
(paren
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
id|pWritePtr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|FLASH_BASE
op_plus
(paren
id|nBlock
op_lshift
l_int|16
)paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|temp
op_assign
l_int|0
suffix:semicolon
id|temp
OL
l_int|16
op_star
l_int|1024
suffix:semicolon
id|temp
op_increment
comma
id|pWritePtr
op_add_assign
l_int|4
)paren
(brace
r_if
c_cond
(paren
(paren
id|temp1
op_assign
op_star
(paren
r_volatile
r_int
r_int
op_star
)paren
id|pWritePtr
)paren
op_ne
l_int|0xFFFFFFFF
)paren
(brace
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
l_string|&quot;Flash_erase: verify err at %X = %X.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|pWritePtr
comma
id|temp1
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * write_block will limit number of bytes written to the space in this block&n; */
DECL|function|write_block
id|MSTATIC
r_int
id|write_block
c_func
(paren
r_int
r_int
id|p
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_volatile
r_int
r_int
id|c1
suffix:semicolon
r_volatile
r_int
r_int
id|c2
suffix:semicolon
r_int
r_char
op_star
id|pWritePtr
suffix:semicolon
r_int
r_int
id|uAddress
suffix:semicolon
r_int
r_int
id|offset
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
r_int
id|timeout1
suffix:semicolon
multiline_comment|/*&n;&t; * red LED == write&n;&t; */
id|leds_event
c_func
(paren
id|led_amber_off
)paren
suffix:semicolon
id|leds_event
c_func
(paren
id|led_red_on
)paren
suffix:semicolon
id|pWritePtr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|FLASH_BASE
op_plus
id|p
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * check if write will end in this block....&n;&t; */
id|offset
op_assign
id|p
op_amp
l_int|0xFFFF
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_plus
id|count
OG
l_int|0x10000
)paren
id|count
op_assign
l_int|0x10000
op_minus
id|offset
suffix:semicolon
multiline_comment|/*&n;&t; * wait up to 30 sec for this block&n;&t; */
id|timeout
op_assign
id|jiffies
op_plus
l_int|30
op_star
id|HZ
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|count
suffix:semicolon
id|offset
op_increment
comma
id|pWritePtr
op_increment
)paren
(brace
id|uAddress
op_assign
(paren
r_int
r_int
)paren
id|pWritePtr
suffix:semicolon
id|uAddress
op_and_assign
l_int|0xFFFFFFFC
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|c2
comma
id|buf
op_plus
id|offset
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|WriteRetry
suffix:colon
multiline_comment|/*&n;&t;  &t; * dummy read&n;&t;  &t; */
id|c1
op_assign
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * kick open the write gate&n;&t;&t; */
id|kick_open
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * program footbridge to the correct offset...0..3&n;&t;&t; */
op_star
id|CSR_ROMWRITEREG
op_assign
(paren
r_int
r_int
)paren
id|pWritePtr
op_amp
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t;&t; * write cmd&n;&t;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|uAddress
)paren
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/*&n;&t;&t; * data to write&n;&t;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|uAddress
)paren
op_assign
id|c2
suffix:semicolon
multiline_comment|/*&n;&t;&t; * get status&n;&t;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x10000
)paren
op_assign
l_int|0x70
suffix:semicolon
id|c1
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * wait up to 1 sec for this byte&n;&t;&t; */
id|timeout1
op_assign
id|jiffies
op_plus
l_int|1
op_star
id|HZ
suffix:semicolon
multiline_comment|/*&n;&t;&t; * while not ready...&n;&t;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
id|c1
op_amp
l_int|0x80
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout1
)paren
)paren
id|c1
op_assign
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if timeout getting status&n;&t;&t; */
r_if
c_cond
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|timeout1
)paren
)paren
(brace
id|kick_open
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * reset err&n;&t;&t;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
op_assign
l_int|0x50
suffix:semicolon
r_goto
id|WriteRetry
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * switch on read access, as a default flash operation mode&n;&t;&t; */
id|kick_open
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * read access&n;&t;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
op_assign
l_int|0xFF
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if hardware reports an error writing, and not timeout - &n;&t;&t; * reset the chip and retry&n;&t;&t; */
r_if
c_cond
(paren
id|c1
op_amp
l_int|0x10
)paren
(brace
id|kick_open
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * reset err&n;&t;&t;&t; */
op_star
(paren
r_volatile
r_int
r_char
op_star
)paren
(paren
id|FLASH_BASE
op_plus
l_int|0x8000
)paren
op_assign
l_int|0x50
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * before timeout?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
(brace
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
l_string|&quot;FlashWrite: Retrying write (addr=0x%X)...&bslash;n&quot;
comma
id|pWritePtr
op_minus
id|FLASH_BASE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * no LED == waiting&n;&t;&t;&t;&t; */
id|leds_event
c_func
(paren
id|led_amber_off
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * wait couple ms&n;&t;&t;&t;&t; */
id|flash_wait
c_func
(paren
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * red LED == write&n;&t;&t;&t;&t; */
id|leds_event
c_func
(paren
id|led_red_on
)paren
suffix:semicolon
r_goto
id|WriteRetry
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Timeout in flash write! (addr=0x%X) Aborting...&bslash;n&quot;
comma
id|pWritePtr
op_minus
id|FLASH_BASE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * return error -2&n;&t;&t;&t;&t; */
r_return
op_minus
l_int|2
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * green LED == read/verify&n;&t; */
id|leds_event
c_func
(paren
id|led_amber_off
)paren
suffix:semicolon
id|leds_event
c_func
(paren
id|led_green_on
)paren
suffix:semicolon
id|flash_wait
c_func
(paren
id|HZ
op_div
l_int|100
)paren
suffix:semicolon
id|pWritePtr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
(paren
r_int
r_int
)paren
(paren
id|FLASH_BASE
op_plus
id|p
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|count
suffix:semicolon
id|offset
op_increment
)paren
(brace
r_char
id|c
comma
id|c1
suffix:semicolon
r_if
c_cond
(paren
id|__get_user
c_func
(paren
id|c
comma
id|buf
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|buf
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c1
op_assign
op_star
id|pWritePtr
op_increment
)paren
op_ne
id|c
)paren
(brace
r_if
c_cond
(paren
id|flashdebug
)paren
id|printk
c_func
(paren
l_string|&quot;flash write verify error at 0x%X! (%02X!=%02X) Retrying...&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|pWritePtr
comma
id|c1
comma
id|c
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|kick_open
id|MSTATIC
r_void
id|kick_open
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; * we want to write a bit pattern XXX1 to Xilinx to enable&n;&t; * the write gate, which will be open for about the next 2ms.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|gpio_lock
comma
id|flags
)paren
suffix:semicolon
id|cpld_modify
c_func
(paren
l_int|1
comma
l_int|1
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|gpio_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * let the ISA bus to catch on...&n;&t; */
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
)brace
DECL|function|nwflash_init
id|MSTATIC
r_int
id|__init
id|nwflash_init
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|machine_is_netwinder
c_func
(paren
)paren
)paren
(brace
r_int
id|id
suffix:semicolon
id|FLASH_BASE
op_assign
id|__ioremap
c_func
(paren
id|DC21285_FLASH
comma
id|KFLASH_SIZE4
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|FLASH_BASE
)paren
r_goto
id|out
suffix:semicolon
id|id
op_assign
id|get_flash_id
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Flash ROM driver v.%s, flash device ID 0x%04X, size %d Mb.&bslash;n&quot;
comma
id|NWFLASH_VERSION
comma
id|id
comma
id|gbFlashSize
op_div
(paren
l_int|1024
op_star
l_int|1024
)paren
)paren
suffix:semicolon
id|misc_register
c_func
(paren
op_amp
id|flash_miscdev
)paren
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
)brace
id|out
suffix:colon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|nwflash_exit
id|MSTATIC
r_void
id|__exit
id|nwflash_exit
c_func
(paren
r_void
)paren
(brace
id|misc_deregister
c_func
(paren
op_amp
id|flash_miscdev
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|FLASH_BASE
)paren
suffix:semicolon
)brace
id|EXPORT_NO_SYMBOLS
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|flashdebug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|nwflash_init
id|module_init
c_func
(paren
id|nwflash_init
)paren
suffix:semicolon
DECL|variable|nwflash_exit
id|module_exit
c_func
(paren
id|nwflash_exit
)paren
suffix:semicolon
eof
