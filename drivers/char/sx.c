multiline_comment|/* sx.c -- driver for the Specialix SX series cards. &n; *&n; *  This driver will also support the older SI, and XIO cards.&n; *&n; *&n; *   (C) 1998 - 2000  R.E.Wolff@BitWizard.nl&n; *&n; *  Simon Allen (simonallen@cix.compulink.co.uk) wrote a previous&n; *  version of this driver. Some fragments may have been copied. (none&n; *  yet :-)&n; *&n; * Specialix pays for the development and support of this driver.&n; * Please DO contact support@specialix.co.uk if you require&n; * support. But please read the documentation (sx.txt) first.&n; *&n; *&n; *&n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License as&n; *      published by the Free Software Foundation; either version 2 of&n; *      the License, or (at your option) any later version.&n; *&n; *      This program is distributed in the hope that it will be&n; *      useful, but WITHOUT ANY WARRANTY; without even the implied&n; *      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR&n; *      PURPOSE.  See the GNU General Public License for more details.&n; *&n; *      You should have received a copy of the GNU General Public&n; *      License along with this program; if not, write to the Free&n; *      Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,&n; *      USA.&n; *&n; * Revision history:&n; * $Log: sx.c,v $&n; * Revision 1.33  2000/03/09 10:00:00  pvdl,wolff&n; * - Fixed module and port counting&n; * - Fixed signal handling&n; * - Fixed an Ooops&n; * &n; * Revision 1.32  2000/03/07 09:00:00  wolff,pvdl&n; * - Fixed some sx_dprintk typos&n; * - added detection for an invalid board/module configuration&n; *&n; * Revision 1.31  2000/03/06 12:00:00  wolff,pvdl&n; * - Added support for EISA&n; *&n; * Revision 1.30  2000/01/21 17:43:06  wolff&n; * - Added support for SX+&n; *&n; * Revision 1.26  1999/08/05 15:22:14  wolff&n; * - Port to 2.3.x&n; * - Reformatted to Linus&squot; liking.&n; *&n; * Revision 1.25  1999/07/30 14:24:08  wolff&n; * Had accidentally left &quot;gs_debug&quot; set to &quot;-1&quot; instead of &quot;off&quot; (=0).&n; *&n; * Revision 1.24  1999/07/28 09:41:52  wolff&n; * - I noticed the remark about use-count straying in sx.txt. I checked&n; *   sx_open, and found a few places where that could happen. I hope it&squot;s&n; *   fixed now.&n; *&n; * Revision 1.23  1999/07/28 08:56:06  wolff&n; * - Fixed crash when sx_firmware run twice.&n; * - Added sx_slowpoll as a module parameter (I guess nobody really wanted&n; *   to change it from the default... )&n; * - Fixed a stupid editing problem I introduced in 1.22.&n; * - Fixed dropping characters on a termios change.&n; *&n; * Revision 1.22  1999/07/26 21:01:43  wolff&n; * Russell Brown noticed that I had overlooked 4 out of six modem control&n; * signals in sx_getsignals. Ooops.&n; *&n; * Revision 1.21  1999/07/23 09:11:33  wolff&n; * I forgot to free dynamically allocated memory when the driver is unloaded.&n; *&n; * Revision 1.20  1999/07/20 06:25:26  wolff&n; * The &quot;closing wait&quot; wasn&squot;t honoured. Thanks to James Griffiths for&n; * reporting this.&n; *&n; * Revision 1.19  1999/07/11 08:59:59  wolff&n; * Fixed an oops in close, when an open was pending. Changed the memtest&n; * a bit. Should also test the board in word-mode, however my card fails the&n; * memtest then. I still have to figure out what is wrong...&n; *&n; * Revision 1.18  1999/06/10 09:38:42  wolff&n; * Changed the format of the firmware revision from %04x to %x.%02x .&n; *&n; * Revision 1.17  1999/06/04 09:44:35  wolff&n; * fixed problem: reference to pci stuff when config_pci was off...&n; * Thanks to Jorge Novo for noticing this.&n; *&n; * Revision 1.16  1999/06/02 08:30:15  wolff&n; * added/removed the workaround for the DCD bug in the Firmware.&n; * A bit more debugging code to locate that...&n; *&n; * Revision 1.15  1999/06/01 11:35:30  wolff&n; * when DCD is left low (floating?), on TA&squot;s the firmware first tells us&n; * that DCD is high, but after a short while suddenly comes to the&n; * conclusion that it is low. All this would be fine, if it weren&squot;t that&n; * Unix requires us to send a &quot;hangup&quot; signal in that case. This usually&n; * all happens BEFORE the program has had a chance to ioctl the device&n; * into clocal mode..&n; *&n; * Revision 1.14  1999/05/25 11:18:59  wolff&n; * Added PCI-fix.&n; * Added checks for return code of sx_sendcommand.&n; * Don&squot;t issue &quot;reconfig&quot; if port isn&squot;t open yet. (bit us on TA modules...)&n; *&n; * Revision 1.13  1999/04/29 15:18:01  wolff&n; * Fixed an &quot;oops&quot; that showed on SuSE 6.0 systems.&n; * Activate DTR again after stty 0.&n; *&n; * Revision 1.12  1999/04/29 07:49:52  wolff&n; * Improved &quot;stty 0&quot; handling a bit. (used to change baud to 9600 assuming&n; *     the connection would be dropped anyway. That is not always the case,&n; *     and confuses people).&n; * Told the card to always monitor the modem signals.&n; * Added support for dynamic  gs_debug adjustments.&n; * Now tells the rest of the system the number of ports.&n; *&n; * Revision 1.11  1999/04/24 11:11:30  wolff&n; * Fixed two stupid typos in the memory test.&n; *&n; * Revision 1.10  1999/04/24 10:53:39  wolff&n; * Added some of Christian&squot;s suggestions.&n; * Fixed an HW_COOK_IN bug (ISIG was not in I_OTHER. We used to trust the&n; * card to send the signal to the process.....)&n; *&n; * Revision 1.9  1999/04/23 07:26:38  wolff&n; * Included Christian Lademann&squot;s 2.0 compile-warning fixes and interrupt&n; *    assignment redesign.&n; * Cleanup of some other stuff.&n; *&n; * Revision 1.8  1999/04/16 13:05:30  wolff&n; * fixed a DCD change unnoticed bug.&n; *&n; * Revision 1.7  1999/04/14 22:19:51  wolff&n; * Fixed typo that showed up in 2.0.x builds (get_user instead of Get_user!)&n; *&n; * Revision 1.6  1999/04/13 18:40:20  wolff&n; * changed misc-minor to 161, as assigned by HPA.&n; *&n; * Revision 1.5  1999/04/13 15:12:25  wolff&n; * Fixed use-count leak when &quot;hangup&quot; occurred.&n; * Added workaround for a stupid-PCIBIOS bug.&n; *&n; *&n; * Revision 1.4  1999/04/01 22:47:40  wolff&n; * Fixed &lt; 1M linux-2.0 problem.&n; * (vremap isn&squot;t compatible with ioremap in that case)&n; *&n; * Revision 1.3  1999/03/31 13:45:45  wolff&n; * Firmware loading is now done through a separate IOCTL.&n; *&n; * Revision 1.2  1999/03/28 12:22:29  wolff&n; * rcs cleanup&n; *&n; * Revision 1.1  1999/03/28 12:10:34  wolff&n; * Readying for release on 2.0.x (sorry David, 1.01 becomes 1.1 for RCS). &n; *&n; * Revision 0.12  1999/03/28 09:20:10  wolff&n; * Fixed problem in 0.11, continueing cleanup.&n; *&n; * Revision 0.11  1999/03/28 08:46:44  wolff&n; * cleanup. Not good.&n; *&n; * Revision 0.10  1999/03/28 08:09:43  wolff&n; * Fixed loosing characters on close.&n; *&n; * Revision 0.9  1999/03/21 22:52:01  wolff&n; * Ported back to 2.2.... (minor things)&n; *&n; * Revision 0.8  1999/03/21 22:40:33  wolff&n; * Port to 2.0&n; *&n; * Revision 0.7  1999/03/21 19:06:34  wolff&n; * Fixed hangup processing.&n; *&n; * Revision 0.6  1999/02/05 08:45:14  wolff&n; * fixed real_raw problems. Inclusion into kernel imminent.&n; *&n; * Revision 0.5  1998/12/21 23:51:06  wolff&n; * Snatched a nasty bug: sx_transmit_chars was getting re-entered, and it&n; * shouldn&squot;t have. THATs why I want to have transmit interrupts even when&n; * the buffer is empty.&n; *&n; * Revision 0.4  1998/12/17 09:34:46  wolff&n; * PPP works. ioctl works. Basically works!&n; *&n; * Revision 0.3  1998/12/15 13:05:18  wolff&n; * It works! Wow! Gotta start implementing IOCTL and stuff....&n; *&n; * Revision 0.2  1998/12/01 08:33:53  wolff&n; * moved over to 2.1.130&n; *&n; * Revision 0.1  1998/11/03 21:23:51  wolff&n; * Initial revision. Detects SX card.&n; *&n; * */
DECL|macro|RCS_ID
mdefine_line|#define RCS_ID &quot;$Id: sx.c,v 1.33 2000/03/08 10:01:02 wolff, pvdl Exp $&quot;
DECL|macro|RCS_REV
mdefine_line|#define RCS_REV &quot;$Revision: 1.33 $&quot;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt; 
macro_line|#include &lt;linux/kdev_t.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
multiline_comment|/* The 3.0.0 version of sxboards/sxwindow.h  uses BYTE and WORD.... */
DECL|macro|BYTE
mdefine_line|#define BYTE u8
DECL|macro|WORD
mdefine_line|#define WORD u16
multiline_comment|/* .... but the 3.0.4 version uses _u8 and _u16. */
DECL|macro|_u8
mdefine_line|#define _u8 u8
DECL|macro|_u16
mdefine_line|#define _u16 u16
macro_line|#include &quot;sxboards.h&quot;
macro_line|#include &quot;sxwindow.h&quot;
macro_line|#include &lt;linux/compatmac.h&gt;
macro_line|#include &lt;linux/generic_serial.h&gt;
macro_line|#include &quot;sx.h&quot;
multiline_comment|/* I don&squot;t think that this driver can handle more than 256 ports on&n;   one machine. You&squot;ll have to increase the number of boards in sx.h&n;   if you want more than 4 boards.  */
multiline_comment|/* Why the hell am I defining these here? */
DECL|macro|SX_TYPE_NORMAL
mdefine_line|#define SX_TYPE_NORMAL 1
DECL|macro|SX_TYPE_CALLOUT
mdefine_line|#define SX_TYPE_CALLOUT 2
macro_line|#ifndef PCI_DEVICE_ID_SPECIALIX_SX_XIO_IO8
DECL|macro|PCI_DEVICE_ID_SPECIALIX_SX_XIO_IO8
mdefine_line|#define PCI_DEVICE_ID_SPECIALIX_SX_XIO_IO8 0x2000
macro_line|#endif
multiline_comment|/* Configurable options: &n;   (Don&squot;t be too sure that it&squot;ll work if you toggle them) */
multiline_comment|/* Am I paranoid or not ? ;-) */
DECL|macro|SX_PARANOIA_CHECK
macro_line|#undef SX_PARANOIA_CHECK
multiline_comment|/* 20 -&gt; 2000 per second. The card should rate-limit interrupts at 100&n;   Hz, but it is user configurable. I don&squot;t recommend going above 1000&n;   Hz. The interrupt ratelimit might trigger if the interrupt is&n;   shared with a very active other device. */
DECL|macro|IRQ_RATE_LIMIT
mdefine_line|#define IRQ_RATE_LIMIT 20
multiline_comment|/* Sharing interrupts is possible now. If the other device wants more&n;   than 2000 interrupts per second, we&squot;d gracefully decline further&n;   interrupts. That&squot;s not what we want. On the other hand, if the&n;   other device interrupts 2000 times a second, don&squot;t use the SX&n;   interrupt. Use polling. */
DECL|macro|IRQ_RATE_LIMIT
macro_line|#undef IRQ_RATE_LIMIT
macro_line|#if 0
multiline_comment|/* Not implemented */
multiline_comment|/* &n; * The following defines are mostly for testing purposes. But if you need&n; * some nice reporting in your syslog, you can define them also.&n; */
mdefine_line|#define SX_REPORT_FIFO
mdefine_line|#define SX_REPORT_OVERRUN
macro_line|#endif 
multiline_comment|/* Function prototypes */
r_static
r_void
id|sx_disable_tx_interrupts
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|sx_enable_tx_interrupts
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|sx_disable_rx_interrupts
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|sx_enable_rx_interrupts
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_int
id|sx_get_CD
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|sx_shutdown_port
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_int
id|sx_set_real_termios
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|sx_hungup
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|sx_close
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_int
id|sx_chars_in_buffer
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_int
id|sx_init_board
(paren
r_struct
id|sx_board
op_star
id|board
)paren
suffix:semicolon
r_static
r_int
id|sx_init_portstructs
(paren
r_int
id|nboards
comma
r_int
id|nports
)paren
suffix:semicolon
r_static
r_int
id|sx_fw_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|sx_init_drivers
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|sx_driver
DECL|variable|sx_callout_driver
r_static
r_struct
id|tty_driver
id|sx_driver
comma
id|sx_callout_driver
suffix:semicolon
DECL|variable|sx_table
r_static
r_struct
id|tty_struct
op_star
id|sx_table
(braket
id|SX_NPORTS
)braket
suffix:semicolon
DECL|variable|sx_termios
r_static
r_struct
id|termios
op_star
op_star
id|sx_termios
suffix:semicolon
DECL|variable|sx_termios_locked
r_static
r_struct
id|termios
op_star
op_star
id|sx_termios_locked
suffix:semicolon
DECL|variable|boards
r_static
r_struct
id|sx_board
id|boards
(braket
id|SX_NBOARDS
)braket
suffix:semicolon
DECL|variable|sx_ports
r_static
r_struct
id|sx_port
op_star
id|sx_ports
suffix:semicolon
DECL|variable|sx_refcount
r_static
r_int
id|sx_refcount
suffix:semicolon
DECL|variable|sx_initialized
r_static
r_int
id|sx_initialized
suffix:semicolon
DECL|variable|sx_nports
r_static
r_int
id|sx_nports
suffix:semicolon
DECL|variable|sx_debug
r_static
r_int
id|sx_debug
suffix:semicolon
multiline_comment|/* You can have the driver poll your card. &n;    - Set sx_poll to 1 to poll every timer tick (10ms on Intel). &n;      This is used when the card cannot use an interrupt for some reason.&n;&n;    - set sx_slowpoll to 100 to do an extra poll once a second (on Intel). If &n;      the driver misses an interrupt (report this if it DOES happen to you!)&n;      everything will continue to work.... &n; */
DECL|variable|sx_poll
r_static
r_int
id|sx_poll
op_assign
l_int|1
suffix:semicolon
DECL|variable|sx_slowpoll
r_static
r_int
id|sx_slowpoll
suffix:semicolon
multiline_comment|/* The card limits the number of interrupts per second. &n;   At 115k2 &quot;100&quot; should be sufficient. &n;   If you&squot;re using higher baudrates, you can increase this...&n; */
DECL|variable|sx_maxints
r_static
r_int
id|sx_maxints
op_assign
l_int|100
suffix:semicolon
multiline_comment|/* These are the only open spaces in my computer. Yours may have more&n;   or less.... -- REW &n;   duh: Card at 0xa0000 is possible on HP Netserver?? -- pvdl&n;*/
DECL|variable|sx_probe_addrs
r_static
r_int
id|sx_probe_addrs
(braket
)braket
op_assign
(brace
l_int|0xc0000
comma
l_int|0xd0000
comma
l_int|0xe0000
comma
l_int|0xc8000
comma
l_int|0xd8000
comma
l_int|0xe8000
)brace
suffix:semicolon
DECL|variable|si_probe_addrs
r_static
r_int
id|si_probe_addrs
(braket
)braket
op_assign
(brace
l_int|0xc0000
comma
l_int|0xd0000
comma
l_int|0xe0000
comma
l_int|0xc8000
comma
l_int|0xd8000
comma
l_int|0xe8000
comma
l_int|0xa0000
)brace
suffix:semicolon
DECL|macro|NR_SX_ADDRS
mdefine_line|#define NR_SX_ADDRS (sizeof(sx_probe_addrs)/sizeof (int))
DECL|macro|NR_SI_ADDRS
mdefine_line|#define NR_SI_ADDRS (sizeof(si_probe_addrs)/sizeof (int))
multiline_comment|/* Set the mask to all-ones. This alas, only supports 32 interrupts. &n;   Some architectures may need more. */
DECL|variable|sx_irqmask
r_static
r_int
id|sx_irqmask
op_assign
op_minus
l_int|1
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sx_probe_addrs
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|si_probe_addrs
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sx_poll
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sx_slowpoll
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sx_maxints
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sx_debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|sx_irqmask
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|sx_real_driver
r_static
r_struct
id|real_driver
id|sx_real_driver
op_assign
(brace
id|sx_disable_tx_interrupts
comma
id|sx_enable_tx_interrupts
comma
id|sx_disable_rx_interrupts
comma
id|sx_enable_rx_interrupts
comma
id|sx_get_CD
comma
id|sx_shutdown_port
comma
id|sx_set_real_termios
comma
id|sx_chars_in_buffer
comma
id|sx_close
comma
id|sx_hungup
comma
)brace
suffix:semicolon
multiline_comment|/* &n;   This driver can spew a whole lot of debugging output at you. If you&n;   need maximum performance, you should disable the DEBUG define. To&n;   aid in debugging in the field, I&squot;m leaving the compile-time debug&n;   features enabled, and disable them &quot;runtime&quot;. That allows me to&n;   instruct people with problems to enable debugging without requiring&n;   them to recompile... &n;*/
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#ifdef DEBUG
DECL|macro|sx_dprintk
mdefine_line|#define sx_dprintk(f, str...) if (sx_debug &amp; f) printk (str)
macro_line|#else
DECL|macro|sx_dprintk
mdefine_line|#define sx_dprintk(f, str...) /* nothing */
macro_line|#endif
DECL|macro|func_enter
mdefine_line|#define func_enter() sx_dprintk (SX_DEBUG_FLOW, &quot;sx: enter &quot; __FUNCTION__ &quot;&bslash;n&quot;)
DECL|macro|func_exit
mdefine_line|#define func_exit()  sx_dprintk (SX_DEBUG_FLOW, &quot;sx: exit  &quot; __FUNCTION__ &quot;&bslash;n&quot;)
DECL|macro|func_enter2
mdefine_line|#define func_enter2() sx_dprintk (SX_DEBUG_FLOW, &quot;sx: enter &quot; __FUNCTION__ &bslash;&n;                                  &quot;(port %d)&bslash;n&quot;, port-&gt;line)
multiline_comment|/* &n; *  Firmware loader driver specific routines&n; *&n; */
DECL|variable|sx_fw_fops
r_static
r_struct
id|file_operations
id|sx_fw_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|ioctl
suffix:colon
id|sx_fw_ioctl
comma
)brace
suffix:semicolon
DECL|variable|sx_fw_device
r_static
r_struct
id|miscdevice
id|sx_fw_device
op_assign
(brace
id|SXCTL_MISC_MINOR
comma
l_string|&quot;sxctl&quot;
comma
op_amp
id|sx_fw_fops
)brace
suffix:semicolon
macro_line|#ifdef SX_PARANOIA_CHECK
multiline_comment|/* This doesn&squot;t work. Who&squot;s paranoid around here? Not me! */
DECL|function|sx_paranoia_check
r_static
r_inline
r_int
id|sx_paranoia_check
c_func
(paren
r_struct
id|sx_port
r_const
op_star
id|port
comma
id|kdev_t
id|device
comma
r_const
r_char
op_star
id|routine
)paren
(brace
r_static
r_const
r_char
op_star
id|badmagic
op_assign
id|KERN_ERR
l_string|&quot;sx: Warning: bad sx port magic number for device %s in %s&bslash;n&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|badinfo
op_assign
id|KERN_ERR
l_string|&quot;sx: Warning: null sx port for device %s in %s&bslash;n&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
(brace
id|printk
c_func
(paren
id|badinfo
comma
id|kdevname
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;magic
op_ne
id|SX_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|badmagic
comma
id|kdevname
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
DECL|macro|sx_paranoia_check
mdefine_line|#define sx_paranoia_check(a,b,c) 0
macro_line|#endif
multiline_comment|/* The timeouts. First try 30 times as fast as possible. Then give&n;   the card some time to breathe between accesses. (Otherwise the&n;   processor on the card might not be able to access its OWN bus... */
DECL|macro|TIMEOUT_1
mdefine_line|#define TIMEOUT_1 30
DECL|macro|TIMEOUT_2
mdefine_line|#define TIMEOUT_2 1000000
macro_line|#ifdef DEBUG
DECL|function|my_hd
r_static
r_void
id|my_hd
(paren
r_int
r_char
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|j
comma
id|ch
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_add_assign
l_int|16
)paren
(brace
id|printk
(paren
l_string|&quot;%08x &quot;
comma
(paren
r_int
)paren
id|addr
op_plus
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
(brace
id|printk
(paren
l_string|&quot;%02x %s&quot;
comma
id|addr
(braket
id|j
op_plus
id|i
)braket
comma
(paren
id|j
op_eq
l_int|7
)paren
ques
c_cond
l_string|&quot; &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
(brace
id|ch
op_assign
id|addr
(braket
id|j
op_plus
id|i
)braket
suffix:semicolon
id|printk
(paren
l_string|&quot;%c&quot;
comma
(paren
id|ch
OL
l_int|0x20
)paren
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
(paren
(paren
id|ch
OG
l_int|0x7f
)paren
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
id|ch
)paren
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* This needs redoing for Alpha -- REW -- Done. */
DECL|function|write_sx_byte
r_static
r_inline
r_void
id|write_sx_byte
(paren
r_struct
id|sx_board
op_star
id|board
comma
r_int
id|offset
comma
id|u8
id|byte
)paren
(brace
id|writeb
(paren
id|byte
comma
id|board-&gt;base
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|read_sx_byte
r_static
r_inline
id|u8
id|read_sx_byte
(paren
r_struct
id|sx_board
op_star
id|board
comma
r_int
id|offset
)paren
(brace
r_return
id|readb
(paren
id|board-&gt;base
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|write_sx_word
r_static
r_inline
r_void
id|write_sx_word
(paren
r_struct
id|sx_board
op_star
id|board
comma
r_int
id|offset
comma
id|u16
id|word
)paren
(brace
id|writew
(paren
id|word
comma
id|board-&gt;base
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|read_sx_word
r_static
r_inline
id|u16
id|read_sx_word
(paren
r_struct
id|sx_board
op_star
id|board
comma
r_int
id|offset
)paren
(brace
r_return
id|readw
(paren
id|board-&gt;base
op_plus
id|offset
)paren
suffix:semicolon
)brace
DECL|function|sx_busy_wait_eq
r_static
r_int
id|sx_busy_wait_eq
(paren
r_struct
id|sx_board
op_star
id|board
comma
r_int
id|offset
comma
r_int
id|mask
comma
r_int
id|correctval
)paren
(brace
r_int
id|i
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
template_param
l_int|0
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|read_sx_byte
(paren
id|board
comma
id|offset
)paren
op_amp
id|mask
)paren
op_eq
id|correctval
)paren
(brace
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
template_param
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|read_sx_byte
(paren
id|board
comma
id|offset
)paren
op_amp
id|mask
)paren
op_eq
id|correctval
)paren
(brace
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|udelay
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sx_busy_wait_neq
r_static
r_int
id|sx_busy_wait_neq
(paren
r_struct
id|sx_board
op_star
id|board
comma
r_int
id|offset
comma
r_int
id|mask
comma
r_int
id|badval
)paren
(brace
r_int
id|i
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
template_param
l_int|0
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|read_sx_byte
(paren
id|board
comma
id|offset
)paren
op_amp
id|mask
)paren
op_ne
id|badval
)paren
(brace
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
template_param
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|read_sx_byte
(paren
id|board
comma
id|offset
)paren
op_amp
id|mask
)paren
op_ne
id|badval
)paren
(brace
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|udelay
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* 5.6.4 of 6210028 r2.3 */
DECL|function|sx_reset
r_static
r_int
id|sx_reset
(paren
r_struct
id|sx_board
op_star
id|board
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_SX_BOARD
(paren
id|board
)paren
)paren
(brace
id|write_sx_byte
(paren
id|board
comma
id|SX_CONFIG
comma
l_int|0
)paren
suffix:semicolon
id|write_sx_byte
(paren
id|board
comma
id|SX_RESET
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Value doesn&squot;t matter */
r_if
c_cond
(paren
op_logical_neg
id|sx_busy_wait_eq
(paren
id|board
comma
id|SX_RESET_STATUS
comma
l_int|1
comma
l_int|0
)paren
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;sx: Card doesn&squot;t respond to reset....&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|IS_EISA_BOARD
c_func
(paren
id|board
)paren
)paren
(brace
id|outb
c_func
(paren
id|board-&gt;irq
op_lshift
l_int|4
comma
id|board-&gt;eisa_base
op_plus
l_int|0xc02
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Gory details of the SI/ISA board */
id|write_sx_byte
(paren
id|board
comma
id|SI2_ISA_RESET
comma
id|SI2_ISA_RESET_SET
)paren
suffix:semicolon
id|write_sx_byte
(paren
id|board
comma
id|SI2_ISA_IRQ11
comma
id|SI2_ISA_IRQ11_CLEAR
)paren
suffix:semicolon
id|write_sx_byte
(paren
id|board
comma
id|SI2_ISA_IRQ12
comma
id|SI2_ISA_IRQ12_CLEAR
)paren
suffix:semicolon
id|write_sx_byte
(paren
id|board
comma
id|SI2_ISA_IRQ15
comma
id|SI2_ISA_IRQ15_CLEAR
)paren
suffix:semicolon
id|write_sx_byte
(paren
id|board
comma
id|SI2_ISA_INTCLEAR
comma
id|SI2_ISA_INTCLEAR_CLEAR
)paren
suffix:semicolon
id|write_sx_byte
(paren
id|board
comma
id|SI2_ISA_IRQSET
comma
id|SI2_ISA_IRQSET_CLEAR
)paren
suffix:semicolon
)brace
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* This doesn&squot;t work on machines where &quot;NULL&quot; isn&squot;t 0 */
multiline_comment|/* If you have one of those, someone will need to write &n;   the equivalent of this, which will amount to about 3 lines. I don&squot;t&n;   want to complicate this right now. -- REW&n;   (See, I do write comments every now and then :-) */
DECL|macro|OFFSETOF
mdefine_line|#define OFFSETOF(strct, elem) ((long)&amp;(((struct strct *)NULL)-&gt;elem))
DECL|macro|CHAN_OFFSET
mdefine_line|#define CHAN_OFFSET(port,elem) (port-&gt;ch_base + OFFSETOF (_SXCHANNEL, elem))
DECL|macro|MODU_OFFSET
mdefine_line|#define MODU_OFFSET(board,addr,elem)    (addr + OFFSETOF (_SXMODULE, elem))
DECL|macro|BRD_OFFSET
mdefine_line|#define  BRD_OFFSET(board,elem)                (OFFSETOF (_SXCARD, elem))
DECL|macro|sx_write_channel_byte
mdefine_line|#define sx_write_channel_byte(port, elem, val) &bslash;&n;   write_sx_byte (port-&gt;board, CHAN_OFFSET (port, elem), val)
DECL|macro|sx_read_channel_byte
mdefine_line|#define sx_read_channel_byte(port, elem) &bslash;&n;   read_sx_byte (port-&gt;board, CHAN_OFFSET (port, elem))
DECL|macro|sx_write_channel_word
mdefine_line|#define sx_write_channel_word(port, elem, val) &bslash;&n;   write_sx_word (port-&gt;board, CHAN_OFFSET (port, elem), val)
DECL|macro|sx_read_channel_word
mdefine_line|#define sx_read_channel_word(port, elem) &bslash;&n;   read_sx_word (port-&gt;board, CHAN_OFFSET (port, elem))
DECL|macro|sx_write_module_byte
mdefine_line|#define sx_write_module_byte(board, addr, elem, val) &bslash;&n;   write_sx_byte (board, MODU_OFFSET (board, addr, elem), val)
DECL|macro|sx_read_module_byte
mdefine_line|#define sx_read_module_byte(board, addr, elem) &bslash;&n;   read_sx_byte (board, MODU_OFFSET (board, addr, elem))
DECL|macro|sx_write_module_word
mdefine_line|#define sx_write_module_word(board, addr, elem, val) &bslash;&n;   write_sx_word (board, MODU_OFFSET (board, addr, elem), val)
DECL|macro|sx_read_module_word
mdefine_line|#define sx_read_module_word(board, addr, elem) &bslash;&n;   read_sx_word (board, MODU_OFFSET (board, addr, elem))
DECL|macro|sx_write_board_byte
mdefine_line|#define sx_write_board_byte(board, elem, val) &bslash;&n;   write_sx_byte (board, BRD_OFFSET (board, elem), val)
DECL|macro|sx_read_board_byte
mdefine_line|#define sx_read_board_byte(board, elem) &bslash;&n;   read_sx_byte (board, BRD_OFFSET (board, elem))
DECL|macro|sx_write_board_word
mdefine_line|#define sx_write_board_word(board, elem, val) &bslash;&n;   write_sx_word (board, BRD_OFFSET (board, elem), val)
DECL|macro|sx_read_board_word
mdefine_line|#define sx_read_board_word(board, elem) &bslash;&n;   read_sx_word (board, BRD_OFFSET (board, elem))
DECL|function|sx_start_board
r_static
r_int
id|sx_start_board
(paren
r_struct
id|sx_board
op_star
id|board
)paren
(brace
r_if
c_cond
(paren
id|IS_SX_BOARD
(paren
id|board
)paren
)paren
(brace
id|write_sx_byte
(paren
id|board
comma
id|SX_CONFIG
comma
id|SX_CONF_BUSEN
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|IS_EISA_BOARD
c_func
(paren
id|board
)paren
)paren
(brace
id|write_sx_byte
c_func
(paren
id|board
comma
id|SI2_EISA_OFF
comma
id|SI2_EISA_VAL
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|board-&gt;irq
op_lshift
l_int|4
)paren
op_or
l_int|4
comma
id|board-&gt;eisa_base
op_plus
l_int|0xc02
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Don&squot;t bug me about the clear_set. &n;&t;&t;   I haven&squot;t the foggiest idea what it&squot;s about -- REW */
id|write_sx_byte
(paren
id|board
comma
id|SI2_ISA_RESET
comma
id|SI2_ISA_RESET_CLEAR
)paren
suffix:semicolon
id|write_sx_byte
(paren
id|board
comma
id|SI2_ISA_INTCLEAR
comma
id|SI2_ISA_INTCLEAR_SET
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|SX_IRQ_REG_VAL
mdefine_line|#define SX_IRQ_REG_VAL(board) &bslash;&n;        ((board-&gt;flags &amp; SX_ISA_BOARD)?(board-&gt;irq &lt;&lt; 4):0)
multiline_comment|/* Note. The SX register is write-only. Therefore, we have to enable the&n;   bus too. This is a no-op, if you don&squot;t mess with this driver... */
DECL|function|sx_start_interrupts
r_static
r_int
id|sx_start_interrupts
(paren
r_struct
id|sx_board
op_star
id|board
)paren
(brace
multiline_comment|/* Don&squot;t call this with board-&gt;irq == 0 */
r_if
c_cond
(paren
id|IS_SX_BOARD
c_func
(paren
id|board
)paren
)paren
(brace
id|write_sx_byte
(paren
id|board
comma
id|SX_CONFIG
comma
id|SX_IRQ_REG_VAL
(paren
id|board
)paren
op_or
id|SX_CONF_BUSEN
op_or
id|SX_CONF_HOSTIRQ
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|IS_EISA_BOARD
c_func
(paren
id|board
)paren
)paren
(brace
id|inb
c_func
(paren
id|board-&gt;eisa_base
op_plus
l_int|0xc03
)paren
suffix:semicolon
)brace
r_else
(brace
r_switch
c_cond
(paren
id|board-&gt;irq
)paren
(brace
r_case
l_int|11
suffix:colon
id|write_sx_byte
(paren
id|board
comma
id|SI2_ISA_IRQ11
comma
id|SI2_ISA_IRQ11_SET
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
id|write_sx_byte
(paren
id|board
comma
id|SI2_ISA_IRQ12
comma
id|SI2_ISA_IRQ12_SET
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|15
suffix:colon
id|write_sx_byte
(paren
id|board
comma
id|SI2_ISA_IRQ15
comma
id|SI2_ISA_IRQ15_SET
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_INFO
l_string|&quot;sx: SI/XIO card doesn&squot;t support interrupt %d.&bslash;n&quot;
comma
id|board-&gt;irq
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|write_sx_byte
(paren
id|board
comma
id|SI2_ISA_INTCLEAR
comma
id|SI2_ISA_INTCLEAR_SET
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|sx_send_command
r_static
r_int
id|sx_send_command
(paren
r_struct
id|sx_port
op_star
id|port
comma
r_int
id|command
comma
r_int
id|mask
comma
r_int
id|newstat
)paren
(brace
id|func_enter2
(paren
)paren
suffix:semicolon
id|write_sx_byte
(paren
id|port-&gt;board
comma
id|CHAN_OFFSET
(paren
id|port
comma
id|hi_hstat
)paren
comma
id|command
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|sx_busy_wait_eq
(paren
id|port-&gt;board
comma
id|CHAN_OFFSET
(paren
id|port
comma
id|hi_hstat
)paren
comma
id|mask
comma
id|newstat
)paren
suffix:semicolon
)brace
DECL|function|mod_type_s
r_static
r_char
op_star
id|mod_type_s
(paren
r_int
id|module_type
)paren
(brace
r_switch
c_cond
(paren
id|module_type
)paren
(brace
r_case
id|TA4
suffix:colon
r_return
l_string|&quot;TA4&quot;
suffix:semicolon
r_case
id|TA8
suffix:colon
r_return
l_string|&quot;TA8&quot;
suffix:semicolon
r_case
id|TA4_ASIC
suffix:colon
r_return
l_string|&quot;TA4_ASIC&quot;
suffix:semicolon
r_case
id|TA8_ASIC
suffix:colon
r_return
l_string|&quot;TA8_ASIC&quot;
suffix:semicolon
r_case
id|MTA_CD1400
suffix:colon
r_return
l_string|&quot;MTA_CD1400&quot;
suffix:semicolon
r_case
id|SXDC
suffix:colon
r_return
l_string|&quot;SXDC&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;Unknown/invalid&quot;
suffix:semicolon
)brace
)brace
DECL|function|pan_type_s
r_static
r_char
op_star
id|pan_type_s
(paren
r_int
id|pan_type
)paren
(brace
r_switch
c_cond
(paren
id|pan_type
)paren
(brace
r_case
id|MOD_RS232DB25
suffix:colon
r_return
l_string|&quot;MOD_RS232DB25&quot;
suffix:semicolon
r_case
id|MOD_RS232RJ45
suffix:colon
r_return
l_string|&quot;MOD_RS232RJ45&quot;
suffix:semicolon
r_case
id|MOD_RS422DB25
suffix:colon
r_return
l_string|&quot;MOD_RS422DB25&quot;
suffix:semicolon
r_case
id|MOD_PARALLEL
suffix:colon
r_return
l_string|&quot;MOD_PARALLEL&quot;
suffix:semicolon
r_case
id|MOD_2_RS232DB25
suffix:colon
r_return
l_string|&quot;MOD_2_RS232DB25&quot;
suffix:semicolon
r_case
id|MOD_2_RS232RJ45
suffix:colon
r_return
l_string|&quot;MOD_2_RS232RJ45&quot;
suffix:semicolon
r_case
id|MOD_2_RS422DB25
suffix:colon
r_return
l_string|&quot;MOD_2_RS422DB25&quot;
suffix:semicolon
r_case
id|MOD_RS232DB25MALE
suffix:colon
r_return
l_string|&quot;MOD_RS232DB25MALE&quot;
suffix:semicolon
r_case
id|MOD_2_PARALLEL
suffix:colon
r_return
l_string|&quot;MOD_2_PARALLEL&quot;
suffix:semicolon
r_case
id|MOD_BLANK
suffix:colon
r_return
l_string|&quot;empty&quot;
suffix:semicolon
r_default
suffix:colon
r_return
l_string|&quot;invalid&quot;
suffix:semicolon
)brace
)brace
DECL|function|mod_compat_type
r_static
r_int
id|mod_compat_type
(paren
r_int
id|module_type
)paren
(brace
r_return
id|module_type
op_rshift
l_int|4
suffix:semicolon
)brace
DECL|function|sx_reconfigure_port
r_static
r_void
id|sx_reconfigure_port
c_func
(paren
r_struct
id|sx_port
op_star
id|port
)paren
(brace
r_if
c_cond
(paren
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_hstat
)paren
op_eq
id|HS_IDLE_OPEN
)paren
(brace
r_if
c_cond
(paren
id|sx_send_command
(paren
id|port
comma
id|HS_CONFIG
comma
op_minus
l_int|1
comma
id|HS_IDLE_OPEN
)paren
op_ne
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;sx: Sent reconfigure command, but card didn&squot;t react.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|sx_dprintk
(paren
id|SX_DEBUG_TERMIOS
comma
l_string|&quot;sx: Not sending reconfigure: port isn&squot;t open (%02x).&bslash;n&quot;
comma
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_hstat
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|sx_setsignals
r_static
r_void
id|sx_setsignals
(paren
r_struct
id|sx_port
op_star
id|port
comma
r_int
id|dtr
comma
r_int
id|rts
)paren
(brace
r_int
id|t
suffix:semicolon
id|func_enter2
(paren
)paren
suffix:semicolon
id|t
op_assign
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dtr
op_ge
l_int|0
)paren
id|t
op_assign
id|dtr
ques
c_cond
(paren
id|t
op_or
id|OP_DTR
)paren
suffix:colon
(paren
id|t
op_amp
op_complement
id|OP_DTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rts
op_ge
l_int|0
)paren
id|t
op_assign
id|rts
ques
c_cond
(paren
id|t
op_or
id|OP_RTS
)paren
suffix:colon
(paren
id|t
op_amp
op_complement
id|OP_RTS
)paren
suffix:semicolon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_op
comma
id|t
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_MODEMSIGNALS
comma
l_string|&quot;setsignals: %d/%d&bslash;n&quot;
comma
id|dtr
comma
id|rts
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|function|sx_getsignals
r_static
r_int
id|sx_getsignals
(paren
r_struct
id|sx_port
op_star
id|port
)paren
(brace
r_int
id|i_stat
comma
id|o_stat
suffix:semicolon
id|o_stat
op_assign
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_op
)paren
suffix:semicolon
id|i_stat
op_assign
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_ip
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_MODEMSIGNALS
comma
l_string|&quot;getsignals: %d/%d  (%d/%d) %02x/%02x&bslash;n&quot;
comma
(paren
id|o_stat
op_amp
id|OP_DTR
)paren
op_ne
l_int|0
comma
(paren
id|o_stat
op_amp
id|OP_RTS
)paren
op_ne
l_int|0
comma
id|port-&gt;c_dcd
comma
id|sx_get_CD
(paren
id|port
)paren
comma
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_ip
)paren
comma
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_state
)paren
)paren
suffix:semicolon
r_return
(paren
(paren
(paren
id|o_stat
op_amp
id|OP_DTR
)paren
ques
c_cond
id|TIOCM_DTR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|o_stat
op_amp
id|OP_RTS
)paren
ques
c_cond
id|TIOCM_RTS
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|i_stat
op_amp
id|IP_CTS
)paren
ques
c_cond
id|TIOCM_CTS
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|i_stat
op_amp
id|IP_DCD
)paren
ques
c_cond
id|TIOCM_CAR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|i_stat
op_amp
id|IP_DSR
)paren
ques
c_cond
id|TIOCM_DSR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|i_stat
op_amp
id|IP_RI
)paren
ques
c_cond
id|TIOCM_RNG
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
)brace
DECL|function|sx_set_baud
r_static
r_void
id|sx_set_baud
(paren
r_struct
id|sx_port
op_star
id|port
)paren
(brace
r_int
id|t
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;board-&gt;ta_type
op_eq
id|MOD_SXDC
)paren
(brace
r_switch
c_cond
(paren
id|port-&gt;gs.baud
)paren
(brace
multiline_comment|/* Save some typing work... */
DECL|macro|e
mdefine_line|#define e(x) case x:t= BAUD_ ## x ; break
id|e
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|75
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|110
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|150
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|300
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|600
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|1200
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|1800
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|2000
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|2400
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|4800
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|7200
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|9600
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|14400
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|19200
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|28800
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|38400
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|56000
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|57600
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|64000
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|76800
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|115200
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|128000
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|150000
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|230400
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|256000
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|460800
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|921600
)paren
suffix:semicolon
r_case
l_int|134
suffix:colon
id|t
op_assign
id|BAUD_134_5
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
id|t
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Can I return &quot;invalid&quot;? */
id|t
op_assign
id|BAUD_9600
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;sx: unsupported baud rate: %d.&bslash;n&quot;
comma
id|port-&gt;gs.baud
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
DECL|macro|e
macro_line|#undef e
r_if
c_cond
(paren
id|t
OG
l_int|0
)paren
(brace
multiline_comment|/* The baud rate is not set to 0, so we&squot;re enabeling DTR... -- REW */
id|sx_setsignals
(paren
id|port
comma
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* XXX This is not TA &amp; MTA compatible */
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_csr
comma
l_int|0xff
)paren
suffix:semicolon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_txbaud
comma
id|t
)paren
suffix:semicolon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_rxbaud
comma
id|t
)paren
suffix:semicolon
)brace
r_else
(brace
id|sx_setsignals
(paren
id|port
comma
l_int|0
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_switch
c_cond
(paren
id|port-&gt;gs.baud
)paren
(brace
DECL|macro|e
mdefine_line|#define e(x) case x:t= CSR_ ## x ; break
id|e
c_func
(paren
l_int|75
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|150
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|300
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|600
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|1200
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|2400
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|4800
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|1800
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|9600
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|19200
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|57600
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|38400
)paren
suffix:semicolon
multiline_comment|/* TA supports 110, but not 115200, MTA supports 115200, but not 110 */
r_case
l_int|110
suffix:colon
r_if
c_cond
(paren
id|port-&gt;board-&gt;ta_type
op_eq
id|MOD_TA
)paren
(brace
id|t
op_assign
id|CSR_110
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|t
op_assign
id|CSR_9600
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;sx: Unsupported baud rate: %d.&bslash;n&quot;
comma
id|port-&gt;gs.baud
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|115200
suffix:colon
r_if
c_cond
(paren
id|port-&gt;board-&gt;ta_type
op_eq
id|MOD_TA
)paren
(brace
id|t
op_assign
id|CSR_9600
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;sx: Unsupported baud rate: %d.&bslash;n&quot;
comma
id|port-&gt;gs.baud
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|t
op_assign
id|CSR_110
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
l_int|0
suffix:colon
id|t
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|t
op_assign
id|CSR_9600
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;sx: Unsupported baud rate: %d.&bslash;n&quot;
comma
id|port-&gt;gs.baud
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
DECL|macro|e
macro_line|#undef e
r_if
c_cond
(paren
id|t
op_ge
l_int|0
)paren
(brace
id|sx_setsignals
(paren
id|port
comma
l_int|1
comma
op_minus
l_int|1
)paren
suffix:semicolon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_csr
comma
id|t
op_star
l_int|0x11
)paren
suffix:semicolon
)brace
r_else
(brace
id|sx_setsignals
(paren
id|port
comma
l_int|0
comma
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Simon Allen&squot;s version of this routine was 225 lines long. 85 is a lot&n;   better. -- REW */
DECL|function|sx_set_real_termios
r_static
r_int
id|sx_set_real_termios
(paren
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|sx_port
op_star
id|port
op_assign
id|ptr
suffix:semicolon
id|func_enter2
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;gs.tty
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* What is this doing here? -- REW&n;&t;   Ha! figured it out. It is to allow you to get DTR active again&n;&t;   if you&squot;ve dropped it with stty 0. Moved to set_baud, where it&n;&t;   belongs (next to the drop dtr if baud == 0) -- REW */
multiline_comment|/* sx_setsignals (port, 1, -1); */
id|sx_set_baud
(paren
id|port
)paren
suffix:semicolon
DECL|macro|CFLAG
mdefine_line|#define CFLAG port-&gt;gs.tty-&gt;termios-&gt;c_cflag
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_mr1
comma
(paren
id|C_PARENB
(paren
id|port-&gt;gs.tty
)paren
ques
c_cond
id|MR1_WITH
suffix:colon
id|MR1_NONE
)paren
op_or
(paren
id|C_PARODD
(paren
id|port-&gt;gs.tty
)paren
ques
c_cond
id|MR1_ODD
suffix:colon
id|MR1_EVEN
)paren
op_or
(paren
id|C_CRTSCTS
c_func
(paren
id|port-&gt;gs.tty
)paren
ques
c_cond
id|MR1_RTS_RXFLOW
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
(paren
id|CFLAG
op_amp
id|CSIZE
)paren
op_eq
id|CS8
)paren
ques
c_cond
id|MR1_8_BITS
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
(paren
id|CFLAG
op_amp
id|CSIZE
)paren
op_eq
id|CS7
)paren
ques
c_cond
id|MR1_7_BITS
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
(paren
id|CFLAG
op_amp
id|CSIZE
)paren
op_eq
id|CS6
)paren
ques
c_cond
id|MR1_6_BITS
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
(paren
id|CFLAG
op_amp
id|CSIZE
)paren
op_eq
id|CS5
)paren
ques
c_cond
id|MR1_5_BITS
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_mr2
comma
(paren
id|C_CRTSCTS
c_func
(paren
id|port-&gt;gs.tty
)paren
ques
c_cond
id|MR2_CTS_TXFLOW
suffix:colon
l_int|0
)paren
op_or
(paren
id|C_CSTOPB
(paren
id|port-&gt;gs.tty
)paren
ques
c_cond
id|MR2_2_STOP
suffix:colon
id|MR2_1_STOP
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|CFLAG
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS8
suffix:colon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_mask
comma
l_int|0xff
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_mask
comma
l_int|0x7f
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_mask
comma
l_int|0x3f
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS5
suffix:colon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_mask
comma
l_int|0x1f
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_INFO
l_string|&quot;sx: Invalid wordsize: %d&bslash;n&quot;
comma
id|CFLAG
op_amp
id|CSIZE
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_prtcl
comma
(paren
id|I_IXON
(paren
id|port-&gt;gs.tty
)paren
ques
c_cond
id|SP_TXEN
suffix:colon
l_int|0
)paren
op_or
(paren
id|I_IXOFF
(paren
id|port-&gt;gs.tty
)paren
ques
c_cond
id|SP_RXEN
suffix:colon
l_int|0
)paren
op_or
(paren
id|I_IXANY
(paren
id|port-&gt;gs.tty
)paren
ques
c_cond
id|SP_TANY
suffix:colon
l_int|0
)paren
op_or
id|SP_DCEN
)paren
suffix:semicolon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_break
comma
id|I_OTHER
c_func
(paren
id|port-&gt;gs.tty
)paren
ques
c_cond
l_int|0
suffix:colon
(paren
id|I_IGNBRK
c_func
(paren
id|port-&gt;gs.tty
)paren
ques
c_cond
id|BR_IGN
suffix:colon
l_int|0
op_or
id|I_BRKINT
c_func
(paren
id|port-&gt;gs.tty
)paren
ques
c_cond
id|BR_INT
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_txon
comma
id|START_CHAR
(paren
id|port-&gt;gs.tty
)paren
)paren
suffix:semicolon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_rxon
comma
id|START_CHAR
(paren
id|port-&gt;gs.tty
)paren
)paren
suffix:semicolon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_txoff
comma
id|STOP_CHAR
(paren
id|port-&gt;gs.tty
)paren
)paren
suffix:semicolon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_rxoff
comma
id|STOP_CHAR
(paren
id|port-&gt;gs.tty
)paren
)paren
suffix:semicolon
id|sx_reconfigure_port
c_func
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* Tell line discipline whether we will do input cooking */
r_if
c_cond
(paren
id|I_OTHER
c_func
(paren
id|port-&gt;gs.tty
)paren
)paren
(brace
id|clear_bit
c_func
(paren
id|TTY_HW_COOK_IN
comma
op_amp
id|port-&gt;gs.tty-&gt;flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|set_bit
c_func
(paren
id|TTY_HW_COOK_IN
comma
op_amp
id|port-&gt;gs.tty-&gt;flags
)paren
suffix:semicolon
)brace
id|sx_dprintk
(paren
id|SX_DEBUG_TERMIOS
comma
l_string|&quot;iflags: %x(%d) &quot;
comma
id|port-&gt;gs.tty-&gt;termios-&gt;c_iflag
comma
id|I_OTHER
c_func
(paren
id|port-&gt;gs.tty
)paren
)paren
suffix:semicolon
multiline_comment|/* Tell line discipline whether we will do output cooking.&n; * If OPOST is set and no other output flags are set then we can do output&n; * processing.  Even if only *one* other flag in the O_OTHER group is set&n; * we do cooking in software.&n; */
r_if
c_cond
(paren
id|O_OPOST
c_func
(paren
id|port-&gt;gs.tty
)paren
op_logical_and
op_logical_neg
id|O_OTHER
c_func
(paren
id|port-&gt;gs.tty
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|TTY_HW_COOK_OUT
comma
op_amp
id|port-&gt;gs.tty-&gt;flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|clear_bit
c_func
(paren
id|TTY_HW_COOK_OUT
comma
op_amp
id|port-&gt;gs.tty-&gt;flags
)paren
suffix:semicolon
)brace
id|sx_dprintk
(paren
id|SX_DEBUG_TERMIOS
comma
l_string|&quot;oflags: %x(%d)&bslash;n&quot;
comma
id|port-&gt;gs.tty-&gt;termios-&gt;c_oflag
comma
id|O_OTHER
c_func
(paren
id|port-&gt;gs.tty
)paren
)paren
suffix:semicolon
multiline_comment|/* port-&gt;c_dcd = sx_get_CD (port); */
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ********************************************************************** *&n; *                   the interrupt related routines                       *&n; * ********************************************************************** */
multiline_comment|/* Note:&n;   Other drivers use the macro &quot;MIN&quot; to calculate how much to copy.&n;   This has the disadvantage that it will evaluate parts twice. That&squot;s&n;   expensive when it&squot;s IO (and the compiler cannot optimize those away!).&n;   Moreover, I&squot;m not sure that you&squot;re race-free. &n;&n;   I assign a value, and then only allow the value to decrease. This&n;   is always safe. This makes the code a few lines longer, and you&n;   know I&squot;m dead against that, but I think it is required in this&n;   case.  */
DECL|function|sx_transmit_chars
r_static
r_void
id|sx_transmit_chars
(paren
r_struct
id|sx_port
op_star
id|port
)paren
(brace
r_int
id|c
suffix:semicolon
r_int
id|tx_ip
suffix:semicolon
r_int
id|txroom
suffix:semicolon
id|func_enter2
(paren
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_TRANSMIT
comma
l_string|&quot;Port %p: transmit %d chars&bslash;n&quot;
comma
id|port
comma
id|port-&gt;gs.xmit_cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
(paren
id|SX_PORT_TRANSMIT_LOCK
comma
op_amp
id|port-&gt;locks
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|c
op_assign
id|port-&gt;gs.xmit_cnt
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_TRANSMIT
comma
l_string|&quot;Copying %d &quot;
comma
id|c
)paren
suffix:semicolon
id|tx_ip
op_assign
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_txipos
)paren
suffix:semicolon
multiline_comment|/* Took me 5 minutes to deduce this formula. &n;&t;&t;   Luckily it is literally in the manual in section 6.5.4.3.5 */
id|txroom
op_assign
(paren
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_txopos
)paren
op_minus
id|tx_ip
op_minus
l_int|1
)paren
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* Don&squot;t copy more bytes than there is room for in the buffer */
r_if
c_cond
(paren
id|c
OG
id|txroom
)paren
id|c
op_assign
id|txroom
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_TRANSMIT
comma
l_string|&quot; %d(%d) &quot;
comma
id|c
comma
id|txroom
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t copy past the end of the hardware transmit buffer */
r_if
c_cond
(paren
id|c
OG
l_int|0x100
op_minus
id|tx_ip
)paren
id|c
op_assign
l_int|0x100
op_minus
id|tx_ip
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_TRANSMIT
comma
l_string|&quot; %d(%d) &quot;
comma
id|c
comma
l_int|0x100
op_minus
id|tx_ip
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t copy pas the end of the source buffer */
r_if
c_cond
(paren
id|c
OG
id|SERIAL_XMIT_SIZE
op_minus
id|port-&gt;gs.xmit_tail
)paren
id|c
op_assign
id|SERIAL_XMIT_SIZE
op_minus
id|port-&gt;gs.xmit_tail
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_TRANSMIT
comma
l_string|&quot; %d(%ld) &bslash;n&quot;
comma
id|c
comma
id|SERIAL_XMIT_SIZE
op_minus
id|port-&gt;gs.xmit_tail
)paren
suffix:semicolon
multiline_comment|/* If for one reason or another, we can&squot;t copy more data, we&squot;re done! */
r_if
c_cond
(paren
id|c
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|memcpy_toio
(paren
id|port-&gt;board-&gt;base
op_plus
id|CHAN_OFFSET
c_func
(paren
id|port
comma
id|hi_txbuf
)paren
op_plus
id|tx_ip
comma
id|port-&gt;gs.xmit_buf
op_plus
id|port-&gt;gs.xmit_tail
comma
id|c
)paren
suffix:semicolon
multiline_comment|/* Update the pointer in the card */
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_txipos
comma
(paren
id|tx_ip
op_plus
id|c
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* Update the kernel buffer end */
id|port-&gt;gs.xmit_tail
op_assign
(paren
id|port-&gt;gs.xmit_tail
op_plus
id|c
)paren
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* This one last. (this is essential)&n;&t;&t;   It would allow others to start putting more data into the buffer! */
id|port-&gt;gs.xmit_cnt
op_sub_assign
id|c
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;gs.xmit_cnt
op_eq
l_int|0
)paren
(brace
id|sx_disable_tx_interrupts
(paren
id|port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|port-&gt;gs.xmit_cnt
op_le
id|port-&gt;gs.wakeup_chars
)paren
op_logical_and
id|port-&gt;gs.tty
)paren
(brace
r_if
c_cond
(paren
(paren
id|port-&gt;gs.tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|port-&gt;gs.tty-&gt;ldisc.write_wakeup
)paren
(paren
id|port-&gt;gs.tty-&gt;ldisc.write_wakeup
)paren
(paren
id|port-&gt;gs.tty
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_TRANSMIT
comma
l_string|&quot;Waking up.... ldisc (%d)....&bslash;n&quot;
comma
id|port-&gt;gs.wakeup_chars
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|port-&gt;gs.tty-&gt;write_wait
)paren
suffix:semicolon
)brace
id|clear_bit
(paren
id|SX_PORT_TRANSMIT_LOCK
comma
op_amp
id|port-&gt;locks
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Note the symmetry between receiving chars and transmitting them!&n;   Note: The kernel should have implemented both a receive buffer and&n;   a transmit buffer. */
multiline_comment|/* Inlined: Called only once. Remove the inline when you add another call */
DECL|function|sx_receive_chars
r_static
r_inline
r_void
id|sx_receive_chars
(paren
r_struct
id|sx_port
op_star
id|port
)paren
(brace
r_int
id|c
suffix:semicolon
r_int
id|rx_op
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
id|func_enter2
(paren
)paren
suffix:semicolon
id|tty
op_assign
id|port-&gt;gs.tty
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|rx_op
op_assign
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_rxopos
)paren
suffix:semicolon
id|c
op_assign
(paren
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_rxipos
)paren
op_minus
id|rx_op
)paren
op_amp
l_int|0xff
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_RECEIVE
comma
l_string|&quot;rxop=%d, c = %d.&bslash;n&quot;
comma
id|rx_op
comma
id|c
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t copy more bytes than there is room for in the buffer */
r_if
c_cond
(paren
id|tty-&gt;flip.count
op_plus
id|c
OG
id|TTY_FLIPBUF_SIZE
)paren
id|c
op_assign
id|TTY_FLIPBUF_SIZE
op_minus
id|tty-&gt;flip.count
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_RECEIVE
comma
l_string|&quot;c = %d.&bslash;n&quot;
comma
id|c
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t copy past the end of the hardware receive buffer */
r_if
c_cond
(paren
id|rx_op
op_plus
id|c
OG
l_int|0x100
)paren
id|c
op_assign
l_int|0x100
op_minus
id|rx_op
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_RECEIVE
comma
l_string|&quot;c = %d.&bslash;n&quot;
comma
id|c
)paren
suffix:semicolon
multiline_comment|/* If for one reason or another, we can&squot;t copy more data, we&squot;re done! */
r_if
c_cond
(paren
id|c
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_RECEIVE
comma
l_string|&quot;Copying over %d chars. First is %d at %lx&bslash;n&quot;
comma
id|c
comma
id|read_sx_byte
(paren
id|port-&gt;board
comma
id|CHAN_OFFSET
c_func
(paren
id|port
comma
id|hi_rxbuf
)paren
op_plus
id|rx_op
)paren
comma
id|CHAN_OFFSET
c_func
(paren
id|port
comma
id|hi_rxbuf
)paren
)paren
suffix:semicolon
id|memcpy_fromio
(paren
id|tty-&gt;flip.char_buf_ptr
comma
id|port-&gt;board-&gt;base
op_plus
id|CHAN_OFFSET
c_func
(paren
id|port
comma
id|hi_rxbuf
)paren
op_plus
id|rx_op
comma
id|c
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tty-&gt;flip.flag_buf_ptr
comma
id|TTY_NORMAL
comma
id|c
)paren
suffix:semicolon
multiline_comment|/* Update the kernel buffer end */
id|tty-&gt;flip.count
op_add_assign
id|c
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_add_assign
id|c
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_add_assign
id|c
suffix:semicolon
multiline_comment|/* This one last. ( Not essential.)&n;&t;&t;   It allows the card to start putting more data into the buffer! &n;&t;&t;   Update the pointer in the card */
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_rxopos
comma
(paren
id|rx_op
op_plus
id|c
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|copied
op_add_assign
id|c
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copied
)paren
(brace
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_RECEIVE
comma
l_string|&quot;pushing flipq port %d (%3d chars): %d.%06d  (%d/%d)&bslash;n&quot;
comma
id|port-&gt;line
comma
id|copied
comma
(paren
r_int
)paren
(paren
id|tv.tv_sec
op_mod
l_int|60
)paren
comma
(paren
r_int
)paren
id|tv.tv_usec
comma
id|tty-&gt;raw
comma
id|tty-&gt;real_raw
)paren
suffix:semicolon
multiline_comment|/* Tell the rest of the system the news. Great news. New characters! */
id|tty_flip_buffer_push
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/*    tty_schedule_flip (tty); */
)brace
id|func_exit
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Inlined: it is called only once. Remove the inline if you add another &n;   call */
DECL|function|sx_check_modem_signals
r_static
r_inline
r_void
id|sx_check_modem_signals
(paren
r_struct
id|sx_port
op_star
id|port
)paren
(brace
r_int
id|hi_state
suffix:semicolon
r_int
id|c_dcd
suffix:semicolon
id|hi_state
op_assign
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_state
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_MODEMSIGNALS
comma
l_string|&quot;Checking modem signals (%d/%d)&bslash;n&quot;
comma
id|port-&gt;c_dcd
comma
id|sx_get_CD
(paren
id|port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hi_state
op_amp
id|ST_BREAK
)paren
(brace
id|hi_state
op_and_assign
op_complement
id|ST_BREAK
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_MODEMSIGNALS
comma
l_string|&quot;got a break.&bslash;n&quot;
)paren
suffix:semicolon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_state
comma
id|hi_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;gs.flags
op_amp
id|ASYNC_SAK
)paren
(brace
id|do_SAK
(paren
id|port-&gt;gs.tty
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|hi_state
op_amp
id|ST_DCD
)paren
(brace
id|hi_state
op_and_assign
op_complement
id|ST_DCD
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_MODEMSIGNALS
comma
l_string|&quot;got a DCD change.&bslash;n&quot;
)paren
suffix:semicolon
id|sx_write_channel_byte
(paren
id|port
comma
id|hi_state
comma
id|hi_state
)paren
suffix:semicolon
id|c_dcd
op_assign
id|sx_get_CD
(paren
id|port
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_MODEMSIGNALS
comma
l_string|&quot;DCD is now %d&bslash;n&quot;
comma
id|c_dcd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c_dcd
op_ne
id|port-&gt;c_dcd
)paren
(brace
id|port-&gt;c_dcd
op_assign
id|c_dcd
suffix:semicolon
r_if
c_cond
(paren
id|sx_get_CD
(paren
id|port
)paren
)paren
(brace
multiline_comment|/* DCD went UP */
r_if
c_cond
(paren
(paren
op_complement
(paren
id|port-&gt;gs.flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
op_logical_or
op_complement
(paren
id|port-&gt;gs.flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
)paren
op_logical_and
(paren
id|sx_read_channel_byte
c_func
(paren
id|port
comma
id|hi_hstat
)paren
op_ne
id|HS_IDLE_CLOSED
)paren
)paren
(brace
multiline_comment|/* Are we blocking in open?*/
id|sx_dprintk
(paren
id|SX_DEBUG_MODEMSIGNALS
comma
l_string|&quot;DCD active, unblocking open&bslash;n&quot;
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|port-&gt;gs.open_wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|sx_dprintk
(paren
id|SX_DEBUG_MODEMSIGNALS
comma
l_string|&quot;DCD raised. Ignoring.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* DCD went down! */
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|port-&gt;gs.flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|port-&gt;gs.flags
op_amp
id|ASYNC_CALLOUT_NOHUP
)paren
)paren
)paren
(brace
id|sx_dprintk
(paren
id|SX_DEBUG_MODEMSIGNALS
comma
l_string|&quot;DCD dropped. hanging up....&bslash;n&quot;
)paren
suffix:semicolon
id|tty_hangup
(paren
id|port-&gt;gs.tty
)paren
suffix:semicolon
)brace
r_else
(brace
id|sx_dprintk
(paren
id|SX_DEBUG_MODEMSIGNALS
comma
l_string|&quot;DCD dropped. ignoring.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|sx_dprintk
(paren
id|SX_DEBUG_MODEMSIGNALS
comma
l_string|&quot;Hmmm. card told us DCD changed, but it didn&squot;t.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* This is what an interrupt routine should look like. &n; * Small, elegant, clear.&n; */
DECL|function|sx_interrupt
r_static
r_void
id|sx_interrupt
(paren
r_int
id|irq
comma
r_void
op_star
id|ptr
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|sx_board
op_star
id|board
op_assign
id|ptr
suffix:semicolon
r_struct
id|sx_port
op_star
id|port
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*   func_enter ();  */
id|sx_dprintk
(paren
id|SX_DEBUG_FLOW
comma
l_string|&quot;sx: enter sx_interrupt (%d/%d)&bslash;n&quot;
comma
id|irq
comma
id|board-&gt;irq
)paren
suffix:semicolon
multiline_comment|/* AAargh! The order in which to do these things is essential and&n;&t;   not trivial. &n;&n;&t;   - Rate limit goes before &quot;recursive&quot;. Otherwise a series of&n;&t;     recursive calls will hang the machine in the interrupt routine. &n;&n;&t;   - hardware twiddling goes before &quot;recursive&quot;. Otherwise when we&n;&t;     poll the card, and a recursive interrupt happens, we wont&n;&t;     ack the card, so it might keep on interrupting us. (especially&n;&t;     level sensitive interrupt systems like PCI).&n;&n;&t;   - Rate limit goes before hardware twiddling. Otherwise we won&squot;t&n;&t;     catch a card that has gone bonkers.&n;&n;&t;   - The &quot;initialized&quot; test goes after the hardware twiddling. Otherwise&n;&t;     the card will stick us in the interrupt routine again.&n;&n;&t;   - The initialized test goes before recursive. &n;&t;*/
macro_line|#ifdef IRQ_RATE_LIMIT
multiline_comment|/* Aaargh! I&squot;m ashamed. This costs more lines-of-code than the&n;&t;   actual interrupt routine!. (Well, used to when I wrote that comment) */
(brace
r_static
r_int
id|lastjif
suffix:semicolon
r_static
r_int
id|nintr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lastjif
op_eq
id|jiffies
)paren
(brace
r_if
c_cond
(paren
op_increment
id|nintr
OG
id|IRQ_RATE_LIMIT
)paren
(brace
id|free_irq
(paren
id|board-&gt;irq
comma
id|board
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;sx: Too many interrupts. Turning off interrupt %d.&bslash;n&quot;
comma
id|board-&gt;irq
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|lastjif
op_assign
id|jiffies
suffix:semicolon
id|nintr
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|board-&gt;irq
op_eq
id|irq
)paren
(brace
multiline_comment|/* Tell the card we&squot;ve noticed the interrupt. */
id|sx_write_board_word
(paren
id|board
comma
id|cc_int_pending
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_SX_BOARD
(paren
id|board
)paren
)paren
(brace
id|write_sx_byte
(paren
id|board
comma
id|SX_RESET_IRQ
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|IS_EISA_BOARD
c_func
(paren
id|board
)paren
)paren
(brace
id|inb
c_func
(paren
id|board-&gt;eisa_base
op_plus
l_int|0xc03
)paren
suffix:semicolon
id|write_sx_word
c_func
(paren
id|board
comma
l_int|8
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|write_sx_byte
(paren
id|board
comma
id|SI2_ISA_INTCLEAR
comma
id|SI2_ISA_INTCLEAR_CLEAR
)paren
suffix:semicolon
id|write_sx_byte
(paren
id|board
comma
id|SI2_ISA_INTCLEAR
comma
id|SI2_ISA_INTCLEAR_SET
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|sx_initialized
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|board-&gt;flags
op_amp
id|SX_BOARD_INITIALIZED
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
(paren
id|SX_BOARD_INTR_LOCK
comma
op_amp
id|board-&gt;locks
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;Recursive interrupt! (%d)&bslash;n&quot;
comma
id|board-&gt;irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|board-&gt;nports
suffix:semicolon
id|i
op_increment
)paren
(brace
id|port
op_assign
op_amp
id|board-&gt;ports
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;gs.flags
op_amp
id|GS_ACTIVE
)paren
(brace
r_if
c_cond
(paren
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_state
)paren
)paren
(brace
id|sx_dprintk
(paren
id|SX_DEBUG_INTERRUPTS
comma
l_string|&quot;Port %d: modem signal change?... &bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|sx_check_modem_signals
(paren
id|port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;gs.xmit_cnt
)paren
(brace
id|sx_transmit_chars
(paren
id|port
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|port-&gt;gs.flags
op_amp
id|SX_RX_THROTTLE
)paren
)paren
(brace
id|sx_receive_chars
(paren
id|port
)paren
suffix:semicolon
)brace
)brace
)brace
id|clear_bit
(paren
id|SX_BOARD_INTR_LOCK
comma
op_amp
id|board-&gt;locks
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_FLOW
comma
l_string|&quot;sx: exit sx_interrupt (%d/%d)&bslash;n&quot;
comma
id|irq
comma
id|board-&gt;irq
)paren
suffix:semicolon
multiline_comment|/*  func_exit ();  */
)brace
DECL|function|sx_pollfunc
r_static
r_void
id|sx_pollfunc
(paren
r_int
r_int
id|data
)paren
(brace
r_struct
id|sx_board
op_star
id|board
op_assign
(paren
r_struct
id|sx_board
op_star
)paren
id|data
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
id|sx_interrupt
(paren
l_int|0
comma
id|board
comma
l_int|NULL
)paren
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|board-&gt;timer
)paren
suffix:semicolon
id|board-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|sx_poll
suffix:semicolon
id|add_timer
(paren
op_amp
id|board-&gt;timer
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* ********************************************************************** *&n; *                Here are the routines that actually                     *&n; *              interface with the generic_serial driver                  *&n; * ********************************************************************** */
multiline_comment|/* Ehhm. I don&squot;t know how to fiddle with interrupts on the SX card. --REW */
multiline_comment|/* Hmm. Ok I figured it out. You don&squot;t.  */
DECL|function|sx_disable_tx_interrupts
r_static
r_void
id|sx_disable_tx_interrupts
(paren
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|sx_port
op_star
id|port
op_assign
id|ptr
suffix:semicolon
id|func_enter2
c_func
(paren
)paren
suffix:semicolon
id|port-&gt;gs.flags
op_and_assign
op_complement
id|GS_TX_INTEN
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|sx_enable_tx_interrupts
r_static
r_void
id|sx_enable_tx_interrupts
(paren
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|sx_port
op_star
id|port
op_assign
id|ptr
suffix:semicolon
r_int
id|data_in_buffer
suffix:semicolon
id|func_enter2
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* First transmit the characters that we&squot;re supposed to */
id|sx_transmit_chars
(paren
id|port
)paren
suffix:semicolon
multiline_comment|/* The sx card will never interrupt us if we don&squot;t fill the buffer&n;&t;   past 25%. So we keep considering interrupts off if that&squot;s the case. */
id|data_in_buffer
op_assign
(paren
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_txipos
)paren
op_minus
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_txopos
)paren
)paren
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* XXX Must be &quot;HIGH_WATER&quot; for SI card according to doc. */
r_if
c_cond
(paren
id|data_in_buffer
OL
id|LOW_WATER
)paren
id|port-&gt;gs.flags
op_and_assign
op_complement
id|GS_TX_INTEN
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|sx_disable_rx_interrupts
r_static
r_void
id|sx_disable_rx_interrupts
(paren
r_void
op_star
id|ptr
)paren
(brace
multiline_comment|/*  struct sx_port *port = ptr; */
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|sx_enable_rx_interrupts
r_static
r_void
id|sx_enable_rx_interrupts
(paren
r_void
op_star
id|ptr
)paren
(brace
multiline_comment|/*  struct sx_port *port = ptr; */
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Jeez. Isn&squot;t this simple? */
DECL|function|sx_get_CD
r_static
r_int
id|sx_get_CD
(paren
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|sx_port
op_star
id|port
op_assign
id|ptr
suffix:semicolon
id|func_enter2
c_func
(paren
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
(paren
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_ip
)paren
op_amp
id|IP_DCD
)paren
op_ne
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* Jeez. Isn&squot;t this simple? */
DECL|function|sx_chars_in_buffer
r_static
r_int
id|sx_chars_in_buffer
(paren
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|sx_port
op_star
id|port
op_assign
id|ptr
suffix:semicolon
id|func_enter2
c_func
(paren
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
(paren
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_txipos
)paren
op_minus
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_txopos
)paren
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
DECL|function|sx_shutdown_port
r_static
r_void
id|sx_shutdown_port
(paren
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|sx_port
op_star
id|port
op_assign
id|ptr
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|port-&gt;gs.flags
op_and_assign
op_complement
id|GS_ACTIVE
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;gs.tty
op_logical_and
(paren
id|port-&gt;gs.tty-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
)paren
(brace
id|sx_setsignals
(paren
id|port
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|sx_reconfigure_port
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* ********************************************************************** *&n; *                Here are the routines that actually                     *&n; *               interface with the rest of the system                    *&n; * ********************************************************************** */
DECL|function|sx_open
r_static
r_int
id|sx_open
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|sx_port
op_star
id|port
suffix:semicolon
r_int
id|retval
comma
id|line
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sx_initialized
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|line
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_OPEN
comma
l_string|&quot;%d: opening line %d. tty=%p ctty=%p, np=%d)&bslash;n&quot;
comma
id|current-&gt;pid
comma
id|line
comma
id|tty
comma
id|current-&gt;tty
comma
id|sx_nports
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|line
OL
l_int|0
)paren
op_logical_or
(paren
id|line
op_ge
id|SX_NPORTS
)paren
op_logical_or
(paren
id|line
op_ge
id|sx_nports
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|port
op_assign
op_amp
id|sx_ports
(braket
id|line
)braket
suffix:semicolon
id|port-&gt;c_dcd
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Make sure that the first interrupt doesn&squot;t detect a&n;&t;                    1 -&gt; 0 transition. */
id|sx_dprintk
(paren
id|SX_DEBUG_OPEN
comma
l_string|&quot;port = %p c_dcd = %d&bslash;n&quot;
comma
id|port
comma
id|port-&gt;c_dcd
)paren
suffix:semicolon
id|tty-&gt;driver_data
op_assign
id|port
suffix:semicolon
id|port-&gt;gs.tty
op_assign
id|tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;gs.count
)paren
id|MOD_INC_USE_COUNT
suffix:semicolon
id|port-&gt;gs.count
op_increment
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_OPEN
comma
l_string|&quot;starting port&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Start up serial port&n;&t; */
id|retval
op_assign
id|gs_init_port
c_func
(paren
op_amp
id|port-&gt;gs
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_OPEN
comma
l_string|&quot;done gs_init&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|port-&gt;gs.count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;gs.count
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
id|port-&gt;gs.flags
op_or_assign
id|GS_ACTIVE
suffix:semicolon
id|sx_setsignals
(paren
id|port
comma
l_int|1
comma
l_int|1
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|sx_debug
op_amp
id|SX_DEBUG_OPEN
)paren
id|my_hd
(paren
(paren
r_int
r_char
op_star
)paren
id|port
comma
r_sizeof
(paren
op_star
id|port
)paren
)paren
suffix:semicolon
macro_line|#else
r_if
c_cond
(paren
id|sx_debug
op_amp
id|SX_DEBUG_OPEN
)paren
id|my_hd
(paren
(paren
r_int
r_char
op_star
)paren
id|port-&gt;board-&gt;base
op_plus
id|port-&gt;ch_base
comma
r_sizeof
(paren
op_star
id|port
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|sx_send_command
(paren
id|port
comma
id|HS_LOPEN
comma
op_minus
l_int|1
comma
id|HS_IDLE_OPEN
)paren
op_ne
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;sx: Card didn&squot;t respond to LOPEN command.&bslash;n&quot;
)paren
suffix:semicolon
id|port-&gt;gs.count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;gs.count
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|retval
op_assign
id|gs_block_til_ready
c_func
(paren
id|port
comma
id|filp
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_OPEN
comma
l_string|&quot;Block til ready returned %d. Count=%d&bslash;n&quot;
comma
id|retval
comma
id|port-&gt;gs.count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
multiline_comment|/* &n;&t;&t; * Don&squot;t lower gs.count here because sx_close() will be called later&n;&t;&t; */
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* tty-&gt;low_latency = 1; */
r_if
c_cond
(paren
(paren
id|port-&gt;gs.count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|port-&gt;gs.flags
op_amp
id|ASYNC_SPLIT_TERMIOS
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_NORMAL
)paren
op_star
id|tty-&gt;termios
op_assign
id|port-&gt;gs.normal_termios
suffix:semicolon
r_else
op_star
id|tty-&gt;termios
op_assign
id|port-&gt;gs.callout_termios
suffix:semicolon
id|sx_set_real_termios
(paren
id|port
)paren
suffix:semicolon
)brace
id|port-&gt;gs.session
op_assign
id|current-&gt;session
suffix:semicolon
id|port-&gt;gs.pgrp
op_assign
id|current-&gt;pgrp
suffix:semicolon
id|port-&gt;c_dcd
op_assign
id|sx_get_CD
(paren
id|port
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_OPEN
comma
l_string|&quot;at open: cd=%d&bslash;n&quot;
comma
id|port-&gt;c_dcd
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* I haven&squot;t the foggiest why the decrement use count has to happen&n;   here. The whole linux serial drivers stuff needs to be redesigned.&n;   My guess is that this is a hack to minimize the impact of a bug&n;   elsewhere. Thinking about it some more. (try it sometime) Try&n;   running minicom on a serial port that is driven by a modularized&n;   driver. Have the modem hangup. Then remove the driver module. Then&n;   exit minicom.  I expect an &quot;oops&quot;.  -- REW */
DECL|function|sx_hungup
r_static
r_void
id|sx_hungup
(paren
r_void
op_star
id|ptr
)paren
(brace
multiline_comment|/*&n;&t;struct sx_port *port = ptr; &n;  */
id|func_enter
(paren
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t force the SX card to close. mgetty doesn&squot;t like it !!!!!! -- pvdl */
multiline_comment|/* For some reson we added this code. Don&squot;t know why anymore ;-( -- pvdl */
multiline_comment|/*&n;&t;sx_setsignals (port, 0, 0);&n;&t;sx_reconfigure_port(port);&t;&n;&t;sx_send_command (port, HS_CLOSE, 0, 0);&n;&n;&t;if (sx_read_channel_byte (port, hi_hstat) != HS_IDLE_CLOSED) {&n;&t;&t;if (sx_send_command (port, HS_FORCE_CLOSED, -1, HS_IDLE_CLOSED) != 1) {&n;&t;&t;&t;printk (KERN_ERR &n;&t;&t;&t;        &quot;sx: sent the force_close command, but card didn&squot;t react&bslash;n&quot;);&n;&t;&t;} else&n;&t;&t;&t;sx_dprintk (SX_DEBUG_CLOSE, &quot;sent the force_close command.&bslash;n&quot;);&n;&t;}&n;&t;*/
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|function|sx_close
r_static
r_void
id|sx_close
(paren
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|sx_port
op_star
id|port
op_assign
id|ptr
suffix:semicolon
multiline_comment|/* Give the port 5 seconds to close down. */
r_int
id|to
op_assign
l_int|5
op_star
id|HZ
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
id|sx_setsignals
(paren
id|port
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|sx_reconfigure_port
c_func
(paren
id|port
)paren
suffix:semicolon
id|sx_send_command
(paren
id|port
comma
id|HS_CLOSE
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_while
c_loop
(paren
id|to
op_decrement
op_logical_and
(paren
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_hstat
)paren
op_ne
id|HS_IDLE_CLOSED
)paren
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_if
c_cond
(paren
id|sx_read_channel_byte
(paren
id|port
comma
id|hi_hstat
)paren
op_ne
id|HS_IDLE_CLOSED
)paren
(brace
r_if
c_cond
(paren
id|sx_send_command
(paren
id|port
comma
id|HS_FORCE_CLOSED
comma
op_minus
l_int|1
comma
id|HS_IDLE_CLOSED
)paren
op_ne
l_int|1
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;sx: sent the force_close command, but card didn&squot;t react&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|sx_dprintk
(paren
id|SX_DEBUG_CLOSE
comma
l_string|&quot;sent the force_close command.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|sx_dprintk
(paren
id|SX_DEBUG_CLOSE
comma
l_string|&quot;waited %d jiffies for close. count=%d&bslash;n&quot;
comma
l_int|5
op_star
id|HZ
op_minus
id|to
op_minus
l_int|1
comma
id|port-&gt;gs.count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|port-&gt;gs.count
)paren
(brace
id|sx_dprintk
c_func
(paren
id|SX_DEBUG_CLOSE
comma
l_string|&quot;WARNING port count:%d&bslash;n&quot;
comma
id|port-&gt;gs.count
)paren
suffix:semicolon
id|port-&gt;gs.count
op_assign
l_int|0
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This is relatively thorough. But then again it is only 20 lines. */
DECL|macro|MARCHUP
mdefine_line|#define MARCHUP    for (i=min;i&lt;max;i++) 
DECL|macro|MARCHDOWN
mdefine_line|#define MARCHDOWN  for (i=max-1;i&gt;=min;i--)
DECL|macro|W0
mdefine_line|#define W0         write_sx_byte (board, i, 0x55)
DECL|macro|W1
mdefine_line|#define W1         write_sx_byte (board, i, 0xaa)
DECL|macro|R0
mdefine_line|#define R0         if (read_sx_byte (board, i) != 0x55) return 1
DECL|macro|R1
mdefine_line|#define R1         if (read_sx_byte (board, i) != 0xaa) return 1
multiline_comment|/* This memtest takes a human-noticable time. You normally only do it&n;   once a boot, so I guess that it is worth it. */
DECL|function|do_memtest
r_static
r_int
id|do_memtest
(paren
r_struct
id|sx_board
op_star
id|board
comma
r_int
id|min
comma
r_int
id|max
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/* This is a marchb. Theoretically, marchb catches much more than&n;&t;   simpler tests. In practise, the longer test just catches more&n;&t;   intermittent errors. -- REW&n;&t;   (For the theory behind memory testing see: &n;&t;   Testing Semiconductor Memories by A.J. van de Goor.) */
id|MARCHUP
(brace
id|W0
suffix:semicolon
)brace
id|MARCHUP
(brace
id|R0
suffix:semicolon
id|W1
suffix:semicolon
id|R1
suffix:semicolon
id|W0
suffix:semicolon
id|R0
suffix:semicolon
id|W1
suffix:semicolon
)brace
id|MARCHUP
(brace
id|R1
suffix:semicolon
id|W0
suffix:semicolon
id|W1
suffix:semicolon
)brace
id|MARCHDOWN
(brace
id|R1
suffix:semicolon
id|W0
suffix:semicolon
id|W1
suffix:semicolon
id|W0
suffix:semicolon
)brace
id|MARCHDOWN
(brace
id|R0
suffix:semicolon
id|W1
suffix:semicolon
id|W0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|MARCHUP
macro_line|#undef MARCHUP
DECL|macro|MARCHDOWN
macro_line|#undef MARCHDOWN
DECL|macro|W0
macro_line|#undef W0
DECL|macro|W1
macro_line|#undef W1
DECL|macro|R0
macro_line|#undef R0
DECL|macro|R1
macro_line|#undef R1
DECL|macro|MARCHUP
mdefine_line|#define MARCHUP    for (i=min;i&lt;max;i+=2) 
DECL|macro|MARCHDOWN
mdefine_line|#define MARCHDOWN  for (i=max-1;i&gt;=min;i-=2)
DECL|macro|W0
mdefine_line|#define W0         write_sx_word (board, i, 0x55aa)
DECL|macro|W1
mdefine_line|#define W1         write_sx_word (board, i, 0xaa55)
DECL|macro|R0
mdefine_line|#define R0         if (read_sx_word (board, i) != 0x55aa) return 1
DECL|macro|R1
mdefine_line|#define R1         if (read_sx_word (board, i) != 0xaa55) return 1
multiline_comment|/* This memtest takes a human-noticable time. You normally only do it&n;   once a boot, so I guess that it is worth it. */
DECL|function|do_memtest_w
r_static
r_int
id|do_memtest_w
(paren
r_struct
id|sx_board
op_star
id|board
comma
r_int
id|min
comma
r_int
id|max
)paren
(brace
r_int
id|i
suffix:semicolon
id|MARCHUP
(brace
id|W0
suffix:semicolon
)brace
id|MARCHUP
(brace
id|R0
suffix:semicolon
id|W1
suffix:semicolon
id|R1
suffix:semicolon
id|W0
suffix:semicolon
id|R0
suffix:semicolon
id|W1
suffix:semicolon
)brace
id|MARCHUP
(brace
id|R1
suffix:semicolon
id|W0
suffix:semicolon
id|W1
suffix:semicolon
)brace
id|MARCHDOWN
(brace
id|R1
suffix:semicolon
id|W0
suffix:semicolon
id|W1
suffix:semicolon
id|W0
suffix:semicolon
)brace
id|MARCHDOWN
(brace
id|R0
suffix:semicolon
id|W1
suffix:semicolon
id|W0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sx_fw_ioctl
r_static
r_int
id|sx_fw_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
op_star
id|descr
op_assign
(paren
r_int
op_star
)paren
id|arg
comma
id|i
suffix:semicolon
r_static
r_struct
id|sx_board
op_star
id|board
op_assign
l_int|NULL
suffix:semicolon
r_int
id|nbytes
comma
id|offset
comma
id|data
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0 
multiline_comment|/* Removed superuser check: Sysops can use the permissions on the device&n;&t;   file to restrict access. Recommendation: Root only. (root.root 600) */
r_if
c_cond
(paren
op_logical_neg
id|suser
(paren
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
macro_line|#endif
id|sx_dprintk
(paren
id|SX_DEBUG_FIRMWARE
comma
l_string|&quot;IOCTL %x: %lx&bslash;n&quot;
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|board
)paren
id|board
op_assign
op_amp
id|boards
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|board-&gt;flags
op_amp
id|SX_BOARD_PRESENT
)paren
(brace
id|sx_dprintk
(paren
id|SX_DEBUG_FIRMWARE
comma
l_string|&quot;Board present! (%x)&bslash;n&quot;
comma
id|board-&gt;flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|sx_dprintk
(paren
id|SX_DEBUG_FIRMWARE
comma
l_string|&quot;Board not present! (%x) all:&quot;
comma
id|board-&gt;flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SX_NBOARDS
suffix:semicolon
id|i
op_increment
)paren
id|sx_dprintk
(paren
id|SX_DEBUG_FIRMWARE
comma
l_string|&quot;&lt;%x&gt; &quot;
comma
id|boards
(braket
id|i
)braket
dot
id|flags
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_FIRMWARE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SXIO_SET_BOARD
suffix:colon
id|sx_dprintk
(paren
id|SX_DEBUG_FIRMWARE
comma
l_string|&quot;set board to %ld&bslash;n&quot;
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
OG
id|SX_NBOARDS
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_FIRMWARE
comma
l_string|&quot;not out of range&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|boards
(braket
id|arg
)braket
dot
id|flags
op_amp
id|SX_BOARD_PRESENT
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_FIRMWARE
comma
l_string|&quot;.. and present!&bslash;n&quot;
)paren
suffix:semicolon
id|board
op_assign
op_amp
id|boards
(braket
id|arg
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SXIO_GET_TYPE
suffix:colon
id|rc
op_assign
op_minus
id|ENOENT
suffix:semicolon
multiline_comment|/* If we manage to miss one, return error. */
r_if
c_cond
(paren
id|IS_SX_BOARD
(paren
id|board
)paren
)paren
id|rc
op_assign
id|SX_TYPE_SX
suffix:semicolon
r_if
c_cond
(paren
id|IS_CF_BOARD
(paren
id|board
)paren
)paren
id|rc
op_assign
id|SX_TYPE_CF
suffix:semicolon
r_if
c_cond
(paren
id|IS_SI_BOARD
(paren
id|board
)paren
)paren
id|rc
op_assign
id|SX_TYPE_SI
suffix:semicolon
r_if
c_cond
(paren
id|IS_EISA_BOARD
(paren
id|board
)paren
)paren
id|rc
op_assign
id|SX_TYPE_SI
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_FIRMWARE
comma
l_string|&quot;returning type= %d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SXIO_DO_RAMTEST
suffix:colon
r_if
c_cond
(paren
id|sx_initialized
)paren
multiline_comment|/* Already initialized: better not ramtest the board.  */
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|IS_SX_BOARD
(paren
id|board
)paren
)paren
(brace
id|rc
op_assign
id|do_memtest
(paren
id|board
comma
l_int|0
comma
l_int|0x7000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
id|rc
op_assign
id|do_memtest
(paren
id|board
comma
l_int|0
comma
l_int|0x7000
)paren
suffix:semicolon
multiline_comment|/*if (!rc) rc = do_memtest_w (board, 0, 0x7000);*/
)brace
r_else
(brace
id|rc
op_assign
id|do_memtest
(paren
id|board
comma
l_int|0
comma
l_int|0x7ff8
)paren
suffix:semicolon
multiline_comment|/* if (!rc) rc = do_memtest_w (board, 0, 0x7ff8); */
)brace
id|sx_dprintk
(paren
id|SX_DEBUG_FIRMWARE
comma
l_string|&quot;returning memtest result= %d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SXIO_DOWNLOAD
suffix:colon
r_if
c_cond
(paren
id|sx_initialized
)paren
multiline_comment|/* Already initialized */
r_return
op_minus
id|EEXIST
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sx_reset
(paren
id|board
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_INIT
comma
l_string|&quot;reset the board...&bslash;n&quot;
)paren
suffix:semicolon
id|tmp
op_assign
id|kmalloc
(paren
id|SX_CHUNK_SIZE
comma
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|Get_user
(paren
id|nbytes
comma
id|descr
op_increment
)paren
suffix:semicolon
id|Get_user
(paren
id|offset
comma
id|descr
op_increment
)paren
suffix:semicolon
id|Get_user
(paren
id|data
comma
id|descr
op_increment
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nbytes
op_logical_and
id|data
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nbytes
suffix:semicolon
id|i
op_add_assign
id|SX_CHUNK_SIZE
)paren
(brace
id|copy_from_user
(paren
id|tmp
comma
(paren
r_char
op_star
)paren
id|data
op_plus
id|i
comma
(paren
id|i
op_plus
id|SX_CHUNK_SIZE
OG
id|nbytes
)paren
ques
c_cond
id|nbytes
op_minus
id|i
suffix:colon
id|SX_CHUNK_SIZE
)paren
suffix:semicolon
id|memcpy_toio
(paren
(paren
r_char
op_star
)paren
(paren
id|board-&gt;base2
op_plus
id|offset
op_plus
id|i
)paren
comma
id|tmp
comma
(paren
id|i
op_plus
id|SX_CHUNK_SIZE
OG
id|nbytes
)paren
ques
c_cond
id|nbytes
op_minus
id|i
suffix:colon
id|SX_CHUNK_SIZE
)paren
suffix:semicolon
)brace
id|Get_user
(paren
id|nbytes
comma
id|descr
op_increment
)paren
suffix:semicolon
id|Get_user
(paren
id|offset
comma
id|descr
op_increment
)paren
suffix:semicolon
id|Get_user
(paren
id|data
comma
id|descr
op_increment
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|tmp
)paren
suffix:semicolon
id|sx_nports
op_add_assign
id|sx_init_board
(paren
id|board
)paren
suffix:semicolon
id|rc
op_assign
id|sx_nports
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SXIO_INIT
suffix:colon
r_if
c_cond
(paren
id|sx_initialized
)paren
multiline_comment|/* Already initialized */
r_return
op_minus
id|EEXIST
suffix:semicolon
multiline_comment|/* This is not allowed until all boards are initialized... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SX_NBOARDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|boards
(braket
id|i
)braket
dot
id|flags
op_amp
id|SX_BOARD_PRESENT
)paren
op_logical_and
op_logical_neg
(paren
id|boards
(braket
id|i
)braket
dot
id|flags
op_amp
id|SX_BOARD_INITIALIZED
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SX_NBOARDS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|boards
(braket
id|i
)braket
dot
id|flags
op_amp
id|SX_BOARD_PRESENT
)paren
)paren
r_break
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_FIRMWARE
comma
l_string|&quot;initing portstructs, %d boards, &quot;
l_string|&quot;%d channels, first board: %d ports&bslash;n&quot;
comma
id|i
comma
id|sx_nports
comma
id|boards
(braket
l_int|0
)braket
dot
id|nports
)paren
suffix:semicolon
id|rc
op_assign
id|sx_init_portstructs
(paren
id|i
comma
id|sx_nports
)paren
suffix:semicolon
id|sx_init_drivers
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_ge
l_int|0
)paren
id|sx_initialized
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SXIO_SETDEBUG
suffix:colon
id|sx_debug
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SXIO_GETDEBUG
suffix:colon
id|rc
op_assign
id|sx_debug
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SXIO_GETGSDEBUG
suffix:colon
r_case
id|SXIO_SETGSDEBUG
suffix:colon
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SXIO_GETNPORTS
suffix:colon
id|rc
op_assign
id|sx_nports
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;Unknown ioctl on firmware device (%x).&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|sx_ioctl
r_static
r_int
id|sx_ioctl
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|rc
suffix:semicolon
r_struct
id|sx_port
op_star
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|ival
suffix:semicolon
multiline_comment|/* func_enter2(); */
id|rc
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCGSOFTCAR
suffix:colon
id|rc
op_assign
id|Put_user
c_func
(paren
(paren
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSSOFTCAR
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|Get_user
c_func
(paren
id|ival
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|tty-&gt;termios-&gt;c_cflag
op_assign
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
op_complement
id|CLOCAL
)paren
op_or
(paren
id|ival
ques
c_cond
id|CLOCAL
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCGSERIAL
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|gs_getserial
c_func
(paren
op_amp
id|port-&gt;gs
comma
(paren
r_struct
id|serial_struct
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSSERIAL
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|rc
op_assign
id|gs_setserial
c_func
(paren
op_amp
id|port-&gt;gs
comma
(paren
r_struct
id|serial_struct
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMGET
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|ival
op_assign
id|sx_getsignals
c_func
(paren
id|port
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|Get_user
c_func
(paren
id|ival
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|sx_setsignals
c_func
(paren
id|port
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
l_int|1
suffix:colon
op_minus
l_int|1
)paren
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
l_int|1
suffix:colon
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|sx_reconfigure_port
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMBIC
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|Get_user
c_func
(paren
id|ival
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|sx_setsignals
c_func
(paren
id|port
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
)paren
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|sx_reconfigure_port
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|Get_user
c_func
(paren
id|ival
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|sx_setsignals
c_func
(paren
id|port
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|sx_reconfigure_port
c_func
(paren
id|port
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|rc
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* func_exit(); */
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* The throttle/unthrottle scheme for the Specialix card is different&n; * from other drivers and deserves some explanation. &n; * The Specialix hardware takes care of XON/XOFF&n; * and CTS/RTS flow control itself.  This means that all we have to&n; * do when signalled by the upper tty layer to throttle/unthrottle is&n; * to make a note of it here.  When we come to read characters from the&n; * rx buffers on the card (sx_receive_chars()) we look to see if the&n; * upper layer can accept more (as noted here in sx_rx_throt[]). &n; * If it can&squot;t we simply don&squot;t remove chars from the cards buffer. &n; * When the tty layer can accept chars, we again note that here and when&n; * sx_receive_chars() is called it will remove them from the cards buffer.&n; * The card will notice that a ports buffer has drained below some low&n; * water mark and will unflow control the line itself, using whatever&n; * flow control scheme is in use for that port. -- Simon Allen&n; */
DECL|function|sx_throttle
r_static
r_void
id|sx_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|sx_port
op_star
id|port
op_assign
(paren
r_struct
id|sx_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|func_enter2
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If the port is using any type of input flow&n;&t; * control then throttle the port.&n;&t; */
r_if
c_cond
(paren
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
op_logical_or
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
)paren
(brace
id|port-&gt;gs.flags
op_or_assign
id|SX_RX_THROTTLE
suffix:semicolon
)brace
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|sx_unthrottle
r_static
r_void
id|sx_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|sx_port
op_star
id|port
op_assign
(paren
r_struct
id|sx_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|func_enter2
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Always unthrottle even if flow control is not enabled on&n;&t; * this port in case we disabled flow control while the port&n;&t; * was throttled&n;&t; */
id|port-&gt;gs.flags
op_and_assign
op_complement
id|SX_RX_THROTTLE
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* ********************************************************************** *&n; *                    Here are the initialization routines.               *&n; * ********************************************************************** */
DECL|function|sx_init_board
r_static
r_int
id|sx_init_board
(paren
r_struct
id|sx_board
op_star
id|board
)paren
(brace
r_int
id|addr
suffix:semicolon
r_int
id|chans
suffix:semicolon
r_int
id|type
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* This is preceded by downloading the download code. */
id|board-&gt;flags
op_or_assign
id|SX_BOARD_INITIALIZED
suffix:semicolon
r_if
c_cond
(paren
id|read_sx_byte
(paren
id|board
comma
l_int|0
)paren
)paren
multiline_comment|/* CF boards may need this. */
id|write_sx_byte
c_func
(paren
id|board
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* This resets the processor again, to make sure it didn&squot;t do any&n;&t;   foolish things while we were downloading the image */
r_if
c_cond
(paren
op_logical_neg
id|sx_reset
(paren
id|board
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|sx_start_board
(paren
id|board
)paren
suffix:semicolon
id|udelay
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sx_busy_wait_neq
(paren
id|board
comma
l_int|0
comma
l_int|0xff
comma
l_int|0
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;sx: Ooops. Board won&squot;t initialize.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Ok. So now the processor on the card is running. It gathered&n;&t;   some info for us... */
id|sx_dprintk
(paren
id|SX_DEBUG_INIT
comma
l_string|&quot;The sxcard structure:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sx_debug
op_amp
id|SX_DEBUG_INIT
)paren
id|my_hd
(paren
(paren
r_char
op_star
)paren
(paren
id|board-&gt;base
)paren
comma
l_int|0x10
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_INIT
comma
l_string|&quot;the first sx_module structure:&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sx_debug
op_amp
id|SX_DEBUG_INIT
)paren
id|my_hd
(paren
(paren
r_char
op_star
)paren
(paren
id|board-&gt;base
op_plus
l_int|0x80
)paren
comma
l_int|0x30
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_INIT
comma
l_string|&quot;init_status: %x, %dk memory, firmware V%x.%02x,&bslash;n&quot;
comma
id|read_sx_byte
(paren
id|board
comma
l_int|0
)paren
comma
id|read_sx_byte
c_func
(paren
id|board
comma
l_int|1
)paren
comma
id|read_sx_byte
(paren
id|board
comma
l_int|5
)paren
comma
id|read_sx_byte
c_func
(paren
id|board
comma
l_int|4
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_sx_byte
(paren
id|board
comma
l_int|0
)paren
op_eq
l_int|0xff
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;sx: No modules found. Sorry.&bslash;n&quot;
)paren
suffix:semicolon
id|board-&gt;nports
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|chans
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|IS_SX_BOARD
c_func
(paren
id|board
)paren
)paren
(brace
id|sx_write_board_word
(paren
id|board
comma
id|cc_int_count
comma
id|sx_maxints
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|sx_maxints
)paren
id|sx_write_board_word
(paren
id|board
comma
id|cc_int_count
comma
id|SI_PROCESSOR_CLOCK
op_div
l_int|8
op_div
id|sx_maxints
)paren
suffix:semicolon
)brace
multiline_comment|/* grab the first module type... */
multiline_comment|/*  board-&gt;ta_type = mod_compat_type (read_sx_byte (board, 0x80 + 0x08)); */
id|board-&gt;ta_type
op_assign
id|mod_compat_type
(paren
id|sx_read_module_byte
(paren
id|board
comma
l_int|0x80
comma
id|mc_chip
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX byteorder */
r_for
c_loop
(paren
id|addr
op_assign
l_int|0x80
suffix:semicolon
id|addr
op_ne
l_int|0
suffix:semicolon
id|addr
op_assign
id|read_sx_word
(paren
id|board
comma
id|addr
)paren
op_amp
l_int|0x7fff
)paren
(brace
id|type
op_assign
id|sx_read_module_byte
(paren
id|board
comma
id|addr
comma
id|mc_chip
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_INIT
comma
l_string|&quot;Module at %x: %d channels&bslash;n&quot;
comma
id|addr
comma
id|read_sx_byte
(paren
id|board
comma
id|addr
op_plus
l_int|2
)paren
)paren
suffix:semicolon
id|chans
op_add_assign
id|sx_read_module_byte
(paren
id|board
comma
id|addr
comma
id|mc_type
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_INIT
comma
l_string|&quot;module is an %s, which has %s/%s panels&bslash;n&quot;
comma
id|mod_type_s
(paren
id|type
)paren
comma
id|pan_type_s
(paren
id|sx_read_module_byte
(paren
id|board
comma
id|addr
comma
id|mc_mods
)paren
op_amp
l_int|0xf
)paren
comma
id|pan_type_s
(paren
id|sx_read_module_byte
(paren
id|board
comma
id|addr
comma
id|mc_mods
)paren
op_rshift
l_int|4
)paren
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_INIT
comma
l_string|&quot;CD1400 versions: %x/%x, ASIC version: %x&bslash;n&quot;
comma
id|sx_read_module_byte
(paren
id|board
comma
id|addr
comma
id|mc_rev1
)paren
comma
id|sx_read_module_byte
(paren
id|board
comma
id|addr
comma
id|mc_rev2
)paren
comma
id|sx_read_module_byte
(paren
id|board
comma
id|addr
comma
id|mc_mtaasic_rev
)paren
)paren
suffix:semicolon
multiline_comment|/* The following combinations are illegal: It should theoretically&n;&t;&t;   work, but timing problems make the bus HANG. */
r_if
c_cond
(paren
id|mod_compat_type
(paren
id|type
)paren
op_ne
id|board-&gt;ta_type
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;sx: This is an invalid configuration.&bslash;n&quot;
l_string|&quot;Don&squot;t mix TA/MTA/SXDC on the same hostadapter.&bslash;n&quot;
)paren
suffix:semicolon
id|chans
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|IS_EISA_BOARD
c_func
(paren
id|board
)paren
op_logical_or
id|IS_SI_BOARD
c_func
(paren
id|board
)paren
)paren
op_logical_and
(paren
id|mod_compat_type
c_func
(paren
id|type
)paren
op_eq
l_int|4
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;sx: This is an invalid configuration.&bslash;n&quot;
l_string|&quot;Don&squot;t use SXDCs on an SI/XIO adapter.&bslash;n&quot;
)paren
suffix:semicolon
id|chans
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#if 0 /* Problem fixed: firmware 3.05 */
r_if
c_cond
(paren
id|IS_SX_BOARD
c_func
(paren
id|board
)paren
op_logical_and
(paren
id|type
op_eq
id|TA8
)paren
)paren
(brace
multiline_comment|/* There are some issues with the firmware and the DCD/RTS&n;&t;&t;&t;   lines. It might work if you tie them together or something.&n;&t;&t;&t;   It might also work if you get a newer sx_firmware.&t;Therefore&n;&t;&t;&t;   this is just a warning. */
id|printk
(paren
id|KERN_WARNING
l_string|&quot;sx: The SX host doesn&squot;t work too well &quot;
l_string|&quot;with the TA8 adapters.&bslash;nSpecialix is working on it.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
r_if
c_cond
(paren
id|chans
)paren
(brace
multiline_comment|/* board-&gt;flags |= SX_BOARD_PRESENT; */
r_if
c_cond
(paren
id|board-&gt;irq
OG
l_int|0
)paren
(brace
multiline_comment|/* fixed irq, probably PCI */
r_if
c_cond
(paren
id|sx_irqmask
op_amp
(paren
l_int|1
op_lshift
id|board-&gt;irq
)paren
)paren
(brace
multiline_comment|/* may we use this irq? */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|board-&gt;irq
comma
id|sx_interrupt
comma
id|SA_SHIRQ
op_or
id|SA_INTERRUPT
comma
l_string|&quot;sx&quot;
comma
id|board
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sx: Cannot allocate irq %d.&bslash;n&quot;
comma
id|board-&gt;irq
)paren
suffix:semicolon
id|board-&gt;irq
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
id|board-&gt;irq
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|board-&gt;irq
OL
l_int|0
op_logical_and
id|sx_irqmask
)paren
(brace
multiline_comment|/* auto-allocate irq */
r_int
id|irqnr
suffix:semicolon
r_int
id|irqmask
op_assign
id|sx_irqmask
op_amp
(paren
id|IS_SX_BOARD
c_func
(paren
id|board
)paren
ques
c_cond
id|SX_ISA_IRQ_MASK
suffix:colon
id|SI2_ISA_IRQ_MASK
)paren
suffix:semicolon
r_for
c_loop
(paren
id|irqnr
op_assign
l_int|15
suffix:semicolon
id|irqnr
OG
l_int|0
suffix:semicolon
id|irqnr
op_decrement
)paren
r_if
c_cond
(paren
id|irqmask
op_amp
(paren
l_int|1
op_lshift
id|irqnr
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
id|request_irq
c_func
(paren
id|irqnr
comma
id|sx_interrupt
comma
id|SA_SHIRQ
op_or
id|SA_INTERRUPT
comma
l_string|&quot;sx&quot;
comma
id|board
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|irqnr
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sx: Cannot allocate IRQ.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|board-&gt;irq
op_assign
id|irqnr
suffix:semicolon
)brace
r_else
id|board-&gt;irq
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|board-&gt;irq
)paren
(brace
multiline_comment|/* Found a valid interrupt, start up interrupts! */
id|sx_dprintk
(paren
id|SX_DEBUG_INIT
comma
l_string|&quot;Using irq %d.&bslash;n&quot;
comma
id|board-&gt;irq
)paren
suffix:semicolon
id|sx_start_interrupts
(paren
id|board
)paren
suffix:semicolon
id|board-&gt;poll
op_assign
id|sx_slowpoll
suffix:semicolon
id|board-&gt;flags
op_or_assign
id|SX_IRQ_ALLOCATED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* no irq: setup board for polled operation */
id|board-&gt;poll
op_assign
id|sx_poll
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_INIT
comma
l_string|&quot;Using poll-interval %d.&bslash;n&quot;
comma
id|board-&gt;poll
)paren
suffix:semicolon
)brace
multiline_comment|/* The timer should be initialized anyway: That way we can safely&n;&t;&t;&t; del_timer it when the module is unloaded. */
id|init_timer
(paren
op_amp
id|board-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|board-&gt;poll
)paren
(brace
id|board-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|board
suffix:semicolon
id|board-&gt;timer.function
op_assign
id|sx_pollfunc
suffix:semicolon
id|board-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|board-&gt;poll
suffix:semicolon
id|add_timer
(paren
op_amp
id|board-&gt;timer
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|board-&gt;irq
op_assign
l_int|0
suffix:semicolon
)brace
id|board-&gt;nports
op_assign
id|chans
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_INIT
comma
l_string|&quot;returning %d ports.&quot;
comma
id|board-&gt;nports
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
id|chans
suffix:semicolon
)brace
DECL|function|printheader
r_static
r_void
id|printheader
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|header_printed
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|header_printed
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;Specialix SX driver &quot;
l_string|&quot;(C) 1998/1999 R.E.Wolff@BitWizard.nl &bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;sx: version %s&bslash;n&quot;
comma
id|RCS_ID
)paren
suffix:semicolon
id|header_printed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|probe_sx
r_static
r_int
id|probe_sx
(paren
r_struct
id|sx_board
op_star
id|board
)paren
(brace
r_struct
id|vpd_prom
id|vpdp
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_CF_BOARD
(paren
id|board
)paren
)paren
(brace
id|sx_dprintk
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;Going to verify vpd prom at %x.&bslash;n&quot;
comma
id|board-&gt;base
op_plus
id|SX_VPD_ROM
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sx_debug
op_amp
id|SX_DEBUG_PROBE
)paren
id|my_hd
(paren
(paren
r_char
op_star
)paren
(paren
id|board-&gt;base
op_plus
id|SX_VPD_ROM
)paren
comma
l_int|0x40
)paren
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
op_amp
id|vpdp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
r_struct
id|vpd_prom
)paren
suffix:semicolon
id|i
op_increment
)paren
op_star
id|p
op_increment
op_assign
id|read_sx_byte
(paren
id|board
comma
id|SX_VPD_ROM
op_plus
id|i
op_star
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sx_debug
op_amp
id|SX_DEBUG_PROBE
)paren
id|my_hd
(paren
(paren
r_char
op_star
)paren
op_amp
id|vpdp
comma
l_int|0x20
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;checking identifier...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strncmp
(paren
id|vpdp.identifier
comma
id|SX_VPD_IDENT_STRING
comma
l_int|16
)paren
op_ne
l_int|0
)paren
(brace
id|sx_dprintk
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;Got non-SX identifier: &squot;%s&squot;&bslash;n&quot;
comma
id|vpdp.identifier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|printheader
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_CF_BOARD
(paren
id|board
)paren
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;sx: Found an SX board at %x&bslash;n&quot;
comma
id|board-&gt;hw_base
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;sx: hw_rev: %d, assembly level: %d, uniq ID:%08x, &quot;
comma
id|vpdp.hwrev
comma
id|vpdp.hwass
comma
id|vpdp.uniqid
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Manufactured: %d/%d&bslash;n&quot;
comma
l_int|1970
op_plus
id|vpdp.myear
comma
id|vpdp.mweek
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
(paren
id|vpdp.uniqid
op_rshift
l_int|24
)paren
op_amp
id|SX_UNIQUEID_MASK
)paren
op_ne
id|SX_PCI_UNIQUEID1
)paren
op_logical_and
(paren
(paren
(paren
id|vpdp.uniqid
op_rshift
l_int|24
)paren
op_amp
id|SX_UNIQUEID_MASK
)paren
op_ne
id|SX_ISA_UNIQUEID1
)paren
)paren
(brace
multiline_comment|/* This might be a bit harsh. This was the primary reason the&n;&t;&t;&t;   SX/ISA card didn&squot;t work at first... */
id|printk
(paren
id|KERN_ERR
l_string|&quot;sx: Hmm. Not an SX/PCI or SX/ISA card. Sorry: giving up.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|vpdp.uniqid
op_rshift
l_int|24
)paren
op_amp
id|SX_UNIQUEID_MASK
)paren
op_eq
id|SX_ISA_UNIQUEID1
)paren
(brace
r_if
c_cond
(paren
id|board-&gt;base
op_amp
l_int|0x8000
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;sx: Warning: There may be hardware problems with the card at %x.&bslash;n&quot;
comma
id|board-&gt;base
)paren
suffix:semicolon
id|printk
(paren
id|KERN_WARNING
l_string|&quot;sx: Read sx.txt for more info.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
id|board-&gt;nports
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* This resets the processor, and keeps it off the bus. */
r_if
c_cond
(paren
op_logical_neg
id|sx_reset
(paren
id|board
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_INIT
comma
l_string|&quot;reset the board...&bslash;n&quot;
)paren
suffix:semicolon
id|board-&gt;flags
op_or_assign
id|SX_BOARD_PRESENT
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Specialix probes for this card at 32k increments from 640k to 16M.&n;   I consider machines with less than 16M unlikely nowadays, so I&squot;m&n;   not probing above 1Mb. Also, 0xa0000, 0xb0000, are taken by the VGA&n;   card. 0xe0000 and 0xf0000 are taken by the BIOS. That only leaves &n;   0xc0000, 0xc8000, 0xd0000 and 0xd8000 . */
DECL|function|probe_si
r_static
r_int
id|probe_si
(paren
r_struct
id|sx_board
op_star
id|board
)paren
(brace
r_int
id|i
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;Going to verify SI signature %x.&bslash;n&quot;
comma
id|board-&gt;base
op_plus
id|SI2_ISA_ID_BASE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sx_debug
op_amp
id|SX_DEBUG_PROBE
)paren
id|my_hd
(paren
(paren
r_char
op_star
)paren
(paren
id|board-&gt;base
op_plus
id|SI2_ISA_ID_BASE
)paren
comma
l_int|0x8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_EISA_BOARD
c_func
(paren
id|board
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|read_sx_byte
(paren
id|board
comma
id|SI2_ISA_ID_BASE
op_plus
l_int|7
op_minus
id|i
)paren
op_amp
l_int|7
)paren
op_ne
id|i
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|printheader
(paren
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;sx: Found an SI board at %x&bslash;n&quot;
comma
id|board-&gt;hw_base
)paren
suffix:semicolon
multiline_comment|/* Compared to the SX boards, it is a complete guess as to what&n;&t;&t; this card is up to... */
id|board-&gt;nports
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* This resets the processor, and keeps it off the bus. */
r_if
c_cond
(paren
op_logical_neg
id|sx_reset
(paren
id|board
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_INIT
comma
l_string|&quot;reset the board...&bslash;n&quot;
)paren
suffix:semicolon
id|board-&gt;flags
op_or_assign
id|SX_BOARD_PRESENT
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|sx_init_drivers
r_static
r_int
id|sx_init_drivers
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|sx_driver
comma
l_int|0
comma
r_sizeof
(paren
id|sx_driver
)paren
)paren
suffix:semicolon
id|sx_driver.magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
id|sx_driver.driver_name
op_assign
l_string|&quot;specialix_sx&quot;
suffix:semicolon
id|sx_driver.name
op_assign
l_string|&quot;ttyX&quot;
suffix:semicolon
id|sx_driver.major
op_assign
id|SX_NORMAL_MAJOR
suffix:semicolon
id|sx_driver.num
op_assign
id|sx_nports
suffix:semicolon
id|sx_driver.type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
id|sx_driver.subtype
op_assign
id|SX_TYPE_NORMAL
suffix:semicolon
id|sx_driver.init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|sx_driver.init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
id|sx_driver.flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
id|sx_driver.refcount
op_assign
op_amp
id|sx_refcount
suffix:semicolon
id|sx_driver.table
op_assign
id|sx_table
suffix:semicolon
id|sx_driver.termios
op_assign
id|sx_termios
suffix:semicolon
id|sx_driver.termios_locked
op_assign
id|sx_termios_locked
suffix:semicolon
id|sx_driver.open
op_assign
id|sx_open
suffix:semicolon
id|sx_driver.close
op_assign
id|gs_close
suffix:semicolon
id|sx_driver.write
op_assign
id|gs_write
suffix:semicolon
id|sx_driver.put_char
op_assign
id|gs_put_char
suffix:semicolon
id|sx_driver.flush_chars
op_assign
id|gs_flush_chars
suffix:semicolon
id|sx_driver.write_room
op_assign
id|gs_write_room
suffix:semicolon
id|sx_driver.chars_in_buffer
op_assign
id|gs_chars_in_buffer
suffix:semicolon
id|sx_driver.flush_buffer
op_assign
id|gs_flush_buffer
suffix:semicolon
id|sx_driver.ioctl
op_assign
id|sx_ioctl
suffix:semicolon
id|sx_driver.throttle
op_assign
id|sx_throttle
suffix:semicolon
id|sx_driver.unthrottle
op_assign
id|sx_unthrottle
suffix:semicolon
id|sx_driver.set_termios
op_assign
id|gs_set_termios
suffix:semicolon
id|sx_driver.stop
op_assign
id|gs_stop
suffix:semicolon
id|sx_driver.start
op_assign
id|gs_start
suffix:semicolon
id|sx_driver.hangup
op_assign
id|gs_hangup
suffix:semicolon
id|sx_callout_driver
op_assign
id|sx_driver
suffix:semicolon
id|sx_callout_driver.name
op_assign
l_string|&quot;cux&quot;
suffix:semicolon
id|sx_callout_driver.major
op_assign
id|SX_CALLOUT_MAJOR
suffix:semicolon
id|sx_callout_driver.subtype
op_assign
id|SX_TYPE_CALLOUT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|tty_register_driver
c_func
(paren
op_amp
id|sx_driver
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sx: Couldn&squot;t register sx driver, error = %d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|tty_register_driver
c_func
(paren
op_amp
id|sx_callout_driver
)paren
)paren
)paren
(brace
id|tty_unregister_driver
c_func
(paren
op_amp
id|sx_driver
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;sx: Couldn&squot;t register sx callout driver, error = %d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ckmalloc
r_static
r_void
op_star
id|ckmalloc
(paren
r_int
id|size
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
id|p
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|sx_init_portstructs
r_static
r_int
id|sx_init_portstructs
(paren
r_int
id|nboards
comma
r_int
id|nports
)paren
(brace
r_struct
id|sx_board
op_star
id|board
suffix:semicolon
r_struct
id|sx_port
op_star
id|port
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|addr
comma
id|chans
suffix:semicolon
r_int
id|portno
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Many drivers statically allocate the maximum number of ports&n;&t;   There is no reason not to allocate them dynamically. Is there? -- REW */
id|sx_ports
op_assign
id|ckmalloc
c_func
(paren
id|nports
op_star
r_sizeof
(paren
r_struct
id|sx_port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sx_ports
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|sx_termios
op_assign
id|ckmalloc
c_func
(paren
id|nports
op_star
r_sizeof
(paren
r_struct
id|termios
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sx_termios
)paren
(brace
id|kfree
(paren
id|sx_ports
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|sx_termios_locked
op_assign
id|ckmalloc
c_func
(paren
id|nports
op_star
r_sizeof
(paren
r_struct
id|termios
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sx_termios_locked
)paren
(brace
id|kfree
(paren
id|sx_ports
)paren
suffix:semicolon
id|kfree
(paren
id|sx_termios
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/* Adjust the values in the &quot;driver&quot; */
id|sx_driver.termios
op_assign
id|sx_termios
suffix:semicolon
id|sx_driver.termios_locked
op_assign
id|sx_termios_locked
suffix:semicolon
id|port
op_assign
id|sx_ports
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nboards
suffix:semicolon
id|i
op_increment
)paren
(brace
id|board
op_assign
op_amp
id|boards
(braket
id|i
)braket
suffix:semicolon
id|board-&gt;ports
op_assign
id|port
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|boards
(braket
id|i
)braket
dot
id|nports
suffix:semicolon
id|j
op_increment
)paren
(brace
id|sx_dprintk
(paren
id|SX_DEBUG_INIT
comma
l_string|&quot;initing port %d&bslash;n&quot;
comma
id|j
)paren
suffix:semicolon
id|port-&gt;gs.callout_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|port-&gt;gs.normal_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|port-&gt;gs.magic
op_assign
id|SX_MAGIC
suffix:semicolon
id|port-&gt;gs.close_delay
op_assign
id|HZ
op_div
l_int|2
suffix:semicolon
id|port-&gt;gs.closing_wait
op_assign
l_int|30
op_star
id|HZ
suffix:semicolon
id|port-&gt;board
op_assign
id|board
suffix:semicolon
id|port-&gt;gs.rd
op_assign
op_amp
id|sx_real_driver
suffix:semicolon
macro_line|#ifdef NEW_WRITE_LOCKING
id|port-&gt;gs.port_write_sem
op_assign
id|MUTEX
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t;&t; * Initializing wait queue&n;&t;&t;&t; */
id|init_waitqueue_head
c_func
(paren
op_amp
id|port-&gt;gs.open_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|port-&gt;gs.close_wait
)paren
suffix:semicolon
id|port
op_increment
suffix:semicolon
)brace
)brace
id|port
op_assign
id|sx_ports
suffix:semicolon
id|portno
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nboards
suffix:semicolon
id|i
op_increment
)paren
(brace
id|board
op_assign
op_amp
id|boards
(braket
id|i
)braket
suffix:semicolon
id|board-&gt;port_base
op_assign
id|portno
suffix:semicolon
multiline_comment|/* Possibly the configuration was rejected. */
id|sx_dprintk
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;Board has %d channels&bslash;n&quot;
comma
id|board-&gt;nports
)paren
suffix:semicolon
r_if
c_cond
(paren
id|board-&gt;nports
op_le
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* XXX byteorder ?? */
r_for
c_loop
(paren
id|addr
op_assign
l_int|0x80
suffix:semicolon
id|addr
op_ne
l_int|0
suffix:semicolon
id|addr
op_assign
id|read_sx_word
(paren
id|board
comma
id|addr
)paren
op_amp
l_int|0x7fff
)paren
(brace
id|chans
op_assign
id|sx_read_module_byte
(paren
id|board
comma
id|addr
comma
id|mc_type
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;Module at %x: %d channels&bslash;n&quot;
comma
id|addr
comma
id|chans
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;Port at&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|chans
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* The &quot;sx-way&quot; is the way it SHOULD be done. That way in the &n;&t;&t;&t;&t;   future, the firmware may for example pack the structures a bit&n;&t;&t;&t;&t;   more efficient. Neil tells me it isn&squot;t going to happen anytime&n;&t;&t;&t;&t;   soon though. */
r_if
c_cond
(paren
id|IS_SX_BOARD
c_func
(paren
id|board
)paren
)paren
id|port-&gt;ch_base
op_assign
id|sx_read_module_word
(paren
id|board
comma
id|addr
op_plus
id|j
op_star
l_int|2
comma
id|mc_chan_pointer
)paren
suffix:semicolon
r_else
id|port-&gt;ch_base
op_assign
id|addr
op_plus
l_int|0x100
op_plus
l_int|0x300
op_star
id|j
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot; %x&quot;
comma
id|port-&gt;ch_base
)paren
suffix:semicolon
id|port-&gt;line
op_assign
id|portno
op_increment
suffix:semicolon
id|port
op_increment
suffix:semicolon
)brace
id|sx_dprintk
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* This has to be done earlier. */
multiline_comment|/* board-&gt;flags |= SX_BOARD_INITIALIZED; */
)brace
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sx_release_drivers
r_static
r_void
id|__exit
id|sx_release_drivers
c_func
(paren
r_void
)paren
(brace
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|tty_unregister_driver
c_func
(paren
op_amp
id|sx_driver
)paren
suffix:semicolon
id|tty_unregister_driver
c_func
(paren
op_amp
id|sx_callout_driver
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef TWO_ZERO
DECL|macro|PDEV
mdefine_line|#define PDEV unsigned char pci_bus, unsigned pci_fun
DECL|macro|pdev
mdefine_line|#define pdev pci_bus, pci_fun
macro_line|#else
DECL|macro|PDEV
mdefine_line|#define PDEV   struct pci_dev *pdev
macro_line|#endif
macro_line|#ifdef CONFIG_PCI
multiline_comment|/******************************************************** &n; * Setting bit 17 in the CNTRL register of the PLX 9050  * &n; * chip forces a retry on writes while a read is pending.*&n; * This is to prevent the card locking up on Intel Xeon  *&n; * multiprocessor systems with the NX chipset.    -- NV  *&n; ********************************************************/
multiline_comment|/* Newer cards are produced with this bit set from the configuration&n;   EEprom.  As the bit is read/write for the CPU, we can fix it here,&n;   if we detect that it isn&squot;t set correctly. -- REW */
DECL|function|fix_sx_pci
r_static
r_void
id|fix_sx_pci
(paren
id|PDEV
comma
r_struct
id|sx_board
op_star
id|board
)paren
(brace
r_int
r_int
id|hwbase
suffix:semicolon
r_int
r_int
id|rebase
suffix:semicolon
r_int
r_int
id|t
suffix:semicolon
DECL|macro|CNTRL_REG_OFFSET
mdefine_line|#define CNTRL_REG_OFFSET        0x50
DECL|macro|CNTRL_REG_GOODVALUE
mdefine_line|#define CNTRL_REG_GOODVALUE     0x18260000
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|hwbase
)paren
suffix:semicolon
id|hwbase
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|rebase
op_assign
(paren
id|ulong
)paren
id|ioremap
c_func
(paren
id|hwbase
comma
l_int|0x80
)paren
suffix:semicolon
id|t
op_assign
id|readl
(paren
id|rebase
op_plus
id|CNTRL_REG_OFFSET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_ne
id|CNTRL_REG_GOODVALUE
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;sx: performing cntrl reg fix: %08x -&gt; %08x&bslash;n&quot;
comma
id|t
comma
id|CNTRL_REG_GOODVALUE
)paren
suffix:semicolon
id|writel
(paren
id|CNTRL_REG_GOODVALUE
comma
id|rebase
op_plus
id|CNTRL_REG_OFFSET
)paren
suffix:semicolon
)brace
id|my_iounmap
(paren
id|hwbase
comma
id|rebase
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|sx_init
r_static
r_int
id|__init
id|sx_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_int
id|eisa_slot
suffix:semicolon
r_struct
id|sx_board
op_star
id|board
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
macro_line|#ifndef TWO_ZERO
r_struct
id|pci_dev
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
macro_line|#else
r_int
r_char
id|pci_bus
comma
id|pci_fun
suffix:semicolon
multiline_comment|/* in 2.2.x pdev is a pointer defining a PCI device. In 2.0 its the bus/fn */
macro_line|#endif
r_int
r_int
id|tint
suffix:semicolon
r_int
r_int
id|tshort
suffix:semicolon
macro_line|#endif
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_INIT
comma
l_string|&quot;Initing sx module... (sx_debug=%d)&bslash;n&quot;
comma
id|sx_debug
)paren
suffix:semicolon
r_if
c_cond
(paren
id|abs
(paren
(paren
r_int
)paren
(paren
op_amp
id|sx_debug
)paren
op_minus
id|sx_debug
)paren
OL
l_int|0x10000
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;sx: sx_debug is an address, instead of a value. &quot;
l_string|&quot;Assuming -1.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;(%p)&bslash;n&quot;
comma
op_amp
id|sx_debug
)paren
suffix:semicolon
id|sx_debug
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
id|pci_present
(paren
)paren
)paren
(brace
macro_line|#ifndef TWO_ZERO
r_while
c_loop
(paren
(paren
id|pdev
op_assign
id|pci_find_device
(paren
id|PCI_VENDOR_ID_SPECIALIX
comma
id|PCI_DEVICE_ID_SPECIALIX_SX_XIO_IO8
comma
id|pdev
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
r_continue
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SX_NBOARDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcibios_find_device
(paren
id|PCI_VENDOR_ID_SPECIALIX
comma
id|PCI_DEVICE_ID_SPECIALIX_SX_XIO_IO8
comma
id|i
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_fun
)paren
)paren
r_break
suffix:semicolon
macro_line|#endif
multiline_comment|/* Specialix has a whole bunch of cards with&n;&t;&t;&t;   0x2000 as the device ID. They say its because&n;&t;&t;&t;   the standard requires it. Stupid standard. */
multiline_comment|/* It seems that reading a word doesn&squot;t work reliably on 2.0.&n;&t;&t;&t;   Also, reading a non-aligned dword doesn&squot;t work. So we read the&n;&t;&t;&t;   whole dword at 0x2c and extract the word at 0x2e (SUBSYSTEM_ID)&n;&t;&t;&t;   ourselves */
multiline_comment|/* I don&squot;t know why the define doesn&squot;t work, constant 0x2c does --REW */
id|pci_read_config_dword
(paren
id|pdev
comma
l_int|0x2c
comma
op_amp
id|tint
)paren
suffix:semicolon
id|tshort
op_assign
(paren
id|tint
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;Got a specialix card: %x.&bslash;n&quot;
comma
id|tint
)paren
suffix:semicolon
multiline_comment|/* sx_dprintk (SX_DEBUG_PROBE, &quot;pdev = %d/%d&t;(%x)&bslash;n&quot;, pdev, tint); */
r_if
c_cond
(paren
(paren
id|tshort
op_ne
l_int|0x0200
)paren
op_logical_and
(paren
id|tshort
op_ne
l_int|0x0300
)paren
)paren
(brace
id|sx_dprintk
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;But it&squot;s not an SX card (%d)...&bslash;n&quot;
comma
id|tshort
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|board
op_assign
op_amp
id|boards
(braket
id|found
)braket
suffix:semicolon
id|board-&gt;flags
op_and_assign
op_complement
id|SX_BOARD_TYPE
suffix:semicolon
id|board-&gt;flags
op_or_assign
(paren
id|tshort
op_eq
l_int|0x200
)paren
ques
c_cond
id|SX_PCI_BOARD
suffix:colon
id|SX_CFPCI_BOARD
suffix:semicolon
multiline_comment|/* CF boards use base address 3.... */
r_if
c_cond
(paren
id|IS_CF_BOARD
(paren
id|board
)paren
)paren
id|board-&gt;hw_base
op_assign
id|pci_resource_start
(paren
id|pdev
comma
l_int|3
)paren
suffix:semicolon
r_else
id|board-&gt;hw_base
op_assign
id|pci_resource_start
(paren
id|pdev
comma
l_int|2
)paren
suffix:semicolon
id|board-&gt;base2
op_assign
id|board-&gt;base
op_assign
(paren
id|ulong
)paren
id|ioremap
c_func
(paren
id|board-&gt;hw_base
comma
id|WINDOW_LEN
(paren
id|board
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|board-&gt;base
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ioremap failed&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* XXX handle error */
)brace
multiline_comment|/* Most of the stuff on the CF board is offset by&n;&t;&t;&t;   0x18000 ....  */
r_if
c_cond
(paren
id|IS_CF_BOARD
(paren
id|board
)paren
)paren
id|board-&gt;base
op_add_assign
l_int|0x18000
suffix:semicolon
id|board-&gt;irq
op_assign
id|get_irq
(paren
id|pdev
)paren
suffix:semicolon
id|sx_dprintk
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;Got a specialix card: %x/%x(%d) %x.&bslash;n&quot;
comma
id|tint
comma
id|boards
(braket
id|found
)braket
dot
id|base
comma
id|board-&gt;irq
comma
id|board-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|probe_sx
(paren
id|board
)paren
)paren
(brace
id|found
op_increment
suffix:semicolon
id|fix_sx_pci
(paren
id|pdev
comma
id|board
)paren
suffix:semicolon
)brace
r_else
id|my_iounmap
(paren
id|board-&gt;hw_base
comma
id|board-&gt;base
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_SX_ADDRS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|board
op_assign
op_amp
id|boards
(braket
id|found
)braket
suffix:semicolon
id|board-&gt;hw_base
op_assign
id|sx_probe_addrs
(braket
id|i
)braket
suffix:semicolon
id|board-&gt;base2
op_assign
id|board-&gt;base
op_assign
(paren
id|ulong
)paren
id|ioremap
c_func
(paren
id|board-&gt;hw_base
comma
id|SX_WINDOW_LEN
)paren
suffix:semicolon
id|board-&gt;flags
op_and_assign
op_complement
id|SX_BOARD_TYPE
suffix:semicolon
id|board-&gt;flags
op_or_assign
id|SX_ISA_BOARD
suffix:semicolon
id|board-&gt;irq
op_assign
id|sx_irqmask
ques
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|probe_sx
(paren
id|board
)paren
)paren
(brace
id|found
op_increment
suffix:semicolon
)brace
r_else
(brace
id|my_iounmap
(paren
id|board-&gt;hw_base
comma
id|board-&gt;base
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_SI_ADDRS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|board
op_assign
op_amp
id|boards
(braket
id|found
)braket
suffix:semicolon
id|board-&gt;hw_base
op_assign
id|si_probe_addrs
(braket
id|i
)braket
suffix:semicolon
id|board-&gt;base2
op_assign
id|board-&gt;base
op_assign
(paren
id|ulong
)paren
id|ioremap
c_func
(paren
id|board-&gt;hw_base
comma
id|SI2_ISA_WINDOW_LEN
)paren
suffix:semicolon
id|board-&gt;flags
op_and_assign
op_complement
id|SX_BOARD_TYPE
suffix:semicolon
id|board-&gt;flags
op_or_assign
id|SI_ISA_BOARD
suffix:semicolon
id|board-&gt;irq
op_assign
id|sx_irqmask
ques
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|probe_si
(paren
id|board
)paren
)paren
(brace
id|found
op_increment
suffix:semicolon
)brace
r_else
(brace
id|my_iounmap
(paren
id|board-&gt;hw_base
comma
id|board-&gt;base
)paren
suffix:semicolon
)brace
)brace
id|sx_dprintk
c_func
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;Probing for EISA cards&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|eisa_slot
op_assign
l_int|0x1000
suffix:semicolon
id|eisa_slot
OL
l_int|0x10000
suffix:semicolon
id|eisa_slot
op_add_assign
l_int|0x1000
)paren
(brace
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|eisa_slot
op_plus
l_int|0xc80
)paren
op_eq
l_int|0x4d
)paren
op_logical_and
(paren
id|inb
c_func
(paren
id|eisa_slot
op_plus
l_int|0xc81
)paren
op_eq
l_int|0x98
)paren
)paren
(brace
id|sx_dprintk
c_func
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;%s : Signature found in EISA slot %d, Product %d Rev %d&bslash;n&quot;
comma
l_string|&quot;XIO&quot;
comma
(paren
id|eisa_slot
op_rshift
l_int|12
)paren
comma
id|inb
c_func
(paren
id|eisa_slot
op_plus
l_int|0xc82
)paren
comma
id|inb
c_func
(paren
id|eisa_slot
op_plus
l_int|0xc83
)paren
)paren
suffix:semicolon
id|board
op_assign
op_amp
id|boards
(braket
id|found
)braket
suffix:semicolon
id|board-&gt;eisa_base
op_assign
id|eisa_slot
suffix:semicolon
id|board-&gt;flags
op_and_assign
op_complement
id|SX_BOARD_TYPE
suffix:semicolon
id|board-&gt;flags
op_or_assign
id|SI_EISA_BOARD
suffix:semicolon
id|board-&gt;hw_base
op_assign
(paren
(paren
(paren
id|inb
c_func
(paren
l_int|0xc01
op_plus
id|eisa_slot
)paren
op_lshift
l_int|8
)paren
op_plus
id|inb
c_func
(paren
l_int|0xc00
op_plus
id|eisa_slot
)paren
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
id|board-&gt;base2
op_assign
id|board-&gt;base
op_assign
(paren
id|ulong
)paren
id|ioremap
c_func
(paren
id|board-&gt;hw_base
comma
id|SI2_EISA_WINDOW_LEN
)paren
suffix:semicolon
id|sx_dprintk
c_func
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;IO hw_base address: %x&bslash;n&quot;
comma
id|board-&gt;hw_base
)paren
suffix:semicolon
id|sx_dprintk
c_func
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;base: %x&bslash;n&quot;
comma
id|board-&gt;base
)paren
suffix:semicolon
id|board-&gt;irq
op_assign
id|inb
c_func
(paren
id|board-&gt;eisa_base
op_plus
l_int|0xc02
)paren
op_rshift
l_int|4
suffix:semicolon
id|sx_dprintk
c_func
(paren
id|SX_DEBUG_PROBE
comma
l_string|&quot;IRQ: %d&bslash;n&quot;
comma
id|board-&gt;irq
)paren
suffix:semicolon
id|probe_si
c_func
(paren
id|board
)paren
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;sx: total of %d boards detected.&bslash;n&quot;
comma
id|found
)paren
suffix:semicolon
r_if
c_cond
(paren
id|misc_register
c_func
(paren
op_amp
id|sx_fw_device
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SX: Unable to register firmware loader driver.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
id|found
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|sx_exit
r_static
r_void
id|__exit
id|sx_exit
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|sx_board
op_star
id|board
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SX_NBOARDS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|board
op_assign
op_amp
id|boards
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|board-&gt;flags
op_amp
id|SX_BOARD_INITIALIZED
)paren
(brace
id|sx_dprintk
(paren
id|SX_DEBUG_CLEANUP
comma
l_string|&quot;Cleaning up board at %x&bslash;n&quot;
comma
id|board-&gt;base
)paren
suffix:semicolon
multiline_comment|/* The board should stop messing with us.&n;&t;&t;&t;   (actually I mean the interrupt) */
id|sx_reset
(paren
id|board
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|board-&gt;irq
)paren
op_logical_and
(paren
id|board-&gt;flags
op_amp
id|SX_IRQ_ALLOCATED
)paren
)paren
id|free_irq
(paren
id|board-&gt;irq
comma
id|board
)paren
suffix:semicolon
multiline_comment|/* It is safe/allowed to del_timer a non-active timer */
id|del_timer
(paren
op_amp
id|board-&gt;timer
)paren
suffix:semicolon
id|my_iounmap
(paren
id|board-&gt;hw_base
comma
id|board-&gt;base
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|misc_deregister
c_func
(paren
op_amp
id|sx_fw_device
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;sx: couldn&squot;t deregister firmware loader device&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|sx_dprintk
(paren
id|SX_DEBUG_CLEANUP
comma
l_string|&quot;Cleaning up drivers (%d)&bslash;n&quot;
comma
id|sx_initialized
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sx_initialized
)paren
id|sx_release_drivers
(paren
)paren
suffix:semicolon
id|kfree
(paren
id|sx_ports
)paren
suffix:semicolon
id|kfree
(paren
id|sx_termios
)paren
suffix:semicolon
id|kfree
(paren
id|sx_termios_locked
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|sx_init
id|module_init
c_func
(paren
id|sx_init
)paren
suffix:semicolon
DECL|variable|sx_exit
id|module_exit
c_func
(paren
id|sx_exit
)paren
suffix:semicolon
eof
