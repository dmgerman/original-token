multiline_comment|/*&n; * random.c -- A strong random number generator&n; *&n; * Version 1.00, last modified 26-May-96&n; * &n; * Copyright Theodore Ts&squot;o, 1994, 1995, 1996.  All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, and the entire permission notice in its entirety,&n; *    including the disclaimer of warranties.&n; * 2. Redistributions in binary form must reproduce the above copyright&n; *    notice, this list of conditions and the following disclaimer in the&n; *    documentation and/or other materials provided with the distribution.&n; * 3. The name of the author may not be used to endorse or promote&n; *    products derived from this software without specific prior&n; *    written permission.&n; * &n; * ALTERNATIVELY, this product may be distributed under the terms of&n; * the GNU Public License, in which case the provisions of the GPL are&n; * required INSTEAD OF the above restrictions.  (This clause is&n; * necessary due to a potential bad interaction between the GPL and&n; * the restrictions contained in a BSD-style copyright.)&n; * &n; * THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES&n; * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&n; * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,&n; * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES&n; * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR&n; * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,&n; * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)&n; * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED&n; * OF THE POSSIBILITY OF SUCH DAMAGE.&n; */
multiline_comment|/*&n; * (now, with legal B.S. out of the way.....) &n; * &n; * This routine gathers environmental noise from device drivers, etc.,&n; * and returns good random numbers, suitable for cryptographic use.&n; * Besides the obvious cryptographic uses, these numbers are also good&n; * for seeding TCP sequence numbers, and other places where it is&n; * desirable to have numbers which are not only random, but hard to&n; * predict by an attacker.&n; *&n; * Theory of operation&n; * ===================&n; * &n; * Computers are very predictable devices.  Hence it is extremely hard&n; * to produce truly random numbers on a computer --- as opposed to&n; * pseudo-random numbers, which can easily generated by using a&n; * algorithm.  Unfortunately, it is very easy for attackers to guess&n; * the sequence of pseudo-random number generators, and for some&n; * applications this is not acceptable.  So instead, we must try to&n; * gather &quot;environmental noise&quot; from the computer&squot;s environment, which&n; * must be hard for outside attackers to observe, and use that to&n; * generate random numbers.  In a Unix environment, this is best done&n; * from inside the kernel.&n; * &n; * Sources of randomness from the environment include inter-keyboard&n; * timings, inter-interrupt timings from some interrupts, and other&n; * events which are both (a) non-deterministic and (b) hard for an&n; * outside observer to measure.  Randomness from these sources are&n; * added to an &quot;entropy pool&quot;, which is mixed using a CRC-like function.&n; * This is not cryptographically strong, but it is adequate assuming&n; * the randomness is not chosen maliciously, and it is fast enough that&n; * the overhead of doing it on every interrupt is very reasonable.&n; * As random bytes are mixed into the entropy pool, the routines keep&n; * an *estimate* of how many bits of randomness have been stored into&n; * the random number generator&squot;s internal state.&n; * &n; * When random bytes are desired, they are obtained by taking the MD5&n; * hash of the contents of the &quot;entropy pool&quot;.  The MD5 hash avoids&n; * exposing the internal state of the entropy pool.  It is believed to&n; * be computationally infeasible to derive any useful information&n; * about the input of MD5 from its output.  Even if it is possible to&n; * analyze MD5 in some clever way, as long as the amount of data&n; * returned from the generator is less than the inherent entropy in&n; * the pool, the output data is totally unpredictable.  For this&n; * reason, the routine decreases its internal estimate of how many&n; * bits of &quot;true randomness&quot; are contained in the entropy pool as it&n; * outputs random numbers.&n; * &n; * If this estimate goes to zero, the routine can still generate&n; * random numbers; however, an attacker may (at least in theory) be&n; * able to infer the future output of the generator from prior&n; * outputs.  This requires successful cryptanalysis of MD5, which is&n; * not believed to be feasible, but there is a remote possibility.&n; * Nonetheless, these numbers should be useful for the vast majority&n; * of purposes.&n; * &n; * Exported interfaces ---- output&n; * ===============================&n; * &n; * There are three exported interfaces; the first is one designed to&n; * be used from within the kernel:&n; *&n; * &t;void get_random_bytes(void *buf, int nbytes);&n; *&n; * This interface will return the requested number of random bytes,&n; * and place it in the requested buffer.&n; * &n; * The two other interfaces are two character devices /dev/random and&n; * /dev/urandom.  /dev/random is suitable for use when very high&n; * quality randomness is desired (for example, for key generation or&n; * one-time pads), as it will only return a maximum of the number of&n; * bits of randomness (as estimated by the random number generator)&n; * contained in the entropy pool.&n; * &n; * The /dev/urandom device does not have this limit, and will return&n; * as many bytes as are requested.  As more and more random bytes are&n; * requested without giving time for the entropy pool to recharge,&n; * this will result in random numbers that are merely cryptographically&n; * strong.  For many applications, however, this is acceptable.&n; *&n; * Exported interfaces ---- input&n; * ==============================&n; * &n; * The current exported interfaces for gathering environmental noise&n; * from the devices are:&n; * &n; * &t;void add_keyboard_randomness(unsigned char scancode);&n; * &t;void add_mouse_randomness(__u32 mouse_data);&n; * &t;void add_interrupt_randomness(int irq);&n; * &t;void add_blkdev_randomness(int irq);&n; * &n; * add_keyboard_randomness() uses the inter-keypress timing, as well as the&n; * scancode as random inputs into the &quot;entropy pool&quot;.&n; * &n; * add_mouse_randomness() uses the mouse interrupt timing, as well as&n; * the reported position of the mouse from the hardware.&n; *&n; * add_interrupt_randomness() uses the inter-interrupt timing as random&n; * inputs to the entropy pool.  Note that not all interrupts are good&n; * sources of randomness!  For example, the timer interrupts is not a&n; * good choice, because the periodicity of the interrupts is to&n; * regular, and hence predictable to an attacker.  Disk interrupts are&n; * a better measure, since the timing of the disk interrupts are more&n; * unpredictable.&n; * &n; * add_blkdev_randomness() times the finishing time of block requests.&n; * &n; * All of these routines try to estimate how many bits of randomness a&n; * particular randomness source.  They do this by keeping track of the&n; * first and second order deltas of the event timings.&n; *&n; * Ensuring unpredictability at system startup&n; * ============================================&n; * &n; * When any operating system starts up, it will go through a sequence&n; * of actions that are fairly predictable by an adversary, especially&n; * if the start-up does not involve interaction with a human operator.&n; * This reduces the actual number of bits of unpredictability in the&n; * entropy pool below the value in entropy_count.  In order to&n; * counteract this effect, it helps to carry information in the&n; * entropy pool across shut-downs and start-ups.  To do this, put the&n; * following lines an appropriate script which is run during the boot&n; * sequence: &n; *&n; *&t;echo &quot;Initializing random number generator...&quot;&n; *&t;# Carry a random seed from start-up to start-up&n; *&t;# Load and then save 512 bytes, which is the size of the entropy pool&n; * &t;if [ -f /etc/random-seed ]; then&n; *&t;&t;cat /etc/random-seed &gt;/dev/urandom&n; * &t;fi&n; *&t;dd if=/dev/urandom of=/etc/random-seed count=1&n; *&n; * and the following lines in an appropriate script which is run as&n; * the system is shutdown:&n; * &n; *&t;# Carry a random seed from shut-down to start-up&n; *&t;# Save 512 bytes, which is the size of the entropy pool&n; *&t;echo &quot;Saving random seed...&quot;&n; *&t;dd if=/dev/urandom of=/etc/random-seed count=1&n; * &n; * For example, on many Linux systems, the appropriate scripts are&n; * usually /etc/rc.d/rc.local and /etc/rc.d/rc.0, respectively.&n; * &n; * Effectively, these commands cause the contents of the entropy pool&n; * to be saved at shut-down time and reloaded into the entropy pool at&n; * start-up.  (The &squot;dd&squot; in the addition to the bootup script is to&n; * make sure that /etc/random-seed is different for every start-up,&n; * even if the system crashes without executing rc.0.)  Even with&n; * complete knowledge of the start-up activities, predicting the state&n; * of the entropy pool requires knowledge of the previous history of&n; * the system.&n; *&n; * Configuring the /dev/random driver under Linux&n; * ==============================================&n; *&n; * The /dev/random driver under Linux uses minor numbers 8 and 9 of&n; * the /dev/mem major number (#1).  So if your system does not have&n; * /dev/random and /dev/urandom created already, they can be created&n; * by using the commands:&n; *&n; * &t;mknod /dev/random c 1 8&n; * &t;mknod /dev/urandom c 1 9&n; * &n; * Acknowledgements:&n; * =================&n; *&n; * Ideas for constructing this random number generator were derived&n; * from the Pretty Good Privacy&squot;s random number generator, and from&n; * private discussions with Phil Karn.  Colin Plumb provided a faster&n; * random number generator, which speed up the mixing function of the&n; * entropy pool, taken from PGP 3.0 (under development).  It has since&n; * been modified by myself to provide better mixing in the case where&n; * the input values to add_entropy_word() are mostly small numbers.&n; * Dale Worley has also contributed many useful ideas and suggestions&n; * to improve this driver.&n; * &n; * Any flaws in the design are solely my responsibility, and should&n; * not be attributed to the Phil, Colin, or any of authors of PGP.&n; * &n; * The code for MD5 transform was taken from Colin Plumb&squot;s&n; * implementation, which has been placed in the public domain.  The&n; * MD5 cryptographic checksum was devised by Ronald Rivest, and is&n; * documented in RFC 1321, &quot;The MD5 Message Digest Algorithm&quot;.&n; * &n; * Further background information on this topic may be obtained from&n; * RFC 1750, &quot;Randomness Recommendations for Security&quot;, by Donald&n; * Eastlake, Steve Crocker, and Jeff Schiller.&n; */
macro_line|#include &lt;linux/utsname.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
multiline_comment|/*&n; * Configuration information&n; */
DECL|macro|RANDOM_BENCHMARK
macro_line|#undef RANDOM_BENCHMARK
DECL|macro|BENCHMARK_NOINT
macro_line|#undef BENCHMARK_NOINT
multiline_comment|/*&n; * The pool is stirred with a primitive polynomial of degree 128&n; * over GF(2), namely x^128 + x^99 + x^59 + x^31 + x^9 + x^7 + 1.&n; * For a pool of size 64, try x^64+x^62+x^38+x^10+x^6+x+1.&n; */
DECL|macro|POOLWORDS
mdefine_line|#define POOLWORDS 128    /* Power of 2 - note that this is 32-bit words */
DECL|macro|POOLBITS
mdefine_line|#define POOLBITS (POOLWORDS*32)
macro_line|#if POOLWORDS == 128
DECL|macro|TAP1
mdefine_line|#define TAP1    99     /* The polynomial taps */
DECL|macro|TAP2
mdefine_line|#define TAP2    59
DECL|macro|TAP3
mdefine_line|#define TAP3    31
DECL|macro|TAP4
mdefine_line|#define TAP4    9
DECL|macro|TAP5
mdefine_line|#define TAP5    7
macro_line|#elif POOLWORDS == 64
DECL|macro|TAP1
mdefine_line|#define TAP1    62      /* The polynomial taps */
DECL|macro|TAP2
mdefine_line|#define TAP2    38
DECL|macro|TAP3
mdefine_line|#define TAP3    10
DECL|macro|TAP4
mdefine_line|#define TAP4    6
DECL|macro|TAP5
mdefine_line|#define TAP5    1
macro_line|#else
macro_line|#error No primitive polynomial available for chosen POOLWORDS
macro_line|#endif
multiline_comment|/*&n; * The minimum number of bits to release a &quot;wait on input&quot;.  Should&n; * probably always be 8, since a /dev/random read can return a single&n; * byte.&n; */
DECL|macro|WAIT_INPUT_BITS
mdefine_line|#define WAIT_INPUT_BITS 8
multiline_comment|/* &n; * The limit number of bits under which to release a &quot;wait on&n; * output&quot;.  Should probably always be the same as WAIT_INPUT_BITS, so&n; * that an output wait releases when and only when a wait on input&n; * would block.&n; */
DECL|macro|WAIT_OUTPUT_BITS
mdefine_line|#define WAIT_OUTPUT_BITS WAIT_INPUT_BITS
multiline_comment|/* There is actually only one of these, globally. */
DECL|struct|random_bucket
r_struct
id|random_bucket
(brace
DECL|member|add_ptr
r_int
id|add_ptr
suffix:semicolon
DECL|member|entropy_count
r_int
id|entropy_count
suffix:semicolon
DECL|member|input_rotate
r_int
id|input_rotate
suffix:semicolon
DECL|member|pool
id|__u32
op_star
id|pool
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef RANDOM_BENCHMARK
multiline_comment|/* For benchmarking only */
DECL|struct|random_benchmark
r_struct
id|random_benchmark
(brace
DECL|member|start_time
r_int
r_int
r_int
id|start_time
suffix:semicolon
DECL|member|times
r_int
id|times
suffix:semicolon
multiline_comment|/* # of samples */
DECL|member|min
r_int
r_int
id|min
suffix:semicolon
DECL|member|max
r_int
r_int
id|max
suffix:semicolon
DECL|member|accum
r_int
r_int
id|accum
suffix:semicolon
multiline_comment|/* accumulator for average */
DECL|member|descr
r_const
r_char
op_star
id|descr
suffix:semicolon
DECL|member|unit
r_int
id|unit
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|BENCHMARK_INTERVAL
mdefine_line|#define BENCHMARK_INTERVAL 500
r_static
r_void
id|initialize_benchmark
c_func
(paren
r_struct
id|random_benchmark
op_star
id|bench
comma
r_const
r_char
op_star
id|descr
comma
r_int
id|unit
)paren
suffix:semicolon
r_static
r_void
id|begin_benchmark
c_func
(paren
r_struct
id|random_benchmark
op_star
id|bench
)paren
suffix:semicolon
r_static
r_void
id|end_benchmark
c_func
(paren
r_struct
id|random_benchmark
op_star
id|bench
)paren
suffix:semicolon
DECL|variable|timer_benchmark
r_struct
id|random_benchmark
id|timer_benchmark
suffix:semicolon
macro_line|#endif
multiline_comment|/* There is one of these per entropy source */
DECL|struct|timer_rand_state
r_struct
id|timer_rand_state
(brace
DECL|member|last_time
r_int
r_int
id|last_time
suffix:semicolon
DECL|member|last_delta
DECL|member|last_delta2
r_int
id|last_delta
comma
id|last_delta2
suffix:semicolon
DECL|member|dont_count_entropy
r_int
id|dont_count_entropy
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|random_state
r_static
r_struct
id|random_bucket
id|random_state
suffix:semicolon
DECL|variable|random_pool
r_static
id|__u32
id|random_pool
(braket
id|POOLWORDS
)braket
suffix:semicolon
DECL|variable|keyboard_timer_state
r_static
r_struct
id|timer_rand_state
id|keyboard_timer_state
suffix:semicolon
DECL|variable|mouse_timer_state
r_static
r_struct
id|timer_rand_state
id|mouse_timer_state
suffix:semicolon
DECL|variable|extract_timer_state
r_static
r_struct
id|timer_rand_state
id|extract_timer_state
suffix:semicolon
DECL|variable|irq_timer_state
r_static
r_struct
id|timer_rand_state
op_star
id|irq_timer_state
(braket
id|NR_IRQS
)braket
suffix:semicolon
DECL|variable|blkdev_timer_state
r_static
r_struct
id|timer_rand_state
op_star
id|blkdev_timer_state
(braket
id|MAX_BLKDEV
)braket
suffix:semicolon
DECL|variable|random_wait
r_static
r_struct
id|wait_queue
op_star
id|random_wait
suffix:semicolon
r_static
r_int
id|random_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|nbytes
)paren
suffix:semicolon
r_static
r_int
id|random_read_unlimited
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|nbytes
)paren
suffix:semicolon
r_static
r_int
id|random_select
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
suffix:semicolon
r_static
r_int
id|random_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
)paren
suffix:semicolon
r_static
r_int
id|random_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_inline
r_void
id|fast_add_entropy_word
c_func
(paren
r_struct
id|random_bucket
op_star
id|r
comma
r_const
id|__u32
id|input
)paren
suffix:semicolon
r_static
r_void
id|add_entropy_word
c_func
(paren
r_struct
id|random_bucket
op_star
id|r
comma
r_const
id|__u32
id|input
)paren
suffix:semicolon
macro_line|#ifndef MIN
DECL|macro|MIN
mdefine_line|#define MIN(a,b) (((a) &lt; (b)) ? (a) : (b))
macro_line|#endif
multiline_comment|/*&n; * Unfortunately, while the GCC optimizer for the i386 understands how&n; * to optimize a static rotate left of x bits, it doesn&squot;t know how to&n; * deal with a variable rotate of x bits.  So we use a bit of asm magic.&n; */
macro_line|#if (!defined (__i386__))
DECL|function|rotate_left
r_extern
r_inline
id|__u32
id|rotate_left
c_func
(paren
r_int
id|i
comma
id|__u32
id|word
)paren
(brace
id|__u32
id|nbits
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|word
op_lshift
id|i
)paren
op_or
(paren
id|word
op_rshift
(paren
l_int|32
op_minus
id|i
)paren
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|function|rotate_left
r_extern
r_inline
id|__u32
id|rotate_left
c_func
(paren
r_int
id|i
comma
id|__u32
id|word
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;roll %%cl,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|word
)paren
suffix:colon
l_string|&quot;0&quot;
(paren
id|word
)paren
comma
l_string|&quot;c&quot;
(paren
id|i
)paren
)paren
suffix:semicolon
r_return
id|word
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * More asm magic....&n; * &n; * For entropy estimation, we need to do an integral base 2&n; * logarithm.  By default, use an open-coded C version, although we do&n; * have a version which takes advantage of the Intel&squot;s x86&squot;s &quot;bsr&quot;&n; * instruction.&n; */
macro_line|#if (!defined (__i386__))
DECL|function|int_ln
r_static
r_inline
id|__u32
id|int_ln
c_func
(paren
id|__u32
id|word
)paren
(brace
id|__u32
id|nbits
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|word
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|word
)paren
r_break
suffix:semicolon
id|nbits
op_increment
suffix:semicolon
)brace
r_return
id|nbits
suffix:semicolon
)brace
macro_line|#else
DECL|function|int_ln
r_static
r_inline
id|__u32
id|int_ln
c_func
(paren
id|__u32
id|word
)paren
(brace
id|__asm__
c_func
(paren
l_string|&quot;bsrl %1,%0&bslash;n&bslash;t&quot;
l_string|&quot;jnz 1f&bslash;n&bslash;t&quot;
l_string|&quot;movl $0,%0&bslash;n&quot;
l_string|&quot;1:&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|word
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|word
)paren
)paren
suffix:semicolon
r_return
id|word
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Initialize the random pool with standard stuff.&n; *&n; * NOTE: This is an OS-dependent function.&n; */
DECL|function|init_std_data
r_static
r_void
id|init_std_data
c_func
(paren
r_struct
id|random_bucket
op_star
id|r
)paren
(brace
id|__u32
id|word
comma
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|timeval
id|tv
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|add_entropy_word
c_func
(paren
id|r
comma
id|tv.tv_sec
)paren
suffix:semicolon
id|add_entropy_word
c_func
(paren
id|r
comma
id|tv.tv_usec
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
(paren
id|__u32
op_star
)paren
op_amp
id|system_utsname
comma
id|i
op_assign
r_sizeof
(paren
id|system_utsname
)paren
op_div
r_sizeof
(paren
id|__u32
)paren
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
comma
id|p
op_increment
)paren
(brace
id|memcpy
c_func
(paren
op_amp
id|word
comma
id|p
comma
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
id|add_entropy_word
c_func
(paren
id|r
comma
id|word
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Clear the entropy pool and associated counters. */
DECL|function|rand_clear_pool
r_static
r_void
id|rand_clear_pool
c_func
(paren
r_void
)paren
(brace
id|random_state.add_ptr
op_assign
l_int|0
suffix:semicolon
id|random_state.entropy_count
op_assign
l_int|0
suffix:semicolon
id|random_state.pool
op_assign
id|random_pool
suffix:semicolon
id|random_state.input_rotate
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|random_pool
comma
l_int|0
comma
r_sizeof
(paren
id|random_pool
)paren
)paren
suffix:semicolon
id|init_std_data
c_func
(paren
op_amp
id|random_state
)paren
suffix:semicolon
)brace
DECL|function|rand_initialize
r_void
id|rand_initialize
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|rand_clear_pool
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_IRQS
suffix:semicolon
id|i
op_increment
)paren
id|irq_timer_state
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_BLKDEV
suffix:semicolon
id|i
op_increment
)paren
id|blkdev_timer_state
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|keyboard_timer_state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|timer_rand_state
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|mouse_timer_state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|timer_rand_state
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|extract_timer_state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|timer_rand_state
)paren
)paren
suffix:semicolon
macro_line|#ifdef RANDOM_BENCHMARK
id|initialize_benchmark
c_func
(paren
op_amp
id|timer_benchmark
comma
l_string|&quot;timer&quot;
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|extract_timer_state.dont_count_entropy
op_assign
l_int|1
suffix:semicolon
id|random_wait
op_assign
l_int|NULL
suffix:semicolon
)brace
DECL|function|rand_initialize_irq
r_void
id|rand_initialize_irq
c_func
(paren
r_int
id|irq
)paren
(brace
r_struct
id|timer_rand_state
op_star
id|state
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
id|NR_IRQS
op_logical_or
id|irq_timer_state
(braket
id|irq
)braket
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If kmalloc returns null, we just won&squot;t use that entropy&n;&t; * source.&n;&t; */
id|state
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|timer_rand_state
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|irq_timer_state
(braket
id|irq
)braket
op_assign
id|state
suffix:semicolon
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|timer_rand_state
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|rand_initialize_blkdev
r_void
id|rand_initialize_blkdev
c_func
(paren
r_int
id|major
comma
r_int
id|mode
)paren
(brace
r_struct
id|timer_rand_state
op_star
id|state
suffix:semicolon
r_if
c_cond
(paren
id|major
op_ge
id|MAX_BLKDEV
op_logical_or
id|blkdev_timer_state
(braket
id|major
)braket
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If kmalloc returns null, we just won&squot;t use that entropy&n;&t; * source.&n;&t; */
id|state
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|timer_rand_state
)paren
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|state
)paren
(brace
id|blkdev_timer_state
(braket
id|major
)braket
op_assign
id|state
suffix:semicolon
id|memset
c_func
(paren
id|state
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|timer_rand_state
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function adds a byte into the entropy &quot;pool&quot;.  It does not&n; * update the entropy estimate.  The caller must do this if appropriate.&n; *&n; * The pool is stirred with a primitive polynomial of degree 128&n; * over GF(2), namely x^128 + x^99 + x^59 + x^31 + x^9 + x^7 + 1.&n; * For a pool of size 64, try x^64+x^62+x^38+x^10+x^6+x+1.&n; * &n; * We rotate the input word by a changing number of bits, to help&n; * assure that all bits in the entropy get toggled.  Otherwise, if we&n; * consistently feed the entropy pool small numbers (like jiffies and&n; * scancodes, for example), the upper bits of the entropy pool don&squot;t&n; * get affected. --- TYT, 10/11/95&n; */
DECL|function|fast_add_entropy_word
r_static
r_inline
r_void
id|fast_add_entropy_word
c_func
(paren
r_struct
id|random_bucket
op_star
id|r
comma
r_const
id|__u32
id|input
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|new_rotate
suffix:semicolon
id|__u32
id|w
suffix:semicolon
id|w
op_assign
id|rotate_left
c_func
(paren
id|r-&gt;input_rotate
comma
id|input
)paren
suffix:semicolon
id|i
op_assign
id|r-&gt;add_ptr
op_assign
(paren
id|r-&gt;add_ptr
op_minus
l_int|1
)paren
op_amp
(paren
id|POOLWORDS
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Normally, we add 7 bits of rotation to the pool.  At the&n;&t; * beginning of the pool, add an extra 7 bits rotation, so&n;&t; * that successive passes spread the input bits across the&n;&t; * pool evenly.&n;&t; */
id|new_rotate
op_assign
id|r-&gt;input_rotate
op_plus
l_int|14
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
id|new_rotate
op_assign
id|r-&gt;input_rotate
op_plus
l_int|7
suffix:semicolon
id|r-&gt;input_rotate
op_assign
id|new_rotate
op_amp
l_int|31
suffix:semicolon
multiline_comment|/* XOR in the various taps */
id|w
op_xor_assign
id|r-&gt;pool
(braket
(paren
id|i
op_plus
id|TAP1
)paren
op_amp
(paren
id|POOLWORDS
op_minus
l_int|1
)paren
)braket
suffix:semicolon
id|w
op_xor_assign
id|r-&gt;pool
(braket
(paren
id|i
op_plus
id|TAP2
)paren
op_amp
(paren
id|POOLWORDS
op_minus
l_int|1
)paren
)braket
suffix:semicolon
id|w
op_xor_assign
id|r-&gt;pool
(braket
(paren
id|i
op_plus
id|TAP3
)paren
op_amp
(paren
id|POOLWORDS
op_minus
l_int|1
)paren
)braket
suffix:semicolon
id|w
op_xor_assign
id|r-&gt;pool
(braket
(paren
id|i
op_plus
id|TAP4
)paren
op_amp
(paren
id|POOLWORDS
op_minus
l_int|1
)paren
)braket
suffix:semicolon
id|w
op_xor_assign
id|r-&gt;pool
(braket
(paren
id|i
op_plus
id|TAP5
)paren
op_amp
(paren
id|POOLWORDS
op_minus
l_int|1
)paren
)braket
suffix:semicolon
id|w
op_xor_assign
id|r-&gt;pool
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Rotate w left 1 bit (stolen from SHA) and store */
id|r-&gt;pool
(braket
id|i
)braket
op_assign
(paren
id|w
op_lshift
l_int|1
)paren
op_or
(paren
id|w
op_rshift
l_int|31
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * For places where we don&squot;t need the inlined version&n; */
DECL|function|add_entropy_word
r_static
r_void
id|add_entropy_word
c_func
(paren
r_struct
id|random_bucket
op_star
id|r
comma
r_const
id|__u32
id|input
)paren
(brace
id|fast_add_entropy_word
c_func
(paren
id|r
comma
id|input
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function adds entropy to the entropy &quot;pool&quot; by using timing&n; * delays.  It uses the timer_rand_state structure to make an estimate&n; * of how many bits of entropy this call has added to the pool.&n; *&n; * The number &quot;num&quot; is also added to the pool - it should somehow describe&n; * the type of event which just happened.  This is currently 0-255 for&n; * keyboard scan codes, and 256 upwards for interrupts.&n; * On the i386, this is assumed to be at most 16 bits, and the high bits&n; * are used for a high-resolution timer.&n; *&n; */
DECL|function|add_timer_randomness
r_static
r_void
id|add_timer_randomness
c_func
(paren
r_struct
id|random_bucket
op_star
id|r
comma
r_struct
id|timer_rand_state
op_star
id|state
comma
r_int
id|num
)paren
(brace
r_int
id|delta
comma
id|delta2
comma
id|delta3
suffix:semicolon
id|__u32
id|time
suffix:semicolon
macro_line|#ifdef RANDOM_BENCHMARK
id|begin_benchmark
c_func
(paren
op_amp
id|timer_benchmark
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined (__i386__)
r_if
c_cond
(paren
id|x86_capability
op_amp
l_int|16
)paren
(brace
r_int
r_int
id|low
comma
id|high
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;.byte 0x0f,0x31&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|low
)paren
comma
l_string|&quot;=d&quot;
(paren
id|high
)paren
)paren
suffix:semicolon
id|time
op_assign
(paren
id|__u32
)paren
id|low
suffix:semicolon
id|num
op_xor_assign
(paren
id|__u32
)paren
id|high
suffix:semicolon
)brace
r_else
(brace
id|time
op_assign
id|jiffies
suffix:semicolon
)brace
macro_line|#else
id|time
op_assign
id|jiffies
suffix:semicolon
macro_line|#endif
id|fast_add_entropy_word
c_func
(paren
id|r
comma
(paren
id|__u32
)paren
id|num
)paren
suffix:semicolon
id|fast_add_entropy_word
c_func
(paren
id|r
comma
id|time
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate number of bits of randomness we probably&n;&t; * added.  We take into account the first and second order&n;&t; * deltas in order to make our estimate.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|state-&gt;dont_count_entropy
op_logical_and
(paren
id|r-&gt;entropy_count
OL
id|POOLBITS
)paren
)paren
(brace
id|delta
op_assign
id|time
op_minus
id|state-&gt;last_time
suffix:semicolon
id|state-&gt;last_time
op_assign
id|time
suffix:semicolon
r_if
c_cond
(paren
id|delta
OL
l_int|0
)paren
id|delta
op_assign
op_minus
id|delta
suffix:semicolon
id|delta2
op_assign
id|delta
op_minus
id|state-&gt;last_delta
suffix:semicolon
id|state-&gt;last_delta
op_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|delta2
OL
l_int|0
)paren
id|delta2
op_assign
op_minus
id|delta2
suffix:semicolon
id|delta3
op_assign
id|delta2
op_minus
id|state-&gt;last_delta2
suffix:semicolon
id|state-&gt;last_delta2
op_assign
id|delta2
suffix:semicolon
r_if
c_cond
(paren
id|delta3
OL
l_int|0
)paren
id|delta3
op_assign
op_minus
id|delta3
suffix:semicolon
id|delta
op_assign
id|MIN
c_func
(paren
id|MIN
c_func
(paren
id|delta
comma
id|delta2
)paren
comma
id|delta3
)paren
op_rshift
l_int|1
suffix:semicolon
multiline_comment|/* Limit entropy estimate to 12 bits */
id|delta
op_and_assign
(paren
l_int|1
op_lshift
l_int|12
)paren
op_minus
l_int|1
suffix:semicolon
id|r-&gt;entropy_count
op_add_assign
id|int_ln
c_func
(paren
id|delta
)paren
suffix:semicolon
multiline_comment|/* Prevent overflow */
r_if
c_cond
(paren
id|r-&gt;entropy_count
OG
id|POOLBITS
)paren
id|r-&gt;entropy_count
op_assign
id|POOLBITS
suffix:semicolon
)brace
multiline_comment|/* Wake up waiting processes, if we have enough entropy. */
r_if
c_cond
(paren
id|r-&gt;entropy_count
op_ge
id|WAIT_INPUT_BITS
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|random_wait
)paren
suffix:semicolon
macro_line|#ifdef RANDOM_BENCHMARK
id|end_benchmark
c_func
(paren
op_amp
id|timer_benchmark
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|add_keyboard_randomness
r_void
id|add_keyboard_randomness
c_func
(paren
r_int
r_char
id|scancode
)paren
(brace
id|add_timer_randomness
c_func
(paren
op_amp
id|random_state
comma
op_amp
id|keyboard_timer_state
comma
id|scancode
)paren
suffix:semicolon
)brace
DECL|function|add_mouse_randomness
r_void
id|add_mouse_randomness
c_func
(paren
id|__u32
id|mouse_data
)paren
(brace
id|add_timer_randomness
c_func
(paren
op_amp
id|random_state
comma
op_amp
id|mouse_timer_state
comma
id|mouse_data
)paren
suffix:semicolon
)brace
DECL|function|add_interrupt_randomness
r_void
id|add_interrupt_randomness
c_func
(paren
r_int
id|irq
)paren
(brace
r_if
c_cond
(paren
id|irq
op_ge
id|NR_IRQS
op_logical_or
id|irq_timer_state
(braket
id|irq
)braket
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|add_timer_randomness
c_func
(paren
op_amp
id|random_state
comma
id|irq_timer_state
(braket
id|irq
)braket
comma
l_int|0x100
op_plus
id|irq
)paren
suffix:semicolon
)brace
DECL|function|add_blkdev_randomness
r_void
id|add_blkdev_randomness
c_func
(paren
r_int
id|major
)paren
(brace
r_if
c_cond
(paren
id|major
op_ge
id|MAX_BLKDEV
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|blkdev_timer_state
(braket
id|major
)braket
op_eq
l_int|0
)paren
(brace
id|rand_initialize_blkdev
c_func
(paren
id|major
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blkdev_timer_state
(braket
id|major
)braket
op_eq
l_int|0
)paren
r_return
suffix:semicolon
)brace
id|add_timer_randomness
c_func
(paren
op_amp
id|random_state
comma
id|blkdev_timer_state
(braket
id|major
)braket
comma
l_int|0x200
op_plus
id|major
)paren
suffix:semicolon
)brace
DECL|macro|USE_SHA
mdefine_line|#define USE_SHA
macro_line|#ifdef USE_SHA
DECL|macro|HASH_BUFFER_SIZE
mdefine_line|#define HASH_BUFFER_SIZE 5
DECL|macro|HASH_TRANSFORM
mdefine_line|#define HASH_TRANSFORM SHATransform
multiline_comment|/*&n; * SHA transform algorithm, taken from code written by Peter Gutman,&n; * and apparently in the public domain.&n; */
multiline_comment|/* The SHA f()-functions.  */
DECL|macro|f1
mdefine_line|#define f1(x,y,z)   ( z ^ ( x &amp; ( y ^ z ) ) )           /* Rounds  0-19 */
DECL|macro|f2
mdefine_line|#define f2(x,y,z)   ( x ^ y ^ z )                       /* Rounds 20-39 */
DECL|macro|f3
mdefine_line|#define f3(x,y,z)   ( ( x &amp; y ) | ( z &amp; ( x | y ) ) )   /* Rounds 40-59 */
DECL|macro|f4
mdefine_line|#define f4(x,y,z)   ( x ^ y ^ z )                       /* Rounds 60-79 */
multiline_comment|/* The SHA Mysterious Constants */
DECL|macro|K1
mdefine_line|#define K1  0x5A827999L                                 /* Rounds  0-19 */
DECL|macro|K2
mdefine_line|#define K2  0x6ED9EBA1L                                 /* Rounds 20-39 */
DECL|macro|K3
mdefine_line|#define K3  0x8F1BBCDCL                                 /* Rounds 40-59 */
DECL|macro|K4
mdefine_line|#define K4  0xCA62C1D6L                                 /* Rounds 60-79 */
DECL|macro|ROTL
mdefine_line|#define ROTL(n,X)  ( ( ( X ) &lt;&lt; n ) | ( ( X ) &gt;&gt; ( 32 - n ) ) )
DECL|macro|expand
mdefine_line|#define expand(W,i) ( W[ i &amp; 15 ] = &bslash;&n;&t;&t;     ROTL( 1, ( W[ i &amp; 15 ] ^ W[ (i - 14) &amp; 15 ] ^ &bslash;&n;&t;&t;&t;        W[ (i - 8) &amp; 15 ] ^ W[ (i - 3) &amp; 15 ] ) ) )
DECL|macro|subRound
mdefine_line|#define subRound(a, b, c, d, e, f, k, data) &bslash;&n;    ( e += ROTL( 5, a ) + f( b, c, d ) + k + data, b = ROTL( 30, b ) )
DECL|function|SHATransform
r_void
id|SHATransform
c_func
(paren
id|__u32
op_star
id|digest
comma
id|__u32
op_star
id|data
)paren
(brace
id|__u32
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
suffix:semicolon
multiline_comment|/* Local vars */
id|__u32
id|eData
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Expanded data */
multiline_comment|/* Set up first buffer and local data buffer */
id|A
op_assign
id|digest
(braket
l_int|0
)braket
suffix:semicolon
id|B
op_assign
id|digest
(braket
l_int|1
)braket
suffix:semicolon
id|C
op_assign
id|digest
(braket
l_int|2
)braket
suffix:semicolon
id|D
op_assign
id|digest
(braket
l_int|3
)braket
suffix:semicolon
id|E
op_assign
id|digest
(braket
l_int|4
)braket
suffix:semicolon
id|memcpy
c_func
(paren
id|eData
comma
id|data
comma
l_int|16
op_star
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
multiline_comment|/* Heavy mangling, in 4 sub-rounds of 20 iterations each. */
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|8
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|9
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|10
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|11
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|12
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|13
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|14
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f1
comma
id|K1
comma
id|eData
(braket
l_int|15
)braket
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f1
comma
id|K1
comma
id|expand
c_func
(paren
id|eData
comma
l_int|16
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f1
comma
id|K1
comma
id|expand
c_func
(paren
id|eData
comma
l_int|17
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f1
comma
id|K1
comma
id|expand
c_func
(paren
id|eData
comma
l_int|18
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f1
comma
id|K1
comma
id|expand
c_func
(paren
id|eData
comma
l_int|19
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|20
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|21
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|22
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|23
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|24
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|25
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|26
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|27
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|28
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|29
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|30
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|31
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|32
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|33
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|34
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|35
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|36
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|37
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|38
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f2
comma
id|K2
comma
id|expand
c_func
(paren
id|eData
comma
l_int|39
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|40
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|41
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|42
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|43
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|44
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|45
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|46
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|47
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|48
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|49
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|50
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|51
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|52
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|53
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|54
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|55
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|56
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|57
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|58
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f3
comma
id|K3
comma
id|expand
c_func
(paren
id|eData
comma
l_int|59
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|60
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|61
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|62
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|63
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|64
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|65
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|66
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|67
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|68
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|69
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|70
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|71
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|72
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|73
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|74
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|75
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|D
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|76
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|C
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|77
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|B
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|78
)paren
)paren
suffix:semicolon
id|subRound
c_func
(paren
id|B
comma
id|C
comma
id|D
comma
id|E
comma
id|A
comma
id|f4
comma
id|K4
comma
id|expand
c_func
(paren
id|eData
comma
l_int|79
)paren
)paren
suffix:semicolon
multiline_comment|/* Build message digest */
id|digest
(braket
l_int|0
)braket
op_add_assign
id|A
suffix:semicolon
id|digest
(braket
l_int|1
)braket
op_add_assign
id|B
suffix:semicolon
id|digest
(braket
l_int|2
)braket
op_add_assign
id|C
suffix:semicolon
id|digest
(braket
l_int|3
)braket
op_add_assign
id|D
suffix:semicolon
id|digest
(braket
l_int|4
)braket
op_add_assign
id|E
suffix:semicolon
)brace
macro_line|#else
DECL|macro|HASH_BUFFER_SIZE
mdefine_line|#define HASH_BUFFER_SIZE 4
DECL|macro|HASH_TRANSFORM
mdefine_line|#define HASH_TRANSFORM MD5Transform
multiline_comment|/*&n; * MD5 transform algorithm, taken from code written by Colin Plumb,&n; * and put into the public domain&n; *&n; * QUESTION: Replace this with SHA, which as generally received better&n; * reviews from the cryptographic community?&n; */
multiline_comment|/* The four core functions - F1 is optimized somewhat */
multiline_comment|/* #define F1(x, y, z) (x &amp; y | ~x &amp; z) */
DECL|macro|F1
mdefine_line|#define F1(x, y, z) (z ^ (x &amp; (y ^ z)))
DECL|macro|F2
mdefine_line|#define F2(x, y, z) F1(z, x, y)
DECL|macro|F3
mdefine_line|#define F3(x, y, z) (x ^ y ^ z)
DECL|macro|F4
mdefine_line|#define F4(x, y, z) (y ^ (x | ~z))
multiline_comment|/* This is the central step in the MD5 algorithm. */
DECL|macro|MD5STEP
mdefine_line|#define MD5STEP(f, w, x, y, z, data, s) &bslash;&n;&t;( w += f(x, y, z) + data,  w = w&lt;&lt;s | w&gt;&gt;(32-s),  w += x )
multiline_comment|/*&n; * The core of the MD5 algorithm, this alters an existing MD5 hash to&n; * reflect the addition of 16 longwords of new data.  MD5Update blocks&n; * the data and converts bytes into longwords for this routine.&n; */
DECL|function|MD5Transform
r_static
r_void
id|MD5Transform
c_func
(paren
id|__u32
id|buf
(braket
l_int|4
)braket
comma
id|__u32
r_const
id|in
(braket
l_int|16
)braket
)paren
(brace
id|__u32
id|a
comma
id|b
comma
id|c
comma
id|d
suffix:semicolon
id|a
op_assign
id|buf
(braket
l_int|0
)braket
suffix:semicolon
id|b
op_assign
id|buf
(braket
l_int|1
)braket
suffix:semicolon
id|c
op_assign
id|buf
(braket
l_int|2
)braket
suffix:semicolon
id|d
op_assign
id|buf
(braket
l_int|3
)braket
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|0
)braket
op_plus
l_int|0xd76aa478
comma
l_int|7
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|1
)braket
op_plus
l_int|0xe8c7b756
comma
l_int|12
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|2
)braket
op_plus
l_int|0x242070db
comma
l_int|17
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|3
)braket
op_plus
l_int|0xc1bdceee
comma
l_int|22
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|4
)braket
op_plus
l_int|0xf57c0faf
comma
l_int|7
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|5
)braket
op_plus
l_int|0x4787c62a
comma
l_int|12
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|6
)braket
op_plus
l_int|0xa8304613
comma
l_int|17
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|7
)braket
op_plus
l_int|0xfd469501
comma
l_int|22
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|8
)braket
op_plus
l_int|0x698098d8
comma
l_int|7
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|9
)braket
op_plus
l_int|0x8b44f7af
comma
l_int|12
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|10
)braket
op_plus
l_int|0xffff5bb1
comma
l_int|17
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|11
)braket
op_plus
l_int|0x895cd7be
comma
l_int|22
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|12
)braket
op_plus
l_int|0x6b901122
comma
l_int|7
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|13
)braket
op_plus
l_int|0xfd987193
comma
l_int|12
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|14
)braket
op_plus
l_int|0xa679438e
comma
l_int|17
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|15
)braket
op_plus
l_int|0x49b40821
comma
l_int|22
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|1
)braket
op_plus
l_int|0xf61e2562
comma
l_int|5
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|6
)braket
op_plus
l_int|0xc040b340
comma
l_int|9
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|11
)braket
op_plus
l_int|0x265e5a51
comma
l_int|14
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|0
)braket
op_plus
l_int|0xe9b6c7aa
comma
l_int|20
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|5
)braket
op_plus
l_int|0xd62f105d
comma
l_int|5
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|10
)braket
op_plus
l_int|0x02441453
comma
l_int|9
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|15
)braket
op_plus
l_int|0xd8a1e681
comma
l_int|14
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|4
)braket
op_plus
l_int|0xe7d3fbc8
comma
l_int|20
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|9
)braket
op_plus
l_int|0x21e1cde6
comma
l_int|5
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|14
)braket
op_plus
l_int|0xc33707d6
comma
l_int|9
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|3
)braket
op_plus
l_int|0xf4d50d87
comma
l_int|14
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|8
)braket
op_plus
l_int|0x455a14ed
comma
l_int|20
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|13
)braket
op_plus
l_int|0xa9e3e905
comma
l_int|5
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|2
)braket
op_plus
l_int|0xfcefa3f8
comma
l_int|9
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|7
)braket
op_plus
l_int|0x676f02d9
comma
l_int|14
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|12
)braket
op_plus
l_int|0x8d2a4c8a
comma
l_int|20
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|5
)braket
op_plus
l_int|0xfffa3942
comma
l_int|4
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|8
)braket
op_plus
l_int|0x8771f681
comma
l_int|11
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|11
)braket
op_plus
l_int|0x6d9d6122
comma
l_int|16
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|14
)braket
op_plus
l_int|0xfde5380c
comma
l_int|23
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|1
)braket
op_plus
l_int|0xa4beea44
comma
l_int|4
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|4
)braket
op_plus
l_int|0x4bdecfa9
comma
l_int|11
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|7
)braket
op_plus
l_int|0xf6bb4b60
comma
l_int|16
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|10
)braket
op_plus
l_int|0xbebfbc70
comma
l_int|23
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|13
)braket
op_plus
l_int|0x289b7ec6
comma
l_int|4
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|0
)braket
op_plus
l_int|0xeaa127fa
comma
l_int|11
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|3
)braket
op_plus
l_int|0xd4ef3085
comma
l_int|16
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|6
)braket
op_plus
l_int|0x04881d05
comma
l_int|23
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|9
)braket
op_plus
l_int|0xd9d4d039
comma
l_int|4
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|12
)braket
op_plus
l_int|0xe6db99e5
comma
l_int|11
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|15
)braket
op_plus
l_int|0x1fa27cf8
comma
l_int|16
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|2
)braket
op_plus
l_int|0xc4ac5665
comma
l_int|23
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|0
)braket
op_plus
l_int|0xf4292244
comma
l_int|6
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|7
)braket
op_plus
l_int|0x432aff97
comma
l_int|10
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|14
)braket
op_plus
l_int|0xab9423a7
comma
l_int|15
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|5
)braket
op_plus
l_int|0xfc93a039
comma
l_int|21
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|12
)braket
op_plus
l_int|0x655b59c3
comma
l_int|6
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|3
)braket
op_plus
l_int|0x8f0ccc92
comma
l_int|10
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|10
)braket
op_plus
l_int|0xffeff47d
comma
l_int|15
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|1
)braket
op_plus
l_int|0x85845dd1
comma
l_int|21
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|8
)braket
op_plus
l_int|0x6fa87e4f
comma
l_int|6
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|15
)braket
op_plus
l_int|0xfe2ce6e0
comma
l_int|10
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|6
)braket
op_plus
l_int|0xa3014314
comma
l_int|15
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|13
)braket
op_plus
l_int|0x4e0811a1
comma
l_int|21
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|4
)braket
op_plus
l_int|0xf7537e82
comma
l_int|6
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|11
)braket
op_plus
l_int|0xbd3af235
comma
l_int|10
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|2
)braket
op_plus
l_int|0x2ad7d2bb
comma
l_int|15
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|9
)braket
op_plus
l_int|0xeb86d391
comma
l_int|21
)paren
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_add_assign
id|a
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_add_assign
id|b
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_add_assign
id|c
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_add_assign
id|d
suffix:semicolon
)brace
DECL|macro|F1
macro_line|#undef F1
DECL|macro|F2
macro_line|#undef F2
DECL|macro|F3
macro_line|#undef F3
DECL|macro|F4
macro_line|#undef F4
DECL|macro|MD5STEP
macro_line|#undef MD5STEP
macro_line|#endif
macro_line|#if POOLWORDS % 16
macro_line|#error extract_entropy() assumes that POOLWORDS is a multiple of 16 words.
macro_line|#endif
multiline_comment|/*&n; * This function extracts randomness from the &quot;entropy pool&quot;, and&n; * returns it in a buffer.  This function computes how many remaining&n; * bits of entropy are left in the pool, but it does not restrict the&n; * number of bytes that are actually obtained.&n; */
DECL|function|extract_entropy
r_static
r_int
id|extract_entropy
c_func
(paren
r_struct
id|random_bucket
op_star
id|r
comma
r_char
op_star
id|buf
comma
r_int
id|nbytes
comma
r_int
id|to_user
)paren
(brace
r_int
id|ret
comma
id|i
suffix:semicolon
id|__u32
id|tmp
(braket
id|HASH_BUFFER_SIZE
)braket
suffix:semicolon
r_char
op_star
id|cp
comma
op_star
id|dp
suffix:semicolon
r_if
c_cond
(paren
id|to_user
)paren
(brace
id|ret
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|buf
comma
id|nbytes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
)brace
id|add_timer_randomness
c_func
(paren
id|r
comma
op_amp
id|extract_timer_state
comma
id|nbytes
)paren
suffix:semicolon
multiline_comment|/* Redundant, but just in case... */
r_if
c_cond
(paren
id|r-&gt;entropy_count
OG
id|POOLBITS
)paren
id|r-&gt;entropy_count
op_assign
id|POOLBITS
suffix:semicolon
id|ret
op_assign
id|nbytes
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;entropy_count
op_div
l_int|8
op_ge
id|nbytes
)paren
id|r-&gt;entropy_count
op_sub_assign
id|nbytes
op_star
l_int|8
suffix:semicolon
r_else
id|r-&gt;entropy_count
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|nbytes
)paren
(brace
multiline_comment|/* Hash the pool to get the output */
id|tmp
(braket
l_int|0
)braket
op_assign
l_int|0x67452301
suffix:semicolon
id|tmp
(braket
l_int|1
)braket
op_assign
l_int|0xefcdab89
suffix:semicolon
id|tmp
(braket
l_int|2
)braket
op_assign
l_int|0x98badcfe
suffix:semicolon
id|tmp
(braket
l_int|3
)braket
op_assign
l_int|0x10325476
suffix:semicolon
macro_line|#ifdef USE_SHA
id|tmp
(braket
l_int|4
)braket
op_assign
l_int|0xc3d2e1f0
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|POOLWORDS
suffix:semicolon
id|i
op_add_assign
l_int|16
)paren
id|HASH_TRANSFORM
c_func
(paren
id|tmp
comma
id|r-&gt;pool
op_plus
id|i
)paren
suffix:semicolon
multiline_comment|/* Modify pool so next hash will produce different results */
id|add_entropy_word
c_func
(paren
id|r
comma
id|tmp
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|add_entropy_word
c_func
(paren
id|r
comma
id|tmp
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|add_entropy_word
c_func
(paren
id|r
comma
id|tmp
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|add_entropy_word
c_func
(paren
id|r
comma
id|tmp
(braket
l_int|3
)braket
)paren
suffix:semicolon
macro_line|#ifdef USE_SHA
id|add_entropy_word
c_func
(paren
id|r
comma
id|tmp
(braket
l_int|4
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;&t; * Run the hash transform one more time, since we want&n;&t;&t; * to add at least minimal obscuring of the inputs to&n;&t;&t; * add_entropy_word().&n;&t;&t; */
id|HASH_TRANSFORM
c_func
(paren
id|tmp
comma
id|r-&gt;pool
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * In case the hash function has some recognizable&n;&t;&t; * output pattern, we fold it in half.&n;&t;&t; */
id|cp
op_assign
(paren
r_char
op_star
)paren
id|tmp
suffix:semicolon
id|dp
op_assign
id|cp
op_plus
(paren
id|HASH_BUFFER_SIZE
op_star
r_sizeof
(paren
id|__u32
)paren
)paren
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|HASH_BUFFER_SIZE
op_star
r_sizeof
(paren
id|__u32
)paren
op_div
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|cp
op_xor_assign
op_star
id|dp
suffix:semicolon
id|cp
op_increment
suffix:semicolon
id|dp
op_decrement
suffix:semicolon
)brace
multiline_comment|/* Copy data to destination buffer */
id|i
op_assign
id|MIN
c_func
(paren
id|nbytes
comma
id|HASH_BUFFER_SIZE
op_star
r_sizeof
(paren
id|__u32
)paren
op_div
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|to_user
)paren
id|memcpy_tofs
c_func
(paren
id|buf
comma
(paren
id|__u8
r_const
op_star
)paren
id|tmp
comma
id|i
)paren
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|buf
comma
(paren
id|__u8
r_const
op_star
)paren
id|tmp
comma
id|i
)paren
suffix:semicolon
id|nbytes
op_sub_assign
id|i
suffix:semicolon
id|buf
op_add_assign
id|i
suffix:semicolon
id|add_timer_randomness
c_func
(paren
id|r
comma
op_amp
id|extract_timer_state
comma
id|nbytes
)paren
suffix:semicolon
)brace
multiline_comment|/* Wipe data from memory */
id|memset
c_func
(paren
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is the exported kernel interface.  It returns some&n; * number of good random numbers, suitable for seeding TCP sequence&n; * numbers, etc.&n; */
DECL|function|get_random_bytes
r_void
id|get_random_bytes
c_func
(paren
r_void
op_star
id|buf
comma
r_int
id|nbytes
)paren
(brace
id|extract_entropy
c_func
(paren
op_amp
id|random_state
comma
(paren
r_char
op_star
)paren
id|buf
comma
id|nbytes
comma
l_int|0
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|random_read
id|random_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|nbytes
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_int
id|n
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|random_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nbytes
OG
l_int|0
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|n
op_assign
id|nbytes
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
id|random_state.entropy_count
op_div
l_int|8
)paren
id|n
op_assign
id|random_state.entropy_count
op_div
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|n
op_assign
id|extract_entropy
c_func
(paren
op_amp
id|random_state
comma
id|buf
comma
id|n
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
id|retval
op_assign
id|n
suffix:semicolon
r_break
suffix:semicolon
)brace
id|count
op_add_assign
id|n
suffix:semicolon
id|buf
op_add_assign
id|n
suffix:semicolon
id|nbytes
op_sub_assign
id|n
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* This break makes the device work */
multiline_comment|/* like a named pipe */
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|random_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If we gave the user some bytes and we have an inode pointer,&n;&t; * update the access time.&n;&t; */
r_if
c_cond
(paren
id|inode
op_logical_and
id|count
op_ne
l_int|0
)paren
(brace
id|inode-&gt;i_atime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|inode-&gt;i_dirt
op_assign
l_int|1
suffix:semicolon
)brace
r_return
(paren
id|count
ques
c_cond
id|count
suffix:colon
id|retval
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|random_read_unlimited
id|random_read_unlimited
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|nbytes
)paren
(brace
r_return
id|extract_entropy
c_func
(paren
op_amp
id|random_state
comma
id|buf
comma
id|nbytes
comma
l_int|1
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|random_select
id|random_select
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
r_switch
c_cond
(paren
id|sel_type
)paren
(brace
r_case
id|SEL_IN
suffix:colon
r_if
c_cond
(paren
id|random_state.entropy_count
op_ge
l_int|8
)paren
r_return
l_int|1
suffix:semicolon
id|select_wait
c_func
(paren
op_amp
id|random_wait
comma
id|wait
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SEL_OUT
suffix:colon
r_if
c_cond
(paren
id|random_state.entropy_count
OL
id|WAIT_OUTPUT_BITS
)paren
r_return
l_int|1
suffix:semicolon
id|select_wait
c_func
(paren
op_amp
id|random_wait
comma
id|wait
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|random_write
id|random_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buffer
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
id|__u32
id|word
comma
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|buffer
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|count
comma
id|p
op_assign
(paren
id|__u32
op_star
)paren
id|buffer
suffix:semicolon
id|i
op_ge
r_sizeof
(paren
id|__u32
)paren
suffix:semicolon
id|i
op_sub_assign
r_sizeof
(paren
id|__u32
)paren
comma
id|p
op_increment
)paren
(brace
id|memcpy_fromfs
c_func
(paren
op_amp
id|word
comma
id|p
comma
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
id|add_entropy_word
c_func
(paren
op_amp
id|random_state
comma
id|word
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
)paren
(brace
id|word
op_assign
l_int|0
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|word
comma
id|p
comma
id|i
)paren
suffix:semicolon
id|add_entropy_word
c_func
(paren
op_amp
id|random_state
comma
id|word
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inode
)paren
(brace
id|inode-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
id|inode-&gt;i_dirt
op_assign
l_int|1
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
r_static
r_int
DECL|function|random_ioctl
id|random_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
op_star
id|p
comma
id|size
comma
id|ent_count
suffix:semicolon
r_int
id|retval
suffix:semicolon
multiline_comment|/*&n;&t; * Translate old 1.3.XX values.&n;&t; * Remove this code in 2.1.0.&n;&t; * &lt;mec@duracef.shout.net&gt;&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_int|0x01080000
suffix:colon
id|cmd
op_assign
id|RNDGETENTCNT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01080001
suffix:colon
id|cmd
op_assign
id|RNDADDTOENTCNT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01080002
suffix:colon
id|cmd
op_assign
id|RNDGETPOOL
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01080003
suffix:colon
id|cmd
op_assign
id|RNDADDENTROPY
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01080004
suffix:colon
id|cmd
op_assign
id|RNDZAPENTCNT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01080006
suffix:colon
id|cmd
op_assign
id|RNDCLEARPOOL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|RNDGETENTCNT
suffix:colon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|ent_count
op_assign
id|random_state.entropy_count
suffix:semicolon
id|put_user
c_func
(paren
id|ent_count
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|RNDADDTOENTCNT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|ent_count
op_assign
id|get_user
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Add i to entropy_count, limiting the result to be&n;&t;&t; * between 0 and POOLBITS.&n;&t;&t; */
r_if
c_cond
(paren
id|ent_count
OL
op_minus
id|random_state.entropy_count
)paren
id|random_state.entropy_count
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ent_count
OG
id|POOLBITS
)paren
id|random_state.entropy_count
op_assign
id|POOLBITS
suffix:semicolon
r_else
(brace
id|random_state.entropy_count
op_add_assign
id|ent_count
suffix:semicolon
r_if
c_cond
(paren
id|random_state.entropy_count
OG
id|POOLBITS
)paren
id|random_state.entropy_count
op_assign
id|POOLBITS
suffix:semicolon
r_if
c_cond
(paren
id|random_state.entropy_count
OL
l_int|0
)paren
id|random_state.entropy_count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Wake up waiting processes if we have enough&n;&t;&t; * entropy.&n;&t;&t; */
r_if
c_cond
(paren
id|random_state.entropy_count
op_ge
id|WAIT_INPUT_BITS
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|random_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|RNDGETPOOL
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|p
op_assign
(paren
r_int
op_star
)paren
id|arg
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|p
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|ent_count
op_assign
id|random_state.entropy_count
suffix:semicolon
id|put_user
c_func
(paren
id|ent_count
comma
id|p
op_increment
)paren
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|p
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|size
op_assign
id|get_user
c_func
(paren
id|p
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|POOLWORDS
comma
id|p
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|size
OG
id|POOLWORDS
)paren
id|size
op_assign
id|POOLWORDS
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|p
comma
id|size
op_star
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|p
comma
id|random_state.pool
comma
id|size
op_star
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|RNDADDENTROPY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|p
op_assign
(paren
r_int
op_star
)paren
id|arg
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|p
comma
l_int|2
op_star
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|ent_count
op_assign
id|get_user
c_func
(paren
id|p
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ent_count
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|size
op_assign
id|get_user
c_func
(paren
id|p
op_increment
)paren
suffix:semicolon
id|retval
op_assign
id|random_write
c_func
(paren
l_int|0
comma
id|file
comma
(paren
r_const
r_char
op_star
)paren
id|p
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Add ent_count to entropy_count, limiting the result to be&n;&t;&t; * between 0 and POOLBITS.&n;&t;&t; */
r_if
c_cond
(paren
id|ent_count
OG
id|POOLBITS
)paren
id|random_state.entropy_count
op_assign
id|POOLBITS
suffix:semicolon
r_else
(brace
id|random_state.entropy_count
op_add_assign
id|ent_count
suffix:semicolon
r_if
c_cond
(paren
id|random_state.entropy_count
OG
id|POOLBITS
)paren
id|random_state.entropy_count
op_assign
id|POOLBITS
suffix:semicolon
r_if
c_cond
(paren
id|random_state.entropy_count
OL
l_int|0
)paren
id|random_state.entropy_count
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Wake up waiting processes if we have enough&n;&t;&t; * entropy.&n;&t;&t; */
r_if
c_cond
(paren
id|random_state.entropy_count
op_ge
id|WAIT_INPUT_BITS
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|random_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|RNDZAPENTCNT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|random_state.entropy_count
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|RNDCLEARPOOL
suffix:colon
multiline_comment|/* Clear the entropy pool and associated counters. */
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|rand_clear_pool
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|variable|random_fops
r_struct
id|file_operations
id|random_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* random_lseek */
id|random_read
comma
id|random_write
comma
l_int|NULL
comma
multiline_comment|/* random_readdir */
id|random_select
comma
multiline_comment|/* random_select */
id|random_ioctl
comma
l_int|NULL
comma
multiline_comment|/* random_mmap */
l_int|NULL
comma
multiline_comment|/* no special open code */
l_int|NULL
multiline_comment|/* no special release code */
)brace
suffix:semicolon
DECL|variable|urandom_fops
r_struct
id|file_operations
id|urandom_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* unrandom_lseek */
id|random_read_unlimited
comma
id|random_write
comma
l_int|NULL
comma
multiline_comment|/* urandom_readdir */
l_int|NULL
comma
multiline_comment|/* urandom_select */
id|random_ioctl
comma
l_int|NULL
comma
multiline_comment|/* urandom_mmap */
l_int|NULL
comma
multiline_comment|/* no special open code */
l_int|NULL
multiline_comment|/* no special release code */
)brace
suffix:semicolon
multiline_comment|/*&n; * TCP initial sequence number picking.  This uses the random number&n; * generator to pick an initial secret value.  This value is hashed&n; * along with the TCP endpoint information to provide a unique&n; * starting point for each pair of TCP endpoints.  This defeats&n; * attacks which rely on guessing the initial TCP sequence number.&n; * This algorithm was suggested by Steve Bellovin.&n; */
DECL|function|secure_tcp_sequence_number
id|__u32
id|secure_tcp_sequence_number
c_func
(paren
id|__u32
id|saddr
comma
id|__u32
id|daddr
comma
id|__u16
id|sport
comma
id|__u16
id|dport
)paren
(brace
r_static
r_int
id|is_init
op_assign
l_int|0
suffix:semicolon
r_static
id|__u32
id|secret
(braket
l_int|16
)braket
suffix:semicolon
r_struct
id|timeval
id|tv
suffix:semicolon
id|__u32
id|tmp
(braket
l_int|16
)braket
suffix:semicolon
id|__u32
id|seq
suffix:semicolon
multiline_comment|/*&n;&t; * Pick a random secret the first time we open a TCP&n;&t; * connection.&n;&t; */
r_if
c_cond
(paren
id|is_init
op_eq
l_int|0
)paren
(brace
id|get_random_bytes
c_func
(paren
op_amp
id|secret
comma
r_sizeof
(paren
id|secret
)paren
)paren
suffix:semicolon
id|is_init
op_assign
l_int|1
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|tmp
comma
id|secret
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Pick a unique starting offset for each&n;&t; * TCP connection endpoints (saddr, daddr, sport, dport)&n;&t; */
id|tmp
(braket
l_int|8
)braket
op_assign
id|saddr
suffix:semicolon
id|tmp
(braket
l_int|9
)braket
op_assign
id|daddr
suffix:semicolon
id|tmp
(braket
l_int|10
)braket
op_assign
(paren
id|sport
op_lshift
l_int|16
)paren
op_plus
id|dport
suffix:semicolon
id|HASH_TRANSFORM
c_func
(paren
id|tmp
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;As close as possible to RFC 793, which&n;&t; *&t;suggests using a 250kHz clock.&n;&t; *&t;Further reading shows this assumes 2MB/s networks.&n;&t; *&t;For 10MB/s ethernet, a 1MHz clock is appropriate.&n;&t; *&t;That&squot;s funny, Linux has one built in!  Use it!&n;&t; */
id|do_gettimeofday
c_func
(paren
op_amp
id|tv
)paren
suffix:semicolon
id|seq
op_assign
id|tmp
(braket
l_int|1
)braket
op_plus
id|tv.tv_usec
op_plus
id|tv.tv_sec
op_star
l_int|1000000
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;init_seq(%lx, %lx, %d, %d) = %d&bslash;n&quot;
comma
id|saddr
comma
id|daddr
comma
id|sport
comma
id|dport
comma
id|seq
)paren
suffix:semicolon
macro_line|#endif
r_return
(paren
id|seq
)paren
suffix:semicolon
)brace
macro_line|#ifdef RANDOM_BENCHMARK
multiline_comment|/*&n; * This is so we can do some benchmarking of the random driver, to see&n; * how much overhead add_timer_randomness really takes.  This only&n; * works on a Pentium, since it depends on the timer clock...&n; *&n; * Note: the results of this benchmark as of this writing (5/27/96)&n; *&n; * On a Pentium, add_timer_randomness() takes between 150 and 1000&n; * clock cycles, with an average of around 600 clock cycles.  On a 75&n; * MHz Pentium, this translates to 2 to 13 microseconds, with an&n; * average time of 8 microseconds.  This should be fast enough so we&n; * can use add_timer_randomness() even with the fastest of interrupts...&n; */
DECL|function|get_clock_cnt
r_static
r_inline
r_int
r_int
r_int
id|get_clock_cnt
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|low
comma
id|high
suffix:semicolon
id|__asm__
c_func
(paren
l_string|&quot;.byte 0x0f,0x31&quot;
suffix:colon
l_string|&quot;=a&quot;
(paren
id|low
)paren
comma
l_string|&quot;=d&quot;
(paren
id|high
)paren
)paren
suffix:semicolon
r_return
(paren
(paren
(paren
r_int
r_int
r_int
)paren
id|high
op_lshift
l_int|31
)paren
op_or
id|low
)paren
suffix:semicolon
)brace
DECL|function|initialize_benchmark
r_static
r_void
id|initialize_benchmark
c_func
(paren
r_struct
id|random_benchmark
op_star
id|bench
comma
r_const
r_char
op_star
id|descr
comma
r_int
id|unit
)paren
(brace
id|bench-&gt;times
op_assign
l_int|0
suffix:semicolon
id|bench-&gt;accum
op_assign
l_int|0
suffix:semicolon
id|bench-&gt;max
op_assign
l_int|0
suffix:semicolon
id|bench-&gt;min
op_assign
l_int|1
op_lshift
l_int|31
suffix:semicolon
id|bench-&gt;descr
op_assign
id|descr
suffix:semicolon
id|bench-&gt;unit
op_assign
id|unit
suffix:semicolon
)brace
DECL|function|begin_benchmark
r_static
r_void
id|begin_benchmark
c_func
(paren
r_struct
id|random_benchmark
op_star
id|bench
)paren
(brace
macro_line|#ifdef BENCHMARK_NOINT
id|save_flags
c_func
(paren
id|bench-&gt;flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|bench-&gt;start_time
op_assign
id|get_clock_cnt
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|end_benchmark
r_static
r_void
id|end_benchmark
c_func
(paren
r_struct
id|random_benchmark
op_star
id|bench
)paren
(brace
r_int
r_int
id|ticks
suffix:semicolon
id|ticks
op_assign
(paren
r_int
r_int
)paren
(paren
id|get_clock_cnt
c_func
(paren
)paren
op_minus
id|bench-&gt;start_time
)paren
suffix:semicolon
macro_line|#ifdef BENCHMARK_NOINT
id|restore_flags
c_func
(paren
id|bench-&gt;flags
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|ticks
OL
id|bench-&gt;min
)paren
id|bench-&gt;min
op_assign
id|ticks
suffix:semicolon
r_if
c_cond
(paren
id|ticks
OG
id|bench-&gt;max
)paren
id|bench-&gt;max
op_assign
id|ticks
suffix:semicolon
id|bench-&gt;accum
op_add_assign
id|ticks
suffix:semicolon
id|bench-&gt;times
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|bench-&gt;times
op_eq
id|BENCHMARK_INTERVAL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Random benchmark: %s %d: %lu min, %lu avg, &quot;
l_string|&quot;%lu max&bslash;n&quot;
comma
id|bench-&gt;descr
comma
id|bench-&gt;unit
comma
id|bench-&gt;min
comma
id|bench-&gt;accum
op_div
id|BENCHMARK_INTERVAL
comma
id|bench-&gt;max
)paren
suffix:semicolon
id|bench-&gt;times
op_assign
l_int|0
suffix:semicolon
id|bench-&gt;accum
op_assign
l_int|0
suffix:semicolon
id|bench-&gt;max
op_assign
l_int|0
suffix:semicolon
id|bench-&gt;min
op_assign
l_int|1
op_lshift
l_int|31
suffix:semicolon
)brace
)brace
macro_line|#endif /* RANDOM_BENCHMARK */
eof
