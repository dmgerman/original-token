multiline_comment|/*&n; * random.c -- A strong random number generator&n; *&n; * Version 0.92, last modified 21-Sep-95&n; * &n; * Copyright Theodore Ts&squot;o, 1994, 1995.  All rights reserved.&n; *&n; * Redistribution and use in source and binary forms, with or without&n; * modification, are permitted provided that the following conditions&n; * are met:&n; * 1. Redistributions of source code must retain the above copyright&n; *    notice, and the entire permission notice in its entirety,&n; *    including the disclaimer of warranties.&n; * 2. Redistributions in binary form must reproduce the above copyright&n; *    notice, this list of conditions and the following disclaimer in the&n; *    documentation and/or other materials provided with the distribution.&n; * 3. The name of the author may not be used to endorse or promote&n; *    products derived from this software without specific prior&n; *    written permission.&n; * &n; * ALTERNATIVELY, this product may be distributed under the terms of&n; * the GNU Public License, in which case the provisions of the GPL are&n; * required INSTEAD OF the above restrictions.  (This clause is&n; * necessary due to a potential bad interaction between the GPL and&n; * the restrictions contained in a BSD-style copyright.)&n; * &n; * THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES&n; * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&n; * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,&n; * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES&n; * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR&n; * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,&n; * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)&n; * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED&n; * OF THE POSSIBILITY OF SUCH DAMAGE.&n; */
multiline_comment|/*&n; * (now, with legal B.S. out of the way.....) &n; * &n; * This routine gathers environmental noise from device drivers, etc.,&n; * and returns good random numbers, suitable for cryptographic use.&n; * Besides the obvious cryptographic uses, these numbers are also good&n; * for seeding TCP sequence numbers, and other places where it is&n; * desireable to have numbers which are not only random, but hard to&n; * predict by an attacker.&n; *&n; * Theory of operation&n; * ===================&n; * &n; * Computers are very predictable devices.  Hence it is extremely hard&n; * to produce truely random numbers on a computer --- as opposed to&n; * pseudo-random numbers, which can easily generated by using a&n; * algorithm.  Unfortunately, it is very easy for attackers to guess&n; * the sequence of pseudo-random number generators, and for some&n; * applications this is not acceptable.  So instead, we must try to&n; * gather &quot;environmental noise&quot; from the computer&squot;s environment, which&n; * must be hard for outside attackers to observe, and use that to&n; * generate random numbers.  In a Unix environment, this is best done&n; * from inside the kernel.&n; * &n; * Sources of randomness from the environment include inter-keyboard&n; * timings, inter-interrupt timings from some interrupts, and other&n; * events which are both (a) non-deterministic and (b) hard for an&n; * outside observer to measure.  Randomness from these sources are&n; * added to an &quot;entropy pool&quot;, which is periodically mixed using the&n; * MD5 compression function in CBC mode.  As random bytes are mixed&n; * into the entropy pool, the routines keep an *estimate* of how many&n; * bits of randomness have been stored into the random number&n; * generator&squot;s internal state.&n; * &n; * When random bytes are desired, they are obtained by taking the MD5&n; * hash of a counter plus the contents of the &quot;entropy pool&quot;.  The&n; * reason for the MD5 hash is so that we can avoid exposing the&n; * internal state of random number generator.  Although the MD5 hash&n; * does protect the pool, as each random byte which is generated from&n; * the pool reveals some information which was derived from the&n; * internal state, and thus increasing the amount of information an&n; * outside attacker has available to try to make some guesses about&n; * the random number generator&squot;s internal state.  For this reason,&n; * the routine decreases its internal estimate of how many bits of&n; * &quot;true randomness&quot; are contained in the entropy pool as it outputs&n; * random numbers.&n; * &n; * If this estimate goes to zero, the routine can still generate random&n; * numbers; however it may now be possible for an attacker to analyze&n; * the output of the random number generator, and the MD5 algorithm,&n; * and thus have some success in guessing the output of the routine.&n; * Phil Karn (who devised this mechanism of using MD5 plus a counter&n; * to extract random numbers from an entropy pool) calls this&n; * &quot;practical randomness&quot;, since in the worse case this is equivalent&n; * to hashing MD5 with a counter and an undisclosed secret.  If MD5 is&n; * a strong cryptographic hash, this should be fairly resistant to attack.&n; * &n; * Exported interfaces ---- output&n; * ===============================&n; * &n; * There are three exported interfaces; the first is one designed to&n; * be used from within the kernel:&n; *&n; * &t;void get_random_bytes(void *buf, int nbytes);&n; *&n; * This interface will return the requested number of random bytes,&n; * and place it in the requested buffer.&n; * &n; * The two other interfaces are two character devices /dev/random and&n; * /dev/urandom.  /dev/random is suitable for use when very high&n; * quality randomness is desired (for example, for key generation.),&n; * as it will only return a maximum of the number of bits of&n; * randomness (as estimated by the random number generator) contained&n; * in the entropy pool.&n; * &n; * The /dev/urandom device does not have this limit, and will return&n; * as many bytes as are requested.  As more and more random bytes are&n; * requested without giving time for the entropy pool to recharge,&n; * this will result in lower quality random numbers.  For many&n; * applications, however, this is acceptable.&n; *&n; * Exported interfaces ---- input&n; * ==============================&n; *&n; * The two current exported interfaces for gathering environmental&n; * noise from the devices are:&n; * &n; * &t;void add_keyboard_randomness(unsigned char scancode);&n; * &t;void add_interrupt_randomness(int irq);&n; * &n; * The first function uses the inter-keypress timing, as well as the&n; * scancode as random inputs into the &quot;entropy pool&quot;.&n; *&n; * The second function uses the inter-interrupt timing as random&n; * inputs to the entropy pool.  Note that not all interrupts are good&n; * sources of randomness!  For example, the timer interrupts is not a&n; * good choice, because the periodicity of the interrupts is to&n; * regular, and hence predictable to an attacker.  Disk interrupts are&n; * a better measure, since the timing of the disk interrupts are more&n; * unpredictable.  The routines try to estimate how many bits of&n; * randomness a particular interrupt channel offers, by keeping track&n; * of the first and second order deltas in the interrupt timings.&n; *&n; * Acknowledgements:&n; * =================&n; * &n; * Ideas for constructing this random number generator were derived&n; * from the Pretty Good Privacy&squot;s random number generator, and from&n; * private discussions with Phil Karn.  This design has been further&n; * modified by myself, so any flaws are solely my responsibility, and&n; * should not be attributed to the authors of PGP or to Phil.&n; * &n; * The code for MD5 transform was taken from Colin Plumb&squot;s&n; * implementation, which has been placed in the public domain.  The&n; * MD5 cryptographic checksum was devised by Ronald Rivest, and is&n; * documented in RFC 1321, &quot;The MD5 Message Digest Algorithm&quot;.&n; * &n; * Further background information on this topic may be obtained from&n; * RFC 1750, &quot;Randomness Recommendations for Security&quot;, by Donald&n; * Eastlake, Steve Crocker, and Jeff Schiller.&n; */
macro_line|#ifdef linux
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#endif
macro_line|#ifdef CONFIG_RANDOM
DECL|macro|RANDPOOL
mdefine_line|#define RANDPOOL 512
DECL|struct|random_bucket
r_struct
id|random_bucket
(brace
DECL|member|add_ptr
r_int
id|add_ptr
suffix:semicolon
DECL|member|entropy_count
r_int
id|entropy_count
suffix:semicolon
DECL|member|length
r_int
id|length
suffix:semicolon
DECL|member|bit_length
r_int
id|bit_length
suffix:semicolon
DECL|member|delay_mix
r_int
id|delay_mix
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pool
id|__u8
op_star
id|pool
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|timer_rand_state
r_struct
id|timer_rand_state
(brace
DECL|member|last_time
r_int
r_int
id|last_time
suffix:semicolon
DECL|member|last_delta
r_int
id|last_delta
suffix:semicolon
DECL|member|nbits
r_int
id|nbits
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|random_state
r_static
r_struct
id|random_bucket
id|random_state
suffix:semicolon
DECL|variable|rand_pool_key
r_static
id|__u32
id|rand_pool_key
(braket
l_int|16
)braket
suffix:semicolon
DECL|variable|random_pool
r_static
id|__u8
id|random_pool
(braket
id|RANDPOOL
)braket
suffix:semicolon
DECL|variable|random_counter
r_static
id|__u32
id|random_counter
(braket
l_int|16
)braket
suffix:semicolon
DECL|variable|keyboard_timer_state
r_static
r_struct
id|timer_rand_state
id|keyboard_timer_state
suffix:semicolon
DECL|variable|irq_timer_state
r_static
r_struct
id|timer_rand_state
id|irq_timer_state
(braket
id|NR_IRQS
)braket
suffix:semicolon
macro_line|#ifndef MIN
DECL|macro|MIN
mdefine_line|#define MIN(a,b) (((a) &lt; (b)) ? (a) : (b))
macro_line|#endif
DECL|function|flush_random
r_static
r_void
id|flush_random
c_func
(paren
r_struct
id|random_bucket
op_star
id|random_state
)paren
(brace
id|random_state-&gt;add_ptr
op_assign
l_int|0
suffix:semicolon
id|random_state-&gt;bit_length
op_assign
id|random_state-&gt;length
op_star
l_int|8
suffix:semicolon
id|random_state-&gt;entropy_count
op_assign
l_int|0
suffix:semicolon
id|random_state-&gt;delay_mix
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|rand_initialize
r_void
id|rand_initialize
c_func
(paren
r_void
)paren
(brace
id|random_state.length
op_assign
id|RANDPOOL
suffix:semicolon
id|random_state.pool
op_assign
id|random_pool
suffix:semicolon
id|flush_random
c_func
(paren
op_amp
id|random_state
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * MD5 transform algorithm, taken from code written by Colin Plumb,&n; * and put into the public domain&n; */
multiline_comment|/* The four core functions - F1 is optimized somewhat */
multiline_comment|/* #define F1(x, y, z) (x &amp; y | ~x &amp; z) */
DECL|macro|F1
mdefine_line|#define F1(x, y, z) (z ^ (x &amp; (y ^ z)))
DECL|macro|F2
mdefine_line|#define F2(x, y, z) F1(z, x, y)
DECL|macro|F3
mdefine_line|#define F3(x, y, z) (x ^ y ^ z)
DECL|macro|F4
mdefine_line|#define F4(x, y, z) (y ^ (x | ~z))
multiline_comment|/* This is the central step in the MD5 algorithm. */
DECL|macro|MD5STEP
mdefine_line|#define MD5STEP(f, w, x, y, z, data, s) &bslash;&n;&t;( w += f(x, y, z) + data,  w = w&lt;&lt;s | w&gt;&gt;(32-s),  w += x )
multiline_comment|/*&n; * The core of the MD5 algorithm, this alters an existing MD5 hash to&n; * reflect the addition of 16 longwords of new data.  MD5Update blocks&n; * the data and converts bytes into longwords for this routine.&n; */
DECL|function|MD5Transform
r_static
r_void
id|MD5Transform
c_func
(paren
id|__u32
id|buf
(braket
l_int|4
)braket
comma
id|__u32
r_const
id|in
(braket
l_int|16
)braket
)paren
(brace
id|__u32
id|a
comma
id|b
comma
id|c
comma
id|d
suffix:semicolon
id|a
op_assign
id|buf
(braket
l_int|0
)braket
suffix:semicolon
id|b
op_assign
id|buf
(braket
l_int|1
)braket
suffix:semicolon
id|c
op_assign
id|buf
(braket
l_int|2
)braket
suffix:semicolon
id|d
op_assign
id|buf
(braket
l_int|3
)braket
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|0
)braket
op_plus
l_int|0xd76aa478
comma
l_int|7
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|1
)braket
op_plus
l_int|0xe8c7b756
comma
l_int|12
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|2
)braket
op_plus
l_int|0x242070db
comma
l_int|17
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|3
)braket
op_plus
l_int|0xc1bdceee
comma
l_int|22
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|4
)braket
op_plus
l_int|0xf57c0faf
comma
l_int|7
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|5
)braket
op_plus
l_int|0x4787c62a
comma
l_int|12
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|6
)braket
op_plus
l_int|0xa8304613
comma
l_int|17
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|7
)braket
op_plus
l_int|0xfd469501
comma
l_int|22
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|8
)braket
op_plus
l_int|0x698098d8
comma
l_int|7
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|9
)braket
op_plus
l_int|0x8b44f7af
comma
l_int|12
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|10
)braket
op_plus
l_int|0xffff5bb1
comma
l_int|17
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|11
)braket
op_plus
l_int|0x895cd7be
comma
l_int|22
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|12
)braket
op_plus
l_int|0x6b901122
comma
l_int|7
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|13
)braket
op_plus
l_int|0xfd987193
comma
l_int|12
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|14
)braket
op_plus
l_int|0xa679438e
comma
l_int|17
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F1
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|15
)braket
op_plus
l_int|0x49b40821
comma
l_int|22
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|1
)braket
op_plus
l_int|0xf61e2562
comma
l_int|5
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|6
)braket
op_plus
l_int|0xc040b340
comma
l_int|9
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|11
)braket
op_plus
l_int|0x265e5a51
comma
l_int|14
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|0
)braket
op_plus
l_int|0xe9b6c7aa
comma
l_int|20
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|5
)braket
op_plus
l_int|0xd62f105d
comma
l_int|5
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|10
)braket
op_plus
l_int|0x02441453
comma
l_int|9
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|15
)braket
op_plus
l_int|0xd8a1e681
comma
l_int|14
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|4
)braket
op_plus
l_int|0xe7d3fbc8
comma
l_int|20
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|9
)braket
op_plus
l_int|0x21e1cde6
comma
l_int|5
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|14
)braket
op_plus
l_int|0xc33707d6
comma
l_int|9
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|3
)braket
op_plus
l_int|0xf4d50d87
comma
l_int|14
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|8
)braket
op_plus
l_int|0x455a14ed
comma
l_int|20
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|13
)braket
op_plus
l_int|0xa9e3e905
comma
l_int|5
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|2
)braket
op_plus
l_int|0xfcefa3f8
comma
l_int|9
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|7
)braket
op_plus
l_int|0x676f02d9
comma
l_int|14
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F2
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|12
)braket
op_plus
l_int|0x8d2a4c8a
comma
l_int|20
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|5
)braket
op_plus
l_int|0xfffa3942
comma
l_int|4
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|8
)braket
op_plus
l_int|0x8771f681
comma
l_int|11
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|11
)braket
op_plus
l_int|0x6d9d6122
comma
l_int|16
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|14
)braket
op_plus
l_int|0xfde5380c
comma
l_int|23
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|1
)braket
op_plus
l_int|0xa4beea44
comma
l_int|4
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|4
)braket
op_plus
l_int|0x4bdecfa9
comma
l_int|11
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|7
)braket
op_plus
l_int|0xf6bb4b60
comma
l_int|16
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|10
)braket
op_plus
l_int|0xbebfbc70
comma
l_int|23
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|13
)braket
op_plus
l_int|0x289b7ec6
comma
l_int|4
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|0
)braket
op_plus
l_int|0xeaa127fa
comma
l_int|11
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|3
)braket
op_plus
l_int|0xd4ef3085
comma
l_int|16
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|6
)braket
op_plus
l_int|0x04881d05
comma
l_int|23
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|9
)braket
op_plus
l_int|0xd9d4d039
comma
l_int|4
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|12
)braket
op_plus
l_int|0xe6db99e5
comma
l_int|11
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|15
)braket
op_plus
l_int|0x1fa27cf8
comma
l_int|16
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F3
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|2
)braket
op_plus
l_int|0xc4ac5665
comma
l_int|23
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|0
)braket
op_plus
l_int|0xf4292244
comma
l_int|6
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|7
)braket
op_plus
l_int|0x432aff97
comma
l_int|10
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|14
)braket
op_plus
l_int|0xab9423a7
comma
l_int|15
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|5
)braket
op_plus
l_int|0xfc93a039
comma
l_int|21
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|12
)braket
op_plus
l_int|0x655b59c3
comma
l_int|6
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|3
)braket
op_plus
l_int|0x8f0ccc92
comma
l_int|10
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|10
)braket
op_plus
l_int|0xffeff47d
comma
l_int|15
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|1
)braket
op_plus
l_int|0x85845dd1
comma
l_int|21
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|8
)braket
op_plus
l_int|0x6fa87e4f
comma
l_int|6
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|15
)braket
op_plus
l_int|0xfe2ce6e0
comma
l_int|10
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|6
)braket
op_plus
l_int|0xa3014314
comma
l_int|15
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|13
)braket
op_plus
l_int|0x4e0811a1
comma
l_int|21
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|a
comma
id|b
comma
id|c
comma
id|d
comma
id|in
(braket
l_int|4
)braket
op_plus
l_int|0xf7537e82
comma
l_int|6
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|d
comma
id|a
comma
id|b
comma
id|c
comma
id|in
(braket
l_int|11
)braket
op_plus
l_int|0xbd3af235
comma
l_int|10
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|c
comma
id|d
comma
id|a
comma
id|b
comma
id|in
(braket
l_int|2
)braket
op_plus
l_int|0x2ad7d2bb
comma
l_int|15
)paren
suffix:semicolon
id|MD5STEP
c_func
(paren
id|F4
comma
id|b
comma
id|c
comma
id|d
comma
id|a
comma
id|in
(braket
l_int|9
)braket
op_plus
l_int|0xeb86d391
comma
l_int|21
)paren
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_add_assign
id|a
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_add_assign
id|b
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_add_assign
id|c
suffix:semicolon
id|buf
(braket
l_int|3
)braket
op_add_assign
id|d
suffix:semicolon
)brace
DECL|macro|F1
macro_line|#undef F1
DECL|macro|F2
macro_line|#undef F2
DECL|macro|F3
macro_line|#undef F3
DECL|macro|F4
macro_line|#undef F4
DECL|macro|MD5STEP
macro_line|#undef MD5STEP
multiline_comment|/*&n; * The function signature should be take a struct random_bucket * as&n; * input, but this makes tqueue unhappy.&n; */
DECL|function|mix_bucket
r_static
r_void
id|mix_bucket
c_func
(paren
r_void
op_star
id|v
)paren
(brace
r_struct
id|random_bucket
op_star
id|r
op_assign
(paren
r_struct
id|random_bucket
op_star
)paren
id|v
suffix:semicolon
r_int
id|i
comma
id|num_passes
suffix:semicolon
id|__u32
op_star
id|p
suffix:semicolon
id|__u32
id|iv
(braket
l_int|4
)braket
suffix:semicolon
id|r-&gt;delay_mix
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start IV from last block of the random pool */
id|memcpy
c_func
(paren
id|iv
comma
id|r-&gt;pool
op_plus
id|r-&gt;length
op_minus
r_sizeof
(paren
id|iv
)paren
comma
r_sizeof
(paren
id|iv
)paren
)paren
suffix:semicolon
id|num_passes
op_assign
id|r-&gt;length
op_div
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|p
op_assign
(paren
id|__u32
op_star
)paren
id|r-&gt;pool
suffix:semicolon
id|i
OL
id|num_passes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|MD5Transform
c_func
(paren
id|iv
comma
id|rand_pool_key
)paren
suffix:semicolon
id|iv
(braket
l_int|0
)braket
op_assign
(paren
op_star
id|p
op_increment
op_xor_assign
id|iv
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|iv
(braket
l_int|1
)braket
op_assign
(paren
op_star
id|p
op_increment
op_xor_assign
id|iv
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|iv
(braket
l_int|2
)braket
op_assign
(paren
op_star
id|p
op_increment
op_xor_assign
id|iv
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|iv
(braket
l_int|3
)braket
op_assign
(paren
op_star
id|p
op_increment
op_xor_assign
id|iv
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|rand_pool_key
comma
id|r-&gt;pool
comma
r_sizeof
(paren
id|rand_pool_key
)paren
)paren
suffix:semicolon
multiline_comment|/* Wipe iv from memory */
id|memset
c_func
(paren
id|iv
comma
l_int|0
comma
r_sizeof
(paren
id|iv
)paren
)paren
suffix:semicolon
id|r-&gt;add_ptr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function adds a byte into the entropy &quot;pool&quot;.  It does not&n; * update the entropy estimate.  The caller must do this if appropriate.&n; */
DECL|function|add_entropy_byte
r_static
r_inline
r_void
id|add_entropy_byte
c_func
(paren
r_struct
id|random_bucket
op_star
id|r
comma
r_const
id|__u8
id|ch
comma
r_int
id|delay
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|delay
op_logical_and
id|r-&gt;delay_mix
)paren
id|mix_bucket
c_func
(paren
id|r
)paren
suffix:semicolon
id|r-&gt;pool
(braket
id|r-&gt;add_ptr
op_increment
)braket
op_xor_assign
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;add_ptr
op_ge
id|r-&gt;length
)paren
(brace
r_if
c_cond
(paren
id|delay
)paren
(brace
id|r-&gt;delay_mix
op_assign
l_int|1
suffix:semicolon
id|r-&gt;add_ptr
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|mix_bucket
c_func
(paren
id|r
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This function adds some number of bytes into the entropy pool and&n; * updates the entropy count as appropriate.&n; */
DECL|function|add_entropy
r_void
id|add_entropy
c_func
(paren
r_struct
id|random_bucket
op_star
id|r
comma
r_const
id|__u8
op_star
id|ptr
comma
r_int
id|length
comma
r_int
id|entropy_level
comma
r_int
id|delay
)paren
(brace
r_while
c_loop
(paren
id|length
op_decrement
OG
l_int|0
)paren
id|add_entropy_byte
c_func
(paren
id|r
comma
op_star
id|ptr
op_increment
comma
id|delay
)paren
suffix:semicolon
id|r-&gt;entropy_count
op_add_assign
id|entropy_level
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;entropy_count
OG
id|r-&gt;length
op_star
l_int|8
)paren
id|r-&gt;entropy_count
op_assign
id|r-&gt;length
op_star
l_int|8
suffix:semicolon
)brace
multiline_comment|/*&n; * This function adds entropy to the entropy &quot;pool&quot; by using timing&n; * delays.  It uses the timer_rand_state structure to make an estimate&n; * of how many bits of entropy this call has added to the pool.&n; */
DECL|function|add_timer_randomness
r_static
r_void
id|add_timer_randomness
c_func
(paren
r_struct
id|random_bucket
op_star
id|r
comma
r_struct
id|timer_rand_state
op_star
id|state
comma
r_int
id|delay
)paren
(brace
r_int
id|delta
comma
id|delta2
suffix:semicolon
r_int
id|nbits
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate number of bits of randomness we probably&n;&t; * added.  We take into account the first and second order&n;&t; * delta&squot;s in order to make our estimate.&n;&t; */
id|delta
op_assign
id|jiffies
op_minus
id|state-&gt;last_time
suffix:semicolon
id|delta2
op_assign
id|delta
op_minus
id|state-&gt;last_delta
suffix:semicolon
id|state-&gt;last_time
op_assign
id|jiffies
suffix:semicolon
id|state-&gt;last_delta
op_assign
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|delta
OL
l_int|0
)paren
id|delta
op_assign
op_minus
id|delta
suffix:semicolon
r_if
c_cond
(paren
id|delta2
OL
l_int|0
)paren
id|delta2
op_assign
op_minus
id|delta2
suffix:semicolon
id|delta
op_assign
id|MIN
c_func
(paren
id|delta
comma
id|delta2
)paren
op_rshift
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|nbits
op_assign
l_int|0
suffix:semicolon
id|delta
suffix:semicolon
id|nbits
op_increment
)paren
id|delta
op_rshift_assign
l_int|1
suffix:semicolon
id|add_entropy
c_func
(paren
id|r
comma
(paren
id|__u8
op_star
)paren
op_amp
id|jiffies
comma
r_sizeof
(paren
id|jiffies
)paren
comma
id|nbits
comma
id|delay
)paren
suffix:semicolon
macro_line|#if defined (__i386__)
multiline_comment|/*&n;&t; * On a 386, read the high resolution timer.  We assume that&n;&t; * this gives us 2 bits of randomness.  XXX This needs&n;&t; * investigation.&n;&t; */
id|outb_p
c_func
(paren
l_int|0x00
comma
l_int|0x43
)paren
suffix:semicolon
multiline_comment|/* latch the count ASAP */
id|add_entropy_byte
c_func
(paren
id|r
comma
id|inb_p
c_func
(paren
l_int|0x40
)paren
comma
l_int|1
)paren
suffix:semicolon
id|add_entropy_byte
c_func
(paren
id|r
comma
id|inb
c_func
(paren
l_int|0x40
)paren
comma
l_int|1
)paren
suffix:semicolon
id|r-&gt;entropy_count
op_add_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;entropy_count
OG
id|r-&gt;bit_length
)paren
id|r-&gt;entropy_count
op_assign
id|r-&gt;bit_length
suffix:semicolon
macro_line|#endif
)brace
DECL|function|add_keyboard_randomness
r_void
id|add_keyboard_randomness
c_func
(paren
r_int
r_char
id|scancode
)paren
(brace
r_struct
id|random_bucket
op_star
id|r
op_assign
op_amp
id|random_state
suffix:semicolon
id|add_timer_randomness
c_func
(paren
id|r
comma
op_amp
id|keyboard_timer_state
comma
l_int|0
)paren
suffix:semicolon
id|add_entropy_byte
c_func
(paren
id|r
comma
id|scancode
comma
l_int|0
)paren
suffix:semicolon
id|r-&gt;entropy_count
op_add_assign
l_int|6
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;entropy_count
OG
id|r-&gt;bit_length
)paren
id|r-&gt;entropy_count
op_assign
id|r-&gt;bit_length
suffix:semicolon
)brace
DECL|function|add_interrupt_randomness
r_void
id|add_interrupt_randomness
c_func
(paren
r_int
id|irq
)paren
(brace
r_struct
id|random_bucket
op_star
id|r
op_assign
op_amp
id|random_state
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ge
id|NR_IRQS
)paren
r_return
suffix:semicolon
id|add_timer_randomness
c_func
(paren
id|r
comma
op_amp
id|irq_timer_state
(braket
id|irq
)braket
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function extracts randomness from the &quot;entropy pool&quot;, and&n; * returns it in a buffer.  This function computes how many remaining&n; * bits of entropy are left in the pool, but it does not restrict the&n; * number of bytes that are actually obtained.&n; */
DECL|function|extract_entropy
r_static
r_inline
r_int
id|extract_entropy
c_func
(paren
r_struct
id|random_bucket
op_star
id|r
comma
r_char
op_star
id|buf
comma
r_int
id|nbytes
comma
r_int
id|to_user
)paren
(brace
r_int
id|length
comma
id|ret
comma
id|passes
comma
id|i
suffix:semicolon
id|__u32
id|tmp
(braket
l_int|4
)braket
suffix:semicolon
id|u8
op_star
id|cp
suffix:semicolon
id|add_entropy
c_func
(paren
id|r
comma
(paren
id|u8
op_star
)paren
op_amp
id|jiffies
comma
r_sizeof
(paren
id|jiffies
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;entropy_count
OG
id|r-&gt;bit_length
)paren
id|r-&gt;entropy_count
op_assign
id|r-&gt;bit_length
suffix:semicolon
r_if
c_cond
(paren
id|nbytes
OG
l_int|32768
)paren
id|nbytes
op_assign
l_int|32768
suffix:semicolon
id|ret
op_assign
id|nbytes
suffix:semicolon
id|r-&gt;entropy_count
op_sub_assign
id|ret
op_star
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|r-&gt;entropy_count
OL
l_int|0
)paren
id|r-&gt;entropy_count
op_assign
l_int|0
suffix:semicolon
id|passes
op_assign
id|r-&gt;length
op_div
l_int|64
suffix:semicolon
r_while
c_loop
(paren
id|nbytes
)paren
(brace
id|length
op_assign
id|MIN
c_func
(paren
id|nbytes
comma
l_int|16
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_increment
id|random_counter
(braket
id|i
)braket
op_ne
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|tmp
(braket
l_int|0
)braket
op_assign
l_int|0x67452301
suffix:semicolon
id|tmp
(braket
l_int|1
)braket
op_assign
l_int|0xefcdab89
suffix:semicolon
id|tmp
(braket
l_int|2
)braket
op_assign
l_int|0x98badcfe
suffix:semicolon
id|tmp
(braket
l_int|3
)braket
op_assign
l_int|0x10325476
suffix:semicolon
id|MD5Transform
c_func
(paren
id|tmp
comma
id|random_counter
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cp
op_assign
id|r-&gt;pool
suffix:semicolon
id|i
OL
id|passes
suffix:semicolon
id|i
op_increment
comma
id|cp
op_add_assign
l_int|64
)paren
id|MD5Transform
c_func
(paren
id|tmp
comma
(paren
id|__u32
op_star
)paren
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|to_user
)paren
id|memcpy_tofs
c_func
(paren
id|buf
comma
id|tmp
comma
id|length
)paren
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|buf
comma
id|tmp
comma
id|length
)paren
suffix:semicolon
id|nbytes
op_sub_assign
id|length
suffix:semicolon
id|buf
op_add_assign
id|length
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is the exported kernel interface.  It returns some&n; * number of good random numbers, suitable for seeding TCP sequence&n; * numbers, etc.&n; */
DECL|function|get_random_bytes
r_void
id|get_random_bytes
c_func
(paren
r_void
op_star
id|buf
comma
r_int
id|nbytes
)paren
(brace
id|extract_entropy
c_func
(paren
op_amp
id|random_state
comma
(paren
r_char
op_star
)paren
id|buf
comma
id|nbytes
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#ifdef linux
DECL|function|read_random
r_int
id|read_random
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|nbytes
)paren
(brace
r_if
c_cond
(paren
(paren
id|nbytes
op_star
l_int|8
)paren
OG
id|random_state.entropy_count
)paren
id|nbytes
op_assign
id|random_state.entropy_count
op_div
l_int|8
suffix:semicolon
r_return
id|extract_entropy
c_func
(paren
op_amp
id|random_state
comma
id|buf
comma
id|nbytes
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|read_random_unlimited
r_int
id|read_random_unlimited
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|nbytes
)paren
(brace
r_return
id|extract_entropy
c_func
(paren
op_amp
id|random_state
comma
id|buf
comma
id|nbytes
comma
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif /* CONFIG_RANDOM */
eof
