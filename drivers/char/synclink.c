multiline_comment|/*&n; * linux/drivers/char/synclink.c&n; *&n; * $Id: synclink.c,v 3.2 2000/11/06 22:34:38 paul Exp $&n; *&n; * Device driver for Microgate SyncLink ISA and PCI&n; * high speed multiprotocol serial adapters.&n; *&n; * written by Paul Fulghum for Microgate Corporation&n; * paulkf@microgate.com&n; *&n; * Microgate and SyncLink are trademarks of Microgate Corporation&n; *&n; * Derived from serial.c written by Theodore Ts&squot;o and Linus Torvalds&n; *&n; * Original release 01/11/99&n; *&n; * This code is released under the GNU General Public License (GPL)&n; *&n; * This driver is primarily intended for use in synchronous&n; * HDLC mode. Asynchronous mode is also provided.&n; *&n; * When operating in synchronous mode, each call to mgsl_write()&n; * contains exactly one complete HDLC frame. Calling mgsl_put_char&n; * will start assembling an HDLC frame that will not be sent until&n; * mgsl_flush_chars or mgsl_write is called.&n; * &n; * Synchronous receive data is reported as complete frames. To accomplish&n; * this, the TTY flip buffer is bypassed (too small to hold largest&n; * frame and may fragment frames) and the line discipline&n; * receive entry point is called directly.&n; *&n; * This driver has been tested with a slightly modified ppp.c driver&n; * for synchronous PPP.&n; *&n; * 2000/02/16&n; * Added interface for syncppp.c driver (an alternate synchronous PPP&n; * implementation that also supports Cisco HDLC). Each device instance&n; * registers as a tty device AND a network device (if dosyncppp option&n; * is set for the device). The functionality is determined by which&n; * device interface is opened.&n; *&n; * THIS SOFTWARE IS PROVIDED ``AS IS&squot;&squot; AND ANY EXPRESS OR IMPLIED&n; * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES&n; * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE&n; * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,&n; * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES&n; * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR&n; * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)&n; * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,&n; * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)&n; * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED&n; * OF THE POSSIBILITY OF SUCH DAMAGE.&n; */
DECL|macro|VERSION
mdefine_line|#define VERSION(ver,rel,seq) (((ver)&lt;&lt;16) | ((rel)&lt;&lt;8) | (seq))
DECL|macro|BREAKPOINT
mdefine_line|#define BREAKPOINT() asm(&quot;   int $3&quot;);
DECL|macro|MAX_ISA_DEVICES
mdefine_line|#define MAX_ISA_DEVICES 10
DECL|macro|MAX_PCI_DEVICES
mdefine_line|#define MAX_PCI_DEVICES 10
DECL|macro|MAX_TOTAL_DEVICES
mdefine_line|#define MAX_TOTAL_DEVICES 20
macro_line|#include &lt;linux/config.h&gt;&t;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/netdevice.h&gt;
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/serial.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/types.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#ifdef CONFIG_SYNCLINK_SYNCPPP_MODULE
DECL|macro|CONFIG_SYNCLINK_SYNCPPP
mdefine_line|#define CONFIG_SYNCLINK_SYNCPPP 1
macro_line|#endif
macro_line|#ifdef CONFIG_SYNCLINK_SYNCPPP
macro_line|#include &quot;../net/wan/syncppp.h&quot;
macro_line|#endif
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|GET_USER
mdefine_line|#define GET_USER(error,value,addr) error = get_user(value,addr)
DECL|macro|COPY_FROM_USER
mdefine_line|#define COPY_FROM_USER(error,dest,src,size) error = copy_from_user(dest,src,size) ? -EFAULT : 0
DECL|macro|PUT_USER
mdefine_line|#define PUT_USER(error,value,addr) error = put_user(value,addr)
DECL|macro|COPY_TO_USER
mdefine_line|#define COPY_TO_USER(error,dest,src,size) error = copy_to_user(dest,src,size) ? -EFAULT : 0
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;linux/synclink.h&quot;
DECL|macro|RCLRVALUE
mdefine_line|#define RCLRVALUE 0xffff
DECL|variable|default_params
id|MGSL_PARAMS
id|default_params
op_assign
(brace
id|MGSL_MODE_HDLC
comma
multiline_comment|/* unsigned long mode */
l_int|0
comma
multiline_comment|/* unsigned char loopback; */
id|HDLC_FLAG_UNDERRUN_ABORT15
comma
multiline_comment|/* unsigned short flags; */
id|HDLC_ENCODING_NRZI_SPACE
comma
multiline_comment|/* unsigned char encoding; */
l_int|0
comma
multiline_comment|/* unsigned long clock_speed; */
l_int|0xff
comma
multiline_comment|/* unsigned char addr_filter; */
id|HDLC_CRC_16_CCITT
comma
multiline_comment|/* unsigned short crc_type; */
id|HDLC_PREAMBLE_LENGTH_8BITS
comma
multiline_comment|/* unsigned char preamble_length; */
id|HDLC_PREAMBLE_PATTERN_NONE
comma
multiline_comment|/* unsigned char preamble; */
l_int|9600
comma
multiline_comment|/* unsigned long data_rate; */
l_int|8
comma
multiline_comment|/* unsigned char data_bits; */
l_int|1
comma
multiline_comment|/* unsigned char stop_bits; */
id|ASYNC_PARITY_NONE
multiline_comment|/* unsigned char parity; */
)brace
suffix:semicolon
DECL|macro|SHARED_MEM_ADDRESS_SIZE
mdefine_line|#define SHARED_MEM_ADDRESS_SIZE 0x40000
DECL|macro|BUFFERLISTSIZE
mdefine_line|#define BUFFERLISTSIZE (PAGE_SIZE)
DECL|macro|DMABUFFERSIZE
mdefine_line|#define DMABUFFERSIZE (PAGE_SIZE)
DECL|macro|MAXRXFRAMES
mdefine_line|#define MAXRXFRAMES 7
DECL|struct|_DMABUFFERENTRY
r_typedef
r_struct
id|_DMABUFFERENTRY
(brace
DECL|member|phys_addr
id|u32
id|phys_addr
suffix:semicolon
multiline_comment|/* 32-bit flat physical address of data buffer */
DECL|member|count
id|u16
id|count
suffix:semicolon
multiline_comment|/* buffer size/data count */
DECL|member|status
id|u16
id|status
suffix:semicolon
multiline_comment|/* Control/status field */
DECL|member|rcc
id|u16
id|rcc
suffix:semicolon
multiline_comment|/* character count field */
DECL|member|reserved
id|u16
id|reserved
suffix:semicolon
multiline_comment|/* padding required by 16C32 */
DECL|member|link
id|u32
id|link
suffix:semicolon
multiline_comment|/* 32-bit flat link to next buffer entry */
DECL|member|virt_addr
r_char
op_star
id|virt_addr
suffix:semicolon
multiline_comment|/* virtual address of data buffer */
DECL|member|phys_entry
id|u32
id|phys_entry
suffix:semicolon
multiline_comment|/* physical address of this buffer entry */
DECL|typedef|DMABUFFERENTRY
DECL|typedef|DMAPBUFFERENTRY
)brace
id|DMABUFFERENTRY
comma
op_star
id|DMAPBUFFERENTRY
suffix:semicolon
multiline_comment|/* The queue of BH actions to be performed */
DECL|macro|BH_RECEIVE
mdefine_line|#define BH_RECEIVE  1
DECL|macro|BH_TRANSMIT
mdefine_line|#define BH_TRANSMIT 2
DECL|macro|BH_STATUS
mdefine_line|#define BH_STATUS   4
DECL|macro|IO_PIN_SHUTDOWN_LIMIT
mdefine_line|#define IO_PIN_SHUTDOWN_LIMIT 100
DECL|macro|RELEVANT_IFLAG
mdefine_line|#define RELEVANT_IFLAG(iflag) (iflag &amp; (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
DECL|struct|_input_signal_events
r_struct
id|_input_signal_events
(brace
DECL|member|ri_up
r_int
id|ri_up
suffix:semicolon
DECL|member|ri_down
r_int
id|ri_down
suffix:semicolon
DECL|member|dsr_up
r_int
id|dsr_up
suffix:semicolon
DECL|member|dsr_down
r_int
id|dsr_down
suffix:semicolon
DECL|member|dcd_up
r_int
id|dcd_up
suffix:semicolon
DECL|member|dcd_down
r_int
id|dcd_down
suffix:semicolon
DECL|member|cts_up
r_int
id|cts_up
suffix:semicolon
DECL|member|cts_down
r_int
id|cts_down
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/*&n; * Device instance data structure&n; */
DECL|struct|mgsl_struct
r_struct
id|mgsl_struct
(brace
DECL|member|if_ptr
r_void
op_star
id|if_ptr
suffix:semicolon
multiline_comment|/* General purpose pointer (used by SPPP) */
DECL|member|magic
r_int
id|magic
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|count
r_int
id|count
suffix:semicolon
multiline_comment|/* count of opens */
DECL|member|line
r_int
id|line
suffix:semicolon
DECL|member|close_delay
r_int
r_int
id|close_delay
suffix:semicolon
DECL|member|closing_wait
r_int
r_int
id|closing_wait
suffix:semicolon
multiline_comment|/* time to wait before closing */
DECL|member|icount
r_struct
id|mgsl_icount
id|icount
suffix:semicolon
DECL|member|normal_termios
r_struct
id|termios
id|normal_termios
suffix:semicolon
DECL|member|callout_termios
r_struct
id|termios
id|callout_termios
suffix:semicolon
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
DECL|member|timeout
r_int
id|timeout
suffix:semicolon
DECL|member|x_char
r_int
id|x_char
suffix:semicolon
multiline_comment|/* xon/xoff character */
DECL|member|blocked_open
r_int
id|blocked_open
suffix:semicolon
multiline_comment|/* # of blocked opens */
DECL|member|session
r_int
id|session
suffix:semicolon
multiline_comment|/* Session of opening process */
DECL|member|pgrp
r_int
id|pgrp
suffix:semicolon
multiline_comment|/* pgrp of opening process */
DECL|member|read_status_mask
id|u16
id|read_status_mask
suffix:semicolon
DECL|member|ignore_status_mask
id|u16
id|ignore_status_mask
suffix:semicolon
DECL|member|xmit_buf
r_int
r_char
op_star
id|xmit_buf
suffix:semicolon
DECL|member|xmit_head
r_int
id|xmit_head
suffix:semicolon
DECL|member|xmit_tail
r_int
id|xmit_tail
suffix:semicolon
DECL|member|xmit_cnt
r_int
id|xmit_cnt
suffix:semicolon
DECL|member|open_wait
id|wait_queue_head_t
id|open_wait
suffix:semicolon
DECL|member|close_wait
id|wait_queue_head_t
id|close_wait
suffix:semicolon
DECL|member|status_event_wait_q
id|wait_queue_head_t
id|status_event_wait_q
suffix:semicolon
DECL|member|event_wait_q
id|wait_queue_head_t
id|event_wait_q
suffix:semicolon
DECL|member|tx_timer
r_struct
id|timer_list
id|tx_timer
suffix:semicolon
multiline_comment|/* HDLC transmit timeout timer */
DECL|member|next_device
r_struct
id|mgsl_struct
op_star
id|next_device
suffix:semicolon
multiline_comment|/* device list link */
DECL|member|irq_spinlock
id|spinlock_t
id|irq_spinlock
suffix:semicolon
multiline_comment|/* spinlock for synchronizing with ISR */
DECL|member|task
r_struct
id|tq_struct
id|task
suffix:semicolon
multiline_comment|/* task structure for scheduling bh */
DECL|member|EventMask
id|u32
id|EventMask
suffix:semicolon
multiline_comment|/* event trigger mask */
DECL|member|RecordedEvents
id|u32
id|RecordedEvents
suffix:semicolon
multiline_comment|/* pending events */
DECL|member|max_frame_size
id|u32
id|max_frame_size
suffix:semicolon
multiline_comment|/* as set by device config */
DECL|member|pending_bh
id|u32
id|pending_bh
suffix:semicolon
DECL|member|bh_running
r_int
id|bh_running
suffix:semicolon
multiline_comment|/* Protection from multiple */
DECL|member|isr_overflow
r_int
id|isr_overflow
suffix:semicolon
DECL|member|bh_requested
r_int
id|bh_requested
suffix:semicolon
DECL|member|dcd_chkcount
r_int
id|dcd_chkcount
suffix:semicolon
multiline_comment|/* check counts to prevent */
DECL|member|cts_chkcount
r_int
id|cts_chkcount
suffix:semicolon
multiline_comment|/* too many IRQs if a signal */
DECL|member|dsr_chkcount
r_int
id|dsr_chkcount
suffix:semicolon
multiline_comment|/* is floating */
DECL|member|ri_chkcount
r_int
id|ri_chkcount
suffix:semicolon
DECL|member|buffer_list
r_char
op_star
id|buffer_list
suffix:semicolon
multiline_comment|/* virtual address of Rx &amp; Tx buffer lists */
DECL|member|buffer_list_phys
r_int
r_int
id|buffer_list_phys
suffix:semicolon
DECL|member|rx_buffer_count
r_int
r_int
id|rx_buffer_count
suffix:semicolon
multiline_comment|/* count of total allocated Rx buffers */
DECL|member|rx_buffer_list
id|DMABUFFERENTRY
op_star
id|rx_buffer_list
suffix:semicolon
multiline_comment|/* list of receive buffer entries */
DECL|member|current_rx_buffer
r_int
r_int
id|current_rx_buffer
suffix:semicolon
DECL|member|tx_buffer_count
r_int
r_int
id|tx_buffer_count
suffix:semicolon
multiline_comment|/* count of total allocated Tx buffers */
DECL|member|tx_buffer_list
id|DMABUFFERENTRY
op_star
id|tx_buffer_list
suffix:semicolon
multiline_comment|/* list of transmit buffer entries */
DECL|member|intermediate_rxbuffer
r_int
r_char
op_star
id|intermediate_rxbuffer
suffix:semicolon
DECL|member|rx_enabled
r_int
id|rx_enabled
suffix:semicolon
DECL|member|rx_overflow
r_int
id|rx_overflow
suffix:semicolon
DECL|member|tx_enabled
r_int
id|tx_enabled
suffix:semicolon
DECL|member|tx_active
r_int
id|tx_active
suffix:semicolon
DECL|member|idle_mode
id|u32
id|idle_mode
suffix:semicolon
DECL|member|cmr_value
id|u16
id|cmr_value
suffix:semicolon
DECL|member|tcsr_value
id|u16
id|tcsr_value
suffix:semicolon
DECL|member|device_name
r_char
id|device_name
(braket
l_int|25
)braket
suffix:semicolon
multiline_comment|/* device instance name */
DECL|member|bus_type
r_int
r_int
id|bus_type
suffix:semicolon
multiline_comment|/* expansion bus type (ISA,EISA,PCI) */
DECL|member|bus
r_int
r_char
id|bus
suffix:semicolon
multiline_comment|/* expansion bus number (zero based) */
DECL|member|function
r_int
r_char
id|function
suffix:semicolon
multiline_comment|/* PCI device number */
DECL|member|io_base
r_int
r_int
id|io_base
suffix:semicolon
multiline_comment|/* base I/O address of adapter */
DECL|member|io_addr_size
r_int
r_int
id|io_addr_size
suffix:semicolon
multiline_comment|/* size of the I/O address range */
DECL|member|io_addr_requested
r_int
id|io_addr_requested
suffix:semicolon
multiline_comment|/* nonzero if I/O address requested */
DECL|member|irq_level
r_int
r_int
id|irq_level
suffix:semicolon
multiline_comment|/* interrupt level */
DECL|member|irq_flags
r_int
r_int
id|irq_flags
suffix:semicolon
DECL|member|irq_requested
r_int
id|irq_requested
suffix:semicolon
multiline_comment|/* nonzero if IRQ requested */
DECL|member|dma_level
r_int
r_int
id|dma_level
suffix:semicolon
multiline_comment|/* DMA channel */
DECL|member|dma_requested
r_int
id|dma_requested
suffix:semicolon
multiline_comment|/* nonzero if dma channel requested */
DECL|member|mbre_bit
id|u16
id|mbre_bit
suffix:semicolon
DECL|member|loopback_bits
id|u16
id|loopback_bits
suffix:semicolon
DECL|member|usc_idle_mode
id|u16
id|usc_idle_mode
suffix:semicolon
DECL|member|params
id|MGSL_PARAMS
id|params
suffix:semicolon
multiline_comment|/* communications parameters */
DECL|member|serial_signals
r_int
r_char
id|serial_signals
suffix:semicolon
multiline_comment|/* current serial signal states */
DECL|member|irq_occurred
r_int
id|irq_occurred
suffix:semicolon
multiline_comment|/* for diagnostics use */
DECL|member|init_error
r_int
r_int
id|init_error
suffix:semicolon
multiline_comment|/* Initialization startup error &t;&t;(DIAGS)&t;*/
DECL|member|fDiagnosticsmode
r_int
id|fDiagnosticsmode
suffix:semicolon
multiline_comment|/* Driver in Diagnostic mode?&t;&t;&t;(DIAGS)&t;*/
DECL|member|last_mem_alloc
id|u32
id|last_mem_alloc
suffix:semicolon
DECL|member|memory_base
r_int
r_char
op_star
id|memory_base
suffix:semicolon
multiline_comment|/* shared memory address (PCI only) */
DECL|member|phys_memory_base
id|u32
id|phys_memory_base
suffix:semicolon
DECL|member|shared_mem_requested
r_int
id|shared_mem_requested
suffix:semicolon
DECL|member|lcr_base
r_int
r_char
op_star
id|lcr_base
suffix:semicolon
multiline_comment|/* local config registers (PCI only) */
DECL|member|phys_lcr_base
id|u32
id|phys_lcr_base
suffix:semicolon
DECL|member|lcr_offset
id|u32
id|lcr_offset
suffix:semicolon
DECL|member|lcr_mem_requested
r_int
id|lcr_mem_requested
suffix:semicolon
DECL|member|misc_ctrl_value
id|u32
id|misc_ctrl_value
suffix:semicolon
DECL|member|flag_buf
r_char
id|flag_buf
(braket
id|MAX_ASYNC_BUFFER_SIZE
)braket
suffix:semicolon
DECL|member|char_buf
r_char
id|char_buf
(braket
id|MAX_ASYNC_BUFFER_SIZE
)braket
suffix:semicolon
DECL|member|drop_rts_on_tx_done
id|BOOLEAN
id|drop_rts_on_tx_done
suffix:semicolon
DECL|member|loopmode_insert_requested
id|BOOLEAN
id|loopmode_insert_requested
suffix:semicolon
DECL|member|loopmode_send_done_requested
id|BOOLEAN
id|loopmode_send_done_requested
suffix:semicolon
DECL|member|input_signal_events
r_struct
id|_input_signal_events
id|input_signal_events
suffix:semicolon
multiline_comment|/* SPPP/Cisco HDLC device parts */
DECL|member|netcount
r_int
id|netcount
suffix:semicolon
DECL|member|dosyncppp
r_int
id|dosyncppp
suffix:semicolon
DECL|member|netlock
id|spinlock_t
id|netlock
suffix:semicolon
macro_line|#ifdef CONFIG_SYNCLINK_SYNCPPP
DECL|member|pppdev
r_struct
id|ppp_device
id|pppdev
suffix:semicolon
DECL|member|netname
r_char
id|netname
(braket
l_int|10
)braket
suffix:semicolon
DECL|member|netdev
r_struct
id|net_device
op_star
id|netdev
suffix:semicolon
DECL|member|netstats
r_struct
id|net_device_stats
id|netstats
suffix:semicolon
DECL|member|netdevice
r_struct
id|net_device
id|netdevice
suffix:semicolon
macro_line|#endif
)brace
suffix:semicolon
DECL|macro|MGSL_MAGIC
mdefine_line|#define MGSL_MAGIC 0x5401
multiline_comment|/*&n; * The size of the serial xmit buffer is 1 page, or 4096 bytes&n; */
macro_line|#ifndef SERIAL_XMIT_SIZE
DECL|macro|SERIAL_XMIT_SIZE
mdefine_line|#define SERIAL_XMIT_SIZE 4096
macro_line|#endif
multiline_comment|/*&n; * These macros define the offsets used in calculating the&n; * I/O address of the specified USC registers.&n; */
DECL|macro|DCPIN
mdefine_line|#define DCPIN 2&t;&t;/* Bit 1 of I/O address */
DECL|macro|SDPIN
mdefine_line|#define SDPIN 4&t;&t;/* Bit 2 of I/O address */
DECL|macro|DCAR
mdefine_line|#define DCAR 0&t;&t;/* DMA command/address register */
DECL|macro|CCAR
mdefine_line|#define CCAR SDPIN&t;&t;/* channel command/address register */
DECL|macro|DATAREG
mdefine_line|#define DATAREG DCPIN + SDPIN&t;/* serial data register */
DECL|macro|MSBONLY
mdefine_line|#define MSBONLY 0x41
DECL|macro|LSBONLY
mdefine_line|#define LSBONLY 0x40
multiline_comment|/*&n; * These macros define the register address (ordinal number)&n; * used for writing address/value pairs to the USC.&n; */
DECL|macro|CMR
mdefine_line|#define CMR&t;0x02&t;/* Channel mode Register */
DECL|macro|CCSR
mdefine_line|#define CCSR&t;0x04&t;/* Channel Command/status Register */
DECL|macro|CCR
mdefine_line|#define CCR&t;0x06&t;/* Channel Control Register */
DECL|macro|PSR
mdefine_line|#define PSR&t;0x08&t;/* Port status Register */
DECL|macro|PCR
mdefine_line|#define PCR&t;0x0a&t;/* Port Control Register */
DECL|macro|TMDR
mdefine_line|#define TMDR&t;0x0c&t;/* Test mode Data Register */
DECL|macro|TMCR
mdefine_line|#define TMCR&t;0x0e&t;/* Test mode Control Register */
DECL|macro|CMCR
mdefine_line|#define CMCR&t;0x10&t;/* Clock mode Control Register */
DECL|macro|HCR
mdefine_line|#define HCR&t;0x12&t;/* Hardware Configuration Register */
DECL|macro|IVR
mdefine_line|#define IVR&t;0x14&t;/* Interrupt Vector Register */
DECL|macro|IOCR
mdefine_line|#define IOCR&t;0x16&t;/* Input/Output Control Register */
DECL|macro|ICR
mdefine_line|#define ICR&t;0x18&t;/* Interrupt Control Register */
DECL|macro|DCCR
mdefine_line|#define DCCR&t;0x1a&t;/* Daisy Chain Control Register */
DECL|macro|MISR
mdefine_line|#define MISR&t;0x1c&t;/* Misc Interrupt status Register */
DECL|macro|SICR
mdefine_line|#define SICR&t;0x1e&t;/* status Interrupt Control Register */
DECL|macro|RDR
mdefine_line|#define RDR&t;0x20&t;/* Receive Data Register */
DECL|macro|RMR
mdefine_line|#define RMR&t;0x22&t;/* Receive mode Register */
DECL|macro|RCSR
mdefine_line|#define RCSR&t;0x24&t;/* Receive Command/status Register */
DECL|macro|RICR
mdefine_line|#define RICR&t;0x26&t;/* Receive Interrupt Control Register */
DECL|macro|RSR
mdefine_line|#define RSR&t;0x28&t;/* Receive Sync Register */
DECL|macro|RCLR
mdefine_line|#define RCLR&t;0x2a&t;/* Receive count Limit Register */
DECL|macro|RCCR
mdefine_line|#define RCCR&t;0x2c&t;/* Receive Character count Register */
DECL|macro|TC0R
mdefine_line|#define TC0R&t;0x2e&t;/* Time Constant 0 Register */
DECL|macro|TDR
mdefine_line|#define TDR&t;0x30&t;/* Transmit Data Register */
DECL|macro|TMR
mdefine_line|#define TMR&t;0x32&t;/* Transmit mode Register */
DECL|macro|TCSR
mdefine_line|#define TCSR&t;0x34&t;/* Transmit Command/status Register */
DECL|macro|TICR
mdefine_line|#define TICR&t;0x36&t;/* Transmit Interrupt Control Register */
DECL|macro|TSR
mdefine_line|#define TSR&t;0x38&t;/* Transmit Sync Register */
DECL|macro|TCLR
mdefine_line|#define TCLR&t;0x3a&t;/* Transmit count Limit Register */
DECL|macro|TCCR
mdefine_line|#define TCCR&t;0x3c&t;/* Transmit Character count Register */
DECL|macro|TC1R
mdefine_line|#define TC1R&t;0x3e&t;/* Time Constant 1 Register */
multiline_comment|/*&n; * MACRO DEFINITIONS FOR DMA REGISTERS&n; */
DECL|macro|DCR
mdefine_line|#define DCR&t;0x06&t;/* DMA Control Register (shared) */
DECL|macro|DACR
mdefine_line|#define DACR&t;0x08&t;/* DMA Array count Register (shared) */
DECL|macro|BDCR
mdefine_line|#define BDCR&t;0x12&t;/* Burst/Dwell Control Register (shared) */
DECL|macro|DIVR
mdefine_line|#define DIVR&t;0x14&t;/* DMA Interrupt Vector Register (shared) */&t;
DECL|macro|DICR
mdefine_line|#define DICR&t;0x18&t;/* DMA Interrupt Control Register (shared) */
DECL|macro|CDIR
mdefine_line|#define CDIR&t;0x1a&t;/* Clear DMA Interrupt Register (shared) */
DECL|macro|SDIR
mdefine_line|#define SDIR&t;0x1c&t;/* Set DMA Interrupt Register (shared) */
DECL|macro|TDMR
mdefine_line|#define TDMR&t;0x02&t;/* Transmit DMA mode Register */
DECL|macro|TDIAR
mdefine_line|#define TDIAR&t;0x1e&t;/* Transmit DMA Interrupt Arm Register */
DECL|macro|TBCR
mdefine_line|#define TBCR&t;0x2a&t;/* Transmit Byte count Register */
DECL|macro|TARL
mdefine_line|#define TARL&t;0x2c&t;/* Transmit Address Register (low) */
DECL|macro|TARU
mdefine_line|#define TARU&t;0x2e&t;/* Transmit Address Register (high) */
DECL|macro|NTBCR
mdefine_line|#define NTBCR&t;0x3a&t;/* Next Transmit Byte count Register */
DECL|macro|NTARL
mdefine_line|#define NTARL&t;0x3c&t;/* Next Transmit Address Register (low) */
DECL|macro|NTARU
mdefine_line|#define NTARU&t;0x3e&t;/* Next Transmit Address Register (high) */
DECL|macro|RDMR
mdefine_line|#define RDMR&t;0x82&t;/* Receive DMA mode Register (non-shared) */
DECL|macro|RDIAR
mdefine_line|#define RDIAR&t;0x9e&t;/* Receive DMA Interrupt Arm Register */
DECL|macro|RBCR
mdefine_line|#define RBCR&t;0xaa&t;/* Receive Byte count Register */
DECL|macro|RARL
mdefine_line|#define RARL&t;0xac&t;/* Receive Address Register (low) */
DECL|macro|RARU
mdefine_line|#define RARU&t;0xae&t;/* Receive Address Register (high) */
DECL|macro|NRBCR
mdefine_line|#define NRBCR&t;0xba&t;/* Next Receive Byte count Register */
DECL|macro|NRARL
mdefine_line|#define NRARL&t;0xbc&t;/* Next Receive Address Register (low) */
DECL|macro|NRARU
mdefine_line|#define NRARU&t;0xbe&t;/* Next Receive Address Register (high) */
multiline_comment|/*&n; * MACRO DEFINITIONS FOR MODEM STATUS BITS&n; */
DECL|macro|MODEMSTATUS_DTR
mdefine_line|#define MODEMSTATUS_DTR 0x80
DECL|macro|MODEMSTATUS_DSR
mdefine_line|#define MODEMSTATUS_DSR 0x40
DECL|macro|MODEMSTATUS_RTS
mdefine_line|#define MODEMSTATUS_RTS 0x20
DECL|macro|MODEMSTATUS_CTS
mdefine_line|#define MODEMSTATUS_CTS 0x10
DECL|macro|MODEMSTATUS_RI
mdefine_line|#define MODEMSTATUS_RI  0x04
DECL|macro|MODEMSTATUS_DCD
mdefine_line|#define MODEMSTATUS_DCD 0x01
multiline_comment|/*&n; * Channel Command/Address Register (CCAR) Command Codes&n; */
DECL|macro|RTCmd_Null
mdefine_line|#define RTCmd_Null&t;&t;&t;0x0000
DECL|macro|RTCmd_ResetHighestIus
mdefine_line|#define RTCmd_ResetHighestIus&t;&t;0x1000
DECL|macro|RTCmd_TriggerChannelLoadDma
mdefine_line|#define RTCmd_TriggerChannelLoadDma&t;0x2000
DECL|macro|RTCmd_TriggerRxDma
mdefine_line|#define RTCmd_TriggerRxDma&t;&t;0x2800
DECL|macro|RTCmd_TriggerTxDma
mdefine_line|#define RTCmd_TriggerTxDma&t;&t;0x3000
DECL|macro|RTCmd_TriggerRxAndTxDma
mdefine_line|#define RTCmd_TriggerRxAndTxDma&t;&t;0x3800
DECL|macro|RTCmd_PurgeRxFifo
mdefine_line|#define RTCmd_PurgeRxFifo&t;&t;0x4800
DECL|macro|RTCmd_PurgeTxFifo
mdefine_line|#define RTCmd_PurgeTxFifo&t;&t;0x5000
DECL|macro|RTCmd_PurgeRxAndTxFifo
mdefine_line|#define RTCmd_PurgeRxAndTxFifo&t;&t;0x5800
DECL|macro|RTCmd_LoadRcc
mdefine_line|#define RTCmd_LoadRcc&t;&t;&t;0x6800
DECL|macro|RTCmd_LoadTcc
mdefine_line|#define RTCmd_LoadTcc&t;&t;&t;0x7000
DECL|macro|RTCmd_LoadRccAndTcc
mdefine_line|#define RTCmd_LoadRccAndTcc&t;&t;0x7800
DECL|macro|RTCmd_LoadTC0
mdefine_line|#define RTCmd_LoadTC0&t;&t;&t;0x8800
DECL|macro|RTCmd_LoadTC1
mdefine_line|#define RTCmd_LoadTC1&t;&t;&t;0x9000
DECL|macro|RTCmd_LoadTC0AndTC1
mdefine_line|#define RTCmd_LoadTC0AndTC1&t;&t;0x9800
DECL|macro|RTCmd_SerialDataLSBFirst
mdefine_line|#define RTCmd_SerialDataLSBFirst&t;0xa000
DECL|macro|RTCmd_SerialDataMSBFirst
mdefine_line|#define RTCmd_SerialDataMSBFirst&t;0xa800
DECL|macro|RTCmd_SelectBigEndian
mdefine_line|#define RTCmd_SelectBigEndian&t;&t;0xb000
DECL|macro|RTCmd_SelectLittleEndian
mdefine_line|#define RTCmd_SelectLittleEndian&t;0xb800
multiline_comment|/*&n; * DMA Command/Address Register (DCAR) Command Codes&n; */
DECL|macro|DmaCmd_Null
mdefine_line|#define DmaCmd_Null&t;&t;&t;0x0000
DECL|macro|DmaCmd_ResetTxChannel
mdefine_line|#define DmaCmd_ResetTxChannel&t;&t;0x1000
DECL|macro|DmaCmd_ResetRxChannel
mdefine_line|#define DmaCmd_ResetRxChannel&t;&t;0x1200
DECL|macro|DmaCmd_StartTxChannel
mdefine_line|#define DmaCmd_StartTxChannel&t;&t;0x2000
DECL|macro|DmaCmd_StartRxChannel
mdefine_line|#define DmaCmd_StartRxChannel&t;&t;0x2200
DECL|macro|DmaCmd_ContinueTxChannel
mdefine_line|#define DmaCmd_ContinueTxChannel&t;0x3000
DECL|macro|DmaCmd_ContinueRxChannel
mdefine_line|#define DmaCmd_ContinueRxChannel&t;0x3200
DECL|macro|DmaCmd_PauseTxChannel
mdefine_line|#define DmaCmd_PauseTxChannel&t;&t;0x4000
DECL|macro|DmaCmd_PauseRxChannel
mdefine_line|#define DmaCmd_PauseRxChannel&t;&t;0x4200
DECL|macro|DmaCmd_AbortTxChannel
mdefine_line|#define DmaCmd_AbortTxChannel&t;&t;0x5000
DECL|macro|DmaCmd_AbortRxChannel
mdefine_line|#define DmaCmd_AbortRxChannel&t;&t;0x5200
DECL|macro|DmaCmd_InitTxChannel
mdefine_line|#define DmaCmd_InitTxChannel&t;&t;0x7000
DECL|macro|DmaCmd_InitRxChannel
mdefine_line|#define DmaCmd_InitRxChannel&t;&t;0x7200
DECL|macro|DmaCmd_ResetHighestDmaIus
mdefine_line|#define DmaCmd_ResetHighestDmaIus&t;0x8000
DECL|macro|DmaCmd_ResetAllChannels
mdefine_line|#define DmaCmd_ResetAllChannels&t;&t;0x9000
DECL|macro|DmaCmd_StartAllChannels
mdefine_line|#define DmaCmd_StartAllChannels&t;&t;0xa000
DECL|macro|DmaCmd_ContinueAllChannels
mdefine_line|#define DmaCmd_ContinueAllChannels&t;0xb000
DECL|macro|DmaCmd_PauseAllChannels
mdefine_line|#define DmaCmd_PauseAllChannels&t;&t;0xc000
DECL|macro|DmaCmd_AbortAllChannels
mdefine_line|#define DmaCmd_AbortAllChannels&t;&t;0xd000
DECL|macro|DmaCmd_InitAllChannels
mdefine_line|#define DmaCmd_InitAllChannels&t;&t;0xf000
DECL|macro|TCmd_Null
mdefine_line|#define TCmd_Null&t;&t;&t;0x0000
DECL|macro|TCmd_ClearTxCRC
mdefine_line|#define TCmd_ClearTxCRC&t;&t;&t;0x2000
DECL|macro|TCmd_SelectTicrTtsaData
mdefine_line|#define TCmd_SelectTicrTtsaData&t;&t;0x4000
DECL|macro|TCmd_SelectTicrTxFifostatus
mdefine_line|#define TCmd_SelectTicrTxFifostatus&t;0x5000
DECL|macro|TCmd_SelectTicrIntLevel
mdefine_line|#define TCmd_SelectTicrIntLevel&t;&t;0x6000
DECL|macro|TCmd_SelectTicrdma_level
mdefine_line|#define TCmd_SelectTicrdma_level&t;&t;0x7000
DECL|macro|TCmd_SendFrame
mdefine_line|#define TCmd_SendFrame&t;&t;&t;0x8000
DECL|macro|TCmd_SendAbort
mdefine_line|#define TCmd_SendAbort&t;&t;&t;0x9000
DECL|macro|TCmd_EnableDleInsertion
mdefine_line|#define TCmd_EnableDleInsertion&t;&t;0xc000
DECL|macro|TCmd_DisableDleInsertion
mdefine_line|#define TCmd_DisableDleInsertion&t;0xd000
DECL|macro|TCmd_ClearEofEom
mdefine_line|#define TCmd_ClearEofEom&t;&t;0xe000
DECL|macro|TCmd_SetEofEom
mdefine_line|#define TCmd_SetEofEom&t;&t;&t;0xf000
DECL|macro|RCmd_Null
mdefine_line|#define RCmd_Null&t;&t;&t;0x0000
DECL|macro|RCmd_ClearRxCRC
mdefine_line|#define RCmd_ClearRxCRC&t;&t;&t;0x2000
DECL|macro|RCmd_EnterHuntmode
mdefine_line|#define RCmd_EnterHuntmode&t;&t;0x3000
DECL|macro|RCmd_SelectRicrRtsaData
mdefine_line|#define RCmd_SelectRicrRtsaData&t;&t;0x4000
DECL|macro|RCmd_SelectRicrRxFifostatus
mdefine_line|#define RCmd_SelectRicrRxFifostatus&t;0x5000
DECL|macro|RCmd_SelectRicrIntLevel
mdefine_line|#define RCmd_SelectRicrIntLevel&t;&t;0x6000
DECL|macro|RCmd_SelectRicrdma_level
mdefine_line|#define RCmd_SelectRicrdma_level&t;&t;0x7000
multiline_comment|/*&n; * Bits for enabling and disabling IRQs in Interrupt Control Register (ICR)&n; */
DECL|macro|RECEIVE_STATUS
mdefine_line|#define RECEIVE_STATUS&t;&t;BIT5
DECL|macro|RECEIVE_DATA
mdefine_line|#define RECEIVE_DATA&t;&t;BIT4
DECL|macro|TRANSMIT_STATUS
mdefine_line|#define TRANSMIT_STATUS&t;&t;BIT3
DECL|macro|TRANSMIT_DATA
mdefine_line|#define TRANSMIT_DATA&t;&t;BIT2
DECL|macro|IO_PIN
mdefine_line|#define IO_PIN&t;&t;&t;BIT1
DECL|macro|MISC
mdefine_line|#define MISC&t;&t;&t;BIT0
multiline_comment|/*&n; * Receive status Bits in Receive Command/status Register RCSR&n; */
DECL|macro|RXSTATUS_SHORT_FRAME
mdefine_line|#define RXSTATUS_SHORT_FRAME&t;&t;BIT8
DECL|macro|RXSTATUS_CODE_VIOLATION
mdefine_line|#define RXSTATUS_CODE_VIOLATION&t;&t;BIT8
DECL|macro|RXSTATUS_EXITED_HUNT
mdefine_line|#define RXSTATUS_EXITED_HUNT&t;&t;BIT7
DECL|macro|RXSTATUS_IDLE_RECEIVED
mdefine_line|#define RXSTATUS_IDLE_RECEIVED&t;&t;BIT6
DECL|macro|RXSTATUS_BREAK_RECEIVED
mdefine_line|#define RXSTATUS_BREAK_RECEIVED&t;&t;BIT5
DECL|macro|RXSTATUS_ABORT_RECEIVED
mdefine_line|#define RXSTATUS_ABORT_RECEIVED&t;&t;BIT5
DECL|macro|RXSTATUS_RXBOUND
mdefine_line|#define RXSTATUS_RXBOUND&t;&t;BIT4
DECL|macro|RXSTATUS_CRC_ERROR
mdefine_line|#define RXSTATUS_CRC_ERROR&t;&t;BIT3
DECL|macro|RXSTATUS_FRAMING_ERROR
mdefine_line|#define RXSTATUS_FRAMING_ERROR&t;&t;BIT3
DECL|macro|RXSTATUS_ABORT
mdefine_line|#define RXSTATUS_ABORT&t;&t;&t;BIT2
DECL|macro|RXSTATUS_PARITY_ERROR
mdefine_line|#define RXSTATUS_PARITY_ERROR&t;&t;BIT2
DECL|macro|RXSTATUS_OVERRUN
mdefine_line|#define RXSTATUS_OVERRUN&t;&t;BIT1
DECL|macro|RXSTATUS_DATA_AVAILABLE
mdefine_line|#define RXSTATUS_DATA_AVAILABLE&t;&t;BIT0
DECL|macro|RXSTATUS_ALL
mdefine_line|#define RXSTATUS_ALL&t;&t;&t;0x01f6
DECL|macro|usc_UnlatchRxstatusBits
mdefine_line|#define usc_UnlatchRxstatusBits(a,b) usc_OutReg( (a), RCSR, (u16)((b) &amp; RXSTATUS_ALL) )
multiline_comment|/*&n; * Values for setting transmit idle mode in &n; * Transmit Control/status Register (TCSR)&n; */
DECL|macro|IDLEMODE_FLAGS
mdefine_line|#define IDLEMODE_FLAGS&t;&t;&t;0x0000
DECL|macro|IDLEMODE_ALT_ONE_ZERO
mdefine_line|#define IDLEMODE_ALT_ONE_ZERO&t;&t;0x0100
DECL|macro|IDLEMODE_ZERO
mdefine_line|#define IDLEMODE_ZERO&t;&t;&t;0x0200
DECL|macro|IDLEMODE_ONE
mdefine_line|#define IDLEMODE_ONE&t;&t;&t;0x0300
DECL|macro|IDLEMODE_ALT_MARK_SPACE
mdefine_line|#define IDLEMODE_ALT_MARK_SPACE&t;&t;0x0500
DECL|macro|IDLEMODE_SPACE
mdefine_line|#define IDLEMODE_SPACE&t;&t;&t;0x0600
DECL|macro|IDLEMODE_MARK
mdefine_line|#define IDLEMODE_MARK&t;&t;&t;0x0700
DECL|macro|IDLEMODE_MASK
mdefine_line|#define IDLEMODE_MASK&t;&t;&t;0x0700
multiline_comment|/*&n; * IUSC revision identifiers&n; */
DECL|macro|IUSC_SL1660
mdefine_line|#define&t;IUSC_SL1660&t;&t;&t;0x4d44
DECL|macro|IUSC_PRE_SL1660
mdefine_line|#define IUSC_PRE_SL1660&t;&t;&t;0x4553
multiline_comment|/*&n; * Transmit status Bits in Transmit Command/status Register (TCSR)&n; */
DECL|macro|TCSR_PRESERVE
mdefine_line|#define TCSR_PRESERVE&t;&t;&t;0x0F00
DECL|macro|TCSR_UNDERWAIT
mdefine_line|#define TCSR_UNDERWAIT&t;&t;&t;BIT11
DECL|macro|TXSTATUS_PREAMBLE_SENT
mdefine_line|#define TXSTATUS_PREAMBLE_SENT&t;&t;BIT7
DECL|macro|TXSTATUS_IDLE_SENT
mdefine_line|#define TXSTATUS_IDLE_SENT&t;&t;BIT6
DECL|macro|TXSTATUS_ABORT_SENT
mdefine_line|#define TXSTATUS_ABORT_SENT&t;&t;BIT5
DECL|macro|TXSTATUS_EOF_SENT
mdefine_line|#define TXSTATUS_EOF_SENT&t;&t;BIT4
DECL|macro|TXSTATUS_EOM_SENT
mdefine_line|#define TXSTATUS_EOM_SENT&t;&t;BIT4
DECL|macro|TXSTATUS_CRC_SENT
mdefine_line|#define TXSTATUS_CRC_SENT&t;&t;BIT3
DECL|macro|TXSTATUS_ALL_SENT
mdefine_line|#define TXSTATUS_ALL_SENT&t;&t;BIT2
DECL|macro|TXSTATUS_UNDERRUN
mdefine_line|#define TXSTATUS_UNDERRUN&t;&t;BIT1
DECL|macro|TXSTATUS_FIFO_EMPTY
mdefine_line|#define TXSTATUS_FIFO_EMPTY&t;&t;BIT0
DECL|macro|TXSTATUS_ALL
mdefine_line|#define TXSTATUS_ALL&t;&t;&t;0x00fa
DECL|macro|usc_UnlatchTxstatusBits
mdefine_line|#define usc_UnlatchTxstatusBits(a,b) usc_OutReg( (a), TCSR, (u16)((a)-&gt;tcsr_value + ((b) &amp; 0x00FF)) )
DECL|macro|MISCSTATUS_RXC_LATCHED
mdefine_line|#define MISCSTATUS_RXC_LATCHED&t;&t;BIT15
DECL|macro|MISCSTATUS_RXC
mdefine_line|#define MISCSTATUS_RXC&t;&t;&t;BIT14
DECL|macro|MISCSTATUS_TXC_LATCHED
mdefine_line|#define MISCSTATUS_TXC_LATCHED&t;&t;BIT13
DECL|macro|MISCSTATUS_TXC
mdefine_line|#define MISCSTATUS_TXC&t;&t;&t;BIT12
DECL|macro|MISCSTATUS_RI_LATCHED
mdefine_line|#define MISCSTATUS_RI_LATCHED&t;&t;BIT11
DECL|macro|MISCSTATUS_RI
mdefine_line|#define MISCSTATUS_RI&t;&t;&t;BIT10
DECL|macro|MISCSTATUS_DSR_LATCHED
mdefine_line|#define MISCSTATUS_DSR_LATCHED&t;&t;BIT9
DECL|macro|MISCSTATUS_DSR
mdefine_line|#define MISCSTATUS_DSR&t;&t;&t;BIT8
DECL|macro|MISCSTATUS_DCD_LATCHED
mdefine_line|#define MISCSTATUS_DCD_LATCHED&t;&t;BIT7
DECL|macro|MISCSTATUS_DCD
mdefine_line|#define MISCSTATUS_DCD&t;&t;&t;BIT6
DECL|macro|MISCSTATUS_CTS_LATCHED
mdefine_line|#define MISCSTATUS_CTS_LATCHED&t;&t;BIT5
DECL|macro|MISCSTATUS_CTS
mdefine_line|#define MISCSTATUS_CTS&t;&t;&t;BIT4
DECL|macro|MISCSTATUS_RCC_UNDERRUN
mdefine_line|#define MISCSTATUS_RCC_UNDERRUN&t;&t;BIT3
DECL|macro|MISCSTATUS_DPLL_NO_SYNC
mdefine_line|#define MISCSTATUS_DPLL_NO_SYNC&t;&t;BIT2
DECL|macro|MISCSTATUS_BRG1_ZERO
mdefine_line|#define MISCSTATUS_BRG1_ZERO&t;&t;BIT1
DECL|macro|MISCSTATUS_BRG0_ZERO
mdefine_line|#define MISCSTATUS_BRG0_ZERO&t;&t;BIT0
DECL|macro|usc_UnlatchIostatusBits
mdefine_line|#define usc_UnlatchIostatusBits(a,b) usc_OutReg((a),MISR,(u16)((b) &amp; 0xaaa0))
DECL|macro|usc_UnlatchMiscstatusBits
mdefine_line|#define usc_UnlatchMiscstatusBits(a,b) usc_OutReg((a),MISR,(u16)((b) &amp; 0x000f))
DECL|macro|SICR_RXC_ACTIVE
mdefine_line|#define SICR_RXC_ACTIVE&t;&t;&t;BIT15
DECL|macro|SICR_RXC_INACTIVE
mdefine_line|#define SICR_RXC_INACTIVE&t;&t;BIT14
DECL|macro|SICR_RXC
mdefine_line|#define SICR_RXC&t;&t;&t;(BIT15+BIT14)
DECL|macro|SICR_TXC_ACTIVE
mdefine_line|#define SICR_TXC_ACTIVE&t;&t;&t;BIT13
DECL|macro|SICR_TXC_INACTIVE
mdefine_line|#define SICR_TXC_INACTIVE&t;&t;BIT12
DECL|macro|SICR_TXC
mdefine_line|#define SICR_TXC&t;&t;&t;(BIT13+BIT12)
DECL|macro|SICR_RI_ACTIVE
mdefine_line|#define SICR_RI_ACTIVE&t;&t;&t;BIT11
DECL|macro|SICR_RI_INACTIVE
mdefine_line|#define SICR_RI_INACTIVE&t;&t;BIT10
DECL|macro|SICR_RI
mdefine_line|#define SICR_RI&t;&t;&t;&t;(BIT11+BIT10)
DECL|macro|SICR_DSR_ACTIVE
mdefine_line|#define SICR_DSR_ACTIVE&t;&t;&t;BIT9
DECL|macro|SICR_DSR_INACTIVE
mdefine_line|#define SICR_DSR_INACTIVE&t;&t;BIT8
DECL|macro|SICR_DSR
mdefine_line|#define SICR_DSR&t;&t;&t;(BIT9+BIT8)
DECL|macro|SICR_DCD_ACTIVE
mdefine_line|#define SICR_DCD_ACTIVE&t;&t;&t;BIT7
DECL|macro|SICR_DCD_INACTIVE
mdefine_line|#define SICR_DCD_INACTIVE&t;&t;BIT6
DECL|macro|SICR_DCD
mdefine_line|#define SICR_DCD&t;&t;&t;(BIT7+BIT6)
DECL|macro|SICR_CTS_ACTIVE
mdefine_line|#define SICR_CTS_ACTIVE&t;&t;&t;BIT5
DECL|macro|SICR_CTS_INACTIVE
mdefine_line|#define SICR_CTS_INACTIVE&t;&t;BIT4
DECL|macro|SICR_CTS
mdefine_line|#define SICR_CTS&t;&t;&t;(BIT5+BIT4)
DECL|macro|SICR_RCC_UNDERFLOW
mdefine_line|#define SICR_RCC_UNDERFLOW&t;&t;BIT3
DECL|macro|SICR_DPLL_NO_SYNC
mdefine_line|#define SICR_DPLL_NO_SYNC&t;&t;BIT2
DECL|macro|SICR_BRG1_ZERO
mdefine_line|#define SICR_BRG1_ZERO&t;&t;&t;BIT1
DECL|macro|SICR_BRG0_ZERO
mdefine_line|#define SICR_BRG0_ZERO&t;&t;&t;BIT0
r_void
id|usc_DisableMasterIrqBit
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_EnableMasterIrqBit
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_EnableInterrupts
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|IrqMask
)paren
suffix:semicolon
r_void
id|usc_DisableInterrupts
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|IrqMask
)paren
suffix:semicolon
r_void
id|usc_ClearIrqPendingBits
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|IrqMask
)paren
suffix:semicolon
DECL|macro|usc_EnableInterrupts
mdefine_line|#define usc_EnableInterrupts( a, b ) &bslash;&n;&t;usc_OutReg( (a), ICR, (u16)((usc_InReg((a),ICR) &amp; 0xff00) + 0xc0 + (b)) )
DECL|macro|usc_DisableInterrupts
mdefine_line|#define usc_DisableInterrupts( a, b ) &bslash;&n;&t;usc_OutReg( (a), ICR, (u16)((usc_InReg((a),ICR) &amp; 0xff00) + 0x80 + (b)) )
DECL|macro|usc_EnableMasterIrqBit
mdefine_line|#define usc_EnableMasterIrqBit(a) &bslash;&n;&t;usc_OutReg( (a), ICR, (u16)((usc_InReg((a),ICR) &amp; 0x0f00) + 0xb000) )
DECL|macro|usc_DisableMasterIrqBit
mdefine_line|#define usc_DisableMasterIrqBit(a) &bslash;&n;&t;usc_OutReg( (a), ICR, (u16)(usc_InReg((a),ICR) &amp; 0x7f00) )
DECL|macro|usc_ClearIrqPendingBits
mdefine_line|#define usc_ClearIrqPendingBits( a, b ) usc_OutReg( (a), DCCR, 0x40 + (b) )
multiline_comment|/*&n; * Transmit status Bits in Transmit Control status Register (TCSR)&n; * and Transmit Interrupt Control Register (TICR) (except BIT2, BIT0)&n; */
DECL|macro|TXSTATUS_PREAMBLE_SENT
mdefine_line|#define TXSTATUS_PREAMBLE_SENT&t;BIT7
DECL|macro|TXSTATUS_IDLE_SENT
mdefine_line|#define TXSTATUS_IDLE_SENT&t;BIT6
DECL|macro|TXSTATUS_ABORT_SENT
mdefine_line|#define TXSTATUS_ABORT_SENT&t;BIT5
DECL|macro|TXSTATUS_EOF
mdefine_line|#define TXSTATUS_EOF&t;&t;BIT4
DECL|macro|TXSTATUS_CRC_SENT
mdefine_line|#define TXSTATUS_CRC_SENT&t;BIT3
DECL|macro|TXSTATUS_ALL_SENT
mdefine_line|#define TXSTATUS_ALL_SENT&t;BIT2
DECL|macro|TXSTATUS_UNDERRUN
mdefine_line|#define TXSTATUS_UNDERRUN&t;BIT1
DECL|macro|TXSTATUS_FIFO_EMPTY
mdefine_line|#define TXSTATUS_FIFO_EMPTY&t;BIT0
DECL|macro|DICR_MASTER
mdefine_line|#define DICR_MASTER&t;&t;BIT15
DECL|macro|DICR_TRANSMIT
mdefine_line|#define DICR_TRANSMIT&t;&t;BIT0
DECL|macro|DICR_RECEIVE
mdefine_line|#define DICR_RECEIVE&t;&t;BIT1
DECL|macro|usc_EnableDmaInterrupts
mdefine_line|#define usc_EnableDmaInterrupts(a,b) &bslash;&n;&t;usc_OutDmaReg( (a), DICR, (u16)(usc_InDmaReg((a),DICR) | (b)) )
DECL|macro|usc_DisableDmaInterrupts
mdefine_line|#define usc_DisableDmaInterrupts(a,b) &bslash;&n;&t;usc_OutDmaReg( (a), DICR, (u16)(usc_InDmaReg((a),DICR) &amp; ~(b)) )
DECL|macro|usc_EnableStatusIrqs
mdefine_line|#define usc_EnableStatusIrqs(a,b) &bslash;&n;&t;usc_OutReg( (a), SICR, (u16)(usc_InReg((a),SICR) | (b)) )
DECL|macro|usc_DisablestatusIrqs
mdefine_line|#define usc_DisablestatusIrqs(a,b) &bslash;&n;&t;usc_OutReg( (a), SICR, (u16)(usc_InReg((a),SICR) &amp; ~(b)) )
multiline_comment|/* Transmit status Bits in Transmit Control status Register (TCSR) */
multiline_comment|/* and Transmit Interrupt Control Register (TICR) (except BIT2, BIT0) */
DECL|macro|DISABLE_UNCONDITIONAL
mdefine_line|#define DISABLE_UNCONDITIONAL    0
DECL|macro|DISABLE_END_OF_FRAME
mdefine_line|#define DISABLE_END_OF_FRAME     1
DECL|macro|ENABLE_UNCONDITIONAL
mdefine_line|#define ENABLE_UNCONDITIONAL     2
DECL|macro|ENABLE_AUTO_CTS
mdefine_line|#define ENABLE_AUTO_CTS          3
DECL|macro|ENABLE_AUTO_DCD
mdefine_line|#define ENABLE_AUTO_DCD          3
DECL|macro|usc_EnableTransmitter
mdefine_line|#define usc_EnableTransmitter(a,b) &bslash;&n;&t;usc_OutReg( (a), TMR, (u16)((usc_InReg((a),TMR) &amp; 0xfffc) | (b)) )
DECL|macro|usc_EnableReceiver
mdefine_line|#define usc_EnableReceiver(a,b) &bslash;&n;&t;usc_OutReg( (a), RMR, (u16)((usc_InReg((a),RMR) &amp; 0xfffc) | (b)) )
id|u16
id|usc_InDmaReg
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|Port
)paren
suffix:semicolon
r_void
id|usc_OutDmaReg
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|Port
comma
id|u16
id|Value
)paren
suffix:semicolon
r_void
id|usc_DmaCmd
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|Cmd
)paren
suffix:semicolon
id|u16
id|usc_InReg
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|Port
)paren
suffix:semicolon
r_void
id|usc_OutReg
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|Port
comma
id|u16
id|Value
)paren
suffix:semicolon
r_void
id|usc_RTCmd
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|Cmd
)paren
suffix:semicolon
r_void
id|usc_RCmd
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|Cmd
)paren
suffix:semicolon
r_void
id|usc_TCmd
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|Cmd
)paren
suffix:semicolon
DECL|macro|usc_TCmd
mdefine_line|#define usc_TCmd(a,b) usc_OutReg((a), TCSR, (u16)((a)-&gt;tcsr_value + (b)))
DECL|macro|usc_RCmd
mdefine_line|#define usc_RCmd(a,b) usc_OutReg((a), RCSR, (b))
r_void
id|usc_process_rxoverrun_sync
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_start_receiver
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_stop_receiver
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_start_transmitter
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_stop_transmitter
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_set_txidle
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_load_txfifo
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_enable_aux_clock
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u32
id|DataRate
)paren
suffix:semicolon
r_void
id|usc_enable_loopback
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
id|enable
)paren
suffix:semicolon
r_void
id|usc_get_serial_signals
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_set_serial_signals
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_reset
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_set_sync_mode
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_set_sdlc_mode
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_set_async_mode
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_enable_async_clock
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u32
id|DataRate
)paren
suffix:semicolon
r_void
id|usc_loopback_frame
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_tx_timeout
c_func
(paren
r_int
r_int
id|context
)paren
suffix:semicolon
r_void
id|usc_loopmode_cancel_transmit
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_loopmode_insert_request
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_int
id|usc_loopmode_active
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|usc_loopmode_send_done
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_int
id|usc_loopmode_send_active
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_int
id|mgsl_ioctl_common
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SYNCLINK_SYNCPPP
multiline_comment|/* SPPP/HDLC stuff */
r_void
id|mgsl_sppp_init
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_sppp_delete
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_int
id|mgsl_sppp_open
c_func
(paren
r_struct
id|net_device
op_star
id|d
)paren
suffix:semicolon
r_int
id|mgsl_sppp_close
c_func
(paren
r_struct
id|net_device
op_star
id|d
)paren
suffix:semicolon
r_void
id|mgsl_sppp_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|d
)paren
suffix:semicolon
r_int
id|mgsl_sppp_tx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|d
)paren
suffix:semicolon
r_void
id|mgsl_sppp_rx_done
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_char
op_star
id|buf
comma
r_int
id|size
)paren
suffix:semicolon
r_void
id|mgsl_sppp_tx_done
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_int
id|mgsl_sppp_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
suffix:semicolon
r_struct
id|net_device_stats
op_star
id|mgsl_net_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Defines a BUS descriptor value for the PCI adapter&n; * local bus address ranges.&n; */
DECL|macro|BUS_DESCRIPTOR
mdefine_line|#define BUS_DESCRIPTOR( WrHold, WrDly, RdDly, Nwdd, Nwad, Nxda, Nrdd, Nrad ) &bslash;&n;(0x00400020 + &bslash;&n;((WrHold) &lt;&lt; 30) + &bslash;&n;((WrDly)  &lt;&lt; 28) + &bslash;&n;((RdDly)  &lt;&lt; 26) + &bslash;&n;((Nwdd)   &lt;&lt; 20) + &bslash;&n;((Nwad)   &lt;&lt; 15) + &bslash;&n;((Nxda)   &lt;&lt; 13) + &bslash;&n;((Nrdd)   &lt;&lt; 11) + &bslash;&n;((Nrad)   &lt;&lt;  6) )
r_void
id|mgsl_trace_block
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_const
r_char
op_star
id|data
comma
r_int
id|count
comma
r_int
id|xmit
)paren
suffix:semicolon
multiline_comment|/*&n; * Adapter diagnostic routines&n; */
id|BOOLEAN
id|mgsl_register_test
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
id|BOOLEAN
id|mgsl_irq_test
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
id|BOOLEAN
id|mgsl_dma_test
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
id|BOOLEAN
id|mgsl_memory_test
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_int
id|mgsl_adapter_test
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
multiline_comment|/*&n; * device and resource management routines&n; */
r_int
id|mgsl_claim_resources
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_release_resources
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_add_device
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_struct
id|mgsl_struct
op_star
id|mgsl_allocate_device
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|mgsl_enum_isa_devices
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * DMA buffer manupulation functions.&n; */
r_void
id|mgsl_free_rx_frame_buffers
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
r_int
id|StartIndex
comma
r_int
r_int
id|EndIndex
)paren
suffix:semicolon
r_int
id|mgsl_get_rx_frame
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_reset_rx_dma_buffers
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_load_tx_dma_buffer
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_const
r_char
op_star
id|Buffer
comma
r_int
r_int
id|BufferSize
)paren
suffix:semicolon
r_void
id|mgsl_load_pci_memory
c_func
(paren
r_char
op_star
id|TargetPtr
comma
r_const
r_char
op_star
id|SourcePtr
comma
r_int
r_int
id|count
)paren
suffix:semicolon
multiline_comment|/*&n; * DMA and Shared Memory buffer allocation and formatting&n; */
r_int
id|mgsl_allocate_dma_buffers
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_free_dma_buffers
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_int
id|mgsl_alloc_frame_memory
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|DMABUFFERENTRY
op_star
id|BufferList
comma
r_int
id|Buffercount
)paren
suffix:semicolon
r_void
id|mgsl_free_frame_memory
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|DMABUFFERENTRY
op_star
id|BufferList
comma
r_int
id|Buffercount
)paren
suffix:semicolon
r_int
id|mgsl_alloc_buffer_list_memory
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_free_buffer_list_memory
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_int
id|mgsl_alloc_intermediate_rxbuffer_memory
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_free_intermediate_rxbuffer_memory
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
multiline_comment|/*&n; * Bottom half interrupt handlers&n; */
r_void
id|mgsl_bh_handler
c_func
(paren
r_void
op_star
id|Context
)paren
suffix:semicolon
r_void
id|mgsl_bh_receive
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_bh_transmit
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_bh_status
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
multiline_comment|/*&n; * Interrupt handler routines and dispatch table.&n; */
r_void
id|mgsl_isr_null
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_isr_transmit_data
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_isr_receive_data
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_isr_receive_status
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_isr_transmit_status
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_isr_io_pin
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_isr_misc
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_void
id|mgsl_isr_receive_dma
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
DECL|typedef|isr_dispatch_func
r_typedef
r_void
(paren
op_star
id|isr_dispatch_func
)paren
(paren
r_struct
id|mgsl_struct
op_star
)paren
suffix:semicolon
DECL|variable|UscIsrTable
id|isr_dispatch_func
id|UscIsrTable
(braket
l_int|7
)braket
op_assign
(brace
id|mgsl_isr_null
comma
id|mgsl_isr_misc
comma
id|mgsl_isr_io_pin
comma
id|mgsl_isr_transmit_data
comma
id|mgsl_isr_transmit_status
comma
id|mgsl_isr_receive_data
comma
id|mgsl_isr_receive_status
)brace
suffix:semicolon
multiline_comment|/*&n; * ioctl call handlers&n; */
r_static
r_int
id|set_modem_info
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
r_int
id|cmd
comma
r_int
r_int
op_star
id|value
)paren
suffix:semicolon
r_static
r_int
id|get_modem_info
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
r_int
op_star
id|value
)paren
suffix:semicolon
r_static
r_int
id|mgsl_get_stats
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_struct
id|mgsl_icount
op_star
id|user_icount
)paren
suffix:semicolon
r_static
r_int
id|mgsl_get_params
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|MGSL_PARAMS
op_star
id|user_params
)paren
suffix:semicolon
r_static
r_int
id|mgsl_set_params
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|MGSL_PARAMS
op_star
id|new_params
)paren
suffix:semicolon
r_static
r_int
id|mgsl_get_txidle
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
op_star
id|idle_mode
)paren
suffix:semicolon
r_static
r_int
id|mgsl_set_txidle
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
id|idle_mode
)paren
suffix:semicolon
r_static
r_int
id|mgsl_txenable
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
id|enable
)paren
suffix:semicolon
r_static
r_int
id|mgsl_txabort
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_static
r_int
id|mgsl_rxenable
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
id|enable
)paren
suffix:semicolon
r_static
r_int
id|mgsl_wait_event
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
op_star
id|mask
)paren
suffix:semicolon
r_static
r_int
id|mgsl_loopmode_send_done
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
DECL|macro|jiffies_from_ms
mdefine_line|#define jiffies_from_ms(a) ((((a) * HZ)/1000)+1)
multiline_comment|/*&n; * Global linked list of SyncLink devices&n; */
DECL|variable|mgsl_device_list
r_struct
id|mgsl_struct
op_star
id|mgsl_device_list
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|mgsl_device_count
r_int
id|mgsl_device_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Set this param to non-zero to load eax with the&n; * .text section address and breakpoint on module load.&n; * This is useful for use with gdb and add-symbol-file command.&n; */
DECL|variable|break_on_load
r_int
id|break_on_load
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Driver major number, defaults to zero to get auto&n; * assigned major number. May be forced as module parameter.&n; */
DECL|variable|ttymajor
r_int
id|ttymajor
op_assign
l_int|0
suffix:semicolon
DECL|variable|cuamajor
r_int
id|cuamajor
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * Array of user specified options for ISA adapters.&n; */
DECL|variable|io
r_static
r_int
id|io
(braket
id|MAX_ISA_DEVICES
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|irq
r_static
r_int
id|irq
(braket
id|MAX_ISA_DEVICES
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|dma
r_static
r_int
id|dma
(braket
id|MAX_ISA_DEVICES
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|debug_level
r_static
r_int
id|debug_level
op_assign
l_int|0
suffix:semicolon
DECL|variable|maxframe
r_static
r_int
id|maxframe
(braket
id|MAX_TOTAL_DEVICES
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|dosyncppp
r_static
r_int
id|dosyncppp
(braket
id|MAX_TOTAL_DEVICES
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|break_on_load
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ttymajor
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|cuamajor
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|io
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_ISA_DEVICES
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_ISA_DEVICES
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dma
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_ISA_DEVICES
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug_level
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|maxframe
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_TOTAL_DEVICES
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|dosyncppp
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|MAX_TOTAL_DEVICES
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|driver_name
r_static
r_char
op_star
id|driver_name
op_assign
l_string|&quot;SyncLink serial driver&quot;
suffix:semicolon
DECL|variable|driver_version
r_static
r_char
op_star
id|driver_version
op_assign
l_string|&quot;3.2&quot;
suffix:semicolon
r_static
r_int
id|__init
id|synclink_init_one
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_const
r_struct
id|pci_device_id
op_star
id|ent
)paren
suffix:semicolon
r_static
r_void
id|__exit
id|synclink_remove_one
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
suffix:semicolon
DECL|variable|__devinitdata
r_static
r_struct
id|pci_device_id
id|synclink_pci_tbl
(braket
)braket
id|__devinitdata
op_assign
(brace
(brace
id|PCI_VENDOR_ID_MICROGATE
comma
id|PCI_DEVICE_ID_MICROGATE_USC
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
)brace
comma
(brace
l_int|0
comma
)brace
comma
multiline_comment|/* terminate list */
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
c_func
(paren
id|pci
comma
id|synclink_pci_tbl
)paren
suffix:semicolon
DECL|variable|synclink_pci_driver
r_static
r_struct
id|pci_driver
id|synclink_pci_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;synclink&quot;
comma
id|id_table
suffix:colon
id|synclink_pci_tbl
comma
id|probe
suffix:colon
id|synclink_init_one
comma
id|remove
suffix:colon
id|synclink_remove_one
comma
)brace
suffix:semicolon
DECL|variable|serial_driver
DECL|variable|callout_driver
r_static
r_struct
id|tty_driver
id|serial_driver
comma
id|callout_driver
suffix:semicolon
DECL|variable|serial_refcount
r_static
r_int
id|serial_refcount
suffix:semicolon
multiline_comment|/* number of characters left in xmit buffer before we ask for more */
DECL|macro|WAKEUP_CHARS
mdefine_line|#define WAKEUP_CHARS 256
r_static
r_void
id|mgsl_change_params
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
suffix:semicolon
r_static
r_void
id|mgsl_wait_until_sent
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|timeout
)paren
suffix:semicolon
DECL|variable|serial_table
r_static
r_struct
id|tty_struct
op_star
id|serial_table
(braket
id|MAX_TOTAL_DEVICES
)braket
suffix:semicolon
DECL|variable|serial_termios
r_static
r_struct
id|termios
op_star
id|serial_termios
(braket
id|MAX_TOTAL_DEVICES
)braket
suffix:semicolon
DECL|variable|serial_termios_locked
r_static
r_struct
id|termios
op_star
id|serial_termios_locked
(braket
id|MAX_TOTAL_DEVICES
)braket
suffix:semicolon
macro_line|#ifndef MIN
DECL|macro|MIN
mdefine_line|#define MIN(a,b)&t;((a) &lt; (b) ? (a) : (b))
macro_line|#endif
multiline_comment|/*&n; * 1st function defined in .text section. Calling this function in&n; * init_module() followed by a breakpoint allows a remote debugger&n; * (gdb) to get the .text address for the add-symbol-file command.&n; * This allows remote debugging of dynamically loadable modules.&n; */
r_void
op_star
id|mgsl_get_text_ptr
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|mgsl_get_text_ptr
r_void
op_star
id|mgsl_get_text_ptr
c_func
(paren
)paren
(brace
r_return
id|mgsl_get_text_ptr
suffix:semicolon
)brace
multiline_comment|/*&n; * tmp_buf is used as a temporary buffer by mgsl_write.  We need to&n; * lock it in case the COPY_FROM_USER blocks while swapping in a page,&n; * and some other program tries to do a serial write at the same time.&n; * Since the lock will only come under contention when the system is&n; * swapping and available memory is low, it makes sense to share one&n; * buffer across all the serial ioports, since it significantly saves&n; * memory if large numbers of serial ports are open.&n; */
DECL|variable|tmp_buf
r_static
r_int
r_char
op_star
id|tmp_buf
suffix:semicolon
r_static
id|DECLARE_MUTEX
c_func
(paren
id|tmp_buf_sem
)paren
suffix:semicolon
DECL|function|mgsl_paranoia_check
r_static
r_inline
r_int
id|mgsl_paranoia_check
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|kdev_t
id|device
comma
r_const
r_char
op_star
id|routine
)paren
(brace
macro_line|#ifdef MGSL_PARANOIA_CHECK
r_static
r_const
r_char
op_star
id|badmagic
op_assign
l_string|&quot;Warning: bad magic number for mgsl struct (%s) in %s&bslash;n&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|badinfo
op_assign
l_string|&quot;Warning: null mgsl_struct for (%s) in %s&bslash;n&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|printk
c_func
(paren
id|badinfo
comma
id|kdevname
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;magic
op_ne
id|MGSL_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|badmagic
comma
id|kdevname
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* mgsl_stop()&t;&t;throttle (stop) transmitter&n; * &t;&n; * Arguments:&t;&t;tty&t;pointer to tty info structure&n; * Return Value:&t;None&n; */
DECL|function|mgsl_stop
r_static
r_void
id|mgsl_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_stop&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;mgsl_stop(%s)&bslash;n&quot;
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tx_enabled
)paren
id|usc_stop_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_stop() */
multiline_comment|/* mgsl_start()&t;&t;release (start) transmitter&n; * &t;&n; * Arguments:&t;&t;tty&t;pointer to tty info structure&n; * Return Value:&t;None&n; */
DECL|function|mgsl_start
r_static
r_void
id|mgsl_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_start&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;mgsl_start(%s)&bslash;n&quot;
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tx_enabled
)paren
id|usc_start_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_start() */
multiline_comment|/*&n; * Bottom half work queue access functions&n; */
multiline_comment|/* mgsl_bh_action()&t;Return next bottom half action to perform.&n; * Return Value:&t;BH action code or 0 if nothing to do.&n; */
DECL|function|mgsl_bh_action
r_int
id|mgsl_bh_action
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;pending_bh
op_amp
id|BH_RECEIVE
)paren
(brace
id|info-&gt;pending_bh
op_and_assign
op_complement
id|BH_RECEIVE
suffix:semicolon
id|rc
op_assign
id|BH_RECEIVE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|info-&gt;pending_bh
op_amp
id|BH_TRANSMIT
)paren
(brace
id|info-&gt;pending_bh
op_and_assign
op_complement
id|BH_TRANSMIT
suffix:semicolon
id|rc
op_assign
id|BH_TRANSMIT
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|info-&gt;pending_bh
op_amp
id|BH_STATUS
)paren
(brace
id|info-&gt;pending_bh
op_and_assign
op_complement
id|BH_STATUS
suffix:semicolon
id|rc
op_assign
id|BH_STATUS
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rc
)paren
(brace
multiline_comment|/* Mark BH routine as complete */
id|info-&gt;bh_running
op_assign
l_int|0
suffix:semicolon
id|info-&gt;bh_requested
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * &t;Perform bottom half processing of work items queued by ISR.&n; */
DECL|function|mgsl_bh_handler
r_void
id|mgsl_bh_handler
c_func
(paren
r_void
op_star
id|Context
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|Context
suffix:semicolon
r_int
id|action
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_BH
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_bh_handler(%s) entry&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|info-&gt;bh_running
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
id|action
op_assign
id|mgsl_bh_action
c_func
(paren
id|info
)paren
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Process work item */
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_BH
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_bh_handler() work item action=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|action
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|action
)paren
(brace
r_case
id|BH_RECEIVE
suffix:colon
id|mgsl_bh_receive
c_func
(paren
id|info
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BH_TRANSMIT
suffix:colon
id|mgsl_bh_transmit
c_func
(paren
id|info
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BH_STATUS
suffix:colon
id|mgsl_bh_status
c_func
(paren
id|info
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* unknown work item ID */
id|printk
c_func
(paren
l_string|&quot;Unknown work item ID=%08X!&bslash;n&quot;
comma
id|action
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_BH
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_bh_handler(%s) exit&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
)brace
DECL|function|mgsl_bh_receive
r_void
id|mgsl_bh_receive
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_BH
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_bh_receive(%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_while
c_loop
(paren
id|mgsl_get_rx_frame
c_func
(paren
id|info
)paren
)paren
(brace
suffix:semicolon
)brace
)brace
DECL|function|mgsl_bh_transmit
r_void
id|mgsl_bh_transmit
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_BH
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_bh_transmit() entry on %s&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty
)paren
(brace
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_BH
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):calling ldisc.write_wakeup on %s&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* if transmitter idle and loopmode_send_done_requested&n;&t; * then start echoing RxD to TxD&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tx_active
op_logical_and
id|info-&gt;loopmode_send_done_requested
)paren
id|usc_loopmode_send_done
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|mgsl_bh_status
r_void
id|mgsl_bh_status
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_BH
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_bh_status() entry on %s&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|info-&gt;ri_chkcount
op_assign
l_int|0
suffix:semicolon
id|info-&gt;dsr_chkcount
op_assign
l_int|0
suffix:semicolon
id|info-&gt;dcd_chkcount
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cts_chkcount
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* mgsl_isr_receive_status()&n; * &n; *&t;Service a receive status interrupt. The type of status&n; *&t;interrupt is indicated by the state of the RCSR.&n; *&t;This is only used for HDLC mode.&n; *&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|mgsl_isr_receive_status
r_void
id|mgsl_isr_receive_status
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|u16
id|status
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|RCSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_isr_receive_status status=%04X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|RXSTATUS_ABORT_RECEIVED
)paren
op_logical_and
id|info-&gt;loopmode_insert_requested
op_logical_and
id|usc_loopmode_active
c_func
(paren
id|info
)paren
)paren
(brace
op_increment
id|info-&gt;icount.rxabort
suffix:semicolon
id|info-&gt;loopmode_insert_requested
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* clear CMR:13 to start echoing RxD to TxD */
id|info-&gt;cmr_value
op_and_assign
op_complement
id|BIT13
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|CMR
comma
id|info-&gt;cmr_value
)paren
suffix:semicolon
multiline_comment|/* disable received abort irq (no longer required) */
id|usc_OutReg
c_func
(paren
id|info
comma
id|RICR
comma
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|RICR
)paren
op_amp
op_complement
id|RXSTATUS_ABORT_RECEIVED
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
(paren
id|RXSTATUS_EXITED_HUNT
op_plus
id|RXSTATUS_IDLE_RECEIVED
)paren
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|RXSTATUS_EXITED_HUNT
)paren
id|info-&gt;icount.exithunt
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RXSTATUS_IDLE_RECEIVED
)paren
id|info-&gt;icount.rxidle
op_increment
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;event_wait_q
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|RXSTATUS_OVERRUN
)paren
(brace
id|info-&gt;icount.rxover
op_increment
suffix:semicolon
id|usc_process_rxoverrun_sync
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|RECEIVE_STATUS
)paren
suffix:semicolon
id|usc_UnlatchRxstatusBits
c_func
(paren
id|info
comma
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_isr_receive_status() */
multiline_comment|/* mgsl_isr_transmit_status()&n; * &n; * &t;Service a transmit status interrupt&n; *&t;HDLC mode :end of transmit frame&n; *&t;Async mode:all data is sent&n; * &t;transmit status is indicated by bits in the TCSR.&n; * &n; * Arguments:&t;&t;info&t;       pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|mgsl_isr_transmit_status
r_void
id|mgsl_isr_transmit_status
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|u16
id|status
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|TCSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_isr_transmit_status status=%04X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|status
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|TRANSMIT_STATUS
)paren
suffix:semicolon
id|usc_UnlatchTxstatusBits
c_func
(paren
id|info
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|TXSTATUS_UNDERRUN
op_or
id|TXSTATUS_ABORT_SENT
)paren
)paren
(brace
multiline_comment|/* finished sending HDLC abort. This may leave&t;*/
multiline_comment|/* the TxFifo with data from the aborted frame&t;*/
multiline_comment|/* so purge the TxFifo. Also shutdown the DMA&t;*/
multiline_comment|/* channel in case there is data remaining in &t;*/
multiline_comment|/* the DMA buffer&t;&t;&t;&t;*/
id|usc_DmaCmd
c_func
(paren
id|info
comma
id|DmaCmd_ResetTxChannel
)paren
suffix:semicolon
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_PurgeTxFifo
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|TXSTATUS_EOF_SENT
)paren
id|info-&gt;icount.txok
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
op_amp
id|TXSTATUS_UNDERRUN
)paren
id|info-&gt;icount.txunder
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
op_amp
id|TXSTATUS_ABORT_SENT
)paren
id|info-&gt;icount.txabort
op_increment
suffix:semicolon
r_else
id|info-&gt;icount.txunder
op_increment
suffix:semicolon
id|info-&gt;tx_active
op_assign
l_int|0
suffix:semicolon
id|info-&gt;xmit_cnt
op_assign
id|info-&gt;xmit_head
op_assign
id|info-&gt;xmit_tail
op_assign
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|info-&gt;tx_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;drop_rts_on_tx_done
)paren
(brace
id|usc_get_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_RTS
)paren
(brace
id|info-&gt;serial_signals
op_and_assign
op_complement
id|SerialSignal_RTS
suffix:semicolon
id|usc_set_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
id|info-&gt;drop_rts_on_tx_done
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SYNCLINK_SYNCPPP&t;
r_if
c_cond
(paren
id|info-&gt;netcount
)paren
id|mgsl_sppp_tx_done
c_func
(paren
id|info
)paren
suffix:semicolon
r_else
macro_line|#endif
(brace
r_if
c_cond
(paren
id|info-&gt;tty-&gt;stopped
op_logical_or
id|info-&gt;tty-&gt;hw_stopped
)paren
(brace
id|usc_stop_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|info-&gt;pending_bh
op_or_assign
id|BH_TRANSMIT
suffix:semicolon
)brace
)brace
multiline_comment|/* end of mgsl_isr_transmit_status() */
multiline_comment|/* mgsl_isr_io_pin()&n; * &n; * &t;Service an Input/Output pin interrupt. The type of&n; * &t;interrupt is indicated by bits in the MISR&n; * &t;&n; * Arguments:&t;&t;info&t;       pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|mgsl_isr_io_pin
r_void
id|mgsl_isr_io_pin
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_struct
id|mgsl_icount
op_star
id|icount
suffix:semicolon
id|u16
id|status
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|MISR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_isr_io_pin status=%04X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|status
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|IO_PIN
)paren
suffix:semicolon
id|usc_UnlatchIostatusBits
c_func
(paren
id|info
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|MISCSTATUS_CTS_LATCHED
op_or
id|MISCSTATUS_DCD_LATCHED
op_or
id|MISCSTATUS_DSR_LATCHED
op_or
id|MISCSTATUS_RI_LATCHED
)paren
)paren
(brace
id|icount
op_assign
op_amp
id|info-&gt;icount
suffix:semicolon
multiline_comment|/* update input line counters */
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_RI_LATCHED
)paren
(brace
r_if
c_cond
(paren
(paren
id|info-&gt;ri_chkcount
)paren
op_increment
op_ge
id|IO_PIN_SHUTDOWN_LIMIT
)paren
id|usc_DisablestatusIrqs
c_func
(paren
id|info
comma
id|SICR_RI
)paren
suffix:semicolon
id|icount-&gt;rng
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_RI
)paren
id|info-&gt;input_signal_events.ri_up
op_increment
suffix:semicolon
r_else
id|info-&gt;input_signal_events.ri_down
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_DSR_LATCHED
)paren
(brace
r_if
c_cond
(paren
(paren
id|info-&gt;dsr_chkcount
)paren
op_increment
op_ge
id|IO_PIN_SHUTDOWN_LIMIT
)paren
id|usc_DisablestatusIrqs
c_func
(paren
id|info
comma
id|SICR_DSR
)paren
suffix:semicolon
id|icount-&gt;dsr
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_DSR
)paren
id|info-&gt;input_signal_events.dsr_up
op_increment
suffix:semicolon
r_else
id|info-&gt;input_signal_events.dsr_down
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_DCD_LATCHED
)paren
(brace
r_if
c_cond
(paren
(paren
id|info-&gt;dcd_chkcount
)paren
op_increment
op_ge
id|IO_PIN_SHUTDOWN_LIMIT
)paren
id|usc_DisablestatusIrqs
c_func
(paren
id|info
comma
id|SICR_DCD
)paren
suffix:semicolon
id|icount-&gt;dcd
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_DCD
)paren
(brace
id|info-&gt;input_signal_events.dcd_up
op_increment
suffix:semicolon
macro_line|#ifdef CONFIG_SYNCLINK_SYNCPPP&t;
r_if
c_cond
(paren
id|info-&gt;netcount
)paren
id|sppp_reopen
c_func
(paren
id|info-&gt;netdev
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
id|info-&gt;input_signal_events.dcd_down
op_increment
suffix:semicolon
macro_line|#ifdef CONFIG_HARD_PPS
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_HARDPPS_CD
)paren
op_logical_and
(paren
id|status
op_amp
id|MISCSTATUS_DCD_LATCHED
)paren
)paren
id|hardpps
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_CTS_LATCHED
)paren
(brace
r_if
c_cond
(paren
(paren
id|info-&gt;cts_chkcount
)paren
op_increment
op_ge
id|IO_PIN_SHUTDOWN_LIMIT
)paren
id|usc_DisablestatusIrqs
c_func
(paren
id|info
comma
id|SICR_CTS
)paren
suffix:semicolon
id|icount-&gt;cts
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_CTS
)paren
id|info-&gt;input_signal_events.cts_up
op_increment
suffix:semicolon
r_else
id|info-&gt;input_signal_events.cts_down
op_increment
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;status_event_wait_q
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;event_wait_q
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CHECK_CD
)paren
op_logical_and
(paren
id|status
op_amp
id|MISCSTATUS_DCD_LATCHED
)paren
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s CD now %s...&quot;
comma
id|info-&gt;device_name
comma
(paren
id|status
op_amp
id|MISCSTATUS_DCD
)paren
ques
c_cond
l_string|&quot;on&quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_DCD
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_NOHUP
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;doing serial hangup...&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
)paren
id|tty_hangup
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CTS_FLOW
)paren
op_logical_and
(paren
id|status
op_amp
id|MISCSTATUS_CTS_LATCHED
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;tty-&gt;hw_stopped
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_CTS
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;CTS tx start...&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
)paren
id|info-&gt;tty-&gt;hw_stopped
op_assign
l_int|0
suffix:semicolon
id|usc_start_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
id|info-&gt;pending_bh
op_or_assign
id|BH_TRANSMIT
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|MISCSTATUS_CTS
)paren
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;CTS tx stop...&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
)paren
id|info-&gt;tty-&gt;hw_stopped
op_assign
l_int|1
suffix:semicolon
id|usc_stop_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
id|info-&gt;pending_bh
op_or_assign
id|BH_STATUS
suffix:semicolon
multiline_comment|/* for diagnostics set IRQ flag */
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_TXC_LATCHED
)paren
(brace
id|usc_OutReg
c_func
(paren
id|info
comma
id|SICR
comma
(paren
r_int
r_int
)paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|SICR
)paren
op_amp
op_complement
(paren
id|SICR_TXC_ACTIVE
op_plus
id|SICR_TXC_INACTIVE
)paren
)paren
)paren
suffix:semicolon
id|usc_UnlatchIostatusBits
c_func
(paren
id|info
comma
id|MISCSTATUS_TXC_LATCHED
)paren
suffix:semicolon
id|info-&gt;irq_occurred
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* end of mgsl_isr_io_pin() */
multiline_comment|/* mgsl_isr_transmit_data()&n; * &n; * &t;Service a transmit data interrupt (async mode only).&n; * &n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|mgsl_isr_transmit_data
r_void
id|mgsl_isr_transmit_data
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_isr_transmit_data xmit_cnt=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;xmit_cnt
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|TRANSMIT_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty-&gt;stopped
op_logical_or
id|info-&gt;tty-&gt;hw_stopped
)paren
(brace
id|usc_stop_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
)paren
id|usc_load_txfifo
c_func
(paren
id|info
)paren
suffix:semicolon
r_else
id|info-&gt;tx_active
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
OL
id|WAKEUP_CHARS
)paren
id|info-&gt;pending_bh
op_or_assign
id|BH_TRANSMIT
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_isr_transmit_data() */
multiline_comment|/* mgsl_isr_receive_data()&n; * &n; * &t;Service a receive data interrupt. This occurs&n; * &t;when operating in asynchronous interrupt transfer mode.&n; *&t;The receive data FIFO is flushed to the receive data buffers. &n; * &n; * Arguments:&t;&t;info&t;&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|mgsl_isr_receive_data
r_void
id|mgsl_isr_receive_data
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
id|Fifocount
suffix:semicolon
id|u16
id|status
suffix:semicolon
r_int
r_char
id|DataByte
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
r_struct
id|mgsl_icount
op_star
id|icount
op_assign
op_amp
id|info-&gt;icount
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_isr_receive_data&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|RECEIVE_DATA
)paren
suffix:semicolon
multiline_comment|/* select FIFO status for RICR readback */
id|usc_RCmd
c_func
(paren
id|info
comma
id|RCmd_SelectRicrRxFifostatus
)paren
suffix:semicolon
multiline_comment|/* clear the Wordstatus bit so that status readback */
multiline_comment|/* only reflects the status of this byte */
id|usc_OutReg
c_func
(paren
id|info
comma
id|RICR
op_plus
id|LSBONLY
comma
(paren
id|u16
)paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|RICR
op_plus
id|LSBONLY
)paren
op_amp
op_complement
id|BIT3
)paren
)paren
suffix:semicolon
multiline_comment|/* flush the receive FIFO */
r_while
c_loop
(paren
(paren
id|Fifocount
op_assign
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|RICR
)paren
op_rshift
l_int|8
)paren
)paren
)paren
(brace
multiline_comment|/* read one byte from RxFIFO */
id|outw
c_func
(paren
(paren
id|inw
c_func
(paren
id|info-&gt;io_base
op_plus
id|CCAR
)paren
op_amp
l_int|0x0780
)paren
op_or
(paren
id|RDR
op_plus
id|LSBONLY
)paren
comma
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
id|DataByte
op_assign
id|inb
c_func
(paren
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
multiline_comment|/* get the status of the received byte */
id|status
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|RCSR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|RXSTATUS_FRAMING_ERROR
op_plus
id|RXSTATUS_PARITY_ERROR
op_plus
id|RXSTATUS_OVERRUN
op_plus
id|RXSTATUS_BREAK_RECEIVED
)paren
)paren
id|usc_UnlatchRxstatusBits
c_func
(paren
id|info
comma
id|RXSTATUS_ALL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
r_continue
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_assign
id|DataByte
suffix:semicolon
id|icount-&gt;rx
op_increment
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|RXSTATUS_FRAMING_ERROR
op_plus
id|RXSTATUS_PARITY_ERROR
op_plus
id|RXSTATUS_OVERRUN
op_plus
id|RXSTATUS_BREAK_RECEIVED
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;rxerr=%04X&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* update error statistics */
r_if
c_cond
(paren
id|status
op_amp
id|RXSTATUS_BREAK_RECEIVED
)paren
(brace
id|status
op_and_assign
op_complement
(paren
id|RXSTATUS_FRAMING_ERROR
op_plus
id|RXSTATUS_PARITY_ERROR
)paren
suffix:semicolon
id|icount-&gt;brk
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|RXSTATUS_PARITY_ERROR
)paren
id|icount-&gt;parity
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
op_amp
id|RXSTATUS_FRAMING_ERROR
)paren
id|icount-&gt;frame
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
op_amp
id|RXSTATUS_OVERRUN
)paren
(brace
multiline_comment|/* must issue purge fifo cmd before */
multiline_comment|/* 16C32 accepts more receive chars */
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_PurgeRxFifo
)paren
suffix:semicolon
id|icount-&gt;overrun
op_increment
suffix:semicolon
)brace
multiline_comment|/* discard char if tty control flags say so */
r_if
c_cond
(paren
id|status
op_amp
id|info-&gt;ignore_status_mask
)paren
r_continue
suffix:semicolon
id|status
op_and_assign
id|info-&gt;read_status_mask
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RXSTATUS_BREAK_RECEIVED
)paren
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_BREAK
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SAK
)paren
id|do_SAK
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_amp
id|RXSTATUS_PARITY_ERROR
)paren
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_PARITY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
op_amp
id|RXSTATUS_FRAMING_ERROR
)paren
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_FRAME
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|RXSTATUS_OVERRUN
)paren
(brace
multiline_comment|/* Overrun is special, since it&squot;s&n;&t;&t;&t;&t; * reported immediately, and doesn&squot;t&n;&t;&t;&t;&t; * affect the current character&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|tty-&gt;flip.count
OL
id|TTY_FLIPBUF_SIZE
)paren
(brace
id|tty-&gt;flip.count
op_increment
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_increment
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|TTY_OVERRUN
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* end of if (error) */
id|tty-&gt;flip.flag_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_increment
suffix:semicolon
id|tty-&gt;flip.count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_isr_receive_data flip count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tty-&gt;flip.count
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s(%d):rx=%d brk=%d parity=%d frame=%d overrun=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|icount-&gt;rx
comma
id|icount-&gt;brk
comma
id|icount-&gt;parity
comma
id|icount-&gt;frame
comma
id|icount-&gt;overrun
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;flip.count
)paren
id|tty_flip_buffer_push
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* mgsl_isr_misc()&n; * &n; * &t;Service a miscellaneos interrupt source.&n; * &t;&n; * Arguments:&t;&t;info&t;&t;pointer to device extension (instance data)&n; * Return Value:&t;None&n; */
DECL|function|mgsl_isr_misc
r_void
id|mgsl_isr_misc
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|u16
id|status
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|MISR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_isr_misc status=%04X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|status
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|MISC
)paren
suffix:semicolon
id|usc_UnlatchMiscstatusBits
c_func
(paren
id|info
comma
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_isr_misc() */
multiline_comment|/* mgsl_isr_null()&n; *&n; * &t;Services undefined interrupt vectors from the&n; * &t;USC. (hence this function SHOULD never be called)&n; * &n; * Arguments:&t;&t;info&t;&t;pointer to device extension (instance data)&n; * Return Value:&t;None&n; */
DECL|function|mgsl_isr_null
r_void
id|mgsl_isr_null
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
)brace
multiline_comment|/* end of mgsl_isr_null() */
multiline_comment|/* mgsl_isr_receive_dma()&n; * &n; * &t;Service a receive DMA channel interrupt.&n; * &t;For this driver there are two sources of receive DMA interrupts&n; * &t;as identified in the Receive DMA mode Register (RDMR):&n; * &n; * &t;BIT3&t;EOA/EOL&t;&t;End of List, all receive buffers in receive&n; * &t;&t;&t;&t;buffer list have been filled (no more free buffers&n; * &t;&t;&t;&t;available). The DMA controller has shut down.&n; * &n; * &t;BIT2&t;EOB&t;&t;End of Buffer. This interrupt occurs when a receive&n; * &t;&t;&t;&t;DMA buffer is terminated in response to completion&n; * &t;&t;&t;&t;of a good frame or a frame with errors. The status&n; * &t;&t;&t;&t;of the frame is stored in the buffer entry in the&n; * &t;&t;&t;&t;list of receive buffer entries.&n; * &n; * Arguments:&t;&t;info&t;&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|mgsl_isr_receive_dma
r_void
id|mgsl_isr_receive_dma
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|u16
id|status
suffix:semicolon
multiline_comment|/* clear interrupt pending and IUS bit for Rx DMA IRQ */
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|CDIR
comma
id|BIT9
op_plus
id|BIT1
)paren
suffix:semicolon
multiline_comment|/* Read the receive DMA status to identify interrupt type. */
multiline_comment|/* This also clears the status bits. */
id|status
op_assign
id|usc_InDmaReg
c_func
(paren
id|info
comma
id|RDMR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_isr_receive_dma(%s) status=%04X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|status
)paren
suffix:semicolon
id|info-&gt;pending_bh
op_or_assign
id|BH_RECEIVE
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|BIT3
)paren
(brace
id|info-&gt;rx_overflow
op_assign
l_int|1
suffix:semicolon
id|info-&gt;icount.buf_overrun
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* end of mgsl_isr_receive_dma() */
multiline_comment|/* mgsl_interrupt()&n; * &n; * &t;Interrupt service routine entry point.&n; * &t;&n; * Arguments:&n; * &n; * &t;irq&t;&t;interrupt number that caused interrupt&n; * &t;dev_id&t;&t;device ID supplied during interrupt registration&n; * &t;regs&t;&t;interrupted processor context&n; * &t;&n; * Return Value: None&n; */
DECL|function|mgsl_interrupt
r_static
r_void
id|mgsl_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
suffix:semicolon
id|u16
id|UscVector
suffix:semicolon
id|u16
id|DmaVector
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_interrupt(%d)entry.&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|irq
)paren
suffix:semicolon
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* Read the interrupt vectors from hardware. */
id|UscVector
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|IVR
)paren
op_rshift
l_int|9
suffix:semicolon
id|DmaVector
op_assign
id|usc_InDmaReg
c_func
(paren
id|info
comma
id|DIVR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):%s UscVector=%08X DmaVector=%08X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|UscVector
comma
id|DmaVector
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|UscVector
op_logical_and
op_logical_neg
id|DmaVector
)paren
r_break
suffix:semicolon
multiline_comment|/* Dispatch interrupt vector */
r_if
c_cond
(paren
id|UscVector
)paren
(paren
op_star
id|UscIsrTable
(braket
id|UscVector
)braket
)paren
(paren
id|info
)paren
suffix:semicolon
r_else
id|mgsl_isr_receive_dma
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;isr_overflow
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s(%d):%s isr overflow irq=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|irq
)paren
suffix:semicolon
id|usc_DisableMasterIrqBit
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_DisableDmaInterrupts
c_func
(paren
id|info
comma
id|DICR_MASTER
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Request bottom half processing if there&squot;s something &n;&t; * for it to do and the bh is not already running&n;&t; */
r_if
c_cond
(paren
id|info-&gt;pending_bh
op_logical_and
op_logical_neg
id|info-&gt;bh_running
op_logical_and
op_logical_neg
id|info-&gt;bh_requested
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):%s queueing bh task.&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|info-&gt;task
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
id|info-&gt;bh_requested
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_interrupt(%d)exit.&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|irq
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_interrupt() */
multiline_comment|/* startup()&n; * &n; * &t;Initialize and start device.&n; * &t;&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|startup
r_static
r_int
id|startup
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_startup(%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;xmit_buf
)paren
(brace
multiline_comment|/* allocate a page of memory for a transmit buffer */
id|info-&gt;xmit_buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;xmit_buf
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s(%d):%s can&squot;t allocate transmit buffer&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|info-&gt;pending_bh
op_assign
l_int|0
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|info-&gt;tx_timer
)paren
suffix:semicolon
id|info-&gt;tx_timer.data
op_assign
(paren
r_int
r_int
)paren
id|info
suffix:semicolon
id|info-&gt;tx_timer.function
op_assign
id|mgsl_tx_timeout
suffix:semicolon
multiline_comment|/* Allocate and claim adapter resources */
id|retval
op_assign
id|mgsl_claim_resources
c_func
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/* perform existance check and diagnostics */
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|retval
op_assign
id|mgsl_adapter_test
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
r_if
c_cond
(paren
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
op_logical_and
id|info-&gt;tty
)paren
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
id|mgsl_release_resources
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* program hardware for current parameters */
id|mgsl_change_params
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
)paren
id|clear_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|ASYNC_INITIALIZED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of startup() */
multiline_comment|/* shutdown()&n; *&n; * Called by mgsl_close() and mgsl_hangup() to shutdown hardware&n; *&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|shutdown
r_static
r_void
id|shutdown
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_shutdown(%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
multiline_comment|/* clear status wait queue because status changes */
multiline_comment|/* can&squot;t happen after shutting down the hardware */
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;status_event_wait_q
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;event_wait_q
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|info-&gt;tx_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;xmit_buf
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|info-&gt;xmit_buf
)paren
suffix:semicolon
id|info-&gt;xmit_buf
op_assign
l_int|0
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_DisableMasterIrqBit
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_stop_receiver
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_stop_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_DisableInterrupts
c_func
(paren
id|info
comma
id|RECEIVE_DATA
op_plus
id|RECEIVE_STATUS
op_plus
id|TRANSMIT_DATA
op_plus
id|TRANSMIT_STATUS
op_plus
id|IO_PIN
op_plus
id|MISC
)paren
suffix:semicolon
id|usc_DisableDmaInterrupts
c_func
(paren
id|info
comma
id|DICR_MASTER
op_plus
id|DICR_TRANSMIT
op_plus
id|DICR_RECEIVE
)paren
suffix:semicolon
multiline_comment|/* Disable DMAEN (Port 7, Bit 14) */
multiline_comment|/* This disconnects the DMA request signal from the ISA bus */
multiline_comment|/* on the ISA adapter. This has no effect for the PCI adapter */
id|usc_OutReg
c_func
(paren
id|info
comma
id|PCR
comma
(paren
id|u16
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|PCR
)paren
op_or
id|BIT15
)paren
op_or
id|BIT14
)paren
)paren
suffix:semicolon
multiline_comment|/* Disable INTEN (Port 6, Bit12) */
multiline_comment|/* This disconnects the IRQ request signal to the ISA bus */
multiline_comment|/* on the ISA adapter. This has no effect for the PCI adapter */
id|usc_OutReg
c_func
(paren
id|info
comma
id|PCR
comma
(paren
id|u16
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|PCR
)paren
op_or
id|BIT13
)paren
op_or
id|BIT12
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tty
op_logical_or
id|info-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
(brace
id|info-&gt;serial_signals
op_and_assign
op_complement
(paren
id|SerialSignal_DTR
op_plus
id|SerialSignal_RTS
)paren
suffix:semicolon
id|usc_set_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|mgsl_release_resources
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
)paren
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
id|ASYNC_INITIALIZED
suffix:semicolon
)brace
multiline_comment|/* end of shutdown() */
DECL|function|mgsl_program_hw
r_static
r_void
id|mgsl_program_hw
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_stop_receiver
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_stop_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
id|info-&gt;xmit_cnt
op_assign
id|info-&gt;xmit_head
op_assign
id|info-&gt;xmit_tail
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.mode
op_eq
id|MGSL_MODE_HDLC
op_logical_or
id|info-&gt;netcount
)paren
id|usc_set_sync_mode
c_func
(paren
id|info
)paren
suffix:semicolon
r_else
id|usc_set_async_mode
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_set_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
id|info-&gt;dcd_chkcount
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cts_chkcount
op_assign
l_int|0
suffix:semicolon
id|info-&gt;ri_chkcount
op_assign
l_int|0
suffix:semicolon
id|info-&gt;dsr_chkcount
op_assign
l_int|0
suffix:semicolon
id|usc_EnableStatusIrqs
c_func
(paren
id|info
comma
id|SICR_CTS
op_plus
id|SICR_DSR
op_plus
id|SICR_DCD
op_plus
id|SICR_RI
)paren
suffix:semicolon
id|usc_EnableInterrupts
c_func
(paren
id|info
comma
id|IO_PIN
)paren
suffix:semicolon
id|usc_get_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;netcount
op_logical_or
id|info-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|CREAD
)paren
id|usc_start_receiver
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Reconfigure adapter based on new parameters&n; */
DECL|function|mgsl_change_params
r_static
r_void
id|mgsl_change_params
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
id|cflag
suffix:semicolon
r_int
id|bits_per_char
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tty
op_logical_or
op_logical_neg
id|info-&gt;tty-&gt;termios
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_change_params(%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|cflag
op_assign
id|info-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
multiline_comment|/* if B0 rate (hangup) specified then negate DTR and RTS */
multiline_comment|/* otherwise assert DTR and RTS */
r_if
c_cond
(paren
id|cflag
op_amp
id|CBAUD
)paren
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_RTS
op_plus
id|SerialSignal_DTR
suffix:semicolon
r_else
id|info-&gt;serial_signals
op_and_assign
op_complement
(paren
id|SerialSignal_RTS
op_plus
id|SerialSignal_DTR
)paren
suffix:semicolon
multiline_comment|/* byte size and parity */
r_switch
c_cond
(paren
id|cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|info-&gt;params.data_bits
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|info-&gt;params.data_bits
op_assign
l_int|6
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|info-&gt;params.data_bits
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS8
suffix:colon
id|info-&gt;params.data_bits
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Never happens, but GCC is too dumb to figure it out */
r_default
suffix:colon
id|info-&gt;params.data_bits
op_assign
l_int|7
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|CSTOPB
)paren
id|info-&gt;params.stop_bits
op_assign
l_int|2
suffix:semicolon
r_else
id|info-&gt;params.stop_bits
op_assign
l_int|1
suffix:semicolon
id|info-&gt;params.parity
op_assign
id|ASYNC_PARITY_NONE
suffix:semicolon
r_if
c_cond
(paren
id|cflag
op_amp
id|PARENB
)paren
(brace
r_if
c_cond
(paren
id|cflag
op_amp
id|PARODD
)paren
id|info-&gt;params.parity
op_assign
id|ASYNC_PARITY_ODD
suffix:semicolon
r_else
id|info-&gt;params.parity
op_assign
id|ASYNC_PARITY_EVEN
suffix:semicolon
macro_line|#ifdef CMSPAR
r_if
c_cond
(paren
id|cflag
op_amp
id|CMSPAR
)paren
id|info-&gt;params.parity
op_assign
id|ASYNC_PARITY_SPACE
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* calculate number of jiffies to transmit a full&n;&t; * FIFO (32 bytes) at specified data rate&n;&t; */
id|bits_per_char
op_assign
id|info-&gt;params.data_bits
op_plus
id|info-&gt;params.stop_bits
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* if port data rate is set to 460800 or less then&n;&t; * allow tty settings to override, otherwise keep the&n;&t; * current data rate.&n;&t; */
r_if
c_cond
(paren
id|info-&gt;params.data_rate
op_le
l_int|460800
)paren
id|info-&gt;params.data_rate
op_assign
id|tty_get_baud_rate
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.data_rate
)paren
(brace
id|info-&gt;timeout
op_assign
(paren
l_int|32
op_star
id|HZ
op_star
id|bits_per_char
)paren
op_div
id|info-&gt;params.data_rate
suffix:semicolon
)brace
id|info-&gt;timeout
op_add_assign
id|HZ
op_div
l_int|50
suffix:semicolon
multiline_comment|/* Add .02 seconds of slop */
r_if
c_cond
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
id|info-&gt;flags
op_or_assign
id|ASYNC_CTS_FLOW
suffix:semicolon
r_else
id|info-&gt;flags
op_and_assign
op_complement
id|ASYNC_CTS_FLOW
suffix:semicolon
r_if
c_cond
(paren
id|cflag
op_amp
id|CLOCAL
)paren
id|info-&gt;flags
op_and_assign
op_complement
id|ASYNC_CHECK_CD
suffix:semicolon
r_else
id|info-&gt;flags
op_or_assign
id|ASYNC_CHECK_CD
suffix:semicolon
multiline_comment|/* process tty input control flags */
id|info-&gt;read_status_mask
op_assign
id|RXSTATUS_OVERRUN
suffix:semicolon
r_if
c_cond
(paren
id|I_INPCK
c_func
(paren
id|info-&gt;tty
)paren
)paren
id|info-&gt;read_status_mask
op_or_assign
id|RXSTATUS_PARITY_ERROR
op_or
id|RXSTATUS_FRAMING_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|I_BRKINT
c_func
(paren
id|info-&gt;tty
)paren
op_logical_or
id|I_PARMRK
c_func
(paren
id|info-&gt;tty
)paren
)paren
id|info-&gt;read_status_mask
op_or_assign
id|RXSTATUS_BREAK_RECEIVED
suffix:semicolon
r_if
c_cond
(paren
id|I_IGNPAR
c_func
(paren
id|info-&gt;tty
)paren
)paren
id|info-&gt;ignore_status_mask
op_or_assign
id|RXSTATUS_PARITY_ERROR
op_or
id|RXSTATUS_FRAMING_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|I_IGNBRK
c_func
(paren
id|info-&gt;tty
)paren
)paren
(brace
id|info-&gt;ignore_status_mask
op_or_assign
id|RXSTATUS_BREAK_RECEIVED
suffix:semicolon
multiline_comment|/* If ignoring parity and break indicators, ignore &n;&t;&t; * overruns too.  (For real raw support).&n;&t;&t; */
r_if
c_cond
(paren
id|I_IGNPAR
c_func
(paren
id|info-&gt;tty
)paren
)paren
id|info-&gt;ignore_status_mask
op_or_assign
id|RXSTATUS_OVERRUN
suffix:semicolon
)brace
id|mgsl_program_hw
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_change_params() */
multiline_comment|/* mgsl_put_char()&n; * &n; * &t;Add a character to the transmit buffer.&n; * &t;&n; * Arguments:&t;&t;tty&t;pointer to tty information structure&n; * &t;&t;&t;ch&t;character to add to transmit buffer&n; * &t;&t;&n; * Return Value:&t;None&n; */
DECL|function|mgsl_put_char
r_static
r_void
id|mgsl_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_put_char(%d) on %s&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|ch
comma
id|info-&gt;device_name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_put_char&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
op_logical_neg
id|info-&gt;xmit_buf
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;params.mode
op_ne
id|MGSL_MODE_HDLC
)paren
op_logical_or
op_logical_neg
id|info-&gt;tx_active
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
OL
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
(brace
id|info-&gt;xmit_buf
(braket
id|info-&gt;xmit_head
op_increment
)braket
op_assign
id|ch
suffix:semicolon
id|info-&gt;xmit_head
op_and_assign
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
suffix:semicolon
id|info-&gt;xmit_cnt
op_increment
suffix:semicolon
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_put_char() */
multiline_comment|/* mgsl_flush_chars()&n; * &n; * &t;Enable transmitter so remaining characters in the&n; * &t;transmit buffer are sent.&n; * &t;&n; * Arguments:&t;&t;tty&t;pointer to tty information structure&n; * Return Value:&t;None&n; */
DECL|function|mgsl_flush_chars
r_static
r_void
id|mgsl_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_flush_chars() entry on %s xmit_cnt=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|info-&gt;xmit_cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_flush_chars&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
op_le
l_int|0
op_logical_or
id|tty-&gt;stopped
op_logical_or
id|tty-&gt;hw_stopped
op_logical_or
op_logical_neg
id|info-&gt;xmit_buf
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_flush_chars() entry on %s starting transmitter&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tx_active
)paren
(brace
r_if
c_cond
(paren
(paren
id|info-&gt;params.mode
op_eq
id|MGSL_MODE_HDLC
)paren
op_logical_and
id|info-&gt;xmit_cnt
)paren
(brace
multiline_comment|/* operating in synchronous (frame oriented) mode */
multiline_comment|/* copy data from circular xmit_buf to */
multiline_comment|/* transmit DMA buffer. */
id|mgsl_load_tx_dma_buffer
c_func
(paren
id|info
comma
id|info-&gt;xmit_buf
comma
id|info-&gt;xmit_cnt
)paren
suffix:semicolon
)brace
id|usc_start_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_flush_chars() */
multiline_comment|/* mgsl_write()&n; * &n; * &t;Send a block of data&n; * &t;&n; * Arguments:&n; * &n; * &t;tty&t;&t;pointer to tty information structure&n; * &t;from_user&t;flag: 1 = from user process&n; * &t;buf&t;&t;pointer to buffer containing send data&n; * &t;count&t;&t;size of send data in bytes&n; * &t;&n; * Return Value:&t;number of characters written&n; */
DECL|function|mgsl_write
r_static
r_int
id|mgsl_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|c
comma
id|ret
op_assign
l_int|0
comma
id|err
suffix:semicolon
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_write(%s) count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_write&quot;
)paren
)paren
r_goto
id|cleanup
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
op_logical_neg
id|info-&gt;xmit_buf
op_logical_or
op_logical_neg
id|tmp_buf
)paren
r_goto
id|cleanup
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.mode
op_eq
id|MGSL_MODE_HDLC
)paren
(brace
multiline_comment|/* operating in synchronous (frame oriented) mode */
r_if
c_cond
(paren
id|info-&gt;tx_active
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* if operating in HDLC LoopMode and the adapter  */
multiline_comment|/* has yet to be inserted into the loop, we can&squot;t */
multiline_comment|/* transmit&t;&t;&t;&t;&t;  */
r_if
c_cond
(paren
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_HDLC_LOOPMODE
)paren
op_logical_and
op_logical_neg
id|usc_loopmode_active
c_func
(paren
id|info
)paren
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
)paren
(brace
multiline_comment|/* Send accumulated from send_char() calls */
multiline_comment|/* as frame and wait before accepting more data. */
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* copy data from circular xmit_buf to */
multiline_comment|/* transmit DMA buffer. */
id|mgsl_load_tx_dma_buffer
c_func
(paren
id|info
comma
id|info-&gt;xmit_buf
comma
id|info-&gt;xmit_cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_write(%s) sync xmit_cnt flushing&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_write(%s) sync transmit accepted&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|ret
op_assign
id|count
suffix:semicolon
id|info-&gt;xmit_cnt
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
(brace
id|down
c_func
(paren
op_amp
id|tmp_buf_sem
)paren
suffix:semicolon
id|COPY_FROM_USER
c_func
(paren
id|err
comma
id|tmp_buf
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_write(%s) sync user buf copy failed&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
id|mgsl_load_tx_dma_buffer
c_func
(paren
id|info
comma
id|tmp_buf
comma
id|count
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|tmp_buf_sem
)paren
suffix:semicolon
)brace
r_else
id|mgsl_load_tx_dma_buffer
c_func
(paren
id|info
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|from_user
)paren
(brace
id|down
c_func
(paren
op_amp
id|tmp_buf_sem
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|c
op_assign
id|MIN
c_func
(paren
id|count
comma
id|MIN
c_func
(paren
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_cnt
op_minus
l_int|1
comma
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_head
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
r_break
suffix:semicolon
id|COPY_FROM_USER
c_func
(paren
id|err
comma
id|tmp_buf
comma
id|buf
comma
id|c
)paren
suffix:semicolon
id|c
op_sub_assign
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|c
op_assign
id|MIN
c_func
(paren
id|c
comma
id|MIN
c_func
(paren
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_cnt
op_minus
l_int|1
comma
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_head
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|info-&gt;xmit_buf
op_plus
id|info-&gt;xmit_head
comma
id|tmp_buf
comma
id|c
)paren
suffix:semicolon
id|info-&gt;xmit_head
op_assign
(paren
(paren
id|info-&gt;xmit_head
op_plus
id|c
)paren
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|info-&gt;xmit_cnt
op_add_assign
id|c
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|buf
op_add_assign
id|c
suffix:semicolon
id|count
op_sub_assign
id|c
suffix:semicolon
id|ret
op_add_assign
id|c
suffix:semicolon
)brace
id|up
c_func
(paren
op_amp
id|tmp_buf_sem
)paren
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|c
op_assign
id|MIN
c_func
(paren
id|count
comma
id|MIN
c_func
(paren
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_cnt
op_minus
l_int|1
comma
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_head
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|info-&gt;xmit_buf
op_plus
id|info-&gt;xmit_head
comma
id|buf
comma
id|c
)paren
suffix:semicolon
id|info-&gt;xmit_head
op_assign
(paren
(paren
id|info-&gt;xmit_head
op_plus
id|c
)paren
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|info-&gt;xmit_cnt
op_add_assign
id|c
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|buf
op_add_assign
id|c
suffix:semicolon
id|count
op_sub_assign
id|c
suffix:semicolon
id|ret
op_add_assign
id|c
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
op_logical_and
op_logical_neg
id|tty-&gt;stopped
op_logical_and
op_logical_neg
id|tty-&gt;hw_stopped
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tx_active
)paren
id|usc_start_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
id|cleanup
suffix:colon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_write(%s) returning=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_write() */
multiline_comment|/* mgsl_write_room()&n; *&n; *&t;Return the count of free bytes in transmit buffer&n; * &t;&n; * Arguments:&t;&t;tty&t;pointer to tty info structure&n; * Return Value:&t;None&n; */
DECL|function|mgsl_write_room
r_static
r_int
id|mgsl_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_write_room&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|ret
op_assign
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_cnt
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_write_room(%s)=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|ret
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.mode
op_eq
id|MGSL_MODE_HDLC
)paren
(brace
multiline_comment|/* operating in synchronous (frame oriented) mode */
r_if
c_cond
(paren
id|info-&gt;tx_active
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
id|HDLC_MAX_FRAME_SIZE
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_write_room() */
multiline_comment|/* mgsl_chars_in_buffer()&n; *&n; *&t;Return the count of bytes in transmit buffer&n; * &t;&n; * Arguments:&t;&t;tty&t;pointer to tty info structure&n; * Return Value:&t;None&n; */
DECL|function|mgsl_chars_in_buffer
r_static
r_int
id|mgsl_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_chars_in_buffer(%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_chars_in_buffer&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_chars_in_buffer(%s)=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|info-&gt;xmit_cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.mode
op_eq
id|MGSL_MODE_HDLC
)paren
(brace
multiline_comment|/* operating in synchronous (frame oriented) mode */
r_if
c_cond
(paren
id|info-&gt;tx_active
)paren
r_return
id|info-&gt;tx_buffer_list
(braket
l_int|0
)braket
dot
id|rcc
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|info-&gt;xmit_cnt
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_chars_in_buffer() */
multiline_comment|/* mgsl_flush_buffer()&n; *&n; *&t;Discard all data in the send buffer&n; * &t;&n; * Arguments:&t;&t;tty&t;pointer to tty info structure&n; * Return Value:&t;None&n; */
DECL|function|mgsl_flush_buffer
r_static
r_void
id|mgsl_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_flush_buffer(%s) entry&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_flush_buffer&quot;
)paren
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|info-&gt;xmit_cnt
op_assign
id|info-&gt;xmit_head
op_assign
id|info-&gt;xmit_tail
op_assign
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|info-&gt;tx_timer
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_flush_buffer() */
multiline_comment|/* mgsl_send_xchar()&n; *&n; *&t;Send a high-priority XON/XOFF character&n; * &t;&n; * Arguments:&t;&t;tty&t;pointer to tty info structure&n; *&t;&t;&t;ch&t;character to send&n; * Return Value:&t;None&n; */
DECL|function|mgsl_send_xchar
r_static
r_void
id|mgsl_send_xchar
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_char
id|ch
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_send_xchar(%s,%d)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|ch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_send_xchar&quot;
)paren
)paren
r_return
suffix:semicolon
id|info-&gt;x_char
op_assign
id|ch
suffix:semicolon
r_if
c_cond
(paren
id|ch
)paren
(brace
multiline_comment|/* Make sure transmit interrupts are on */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tx_enabled
)paren
id|usc_start_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end of mgsl_send_xchar() */
multiline_comment|/* mgsl_throttle()&n; * &n; * &t;Signal remote device to throttle send data (our receive data)&n; * &t;&n; * Arguments:&t;&t;tty&t;pointer to tty info structure&n; * Return Value:&t;None&n; */
DECL|function|mgsl_throttle
r_static
r_void
id|mgsl_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_throttle(%s) entry&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_throttle&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
id|mgsl_send_xchar
c_func
(paren
id|tty
comma
id|STOP_CHAR
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|info-&gt;serial_signals
op_and_assign
op_complement
id|SerialSignal_RTS
suffix:semicolon
id|usc_set_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end of mgsl_throttle() */
multiline_comment|/* mgsl_unthrottle()&n; * &n; * &t;Signal remote device to stop throttling send data (our receive data)&n; * &t;&n; * Arguments:&t;&t;tty&t;pointer to tty info structure&n; * Return Value:&t;None&n; */
DECL|function|mgsl_unthrottle
r_static
r_void
id|mgsl_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_unthrottle(%s) entry&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_unthrottle&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;x_char
)paren
id|info-&gt;x_char
op_assign
l_int|0
suffix:semicolon
r_else
id|mgsl_send_xchar
c_func
(paren
id|tty
comma
id|START_CHAR
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_RTS
suffix:semicolon
id|usc_set_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end of mgsl_unthrottle() */
multiline_comment|/* mgsl_get_stats()&n; * &n; * &t;get the current serial parameters information&n; *&n; * Arguments:&t;info&t;&t;pointer to device instance data&n; * &t;&t;user_icount&t;pointer to buffer to hold returned stats&n; * &t;&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|mgsl_get_stats
r_static
r_int
id|mgsl_get_stats
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_struct
id|mgsl_icount
op_star
id|user_icount
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_get_params(%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|COPY_TO_USER
c_func
(paren
id|err
comma
id|user_icount
comma
op_amp
id|info-&gt;icount
comma
r_sizeof
(paren
r_struct
id|mgsl_icount
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_get_stats(%s) user buffer copy failed&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_get_stats() */
multiline_comment|/* mgsl_get_params()&n; * &n; * &t;get the current serial parameters information&n; *&n; * Arguments:&t;info&t;&t;pointer to device instance data&n; * &t;&t;user_params&t;pointer to buffer to hold returned params&n; * &t;&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|mgsl_get_params
r_static
r_int
id|mgsl_get_params
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|MGSL_PARAMS
op_star
id|user_params
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_get_params(%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|COPY_TO_USER
c_func
(paren
id|err
comma
id|user_params
comma
op_amp
id|info-&gt;params
comma
r_sizeof
(paren
id|MGSL_PARAMS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_get_params(%s) user buffer copy failed&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_get_params() */
multiline_comment|/* mgsl_set_params()&n; * &n; * &t;set the serial parameters&n; * &t;&n; * Arguments:&n; * &n; * &t;info&t;&t;pointer to device instance data&n; * &t;new_params&t;user buffer containing new serial params&n; *&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|mgsl_set_params
r_static
r_int
id|mgsl_set_params
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|MGSL_PARAMS
op_star
id|new_params
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|MGSL_PARAMS
id|tmp_params
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_set_params %s&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|COPY_FROM_USER
c_func
(paren
id|err
comma
op_amp
id|tmp_params
comma
id|new_params
comma
r_sizeof
(paren
id|MGSL_PARAMS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_set_params(%s) user buffer copy failed&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|info-&gt;params
comma
op_amp
id|tmp_params
comma
r_sizeof
(paren
id|MGSL_PARAMS
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|mgsl_change_params
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_set_params() */
multiline_comment|/* mgsl_get_txidle()&n; * &n; * &t;get the current transmit idle mode&n; *&n; * Arguments:&t;info&t;&t;pointer to device instance data&n; * &t;&t;idle_mode&t;pointer to buffer to hold returned idle mode&n; * &t;&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|mgsl_get_txidle
r_static
r_int
id|mgsl_get_txidle
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
op_star
id|idle_mode
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_get_txidle(%s)=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|info-&gt;idle_mode
)paren
suffix:semicolon
id|COPY_TO_USER
c_func
(paren
id|err
comma
id|idle_mode
comma
op_amp
id|info-&gt;idle_mode
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_get_txidle(%s) user buffer copy failed&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_get_txidle() */
multiline_comment|/* mgsl_set_txidle()&t;service ioctl to set transmit idle mode&n; * &t;&n; * Arguments:&t; &t;info&t;&t;pointer to device instance data&n; * &t;&t;&t;idle_mode&t;new idle mode&n; *&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|mgsl_set_txidle
r_static
r_int
id|mgsl_set_txidle
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
id|idle_mode
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_set_txidle(%s,%d)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|idle_mode
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|info-&gt;idle_mode
op_assign
id|idle_mode
suffix:semicolon
id|usc_set_txidle
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_set_txidle() */
multiline_comment|/* mgsl_txenable()&n; * &n; * &t;enable or disable the transmitter&n; * &t;&n; * Arguments:&n; * &n; * &t;info&t;&t;pointer to device instance data&n; * &t;enable&t;&t;1 = enable, 0 = disable&n; *&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|mgsl_txenable
r_static
r_int
id|mgsl_txenable
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
id|enable
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_txenable(%s,%d)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|enable
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|enable
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tx_enabled
)paren
(brace
id|usc_start_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/*--------------------------------------------------&n;&t;&t;&t; * if HDLC/SDLC Loop mode, attempt to insert the&n;&t;&t;&t; * station in the &squot;loop&squot; by setting CMR:13. Upon&n;&t;&t;&t; * receipt of the next GoAhead (RxAbort) sequence,&n;&t;&t;&t; * the OnLoop indicator (CCSR:7) should go active&n;&t;&t;&t; * to indicate that we are on the loop&n;&t;&t;&t; *--------------------------------------------------*/
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_HDLC_LOOPMODE
)paren
id|usc_loopmode_insert_request
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|info-&gt;tx_enabled
)paren
id|usc_stop_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_txenable() */
multiline_comment|/* mgsl_txabort()&t;abort send HDLC frame&n; * &t;&n; * Arguments:&t; &t;info&t;&t;pointer to device instance data&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|mgsl_txabort
r_static
r_int
id|mgsl_txabort
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_txabort(%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tx_active
op_logical_and
id|info-&gt;params.mode
op_eq
id|MGSL_MODE_HDLC
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_HDLC_LOOPMODE
)paren
id|usc_loopmode_cancel_transmit
c_func
(paren
id|info
)paren
suffix:semicolon
r_else
id|usc_TCmd
c_func
(paren
id|info
comma
id|TCmd_SendAbort
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_txabort() */
multiline_comment|/* mgsl_rxenable() &t;enable or disable the receiver&n; * &t;&n; * Arguments:&t; &t;info&t;&t;pointer to device instance data&n; * &t;&t;&t;enable&t;&t;1 = enable, 0 = disable&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|mgsl_rxenable
r_static
r_int
id|mgsl_rxenable
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
id|enable
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_rxenable(%s,%d)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|enable
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|enable
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;rx_enabled
)paren
id|usc_start_receiver
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|info-&gt;rx_enabled
)paren
id|usc_stop_receiver
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_rxenable() */
multiline_comment|/* mgsl_wait_event() &t;wait for specified event to occur&n; * &t;&n; * Arguments:&t; &t;info&t;pointer to device instance data&n; * &t;&t;&t;mask&t;pointer to bitmask of events to wait for&n; * Return Value:&t;0 &t;if successful and bit mask updated with&n; *&t;&t;&t;&t;of events triggerred,&n; * &t;&t;&t;otherwise error code&n; */
DECL|function|mgsl_wait_event
r_static
r_int
id|mgsl_wait_event
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
op_star
id|mask_ptr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|s
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|u16
id|regval
suffix:semicolon
r_struct
id|mgsl_icount
id|cprev
comma
id|cnow
suffix:semicolon
r_int
id|events
op_assign
l_int|0
suffix:semicolon
r_int
id|mask
suffix:semicolon
r_struct
id|_input_signal_events
id|signal_events_prev
comma
id|signal_events_now
suffix:semicolon
id|COPY_FROM_USER
c_func
(paren
id|rc
comma
op_amp
id|mask
comma
id|mask_ptr
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_wait_event(%s,%d)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|mask
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_get_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
id|s
op_assign
id|info-&gt;serial_signals
suffix:semicolon
multiline_comment|/* note the counters on entry */
id|cprev
op_assign
id|info-&gt;icount
suffix:semicolon
id|signal_events_prev
op_assign
id|info-&gt;input_signal_events
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|MgslEvent_ExitHuntMode
)paren
(brace
multiline_comment|/* enable exit hunt mode IRQ */
id|regval
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|RICR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|regval
op_amp
id|RXSTATUS_EXITED_HUNT
)paren
)paren
id|usc_OutReg
c_func
(paren
id|info
comma
id|RICR
comma
id|regval
op_or
id|RXSTATUS_EXITED_HUNT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mask
op_amp
id|MgslEvent_IdleReceived
)paren
(brace
multiline_comment|/* enable idle mode received IRQ */
id|regval
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|RICR
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|regval
op_amp
id|RXSTATUS_IDLE_RECEIVED
)paren
)paren
id|usc_OutReg
c_func
(paren
id|info
comma
id|RICR
comma
id|regval
op_or
id|RXSTATUS_IDLE_RECEIVED
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Determine if any user requested events for input signals is currently TRUE */
id|events
op_or_assign
(paren
id|mask
op_amp
(paren
(paren
id|s
op_amp
id|SerialSignal_DSR
)paren
ques
c_cond
id|MgslEvent_DsrActive
suffix:colon
id|MgslEvent_DsrInactive
)paren
)paren
suffix:semicolon
id|events
op_or_assign
(paren
id|mask
op_amp
(paren
(paren
id|s
op_amp
id|SerialSignal_DCD
)paren
ques
c_cond
id|MgslEvent_DcdActive
suffix:colon
id|MgslEvent_DcdInactive
)paren
)paren
suffix:semicolon
id|events
op_or_assign
(paren
id|mask
op_amp
(paren
(paren
id|s
op_amp
id|SerialSignal_CTS
)paren
ques
c_cond
id|MgslEvent_CtsActive
suffix:colon
id|MgslEvent_CtsInactive
)paren
)paren
suffix:semicolon
id|events
op_or_assign
(paren
id|mask
op_amp
(paren
(paren
id|s
op_amp
id|SerialSignal_RI
)paren
ques
c_cond
id|MgslEvent_RiActive
suffix:colon
id|MgslEvent_RiInactive
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|events
)paren
(brace
multiline_comment|/* sleep until event occurs */
id|interruptible_sleep_on
c_func
(paren
op_amp
id|info-&gt;event_wait_q
)paren
suffix:semicolon
multiline_comment|/* see if a signal woke us */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* get icount and serial signal states */
id|cnow
op_assign
id|info-&gt;icount
suffix:semicolon
id|signal_events_now
op_assign
id|info-&gt;input_signal_events
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_events_now.dsr_up
op_ne
id|signal_events_prev.dsr_up
op_logical_and
id|mask
op_amp
id|MgslEvent_DsrActive
)paren
id|events
op_or_assign
id|MgslEvent_DsrActive
suffix:semicolon
r_if
c_cond
(paren
id|signal_events_now.dsr_down
op_ne
id|signal_events_prev.dsr_down
op_logical_and
id|mask
op_amp
id|MgslEvent_DsrInactive
)paren
id|events
op_or_assign
id|MgslEvent_DsrInactive
suffix:semicolon
r_if
c_cond
(paren
id|signal_events_now.dcd_up
op_ne
id|signal_events_prev.dcd_up
op_logical_and
id|mask
op_amp
id|MgslEvent_DcdActive
)paren
id|events
op_or_assign
id|MgslEvent_DcdActive
suffix:semicolon
r_if
c_cond
(paren
id|signal_events_now.dcd_down
op_ne
id|signal_events_prev.dcd_down
op_logical_and
id|mask
op_amp
id|MgslEvent_DcdInactive
)paren
id|events
op_or_assign
id|MgslEvent_DcdInactive
suffix:semicolon
r_if
c_cond
(paren
id|signal_events_now.cts_up
op_ne
id|signal_events_prev.cts_up
op_logical_and
id|mask
op_amp
id|MgslEvent_CtsActive
)paren
id|events
op_or_assign
id|MgslEvent_CtsActive
suffix:semicolon
r_if
c_cond
(paren
id|signal_events_now.cts_down
op_ne
id|signal_events_prev.cts_down
op_logical_and
id|mask
op_amp
id|MgslEvent_CtsInactive
)paren
id|events
op_or_assign
id|MgslEvent_CtsInactive
suffix:semicolon
r_if
c_cond
(paren
id|signal_events_now.ri_up
op_ne
id|signal_events_prev.ri_up
op_logical_and
id|mask
op_amp
id|MgslEvent_RiActive
)paren
id|events
op_or_assign
id|MgslEvent_RiActive
suffix:semicolon
r_if
c_cond
(paren
id|signal_events_now.ri_down
op_ne
id|signal_events_prev.ri_down
op_logical_and
id|mask
op_amp
id|MgslEvent_RiInactive
)paren
id|events
op_or_assign
id|MgslEvent_RiInactive
suffix:semicolon
r_if
c_cond
(paren
id|cnow.exithunt
op_ne
id|cprev.exithunt
)paren
id|events
op_or_assign
(paren
id|mask
op_amp
id|MgslEvent_ExitHuntMode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnow.rxidle
op_ne
id|cprev.rxidle
)paren
id|events
op_or_assign
(paren
id|mask
op_amp
id|MgslEvent_IdleReceived
)paren
suffix:semicolon
id|cprev
op_assign
id|cnow
suffix:semicolon
id|signal_events_prev
op_assign
id|signal_events_now
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mask
op_amp
(paren
id|MgslEvent_ExitHuntMode
op_plus
id|MgslEvent_IdleReceived
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|waitqueue_active
c_func
(paren
op_amp
id|info-&gt;event_wait_q
)paren
)paren
(brace
multiline_comment|/* disable enable exit hunt mode/idle rcvd IRQs */
id|regval
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|RICR
)paren
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|RICR
comma
id|regval
op_amp
op_complement
(paren
id|RXSTATUS_EXITED_HUNT
op_plus
id|RXSTATUS_IDLE_RECEIVED
)paren
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
id|PUT_USER
c_func
(paren
id|rc
comma
id|events
comma
id|mask_ptr
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_wait_event() */
multiline_comment|/* get_modem_info()&n; * &n; * &t;Read the state of the serial control and&n; * &t;status signals and return to caller.&n; * &t;&n; * Arguments:&t; &t;info&t;pointer to device instance data&n; * &t;&t;&t;value&t;pointer to int to hold returned info&n; * &t;&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|get_modem_info
r_static
r_int
id|get_modem_info
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
r_int
id|result
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|err
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_get_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_RTS
)paren
id|result
op_or_assign
id|TIOCM_RTS
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_DTR
)paren
id|result
op_or_assign
id|TIOCM_DTR
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_DCD
)paren
id|result
op_or_assign
id|TIOCM_CAR
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_RI
)paren
id|result
op_or_assign
id|TIOCM_RNG
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_DSR
)paren
id|result
op_or_assign
id|TIOCM_DSR
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_CTS
)paren
id|result
op_or_assign
id|TIOCM_CTS
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_get_modem_info %s value=%08X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|result
)paren
suffix:semicolon
id|PUT_USER
c_func
(paren
id|err
comma
id|result
comma
id|value
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* end of get_modem_info() */
multiline_comment|/* set_modem_info()&n; * &n; * &t;Set the state of the modem control signals (DTR/RTS)&n; * &t;&n; * Arguments:&n; * &n; * &t;info&t;pointer to device instance data&n; * &t;cmd&t;signal command: TIOCMBIS = set bit TIOCMBIC = clear bit&n; *&t;&t;TIOCMSET = set/clear signal values&n; * &t;value&t;bit mask for command&n; * &t;&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|set_modem_info
r_static
r_int
id|set_modem_info
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
r_int
id|cmd
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
r_int
id|arg
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_set_modem_info %s&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|GET_USER
c_func
(paren
id|error
comma
id|arg
comma
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMBIS
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_RTS
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_DTR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMBIC
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
id|info-&gt;serial_signals
op_and_assign
op_complement
id|SerialSignal_RTS
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
id|info-&gt;serial_signals
op_and_assign
op_complement
id|SerialSignal_DTR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_RTS
suffix:semicolon
r_else
id|info-&gt;serial_signals
op_and_assign
op_complement
id|SerialSignal_RTS
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_DTR
suffix:semicolon
r_else
id|info-&gt;serial_signals
op_and_assign
op_complement
id|SerialSignal_DTR
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_set_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of set_modem_info() */
multiline_comment|/* mgsl_break()&t;&t;Set or clear transmit break condition&n; *&n; * Arguments:&t;&t;tty&t;&t;pointer to tty instance data&n; *&t;&t;&t;break_state&t;-1=set break condition, 0=clear&n; * Return Value:&t;None&n; */
DECL|function|mgsl_break
r_static
r_void
id|mgsl_break
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|break_state
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_break(%s,%d)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|break_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_break&quot;
)paren
)paren
r_return
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|break_state
op_eq
op_minus
l_int|1
)paren
id|usc_OutReg
c_func
(paren
id|info
comma
id|IOCR
comma
(paren
id|u16
)paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|IOCR
)paren
op_or
id|BIT7
)paren
)paren
suffix:semicolon
r_else
id|usc_OutReg
c_func
(paren
id|info
comma
id|IOCR
comma
(paren
id|u16
)paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|IOCR
)paren
op_amp
op_complement
id|BIT7
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_break() */
multiline_comment|/* mgsl_ioctl()&t;Service an IOCTL request&n; * &t;&n; * Arguments:&n; * &n; * &t;tty&t;pointer to tty instance data&n; * &t;file&t;pointer to associated file object for device&n; * &t;cmd&t;IOCTL command code&n; * &t;arg&t;command argument/context&n; * &t;&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|mgsl_ioctl
r_static
r_int
id|mgsl_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_ioctl %s cmd=%08X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_ioctl&quot;
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_ne
id|TIOCGSERIAL
)paren
op_logical_and
(paren
id|cmd
op_ne
id|TIOCSSERIAL
)paren
op_logical_and
(paren
id|cmd
op_ne
id|TIOCMIWAIT
)paren
op_logical_and
(paren
id|cmd
op_ne
id|TIOCGICOUNT
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
id|mgsl_ioctl_common
c_func
(paren
id|info
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|function|mgsl_ioctl_common
r_int
id|mgsl_ioctl_common
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|mgsl_icount
id|cprev
comma
id|cnow
suffix:semicolon
multiline_comment|/* kernel counter temps */
r_struct
id|serial_icounter_struct
op_star
id|p_cuser
suffix:semicolon
multiline_comment|/* user space */
r_int
r_int
id|flags
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMGET
suffix:colon
r_return
id|get_modem_info
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
r_case
id|TIOCMBIC
suffix:colon
r_case
id|TIOCMSET
suffix:colon
r_return
id|set_modem_info
c_func
(paren
id|info
comma
id|cmd
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|MGSL_IOCGPARAMS
suffix:colon
r_return
id|mgsl_get_params
c_func
(paren
id|info
comma
(paren
id|MGSL_PARAMS
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|MGSL_IOCSPARAMS
suffix:colon
r_return
id|mgsl_set_params
c_func
(paren
id|info
comma
(paren
id|MGSL_PARAMS
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|MGSL_IOCGTXIDLE
suffix:colon
r_return
id|mgsl_get_txidle
c_func
(paren
id|info
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|MGSL_IOCSTXIDLE
suffix:colon
r_return
id|mgsl_set_txidle
c_func
(paren
id|info
comma
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
r_case
id|MGSL_IOCTXENABLE
suffix:colon
r_return
id|mgsl_txenable
c_func
(paren
id|info
comma
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
r_case
id|MGSL_IOCRXENABLE
suffix:colon
r_return
id|mgsl_rxenable
c_func
(paren
id|info
comma
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
r_case
id|MGSL_IOCTXABORT
suffix:colon
r_return
id|mgsl_txabort
c_func
(paren
id|info
)paren
suffix:semicolon
r_case
id|MGSL_IOCGSTATS
suffix:colon
r_return
id|mgsl_get_stats
c_func
(paren
id|info
comma
(paren
r_struct
id|mgsl_icount
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|MGSL_IOCWAITEVENT
suffix:colon
r_return
id|mgsl_wait_event
c_func
(paren
id|info
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|MGSL_IOCLOOPTXDONE
suffix:colon
r_return
id|mgsl_loopmode_send_done
c_func
(paren
id|info
)paren
suffix:semicolon
r_case
id|MGSL_IOCCLRMODCOUNT
suffix:colon
r_while
c_loop
(paren
id|MOD_IN_USE
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change&n;&t;&t; * - mask passed in arg for lines of interest&n; &t;&t; *   (use |&squot;ed TIOCM_RNG/DSR/CD/CTS for masking)&n;&t;&t; * Caller should use TIOCGICOUNT to see which one it was&n;&t;&t; */
r_case
id|TIOCMIWAIT
suffix:colon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* note the counters on entry */
id|cprev
op_assign
id|info-&gt;icount
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|info-&gt;status_event_wait_q
)paren
suffix:semicolon
multiline_comment|/* see if a signal did it */
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|cnow
op_assign
id|info-&gt;icount
suffix:semicolon
multiline_comment|/* atomic copy */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnow.rng
op_eq
id|cprev.rng
op_logical_and
id|cnow.dsr
op_eq
id|cprev.dsr
op_logical_and
id|cnow.dcd
op_eq
id|cprev.dcd
op_logical_and
id|cnow.cts
op_eq
id|cprev.cts
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* no change =&gt; error */
r_if
c_cond
(paren
(paren
(paren
id|arg
op_amp
id|TIOCM_RNG
)paren
op_logical_and
(paren
id|cnow.rng
op_ne
id|cprev.rng
)paren
)paren
op_logical_or
(paren
(paren
id|arg
op_amp
id|TIOCM_DSR
)paren
op_logical_and
(paren
id|cnow.dsr
op_ne
id|cprev.dsr
)paren
)paren
op_logical_or
(paren
(paren
id|arg
op_amp
id|TIOCM_CD
)paren
op_logical_and
(paren
id|cnow.dcd
op_ne
id|cprev.dcd
)paren
)paren
op_logical_or
(paren
(paren
id|arg
op_amp
id|TIOCM_CTS
)paren
op_logical_and
(paren
id|cnow.cts
op_ne
id|cprev.cts
)paren
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|cprev
op_assign
id|cnow
suffix:semicolon
)brace
multiline_comment|/* NOTREACHED */
multiline_comment|/* &n;&t;&t; * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)&n;&t;&t; * Return: write counters to the user passed counter struct&n;&t;&t; * NB: both 1-&gt;0 and 0-&gt;1 transitions are counted except for&n;&t;&t; *     RI where only 0-&gt;1 is counted.&n;&t;&t; */
r_case
id|TIOCGICOUNT
suffix:colon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|cnow
op_assign
id|info-&gt;icount
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|p_cuser
op_assign
(paren
r_struct
id|serial_icounter_struct
op_star
)paren
id|arg
suffix:semicolon
id|PUT_USER
c_func
(paren
id|error
comma
id|cnow.cts
comma
op_amp
id|p_cuser-&gt;cts
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|PUT_USER
c_func
(paren
id|error
comma
id|cnow.dsr
comma
op_amp
id|p_cuser-&gt;dsr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|PUT_USER
c_func
(paren
id|error
comma
id|cnow.rng
comma
op_amp
id|p_cuser-&gt;rng
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|PUT_USER
c_func
(paren
id|error
comma
id|cnow.dcd
comma
op_amp
id|p_cuser-&gt;dcd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|PUT_USER
c_func
(paren
id|error
comma
id|cnow.rx
comma
op_amp
id|p_cuser-&gt;rx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|PUT_USER
c_func
(paren
id|error
comma
id|cnow.tx
comma
op_amp
id|p_cuser-&gt;tx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|PUT_USER
c_func
(paren
id|error
comma
id|cnow.frame
comma
op_amp
id|p_cuser-&gt;frame
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|PUT_USER
c_func
(paren
id|error
comma
id|cnow.overrun
comma
op_amp
id|p_cuser-&gt;overrun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|PUT_USER
c_func
(paren
id|error
comma
id|cnow.parity
comma
op_amp
id|p_cuser-&gt;parity
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|PUT_USER
c_func
(paren
id|error
comma
id|cnow.brk
comma
op_amp
id|p_cuser-&gt;brk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|PUT_USER
c_func
(paren
id|error
comma
id|cnow.buf_overrun
comma
op_amp
id|p_cuser-&gt;buf_overrun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* mgsl_set_termios()&n; * &n; * &t;Set new termios settings&n; * &t;&n; * Arguments:&n; * &n; * &t;tty&t;&t;pointer to tty structure&n; * &t;termios&t;&t;pointer to buffer to hold returned old termios&n; * &t;&n; * Return Value:&t;&t;None&n; */
DECL|function|mgsl_set_termios
r_static
r_void
id|mgsl_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_set_termios %s&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tty-&gt;driver.name
)paren
suffix:semicolon
multiline_comment|/* just return if nothing has changed */
r_if
c_cond
(paren
(paren
id|tty-&gt;termios-&gt;c_cflag
op_eq
id|old_termios-&gt;c_cflag
)paren
op_logical_and
(paren
id|RELEVANT_IFLAG
c_func
(paren
id|tty-&gt;termios-&gt;c_iflag
)paren
op_eq
id|RELEVANT_IFLAG
c_func
(paren
id|old_termios-&gt;c_iflag
)paren
)paren
)paren
r_return
suffix:semicolon
id|mgsl_change_params
c_func
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/* Handle transition to B0 status */
r_if
c_cond
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CBAUD
op_logical_and
op_logical_neg
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
)paren
(brace
id|info-&gt;serial_signals
op_and_assign
op_complement
(paren
id|SerialSignal_RTS
op_plus
id|SerialSignal_DTR
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_set_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle transition away from B0 status */
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
op_logical_and
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
(brace
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_DTR
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
op_logical_or
op_logical_neg
id|test_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
)paren
(brace
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_RTS
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_set_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle turning off CRTSCTS */
r_if
c_cond
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CRTSCTS
op_logical_and
op_logical_neg
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
)paren
(brace
id|tty-&gt;hw_stopped
op_assign
l_int|0
suffix:semicolon
id|mgsl_start
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end of mgsl_set_termios() */
multiline_comment|/* mgsl_close()&n; * &n; * &t;Called when port is closed. Wait for remaining data to be&n; * &t;sent. Disable port and free resources.&n; * &t;&n; * Arguments:&n; * &n; * &t;tty&t;pointer to open tty structure&n; * &t;filp&t;pointer to open file object&n; * &t;&n; * Return Value:&t;None&n; */
DECL|function|mgsl_close
r_static
r_void
id|mgsl_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
op_logical_or
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_close&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_close(%s) entry, count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|info-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;count
op_logical_or
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
r_goto
id|cleanup
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|info-&gt;count
op_ne
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * tty-&gt;count is 1 and the tty structure will be freed.&n;&t;&t; * info-&gt;count should be one in this case.&n;&t;&t; * if it&squot;s not, correct it so that the port is shutdown.&n;&t;&t; */
id|printk
c_func
(paren
l_string|&quot;mgsl_close: bad refcount; tty-&gt;count is 1, &quot;
l_string|&quot;info-&gt;count is %d&bslash;n&quot;
comma
id|info-&gt;count
)paren
suffix:semicolon
id|info-&gt;count
op_assign
l_int|1
suffix:semicolon
)brace
id|info-&gt;count
op_decrement
suffix:semicolon
multiline_comment|/* if at least one open remaining, leave hardware active */
r_if
c_cond
(paren
id|info-&gt;count
)paren
r_goto
id|cleanup
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|ASYNC_CLOSING
suffix:semicolon
multiline_comment|/* Save the termios structure, since this port may have&n;&t; * separate termios for callout and dialin.&n;&t; */
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
id|info-&gt;normal_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
id|info-&gt;callout_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
multiline_comment|/* set tty-&gt;closing to notify line discipline to &n;&t; * only process XON/XOFF characters. Only the N_TTY&n;&t; * discipline appears to use this (ppp does not).&n;&t; */
id|tty-&gt;closing
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* wait for transmit data to clear all layers */
r_if
c_cond
(paren
id|info-&gt;closing_wait
op_ne
id|ASYNC_CLOSING_WAIT_NONE
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_close(%s) calling tty_wait_until_sent&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
id|info-&gt;closing_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
id|mgsl_wait_until_sent
c_func
(paren
id|tty
comma
id|info-&gt;timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|shutdown
c_func
(paren
id|info
)paren
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tty
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;blocked_open
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;close_delay
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|info-&gt;close_delay
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
)brace
id|info-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
op_or
id|ASYNC_CLOSING
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
id|cleanup
suffix:colon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_close(%s) exit, count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tty-&gt;driver.name
comma
id|info-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MOD_IN_USE
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
)brace
multiline_comment|/* end of mgsl_close() */
multiline_comment|/* mgsl_wait_until_sent()&n; *&n; *&t;Wait until the transmitter is empty.&n; *&n; * Arguments:&n; *&n; *&t;tty&t;&t;pointer to tty info structure&n; *&t;timeout&t;&t;time to wait for send completion&n; *&n; * Return Value:&t;None&n; */
DECL|function|mgsl_wait_until_sent
r_static
r_void
id|mgsl_wait_until_sent
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|timeout
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|orig_jiffies
comma
id|char_time
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_wait_until_sent(%s) entry&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_wait_until_sent&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
r_goto
m_exit
suffix:semicolon
id|orig_jiffies
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Set check interval to 1/5 of estimated time to&n;&t; * send a character, and make it at least 1. The check&n;&t; * interval should also be less than the timeout.&n;&t; * Note: use tight timings here to satisfy the NIST-PCTS.&n;&t; */
r_if
c_cond
(paren
id|info-&gt;params.data_rate
)paren
(brace
id|char_time
op_assign
id|info-&gt;timeout
op_div
(paren
l_int|32
op_star
l_int|5
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|char_time
)paren
id|char_time
op_increment
suffix:semicolon
)brace
r_else
id|char_time
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|timeout
)paren
id|char_time
op_assign
id|MIN
c_func
(paren
id|char_time
comma
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.mode
op_eq
id|MGSL_MODE_HDLC
)paren
(brace
r_while
c_loop
(paren
id|info-&gt;tx_active
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|char_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_logical_and
(paren
(paren
id|orig_jiffies
op_plus
id|timeout
)paren
OL
id|jiffies
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|TCSR
)paren
op_amp
id|TXSTATUS_ALL_SENT
)paren
op_logical_and
id|info-&gt;tx_enabled
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|char_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|timeout
op_logical_and
(paren
(paren
id|orig_jiffies
op_plus
id|timeout
)paren
OL
id|jiffies
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
m_exit
suffix:colon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_wait_until_sent(%s) exit&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_wait_until_sent() */
multiline_comment|/* mgsl_hangup()&n; *&n; *&t;Called by tty_hangup() when a hangup is signaled.&n; *&t;This is the same as to closing all open files for the port.&n; *&n; * Arguments:&t;&t;tty&t;pointer to associated tty object&n; * Return Value:&t;None&n; */
DECL|function|mgsl_hangup
r_static
r_void
id|mgsl_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_hangup(%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_hangup&quot;
)paren
)paren
r_return
suffix:semicolon
id|mgsl_flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|shutdown
c_func
(paren
id|info
)paren
suffix:semicolon
id|info-&gt;count
op_assign
l_int|0
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
)paren
suffix:semicolon
id|info-&gt;tty
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_hangup() */
multiline_comment|/* block_til_ready()&n; * &n; * &t;Block the current process until the specified port&n; * &t;is ready to be opened.&n; * &t;&n; * Arguments:&n; * &n; * &t;tty&t;&t;pointer to tty info structure&n; * &t;filp&t;&t;pointer to open file object&n; * &t;info&t;&t;pointer to device instance data&n; * &t;&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|block_til_ready
r_static
r_int
id|block_til_ready
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|do_clocal
op_assign
l_int|0
comma
id|extra_count
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):block_til_ready on %s&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tty-&gt;driver.name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_CALLOUT
)paren
(brace
multiline_comment|/* this is a callout device */
multiline_comment|/* just verify that normal device is not in use */
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SESSION_LOCKOUT
)paren
op_logical_and
(paren
id|info-&gt;session
op_ne
id|current-&gt;session
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_PGRP_LOCKOUT
)paren
op_logical_and
(paren
id|info-&gt;pgrp
op_ne
id|current-&gt;pgrp
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|ASYNC_CALLOUT_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
op_logical_or
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
(brace
multiline_comment|/* nonblock mode is set or port is not enabled */
multiline_comment|/* just verify that callout device is not active */
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;normal_termios.c_cflag
op_amp
id|CLOCAL
)paren
id|do_clocal
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
id|do_clocal
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Wait for carrier detect and the line to become&n;&t; * free (i.e., not in use by the callout).  While we are in&n;&t; * this loop, info-&gt;count is dropped by one, so that&n;&t; * mgsl_close() knows when to free things.  We restore it upon&n;&t; * exit, either normal or abnormal.&n;&t; */
id|retval
op_assign
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|info-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):block_til_ready before block on %s count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tty-&gt;driver.name
comma
id|info-&gt;count
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|extra_count
op_assign
l_int|1
suffix:semicolon
id|info-&gt;count
op_decrement
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|info-&gt;blocked_open
op_increment
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_RTS
op_plus
id|SerialSignal_DTR
suffix:semicolon
id|usc_set_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
(brace
id|retval
op_assign
(paren
id|info-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
ques
c_cond
op_minus
id|EAGAIN
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_get_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
op_logical_and
(paren
id|do_clocal
op_logical_or
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_DCD
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):block_til_ready blocking on %s count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tty-&gt;driver.name
comma
id|info-&gt;count
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|info-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|extra_count
)paren
id|info-&gt;count
op_increment
suffix:semicolon
id|info-&gt;blocked_open
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):block_til_ready after blocking on %s count=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tty-&gt;driver.name
comma
id|info-&gt;count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|info-&gt;flags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* end of block_til_ready() */
multiline_comment|/* mgsl_open()&n; *&n; *&t;Called when a port is opened.  Init and enable port.&n; *&t;Perform serial-specific initialization for the tty structure.&n; *&n; * Arguments:&t;&t;tty&t;pointer to tty info structure&n; *&t;&t;&t;filp&t;associated file pointer&n; *&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|mgsl_open
r_static
r_int
id|mgsl_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
suffix:semicolon
r_int
id|retval
comma
id|line
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* verify range of specified line number */
id|line
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
suffix:semicolon
r_if
c_cond
(paren
(paren
id|line
OL
l_int|0
)paren
op_logical_or
(paren
id|line
op_ge
id|mgsl_device_count
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_open with illegal line #%d.&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* find the info structure for the specified line */
id|info
op_assign
id|mgsl_device_list
suffix:semicolon
r_while
c_loop
(paren
id|info
op_logical_and
id|info-&gt;line
op_ne
id|line
)paren
(brace
id|info
op_assign
id|info-&gt;next_device
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):Can&squot;t find specified device on open (line=%d)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|tty-&gt;driver_data
op_assign
id|info
suffix:semicolon
id|info-&gt;tty
op_assign
id|tty
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;mgsl_open&quot;
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_open(%s), old ref count = %d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|tty-&gt;driver.name
comma
id|info-&gt;count
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* If port is closing, signal caller to try again */
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
id|info-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
id|retval
op_assign
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
ques
c_cond
op_minus
id|EAGAIN
suffix:colon
op_minus
id|ERESTARTSYS
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp_buf
)paren
(brace
id|page
op_assign
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|page
)paren
(brace
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp_buf
)paren
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_else
id|tmp_buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|page
suffix:semicolon
)brace
id|info-&gt;tty-&gt;low_latency
op_assign
(paren
id|info-&gt;flags
op_amp
id|ASYNC_LOW_LATENCY
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;netlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;netcount
)paren
(brace
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;netlock
comma
id|flags
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
id|info-&gt;count
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;netlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;count
op_eq
l_int|1
)paren
(brace
multiline_comment|/* 1st open on this device, init hardware */
id|retval
op_assign
id|startup
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_goto
id|cleanup
suffix:semicolon
)brace
id|retval
op_assign
id|block_til_ready
c_func
(paren
id|tty
comma
id|filp
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):block_til_ready(%s) returned %d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|retval
)paren
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|info-&gt;count
op_eq
l_int|1
)paren
op_logical_and
id|info-&gt;flags
op_amp
id|ASYNC_SPLIT_TERMIOS
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_NORMAL
)paren
op_star
id|tty-&gt;termios
op_assign
id|info-&gt;normal_termios
suffix:semicolon
r_else
op_star
id|tty-&gt;termios
op_assign
id|info-&gt;callout_termios
suffix:semicolon
id|mgsl_change_params
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
id|info-&gt;session
op_assign
id|current-&gt;session
suffix:semicolon
id|info-&gt;pgrp
op_assign
id|current-&gt;pgrp
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_open(%s) success&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|cleanup
suffix:colon
r_if
c_cond
(paren
id|retval
)paren
(brace
r_if
c_cond
(paren
id|MOD_IN_USE
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;count
)paren
(brace
id|info-&gt;count
op_decrement
suffix:semicolon
)brace
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_open() */
multiline_comment|/*&n; * /proc fs routines....&n; */
DECL|function|line_info
r_static
r_inline
r_int
id|line_info
c_func
(paren
r_char
op_star
id|buf
comma
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_char
id|stat_buf
(braket
l_int|30
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
(brace
id|ret
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s:PCI io:%04X irq:%d mem:%08X lcr:%08X&quot;
comma
id|info-&gt;device_name
comma
id|info-&gt;io_base
comma
id|info-&gt;irq_level
comma
id|info-&gt;phys_memory_base
comma
id|info-&gt;phys_lcr_base
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_assign
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s:(E)ISA io:%04X irq:%d dma:%d&quot;
comma
id|info-&gt;device_name
comma
id|info-&gt;io_base
comma
id|info-&gt;irq_level
comma
id|info-&gt;dma_level
)paren
suffix:semicolon
)brace
multiline_comment|/* output current serial signal states */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_get_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|stat_buf
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|stat_buf
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_RTS
)paren
id|strcat
c_func
(paren
id|stat_buf
comma
l_string|&quot;|RTS&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_CTS
)paren
id|strcat
c_func
(paren
id|stat_buf
comma
l_string|&quot;|CTS&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_DTR
)paren
id|strcat
c_func
(paren
id|stat_buf
comma
l_string|&quot;|DTR&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_DSR
)paren
id|strcat
c_func
(paren
id|stat_buf
comma
l_string|&quot;|DSR&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_DCD
)paren
id|strcat
c_func
(paren
id|stat_buf
comma
l_string|&quot;|CD&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_RI
)paren
id|strcat
c_func
(paren
id|stat_buf
comma
l_string|&quot;|RI&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.mode
op_eq
id|MGSL_MODE_HDLC
)paren
(brace
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; HDLC txok:%d rxok:%d&quot;
comma
id|info-&gt;icount.txok
comma
id|info-&gt;icount.rxok
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;icount.txunder
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; txunder:%d&quot;
comma
id|info-&gt;icount.txunder
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;icount.txabort
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; txabort:%d&quot;
comma
id|info-&gt;icount.txabort
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;icount.rxshort
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; rxshort:%d&quot;
comma
id|info-&gt;icount.rxshort
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;icount.rxlong
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; rxlong:%d&quot;
comma
id|info-&gt;icount.rxlong
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;icount.rxover
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; rxover:%d&quot;
comma
id|info-&gt;icount.rxover
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;icount.rxcrc
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; rxlong:%d&quot;
comma
id|info-&gt;icount.rxcrc
)paren
suffix:semicolon
)brace
r_else
(brace
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; ASYNC tx:%d rx:%d&quot;
comma
id|info-&gt;icount.tx
comma
id|info-&gt;icount.rx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;icount.frame
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; fe:%d&quot;
comma
id|info-&gt;icount.frame
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;icount.parity
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; pe:%d&quot;
comma
id|info-&gt;icount.parity
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;icount.brk
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; brk:%d&quot;
comma
id|info-&gt;icount.brk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;icount.overrun
)paren
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; oe:%d&quot;
comma
id|info-&gt;icount.overrun
)paren
suffix:semicolon
)brace
multiline_comment|/* Append serial signal status to end */
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot; %s&bslash;n&quot;
comma
id|stat_buf
op_plus
l_int|1
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;txactive=%d bh_req=%d bh_run=%d pending_bh=%x&bslash;n&quot;
comma
id|info-&gt;tx_active
comma
id|info-&gt;bh_requested
comma
id|info-&gt;bh_running
comma
id|info-&gt;pending_bh
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
(brace
id|u16
id|Tcsr
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|TCSR
)paren
suffix:semicolon
id|u16
id|Tdmr
op_assign
id|usc_InDmaReg
c_func
(paren
id|info
comma
id|TDMR
)paren
suffix:semicolon
id|u16
id|Ticr
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|TICR
)paren
suffix:semicolon
id|u16
id|Rscr
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|RCSR
)paren
suffix:semicolon
id|u16
id|Rdmr
op_assign
id|usc_InDmaReg
c_func
(paren
id|info
comma
id|RDMR
)paren
suffix:semicolon
id|u16
id|Ricr
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|RICR
)paren
suffix:semicolon
id|u16
id|Icr
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|ICR
)paren
suffix:semicolon
id|u16
id|Dccr
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|DCCR
)paren
suffix:semicolon
id|u16
id|Tmr
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|TMR
)paren
suffix:semicolon
id|u16
id|Tccr
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|TCCR
)paren
suffix:semicolon
id|u16
id|Ccar
op_assign
id|inw
c_func
(paren
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
id|ret
op_add_assign
id|sprintf
c_func
(paren
id|buf
op_plus
id|ret
comma
l_string|&quot;tcsr=%04X tdmr=%04X ticr=%04X rcsr=%04X rdmr=%04X&bslash;n&quot;
l_string|&quot;ricr=%04X icr =%04X dccr=%04X tmr=%04X tccr=%04X ccar=%04X&bslash;n&quot;
comma
id|Tcsr
comma
id|Tdmr
comma
id|Ticr
comma
id|Rscr
comma
id|Rdmr
comma
id|Ricr
comma
id|Icr
comma
id|Dccr
comma
id|Tmr
comma
id|Tccr
comma
id|Ccar
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* end of line_info() */
multiline_comment|/* mgsl_read_proc()&n; * &n; * Called to print information about devices&n; * &n; * Arguments:&n; * &t;page&t;page of memory to hold returned info&n; * &t;start&t;&n; * &t;off&n; * &t;count&n; * &t;eof&n; * &t;data&n; * &t;&n; * Return Value:&n; */
DECL|function|mgsl_read_proc
r_int
id|mgsl_read_proc
c_func
(paren
r_char
op_star
id|page
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|off
comma
r_int
id|count
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_int
id|len
op_assign
l_int|0
comma
id|l
suffix:semicolon
id|off_t
id|begin
op_assign
l_int|0
suffix:semicolon
r_struct
id|mgsl_struct
op_star
id|info
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|page
comma
l_string|&quot;synclink driver:%s&bslash;n&quot;
comma
id|driver_version
)paren
suffix:semicolon
id|info
op_assign
id|mgsl_device_list
suffix:semicolon
r_while
c_loop
(paren
id|info
)paren
(brace
id|l
op_assign
id|line_info
c_func
(paren
id|page
op_plus
id|len
comma
id|info
)paren
suffix:semicolon
id|len
op_add_assign
id|l
suffix:semicolon
r_if
c_cond
(paren
id|len
op_plus
id|begin
OG
id|off
op_plus
id|count
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|len
op_plus
id|begin
OL
id|off
)paren
(brace
id|begin
op_add_assign
id|len
suffix:semicolon
id|len
op_assign
l_int|0
suffix:semicolon
)brace
id|info
op_assign
id|info-&gt;next_device
suffix:semicolon
)brace
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|off
op_ge
id|len
op_plus
id|begin
)paren
r_return
l_int|0
suffix:semicolon
op_star
id|start
op_assign
id|page
op_plus
(paren
id|off
op_minus
id|begin
)paren
suffix:semicolon
r_return
(paren
(paren
id|count
OL
id|begin
op_plus
id|len
op_minus
id|off
)paren
ques
c_cond
id|count
suffix:colon
id|begin
op_plus
id|len
op_minus
id|off
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_read_proc() */
multiline_comment|/* mgsl_allocate_dma_buffers()&n; * &n; * &t;Allocate and format DMA buffers (ISA adapter)&n; * &t;or format shared memory buffers (PCI adapter).&n; * &n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;0 if success, otherwise error&n; */
DECL|function|mgsl_allocate_dma_buffers
r_int
id|mgsl_allocate_dma_buffers
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
r_int
id|BuffersPerFrame
suffix:semicolon
id|info-&gt;last_mem_alloc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Calculate the number of DMA buffers necessary to hold the */
multiline_comment|/* largest allowable frame size. Note: If the max frame size is */
multiline_comment|/* not an even multiple of the DMA buffer size then we need to */
multiline_comment|/* round the buffer count per frame up one. */
id|BuffersPerFrame
op_assign
(paren
r_int
r_int
)paren
(paren
id|info-&gt;max_frame_size
op_div
id|DMABUFFERSIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;max_frame_size
op_mod
id|DMABUFFERSIZE
)paren
id|BuffersPerFrame
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
(brace
multiline_comment|/*&n;&t;&t; * The PCI adapter has 256KBytes of shared memory to use.&n;&t;&t; * This is 64 PAGE_SIZE buffers.&n;&t;&t; *&n;&t;&t; * The first page is used for padding at this time so the&n;&t;&t; * buffer list does not begin at offset 0 of the PCI&n;&t;&t; * adapter&squot;s shared memory.&n;&t;&t; *&n;&t;&t; * The 2nd page is used for the buffer list. A 4K buffer&n;&t;&t; * list can hold 128 DMA_BUFFER structures at 32 bytes&n;&t;&t; * each.&n;&t;&t; *&n;&t;&t; * This leaves 62 4K pages.&n;&t;&t; *&n;&t;&t; * The next N pages are used for a transmit frame. We&n;&t;&t; * reserve enough 4K page blocks to hold the configured&n;&t;&t; * MaxFrameSize&n;&t;&t; *&n;&t;&t; * Of the remaining pages (62-N), determine how many can&n;&t;&t; * be used to receive full MaxFrameSize inbound frames&n;&t;&t; */
id|info-&gt;tx_buffer_count
op_assign
id|BuffersPerFrame
suffix:semicolon
id|info-&gt;rx_buffer_count
op_assign
l_int|62
op_minus
id|info-&gt;tx_buffer_count
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Calculate the number of PAGE_SIZE buffers needed for */
multiline_comment|/* receive and transmit DMA buffers. */
multiline_comment|/* Calculate the number of DMA buffers necessary to */
multiline_comment|/* hold 7 max size receive frames and one max size transmit frame. */
multiline_comment|/* The receive buffer count is bumped by one so we avoid an */
multiline_comment|/* End of List condition if all receive buffers are used when */
multiline_comment|/* using linked list DMA buffers. */
id|info-&gt;tx_buffer_count
op_assign
id|BuffersPerFrame
suffix:semicolon
id|info-&gt;rx_buffer_count
op_assign
(paren
id|BuffersPerFrame
op_star
id|MAXRXFRAMES
)paren
op_plus
l_int|6
suffix:semicolon
multiline_comment|/* &n;&t;&t; * limit total TxBuffers &amp; RxBuffers to 62 4K total &n;&t;&t; * (ala PCI Allocation) &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|info-&gt;tx_buffer_count
op_plus
id|info-&gt;rx_buffer_count
)paren
OG
l_int|62
)paren
id|info-&gt;rx_buffer_count
op_assign
l_int|62
op_minus
id|info-&gt;tx_buffer_count
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):Allocating %d TX and %d RX DMA buffers.&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;tx_buffer_count
comma
id|info-&gt;rx_buffer_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mgsl_alloc_buffer_list_memory
c_func
(paren
id|info
)paren
OL
l_int|0
op_logical_or
id|mgsl_alloc_frame_memory
c_func
(paren
id|info
comma
id|info-&gt;rx_buffer_list
comma
id|info-&gt;rx_buffer_count
)paren
OL
l_int|0
op_logical_or
id|mgsl_alloc_frame_memory
c_func
(paren
id|info
comma
id|info-&gt;tx_buffer_list
comma
id|info-&gt;tx_buffer_count
)paren
OL
l_int|0
op_logical_or
id|mgsl_alloc_intermediate_rxbuffer_memory
c_func
(paren
id|info
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):Can&squot;t allocate DMA buffer memory&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|mgsl_reset_rx_dma_buffers
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_allocate_dma_buffers() */
multiline_comment|/*&n; * mgsl_alloc_buffer_list_memory()&n; * &n; * Allocate a common DMA buffer for use as the&n; * receive and transmit buffer lists.&n; * &n; * A buffer list is a set of buffer entries where each entry contains&n; * a pointer to an actual buffer and a pointer to the next buffer entry&n; * (plus some other info about the buffer).&n; * &n; * The buffer entries for a list are built to form a circular list so&n; * that when the entire list has been traversed you start back at the&n; * beginning.&n; * &n; * This function allocates memory for just the buffer entries.&n; * The links (pointer to next entry) are filled in with the physical&n; * address of the next entry so the adapter can navigate the list&n; * using bus master DMA. The pointers to the actual buffers are filled&n; * out later when the actual buffers are allocated.&n; * &n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;0 if success, otherwise error&n; */
DECL|function|mgsl_alloc_buffer_list_memory
r_int
id|mgsl_alloc_buffer_list_memory
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
(brace
multiline_comment|/* PCI adapter uses shared memory. */
id|info-&gt;buffer_list
op_assign
id|info-&gt;memory_base
op_plus
id|info-&gt;last_mem_alloc
suffix:semicolon
id|info-&gt;buffer_list_phys
op_assign
id|info-&gt;last_mem_alloc
suffix:semicolon
id|info-&gt;last_mem_alloc
op_add_assign
id|BUFFERLISTSIZE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ISA adapter uses system memory. */
multiline_comment|/* The buffer lists are allocated as a common buffer that both */
multiline_comment|/* the processor and adapter can access. This allows the driver to */
multiline_comment|/* inspect portions of the buffer while other portions are being */
multiline_comment|/* updated by the adapter using Bus Master DMA. */
id|info-&gt;buffer_list
op_assign
id|kmalloc
c_func
(paren
id|BUFFERLISTSIZE
comma
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;buffer_list
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|info-&gt;buffer_list_phys
op_assign
id|virt_to_bus
c_func
(paren
id|info-&gt;buffer_list
)paren
suffix:semicolon
)brace
multiline_comment|/* We got the memory for the buffer entry lists. */
multiline_comment|/* Initialize the memory block to all zeros. */
id|memset
c_func
(paren
id|info-&gt;buffer_list
comma
l_int|0
comma
id|BUFFERLISTSIZE
)paren
suffix:semicolon
multiline_comment|/* Save virtual address pointers to the receive and */
multiline_comment|/* transmit buffer lists. (Receive 1st). These pointers will */
multiline_comment|/* be used by the processor to access the lists. */
id|info-&gt;rx_buffer_list
op_assign
(paren
id|DMABUFFERENTRY
op_star
)paren
id|info-&gt;buffer_list
suffix:semicolon
id|info-&gt;tx_buffer_list
op_assign
(paren
id|DMABUFFERENTRY
op_star
)paren
id|info-&gt;buffer_list
suffix:semicolon
id|info-&gt;tx_buffer_list
op_add_assign
id|info-&gt;rx_buffer_count
suffix:semicolon
multiline_comment|/*&n;&t; * Build the links for the buffer entry lists such that&n;&t; * two circular lists are built. (Transmit and Receive).&n;&t; *&n;&t; * Note: the links are physical addresses&n;&t; * which are read by the adapter to determine the next&n;&t; * buffer entry to use.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;rx_buffer_count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* calculate and store physical address of this buffer entry */
id|info-&gt;rx_buffer_list
(braket
id|i
)braket
dot
id|phys_entry
op_assign
id|info-&gt;buffer_list_phys
op_plus
(paren
id|i
op_star
r_sizeof
(paren
id|DMABUFFERENTRY
)paren
)paren
suffix:semicolon
multiline_comment|/* calculate and store physical address of */
multiline_comment|/* next entry in cirular list of entries */
id|info-&gt;rx_buffer_list
(braket
id|i
)braket
dot
id|link
op_assign
id|info-&gt;buffer_list_phys
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|info-&gt;rx_buffer_count
op_minus
l_int|1
)paren
id|info-&gt;rx_buffer_list
(braket
id|i
)braket
dot
id|link
op_add_assign
(paren
id|i
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|DMABUFFERENTRY
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;tx_buffer_count
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* calculate and store physical address of this buffer entry */
id|info-&gt;tx_buffer_list
(braket
id|i
)braket
dot
id|phys_entry
op_assign
id|info-&gt;buffer_list_phys
op_plus
(paren
(paren
id|info-&gt;rx_buffer_count
op_plus
id|i
)paren
op_star
r_sizeof
(paren
id|DMABUFFERENTRY
)paren
)paren
suffix:semicolon
multiline_comment|/* calculate and store physical address of */
multiline_comment|/* next entry in cirular list of entries */
id|info-&gt;tx_buffer_list
(braket
id|i
)braket
dot
id|link
op_assign
id|info-&gt;buffer_list_phys
op_plus
id|info-&gt;rx_buffer_count
op_star
r_sizeof
(paren
id|DMABUFFERENTRY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|info-&gt;tx_buffer_count
op_minus
l_int|1
)paren
id|info-&gt;tx_buffer_list
(braket
id|i
)braket
dot
id|link
op_add_assign
(paren
id|i
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|DMABUFFERENTRY
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_alloc_buffer_list_memory() */
multiline_comment|/* Free DMA buffers allocated for use as the&n; * receive and transmit buffer lists.&n; * Warning:&n; * &n; * &t;The data transfer buffers associated with the buffer list&n; * &t;MUST be freed before freeing the buffer list itself because&n; * &t;the buffer list contains the information necessary to free&n; * &t;the individual buffers!&n; */
DECL|function|mgsl_free_buffer_list_memory
r_void
id|mgsl_free_buffer_list_memory
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;buffer_list
op_logical_and
id|info-&gt;bus_type
op_ne
id|MGSL_BUS_TYPE_PCI
)paren
id|kfree
c_func
(paren
id|info-&gt;buffer_list
)paren
suffix:semicolon
id|info-&gt;buffer_list
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;rx_buffer_list
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;tx_buffer_list
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_free_buffer_list_memory() */
multiline_comment|/*&n; * mgsl_alloc_frame_memory()&n; * &n; * &t;Allocate the frame DMA buffers used by the specified buffer list.&n; * &t;Each DMA buffer will be one memory page in size. This is necessary&n; * &t;because memory can fragment enough that it may be impossible&n; * &t;contiguous pages.&n; * &n; * Arguments:&n; * &n; *&t;info&t;&t;pointer to device instance data&n; * &t;BufferList&t;pointer to list of buffer entries&n; * &t;Buffercount&t;count of buffer entries in buffer list&n; * &n; * Return Value:&t;0 if success, otherwise -ENOMEM&n; */
DECL|function|mgsl_alloc_frame_memory
r_int
id|mgsl_alloc_frame_memory
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|DMABUFFERENTRY
op_star
id|BufferList
comma
r_int
id|Buffercount
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|phys_addr
suffix:semicolon
multiline_comment|/* Allocate page sized buffers for the receive buffer list */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|Buffercount
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
(brace
multiline_comment|/* PCI adapter uses shared memory buffers. */
id|BufferList
(braket
id|i
)braket
dot
id|virt_addr
op_assign
id|info-&gt;memory_base
op_plus
id|info-&gt;last_mem_alloc
suffix:semicolon
id|phys_addr
op_assign
id|info-&gt;last_mem_alloc
suffix:semicolon
id|info-&gt;last_mem_alloc
op_add_assign
id|DMABUFFERSIZE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ISA adapter uses system memory. */
id|BufferList
(braket
id|i
)braket
dot
id|virt_addr
op_assign
id|kmalloc
c_func
(paren
id|DMABUFFERSIZE
comma
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|BufferList
(braket
id|i
)braket
dot
id|virt_addr
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|phys_addr
op_assign
id|virt_to_bus
c_func
(paren
id|BufferList
(braket
id|i
)braket
dot
id|virt_addr
)paren
suffix:semicolon
)brace
id|BufferList
(braket
id|i
)braket
dot
id|phys_addr
op_assign
id|phys_addr
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_alloc_frame_memory() */
multiline_comment|/*&n; * mgsl_free_frame_memory()&n; * &n; * &t;Free the buffers associated with&n; * &t;each buffer entry of a buffer list.&n; * &n; * Arguments:&n; * &n; *&t;info&t;&t;pointer to device instance data&n; * &t;BufferList&t;pointer to list of buffer entries&n; * &t;Buffercount&t;count of buffer entries in buffer list&n; * &n; * Return Value:&t;None&n; */
DECL|function|mgsl_free_frame_memory
r_void
id|mgsl_free_frame_memory
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|DMABUFFERENTRY
op_star
id|BufferList
comma
r_int
id|Buffercount
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|BufferList
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|Buffercount
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|BufferList
(braket
id|i
)braket
dot
id|virt_addr
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;bus_type
op_ne
id|MGSL_BUS_TYPE_PCI
)paren
id|kfree
c_func
(paren
id|BufferList
(braket
id|i
)braket
dot
id|virt_addr
)paren
suffix:semicolon
id|BufferList
(braket
id|i
)braket
dot
id|virt_addr
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/* end of mgsl_free_frame_memory() */
multiline_comment|/* mgsl_free_dma_buffers()&n; * &n; * &t;Free DMA buffers&n; * &t;&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|mgsl_free_dma_buffers
r_void
id|mgsl_free_dma_buffers
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|mgsl_free_frame_memory
c_func
(paren
id|info
comma
id|info-&gt;rx_buffer_list
comma
id|info-&gt;rx_buffer_count
)paren
suffix:semicolon
id|mgsl_free_frame_memory
c_func
(paren
id|info
comma
id|info-&gt;tx_buffer_list
comma
id|info-&gt;tx_buffer_count
)paren
suffix:semicolon
id|mgsl_free_buffer_list_memory
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_free_dma_buffers() */
multiline_comment|/*&n; * mgsl_alloc_intermediate_rxbuffer_memory()&n; * &n; * &t;Allocate a buffer large enough to hold max_frame_size. This buffer&n; *&t;is used to pass an assembled frame to the line discipline.&n; * &n; * Arguments:&n; * &n; *&t;info&t;&t;pointer to device instance data&n; * &n; * Return Value:&t;0 if success, otherwise -ENOMEM&n; */
DECL|function|mgsl_alloc_intermediate_rxbuffer_memory
r_int
id|mgsl_alloc_intermediate_rxbuffer_memory
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|info-&gt;intermediate_rxbuffer
op_assign
id|kmalloc
c_func
(paren
id|info-&gt;max_frame_size
comma
id|GFP_KERNEL
op_or
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;intermediate_rxbuffer
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_alloc_intermediate_rxbuffer_memory() */
multiline_comment|/*&n; * mgsl_free_intermediate_rxbuffer_memory()&n; * &n; * &n; * Arguments:&n; * &n; *&t;info&t;&t;pointer to device instance data&n; * &n; * Return Value:&t;None&n; */
DECL|function|mgsl_free_intermediate_rxbuffer_memory
r_void
id|mgsl_free_intermediate_rxbuffer_memory
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;intermediate_rxbuffer
)paren
id|kfree
c_func
(paren
id|info-&gt;intermediate_rxbuffer
)paren
suffix:semicolon
id|info-&gt;intermediate_rxbuffer
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_free_intermediate_rxbuffer_memory() */
DECL|function|mgsl_claim_resources
r_int
id|mgsl_claim_resources
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|request_region
c_func
(paren
id|info-&gt;io_base
comma
id|info-&gt;io_addr_size
comma
l_string|&quot;synclink&quot;
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):I/O address conflict on device %s Addr=%08X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|info-&gt;io_base
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|info-&gt;io_addr_requested
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|info-&gt;irq_level
comma
id|mgsl_interrupt
comma
id|info-&gt;irq_flags
comma
id|info-&gt;device_name
comma
id|info
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):Cant request interrupt on device %s IRQ=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|info-&gt;irq_level
)paren
suffix:semicolon
r_goto
id|errout
suffix:semicolon
)brace
id|info-&gt;irq_requested
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
(brace
r_if
c_cond
(paren
id|request_mem_region
c_func
(paren
id|info-&gt;phys_memory_base
comma
l_int|0x40000
comma
l_string|&quot;synclink&quot;
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):mem addr conflict device %s Addr=%08X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|info-&gt;phys_memory_base
)paren
suffix:semicolon
r_goto
id|errout
suffix:semicolon
)brace
id|info-&gt;shared_mem_requested
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|request_mem_region
c_func
(paren
id|info-&gt;phys_lcr_base
comma
l_int|128
comma
l_string|&quot;synclink&quot;
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):lcr mem addr conflict device %s Addr=%08X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|info-&gt;phys_lcr_base
)paren
suffix:semicolon
r_goto
id|errout
suffix:semicolon
)brace
id|info-&gt;lcr_mem_requested
op_assign
l_int|1
suffix:semicolon
id|info-&gt;memory_base
op_assign
id|ioremap
c_func
(paren
id|info-&gt;phys_memory_base
comma
l_int|0x40000
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;memory_base
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):Cant map shared memory on device %s MemAddr=%08X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|info-&gt;phys_memory_base
)paren
suffix:semicolon
r_goto
id|errout
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mgsl_memory_test
c_func
(paren
id|info
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):Failed shared memory test %s MemAddr=%08X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|info-&gt;phys_memory_base
)paren
suffix:semicolon
r_goto
id|errout
suffix:semicolon
)brace
id|info-&gt;lcr_base
op_assign
id|ioremap
c_func
(paren
id|info-&gt;phys_lcr_base
comma
id|PAGE_SIZE
)paren
op_plus
id|info-&gt;lcr_offset
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;lcr_base
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):Cant map LCR memory on device %s MemAddr=%08X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|info-&gt;phys_lcr_base
)paren
suffix:semicolon
r_goto
id|errout
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* claim DMA channel */
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|info-&gt;dma_level
comma
id|info-&gt;device_name
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):Cant request DMA channel on device %s DMA=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|info-&gt;dma_level
)paren
suffix:semicolon
id|mgsl_release_resources
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|info-&gt;dma_requested
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* ISA adapter uses bus master DMA */
id|set_dma_mode
c_func
(paren
id|info-&gt;dma_level
comma
id|DMA_MODE_CASCADE
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|info-&gt;dma_level
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mgsl_allocate_dma_buffers
c_func
(paren
id|info
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):Cant allocate DMA buffers on device %s DMA=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|info-&gt;dma_level
)paren
suffix:semicolon
r_goto
id|errout
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|errout
suffix:colon
id|mgsl_release_resources
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_claim_resources() */
DECL|function|mgsl_release_resources
r_void
id|mgsl_release_resources
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_release_resources(%s) entry&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;irq_requested
)paren
(brace
id|free_irq
c_func
(paren
id|info-&gt;irq_level
comma
id|info
)paren
suffix:semicolon
id|info-&gt;irq_requested
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;dma_requested
)paren
(brace
id|disable_dma
c_func
(paren
id|info-&gt;dma_level
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|info-&gt;dma_level
)paren
suffix:semicolon
id|info-&gt;dma_requested
op_assign
l_int|0
suffix:semicolon
)brace
id|mgsl_free_dma_buffers
c_func
(paren
id|info
)paren
suffix:semicolon
id|mgsl_free_intermediate_rxbuffer_memory
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;io_addr_requested
)paren
(brace
id|release_region
c_func
(paren
id|info-&gt;io_base
comma
id|info-&gt;io_addr_size
)paren
suffix:semicolon
id|info-&gt;io_addr_requested
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;shared_mem_requested
)paren
(brace
id|release_mem_region
c_func
(paren
id|info-&gt;phys_memory_base
comma
l_int|0x40000
)paren
suffix:semicolon
id|info-&gt;shared_mem_requested
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;lcr_mem_requested
)paren
(brace
id|release_mem_region
c_func
(paren
id|info-&gt;phys_lcr_base
comma
l_int|128
)paren
suffix:semicolon
id|info-&gt;lcr_mem_requested
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;memory_base
)paren
(brace
id|iounmap
c_func
(paren
id|info-&gt;memory_base
)paren
suffix:semicolon
id|info-&gt;memory_base
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;lcr_base
)paren
(brace
id|iounmap
c_func
(paren
id|info-&gt;lcr_base
op_minus
id|info-&gt;lcr_offset
)paren
suffix:semicolon
id|info-&gt;lcr_base
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_release_resources(%s) exit&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_release_resources() */
multiline_comment|/* mgsl_add_device()&n; * &n; * &t;Add the specified device instance data structure to the&n; * &t;global linked list of devices and increment the device count.&n; * &t;&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|mgsl_add_device
r_void
id|mgsl_add_device
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|info-&gt;next_device
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;line
op_assign
id|mgsl_device_count
suffix:semicolon
id|sprintf
c_func
(paren
id|info-&gt;device_name
comma
l_string|&quot;ttySL%d&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;line
OL
id|MAX_TOTAL_DEVICES
)paren
(brace
r_if
c_cond
(paren
id|maxframe
(braket
id|info-&gt;line
)braket
)paren
id|info-&gt;max_frame_size
op_assign
id|maxframe
(braket
id|info-&gt;line
)braket
suffix:semicolon
id|info-&gt;dosyncppp
op_assign
id|dosyncppp
(braket
id|info-&gt;line
)braket
suffix:semicolon
)brace
id|mgsl_device_count
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mgsl_device_list
)paren
id|mgsl_device_list
op_assign
id|info
suffix:semicolon
r_else
(brace
r_struct
id|mgsl_struct
op_star
id|current_dev
op_assign
id|mgsl_device_list
suffix:semicolon
r_while
c_loop
(paren
id|current_dev-&gt;next_device
)paren
(brace
id|current_dev
op_assign
id|current_dev-&gt;next_device
suffix:semicolon
)brace
id|current_dev-&gt;next_device
op_assign
id|info
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;max_frame_size
OL
l_int|4096
)paren
id|info-&gt;max_frame_size
op_assign
l_int|4096
suffix:semicolon
r_else
r_if
c_cond
(paren
id|info-&gt;max_frame_size
OG
l_int|65535
)paren
id|info-&gt;max_frame_size
op_assign
l_int|65535
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;SyncLink device %s added:PCI bus IO=%04X IRQ=%d Mem=%08X LCR=%08X MaxFrameSize=%u&bslash;n&quot;
comma
id|info-&gt;device_name
comma
id|info-&gt;io_base
comma
id|info-&gt;irq_level
comma
id|info-&gt;phys_memory_base
comma
id|info-&gt;phys_lcr_base
comma
id|info-&gt;max_frame_size
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;SyncLink device %s added:ISA bus IO=%04X IRQ=%d DMA=%d MaxFrameSize=%u&bslash;n&quot;
comma
id|info-&gt;device_name
comma
id|info-&gt;io_base
comma
id|info-&gt;irq_level
comma
id|info-&gt;dma_level
comma
id|info-&gt;max_frame_size
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SYNCLINK_SYNCPPP
r_if
c_cond
(paren
id|info-&gt;dosyncppp
)paren
id|mgsl_sppp_init
c_func
(paren
id|info
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* end of mgsl_add_device() */
multiline_comment|/* mgsl_allocate_device()&n; * &n; * &t;Allocate and initialize a device instance structure&n; * &t;&n; * Arguments:&t;&t;none&n; * Return Value:&t;pointer to mgsl_struct if success, otherwise NULL&n; */
DECL|function|mgsl_allocate_device
r_struct
id|mgsl_struct
op_star
id|mgsl_allocate_device
c_func
(paren
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
suffix:semicolon
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|mgsl_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error can&squot;t allocate device instance data&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mgsl_struct
)paren
)paren
suffix:semicolon
id|info-&gt;magic
op_assign
id|MGSL_MAGIC
suffix:semicolon
id|info-&gt;task.sync
op_assign
l_int|0
suffix:semicolon
id|info-&gt;task.routine
op_assign
id|mgsl_bh_handler
suffix:semicolon
id|info-&gt;task.data
op_assign
id|info
suffix:semicolon
id|info-&gt;max_frame_size
op_assign
l_int|4096
suffix:semicolon
id|info-&gt;close_delay
op_assign
l_int|5
op_star
id|HZ
op_div
l_int|10
suffix:semicolon
id|info-&gt;closing_wait
op_assign
l_int|30
op_star
id|HZ
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|info-&gt;status_event_wait_q
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|info-&gt;event_wait_q
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|info-&gt;netlock
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|info-&gt;params
comma
op_amp
id|default_params
comma
r_sizeof
(paren
id|MGSL_PARAMS
)paren
)paren
suffix:semicolon
id|info-&gt;idle_mode
op_assign
id|HDLC_TXIDLE_FLAGS
suffix:semicolon
)brace
r_return
id|info
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_allocate_device()*/
multiline_comment|/*&n; * perform tty device initialization&n; */
r_int
id|mgsl_init_tty
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|mgsl_init_tty
r_int
id|mgsl_init_tty
c_func
(paren
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
suffix:semicolon
id|memset
c_func
(paren
id|serial_table
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_struct
op_star
)paren
op_star
id|MAX_TOTAL_DEVICES
)paren
suffix:semicolon
id|memset
c_func
(paren
id|serial_termios
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|termios
op_star
)paren
op_star
id|MAX_TOTAL_DEVICES
)paren
suffix:semicolon
id|memset
c_func
(paren
id|serial_termios_locked
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|termios
op_star
)paren
op_star
id|MAX_TOTAL_DEVICES
)paren
suffix:semicolon
multiline_comment|/* Initialize the tty_driver structure */
id|memset
c_func
(paren
op_amp
id|serial_driver
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|serial_driver.magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
id|serial_driver.driver_name
op_assign
l_string|&quot;synclink&quot;
suffix:semicolon
id|serial_driver.name
op_assign
l_string|&quot;ttySL&quot;
suffix:semicolon
id|serial_driver.major
op_assign
id|ttymajor
suffix:semicolon
id|serial_driver.minor_start
op_assign
l_int|64
suffix:semicolon
id|serial_driver.num
op_assign
id|mgsl_device_count
suffix:semicolon
id|serial_driver.type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
id|serial_driver.subtype
op_assign
id|SERIAL_TYPE_NORMAL
suffix:semicolon
id|serial_driver.init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|serial_driver.init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
id|serial_driver.flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
id|serial_driver.refcount
op_assign
op_amp
id|serial_refcount
suffix:semicolon
id|serial_driver.table
op_assign
id|serial_table
suffix:semicolon
id|serial_driver.termios
op_assign
id|serial_termios
suffix:semicolon
id|serial_driver.termios_locked
op_assign
id|serial_termios_locked
suffix:semicolon
id|serial_driver.open
op_assign
id|mgsl_open
suffix:semicolon
id|serial_driver.close
op_assign
id|mgsl_close
suffix:semicolon
id|serial_driver.write
op_assign
id|mgsl_write
suffix:semicolon
id|serial_driver.put_char
op_assign
id|mgsl_put_char
suffix:semicolon
id|serial_driver.flush_chars
op_assign
id|mgsl_flush_chars
suffix:semicolon
id|serial_driver.write_room
op_assign
id|mgsl_write_room
suffix:semicolon
id|serial_driver.chars_in_buffer
op_assign
id|mgsl_chars_in_buffer
suffix:semicolon
id|serial_driver.flush_buffer
op_assign
id|mgsl_flush_buffer
suffix:semicolon
id|serial_driver.ioctl
op_assign
id|mgsl_ioctl
suffix:semicolon
id|serial_driver.throttle
op_assign
id|mgsl_throttle
suffix:semicolon
id|serial_driver.unthrottle
op_assign
id|mgsl_unthrottle
suffix:semicolon
id|serial_driver.send_xchar
op_assign
id|mgsl_send_xchar
suffix:semicolon
id|serial_driver.break_ctl
op_assign
id|mgsl_break
suffix:semicolon
id|serial_driver.wait_until_sent
op_assign
id|mgsl_wait_until_sent
suffix:semicolon
id|serial_driver.read_proc
op_assign
id|mgsl_read_proc
suffix:semicolon
id|serial_driver.set_termios
op_assign
id|mgsl_set_termios
suffix:semicolon
id|serial_driver.stop
op_assign
id|mgsl_stop
suffix:semicolon
id|serial_driver.start
op_assign
id|mgsl_start
suffix:semicolon
id|serial_driver.hangup
op_assign
id|mgsl_hangup
suffix:semicolon
multiline_comment|/*&n;&t; * The callout device is just like normal device except for&n;&t; * major number and the subtype code.&n;&t; */
id|callout_driver
op_assign
id|serial_driver
suffix:semicolon
id|callout_driver.name
op_assign
l_string|&quot;cuaSL&quot;
suffix:semicolon
id|callout_driver.major
op_assign
id|cuamajor
suffix:semicolon
id|callout_driver.subtype
op_assign
id|SERIAL_TYPE_CALLOUT
suffix:semicolon
id|callout_driver.read_proc
op_assign
l_int|0
suffix:semicolon
id|callout_driver.proc_entry
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|serial_driver
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):Couldn&squot;t register serial driver&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|callout_driver
)paren
OL
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):Couldn&squot;t register callout driver&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s version %s, tty major#%d callout major#%d&bslash;n&quot;
comma
id|driver_name
comma
id|driver_version
comma
id|serial_driver.major
comma
id|callout_driver.major
)paren
suffix:semicolon
multiline_comment|/* Propagate these values to all device instances */
id|info
op_assign
id|mgsl_device_list
suffix:semicolon
r_while
c_loop
(paren
id|info
)paren
(brace
id|info-&gt;callout_termios
op_assign
id|callout_driver.init_termios
suffix:semicolon
id|info-&gt;normal_termios
op_assign
id|serial_driver.init_termios
suffix:semicolon
id|info
op_assign
id|info-&gt;next_device
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* enumerate user specified ISA adapters&n; */
DECL|function|mgsl_enum_isa_devices
r_int
id|mgsl_enum_isa_devices
c_func
(paren
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Check for user specified ISA devices */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
(paren
id|i
OL
id|MAX_ISA_DEVICES
)paren
op_logical_and
id|io
(braket
id|i
)braket
op_logical_and
id|irq
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;ISA device specified io=%04X,irq=%d,dma=%d&bslash;n&quot;
comma
id|io
(braket
id|i
)braket
comma
id|irq
(braket
id|i
)braket
comma
id|dma
(braket
id|i
)braket
)paren
suffix:semicolon
id|info
op_assign
id|mgsl_allocate_device
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
multiline_comment|/* error allocating device instance data */
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ERROR
)paren
id|printk
c_func
(paren
l_string|&quot;can&squot;t allocate device instance data.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Copy user configuration info to device instance data */
id|info-&gt;io_base
op_assign
(paren
r_int
r_int
)paren
id|io
(braket
id|i
)braket
suffix:semicolon
id|info-&gt;irq_level
op_assign
(paren
r_int
r_int
)paren
id|irq
(braket
id|i
)braket
suffix:semicolon
id|info-&gt;irq_level
op_assign
id|irq_cannonicalize
c_func
(paren
id|info-&gt;irq_level
)paren
suffix:semicolon
id|info-&gt;dma_level
op_assign
(paren
r_int
r_int
)paren
id|dma
(braket
id|i
)braket
suffix:semicolon
id|info-&gt;bus_type
op_assign
id|MGSL_BUS_TYPE_ISA
suffix:semicolon
id|info-&gt;io_addr_size
op_assign
l_int|16
suffix:semicolon
id|info-&gt;irq_flags
op_assign
l_int|0
suffix:semicolon
id|mgsl_add_device
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* mgsl_init()&n; * &n; * &t;Driver initialization entry point.&n; * &t;&n; * Arguments:&t;None&n; * Return Value:&t;0 if success, otherwise error code&n; */
DECL|function|mgsl_init
r_int
id|__init
id|mgsl_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
id|EXPORT_NO_SYMBOLS
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s version %s&bslash;n&quot;
comma
id|driver_name
comma
id|driver_version
)paren
suffix:semicolon
id|mgsl_enum_isa_devices
c_func
(paren
)paren
suffix:semicolon
id|pci_register_driver
c_func
(paren
op_amp
id|synclink_pci_driver
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mgsl_device_list
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s(%d):No SyncLink devices found.&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|mgsl_init_tty
c_func
(paren
)paren
)paren
)paren
r_return
id|rc
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|synclink_init
r_static
r_int
id|__init
id|synclink_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Uncomment this to kernel debug module.&n; * mgsl_get_text_ptr() leaves the .text address in eax&n; * which can be used with add-symbol-file with gdb.&n; */
r_if
c_cond
(paren
id|break_on_load
)paren
(brace
id|mgsl_get_text_ptr
c_func
(paren
)paren
suffix:semicolon
id|BREAKPOINT
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|mgsl_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|synclink_exit
r_static
r_void
id|__exit
id|synclink_exit
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_struct
id|mgsl_struct
op_star
id|info
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unloading %s: version %s&bslash;n&quot;
comma
id|driver_name
comma
id|driver_version
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|tty_unregister_driver
c_func
(paren
op_amp
id|serial_driver
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d) failed to unregister tty driver err=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|rc
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|tty_unregister_driver
c_func
(paren
op_amp
id|callout_driver
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d) failed to unregister callout driver err=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|rc
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|info
op_assign
id|mgsl_device_list
suffix:semicolon
r_while
c_loop
(paren
id|info
)paren
(brace
macro_line|#ifdef CONFIG_SYNCLINK_SYNCPPP
r_if
c_cond
(paren
id|info-&gt;dosyncppp
)paren
id|mgsl_sppp_delete
c_func
(paren
id|info
)paren
suffix:semicolon
macro_line|#endif
id|mgsl_release_resources
c_func
(paren
id|info
)paren
suffix:semicolon
id|info
op_assign
id|info-&gt;next_device
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp_buf
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|tmp_buf
)paren
suffix:semicolon
id|tmp_buf
op_assign
l_int|NULL
suffix:semicolon
)brace
id|pci_unregister_driver
c_func
(paren
op_amp
id|synclink_pci_driver
)paren
suffix:semicolon
)brace
DECL|variable|synclink_init
id|module_init
c_func
(paren
id|synclink_init
)paren
suffix:semicolon
DECL|variable|synclink_exit
id|module_exit
c_func
(paren
id|synclink_exit
)paren
suffix:semicolon
multiline_comment|/*&n; * usc_RTCmd()&n; *&n; * Issue a USC Receive/Transmit command to the&n; * Channel Command/Address Register (CCAR).&n; *&n; * Notes:&n; *&n; *    The command is encoded in the most significant 5 bits &lt;15..11&gt;&n; *    of the CCAR value. Bits &lt;10..7&gt; of the CCAR must be preserved&n; *    and Bits &lt;6..0&gt; must be written as zeros.&n; *&n; * Arguments:&n; *&n; *    info   pointer to device information structure&n; *    Cmd    command mask (use symbolic macros)&n; *&n; * Return Value:&n; *&n; *    None&n; */
DECL|function|usc_RTCmd
r_void
id|usc_RTCmd
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|Cmd
)paren
(brace
multiline_comment|/* output command to CCAR in bits &lt;15..11&gt; */
multiline_comment|/* preserve bits &lt;10..7&gt;, bits &lt;6..0&gt; must be zero */
id|outw
c_func
(paren
id|Cmd
op_plus
id|info-&gt;loopback_bits
comma
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
multiline_comment|/* Read to flush write to CCAR */
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
id|inw
c_func
(paren
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
)brace
multiline_comment|/* end of usc_RTCmd() */
multiline_comment|/*&n; * usc_DmaCmd()&n; *&n; *    Issue a DMA command to the DMA Command/Address Register (DCAR).&n; *&n; * Arguments:&n; *&n; *    info   pointer to device information structure&n; *    Cmd    DMA command mask (usc_DmaCmd_XX Macros)&n; *&n; * Return Value:&n; *&n; *       None&n; */
DECL|function|usc_DmaCmd
r_void
id|usc_DmaCmd
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|Cmd
)paren
(brace
multiline_comment|/* write command mask to DCAR */
id|outw
c_func
(paren
id|Cmd
op_plus
id|info-&gt;mbre_bit
comma
id|info-&gt;io_base
)paren
suffix:semicolon
multiline_comment|/* Read to flush write to DCAR */
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
id|inw
c_func
(paren
id|info-&gt;io_base
)paren
suffix:semicolon
)brace
multiline_comment|/* end of usc_DmaCmd() */
multiline_comment|/*&n; * usc_OutDmaReg()&n; *&n; *    Write a 16-bit value to a USC DMA register&n; *&n; * Arguments:&n; *&n; *    info      pointer to device info structure&n; *    RegAddr   register address (number) for write&n; *    RegValue  16-bit value to write to register&n; *&n; * Return Value:&n; *&n; *    None&n; *&n; */
DECL|function|usc_OutDmaReg
r_void
id|usc_OutDmaReg
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|RegAddr
comma
id|u16
id|RegValue
)paren
(brace
multiline_comment|/* Note: The DCAR is located at the adapter base address */
multiline_comment|/* Note: must preserve state of BIT8 in DCAR */
id|outw
c_func
(paren
id|RegAddr
op_plus
id|info-&gt;mbre_bit
comma
id|info-&gt;io_base
)paren
suffix:semicolon
id|outw
c_func
(paren
id|RegValue
comma
id|info-&gt;io_base
)paren
suffix:semicolon
multiline_comment|/* Read to flush write to DCAR */
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
id|inw
c_func
(paren
id|info-&gt;io_base
)paren
suffix:semicolon
)brace
multiline_comment|/* end of usc_OutDmaReg() */
multiline_comment|/*&n; * usc_InDmaReg()&n; *&n; *    Read a 16-bit value from a DMA register&n; *&n; * Arguments:&n; *&n; *    info     pointer to device info structure&n; *    RegAddr  register address (number) to read from&n; *&n; * Return Value:&n; *&n; *    The 16-bit value read from register&n; *&n; */
DECL|function|usc_InDmaReg
id|u16
id|usc_InDmaReg
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|RegAddr
)paren
(brace
multiline_comment|/* Note: The DCAR is located at the adapter base address */
multiline_comment|/* Note: must preserve state of BIT8 in DCAR */
id|outw
c_func
(paren
id|RegAddr
op_plus
id|info-&gt;mbre_bit
comma
id|info-&gt;io_base
)paren
suffix:semicolon
r_return
id|inw
c_func
(paren
id|info-&gt;io_base
)paren
suffix:semicolon
)brace
multiline_comment|/* end of usc_InDmaReg() */
multiline_comment|/*&n; *&n; * usc_OutReg()&n; *&n; *    Write a 16-bit value to a USC serial channel register &n; *&n; * Arguments:&n; *&n; *    info      pointer to device info structure&n; *    RegAddr   register address (number) to write to&n; *    RegValue  16-bit value to write to register&n; *&n; * Return Value:&n; *&n; *    None&n; *&n; */
DECL|function|usc_OutReg
r_void
id|usc_OutReg
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|RegAddr
comma
id|u16
id|RegValue
)paren
(brace
id|outw
c_func
(paren
id|RegAddr
op_plus
id|info-&gt;loopback_bits
comma
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
id|outw
c_func
(paren
id|RegValue
comma
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
multiline_comment|/* Read to flush write to CCAR */
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
id|inw
c_func
(paren
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
)brace
multiline_comment|/* end of usc_OutReg() */
multiline_comment|/*&n; * usc_InReg()&n; *&n; *    Reads a 16-bit value from a USC serial channel register&n; *&n; * Arguments:&n; *&n; *    info       pointer to device extension&n; *    RegAddr    register address (number) to read from&n; *&n; * Return Value:&n; *&n; *    16-bit value read from register&n; */
DECL|function|usc_InReg
id|u16
id|usc_InReg
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u16
id|RegAddr
)paren
(brace
id|outw
c_func
(paren
id|RegAddr
op_plus
id|info-&gt;loopback_bits
comma
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
r_return
id|inw
c_func
(paren
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
)brace
multiline_comment|/* end of usc_InReg() */
multiline_comment|/* usc_set_sdlc_mode()&n; *&n; *    Set up the adapter for SDLC DMA communications.&n; *&n; * Arguments:&t;&t;info    pointer to device instance data&n; * Return Value: &t;NONE&n; */
DECL|function|usc_set_sdlc_mode
r_void
id|usc_set_sdlc_mode
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|u16
id|RegValue
suffix:semicolon
r_int
id|PreSL1660
suffix:semicolon
multiline_comment|/*&n;&t; * determine if the IUSC on the adapter is pre-SL1660. If&n;&t; * not, take advantage of the UnderWait feature of more&n;&t; * modern chips. If an underrun occurs and this bit is set,&n;&t; * the transmitter will idle the programmed idle pattern&n;&t; * until the driver has time to service the underrun. Otherwise,&n;&t; * the dma controller may get the cycles previously requested&n;&t; * and begin transmitting queued tx data.&n;&t; */
id|usc_OutReg
c_func
(paren
id|info
comma
id|TMCR
comma
l_int|0x1f
)paren
suffix:semicolon
id|RegValue
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|TMDR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RegValue
op_eq
id|IUSC_PRE_SL1660
)paren
id|PreSL1660
op_assign
l_int|1
suffix:semicolon
r_else
id|PreSL1660
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_HDLC_LOOPMODE
)paren
(brace
multiline_comment|/*&n; &t;   ** Channel Mode Register (CMR)&n; &t;   **&n; &t;   ** &lt;15..14&gt;    10    Tx Sub Modes, Send Flag on Underrun&n; &t;   ** &lt;13&gt;        0     0 = Transmit Disabled (initially)&n; &t;   ** &lt;12&gt;        0     1 = Consecutive Idles share common 0&n; &t;   ** &lt;11..8&gt;     1110  Transmitter Mode = HDLC/SDLC Loop&n; &t;   ** &lt;7..4&gt;      0000  Rx Sub Modes, addr/ctrl field handling&n; &t;   ** &lt;3..0&gt;      0110  Receiver Mode = HDLC/SDLC&n; &t;   **&n; &t;   ** 1000 1110 0000 0110 = 0x8e06&n; &t;   */
id|RegValue
op_assign
l_int|0x8e06
suffix:semicolon
multiline_comment|/*--------------------------------------------------&n; &t;    * ignore user options for UnderRun Actions and&n; &t;    * preambles&n; &t;    *--------------------------------------------------*/
)brace
r_else
(brace
multiline_comment|/* Channel mode Register (CMR)&n;&t;&t; *&n;&t;&t; * &lt;15..14&gt;  00    Tx Sub modes, Underrun Action&n;&t;&t; * &lt;13&gt;      0     1 = Send Preamble before opening flag&n;&t;&t; * &lt;12&gt;      0     1 = Consecutive Idles share common 0&n;&t;&t; * &lt;11..8&gt;   0110  Transmitter mode = HDLC/SDLC&n;&t;&t; * &lt;7..4&gt;    0000  Rx Sub modes, addr/ctrl field handling&n;&t;&t; * &lt;3..0&gt;    0110  Receiver mode = HDLC/SDLC&n;&t;&t; *&n;&t;&t; * 0000 0110 0000 0110 = 0x0606&n;&t;&t; */
id|RegValue
op_assign
l_int|0x0606
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_UNDERRUN_ABORT15
)paren
id|RegValue
op_or_assign
id|BIT14
suffix:semicolon
r_else
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_UNDERRUN_FLAG
)paren
id|RegValue
op_or_assign
id|BIT15
suffix:semicolon
r_else
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_UNDERRUN_CRC
)paren
id|RegValue
op_or_assign
id|BIT15
op_plus
id|BIT14
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.preamble
op_ne
id|HDLC_PREAMBLE_PATTERN_NONE
)paren
id|RegValue
op_or_assign
id|BIT13
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_SHARE_ZERO
)paren
id|RegValue
op_or_assign
id|BIT12
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.addr_filter
op_ne
l_int|0xff
)paren
(brace
multiline_comment|/* set up receive address filtering */
id|usc_OutReg
c_func
(paren
id|info
comma
id|RSR
comma
id|info-&gt;params.addr_filter
)paren
suffix:semicolon
id|RegValue
op_or_assign
id|BIT4
suffix:semicolon
)brace
id|usc_OutReg
c_func
(paren
id|info
comma
id|CMR
comma
id|RegValue
)paren
suffix:semicolon
id|info-&gt;cmr_value
op_assign
id|RegValue
suffix:semicolon
multiline_comment|/* Receiver mode Register (RMR)&n;&t; *&n;&t; * &lt;15..13&gt;  000    encoding&n;&t; * &lt;12..11&gt;  00     FCS = 16bit CRC CCITT (x15 + x12 + x5 + 1)&n;&t; * &lt;10&gt;      1      1 = Set CRC to all 1s (use for SDLC/HDLC)&n;&t; * &lt;9&gt;       0      1 = Include Receive chars in CRC&n;&t; * &lt;8&gt;       1      1 = Use Abort/PE bit as abort indicator&n;&t; * &lt;7..6&gt;    00     Even parity&n;&t; * &lt;5&gt;       0      parity disabled&n;&t; * &lt;4..2&gt;    000    Receive Char Length = 8 bits&n;&t; * &lt;1..0&gt;    00     Disable Receiver&n;&t; *&n;&t; * 0000 0101 0000 0000 = 0x0500&n;&t; */
id|RegValue
op_assign
l_int|0x0500
suffix:semicolon
r_switch
c_cond
(paren
id|info-&gt;params.encoding
)paren
(brace
r_case
id|HDLC_ENCODING_NRZB
suffix:colon
id|RegValue
op_or_assign
id|BIT13
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_ENCODING_NRZI_MARK
suffix:colon
id|RegValue
op_or_assign
id|BIT14
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_ENCODING_NRZI_SPACE
suffix:colon
id|RegValue
op_or_assign
id|BIT14
op_plus
id|BIT13
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_ENCODING_BIPHASE_MARK
suffix:colon
id|RegValue
op_or_assign
id|BIT15
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_ENCODING_BIPHASE_SPACE
suffix:colon
id|RegValue
op_or_assign
id|BIT15
op_plus
id|BIT13
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_ENCODING_BIPHASE_LEVEL
suffix:colon
id|RegValue
op_or_assign
id|BIT15
op_plus
id|BIT14
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_ENCODING_DIFF_BIPHASE_LEVEL
suffix:colon
id|RegValue
op_or_assign
id|BIT15
op_plus
id|BIT14
op_plus
id|BIT13
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;params.crc_type
op_eq
id|HDLC_CRC_16_CCITT
)paren
id|RegValue
op_or_assign
id|BIT9
suffix:semicolon
r_else
r_if
c_cond
(paren
id|info-&gt;params.crc_type
op_eq
id|HDLC_CRC_32_CCITT
)paren
id|RegValue
op_or_assign
(paren
id|BIT12
op_or
id|BIT10
op_or
id|BIT9
)paren
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|RMR
comma
id|RegValue
)paren
suffix:semicolon
multiline_comment|/* Set the Receive count Limit Register (RCLR) to 0xffff. */
multiline_comment|/* When an opening flag of an SDLC frame is recognized the */
multiline_comment|/* Receive Character count (RCC) is loaded with the value in */
multiline_comment|/* RCLR. The RCC is decremented for each received byte.  The */
multiline_comment|/* value of RCC is stored after the closing flag of the frame */
multiline_comment|/* allowing the frame size to be computed. */
id|usc_OutReg
c_func
(paren
id|info
comma
id|RCLR
comma
id|RCLRVALUE
)paren
suffix:semicolon
id|usc_RCmd
c_func
(paren
id|info
comma
id|RCmd_SelectRicrdma_level
)paren
suffix:semicolon
multiline_comment|/* Receive Interrupt Control Register (RICR)&n;&t; *&n;&t; * &lt;15..8&gt;&t;?&t;RxFIFO DMA Request Level&n;&t; * &lt;7&gt;&t;&t;0&t;Exited Hunt IA (Interrupt Arm)&n;&t; * &lt;6&gt;&t;&t;0&t;Idle Received IA&n;&t; * &lt;5&gt;&t;&t;0&t;Break/Abort IA&n;&t; * &lt;4&gt;&t;&t;0&t;Rx Bound IA&n;&t; * &lt;3&gt;&t;&t;1&t;Queued status reflects oldest 2 bytes in FIFO&n;&t; * &lt;2&gt;&t;&t;0&t;Abort/PE IA&n;&t; * &lt;1&gt;&t;&t;1&t;Rx Overrun IA&n;&t; * &lt;0&gt;&t;&t;0&t;Select TC0 value for readback&n;&t; *&n;&t; *&t;0000 0000 0000 1000 = 0x000a&n;&t; */
multiline_comment|/* Carry over the Exit Hunt and Idle Received bits */
multiline_comment|/* in case they have been armed by usc_ArmEvents.   */
id|RegValue
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|RICR
)paren
op_amp
l_int|0xc0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
id|usc_OutReg
c_func
(paren
id|info
comma
id|RICR
comma
(paren
id|u16
)paren
(paren
l_int|0x030a
op_or
id|RegValue
)paren
)paren
suffix:semicolon
r_else
id|usc_OutReg
c_func
(paren
id|info
comma
id|RICR
comma
(paren
id|u16
)paren
(paren
l_int|0x140a
op_or
id|RegValue
)paren
)paren
suffix:semicolon
multiline_comment|/* Unlatch all Rx status bits and clear Rx status IRQ Pending */
id|usc_UnlatchRxstatusBits
c_func
(paren
id|info
comma
id|RXSTATUS_ALL
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|RECEIVE_STATUS
)paren
suffix:semicolon
multiline_comment|/* Transmit mode Register (TMR)&n;&t; *&t;&n;&t; * &lt;15..13&gt;&t;000&t;encoding&n;&t; * &lt;12..11&gt;&t;00&t;FCS = 16bit CRC CCITT (x15 + x12 + x5 + 1)&n;&t; * &lt;10&gt;&t;&t;1&t;1 = Start CRC as all 1s (use for SDLC/HDLC)&n;&t; * &lt;9&gt;&t;&t;0&t;1 = Tx CRC Enabled&n;&t; * &lt;8&gt;&t;&t;0&t;1 = Append CRC to end of transmit frame&n;&t; * &lt;7..6&gt;&t;00&t;Transmit parity Even&n;&t; * &lt;5&gt;&t;&t;0&t;Transmit parity Disabled&n;&t; * &lt;4..2&gt;&t;000&t;Tx Char Length = 8 bits&n;&t; * &lt;1..0&gt;&t;00&t;Disable Transmitter&n;&t; *&n;&t; * &t;0000 0100 0000 0000 = 0x0400&n;&t; */
id|RegValue
op_assign
l_int|0x0400
suffix:semicolon
r_switch
c_cond
(paren
id|info-&gt;params.encoding
)paren
(brace
r_case
id|HDLC_ENCODING_NRZB
suffix:colon
id|RegValue
op_or_assign
id|BIT13
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_ENCODING_NRZI_MARK
suffix:colon
id|RegValue
op_or_assign
id|BIT14
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_ENCODING_NRZI_SPACE
suffix:colon
id|RegValue
op_or_assign
id|BIT14
op_plus
id|BIT13
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_ENCODING_BIPHASE_MARK
suffix:colon
id|RegValue
op_or_assign
id|BIT15
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_ENCODING_BIPHASE_SPACE
suffix:colon
id|RegValue
op_or_assign
id|BIT15
op_plus
id|BIT13
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_ENCODING_BIPHASE_LEVEL
suffix:colon
id|RegValue
op_or_assign
id|BIT15
op_plus
id|BIT14
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_ENCODING_DIFF_BIPHASE_LEVEL
suffix:colon
id|RegValue
op_or_assign
id|BIT15
op_plus
id|BIT14
op_plus
id|BIT13
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;params.crc_type
op_eq
id|HDLC_CRC_16_CCITT
)paren
id|RegValue
op_or_assign
id|BIT9
op_plus
id|BIT8
suffix:semicolon
r_else
r_if
c_cond
(paren
id|info-&gt;params.crc_type
op_eq
id|HDLC_CRC_32_CCITT
)paren
id|RegValue
op_or_assign
(paren
id|BIT12
op_or
id|BIT10
op_or
id|BIT9
op_or
id|BIT8
)paren
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|TMR
comma
id|RegValue
)paren
suffix:semicolon
id|usc_set_txidle
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_TCmd
c_func
(paren
id|info
comma
id|TCmd_SelectTicrdma_level
)paren
suffix:semicolon
multiline_comment|/* Transmit Interrupt Control Register (TICR)&n;&t; *&n;&t; * &lt;15..8&gt;&t;?&t;Transmit FIFO DMA Level&n;&t; * &lt;7&gt;&t;&t;0&t;Present IA (Interrupt Arm)&n;&t; * &lt;6&gt;&t;&t;0&t;Idle Sent IA&n;&t; * &lt;5&gt;&t;&t;1&t;Abort Sent IA&n;&t; * &lt;4&gt;&t;&t;1&t;EOF/EOM Sent IA&n;&t; * &lt;3&gt;&t;&t;0&t;CRC Sent IA&n;&t; * &lt;2&gt;&t;&t;1&t;1 = Wait for SW Trigger to Start Frame&n;&t; * &lt;1&gt;&t;&t;1&t;Tx Underrun IA&n;&t; * &lt;0&gt;&t;&t;0&t;TC0 constant on read back&n;&t; *&n;&t; *&t;0000 0000 0011 0110 = 0x0036&n;&t; */
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
id|usc_OutReg
c_func
(paren
id|info
comma
id|TICR
comma
l_int|0x0736
)paren
suffix:semicolon
r_else
id|usc_OutReg
c_func
(paren
id|info
comma
id|TICR
comma
l_int|0x1436
)paren
suffix:semicolon
id|usc_UnlatchTxstatusBits
c_func
(paren
id|info
comma
id|TXSTATUS_ALL
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|TRANSMIT_STATUS
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Transmit Command/Status Register (TCSR)&n;&t;**&n;&t;** &lt;15..12&gt;&t;0000&t;TCmd&n;&t;** &lt;11&gt; &t;0/1&t;UnderWait&n;&t;** &lt;10..08&gt;&t;000&t;TxIdle&n;&t;** &lt;7&gt;&t;&t;x&t;PreSent&n;&t;** &lt;6&gt;         &t;x&t;IdleSent&n;&t;** &lt;5&gt;         &t;x&t;AbortSent&n;&t;** &lt;4&gt;         &t;x&t;EOF/EOM Sent&n;&t;** &lt;3&gt;         &t;x&t;CRC Sent&n;&t;** &lt;2&gt;         &t;x&t;All Sent&n;&t;** &lt;1&gt;         &t;x&t;TxUnder&n;&t;** &lt;0&gt;         &t;x&t;TxEmpty&n;&t;** &n;&t;** 0000 0000 0000 0000 = 0x0000&n;&t;*/
id|info-&gt;tcsr_value
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PreSL1660
)paren
id|info-&gt;tcsr_value
op_or_assign
id|TCSR_UNDERWAIT
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|TCSR
comma
id|info-&gt;tcsr_value
)paren
suffix:semicolon
multiline_comment|/* Clock mode Control Register (CMCR)&n;&t; *&n;&t; * &lt;15..14&gt;&t;00&t;counter 1 Source = Disabled&n;&t; * &lt;13..12&gt; &t;00&t;counter 0 Source = Disabled&n;&t; * &lt;11..10&gt; &t;11&t;BRG1 Input is TxC Pin&n;&t; * &lt;9..8&gt;&t;11&t;BRG0 Input is TxC Pin&n;&t; * &lt;7..6&gt;&t;01&t;DPLL Input is BRG1 Output&n;&t; * &lt;5..3&gt;&t;XXX&t;TxCLK comes from Port 0&n;&t; * &lt;2..0&gt;   &t;XXX&t;RxCLK comes from Port 1&n;&t; *&n;&t; *&t;0000 1111 0111 0111 = 0x0f77&n;&t; */
id|RegValue
op_assign
l_int|0x0f40
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_RXC_DPLL
)paren
id|RegValue
op_or_assign
l_int|0x0003
suffix:semicolon
multiline_comment|/* RxCLK from DPLL */
r_else
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_RXC_BRG
)paren
id|RegValue
op_or_assign
l_int|0x0004
suffix:semicolon
multiline_comment|/* RxCLK from BRG0 */
r_else
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_RXC_TXCPIN
)paren
id|RegValue
op_or_assign
l_int|0x0006
suffix:semicolon
multiline_comment|/* RxCLK from TXC Input */
r_else
id|RegValue
op_or_assign
l_int|0x0007
suffix:semicolon
multiline_comment|/* RxCLK from Port1 */
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_TXC_DPLL
)paren
id|RegValue
op_or_assign
l_int|0x0018
suffix:semicolon
multiline_comment|/* TxCLK from DPLL */
r_else
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_TXC_BRG
)paren
id|RegValue
op_or_assign
l_int|0x0020
suffix:semicolon
multiline_comment|/* TxCLK from BRG0 */
r_else
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_TXC_RXCPIN
)paren
id|RegValue
op_or_assign
l_int|0x0038
suffix:semicolon
multiline_comment|/* RxCLK from TXC Input */
r_else
id|RegValue
op_or_assign
l_int|0x0030
suffix:semicolon
multiline_comment|/* TxCLK from Port0 */
id|usc_OutReg
c_func
(paren
id|info
comma
id|CMCR
comma
id|RegValue
)paren
suffix:semicolon
multiline_comment|/* Hardware Configuration Register (HCR)&n;&t; *&n;&t; * &lt;15..14&gt;&t;00&t;CTR0 Divisor:00=32,01=16,10=8,11=4&n;&t; * &lt;13&gt;&t;&t;0&t;CTR1DSel:0=CTR0Div determines CTR0Div&n;&t; * &lt;12&gt;&t;&t;0&t;CVOK:0=report code violation in biphase&n;&t; * &lt;11..10&gt;&t;00&t;DPLL Divisor:00=32,01=16,10=8,11=4&n;&t; * &lt;9..8&gt;&t;XX&t;DPLL mode:00=disable,01=NRZ,10=Biphase,11=Biphase Level&n;&t; * &lt;7..6&gt;&t;00&t;reserved&n;&t; * &lt;5&gt;&t;&t;0&t;BRG1 mode:0=continuous,1=single cycle&n;&t; * &lt;4&gt;&t;&t;X&t;BRG1 Enable&n;&t; * &lt;3..2&gt;&t;00&t;reserved&n;&t; * &lt;1&gt;&t;&t;0&t;BRG0 mode:0=continuous,1=single cycle&n;&t; * &lt;0&gt;&t;&t;0&t;BRG0 Enable&n;&t; */
id|RegValue
op_assign
l_int|0x0000
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
(paren
id|HDLC_FLAG_RXC_DPLL
op_plus
id|HDLC_FLAG_TXC_DPLL
)paren
)paren
(brace
id|u32
id|XtalSpeed
suffix:semicolon
id|u32
id|DpllDivisor
suffix:semicolon
id|u16
id|Tc
suffix:semicolon
multiline_comment|/*  DPLL is enabled. Use BRG1 to provide continuous reference clock  */
multiline_comment|/*  for DPLL. DPLL mode in HCR is dependent on the encoding used. */
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
id|XtalSpeed
op_assign
l_int|11059200
suffix:semicolon
r_else
id|XtalSpeed
op_assign
l_int|14745600
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_DPLL_DIV16
)paren
(brace
id|DpllDivisor
op_assign
l_int|16
suffix:semicolon
id|RegValue
op_or_assign
id|BIT10
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_DPLL_DIV8
)paren
(brace
id|DpllDivisor
op_assign
l_int|8
suffix:semicolon
id|RegValue
op_or_assign
id|BIT11
suffix:semicolon
)brace
r_else
id|DpllDivisor
op_assign
l_int|32
suffix:semicolon
multiline_comment|/*  Tc = (Xtal/Speed) - 1 */
multiline_comment|/*  If twice the remainder of (Xtal/Speed) is greater than Speed */
multiline_comment|/*  then rounding up gives a more precise time constant. Instead */
multiline_comment|/*  of rounding up and then subtracting 1 we just don&squot;t subtract */
multiline_comment|/*  the one in this case. */
multiline_comment|/*--------------------------------------------------&n; &t;&t; * ejz: for DPLL mode, application should use the&n; &t;&t; * same clock speed as the partner system, even &n; &t;&t; * though clocking is derived from the input RxData.&n; &t;&t; * In case the user uses a 0 for the clock speed,&n; &t;&t; * default to 0xffffffff and don&squot;t try to divide by&n; &t;&t; * zero&n; &t;&t; *--------------------------------------------------*/
r_if
c_cond
(paren
id|info-&gt;params.clock_speed
)paren
(brace
id|Tc
op_assign
(paren
id|u16
)paren
(paren
(paren
id|XtalSpeed
op_div
id|DpllDivisor
)paren
op_div
id|info-&gt;params.clock_speed
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
(paren
id|XtalSpeed
op_div
id|DpllDivisor
)paren
op_mod
id|info-&gt;params.clock_speed
)paren
op_star
l_int|2
)paren
op_div
id|info-&gt;params.clock_speed
)paren
)paren
id|Tc
op_decrement
suffix:semicolon
)brace
r_else
id|Tc
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Write 16-bit Time Constant for BRG1 */
id|usc_OutReg
c_func
(paren
id|info
comma
id|TC1R
comma
id|Tc
)paren
suffix:semicolon
id|RegValue
op_or_assign
id|BIT4
suffix:semicolon
multiline_comment|/* enable BRG1 */
r_switch
c_cond
(paren
id|info-&gt;params.encoding
)paren
(brace
r_case
id|HDLC_ENCODING_NRZ
suffix:colon
r_case
id|HDLC_ENCODING_NRZB
suffix:colon
r_case
id|HDLC_ENCODING_NRZI_MARK
suffix:colon
r_case
id|HDLC_ENCODING_NRZI_SPACE
suffix:colon
id|RegValue
op_or_assign
id|BIT8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_ENCODING_BIPHASE_MARK
suffix:colon
r_case
id|HDLC_ENCODING_BIPHASE_SPACE
suffix:colon
id|RegValue
op_or_assign
id|BIT9
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_ENCODING_BIPHASE_LEVEL
suffix:colon
r_case
id|HDLC_ENCODING_DIFF_BIPHASE_LEVEL
suffix:colon
id|RegValue
op_or_assign
id|BIT9
op_plus
id|BIT8
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|usc_OutReg
c_func
(paren
id|info
comma
id|HCR
comma
id|RegValue
)paren
suffix:semicolon
multiline_comment|/* Channel Control/status Register (CCSR)&n;&t; *&n;&t; * &lt;15&gt;&t;&t;X&t;RCC FIFO Overflow status (RO)&n;&t; * &lt;14&gt;&t;&t;X&t;RCC FIFO Not Empty status (RO)&n;&t; * &lt;13&gt;&t;&t;0&t;1 = Clear RCC FIFO (WO)&n;&t; * &lt;12&gt;&t;&t;X&t;DPLL Sync (RW)&n;&t; * &lt;11&gt;&t;&t;X&t;DPLL 2 Missed Clocks status (RO)&n;&t; * &lt;10&gt;&t;&t;X&t;DPLL 1 Missed Clock status (RO)&n;&t; * &lt;9..8&gt;&t;00&t;DPLL Resync on rising and falling edges (RW)&n;&t; * &lt;7&gt;&t;&t;X&t;SDLC Loop On status (RO)&n;&t; * &lt;6&gt;&t;&t;X&t;SDLC Loop Send status (RO)&n;&t; * &lt;5&gt;&t;&t;1&t;Bypass counters for TxClk and RxClk (RW)&n;&t; * &lt;4..2&gt;   &t;000&t;Last Char of SDLC frame has 8 bits (RW)&n;&t; * &lt;1..0&gt;   &t;00&t;reserved&n;&t; *&n;&t; *&t;0000 0000 0010 0000 = 0x0020&n;&t; */
id|usc_OutReg
c_func
(paren
id|info
comma
id|CCSR
comma
l_int|0x1020
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_AUTO_CTS
)paren
(brace
id|usc_OutReg
c_func
(paren
id|info
comma
id|SICR
comma
(paren
id|u16
)paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|SICR
)paren
op_or
id|SICR_CTS_INACTIVE
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* enable Master Interrupt Enable bit (MIE) */
id|usc_EnableMasterIrqBit
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|RECEIVE_STATUS
op_plus
id|RECEIVE_DATA
op_plus
id|TRANSMIT_STATUS
op_plus
id|TRANSMIT_DATA
)paren
suffix:semicolon
id|info-&gt;mbre_bit
op_assign
l_int|0
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|info-&gt;io_base
)paren
suffix:semicolon
multiline_comment|/* clear Master Bus Enable (DCAR) */
id|usc_DmaCmd
c_func
(paren
id|info
comma
id|DmaCmd_ResetAllChannels
)paren
suffix:semicolon
multiline_comment|/* disable both DMA channels */
id|info-&gt;mbre_bit
op_assign
id|BIT8
suffix:semicolon
id|outw
c_func
(paren
id|BIT8
comma
id|info-&gt;io_base
)paren
suffix:semicolon
multiline_comment|/* set Master Bus Enable (DCAR) */
multiline_comment|/* Enable DMAEN (Port 7, Bit 14) */
multiline_comment|/* This connects the DMA request signal to the ISA bus */
multiline_comment|/* on the ISA adapter. This has no effect for the PCI adapter */
id|usc_OutReg
c_func
(paren
id|info
comma
id|PCR
comma
(paren
id|u16
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|PCR
)paren
op_or
id|BIT15
)paren
op_amp
op_complement
id|BIT14
)paren
)paren
suffix:semicolon
multiline_comment|/* DMA Control Register (DCR)&n;&t; *&n;&t; * &lt;15..14&gt;&t;10&t;Priority mode = Alternating Tx/Rx&n;&t; *&t;&t;01&t;Rx has priority&n;&t; *&t;&t;00&t;Tx has priority&n;&t; *&n;&t; * &lt;13&gt;&t;&t;1&t;Enable Priority Preempt per DCR&lt;15..14&gt;&n;&t; *&t;&t;&t;(WARNING DCR&lt;11..10&gt; must be 00 when this is 1)&n;&t; *&t;&t;0&t;Choose activate channel per DCR&lt;11..10&gt;&n;&t; *&n;&t; * &lt;12&gt;&t;&t;0&t;Little Endian for Array/List&n;&t; * &lt;11..10&gt;&t;00&t;Both Channels can use each bus grant&n;&t; * &lt;9..6&gt;&t;0000&t;reserved&n;&t; * &lt;5&gt;&t;&t;0&t;7 CLK - Minimum Bus Re-request Interval&n;&t; * &lt;4&gt;&t;&t;0&t;1 = drive D/C and S/D pins&n;&t; * &lt;3&gt;&t;&t;1&t;1 = Add one wait state to all DMA cycles.&n;&t; * &lt;2&gt;&t;&t;0&t;1 = Strobe /UAS on every transfer.&n;&t; * &lt;1..0&gt;&t;11&t;Addr incrementing only affects LS24 bits&n;&t; *&n;&t; *&t;0110 0000 0000 1011 = 0x600b&n;&t; */
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
(brace
multiline_comment|/* PCI adapter does not need DMA wait state */
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|DCR
comma
l_int|0xa00b
)paren
suffix:semicolon
)brace
r_else
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|DCR
comma
l_int|0x800b
)paren
suffix:semicolon
multiline_comment|/* Receive DMA mode Register (RDMR)&n;&t; *&n;&t; * &lt;15..14&gt;&t;11&t;DMA mode = Linked List Buffer mode&n;&t; * &lt;13&gt;&t;&t;1&t;RSBinA/L = store Rx status Block in Arrary/List entry&n;&t; * &lt;12&gt;&t;&t;1&t;Clear count of List Entry after fetching&n;&t; * &lt;11..10&gt;&t;00&t;Address mode = Increment&n;&t; * &lt;9&gt;&t;&t;1&t;Terminate Buffer on RxBound&n;&t; * &lt;8&gt;&t;&t;0&t;Bus Width = 16bits&n;&t; * &lt;7..0&gt;&t;?&t;status Bits (write as 0s)&n;&t; *&n;&t; * 1111 0010 0000 0000 = 0xf200&n;&t; */
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|RDMR
comma
l_int|0xf200
)paren
suffix:semicolon
multiline_comment|/* Transmit DMA mode Register (TDMR)&n;&t; *&n;&t; * &lt;15..14&gt;&t;11&t;DMA mode = Linked List Buffer mode&n;&t; * &lt;13&gt;&t;&t;1&t;TCBinA/L = fetch Tx Control Block from List entry&n;&t; * &lt;12&gt;&t;&t;1&t;Clear count of List Entry after fetching&n;&t; * &lt;11..10&gt;&t;00&t;Address mode = Increment&n;&t; * &lt;9&gt;&t;&t;1&t;Terminate Buffer on end of frame&n;&t; * &lt;8&gt;&t;&t;0&t;Bus Width = 16bits&n;&t; * &lt;7..0&gt;&t;?&t;status Bits (Read Only so write as 0)&n;&t; *&n;&t; *&t;1111 0010 0000 0000 = 0xf200&n;&t; */
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|TDMR
comma
l_int|0xf200
)paren
suffix:semicolon
multiline_comment|/* DMA Interrupt Control Register (DICR)&n;&t; *&n;&t; * &lt;15&gt;&t;&t;1&t;DMA Interrupt Enable&n;&t; * &lt;14&gt;&t;&t;0&t;1 = Disable IEO from USC&n;&t; * &lt;13&gt;&t;&t;0&t;1 = Don&squot;t provide vector during IntAck&n;&t; * &lt;12&gt;&t;&t;1&t;1 = Include status in Vector&n;&t; * &lt;10..2&gt;&t;0&t;reserved, Must be 0s&n;&t; * &lt;1&gt;&t;&t;0&t;1 = Rx DMA Interrupt Enabled&n;&t; * &lt;0&gt;&t;&t;0&t;1 = Tx DMA Interrupt Enabled&n;&t; *&n;&t; *&t;1001 0000 0000 0000 = 0x9000&n;&t; */
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|DICR
comma
l_int|0x9000
)paren
suffix:semicolon
id|usc_InDmaReg
c_func
(paren
id|info
comma
id|RDMR
)paren
suffix:semicolon
multiline_comment|/* clear pending receive DMA IRQ bits */
id|usc_InDmaReg
c_func
(paren
id|info
comma
id|TDMR
)paren
suffix:semicolon
multiline_comment|/* clear pending transmit DMA IRQ bits */
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|CDIR
comma
l_int|0x0303
)paren
suffix:semicolon
multiline_comment|/* clear IUS and Pending for Tx and Rx */
multiline_comment|/* Channel Control Register (CCR)&n;&t; *&n;&t; * &lt;15..14&gt;&t;10&t;Use 32-bit Tx Control Blocks (TCBs)&n;&t; * &lt;13&gt;&t;&t;0&t;Trigger Tx on SW Command Disabled&n;&t; * &lt;12&gt;&t;&t;0&t;Flag Preamble Disabled&n;&t; * &lt;11..10&gt;&t;00&t;Preamble Length&n;&t; * &lt;9..8&gt;&t;00&t;Preamble Pattern&n;&t; * &lt;7..6&gt;&t;10&t;Use 32-bit Rx status Blocks (RSBs)&n;&t; * &lt;5&gt;&t;&t;0&t;Trigger Rx on SW Command Disabled&n;&t; * &lt;4..0&gt;&t;0&t;reserved&n;&t; *&n;&t; *&t;1000 0000 1000 0000 = 0x8080&n;&t; */
id|RegValue
op_assign
l_int|0x8080
suffix:semicolon
r_switch
c_cond
(paren
id|info-&gt;params.preamble_length
)paren
(brace
r_case
id|HDLC_PREAMBLE_LENGTH_16BITS
suffix:colon
id|RegValue
op_or_assign
id|BIT10
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_PREAMBLE_LENGTH_32BITS
suffix:colon
id|RegValue
op_or_assign
id|BIT11
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_PREAMBLE_LENGTH_64BITS
suffix:colon
id|RegValue
op_or_assign
id|BIT11
op_plus
id|BIT10
suffix:semicolon
r_break
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|info-&gt;params.preamble
)paren
(brace
r_case
id|HDLC_PREAMBLE_PATTERN_FLAGS
suffix:colon
id|RegValue
op_or_assign
id|BIT8
op_plus
id|BIT12
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_PREAMBLE_PATTERN_ONES
suffix:colon
id|RegValue
op_or_assign
id|BIT8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_PREAMBLE_PATTERN_10
suffix:colon
id|RegValue
op_or_assign
id|BIT9
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_PREAMBLE_PATTERN_01
suffix:colon
id|RegValue
op_or_assign
id|BIT9
op_plus
id|BIT8
suffix:semicolon
r_break
suffix:semicolon
)brace
id|usc_OutReg
c_func
(paren
id|info
comma
id|CCR
comma
id|RegValue
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Burst/Dwell Control Register&n;&t; *&n;&t; * &lt;15..8&gt;&t;0x20&t;Maximum number of transfers per bus grant&n;&t; * &lt;7..0&gt;&t;0x00&t;Maximum number of clock cycles per bus grant&n;&t; */
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
(brace
multiline_comment|/* don&squot;t limit bus occupancy on PCI adapter */
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|BDCR
comma
l_int|0x0000
)paren
suffix:semicolon
)brace
r_else
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|BDCR
comma
l_int|0x2000
)paren
suffix:semicolon
id|usc_stop_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_stop_receiver
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/* end of usc_set_sdlc_mode() */
multiline_comment|/* usc_enable_loopback()&n; *&n; * Set the 16C32 for internal loopback mode.&n; * The TxCLK and RxCLK signals are generated from the BRG0 and&n; * the TxD is looped back to the RxD internally.&n; *&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; *&t;&t;&t;enable&t;1 = enable loopback, 0 = disable&n; * Return Value:&t;None&n; */
DECL|function|usc_enable_loopback
r_void
id|usc_enable_loopback
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
id|enable
)paren
(brace
r_if
c_cond
(paren
id|enable
)paren
(brace
multiline_comment|/* blank external TXD output */
id|usc_OutReg
c_func
(paren
id|info
comma
id|IOCR
comma
id|usc_InReg
c_func
(paren
id|info
comma
id|IOCR
)paren
op_or
(paren
id|BIT7
op_plus
id|BIT6
)paren
)paren
suffix:semicolon
multiline_comment|/* Clock mode Control Register (CMCR)&n;&t;&t; *&n;&t;&t; * &lt;15..14&gt;&t;00&t;counter 1 Disabled&n;&t;&t; * &lt;13..12&gt; &t;00&t;counter 0 Disabled&n;&t;&t; * &lt;11..10&gt; &t;11&t;BRG1 Input is TxC Pin&n;&t;&t; * &lt;9..8&gt;&t;11&t;BRG0 Input is TxC Pin&n;&t;&t; * &lt;7..6&gt;&t;01&t;DPLL Input is BRG1 Output&n;&t;&t; * &lt;5..3&gt;&t;100&t;TxCLK comes from BRG0&n;&t;&t; * &lt;2..0&gt;   &t;100&t;RxCLK comes from BRG0&n;&t;&t; *&n;&t;&t; * 0000 1111 0110 0100 = 0x0f64&n;&t;&t; */
id|usc_OutReg
c_func
(paren
id|info
comma
id|CMCR
comma
l_int|0x0f64
)paren
suffix:semicolon
multiline_comment|/* Write 16-bit Time Constant for BRG0 */
multiline_comment|/* use clock speed if available, otherwise use 8 for diagnostics */
r_if
c_cond
(paren
id|info-&gt;params.clock_speed
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
id|usc_OutReg
c_func
(paren
id|info
comma
id|TC0R
comma
(paren
id|u16
)paren
(paren
(paren
l_int|11059200
op_div
id|info-&gt;params.clock_speed
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_else
id|usc_OutReg
c_func
(paren
id|info
comma
id|TC0R
comma
(paren
id|u16
)paren
(paren
(paren
l_int|14745600
op_div
id|info-&gt;params.clock_speed
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_else
id|usc_OutReg
c_func
(paren
id|info
comma
id|TC0R
comma
(paren
id|u16
)paren
l_int|8
)paren
suffix:semicolon
multiline_comment|/* Hardware Configuration Register (HCR) Clear Bit 1, BRG0&n;&t;&t;   mode = Continuous Set Bit 0 to enable BRG0.  */
id|usc_OutReg
c_func
(paren
id|info
comma
id|HCR
comma
(paren
id|u16
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|HCR
)paren
op_amp
op_complement
id|BIT1
)paren
op_or
id|BIT0
)paren
)paren
suffix:semicolon
multiline_comment|/* Input/Output Control Reg, &lt;2..0&gt; = 100, Drive RxC pin with BRG0 */
id|usc_OutReg
c_func
(paren
id|info
comma
id|IOCR
comma
(paren
id|u16
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|IOCR
)paren
op_amp
l_int|0xfff8
)paren
op_or
l_int|0x0004
)paren
)paren
suffix:semicolon
multiline_comment|/* set Internal Data loopback mode */
id|info-&gt;loopback_bits
op_assign
l_int|0x300
suffix:semicolon
id|outw
c_func
(paren
l_int|0x0300
comma
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* enable external TXD output */
id|usc_OutReg
c_func
(paren
id|info
comma
id|IOCR
comma
id|usc_InReg
c_func
(paren
id|info
comma
id|IOCR
)paren
op_amp
op_complement
(paren
id|BIT7
op_plus
id|BIT6
)paren
)paren
suffix:semicolon
multiline_comment|/* clear Internal Data loopback mode */
id|info-&gt;loopback_bits
op_assign
l_int|0
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end of usc_enable_loopback() */
multiline_comment|/* usc_enable_aux_clock()&n; *&n; * Enabled the AUX clock output at the specified frequency.&n; *&n; * Arguments:&n; *&n; *&t;info&t;&t;pointer to device extension&n; *&t;data_rate&t;data rate of clock in bits per second&n; *&t;&t;&t;A data rate of 0 disables the AUX clock.&n; *&n; * Return Value:&t;None&n; */
DECL|function|usc_enable_aux_clock
r_void
id|usc_enable_aux_clock
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u32
id|data_rate
)paren
(brace
id|u32
id|XtalSpeed
suffix:semicolon
id|u16
id|Tc
suffix:semicolon
r_if
c_cond
(paren
id|data_rate
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
id|XtalSpeed
op_assign
l_int|11059200
suffix:semicolon
r_else
id|XtalSpeed
op_assign
l_int|14745600
suffix:semicolon
multiline_comment|/* Tc = (Xtal/Speed) - 1 */
multiline_comment|/* If twice the remainder of (Xtal/Speed) is greater than Speed */
multiline_comment|/* then rounding up gives a more precise time constant. Instead */
multiline_comment|/* of rounding up and then subtracting 1 we just don&squot;t subtract */
multiline_comment|/* the one in this case. */
id|Tc
op_assign
(paren
id|u16
)paren
(paren
id|XtalSpeed
op_div
id|data_rate
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
id|XtalSpeed
op_mod
id|data_rate
)paren
op_star
l_int|2
)paren
op_div
id|data_rate
)paren
)paren
id|Tc
op_decrement
suffix:semicolon
multiline_comment|/* Write 16-bit Time Constant for BRG0 */
id|usc_OutReg
c_func
(paren
id|info
comma
id|TC0R
comma
id|Tc
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Hardware Configuration Register (HCR)&n;&t;&t; * Clear Bit 1, BRG0 mode = Continuous&n;&t;&t; * Set Bit 0 to enable BRG0.&n;&t;&t; */
id|usc_OutReg
c_func
(paren
id|info
comma
id|HCR
comma
(paren
id|u16
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|HCR
)paren
op_amp
op_complement
id|BIT1
)paren
op_or
id|BIT0
)paren
)paren
suffix:semicolon
multiline_comment|/* Input/Output Control Reg, &lt;2..0&gt; = 100, Drive RxC pin with BRG0 */
id|usc_OutReg
c_func
(paren
id|info
comma
id|IOCR
comma
(paren
id|u16
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|IOCR
)paren
op_amp
l_int|0xfff8
)paren
op_or
l_int|0x0004
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* data rate == 0 so turn off BRG0 */
id|usc_OutReg
c_func
(paren
id|info
comma
id|HCR
comma
(paren
id|u16
)paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|HCR
)paren
op_amp
op_complement
id|BIT0
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end of usc_enable_aux_clock() */
multiline_comment|/*&n; *&n; * usc_process_rxoverrun_sync()&n; *&n; *&t;&t;This function processes a receive overrun by resetting the&n; *&t;&t;receive DMA buffers and issuing a Purge Rx FIFO command&n; *&t;&t;to allow the receiver to continue receiving.&n; *&n; * Arguments:&n; *&n; *&t;info&t;&t;pointer to device extension&n; *&n; * Return Value: None&n; */
DECL|function|usc_process_rxoverrun_sync
r_void
id|usc_process_rxoverrun_sync
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
id|start_index
suffix:semicolon
r_int
id|end_index
suffix:semicolon
r_int
id|frame_start_index
suffix:semicolon
r_int
id|start_of_frame_found
op_assign
id|FALSE
suffix:semicolon
r_int
id|end_of_frame_found
op_assign
id|FALSE
suffix:semicolon
r_int
id|reprogram_dma
op_assign
id|FALSE
suffix:semicolon
id|DMABUFFERENTRY
op_star
id|buffer_list
op_assign
id|info-&gt;rx_buffer_list
suffix:semicolon
id|u32
id|phys_addr
suffix:semicolon
id|usc_DmaCmd
c_func
(paren
id|info
comma
id|DmaCmd_PauseRxChannel
)paren
suffix:semicolon
id|usc_RCmd
c_func
(paren
id|info
comma
id|RCmd_EnterHuntmode
)paren
suffix:semicolon
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_PurgeRxFifo
)paren
suffix:semicolon
multiline_comment|/* CurrentRxBuffer points to the 1st buffer of the next */
multiline_comment|/* possibly available receive frame. */
id|frame_start_index
op_assign
id|start_index
op_assign
id|end_index
op_assign
id|info-&gt;current_rx_buffer
suffix:semicolon
multiline_comment|/* Search for an unfinished string of buffers. This means */
multiline_comment|/* that a receive frame started (at least one buffer with */
multiline_comment|/* count set to zero) but there is no terminiting buffer */
multiline_comment|/* (status set to non-zero). */
r_while
c_loop
(paren
op_logical_neg
id|buffer_list
(braket
id|end_index
)braket
dot
id|count
)paren
(brace
multiline_comment|/* Count field has been reset to zero by 16C32. */
multiline_comment|/* This buffer is currently in use. */
r_if
c_cond
(paren
op_logical_neg
id|start_of_frame_found
)paren
(brace
id|start_of_frame_found
op_assign
id|TRUE
suffix:semicolon
id|frame_start_index
op_assign
id|end_index
suffix:semicolon
id|end_of_frame_found
op_assign
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer_list
(braket
id|end_index
)braket
dot
id|status
)paren
(brace
multiline_comment|/* Status field has been set by 16C32. */
multiline_comment|/* This is the last buffer of a received frame. */
multiline_comment|/* We want to leave the buffers for this frame intact. */
multiline_comment|/* Move on to next possible frame. */
id|start_of_frame_found
op_assign
id|FALSE
suffix:semicolon
id|end_of_frame_found
op_assign
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* advance to next buffer entry in linked list */
id|end_index
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|end_index
op_eq
id|info-&gt;rx_buffer_count
)paren
id|end_index
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|start_index
op_eq
id|end_index
)paren
(brace
multiline_comment|/* The entire list has been searched with all Counts == 0 and */
multiline_comment|/* all Status == 0. The receive buffers are */
multiline_comment|/* completely screwed, reset all receive buffers! */
id|mgsl_reset_rx_dma_buffers
c_func
(paren
id|info
)paren
suffix:semicolon
id|frame_start_index
op_assign
l_int|0
suffix:semicolon
id|start_of_frame_found
op_assign
id|FALSE
suffix:semicolon
id|reprogram_dma
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|start_of_frame_found
op_logical_and
op_logical_neg
id|end_of_frame_found
)paren
(brace
multiline_comment|/* There is an unfinished string of receive DMA buffers */
multiline_comment|/* as a result of the receiver overrun. */
multiline_comment|/* Reset the buffers for the unfinished frame */
multiline_comment|/* and reprogram the receive DMA controller to start */
multiline_comment|/* at the 1st buffer of unfinished frame. */
id|start_index
op_assign
id|frame_start_index
suffix:semicolon
r_do
(brace
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|info-&gt;rx_buffer_list
(braket
id|start_index
op_increment
)braket
dot
id|count
)paren
)paren
op_assign
id|DMABUFFERSIZE
suffix:semicolon
multiline_comment|/* Adjust index for wrap around. */
r_if
c_cond
(paren
id|start_index
op_eq
id|info-&gt;rx_buffer_count
)paren
id|start_index
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|start_index
op_ne
id|end_index
)paren
(brace
suffix:semicolon
)brace
id|reprogram_dma
op_assign
id|TRUE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reprogram_dma
)paren
(brace
id|usc_UnlatchRxstatusBits
c_func
(paren
id|info
comma
id|RXSTATUS_ALL
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|RECEIVE_DATA
op_or
id|RECEIVE_STATUS
)paren
suffix:semicolon
id|usc_UnlatchRxstatusBits
c_func
(paren
id|info
comma
id|RECEIVE_DATA
op_or
id|RECEIVE_STATUS
)paren
suffix:semicolon
id|usc_EnableReceiver
c_func
(paren
id|info
comma
id|DISABLE_UNCONDITIONAL
)paren
suffix:semicolon
multiline_comment|/* This empties the receive FIFO and loads the RCC with RCLR */
id|usc_OutReg
c_func
(paren
id|info
comma
id|CCSR
comma
(paren
id|u16
)paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|CCSR
)paren
op_or
id|BIT13
)paren
)paren
suffix:semicolon
multiline_comment|/* program 16C32 with physical address of 1st DMA buffer entry */
id|phys_addr
op_assign
id|info-&gt;rx_buffer_list
(braket
id|frame_start_index
)braket
dot
id|phys_entry
suffix:semicolon
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|NRARL
comma
(paren
id|u16
)paren
id|phys_addr
)paren
suffix:semicolon
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|NRARU
comma
(paren
id|u16
)paren
(paren
id|phys_addr
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
id|usc_UnlatchRxstatusBits
c_func
(paren
id|info
comma
id|RXSTATUS_ALL
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|RECEIVE_DATA
op_plus
id|RECEIVE_STATUS
)paren
suffix:semicolon
id|usc_EnableInterrupts
c_func
(paren
id|info
comma
id|RECEIVE_STATUS
)paren
suffix:semicolon
multiline_comment|/* 1. Arm End of Buffer (EOB) Receive DMA Interrupt (BIT2 of RDIAR) */
multiline_comment|/* 2. Enable Receive DMA Interrupts (BIT1 of DICR) */
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|RDIAR
comma
id|BIT3
op_plus
id|BIT2
)paren
suffix:semicolon
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|DICR
comma
(paren
id|u16
)paren
(paren
id|usc_InDmaReg
c_func
(paren
id|info
comma
id|DICR
)paren
op_or
id|BIT1
)paren
)paren
suffix:semicolon
id|usc_DmaCmd
c_func
(paren
id|info
comma
id|DmaCmd_InitRxChannel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_AUTO_DCD
)paren
id|usc_EnableReceiver
c_func
(paren
id|info
comma
id|ENABLE_AUTO_DCD
)paren
suffix:semicolon
r_else
id|usc_EnableReceiver
c_func
(paren
id|info
comma
id|ENABLE_UNCONDITIONAL
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This empties the receive FIFO and loads the RCC with RCLR */
id|usc_OutReg
c_func
(paren
id|info
comma
id|CCSR
comma
(paren
id|u16
)paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|CCSR
)paren
op_or
id|BIT13
)paren
)paren
suffix:semicolon
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_PurgeRxFifo
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end of usc_process_rxoverrun_sync() */
multiline_comment|/* usc_stop_receiver()&n; *&n; *&t;Disable USC receiver&n; *&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|usc_stop_receiver
r_void
id|usc_stop_receiver
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):usc_stop_receiver(%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
multiline_comment|/* Disable receive DMA channel. */
multiline_comment|/* This also disables receive DMA channel interrupts */
id|usc_DmaCmd
c_func
(paren
id|info
comma
id|DmaCmd_ResetRxChannel
)paren
suffix:semicolon
id|usc_UnlatchRxstatusBits
c_func
(paren
id|info
comma
id|RXSTATUS_ALL
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|RECEIVE_DATA
op_plus
id|RECEIVE_STATUS
)paren
suffix:semicolon
id|usc_DisableInterrupts
c_func
(paren
id|info
comma
id|RECEIVE_DATA
op_plus
id|RECEIVE_STATUS
)paren
suffix:semicolon
id|usc_EnableReceiver
c_func
(paren
id|info
comma
id|DISABLE_UNCONDITIONAL
)paren
suffix:semicolon
multiline_comment|/* This empties the receive FIFO and loads the RCC with RCLR */
id|usc_OutReg
c_func
(paren
id|info
comma
id|CCSR
comma
(paren
id|u16
)paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|CCSR
)paren
op_or
id|BIT13
)paren
)paren
suffix:semicolon
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_PurgeRxFifo
)paren
suffix:semicolon
id|info-&gt;rx_enabled
op_assign
l_int|0
suffix:semicolon
id|info-&gt;rx_overflow
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of stop_receiver() */
multiline_comment|/* usc_start_receiver()&n; *&n; *&t;Enable the USC receiver &n; *&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|usc_start_receiver
r_void
id|usc_start_receiver
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|u32
id|phys_addr
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):usc_start_receiver(%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|mgsl_reset_rx_dma_buffers
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_stop_receiver
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|CCSR
comma
(paren
id|u16
)paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|CCSR
)paren
op_or
id|BIT13
)paren
)paren
suffix:semicolon
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_PurgeRxFifo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.mode
op_eq
id|MGSL_MODE_HDLC
)paren
(brace
multiline_comment|/* DMA mode Transfers */
multiline_comment|/* Program the DMA controller. */
multiline_comment|/* Enable the DMA controller end of buffer interrupt. */
multiline_comment|/* program 16C32 with physical address of 1st DMA buffer entry */
id|phys_addr
op_assign
id|info-&gt;rx_buffer_list
(braket
l_int|0
)braket
dot
id|phys_entry
suffix:semicolon
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|NRARL
comma
(paren
id|u16
)paren
id|phys_addr
)paren
suffix:semicolon
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|NRARU
comma
(paren
id|u16
)paren
(paren
id|phys_addr
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
id|usc_UnlatchRxstatusBits
c_func
(paren
id|info
comma
id|RXSTATUS_ALL
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|RECEIVE_DATA
op_plus
id|RECEIVE_STATUS
)paren
suffix:semicolon
id|usc_EnableInterrupts
c_func
(paren
id|info
comma
id|RECEIVE_STATUS
)paren
suffix:semicolon
multiline_comment|/* 1. Arm End of Buffer (EOB) Receive DMA Interrupt (BIT2 of RDIAR) */
multiline_comment|/* 2. Enable Receive DMA Interrupts (BIT1 of DICR) */
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|RDIAR
comma
id|BIT3
op_plus
id|BIT2
)paren
suffix:semicolon
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|DICR
comma
(paren
id|u16
)paren
(paren
id|usc_InDmaReg
c_func
(paren
id|info
comma
id|DICR
)paren
op_or
id|BIT1
)paren
)paren
suffix:semicolon
id|usc_DmaCmd
c_func
(paren
id|info
comma
id|DmaCmd_InitRxChannel
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_AUTO_DCD
)paren
id|usc_EnableReceiver
c_func
(paren
id|info
comma
id|ENABLE_AUTO_DCD
)paren
suffix:semicolon
r_else
id|usc_EnableReceiver
c_func
(paren
id|info
comma
id|ENABLE_UNCONDITIONAL
)paren
suffix:semicolon
)brace
r_else
(brace
id|usc_UnlatchRxstatusBits
c_func
(paren
id|info
comma
id|RXSTATUS_ALL
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|RECEIVE_DATA
op_plus
id|RECEIVE_STATUS
)paren
suffix:semicolon
id|usc_EnableInterrupts
c_func
(paren
id|info
comma
id|RECEIVE_DATA
)paren
suffix:semicolon
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_PurgeRxFifo
)paren
suffix:semicolon
id|usc_RCmd
c_func
(paren
id|info
comma
id|RCmd_EnterHuntmode
)paren
suffix:semicolon
id|usc_EnableReceiver
c_func
(paren
id|info
comma
id|ENABLE_UNCONDITIONAL
)paren
suffix:semicolon
)brace
id|usc_OutReg
c_func
(paren
id|info
comma
id|CCSR
comma
l_int|0x1020
)paren
suffix:semicolon
id|info-&gt;rx_enabled
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* end of usc_start_receiver() */
multiline_comment|/* usc_start_transmitter()&n; *&n; *&t;Enable the USC transmitter and send a transmit frame if&n; *&t;one is loaded in the DMA buffers.&n; *&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|usc_start_transmitter
r_void
id|usc_start_transmitter
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|u32
id|phys_addr
suffix:semicolon
r_int
r_int
id|FrameSize
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):usc_start_transmitter(%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
)paren
(brace
multiline_comment|/* If auto RTS enabled and RTS is inactive, then assert */
multiline_comment|/* RTS and set a flag indicating that the driver should */
multiline_comment|/* negate RTS when the transmission completes. */
id|info-&gt;drop_rts_on_tx_done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_AUTO_RTS
)paren
(brace
id|usc_get_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;serial_signals
op_amp
id|SerialSignal_RTS
)paren
)paren
(brace
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_RTS
suffix:semicolon
id|usc_set_serial_signals
c_func
(paren
id|info
)paren
suffix:semicolon
id|info-&gt;drop_rts_on_tx_done
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|info-&gt;params.mode
op_eq
id|MGSL_MODE_ASYNC
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tx_active
)paren
(brace
id|usc_UnlatchTxstatusBits
c_func
(paren
id|info
comma
id|TXSTATUS_ALL
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|TRANSMIT_STATUS
op_plus
id|TRANSMIT_DATA
)paren
suffix:semicolon
id|usc_EnableInterrupts
c_func
(paren
id|info
comma
id|TRANSMIT_DATA
)paren
suffix:semicolon
id|usc_load_txfifo
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Disable transmit DMA controller while programming. */
id|usc_DmaCmd
c_func
(paren
id|info
comma
id|DmaCmd_ResetTxChannel
)paren
suffix:semicolon
multiline_comment|/* Transmit DMA buffer is loaded, so program USC */
multiline_comment|/* to send the frame contained in the buffers.&t; */
id|FrameSize
op_assign
id|info-&gt;tx_buffer_list
(braket
l_int|0
)braket
dot
id|rcc
suffix:semicolon
multiline_comment|/* Program the Transmit Character Length Register (TCLR) */
multiline_comment|/* and clear FIFO (TCC is loaded with TCLR on FIFO clear) */
id|usc_OutReg
c_func
(paren
id|info
comma
id|TCLR
comma
(paren
id|u16
)paren
id|FrameSize
)paren
suffix:semicolon
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_PurgeTxFifo
)paren
suffix:semicolon
multiline_comment|/* Program the address of the 1st DMA Buffer Entry in linked list */
id|phys_addr
op_assign
id|info-&gt;tx_buffer_list
(braket
l_int|0
)braket
dot
id|phys_entry
suffix:semicolon
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|NTARL
comma
(paren
id|u16
)paren
id|phys_addr
)paren
suffix:semicolon
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|NTARU
comma
(paren
id|u16
)paren
(paren
id|phys_addr
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
id|usc_UnlatchTxstatusBits
c_func
(paren
id|info
comma
id|TXSTATUS_ALL
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|TRANSMIT_STATUS
)paren
suffix:semicolon
id|usc_EnableInterrupts
c_func
(paren
id|info
comma
id|TRANSMIT_STATUS
)paren
suffix:semicolon
multiline_comment|/* Initialize Transmit DMA Channel */
id|usc_DmaCmd
c_func
(paren
id|info
comma
id|DmaCmd_InitTxChannel
)paren
suffix:semicolon
id|usc_TCmd
c_func
(paren
id|info
comma
id|TCmd_SendFrame
)paren
suffix:semicolon
id|info-&gt;tx_timer.expires
op_assign
id|jiffies
op_plus
id|jiffies_from_ms
c_func
(paren
l_int|5000
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|info-&gt;tx_timer
)paren
suffix:semicolon
)brace
id|info-&gt;tx_active
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tx_enabled
)paren
(brace
id|info-&gt;tx_enabled
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_AUTO_CTS
)paren
id|usc_EnableTransmitter
c_func
(paren
id|info
comma
id|ENABLE_AUTO_CTS
)paren
suffix:semicolon
r_else
id|usc_EnableTransmitter
c_func
(paren
id|info
comma
id|ENABLE_UNCONDITIONAL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end of usc_start_transmitter() */
multiline_comment|/* usc_stop_transmitter()&n; *&n; *&t;Stops the transmitter and DMA&n; *&n; * Arguments:&t;&t;info&t;pointer to device isntance data&n; * Return Value:&t;None&n; */
DECL|function|usc_stop_transmitter
r_void
id|usc_stop_transmitter
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_ISR
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):usc_stop_transmitter(%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|info-&gt;tx_timer
)paren
suffix:semicolon
id|usc_UnlatchTxstatusBits
c_func
(paren
id|info
comma
id|TXSTATUS_ALL
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|TRANSMIT_STATUS
op_plus
id|TRANSMIT_DATA
)paren
suffix:semicolon
id|usc_DisableInterrupts
c_func
(paren
id|info
comma
id|TRANSMIT_STATUS
op_plus
id|TRANSMIT_DATA
)paren
suffix:semicolon
id|usc_EnableTransmitter
c_func
(paren
id|info
comma
id|DISABLE_UNCONDITIONAL
)paren
suffix:semicolon
id|usc_DmaCmd
c_func
(paren
id|info
comma
id|DmaCmd_ResetTxChannel
)paren
suffix:semicolon
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_PurgeTxFifo
)paren
suffix:semicolon
id|info-&gt;tx_enabled
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tx_active
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of usc_stop_transmitter() */
multiline_comment|/* usc_load_txfifo()&n; *&n; *&t;Fill the transmit FIFO until the FIFO is full or&n; *&t;there is no more data to load.&n; *&n; * Arguments:&t;&t;info&t;pointer to device extension (instance data)&n; * Return Value:&t;None&n; */
DECL|function|usc_load_txfifo
r_void
id|usc_load_txfifo
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
id|Fifocount
suffix:semicolon
id|u8
id|TwoBytes
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;xmit_cnt
op_logical_and
op_logical_neg
id|info-&gt;x_char
)paren
r_return
suffix:semicolon
multiline_comment|/* Select transmit FIFO status readback in TICR */
id|usc_TCmd
c_func
(paren
id|info
comma
id|TCmd_SelectTicrTxFifostatus
)paren
suffix:semicolon
multiline_comment|/* load the Transmit FIFO until FIFOs full or all data sent */
r_while
c_loop
(paren
(paren
id|Fifocount
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|TICR
)paren
op_rshift
l_int|8
)paren
op_logical_and
id|info-&gt;xmit_cnt
)paren
(brace
multiline_comment|/* there is more space in the transmit FIFO and */
multiline_comment|/* there is more data in transmit buffer */
r_if
c_cond
(paren
(paren
id|info-&gt;xmit_cnt
OG
l_int|1
)paren
op_logical_and
(paren
id|Fifocount
OG
l_int|1
)paren
op_logical_and
op_logical_neg
id|info-&gt;x_char
)paren
(brace
multiline_comment|/* write a 16-bit word from transmit buffer to 16C32 */
id|TwoBytes
(braket
l_int|0
)braket
op_assign
id|info-&gt;xmit_buf
(braket
id|info-&gt;xmit_tail
op_increment
)braket
suffix:semicolon
id|info-&gt;xmit_tail
op_assign
id|info-&gt;xmit_tail
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|TwoBytes
(braket
l_int|1
)braket
op_assign
id|info-&gt;xmit_buf
(braket
id|info-&gt;xmit_tail
op_increment
)braket
suffix:semicolon
id|info-&gt;xmit_tail
op_assign
id|info-&gt;xmit_tail
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|outw
c_func
(paren
op_star
(paren
(paren
id|u16
op_star
)paren
id|TwoBytes
)paren
comma
id|info-&gt;io_base
op_plus
id|DATAREG
)paren
suffix:semicolon
id|info-&gt;xmit_cnt
op_sub_assign
l_int|2
suffix:semicolon
id|info-&gt;icount.tx
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* only 1 byte left to transmit or 1 FIFO slot left */
id|outw
c_func
(paren
(paren
id|inw
c_func
(paren
id|info-&gt;io_base
op_plus
id|CCAR
)paren
op_amp
l_int|0x0780
)paren
op_or
(paren
id|TDR
op_plus
id|LSBONLY
)paren
comma
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;x_char
)paren
(brace
multiline_comment|/* transmit pending high priority char */
id|outw
c_func
(paren
id|info-&gt;x_char
comma
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
id|info-&gt;x_char
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|outw
c_func
(paren
id|info-&gt;xmit_buf
(braket
id|info-&gt;xmit_tail
op_increment
)braket
comma
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
id|info-&gt;xmit_tail
op_assign
id|info-&gt;xmit_tail
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|info-&gt;xmit_cnt
op_decrement
suffix:semicolon
)brace
id|info-&gt;icount.tx
op_increment
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* end of usc_load_txfifo() */
multiline_comment|/* usc_reset()&n; *&n; *&t;Reset the adapter to a known state and prepare it for further use.&n; *&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|usc_reset
r_void
id|usc_reset
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
(brace
r_int
id|i
suffix:semicolon
id|u32
id|readval
suffix:semicolon
multiline_comment|/* Set BIT30 of Misc Control Register */
multiline_comment|/* (Local Control Register 0x50) to force reset of USC. */
r_volatile
id|u32
op_star
id|MiscCtrl
op_assign
(paren
id|u32
op_star
)paren
(paren
id|info-&gt;lcr_base
op_plus
l_int|0x50
)paren
suffix:semicolon
id|u32
op_star
id|LCR0BRDR
op_assign
(paren
id|u32
op_star
)paren
(paren
id|info-&gt;lcr_base
op_plus
l_int|0x28
)paren
suffix:semicolon
id|info-&gt;misc_ctrl_value
op_or_assign
id|BIT30
suffix:semicolon
op_star
id|MiscCtrl
op_assign
id|info-&gt;misc_ctrl_value
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Force at least 170ns delay before clearing &n;&t;&t; * reset bit. Each read from LCR takes at least &n;&t;&t; * 30ns so 10 times for 300ns to be safe.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|readval
op_assign
op_star
id|MiscCtrl
suffix:semicolon
)brace
id|info-&gt;misc_ctrl_value
op_and_assign
op_complement
id|BIT30
suffix:semicolon
op_star
id|MiscCtrl
op_assign
id|info-&gt;misc_ctrl_value
suffix:semicolon
op_star
id|LCR0BRDR
op_assign
id|BUS_DESCRIPTOR
c_func
(paren
l_int|1
comma
singleline_comment|// Write Strobe Hold (0-3)
l_int|2
comma
singleline_comment|// Write Strobe Delay (0-3)
l_int|2
comma
singleline_comment|// Read Strobe Delay  (0-3)
l_int|0
comma
singleline_comment|// NWDD (Write data-data) (0-3)
l_int|4
comma
singleline_comment|// NWAD (Write Addr-data) (0-31)
l_int|0
comma
singleline_comment|// NXDA (Read/Write Data-Addr) (0-3)
l_int|0
comma
singleline_comment|// NRDD (Read Data-Data) (0-3)
l_int|5
singleline_comment|// NRAD (Read Addr-Data) (0-31)
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* do HW reset */
id|outb
c_func
(paren
l_int|0
comma
id|info-&gt;io_base
op_plus
l_int|8
)paren
suffix:semicolon
)brace
id|info-&gt;mbre_bit
op_assign
l_int|0
suffix:semicolon
id|info-&gt;loopback_bits
op_assign
l_int|0
suffix:semicolon
id|info-&gt;usc_idle_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Program the Bus Configuration Register (BCR)&n;&t; *&n;&t; * &lt;15&gt;&t;&t;0&t;Don&squot;t use seperate address&n;&t; * &lt;14..6&gt;&t;0&t;reserved&n;&t; * &lt;5..4&gt;&t;00&t;IAckmode = Default, don&squot;t care&n;&t; * &lt;3&gt;&t;&t;1&t;Bus Request Totem Pole output&n;&t; * &lt;2&gt;&t;&t;1&t;Use 16 Bit data bus&n;&t; * &lt;1&gt;&t;&t;0&t;IRQ Totem Pole output&n;&t; * &lt;0&gt;&t;&t;0&t;Don&squot;t Shift Right Addr&n;&t; *&n;&t; * 0000 0000 0000 1100 = 0x000c&n;&t; *&n;&t; * By writing to io_base + SDPIN the Wait/Ack pin is&n;&t; * programmed to work as a Wait pin.&n;&t; */
id|outw
c_func
(paren
l_int|0x000c
comma
id|info-&gt;io_base
op_plus
id|SDPIN
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|info-&gt;io_base
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|info-&gt;io_base
op_plus
id|CCAR
)paren
suffix:semicolon
multiline_comment|/* select little endian byte ordering */
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_SelectLittleEndian
)paren
suffix:semicolon
multiline_comment|/* Port Control Register (PCR)&n;&t; *&n;&t; * &lt;15..14&gt;&t;11&t;Port 7 is Output (~DMAEN, Bit 14 : 0 = Enabled)&n;&t; * &lt;13..12&gt;&t;11&t;Port 6 is Output (~INTEN, Bit 12 : 0 = Enabled)&n;&t; * &lt;11..10&gt; &t;00&t;Port 5 is Input (No Connect, Don&squot;t Care)&n;&t; * &lt;9..8&gt; &t;00&t;Port 4 is Input (No Connect, Don&squot;t Care)&n;&t; * &lt;7..6&gt;&t;11&t;Port 3 is Output (~RTS, Bit 6 : 0 = Enabled )&n;&t; * &lt;5..4&gt;&t;11&t;Port 2 is Output (~DTR, Bit 4 : 0 = Enabled )&n;&t; * &lt;3..2&gt;&t;01&t;Port 1 is Input (Dedicated RxC)&n;&t; * &lt;1..0&gt;&t;01&t;Port 0 is Input (Dedicated TxC)&n;&t; *&n;&t; *&t;1111 0000 1111 0101 = 0xf0f5&n;&t; */
id|usc_OutReg
c_func
(paren
id|info
comma
id|PCR
comma
l_int|0xf0f5
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Input/Output Control Register&n;&t; *&n;&t; * &lt;15..14&gt;&t;00&t;CTS is active low input&n;&t; * &lt;13..12&gt;&t;00&t;DCD is active low input&n;&t; * &lt;11..10&gt;&t;00&t;TxREQ pin is input (DSR)&n;&t; * &lt;9..8&gt;&t;00&t;RxREQ pin is input (RI)&n;&t; * &lt;7..6&gt;&t;00&t;TxD is output (Transmit Data)&n;&t; * &lt;5..3&gt;&t;000&t;TxC Pin in Input (14.7456MHz Clock)&n;&t; * &lt;2..0&gt;&t;100&t;RxC is Output (drive with BRG0)&n;&t; *&n;&t; *&t;0000 0000 0000 0100 = 0x0004&n;&t; */
id|usc_OutReg
c_func
(paren
id|info
comma
id|IOCR
comma
l_int|0x0004
)paren
suffix:semicolon
)brace
multiline_comment|/* end of usc_reset() */
multiline_comment|/* usc_set_async_mode()&n; *&n; *&t;Program adapter for asynchronous communications.&n; *&n; * Arguments:&t;&t;info&t;&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|usc_set_async_mode
r_void
id|usc_set_async_mode
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|u16
id|RegValue
suffix:semicolon
multiline_comment|/* disable interrupts while programming USC */
id|usc_DisableMasterIrqBit
c_func
(paren
id|info
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|info-&gt;io_base
)paren
suffix:semicolon
multiline_comment|/* clear Master Bus Enable (DCAR) */
id|usc_DmaCmd
c_func
(paren
id|info
comma
id|DmaCmd_ResetAllChannels
)paren
suffix:semicolon
multiline_comment|/* disable both DMA channels */
id|usc_loopback_frame
c_func
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/* Channel mode Register (CMR)&n;&t; *&n;&t; * &lt;15..14&gt;&t;00&t;Tx Sub modes, 00 = 1 Stop Bit&n;&t; * &lt;13..12&gt;&t;00&t;              00 = 16X Clock&n;&t; * &lt;11..8&gt;&t;0000&t;Transmitter mode = Asynchronous&n;&t; * &lt;7..6&gt;&t;00&t;reserved?&n;&t; * &lt;5..4&gt;&t;00&t;Rx Sub modes, 00 = 16X Clock&n;&t; * &lt;3..0&gt;&t;0000&t;Receiver mode = Asynchronous&n;&t; *&n;&t; * 0000 0000 0000 0000 = 0x0&n;&t; */
id|RegValue
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.stop_bits
op_ne
l_int|1
)paren
id|RegValue
op_or_assign
id|BIT14
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|CMR
comma
id|RegValue
)paren
suffix:semicolon
multiline_comment|/* Receiver mode Register (RMR)&n;&t; *&n;&t; * &lt;15..13&gt;&t;000&t;encoding = None&n;&t; * &lt;12..08&gt;&t;00000&t;reserved (Sync Only)&n;&t; * &lt;7..6&gt;   &t;00&t;Even parity&n;&t; * &lt;5&gt;&t;&t;0&t;parity disabled&n;&t; * &lt;4..2&gt;&t;000&t;Receive Char Length = 8 bits&n;&t; * &lt;1..0&gt;&t;00&t;Disable Receiver&n;&t; *&n;&t; * 0000 0000 0000 0000 = 0x0&n;&t; */
id|RegValue
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.data_bits
op_ne
l_int|8
)paren
id|RegValue
op_or_assign
id|BIT4
op_plus
id|BIT3
op_plus
id|BIT2
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.parity
op_ne
id|ASYNC_PARITY_NONE
)paren
(brace
id|RegValue
op_or_assign
id|BIT5
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.parity
op_ne
id|ASYNC_PARITY_ODD
)paren
id|RegValue
op_or_assign
id|BIT6
suffix:semicolon
)brace
id|usc_OutReg
c_func
(paren
id|info
comma
id|RMR
comma
id|RegValue
)paren
suffix:semicolon
multiline_comment|/* Set IRQ trigger level */
id|usc_RCmd
c_func
(paren
id|info
comma
id|RCmd_SelectRicrIntLevel
)paren
suffix:semicolon
multiline_comment|/* Receive Interrupt Control Register (RICR)&n;&t; *&n;&t; * &lt;15..8&gt;&t;?&t;&t;RxFIFO IRQ Request Level&n;&t; *&n;&t; * Note: For async mode the receive FIFO level must be set&n;&t; * to 0 to aviod the situation where the FIFO contains fewer bytes&n;&t; * than the trigger level and no more data is expected.&n;&t; *&n;&t; * &lt;7&gt;&t;&t;0&t;&t;Exited Hunt IA (Interrupt Arm)&n;&t; * &lt;6&gt;&t;&t;0&t;&t;Idle Received IA&n;&t; * &lt;5&gt;&t;&t;0&t;&t;Break/Abort IA&n;&t; * &lt;4&gt;&t;&t;0&t;&t;Rx Bound IA&n;&t; * &lt;3&gt;&t;&t;0&t;&t;Queued status reflects oldest byte in FIFO&n;&t; * &lt;2&gt;&t;&t;0&t;&t;Abort/PE IA&n;&t; * &lt;1&gt;&t;&t;0&t;&t;Rx Overrun IA&n;&t; * &lt;0&gt;&t;&t;0&t;&t;Select TC0 value for readback&n;&t; *&n;&t; * 0000 0000 0100 0000 = 0x0000 + (FIFOLEVEL in MSB)&n;&t; */
id|usc_OutReg
c_func
(paren
id|info
comma
id|RICR
comma
l_int|0x0000
)paren
suffix:semicolon
id|usc_UnlatchRxstatusBits
c_func
(paren
id|info
comma
id|RXSTATUS_ALL
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|RECEIVE_STATUS
)paren
suffix:semicolon
multiline_comment|/* Transmit mode Register (TMR)&n;&t; *&n;&t; * &lt;15..13&gt;&t;000&t;encoding = None&n;&t; * &lt;12..08&gt;&t;00000&t;reserved (Sync Only)&n;&t; * &lt;7..6&gt;&t;00&t;Transmit parity Even&n;&t; * &lt;5&gt;&t;&t;0&t;Transmit parity Disabled&n;&t; * &lt;4..2&gt;&t;000&t;Tx Char Length = 8 bits&n;&t; * &lt;1..0&gt;&t;00&t;Disable Transmitter&n;&t; *&n;&t; * 0000 0000 0000 0000 = 0x0&n;&t; */
id|RegValue
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.data_bits
op_ne
l_int|8
)paren
id|RegValue
op_or_assign
id|BIT4
op_plus
id|BIT3
op_plus
id|BIT2
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.parity
op_ne
id|ASYNC_PARITY_NONE
)paren
(brace
id|RegValue
op_or_assign
id|BIT5
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.parity
op_ne
id|ASYNC_PARITY_ODD
)paren
id|RegValue
op_or_assign
id|BIT6
suffix:semicolon
)brace
id|usc_OutReg
c_func
(paren
id|info
comma
id|TMR
comma
id|RegValue
)paren
suffix:semicolon
id|usc_set_txidle
c_func
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/* Set IRQ trigger level */
id|usc_TCmd
c_func
(paren
id|info
comma
id|TCmd_SelectTicrIntLevel
)paren
suffix:semicolon
multiline_comment|/* Transmit Interrupt Control Register (TICR)&n;&t; *&n;&t; * &lt;15..8&gt;&t;?&t;Transmit FIFO IRQ Level&n;&t; * &lt;7&gt;&t;&t;0&t;Present IA (Interrupt Arm)&n;&t; * &lt;6&gt;&t;&t;1&t;Idle Sent IA&n;&t; * &lt;5&gt;&t;&t;0&t;Abort Sent IA&n;&t; * &lt;4&gt;&t;&t;0&t;EOF/EOM Sent IA&n;&t; * &lt;3&gt;&t;&t;0&t;CRC Sent IA&n;&t; * &lt;2&gt;&t;&t;0&t;1 = Wait for SW Trigger to Start Frame&n;&t; * &lt;1&gt;&t;&t;0&t;Tx Underrun IA&n;&t; * &lt;0&gt;&t;&t;0&t;TC0 constant on read back&n;&t; *&n;&t; *&t;0000 0000 0100 0000 = 0x0040&n;&t; */
id|usc_OutReg
c_func
(paren
id|info
comma
id|TICR
comma
l_int|0x1f40
)paren
suffix:semicolon
id|usc_UnlatchTxstatusBits
c_func
(paren
id|info
comma
id|TXSTATUS_ALL
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|TRANSMIT_STATUS
)paren
suffix:semicolon
id|usc_enable_async_clock
c_func
(paren
id|info
comma
id|info-&gt;params.data_rate
)paren
suffix:semicolon
multiline_comment|/* Channel Control/status Register (CCSR)&n;&t; *&n;&t; * &lt;15&gt;&t;&t;X&t;RCC FIFO Overflow status (RO)&n;&t; * &lt;14&gt;&t;&t;X&t;RCC FIFO Not Empty status (RO)&n;&t; * &lt;13&gt;&t;&t;0&t;1 = Clear RCC FIFO (WO)&n;&t; * &lt;12&gt;&t;&t;X&t;DPLL in Sync status (RO)&n;&t; * &lt;11&gt;&t;&t;X&t;DPLL 2 Missed Clocks status (RO)&n;&t; * &lt;10&gt;&t;&t;X&t;DPLL 1 Missed Clock status (RO)&n;&t; * &lt;9..8&gt;&t;00&t;DPLL Resync on rising and falling edges (RW)&n;&t; * &lt;7&gt;&t;&t;X&t;SDLC Loop On status (RO)&n;&t; * &lt;6&gt;&t;&t;X&t;SDLC Loop Send status (RO)&n;&t; * &lt;5&gt;&t;&t;1&t;Bypass counters for TxClk and RxClk (RW)&n;&t; * &lt;4..2&gt;   &t;000&t;Last Char of SDLC frame has 8 bits (RW)&n;&t; * &lt;1..0&gt;   &t;00&t;reserved&n;&t; *&n;&t; *&t;0000 0000 0010 0000 = 0x0020&n;&t; */
id|usc_OutReg
c_func
(paren
id|info
comma
id|CCSR
comma
l_int|0x0020
)paren
suffix:semicolon
id|usc_DisableInterrupts
c_func
(paren
id|info
comma
id|TRANSMIT_STATUS
op_plus
id|TRANSMIT_DATA
op_plus
id|RECEIVE_DATA
op_plus
id|RECEIVE_STATUS
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|TRANSMIT_STATUS
op_plus
id|TRANSMIT_DATA
op_plus
id|RECEIVE_DATA
op_plus
id|RECEIVE_STATUS
)paren
suffix:semicolon
id|usc_EnableMasterIrqBit
c_func
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/* Enable INTEN (Port 6, Bit12) */
multiline_comment|/* This connects the IRQ request signal to the ISA bus */
multiline_comment|/* on the ISA adapter. This has no effect for the PCI adapter */
id|usc_OutReg
c_func
(paren
id|info
comma
id|PCR
comma
(paren
id|u16
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|PCR
)paren
op_or
id|BIT13
)paren
op_amp
op_complement
id|BIT12
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* end of usc_set_async_mode() */
multiline_comment|/* usc_loopback_frame()&n; *&n; *&t;Loop back a small (2 byte) dummy SDLC frame.&n; *&t;Interrupts and DMA are NOT used. The purpose of this is to&n; *&t;clear any &squot;stale&squot; status info left over from running in&t;async mode.&n; *&n; *&t;The 16C32 shows the strange behaviour of marking the 1st&n; *&t;received SDLC frame with a CRC error even when there is no&n; *&t;CRC error. To get around this a small dummy from of 2 bytes&n; *&t;is looped back when switching from async to sync mode.&n; *&n; * Arguments:&t;&t;info&t;&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|usc_loopback_frame
r_void
id|usc_loopback_frame
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
id|i
suffix:semicolon
id|usc_DisableMasterIrqBit
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_set_sdlc_mode
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_enable_loopback
c_func
(paren
id|info
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Write 16-bit Time Constant for BRG0 */
id|usc_OutReg
c_func
(paren
id|info
comma
id|TC0R
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Channel Control Register (CCR)&n;&t; *&n;&t; * &lt;15..14&gt;&t;00&t;Don&squot;t use 32-bit Tx Control Blocks (TCBs)&n;&t; * &lt;13&gt;&t;&t;0&t;Trigger Tx on SW Command Disabled&n;&t; * &lt;12&gt;&t;&t;0&t;Flag Preamble Disabled&n;&t; * &lt;11..10&gt;&t;00&t;Preamble Length = 8-Bits&n;&t; * &lt;9..8&gt;&t;01&t;Preamble Pattern = flags&n;&t; * &lt;7..6&gt;&t;10&t;Don&squot;t use 32-bit Rx status Blocks (RSBs)&n;&t; * &lt;5&gt;&t;&t;0&t;Trigger Rx on SW Command Disabled&n;&t; * &lt;4..0&gt;&t;0&t;reserved&n;&t; *&n;&t; *&t;0000 0001 0000 0000 = 0x0100&n;&t; */
id|usc_OutReg
c_func
(paren
id|info
comma
id|CCR
comma
l_int|0x0100
)paren
suffix:semicolon
multiline_comment|/* SETUP RECEIVER */
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_PurgeRxFifo
)paren
suffix:semicolon
id|usc_EnableReceiver
c_func
(paren
id|info
comma
id|ENABLE_UNCONDITIONAL
)paren
suffix:semicolon
multiline_comment|/* SETUP TRANSMITTER */
multiline_comment|/* Program the Transmit Character Length Register (TCLR) */
multiline_comment|/* and clear FIFO (TCC is loaded with TCLR on FIFO clear) */
id|usc_OutReg
c_func
(paren
id|info
comma
id|TCLR
comma
l_int|2
)paren
suffix:semicolon
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_PurgeTxFifo
)paren
suffix:semicolon
multiline_comment|/* unlatch Tx status bits, and start transmit channel. */
id|usc_UnlatchTxstatusBits
c_func
(paren
id|info
comma
id|TXSTATUS_ALL
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0
comma
id|info-&gt;io_base
op_plus
id|DATAREG
)paren
suffix:semicolon
multiline_comment|/* ENABLE TRANSMITTER */
id|usc_TCmd
c_func
(paren
id|info
comma
id|TCmd_SendFrame
)paren
suffix:semicolon
id|usc_EnableTransmitter
c_func
(paren
id|info
comma
id|ENABLE_UNCONDITIONAL
)paren
suffix:semicolon
multiline_comment|/* WAIT FOR RECEIVE COMPLETE */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|RCSR
)paren
op_amp
(paren
id|BIT8
op_plus
id|BIT4
op_plus
id|BIT3
op_plus
id|BIT1
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* clear Internal Data loopback mode */
id|usc_enable_loopback
c_func
(paren
id|info
comma
l_int|0
)paren
suffix:semicolon
id|usc_EnableMasterIrqBit
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/* end of usc_loopback_frame() */
multiline_comment|/* usc_set_sync_mode()&t;Programs the USC for SDLC communications.&n; *&n; * Arguments:&t;&t;info&t;pointer to adapter info structure&n; * Return Value:&t;None&n; */
DECL|function|usc_set_sync_mode
r_void
id|usc_set_sync_mode
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|usc_loopback_frame
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_set_sdlc_mode
c_func
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/* Enable INTEN (Port 6, Bit12) */
multiline_comment|/* This connects the IRQ request signal to the ISA bus */
multiline_comment|/* on the ISA adapter. This has no effect for the PCI adapter */
id|usc_OutReg
c_func
(paren
id|info
comma
id|PCR
comma
(paren
id|u16
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|PCR
)paren
op_or
id|BIT13
)paren
op_amp
op_complement
id|BIT12
)paren
)paren
suffix:semicolon
id|usc_enable_aux_clock
c_func
(paren
id|info
comma
id|info-&gt;params.clock_speed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.loopback
)paren
id|usc_enable_loopback
c_func
(paren
id|info
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_set_sync_mode() */
multiline_comment|/* usc_set_txidle()&t;Set the HDLC idle mode for the transmitter.&n; *&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|usc_set_txidle
r_void
id|usc_set_txidle
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|u16
id|usc_idle_mode
op_assign
id|IDLEMODE_FLAGS
suffix:semicolon
multiline_comment|/* Map API idle mode to USC register bits */
r_switch
c_cond
(paren
id|info-&gt;idle_mode
)paren
(brace
r_case
id|HDLC_TXIDLE_FLAGS
suffix:colon
id|usc_idle_mode
op_assign
id|IDLEMODE_FLAGS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_TXIDLE_ALT_ZEROS_ONES
suffix:colon
id|usc_idle_mode
op_assign
id|IDLEMODE_ALT_ONE_ZERO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_TXIDLE_ZEROS
suffix:colon
id|usc_idle_mode
op_assign
id|IDLEMODE_ZERO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_TXIDLE_ONES
suffix:colon
id|usc_idle_mode
op_assign
id|IDLEMODE_ONE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_TXIDLE_ALT_MARK_SPACE
suffix:colon
id|usc_idle_mode
op_assign
id|IDLEMODE_ALT_MARK_SPACE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_TXIDLE_SPACE
suffix:colon
id|usc_idle_mode
op_assign
id|IDLEMODE_SPACE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDLC_TXIDLE_MARK
suffix:colon
id|usc_idle_mode
op_assign
id|IDLEMODE_MARK
suffix:semicolon
r_break
suffix:semicolon
)brace
id|info-&gt;usc_idle_mode
op_assign
id|usc_idle_mode
suffix:semicolon
singleline_comment|//usc_OutReg(info, TCSR, usc_idle_mode);
id|info-&gt;tcsr_value
op_and_assign
op_complement
id|IDLEMODE_MASK
suffix:semicolon
multiline_comment|/* clear idle mode bits */
id|info-&gt;tcsr_value
op_add_assign
id|usc_idle_mode
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|TCSR
comma
id|info-&gt;tcsr_value
)paren
suffix:semicolon
)brace
multiline_comment|/* end of usc_set_txidle() */
multiline_comment|/* usc_get_serial_signals()&n; *&n; *&t;Query the adapter for the state of the V24 status (input) signals.&n; *&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|usc_get_serial_signals
r_void
id|usc_get_serial_signals
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|u16
id|status
suffix:semicolon
multiline_comment|/* clear all serial signals except DTR and RTS */
id|info-&gt;serial_signals
op_and_assign
id|SerialSignal_DTR
op_plus
id|SerialSignal_RTS
suffix:semicolon
multiline_comment|/* Read the Misc Interrupt status Register (MISR) to get */
multiline_comment|/* the V24 status signals. */
id|status
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|MISR
)paren
suffix:semicolon
multiline_comment|/* set serial signal bits to reflect MISR */
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_CTS
)paren
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_CTS
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_DCD
)paren
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_DCD
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_RI
)paren
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_RI
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|MISCSTATUS_DSR
)paren
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_DSR
suffix:semicolon
)brace
multiline_comment|/* end of usc_get_serial_signals() */
multiline_comment|/* usc_set_serial_signals()&n; *&n; *&t;Set the state of DTR and RTS based on contents of&n; *&t;serial_signals member of device extension.&n; *&t;&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|usc_set_serial_signals
r_void
id|usc_set_serial_signals
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|u16
id|Control
suffix:semicolon
r_int
r_char
id|V24Out
op_assign
id|info-&gt;serial_signals
suffix:semicolon
multiline_comment|/* get the current value of the Port Control Register (PCR) */
id|Control
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|PCR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|V24Out
op_amp
id|SerialSignal_RTS
)paren
id|Control
op_and_assign
op_complement
(paren
id|BIT6
)paren
suffix:semicolon
r_else
id|Control
op_or_assign
id|BIT6
suffix:semicolon
r_if
c_cond
(paren
id|V24Out
op_amp
id|SerialSignal_DTR
)paren
id|Control
op_and_assign
op_complement
(paren
id|BIT4
)paren
suffix:semicolon
r_else
id|Control
op_or_assign
id|BIT4
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|PCR
comma
id|Control
)paren
suffix:semicolon
)brace
multiline_comment|/* end of usc_set_serial_signals() */
multiline_comment|/* usc_enable_async_clock()&n; *&n; *&t;Enable the async clock at the specified frequency.&n; *&n; * Arguments:&t;&t;info&t;&t;pointer to device instance data&n; *&t;&t;&t;data_rate&t;data rate of clock in bps&n; *&t;&t;&t;&t;&t;0 disables the AUX clock.&n; * Return Value:&t;None&n; */
DECL|function|usc_enable_async_clock
r_void
id|usc_enable_async_clock
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
id|u32
id|data_rate
)paren
(brace
r_if
c_cond
(paren
id|data_rate
)paren
(brace
multiline_comment|/*&n;&t;&t; * Clock mode Control Register (CMCR)&n;&t;&t; * &n;&t;&t; * &lt;15..14&gt;     00      counter 1 Disabled&n;&t;&t; * &lt;13..12&gt;     00      counter 0 Disabled&n;&t;&t; * &lt;11..10&gt;     11      BRG1 Input is TxC Pin&n;&t;&t; * &lt;9..8&gt;       11      BRG0 Input is TxC Pin&n;&t;&t; * &lt;7..6&gt;       01      DPLL Input is BRG1 Output&n;&t;&t; * &lt;5..3&gt;       100     TxCLK comes from BRG0&n;&t;&t; * &lt;2..0&gt;       100     RxCLK comes from BRG0&n;&t;&t; *&n;&t;&t; * 0000 1111 0110 0100 = 0x0f64&n;&t;&t; */
id|usc_OutReg
c_func
(paren
id|info
comma
id|CMCR
comma
l_int|0x0f64
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Write 16-bit Time Constant for BRG0&n;&t;&t; * Time Constant = (ClkSpeed / data_rate) - 1&n;&t;&t; * ClkSpeed = 921600 (ISA), 691200 (PCI)&n;&t;&t; */
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
id|usc_OutReg
c_func
(paren
id|info
comma
id|TC0R
comma
(paren
id|u16
)paren
(paren
(paren
l_int|691200
op_div
id|data_rate
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_else
id|usc_OutReg
c_func
(paren
id|info
comma
id|TC0R
comma
(paren
id|u16
)paren
(paren
(paren
l_int|921600
op_div
id|data_rate
)paren
op_minus
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Hardware Configuration Register (HCR)&n;&t;&t; * Clear Bit 1, BRG0 mode = Continuous&n;&t;&t; * Set Bit 0 to enable BRG0.&n;&t;&t; */
id|usc_OutReg
c_func
(paren
id|info
comma
id|HCR
comma
(paren
id|u16
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|HCR
)paren
op_amp
op_complement
id|BIT1
)paren
op_or
id|BIT0
)paren
)paren
suffix:semicolon
multiline_comment|/* Input/Output Control Reg, &lt;2..0&gt; = 100, Drive RxC pin with BRG0 */
id|usc_OutReg
c_func
(paren
id|info
comma
id|IOCR
comma
(paren
id|u16
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|IOCR
)paren
op_amp
l_int|0xfff8
)paren
op_or
l_int|0x0004
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* data rate == 0 so turn off BRG0 */
id|usc_OutReg
c_func
(paren
id|info
comma
id|HCR
comma
(paren
id|u16
)paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|HCR
)paren
op_amp
op_complement
id|BIT0
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* end of usc_enable_async_clock() */
multiline_comment|/*&n; * Buffer Structures:&n; *&n; * Normal memory access uses virtual addresses that can make discontiguous&n; * physical memory pages appear to be contiguous in the virtual address&n; * space (the processors memory mapping handles the conversions).&n; *&n; * DMA transfers require physically contiguous memory. This is because&n; * the DMA system controller and DMA bus masters deal with memory using&n; * only physical addresses.&n; *&n; * This causes a problem under Windows NT when large DMA buffers are&n; * needed. Fragmentation of the nonpaged pool prevents allocations of&n; * physically contiguous buffers larger than the PAGE_SIZE.&n; *&n; * However the 16C32 supports Bus Master Scatter/Gather DMA which&n; * allows DMA transfers to physically discontiguous buffers. Information&n; * about each data transfer buffer is contained in a memory structure&n; * called a &squot;buffer entry&squot;. A list of buffer entries is maintained&n; * to track and control the use of the data transfer buffers.&n; *&n; * To support this strategy we will allocate sufficient PAGE_SIZE&n; * contiguous memory buffers to allow for the total required buffer&n; * space.&n; *&n; * The 16C32 accesses the list of buffer entries using Bus Master&n; * DMA. Control information is read from the buffer entries by the&n; * 16C32 to control data transfers. status information is written to&n; * the buffer entries by the 16C32 to indicate the status of completed&n; * transfers.&n; *&n; * The CPU writes control information to the buffer entries to control&n; * the 16C32 and reads status information from the buffer entries to&n; * determine information about received and transmitted frames.&n; *&n; * Because the CPU and 16C32 (adapter) both need simultaneous access&n; * to the buffer entries, the buffer entry memory is allocated with&n; * HalAllocateCommonBuffer(). This restricts the size of the buffer&n; * entry list to PAGE_SIZE.&n; *&n; * The actual data buffers on the other hand will only be accessed&n; * by the CPU or the adapter but not by both simultaneously. This allows&n; * Scatter/Gather packet based DMA procedures for using physically&n; * discontiguous pages.&n; */
multiline_comment|/*&n; * mgsl_reset_rx_dma_buffers()&n; * &n; * &t;Set the count for all receive buffers to DMABUFFERSIZE&n; * &t;and set the current buffer to the first buffer. This effectively&n; * &t;makes all buffers free and discards any data in buffers.&n; * &n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|mgsl_reset_rx_dma_buffers
r_void
id|mgsl_reset_rx_dma_buffers
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|info-&gt;rx_buffer_count
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|info-&gt;rx_buffer_list
(braket
id|i
)braket
dot
id|count
)paren
)paren
op_assign
id|DMABUFFERSIZE
suffix:semicolon
singleline_comment|//&t;&t;info-&gt;rx_buffer_list[i].count = DMABUFFERSIZE;
singleline_comment|//&t;&t;info-&gt;rx_buffer_list[i].status = 0;
)brace
id|info-&gt;current_rx_buffer
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_reset_rx_dma_buffers() */
multiline_comment|/*&n; * mgsl_free_rx_frame_buffers()&n; * &n; * &t;Free the receive buffers used by a received SDLC&n; * &t;frame such that the buffers can be reused.&n; * &n; * Arguments:&n; * &n; * &t;info&t;&t;&t;pointer to device instance data&n; * &t;StartIndex&t;&t;index of 1st receive buffer of frame&n; * &t;EndIndex&t;&t;index of last receive buffer of frame&n; * &n; * Return Value:&t;None&n; */
DECL|function|mgsl_free_rx_frame_buffers
r_void
id|mgsl_free_rx_frame_buffers
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_int
r_int
id|StartIndex
comma
r_int
r_int
id|EndIndex
)paren
(brace
r_int
id|Done
op_assign
l_int|0
suffix:semicolon
id|DMABUFFERENTRY
op_star
id|pBufEntry
suffix:semicolon
r_int
r_int
id|Index
suffix:semicolon
multiline_comment|/* Starting with 1st buffer entry of the frame clear the status */
multiline_comment|/* field and set the count field to DMA Buffer Size. */
id|Index
op_assign
id|StartIndex
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|Done
)paren
(brace
id|pBufEntry
op_assign
op_amp
(paren
id|info-&gt;rx_buffer_list
(braket
id|Index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Index
op_eq
id|EndIndex
)paren
(brace
multiline_comment|/* This is the last buffer of the frame! */
id|Done
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* reset current buffer for reuse */
singleline_comment|//&t;&t;pBufEntry-&gt;status = 0;
singleline_comment|//&t;&t;pBufEntry-&gt;count = DMABUFFERSIZE;
op_star
(paren
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|pBufEntry-&gt;count
)paren
)paren
op_assign
id|DMABUFFERSIZE
suffix:semicolon
multiline_comment|/* advance to next buffer entry in linked list */
id|Index
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|Index
op_eq
id|info-&gt;rx_buffer_count
)paren
id|Index
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set current buffer to next buffer after last buffer of frame */
id|info-&gt;current_rx_buffer
op_assign
id|Index
suffix:semicolon
)brace
multiline_comment|/* end of free_rx_frame_buffers() */
multiline_comment|/* mgsl_get_rx_frame()&n; * &n; * &t;This function attempts to return a received SDLC frame from the&n; * &t;receive DMA buffers. Only frames received without errors are returned.&n; *&n; * Arguments:&t; &t;info&t;pointer to device extension&n; * Return Value:&t;1 if frame returned, otherwise 0&n; */
DECL|function|mgsl_get_rx_frame
r_int
id|mgsl_get_rx_frame
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
r_int
id|StartIndex
comma
id|EndIndex
suffix:semicolon
multiline_comment|/* index of 1st and last buffers of Rx frame */
r_int
r_int
id|status
suffix:semicolon
id|DMABUFFERENTRY
op_star
id|pBufEntry
suffix:semicolon
r_int
r_int
id|framesize
suffix:semicolon
r_int
id|ReturnCode
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
multiline_comment|/*&n;&t; * current_rx_buffer points to the 1st buffer of the next available&n;&t; * receive frame. To find the last buffer of the frame look for&n;&t; * a non-zero status field in the buffer entries. (The status&n;&t; * field is set by the 16C32 after completing a receive frame.&n;&t; */
id|StartIndex
op_assign
id|EndIndex
op_assign
id|info-&gt;current_rx_buffer
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|info-&gt;rx_buffer_list
(braket
id|EndIndex
)braket
dot
id|status
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the count field of the buffer entry is non-zero then&n;&t;&t; * this buffer has not been used. (The 16C32 clears the count&n;&t;&t; * field when it starts using the buffer.) If an unused buffer&n;&t;&t; * is encountered then there are no frames available.&n;&t;&t; */
r_if
c_cond
(paren
id|info-&gt;rx_buffer_list
(braket
id|EndIndex
)braket
dot
id|count
)paren
r_goto
id|Cleanup
suffix:semicolon
multiline_comment|/* advance to next buffer entry in linked list */
id|EndIndex
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|EndIndex
op_eq
id|info-&gt;rx_buffer_count
)paren
id|EndIndex
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* if entire list searched then no frame available */
r_if
c_cond
(paren
id|EndIndex
op_eq
id|StartIndex
)paren
(brace
multiline_comment|/* If this occurs then something bad happened,&n;&t;&t;&t; * all buffers have been &squot;used&squot; but none mark&n;&t;&t;&t; * the end of a frame. Reset buffers and receiver.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|info-&gt;rx_enabled
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_start_receiver
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
r_goto
id|Cleanup
suffix:semicolon
)brace
)brace
multiline_comment|/* check status of receive frame */
id|status
op_assign
id|info-&gt;rx_buffer_list
(braket
id|EndIndex
)braket
dot
id|status
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|RXSTATUS_SHORT_FRAME
op_plus
id|RXSTATUS_OVERRUN
op_plus
id|RXSTATUS_CRC_ERROR
op_plus
id|RXSTATUS_ABORT
)paren
)paren
(brace
r_if
c_cond
(paren
id|status
op_amp
id|RXSTATUS_SHORT_FRAME
)paren
id|info-&gt;icount.rxshort
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
op_amp
id|RXSTATUS_ABORT
)paren
id|info-&gt;icount.rxabort
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|status
op_amp
id|RXSTATUS_OVERRUN
)paren
id|info-&gt;icount.rxover
op_increment
suffix:semicolon
r_else
id|info-&gt;icount.rxcrc
op_increment
suffix:semicolon
id|framesize
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_SYNCLINK_SYNCPPP
id|info-&gt;netstats.rx_errors
op_increment
suffix:semicolon
id|info-&gt;netstats.rx_frame_errors
op_increment
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* receive frame has no errors, get frame size.&n;&t;&t; * The frame size is the starting value of the RCC (which was&n;&t;&t; * set to 0xffff) minus the ending value of the RCC (decremented&n;&t;&t; * once for each receive character) minus 2 for the 16-bit CRC.&n;&t;&t; */
id|framesize
op_assign
id|RCLRVALUE
op_minus
id|info-&gt;rx_buffer_list
(braket
id|EndIndex
)braket
dot
id|rcc
suffix:semicolon
multiline_comment|/* adjust frame size for CRC if any */
r_if
c_cond
(paren
id|info-&gt;params.crc_type
op_eq
id|HDLC_CRC_16_CCITT
)paren
id|framesize
op_sub_assign
l_int|2
suffix:semicolon
r_else
r_if
c_cond
(paren
id|info-&gt;params.crc_type
op_eq
id|HDLC_CRC_32_CCITT
)paren
id|framesize
op_sub_assign
l_int|4
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_BH
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_get_rx_frame(%s) status=%04X size=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
id|status
comma
id|framesize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_DATA
)paren
id|mgsl_trace_block
c_func
(paren
id|info
comma
id|info-&gt;rx_buffer_list
(braket
id|StartIndex
)braket
dot
id|virt_addr
comma
id|MIN
c_func
(paren
id|framesize
comma
id|DMABUFFERSIZE
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|framesize
)paren
(brace
r_if
c_cond
(paren
id|framesize
OG
id|info-&gt;max_frame_size
)paren
id|info-&gt;icount.rxlong
op_increment
suffix:semicolon
r_else
(brace
multiline_comment|/* copy dma buffer(s) to contiguous intermediate buffer */
r_int
id|copy_count
op_assign
id|framesize
suffix:semicolon
r_int
id|index
op_assign
id|StartIndex
suffix:semicolon
r_int
r_char
op_star
id|ptmp
op_assign
id|info-&gt;intermediate_rxbuffer
suffix:semicolon
id|info-&gt;icount.rxok
op_increment
suffix:semicolon
r_while
c_loop
(paren
id|copy_count
)paren
(brace
r_int
id|partial_count
suffix:semicolon
r_if
c_cond
(paren
id|copy_count
OG
id|DMABUFFERSIZE
)paren
id|partial_count
op_assign
id|DMABUFFERSIZE
suffix:semicolon
r_else
id|partial_count
op_assign
id|copy_count
suffix:semicolon
id|pBufEntry
op_assign
op_amp
(paren
id|info-&gt;rx_buffer_list
(braket
id|index
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|ptmp
comma
id|pBufEntry-&gt;virt_addr
comma
id|partial_count
)paren
suffix:semicolon
id|ptmp
op_add_assign
id|partial_count
suffix:semicolon
id|copy_count
op_sub_assign
id|partial_count
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|index
op_eq
id|info-&gt;rx_buffer_count
)paren
id|index
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SYNCLINK_SYNCPPP
r_if
c_cond
(paren
id|info-&gt;netcount
)paren
(brace
multiline_comment|/* pass frame to syncppp device */
id|mgsl_sppp_rx_done
c_func
(paren
id|info
comma
id|info-&gt;intermediate_rxbuffer
comma
id|framesize
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
(brace
multiline_comment|/* Call the line discipline receive callback directly. */
id|tty-&gt;ldisc
dot
id|receive_buf
c_func
(paren
id|tty
comma
id|info-&gt;intermediate_rxbuffer
comma
id|info-&gt;flag_buf
comma
id|framesize
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Free the buffers used by this frame. */
id|mgsl_free_rx_frame_buffers
c_func
(paren
id|info
comma
id|StartIndex
comma
id|EndIndex
)paren
suffix:semicolon
id|ReturnCode
op_assign
l_int|1
suffix:semicolon
id|Cleanup
suffix:colon
r_if
c_cond
(paren
id|info-&gt;rx_enabled
op_logical_and
id|info-&gt;rx_overflow
)paren
(brace
multiline_comment|/* The receiver needs to restarted because of &n;&t;&t; * a receive overflow (buffer or FIFO). If the &n;&t;&t; * receive buffers are now empty, then restart receiver.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;rx_buffer_list
(braket
id|EndIndex
)braket
dot
id|status
op_logical_and
id|info-&gt;rx_buffer_list
(braket
id|EndIndex
)braket
dot
id|count
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_start_receiver
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_return
id|ReturnCode
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_get_rx_frame() */
multiline_comment|/* mgsl_load_tx_dma_buffer()&n; * &n; * &t;Load the transmit DMA buffer with the specified data.&n; * &n; * Arguments:&n; * &n; * &t;info&t;&t;pointer to device extension&n; * &t;Buffer&t;&t;pointer to buffer containing frame to load&n; * &t;BufferSize&t;size in bytes of frame in Buffer&n; * &n; * Return Value: &t;None&n; */
DECL|function|mgsl_load_tx_dma_buffer
r_void
id|mgsl_load_tx_dma_buffer
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_const
r_char
op_star
id|Buffer
comma
r_int
r_int
id|BufferSize
)paren
(brace
r_int
r_int
id|Copycount
suffix:semicolon
r_int
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|DMABUFFERENTRY
op_star
id|pBufEntry
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_DATA
)paren
id|mgsl_trace_block
c_func
(paren
id|info
comma
id|Buffer
comma
id|MIN
c_func
(paren
id|BufferSize
comma
id|DMABUFFERSIZE
)paren
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_HDLC_LOOPMODE
)paren
(brace
multiline_comment|/* set CMR:13 to start transmit when&n;&t;&t; * next GoAhead (abort) is received&n;&t;&t; */
id|info-&gt;cmr_value
op_or_assign
id|BIT13
suffix:semicolon
)brace
multiline_comment|/* Setup the status and RCC (Frame Size) fields of the 1st */
multiline_comment|/* buffer entry in the transmit DMA buffer list. */
id|info-&gt;tx_buffer_list
(braket
l_int|0
)braket
dot
id|status
op_assign
id|info-&gt;cmr_value
op_amp
l_int|0xf000
suffix:semicolon
id|info-&gt;tx_buffer_list
(braket
l_int|0
)braket
dot
id|rcc
op_assign
id|BufferSize
suffix:semicolon
id|info-&gt;tx_buffer_list
(braket
l_int|0
)braket
dot
id|count
op_assign
id|BufferSize
suffix:semicolon
multiline_comment|/* Copy frame data from 1st source buffer to the DMA buffers. */
multiline_comment|/* The frame data may span multiple DMA buffers. */
r_while
c_loop
(paren
id|BufferSize
)paren
(brace
multiline_comment|/* Get a pointer to next DMA buffer entry. */
id|pBufEntry
op_assign
op_amp
id|info-&gt;tx_buffer_list
(braket
id|i
op_increment
)braket
suffix:semicolon
multiline_comment|/* Calculate the number of bytes that can be copied from */
multiline_comment|/* the source buffer to this DMA buffer. */
r_if
c_cond
(paren
id|BufferSize
OG
id|DMABUFFERSIZE
)paren
id|Copycount
op_assign
id|DMABUFFERSIZE
suffix:semicolon
r_else
id|Copycount
op_assign
id|BufferSize
suffix:semicolon
multiline_comment|/* Actually copy data from source buffer to DMA buffer. */
multiline_comment|/* Also set the data count for this individual DMA buffer. */
r_if
c_cond
(paren
id|info-&gt;bus_type
op_eq
id|MGSL_BUS_TYPE_PCI
)paren
id|mgsl_load_pci_memory
c_func
(paren
id|pBufEntry-&gt;virt_addr
comma
id|Buffer
comma
id|Copycount
)paren
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|pBufEntry-&gt;virt_addr
comma
id|Buffer
comma
id|Copycount
)paren
suffix:semicolon
id|pBufEntry-&gt;count
op_assign
id|Copycount
suffix:semicolon
multiline_comment|/* Advance source pointer and reduce remaining data count. */
id|Buffer
op_add_assign
id|Copycount
suffix:semicolon
id|BufferSize
op_sub_assign
id|Copycount
suffix:semicolon
)brace
)brace
multiline_comment|/* end of mgsl_load_tx_dma_buffer() */
multiline_comment|/*&n; * mgsl_register_test()&n; * &n; * &t;Performs a register test of the 16C32.&n; * &t;&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;&t;TRUE if test passed, otherwise FALSE&n; */
DECL|function|mgsl_register_test
id|BOOLEAN
id|mgsl_register_test
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_static
r_int
r_int
id|BitPatterns
(braket
)braket
op_assign
(brace
l_int|0x0000
comma
l_int|0xffff
comma
l_int|0xaaaa
comma
l_int|0x5555
comma
l_int|0x1234
comma
l_int|0x6969
comma
l_int|0x9696
comma
l_int|0x0f0f
)brace
suffix:semicolon
r_static
r_int
r_int
id|Patterncount
op_assign
r_sizeof
(paren
id|BitPatterns
)paren
op_div
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|BOOLEAN
id|rc
op_assign
id|TRUE
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_reset
c_func
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/* Verify the reset state of some registers. */
r_if
c_cond
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|SICR
)paren
op_ne
l_int|0
)paren
op_logical_or
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|IVR
)paren
op_ne
l_int|0
)paren
op_logical_or
(paren
id|usc_InDmaReg
c_func
(paren
id|info
comma
id|DIVR
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|rc
op_assign
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
op_eq
id|TRUE
)paren
(brace
multiline_comment|/* Write bit patterns to various registers but do it out of */
multiline_comment|/* sync, then read back and verify values. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|Patterncount
suffix:semicolon
id|i
op_increment
)paren
(brace
id|usc_OutReg
c_func
(paren
id|info
comma
id|TC0R
comma
id|BitPatterns
(braket
id|i
)braket
)paren
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|TC1R
comma
id|BitPatterns
(braket
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|Patterncount
)braket
)paren
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|TCLR
comma
id|BitPatterns
(braket
(paren
id|i
op_plus
l_int|2
)paren
op_mod
id|Patterncount
)braket
)paren
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|RCLR
comma
id|BitPatterns
(braket
(paren
id|i
op_plus
l_int|3
)paren
op_mod
id|Patterncount
)braket
)paren
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|RSR
comma
id|BitPatterns
(braket
(paren
id|i
op_plus
l_int|4
)paren
op_mod
id|Patterncount
)braket
)paren
suffix:semicolon
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|TBCR
comma
id|BitPatterns
(braket
(paren
id|i
op_plus
l_int|5
)paren
op_mod
id|Patterncount
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|TC0R
)paren
op_ne
id|BitPatterns
(braket
id|i
)braket
)paren
op_logical_or
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|TC1R
)paren
op_ne
id|BitPatterns
(braket
(paren
id|i
op_plus
l_int|1
)paren
op_mod
id|Patterncount
)braket
)paren
op_logical_or
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|TCLR
)paren
op_ne
id|BitPatterns
(braket
(paren
id|i
op_plus
l_int|2
)paren
op_mod
id|Patterncount
)braket
)paren
op_logical_or
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|RCLR
)paren
op_ne
id|BitPatterns
(braket
(paren
id|i
op_plus
l_int|3
)paren
op_mod
id|Patterncount
)braket
)paren
op_logical_or
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|RSR
)paren
op_ne
id|BitPatterns
(braket
(paren
id|i
op_plus
l_int|4
)paren
op_mod
id|Patterncount
)braket
)paren
op_logical_or
(paren
id|usc_InDmaReg
c_func
(paren
id|info
comma
id|TBCR
)paren
op_ne
id|BitPatterns
(braket
(paren
id|i
op_plus
l_int|5
)paren
op_mod
id|Patterncount
)braket
)paren
)paren
(brace
id|rc
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|usc_reset
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_register_test() */
multiline_comment|/* mgsl_irq_test() &t;Perform interrupt test of the 16C32.&n; * &n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;TRUE if test passed, otherwise FALSE&n; */
DECL|function|mgsl_irq_test
id|BOOLEAN
id|mgsl_irq_test
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
r_int
id|EndTime
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_reset
c_func
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Setup 16C32 to interrupt on TxC pin (14MHz clock) transition. &n;&t; * The ISR sets irq_occurred to 1. &n;&t; */
id|info-&gt;irq_occurred
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* Enable INTEN gate for ISA adapter (Port 6, Bit12) */
multiline_comment|/* Enable INTEN (Port 6, Bit12) */
multiline_comment|/* This connects the IRQ request signal to the ISA bus */
multiline_comment|/* on the ISA adapter. This has no effect for the PCI adapter */
id|usc_OutReg
c_func
(paren
id|info
comma
id|PCR
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|PCR
)paren
op_or
id|BIT13
)paren
op_amp
op_complement
id|BIT12
)paren
)paren
suffix:semicolon
id|usc_EnableMasterIrqBit
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_EnableInterrupts
c_func
(paren
id|info
comma
id|IO_PIN
)paren
suffix:semicolon
id|usc_ClearIrqPendingBits
c_func
(paren
id|info
comma
id|IO_PIN
)paren
suffix:semicolon
id|usc_UnlatchIostatusBits
c_func
(paren
id|info
comma
id|MISCSTATUS_TXC_LATCHED
)paren
suffix:semicolon
id|usc_EnableStatusIrqs
c_func
(paren
id|info
comma
id|SICR_TXC_ACTIVE
op_plus
id|SICR_TXC_INACTIVE
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|EndTime
op_assign
l_int|100
suffix:semicolon
r_while
c_loop
(paren
id|EndTime
op_decrement
op_logical_and
op_logical_neg
id|info-&gt;irq_occurred
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|jiffies_from_ms
c_func
(paren
l_int|10
)paren
)paren
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_reset
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;irq_occurred
)paren
r_return
id|FALSE
suffix:semicolon
r_else
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_irq_test() */
multiline_comment|/* mgsl_dma_test()&n; * &n; * &t;Perform a DMA test of the 16C32. A small frame is&n; * &t;transmitted via DMA from a transmit buffer to a receive buffer&n; * &t;using single buffer DMA mode.&n; * &t;&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;TRUE if test passed, otherwise FALSE&n; */
DECL|function|mgsl_dma_test
id|BOOLEAN
id|mgsl_dma_test
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
r_int
id|FifoLevel
suffix:semicolon
r_int
r_int
id|phys_addr
suffix:semicolon
r_int
r_int
id|FrameSize
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_char
op_star
id|TmpPtr
suffix:semicolon
id|BOOLEAN
id|rc
op_assign
id|TRUE
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
r_int
r_int
id|EndTime
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|MGSL_PARAMS
id|tmp_params
suffix:semicolon
multiline_comment|/* save current port options */
id|memcpy
c_func
(paren
op_amp
id|tmp_params
comma
op_amp
id|info-&gt;params
comma
r_sizeof
(paren
id|MGSL_PARAMS
)paren
)paren
suffix:semicolon
multiline_comment|/* load default port options */
id|memcpy
c_func
(paren
op_amp
id|info-&gt;params
comma
op_amp
id|default_params
comma
r_sizeof
(paren
id|MGSL_PARAMS
)paren
)paren
suffix:semicolon
DECL|macro|TESTFRAMESIZE
mdefine_line|#define TESTFRAMESIZE 40
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* setup 16C32 for SDLC DMA transfer mode */
id|usc_reset
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_set_sdlc_mode
c_func
(paren
id|info
)paren
suffix:semicolon
id|usc_enable_loopback
c_func
(paren
id|info
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Reprogram the RDMR so that the 16C32 does NOT clear the count&n;&t; * field of the buffer entry after fetching buffer address. This&n;&t; * way we can detect a DMA failure for a DMA read (which should be&n;&t; * non-destructive to system memory) before we try and write to&n;&t; * memory (where a failure could corrupt system memory).&n;&t; */
multiline_comment|/* Receive DMA mode Register (RDMR)&n;&t; * &n;&t; * &lt;15..14&gt;&t;11&t;DMA mode = Linked List Buffer mode&n;&t; * &lt;13&gt;&t;&t;1&t;RSBinA/L = store Rx status Block in List entry&n;&t; * &lt;12&gt;&t;&t;0&t;1 = Clear count of List Entry after fetching&n;&t; * &lt;11..10&gt;&t;00&t;Address mode = Increment&n;&t; * &lt;9&gt;&t;&t;1&t;Terminate Buffer on RxBound&n;&t; * &lt;8&gt;&t;&t;0&t;Bus Width = 16bits&n;&t; * &lt;7..0&gt;&t;&t;?&t;status Bits (write as 0s)&n;&t; * &n;&t; * 1110 0010 0000 0000 = 0xe200&n;&t; */
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|RDMR
comma
l_int|0xe200
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* SETUP TRANSMIT AND RECEIVE DMA BUFFERS */
id|FrameSize
op_assign
id|TESTFRAMESIZE
suffix:semicolon
multiline_comment|/* setup 1st transmit buffer entry: */
multiline_comment|/* with frame size and transmit control word */
id|info-&gt;tx_buffer_list
(braket
l_int|0
)braket
dot
id|count
op_assign
id|FrameSize
suffix:semicolon
id|info-&gt;tx_buffer_list
(braket
l_int|0
)braket
dot
id|rcc
op_assign
id|FrameSize
suffix:semicolon
id|info-&gt;tx_buffer_list
(braket
l_int|0
)braket
dot
id|status
op_assign
l_int|0x4000
suffix:semicolon
multiline_comment|/* build a transmit frame in 1st transmit DMA buffer */
id|TmpPtr
op_assign
id|info-&gt;tx_buffer_list
(braket
l_int|0
)braket
dot
id|virt_addr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FrameSize
suffix:semicolon
id|i
op_increment
)paren
op_star
id|TmpPtr
op_increment
op_assign
id|i
suffix:semicolon
multiline_comment|/* setup 1st receive buffer entry: */
multiline_comment|/* clear status, set max receive buffer size */
id|info-&gt;rx_buffer_list
(braket
l_int|0
)braket
dot
id|status
op_assign
l_int|0
suffix:semicolon
id|info-&gt;rx_buffer_list
(braket
l_int|0
)braket
dot
id|count
op_assign
id|FrameSize
op_plus
l_int|4
suffix:semicolon
multiline_comment|/* zero out the 1st receive buffer */
id|memset
c_func
(paren
id|info-&gt;rx_buffer_list
(braket
l_int|0
)braket
dot
id|virt_addr
comma
l_int|0
comma
id|FrameSize
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Set count field of next buffer entries to prevent */
multiline_comment|/* 16C32 from using buffers after the 1st one. */
id|info-&gt;tx_buffer_list
(braket
l_int|1
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
id|info-&gt;rx_buffer_list
(braket
l_int|1
)braket
dot
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/***************************/
multiline_comment|/* Program 16C32 receiver. */
multiline_comment|/***************************/
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* setup DMA transfers */
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_PurgeRxFifo
)paren
suffix:semicolon
multiline_comment|/* program 16C32 receiver with physical address of 1st DMA buffer entry */
id|phys_addr
op_assign
id|info-&gt;rx_buffer_list
(braket
l_int|0
)braket
dot
id|phys_entry
suffix:semicolon
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|NRARL
comma
(paren
r_int
r_int
)paren
id|phys_addr
)paren
suffix:semicolon
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|NRARU
comma
(paren
r_int
r_int
)paren
(paren
id|phys_addr
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
multiline_comment|/* Clear the Rx DMA status bits (read RDMR) and start channel */
id|usc_InDmaReg
c_func
(paren
id|info
comma
id|RDMR
)paren
suffix:semicolon
id|usc_DmaCmd
c_func
(paren
id|info
comma
id|DmaCmd_InitRxChannel
)paren
suffix:semicolon
multiline_comment|/* Enable Receiver (RMR &lt;1..0&gt; = 10) */
id|usc_OutReg
c_func
(paren
id|info
comma
id|RMR
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|RMR
)paren
op_amp
l_int|0xfffc
)paren
op_or
l_int|0x0002
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*************************************************************/
multiline_comment|/* WAIT FOR RECEIVER TO DMA ALL PARAMETERS FROM BUFFER ENTRY */
multiline_comment|/*************************************************************/
multiline_comment|/* Wait 100ms for interrupt. */
id|EndTime
op_assign
id|jiffies
op_plus
id|jiffies_from_ms
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|jiffies
OG
id|EndTime
)paren
(brace
id|rc
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|status
op_assign
id|usc_InDmaReg
c_func
(paren
id|info
comma
id|RDMR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|BIT4
)paren
op_logical_and
(paren
id|status
op_amp
id|BIT5
)paren
)paren
(brace
multiline_comment|/* INITG (BIT 4) is inactive (no entry read in progress) AND */
multiline_comment|/* BUSY  (BIT 5) is active (channel still active). */
multiline_comment|/* This means the buffer entry read has completed. */
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/******************************/
multiline_comment|/* Program 16C32 transmitter. */
multiline_comment|/******************************/
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Program the Transmit Character Length Register (TCLR) */
multiline_comment|/* and clear FIFO (TCC is loaded with TCLR on FIFO clear) */
id|usc_OutReg
c_func
(paren
id|info
comma
id|TCLR
comma
(paren
r_int
r_int
)paren
id|info-&gt;tx_buffer_list
(braket
l_int|0
)braket
dot
id|count
)paren
suffix:semicolon
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_PurgeTxFifo
)paren
suffix:semicolon
multiline_comment|/* Program the address of the 1st DMA Buffer Entry in linked list */
id|phys_addr
op_assign
id|info-&gt;tx_buffer_list
(braket
l_int|0
)braket
dot
id|phys_entry
suffix:semicolon
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|NTARL
comma
(paren
r_int
r_int
)paren
id|phys_addr
)paren
suffix:semicolon
id|usc_OutDmaReg
c_func
(paren
id|info
comma
id|NTARU
comma
(paren
r_int
r_int
)paren
(paren
id|phys_addr
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
multiline_comment|/* unlatch Tx status bits, and start transmit channel. */
id|usc_OutReg
c_func
(paren
id|info
comma
id|TCSR
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|TCSR
)paren
op_amp
l_int|0x0f00
)paren
op_or
l_int|0xfa
)paren
)paren
suffix:semicolon
id|usc_DmaCmd
c_func
(paren
id|info
comma
id|DmaCmd_InitTxChannel
)paren
suffix:semicolon
multiline_comment|/* wait for DMA controller to fill transmit FIFO */
id|usc_TCmd
c_func
(paren
id|info
comma
id|TCmd_SelectTicrTxFifostatus
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/**********************************/
multiline_comment|/* WAIT FOR TRANSMIT FIFO TO FILL */
multiline_comment|/**********************************/
multiline_comment|/* Wait 100ms */
id|EndTime
op_assign
id|jiffies
op_plus
id|jiffies_from_ms
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|jiffies
OG
id|EndTime
)paren
(brace
id|rc
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|FifoLevel
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|TICR
)paren
op_rshift
l_int|8
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FifoLevel
OL
l_int|16
)paren
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
id|FrameSize
OL
l_int|32
)paren
(brace
multiline_comment|/* This frame is smaller than the entire transmit FIFO */
multiline_comment|/* so wait for the entire frame to be loaded. */
r_if
c_cond
(paren
id|FifoLevel
op_le
(paren
l_int|32
op_minus
id|FrameSize
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rc
op_eq
id|TRUE
)paren
(brace
multiline_comment|/* Enable 16C32 transmitter. */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Transmit mode Register (TMR), &lt;1..0&gt; = 10, Enable Transmitter */
id|usc_TCmd
c_func
(paren
id|info
comma
id|TCmd_SendFrame
)paren
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|TMR
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|TMR
)paren
op_amp
l_int|0xfffc
)paren
op_or
l_int|0x0002
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/******************************/
multiline_comment|/* WAIT FOR TRANSMIT COMPLETE */
multiline_comment|/******************************/
multiline_comment|/* Wait 100ms */
id|EndTime
op_assign
id|jiffies
op_plus
id|jiffies_from_ms
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* While timer not expired wait for transmit complete */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|status
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|TCSR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|status
op_amp
(paren
id|BIT6
op_plus
id|BIT5
op_plus
id|BIT4
op_plus
id|BIT2
op_plus
id|BIT1
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|jiffies
OG
id|EndTime
)paren
(brace
id|rc
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|status
op_assign
id|usc_InReg
c_func
(paren
id|info
comma
id|TCSR
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rc
op_eq
id|TRUE
)paren
(brace
multiline_comment|/* CHECK FOR TRANSMIT ERRORS */
r_if
c_cond
(paren
id|status
op_amp
(paren
id|BIT5
op_plus
id|BIT1
)paren
)paren
id|rc
op_assign
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rc
op_eq
id|TRUE
)paren
(brace
multiline_comment|/* WAIT FOR RECEIVE COMPLETE */
multiline_comment|/* Wait 100ms */
id|EndTime
op_assign
id|jiffies
op_plus
id|jiffies_from_ms
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Wait for 16C32 to write receive status to buffer entry. */
id|status
op_assign
id|info-&gt;rx_buffer_list
(braket
l_int|0
)braket
dot
id|status
suffix:semicolon
r_while
c_loop
(paren
id|status
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|jiffies
OG
id|EndTime
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;mark 4&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
id|FALSE
suffix:semicolon
r_break
suffix:semicolon
)brace
id|status
op_assign
id|info-&gt;rx_buffer_list
(braket
l_int|0
)braket
dot
id|status
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rc
op_eq
id|TRUE
)paren
(brace
multiline_comment|/* CHECK FOR RECEIVE ERRORS */
id|status
op_assign
id|info-&gt;rx_buffer_list
(braket
l_int|0
)braket
dot
id|status
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
(paren
id|BIT8
op_plus
id|BIT3
op_plus
id|BIT1
)paren
)paren
(brace
multiline_comment|/* receive error has occured */
id|rc
op_assign
id|FALSE
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|info-&gt;tx_buffer_list
(braket
l_int|0
)braket
dot
id|virt_addr
comma
id|info-&gt;rx_buffer_list
(braket
l_int|0
)braket
dot
id|virt_addr
comma
id|FrameSize
)paren
)paren
(brace
id|rc
op_assign
id|FALSE
suffix:semicolon
)brace
)brace
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_reset
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* restore current port options */
id|memcpy
c_func
(paren
op_amp
id|info-&gt;params
comma
op_amp
id|tmp_params
comma
r_sizeof
(paren
id|MGSL_PARAMS
)paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_dma_test() */
multiline_comment|/* mgsl_adapter_test()&n; * &n; * &t;Perform the register, IRQ, and DMA tests for the 16C32.&n; * &t;&n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;0 if success, otherwise -ENODEV&n; */
DECL|function|mgsl_adapter_test
r_int
id|mgsl_adapter_test
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):Testing device %s&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mgsl_register_test
c_func
(paren
id|info
)paren
)paren
(brace
id|info-&gt;init_error
op_assign
id|DiagStatus_AddressFailure
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s(%d):Register test failure for device %s Addr=%04X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
(paren
r_int
r_int
)paren
(paren
id|info-&gt;io_base
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mgsl_irq_test
c_func
(paren
id|info
)paren
)paren
(brace
id|info-&gt;init_error
op_assign
id|DiagStatus_IrqFailure
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s(%d):Interrupt test failure for device %s IRQ=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
(paren
r_int
r_int
)paren
(paren
id|info-&gt;irq_level
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|mgsl_dma_test
c_func
(paren
id|info
)paren
)paren
(brace
id|info-&gt;init_error
op_assign
id|DiagStatus_DmaFailure
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s(%d):DMA test failure for device %s DMA=%d&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
comma
(paren
r_int
r_int
)paren
(paren
id|info-&gt;dma_level
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):device %s passed diagnostics&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_adapter_test() */
multiline_comment|/* mgsl_memory_test()&n; * &n; * &t;Test the shared memory on a PCI adapter.&n; * &n; * Arguments:&t;&t;info&t;pointer to device instance data&n; * Return Value:&t;TRUE if test passed, otherwise FALSE&n; */
DECL|function|mgsl_memory_test
id|BOOLEAN
id|mgsl_memory_test
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_static
r_int
r_int
id|BitPatterns
(braket
)braket
op_assign
(brace
l_int|0x0
comma
l_int|0x55555555
comma
l_int|0xaaaaaaaa
comma
l_int|0x66666666
comma
l_int|0x99999999
comma
l_int|0xffffffff
comma
l_int|0x12345678
)brace
suffix:semicolon
r_int
r_int
id|Patterncount
op_assign
r_sizeof
(paren
id|BitPatterns
)paren
op_div
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|TestLimit
op_assign
id|SHARED_MEM_ADDRESS_SIZE
op_div
r_sizeof
(paren
r_int
r_int
)paren
suffix:semicolon
r_int
r_int
op_star
id|TestAddr
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;bus_type
op_ne
id|MGSL_BUS_TYPE_PCI
)paren
r_return
id|TRUE
suffix:semicolon
id|TestAddr
op_assign
(paren
r_int
r_int
op_star
)paren
id|info-&gt;memory_base
suffix:semicolon
multiline_comment|/* Test data lines with test pattern at one location. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|Patterncount
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|TestAddr
op_assign
id|BitPatterns
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|TestAddr
op_ne
id|BitPatterns
(braket
id|i
)braket
)paren
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/* Test address lines with incrementing pattern over */
multiline_comment|/* entire address range. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TestLimit
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|TestAddr
op_assign
id|i
op_star
l_int|4
suffix:semicolon
id|TestAddr
op_increment
suffix:semicolon
)brace
id|TestAddr
op_assign
(paren
r_int
r_int
op_star
)paren
id|info-&gt;memory_base
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|TestLimit
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_star
id|TestAddr
op_ne
id|i
op_star
l_int|4
)paren
r_return
id|FALSE
suffix:semicolon
id|TestAddr
op_increment
suffix:semicolon
)brace
id|memset
c_func
(paren
id|info-&gt;memory_base
comma
l_int|0
comma
id|SHARED_MEM_ADDRESS_SIZE
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* End Of mgsl_memory_test() */
multiline_comment|/* mgsl_load_pci_memory()&n; * &n; * &t;Load a large block of data into the PCI shared memory.&n; * &t;Use this instead of memcpy() or memmove() to move data&n; * &t;into the PCI shared memory.&n; * &n; * Notes:&n; * &n; * &t;This function prevents the PCI9050 interface chip from hogging&n; * &t;the adapter local bus, which can starve the 16C32 by preventing&n; * &t;16C32 bus master cycles.&n; * &n; * &t;The PCI9050 documentation says that the 9050 will always release&n; * &t;control of the local bus after completing the current read&n; * &t;or write operation.&n; * &n; * &t;It appears that as long as the PCI9050 write FIFO is full, the&n; * &t;PCI9050 treats all of the writes as a single burst transaction&n; * &t;and will not release the bus. This causes DMA latency problems&n; * &t;at high speeds when copying large data blocks to the shared&n; * &t;memory.&n; * &n; * &t;This function in effect, breaks the a large shared memory write&n; * &t;into multiple transations by interleaving a shared memory read&n; * &t;which will flush the write FIFO and &squot;complete&squot; the write&n; * &t;transation. This allows any pending DMA request to gain control&n; * &t;of the local bus in a timely fasion.&n; * &n; * Arguments:&n; * &n; * &t;TargetPtr&t;pointer to target address in PCI shared memory&n; * &t;SourcePtr&t;pointer to source buffer for data&n; * &t;count&t;&t;count in bytes of data to copy&n; *&n; * Return Value:&t;None&n; */
DECL|function|mgsl_load_pci_memory
r_void
id|mgsl_load_pci_memory
c_func
(paren
r_char
op_star
id|TargetPtr
comma
r_const
r_char
op_star
id|SourcePtr
comma
r_int
r_int
id|count
)paren
(brace
multiline_comment|/* 16 32-bit writes @ 60ns each = 960ns max latency on local bus */
DECL|macro|PCI_LOAD_INTERVAL
mdefine_line|#define PCI_LOAD_INTERVAL 64
r_int
r_int
id|Intervalcount
op_assign
id|count
op_div
id|PCI_LOAD_INTERVAL
suffix:semicolon
r_int
r_int
id|Index
suffix:semicolon
r_int
r_int
id|Dummy
suffix:semicolon
r_for
c_loop
(paren
id|Index
op_assign
l_int|0
suffix:semicolon
id|Index
OL
id|Intervalcount
suffix:semicolon
id|Index
op_increment
)paren
(brace
id|memcpy
c_func
(paren
id|TargetPtr
comma
id|SourcePtr
comma
id|PCI_LOAD_INTERVAL
)paren
suffix:semicolon
id|Dummy
op_assign
op_star
(paren
(paren
r_volatile
r_int
r_int
op_star
)paren
id|TargetPtr
)paren
suffix:semicolon
id|TargetPtr
op_add_assign
id|PCI_LOAD_INTERVAL
suffix:semicolon
id|SourcePtr
op_add_assign
id|PCI_LOAD_INTERVAL
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|TargetPtr
comma
id|SourcePtr
comma
id|count
op_mod
id|PCI_LOAD_INTERVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* End Of mgsl_load_pci_memory() */
DECL|function|mgsl_trace_block
r_void
id|mgsl_trace_block
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_const
r_char
op_star
id|data
comma
r_int
id|count
comma
r_int
id|xmit
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|linecount
suffix:semicolon
r_if
c_cond
(paren
id|xmit
)paren
id|printk
c_func
(paren
l_string|&quot;%s tx data:&bslash;n&quot;
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%s rx data:&bslash;n&quot;
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
r_if
c_cond
(paren
id|count
OG
l_int|16
)paren
id|linecount
op_assign
l_int|16
suffix:semicolon
r_else
id|linecount
op_assign
id|count
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|linecount
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02X &quot;
comma
(paren
r_int
r_char
)paren
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|i
OL
l_int|17
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;   &quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|linecount
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|040
op_logical_and
id|data
(braket
id|i
)braket
op_le
l_int|0176
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;.&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|data
op_add_assign
id|linecount
suffix:semicolon
id|count
op_sub_assign
id|linecount
suffix:semicolon
)brace
)brace
multiline_comment|/* end of mgsl_trace_block() */
multiline_comment|/* mgsl_tx_timeout()&n; * &n; * &t;called when HDLC frame times out&n; * &t;update stats and do tx completion processing&n; * &t;&n; * Arguments:&t;context&t;&t;pointer to device instance data&n; * Return Value:&t;None&n; */
DECL|function|mgsl_tx_timeout
r_void
id|mgsl_tx_timeout
c_func
(paren
r_int
r_int
id|context
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|context
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_tx_timeout(%s)&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;device_name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tx_active
op_logical_and
id|info-&gt;params.mode
op_eq
id|MGSL_MODE_HDLC
)paren
(brace
id|info-&gt;icount.txtimeout
op_increment
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|info-&gt;tx_active
op_assign
l_int|0
suffix:semicolon
id|info-&gt;xmit_cnt
op_assign
id|info-&gt;xmit_head
op_assign
id|info-&gt;xmit_tail
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_HDLC_LOOPMODE
)paren
id|usc_loopmode_cancel_transmit
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SYNCLINK_SYNCPPP
r_if
c_cond
(paren
id|info-&gt;netcount
)paren
id|mgsl_sppp_tx_done
c_func
(paren
id|info
)paren
suffix:semicolon
r_else
macro_line|#endif
id|mgsl_bh_transmit
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/* end of mgsl_tx_timeout() */
multiline_comment|/* signal that there are no more frames to send, so that&n; * line is &squot;released&squot; by echoing RxD to TxD when current&n; * transmission is complete (or immediately if no tx in progress).&n; */
DECL|function|mgsl_loopmode_send_done
r_static
r_int
id|mgsl_loopmode_send_done
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;params.flags
op_amp
id|HDLC_FLAG_HDLC_LOOPMODE
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;tx_active
)paren
id|info-&gt;loopmode_send_done_requested
op_assign
id|TRUE
suffix:semicolon
r_else
id|usc_loopmode_send_done
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* release the line by echoing RxD to TxD&n; * upon completion of a transmit frame&n; */
DECL|function|usc_loopmode_send_done
r_void
id|usc_loopmode_send_done
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|info-&gt;loopmode_send_done_requested
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/* clear CMR:13 to 0 to start echoing RxData to TxData */
id|info-&gt;cmr_value
op_and_assign
op_complement
id|BIT13
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|CMR
comma
id|info-&gt;cmr_value
)paren
suffix:semicolon
)brace
multiline_comment|/* abort a transmit in progress while in HDLC LoopMode&n; */
DECL|function|usc_loopmode_cancel_transmit
r_void
id|usc_loopmode_cancel_transmit
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
multiline_comment|/* reset tx dma channel and purge TxFifo */
id|usc_RTCmd
c_func
(paren
id|info
comma
id|RTCmd_PurgeTxFifo
)paren
suffix:semicolon
id|usc_DmaCmd
c_func
(paren
id|info
comma
id|DmaCmd_ResetTxChannel
)paren
suffix:semicolon
id|usc_loopmode_send_done
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/* for HDLC/SDLC LoopMode, setting CMR:13 after the transmitter is enabled&n; * is an Insert Into Loop action. Upon receipt of a GoAhead sequence (RxAbort)&n; * we must clear CMR:13 to begin repeating TxData to RxData&n; */
DECL|function|usc_loopmode_insert_request
r_void
id|usc_loopmode_insert_request
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
id|info-&gt;loopmode_insert_requested
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* enable RxAbort irq. On next RxAbort, clear CMR:13 to&n; &t; * begin repeating TxData on RxData (complete insertion)&n;&t; */
id|usc_OutReg
c_func
(paren
id|info
comma
id|RICR
comma
(paren
id|usc_InReg
c_func
(paren
id|info
comma
id|RICR
)paren
op_or
id|RXSTATUS_ABORT_RECEIVED
)paren
)paren
suffix:semicolon
multiline_comment|/* set CMR:13 to insert into loop on next GoAhead (RxAbort) */
id|info-&gt;cmr_value
op_or_assign
id|BIT13
suffix:semicolon
id|usc_OutReg
c_func
(paren
id|info
comma
id|CMR
comma
id|info-&gt;cmr_value
)paren
suffix:semicolon
)brace
multiline_comment|/* return 1 if station is inserted into the loop, otherwise 0&n; */
DECL|function|usc_loopmode_active
r_int
id|usc_loopmode_active
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_return
id|usc_InReg
c_func
(paren
id|info
comma
id|CCSR
)paren
op_amp
id|BIT7
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* return 1 if USC is in loop send mode, otherwise 0&n; */
DECL|function|usc_loopmode_send_active
r_int
id|usc_loopmode_send_active
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_return
id|usc_InReg
c_func
(paren
id|info
comma
id|CCSR
)paren
op_amp
id|BIT6
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SYNCLINK_SYNCPPP
multiline_comment|/* syncppp net device routines&n; */
DECL|function|mgsl_sppp_init
r_void
id|mgsl_sppp_init
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_struct
id|net_device
op_star
id|d
suffix:semicolon
id|sprintf
c_func
(paren
id|info-&gt;netname
comma
l_string|&quot;mgsl%d&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
id|info-&gt;if_ptr
op_assign
op_amp
id|info-&gt;pppdev
suffix:semicolon
id|info-&gt;netdev
op_assign
id|info-&gt;pppdev.dev
op_assign
op_amp
id|info-&gt;netdevice
suffix:semicolon
id|sppp_attach
c_func
(paren
op_amp
id|info-&gt;pppdev
)paren
suffix:semicolon
id|d
op_assign
id|info-&gt;netdev
suffix:semicolon
id|strcpy
c_func
(paren
id|d-&gt;name
comma
id|info-&gt;netname
)paren
suffix:semicolon
id|d-&gt;base_addr
op_assign
id|info-&gt;io_base
suffix:semicolon
id|d-&gt;irq
op_assign
id|info-&gt;irq_level
suffix:semicolon
id|d-&gt;dma
op_assign
id|info-&gt;dma_level
suffix:semicolon
id|d-&gt;priv
op_assign
id|info
suffix:semicolon
id|d-&gt;init
op_assign
l_int|NULL
suffix:semicolon
id|d-&gt;open
op_assign
id|mgsl_sppp_open
suffix:semicolon
id|d-&gt;stop
op_assign
id|mgsl_sppp_close
suffix:semicolon
id|d-&gt;hard_start_xmit
op_assign
id|mgsl_sppp_tx
suffix:semicolon
id|d-&gt;do_ioctl
op_assign
id|mgsl_sppp_ioctl
suffix:semicolon
id|d-&gt;get_stats
op_assign
id|mgsl_net_stats
suffix:semicolon
id|d-&gt;tx_timeout
op_assign
id|mgsl_sppp_tx_timeout
suffix:semicolon
id|d-&gt;watchdog_timeo
op_assign
l_int|10
op_star
id|HZ
suffix:semicolon
id|dev_init_buffers
c_func
(paren
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_netdev
c_func
(paren
id|d
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: register_netdev failed.&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
id|sppp_detach
c_func
(paren
id|info-&gt;netdev
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;mgsl_sppp_init()&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|mgsl_sppp_delete
r_void
id|mgsl_sppp_delete
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;mgsl_sppp_delete(%s)&bslash;n&quot;
comma
id|info-&gt;netname
)paren
suffix:semicolon
id|sppp_detach
c_func
(paren
id|info-&gt;netdev
)paren
suffix:semicolon
id|unregister_netdev
c_func
(paren
id|info-&gt;netdev
)paren
suffix:semicolon
)brace
DECL|function|mgsl_sppp_open
r_int
id|mgsl_sppp_open
c_func
(paren
r_struct
id|net_device
op_star
id|d
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
id|d-&gt;priv
suffix:semicolon
r_int
id|err
comma
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;mgsl_sppp_open(%s)&bslash;n&quot;
comma
id|info-&gt;netname
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;netlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;count
op_ne
l_int|0
op_logical_or
id|info-&gt;netcount
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s: sppp_open returning busy&bslash;n&quot;
comma
id|info-&gt;netname
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;netlock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|info-&gt;netcount
op_assign
l_int|1
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;netlock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* claim resources and init adapter */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|startup
c_func
(paren
id|info
)paren
)paren
op_ne
l_int|0
)paren
r_goto
id|open_fail
suffix:semicolon
multiline_comment|/* allow syncppp module to do open processing */
r_if
c_cond
(paren
(paren
id|err
op_assign
id|sppp_open
c_func
(paren
id|d
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|shutdown
c_func
(paren
id|info
)paren
suffix:semicolon
r_goto
id|open_fail
suffix:semicolon
)brace
id|info-&gt;serial_signals
op_or_assign
id|SerialSignal_RTS
op_plus
id|SerialSignal_DTR
suffix:semicolon
id|mgsl_program_hw
c_func
(paren
id|info
)paren
suffix:semicolon
id|d-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|netif_start_queue
c_func
(paren
id|d
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|open_fail
suffix:colon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;netlock
comma
id|flags
)paren
suffix:semicolon
id|info-&gt;netcount
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;netlock
comma
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|mgsl_sppp_tx_timeout
r_void
id|mgsl_sppp_tx_timeout
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;mgsl_sppp_tx_timeout(%s)&bslash;n&quot;
comma
id|info-&gt;netname
)paren
suffix:semicolon
id|info-&gt;netstats.tx_errors
op_increment
suffix:semicolon
id|info-&gt;netstats.tx_aborted_errors
op_increment
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|usc_stop_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
id|netif_wake_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
DECL|function|mgsl_sppp_tx
r_int
id|mgsl_sppp_tx
c_func
(paren
r_struct
id|sk_buff
op_star
id|skb
comma
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
id|dev-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;mgsl_sppp_tx(%s)&bslash;n&quot;
comma
id|info-&gt;netname
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|info-&gt;xmit_cnt
op_assign
id|skb-&gt;len
suffix:semicolon
id|mgsl_load_tx_dma_buffer
c_func
(paren
id|info
comma
id|skb-&gt;data
comma
id|skb-&gt;len
)paren
suffix:semicolon
id|info-&gt;netstats.tx_packets
op_increment
suffix:semicolon
id|info-&gt;netstats.tx_bytes
op_add_assign
id|skb-&gt;len
suffix:semicolon
id|dev_kfree_skb
c_func
(paren
id|skb
)paren
suffix:semicolon
id|dev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tx_active
)paren
id|usc_start_transmitter
c_func
(paren
id|info
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;irq_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mgsl_sppp_close
r_int
id|mgsl_sppp_close
c_func
(paren
r_struct
id|net_device
op_star
id|d
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
id|d-&gt;priv
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;mgsl_sppp_close(%s)&bslash;n&quot;
comma
id|info-&gt;netname
)paren
suffix:semicolon
multiline_comment|/* shutdown adapter and release resources */
id|shutdown
c_func
(paren
id|info
)paren
suffix:semicolon
multiline_comment|/* allow syncppp to do close processing */
id|sppp_close
c_func
(paren
id|d
)paren
suffix:semicolon
id|netif_stop_queue
c_func
(paren
id|d
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|info-&gt;netlock
comma
id|flags
)paren
suffix:semicolon
id|info-&gt;netcount
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|info-&gt;netlock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mgsl_sppp_rx_done
r_void
id|mgsl_sppp_rx_done
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
comma
r_char
op_star
id|buf
comma
r_int
id|size
)paren
(brace
r_struct
id|sk_buff
op_star
id|skb
op_assign
id|dev_alloc_skb
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;mgsl_sppp_rx_done(%s)&bslash;n&quot;
comma
id|info-&gt;netname
)paren
suffix:semicolon
r_if
c_cond
(paren
id|skb
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s: cant alloc skb, dropping packet&bslash;n&quot;
comma
id|info-&gt;netname
)paren
suffix:semicolon
id|info-&gt;netstats.rx_dropped
op_increment
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|skb_put
c_func
(paren
id|skb
comma
id|size
)paren
comma
id|buf
comma
id|size
)paren
suffix:semicolon
id|skb-&gt;protocol
op_assign
id|htons
c_func
(paren
id|ETH_P_WAN_PPP
)paren
suffix:semicolon
id|skb-&gt;dev
op_assign
id|info-&gt;netdev
suffix:semicolon
id|skb-&gt;mac.raw
op_assign
id|skb-&gt;data
suffix:semicolon
id|info-&gt;netstats.rx_packets
op_increment
suffix:semicolon
id|info-&gt;netstats.rx_bytes
op_add_assign
id|size
suffix:semicolon
id|netif_rx
c_func
(paren
id|skb
)paren
suffix:semicolon
id|info-&gt;netdev-&gt;trans_start
op_assign
id|jiffies
suffix:semicolon
)brace
DECL|function|mgsl_sppp_tx_done
r_void
id|mgsl_sppp_tx_done
c_func
(paren
r_struct
id|mgsl_struct
op_star
id|info
)paren
(brace
r_if
c_cond
(paren
id|netif_queue_stopped
c_func
(paren
id|info-&gt;netdev
)paren
)paren
id|netif_wake_queue
c_func
(paren
id|info-&gt;netdev
)paren
suffix:semicolon
)brace
DECL|function|mgsl_net_stats
r_struct
id|net_device_stats
op_star
id|mgsl_net_stats
c_func
(paren
r_struct
id|net_device
op_star
id|dev
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;mgsl_net_stats(%s)&bslash;n&quot;
comma
id|info-&gt;netname
)paren
suffix:semicolon
r_return
op_amp
id|info-&gt;netstats
suffix:semicolon
)brace
DECL|function|mgsl_sppp_ioctl
r_int
id|mgsl_sppp_ioctl
c_func
(paren
r_struct
id|net_device
op_star
id|dev
comma
r_struct
id|ifreq
op_star
id|ifr
comma
r_int
id|cmd
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
op_assign
(paren
r_struct
id|mgsl_struct
op_star
)paren
id|dev-&gt;priv
suffix:semicolon
r_if
c_cond
(paren
id|debug_level
op_ge
id|DEBUG_LEVEL_INFO
)paren
id|printk
c_func
(paren
l_string|&quot;%s(%d):mgsl_ioctl %s cmd=%08X&bslash;n&quot;
comma
id|__FILE__
comma
id|__LINE__
comma
id|info-&gt;netname
comma
id|cmd
)paren
suffix:semicolon
r_return
id|sppp_do_ioctl
c_func
(paren
id|dev
comma
id|ifr
comma
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#endif /* ifdef CONFIG_SYNCLINK_SYNCPPP */
DECL|function|synclink_init_one
r_static
r_int
id|__init
id|synclink_init_one
(paren
r_struct
id|pci_dev
op_star
id|dev
comma
r_const
r_struct
id|pci_device_id
op_star
id|ent
)paren
(brace
r_struct
id|mgsl_struct
op_star
id|info
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;error enabling pci device %p&bslash;n&quot;
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|info
op_assign
id|mgsl_allocate_device
c_func
(paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;can&squot;t allocate device instance data.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Copy user configuration info to device instance data */
id|info-&gt;io_base
op_assign
id|pci_resource_start
c_func
(paren
id|dev
comma
l_int|2
)paren
suffix:semicolon
id|info-&gt;irq_level
op_assign
id|dev-&gt;irq
suffix:semicolon
id|info-&gt;phys_memory_base
op_assign
id|pci_resource_start
c_func
(paren
id|dev
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* Because veremap only works on page boundaries we must map&n;&t; * a larger area than is actually implemented for the LCR&n;&t; * memory range. We map a full page starting at the page boundary.&n;&t; */
id|info-&gt;phys_lcr_base
op_assign
id|pci_resource_start
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
id|info-&gt;lcr_offset
op_assign
id|info-&gt;phys_lcr_base
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|info-&gt;phys_lcr_base
op_and_assign
op_complement
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|info-&gt;bus_type
op_assign
id|MGSL_BUS_TYPE_PCI
suffix:semicolon
id|info-&gt;io_addr_size
op_assign
l_int|8
suffix:semicolon
id|info-&gt;irq_flags
op_assign
id|SA_SHIRQ
suffix:semicolon
multiline_comment|/* Store the PCI9050 misc control register value because a flaw&n;&t; * in the PCI9050 prevents LCR registers from being read if &n;&t; * BIOS assigns an LCR base address with bit 7 set.&n;&t; *  &n;&t; * Only the misc control register is accessed for which only &n;&t; * write access is needed, so set an initial value and change &n;&t; * bits to the device instance data as we write the value&n;&t; * to the actual misc control register.&n;&t; */
id|info-&gt;misc_ctrl_value
op_assign
l_int|0x087e4546
suffix:semicolon
id|mgsl_add_device
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|synclink_remove_one
r_static
r_void
id|__exit
id|synclink_remove_one
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
)brace
eof
