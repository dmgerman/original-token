DECL|variable|rcsid
r_static
r_char
id|rcsid
(braket
)braket
op_assign
l_string|&quot;$Revision: 1.36.3.7 $$Date: 1996/04/19 21:06:18 $&quot;
suffix:semicolon
multiline_comment|/*&n; *  linux/drivers/char/cyclades.c&n; *&n; * This file contains the driver for the Cyclades Cyclom-Y multiport&n; * serial boards.&n; *&n; * Maintained by Marcio Saito (marcio@cyclades.com) and&n; * Randolph Bentson (bentson@grieg.seaslug.org)&n; *&n; * For Technical support and installation problems, please send e-mail&n; * to support@cyclades.com.&n; *&n; * Much of the design and some of the code came from serial.c&n; * which was copyright (C) 1991, 1992  Linus Torvalds.  It was&n; * extensively rewritten by Theodore Ts&squot;o, 8/16/92 -- 9/14/92,&n; * and then fixed as suggested by Michael K. Johnson 12/12/92.&n; *&n; * This version does not support shared irq&squot;s.&n; *&n; * This module exports the following rs232 io functions:&n; *   int cy_init(void);&n; *   int cy_open(struct tty_struct *tty, struct file *filp);&n; *&n; * $Log: cyclades.c,v $&n; * Revision 1.36.3.7  1996/04/19 21:06:18  bentson&n; * remove unneeded boot message &amp; fix CLOCAL hardware flow&n; * control (Miquel van Smoorenburg &lt;miquels@Q.cistron.nl&gt;);&n; * remove unused diagnostic statements; minor 0 is first;&n; *&n; * Revision 1.36.3.6  1996/03/13 13:21:17  marcio&n; * The kernel function vremap (available only in later 1.3.xx kernels)&n; * allows the access to memory addresses above the RAM. This revision&n; * of the driver supports PCI boards below 1Mb (device id 0x100) and&n; * above 1Mb (device id 0x101).&n; *&n; * Revision 1.36.3.5  1996/03/07 15:20:17  bentson&n; * Some global changes to interrupt handling spilled into&n; * this driver--mostly unused arguments in system function&n; * calls.  Also added change by Marcio Saito which should&n; * reduce lost interrupts at startup by fast processors.&n; *&n; * Revision 1.36.3.4  1995/11/13  20:45:10  bentson&n; * Changes by Corey Minyard &lt;minyard@wf-rch.cirr.com&gt; distributed&n; * in 1.3.41 kernel to remove a possible race condition, extend&n; * some error messages, and let the driver run as a loadable module&n; * Change by Alan Wendt &lt;alan@ez0.ezlink.com&gt; to remove a&n; * possible race condition.&n; * Change by Marcio Saito &lt;marcio@cyclades.com&gt; to fix PCI addressing.&n; *&n; * Revision 1.36.3.3  1995/11/13  19:44:48  bentson&n; * Changes by Linus Torvalds in 1.3.33 kernel distribution&n; * required due to reordering of driver initialization.&n; * Drivers are now initialized *after* memory management.&n; *&n; * Revision 1.36.3.2  1995/09/08  22:07:14  bentson&n; * remove printk from ISR; fix typo&n; *&n; * Revision 1.36.3.1  1995/09/01  12:00:42  marcio&n; * Minor fixes in the PCI board support. PCI function calls in&n; * conditional compilation (CONFIG_PCI). Thanks to Jim Duncan&n; * &lt;duncan@okay.com&gt;. &quot;bad serial count&quot; message removed.&n; *&n; * Revision 1.36.3  1995/08/22  09:19:42  marcio&n; * Cyclom-Y/PCI support added. Changes in the cy_init routine and&n; * board initialization. Changes in the boot messages. The driver&n; * supports up to 4 boards and 64 ports by default.&n; *&n; * Revision 1.36.1.4  1995/03/29  06:14:14  bentson&n; * disambiguate between Cyclom-16Y and Cyclom-32Ye;&n; *&n; * Revision 1.36.1.3  1995/03/23  22:15:35  bentson&n; * add missing break in modem control block in ioctl switch statement&n; * (discovered by Michael Edward Chastain &lt;mec@jobe.shell.portal.com&gt;);&n; *&n; * Revision 1.36.1.2  1995/03/22  19:16:22  bentson&n; * make sure CTS flow control is set as soon as possible (thanks&n; * to note from David Lambert &lt;lambert@chesapeake.rps.slb.com&gt;);&n; *&n; * Revision 1.36.1.1  1995/03/13  15:44:43  bentson&n; * initialize defaults for receive threshold and stale data timeout;&n; * cosmetic changes;&n; *&n; * Revision 1.36  1995/03/10  23:33:53  bentson&n; * added support of chips 4-7 in 32 port Cyclom-Ye;&n; * fix cy_interrupt pointer dereference problem&n; * (Joe Portman &lt;baron@aa.net&gt;);&n; * give better error response if open is attempted on non-existent port&n; * (Zachariah Vaum &lt;jchryslr@netcom.com&gt;);&n; * correct command timeout (Kenneth Lerman &lt;lerman@@seltd.newnet.com&gt;);&n; * conditional compilation for -16Y on systems with fast, noisy bus;&n; * comment out diagnostic print function;&n; * cleaned up table of base addresses;&n; * set receiver time-out period register to correct value,&n; * set receive threshold to better default values,&n; * set chip timer to more accurate 200 Hz ticking,&n; * add code to monitor and modify receive parameters&n; * (Rik Faith &lt;faith@cs.unc.edu&gt; Nick Simicich&n; * &lt;njs@scifi.emi.net&gt;);&n; *&n; * Revision 1.35  1994/12/16  13:54:18  steffen&n; * additional patch by Marcio Saito for board detection&n; * Accidently left out in 1.34&n; *&n; * Revision 1.34  1994/12/10  12:37:12  steffen&n; * This is the corrected version as suggested by Marcio Saito&n; *&n; * Revision 1.33  1994/12/01  22:41:18  bentson&n; * add hooks to support more high speeds directly; add tytso&n; * patch regarding CLOCAL wakeups&n; *&n; * Revision 1.32  1994/11/23  19:50:04  bentson&n; * allow direct kernel control of higher signalling rates;&n; * look for cards at additional locations&n; *&n; * Revision 1.31  1994/11/16  04:33:28  bentson&n; * ANOTHER fix from Corey Minyard, minyard@wf-rch.cirr.com--&n; * a problem in chars_in_buffer has been resolved by some&n; * small changes;  this should yield smoother output&n; *&n; * Revision 1.30  1994/11/16  04:28:05  bentson&n; * Fix from Corey Minyard, Internet: minyard@metronet.com,&n; * UUCP: minyard@wf-rch.cirr.com, WORK: minyardbnr.ca, to&n; * cy_hangup that appears to clear up much (all?) of the&n; * DTR glitches; also he&squot;s added/cleaned-up diagnostic messages&n; *&n; * Revision 1.29  1994/11/16  04:16:07  bentson&n; * add change proposed by Ralph Sims, ralphs@halcyon.com, to&n; * operate higher speeds in same way as other serial ports;&n; * add more serial ports (for up to two 16-port muxes).&n; *&n; * Revision 1.28  1994/11/04  00:13:16  root&n; * turn off diagnostic messages&n; *&n; * Revision 1.27  1994/11/03  23:46:37  root&n; * bunch of changes to bring driver into greater conformance&n; * with the serial.c driver (looking for missed fixes)&n; *&n; * Revision 1.26  1994/11/03  22:40:36  root&n; * automatic interrupt probing fixed.&n; *&n; * Revision 1.25  1994/11/03  20:17:02  root&n; * start to implement auto-irq&n; *&n; * Revision 1.24  1994/11/03  18:01:55  root&n; * still working on modem signals--trying not to drop DTR&n; * during the getty/login processes&n; *&n; * Revision 1.23  1994/11/03  17:51:36  root&n; * extend baud rate support; set receive threshold as function&n; * of baud rate; fix some problems with RTS/CTS;&n; *&n; * Revision 1.22  1994/11/02  18:05:35  root&n; * changed arguments to udelay to type long to get&n; * delays to be of correct duration&n; *&n; * Revision 1.21  1994/11/02  17:37:30  root&n; * employ udelay (after calibrating loops_per_second earlier&n; * in init/main.c) instead of using home-grown delay routines&n; *&n; * Revision 1.20  1994/11/02  03:11:38  root&n; * cy_chars_in_buffer forces a return value of 0 to let&n; * login work (don&squot;t know why it does); some functions&n; * that were returning EFAULT, now executes the code;&n; * more work on deciding when to disable xmit interrupts;&n; *&n; * Revision 1.19  1994/11/01  20:10:14  root&n; * define routine to start transmission interrupts (by enabling&n; * transmit interrupts); directly enable/disable modem interrupts;&n; *&n; * Revision 1.18  1994/11/01  18:40:45  bentson&n; * Don&squot;t always enable transmit interrupts in startup; interrupt on&n; * TxMpty instead of TxRdy to help characters get out before shutdown;&n; * restructure xmit interrupt to check for chars first and quit if&n; * none are ready to go; modem status (MXVRx) is upright, _not_ inverted&n; * (to my view);&n; *&n; * Revision 1.17  1994/10/30  04:39:45  bentson&n; * rename serial_driver and callout_driver to cy_serial_driver and&n; * cy_callout_driver to avoid linkage interference; initialize&n; * info-&gt;type to PORT_CIRRUS; ruggedize paranoia test; elide -&gt;port&n; * from cyclades_port structure; add paranoia check to cy_close;&n; *&n; * Revision 1.16  1994/10/30  01:14:33  bentson&n; * change major numbers; add some _early_ return statements;&n; *&n; * Revision 1.15  1994/10/29  06:43:15  bentson&n; * final tidying up for clean compile;  enable some error reporting&n; *&n; * Revision 1.14  1994/10/28  20:30:22  Bentson&n; * lots of changes to drag the driver towards the new tty_io&n; * structures and operation.  not expected to work, but may&n; * compile cleanly.&n; *&n; * Revision 1.13  1994/07/21  23:08:57  Bentson&n; * add some diagnostic cruft; support 24 lines (for testing&n; * both -8Y and -16Y cards; be more thorough in servicing all&n; * chips during interrupt; add &quot;volatile&quot; a few places to&n; * circumvent compiler optimizations; fix base &amp; offset&n; * computations in block_til_ready (was causing chip 0 to&n; * stop operation)&n; *&n; * Revision 1.12  1994/07/19  16:42:11  Bentson&n; * add some hackery for kernel version 1.1.8; expand&n; * error messages; refine timing for delay loops and&n; * declare loop params volatile&n; *&n; * Revision 1.11  1994/06/11  21:53:10  bentson&n; * get use of save_car right in transmit interrupt service&n; *&n; * Revision 1.10.1.1  1994/06/11  21:31:18  bentson&n; * add some diagnostic printing; try to fix save_car stuff&n; *&n; * Revision 1.10  1994/06/11  20:36:08  bentson&n; * clean up compiler warnings&n; *&n; * Revision 1.9  1994/06/11  19:42:46  bentson&n; * added a bunch of code to support modem signalling&n; *&n; * Revision 1.8  1994/06/11  17:57:07  bentson&n; * recognize break &amp; parity error&n; *&n; * Revision 1.7  1994/06/05  05:51:34  bentson&n; * Reorder baud table to be monotonic; add cli to CP; discard&n; * incoming characters and status if the line isn&squot;t open; start to&n; * fold code into cy_throttle; start to port get_serial_info,&n; * set_serial_info, get_modem_info, set_modem_info, and send_break&n; * from serial.c; expand cy_ioctl; relocate and expand config_setup;&n; * get flow control characters from tty struct; invalidate ports w/o&n; * hardware;&n; *&n; * Revision 1.6  1994/05/31  18:42:21  bentson&n; * add a loop-breaker in the interrupt service routine;&n; * note when port is initialized so that it can be shut&n; * down under the right conditions; receive works without&n; * any obvious errors&n; *&n; * Revision 1.5  1994/05/30  00:55:02  bentson&n; * transmit works without obvious errors&n; *&n; * Revision 1.4  1994/05/27  18:46:27  bentson&n; * incorporated more code from lib_y.c; can now print short&n; * strings under interrupt control to port zero; seems to&n; * select ports/channels/lines correctly&n; *&n; * Revision 1.3  1994/05/25  22:12:44  bentson&n; * shifting from multi-port on a card to proper multiplexor&n; * data structures;  added skeletons of most routines&n; *&n; * Revision 1.2  1994/05/19  13:21:43  bentson&n; * start to crib from other sources&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/cyclades.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
DECL|macro|small_delay
mdefine_line|#define small_delay(x) for(j=0;j&lt;x;j++)k++;
DECL|macro|SERIAL_PARANOIA_CHECK
mdefine_line|#define SERIAL_PARANOIA_CHECK
DECL|macro|SERIAL_DEBUG_OPEN
macro_line|#undef  SERIAL_DEBUG_OPEN
DECL|macro|SERIAL_DEBUG_THROTTLE
macro_line|#undef  SERIAL_DEBUG_THROTTLE
DECL|macro|SERIAL_DEBUG_OTHER
macro_line|#undef  SERIAL_DEBUG_OTHER
DECL|macro|SERIAL_DEBUG_IO
macro_line|#undef  SERIAL_DEBUG_IO
DECL|macro|SERIAL_DEBUG_COUNT
macro_line|#undef  SERIAL_DEBUG_COUNT
DECL|macro|SERIAL_DEBUG_DTR
macro_line|#undef  SERIAL_DEBUG_DTR
DECL|macro|CYCLOM_16Y_HACK
macro_line|#undef  CYCLOM_16Y_HACK
DECL|macro|CYCLOM_ENABLE_MONITORING
macro_line|#undef  CYCLOM_ENABLE_MONITORING
macro_line|#ifndef MIN
DECL|macro|MIN
mdefine_line|#define MIN(a,b)&t;((a) &lt; (b) ? (a) : (b))
macro_line|#endif
DECL|macro|WAKEUP_CHARS
mdefine_line|#define WAKEUP_CHARS 256
DECL|macro|STD_COM_FLAGS
mdefine_line|#define STD_COM_FLAGS (0)
DECL|macro|SERIAL_TYPE_NORMAL
mdefine_line|#define SERIAL_TYPE_NORMAL  1
DECL|macro|SERIAL_TYPE_CALLOUT
mdefine_line|#define SERIAL_TYPE_CALLOUT 2
DECL|variable|tq_cyclades
id|DECLARE_TASK_QUEUE
c_func
(paren
id|tq_cyclades
)paren
suffix:semicolon
DECL|variable|cy_serial_driver
DECL|variable|cy_callout_driver
r_struct
id|tty_driver
id|cy_serial_driver
comma
id|cy_callout_driver
suffix:semicolon
DECL|variable|cy_irq_triggered
r_static
r_volatile
r_int
id|cy_irq_triggered
suffix:semicolon
DECL|variable|cy_triggered
r_static
r_volatile
r_int
id|cy_triggered
suffix:semicolon
DECL|variable|cy_wild_int_mask
r_static
r_int
id|cy_wild_int_mask
suffix:semicolon
DECL|variable|intr_base_addr
r_static
r_int
r_char
op_star
id|intr_base_addr
suffix:semicolon
multiline_comment|/* This is the address lockup table. The driver will probe for Cyclom-Y/ISA&n;   boards at all addresses in here. If you want the driver to probe addresses&n;   in a different address, add it to this table.&n;   If the driver is probing some other board and causing problems, remove the&n;   address from this table.  */
DECL|variable|cy_isa_addresses
r_static
r_int
r_char
op_star
id|cy_isa_addresses
(braket
)braket
op_assign
(brace
(paren
r_int
r_char
op_star
)paren
l_int|0xD0000
comma
(paren
r_int
r_char
op_star
)paren
l_int|0xD2000
comma
(paren
r_int
r_char
op_star
)paren
l_int|0xD4000
comma
(paren
r_int
r_char
op_star
)paren
l_int|0xD6000
comma
(paren
r_int
r_char
op_star
)paren
l_int|0xD8000
comma
(paren
r_int
r_char
op_star
)paren
l_int|0xDA000
comma
(paren
r_int
r_char
op_star
)paren
l_int|0xDC000
comma
(paren
r_int
r_char
op_star
)paren
l_int|0xDE000
comma
)brace
suffix:semicolon
DECL|macro|NR_ISA_ADDRESSES
mdefine_line|#define&t;NR_ISA_ADDRESSES&t;(sizeof(cy_isa_addresses)/sizeof(unsigned char *))
multiline_comment|/* This is the per-card data structure containing address, irq, number of&n;   channels, etc. This driver supports a maximum of NR_CARDS cards. If&n;   you need to install more boards, change this constant in the definition&n;   below. No other change is necessary to support more boards. */
DECL|macro|NR_CARDS
mdefine_line|#define NR_CARDS&t;4
DECL|variable|cy_card
r_static
r_struct
id|cyclades_card
id|cy_card
(braket
id|NR_CARDS
)braket
suffix:semicolon
multiline_comment|/* This is the per-channel data structure containing pointers, flags&n;   and variables for the port. This driver supports a maximum of NR_PORTS.&n;   If the total number of ports is larger than NR_PORTS, change this&n;   constant in the definition below. No other change is necessary to&n;   support more boards/ports. */
DECL|macro|NR_PORTS
mdefine_line|#define NR_PORTS        64
DECL|variable|cy_port
r_static
r_struct
id|cyclades_port
id|cy_port
(braket
id|NR_PORTS
)braket
suffix:semicolon
multiline_comment|/*  The Cyclom-Ye has placed the sequential chips in non-sequential&n; *  address order.  This look-up table overcomes that problem.&n; */
DECL|variable|cy_chip_offset
r_static
r_int
id|cy_chip_offset
(braket
)braket
op_assign
(brace
l_int|0x0000
comma
l_int|0x0400
comma
l_int|0x0800
comma
l_int|0x0C00
comma
l_int|0x0200
comma
l_int|0x0600
comma
l_int|0x0A00
comma
l_int|0x0E00
)brace
suffix:semicolon
multiline_comment|/* PCI related definitions */
DECL|variable|cy_pci_nboard
r_static
r_int
r_int
id|cy_pci_nboard
op_assign
l_int|0
suffix:semicolon
DECL|variable|cy_isa_nboard
r_static
r_int
r_int
id|cy_isa_nboard
op_assign
l_int|0
suffix:semicolon
DECL|variable|cy_nboard
r_static
r_int
r_int
id|cy_nboard
op_assign
l_int|0
suffix:semicolon
DECL|variable|cy_pci_dev_id
r_static
r_int
r_int
id|cy_pci_dev_id
(braket
)braket
op_assign
(brace
id|PCI_DEVICE_ID_CYCLOM_Y_Lo
comma
multiline_comment|/* PCI below 1Mb */
id|PCI_DEVICE_ID_CYCLOM_Y_Hi
comma
multiline_comment|/* PCI above 1Mb */
l_int|0
multiline_comment|/* end of table */
)brace
suffix:semicolon
r_int
id|cy_detect_isa
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|cy_detect_pci
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|cy_next_channel
r_static
r_int
id|cy_next_channel
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* next minor available */
DECL|variable|serial_refcount
r_static
r_int
id|serial_refcount
suffix:semicolon
DECL|variable|serial_table
r_static
r_struct
id|tty_struct
op_star
id|serial_table
(braket
id|NR_PORTS
)braket
suffix:semicolon
DECL|variable|serial_termios
r_static
r_struct
id|termios
op_star
id|serial_termios
(braket
id|NR_PORTS
)braket
suffix:semicolon
DECL|variable|serial_termios_locked
r_static
r_struct
id|termios
op_star
id|serial_termios_locked
(braket
id|NR_PORTS
)braket
suffix:semicolon
multiline_comment|/* This is the per-irq data structure,&n;   it maps an irq to the corresponding card */
DECL|variable|IRQ_cards
r_struct
id|cyclades_card
op_star
id|IRQ_cards
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/*&n; * tmp_buf is used as a temporary buffer by serial_write.  We need to&n; * lock it in case the memcpy_fromfs blocks while swapping in a page,&n; * and some other program tries to do a serial write at the same time.&n; * Since the lock will only come under contention when the system is&n; * swapping and available memory is low, it makes sense to share one&n; * buffer across all the serial ports, since it significantly saves&n; * memory if large numbers of serial ports are open.&n; */
DECL|variable|tmp_buf
r_static
r_int
r_char
op_star
id|tmp_buf
op_assign
l_int|0
suffix:semicolon
DECL|variable|tmp_buf_sem
r_static
r_struct
id|semaphore
id|tmp_buf_sem
op_assign
id|MUTEX
suffix:semicolon
multiline_comment|/*&n; * This is used to look up the divisor speeds and the timeouts&n; * We&squot;re normally limited to 15 distinct baud rates.  The extra&n; * are accessed via settings in info-&gt;flags.&n; *         0,     1,     2,     3,     4,     5,     6,     7,     8,     9,&n; *        10,    11,    12,    13,    14,    15,    16,    17,    18,    19,&n; *                                                  HI            VHI&n; */
DECL|variable|baud_table
r_static
r_int
id|baud_table
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|50
comma
l_int|75
comma
l_int|110
comma
l_int|134
comma
l_int|150
comma
l_int|200
comma
l_int|300
comma
l_int|600
comma
l_int|1200
comma
l_int|1800
comma
l_int|2400
comma
l_int|4800
comma
l_int|9600
comma
l_int|19200
comma
l_int|38400
comma
l_int|57600
comma
l_int|76800
comma
l_int|115200
comma
l_int|150000
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|baud_co
r_static
r_char
id|baud_co
(braket
)braket
op_assign
(brace
multiline_comment|/* 25 MHz clock option table */
multiline_comment|/* value =&gt;    00    01   02    03    04 */
multiline_comment|/* divide by    8    32   128   512  2048 */
l_int|0x00
comma
l_int|0x04
comma
l_int|0x04
comma
l_int|0x04
comma
l_int|0x04
comma
l_int|0x04
comma
l_int|0x03
comma
l_int|0x03
comma
l_int|0x03
comma
l_int|0x02
comma
l_int|0x02
comma
l_int|0x02
comma
l_int|0x01
comma
l_int|0x01
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
DECL|variable|baud_bpr
r_static
r_char
id|baud_bpr
(braket
)braket
op_assign
(brace
multiline_comment|/* 25 MHz baud rate period table */
l_int|0x00
comma
l_int|0xf5
comma
l_int|0xa3
comma
l_int|0x6f
comma
l_int|0x5c
comma
l_int|0x51
comma
l_int|0xf5
comma
l_int|0xa3
comma
l_int|0x51
comma
l_int|0xa3
comma
l_int|0x6d
comma
l_int|0x51
comma
l_int|0xa3
comma
l_int|0x51
comma
l_int|0xa3
comma
l_int|0x51
comma
l_int|0x36
comma
l_int|0x29
comma
l_int|0x1b
comma
l_int|0x15
)brace
suffix:semicolon
DECL|variable|baud_cor3
r_static
r_char
id|baud_cor3
(braket
)braket
op_assign
(brace
multiline_comment|/* receive threshold */
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x0a
comma
l_int|0x09
comma
l_int|0x09
comma
l_int|0x08
comma
l_int|0x08
comma
l_int|0x08
comma
l_int|0x08
comma
l_int|0x07
)brace
suffix:semicolon
r_static
r_void
id|shutdown
c_func
(paren
r_struct
id|cyclades_port
op_star
)paren
suffix:semicolon
r_static
r_int
id|startup
(paren
r_struct
id|cyclades_port
op_star
)paren
suffix:semicolon
r_static
r_void
id|cy_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_void
id|cy_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
)paren
suffix:semicolon
r_static
r_void
id|config_setup
c_func
(paren
r_struct
id|cyclades_port
op_star
)paren
suffix:semicolon
macro_line|#ifdef CYCLOM_SHOW_STATUS
r_static
r_void
id|show_status
c_func
(paren
r_int
)paren
suffix:semicolon
macro_line|#endif
r_static
r_inline
r_int
DECL|function|serial_paranoia_check
id|serial_paranoia_check
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
id|kdev_t
id|device
comma
r_const
r_char
op_star
id|routine
)paren
(brace
macro_line|#ifdef SERIAL_PARANOIA_CHECK
r_static
r_const
r_char
op_star
id|badmagic
op_assign
l_string|&quot;Warning: bad magic number for serial struct (%s) in %s&bslash;n&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|badinfo
op_assign
l_string|&quot;Warning: null cyclades_port for (%s) in %s&bslash;n&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|badrange
op_assign
l_string|&quot;Warning: cyclades_port out of range for (%s) in %s&bslash;n&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
(brace
id|printk
c_func
(paren
id|badinfo
comma
id|kdevname
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|info
OL
(paren
r_int
)paren
(paren
op_amp
id|cy_port
(braket
l_int|0
)braket
)paren
op_logical_or
(paren
r_int
)paren
(paren
op_amp
id|cy_port
(braket
id|NR_PORTS
)braket
)paren
OL
(paren
r_int
)paren
id|info
)paren
(brace
id|printk
c_func
(paren
id|badrange
comma
id|kdevname
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;magic
op_ne
id|CYCLADES_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|badmagic
comma
id|kdevname
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* serial_paranoia_check */
multiline_comment|/* The following diagnostic routines allow the driver to spew&n;   information on the screen, even (especially!) during interrupts.&n; */
r_void
DECL|function|SP
(def_block
id|SP
c_func
(paren
r_char
op_star
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|console_print
c_func
(paren
id|data
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)def_block
r_void
DECL|function|CP
(def_block
id|CP
c_func
(paren
r_char
id|data
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
id|scrn
(braket
l_int|2
)braket
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|scrn
(braket
l_int|0
)braket
op_assign
id|data
suffix:semicolon
id|scrn
(braket
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|console_print
c_func
(paren
id|scrn
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)def_block
multiline_comment|/* CP */
DECL|function|CP1
r_void
id|CP1
c_func
(paren
r_int
id|data
)paren
(brace
(paren
id|data
OL
l_int|10
)paren
ques
c_cond
id|CP
c_func
(paren
id|data
op_plus
l_char|&squot;0&squot;
)paren
suffix:colon
id|CP
c_func
(paren
id|data
op_plus
l_char|&squot;A&squot;
op_minus
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/* CP1 */
DECL|function|CP2
r_void
id|CP2
c_func
(paren
r_int
id|data
)paren
(brace
id|CP1
c_func
(paren
(paren
id|data
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
suffix:semicolon
id|CP1
c_func
(paren
id|data
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
multiline_comment|/* CP2 */
DECL|function|CP4
r_void
id|CP4
c_func
(paren
r_int
id|data
)paren
(brace
id|CP2
c_func
(paren
(paren
id|data
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|CP2
c_func
(paren
id|data
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
multiline_comment|/* CP4 */
DECL|function|CP8
r_void
id|CP8
c_func
(paren
r_int
id|data
)paren
(brace
id|CP4
c_func
(paren
(paren
id|data
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
suffix:semicolon
id|CP4
c_func
(paren
id|data
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
multiline_comment|/* CP8 */
multiline_comment|/* This routine waits up to 1000 micro-seconds for the previous&n;   command to the Cirrus chip to complete and then issues the&n;   new command.  An error is returned if the previous command&n;   didn&squot;t finish within the time limit.&n; */
id|u_short
DECL|function|write_cy_cmd
id|write_cy_cmd
c_func
(paren
id|u_char
op_star
id|base_addr
comma
id|u_char
id|cmd
comma
r_int
id|index
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_volatile
r_int
id|i
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Check to see that the previous command has completed */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|base_addr
(braket
id|CyCCR
op_lshift
id|index
)braket
op_eq
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|10L
)paren
suffix:semicolon
)brace
multiline_comment|/* if the CCR never cleared, the previous command&n;&t;    didn&squot;t finish within the &quot;reasonable time&quot; */
r_if
c_cond
(paren
id|i
op_eq
l_int|100
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Issue the new command */
id|base_addr
(braket
id|CyCCR
op_lshift
id|index
)braket
op_assign
id|cmd
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* write_cy_cmd */
multiline_comment|/* cy_start and cy_stop provide software output flow control as a&n;   function of XON/XOFF, software CTS, and other such stuff. */
r_static
r_void
DECL|function|cy_stop
id|cy_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_card
op_star
id|cinfo
suffix:semicolon
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|chip
comma
id|channel
comma
id|index
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_stop ttyC%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_stop&quot;
)paren
)paren
r_return
suffix:semicolon
id|cinfo
op_assign
op_amp
id|cy_card
(braket
id|info-&gt;card
)braket
suffix:semicolon
id|index
op_assign
id|cinfo-&gt;bus_index
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
op_minus
id|cinfo-&gt;first_line
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|info-&gt;card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
(paren
id|channel
op_amp
l_int|0x0003
)paren
suffix:semicolon
multiline_comment|/* index channel */
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_and_assign
op_complement
id|CyTxMpty
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* cy_stop */
r_static
r_void
DECL|function|cy_start
id|cy_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_card
op_star
id|cinfo
suffix:semicolon
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|chip
comma
id|channel
comma
id|index
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_start ttyC%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_start&quot;
)paren
)paren
r_return
suffix:semicolon
id|cinfo
op_assign
op_amp
id|cy_card
(braket
id|info-&gt;card
)braket
suffix:semicolon
id|index
op_assign
id|cinfo-&gt;bus_index
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
op_minus
id|cinfo-&gt;first_line
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|info-&gt;card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
(paren
id|channel
op_amp
l_int|0x0003
)paren
suffix:semicolon
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_or_assign
id|CyTxMpty
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* cy_start */
multiline_comment|/*&n; * This routine is used by the interrupt handler to schedule&n; * processing in the software interrupt portion of the driver&n; * (also known as the &quot;bottom half&quot;).  This can be called any&n; * number of times for any channel without harm.&n; */
r_static
r_inline
r_void
DECL|function|cy_sched_event
id|cy_sched_event
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
id|event
)paren
(brace
id|info-&gt;event
op_or_assign
l_int|1
op_lshift
id|event
suffix:semicolon
multiline_comment|/* remember what kind of event and who */
id|queue_task_irq_off
c_func
(paren
op_amp
id|info-&gt;tqueue
comma
op_amp
id|tq_cyclades
)paren
suffix:semicolon
multiline_comment|/* it belongs to */
id|mark_bh
c_func
(paren
id|CYCLADES_BH
)paren
suffix:semicolon
multiline_comment|/* then trigger event */
)brace
multiline_comment|/* cy_sched_event */
DECL|variable|probe_ready
r_static
r_int
id|probe_ready
suffix:semicolon
multiline_comment|/*&n; * This interrupt routine is used&n; * while we are probing for submarines.&n; */
r_static
r_void
DECL|function|cy_probe
id|cy_probe
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|save_xir
comma
id|save_car
suffix:semicolon
r_int
id|index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* probing interrupts is only for ISA */
r_if
c_cond
(paren
op_logical_neg
id|probe_ready
)paren
(brace
op_star
(paren
id|intr_base_addr
op_plus
(paren
id|Cy_ClrIntr
op_lshift
id|index
)paren
)paren
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|cy_irq_triggered
op_assign
id|irq
suffix:semicolon
id|cy_triggered
op_or_assign
l_int|1
op_lshift
id|irq
suffix:semicolon
r_if
c_cond
(paren
id|intr_base_addr
(braket
id|CySVRR
op_lshift
id|index
)braket
op_ne
l_int|0
)paren
(brace
id|save_xir
op_assign
(paren
id|u_char
)paren
id|intr_base_addr
(braket
id|CyTIR
op_lshift
id|index
)braket
suffix:semicolon
id|save_car
op_assign
id|intr_base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|save_xir
op_amp
l_int|0x3
)paren
op_ne
l_int|0
)paren
(brace
id|SP
c_func
(paren
l_string|&quot;channel &quot;
)paren
suffix:semicolon
id|CP2
c_func
(paren
id|save_xir
)paren
suffix:semicolon
id|SP
c_func
(paren
l_string|&quot; requesting unexpected interrupt&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|intr_base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|save_xir
op_amp
l_int|0x3
)paren
suffix:semicolon
id|intr_base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_and_assign
op_complement
id|CyTxMpty
suffix:semicolon
id|intr_base_addr
(braket
id|CyTIR
op_lshift
id|index
)braket
op_assign
(paren
id|save_xir
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|intr_base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|save_car
)paren
suffix:semicolon
)brace
op_star
(paren
id|intr_base_addr
op_plus
(paren
id|Cy_ClrIntr
op_lshift
id|index
)paren
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Cy_ClrIntr is 0x1800 */
r_return
suffix:semicolon
)brace
multiline_comment|/* cy_probe */
multiline_comment|/* The real interrupt service routine is called&n;   whenever the card wants its hand held--chars&n;   received, out buffer empty, modem change, etc.&n; */
r_static
r_void
DECL|function|cy_interrupt
id|cy_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
id|status
suffix:semicolon
r_struct
id|cyclades_card
op_star
id|cinfo
suffix:semicolon
r_struct
id|cyclades_port
op_star
id|info
suffix:semicolon
r_volatile
r_int
r_char
op_star
id|base_addr
comma
op_star
id|card_base_addr
suffix:semicolon
r_int
id|chip
suffix:semicolon
r_int
id|save_xir
comma
id|channel
comma
id|save_car
suffix:semicolon
r_char
id|data
suffix:semicolon
r_int
id|char_count
suffix:semicolon
r_int
id|outch
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|index
suffix:semicolon
r_int
id|too_many
suffix:semicolon
r_int
id|had_work
suffix:semicolon
r_int
id|mdm_change
suffix:semicolon
r_int
id|mdm_status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cinfo
op_assign
id|IRQ_cards
(braket
id|irq
)braket
)paren
op_eq
l_int|0
)paren
(brace
r_return
suffix:semicolon
multiline_comment|/* spurious interrupt */
)brace
id|card_base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
id|cinfo-&gt;base_addr
suffix:semicolon
id|index
op_assign
id|cinfo-&gt;bus_index
suffix:semicolon
multiline_comment|/* This loop checks all chips in the card.  Make a note whenever&n;       _any_ chip had some work to do, as this is considered an&n;       indication that there will be more to do.  Only when no chip&n;       has any work does this outermost loop exit.&n;     */
r_do
(brace
id|had_work
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|chip
op_assign
l_int|0
suffix:semicolon
id|chip
OL
id|cinfo-&gt;num_chips
suffix:semicolon
id|chip
op_increment
)paren
(brace
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cinfo-&gt;base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
id|too_many
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|status
op_assign
id|base_addr
(braket
id|CySVRR
op_lshift
id|index
)braket
)paren
op_ne
l_int|0x00
)paren
(brace
id|had_work
op_increment
suffix:semicolon
multiline_comment|/* The purpose of the following test is to ensure that&n;                   no chip can monopolize the driver.  This forces the&n;                   chips to be checked in a round-robin fashion (after&n;                   draining each of a bunch (1000) of characters).&n;&t;&t; */
r_if
c_cond
(paren
l_int|1000
OL
id|too_many
op_increment
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|CySRReceive
)paren
(brace
multiline_comment|/* reception interrupt */
multiline_comment|/* determine the channel and change to that context */
id|save_xir
op_assign
(paren
id|u_char
)paren
id|base_addr
(braket
id|CyRIR
op_lshift
id|index
)braket
suffix:semicolon
id|channel
op_assign
(paren
id|u_short
)paren
(paren
id|save_xir
op_amp
id|CyIRChannel
)paren
suffix:semicolon
id|i
op_assign
id|channel
op_plus
id|chip
op_star
l_int|4
op_plus
id|cinfo-&gt;first_line
suffix:semicolon
id|info
op_assign
op_amp
id|cy_port
(braket
id|i
)braket
suffix:semicolon
id|info-&gt;last_active
op_assign
id|jiffies
suffix:semicolon
id|save_car
op_assign
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
id|save_xir
suffix:semicolon
multiline_comment|/* if there is nowhere to put the data, discard it */
r_if
c_cond
(paren
id|info-&gt;tty
op_eq
l_int|0
)paren
(brace
id|j
op_assign
(paren
id|base_addr
(braket
id|CyRIVR
op_lshift
id|index
)braket
op_amp
id|CyIVRMask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
id|CyIVRRxEx
)paren
(brace
multiline_comment|/* exception */
id|data
op_assign
id|base_addr
(braket
id|CyRDSR
op_lshift
id|index
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* normal character reception */
id|char_count
op_assign
id|base_addr
(braket
id|CyRDCR
op_lshift
id|index
)braket
suffix:semicolon
r_while
c_loop
(paren
id|char_count
op_decrement
)paren
(brace
id|data
op_assign
id|base_addr
(braket
id|CyRDSR
op_lshift
id|index
)braket
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* there is an open port for this data */
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
id|j
op_assign
(paren
id|base_addr
(braket
id|CyRIVR
op_lshift
id|index
)braket
op_amp
id|CyIVRMask
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
id|CyIVRRxEx
)paren
(brace
multiline_comment|/* exception */
id|data
op_assign
id|base_addr
(braket
id|CyRDSR
op_lshift
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|data
op_amp
id|info-&gt;ignore_status_mask
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;flip.count
OL
id|TTY_FLIPBUF_SIZE
)paren
(brace
id|tty-&gt;flip.count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|data
op_amp
id|info-&gt;read_status_mask
)paren
(brace
r_if
c_cond
(paren
id|data
op_amp
id|CyBREAK
)paren
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_BREAK
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
id|base_addr
(braket
id|CyRDSR
op_lshift
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SAK
)paren
(brace
id|do_SAK
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|data
op_amp
id|CyFRAME
)paren
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_FRAME
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
id|base_addr
(braket
id|CyRDSR
op_lshift
id|index
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data
op_amp
id|CyPARITY
)paren
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_PARITY
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
id|base_addr
(braket
id|CyRDSR
op_lshift
id|index
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|data
op_amp
id|CyOVERRUN
)paren
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_OVERRUN
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If the flip buffer itself is&n;&t;&t;&t;&t;&t;   overflowing, we still loose&n;&t;&t;&t;&t;&t;   the next incoming character.&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|tty-&gt;flip.count
OL
id|TTY_FLIPBUF_SIZE
)paren
(brace
id|tty-&gt;flip.count
op_increment
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_NORMAL
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
id|base_addr
(braket
id|CyRDSR
op_lshift
id|index
)braket
suffix:semicolon
)brace
multiline_comment|/* These two conditions may imply */
multiline_comment|/* a normal read should be done. */
multiline_comment|/* }else if(data &amp; CyTIMEOUT){ */
multiline_comment|/* }else if(data &amp; CySPECHAR){ */
)brace
r_else
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
l_int|0
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
l_int|0
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* there was a software buffer overrun&n;&t;&t;&t;&t;    and nothing could be done about it!!! */
)brace
)brace
r_else
(brace
multiline_comment|/* normal character reception */
multiline_comment|/* load # characters available from the chip */
id|char_count
op_assign
id|base_addr
(braket
id|CyRDCR
op_lshift
id|index
)braket
suffix:semicolon
macro_line|#ifdef CYCLOM_ENABLE_MONITORING
op_increment
id|info-&gt;mon.int_count
suffix:semicolon
id|info-&gt;mon.char_count
op_add_assign
id|char_count
suffix:semicolon
r_if
c_cond
(paren
id|char_count
OG
id|info-&gt;mon.char_max
)paren
id|info-&gt;mon.char_max
op_assign
id|char_count
suffix:semicolon
id|info-&gt;mon.char_last
op_assign
id|char_count
suffix:semicolon
macro_line|#endif
r_while
c_loop
(paren
id|char_count
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
(brace
r_break
suffix:semicolon
)brace
id|tty-&gt;flip.count
op_increment
suffix:semicolon
id|data
op_assign
id|base_addr
(braket
id|CyRDSR
op_lshift
id|index
)braket
suffix:semicolon
op_star
id|tty-&gt;flip.flag_buf_ptr
op_increment
op_assign
id|TTY_NORMAL
suffix:semicolon
op_star
id|tty-&gt;flip.char_buf_ptr
op_increment
op_assign
id|data
suffix:semicolon
macro_line|#ifdef CYCLOM_16Y_HACK
id|udelay
c_func
(paren
l_int|10L
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
id|queue_task_irq_off
c_func
(paren
op_amp
id|tty-&gt;flip.tqueue
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* end of service */
id|base_addr
(braket
id|CyRIR
op_lshift
id|index
)braket
op_assign
(paren
id|save_xir
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|save_car
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|CySRTransmit
)paren
(brace
multiline_comment|/* transmission interrupt */
multiline_comment|/* Since we only get here when the transmit buffer is empty,&n;                        we know we can always stuff a dozen characters. */
multiline_comment|/* determine the channel and change to that context */
id|save_xir
op_assign
(paren
id|u_char
)paren
id|base_addr
(braket
id|CyTIR
op_lshift
id|index
)braket
suffix:semicolon
id|channel
op_assign
(paren
id|u_short
)paren
(paren
id|save_xir
op_amp
id|CyIRChannel
)paren
suffix:semicolon
id|i
op_assign
id|channel
op_plus
id|chip
op_star
l_int|4
op_plus
id|cinfo-&gt;first_line
suffix:semicolon
id|save_car
op_assign
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
id|save_xir
suffix:semicolon
multiline_comment|/* validate the port number (as configured and open) */
r_if
c_cond
(paren
(paren
id|i
OL
l_int|0
)paren
op_logical_or
(paren
id|NR_PORTS
op_le
id|i
)paren
)paren
(brace
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_and_assign
op_complement
id|CyTxMpty
suffix:semicolon
r_goto
id|txend
suffix:semicolon
)brace
id|info
op_assign
op_amp
id|cy_port
(braket
id|i
)braket
suffix:semicolon
id|info-&gt;last_active
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
op_eq
l_int|0
)paren
(brace
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_and_assign
op_complement
id|CyTxMpty
suffix:semicolon
r_goto
id|txdone
suffix:semicolon
)brace
multiline_comment|/* load the on-chip space available for outbound data */
id|char_count
op_assign
id|info-&gt;xmit_fifo_size
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;x_char
)paren
(brace
multiline_comment|/* send special char */
id|outch
op_assign
id|info-&gt;x_char
suffix:semicolon
id|base_addr
(braket
id|CyTDR
op_lshift
id|index
)braket
op_assign
id|outch
suffix:semicolon
id|char_count
op_decrement
suffix:semicolon
id|info-&gt;x_char
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;x_break
)paren
(brace
multiline_comment|/*  The Cirrus chip requires the &quot;Embedded Transmit&n;&t;&t;&t;    Commands&quot; of start break, delay, and end break&n;&t;&t;&t;    sequences to be sent.  The duration of the&n;&t;&t;&t;    break is given in TICs, which runs at HZ&n;&t;&t;&t;    (typically 100) and the PPR runs at 200 Hz,&n;&t;&t;&t;    so the delay is duration * 200/HZ, and thus a&n;&t;&t;&t;    break can run from 1/100 sec to about 5/4 sec.&n;&t;&t;&t; */
id|base_addr
(braket
id|CyTDR
op_lshift
id|index
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* start break */
id|base_addr
(braket
id|CyTDR
op_lshift
id|index
)braket
op_assign
l_int|0x81
suffix:semicolon
id|base_addr
(braket
id|CyTDR
op_lshift
id|index
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* delay a bit */
id|base_addr
(braket
id|CyTDR
op_lshift
id|index
)braket
op_assign
l_int|0x82
suffix:semicolon
id|base_addr
(braket
id|CyTDR
op_lshift
id|index
)braket
op_assign
id|info-&gt;x_break
op_star
l_int|200
op_div
id|HZ
suffix:semicolon
id|base_addr
(braket
id|CyTDR
op_lshift
id|index
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* terminate break */
id|base_addr
(braket
id|CyTDR
op_lshift
id|index
)braket
op_assign
l_int|0x83
suffix:semicolon
id|char_count
op_sub_assign
l_int|7
suffix:semicolon
id|info-&gt;x_break
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|char_count
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;xmit_cnt
)paren
(brace
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_and_assign
op_complement
id|CyTxMpty
suffix:semicolon
r_goto
id|txdone
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;xmit_buf
op_eq
l_int|0
)paren
(brace
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_and_assign
op_complement
id|CyTxMpty
suffix:semicolon
r_goto
id|txdone
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;tty-&gt;stopped
op_logical_or
id|info-&gt;tty-&gt;hw_stopped
)paren
(brace
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_and_assign
op_complement
id|CyTxMpty
suffix:semicolon
r_goto
id|txdone
suffix:semicolon
)brace
multiline_comment|/* Because the Embedded Transmit Commands have been&n;                           enabled, we must check to see if the escape&n;                           character, NULL, is being sent.  If it is, we&n;                           must ensure that there is room for it to be&n;                           doubled in the output stream.  Therefore we&n;                           no longer advance the pointer when the character&n;                           is fetched, but rather wait until after the check&n;                           for a NULL output character. (This is necessary&n;                           because there may not be room for the two chars&n;                           needed to send a NULL.&n;&t;&t;         */
id|outch
op_assign
id|info-&gt;xmit_buf
(braket
id|info-&gt;xmit_tail
)braket
suffix:semicolon
r_if
c_cond
(paren
id|outch
)paren
(brace
id|info-&gt;xmit_cnt
op_decrement
suffix:semicolon
id|info-&gt;xmit_tail
op_assign
(paren
id|info-&gt;xmit_tail
op_plus
l_int|1
)paren
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|base_addr
(braket
id|CyTDR
op_lshift
id|index
)braket
op_assign
id|outch
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|char_count
OG
l_int|1
)paren
(brace
id|info-&gt;xmit_cnt
op_decrement
suffix:semicolon
id|info-&gt;xmit_tail
op_assign
(paren
id|info-&gt;xmit_tail
op_plus
l_int|1
)paren
op_amp
(paren
id|PAGE_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|base_addr
(braket
id|CyTDR
op_lshift
id|index
)braket
op_assign
id|outch
suffix:semicolon
id|base_addr
(braket
id|CyTDR
op_lshift
id|index
)braket
op_assign
l_int|0
suffix:semicolon
id|char_count
op_decrement
suffix:semicolon
)brace
r_else
(brace
)brace
)brace
)brace
id|txdone
suffix:colon
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
OL
id|WAKEUP_CHARS
)paren
(brace
id|cy_sched_event
c_func
(paren
id|info
comma
id|Cy_EVENT_WRITE_WAKEUP
)paren
suffix:semicolon
)brace
id|txend
suffix:colon
multiline_comment|/* end of service */
id|base_addr
(braket
id|CyTIR
op_lshift
id|index
)braket
op_assign
(paren
id|save_xir
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|save_car
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|CySRModem
)paren
(brace
multiline_comment|/* modem interrupt */
multiline_comment|/* determine the channel and change to that context */
id|save_xir
op_assign
(paren
id|u_char
)paren
id|base_addr
(braket
id|CyMIR
op_lshift
id|index
)braket
suffix:semicolon
id|channel
op_assign
(paren
id|u_short
)paren
(paren
id|save_xir
op_amp
id|CyIRChannel
)paren
suffix:semicolon
id|info
op_assign
op_amp
id|cy_port
(braket
id|channel
op_plus
id|chip
op_star
l_int|4
op_plus
id|cinfo-&gt;first_line
)braket
suffix:semicolon
id|info-&gt;last_active
op_assign
id|jiffies
suffix:semicolon
id|save_car
op_assign
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
id|save_xir
suffix:semicolon
id|mdm_change
op_assign
id|base_addr
(braket
id|CyMISR
op_lshift
id|index
)braket
suffix:semicolon
id|mdm_status
op_assign
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
op_eq
l_int|0
)paren
(brace
multiline_comment|/* nowhere to put the data, ignore it */
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|mdm_change
op_amp
id|CyDCD
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CHECK_CD
)paren
)paren
(brace
r_if
c_cond
(paren
id|mdm_status
op_amp
id|CyDCD
)paren
(brace
id|cy_sched_event
c_func
(paren
id|info
comma
id|Cy_EVENT_OPEN_WAKEUP
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_NOHUP
)paren
)paren
)paren
(brace
id|cy_sched_event
c_func
(paren
id|info
comma
id|Cy_EVENT_HANGUP
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|mdm_change
op_amp
id|CyCTS
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CTS_FLOW
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;tty-&gt;hw_stopped
)paren
(brace
r_if
c_cond
(paren
id|mdm_status
op_amp
id|CyCTS
)paren
(brace
multiline_comment|/* !!! cy_start isn&squot;t used because... */
id|info-&gt;tty-&gt;hw_stopped
op_assign
l_int|0
suffix:semicolon
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_or_assign
id|CyTxMpty
suffix:semicolon
id|cy_sched_event
c_func
(paren
id|info
comma
id|Cy_EVENT_WRITE_WAKEUP
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mdm_status
op_amp
id|CyCTS
)paren
)paren
(brace
multiline_comment|/* !!! cy_stop isn&squot;t used because... */
id|info-&gt;tty-&gt;hw_stopped
op_assign
l_int|1
suffix:semicolon
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_and_assign
op_complement
id|CyTxMpty
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|mdm_status
op_amp
id|CyDSR
)paren
(brace
)brace
r_if
c_cond
(paren
id|mdm_status
op_amp
id|CyRI
)paren
(brace
)brace
)brace
multiline_comment|/* end of service */
id|base_addr
(braket
id|CyMIR
op_lshift
id|index
)braket
op_assign
(paren
id|save_xir
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
id|save_car
suffix:semicolon
)brace
)brace
multiline_comment|/* end while status != 0 */
)brace
multiline_comment|/* end loop for chips... */
)brace
r_while
c_loop
(paren
id|had_work
)paren
(brace
suffix:semicolon
)brace
multiline_comment|/* clear interrupts */
op_star
(paren
id|card_base_addr
op_plus
(paren
id|Cy_ClrIntr
op_lshift
id|index
)paren
)paren
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Cy_ClrIntr is 0x1800 */
)brace
multiline_comment|/* cy_interrupt */
multiline_comment|/*&n; * This routine is used to handle the &quot;bottom half&quot; processing for the&n; * serial driver, known also the &quot;software interrupt&quot; processing.&n; * This processing is done at the kernel interrupt level, after the&n; * cy_interrupt() has returned, BUT WITH INTERRUPTS TURNED ON.  This&n; * is where time-consuming activities which can not be done in the&n; * interrupt driver proper are done; the interrupt driver schedules&n; * them using cy_sched_event(), and they get done here.&n; *&n; * This is done through one level of indirection--the task queue.&n; * When a hardware interrupt service routine wants service by the&n; * driver&squot;s bottom half, it enqueues the appropriate tq_struct (one&n; * per port) to the tq_cyclades work queue and sets a request flag&n; * via mark_bh for processing that queue.  When the time is right,&n; * do_cyclades_bh is called (because of the mark_bh) and it requests&n; * that the work queue be processed.&n; *&n; * Although this may seem unwieldy, it gives the system a way to&n; * pass an argument (in this case the pointer to the cyclades_port&n; * structure) to the bottom half of the driver.  Previous kernels&n; * had to poll every port to see if that port needed servicing.&n; */
r_static
r_void
DECL|function|do_cyclades_bh
id|do_cyclades_bh
c_func
(paren
r_void
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_cyclades
)paren
suffix:semicolon
)brace
multiline_comment|/* do_cyclades_bh */
r_static
r_void
DECL|function|do_softint
id|do_softint
c_func
(paren
r_void
op_star
id|private_
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|private_
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|tty
op_assign
id|info-&gt;tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|clear_bit
c_func
(paren
id|Cy_EVENT_HANGUP
comma
op_amp
id|info-&gt;event
)paren
)paren
(brace
id|tty_hangup
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|clear_bit
c_func
(paren
id|Cy_EVENT_OPEN_WAKEUP
comma
op_amp
id|info-&gt;event
)paren
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|clear_bit
c_func
(paren
id|Cy_EVENT_WRITE_WAKEUP
comma
op_amp
id|info-&gt;event
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(brace
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* do_softint */
multiline_comment|/*&n; * Grab all interrupts in preparation for doing an automatic irq&n; * detection.  dontgrab is a mask of irq&squot;s _not_ to grab.  Returns a&n; * mask of irq&squot;s which were grabbed and should therefore be freed&n; * using free_all_interrupts().&n; */
r_static
r_int
DECL|function|grab_all_interrupts
id|grab_all_interrupts
c_func
(paren
r_int
id|dontgrab
)paren
(brace
r_int
id|irq_lines
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|mask
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
comma
id|mask
op_lshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_amp
id|dontgrab
)paren
op_logical_and
op_logical_neg
id|request_irq
c_func
(paren
id|i
comma
id|cy_probe
comma
id|SA_INTERRUPT
comma
l_string|&quot;serial probe&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|irq_lines
op_or_assign
id|mask
suffix:semicolon
)brace
)brace
r_return
id|irq_lines
suffix:semicolon
)brace
multiline_comment|/* grab_all_interrupts */
multiline_comment|/*&n; * Release all interrupts grabbed by grab_all_interrupts&n; */
r_static
r_void
DECL|function|free_all_interrupts
id|free_all_interrupts
c_func
(paren
r_int
id|irq_lines
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|irq_lines
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
id|free_irq
c_func
(paren
id|i
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* free_all_interrupts */
multiline_comment|/*&n; * This routine returns a bitfield of &quot;wild interrupts&quot;.  Basically,&n; * any unclaimed interrupts which is flapping around.&n; */
r_static
r_int
DECL|function|check_wild_interrupts
id|check_wild_interrupts
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|mask
suffix:semicolon
r_int
id|wild_interrupts
op_assign
l_int|0
suffix:semicolon
r_int
id|irq_lines
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*Turn on interrupts (they may be off) */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|irq_lines
op_assign
id|grab_all_interrupts
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Delay for 0.1 seconds -- we use a busy loop since this may &n;&t; * occur during the bootup sequence&n;&t; */
id|timeout
op_assign
id|jiffies
op_plus
l_int|10
suffix:semicolon
r_while
c_loop
(paren
id|timeout
op_ge
id|jiffies
)paren
suffix:semicolon
id|cy_triggered
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Reset after letting things settle */
id|timeout
op_assign
id|jiffies
op_plus
l_int|10
suffix:semicolon
r_while
c_loop
(paren
id|timeout
op_ge
id|jiffies
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
comma
id|mask
op_lshift_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|cy_triggered
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
op_logical_and
(paren
id|irq_lines
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
)paren
(brace
id|wild_interrupts
op_or_assign
id|mask
suffix:semicolon
)brace
)brace
id|free_all_interrupts
c_func
(paren
id|irq_lines
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|wild_interrupts
suffix:semicolon
)brace
multiline_comment|/* check_wild_interrupts */
multiline_comment|/*&n; * This routine is called by do_auto_irq(); it attempts to determine&n; * which interrupt a serial port is configured to use.  It is not&n; * fool-proof, but it works a large part of the time.&n; */
r_static
r_int
DECL|function|get_auto_irq
id|get_auto_irq
c_func
(paren
r_int
r_char
op_star
id|address
)paren
(brace
r_int
r_int
id|timeout
suffix:semicolon
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|index
suffix:semicolon
id|index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* IRQ probing is only for ISA */
id|base_addr
op_assign
id|address
suffix:semicolon
id|intr_base_addr
op_assign
id|address
suffix:semicolon
multiline_comment|/*&n;     * Enable interrupts and see who answers&n;     */
id|cy_irq_triggered
op_assign
l_int|0
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
l_int|0
suffix:semicolon
id|write_cy_cmd
c_func
(paren
id|base_addr
comma
id|CyCHAN_CTL
op_or
id|CyENB_XMTR
comma
id|index
)paren
suffix:semicolon
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_or_assign
id|CyTxMpty
suffix:semicolon
id|probe_ready
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|timeout
op_ge
id|jiffies
)paren
(brace
r_if
c_cond
(paren
id|cy_irq_triggered
)paren
r_break
suffix:semicolon
)brace
id|probe_ready
op_assign
l_int|0
suffix:semicolon
r_return
id|cy_irq_triggered
suffix:semicolon
)brace
multiline_comment|/* get_auto_irq */
multiline_comment|/*&n; * Calls get_auto_irq() multiple times, to make sure we don&squot;t get&n; * faked out by random interrupts&n; */
r_static
r_int
DECL|function|do_auto_irq
id|do_auto_irq
c_func
(paren
r_int
r_char
op_star
id|address
)paren
(brace
r_int
id|irq_lines
op_assign
l_int|0
suffix:semicolon
r_int
id|irq_try_1
op_assign
l_int|0
comma
id|irq_try_2
op_assign
l_int|0
suffix:semicolon
r_int
id|retries
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Turn on interrupts (they may be off) */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|probe_ready
op_assign
l_int|0
suffix:semicolon
id|cy_wild_int_mask
op_assign
id|check_wild_interrupts
c_func
(paren
)paren
suffix:semicolon
id|irq_lines
op_assign
id|grab_all_interrupts
c_func
(paren
id|cy_wild_int_mask
)paren
suffix:semicolon
r_for
c_loop
(paren
id|retries
op_assign
l_int|0
suffix:semicolon
id|retries
OL
l_int|5
suffix:semicolon
id|retries
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|irq_try_1
)paren
id|irq_try_1
op_assign
id|get_auto_irq
c_func
(paren
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|irq_try_2
)paren
id|irq_try_2
op_assign
id|get_auto_irq
c_func
(paren
id|address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_try_1
op_logical_and
id|irq_try_2
)paren
(brace
r_if
c_cond
(paren
id|irq_try_1
op_eq
id|irq_try_2
)paren
r_break
suffix:semicolon
id|irq_try_1
op_assign
id|irq_try_2
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|free_all_interrupts
c_func
(paren
id|irq_lines
)paren
suffix:semicolon
r_return
(paren
id|irq_try_1
op_eq
id|irq_try_2
)paren
ques
c_cond
id|irq_try_1
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* do_auto_irq */
multiline_comment|/* This is called whenever a port becomes active;&n;   interrupts are enabled and DTR &amp; RTS are turned on.&n; */
r_static
r_int
DECL|function|startup
id|startup
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|card
comma
id|chip
comma
id|channel
comma
id|index
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;type
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;tty
)paren
(brace
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;xmit_buf
)paren
(brace
id|info-&gt;xmit_buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|get_free_page
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;xmit_buf
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|config_setup
c_func
(paren
id|info
)paren
suffix:semicolon
id|card
op_assign
id|info-&gt;card
suffix:semicolon
id|channel
op_assign
(paren
id|info-&gt;line
)paren
op_minus
(paren
id|cy_card
(braket
id|card
)braket
dot
id|first_line
)paren
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|index
op_assign
id|cy_card
(braket
id|card
)braket
dot
id|bus_index
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;startup card %d, chip %d, channel %d, base_addr %lx&quot;
comma
id|card
comma
id|chip
comma
id|channel
comma
(paren
r_int
)paren
id|base_addr
)paren
suffix:semicolon
multiline_comment|/**/
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyRTPR
op_lshift
id|index
)braket
op_assign
(paren
id|info-&gt;default_timeout
ques
c_cond
id|info-&gt;default_timeout
suffix:colon
l_int|0x02
)paren
suffix:semicolon
multiline_comment|/* 10ms rx timeout */
id|write_cy_cmd
c_func
(paren
id|base_addr
comma
id|CyCHAN_CTL
op_or
id|CyENB_RCVR
op_or
id|CyENB_XMTR
comma
id|index
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
multiline_comment|/* !!! Is this needed? */
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
op_assign
id|CyRTS
suffix:semicolon
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
op_assign
id|CyDTR
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: raising DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
comma
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
)paren
suffix:semicolon
macro_line|#endif
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_or_assign
id|CyRxData
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|ASYNC_INITIALIZED
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;tty
)paren
(brace
id|clear_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
)brace
id|info-&gt;xmit_cnt
op_assign
id|info-&gt;xmit_head
op_assign
id|info-&gt;xmit_tail
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot; done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* startup */
r_void
DECL|function|start_xmit
id|start_xmit
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|card
comma
id|chip
comma
id|channel
comma
id|index
suffix:semicolon
id|card
op_assign
id|info-&gt;card
suffix:semicolon
id|channel
op_assign
(paren
id|info-&gt;line
)paren
op_minus
(paren
id|cy_card
(braket
id|card
)braket
dot
id|first_line
)paren
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|index
op_assign
id|cy_card
(braket
id|card
)braket
dot
id|bus_index
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
id|channel
suffix:semicolon
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_or_assign
id|CyTxMpty
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* start_xmit */
multiline_comment|/*&n; * This routine shuts down a serial port; interrupts are disabled,&n; * and DTR is dropped if the hangup on close termio flag is on.&n; */
r_static
r_void
DECL|function|shutdown
id|shutdown
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|card
comma
id|chip
comma
id|channel
comma
id|index
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|card
op_assign
id|info-&gt;card
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
op_minus
id|cy_card
(braket
id|card
)braket
dot
id|first_line
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|index
op_assign
id|cy_card
(braket
id|card
)braket
dot
id|bus_index
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;shutdown card %d, chip %d, channel %d, base_addr %lx&bslash;n&quot;
comma
id|card
comma
id|chip
comma
id|channel
comma
(paren
r_int
)paren
id|base_addr
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* !!! REALLY MUST WAIT FOR LAST CHARACTER TO BE&n;       SENT BEFORE DROPPING THE LINE !!!  (Perhaps&n;       set some flag that is read when XMTY happens.)&n;       Other choices are to delay some fixed interval&n;       or schedule some later processing.&n;     */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;xmit_buf
)paren
(brace
r_int
r_char
op_star
id|temp
suffix:semicolon
id|temp
op_assign
id|info-&gt;xmit_buf
suffix:semicolon
id|info-&gt;xmit_buf
op_assign
l_int|0
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|temp
)paren
suffix:semicolon
)brace
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tty
op_logical_or
(paren
id|info-&gt;tty-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
)paren
(brace
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
op_assign
op_complement
id|CyRTS
suffix:semicolon
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
op_assign
op_complement
id|CyDTR
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: dropping DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
comma
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
id|write_cy_cmd
c_func
(paren
id|base_addr
comma
id|CyCHAN_CTL
op_or
id|CyDIS_RCVR
comma
id|index
)paren
suffix:semicolon
multiline_comment|/* it may be appropriate to clear _XMIT at&n;           some later date (after testing)!!! */
r_if
c_cond
(paren
id|info-&gt;tty
)paren
(brace
id|set_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
)brace
id|info-&gt;flags
op_and_assign
op_complement
id|ASYNC_INITIALIZED
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot; done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* shutdown */
multiline_comment|/*&n; * This routine finds or computes the various line characteristics.&n; */
r_static
r_void
DECL|function|config_setup
id|config_setup
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|card
comma
id|chip
comma
id|channel
comma
id|index
suffix:semicolon
r_int
id|cflag
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;tty
op_logical_or
op_logical_neg
id|info-&gt;tty-&gt;termios
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;line
op_eq
op_minus
l_int|1
)paren
(brace
r_return
suffix:semicolon
)brace
id|cflag
op_assign
id|info-&gt;tty-&gt;termios-&gt;c_cflag
suffix:semicolon
multiline_comment|/* baud rate */
id|i
op_assign
id|cflag
op_amp
id|CBAUD
suffix:semicolon
macro_line|#ifdef CBAUDEX
multiline_comment|/* Starting with kernel 1.1.65, there is direct support for&n;   higher baud rates.  The following code supports those&n;   changes.  The conditional aspect allows this driver to be&n;   used for earlier as well as later kernel versions.  (The&n;   mapping is slightly different from serial.c because there&n;   is still the possibility of supporting 75 kbit/sec with&n;   the Cyclades board.)&n; */
r_if
c_cond
(paren
id|i
op_amp
id|CBAUDEX
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|B57600
)paren
id|i
op_assign
l_int|16
suffix:semicolon
r_else
r_if
c_cond
(paren
id|i
op_eq
id|B115200
)paren
(brace
id|i
op_assign
l_int|18
suffix:semicolon
)brace
macro_line|#ifdef B78600
r_else
r_if
c_cond
(paren
id|i
op_eq
id|B78600
)paren
(brace
id|i
op_assign
l_int|17
suffix:semicolon
)brace
macro_line|#endif
r_else
id|info-&gt;tty-&gt;termios-&gt;c_cflag
op_and_assign
op_complement
id|CBAUDEX
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|i
op_eq
l_int|15
)paren
(brace
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_HI
)paren
id|i
op_add_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SPD_MASK
)paren
op_eq
id|ASYNC_SPD_VHI
)paren
id|i
op_add_assign
l_int|3
suffix:semicolon
)brace
id|info-&gt;tbpr
op_assign
id|baud_bpr
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Tx BPR */
id|info-&gt;tco
op_assign
id|baud_co
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Tx CO */
id|info-&gt;rbpr
op_assign
id|baud_bpr
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Rx BPR */
id|info-&gt;rco
op_assign
id|baud_co
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Rx CO */
r_if
c_cond
(paren
id|baud_table
(braket
id|i
)braket
op_eq
l_int|134
)paren
(brace
id|info-&gt;timeout
op_assign
(paren
id|info-&gt;xmit_fifo_size
op_star
id|HZ
op_star
l_int|30
op_div
l_int|269
)paren
op_plus
l_int|2
suffix:semicolon
multiline_comment|/* get it right for 134.5 baud */
)brace
r_else
r_if
c_cond
(paren
id|baud_table
(braket
id|i
)braket
)paren
(brace
id|info-&gt;timeout
op_assign
(paren
id|info-&gt;xmit_fifo_size
op_star
id|HZ
op_star
l_int|15
op_div
id|baud_table
(braket
id|i
)braket
)paren
op_plus
l_int|2
suffix:semicolon
multiline_comment|/* this needs to be propagated into the card info */
)brace
r_else
(brace
id|info-&gt;timeout
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* By tradition (is it a standard?) a baud rate of zero&n;       implies the line should be/has been closed.  A bit&n;       later in this routine such a test is performed. */
multiline_comment|/* byte size and parity */
id|info-&gt;cor5
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cor4
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cor3
op_assign
(paren
id|info-&gt;default_threshold
ques
c_cond
id|info-&gt;default_threshold
suffix:colon
id|baud_cor3
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/* receive threshold */
id|info-&gt;cor2
op_assign
id|CyETC
suffix:semicolon
r_switch
c_cond
(paren
id|cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|info-&gt;cor1
op_assign
id|Cy_5_BITS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|info-&gt;cor1
op_assign
id|Cy_6_BITS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|info-&gt;cor1
op_assign
id|Cy_7_BITS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS8
suffix:colon
id|info-&gt;cor1
op_assign
id|Cy_8_BITS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|CSTOPB
)paren
(brace
id|info-&gt;cor1
op_or_assign
id|Cy_2_STOP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|PARENB
)paren
(brace
r_if
c_cond
(paren
id|cflag
op_amp
id|PARODD
)paren
(brace
id|info-&gt;cor1
op_or_assign
id|CyPARITY_O
suffix:semicolon
)brace
r_else
(brace
id|info-&gt;cor1
op_or_assign
id|CyPARITY_E
suffix:semicolon
)brace
)brace
r_else
(brace
id|info-&gt;cor1
op_or_assign
id|CyPARITY_NONE
suffix:semicolon
)brace
multiline_comment|/* CTS flow control flag */
r_if
c_cond
(paren
id|cflag
op_amp
id|CRTSCTS
)paren
(brace
id|info-&gt;flags
op_or_assign
id|ASYNC_CTS_FLOW
suffix:semicolon
id|info-&gt;cor2
op_or_assign
id|CyCtsAE
suffix:semicolon
)brace
r_else
(brace
id|info-&gt;flags
op_and_assign
op_complement
id|ASYNC_CTS_FLOW
suffix:semicolon
id|info-&gt;cor2
op_and_assign
op_complement
id|CyCtsAE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cflag
op_amp
id|CLOCAL
)paren
id|info-&gt;flags
op_and_assign
op_complement
id|ASYNC_CHECK_CD
suffix:semicolon
r_else
id|info-&gt;flags
op_or_assign
id|ASYNC_CHECK_CD
suffix:semicolon
multiline_comment|/***********************************************&n;&t;The hardware option, CyRtsAO, presents RTS when&n;&t;the chip has characters to send.  Since most modems&n;&t;use RTS as reverse (inbound) flow control, this&n;&t;option is not used.  If inbound flow control is&n;&t;necessary, DTR can be programmed to provide the&n;&t;appropriate signals for use with a non-standard&n;&t;cable.  Contact Marcio Saito for details.&n;     ***********************************************/
id|card
op_assign
id|info-&gt;card
suffix:semicolon
id|channel
op_assign
(paren
id|info-&gt;line
)paren
op_minus
(paren
id|cy_card
(braket
id|card
)braket
dot
id|first_line
)paren
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|index
op_assign
id|cy_card
(braket
id|card
)braket
dot
id|bus_index
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
multiline_comment|/* tx and rx baud rate */
id|base_addr
(braket
id|CyTCOR
op_lshift
id|index
)braket
op_assign
id|info-&gt;tco
suffix:semicolon
id|base_addr
(braket
id|CyTBPR
op_lshift
id|index
)braket
op_assign
id|info-&gt;tbpr
suffix:semicolon
id|base_addr
(braket
id|CyRCOR
op_lshift
id|index
)braket
op_assign
id|info-&gt;rco
suffix:semicolon
id|base_addr
(braket
id|CyRBPR
op_lshift
id|index
)braket
op_assign
id|info-&gt;rbpr
suffix:semicolon
multiline_comment|/* set line characteristics  according configuration */
id|base_addr
(braket
id|CySCHR1
op_lshift
id|index
)braket
op_assign
id|START_CHAR
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
id|base_addr
(braket
id|CySCHR2
op_lshift
id|index
)braket
op_assign
id|STOP_CHAR
c_func
(paren
id|info-&gt;tty
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCOR1
op_lshift
id|index
)braket
op_assign
id|info-&gt;cor1
suffix:semicolon
id|base_addr
(braket
id|CyCOR2
op_lshift
id|index
)braket
op_assign
id|info-&gt;cor2
suffix:semicolon
id|base_addr
(braket
id|CyCOR3
op_lshift
id|index
)braket
op_assign
id|info-&gt;cor3
suffix:semicolon
id|base_addr
(braket
id|CyCOR4
op_lshift
id|index
)braket
op_assign
id|info-&gt;cor4
suffix:semicolon
id|base_addr
(braket
id|CyCOR5
op_lshift
id|index
)braket
op_assign
id|info-&gt;cor5
suffix:semicolon
id|write_cy_cmd
c_func
(paren
id|base_addr
comma
id|CyCOR_CHANGE
op_or
id|CyCOR1ch
op_or
id|CyCOR2ch
op_or
id|CyCOR3ch
comma
id|index
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
multiline_comment|/* !!! Is this needed? */
id|base_addr
(braket
id|CyRTPR
op_lshift
id|index
)braket
op_assign
(paren
id|info-&gt;default_timeout
ques
c_cond
id|info-&gt;default_timeout
suffix:colon
l_int|0x02
)paren
suffix:semicolon
multiline_comment|/* 10ms rx timeout */
r_if
c_cond
(paren
id|C_CLOCAL
c_func
(paren
id|info-&gt;tty
)paren
)paren
(brace
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_or_assign
id|CyMdmCh
suffix:semicolon
multiline_comment|/* without modem intr */
multiline_comment|/* act on 1-&gt;0 modem transitions */
id|base_addr
(braket
id|CyMCOR1
op_lshift
id|index
)braket
op_assign
id|CyCTS
suffix:semicolon
multiline_comment|/* act on 0-&gt;1 modem transitions */
id|base_addr
(braket
id|CyMCOR2
op_lshift
id|index
)braket
op_assign
id|CyCTS
suffix:semicolon
)brace
r_else
(brace
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_or_assign
id|CyMdmCh
suffix:semicolon
multiline_comment|/* with modem intr */
multiline_comment|/* act on 1-&gt;0 modem transitions */
id|base_addr
(braket
id|CyMCOR1
op_lshift
id|index
)braket
op_assign
id|CyDSR
op_or
id|CyCTS
op_or
id|CyRI
op_or
id|CyDCD
suffix:semicolon
multiline_comment|/* act on 0-&gt;1 modem transitions */
id|base_addr
(braket
id|CyMCOR2
op_lshift
id|index
)braket
op_assign
id|CyDSR
op_or
id|CyCTS
op_or
id|CyRI
op_or
id|CyDCD
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
multiline_comment|/* baud rate is zero, turn off line */
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
op_assign
op_complement
id|CyDTR
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: dropping DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
comma
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
op_assign
id|CyDTR
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: raising DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
comma
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|info-&gt;tty
)paren
(brace
id|clear_bit
c_func
(paren
id|TTY_IO_ERROR
comma
op_amp
id|info-&gt;tty-&gt;flags
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* config_setup */
r_static
r_void
DECL|function|cy_put_char
id|cy_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;cy_put_char ttyC%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_put_char&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
op_logical_neg
id|info-&gt;xmit_buf
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
op_ge
id|PAGE_SIZE
op_minus
l_int|1
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|info-&gt;xmit_buf
(braket
id|info-&gt;xmit_head
op_increment
)braket
op_assign
id|ch
suffix:semicolon
id|info-&gt;xmit_head
op_and_assign
id|PAGE_SIZE
op_minus
l_int|1
suffix:semicolon
id|info-&gt;xmit_cnt
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* cy_put_char */
r_static
r_void
DECL|function|cy_flush_chars
id|cy_flush_chars
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|card
comma
id|chip
comma
id|channel
comma
id|index
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;cy_flush_chars ttyC%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_flush_chars&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
op_le
l_int|0
op_logical_or
id|tty-&gt;stopped
op_logical_or
id|tty-&gt;hw_stopped
op_logical_or
op_logical_neg
id|info-&gt;xmit_buf
)paren
r_return
suffix:semicolon
id|card
op_assign
id|info-&gt;card
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
op_minus
id|cy_card
(braket
id|card
)braket
dot
id|first_line
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|index
op_assign
id|cy_card
(braket
id|card
)braket
dot
id|bus_index
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
id|channel
suffix:semicolon
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
op_or_assign
id|CyTxMpty
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* cy_flush_chars */
multiline_comment|/* This routine gets called when tty_write has put something into&n;    the write_queue.  If the port is not already transmitting stuff,&n;    start it off by enabling interrupts.  The interrupt service&n;    routine will then ensure that the characters are sent.  If the&n;    port is already active, there is no need to kick it.&n; */
r_static
r_int
DECL|function|cy_write
id|cy_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|c
comma
id|total
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;cy_write ttyC%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_write&quot;
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
op_logical_neg
id|info-&gt;xmit_buf
op_logical_or
op_logical_neg
id|tmp_buf
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|c
op_assign
id|MIN
c_func
(paren
id|count
comma
id|MIN
c_func
(paren
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_cnt
op_minus
l_int|1
comma
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_head
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_le
l_int|0
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|from_user
)paren
(brace
id|down
c_func
(paren
op_amp
id|tmp_buf_sem
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|tmp_buf
comma
id|buf
comma
id|c
)paren
suffix:semicolon
id|c
op_assign
id|MIN
c_func
(paren
id|c
comma
id|MIN
c_func
(paren
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_cnt
op_minus
l_int|1
comma
id|SERIAL_XMIT_SIZE
op_minus
id|info-&gt;xmit_head
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|info-&gt;xmit_buf
op_plus
id|info-&gt;xmit_head
comma
id|tmp_buf
comma
id|c
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|tmp_buf_sem
)paren
suffix:semicolon
)brace
r_else
id|memcpy
c_func
(paren
id|info-&gt;xmit_buf
op_plus
id|info-&gt;xmit_head
comma
id|buf
comma
id|c
)paren
suffix:semicolon
id|info-&gt;xmit_head
op_assign
(paren
id|info-&gt;xmit_head
op_plus
id|c
)paren
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|info-&gt;xmit_cnt
op_add_assign
id|c
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|buf
op_add_assign
id|c
suffix:semicolon
id|count
op_sub_assign
id|c
suffix:semicolon
id|total
op_add_assign
id|c
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;xmit_cnt
op_logical_and
op_logical_neg
id|tty-&gt;stopped
op_logical_and
op_logical_neg
id|tty-&gt;hw_stopped
)paren
(brace
id|start_xmit
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
r_return
id|total
suffix:semicolon
)brace
multiline_comment|/* cy_write */
r_static
r_int
DECL|function|cy_write_room
id|cy_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|ret
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;cy_write_room ttyC%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_write_room&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|ret
op_assign
id|PAGE_SIZE
op_minus
id|info-&gt;xmit_cnt
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* cy_write_room */
r_static
r_int
DECL|function|cy_chars_in_buffer
id|cy_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;cy_chars_in_buffer ttyC%d %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;xmit_cnt
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_chars_in_buffer&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|info-&gt;xmit_cnt
suffix:semicolon
)brace
multiline_comment|/* cy_chars_in_buffer */
r_static
r_void
DECL|function|cy_flush_buffer
id|cy_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_IO
id|printk
c_func
(paren
l_string|&quot;cy_flush_buffer ttyC%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_flush_buffer&quot;
)paren
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|info-&gt;xmit_cnt
op_assign
id|info-&gt;xmit_head
op_assign
id|info-&gt;xmit_tail
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* cy_flush_buffer */
multiline_comment|/* This routine is called by the upper-layer tty layer to signal&n;   that incoming characters should be throttled or that the&n;   throttle should be released.&n; */
r_static
r_void
DECL|function|cy_throttle
id|cy_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|card
comma
id|chip
comma
id|channel
comma
id|index
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_THROTTLE
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;throttle %s: %d....&bslash;n&quot;
comma
id|_tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
comma
id|tty-&gt;ldisc
dot
id|chars_in_buffer
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cy_throttle ttyC%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_nthrottle&quot;
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
(brace
id|info-&gt;x_char
op_assign
id|STOP_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/* Should use the &quot;Send Special Character&quot; feature!!! */
)brace
id|card
op_assign
id|info-&gt;card
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
op_minus
id|cy_card
(braket
id|card
)braket
dot
id|first_line
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|index
op_assign
id|cy_card
(braket
id|card
)braket
dot
id|bus_index
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
op_assign
op_complement
id|CyRTS
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* cy_throttle */
r_static
r_void
DECL|function|cy_unthrottle
id|cy_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|card
comma
id|chip
comma
id|channel
comma
id|index
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_THROTTLE
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;throttle %s: %d....&bslash;n&quot;
comma
id|_tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
comma
id|tty-&gt;ldisc
dot
id|chars_in_buffer
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cy_unthrottle ttyC%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_nthrottle&quot;
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
(brace
id|info-&gt;x_char
op_assign
id|START_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/* Should use the &quot;Send Special Character&quot; feature!!! */
)brace
id|card
op_assign
id|info-&gt;card
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
op_minus
id|cy_card
(braket
id|card
)braket
dot
id|first_line
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|index
op_assign
id|cy_card
(braket
id|card
)braket
dot
id|bus_index
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
op_assign
id|CyRTS
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* cy_unthrottle */
r_static
r_int
DECL|function|get_serial_info
id|get_serial_info
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_struct
id|serial_struct
op_star
id|retinfo
)paren
(brace
r_struct
id|serial_struct
id|tmp
suffix:semicolon
r_struct
id|cyclades_card
op_star
id|cinfo
op_assign
op_amp
id|cy_card
(braket
id|info-&gt;card
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retinfo
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tmp
comma
l_int|0
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
id|tmp.type
op_assign
id|info-&gt;type
suffix:semicolon
id|tmp.line
op_assign
id|info-&gt;line
suffix:semicolon
id|tmp.port
op_assign
id|info-&gt;card
op_star
l_int|0x100
op_plus
id|info-&gt;line
op_minus
id|cinfo-&gt;first_line
suffix:semicolon
id|tmp.irq
op_assign
id|cinfo-&gt;irq
suffix:semicolon
id|tmp.flags
op_assign
id|info-&gt;flags
suffix:semicolon
id|tmp.baud_base
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*!!!*/
id|tmp.close_delay
op_assign
id|info-&gt;close_delay
suffix:semicolon
id|tmp.custom_divisor
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*!!!*/
id|tmp.hub6
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*!!!*/
id|memcpy_tofs
c_func
(paren
id|retinfo
comma
op_amp
id|tmp
comma
r_sizeof
(paren
op_star
id|retinfo
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* get_serial_info */
r_static
r_int
DECL|function|set_serial_info
id|set_serial_info
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_struct
id|serial_struct
op_star
id|new_info
)paren
(brace
r_struct
id|serial_struct
id|new_serial
suffix:semicolon
r_struct
id|cyclades_port
id|old_info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|new_info
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|new_serial
comma
id|new_info
comma
r_sizeof
(paren
id|new_serial
)paren
)paren
suffix:semicolon
id|old_info
op_assign
op_star
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|new_serial.close_delay
op_ne
id|info-&gt;close_delay
)paren
op_logical_or
(paren
(paren
id|new_serial.flags
op_amp
id|ASYNC_FLAGS
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
op_ne
(paren
id|info-&gt;flags
op_amp
id|ASYNC_FLAGS
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|info-&gt;flags
op_assign
(paren
(paren
id|info-&gt;flags
op_amp
op_complement
id|ASYNC_USR_MASK
)paren
op_or
(paren
id|new_serial.flags
op_amp
id|ASYNC_USR_MASK
)paren
)paren
suffix:semicolon
r_goto
id|check_and_exit
suffix:semicolon
)brace
multiline_comment|/*&n;     * OK, past this point, all the error checking has been done.&n;     * At this point, we start making changes.....&n;     */
id|info-&gt;flags
op_assign
(paren
(paren
id|info-&gt;flags
op_amp
op_complement
id|ASYNC_FLAGS
)paren
op_or
(paren
id|new_serial.flags
op_amp
id|ASYNC_FLAGS
)paren
)paren
suffix:semicolon
id|info-&gt;close_delay
op_assign
id|new_serial.close_delay
suffix:semicolon
id|check_and_exit
suffix:colon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
(brace
id|config_setup
c_func
(paren
id|info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_return
id|startup
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* set_serial_info */
r_static
r_int
DECL|function|get_modem_info
id|get_modem_info
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
id|card
comma
id|chip
comma
id|channel
comma
id|index
suffix:semicolon
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
r_int
id|result
suffix:semicolon
id|card
op_assign
id|info-&gt;card
suffix:semicolon
id|channel
op_assign
(paren
id|info-&gt;line
)paren
op_minus
(paren
id|cy_card
(braket
id|card
)braket
dot
id|first_line
)paren
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|index
op_assign
id|cy_card
(braket
id|card
)braket
dot
id|bus_index
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|status
op_assign
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
suffix:semicolon
id|status
op_or_assign
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|result
op_assign
(paren
(paren
id|status
op_amp
id|CyRTS
)paren
ques
c_cond
id|TIOCM_RTS
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
id|CyDTR
)paren
ques
c_cond
id|TIOCM_DTR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
id|CyDCD
)paren
ques
c_cond
id|TIOCM_CAR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
id|CyRI
)paren
ques
c_cond
id|TIOCM_RNG
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
id|CyDSR
)paren
ques
c_cond
id|TIOCM_DSR
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|status
op_amp
id|CyCTS
)paren
ques
c_cond
id|TIOCM_CTS
suffix:colon
l_int|0
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|result
comma
(paren
r_int
r_int
op_star
)paren
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* get_modem_info */
r_static
r_int
DECL|function|set_modem_info
id|set_modem_info
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
id|cmd
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
id|card
comma
id|chip
comma
id|channel
comma
id|index
suffix:semicolon
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|arg
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|value
)paren
suffix:semicolon
id|card
op_assign
id|info-&gt;card
suffix:semicolon
id|channel
op_assign
(paren
id|info-&gt;line
)paren
op_minus
(paren
id|cy_card
(braket
id|card
)braket
dot
id|first_line
)paren
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|index
op_assign
id|cy_card
(braket
id|card
)braket
dot
id|bus_index
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCMBIS
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
op_assign
id|CyRTS
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
op_assign
id|CyDTR
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: raising DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
comma
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMBIC
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
op_assign
op_complement
id|CyRTS
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
op_assign
op_complement
id|CyDTR
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: dropping DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
comma
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_RTS
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
op_assign
id|CyRTS
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
op_assign
op_complement
id|CyRTS
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_amp
id|TIOCM_DTR
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
op_assign
id|CyDTR
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: raising DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
comma
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
op_assign
op_complement
id|CyDTR
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: dropping DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
comma
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* set_modem_info */
r_static
r_void
DECL|function|send_break
id|send_break
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
id|duration
)paren
(brace
multiline_comment|/* Let the transmit ISR take care of this (since it&n;     requires stuffing characters into the output stream).&n;   */
id|info-&gt;x_break
op_assign
id|duration
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;xmit_cnt
)paren
(brace
id|start_xmit
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* send_break */
r_static
r_int
DECL|function|get_mon_info
id|get_mon_info
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_struct
id|cyclades_monitor
op_star
id|mon
)paren
(brace
id|memcpy_tofs
c_func
(paren
id|mon
comma
op_amp
id|info-&gt;mon
comma
r_sizeof
(paren
r_struct
id|cyclades_monitor
)paren
)paren
suffix:semicolon
id|info-&gt;mon.int_count
op_assign
l_int|0
suffix:semicolon
id|info-&gt;mon.char_count
op_assign
l_int|0
suffix:semicolon
id|info-&gt;mon.char_max
op_assign
l_int|0
suffix:semicolon
id|info-&gt;mon.char_last
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_threshold
id|set_threshold
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
id|value
)paren
(brace
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|card
comma
id|channel
comma
id|chip
comma
id|index
suffix:semicolon
id|card
op_assign
id|info-&gt;card
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
op_minus
id|cy_card
(braket
id|card
)braket
dot
id|first_line
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|index
op_assign
id|cy_card
(braket
id|card
)braket
dot
id|bus_index
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
id|info-&gt;cor3
op_and_assign
op_complement
id|CyREC_FIFO
suffix:semicolon
id|info-&gt;cor3
op_or_assign
id|value
op_amp
id|CyREC_FIFO
suffix:semicolon
id|base_addr
(braket
id|CyCOR3
op_lshift
id|index
)braket
op_assign
id|info-&gt;cor3
suffix:semicolon
id|write_cy_cmd
c_func
(paren
id|base_addr
comma
id|CyCOR_CHANGE
op_or
id|CyCOR3ch
comma
id|index
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|get_threshold
id|get_threshold
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|card
comma
id|channel
comma
id|chip
comma
id|index
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|card
op_assign
id|info-&gt;card
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
op_minus
id|cy_card
(braket
id|card
)braket
dot
id|first_line
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|index
op_assign
id|cy_card
(braket
id|card
)braket
dot
id|bus_index
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
id|tmp
op_assign
id|base_addr
(braket
id|CyCOR3
op_lshift
id|index
)braket
op_amp
id|CyREC_FIFO
suffix:semicolon
id|put_fs_long
c_func
(paren
id|tmp
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_default_threshold
id|set_default_threshold
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
id|value
)paren
(brace
id|info-&gt;default_threshold
op_assign
id|value
op_amp
l_int|0x0f
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|get_default_threshold
id|get_default_threshold
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
op_star
id|value
)paren
(brace
id|put_fs_long
c_func
(paren
id|info-&gt;default_threshold
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_timeout
id|set_timeout
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
id|value
)paren
(brace
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|card
comma
id|channel
comma
id|chip
comma
id|index
suffix:semicolon
id|card
op_assign
id|info-&gt;card
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
op_minus
id|cy_card
(braket
id|card
)braket
dot
id|first_line
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|index
op_assign
id|cy_card
(braket
id|card
)braket
dot
id|bus_index
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyRTPR
op_lshift
id|index
)braket
op_assign
id|value
op_amp
l_int|0xff
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|get_timeout
id|get_timeout
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
op_star
id|value
)paren
(brace
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|card
comma
id|channel
comma
id|chip
comma
id|index
suffix:semicolon
r_int
r_int
id|tmp
suffix:semicolon
id|card
op_assign
id|info-&gt;card
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
op_minus
id|cy_card
(braket
id|card
)braket
dot
id|first_line
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|index
op_assign
id|cy_card
(braket
id|card
)braket
dot
id|bus_index
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
id|tmp
op_assign
id|base_addr
(braket
id|CyRTPR
op_lshift
id|index
)braket
suffix:semicolon
id|put_fs_long
c_func
(paren
id|tmp
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|set_default_timeout
id|set_default_timeout
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
id|value
)paren
(brace
id|info-&gt;default_timeout
op_assign
id|value
op_amp
l_int|0xff
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|get_default_timeout
id|get_default_timeout
c_func
(paren
r_struct
id|cyclades_port
op_star
id|info
comma
r_int
r_int
op_star
id|value
)paren
(brace
id|put_fs_long
c_func
(paren
id|info-&gt;default_timeout
comma
id|value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|cy_ioctl
id|cy_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|error
suffix:semicolon
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|ret_val
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_ioctl ttyC%d, cmd = %x arg = %lx&bslash;n&quot;
comma
id|info-&gt;line
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CYGETMON
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|cyclades_monitor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ret_val
op_assign
id|error
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret_val
op_assign
id|get_mon_info
c_func
(paren
id|info
comma
(paren
r_struct
id|cyclades_monitor
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYGETTHRESH
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ret_val
op_assign
id|error
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret_val
op_assign
id|get_threshold
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYSETTHRESH
suffix:colon
id|ret_val
op_assign
id|set_threshold
c_func
(paren
id|info
comma
(paren
r_int
r_int
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYGETDEFTHRESH
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ret_val
op_assign
id|error
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret_val
op_assign
id|get_default_threshold
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYSETDEFTHRESH
suffix:colon
id|ret_val
op_assign
id|set_default_threshold
c_func
(paren
id|info
comma
(paren
r_int
r_int
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYGETTIMEOUT
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ret_val
op_assign
id|error
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret_val
op_assign
id|get_timeout
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYSETTIMEOUT
suffix:colon
id|ret_val
op_assign
id|set_timeout
c_func
(paren
id|info
comma
(paren
r_int
r_int
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYGETDEFTIMEOUT
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ret_val
op_assign
id|error
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret_val
op_assign
id|get_default_timeout
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CYSETDEFTIMEOUT
suffix:colon
id|ret_val
op_assign
id|set_default_timeout
c_func
(paren
id|info
comma
(paren
r_int
r_int
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TCSBRK
suffix:colon
multiline_comment|/* SVID version: non-zero arg --&gt; no break */
id|ret_val
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
)paren
r_return
id|ret_val
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
id|send_break
c_func
(paren
id|info
comma
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
multiline_comment|/* 1/4 second */
r_break
suffix:semicolon
r_case
id|TCSBRKP
suffix:colon
multiline_comment|/* support for POSIX tcsendbreak() */
id|ret_val
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_val
)paren
r_return
id|ret_val
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
id|send_break
c_func
(paren
id|info
comma
id|arg
ques
c_cond
id|arg
op_star
(paren
id|HZ
op_div
l_int|10
)paren
suffix:colon
id|HZ
op_div
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
r_case
id|TIOCMBIC
suffix:colon
r_case
id|TIOCMSET
suffix:colon
id|ret_val
op_assign
id|set_modem_info
c_func
(paren
id|info
comma
id|cmd
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* The following commands are incompletely implemented!!! */
r_case
id|TIOCGSOFTCAR
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ret_val
op_assign
id|error
suffix:semicolon
r_break
suffix:semicolon
)brace
id|put_fs_long
c_func
(paren
id|C_CLOCAL
c_func
(paren
id|tty
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSSOFTCAR
suffix:colon
id|arg
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|tty-&gt;termios-&gt;c_cflag
op_assign
(paren
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
op_complement
id|CLOCAL
)paren
op_or
(paren
id|arg
ques
c_cond
id|CLOCAL
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMGET
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
op_star
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ret_val
op_assign
id|error
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret_val
op_assign
id|get_modem_info
c_func
(paren
id|info
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCGSERIAL
suffix:colon
id|error
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
(brace
id|ret_val
op_assign
id|error
suffix:semicolon
r_break
suffix:semicolon
)brace
id|ret_val
op_assign
id|get_serial_info
c_func
(paren
id|info
comma
(paren
r_struct
id|serial_struct
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSSERIAL
suffix:colon
id|ret_val
op_assign
id|set_serial_info
c_func
(paren
id|info
comma
(paren
r_struct
id|serial_struct
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|ret_val
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_ioctl done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|ret_val
suffix:semicolon
)brace
multiline_comment|/* cy_ioctl */
r_static
r_void
DECL|function|cy_set_termios
id|cy_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old_termios
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_set_termios ttyC%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty-&gt;termios-&gt;c_cflag
op_eq
id|old_termios-&gt;c_cflag
)paren
r_return
suffix:semicolon
id|config_setup
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
op_logical_and
op_logical_neg
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
)paren
(brace
id|tty-&gt;stopped
op_assign
l_int|0
suffix:semicolon
id|cy_start
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
macro_line|#ifdef tytso_patch_94Nov25_1726
r_if
c_cond
(paren
op_logical_neg
(paren
id|old_termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
op_logical_and
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/* cy_set_termios */
r_static
r_void
DECL|function|cy_close
id|cy_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_close ttyC%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|info
op_logical_or
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_close&quot;
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;cy_close ttyC%d, count = %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If the TTY is being hung up, nothing to do */
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tty-&gt;count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|info-&gt;count
op_ne
l_int|1
)paren
)paren
(brace
multiline_comment|/*&n;&t; * Uh, oh.  tty-&gt;count is 1, which means that the tty&n;&t; * structure will be freed.  Info-&gt;count should always&n;&t; * be one in these conditions.  If it&squot;s greater than&n;&t; * one, we&squot;ve got real problems, since it means the&n;&t; * serial port won&squot;t be shutdown.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;cy_close: bad serial port count; tty-&gt;count is 1, &quot;
l_string|&quot;info-&gt;count is %d&bslash;n&quot;
comma
id|info-&gt;count
)paren
suffix:semicolon
id|info-&gt;count
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_COUNT
id|printk
c_func
(paren
l_string|&quot;cyc: %d(%d): decrementing count to %d&bslash;n&quot;
comma
id|__LINE__
comma
id|current-&gt;pid
comma
id|info-&gt;count
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_decrement
id|info-&gt;count
OL
l_int|0
)paren
(brace
macro_line|#ifdef SERIAL_DEBUG_COUNT
id|printk
c_func
(paren
l_string|&quot;cyc: %d: setting count to 0&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;count
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|info-&gt;flags
op_or_assign
id|ASYNC_CLOSING
suffix:semicolon
multiline_comment|/*&n;     * Save the termios structure, since this port may have&n;     * separate termios for callout and dialin.&n;     */
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
id|info-&gt;normal_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
id|info-&gt;callout_termios
op_assign
op_star
id|tty-&gt;termios
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|30
op_star
id|HZ
)paren
suffix:semicolon
multiline_comment|/* 30 seconds timeout */
id|shutdown
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
id|info-&gt;event
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tty
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;blocked_open
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;close_delay
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|info-&gt;close_delay
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
)brace
id|info-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
op_or
id|ASYNC_CLOSING
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_close done&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* cy_close */
multiline_comment|/*&n; * cy_hangup() --- called by tty_hangup() when a hangup is signaled.&n; */
r_void
DECL|function|cy_hangup
id|cy_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
op_assign
(paren
r_struct
id|cyclades_port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_hangup ttyC%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_hangup&quot;
)paren
)paren
r_return
suffix:semicolon
id|shutdown
c_func
(paren
id|info
)paren
suffix:semicolon
id|info-&gt;event
op_assign
l_int|0
suffix:semicolon
id|info-&gt;count
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_COUNT
id|printk
c_func
(paren
l_string|&quot;cyc: %d(%d): setting count to 0&bslash;n&quot;
comma
id|__LINE__
comma
id|current-&gt;pid
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;tty
op_assign
l_int|0
suffix:semicolon
id|info-&gt;flags
op_and_assign
op_complement
(paren
id|ASYNC_NORMAL_ACTIVE
op_or
id|ASYNC_CALLOUT_ACTIVE
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|info-&gt;open_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* cy_hangup */
multiline_comment|/*&n; * ------------------------------------------------------------&n; * cy_open() and friends&n; * ------------------------------------------------------------&n; */
r_static
r_int
DECL|function|block_til_ready
id|block_til_ready
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
r_struct
id|cyclades_port
op_star
id|info
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_struct
id|cyclades_card
op_star
id|cinfo
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|chip
comma
id|channel
comma
id|index
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_char
op_star
id|base_addr
suffix:semicolon
multiline_comment|/*&n;     * If the device is in the middle of being closed, then block&n;     * until it&squot;s done, and then try again.&n;     */
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|info-&gt;close_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
(brace
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;     * If this is a callout device, then just make sure the normal&n;     * device isn&squot;t being used.&n;     */
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_CALLOUT
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_NORMAL_ACTIVE
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SESSION_LOCKOUT
)paren
op_logical_and
(paren
id|info-&gt;session
op_ne
id|current-&gt;session
)paren
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_PGRP_LOCKOUT
)paren
op_logical_and
(paren
id|info-&gt;pgrp
op_ne
id|current-&gt;pgrp
)paren
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|info-&gt;flags
op_or_assign
id|ASYNC_CALLOUT_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * If non-blocking mode is set, then make the check up front&n;     * and then exit.&n;     */
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|info-&gt;flags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;     * Block waiting for the carrier detect and the line to become&n;     * free (i.e., not in use by the callout).  While we are in&n;     * this loop, info-&gt;count is dropped by one, so that&n;     * cy_close() knows when to free things.  We restore it upon&n;     * exit, either normal or abnormal.&n;     */
id|retval
op_assign
l_int|0
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|info-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;block_til_ready before block: ttyC%d, count = %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
multiline_comment|/**/
macro_line|#endif
id|info-&gt;count
op_decrement
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_COUNT
id|printk
c_func
(paren
l_string|&quot;cyc: %d(%d): decrementing count to %d&bslash;n&quot;
comma
id|__LINE__
comma
id|current-&gt;pid
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;blocked_open
op_increment
suffix:semicolon
id|cinfo
op_assign
op_amp
id|cy_card
(braket
id|info-&gt;card
)braket
suffix:semicolon
id|channel
op_assign
id|info-&gt;line
op_minus
id|cinfo-&gt;first_line
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|index
op_assign
id|cinfo-&gt;bus_index
suffix:semicolon
id|base_addr
op_assign
(paren
r_char
op_star
)paren
(paren
id|cinfo-&gt;base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
)paren
(brace
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
op_assign
id|CyRTS
suffix:semicolon
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
op_assign
id|CyDTR
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_DTR
id|printk
c_func
(paren
l_string|&quot;cyc: %d: raising DTR&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;     status: 0x%x, 0x%x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
comma
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
op_logical_or
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_HUP_NOTIFY
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CALLOUT_ACTIVE
)paren
op_logical_and
op_logical_neg
(paren
id|info-&gt;flags
op_amp
id|ASYNC_CLOSING
)paren
op_logical_and
(paren
id|C_CLOCAL
c_func
(paren
id|tty
)paren
op_logical_or
(paren
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
op_amp
id|CyDCD
)paren
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;block_til_ready blocking: ttyC%d, count = %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
multiline_comment|/**/
macro_line|#endif
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|info-&gt;open_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty_hung_up_p
c_func
(paren
id|filp
)paren
)paren
(brace
id|info-&gt;count
op_increment
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_COUNT
id|printk
c_func
(paren
l_string|&quot;cyc: %d(%d): incrementing count to %d&bslash;n&quot;
comma
id|__LINE__
comma
id|current-&gt;pid
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
)brace
id|info-&gt;blocked_open
op_decrement
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;block_til_ready after blocking: ttyC%d, count = %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
multiline_comment|/**/
macro_line|#endif
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|ASYNC_NORMAL_ACTIVE
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* block_til_ready */
multiline_comment|/*&n; * This routine is called whenever a serial port is opened.  It&n; * performs the serial-specific initialization for the tty structure.&n; */
r_int
DECL|function|cy_open
id|cy_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
suffix:semicolon
r_int
id|retval
comma
id|line
suffix:semicolon
id|line
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
suffix:semicolon
r_if
c_cond
(paren
(paren
id|line
OL
l_int|0
)paren
op_logical_or
(paren
id|NR_PORTS
op_le
id|line
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|info
op_assign
op_amp
id|cy_port
(braket
id|line
)braket
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;line
OL
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_OTHER
id|printk
c_func
(paren
l_string|&quot;cy_open ttyC%d&bslash;n&quot;
comma
id|info-&gt;line
)paren
suffix:semicolon
multiline_comment|/* */
macro_line|#endif
r_if
c_cond
(paren
id|serial_paranoia_check
c_func
(paren
id|info
comma
id|tty-&gt;device
comma
l_string|&quot;cy_open&quot;
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;cy_open ttyC%d, count = %d&bslash;n&quot;
comma
id|info-&gt;line
comma
id|info-&gt;count
)paren
suffix:semicolon
multiline_comment|/**/
macro_line|#endif
id|info-&gt;count
op_increment
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_COUNT
id|printk
c_func
(paren
l_string|&quot;cyc: %d(%d): incrementing count to %d&bslash;n&quot;
comma
id|__LINE__
comma
id|current-&gt;pid
comma
id|info-&gt;count
)paren
suffix:semicolon
macro_line|#endif
id|tty-&gt;driver_data
op_assign
id|info
suffix:semicolon
id|info-&gt;tty
op_assign
id|tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_buf
)paren
(brace
id|tmp_buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp_buf
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|info-&gt;count
op_eq
l_int|1
)paren
op_logical_and
(paren
id|info-&gt;flags
op_amp
id|ASYNC_SPLIT_TERMIOS
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;driver.subtype
op_eq
id|SERIAL_TYPE_NORMAL
)paren
op_star
id|tty-&gt;termios
op_assign
id|info-&gt;normal_termios
suffix:semicolon
r_else
op_star
id|tty-&gt;termios
op_assign
id|info-&gt;callout_termios
suffix:semicolon
)brace
multiline_comment|/*&n;     * Start up serial port&n;     */
id|retval
op_assign
id|startup
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
r_return
id|retval
suffix:semicolon
)brace
id|retval
op_assign
id|block_til_ready
c_func
(paren
id|tty
comma
id|filp
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;cy_open returning after block_til_ready with %d&bslash;n&quot;
comma
id|retval
)paren
suffix:semicolon
macro_line|#endif
r_return
id|retval
suffix:semicolon
)brace
id|info-&gt;session
op_assign
id|current-&gt;session
suffix:semicolon
id|info-&gt;pgrp
op_assign
id|current-&gt;pgrp
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;cy_open done&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/**/
macro_line|#endif
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* cy_open */
multiline_comment|/*&n; * ---------------------------------------------------------------------&n; * cy_init() and friends&n; *&n; * cy_init() is called at boot-time to initialize the serial driver.&n; * ---------------------------------------------------------------------&n; */
multiline_comment|/*&n; * This routine prints out the appropriate serial driver version&n; * number, and identifies which options were configured into this&n; * driver.&n; */
r_static
r_void
DECL|function|show_version
id|show_version
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cyclom driver %s&bslash;n&quot;
comma
id|rcsid
)paren
suffix:semicolon
)brace
multiline_comment|/* show_version */
multiline_comment|/* initialize chips on card -- return number of valid&n;   chips (which is number of ports/4) */
r_int
DECL|function|cy_init_card
id|cy_init_card
c_func
(paren
r_int
r_char
op_star
id|true_base_addr
comma
r_int
id|index
)paren
(brace
r_int
r_int
id|chip_number
suffix:semicolon
r_int
r_char
op_star
id|base_addr
suffix:semicolon
id|true_base_addr
(braket
id|Cy_HwReset
op_lshift
id|index
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Cy_HwReset is 0x1400 */
id|true_base_addr
(braket
id|Cy_ClrIntr
op_lshift
id|index
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Cy_ClrIntr is 0x1800 */
id|udelay
c_func
(paren
l_int|500L
)paren
suffix:semicolon
r_for
c_loop
(paren
id|chip_number
op_assign
l_int|0
suffix:semicolon
id|chip_number
OL
id|CyMaxChipsPerCard
suffix:semicolon
id|chip_number
op_increment
)paren
(brace
id|base_addr
op_assign
id|true_base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip_number
)braket
op_lshift
id|index
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000L
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyCCR
op_lshift
id|index
)braket
op_ne
l_int|0x00
)paren
(brace
multiline_comment|/*************&n;            printk(&quot; chip #%d at %#6lx is never idle (CCR != 0)&bslash;n&quot;,&n;               chip_number, (unsigned long)base_addr);&n;            *************/
r_return
id|chip_number
suffix:semicolon
)brace
id|base_addr
(braket
id|CyGFRCR
op_lshift
id|index
)braket
op_assign
l_int|0
suffix:semicolon
id|udelay
c_func
(paren
l_int|10L
)paren
suffix:semicolon
multiline_comment|/* The Cyclom-16Y does not decode address bit 9 and therefore&n;           cannot distinguish between references to chip 0 and a non-&n;           existent chip 4.  If the preceding clearing of the supposed&n;           chip 4 GFRCR register appears at chip 0, there is no chip 4&n;           and this must be a Cyclom-16Y, not a Cyclom-32Ye.&n;        */
r_if
c_cond
(paren
id|chip_number
op_eq
l_int|4
op_logical_and
op_star
(paren
id|true_base_addr
op_plus
(paren
id|cy_chip_offset
(braket
l_int|0
)braket
op_lshift
id|index
)paren
op_plus
(paren
id|CyGFRCR
op_lshift
id|index
)paren
)paren
op_eq
l_int|0
)paren
(brace
r_return
id|chip_number
suffix:semicolon
)brace
id|base_addr
(braket
id|CyCCR
op_lshift
id|index
)braket
op_assign
id|CyCHIP_RESET
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000L
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base_addr
(braket
id|CyGFRCR
op_lshift
id|index
)braket
op_eq
l_int|0x00
)paren
(brace
multiline_comment|/*&n;            printk(&quot; chip #%d at %#6lx is not responding (GFRCR stayed 0)&bslash;n&quot;,&n;               chip_number, (unsigned long)base_addr);&n;&t;    */
r_return
id|chip_number
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
l_int|0xf0
op_amp
id|base_addr
(braket
id|CyGFRCR
op_lshift
id|index
)braket
)paren
op_ne
l_int|0x40
)paren
(brace
multiline_comment|/*&n;            printk(&quot; chip #%d at %#6lx is not valid (GFRCR == %#2x)&bslash;n&quot;,&n;               chip_number, (unsigned long)base_addr, base_addr[CyGFRCR&lt;&lt;index]);&n;&t;    */
r_return
id|chip_number
suffix:semicolon
)brace
id|base_addr
(braket
id|CyGCR
op_lshift
id|index
)braket
op_assign
id|CyCH0_SERIAL
suffix:semicolon
id|base_addr
(braket
id|CyPPR
op_lshift
id|index
)braket
op_assign
l_int|244
suffix:semicolon
multiline_comment|/* better value than CyCLOCK_25_1MS * 5&n;                                                  to run clock at 200 Hz */
multiline_comment|/*&n;        printk(&quot; chip #%d at %#6lx is rev 0x%2x&bslash;n&quot;,&n;               chip_number, (unsigned long)base_addr, base_addr[CyGFRCR&lt;&lt;index]);&n;&t;*/
)brace
r_return
id|chip_number
suffix:semicolon
)brace
multiline_comment|/* cy_init_card */
multiline_comment|/* The serial driver boot-time initialization code!&n;    Hardware I/O ports are mapped to character special devices on a&n;    first found, first allocated manner.  That is, this code searches&n;    for Cyclom cards in the system.  As each is found, it is probed&n;    to discover how many chips (and thus how many ports) are present.&n;    These ports are mapped to the tty ports 32 and upward in monotonic&n;    fashion.  If an 8-port card is replaced with a 16-port card, the&n;    port mapping on a following card will shift.&n;&n;    This approach is different from what is used in the other serial&n;    device driver because the Cyclom is more properly a multiplexer,&n;    not just an aggregation of serial ports on one card.&n;&n;    If there are more cards with more ports than have been statically&n;    allocated above, a warning is printed and the extra ports are ignored.&n; */
r_int
DECL|function|cy_init
id|cy_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|cyclades_port
op_star
id|info
suffix:semicolon
r_struct
id|cyclades_card
op_star
id|cinfo
suffix:semicolon
r_int
id|board
comma
id|port
comma
id|i
suffix:semicolon
id|show_version
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Initialize the tty_driver structure */
id|memset
c_func
(paren
op_amp
id|cy_serial_driver
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|cy_serial_driver.magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
id|cy_serial_driver.name
op_assign
l_string|&quot;ttyC&quot;
suffix:semicolon
id|cy_serial_driver.major
op_assign
id|CYCLADES_MAJOR
suffix:semicolon
id|cy_serial_driver.minor_start
op_assign
l_int|0
suffix:semicolon
id|cy_serial_driver.num
op_assign
id|NR_PORTS
suffix:semicolon
id|cy_serial_driver.type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
id|cy_serial_driver.subtype
op_assign
id|SERIAL_TYPE_NORMAL
suffix:semicolon
id|cy_serial_driver.init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|cy_serial_driver.init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
id|cy_serial_driver.flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
id|cy_serial_driver.refcount
op_assign
op_amp
id|serial_refcount
suffix:semicolon
id|cy_serial_driver.table
op_assign
id|serial_table
suffix:semicolon
id|cy_serial_driver.termios
op_assign
id|serial_termios
suffix:semicolon
id|cy_serial_driver.termios_locked
op_assign
id|serial_termios_locked
suffix:semicolon
id|cy_serial_driver.open
op_assign
id|cy_open
suffix:semicolon
id|cy_serial_driver.close
op_assign
id|cy_close
suffix:semicolon
id|cy_serial_driver.write
op_assign
id|cy_write
suffix:semicolon
id|cy_serial_driver.put_char
op_assign
id|cy_put_char
suffix:semicolon
id|cy_serial_driver.flush_chars
op_assign
id|cy_flush_chars
suffix:semicolon
id|cy_serial_driver.write_room
op_assign
id|cy_write_room
suffix:semicolon
id|cy_serial_driver.chars_in_buffer
op_assign
id|cy_chars_in_buffer
suffix:semicolon
id|cy_serial_driver.flush_buffer
op_assign
id|cy_flush_buffer
suffix:semicolon
id|cy_serial_driver.ioctl
op_assign
id|cy_ioctl
suffix:semicolon
id|cy_serial_driver.throttle
op_assign
id|cy_throttle
suffix:semicolon
id|cy_serial_driver.unthrottle
op_assign
id|cy_unthrottle
suffix:semicolon
id|cy_serial_driver.set_termios
op_assign
id|cy_set_termios
suffix:semicolon
id|cy_serial_driver.stop
op_assign
id|cy_stop
suffix:semicolon
id|cy_serial_driver.start
op_assign
id|cy_start
suffix:semicolon
id|cy_serial_driver.hangup
op_assign
id|cy_hangup
suffix:semicolon
multiline_comment|/*&n;     * The callout device is just like normal device except for&n;     * major number and the subtype code.&n;     */
id|cy_callout_driver
op_assign
id|cy_serial_driver
suffix:semicolon
id|cy_callout_driver.name
op_assign
l_string|&quot;cub&quot;
suffix:semicolon
id|cy_callout_driver.major
op_assign
id|CYCLADESAUX_MAJOR
suffix:semicolon
id|cy_callout_driver.subtype
op_assign
id|SERIAL_TYPE_CALLOUT
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|cy_serial_driver
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t register Cyclom serial driver&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|cy_callout_driver
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t register Cyclom callout driver&bslash;n&quot;
)paren
suffix:semicolon
id|init_bh
c_func
(paren
id|CYCLADES_BH
comma
id|do_cyclades_bh
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|IRQ_cards
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CARDS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* base_addr=0 indicates board not found */
id|cy_card
(braket
id|i
)braket
dot
id|base_addr
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* the code below is responsible to find the boards. Each different&n;       type of board has its own detection routine. If a board is found,&n;       the next cy_card structure available is set by the detection&n;       routine. These functions are responsible for checking the availability&n;       of cy_card and cy_port data structures and updating the&n;       cy_next_channel. */
multiline_comment|/* look for isa boards */
id|cy_isa_nboard
op_assign
id|cy_detect_isa
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* look for pci boards */
id|cy_pci_nboard
op_assign
id|cy_detect_pci
c_func
(paren
)paren
suffix:semicolon
id|cy_nboard
op_assign
id|cy_isa_nboard
op_plus
id|cy_pci_nboard
suffix:semicolon
multiline_comment|/* invalidate remaining cy_card structures */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CARDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cy_card
(braket
id|i
)braket
dot
id|base_addr
op_eq
l_int|0
)paren
(brace
id|cy_card
(braket
id|i
)braket
dot
id|first_line
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* invalidate remaining cy_port structures */
r_for
c_loop
(paren
id|i
op_assign
id|cy_next_channel
suffix:semicolon
id|i
OL
id|NR_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cy_port
(braket
id|i
)braket
dot
id|line
op_assign
op_minus
l_int|1
suffix:semicolon
id|cy_port
(braket
id|i
)braket
dot
id|magic
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* initialize per-port data structures for each valid board found */
r_for
c_loop
(paren
id|board
op_assign
l_int|0
suffix:semicolon
id|board
OL
id|cy_nboard
suffix:semicolon
id|board
op_increment
)paren
(brace
id|cinfo
op_assign
op_amp
id|cy_card
(braket
id|board
)braket
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
id|cinfo-&gt;first_line
suffix:semicolon
id|port
OL
id|cinfo-&gt;first_line
op_plus
l_int|4
op_star
id|cinfo-&gt;num_chips
suffix:semicolon
id|port
op_increment
)paren
(brace
id|info
op_assign
op_amp
id|cy_port
(braket
id|port
)braket
suffix:semicolon
id|info-&gt;magic
op_assign
id|CYCLADES_MAGIC
suffix:semicolon
id|info-&gt;type
op_assign
id|PORT_CIRRUS
suffix:semicolon
id|info-&gt;card
op_assign
id|board
suffix:semicolon
id|info-&gt;line
op_assign
id|port
suffix:semicolon
id|info-&gt;flags
op_assign
id|STD_COM_FLAGS
suffix:semicolon
id|info-&gt;tty
op_assign
l_int|0
suffix:semicolon
id|info-&gt;xmit_fifo_size
op_assign
l_int|12
suffix:semicolon
id|info-&gt;cor1
op_assign
id|CyPARITY_NONE
op_or
id|Cy_1_STOP
op_or
id|Cy_8_BITS
suffix:semicolon
id|info-&gt;cor2
op_assign
id|CyETC
suffix:semicolon
id|info-&gt;cor3
op_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* _very_ small receive threshold */
id|info-&gt;cor4
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cor5
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tbpr
op_assign
id|baud_bpr
(braket
l_int|13
)braket
suffix:semicolon
multiline_comment|/* Tx BPR */
id|info-&gt;tco
op_assign
id|baud_co
(braket
l_int|13
)braket
suffix:semicolon
multiline_comment|/* Tx CO */
id|info-&gt;rbpr
op_assign
id|baud_bpr
(braket
l_int|13
)braket
suffix:semicolon
multiline_comment|/* Rx BPR */
id|info-&gt;rco
op_assign
id|baud_co
(braket
l_int|13
)braket
suffix:semicolon
multiline_comment|/* Rx CO */
id|info-&gt;close_delay
op_assign
l_int|0
suffix:semicolon
id|info-&gt;x_char
op_assign
l_int|0
suffix:semicolon
id|info-&gt;event
op_assign
l_int|0
suffix:semicolon
id|info-&gt;count
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_COUNT
id|printk
c_func
(paren
l_string|&quot;cyc: %d: setting count to 0&bslash;n&quot;
comma
id|__LINE__
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;blocked_open
op_assign
l_int|0
suffix:semicolon
id|info-&gt;default_threshold
op_assign
l_int|0
suffix:semicolon
id|info-&gt;default_timeout
op_assign
l_int|0
suffix:semicolon
id|info-&gt;tqueue.routine
op_assign
id|do_softint
suffix:semicolon
id|info-&gt;tqueue.data
op_assign
id|info
suffix:semicolon
id|info-&gt;callout_termios
op_assign
id|cy_callout_driver.init_termios
suffix:semicolon
id|info-&gt;normal_termios
op_assign
id|cy_serial_driver.init_termios
suffix:semicolon
id|info-&gt;open_wait
op_assign
l_int|0
suffix:semicolon
id|info-&gt;close_wait
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* info-&gt;session */
multiline_comment|/* info-&gt;pgrp */
id|info-&gt;read_status_mask
op_assign
id|CyTIMEOUT
op_or
id|CySPECHAR
op_or
id|CyBREAK
op_or
id|CyPARITY
op_or
id|CyFRAME
op_or
id|CyOVERRUN
suffix:semicolon
multiline_comment|/* info-&gt;timeout */
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* cy_init */
macro_line|#ifdef MODULE
r_int
DECL|function|init_module
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|cy_init
c_func
(paren
)paren
suffix:semicolon
)brace
r_void
DECL|function|cleanup_module
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|tty_unregister_driver
c_func
(paren
op_amp
id|cy_callout_driver
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t unregister Cyclom callout driver&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_unregister_driver
c_func
(paren
op_amp
id|cy_serial_driver
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;Couldn&squot;t unregister Cyclom serial driver&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CARDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cy_card
(braket
id|i
)braket
dot
id|base_addr
op_ne
l_int|0
)paren
(brace
id|free_irq
c_func
(paren
id|cy_card
(braket
id|i
)braket
dot
id|irq
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
multiline_comment|/*&n; * ---------------------------------------------------------------------&n; * cy_detect_isa() - Probe for Cyclom-Y/ISA boards.&n; * sets global variables and return the number of ISA boards found.&n; * ---------------------------------------------------------------------&n; */
r_int
DECL|function|cy_detect_isa
id|cy_detect_isa
c_func
(paren
)paren
(brace
r_int
r_int
id|cy_isa_irq
comma
id|nboard
suffix:semicolon
r_int
r_char
op_star
id|cy_isa_address
suffix:semicolon
r_int
r_int
id|i
comma
id|j
comma
id|cy_isa_nchan
suffix:semicolon
id|nboard
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* scan the address table probing for Cyclom-Y/ISA boards */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_ISA_ADDRESSES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cy_isa_address
op_assign
id|cy_isa_addresses
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cy_isa_address
op_eq
l_int|0x0000
)paren
(brace
r_return
id|nboard
suffix:semicolon
)brace
multiline_comment|/* probe for CD1400... */
id|cy_isa_nchan
op_assign
l_int|4
op_star
id|cy_init_card
c_func
(paren
id|cy_isa_address
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cy_isa_nchan
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* find out the board&squot;s irq by probing */
id|cy_isa_irq
op_assign
id|do_auto_irq
c_func
(paren
id|cy_isa_address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cy_isa_irq
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cyclom-Y/ISA found at 0x%x but the IRQ could not be detected.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cy_isa_address
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cy_next_channel
op_plus
id|cy_isa_nchan
)paren
OG
id|NR_PORTS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cyclom-Y/ISA found at 0x%x but no more channel structures are available.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cy_isa_address
)paren
suffix:semicolon
r_return
id|nboard
suffix:semicolon
)brace
multiline_comment|/* fill the next cy_card structure available */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NR_CARDS
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cy_card
(braket
id|j
)braket
dot
id|base_addr
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
op_eq
id|NR_CARDS
)paren
(brace
multiline_comment|/* no more cy_cards available */
id|printk
c_func
(paren
l_string|&quot;Cyclom-Y/ISA found at 0x%x but no more card structures are available.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cy_isa_address
)paren
suffix:semicolon
r_return
id|nboard
suffix:semicolon
)brace
multiline_comment|/* allocate IRQ */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|cy_isa_irq
comma
id|cy_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;cyclades&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cyclom-Y/ISA found at 0x%x but could not allocate interrupt IRQ#%d.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cy_isa_address
comma
id|cy_isa_irq
)paren
suffix:semicolon
r_return
id|nboard
suffix:semicolon
)brace
multiline_comment|/* set cy_card */
id|cy_card
(braket
id|j
)braket
dot
id|base_addr
op_assign
(paren
r_int
)paren
id|cy_isa_address
suffix:semicolon
id|cy_card
(braket
id|j
)braket
dot
id|irq
op_assign
(paren
r_int
)paren
id|cy_isa_irq
suffix:semicolon
id|cy_card
(braket
id|j
)braket
dot
id|bus_index
op_assign
l_int|0
suffix:semicolon
id|cy_card
(braket
id|j
)braket
dot
id|first_line
op_assign
id|cy_next_channel
suffix:semicolon
id|cy_card
(braket
id|j
)braket
dot
id|num_chips
op_assign
id|cy_isa_nchan
op_div
l_int|4
suffix:semicolon
id|IRQ_cards
(braket
id|cy_isa_irq
)braket
op_assign
op_amp
id|cy_card
(braket
id|j
)braket
suffix:semicolon
id|nboard
op_increment
suffix:semicolon
multiline_comment|/* print message */
id|printk
c_func
(paren
l_string|&quot;Cyclom-Y/ISA #%d: 0x%x-0x%x, IRQ%d, %d channels starting from port %d.&bslash;n&quot;
comma
id|j
op_plus
l_int|1
comma
(paren
r_int
r_int
)paren
id|cy_isa_address
comma
(paren
r_int
r_int
)paren
(paren
id|cy_isa_address
op_plus
l_int|0x1fff
)paren
comma
id|cy_isa_irq
comma
id|cy_isa_nchan
comma
id|cy_next_channel
)paren
suffix:semicolon
id|cy_next_channel
op_add_assign
id|cy_isa_nchan
suffix:semicolon
)brace
r_return
id|nboard
suffix:semicolon
)brace
multiline_comment|/*&n; * ---------------------------------------------------------------------&n; * cy_detect_pci() - Test PCI bus presence and Cyclom-Ye/PCI.&n; * sets global variables and return the number of PCI boards found.&n; * ---------------------------------------------------------------------&n; */
r_int
DECL|function|cy_detect_pci
id|cy_detect_pci
c_func
(paren
)paren
(brace
macro_line|#ifdef CONFIG_PCI
r_int
r_char
id|cyy_bus
comma
id|cyy_dev_fn
comma
id|cyy_rev_id
suffix:semicolon
r_int
r_int
id|pci_intr_ctrl
suffix:semicolon
r_int
r_char
id|cy_pci_irq
suffix:semicolon
r_int
r_int
id|cy_pci_address
comma
id|cy_pci_io
suffix:semicolon
r_int
r_int
id|i
comma
id|j
comma
id|cy_pci_nchan
suffix:semicolon
r_int
r_int
id|device_id
comma
id|dev_index
op_assign
l_int|0
comma
id|board_index
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pcibios_present
c_func
(paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* PCI bus not present */
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CARDS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* look for a Cyclom-Y card by vendor and device id */
r_while
c_loop
(paren
(paren
id|device_id
op_assign
id|cy_pci_dev_id
(braket
id|dev_index
)braket
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pcibios_find_device
c_func
(paren
id|PCI_VENDOR_ID_CYCLADES
comma
id|device_id
comma
id|board_index
comma
op_amp
id|cyy_bus
comma
op_amp
id|cyy_dev_fn
)paren
op_ne
l_int|0
)paren
(brace
id|dev_index
op_increment
suffix:semicolon
multiline_comment|/* try next device id */
id|board_index
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|board_index
op_increment
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* found a board */
)brace
)brace
r_if
c_cond
(paren
id|device_id
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* read PCI configuration area */
id|pcibios_read_config_byte
c_func
(paren
id|cyy_bus
comma
id|cyy_dev_fn
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|cy_pci_irq
)paren
suffix:semicolon
id|pcibios_read_config_dword
c_func
(paren
id|cyy_bus
comma
id|cyy_dev_fn
comma
id|PCI_BASE_ADDRESS_1
comma
op_amp
id|cy_pci_io
)paren
suffix:semicolon
id|pcibios_read_config_dword
c_func
(paren
id|cyy_bus
comma
id|cyy_dev_fn
comma
id|PCI_BASE_ADDRESS_2
comma
op_amp
id|cy_pci_address
)paren
suffix:semicolon
id|pcibios_read_config_byte
c_func
(paren
id|cyy_bus
comma
id|cyy_dev_fn
comma
id|PCI_REVISION_ID
comma
op_amp
id|cyy_rev_id
)paren
suffix:semicolon
id|cy_pci_address
op_and_assign
l_int|0xfffffff0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ulong
)paren
id|cy_pci_address
op_ge
l_int|0x100000
)paren
(brace
multiline_comment|/* above 1M? */
id|cy_pci_address
op_assign
(paren
r_int
r_int
)paren
id|vremap
c_func
(paren
id|cy_pci_address
comma
l_int|0x4000
)paren
suffix:semicolon
)brace
id|cy_pci_io
op_and_assign
l_int|0xfffffffc
suffix:semicolon
id|cy_pci_nchan
op_assign
l_int|4
op_star
id|cy_init_card
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|cy_pci_address
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cy_pci_nchan
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cyclom-Y PCI host card with no Serial-Modules at 0x%x.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cy_pci_address
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|cy_next_channel
op_plus
id|cy_pci_nchan
)paren
OG
id|NR_PORTS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cyclom-Y/PCI found at 0x%x but no more channel structures are available.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cy_pci_address
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
macro_line|#ifdef CY_PCI_DEBUG
id|printk
c_func
(paren
l_string|&quot;Cyclom-Ye/PCI #%d (bus=0x0%x, pci_id=0x%x, rev_id=%d).&bslash;n&quot;
comma
id|i
op_plus
l_int|1
comma
id|cyy_bus
comma
id|cyy_dev_fn
comma
id|cyy_rev_id
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Cyclom-Ye/PCI: found at 0x%x, IRQ%d, ioaddr = 0x%lx.&bslash;n&quot;
comma
id|cy_pci_address
comma
(paren
r_int
)paren
id|cy_pci_irq
comma
id|cy_pci_io
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* fill the next cy_card structure available */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NR_CARDS
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|cy_card
(braket
id|j
)braket
dot
id|base_addr
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|j
op_eq
id|NR_CARDS
)paren
(brace
multiline_comment|/* no more cy_cards available */
id|printk
c_func
(paren
l_string|&quot;Cyclom-Y/PCI found at 0x%x but no more card structures are available.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cy_pci_address
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* allocate IRQ */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|cy_pci_irq
comma
id|cy_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;cyclades&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cyclom-Y/PCI found at 0x%x but could not allocate interrupt IRQ%d.&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|cy_pci_address
comma
id|cy_pci_irq
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* set cy_card */
id|cy_card
(braket
id|j
)braket
dot
id|base_addr
op_assign
(paren
r_int
)paren
id|cy_pci_address
suffix:semicolon
id|cy_card
(braket
id|j
)braket
dot
id|irq
op_assign
(paren
r_int
)paren
id|cy_pci_irq
suffix:semicolon
id|cy_card
(braket
id|j
)braket
dot
id|bus_index
op_assign
l_int|1
suffix:semicolon
id|cy_card
(braket
id|j
)braket
dot
id|first_line
op_assign
id|cy_next_channel
suffix:semicolon
id|cy_card
(braket
id|j
)braket
dot
id|num_chips
op_assign
id|cy_pci_nchan
op_div
l_int|4
suffix:semicolon
id|IRQ_cards
(braket
id|cy_pci_irq
)braket
op_assign
op_amp
id|cy_card
(braket
id|j
)braket
suffix:semicolon
multiline_comment|/* enable interrupts in the PCI interface */
id|outw
c_func
(paren
id|inw
c_func
(paren
id|cy_pci_io
op_plus
l_int|0x68
)paren
op_or
l_int|0x0900
comma
id|cy_pci_io
op_plus
l_int|0x68
)paren
suffix:semicolon
id|pci_intr_ctrl
op_assign
(paren
r_int
r_int
)paren
(paren
id|inw
c_func
(paren
id|cy_pci_io
op_plus
l_int|0x68
)paren
op_or
id|inw
c_func
(paren
id|cy_pci_io
op_plus
l_int|0x6a
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* print message */
id|printk
c_func
(paren
l_string|&quot;Cyclom-Y/PCI #%d: 0x%x-0x%x, IRQ%d, %d channels starting from port %d.&bslash;n&quot;
comma
id|j
op_plus
l_int|1
comma
(paren
r_int
r_int
)paren
id|cy_pci_address
comma
(paren
r_int
r_int
)paren
(paren
id|cy_pci_address
op_plus
l_int|0x3fff
)paren
comma
(paren
r_int
)paren
id|cy_pci_irq
comma
id|cy_pci_nchan
comma
id|cy_next_channel
)paren
suffix:semicolon
id|cy_next_channel
op_add_assign
id|cy_pci_nchan
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
macro_line|#else
r_return
l_int|0
suffix:semicolon
macro_line|#endif /* ifdef CONFIG_PCI */
)brace
macro_line|#ifdef CYCLOM_SHOW_STATUS
r_static
r_void
DECL|function|show_status
id|show_status
c_func
(paren
r_int
id|line_num
)paren
(brace
r_int
r_char
op_star
id|base_addr
suffix:semicolon
r_int
id|card
comma
id|chip
comma
id|channel
comma
id|index
suffix:semicolon
r_struct
id|cyclades_port
op_star
id|info
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|info
op_assign
op_amp
id|cy_port
(braket
id|line_num
)braket
suffix:semicolon
id|card
op_assign
id|info-&gt;card
suffix:semicolon
id|index
op_assign
id|cy_card
(braket
id|card
)braket
dot
id|bus_index
suffix:semicolon
id|channel
op_assign
(paren
id|info-&gt;line
)paren
op_minus
(paren
id|cy_card
(braket
id|card
)braket
dot
id|first_line
)paren
suffix:semicolon
id|chip
op_assign
id|channel
op_rshift
l_int|2
suffix:semicolon
id|channel
op_and_assign
l_int|0x03
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  card %d, chip %d, channel %d&bslash;n&quot;
comma
id|card
comma
id|chip
comma
id|channel
)paren
suffix:semicolon
multiline_comment|/**/
id|printk
c_func
(paren
l_string|&quot; cy_card&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  irq base_addr num_chips first_line = %d %lx %d %d&bslash;n&quot;
comma
id|cy_card
(braket
id|card
)braket
dot
id|irq
comma
(paren
r_int
)paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
comma
id|cy_card
(braket
id|card
)braket
dot
id|num_chips
comma
id|cy_card
(braket
id|card
)braket
dot
id|first_line
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; cy_port&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  card line flags = %d %d %x&bslash;n&quot;
comma
id|info-&gt;card
comma
id|info-&gt;line
comma
id|info-&gt;flags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  *tty read_status_mask timeout xmit_fifo_size = %lx %x %x %x&bslash;n&quot;
comma
(paren
r_int
)paren
id|info-&gt;tty
comma
id|info-&gt;read_status_mask
comma
id|info-&gt;timeout
comma
id|info-&gt;xmit_fifo_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  cor1,cor2,cor3,cor4,cor5 = %x %x %x %x %x&bslash;n&quot;
comma
id|info-&gt;cor1
comma
id|info-&gt;cor2
comma
id|info-&gt;cor3
comma
id|info-&gt;cor4
comma
id|info-&gt;cor5
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  tbpr,tco,rbpr,rco = %d %d %d %d&bslash;n&quot;
comma
id|info-&gt;tbpr
comma
id|info-&gt;tco
comma
id|info-&gt;rbpr
comma
id|info-&gt;rco
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  close_delay event count = %d %d %d&bslash;n&quot;
comma
id|info-&gt;close_delay
comma
id|info-&gt;event
comma
id|info-&gt;count
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  x_char blocked_open = %x %x&bslash;n&quot;
comma
id|info-&gt;x_char
comma
id|info-&gt;blocked_open
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  session pgrp open_wait = %lx %lx %lx&bslash;n&quot;
comma
id|info-&gt;session
comma
id|info-&gt;pgrp
comma
(paren
r_int
)paren
id|info-&gt;open_wait
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|base_addr
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|cy_card
(braket
id|card
)braket
dot
id|base_addr
op_plus
(paren
id|cy_chip_offset
(braket
id|chip
)braket
op_lshift
id|index
)paren
)paren
suffix:semicolon
multiline_comment|/* Global Registers */
id|printk
c_func
(paren
l_string|&quot; CyGFRCR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyGFRCR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyCAR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyGCR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyGCR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CySVRR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CySVRR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyRICR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRICR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyTICR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyTICR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMICR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMICR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyRIR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRIR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyTIR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyTIR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMIR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMIR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyPPR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyPPR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|base_addr
(braket
id|CyCAR
op_lshift
id|index
)braket
op_assign
(paren
id|u_char
)paren
id|channel
suffix:semicolon
multiline_comment|/* Virtual Registers */
id|printk
c_func
(paren
l_string|&quot; CyRIVR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRIVR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyTIVR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyTIVR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMIVR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMIVR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMISR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMISR
op_lshift
id|index
)braket
)paren
suffix:semicolon
multiline_comment|/* Channel Registers */
id|printk
c_func
(paren
l_string|&quot; CyCCR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCCR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CySRER %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CySRER
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyCOR1 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCOR1
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyCOR2 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCOR2
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyCOR3 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCOR3
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyCOR4 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCOR4
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyCOR5 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCOR5
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyCCSR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyCCSR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyRDCR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRDCR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CySCHR1 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CySCHR1
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CySCHR2 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CySCHR2
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CySCHR3 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CySCHR3
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CySCHR4 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CySCHR4
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CySCRL %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CySCRL
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CySCRH %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CySCRH
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyLNC %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyLNC
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMCOR1 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMCOR1
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMCOR2 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMCOR2
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyRTPR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRTPR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMSVR1 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR1
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyMSVR2 %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyMSVR2
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyRBPR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRBPR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyRCOR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyRCOR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyTBPR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyTBPR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; CyTCOR %x&bslash;n&quot;
comma
id|base_addr
(braket
id|CyTCOR
op_lshift
id|index
)braket
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* show_status */
macro_line|#endif
eof
