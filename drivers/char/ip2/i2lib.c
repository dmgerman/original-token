multiline_comment|/*******************************************************************************&n;*&n;*   (c) 1999 by Computone Corporation&n;*&n;********************************************************************************&n;*&n;*&n;*   PACKAGE:     Linux tty Device Driver for IntelliPort family of multiport&n;*                serial I/O controllers.&n;*&n;*   DESCRIPTION: High-level interface code for the device driver. Uses the&n;*                Extremely Low Level Interface Support (i2ellis.c). Provides an&n;*                interface to the standard loadware, to support drivers or&n;*                application code. (This is included source code, not a separate&n;*                compilation module.)&n;*&n;*******************************************************************************/
singleline_comment|//------------------------------------------------------------------------------
singleline_comment|// Note on Strategy:
singleline_comment|// Once the board has been initialized, it will interrupt us when:
singleline_comment|// 1) It has something in the fifo for us to read (incoming data, flow control
singleline_comment|// packets, or whatever).
singleline_comment|// 2) It has stripped whatever we have sent last time in the FIFO (and
singleline_comment|// consequently is ready for more).
singleline_comment|//
singleline_comment|// Note also that the buffer sizes declared in i2lib.h are VERY SMALL. This
singleline_comment|// worsens performance considerably, but is done so that a great many channels
singleline_comment|// might use only a little memory.
singleline_comment|//------------------------------------------------------------------------------
singleline_comment|//------------------------------------------------------------------------------
singleline_comment|// Revision History:
singleline_comment|//
singleline_comment|// 0.00 -  4/16/91 --- First Draft
singleline_comment|// 0.01 -  4/29/91 --- 1st beta release
singleline_comment|// 0.02 -  6/14/91 --- Changes to allow small model compilation
singleline_comment|// 0.03 -  6/17/91 MAG Break reporting protected from interrupts routines with
singleline_comment|//                     in-line asm added for moving data to/from ring buffers,
singleline_comment|//                     replacing a variety of methods used previously.
singleline_comment|// 0.04 -  6/21/91 MAG Initial flow-control packets not queued until
singleline_comment|//                     i2_enable_interrupts time. Former versions would enqueue
singleline_comment|//                     them at i2_init_channel time, before we knew how many
singleline_comment|//                     channels were supposed to exist!
singleline_comment|// 0.05 - 10/12/91 MAG Major changes: works through the ellis.c routines now;
singleline_comment|//                     supports new 16-bit protocol and expandable boards.
singleline_comment|//      - 10/24/91 MAG Most changes in place and stable.
singleline_comment|// 0.06 -  2/20/92 MAG Format of CMD_HOTACK corrected: the command takes no
singleline_comment|//                     argument.
singleline_comment|// 0.07 -- 3/11/92 MAG Support added to store special packet types at interrupt
singleline_comment|//                     level (mostly responses to specific commands.)
singleline_comment|// 0.08 -- 3/30/92 MAG Support added for STAT_MODEM packet
singleline_comment|// 0.09 -- 6/24/93 MAG i2Link... needed to update number of boards BEFORE
singleline_comment|//                     turning on the interrupt.
singleline_comment|// 0.10 -- 6/25/93 MAG To avoid gruesome death from a bad board, we sanity check
singleline_comment|//                     some incoming.
singleline_comment|//
singleline_comment|// 1.1  - 12/25/96 AKM Linux version.
singleline_comment|//      - 10/09/98 DMC Revised Linux version.
singleline_comment|//------------------------------------------------------------------------------
singleline_comment|//************
singleline_comment|//* Includes *
singleline_comment|//************
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &quot;i2lib.h&quot;
singleline_comment|//***********************
singleline_comment|//* Function Prototypes *
singleline_comment|//***********************
r_static
r_void
id|i2QueueNeeds
c_func
(paren
id|i2eBordStrPtr
comma
id|i2ChanStrPtr
comma
r_int
)paren
suffix:semicolon
r_static
id|i2ChanStrPtr
id|i2DeQueueNeeds
c_func
(paren
id|i2eBordStrPtr
comma
r_int
)paren
suffix:semicolon
r_static
r_void
id|i2StripFifo
c_func
(paren
id|i2eBordStrPtr
)paren
suffix:semicolon
r_static
r_void
id|i2StuffFifoBypass
c_func
(paren
id|i2eBordStrPtr
)paren
suffix:semicolon
r_static
r_void
id|i2StuffFifoFlow
c_func
(paren
id|i2eBordStrPtr
)paren
suffix:semicolon
r_static
r_void
id|i2StuffFifoInline
c_func
(paren
id|i2eBordStrPtr
)paren
suffix:semicolon
r_static
r_int
id|i2RetryFlushOutput
c_func
(paren
id|i2ChanStrPtr
)paren
suffix:semicolon
singleline_comment|// Not a documented part of the library routines (careful...) but the Diagnostic
singleline_comment|// i2diag.c finds them useful to help the throughput in certain limited
singleline_comment|// single-threaded operations.
r_static
r_void
id|iiSendPendingMail
c_func
(paren
id|i2eBordStrPtr
)paren
suffix:semicolon
r_static
r_void
id|serviceOutgoingFifo
c_func
(paren
id|i2eBordStrPtr
)paren
suffix:semicolon
singleline_comment|// Functions defined in ip2.c as part of interrupt handling
r_static
r_void
id|do_input
c_func
(paren
id|i2ChanStrPtr
)paren
suffix:semicolon
r_static
r_void
id|do_status
c_func
(paren
id|i2ChanStrPtr
)paren
suffix:semicolon
singleline_comment|//***************
singleline_comment|//* Debug  Data *
singleline_comment|//***************
macro_line|#ifdef DEBUG_FIFO
DECL|variable|DBGBuf
r_int
r_char
id|DBGBuf
(braket
l_int|0x4000
)braket
suffix:semicolon
DECL|variable|I
r_int
r_int
id|I
op_assign
l_int|0
suffix:semicolon
r_static
r_void
DECL|function|WriteDBGBuf
id|WriteDBGBuf
c_func
(paren
r_char
op_star
id|s
comma
r_int
r_char
op_star
id|src
comma
r_int
r_int
id|n
)paren
(brace
r_char
op_star
id|p
op_assign
id|src
suffix:semicolon
singleline_comment|// XXX: We need a spin lock here if we ever use this again
r_while
c_loop
(paren
op_star
id|s
)paren
(brace
singleline_comment|// copy label
id|DBGBuf
(braket
id|I
)braket
op_assign
op_star
id|s
op_increment
suffix:semicolon
id|I
op_assign
id|I
op_increment
op_amp
l_int|0x3fff
suffix:semicolon
)brace
r_while
c_loop
(paren
id|n
op_decrement
)paren
(brace
singleline_comment|// copy data
id|DBGBuf
(braket
id|I
)braket
op_assign
op_star
id|p
op_increment
suffix:semicolon
id|I
op_assign
id|I
op_increment
op_amp
l_int|0x3fff
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|fatality
id|fatality
c_func
(paren
id|i2eBordStrPtr
id|pB
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|DBGBuf
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n%4x:&quot;
comma
id|i
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
id|DBGBuf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|DBGBuf
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_mod
l_int|16
)paren
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n%4x:&quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DBGBuf
(braket
id|i
)braket
op_ge
l_char|&squot; &squot;
op_logical_and
id|DBGBuf
(braket
id|i
)braket
op_le
l_char|&squot;~&squot;
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %c &quot;
comma
id|DBGBuf
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot; . &quot;
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Last index %x&bslash;n&quot;
comma
id|I
)paren
suffix:semicolon
)brace
macro_line|#endif /* DEBUG_FIFO */
singleline_comment|//********
singleline_comment|//* Code *
singleline_comment|//********
r_inline
r_int
DECL|function|i2Validate
id|i2Validate
(paren
id|i2ChanStrPtr
id|pCh
)paren
(brace
singleline_comment|//ip2trace(pCh-&gt;port_index, ITRC_VERIFY,ITRC_ENTER,2,pCh-&gt;validity,
singleline_comment|//&t;(CHANNEL_MAGIC | CHANNEL_SUPPORT));
r_return
(paren
(paren
id|pCh-&gt;validity
op_amp
(paren
id|CHANNEL_MAGIC_BITS
op_or
id|CHANNEL_SUPPORT
)paren
)paren
op_eq
(paren
id|CHANNEL_MAGIC
op_or
id|CHANNEL_SUPPORT
)paren
)paren
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   iiSendPendingMail(pB)
singleline_comment|// Parameters: Pointer to a board structure
singleline_comment|// Returns:    Nothing
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// If any outgoing mail bits are set and there is outgoing mailbox is empty,
singleline_comment|// send the mail and clear the bits.
singleline_comment|//******************************************************************************
r_static
r_inline
r_void
DECL|function|iiSendPendingMail
id|iiSendPendingMail
c_func
(paren
id|i2eBordStrPtr
id|pB
)paren
(brace
r_if
c_cond
(paren
id|pB-&gt;i2eOutMailWaiting
op_logical_and
(paren
op_logical_neg
id|pB-&gt;i2eWaitingForEmptyFifo
)paren
)paren
(brace
r_if
c_cond
(paren
id|iiTrySendMail
c_func
(paren
id|pB
comma
id|pB-&gt;i2eOutMailWaiting
)paren
)paren
(brace
multiline_comment|/* If we were already waiting for fifo to empty,&n;&t;&t;&t; * or just sent MB_OUT_STUFFED, then we are&n;&t;&t;&t; * still waiting for it to empty, until we should&n;&t;&t;&t; * receive an MB_IN_STRIPPED from the board.&n;&t;&t;&t; */
id|pB-&gt;i2eWaitingForEmptyFifo
op_or_assign
(paren
id|pB-&gt;i2eOutMailWaiting
op_amp
id|MB_OUT_STUFFED
)paren
suffix:semicolon
id|pB-&gt;i2eOutMailWaiting
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2InitChannels(pB, nChannels, pCh)
singleline_comment|// Parameters: Pointer to Ellis Board structure
singleline_comment|//             Number of channels to initialize
singleline_comment|//             Pointer to first element in an array of channel structures
singleline_comment|// Returns:    Success or failure
singleline_comment|//
singleline_comment|// Description:
singleline_comment|//
singleline_comment|// This function patches pointers, back-pointers, and initializes all the
singleline_comment|// elements in the channel structure array.
singleline_comment|//
singleline_comment|// This should be run after the board structure is initialized, through having
singleline_comment|// loaded the standard loadware (otherwise it complains).
singleline_comment|//
singleline_comment|// In any case, it must be done before any serious work begins initializing the
singleline_comment|// irq&squot;s or sending commands...
singleline_comment|//
singleline_comment|//******************************************************************************
r_static
r_int
DECL|function|i2InitChannels
id|i2InitChannels
(paren
id|i2eBordStrPtr
id|pB
comma
r_int
id|nChannels
comma
id|i2ChanStrPtr
id|pCh
)paren
(brace
r_int
id|index
comma
id|stuffIndex
suffix:semicolon
id|i2ChanStrPtr
op_star
id|ppCh
suffix:semicolon
r_if
c_cond
(paren
id|pB-&gt;i2eValid
op_ne
id|I2E_MAGIC
)paren
(brace
id|COMPLETE
c_func
(paren
id|pB
comma
id|I2EE_BADMAGIC
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pB-&gt;i2eState
op_ne
id|II_STATE_STDLOADED
)paren
(brace
id|COMPLETE
c_func
(paren
id|pB
comma
id|I2EE_BADSTATE
)paren
suffix:semicolon
)brace
id|LOCK_INIT
c_func
(paren
op_amp
id|pB-&gt;read_fifo_spinlock
)paren
suffix:semicolon
id|LOCK_INIT
c_func
(paren
op_amp
id|pB-&gt;write_fifo_spinlock
)paren
suffix:semicolon
id|LOCK_INIT
c_func
(paren
op_amp
id|pB-&gt;Dbuf_spinlock
)paren
suffix:semicolon
id|LOCK_INIT
c_func
(paren
op_amp
id|pB-&gt;Bbuf_spinlock
)paren
suffix:semicolon
id|LOCK_INIT
c_func
(paren
op_amp
id|pB-&gt;Fbuf_spinlock
)paren
suffix:semicolon
singleline_comment|// NO LOCK needed yet - this is init
id|pB-&gt;i2eChannelPtr
op_assign
id|pCh
suffix:semicolon
id|pB-&gt;i2eChannelCnt
op_assign
id|nChannels
suffix:semicolon
id|pB-&gt;i2Fbuf_strip
op_assign
id|pB-&gt;i2Fbuf_stuff
op_assign
l_int|0
suffix:semicolon
id|pB-&gt;i2Dbuf_strip
op_assign
id|pB-&gt;i2Dbuf_stuff
op_assign
l_int|0
suffix:semicolon
id|pB-&gt;i2Bbuf_strip
op_assign
id|pB-&gt;i2Bbuf_stuff
op_assign
l_int|0
suffix:semicolon
id|memset
(paren
id|pCh
comma
l_int|0
comma
r_sizeof
(paren
id|i2ChanStr
)paren
op_star
id|nChannels
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
id|stuffIndex
op_assign
l_int|0
comma
id|ppCh
op_assign
(paren
id|i2ChanStrPtr
op_star
)paren
(paren
id|pB-&gt;i2Fbuf
)paren
suffix:semicolon
id|nChannels
op_logical_and
id|index
OL
id|ABS_MOST_PORTS
suffix:semicolon
id|index
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|pB-&gt;i2eChannelMap
(braket
id|index
op_rshift
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|index
op_amp
l_int|0xf
)paren
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|LOCK_INIT
c_func
(paren
op_amp
id|pCh-&gt;Ibuf_spinlock
)paren
suffix:semicolon
id|LOCK_INIT
c_func
(paren
op_amp
id|pCh-&gt;Obuf_spinlock
)paren
suffix:semicolon
id|LOCK_INIT
c_func
(paren
op_amp
id|pCh-&gt;Cbuf_spinlock
)paren
suffix:semicolon
id|LOCK_INIT
c_func
(paren
op_amp
id|pCh-&gt;Pbuf_spinlock
)paren
suffix:semicolon
singleline_comment|// NO LOCK needed yet - this is init
singleline_comment|// Set up validity flag according to support level
r_if
c_cond
(paren
id|pB-&gt;i2eGoodMap
(braket
id|index
op_rshift
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|index
op_amp
l_int|0xf
)paren
)paren
)paren
(brace
id|pCh-&gt;validity
op_assign
id|CHANNEL_MAGIC
op_or
id|CHANNEL_SUPPORT
suffix:semicolon
)brace
r_else
(brace
id|pCh-&gt;validity
op_assign
id|CHANNEL_MAGIC
suffix:semicolon
)brace
id|pCh-&gt;pMyBord
op_assign
id|pB
suffix:semicolon
multiline_comment|/* Back-pointer */
singleline_comment|// Prepare an outgoing flow-control packet to send as soon as the chance
singleline_comment|// occurs.
r_if
c_cond
(paren
id|pCh-&gt;validity
op_amp
id|CHANNEL_SUPPORT
)paren
(brace
id|pCh-&gt;infl.hd.i2sChannel
op_assign
id|index
suffix:semicolon
id|pCh-&gt;infl.hd.i2sCount
op_assign
l_int|5
suffix:semicolon
id|pCh-&gt;infl.hd.i2sType
op_assign
id|PTYPE_BYPASS
suffix:semicolon
id|pCh-&gt;infl.fcmd
op_assign
l_int|37
suffix:semicolon
id|pCh-&gt;infl.asof
op_assign
l_int|0
suffix:semicolon
id|pCh-&gt;infl.room
op_assign
id|IBUF_SIZE
op_minus
l_int|1
suffix:semicolon
id|pCh-&gt;whenSendFlow
op_assign
(paren
id|IBUF_SIZE
op_div
l_int|5
)paren
op_star
l_int|4
suffix:semicolon
singleline_comment|// when 80% full
singleline_comment|// The following is similar to calling i2QueueNeeds, except that this
singleline_comment|// is done in longhand, since we are setting up initial conditions on
singleline_comment|// many channels at once.
id|pCh-&gt;channelNeeds
op_assign
id|NEED_FLOW
suffix:semicolon
singleline_comment|// Since starting from scratch
id|pCh-&gt;sinceLastFlow
op_assign
l_int|0
suffix:semicolon
singleline_comment|// No bytes received since last flow
singleline_comment|// control packet was queued
id|stuffIndex
op_increment
suffix:semicolon
op_star
id|ppCh
op_increment
op_assign
id|pCh
suffix:semicolon
singleline_comment|// List this channel as needing
singleline_comment|// initial flow control packet sent
)brace
singleline_comment|// Don&squot;t allow anything to be sent until the status packets come in from
singleline_comment|// the board.
id|pCh-&gt;outfl.asof
op_assign
l_int|0
suffix:semicolon
id|pCh-&gt;outfl.room
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Initialize all the ring buffers
id|pCh-&gt;Ibuf_stuff
op_assign
id|pCh-&gt;Ibuf_strip
op_assign
l_int|0
suffix:semicolon
id|pCh-&gt;Obuf_stuff
op_assign
id|pCh-&gt;Obuf_strip
op_assign
l_int|0
suffix:semicolon
id|pCh-&gt;Cbuf_stuff
op_assign
id|pCh-&gt;Cbuf_strip
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pCh-&gt;icount
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|async_icount
)paren
)paren
suffix:semicolon
id|pCh-&gt;hotKeyIn
op_assign
id|HOT_CLEAR
suffix:semicolon
id|pCh-&gt;channelOptions
op_assign
l_int|0
suffix:semicolon
id|pCh-&gt;bookMarks
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|pCh-&gt;pBookmarkWait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|pCh-&gt;open_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|pCh-&gt;close_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|pCh-&gt;delta_msr_wait
)paren
suffix:semicolon
singleline_comment|// Set base and divisor so default custom rate is 9600
id|pCh-&gt;BaudBase
op_assign
l_int|921600
suffix:semicolon
singleline_comment|// MAX for ST654, changed after we get
id|pCh-&gt;BaudDivisor
op_assign
l_int|96
suffix:semicolon
singleline_comment|// the boxids (UART types) later
id|pCh-&gt;dataSetIn
op_assign
l_int|0
suffix:semicolon
id|pCh-&gt;dataSetOut
op_assign
l_int|0
suffix:semicolon
id|pCh-&gt;wopen
op_assign
l_int|0
suffix:semicolon
id|pCh-&gt;throttled
op_assign
l_int|0
suffix:semicolon
id|pCh-&gt;speed
op_assign
id|CBR_9600
suffix:semicolon
id|pCh-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|pCh-&gt;session
op_assign
l_int|0
suffix:semicolon
id|pCh-&gt;pgrp
op_assign
l_int|0
suffix:semicolon
id|pCh-&gt;ClosingDelay
op_assign
l_int|5
op_star
id|HZ
op_div
l_int|10
suffix:semicolon
id|pCh-&gt;ClosingWaitTime
op_assign
l_int|30
op_star
id|HZ
suffix:semicolon
macro_line|#ifdef USE_IQ
singleline_comment|// Initialize task queue objects
id|pCh-&gt;tqueue_input.routine
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|do_input
suffix:semicolon
id|pCh-&gt;tqueue_input.data
op_assign
id|pCh
suffix:semicolon
id|pCh-&gt;tqueue_status.routine
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
r_void
op_star
)paren
)paren
id|do_status
suffix:semicolon
id|pCh-&gt;tqueue_status.data
op_assign
id|pCh
suffix:semicolon
macro_line|#endif
id|pCh-&gt;trace
op_assign
id|ip2trace
suffix:semicolon
op_increment
id|pCh
suffix:semicolon
op_decrement
id|nChannels
suffix:semicolon
)brace
singleline_comment|// No need to check for wrap here; this is initialization.
id|pB-&gt;i2Fbuf_stuff
op_assign
id|stuffIndex
suffix:semicolon
id|COMPLETE
c_func
(paren
id|pB
comma
id|I2EE_GOOD
)paren
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2DeQueueNeeds(pB, type)
singleline_comment|// Parameters: Pointer to a board structure
singleline_comment|//             type bit map: may include NEED_INLINE, NEED_BYPASS, or NEED_FLOW
singleline_comment|// Returns:   
singleline_comment|//             Pointer to a channel structure
singleline_comment|//
singleline_comment|// Description: Returns pointer struct of next channel that needs service of
singleline_comment|//  the type specified. Otherwise returns a NULL reference.
singleline_comment|//
singleline_comment|//******************************************************************************
r_static
id|i2ChanStrPtr
DECL|function|i2DeQueueNeeds
id|i2DeQueueNeeds
c_func
(paren
id|i2eBordStrPtr
id|pB
comma
r_int
id|type
)paren
(brace
r_int
r_int
id|queueIndex
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|i2ChanStrPtr
id|pCh
op_assign
l_int|NULL
suffix:semicolon
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|NEED_INLINE
suffix:colon
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pB-&gt;Dbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pB-&gt;i2Dbuf_stuff
op_ne
id|pB-&gt;i2Dbuf_strip
)paren
(brace
id|queueIndex
op_assign
id|pB-&gt;i2Dbuf_strip
suffix:semicolon
id|pCh
op_assign
id|pB-&gt;i2Dbuf
(braket
id|queueIndex
)braket
suffix:semicolon
id|queueIndex
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|queueIndex
op_ge
id|CH_QUEUE_SIZE
)paren
(brace
id|queueIndex
op_assign
l_int|0
suffix:semicolon
)brace
id|pB-&gt;i2Dbuf_strip
op_assign
id|queueIndex
suffix:semicolon
id|pCh-&gt;channelNeeds
op_and_assign
op_complement
id|NEED_INLINE
suffix:semicolon
)brace
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pB-&gt;Dbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NEED_BYPASS
suffix:colon
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pB-&gt;Bbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pB-&gt;i2Bbuf_stuff
op_ne
id|pB-&gt;i2Bbuf_strip
)paren
(brace
id|queueIndex
op_assign
id|pB-&gt;i2Bbuf_strip
suffix:semicolon
id|pCh
op_assign
id|pB-&gt;i2Bbuf
(braket
id|queueIndex
)braket
suffix:semicolon
id|queueIndex
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|queueIndex
op_ge
id|CH_QUEUE_SIZE
)paren
(brace
id|queueIndex
op_assign
l_int|0
suffix:semicolon
)brace
id|pB-&gt;i2Bbuf_strip
op_assign
id|queueIndex
suffix:semicolon
id|pCh-&gt;channelNeeds
op_and_assign
op_complement
id|NEED_BYPASS
suffix:semicolon
)brace
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pB-&gt;Bbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NEED_FLOW
suffix:colon
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pB-&gt;Fbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pB-&gt;i2Fbuf_stuff
op_ne
id|pB-&gt;i2Fbuf_strip
)paren
(brace
id|queueIndex
op_assign
id|pB-&gt;i2Fbuf_strip
suffix:semicolon
id|pCh
op_assign
id|pB-&gt;i2Fbuf
(braket
id|queueIndex
)braket
suffix:semicolon
id|queueIndex
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|queueIndex
op_ge
id|CH_QUEUE_SIZE
)paren
(brace
id|queueIndex
op_assign
l_int|0
suffix:semicolon
)brace
id|pB-&gt;i2Fbuf_strip
op_assign
id|queueIndex
suffix:semicolon
id|pCh-&gt;channelNeeds
op_and_assign
op_complement
id|NEED_FLOW
suffix:semicolon
)brace
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pB-&gt;Fbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2DeQueueNeeds called with bad type:%x&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|pCh
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2QueueNeeds(pB, pCh, type)
singleline_comment|// Parameters: Pointer to a board structure
singleline_comment|//             Pointer to a channel structure
singleline_comment|//             type bit map: may include NEED_INLINE, NEED_BYPASS, or NEED_FLOW
singleline_comment|// Returns:    Nothing
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// For each type of need selected, if the given channel is not already in the
singleline_comment|// queue, adds it, and sets the flag indicating it is in the queue.
singleline_comment|//******************************************************************************
r_static
r_void
DECL|function|i2QueueNeeds
id|i2QueueNeeds
c_func
(paren
id|i2eBordStrPtr
id|pB
comma
id|i2ChanStrPtr
id|pCh
comma
r_int
id|type
)paren
(brace
r_int
r_int
id|queueIndex
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
singleline_comment|// We turn off all the interrupts during this brief process, since the
singleline_comment|// interrupt-level code might want to put things on the queue as well.
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|NEED_INLINE
suffix:colon
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pB-&gt;Dbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pCh-&gt;channelNeeds
op_amp
id|NEED_INLINE
)paren
)paren
(brace
id|pCh-&gt;channelNeeds
op_or_assign
id|NEED_INLINE
suffix:semicolon
id|queueIndex
op_assign
id|pB-&gt;i2Dbuf_stuff
suffix:semicolon
id|pB-&gt;i2Dbuf
(braket
id|queueIndex
op_increment
)braket
op_assign
id|pCh
suffix:semicolon
r_if
c_cond
(paren
id|queueIndex
op_ge
id|CH_QUEUE_SIZE
)paren
id|queueIndex
op_assign
l_int|0
suffix:semicolon
id|pB-&gt;i2Dbuf_stuff
op_assign
id|queueIndex
suffix:semicolon
)brace
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pB-&gt;Dbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NEED_BYPASS
suffix:colon
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pB-&gt;Bbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
op_amp
id|NEED_BYPASS
)paren
op_logical_and
op_logical_neg
(paren
id|pCh-&gt;channelNeeds
op_amp
id|NEED_BYPASS
)paren
)paren
(brace
id|pCh-&gt;channelNeeds
op_or_assign
id|NEED_BYPASS
suffix:semicolon
id|queueIndex
op_assign
id|pB-&gt;i2Bbuf_stuff
suffix:semicolon
id|pB-&gt;i2Bbuf
(braket
id|queueIndex
op_increment
)braket
op_assign
id|pCh
suffix:semicolon
r_if
c_cond
(paren
id|queueIndex
op_ge
id|CH_QUEUE_SIZE
)paren
id|queueIndex
op_assign
l_int|0
suffix:semicolon
id|pB-&gt;i2Bbuf_stuff
op_assign
id|queueIndex
suffix:semicolon
)brace
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pB-&gt;Bbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NEED_FLOW
suffix:colon
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pB-&gt;Fbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|type
op_amp
id|NEED_FLOW
)paren
op_logical_and
op_logical_neg
(paren
id|pCh-&gt;channelNeeds
op_amp
id|NEED_FLOW
)paren
)paren
(brace
id|pCh-&gt;channelNeeds
op_or_assign
id|NEED_FLOW
suffix:semicolon
id|queueIndex
op_assign
id|pB-&gt;i2Fbuf_stuff
suffix:semicolon
id|pB-&gt;i2Fbuf
(braket
id|queueIndex
op_increment
)braket
op_assign
id|pCh
suffix:semicolon
r_if
c_cond
(paren
id|queueIndex
op_ge
id|CH_QUEUE_SIZE
)paren
id|queueIndex
op_assign
l_int|0
suffix:semicolon
id|pB-&gt;i2Fbuf_stuff
op_assign
id|queueIndex
suffix:semicolon
)brace
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pB-&gt;Fbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|NEED_CREDIT
suffix:colon
id|pCh-&gt;channelNeeds
op_or_assign
id|NEED_CREDIT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;i2QueueNeeds called with bad type:%x&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2QueueCommands(type, pCh, timeout, nCommands, pCs,...)
singleline_comment|// Parameters: type - PTYPE_BYPASS or PTYPE_INLINE
singleline_comment|//             pointer to the channel structure
singleline_comment|//             maximum period to wait
singleline_comment|//             number of commands (n)
singleline_comment|//             n commands
singleline_comment|// Returns:    Number of commands sent, or -1 for error
singleline_comment|//
singleline_comment|// get board lock before calling
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// Queues up some commands to be sent to a channel. To send possibly several
singleline_comment|// bypass or inline commands to the given channel. The timeout parameter
singleline_comment|// indicates how many HUNDREDTHS OF SECONDS to wait until there is room:
singleline_comment|// 0 = return immediately if no room, -ive  = wait forever, +ive = number of
singleline_comment|// 1/100 seconds to wait. Return values:
singleline_comment|// -1 Some kind of nasty error: bad channel structure or invalid arguments.
singleline_comment|//  0 No room to send all the commands
singleline_comment|// (+)   Number of commands sent
singleline_comment|//******************************************************************************
r_static
r_int
DECL|function|i2QueueCommands
id|i2QueueCommands
c_func
(paren
r_int
id|type
comma
id|i2ChanStrPtr
id|pCh
comma
r_int
id|timeout
comma
r_int
id|nCommands
comma
id|cmdSyntaxPtr
id|pCs0
comma
dot
dot
dot
)paren
(brace
r_int
id|totalsize
op_assign
l_int|0
suffix:semicolon
r_int
id|blocksize
suffix:semicolon
r_int
id|lastended
suffix:semicolon
id|cmdSyntaxPtr
op_star
id|ppCs
suffix:semicolon
id|cmdSyntaxPtr
id|pCs
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|flag
suffix:semicolon
id|i2eBordStrPtr
id|pB
suffix:semicolon
r_int
r_int
id|maxBlock
suffix:semicolon
r_int
r_int
id|maxBuff
suffix:semicolon
r_int
id|bufroom
suffix:semicolon
r_int
r_int
id|stuffIndex
suffix:semicolon
r_int
r_char
op_star
id|pBuf
suffix:semicolon
r_int
r_char
op_star
id|pInsert
suffix:semicolon
r_int
r_char
op_star
id|pDest
comma
op_star
id|pSource
suffix:semicolon
r_int
r_int
id|channel
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
id|rwlock_t
op_star
id|lock_var_p
op_assign
l_int|NULL
suffix:semicolon
singleline_comment|// Make sure the channel exists, otherwise do nothing
r_if
c_cond
(paren
op_logical_neg
id|i2Validate
(paren
id|pCh
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_QUEUE
comma
id|ITRC_ENTER
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|pB
op_assign
id|pCh-&gt;pMyBord
suffix:semicolon
singleline_comment|// Board must also exist, and THE INTERRUPT COMMAND ALREADY SENT
r_if
c_cond
(paren
id|pB-&gt;i2eValid
op_ne
id|I2E_MAGIC
op_logical_or
id|pB-&gt;i2eUsingIrq
op_eq
id|IRQ_UNDEFINED
)paren
(brace
r_return
op_minus
l_int|2
suffix:semicolon
)brace
singleline_comment|// If the board has gone fatal, return bad, and also hit the trap routine if
singleline_comment|// it exists.
r_if
c_cond
(paren
id|pB-&gt;i2eFatal
)paren
(brace
r_if
c_cond
(paren
id|pB-&gt;i2eFatalTrap
)paren
(brace
(paren
op_star
(paren
id|pB
)paren
op_member_access_from_pointer
id|i2eFatalTrap
)paren
(paren
id|pB
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|3
suffix:semicolon
)brace
singleline_comment|// Set up some variables, Which buffers are we using?  How big are they?
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|PTYPE_INLINE
suffix:colon
id|flag
op_assign
id|INL
suffix:semicolon
id|maxBlock
op_assign
id|MAX_OBUF_BLOCK
suffix:semicolon
id|maxBuff
op_assign
id|OBUF_SIZE
suffix:semicolon
id|pBuf
op_assign
id|pCh-&gt;Obuf
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PTYPE_BYPASS
suffix:colon
id|flag
op_assign
id|BYP
suffix:semicolon
id|maxBlock
op_assign
id|MAX_CBUF_BLOCK
suffix:semicolon
id|maxBuff
op_assign
id|CBUF_SIZE
suffix:semicolon
id|pBuf
op_assign
id|pCh-&gt;Cbuf
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|4
suffix:semicolon
)brace
singleline_comment|// Determine the total size required for all the commands
id|totalsize
op_assign
id|blocksize
op_assign
r_sizeof
(paren
id|i2CmdHeader
)paren
suffix:semicolon
id|lastended
op_assign
l_int|0
suffix:semicolon
id|ppCs
op_assign
op_amp
id|pCs0
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
id|nCommands
suffix:semicolon
id|count
suffix:semicolon
id|count
op_decrement
comma
id|ppCs
op_increment
)paren
(brace
id|pCs
op_assign
op_star
id|ppCs
suffix:semicolon
id|cnt
op_assign
id|pCs-&gt;length
suffix:semicolon
singleline_comment|// Will a new block be needed for this one? 
singleline_comment|// Two possible reasons: too
singleline_comment|// big or previous command has to be at the end of a packet.
r_if
c_cond
(paren
(paren
id|blocksize
op_plus
id|cnt
OG
id|maxBlock
)paren
op_logical_or
id|lastended
)paren
(brace
id|blocksize
op_assign
r_sizeof
(paren
id|i2CmdHeader
)paren
suffix:semicolon
id|totalsize
op_add_assign
r_sizeof
(paren
id|i2CmdHeader
)paren
suffix:semicolon
)brace
id|totalsize
op_add_assign
id|cnt
suffix:semicolon
id|blocksize
op_add_assign
id|cnt
suffix:semicolon
singleline_comment|// If this command had to end a block, then we will make sure to
singleline_comment|// account for it should there be any more blocks.
id|lastended
op_assign
id|pCs-&gt;flags
op_amp
id|END
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
singleline_comment|// Make sure any pending flush commands go out before we add more data.
r_if
c_cond
(paren
op_logical_neg
(paren
id|pCh-&gt;flush_flags
op_logical_and
id|i2RetryFlushOutput
c_func
(paren
id|pCh
)paren
)paren
)paren
(brace
singleline_comment|// How much room (this time through) ?
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|PTYPE_INLINE
suffix:colon
id|lock_var_p
op_assign
op_amp
id|pCh-&gt;Obuf_spinlock
suffix:semicolon
id|WRITE_LOCK_IRQSAVE
c_func
(paren
id|lock_var_p
comma
id|flags
)paren
suffix:semicolon
id|stuffIndex
op_assign
id|pCh-&gt;Obuf_stuff
suffix:semicolon
id|bufroom
op_assign
id|pCh-&gt;Obuf_strip
op_minus
id|stuffIndex
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PTYPE_BYPASS
suffix:colon
id|lock_var_p
op_assign
op_amp
id|pCh-&gt;Cbuf_spinlock
suffix:semicolon
id|WRITE_LOCK_IRQSAVE
c_func
(paren
id|lock_var_p
comma
id|flags
)paren
suffix:semicolon
id|stuffIndex
op_assign
id|pCh-&gt;Cbuf_stuff
suffix:semicolon
id|bufroom
op_assign
id|pCh-&gt;Cbuf_strip
op_minus
id|stuffIndex
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
l_int|5
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|bufroom
OL
l_int|0
)paren
(brace
id|bufroom
op_add_assign
id|maxBuff
suffix:semicolon
)brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_QUEUE
comma
l_int|2
comma
l_int|1
comma
id|bufroom
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// Check for overflow
r_if
c_cond
(paren
id|totalsize
op_le
id|bufroom
)paren
(brace
singleline_comment|// Normal Expected path - We still hold LOCK
r_break
suffix:semicolon
multiline_comment|/* from for()- Enough room: goto proceed */
)brace
)brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_QUEUE
comma
l_int|3
comma
l_int|1
comma
id|totalsize
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// Prepare to wait for buffers to empty
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
id|lock_var_p
comma
id|flags
)paren
suffix:semicolon
id|serviceOutgoingFifo
c_func
(paren
id|pB
)paren
suffix:semicolon
singleline_comment|// Dump what we got
r_if
c_cond
(paren
id|timeout
op_eq
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
singleline_comment|// Tired of waiting
)brace
r_if
c_cond
(paren
id|timeout
OG
l_int|0
)paren
id|timeout
op_decrement
suffix:semicolon
singleline_comment|// So negative values == forever
r_if
c_cond
(paren
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
singleline_comment|// short nap 
)brace
r_else
(brace
singleline_comment|// we cannot sched/sleep in interrrupt silly
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
singleline_comment|// Wake up! Time to die!!!
)brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_QUEUE
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
singleline_comment|// end of for(;;)
singleline_comment|// At this point we have room and the lock - stick them in.
id|channel
op_assign
id|pCh-&gt;infl.hd.i2sChannel
suffix:semicolon
id|pInsert
op_assign
op_amp
id|pBuf
(braket
id|stuffIndex
)braket
suffix:semicolon
singleline_comment|// Pointer to start of packet
id|pDest
op_assign
id|CMD_OF
c_func
(paren
id|pInsert
)paren
suffix:semicolon
singleline_comment|// Pointer to start of command
singleline_comment|// When we start counting, the block is the size of the header
r_for
c_loop
(paren
id|blocksize
op_assign
r_sizeof
(paren
id|i2CmdHeader
)paren
comma
id|count
op_assign
id|nCommands
comma
id|lastended
op_assign
l_int|0
comma
id|ppCs
op_assign
op_amp
id|pCs0
suffix:semicolon
id|count
suffix:semicolon
id|count
op_decrement
comma
id|ppCs
op_increment
)paren
(brace
id|pCs
op_assign
op_star
id|ppCs
suffix:semicolon
singleline_comment|// Points to command protocol structure
singleline_comment|// If this is a bookmark request command, post the fact that a bookmark
singleline_comment|// request is pending. NOTE THIS TRICK ONLY WORKS BECAUSE CMD_BMARK_REQ
singleline_comment|// has no parameters!  The more general solution would be to reference
singleline_comment|// pCs-&gt;cmd[0].
r_if
c_cond
(paren
id|pCs
op_eq
id|CMD_BMARK_REQ
)paren
(brace
id|pCh-&gt;bookMarks
op_increment
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_DRAIN
comma
l_int|30
comma
l_int|1
comma
id|pCh-&gt;bookMarks
)paren
suffix:semicolon
macro_line|#endif
)brace
id|cnt
op_assign
id|pCs-&gt;length
suffix:semicolon
singleline_comment|// If this command would put us over the maximum block size or 
singleline_comment|// if the last command had to be at the end of a block, we end
singleline_comment|// the existing block here and start a new one.
r_if
c_cond
(paren
(paren
id|blocksize
op_plus
id|cnt
OG
id|maxBlock
)paren
op_logical_or
id|lastended
)paren
(brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_QUEUE
comma
l_int|5
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|PTYPE_OF
c_func
(paren
id|pInsert
)paren
op_assign
id|type
suffix:semicolon
id|CHANNEL_OF
c_func
(paren
id|pInsert
)paren
op_assign
id|channel
suffix:semicolon
singleline_comment|// count here does not include the header
id|CMD_COUNT_OF
c_func
(paren
id|pInsert
)paren
op_assign
id|blocksize
op_minus
r_sizeof
(paren
id|i2CmdHeader
)paren
suffix:semicolon
id|stuffIndex
op_add_assign
id|blocksize
suffix:semicolon
r_if
c_cond
(paren
id|stuffIndex
op_ge
id|maxBuff
)paren
(brace
id|stuffIndex
op_assign
l_int|0
suffix:semicolon
id|pInsert
op_assign
id|pBuf
suffix:semicolon
)brace
id|pInsert
op_assign
op_amp
id|pBuf
(braket
id|stuffIndex
)braket
suffix:semicolon
singleline_comment|// Pointer to start of next pkt
id|pDest
op_assign
id|CMD_OF
c_func
(paren
id|pInsert
)paren
suffix:semicolon
id|blocksize
op_assign
r_sizeof
(paren
id|i2CmdHeader
)paren
suffix:semicolon
)brace
singleline_comment|// Now we know there is room for this one in the current block
id|blocksize
op_add_assign
id|cnt
suffix:semicolon
singleline_comment|// Total bytes in this command
id|pSource
op_assign
id|pCs-&gt;cmd
suffix:semicolon
singleline_comment|// Copy the command into the buffer
r_while
c_loop
(paren
id|cnt
op_decrement
)paren
(brace
op_star
id|pDest
op_increment
op_assign
op_star
id|pSource
op_increment
suffix:semicolon
)brace
singleline_comment|// If this command had to end a block, then we will make sure to account
singleline_comment|// for it should there be any more blocks.
id|lastended
op_assign
id|pCs-&gt;flags
op_amp
id|END
suffix:semicolon
)brace
singleline_comment|// end for
singleline_comment|// Clean up the final block by writing header, etc
id|PTYPE_OF
c_func
(paren
id|pInsert
)paren
op_assign
id|type
suffix:semicolon
id|CHANNEL_OF
c_func
(paren
id|pInsert
)paren
op_assign
id|channel
suffix:semicolon
singleline_comment|// count here does not include the header
id|CMD_COUNT_OF
c_func
(paren
id|pInsert
)paren
op_assign
id|blocksize
op_minus
r_sizeof
(paren
id|i2CmdHeader
)paren
suffix:semicolon
id|stuffIndex
op_add_assign
id|blocksize
suffix:semicolon
r_if
c_cond
(paren
id|stuffIndex
op_ge
id|maxBuff
)paren
(brace
id|stuffIndex
op_assign
l_int|0
suffix:semicolon
id|pInsert
op_assign
id|pBuf
suffix:semicolon
)brace
singleline_comment|// Updates the index, and post the need for service. When adding these to
singleline_comment|// the queue of channels, we turn off the interrupt while doing so,
singleline_comment|// because at interrupt level we might want to push a channel back to the
singleline_comment|// end of the queue.
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
id|PTYPE_INLINE
suffix:colon
id|pCh-&gt;Obuf_stuff
op_assign
id|stuffIndex
suffix:semicolon
singleline_comment|// Store buffer pointer
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pCh-&gt;Obuf_spinlock
comma
id|flags
)paren
suffix:semicolon
id|pB-&gt;debugInlineQueued
op_increment
suffix:semicolon
singleline_comment|// Add the channel pointer to list of channels needing service (first
singleline_comment|// come...), if it&squot;s not already there.
id|i2QueueNeeds
c_func
(paren
id|pB
comma
id|pCh
comma
id|NEED_INLINE
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PTYPE_BYPASS
suffix:colon
id|pCh-&gt;Cbuf_stuff
op_assign
id|stuffIndex
suffix:semicolon
singleline_comment|// Store buffer pointer
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pCh-&gt;Cbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
id|pB-&gt;debugBypassQueued
op_increment
suffix:semicolon
singleline_comment|// Add the channel pointer to list of channels needing service (first
singleline_comment|// come...), if it&squot;s not already there.
id|i2QueueNeeds
c_func
(paren
id|pB
comma
id|pCh
comma
id|NEED_BYPASS
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_QUEUE
comma
id|ITRC_RETURN
comma
l_int|1
comma
id|nCommands
)paren
suffix:semicolon
macro_line|#endif
r_return
id|nCommands
suffix:semicolon
singleline_comment|// Good status: number of commands sent
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2GetStatus(pCh,resetBits)
singleline_comment|// Parameters: Pointer to a channel structure
singleline_comment|//             Bit map of status bits to clear
singleline_comment|// Returns:    Bit map of current status bits
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// Returns the state of data set signals, and whether a break has been received,
singleline_comment|// (see i2lib.h for bit-mapped result). resetBits is a bit-map of any status
singleline_comment|// bits to be cleared: I2_BRK, I2_PAR, I2_FRA, I2_OVR,... These are cleared
singleline_comment|// AFTER the condition is passed. If pCh does not point to a valid channel,
singleline_comment|// returns -1 (which would be impossible otherwise.
singleline_comment|//******************************************************************************
r_static
r_int
DECL|function|i2GetStatus
id|i2GetStatus
c_func
(paren
id|i2ChanStrPtr
id|pCh
comma
r_int
id|resetBits
)paren
(brace
r_int
r_int
id|status
suffix:semicolon
id|i2eBordStrPtr
id|pB
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_STATUS
comma
id|ITRC_ENTER
comma
l_int|2
comma
id|pCh-&gt;dataSetIn
comma
id|resetBits
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// Make sure the channel exists, otherwise do nothing */
r_if
c_cond
(paren
op_logical_neg
id|i2Validate
(paren
id|pCh
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|pB
op_assign
id|pCh-&gt;pMyBord
suffix:semicolon
id|status
op_assign
id|pCh-&gt;dataSetIn
suffix:semicolon
singleline_comment|// Clear any specified error bits: but note that only actual error bits can
singleline_comment|// be cleared, regardless of the value passed.
r_if
c_cond
(paren
id|resetBits
)paren
(brace
id|pCh-&gt;dataSetIn
op_and_assign
op_complement
(paren
id|resetBits
op_amp
(paren
id|I2_BRK
op_or
id|I2_PAR
op_or
id|I2_FRA
op_or
id|I2_OVR
)paren
)paren
suffix:semicolon
id|pCh-&gt;dataSetIn
op_and_assign
op_complement
(paren
id|I2_DDCD
op_or
id|I2_DCTS
op_or
id|I2_DDSR
op_or
id|I2_DRI
)paren
suffix:semicolon
)brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_STATUS
comma
id|ITRC_RETURN
comma
l_int|1
comma
id|pCh-&gt;dataSetIn
)paren
suffix:semicolon
macro_line|#endif
r_return
id|status
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2Input(pChpDest,count)
singleline_comment|// Parameters: Pointer to a channel structure
singleline_comment|//             Pointer to data buffer
singleline_comment|//             Number of bytes to read
singleline_comment|// Returns:    Number of bytes read, or -1 for error
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// Strips data from the input buffer and writes it to pDest. If there is a
singleline_comment|// collosal blunder, (invalid structure pointers or the like), returns -1.
singleline_comment|// Otherwise, returns the number of bytes read.
singleline_comment|//******************************************************************************
r_static
r_int
DECL|function|i2Input
id|i2Input
c_func
(paren
id|i2ChanStrPtr
id|pCh
)paren
(brace
r_int
id|amountToMove
suffix:semicolon
r_int
r_int
id|stripIndex
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_int
id|flags
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_INPUT
comma
id|ITRC_ENTER
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// Ensure channel structure seems real
r_if
c_cond
(paren
op_logical_neg
id|i2Validate
c_func
(paren
id|pCh
)paren
)paren
(brace
id|count
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|i2Input_exit
suffix:semicolon
)brace
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pCh-&gt;Ibuf_spinlock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// initialize some accelerators and private copies
id|stripIndex
op_assign
id|pCh-&gt;Ibuf_strip
suffix:semicolon
id|count
op_assign
id|pCh-&gt;Ibuf_stuff
op_minus
id|stripIndex
suffix:semicolon
singleline_comment|// If buffer is empty or requested data count was 0, (trivial case) return
singleline_comment|// without any further thought.
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pCh-&gt;Ibuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_goto
id|i2Input_exit
suffix:semicolon
)brace
singleline_comment|// Adjust for buffer wrap
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
(brace
id|count
op_add_assign
id|IBUF_SIZE
suffix:semicolon
)brace
singleline_comment|// Don&squot;t give more than can be taken by the line discipline
id|amountToMove
op_assign
id|pCh-&gt;pTTY-&gt;ldisc
dot
id|receive_room
c_func
(paren
id|pCh-&gt;pTTY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|amountToMove
)paren
(brace
id|count
op_assign
id|amountToMove
suffix:semicolon
)brace
singleline_comment|// How much could we copy without a wrap?
id|amountToMove
op_assign
id|IBUF_SIZE
op_minus
id|stripIndex
suffix:semicolon
r_if
c_cond
(paren
id|amountToMove
OG
id|count
)paren
(brace
id|amountToMove
op_assign
id|count
suffix:semicolon
)brace
singleline_comment|// Move the first block
id|pCh-&gt;pTTY-&gt;ldisc
dot
id|receive_buf
c_func
(paren
id|pCh-&gt;pTTY
comma
op_amp
(paren
id|pCh-&gt;Ibuf
(braket
id|stripIndex
)braket
)paren
comma
l_int|NULL
comma
id|amountToMove
)paren
suffix:semicolon
singleline_comment|// If we needed to wrap, do the second data move
r_if
c_cond
(paren
id|count
OG
id|amountToMove
)paren
(brace
id|pCh-&gt;pTTY-&gt;ldisc
dot
id|receive_buf
c_func
(paren
id|pCh-&gt;pTTY
comma
id|pCh-&gt;Ibuf
comma
l_int|NULL
comma
id|count
op_minus
id|amountToMove
)paren
suffix:semicolon
)brace
singleline_comment|// Bump and wrap the stripIndex all at once by the amount of data read. This
singleline_comment|// method is good regardless of whether the data was in one or two pieces.
id|stripIndex
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|stripIndex
op_ge
id|IBUF_SIZE
)paren
(brace
id|stripIndex
op_sub_assign
id|IBUF_SIZE
suffix:semicolon
)brace
id|pCh-&gt;Ibuf_strip
op_assign
id|stripIndex
suffix:semicolon
singleline_comment|// Update our flow control information and possibly queue ourselves to send
singleline_comment|// it, depending on how much data has been stripped since the last time a
singleline_comment|// packet was sent.
id|pCh-&gt;infl.asof
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pCh-&gt;sinceLastFlow
op_add_assign
id|count
)paren
op_ge
id|pCh-&gt;whenSendFlow
)paren
(brace
id|pCh-&gt;sinceLastFlow
op_sub_assign
id|pCh-&gt;whenSendFlow
suffix:semicolon
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pCh-&gt;Ibuf_spinlock
comma
id|flags
)paren
suffix:semicolon
id|i2QueueNeeds
c_func
(paren
id|pCh-&gt;pMyBord
comma
id|pCh
comma
id|NEED_FLOW
)paren
suffix:semicolon
)brace
r_else
(brace
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pCh-&gt;Ibuf_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
id|i2Input_exit
suffix:colon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_INPUT
comma
id|ITRC_RETURN
comma
l_int|1
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_return
id|count
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2InputFlush(pCh)
singleline_comment|// Parameters: Pointer to a channel structure
singleline_comment|// Returns:    Number of bytes stripped, or -1 for error
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// Strips any data from the input buffer. If there is a collosal blunder,
singleline_comment|// (invalid structure pointers or the like), returns -1. Otherwise, returns the
singleline_comment|// number of bytes stripped.
singleline_comment|//******************************************************************************
r_static
r_int
DECL|function|i2InputFlush
id|i2InputFlush
c_func
(paren
id|i2ChanStrPtr
id|pCh
)paren
(brace
r_int
id|count
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
singleline_comment|// Ensure channel structure seems real
r_if
c_cond
(paren
op_logical_neg
id|i2Validate
(paren
id|pCh
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_INPUT
comma
l_int|10
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pCh-&gt;Ibuf_spinlock
comma
id|flags
)paren
suffix:semicolon
id|count
op_assign
id|pCh-&gt;Ibuf_stuff
op_minus
id|pCh-&gt;Ibuf_strip
suffix:semicolon
singleline_comment|// Adjust for buffer wrap
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
(brace
id|count
op_add_assign
id|IBUF_SIZE
suffix:semicolon
)brace
singleline_comment|// Expedient way to zero out the buffer
id|pCh-&gt;Ibuf_strip
op_assign
id|pCh-&gt;Ibuf_stuff
suffix:semicolon
singleline_comment|// Update our flow control information and possibly queue ourselves to send
singleline_comment|// it, depending on how much data has been stripped since the last time a
singleline_comment|// packet was sent.
id|pCh-&gt;infl.asof
op_add_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pCh-&gt;sinceLastFlow
op_add_assign
id|count
)paren
op_ge
id|pCh-&gt;whenSendFlow
)paren
(brace
id|pCh-&gt;sinceLastFlow
op_sub_assign
id|pCh-&gt;whenSendFlow
suffix:semicolon
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pCh-&gt;Ibuf_spinlock
comma
id|flags
)paren
suffix:semicolon
id|i2QueueNeeds
c_func
(paren
id|pCh-&gt;pMyBord
comma
id|pCh
comma
id|NEED_FLOW
)paren
suffix:semicolon
)brace
r_else
(brace
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pCh-&gt;Ibuf_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_INPUT
comma
l_int|19
comma
l_int|1
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_return
id|count
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2InputAvailable(pCh)
singleline_comment|// Parameters: Pointer to a channel structure
singleline_comment|// Returns:    Number of bytes available, or -1 for error
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// If there is a collosal blunder, (invalid structure pointers or the like),
singleline_comment|// returns -1. Otherwise, returns the number of bytes stripped. Otherwise,
singleline_comment|// returns the number of bytes available in the buffer.
singleline_comment|//******************************************************************************
macro_line|#if 0
r_static
r_int
id|i2InputAvailable
c_func
(paren
id|i2ChanStrPtr
id|pCh
)paren
(brace
r_int
id|count
suffix:semicolon
singleline_comment|// Ensure channel structure seems real
r_if
c_cond
(paren
op_logical_neg
id|i2Validate
(paren
id|pCh
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
singleline_comment|// initialize some accelerators and private copies
id|READ_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pCh-&gt;Ibuf_spinlock
comma
id|flags
)paren
suffix:semicolon
id|count
op_assign
id|pCh-&gt;Ibuf_stuff
op_minus
id|pCh-&gt;Ibuf_strip
suffix:semicolon
id|READ_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pCh-&gt;Ibuf_spinlock
comma
id|flags
)paren
suffix:semicolon
singleline_comment|// Adjust for buffer wrap
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
(brace
id|count
op_add_assign
id|IBUF_SIZE
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
macro_line|#endif 
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2Output(pCh, pSource, count)
singleline_comment|// Parameters: Pointer to channel structure
singleline_comment|//             Pointer to source data
singleline_comment|//             Number of bytes to send
singleline_comment|// Returns:    Number of bytes sent, or -1 for error
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// Queues the data at pSource to be sent as data packets to the board. If there
singleline_comment|// is a collosal blunder, (invalid structure pointers or the like), returns -1.
singleline_comment|// Otherwise, returns the number of bytes written. What if there is not enough
singleline_comment|// room for all the data? If pCh-&gt;channelOptions &amp; CO_NBLOCK_WRITE is set, then
singleline_comment|// we transfer as many characters as we can now, then return. If this bit is
singleline_comment|// clear (default), routine will spin along until all the data is buffered.
singleline_comment|// Should this occur, the 1-ms delay routine is called while waiting to avoid
singleline_comment|// applications that one cannot break out of.
singleline_comment|//******************************************************************************
r_static
r_int
DECL|function|i2Output
id|i2Output
c_func
(paren
id|i2ChanStrPtr
id|pCh
comma
r_const
r_char
op_star
id|pSource
comma
r_int
id|count
comma
r_int
id|user
)paren
(brace
id|i2eBordStrPtr
id|pB
suffix:semicolon
r_int
r_char
op_star
id|pInsert
suffix:semicolon
r_int
id|amountToMove
suffix:semicolon
r_int
id|countOriginal
op_assign
id|count
suffix:semicolon
r_int
r_int
id|channel
suffix:semicolon
r_int
r_int
id|stuffIndex
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
id|bailout
op_assign
l_int|10
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_OUTPUT
comma
id|ITRC_ENTER
comma
l_int|2
comma
id|count
comma
id|user
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// Ensure channel structure seems real
r_if
c_cond
(paren
op_logical_neg
id|i2Validate
(paren
id|pCh
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
singleline_comment|// initialize some accelerators and private copies
id|pB
op_assign
id|pCh-&gt;pMyBord
suffix:semicolon
id|channel
op_assign
id|pCh-&gt;infl.hd.i2sChannel
suffix:semicolon
singleline_comment|// If the board has gone fatal, return bad, and also hit the trap routine if
singleline_comment|// it exists.
r_if
c_cond
(paren
id|pB-&gt;i2eFatal
)paren
(brace
r_if
c_cond
(paren
id|pB-&gt;i2eFatalTrap
)paren
(brace
(paren
op_star
(paren
id|pB
)paren
op_member_access_from_pointer
id|i2eFatalTrap
)paren
(paren
id|pB
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
singleline_comment|// Proceed as though we would do everything
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
singleline_comment|// How much room in output buffer is there?
id|READ_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pCh-&gt;Obuf_spinlock
comma
id|flags
)paren
suffix:semicolon
id|amountToMove
op_assign
id|pCh-&gt;Obuf_strip
op_minus
id|pCh-&gt;Obuf_stuff
op_minus
l_int|1
suffix:semicolon
id|READ_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pCh-&gt;Obuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amountToMove
OL
l_int|0
)paren
(brace
id|amountToMove
op_add_assign
id|OBUF_SIZE
suffix:semicolon
)brace
singleline_comment|// Subtract off the headers size and see how much room there is for real
singleline_comment|// data. If this is negative, we will discover later.
id|amountToMove
op_sub_assign
r_sizeof
(paren
id|i2DataHeader
)paren
suffix:semicolon
singleline_comment|// Don&squot;t move more (now) than can go in a single packet
r_if
c_cond
(paren
id|amountToMove
OG
(paren
r_int
)paren
(paren
id|MAX_OBUF_BLOCK
op_minus
r_sizeof
(paren
id|i2DataHeader
)paren
)paren
)paren
(brace
id|amountToMove
op_assign
id|MAX_OBUF_BLOCK
op_minus
r_sizeof
(paren
id|i2DataHeader
)paren
suffix:semicolon
)brace
singleline_comment|// Don&squot;t move more than the count we were given
r_if
c_cond
(paren
id|amountToMove
OG
id|count
)paren
(brace
id|amountToMove
op_assign
id|count
suffix:semicolon
)brace
singleline_comment|// Now we know how much we must move: NB because the ring buffers have
singleline_comment|// an overflow area at the end, we needn&squot;t worry about wrapping in the
singleline_comment|// middle of a packet.
singleline_comment|// Small WINDOW here with no LOCK but I can&squot;t call Flush with LOCK
singleline_comment|// We would be flushing (or ending flush) anyway
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_OUTPUT
comma
l_int|10
comma
l_int|1
comma
id|amountToMove
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|pCh-&gt;flush_flags
op_logical_and
id|i2RetryFlushOutput
c_func
(paren
id|pCh
)paren
)paren
op_logical_and
id|amountToMove
OG
l_int|0
)paren
(brace
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pCh-&gt;Obuf_spinlock
comma
id|flags
)paren
suffix:semicolon
id|stuffIndex
op_assign
id|pCh-&gt;Obuf_stuff
suffix:semicolon
singleline_comment|// Had room to move some data: don&squot;t know whether the block size,
singleline_comment|// buffer space, or what was the limiting factor...
id|pInsert
op_assign
op_amp
(paren
id|pCh-&gt;Obuf
(braket
id|stuffIndex
)braket
)paren
suffix:semicolon
singleline_comment|// Set up the header
id|CHANNEL_OF
c_func
(paren
id|pInsert
)paren
op_assign
id|channel
suffix:semicolon
id|PTYPE_OF
c_func
(paren
id|pInsert
)paren
op_assign
id|PTYPE_DATA
suffix:semicolon
id|TAG_OF
c_func
(paren
id|pInsert
)paren
op_assign
l_int|0
suffix:semicolon
id|ID_OF
c_func
(paren
id|pInsert
)paren
op_assign
id|ID_ORDINARY_DATA
suffix:semicolon
id|DATA_COUNT_OF
c_func
(paren
id|pInsert
)paren
op_assign
id|amountToMove
suffix:semicolon
singleline_comment|// Move the data
r_if
c_cond
(paren
id|user
)paren
(brace
id|COPY_FROM_USER
c_func
(paren
id|rc
comma
(paren
r_char
op_star
)paren
(paren
id|DATA_OF
c_func
(paren
id|pInsert
)paren
)paren
comma
id|pSource
comma
id|amountToMove
)paren
suffix:semicolon
)brace
r_else
(brace
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
(paren
id|DATA_OF
c_func
(paren
id|pInsert
)paren
)paren
comma
id|pSource
comma
id|amountToMove
)paren
suffix:semicolon
)brace
singleline_comment|// Adjust pointers and indices
id|pSource
op_add_assign
id|amountToMove
suffix:semicolon
id|pCh-&gt;Obuf_char_count
op_add_assign
id|amountToMove
suffix:semicolon
id|stuffIndex
op_add_assign
id|amountToMove
op_plus
r_sizeof
(paren
id|i2DataHeader
)paren
suffix:semicolon
id|count
op_sub_assign
id|amountToMove
suffix:semicolon
r_if
c_cond
(paren
id|stuffIndex
op_ge
id|OBUF_SIZE
)paren
(brace
id|stuffIndex
op_assign
l_int|0
suffix:semicolon
)brace
id|pCh-&gt;Obuf_stuff
op_assign
id|stuffIndex
suffix:semicolon
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pCh-&gt;Obuf_spinlock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_OUTPUT
comma
l_int|13
comma
l_int|1
comma
id|stuffIndex
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
singleline_comment|// Cannot move data
singleline_comment|// becuz we need to stuff a flush 
singleline_comment|// or amount to move is &lt;= 0
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
c_func
(paren
id|CHANN
comma
id|ITRC_OUTPUT
comma
l_int|14
comma
l_int|3
comma
id|amountToMove
comma
id|pB-&gt;i2eFifoRemains
comma
id|pB-&gt;i2eWaitingForEmptyFifo
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// Put this channel back on queue
singleline_comment|// this ultimatly gets more data or wakes write output
id|i2QueueNeeds
c_func
(paren
id|pB
comma
id|pCh
comma
id|NEED_INLINE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pB-&gt;i2eWaitingForEmptyFifo
)paren
(brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_OUTPUT
comma
l_int|16
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// or schedule
r_if
c_cond
(paren
op_logical_neg
id|in_interrupt
c_func
(paren
)paren
)paren
(brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_OUTPUT
comma
l_int|61
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_OUTPUT
comma
l_int|62
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// let interrupt in = WAS restore_flags()
singleline_comment|// We hold no lock nor is irq off anymore???
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
singleline_comment|// from while(count)
)brace
r_else
r_if
c_cond
(paren
id|pB-&gt;i2eFifoRemains
OL
l_int|32
op_logical_and
op_logical_neg
id|pB-&gt;i2eTxMailEmpty
(paren
id|pB
)paren
)paren
(brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_OUTPUT
comma
l_int|19
comma
l_int|2
comma
id|pB-&gt;i2eFifoRemains
comma
id|pB-&gt;i2eTxMailEmpty
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
singleline_comment|// from while(count)
)brace
r_else
r_if
c_cond
(paren
id|pCh-&gt;channelNeeds
op_amp
id|NEED_CREDIT
)paren
(brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_OUTPUT
comma
l_int|22
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
singleline_comment|// from while(count)
)brace
r_else
r_if
c_cond
(paren
op_decrement
id|bailout
)paren
(brace
singleline_comment|// Try to throw more things (maybe not us) in the fifo if we&squot;re
singleline_comment|// not already waiting for it.
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_OUTPUT
comma
l_int|20
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|serviceOutgoingFifo
c_func
(paren
id|pB
)paren
suffix:semicolon
singleline_comment|//break;  CONTINUE;
)brace
r_else
(brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_OUTPUT
comma
l_int|21
comma
l_int|3
comma
id|pB-&gt;i2eFifoRemains
comma
id|pB-&gt;i2eOutMailWaiting
comma
id|pB-&gt;i2eWaitingForEmptyFifo
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
singleline_comment|// from while(count)
)brace
)brace
)brace
singleline_comment|// End of while(count)
id|i2QueueNeeds
c_func
(paren
id|pB
comma
id|pCh
comma
id|NEED_INLINE
)paren
suffix:semicolon
singleline_comment|// We drop through either when the count expires, or when there is some
singleline_comment|// count left, but there was a non-blocking write.
r_if
c_cond
(paren
id|countOriginal
OG
id|count
)paren
(brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_OUTPUT
comma
l_int|17
comma
l_int|2
comma
id|countOriginal
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
id|serviceOutgoingFifo
c_func
(paren
id|pB
)paren
suffix:semicolon
)brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_OUTPUT
comma
id|ITRC_RETURN
comma
l_int|2
comma
id|countOriginal
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
r_return
id|countOriginal
op_minus
id|count
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2FlushOutput(pCh)
singleline_comment|// Parameters: Pointer to a channel structure
singleline_comment|// Returns:    Nothing
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// Sends bypass command to start flushing (waiting possibly forever until there
singleline_comment|// is room), then sends inline command to stop flushing output, (again waiting
singleline_comment|// possibly forever).
singleline_comment|//******************************************************************************
r_static
r_inline
r_void
DECL|function|i2FlushOutput
id|i2FlushOutput
c_func
(paren
id|i2ChanStrPtr
id|pCh
)paren
(brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_FLUSH
comma
l_int|1
comma
l_int|1
comma
id|pCh-&gt;flush_flags
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pCh-&gt;flush_flags
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
l_int|1
op_ne
id|i2QueueCommands
c_func
(paren
id|PTYPE_BYPASS
comma
id|pCh
comma
l_int|0
comma
l_int|1
comma
id|CMD_STARTFL
)paren
)paren
(brace
id|pCh-&gt;flush_flags
op_assign
id|STARTFL_FLAG
suffix:semicolon
singleline_comment|// Failed - flag for later
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_FLUSH
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
r_if
c_cond
(paren
l_int|1
op_ne
id|i2QueueCommands
c_func
(paren
id|PTYPE_INLINE
comma
id|pCh
comma
l_int|0
comma
l_int|1
comma
id|CMD_STOPFL
)paren
)paren
(brace
id|pCh-&gt;flush_flags
op_assign
id|STOPFL_FLAG
suffix:semicolon
singleline_comment|// Failed - flag for later
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_FLUSH
comma
l_int|3
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_static
r_int
DECL|function|i2RetryFlushOutput
id|i2RetryFlushOutput
c_func
(paren
id|i2ChanStrPtr
id|pCh
)paren
(brace
r_int
id|old_flags
op_assign
id|pCh-&gt;flush_flags
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_FLUSH
comma
l_int|14
comma
l_int|1
comma
id|old_flags
)paren
suffix:semicolon
macro_line|#endif
id|pCh-&gt;flush_flags
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Clear flag so we can avoid recursion
singleline_comment|// and queue the commands
r_if
c_cond
(paren
id|old_flags
op_amp
id|STARTFL_FLAG
)paren
(brace
r_if
c_cond
(paren
l_int|1
op_eq
id|i2QueueCommands
c_func
(paren
id|PTYPE_BYPASS
comma
id|pCh
comma
l_int|0
comma
l_int|1
comma
id|CMD_STARTFL
)paren
)paren
(brace
id|old_flags
op_assign
id|STOPFL_FLAG
suffix:semicolon
singleline_comment|//Success - send stop flush
)brace
r_else
(brace
id|old_flags
op_assign
id|STARTFL_FLAG
suffix:semicolon
singleline_comment|//Failure - Flag for retry later
)brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_FLUSH
comma
l_int|15
comma
l_int|1
comma
id|old_flags
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|old_flags
op_amp
id|STOPFL_FLAG
)paren
(brace
r_if
c_cond
(paren
l_int|1
op_eq
id|i2QueueCommands
c_func
(paren
id|PTYPE_INLINE
comma
id|pCh
comma
l_int|0
comma
l_int|1
comma
id|CMD_STOPFL
)paren
OG
l_int|0
)paren
(brace
id|old_flags
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Success - clear flags
)brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_FLUSH
comma
l_int|16
comma
l_int|1
comma
id|old_flags
)paren
suffix:semicolon
macro_line|#endif
)brace
id|pCh-&gt;flush_flags
op_assign
id|old_flags
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_FLUSH
comma
l_int|17
comma
l_int|1
comma
id|old_flags
)paren
suffix:semicolon
macro_line|#endif
r_return
id|old_flags
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2DrainOutput(pCh,timeout)
singleline_comment|// Parameters: Pointer to a channel structure
singleline_comment|//             Maximum period to wait
singleline_comment|// Returns:    ?
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// Uses the bookmark request command to ask the board to send a bookmark back as
singleline_comment|// soon as all the data is completely sent.
singleline_comment|//******************************************************************************
r_static
r_void
DECL|function|i2DrainWakeup
id|i2DrainWakeup
c_func
(paren
id|i2ChanStrPtr
id|pCh
)paren
(brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_DRAIN
comma
l_int|10
comma
l_int|1
comma
id|pCh-&gt;BookmarkTimer.expires
)paren
suffix:semicolon
macro_line|#endif
id|pCh-&gt;BookmarkTimer.expires
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|pCh-&gt;pBookmarkWait
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|i2DrainOutput
id|i2DrainOutput
c_func
(paren
id|i2ChanStrPtr
id|pCh
comma
r_int
id|timeout
)paren
(brace
id|i2eBordStrPtr
id|pB
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_DRAIN
comma
id|ITRC_ENTER
comma
l_int|1
comma
id|pCh-&gt;BookmarkTimer.expires
)paren
suffix:semicolon
macro_line|#endif
id|pB
op_assign
id|pCh-&gt;pMyBord
suffix:semicolon
singleline_comment|// If the board has gone fatal, return bad, 
singleline_comment|// and also hit the trap routine if it exists.
r_if
c_cond
(paren
id|pB-&gt;i2eFatal
)paren
(brace
r_if
c_cond
(paren
id|pB-&gt;i2eFatalTrap
)paren
(brace
(paren
op_star
(paren
id|pB
)paren
op_member_access_from_pointer
id|i2eFatalTrap
)paren
(paren
id|pB
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|timeout
OG
l_int|0
)paren
op_logical_and
(paren
id|pCh-&gt;BookmarkTimer.expires
op_eq
l_int|0
)paren
)paren
(brace
singleline_comment|// One per customer (channel)
id|init_timer
c_func
(paren
op_amp
(paren
id|pCh-&gt;BookmarkTimer
)paren
)paren
suffix:semicolon
id|pCh-&gt;BookmarkTimer.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|pCh-&gt;BookmarkTimer.function
op_assign
(paren
r_void
op_star
)paren
(paren
r_int
r_int
)paren
id|i2DrainWakeup
suffix:semicolon
id|pCh-&gt;BookmarkTimer.data
op_assign
(paren
r_int
r_int
)paren
id|pCh
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_DRAIN
comma
l_int|1
comma
l_int|1
comma
id|pCh-&gt;BookmarkTimer.expires
)paren
suffix:semicolon
macro_line|#endif
id|add_timer
c_func
(paren
op_amp
(paren
id|pCh-&gt;BookmarkTimer
)paren
)paren
suffix:semicolon
)brace
id|i2QueueCommands
c_func
(paren
id|PTYPE_INLINE
comma
id|pCh
comma
op_minus
l_int|1
comma
l_int|1
comma
id|CMD_BMARK_REQ
)paren
suffix:semicolon
id|serviceOutgoingFifo
c_func
(paren
id|pB
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
(paren
id|pCh-&gt;pBookmarkWait
)paren
)paren
suffix:semicolon
singleline_comment|// if expires == 0 then timer poped, then do not need to del_timer
r_if
c_cond
(paren
(paren
id|timeout
OG
l_int|0
)paren
op_logical_and
id|pCh-&gt;BookmarkTimer.expires
op_logical_and
(paren
id|pCh-&gt;BookmarkTimer.expires
OG
id|jiffies
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
(paren
id|pCh-&gt;BookmarkTimer
)paren
)paren
suffix:semicolon
id|pCh-&gt;BookmarkTimer.expires
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_DRAIN
comma
l_int|3
comma
l_int|1
comma
id|pCh-&gt;BookmarkTimer.expires
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_DRAIN
comma
id|ITRC_RETURN
comma
l_int|1
comma
id|pCh-&gt;BookmarkTimer.expires
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2OutputFree(pCh)
singleline_comment|// Parameters: Pointer to a channel structure
singleline_comment|// Returns:    Space in output buffer
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// Returns -1 if very gross error. Otherwise returns the amount of bytes still
singleline_comment|// free in the output buffer.
singleline_comment|//******************************************************************************
r_static
r_int
DECL|function|i2OutputFree
id|i2OutputFree
c_func
(paren
id|i2ChanStrPtr
id|pCh
)paren
(brace
r_int
id|amountToMove
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
singleline_comment|// Ensure channel structure seems real
r_if
c_cond
(paren
op_logical_neg
id|i2Validate
(paren
id|pCh
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|READ_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pCh-&gt;Obuf_spinlock
comma
id|flags
)paren
suffix:semicolon
id|amountToMove
op_assign
id|pCh-&gt;Obuf_strip
op_minus
id|pCh-&gt;Obuf_stuff
op_minus
l_int|1
suffix:semicolon
id|READ_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pCh-&gt;Obuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|amountToMove
OL
l_int|0
)paren
(brace
id|amountToMove
op_add_assign
id|OBUF_SIZE
suffix:semicolon
)brace
singleline_comment|// If this is negative, we will discover later
id|amountToMove
op_sub_assign
r_sizeof
(paren
id|i2DataHeader
)paren
suffix:semicolon
r_return
(paren
id|amountToMove
OL
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
id|amountToMove
suffix:semicolon
)brace
r_static
r_void
DECL|function|ip2_owake
id|ip2_owake
c_func
(paren
id|PTTY
id|tp
)paren
(brace
id|i2ChanStrPtr
id|pCh
suffix:semicolon
r_if
c_cond
(paren
id|tp
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|pCh
op_assign
id|tp-&gt;driver_data
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_SICMD
comma
l_int|10
comma
l_int|2
comma
id|tp-&gt;flags
comma
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
suffix:semicolon
macro_line|#endif
id|wake_up_interruptible
(paren
op_amp
id|tp-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tp-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tp-&gt;ldisc.write_wakeup
)paren
(brace
(paren
id|tp-&gt;ldisc.write_wakeup
)paren
(paren
id|tp
)paren
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_SICMD
comma
l_int|11
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_static
r_inline
r_void
DECL|function|set_baud_params
id|set_baud_params
c_func
(paren
id|i2eBordStrPtr
id|pB
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
id|i2ChanStrPtr
op_star
id|pCh
suffix:semicolon
id|pCh
op_assign
(paren
id|i2ChanStrPtr
op_star
)paren
id|pB-&gt;i2eChannelPtr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ABS_MAX_BOXES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pB-&gt;channelBtypes.bid_value
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|BID_HAS_654
c_func
(paren
id|pB-&gt;channelBtypes.bid_value
(braket
id|i
)braket
)paren
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ABS_BIGGEST_BOX
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pCh
(braket
id|i
op_star
l_int|16
op_plus
id|j
)braket
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
(paren
id|pCh
(braket
id|i
op_star
l_int|16
op_plus
id|j
)braket
)paren
op_member_access_from_pointer
id|BaudBase
op_assign
l_int|921600
suffix:semicolon
singleline_comment|// MAX for ST654
(paren
id|pCh
(braket
id|i
op_star
l_int|16
op_plus
id|j
)braket
)paren
op_member_access_from_pointer
id|BaudDivisor
op_assign
l_int|96
suffix:semicolon
)brace
)brace
r_else
(brace
singleline_comment|// has cirrus cd1400
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|ABS_BIGGEST_BOX
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pCh
(braket
id|i
op_star
l_int|16
op_plus
id|j
)braket
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
(paren
id|pCh
(braket
id|i
op_star
l_int|16
op_plus
id|j
)braket
)paren
op_member_access_from_pointer
id|BaudBase
op_assign
l_int|115200
suffix:semicolon
singleline_comment|// MAX for CD1400
(paren
id|pCh
(braket
id|i
op_star
l_int|16
op_plus
id|j
)braket
)paren
op_member_access_from_pointer
id|BaudDivisor
op_assign
l_int|12
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2StripFifo(pB)
singleline_comment|// Parameters: Pointer to a board structure
singleline_comment|// Returns:    ?
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// Strips all the available data from the incoming FIFO, identifies the type of
singleline_comment|// packet, and either buffers the data or does what needs to be done.
singleline_comment|//
singleline_comment|// Note there is no overflow checking here: if the board sends more data than it
singleline_comment|// ought to, we will not detect it here, but blindly overflow...
singleline_comment|//******************************************************************************
singleline_comment|// A buffer for reading in blocks for unknown channels
DECL|variable|junkBuffer
r_static
r_int
r_char
id|junkBuffer
(braket
id|IBUF_SIZE
)braket
suffix:semicolon
singleline_comment|// A buffer to read in a status packet. Because of the size of the count field
singleline_comment|// for these things, the maximum packet size must be less than MAX_CMD_PACK_SIZE
DECL|variable|cmdBuffer
r_static
r_int
r_char
id|cmdBuffer
(braket
id|MAX_CMD_PACK_SIZE
op_plus
l_int|4
)braket
suffix:semicolon
singleline_comment|// This table changes the bit order from MSR order given by STAT_MODEM packet to
singleline_comment|// status bits used in our library.
DECL|variable|xlatDss
r_static
r_char
id|xlatDss
(braket
l_int|16
)braket
op_assign
(brace
l_int|0
op_or
l_int|0
op_or
l_int|0
op_or
l_int|0
comma
l_int|0
op_or
l_int|0
op_or
l_int|0
op_or
id|I2_CTS
comma
l_int|0
op_or
l_int|0
op_or
id|I2_DSR
op_or
l_int|0
comma
l_int|0
op_or
l_int|0
op_or
id|I2_DSR
op_or
id|I2_CTS
comma
l_int|0
op_or
id|I2_RI
op_or
l_int|0
op_or
l_int|0
comma
l_int|0
op_or
id|I2_RI
op_or
l_int|0
op_or
id|I2_CTS
comma
l_int|0
op_or
id|I2_RI
op_or
id|I2_DSR
op_or
l_int|0
comma
l_int|0
op_or
id|I2_RI
op_or
id|I2_DSR
op_or
id|I2_CTS
comma
id|I2_DCD
op_or
l_int|0
op_or
l_int|0
op_or
l_int|0
comma
id|I2_DCD
op_or
l_int|0
op_or
l_int|0
op_or
id|I2_CTS
comma
id|I2_DCD
op_or
l_int|0
op_or
id|I2_DSR
op_or
l_int|0
comma
id|I2_DCD
op_or
l_int|0
op_or
id|I2_DSR
op_or
id|I2_CTS
comma
id|I2_DCD
op_or
id|I2_RI
op_or
l_int|0
op_or
l_int|0
comma
id|I2_DCD
op_or
id|I2_RI
op_or
l_int|0
op_or
id|I2_CTS
comma
id|I2_DCD
op_or
id|I2_RI
op_or
id|I2_DSR
op_or
l_int|0
comma
id|I2_DCD
op_or
id|I2_RI
op_or
id|I2_DSR
op_or
id|I2_CTS
)brace
suffix:semicolon
r_static
r_inline
r_void
DECL|function|i2StripFifo
id|i2StripFifo
c_func
(paren
id|i2eBordStrPtr
id|pB
)paren
(brace
id|i2ChanStrPtr
id|pCh
suffix:semicolon
r_int
id|channel
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
r_int
id|stuffIndex
suffix:semicolon
r_int
id|amountToRead
suffix:semicolon
r_int
r_char
op_star
id|pc
comma
op_star
id|pcLimit
suffix:semicolon
r_int
r_char
id|uc
suffix:semicolon
r_int
r_char
id|dss_change
suffix:semicolon
r_int
r_int
id|bflags
comma
id|cflags
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
singleline_comment|//ip2trace (ITRC_NO_PORT, ITRC_SFIFO, ITRC_ENTER, 0 );
macro_line|#endif
r_while
c_loop
(paren
id|HAS_INPUT
c_func
(paren
id|pB
)paren
)paren
(brace
macro_line|#ifdef IP2DEBUG_TRACE
singleline_comment|//ip2trace (ITRC_NO_PORT, ITRC_SFIFO, 2, 0 );
macro_line|#endif
singleline_comment|// Process packet from fifo a one atomic unit
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pB-&gt;read_fifo_spinlock
comma
id|bflags
)paren
suffix:semicolon
singleline_comment|// The first word (or two bytes) will have channel number and type of
singleline_comment|// packet, possibly other information
id|pB-&gt;i2eLeadoffWord
(braket
l_int|0
)braket
op_assign
id|iiReadWord
c_func
(paren
id|pB
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|PTYPE_OF
c_func
(paren
id|pB-&gt;i2eLeadoffWord
)paren
)paren
(brace
r_case
id|PTYPE_DATA
suffix:colon
id|pB-&gt;got_input
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
singleline_comment|//ip2trace (ITRC_NO_PORT, ITRC_SFIFO, 3, 0 );
macro_line|#endif
id|channel
op_assign
id|CHANNEL_OF
c_func
(paren
id|pB-&gt;i2eLeadoffWord
)paren
suffix:semicolon
multiline_comment|/* Store channel */
id|count
op_assign
id|iiReadWord
c_func
(paren
id|pB
)paren
suffix:semicolon
multiline_comment|/* Count is in the next word */
singleline_comment|// NEW: Check the count for sanity! Should the hardware fail, our death
singleline_comment|// is more pleasant. While an oversize channel is acceptable (just more
singleline_comment|// than the driver supports), an over-length count clearly means we are
singleline_comment|// sick!
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|count
)paren
OG
id|IBUF_SIZE
)paren
(brace
id|pB-&gt;i2eFatal
op_assign
l_int|2
suffix:semicolon
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pB-&gt;read_fifo_spinlock
comma
id|bflags
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* Bail out ASAP */
)brace
singleline_comment|// Channel is illegally big ?
r_if
c_cond
(paren
(paren
id|channel
op_ge
id|pB-&gt;i2eChannelCnt
)paren
op_logical_or
(paren
l_int|NULL
op_eq
(paren
id|pCh
op_assign
(paren
(paren
id|i2ChanStrPtr
op_star
)paren
id|pB-&gt;i2eChannelPtr
)paren
(braket
id|channel
)braket
)paren
)paren
)paren
(brace
id|iiReadBuf
c_func
(paren
id|pB
comma
id|junkBuffer
comma
id|count
)paren
suffix:semicolon
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pB-&gt;read_fifo_spinlock
comma
id|bflags
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* From switch: ready for next packet */
)brace
singleline_comment|// Channel should be valid, then
singleline_comment|// If this is a hot-key, merely post its receipt for now. These are
singleline_comment|// always supposed to be 1-byte packets, so we won&squot;t even check the
singleline_comment|// count. Also we will post an acknowledgement to the board so that
singleline_comment|// more data can be forthcoming. Note that we are not trying to use
singleline_comment|// these sequences in this driver, merely to robustly ignore them.
r_if
c_cond
(paren
id|ID_OF
c_func
(paren
id|pB-&gt;i2eLeadoffWord
)paren
op_eq
id|ID_HOT_KEY
)paren
(brace
id|pCh-&gt;hotKeyIn
op_assign
id|iiReadWord
c_func
(paren
id|pB
)paren
op_amp
l_int|0xff
suffix:semicolon
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pB-&gt;read_fifo_spinlock
comma
id|bflags
)paren
suffix:semicolon
id|i2QueueCommands
c_func
(paren
id|PTYPE_BYPASS
comma
id|pCh
comma
l_int|0
comma
l_int|1
comma
id|CMD_HOTACK
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* From the switch: ready for next packet */
)brace
singleline_comment|// Normal data! We crudely assume there is room for the data in our
singleline_comment|// buffer because the board wouldn&squot;t have exceeded his credit limit.
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pCh-&gt;Ibuf_spinlock
comma
id|cflags
)paren
suffix:semicolon
singleline_comment|// We have 2 locks now
id|stuffIndex
op_assign
id|pCh-&gt;Ibuf_stuff
suffix:semicolon
id|amountToRead
op_assign
id|IBUF_SIZE
op_minus
id|stuffIndex
suffix:semicolon
r_if
c_cond
(paren
id|amountToRead
OG
id|count
)paren
id|amountToRead
op_assign
id|count
suffix:semicolon
singleline_comment|// stuffIndex would have been already adjusted so there would 
singleline_comment|// always be room for at least one, and count is always at least
singleline_comment|// one.
id|iiReadBuf
c_func
(paren
id|pB
comma
op_amp
(paren
id|pCh-&gt;Ibuf
(braket
id|stuffIndex
)braket
)paren
comma
id|amountToRead
)paren
suffix:semicolon
id|pCh-&gt;icount.rx
op_add_assign
id|amountToRead
suffix:semicolon
singleline_comment|// Update the stuffIndex by the amount of data moved. Note we could
singleline_comment|// never ask for more data than would just fit. However, we might
singleline_comment|// have read in one more byte than we wanted because the read
singleline_comment|// rounds up to even bytes. If this byte is on the end of the
singleline_comment|// packet, and is padding, we ignore it. If the byte is part of
singleline_comment|// the actual data, we need to move it.
id|stuffIndex
op_add_assign
id|amountToRead
suffix:semicolon
r_if
c_cond
(paren
id|stuffIndex
op_ge
id|IBUF_SIZE
)paren
(brace
r_if
c_cond
(paren
(paren
id|amountToRead
op_amp
l_int|1
)paren
op_logical_and
(paren
id|count
OG
id|amountToRead
)paren
)paren
(brace
id|pCh-&gt;Ibuf
(braket
l_int|0
)braket
op_assign
id|pCh-&gt;Ibuf
(braket
id|IBUF_SIZE
)braket
suffix:semicolon
id|amountToRead
op_increment
suffix:semicolon
id|stuffIndex
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|stuffIndex
op_assign
l_int|0
suffix:semicolon
)brace
)brace
singleline_comment|// If there is anything left over, read it as well
r_if
c_cond
(paren
id|count
OG
id|amountToRead
)paren
(brace
id|amountToRead
op_assign
id|count
op_minus
id|amountToRead
suffix:semicolon
id|iiReadBuf
c_func
(paren
id|pB
comma
op_amp
(paren
id|pCh-&gt;Ibuf
(braket
id|stuffIndex
)braket
)paren
comma
id|amountToRead
)paren
suffix:semicolon
id|pCh-&gt;icount.rx
op_add_assign
id|amountToRead
suffix:semicolon
id|stuffIndex
op_add_assign
id|amountToRead
suffix:semicolon
)brace
singleline_comment|// Update stuff index
id|pCh-&gt;Ibuf_stuff
op_assign
id|stuffIndex
suffix:semicolon
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pCh-&gt;Ibuf_spinlock
comma
id|cflags
)paren
suffix:semicolon
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pB-&gt;read_fifo_spinlock
comma
id|bflags
)paren
suffix:semicolon
macro_line|#ifdef USE_IQ
id|queue_task
c_func
(paren
op_amp
id|pCh-&gt;tqueue_input
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
macro_line|#else
id|do_input
c_func
(paren
id|pCh
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// Note we do not need to maintain any flow-control credits at this
singleline_comment|// time:  if we were to increment .asof and decrement .room, there
singleline_comment|// would be no net effect. Instead, when we strip data, we will
singleline_comment|// increment .asof and leave .room unchanged.
r_break
suffix:semicolon
singleline_comment|// From switch: ready for next packet
r_case
id|PTYPE_STATUS
suffix:colon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|ITRC_NO_PORT
comma
id|ITRC_SFIFO
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|count
op_assign
id|CMD_COUNT_OF
c_func
(paren
id|pB-&gt;i2eLeadoffWord
)paren
suffix:semicolon
id|iiReadBuf
c_func
(paren
id|pB
comma
id|cmdBuffer
comma
id|count
)paren
suffix:semicolon
singleline_comment|// We can release early with buffer grab
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pB-&gt;read_fifo_spinlock
comma
id|bflags
)paren
suffix:semicolon
id|pc
op_assign
id|cmdBuffer
suffix:semicolon
id|pcLimit
op_assign
op_amp
(paren
id|cmdBuffer
(braket
id|count
)braket
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pc
OL
id|pcLimit
)paren
(brace
id|channel
op_assign
op_star
id|pc
op_increment
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|channel
comma
id|ITRC_SFIFO
comma
l_int|7
comma
l_int|2
comma
id|channel
comma
op_star
id|pc
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* check for valid channel */
r_if
c_cond
(paren
id|channel
OL
id|pB-&gt;i2eChannelCnt
op_logical_and
(paren
id|pCh
op_assign
(paren
(paren
(paren
id|i2ChanStrPtr
op_star
)paren
id|pB-&gt;i2eChannelPtr
)paren
(braket
id|channel
)braket
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|dss_change
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|uc
op_assign
op_star
id|pc
op_increment
)paren
(brace
multiline_comment|/* Breaks and modem signals are easy: just update status */
r_case
id|STAT_CTS_UP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pCh-&gt;dataSetIn
op_amp
id|I2_CTS
)paren
)paren
(brace
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_DCTS
suffix:semicolon
id|pCh-&gt;icount.cts
op_increment
suffix:semicolon
id|dss_change
op_assign
l_int|1
suffix:semicolon
)brace
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_CTS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STAT_CTS_DN
suffix:colon
r_if
c_cond
(paren
id|pCh-&gt;dataSetIn
op_amp
id|I2_CTS
)paren
(brace
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_DCTS
suffix:semicolon
id|pCh-&gt;icount.cts
op_increment
suffix:semicolon
id|dss_change
op_assign
l_int|1
suffix:semicolon
)brace
id|pCh-&gt;dataSetIn
op_and_assign
op_complement
id|I2_CTS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STAT_DCD_UP
suffix:colon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|channel
comma
id|ITRC_MODEM
comma
l_int|1
comma
l_int|1
comma
id|pCh-&gt;dataSetIn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|pCh-&gt;dataSetIn
op_amp
id|I2_DCD
)paren
)paren
(brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_MODEM
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_DDCD
suffix:semicolon
id|pCh-&gt;icount.dcd
op_increment
suffix:semicolon
id|dss_change
op_assign
l_int|1
suffix:semicolon
)brace
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_DCD
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|channel
comma
id|ITRC_MODEM
comma
l_int|3
comma
l_int|1
comma
id|pCh-&gt;dataSetIn
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|STAT_DCD_DN
suffix:colon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|channel
comma
id|ITRC_MODEM
comma
l_int|4
comma
l_int|1
comma
id|pCh-&gt;dataSetIn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pCh-&gt;dataSetIn
op_amp
id|I2_DCD
)paren
(brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|channel
comma
id|ITRC_MODEM
comma
l_int|5
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_DDCD
suffix:semicolon
id|pCh-&gt;icount.dcd
op_increment
suffix:semicolon
id|dss_change
op_assign
l_int|1
suffix:semicolon
)brace
id|pCh-&gt;dataSetIn
op_and_assign
op_complement
id|I2_DCD
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|channel
comma
id|ITRC_MODEM
comma
l_int|6
comma
l_int|1
comma
id|pCh-&gt;dataSetIn
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|STAT_DSR_UP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pCh-&gt;dataSetIn
op_amp
id|I2_DSR
)paren
)paren
(brace
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_DDSR
suffix:semicolon
id|pCh-&gt;icount.dsr
op_increment
suffix:semicolon
id|dss_change
op_assign
l_int|1
suffix:semicolon
)brace
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_DSR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STAT_DSR_DN
suffix:colon
r_if
c_cond
(paren
id|pCh-&gt;dataSetIn
op_amp
id|I2_DSR
)paren
(brace
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_DDSR
suffix:semicolon
id|pCh-&gt;icount.dsr
op_increment
suffix:semicolon
id|dss_change
op_assign
l_int|1
suffix:semicolon
)brace
id|pCh-&gt;dataSetIn
op_and_assign
op_complement
id|I2_DSR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STAT_RI_UP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pCh-&gt;dataSetIn
op_amp
id|I2_RI
)paren
)paren
(brace
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_DRI
suffix:semicolon
id|pCh-&gt;icount.rng
op_increment
suffix:semicolon
id|dss_change
op_assign
l_int|1
suffix:semicolon
)brace
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_RI
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STAT_RI_DN
suffix:colon
singleline_comment|// to be compat with serial.c
singleline_comment|//if ( pCh-&gt;dataSetIn &amp; I2_RI )
singleline_comment|//{
singleline_comment|//&t;pCh-&gt;dataSetIn |= I2_DRI;
singleline_comment|//&t;pCh-&gt;icount.rng++; 
singleline_comment|//&t;dss_change = 1;
singleline_comment|//}
id|pCh-&gt;dataSetIn
op_and_assign
op_complement
id|I2_RI
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STAT_BRK_DET
suffix:colon
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_BRK
suffix:semicolon
id|pCh-&gt;icount.brk
op_increment
suffix:semicolon
id|dss_change
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
singleline_comment|// Bookmarks? one less request we&squot;re waiting for
r_case
id|STAT_BMARK
suffix:colon
id|pCh-&gt;bookMarks
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|pCh-&gt;bookMarks
op_le
l_int|0
)paren
(brace
id|pCh-&gt;bookMarks
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|pCh-&gt;pBookmarkWait
)paren
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|channel
comma
id|ITRC_DRAIN
comma
l_int|20
comma
l_int|1
comma
id|pCh-&gt;BookmarkTimer.expires
)paren
suffix:semicolon
macro_line|#endif
)brace
r_break
suffix:semicolon
singleline_comment|// Flow control packets? Update the new credits, and if
singleline_comment|// someone was waiting for output, queue him up again.
r_case
id|STAT_FLOW
suffix:colon
id|pCh-&gt;outfl.room
op_assign
(paren
(paren
id|flowStatPtr
)paren
id|pc
)paren
op_member_access_from_pointer
id|room
op_minus
(paren
id|pCh-&gt;outfl.asof
op_minus
(paren
(paren
id|flowStatPtr
)paren
id|pc
)paren
op_member_access_from_pointer
id|asof
)paren
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|channel
comma
id|ITRC_STFLW
comma
l_int|1
comma
l_int|1
comma
id|pCh-&gt;outfl.room
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pCh-&gt;channelNeeds
op_amp
id|NEED_CREDIT
)paren
(brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|channel
comma
id|ITRC_STFLW
comma
l_int|2
comma
l_int|1
comma
id|pCh-&gt;channelNeeds
)paren
suffix:semicolon
macro_line|#endif
id|pCh-&gt;channelNeeds
op_and_assign
op_complement
id|NEED_CREDIT
suffix:semicolon
id|i2QueueNeeds
c_func
(paren
id|pB
comma
id|pCh
comma
id|NEED_INLINE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pCh-&gt;pTTY
)paren
id|ip2_owake
c_func
(paren
id|pCh-&gt;pTTY
)paren
suffix:semicolon
)brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|channel
comma
id|ITRC_STFLW
comma
l_int|3
comma
l_int|1
comma
id|pCh-&gt;channelNeeds
)paren
suffix:semicolon
macro_line|#endif
id|pc
op_add_assign
r_sizeof
(paren
id|flowStat
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Special packets: */
multiline_comment|/* Just copy the information into the channel structure */
r_case
id|STAT_STATUS
suffix:colon
id|pCh-&gt;channelStatus
op_assign
op_star
(paren
(paren
id|debugStatPtr
)paren
id|pc
)paren
suffix:semicolon
id|pc
op_add_assign
r_sizeof
(paren
id|debugStat
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STAT_TXCNT
suffix:colon
id|pCh-&gt;channelTcount
op_assign
op_star
(paren
(paren
id|cntStatPtr
)paren
id|pc
)paren
suffix:semicolon
id|pc
op_add_assign
r_sizeof
(paren
id|cntStat
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STAT_RXCNT
suffix:colon
id|pCh-&gt;channelRcount
op_assign
op_star
(paren
(paren
id|cntStatPtr
)paren
id|pc
)paren
suffix:semicolon
id|pc
op_add_assign
r_sizeof
(paren
id|cntStat
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STAT_BOXIDS
suffix:colon
id|pB-&gt;channelBtypes
op_assign
op_star
(paren
(paren
id|bidStatPtr
)paren
id|pc
)paren
suffix:semicolon
id|pc
op_add_assign
r_sizeof
(paren
id|bidStat
)paren
suffix:semicolon
id|set_baud_params
c_func
(paren
id|pB
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|STAT_HWFAIL
suffix:colon
id|i2QueueCommands
(paren
id|PTYPE_INLINE
comma
id|pCh
comma
l_int|0
comma
l_int|1
comma
id|CMD_HW_TEST
)paren
suffix:semicolon
id|pCh-&gt;channelFail
op_assign
op_star
(paren
(paren
id|failStatPtr
)paren
id|pc
)paren
suffix:semicolon
id|pc
op_add_assign
r_sizeof
(paren
id|failStat
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* No explicit match? then&n;&t;&t;&t;&t;&t; * Might be an error packet...&n;&t;&t;&t;&t;&t; */
r_default
suffix:colon
(brace
)brace
r_switch
c_cond
(paren
id|uc
op_amp
id|STAT_MOD_ERROR
)paren
(brace
r_case
id|STAT_ERROR
suffix:colon
r_if
c_cond
(paren
id|uc
op_amp
id|STAT_E_PARITY
)paren
(brace
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_PAR
suffix:semicolon
id|pCh-&gt;icount.parity
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uc
op_amp
id|STAT_E_FRAMING
)paren
(brace
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_FRA
suffix:semicolon
id|pCh-&gt;icount.frame
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uc
op_amp
id|STAT_E_OVERRUN
)paren
(brace
id|pCh-&gt;dataSetIn
op_or_assign
id|I2_OVR
suffix:semicolon
id|pCh-&gt;icount.overrun
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|STAT_MODEM
suffix:colon
singleline_comment|// the answer to DSS_NOW request (not change)
id|pCh-&gt;dataSetIn
op_assign
(paren
id|pCh-&gt;dataSetIn
op_amp
op_complement
(paren
id|I2_RI
op_or
id|I2_CTS
op_or
id|I2_DCD
op_or
id|I2_DSR
)paren
)paren
op_or
id|xlatDss
(braket
id|uc
op_amp
l_int|0xf
)braket
suffix:semicolon
id|wake_up_interruptible
(paren
op_amp
id|pCh-&gt;dss_now_wait
)paren
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* End of switch on status type */
r_if
c_cond
(paren
id|dss_change
)paren
(brace
macro_line|#ifdef USE_IQ
id|queue_task
c_func
(paren
op_amp
id|pCh-&gt;tqueue_status
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
macro_line|#else
id|do_status
c_func
(paren
id|pCh
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
multiline_comment|/* Or else, channel is invalid */
(brace
singleline_comment|// Even though the channel is invalid, we must test the
singleline_comment|// status to see how much additional data it has (to be
singleline_comment|// skipped)
r_switch
c_cond
(paren
op_star
id|pc
op_increment
)paren
(brace
r_case
id|STAT_FLOW
suffix:colon
id|pc
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* Skip the data */
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
)brace
singleline_comment|// End of while (there is still some status packet left)
r_break
suffix:semicolon
r_default
suffix:colon
singleline_comment|// Neither packet? should be impossible
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|ITRC_NO_PORT
comma
id|ITRC_SFIFO
comma
l_int|5
comma
l_int|1
comma
id|PTYPE_OF
c_func
(paren
id|pB-&gt;i2eLeadoffWord
)paren
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
singleline_comment|// End of switch on type of packets
)brace
singleline_comment|//while(board HAS_INPUT)
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|ITRC_NO_PORT
comma
id|ITRC_SFIFO
comma
id|ITRC_RETURN
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// Send acknowledgement to the board even if there was no data!
id|pB-&gt;i2eOutMailWaiting
op_or_assign
id|MB_IN_STRIPPED
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2Write2Fifo(pB,address,count)
singleline_comment|// Parameters: Pointer to a board structure, source address, byte count
singleline_comment|// Returns:    bytes written
singleline_comment|//
singleline_comment|// Description:
singleline_comment|//  Writes count bytes to board io address(implied) from source
singleline_comment|//  Adjusts count, leaves reserve for next time around bypass cmds
singleline_comment|//******************************************************************************
r_static
r_int
DECL|function|i2Write2Fifo
id|i2Write2Fifo
c_func
(paren
id|i2eBordStrPtr
id|pB
comma
r_int
r_char
op_star
id|source
comma
r_int
id|count
comma
r_int
id|reserve
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pB-&gt;write_fifo_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pB-&gt;i2eWaitingForEmptyFifo
)paren
(brace
r_if
c_cond
(paren
id|pB-&gt;i2eFifoRemains
OG
(paren
id|count
op_plus
id|reserve
)paren
)paren
(brace
id|pB-&gt;i2eFifoRemains
op_sub_assign
id|count
suffix:semicolon
id|iiWriteBuf
c_func
(paren
id|pB
comma
id|source
comma
id|count
)paren
suffix:semicolon
id|pB-&gt;i2eOutMailWaiting
op_or_assign
id|MB_OUT_STUFFED
suffix:semicolon
id|rc
op_assign
id|count
suffix:semicolon
)brace
)brace
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pB-&gt;write_fifo_spinlock
comma
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2StuffFifoBypass(pB)
singleline_comment|// Parameters: Pointer to a board structure
singleline_comment|// Returns:    Nothing
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// Stuffs as many bypass commands into the fifo as possible. This is simpler
singleline_comment|// than stuffing data or inline commands to fifo, since we do not have
singleline_comment|// flow-control to deal with.
singleline_comment|//******************************************************************************
r_static
r_inline
r_void
DECL|function|i2StuffFifoBypass
id|i2StuffFifoBypass
c_func
(paren
id|i2eBordStrPtr
id|pB
)paren
(brace
id|i2ChanStrPtr
id|pCh
suffix:semicolon
r_int
r_char
op_star
id|pRemove
suffix:semicolon
r_int
r_int
id|stripIndex
suffix:semicolon
r_int
r_int
id|packetSize
suffix:semicolon
r_int
r_int
id|paddedSize
suffix:semicolon
r_int
r_int
id|notClogged
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|bailout
op_assign
l_int|1000
suffix:semicolon
singleline_comment|// Continue processing so long as there are entries, or there is room in the
singleline_comment|// fifo. Each entry represents a channel with something to do.
r_while
c_loop
(paren
op_decrement
id|bailout
op_logical_and
id|notClogged
op_logical_and
(paren
l_int|NULL
op_ne
(paren
id|pCh
op_assign
id|i2DeQueueNeeds
c_func
(paren
id|pB
comma
id|NEED_BYPASS
)paren
)paren
)paren
)paren
(brace
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pCh-&gt;Cbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
id|stripIndex
op_assign
id|pCh-&gt;Cbuf_strip
suffix:semicolon
singleline_comment|// as long as there are packets for this channel...
r_while
c_loop
(paren
id|stripIndex
op_ne
id|pCh-&gt;Cbuf_stuff
)paren
(brace
id|pRemove
op_assign
op_amp
(paren
id|pCh-&gt;Cbuf
(braket
id|stripIndex
)braket
)paren
suffix:semicolon
id|packetSize
op_assign
id|CMD_COUNT_OF
c_func
(paren
id|pRemove
)paren
op_plus
r_sizeof
(paren
id|i2CmdHeader
)paren
suffix:semicolon
id|paddedSize
op_assign
id|ROUNDUP
c_func
(paren
id|packetSize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|paddedSize
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
l_int|0
op_eq
id|i2Write2Fifo
c_func
(paren
id|pB
comma
id|pRemove
comma
id|paddedSize
comma
l_int|0
)paren
)paren
(brace
id|notClogged
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* fifo full */
id|i2QueueNeeds
c_func
(paren
id|pB
comma
id|pCh
comma
id|NEED_BYPASS
)paren
suffix:semicolon
singleline_comment|// Put back on queue
r_break
suffix:semicolon
singleline_comment|// Break from the channel
)brace
)brace
macro_line|#ifdef DEBUG_FIFO
id|WriteDBGBuf
c_func
(paren
l_string|&quot;BYPS&quot;
comma
id|pRemove
comma
id|paddedSize
)paren
suffix:semicolon
macro_line|#endif&t;/* DEBUG_FIFO */
id|pB-&gt;debugBypassCount
op_increment
suffix:semicolon
id|pRemove
op_add_assign
id|packetSize
suffix:semicolon
id|stripIndex
op_add_assign
id|packetSize
suffix:semicolon
r_if
c_cond
(paren
id|stripIndex
op_ge
id|CBUF_SIZE
)paren
(brace
id|stripIndex
op_assign
l_int|0
suffix:semicolon
id|pRemove
op_assign
id|pCh-&gt;Cbuf
suffix:semicolon
)brace
)brace
singleline_comment|// Done with this channel. Move to next, removing this one from 
singleline_comment|// the queue of channels if we cleaned it out (i.e., didn&squot;t get clogged.
id|pCh-&gt;Cbuf_strip
op_assign
id|stripIndex
suffix:semicolon
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pCh-&gt;Cbuf_spinlock
comma
id|flags
)paren
suffix:semicolon
)brace
singleline_comment|// Either clogged or finished all the work
macro_line|#ifdef IP2DEBUG_TRACE
r_if
c_cond
(paren
op_logical_neg
id|bailout
)paren
(brace
id|ip2trace
(paren
id|ITRC_NO_PORT
comma
id|ITRC_ERROR
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2StuffFifoFlow(pB)
singleline_comment|// Parameters: Pointer to a board structure
singleline_comment|// Returns:    Nothing
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// Stuffs as many flow control packets into the fifo as possible. This is easier
singleline_comment|// even than doing normal bypass commands, because there is always at most one
singleline_comment|// packet, already assembled, for each channel.
singleline_comment|//******************************************************************************
r_static
r_inline
r_void
DECL|function|i2StuffFifoFlow
id|i2StuffFifoFlow
c_func
(paren
id|i2eBordStrPtr
id|pB
)paren
(brace
id|i2ChanStrPtr
id|pCh
suffix:semicolon
r_int
r_int
id|paddedSize
op_assign
id|ROUNDUP
c_func
(paren
r_sizeof
(paren
id|flowIn
)paren
)paren
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|ITRC_NO_PORT
comma
id|ITRC_SFLOW
comma
id|ITRC_ENTER
comma
l_int|2
comma
id|pB-&gt;i2eFifoRemains
comma
id|paddedSize
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// Continue processing so long as there are entries, or there is room in the
singleline_comment|// fifo. Each entry represents a channel with something to do.
r_while
c_loop
(paren
(paren
l_int|NULL
op_ne
(paren
id|pCh
op_assign
id|i2DeQueueNeeds
c_func
(paren
id|pB
comma
id|NEED_FLOW
)paren
)paren
)paren
)paren
(brace
id|pB-&gt;debugFlowCount
op_increment
suffix:semicolon
singleline_comment|// NO Chan LOCK needed ???
r_if
c_cond
(paren
l_int|0
op_eq
id|i2Write2Fifo
c_func
(paren
id|pB
comma
(paren
r_int
r_char
op_star
)paren
op_amp
(paren
id|pCh-&gt;infl
)paren
comma
id|paddedSize
comma
l_int|0
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
macro_line|#ifdef DEBUG_FIFO
id|WriteDBGBuf
c_func
(paren
l_string|&quot;FLOW&quot;
comma
(paren
r_int
r_char
op_star
)paren
op_amp
(paren
id|pCh-&gt;infl
)paren
comma
id|paddedSize
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_FIFO */
)brace
singleline_comment|// Either clogged or finished all the work
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|ITRC_NO_PORT
comma
id|ITRC_SFLOW
comma
id|ITRC_RETURN
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2StuffFifoInline(pB)
singleline_comment|// Parameters: Pointer to a board structure
singleline_comment|// Returns:    Nothing
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// Stuffs as much data and inline commands into the fifo as possible. This is
singleline_comment|// the most complex fifo-stuffing operation, since there if now the channel
singleline_comment|// flow-control issue to deal with.
singleline_comment|//******************************************************************************
r_static
r_inline
r_void
DECL|function|i2StuffFifoInline
id|i2StuffFifoInline
c_func
(paren
id|i2eBordStrPtr
id|pB
)paren
(brace
id|i2ChanStrPtr
id|pCh
suffix:semicolon
r_int
r_char
op_star
id|pRemove
suffix:semicolon
r_int
r_int
id|stripIndex
suffix:semicolon
r_int
r_int
id|packetSize
suffix:semicolon
r_int
r_int
id|paddedSize
suffix:semicolon
r_int
r_int
id|notClogged
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|flowsize
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|bailout
op_assign
l_int|1000
suffix:semicolon
r_int
id|bailout2
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|ITRC_NO_PORT
comma
id|ITRC_SICMD
comma
id|ITRC_ENTER
comma
l_int|3
comma
id|pB-&gt;i2eFifoRemains
comma
id|pB-&gt;i2Dbuf_strip
comma
id|pB-&gt;i2Dbuf_stuff
)paren
suffix:semicolon
macro_line|#endif
singleline_comment|// Continue processing so long as there are entries, or there is room in the
singleline_comment|// fifo. Each entry represents a channel with something to do.
r_while
c_loop
(paren
op_decrement
id|bailout
op_logical_and
id|notClogged
op_logical_and
(paren
l_int|NULL
op_ne
(paren
id|pCh
op_assign
id|i2DeQueueNeeds
c_func
(paren
id|pB
comma
id|NEED_INLINE
)paren
)paren
)paren
)paren
(brace
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pCh-&gt;Obuf_spinlock
comma
id|flags
)paren
suffix:semicolon
id|stripIndex
op_assign
id|pCh-&gt;Obuf_strip
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_SICMD
comma
l_int|3
comma
l_int|2
comma
id|stripIndex
comma
id|pCh-&gt;Obuf_stuff
)paren
suffix:semicolon
macro_line|#endif 
singleline_comment|// as long as there are packets for this channel...
id|bailout2
op_assign
l_int|1000
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|bailout2
op_logical_and
id|stripIndex
op_ne
id|pCh-&gt;Obuf_stuff
)paren
(brace
id|pRemove
op_assign
op_amp
(paren
id|pCh-&gt;Obuf
(braket
id|stripIndex
)braket
)paren
suffix:semicolon
singleline_comment|// Must determine whether this be a data or command packet to
singleline_comment|// calculate correctly the header size and the amount of
singleline_comment|// flow-control credit this type of packet will use.
r_if
c_cond
(paren
id|PTYPE_OF
c_func
(paren
id|pRemove
)paren
op_eq
id|PTYPE_DATA
)paren
(brace
id|flowsize
op_assign
id|DATA_COUNT_OF
c_func
(paren
id|pRemove
)paren
suffix:semicolon
id|packetSize
op_assign
id|flowsize
op_plus
r_sizeof
(paren
id|i2DataHeader
)paren
suffix:semicolon
)brace
r_else
(brace
id|flowsize
op_assign
id|CMD_COUNT_OF
c_func
(paren
id|pRemove
)paren
suffix:semicolon
id|packetSize
op_assign
id|flowsize
op_plus
r_sizeof
(paren
id|i2CmdHeader
)paren
suffix:semicolon
)brace
id|flowsize
op_assign
id|CREDIT_USAGE
c_func
(paren
id|flowsize
)paren
suffix:semicolon
id|paddedSize
op_assign
id|ROUNDUP
c_func
(paren
id|packetSize
)paren
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_SICMD
comma
l_int|4
comma
l_int|2
comma
id|pB-&gt;i2eFifoRemains
comma
id|paddedSize
)paren
suffix:semicolon
macro_line|#endif 
singleline_comment|// If we don&squot;t have enough credits from the board to send the data,
singleline_comment|// flag the channel that we are waiting for flow control credit, and
singleline_comment|// break out. This will clean up this channel and remove us from the
singleline_comment|// queue of hot things to do.
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_SICMD
comma
l_int|5
comma
l_int|2
comma
id|pCh-&gt;outfl.room
comma
id|flowsize
)paren
suffix:semicolon
macro_line|#endif 
r_if
c_cond
(paren
id|pCh-&gt;outfl.room
op_le
id|flowsize
)paren
(brace
singleline_comment|// Do Not have the credits to send this packet.
id|i2QueueNeeds
c_func
(paren
id|pB
comma
id|pCh
comma
id|NEED_CREDIT
)paren
suffix:semicolon
id|notClogged
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
singleline_comment|// So to do next channel
)brace
r_if
c_cond
(paren
(paren
id|paddedSize
OG
l_int|0
)paren
op_logical_and
(paren
l_int|0
op_eq
id|i2Write2Fifo
c_func
(paren
id|pB
comma
id|pRemove
comma
id|paddedSize
comma
l_int|128
)paren
)paren
)paren
(brace
singleline_comment|// Do Not have room in fifo to send this packet.
id|notClogged
op_assign
l_int|0
suffix:semicolon
id|i2QueueNeeds
c_func
(paren
id|pB
comma
id|pCh
comma
id|NEED_INLINE
)paren
suffix:semicolon
r_break
suffix:semicolon
singleline_comment|// Break from the channel
)brace
macro_line|#ifdef DEBUG_FIFO
id|WriteDBGBuf
c_func
(paren
l_string|&quot;DATA&quot;
comma
id|pRemove
comma
id|paddedSize
)paren
suffix:semicolon
macro_line|#endif /* DEBUG_FIFO */
id|pB-&gt;debugInlineCount
op_increment
suffix:semicolon
id|pCh-&gt;icount.tx
op_add_assign
id|flowsize
suffix:semicolon
singleline_comment|// Update current credits
id|pCh-&gt;outfl.room
op_sub_assign
id|flowsize
suffix:semicolon
id|pCh-&gt;outfl.asof
op_add_assign
id|flowsize
suffix:semicolon
r_if
c_cond
(paren
id|PTYPE_OF
c_func
(paren
id|pRemove
)paren
op_eq
id|PTYPE_DATA
)paren
(brace
id|pCh-&gt;Obuf_char_count
op_sub_assign
id|DATA_COUNT_OF
c_func
(paren
id|pRemove
)paren
suffix:semicolon
)brace
id|pRemove
op_add_assign
id|packetSize
suffix:semicolon
id|stripIndex
op_add_assign
id|packetSize
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_SICMD
comma
l_int|6
comma
l_int|2
comma
id|stripIndex
comma
id|pCh-&gt;Obuf_strip
)paren
suffix:semicolon
macro_line|#endif 
r_if
c_cond
(paren
id|stripIndex
op_ge
id|OBUF_SIZE
)paren
(brace
id|stripIndex
op_assign
l_int|0
suffix:semicolon
id|pRemove
op_assign
id|pCh-&gt;Obuf
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_SICMD
comma
l_int|7
comma
l_int|1
comma
id|stripIndex
)paren
suffix:semicolon
macro_line|#endif 
)brace
)brace
multiline_comment|/* while */
r_if
c_cond
(paren
op_logical_neg
id|bailout2
)paren
(brace
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_ERROR
comma
l_int|3
comma
l_int|0
)paren
suffix:semicolon
)brace
singleline_comment|// Done with this channel. Move to next, removing this one from the
singleline_comment|// queue of channels if we cleaned it out (i.e., didn&squot;t get clogged.
id|pCh-&gt;Obuf_strip
op_assign
id|stripIndex
suffix:semicolon
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pCh-&gt;Obuf_spinlock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|notClogged
)paren
(brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|CHANN
comma
id|ITRC_SICMD
comma
l_int|8
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|pCh-&gt;pTTY
)paren
(brace
id|ip2_owake
c_func
(paren
id|pCh-&gt;pTTY
)paren
suffix:semicolon
)brace
)brace
)brace
singleline_comment|// Either clogged or finished all the work
macro_line|#ifdef IP2DEBUG_TRACE
r_if
c_cond
(paren
op_logical_neg
id|bailout
)paren
(brace
id|ip2trace
(paren
id|ITRC_NO_PORT
comma
id|ITRC_ERROR
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|ITRC_NO_PORT
comma
id|ITRC_SICMD
comma
id|ITRC_RETURN
comma
l_int|1
comma
id|pB-&gt;i2Dbuf_strip
)paren
suffix:semicolon
macro_line|#endif
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   serviceOutgoingFifo(pB)
singleline_comment|// Parameters: Pointer to a board structure
singleline_comment|// Returns:    Nothing
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// Helper routine to put data in the outgoing fifo, if we aren&squot;t already waiting
singleline_comment|// for something to be there. If the fifo has only room for a very little data,
singleline_comment|// go head and hit the board with a mailbox hit immediately. Otherwise, it will
singleline_comment|// have to happen later in the interrupt processing. Since this routine may be
singleline_comment|// called both at interrupt and foreground time, we must turn off interrupts
singleline_comment|// during the entire process.
singleline_comment|//******************************************************************************
r_static
r_void
DECL|function|serviceOutgoingFifo
id|serviceOutgoingFifo
c_func
(paren
id|i2eBordStrPtr
id|pB
)paren
(brace
singleline_comment|// If we aren&squot;t currently waiting for the board to empty our fifo, service
singleline_comment|// everything that is pending, in priority order (especially, Bypass before
singleline_comment|// Inline).
r_if
c_cond
(paren
op_logical_neg
id|pB-&gt;i2eWaitingForEmptyFifo
)paren
(brace
id|i2StuffFifoFlow
c_func
(paren
id|pB
)paren
suffix:semicolon
id|i2StuffFifoBypass
c_func
(paren
id|pB
)paren
suffix:semicolon
id|i2StuffFifoInline
c_func
(paren
id|pB
)paren
suffix:semicolon
id|iiSendPendingMail
c_func
(paren
id|pB
)paren
suffix:semicolon
)brace
)brace
singleline_comment|//******************************************************************************
singleline_comment|// Function:   i2ServiceBoard(pB)
singleline_comment|// Parameters: Pointer to a board structure
singleline_comment|// Returns:    Nothing
singleline_comment|//
singleline_comment|// Description:
singleline_comment|// Normally this is called from interrupt level, but there is deliberately
singleline_comment|// nothing in here specific to being called from interrupt level. All the
singleline_comment|// hardware-specific, interrupt-specific things happen at the outer levels.
singleline_comment|//
singleline_comment|// For example, a timer interrupt could drive this routine for some sort of
singleline_comment|// polled operation. The only requirement is that the programmer deal with any
singleline_comment|// atomiticity/concurrency issues that result.
singleline_comment|//
singleline_comment|// This routine responds to the board&squot;s having sent mailbox information to the
singleline_comment|// host (which would normally cause an interrupt). This routine reads the
singleline_comment|// incoming mailbox. If there is no data in it, this board did not create the
singleline_comment|// interrupt and/or has nothing to be done to it. (Except, if we have been
singleline_comment|// waiting to write mailbox data to it, we may do so.
singleline_comment|//
singleline_comment|// Based on the value in the mailbox, we may take various actions.
singleline_comment|//
singleline_comment|// No checking here of pB validity: after all, it shouldn&squot;t have been called by
singleline_comment|// the handler unless pB were on the list.
singleline_comment|//******************************************************************************
r_static
r_inline
r_int
DECL|function|i2ServiceBoard
id|i2ServiceBoard
(paren
id|i2eBordStrPtr
id|pB
)paren
(brace
r_int
id|inmail
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|inmail
op_assign
id|iiGetMail
c_func
(paren
id|pB
)paren
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|ITRC_NO_PORT
comma
id|ITRC_INTR
comma
l_int|2
comma
l_int|1
comma
id|inmail
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|inmail
op_ne
id|NO_MAIL_HERE
)paren
(brace
singleline_comment|// If the board has gone fatal, nothing to do but hit a bit that will
singleline_comment|// alert foreground tasks to protest!
r_if
c_cond
(paren
id|inmail
op_amp
id|MB_FATAL_ERROR
)paren
(brace
id|pB-&gt;i2eFatal
op_assign
l_int|1
suffix:semicolon
r_goto
id|exit_i2ServiceBoard
suffix:semicolon
)brace
multiline_comment|/* Assuming no fatal condition, we proceed to do work */
r_if
c_cond
(paren
id|inmail
op_amp
id|MB_IN_STUFFED
)paren
(brace
id|pB-&gt;i2eFifoInInts
op_increment
suffix:semicolon
id|i2StripFifo
c_func
(paren
id|pB
)paren
suffix:semicolon
multiline_comment|/* There might be incoming packets */
)brace
r_if
c_cond
(paren
id|inmail
op_amp
id|MB_OUT_STRIPPED
)paren
(brace
id|pB-&gt;i2eFifoOutInts
op_increment
suffix:semicolon
id|WRITE_LOCK_IRQSAVE
c_func
(paren
op_amp
id|pB-&gt;write_fifo_spinlock
comma
id|flags
)paren
suffix:semicolon
id|pB-&gt;i2eFifoRemains
op_assign
id|pB-&gt;i2eFifoSize
suffix:semicolon
id|pB-&gt;i2eWaitingForEmptyFifo
op_assign
l_int|0
suffix:semicolon
id|WRITE_UNLOCK_IRQRESTORE
c_func
(paren
op_amp
id|pB-&gt;write_fifo_spinlock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|ITRC_NO_PORT
comma
id|ITRC_INTR
comma
l_int|30
comma
l_int|1
comma
id|pB-&gt;i2eFifoRemains
)paren
suffix:semicolon
macro_line|#endif
)brace
id|serviceOutgoingFifo
c_func
(paren
id|pB
)paren
suffix:semicolon
)brace
macro_line|#ifdef IP2DEBUG_TRACE
id|ip2trace
(paren
id|ITRC_NO_PORT
comma
id|ITRC_INTR
comma
l_int|8
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|exit_i2ServiceBoard
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
eof
