multiline_comment|/*****************************************************************************/
multiline_comment|/*&n; *&t;baycom.c  -- baycom ser12 and par96 radio modem driver.&n; *&n; *&t;Copyright (C) 1996  Thomas Sailer (sailer@ife.ee.ethz.ch)&n; *&n; *&t;This program is free software; you can redistribute it and/or modify&n; *&t;it under the terms of the GNU General Public License as published by&n; *&t;the Free Software Foundation; either version 2 of the License, or&n; *&t;(at your option) any later version.&n; *&n; *&t;This program is distributed in the hope that it will be useful,&n; *&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *&t;GNU General Public License for more details.&n; *&n; *&t;You should have received a copy of the GNU General Public License&n; *&t;along with this program; if not, write to the Free Software&n; *&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *  Please note that the GPL allows you to use the driver, NOT the radio.&n; *  In order to use the radio, you need a license from the communications&n; *  authority of your country.&n; *&n; *&n; *  Supported modems&n; *&n; *  ser12: This is a very simple 1200 baud AFSK modem. The modem consists only&n; *         of a modulator/demodulator chip, usually a TI TCM3105. The computer&n; *         is responsible for regenerating the receiver bit clock, as well as&n; *         for handling the HDLC protocol. The modem connects to a serial port,&n; *         hence the name. Since the serial port is not used as an async serial&n; *         port, the kernel driver for serial ports cannot be used, and this&n; *         driver only supports standard serial hardware (8250, 16450, 16550)&n; *  &n; *  par96: This is a modem for 9600 baud FSK compatible to the G3RUH standard.&n; *         The modem does all the filtering and regenerates the receiver clock.&n; *         Data is transferred from and to the PC via a shift register.&n; *         The shift register is filled with 16 bits and an interrupt is&n; *         signalled. The PC then empties the shift register in a burst. This&n; *         modem connects to the parallel port, hence the name. The modem&n; *         leaves the implementation of the HDLC protocol and the scrambler&n; *         polynomial to the PC.&n; *  &n; *  par97: This is a redesign of the par96 modem by Henning Rech, DF9IC. The&n; *         modem is protocol compatible to par96, but uses only three low&n; *         power ICs and can therefore be fed from the parallel port and&n; *         does not require an additional power supply.&n; *&n; *&n; *  Command line options (insmod command line)&n; * &n; *  major    major number the driver should use; default 60 &n; *  modem    modem type of the first channel (minor 0); 1=ser12,&n; *           2=par96/par97, any other value invalid&n; *  iobase   base address of the port; common values are for ser12 0x3f8,&n; *           0x2f8, 0x3e8, 0x2e8 and for par96/par97 0x378, 0x278, 0x3bc&n; *  irq      interrupt line of the port; common values are for ser12 3,4&n; *           and for par96/par97 7&n; *  options  0=use hardware DCD, 1=use software DCD&n; * &n; *&n; *  History:&n; *   0.1  03.05.96  Renamed from ser12 0.5 and added support for par96&n; *                  Various resource allocation cleanups&n; *   0.2  12.05.96  Changed major to allocated 51. Integrated into kernel&n; *                  source tree&n; *   0.3  04.06.96  Major bug fixed (forgot to wake up after write) which&n; *                  interestingly manifested only with kernel ax25&n; *                  (the slip line discipline)&n; *                  introduced bottom half and tq_baycom&n; *                  HDLC processing now done with interrupts on&n; */
multiline_comment|/*****************************************************************************/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/baycom.h&gt;
multiline_comment|/* --------------------------------------------------------------------- */
DECL|macro|BAYCOM_TYPE_NORMAL
mdefine_line|#define BAYCOM_TYPE_NORMAL 0&t;&t;/* not used */
DECL|macro|TTY_DRIVER_TYPE_BAYCOM
mdefine_line|#define TTY_DRIVER_TYPE_BAYCOM 6
multiline_comment|/*&n; * ser12 options:&n; * BAYCOM_OPTIONS_SOFTDCD: if undefined, you must use the transmitters&n; * hardware carrier detect circuitry, the driver will report DCD as soon as&n; * there are transitions on the input line. Advantage: lower interrupt load&n; * on the system. Disadvantage: slower, since hardware carrier detect&n; * circuitry is usually slow.&n; */
DECL|macro|BUFLEN_RX
mdefine_line|#define BUFLEN_RX 8192
DECL|macro|BUFLEN_TX
mdefine_line|#define BUFLEN_TX 8192
DECL|macro|NR_PORTS
mdefine_line|#define NR_PORTS 4
DECL|macro|KISS_VERBOSE
mdefine_line|#define KISS_VERBOSE
DECL|macro|BAYCOM_MAGIC
mdefine_line|#define BAYCOM_MAGIC 0x3105bac0
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * user settable parameters (from the command line)&n; */
macro_line|#ifndef MODULE
r_static
macro_line|#endif /* MODULE */
DECL|variable|major
r_int
id|major
op_assign
id|BAYCOM_MAJOR
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- */
DECL|variable|baycom_table
r_static
r_struct
id|tty_struct
op_star
id|baycom_table
(braket
id|NR_PORTS
)braket
suffix:semicolon
DECL|variable|baycom_termios
r_static
r_struct
id|termios
op_star
id|baycom_termios
(braket
id|NR_PORTS
)braket
suffix:semicolon
DECL|variable|baycom_termios_locked
r_static
r_struct
id|termios
op_star
id|baycom_termios_locked
(braket
id|NR_PORTS
)braket
suffix:semicolon
DECL|variable|baycom_refcount
r_static
r_int
id|baycom_refcount
suffix:semicolon
DECL|variable|baycom_driver
r_static
r_struct
id|tty_driver
id|baycom_driver
suffix:semicolon
r_static
r_struct
(brace
DECL|member|modem
DECL|member|iobase
DECL|member|irq
DECL|member|options
r_int
id|modem
comma
id|iobase
comma
id|irq
comma
id|options
suffix:semicolon
DECL|variable|baycom_ports
)brace
id|baycom_ports
(braket
id|NR_PORTS
)braket
op_assign
(brace
(brace
id|BAYCOM_MODEM_INVALID
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- */
DECL|macro|RBR
mdefine_line|#define RBR(iobase) (iobase+0)
DECL|macro|THR
mdefine_line|#define THR(iobase) (iobase+0)
DECL|macro|IER
mdefine_line|#define IER(iobase) (iobase+1)
DECL|macro|IIR
mdefine_line|#define IIR(iobase) (iobase+2)
DECL|macro|FCR
mdefine_line|#define FCR(iobase) (iobase+2)
DECL|macro|LCR
mdefine_line|#define LCR(iobase) (iobase+3)
DECL|macro|MCR
mdefine_line|#define MCR(iobase) (iobase+4)
DECL|macro|LSR
mdefine_line|#define LSR(iobase) (iobase+5)
DECL|macro|MSR
mdefine_line|#define MSR(iobase) (iobase+6)
DECL|macro|SCR
mdefine_line|#define SCR(iobase) (iobase+7)
DECL|macro|DLL
mdefine_line|#define DLL(iobase) (iobase+0)
DECL|macro|DLM
mdefine_line|#define DLM(iobase) (iobase+1)
DECL|macro|SER12_EXTENT
mdefine_line|#define SER12_EXTENT 8
DECL|macro|LPT_DATA
mdefine_line|#define LPT_DATA(iobase)    (iobase+0)
DECL|macro|LPT_STATUS
mdefine_line|#define LPT_STATUS(iobase)  (iobase+1)
DECL|macro|LPT_CONTROL
mdefine_line|#define LPT_CONTROL(iobase) (iobase+2)
DECL|macro|LPT_IRQ_ENABLE
mdefine_line|#define LPT_IRQ_ENABLE      0x10
DECL|macro|PAR96_BURSTBITS
mdefine_line|#define PAR96_BURSTBITS 16
DECL|macro|PAR96_BURST
mdefine_line|#define PAR96_BURST     4
DECL|macro|PAR96_PTT
mdefine_line|#define PAR96_PTT       2
DECL|macro|PAR96_TXBIT
mdefine_line|#define PAR96_TXBIT     1
DECL|macro|PAR96_ACK
mdefine_line|#define PAR96_ACK       0x40
DECL|macro|PAR96_RXBIT
mdefine_line|#define PAR96_RXBIT     0x20
DECL|macro|PAR96_DCD
mdefine_line|#define PAR96_DCD       0x10
DECL|macro|PAR97_POWER
mdefine_line|#define PAR97_POWER     0xf8
DECL|macro|PAR96_EXTENT
mdefine_line|#define PAR96_EXTENT 3
multiline_comment|/* ---------------------------------------------------------------------- */
DECL|struct|access_params
r_struct
id|access_params
(brace
DECL|member|tx_delay
r_int
id|tx_delay
suffix:semicolon
DECL|member|tx_tail
r_int
id|tx_tail
suffix:semicolon
DECL|member|slottime
r_int
id|slottime
suffix:semicolon
DECL|member|ppersist
r_int
id|ppersist
suffix:semicolon
DECL|member|fulldup
r_int
id|fulldup
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|hdlc_state_rx
r_struct
id|hdlc_state_rx
(brace
DECL|member|rx_state
r_int
id|rx_state
suffix:semicolon
multiline_comment|/* 0 = sync hunt, != 0 receiving */
DECL|member|bitstream
r_int
r_int
id|bitstream
suffix:semicolon
DECL|member|bitbuf
r_int
r_int
id|bitbuf
suffix:semicolon
DECL|member|numbits
r_int
id|numbits
suffix:semicolon
DECL|member|shreg1
DECL|member|shreg2
r_int
r_int
id|shreg1
comma
id|shreg2
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|bp
r_int
r_char
op_star
id|bp
suffix:semicolon
DECL|member|buffer
r_int
r_char
id|buffer
(braket
id|BAYCOM_MAXFLEN
op_plus
l_int|2
)braket
suffix:semicolon
multiline_comment|/* make room for CRC */
)brace
suffix:semicolon
DECL|struct|hdlc_state_tx
r_struct
id|hdlc_state_tx
(brace
multiline_comment|/*&n;&t; * 0 = send flags&n;&t; * 1 = send txtail (flags)&n;&t; * 2 = send packet&n;&t; */
DECL|member|tx_state
r_int
id|tx_state
suffix:semicolon
DECL|member|numflags
r_int
id|numflags
suffix:semicolon
DECL|member|bitstream
r_int
r_int
id|bitstream
suffix:semicolon
DECL|member|current_byte
r_int
r_int
id|current_byte
suffix:semicolon
DECL|member|ptt
r_int
r_char
id|ptt
suffix:semicolon
DECL|member|bitbuf
r_int
r_int
id|bitbuf
suffix:semicolon
DECL|member|numbits
r_int
id|numbits
suffix:semicolon
DECL|member|shreg1
DECL|member|shreg2
r_int
r_int
id|shreg1
comma
id|shreg2
suffix:semicolon
DECL|member|len
r_int
id|len
suffix:semicolon
DECL|member|bp
r_int
r_char
op_star
id|bp
suffix:semicolon
DECL|member|buffer
r_int
r_char
id|buffer
(braket
id|BAYCOM_MAXFLEN
op_plus
l_int|2
)braket
suffix:semicolon
multiline_comment|/* make room for CRC */
)brace
suffix:semicolon
DECL|struct|modem_state_ser12
r_struct
id|modem_state_ser12
(brace
DECL|member|last_sample
r_int
r_char
id|last_sample
suffix:semicolon
DECL|member|interm_sample
r_int
r_char
id|interm_sample
suffix:semicolon
DECL|member|bit_pll
r_int
r_int
id|bit_pll
suffix:semicolon
DECL|member|dcd_shreg
r_int
r_int
id|dcd_shreg
suffix:semicolon
DECL|member|dcd_sum0
DECL|member|dcd_sum1
DECL|member|dcd_sum2
r_int
id|dcd_sum0
comma
id|dcd_sum1
comma
id|dcd_sum2
suffix:semicolon
DECL|member|dcd_time
r_int
r_int
id|dcd_time
suffix:semicolon
DECL|member|last_rxbit
r_int
r_char
id|last_rxbit
suffix:semicolon
DECL|member|tx_bit
r_int
r_char
id|tx_bit
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|modem_state_par96
r_struct
id|modem_state_par96
(brace
DECL|member|dcd_count
r_int
id|dcd_count
suffix:semicolon
DECL|member|dcd_shreg
r_int
r_int
id|dcd_shreg
suffix:semicolon
DECL|member|descram
r_int
r_int
id|descram
suffix:semicolon
DECL|member|scram
r_int
r_int
id|scram
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|modem_state
r_struct
id|modem_state
(brace
DECL|member|dcd
r_int
r_char
id|dcd
suffix:semicolon
DECL|member|arb_divider
r_int
id|arb_divider
suffix:semicolon
DECL|member|flags
r_int
r_char
id|flags
suffix:semicolon
DECL|member|ser12
r_struct
id|modem_state_ser12
id|ser12
suffix:semicolon
DECL|member|par96
r_struct
id|modem_state_par96
id|par96
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|packet_buffer
r_struct
id|packet_buffer
(brace
DECL|member|rd
r_int
r_int
id|rd
suffix:semicolon
DECL|member|wr
r_int
r_int
id|wr
suffix:semicolon
DECL|member|buflen
r_int
r_int
id|buflen
suffix:semicolon
DECL|member|buffer
r_int
r_char
op_star
id|buffer
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|packet_hdr
r_struct
id|packet_hdr
(brace
DECL|member|next
r_int
r_int
id|next
suffix:semicolon
DECL|member|len
r_int
r_int
id|len
suffix:semicolon
multiline_comment|/* packet following */
)brace
suffix:semicolon
macro_line|#ifdef BAYCOM_DEBUG
DECL|struct|bit_buffer
r_struct
id|bit_buffer
(brace
DECL|member|rd
r_int
r_int
id|rd
suffix:semicolon
DECL|member|wr
r_int
r_int
id|wr
suffix:semicolon
DECL|member|shreg
r_int
r_int
id|shreg
suffix:semicolon
DECL|member|buffer
r_int
r_char
id|buffer
(braket
l_int|64
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|debug_vals
r_struct
id|debug_vals
(brace
DECL|member|last_jiffies
r_int
r_int
id|last_jiffies
suffix:semicolon
DECL|member|cur_intcnt
r_int
id|cur_intcnt
suffix:semicolon
DECL|member|last_intcnt
r_int
id|last_intcnt
suffix:semicolon
DECL|member|cur_pllcorr
r_int
id|cur_pllcorr
suffix:semicolon
DECL|member|last_pllcorr
r_int
id|last_pllcorr
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif /* BAYCOM_DEBUG */
DECL|struct|kiss_decode
r_struct
id|kiss_decode
(brace
DECL|member|dec_state
r_int
r_char
id|dec_state
suffix:semicolon
multiline_comment|/* 0 = hunt FEND */
DECL|member|escaped
r_int
r_char
id|escaped
suffix:semicolon
DECL|member|pkt_buf
r_int
r_char
id|pkt_buf
(braket
id|BAYCOM_MAXFLEN
op_plus
l_int|1
)braket
suffix:semicolon
DECL|member|wr
r_int
r_int
id|wr
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------------------- */
DECL|struct|baycom_state
r_struct
id|baycom_state
(brace
DECL|member|magic
r_int
id|magic
suffix:semicolon
DECL|member|modem_type
r_int
r_char
id|modem_type
suffix:semicolon
DECL|member|iobase
r_int
r_int
id|iobase
suffix:semicolon
DECL|member|irq
r_int
r_int
id|irq
suffix:semicolon
DECL|member|options
r_int
r_int
id|options
suffix:semicolon
DECL|member|opened
r_int
id|opened
suffix:semicolon
DECL|member|tty
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
macro_line|#ifdef BAYCOM_USE_BH
DECL|member|tq_receiver
DECL|member|tq_transmitter
DECL|member|tq_arbitrate
r_struct
id|tq_struct
id|tq_receiver
comma
id|tq_transmitter
comma
id|tq_arbitrate
suffix:semicolon
macro_line|#endif /* BAYCOM_USE_BH */
DECL|member|rx_buf
r_struct
id|packet_buffer
id|rx_buf
suffix:semicolon
DECL|member|tx_buf
r_struct
id|packet_buffer
id|tx_buf
suffix:semicolon
DECL|member|ch_params
r_struct
id|access_params
id|ch_params
suffix:semicolon
DECL|member|hdlc_rx
r_struct
id|hdlc_state_rx
id|hdlc_rx
suffix:semicolon
DECL|member|hdlc_tx
r_struct
id|hdlc_state_tx
id|hdlc_tx
suffix:semicolon
DECL|member|calibrate
r_int
id|calibrate
suffix:semicolon
DECL|member|modem
r_struct
id|modem_state
id|modem
suffix:semicolon
macro_line|#ifdef BAYCOM_DEBUG
DECL|member|bitbuf_channel
r_struct
id|bit_buffer
id|bitbuf_channel
suffix:semicolon
DECL|member|bitbuf_hdlc
r_struct
id|bit_buffer
id|bitbuf_hdlc
suffix:semicolon
DECL|member|debug_vals
r_struct
id|debug_vals
id|debug_vals
suffix:semicolon
macro_line|#endif /* BAYCOM_DEBUG */
DECL|member|kiss_decode
r_struct
id|kiss_decode
id|kiss_decode
suffix:semicolon
DECL|member|stat
r_struct
id|baycom_statistics
id|stat
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* --------------------------------------------------------------------- */
DECL|variable|baycom_state
r_struct
id|baycom_state
id|baycom_state
(braket
id|NR_PORTS
)braket
suffix:semicolon
macro_line|#ifdef BAYCOM_USE_BH
DECL|variable|tq_baycom
id|DECLARE_TASK_QUEUE
c_func
(paren
id|tq_baycom
)paren
suffix:semicolon
macro_line|#endif /* BAYCOM_USE_BH */
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * the CRC routines are stolen from WAMPES&n; * by Dieter Deyke&n; */
DECL|variable|crc_ccitt_table
r_static
r_const
r_int
r_int
id|crc_ccitt_table
(braket
)braket
op_assign
(brace
l_int|0x0000
comma
l_int|0x1189
comma
l_int|0x2312
comma
l_int|0x329b
comma
l_int|0x4624
comma
l_int|0x57ad
comma
l_int|0x6536
comma
l_int|0x74bf
comma
l_int|0x8c48
comma
l_int|0x9dc1
comma
l_int|0xaf5a
comma
l_int|0xbed3
comma
l_int|0xca6c
comma
l_int|0xdbe5
comma
l_int|0xe97e
comma
l_int|0xf8f7
comma
l_int|0x1081
comma
l_int|0x0108
comma
l_int|0x3393
comma
l_int|0x221a
comma
l_int|0x56a5
comma
l_int|0x472c
comma
l_int|0x75b7
comma
l_int|0x643e
comma
l_int|0x9cc9
comma
l_int|0x8d40
comma
l_int|0xbfdb
comma
l_int|0xae52
comma
l_int|0xdaed
comma
l_int|0xcb64
comma
l_int|0xf9ff
comma
l_int|0xe876
comma
l_int|0x2102
comma
l_int|0x308b
comma
l_int|0x0210
comma
l_int|0x1399
comma
l_int|0x6726
comma
l_int|0x76af
comma
l_int|0x4434
comma
l_int|0x55bd
comma
l_int|0xad4a
comma
l_int|0xbcc3
comma
l_int|0x8e58
comma
l_int|0x9fd1
comma
l_int|0xeb6e
comma
l_int|0xfae7
comma
l_int|0xc87c
comma
l_int|0xd9f5
comma
l_int|0x3183
comma
l_int|0x200a
comma
l_int|0x1291
comma
l_int|0x0318
comma
l_int|0x77a7
comma
l_int|0x662e
comma
l_int|0x54b5
comma
l_int|0x453c
comma
l_int|0xbdcb
comma
l_int|0xac42
comma
l_int|0x9ed9
comma
l_int|0x8f50
comma
l_int|0xfbef
comma
l_int|0xea66
comma
l_int|0xd8fd
comma
l_int|0xc974
comma
l_int|0x4204
comma
l_int|0x538d
comma
l_int|0x6116
comma
l_int|0x709f
comma
l_int|0x0420
comma
l_int|0x15a9
comma
l_int|0x2732
comma
l_int|0x36bb
comma
l_int|0xce4c
comma
l_int|0xdfc5
comma
l_int|0xed5e
comma
l_int|0xfcd7
comma
l_int|0x8868
comma
l_int|0x99e1
comma
l_int|0xab7a
comma
l_int|0xbaf3
comma
l_int|0x5285
comma
l_int|0x430c
comma
l_int|0x7197
comma
l_int|0x601e
comma
l_int|0x14a1
comma
l_int|0x0528
comma
l_int|0x37b3
comma
l_int|0x263a
comma
l_int|0xdecd
comma
l_int|0xcf44
comma
l_int|0xfddf
comma
l_int|0xec56
comma
l_int|0x98e9
comma
l_int|0x8960
comma
l_int|0xbbfb
comma
l_int|0xaa72
comma
l_int|0x6306
comma
l_int|0x728f
comma
l_int|0x4014
comma
l_int|0x519d
comma
l_int|0x2522
comma
l_int|0x34ab
comma
l_int|0x0630
comma
l_int|0x17b9
comma
l_int|0xef4e
comma
l_int|0xfec7
comma
l_int|0xcc5c
comma
l_int|0xddd5
comma
l_int|0xa96a
comma
l_int|0xb8e3
comma
l_int|0x8a78
comma
l_int|0x9bf1
comma
l_int|0x7387
comma
l_int|0x620e
comma
l_int|0x5095
comma
l_int|0x411c
comma
l_int|0x35a3
comma
l_int|0x242a
comma
l_int|0x16b1
comma
l_int|0x0738
comma
l_int|0xffcf
comma
l_int|0xee46
comma
l_int|0xdcdd
comma
l_int|0xcd54
comma
l_int|0xb9eb
comma
l_int|0xa862
comma
l_int|0x9af9
comma
l_int|0x8b70
comma
l_int|0x8408
comma
l_int|0x9581
comma
l_int|0xa71a
comma
l_int|0xb693
comma
l_int|0xc22c
comma
l_int|0xd3a5
comma
l_int|0xe13e
comma
l_int|0xf0b7
comma
l_int|0x0840
comma
l_int|0x19c9
comma
l_int|0x2b52
comma
l_int|0x3adb
comma
l_int|0x4e64
comma
l_int|0x5fed
comma
l_int|0x6d76
comma
l_int|0x7cff
comma
l_int|0x9489
comma
l_int|0x8500
comma
l_int|0xb79b
comma
l_int|0xa612
comma
l_int|0xd2ad
comma
l_int|0xc324
comma
l_int|0xf1bf
comma
l_int|0xe036
comma
l_int|0x18c1
comma
l_int|0x0948
comma
l_int|0x3bd3
comma
l_int|0x2a5a
comma
l_int|0x5ee5
comma
l_int|0x4f6c
comma
l_int|0x7df7
comma
l_int|0x6c7e
comma
l_int|0xa50a
comma
l_int|0xb483
comma
l_int|0x8618
comma
l_int|0x9791
comma
l_int|0xe32e
comma
l_int|0xf2a7
comma
l_int|0xc03c
comma
l_int|0xd1b5
comma
l_int|0x2942
comma
l_int|0x38cb
comma
l_int|0x0a50
comma
l_int|0x1bd9
comma
l_int|0x6f66
comma
l_int|0x7eef
comma
l_int|0x4c74
comma
l_int|0x5dfd
comma
l_int|0xb58b
comma
l_int|0xa402
comma
l_int|0x9699
comma
l_int|0x8710
comma
l_int|0xf3af
comma
l_int|0xe226
comma
l_int|0xd0bd
comma
l_int|0xc134
comma
l_int|0x39c3
comma
l_int|0x284a
comma
l_int|0x1ad1
comma
l_int|0x0b58
comma
l_int|0x7fe7
comma
l_int|0x6e6e
comma
l_int|0x5cf5
comma
l_int|0x4d7c
comma
l_int|0xc60c
comma
l_int|0xd785
comma
l_int|0xe51e
comma
l_int|0xf497
comma
l_int|0x8028
comma
l_int|0x91a1
comma
l_int|0xa33a
comma
l_int|0xb2b3
comma
l_int|0x4a44
comma
l_int|0x5bcd
comma
l_int|0x6956
comma
l_int|0x78df
comma
l_int|0x0c60
comma
l_int|0x1de9
comma
l_int|0x2f72
comma
l_int|0x3efb
comma
l_int|0xd68d
comma
l_int|0xc704
comma
l_int|0xf59f
comma
l_int|0xe416
comma
l_int|0x90a9
comma
l_int|0x8120
comma
l_int|0xb3bb
comma
l_int|0xa232
comma
l_int|0x5ac5
comma
l_int|0x4b4c
comma
l_int|0x79d7
comma
l_int|0x685e
comma
l_int|0x1ce1
comma
l_int|0x0d68
comma
l_int|0x3ff3
comma
l_int|0x2e7a
comma
l_int|0xe70e
comma
l_int|0xf687
comma
l_int|0xc41c
comma
l_int|0xd595
comma
l_int|0xa12a
comma
l_int|0xb0a3
comma
l_int|0x8238
comma
l_int|0x93b1
comma
l_int|0x6b46
comma
l_int|0x7acf
comma
l_int|0x4854
comma
l_int|0x59dd
comma
l_int|0x2d62
comma
l_int|0x3ceb
comma
l_int|0x0e70
comma
l_int|0x1ff9
comma
l_int|0xf78f
comma
l_int|0xe606
comma
l_int|0xd49d
comma
l_int|0xc514
comma
l_int|0xb1ab
comma
l_int|0xa022
comma
l_int|0x92b9
comma
l_int|0x8330
comma
l_int|0x7bc7
comma
l_int|0x6a4e
comma
l_int|0x58d5
comma
l_int|0x495c
comma
l_int|0x3de3
comma
l_int|0x2c6a
comma
l_int|0x1ef1
comma
l_int|0x0f78
)brace
suffix:semicolon
multiline_comment|/*---------------------------------------------------------------------------*/
DECL|function|append_crc_ccitt
r_static
r_inline
r_void
id|append_crc_ccitt
c_func
(paren
r_int
r_char
op_star
id|buffer
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|crc
op_assign
l_int|0xffff
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|len
OG
l_int|0
suffix:semicolon
id|len
op_decrement
)paren
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|8
)paren
op_xor
id|crc_ccitt_table
(braket
(paren
id|crc
op_xor
op_star
id|buffer
op_increment
)paren
op_amp
l_int|0xff
)braket
suffix:semicolon
id|crc
op_xor_assign
l_int|0xffff
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
id|crc
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
id|crc
op_rshift
l_int|8
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------------------------------*/
DECL|function|check_crc_ccitt
r_static
r_inline
r_int
id|check_crc_ccitt
c_func
(paren
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|cnt
)paren
(brace
r_int
r_int
id|crc
op_assign
l_int|0xffff
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|cnt
OG
l_int|0
suffix:semicolon
id|cnt
op_decrement
)paren
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|8
)paren
op_xor
id|crc_ccitt_table
(braket
(paren
id|crc
op_xor
op_star
id|buf
op_increment
)paren
op_amp
l_int|0xff
)braket
suffix:semicolon
r_return
(paren
id|crc
op_amp
l_int|0xffff
)paren
op_eq
l_int|0xf0b8
suffix:semicolon
)brace
multiline_comment|/*---------------------------------------------------------------------------*/
macro_line|#if 0
r_static
r_int
id|calc_crc_ccitt
c_func
(paren
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|cnt
)paren
(brace
r_int
r_int
id|crc
op_assign
l_int|0xffff
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|cnt
OG
l_int|0
suffix:semicolon
id|cnt
op_decrement
)paren
id|crc
op_assign
(paren
id|crc
op_rshift
l_int|8
)paren
op_xor
id|crc_ccitt_table
(braket
(paren
id|crc
op_xor
op_star
id|buf
op_increment
)paren
op_amp
l_int|0xff
)braket
suffix:semicolon
id|crc
op_xor_assign
l_int|0xffff
suffix:semicolon
r_return
(paren
id|crc
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* ---------------------------------------------------------------------- */
DECL|function|store_packet
r_static
r_int
id|store_packet
c_func
(paren
r_struct
id|packet_buffer
op_star
id|buf
comma
r_int
r_char
op_star
id|data
comma
r_char
id|from_user
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|free
suffix:semicolon
r_struct
id|packet_hdr
op_star
id|hdr
suffix:semicolon
r_int
r_int
id|needed
op_assign
r_sizeof
(paren
r_struct
id|packet_hdr
)paren
op_plus
id|len
suffix:semicolon
id|free
op_assign
id|buf-&gt;rd
op_minus
id|buf-&gt;wr
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;rd
op_le
id|buf-&gt;wr
)paren
(brace
id|free
op_assign
id|buf-&gt;buflen
op_minus
id|buf-&gt;wr
suffix:semicolon
r_if
c_cond
(paren
(paren
id|free
OL
id|needed
)paren
op_logical_and
(paren
id|buf-&gt;rd
op_ge
id|needed
)paren
)paren
(brace
id|hdr
op_assign
(paren
r_struct
id|packet_hdr
op_star
)paren
(paren
id|buf-&gt;buffer
op_plus
id|buf-&gt;wr
)paren
suffix:semicolon
id|hdr-&gt;next
op_assign
l_int|0
suffix:semicolon
id|hdr-&gt;len
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;wr
op_assign
l_int|0
suffix:semicolon
id|free
op_assign
id|buf-&gt;rd
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|free
OL
id|needed
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* buffer overrun */
id|hdr
op_assign
(paren
r_struct
id|packet_hdr
op_star
)paren
(paren
id|buf-&gt;buffer
op_plus
id|buf-&gt;wr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
id|copy_from_user
c_func
(paren
id|hdr
op_plus
l_int|1
comma
id|data
comma
id|len
)paren
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|hdr
op_plus
l_int|1
comma
id|data
comma
id|len
)paren
suffix:semicolon
id|hdr-&gt;len
op_assign
id|len
suffix:semicolon
id|hdr-&gt;next
op_assign
id|buf-&gt;wr
op_plus
id|needed
suffix:semicolon
r_if
c_cond
(paren
id|hdr-&gt;next
op_plus
r_sizeof
(paren
r_struct
id|packet_hdr
)paren
op_ge
id|buf-&gt;buflen
)paren
id|hdr-&gt;next
op_assign
l_int|0
suffix:semicolon
id|buf-&gt;wr
op_assign
id|hdr-&gt;next
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------------------- */
DECL|function|get_packet
r_static
r_void
id|get_packet
c_func
(paren
r_struct
id|packet_buffer
op_star
id|buf
comma
r_int
r_char
op_star
op_star
id|data
comma
r_int
r_int
op_star
id|len
)paren
(brace
r_struct
id|packet_hdr
op_star
id|hdr
suffix:semicolon
op_star
id|data
op_assign
l_int|NULL
suffix:semicolon
op_star
id|len
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;rd
op_eq
id|buf-&gt;wr
)paren
r_return
suffix:semicolon
id|hdr
op_assign
(paren
r_struct
id|packet_hdr
op_star
)paren
(paren
id|buf-&gt;buffer
op_plus
id|buf-&gt;rd
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|hdr-&gt;len
)paren
)paren
(brace
id|buf-&gt;rd
op_assign
id|hdr-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;rd
op_eq
id|buf-&gt;wr
)paren
r_return
suffix:semicolon
id|hdr
op_assign
(paren
r_struct
id|packet_hdr
op_star
)paren
(paren
id|buf-&gt;buffer
op_plus
id|buf-&gt;rd
)paren
suffix:semicolon
)brace
op_star
id|data
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|hdr
op_plus
l_int|1
)paren
suffix:semicolon
op_star
id|len
op_assign
id|hdr-&gt;len
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------------------- */
DECL|function|ack_packet
r_static
r_void
id|ack_packet
c_func
(paren
r_struct
id|packet_buffer
op_star
id|buf
)paren
(brace
r_struct
id|packet_hdr
op_star
id|hdr
suffix:semicolon
r_if
c_cond
(paren
id|buf-&gt;rd
op_eq
id|buf-&gt;wr
)paren
r_return
suffix:semicolon
id|hdr
op_assign
(paren
r_struct
id|packet_hdr
op_star
)paren
(paren
id|buf-&gt;buffer
op_plus
id|buf-&gt;rd
)paren
suffix:semicolon
id|buf-&gt;rd
op_assign
id|hdr-&gt;next
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------------------- */
DECL|function|store_kiss_packet
r_static
r_int
id|store_kiss_packet
c_func
(paren
r_struct
id|packet_buffer
op_star
id|buf
comma
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_char
op_star
id|bp
op_assign
id|data
suffix:semicolon
r_int
id|ln
op_assign
id|len
suffix:semicolon
multiline_comment|/*&n;&t; * variables of buf&n;&t; */
r_int
r_int
id|rd
suffix:semicolon
r_int
r_int
id|wr
suffix:semicolon
r_int
r_int
id|buflen
suffix:semicolon
r_int
r_char
op_star
id|buffer
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|len
op_logical_or
op_logical_neg
id|data
op_logical_or
op_logical_neg
id|buf
)paren
r_return
l_int|0
suffix:semicolon
id|buflen
op_assign
id|buf-&gt;buflen
suffix:semicolon
id|rd
op_assign
id|buf-&gt;rd
suffix:semicolon
id|wr
op_assign
id|buf-&gt;wr
suffix:semicolon
id|buffer
op_assign
id|buf-&gt;buffer
suffix:semicolon
DECL|macro|ADD_CHAR
mdefine_line|#define ADD_CHAR(c) {&bslash;&n;&t;&t;buffer[wr++] = c;&bslash;&n;&t;&t;if (wr &gt;= buflen) wr = 0;&bslash;&n;&t;&t;if (wr == rd) return 0;&bslash;&n;&t;}
DECL|macro|ADD_KISSCHAR
mdefine_line|#define ADD_KISSCHAR(c) {&bslash;&n;&t;&t;if (((c) &amp; 0xff) == KISS_FEND) {&bslash;&n;&t;&t;&t;ADD_CHAR(KISS_FESC);&bslash;&n;&t;&t;&t;ADD_CHAR(KISS_TFEND);&bslash;&n;&t;&t;} else if (((c) &amp; 0xff) == KISS_FESC) {&bslash;&n;&t;&t;&t;ADD_CHAR(KISS_FESC);&bslash;&n;&t;&t;&t;ADD_CHAR(KISS_TFESC);&bslash;&n;&t;&t;} else {&bslash;&n;&t;&t;&t;ADD_CHAR(c);&bslash;&n;&t;&t;}&bslash;&n;&t;}
id|ADD_CHAR
c_func
(paren
id|KISS_FEND
)paren
suffix:semicolon
id|ADD_KISSCHAR
c_func
(paren
id|KISS_CMD_DATA
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|ln
OG
l_int|0
suffix:semicolon
id|ln
op_decrement
comma
id|bp
op_increment
)paren
(brace
id|ADD_KISSCHAR
c_func
(paren
op_star
id|bp
)paren
suffix:semicolon
)brace
id|ADD_CHAR
c_func
(paren
id|KISS_FEND
)paren
suffix:semicolon
id|buf-&gt;wr
op_assign
id|wr
suffix:semicolon
DECL|macro|ADD_CHAR
macro_line|#undef ADD_CHAR
DECL|macro|ADD_KISSCHAR
macro_line|#undef ADD_KISSCHAR
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------------------- */
macro_line|#ifdef BAYCOM_DEBUG
DECL|function|add_bitbuffer
r_static
r_inline
r_void
id|add_bitbuffer
c_func
(paren
r_struct
id|bit_buffer
op_star
id|buf
comma
r_int
r_int
id|bit
)paren
(brace
r_int
r_char
r_new
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
r_return
suffix:semicolon
r_new
op_assign
id|buf-&gt;shreg
op_amp
l_int|1
suffix:semicolon
id|buf-&gt;shreg
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bit
)paren
id|buf-&gt;shreg
op_or_assign
l_int|0x80
suffix:semicolon
r_if
c_cond
(paren
r_new
)paren
(brace
id|buf-&gt;buffer
(braket
id|buf-&gt;wr
)braket
op_assign
id|buf-&gt;shreg
suffix:semicolon
id|buf-&gt;wr
op_assign
(paren
id|buf-&gt;wr
op_plus
l_int|1
)paren
op_mod
r_sizeof
(paren
id|buf-&gt;buffer
)paren
suffix:semicolon
id|buf-&gt;shreg
op_assign
l_int|0x80
suffix:semicolon
)brace
)brace
DECL|function|add_bitbuffer_word
r_static
r_inline
r_void
id|add_bitbuffer_word
c_func
(paren
r_struct
id|bit_buffer
op_star
id|buf
comma
r_int
r_int
id|bits
)paren
(brace
id|buf-&gt;buffer
(braket
id|buf-&gt;wr
)braket
op_assign
id|bits
op_amp
l_int|0xff
suffix:semicolon
id|buf-&gt;wr
op_assign
(paren
id|buf-&gt;wr
op_plus
l_int|1
)paren
op_mod
r_sizeof
(paren
id|buf-&gt;buffer
)paren
suffix:semicolon
id|buf-&gt;buffer
(braket
id|buf-&gt;wr
)braket
op_assign
(paren
id|bits
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|buf-&gt;wr
op_assign
(paren
id|buf-&gt;wr
op_plus
l_int|1
)paren
op_mod
r_sizeof
(paren
id|buf-&gt;buffer
)paren
suffix:semicolon
)brace
macro_line|#endif /* BAYCOM_DEBUG */
multiline_comment|/* ---------------------------------------------------------------------- */
DECL|function|tenms_to_2flags
r_static
r_inline
r_int
r_int
id|tenms_to_2flags
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
comma
r_int
r_int
id|tenms
)paren
(brace
r_switch
c_cond
(paren
id|bc-&gt;modem_type
)paren
(brace
r_case
id|BAYCOM_MODEM_SER12
suffix:colon
r_return
id|tenms
op_star
l_int|3
op_div
l_int|4
suffix:semicolon
r_case
id|BAYCOM_MODEM_PAR96
suffix:colon
r_return
id|tenms
op_star
l_int|6
suffix:semicolon
r_default
suffix:colon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* ---------------------------------------------------------------------- */
multiline_comment|/*&n; * The HDLC routines&n; */
DECL|function|hdlc_rx_add_bytes
r_static
r_inline
r_int
id|hdlc_rx_add_bytes
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
comma
r_int
r_int
id|bits
comma
r_int
id|num
)paren
(brace
r_int
id|added
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|bc-&gt;hdlc_rx.rx_state
op_logical_and
id|num
op_ge
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|bc-&gt;hdlc_rx.len
op_ge
r_sizeof
(paren
id|bc-&gt;hdlc_rx.buffer
)paren
)paren
(brace
id|bc-&gt;hdlc_rx.rx_state
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
op_star
id|bc-&gt;hdlc_rx.bp
op_increment
op_assign
id|bits
op_rshift
(paren
l_int|32
op_minus
id|num
)paren
suffix:semicolon
id|bc-&gt;hdlc_rx.len
op_increment
suffix:semicolon
id|num
op_sub_assign
l_int|8
suffix:semicolon
id|added
op_add_assign
l_int|8
suffix:semicolon
)brace
r_return
id|added
suffix:semicolon
)brace
DECL|function|hdlc_rx_flag
r_static
r_inline
r_void
id|hdlc_rx_flag
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
)paren
(brace
r_if
c_cond
(paren
id|bc-&gt;hdlc_rx.len
OL
l_int|4
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|check_crc_ccitt
c_func
(paren
id|bc-&gt;hdlc_rx.buffer
comma
id|bc-&gt;hdlc_rx.len
)paren
)paren
r_return
suffix:semicolon
id|bc-&gt;stat.rx_packets
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|store_kiss_packet
c_func
(paren
op_amp
id|bc-&gt;rx_buf
comma
id|bc-&gt;hdlc_rx.buffer
comma
id|bc-&gt;hdlc_rx.len
op_minus
l_int|2
)paren
)paren
id|bc-&gt;stat.rx_bufferoverrun
op_increment
suffix:semicolon
)brace
DECL|function|hdlc_rx_word
r_static
r_void
id|hdlc_rx_word
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
comma
r_int
r_int
id|word
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|mask1
comma
id|mask2
comma
id|mask3
comma
id|mask4
comma
id|mask5
comma
id|mask6
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
)paren
r_return
suffix:semicolon
id|word
op_and_assign
l_int|0xffff
suffix:semicolon
macro_line|#ifdef BAYCOM_DEBUG
id|add_bitbuffer_word
c_func
(paren
op_amp
id|bc-&gt;bitbuf_hdlc
comma
id|word
)paren
suffix:semicolon
macro_line|#endif /* BAYCOM_DEBUG */
id|bc-&gt;hdlc_rx.bitstream
op_rshift_assign
l_int|16
suffix:semicolon
id|bc-&gt;hdlc_rx.bitstream
op_or_assign
id|word
op_lshift
l_int|16
suffix:semicolon
id|bc-&gt;hdlc_rx.bitbuf
op_rshift_assign
l_int|16
suffix:semicolon
id|bc-&gt;hdlc_rx.bitbuf
op_or_assign
id|word
op_lshift
l_int|16
suffix:semicolon
id|bc-&gt;hdlc_rx.numbits
op_add_assign
l_int|16
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|15
comma
id|mask1
op_assign
l_int|0x1fc00
comma
id|mask2
op_assign
l_int|0x1fe00
comma
id|mask3
op_assign
l_int|0x0fc00
comma
id|mask4
op_assign
l_int|0x1f800
comma
id|mask5
op_assign
l_int|0xf800
comma
id|mask6
op_assign
l_int|0xffff
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
comma
id|mask1
op_lshift_assign
l_int|1
comma
id|mask2
op_lshift_assign
l_int|1
comma
id|mask3
op_lshift_assign
l_int|1
comma
id|mask4
op_lshift_assign
l_int|1
comma
id|mask5
op_lshift_assign
l_int|1
comma
id|mask6
op_assign
(paren
id|mask6
op_lshift
l_int|1
)paren
op_or
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|bc-&gt;hdlc_rx.bitstream
op_amp
id|mask1
)paren
op_eq
id|mask1
)paren
id|bc-&gt;hdlc_rx.rx_state
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* abort received */
r_else
r_if
c_cond
(paren
(paren
id|bc-&gt;hdlc_rx.bitstream
op_amp
id|mask2
)paren
op_eq
id|mask3
)paren
(brace
multiline_comment|/* flag received */
r_if
c_cond
(paren
id|bc-&gt;hdlc_rx.rx_state
)paren
(brace
id|hdlc_rx_add_bytes
c_func
(paren
id|bc
comma
id|bc-&gt;hdlc_rx.bitbuf
op_lshift
(paren
l_int|8
op_plus
id|i
)paren
comma
id|bc-&gt;hdlc_rx.numbits
op_minus
l_int|8
op_minus
id|i
)paren
suffix:semicolon
id|hdlc_rx_flag
c_func
(paren
id|bc
)paren
suffix:semicolon
)brace
id|bc-&gt;hdlc_rx.len
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;hdlc_rx.bp
op_assign
id|bc-&gt;hdlc_rx.buffer
suffix:semicolon
id|bc-&gt;hdlc_rx.rx_state
op_assign
l_int|1
suffix:semicolon
id|bc-&gt;hdlc_rx.numbits
op_assign
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|bc-&gt;hdlc_rx.bitstream
op_amp
id|mask4
)paren
op_eq
id|mask5
)paren
(brace
multiline_comment|/* stuffed bit */
id|bc-&gt;hdlc_rx.numbits
op_decrement
suffix:semicolon
id|bc-&gt;hdlc_rx.bitbuf
op_assign
(paren
id|bc-&gt;hdlc_rx.bitbuf
op_amp
(paren
op_complement
id|mask6
)paren
)paren
op_or
(paren
(paren
id|bc-&gt;hdlc_rx.bitbuf
op_amp
id|mask6
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
)brace
id|bc-&gt;hdlc_rx.numbits
op_sub_assign
id|hdlc_rx_add_bytes
c_func
(paren
id|bc
comma
id|bc-&gt;hdlc_rx.bitbuf
comma
id|bc-&gt;hdlc_rx.numbits
)paren
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------------------- */
DECL|function|hdlc_tx_word
r_static
r_int
r_int
id|hdlc_tx_word
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
)paren
(brace
r_int
r_int
id|mask1
comma
id|mask2
comma
id|mask3
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
op_logical_neg
id|bc-&gt;hdlc_tx.ptt
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|bc-&gt;hdlc_tx.numbits
op_ge
l_int|16
)paren
(brace
r_int
r_int
id|ret
op_assign
id|bc-&gt;hdlc_tx.bitbuf
op_amp
l_int|0xffff
suffix:semicolon
id|bc-&gt;hdlc_tx.bitbuf
op_rshift_assign
l_int|16
suffix:semicolon
id|bc-&gt;hdlc_tx.numbits
op_sub_assign
l_int|16
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|bc-&gt;hdlc_tx.tx_state
)paren
(brace
r_default
suffix:colon
id|bc-&gt;hdlc_tx.ptt
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;hdlc_tx.tx_state
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
l_int|0
suffix:colon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|bc-&gt;hdlc_tx.numflags
)paren
(brace
id|bc-&gt;hdlc_tx.numflags
op_decrement
suffix:semicolon
id|bc-&gt;hdlc_tx.bitbuf
op_or_assign
l_int|0x7e7e
op_lshift
id|bc-&gt;hdlc_tx.numbits
suffix:semicolon
id|bc-&gt;hdlc_tx.numbits
op_add_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bc-&gt;hdlc_tx.tx_state
op_eq
l_int|1
)paren
(brace
id|bc-&gt;hdlc_tx.ptt
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|get_packet
c_func
(paren
op_amp
id|bc-&gt;tx_buf
comma
op_amp
id|bc-&gt;hdlc_tx.bp
comma
op_amp
id|bc-&gt;hdlc_tx.len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc-&gt;hdlc_tx.bp
op_logical_or
op_logical_neg
id|bc-&gt;hdlc_tx.len
)paren
(brace
id|bc-&gt;hdlc_tx.tx_state
op_assign
l_int|1
suffix:semicolon
id|bc-&gt;hdlc_tx.numflags
op_assign
id|tenms_to_2flags
(paren
id|bc
comma
id|bc-&gt;ch_params.tx_tail
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bc-&gt;hdlc_tx.len
op_ge
id|BAYCOM_MAXFLEN
)paren
(brace
id|bc-&gt;hdlc_tx.tx_state
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;hdlc_tx.numflags
op_assign
l_int|1
suffix:semicolon
id|ack_packet
c_func
(paren
op_amp
id|bc-&gt;tx_buf
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memcpy
c_func
(paren
id|bc-&gt;hdlc_tx.buffer
comma
id|bc-&gt;hdlc_tx.bp
comma
id|bc-&gt;hdlc_tx.len
)paren
suffix:semicolon
id|ack_packet
c_func
(paren
op_amp
id|bc-&gt;tx_buf
)paren
suffix:semicolon
id|bc-&gt;hdlc_tx.bp
op_assign
id|bc-&gt;hdlc_tx.buffer
suffix:semicolon
id|append_crc_ccitt
c_func
(paren
id|bc-&gt;hdlc_tx.buffer
comma
id|bc-&gt;hdlc_tx.len
)paren
suffix:semicolon
multiline_comment|/* the appended CRC */
id|bc-&gt;hdlc_tx.len
op_add_assign
l_int|2
suffix:semicolon
id|bc-&gt;hdlc_tx.tx_state
op_assign
l_int|2
suffix:semicolon
id|bc-&gt;hdlc_tx.bitstream
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;stat.tx_packets
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|bc-&gt;hdlc_tx.len
)paren
(brace
id|bc-&gt;hdlc_tx.tx_state
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;hdlc_tx.numflags
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bc-&gt;hdlc_tx.len
op_decrement
suffix:semicolon
id|bc-&gt;hdlc_tx.bitbuf
op_or_assign
op_star
id|bc-&gt;hdlc_tx.bp
op_lshift
id|bc-&gt;hdlc_tx.numbits
suffix:semicolon
id|bc-&gt;hdlc_tx.bitstream
op_rshift_assign
l_int|8
suffix:semicolon
id|bc-&gt;hdlc_tx.bitstream
op_or_assign
(paren
op_star
id|bc-&gt;hdlc_tx.bp
op_increment
)paren
op_lshift
l_int|16
suffix:semicolon
id|mask1
op_assign
l_int|0x1f000
suffix:semicolon
id|mask2
op_assign
l_int|0x10000
suffix:semicolon
id|mask3
op_assign
l_int|0xffffffff
op_rshift
(paren
l_int|31
op_minus
id|bc-&gt;hdlc_tx.numbits
)paren
suffix:semicolon
id|bc-&gt;hdlc_tx.numbits
op_add_assign
l_int|8
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
comma
id|mask1
op_lshift_assign
l_int|1
comma
id|mask2
op_lshift_assign
l_int|1
comma
id|mask3
op_assign
(paren
id|mask3
op_lshift
l_int|1
)paren
op_or
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|bc-&gt;hdlc_tx.bitstream
op_amp
id|mask1
)paren
op_ne
id|mask1
)paren
r_continue
suffix:semicolon
id|bc-&gt;hdlc_tx.bitstream
op_and_assign
op_complement
id|mask2
suffix:semicolon
id|bc-&gt;hdlc_tx.bitbuf
op_assign
(paren
id|bc-&gt;hdlc_tx.bitbuf
op_amp
id|mask3
)paren
op_or
(paren
(paren
id|bc-&gt;hdlc_tx.bitbuf
op_amp
(paren
op_complement
id|mask3
)paren
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
id|bc-&gt;hdlc_tx.numbits
op_increment
suffix:semicolon
id|mask3
op_assign
(paren
id|mask3
op_lshift
l_int|1
)paren
op_or
l_int|1
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* ---------------------------------------------------------------------- */
DECL|variable|random_seed
r_static
r_int
r_int
id|random_seed
suffix:semicolon
DECL|function|random_num
r_static
r_inline
r_int
r_int
id|random_num
c_func
(paren
r_void
)paren
(brace
id|random_seed
op_assign
l_int|28629
op_star
id|random_seed
op_plus
l_int|157
suffix:semicolon
r_return
id|random_seed
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------------------- */
DECL|function|tx_arbitrate
r_static
r_inline
r_void
id|tx_arbitrate
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
)paren
(brace
r_int
r_char
op_star
id|bp
suffix:semicolon
r_int
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
id|bc-&gt;hdlc_tx.ptt
op_logical_or
id|bc-&gt;modem.dcd
)paren
r_return
suffix:semicolon
id|get_packet
c_func
(paren
op_amp
id|bc-&gt;tx_buf
comma
op_amp
id|bp
comma
op_amp
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp
op_logical_or
op_logical_neg
id|len
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc-&gt;ch_params.fulldup
)paren
(brace
r_if
c_cond
(paren
(paren
id|random_num
c_func
(paren
)paren
op_mod
l_int|256
)paren
OG
id|bc-&gt;ch_params.ppersist
)paren
r_return
suffix:semicolon
)brace
id|bc-&gt;hdlc_tx.tx_state
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;hdlc_tx.numflags
op_assign
id|tenms_to_2flags
c_func
(paren
id|bc
comma
id|bc-&gt;ch_params.tx_delay
)paren
suffix:semicolon
id|bc-&gt;hdlc_tx.numbits
op_assign
id|bc-&gt;hdlc_tx.bitbuf
op_assign
id|bc-&gt;hdlc_tx.bitstream
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;hdlc_tx.ptt
op_assign
l_int|1
suffix:semicolon
id|bc-&gt;stat.ptt_keyed
op_increment
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
macro_line|#ifdef BAYCOM_DEBUG
DECL|function|baycom_int_freq
r_static
r_void
r_inline
id|baycom_int_freq
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
)paren
(brace
r_int
r_int
id|cur_jiffies
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* &n;&t; * measure the interrupt frequency&n;&t; */
id|bc-&gt;debug_vals.cur_intcnt
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cur_jiffies
op_minus
id|bc-&gt;debug_vals.last_jiffies
)paren
op_ge
id|HZ
)paren
(brace
id|bc-&gt;debug_vals.last_jiffies
op_assign
id|cur_jiffies
suffix:semicolon
id|bc-&gt;debug_vals.last_intcnt
op_assign
id|bc-&gt;debug_vals.cur_intcnt
suffix:semicolon
id|bc-&gt;debug_vals.cur_intcnt
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;debug_vals.last_pllcorr
op_assign
id|bc-&gt;debug_vals.cur_pllcorr
suffix:semicolon
id|bc-&gt;debug_vals.cur_pllcorr
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif /* BAYCOM_DEBUG */
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|rx_chars_to_flip
r_static
r_inline
r_void
id|rx_chars_to_flip
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
)paren
(brace
r_int
id|flip_free
suffix:semicolon
r_int
r_int
id|cnt
suffix:semicolon
r_int
r_int
id|new_rd
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|bc
)paren
op_logical_or
(paren
op_logical_neg
id|bc-&gt;tty
)paren
op_logical_or
(paren
id|bc-&gt;tty-&gt;flip.count
op_ge
id|TTY_FLIPBUF_SIZE
)paren
op_logical_or
(paren
id|bc-&gt;rx_buf.rd
op_eq
id|bc-&gt;rx_buf.wr
)paren
op_logical_or
(paren
op_logical_neg
id|bc-&gt;tty-&gt;flip.char_buf_ptr
)paren
op_logical_or
(paren
op_logical_neg
id|bc-&gt;tty-&gt;flip.flag_buf_ptr
)paren
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|flip_free
op_assign
id|TTY_FLIPBUF_SIZE
op_minus
id|bc-&gt;tty-&gt;flip.count
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;rx_buf.rd
op_le
id|bc-&gt;rx_buf.wr
)paren
id|cnt
op_assign
id|bc-&gt;rx_buf.wr
op_minus
id|bc-&gt;rx_buf.rd
suffix:semicolon
r_else
id|cnt
op_assign
id|bc-&gt;rx_buf.buflen
op_minus
id|bc-&gt;rx_buf.rd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flip_free
op_le
l_int|0
)paren
op_logical_or
(paren
op_logical_neg
id|cnt
)paren
)paren
(brace
id|tty_schedule_flip
c_func
(paren
id|bc-&gt;tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cnt
OG
id|flip_free
)paren
id|cnt
op_assign
id|flip_free
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|bc-&gt;tty-&gt;flip.char_buf_ptr
comma
id|bc-&gt;rx_buf.buffer
op_plus
id|bc-&gt;rx_buf.rd
comma
id|cnt
)paren
suffix:semicolon
id|memset
c_func
(paren
id|bc-&gt;tty-&gt;flip.flag_buf_ptr
comma
id|TTY_NORMAL
comma
id|cnt
)paren
suffix:semicolon
id|bc-&gt;tty-&gt;flip.count
op_add_assign
id|cnt
suffix:semicolon
id|bc-&gt;tty-&gt;flip.char_buf_ptr
op_add_assign
id|cnt
suffix:semicolon
id|bc-&gt;tty-&gt;flip.flag_buf_ptr
op_add_assign
id|cnt
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|new_rd
op_assign
id|bc-&gt;rx_buf.rd
op_plus
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|new_rd
op_ge
id|bc-&gt;rx_buf.buflen
)paren
id|new_rd
op_sub_assign
id|bc-&gt;rx_buf.buflen
suffix:semicolon
id|bc-&gt;rx_buf.rd
op_assign
id|new_rd
suffix:semicolon
)brace
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * ===================== SER12 specific routines =========================&n; */
DECL|function|ser12_set_divisor
r_static
r_void
r_inline
id|ser12_set_divisor
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
comma
r_int
r_char
id|divisor
)paren
(brace
id|outb
c_func
(paren
l_int|0x81
comma
id|LCR
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* DLAB = 1 */
id|outb
c_func
(paren
id|divisor
comma
id|DLL
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|DLM
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x01
comma
id|LCR
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* word length = 6 */
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * must call the TX arbitrator every 10ms&n; */
DECL|macro|SER12_ARB_DIVIDER
mdefine_line|#define SER12_ARB_DIVIDER(bc) ((bc-&gt;options &amp; BAYCOM_OPTIONS_SOFTDCD) ? &bslash;&n;&t;&t;&t;       36 : 24)
DECL|macro|SER12_DCD_INTERVAL
mdefine_line|#define SER12_DCD_INTERVAL(bc) ((bc-&gt;options &amp; BAYCOM_OPTIONS_SOFTDCD) ? &bslash;&n;&t;&t;&t;&t;240 : 12)
DECL|function|baycom_ser12_interrupt
r_static
r_void
id|baycom_ser12_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|baycom_state
op_star
id|bc
op_assign
(paren
r_struct
id|baycom_state
op_star
)paren
id|dev_id
suffix:semicolon
r_int
r_char
id|cur_s
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
id|bc-&gt;magic
op_ne
id|BAYCOM_MAGIC
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * make sure the next interrupt is generated;&n;&t; * 0 must be used to power the modem; the modem draws its&n;&t; * power from the TxD line&n;&t; */
id|outb
c_func
(paren
l_int|0x00
comma
id|THR
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
id|rx_chars_to_flip
c_func
(paren
id|bc
)paren
suffix:semicolon
macro_line|#ifdef BAYCOM_DEBUG
id|baycom_int_freq
c_func
(paren
id|bc
)paren
suffix:semicolon
macro_line|#endif /* BAYCOM_DEBUG */
multiline_comment|/*&n;&t; * check if transmitter active&n;&t; */
r_if
c_cond
(paren
id|bc-&gt;hdlc_tx.ptt
op_logical_or
id|bc-&gt;calibrate
OG
l_int|0
)paren
(brace
id|ser12_set_divisor
c_func
(paren
id|bc
comma
l_int|12
)paren
suffix:semicolon
multiline_comment|/* one interrupt per channel bit */
multiline_comment|/*&n;&t;&t; * first output the last bit (!) then call HDLC transmitter,&n;&t;&t; * since this may take quite long&n;&t;&t; */
id|outb
c_func
(paren
l_int|0x0e
op_or
(paren
id|bc-&gt;modem.ser12.tx_bit
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
id|MCR
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;hdlc_tx.shreg1
op_le
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|bc-&gt;calibrate
OG
l_int|0
)paren
(brace
id|bc-&gt;hdlc_tx.shreg1
op_assign
l_int|0x10000
suffix:semicolon
id|bc-&gt;calibrate
op_decrement
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef BAYCOM_USE_BH
id|bc-&gt;hdlc_tx.shreg1
op_assign
id|bc-&gt;hdlc_tx.shreg2
suffix:semicolon
id|bc-&gt;hdlc_tx.shreg2
op_assign
l_int|0
suffix:semicolon
id|queue_task_irq_off
c_func
(paren
op_amp
id|bc-&gt;tq_transmitter
comma
op_amp
id|tq_baycom
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|BAYCOM_BH
)paren
suffix:semicolon
macro_line|#ifdef HDLC_LOOPBACK
id|bc-&gt;hdlc_rx.shreg2
op_assign
id|bc-&gt;hdlc_tx.shreg1
suffix:semicolon
id|queue_task_irq_off
c_func
(paren
op_amp
id|bc-&gt;tq_receiver
comma
op_amp
id|tq_baycom
)paren
suffix:semicolon
macro_line|#endif /* HDLC_LOOPBACK */
macro_line|#else /* BAYCOM_USE_BH */
id|bc-&gt;hdlc_tx.shreg1
op_assign
id|hdlc_tx_word
c_func
(paren
id|bc
)paren
op_or
l_int|0x10000
suffix:semicolon
macro_line|#ifdef HDLC_LOOPBACK
id|hdlc_rx_word
c_func
(paren
id|bc
comma
id|bc-&gt;hdlc_tx.shreg1
)paren
suffix:semicolon
macro_line|#endif /* HDLC_LOOPBACK */
macro_line|#endif /* BAYCOM_USE_BH */
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bc-&gt;hdlc_tx.shreg1
op_amp
l_int|1
)paren
)paren
id|bc-&gt;modem.ser12.tx_bit
op_assign
op_logical_neg
id|bc-&gt;modem.ser12.tx_bit
suffix:semicolon
id|bc-&gt;hdlc_tx.shreg1
op_rshift_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * do demodulator&n;&t; */
id|outb
c_func
(paren
l_int|0x0d
comma
id|MCR
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* transmitter off */
id|cur_s
op_assign
id|inb
c_func
(paren
id|MSR
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
op_amp
l_int|0x10
suffix:semicolon
multiline_comment|/* the CTS line */
macro_line|#ifdef BAYCOM_DEBUG
id|add_bitbuffer
c_func
(paren
op_amp
id|bc-&gt;bitbuf_channel
comma
id|cur_s
)paren
suffix:semicolon
macro_line|#endif /* BAYCOM_DEBUG */
id|bc-&gt;modem.ser12.dcd_shreg
op_lshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cur_s
op_ne
id|bc-&gt;modem.ser12.last_sample
)paren
(brace
id|bc-&gt;modem.ser12.dcd_shreg
op_or_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;options
op_amp
id|BAYCOM_OPTIONS_SOFTDCD
)paren
(brace
r_int
r_int
id|dcdspos
comma
id|dcdsneg
suffix:semicolon
id|dcdspos
op_assign
id|dcdsneg
op_assign
l_int|0
suffix:semicolon
id|dcdspos
op_add_assign
(paren
(paren
id|bc-&gt;modem.ser12.dcd_shreg
op_rshift
l_int|1
)paren
op_amp
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bc-&gt;modem.ser12.dcd_shreg
op_amp
l_int|0x7ffffffe
)paren
)paren
id|dcdspos
op_add_assign
l_int|2
suffix:semicolon
id|dcdsneg
op_add_assign
(paren
(paren
id|bc-&gt;modem.ser12.dcd_shreg
op_rshift
l_int|2
)paren
op_amp
l_int|1
)paren
suffix:semicolon
id|dcdsneg
op_add_assign
(paren
(paren
id|bc-&gt;modem.ser12.dcd_shreg
op_rshift
l_int|3
)paren
op_amp
l_int|1
)paren
suffix:semicolon
id|dcdsneg
op_add_assign
(paren
(paren
id|bc-&gt;modem.ser12.dcd_shreg
op_rshift
l_int|4
)paren
op_amp
l_int|1
)paren
suffix:semicolon
id|bc-&gt;modem.ser12.dcd_sum0
op_add_assign
l_int|16
op_star
id|dcdspos
op_minus
id|dcdsneg
suffix:semicolon
)brace
r_else
id|bc-&gt;modem.ser12.dcd_sum0
op_decrement
suffix:semicolon
)brace
id|bc-&gt;modem.ser12.last_sample
op_assign
id|cur_s
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc-&gt;modem.ser12.dcd_time
)paren
(brace
id|bc-&gt;modem.dcd
op_assign
(paren
id|bc-&gt;modem.ser12.dcd_sum0
op_plus
id|bc-&gt;modem.ser12.dcd_sum1
op_plus
id|bc-&gt;modem.ser12.dcd_sum2
)paren
OL
l_int|0
suffix:semicolon
id|bc-&gt;modem.ser12.dcd_sum2
op_assign
id|bc-&gt;modem.ser12.dcd_sum1
suffix:semicolon
id|bc-&gt;modem.ser12.dcd_sum1
op_assign
id|bc-&gt;modem.ser12.dcd_sum0
suffix:semicolon
multiline_comment|/* offset to ensure DCD off on silent input */
id|bc-&gt;modem.ser12.dcd_sum0
op_assign
l_int|2
suffix:semicolon
id|bc-&gt;modem.ser12.dcd_time
op_assign
id|SER12_DCD_INTERVAL
c_func
(paren
id|bc
)paren
suffix:semicolon
)brace
id|bc-&gt;modem.ser12.dcd_time
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;options
op_amp
id|BAYCOM_OPTIONS_SOFTDCD
)paren
(brace
multiline_comment|/*&n;&t;&t; * PLL code for the improved software DCD algorithm&n;&t;&t; */
r_if
c_cond
(paren
id|bc-&gt;modem.ser12.interm_sample
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * intermediate sample; set timing correction to normal&n;&t;&t;&t; */
id|ser12_set_divisor
c_func
(paren
id|bc
comma
l_int|4
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * do PLL correction and call HDLC receiver&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|bc-&gt;modem.ser12.dcd_shreg
op_amp
l_int|7
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* transition too late */
id|ser12_set_divisor
c_func
(paren
id|bc
comma
l_int|5
)paren
suffix:semicolon
macro_line|#ifdef BAYCOM_DEBUG
id|bc-&gt;debug_vals.cur_pllcorr
op_increment
suffix:semicolon
macro_line|#endif /* BAYCOM_DEBUG */
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* transition too early */
id|ser12_set_divisor
c_func
(paren
id|bc
comma
l_int|3
)paren
suffix:semicolon
macro_line|#ifdef BAYCOM_DEBUG
id|bc-&gt;debug_vals.cur_pllcorr
op_decrement
suffix:semicolon
macro_line|#endif /* BAYCOM_DEBUG */
r_break
suffix:semicolon
r_default
suffix:colon
id|ser12_set_divisor
c_func
(paren
id|bc
comma
l_int|4
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bc-&gt;hdlc_rx.shreg1
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;modem.ser12.last_sample
op_eq
id|bc-&gt;modem.ser12.last_rxbit
)paren
id|bc-&gt;hdlc_rx.shreg1
op_or_assign
l_int|0x10000
suffix:semicolon
id|bc-&gt;modem.ser12.last_rxbit
op_assign
id|bc-&gt;modem.ser12.last_sample
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|bc-&gt;modem.ser12.interm_sample
op_ge
l_int|3
)paren
id|bc-&gt;modem.ser12.interm_sample
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * PLL algorithm for the hardware squelch DCD algorithm&n;&t;&t; */
r_if
c_cond
(paren
id|bc-&gt;modem.ser12.interm_sample
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * intermediate sample; set timing correction to normal&n;&t;&t;&t; */
id|ser12_set_divisor
c_func
(paren
id|bc
comma
l_int|6
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * do PLL correction and call HDLC receiver&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|bc-&gt;modem.ser12.dcd_shreg
op_amp
l_int|3
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* transition too late */
id|ser12_set_divisor
c_func
(paren
id|bc
comma
l_int|7
)paren
suffix:semicolon
macro_line|#ifdef BAYCOM_DEBUG
id|bc-&gt;debug_vals.cur_pllcorr
op_increment
suffix:semicolon
macro_line|#endif /* BAYCOM_DEBUG */
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* transition too early */
id|ser12_set_divisor
c_func
(paren
id|bc
comma
l_int|5
)paren
suffix:semicolon
macro_line|#ifdef BAYCOM_DEBUG
id|bc-&gt;debug_vals.cur_pllcorr
op_decrement
suffix:semicolon
macro_line|#endif /* BAYCOM_DEBUG */
r_break
suffix:semicolon
r_default
suffix:colon
id|ser12_set_divisor
c_func
(paren
id|bc
comma
l_int|6
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bc-&gt;hdlc_rx.shreg1
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;modem.ser12.last_sample
op_eq
id|bc-&gt;modem.ser12.last_rxbit
)paren
id|bc-&gt;hdlc_rx.shreg1
op_or_assign
l_int|0x10000
suffix:semicolon
id|bc-&gt;modem.ser12.last_rxbit
op_assign
id|bc-&gt;modem.ser12.last_sample
suffix:semicolon
)brace
id|bc-&gt;modem.ser12.interm_sample
op_assign
op_logical_neg
id|bc-&gt;modem.ser12.interm_sample
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bc-&gt;hdlc_rx.shreg1
op_amp
l_int|1
)paren
(brace
macro_line|#ifdef BAYCOM_USE_BH
id|bc-&gt;hdlc_rx.shreg2
op_assign
(paren
id|bc-&gt;hdlc_rx.shreg1
op_rshift
l_int|1
)paren
op_or
l_int|0x10000
suffix:semicolon
id|queue_task_irq_off
c_func
(paren
op_amp
id|bc-&gt;tq_receiver
comma
op_amp
id|tq_baycom
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|BAYCOM_BH
)paren
suffix:semicolon
macro_line|#else /* BAYCOM_USE_BH */
id|hdlc_rx_word
c_func
(paren
id|bc
comma
id|bc-&gt;hdlc_rx.shreg1
op_rshift
l_int|1
)paren
suffix:semicolon
macro_line|#endif /* BAYCOM_USE_BH */
id|bc-&gt;hdlc_rx.shreg1
op_assign
l_int|0x10000
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|bc-&gt;modem.arb_divider
op_le
l_int|0
)paren
(brace
macro_line|#ifdef BAYCOM_USE_BH
id|queue_task_irq_off
c_func
(paren
op_amp
id|bc-&gt;tq_arbitrate
comma
op_amp
id|tq_baycom
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|BAYCOM_BH
)paren
suffix:semicolon
macro_line|#else /* BAYCOM_USE_BH */
id|tx_arbitrate
c_func
(paren
id|bc
)paren
suffix:semicolon
macro_line|#endif /* BAYCOM_USE_BH */
id|bc-&gt;modem.arb_divider
op_assign
id|bc-&gt;ch_params.slottime
op_star
id|SER12_ARB_DIVIDER
c_func
(paren
id|bc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|enum|uart
DECL|enumerator|c_uart_unknown
DECL|enumerator|c_uart_8250
r_enum
id|uart
(brace
id|c_uart_unknown
comma
id|c_uart_8250
comma
DECL|enumerator|c_uart_16450
DECL|enumerator|c_uart_16550
DECL|enumerator|c_uart_16550A
id|c_uart_16450
comma
id|c_uart_16550
comma
id|c_uart_16550A
)brace
suffix:semicolon
DECL|variable|uart_str
r_static
r_const
r_char
op_star
id|uart_str
(braket
)braket
op_assign
(brace
l_string|&quot;unknown&quot;
comma
l_string|&quot;8250&quot;
comma
l_string|&quot;16450&quot;
comma
l_string|&quot;16550&quot;
comma
l_string|&quot;16550A&quot;
)brace
suffix:semicolon
DECL|function|ser12_check_uart
r_static
r_enum
id|uart
id|ser12_check_uart
c_func
(paren
r_int
r_int
id|iobase
)paren
(brace
r_int
r_char
id|b1
comma
id|b2
comma
id|b3
suffix:semicolon
r_enum
id|uart
id|u
suffix:semicolon
r_enum
id|uart
id|uart_tab
(braket
)braket
op_assign
(brace
id|c_uart_16450
comma
id|c_uart_unknown
comma
id|c_uart_16550
comma
id|c_uart_16550A
)brace
suffix:semicolon
id|b1
op_assign
id|inb
c_func
(paren
id|MCR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|b1
op_or
l_int|0x10
comma
id|MCR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* loopback mode */
id|b2
op_assign
id|inb
c_func
(paren
id|MSR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x1a
comma
id|MCR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|b3
op_assign
id|inb
c_func
(paren
id|MSR
c_func
(paren
id|iobase
)paren
)paren
op_amp
l_int|0xf0
suffix:semicolon
id|outb
c_func
(paren
id|b1
comma
id|MCR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* restore old values */
id|outb
c_func
(paren
id|b2
comma
id|MSR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|b3
op_ne
l_int|0x90
)paren
r_return
id|c_uart_unknown
suffix:semicolon
id|inb
c_func
(paren
id|RBR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|inb
c_func
(paren
id|RBR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x01
comma
id|FCR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* enable FIFOs */
id|u
op_assign
id|uart_tab
(braket
(paren
id|inb
c_func
(paren
id|IIR
c_func
(paren
id|iobase
)paren
)paren
op_rshift
l_int|6
)paren
op_amp
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|u
op_eq
id|c_uart_16450
)paren
(brace
id|outb
c_func
(paren
l_int|0x5a
comma
id|SCR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|b1
op_assign
id|inb
c_func
(paren
id|SCR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xa5
comma
id|SCR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|b2
op_assign
id|inb
c_func
(paren
id|SCR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|b1
op_ne
l_int|0x5a
)paren
op_logical_or
(paren
id|b2
op_ne
l_int|0xa5
)paren
)paren
id|u
op_assign
id|c_uart_8250
suffix:semicolon
)brace
r_return
id|u
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|ser12_allocate_resources
r_static
r_int
id|ser12_allocate_resources
c_func
(paren
r_int
r_int
id|iobase
comma
r_int
r_int
id|irq
comma
r_int
r_int
id|options
)paren
(brace
r_enum
id|uart
id|u
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iobase
op_logical_or
id|iobase
OG
l_int|0xfff
op_logical_or
id|irq
template_param
l_int|15
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|iobase
comma
id|SER12_EXTENT
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
(paren
id|u
op_assign
id|ser12_check_uart
c_func
(paren
id|iobase
)paren
)paren
op_eq
id|c_uart_unknown
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|request_region
c_func
(paren
id|iobase
comma
id|SER12_EXTENT
comma
l_string|&quot;baycom_ser12&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|FCR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* disable FIFOs */
id|outb
c_func
(paren
l_int|0x0d
comma
id|MCR
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;baycom: ser12 at iobase 0x%x irq %u options 0x%x &quot;
l_string|&quot;uart %s&bslash;n&quot;
comma
id|iobase
comma
id|irq
comma
id|options
comma
id|uart_str
(braket
id|u
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|ser12_deallocate_resources
r_static
r_void
id|ser12_deallocate_resources
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
id|bc-&gt;modem_type
op_ne
id|BAYCOM_MODEM_SER12
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * disable interrupts&n;&t; */
id|outb
c_func
(paren
l_int|0
comma
id|IER
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|MCR
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * this should prevent kernel: Trying to free IRQx&n;&t; * messages&n;&t; */
r_if
c_cond
(paren
id|bc-&gt;opened
OG
l_int|0
)paren
id|free_irq
c_func
(paren
id|bc-&gt;irq
comma
id|bc
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|bc-&gt;iobase
comma
id|SER12_EXTENT
)paren
suffix:semicolon
id|bc-&gt;modem_type
op_assign
id|BAYCOM_MODEM_INVALID
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;baycom: release ser12 at iobase 0x%x irq %u&bslash;n&quot;
comma
id|bc-&gt;iobase
comma
id|bc-&gt;irq
)paren
suffix:semicolon
id|bc-&gt;iobase
op_assign
id|bc-&gt;irq
op_assign
id|bc-&gt;options
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|ser12_on_open
r_static
r_int
id|ser12_on_open
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
id|bc-&gt;modem_type
op_ne
id|BAYCOM_MODEM_SER12
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/*&n;&t; * set the SIO to 6 Bits/character and 19200 or 28800 baud, so that&n;&t; * we get exactly (hopefully) 2 or 3 interrupts per radio symbol,&n;&t; * depending on the usage of the software DCD routine&n;&t; */
id|ser12_set_divisor
c_func
(paren
id|bc
comma
(paren
id|bc-&gt;options
op_amp
id|BAYCOM_OPTIONS_SOFTDCD
)paren
ques
c_cond
l_int|4
suffix:colon
l_int|6
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0d
comma
id|MCR
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|IER
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|bc-&gt;irq
comma
id|baycom_ser12_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;baycom_ser12&quot;
comma
id|bc
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/*&n;&t; * enable transmitter empty interrupt&n;&t; */
id|outb
c_func
(paren
l_int|2
comma
id|IER
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * the value here serves to power the modem&n;&t; */
id|outb
c_func
(paren
l_int|0x00
comma
id|THR
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|ser12_on_close
r_static
r_void
id|ser12_on_close
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
id|bc-&gt;modem_type
op_ne
id|BAYCOM_MODEM_SER12
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * disable interrupts&n;&t; */
id|outb
c_func
(paren
l_int|0
comma
id|IER
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|MCR
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|bc-&gt;irq
comma
id|bc
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * ===================== PAR96 specific routines =========================&n; */
DECL|macro|PAR96_DESCRAM_TAP1
mdefine_line|#define PAR96_DESCRAM_TAP1 0x20000
DECL|macro|PAR96_DESCRAM_TAP2
mdefine_line|#define PAR96_DESCRAM_TAP2 0x01000
DECL|macro|PAR96_DESCRAM_TAP3
mdefine_line|#define PAR96_DESCRAM_TAP3 0x00001
DECL|macro|PAR96_DESCRAM_TAPSH1
mdefine_line|#define PAR96_DESCRAM_TAPSH1 17
DECL|macro|PAR96_DESCRAM_TAPSH2
mdefine_line|#define PAR96_DESCRAM_TAPSH2 12
DECL|macro|PAR96_DESCRAM_TAPSH3
mdefine_line|#define PAR96_DESCRAM_TAPSH3 0
DECL|macro|PAR96_SCRAM_TAP1
mdefine_line|#define PAR96_SCRAM_TAP1 0x20000 /* X^17 */
DECL|macro|PAR96_SCRAM_TAPN
mdefine_line|#define PAR96_SCRAM_TAPN 0x00021 /* X^0+X^5 */
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|baycom_par96_interrupt
r_static
r_void
id|baycom_par96_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_register
r_struct
id|baycom_state
op_star
id|bc
op_assign
(paren
r_struct
id|baycom_state
op_star
)paren
id|dev_id
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|data
comma
id|descx
comma
id|mask
comma
id|mask2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
id|bc-&gt;magic
op_ne
id|BAYCOM_MAGIC
)paren
r_return
suffix:semicolon
id|rx_chars_to_flip
c_func
(paren
id|bc
)paren
suffix:semicolon
macro_line|#ifdef BAYCOM_DEBUG
id|baycom_int_freq
c_func
(paren
id|bc
)paren
suffix:semicolon
macro_line|#endif /* BAYCOM_DEBUG */
multiline_comment|/*&n;&t; * check if transmitter active&n;&t; */
r_if
c_cond
(paren
id|bc-&gt;hdlc_tx.ptt
op_logical_or
id|bc-&gt;calibrate
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * first output the last 16 bits (!) then call HDLC&n;&t;&t; * transmitter, since this may take quite long&n;&t;&t; * do the differential encoder and the scrambler on the fly&n;&t;&t; */
id|data
op_assign
id|bc-&gt;hdlc_tx.shreg1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PAR96_BURSTBITS
suffix:semicolon
id|i
op_increment
comma
id|data
op_rshift_assign
l_int|1
)paren
(brace
r_int
r_char
id|val
op_assign
id|PAR97_POWER
suffix:semicolon
id|bc-&gt;modem.par96.scram
op_assign
(paren
(paren
id|bc-&gt;modem.par96.scram
op_lshift
l_int|1
)paren
op_or
(paren
id|bc-&gt;modem.par96.scram
op_amp
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|data
op_amp
l_int|1
)paren
)paren
id|bc-&gt;modem.par96.scram
op_xor_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;modem.par96.scram
op_amp
(paren
id|PAR96_SCRAM_TAP1
op_lshift
l_int|1
)paren
)paren
id|bc-&gt;modem.par96.scram
op_xor_assign
(paren
id|PAR96_SCRAM_TAPN
op_lshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;modem.par96.scram
op_amp
(paren
id|PAR96_SCRAM_TAP1
op_lshift
l_int|2
)paren
)paren
id|val
op_or_assign
id|PAR96_TXBIT
suffix:semicolon
id|outb
c_func
(paren
id|val
comma
id|LPT_DATA
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|val
op_or
id|PAR96_BURST
comma
id|LPT_DATA
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bc-&gt;calibrate
OG
l_int|0
)paren
(brace
id|bc-&gt;hdlc_tx.shreg1
op_assign
l_int|0x10000
suffix:semicolon
id|bc-&gt;calibrate
op_decrement
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef BAYCOM_USE_BH
id|bc-&gt;hdlc_tx.shreg1
op_assign
id|bc-&gt;hdlc_tx.shreg2
suffix:semicolon
id|bc-&gt;hdlc_tx.shreg2
op_assign
l_int|0
suffix:semicolon
id|queue_task_irq_off
c_func
(paren
op_amp
id|bc-&gt;tq_transmitter
comma
op_amp
id|tq_baycom
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|BAYCOM_BH
)paren
suffix:semicolon
macro_line|#ifdef HDLC_LOOPBACK
id|bc-&gt;hdlc_rx.shreg2
op_assign
id|bc-&gt;hdlc_tx.shreg1
suffix:semicolon
id|queue_task_irq_off
c_func
(paren
op_amp
id|bc-&gt;tq_receiver
comma
op_amp
id|tq_baycom
)paren
suffix:semicolon
macro_line|#endif /* HDLC_LOOPBACK */
macro_line|#else /* BAYCOM_USE_BH */
id|bc-&gt;hdlc_tx.shreg1
op_assign
id|hdlc_tx_word
c_func
(paren
id|bc
)paren
suffix:semicolon
macro_line|#ifdef HDLC_LOOPBACK
id|hdlc_rx_word
c_func
(paren
id|bc
comma
id|bc-&gt;hdlc_tx.shreg1
)paren
suffix:semicolon
macro_line|#endif /* HDLC_LOOPBACK */
macro_line|#endif /* BAYCOM_USE_BH */
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * do receiver; differential decode and descramble on the fly&n;&t; */
r_for
c_loop
(paren
id|data
op_assign
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PAR96_BURSTBITS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bc-&gt;modem.par96.descram
op_assign
(paren
id|bc-&gt;modem.par96.descram
op_lshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|LPT_STATUS
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
op_amp
id|PAR96_RXBIT
)paren
id|bc-&gt;modem.par96.descram
op_or_assign
l_int|1
suffix:semicolon
id|descx
op_assign
id|bc-&gt;modem.par96.descram
op_xor
(paren
id|bc-&gt;modem.par96.descram
op_rshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* now the diff decoded data is inverted in descram */
id|outb
c_func
(paren
id|PAR97_POWER
op_or
id|PAR96_PTT
comma
id|LPT_DATA
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
id|descx
op_xor_assign
(paren
(paren
id|descx
op_rshift
id|PAR96_DESCRAM_TAPSH1
)paren
op_xor
(paren
id|descx
op_rshift
id|PAR96_DESCRAM_TAPSH2
)paren
)paren
suffix:semicolon
id|data
op_rshift_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|descx
op_amp
l_int|1
)paren
)paren
id|data
op_or_assign
l_int|0x8000
suffix:semicolon
id|outb
c_func
(paren
id|PAR97_POWER
op_or
id|PAR96_PTT
op_or
id|PAR96_BURST
comma
id|LPT_DATA
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef BAYCOM_USE_BH
id|bc-&gt;hdlc_rx.shreg2
op_assign
id|bc-&gt;hdlc_rx.shreg1
suffix:semicolon
id|bc-&gt;hdlc_rx.shreg1
op_assign
id|data
op_or
l_int|0x10000
suffix:semicolon
id|queue_task_irq_off
c_func
(paren
op_amp
id|bc-&gt;tq_receiver
comma
op_amp
id|tq_baycom
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|BAYCOM_BH
)paren
suffix:semicolon
macro_line|#else /* BAYCOM_USE_BH */
id|hdlc_rx_word
c_func
(paren
id|bc
comma
id|data
)paren
suffix:semicolon
macro_line|#endif /* BAYCOM_USE_BH */
multiline_comment|/*&n;&t; * do DCD algorithm&n;&t; */
r_if
c_cond
(paren
id|bc-&gt;options
op_amp
id|BAYCOM_OPTIONS_SOFTDCD
)paren
(brace
id|bc-&gt;modem.par96.dcd_shreg
op_assign
(paren
id|bc-&gt;modem.par96.dcd_shreg
op_rshift
l_int|16
)paren
op_or
(paren
id|data
op_lshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/* search for flags and set the dcd counter appropriately */
r_for
c_loop
(paren
id|mask
op_assign
l_int|0x1fe00
comma
id|mask2
op_assign
l_int|0xfc00
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PAR96_BURSTBITS
suffix:semicolon
id|i
op_increment
comma
id|mask
op_lshift_assign
l_int|1
comma
id|mask2
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
(paren
id|bc-&gt;modem.par96.dcd_shreg
op_amp
id|mask
)paren
op_eq
id|mask2
)paren
id|bc-&gt;modem.par96.dcd_count
op_assign
id|BAYCOM_MAXFLEN
op_plus
l_int|4
suffix:semicolon
multiline_comment|/* check for abort/noise sequences */
r_for
c_loop
(paren
id|mask
op_assign
l_int|0x1fe00
comma
id|mask2
op_assign
l_int|0x1fe00
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PAR96_BURSTBITS
suffix:semicolon
id|i
op_increment
comma
id|mask
op_lshift_assign
l_int|1
comma
id|mask2
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
(paren
(paren
id|bc-&gt;modem.par96.dcd_shreg
op_amp
id|mask
)paren
op_eq
id|mask2
)paren
op_logical_and
(paren
id|bc-&gt;modem.par96.dcd_count
op_ge
l_int|0
)paren
)paren
id|bc-&gt;modem.par96.dcd_count
op_sub_assign
id|BAYCOM_MAXFLEN
op_minus
l_int|10
suffix:semicolon
multiline_comment|/* decrement and set the dcd variable */
r_if
c_cond
(paren
id|bc-&gt;modem.par96.dcd_count
op_ge
l_int|0
)paren
id|bc-&gt;modem.par96.dcd_count
op_sub_assign
l_int|2
suffix:semicolon
id|bc-&gt;modem.dcd
op_assign
id|bc-&gt;modem.par96.dcd_count
OG
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|bc-&gt;modem.dcd
op_assign
op_logical_neg
op_logical_neg
(paren
id|inb
c_func
(paren
id|LPT_STATUS
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
op_amp
id|PAR96_DCD
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|bc-&gt;modem.arb_divider
op_le
l_int|0
)paren
(brace
macro_line|#ifdef BAYCOM_USE_BH
id|queue_task_irq_off
c_func
(paren
op_amp
id|bc-&gt;tq_arbitrate
comma
op_amp
id|tq_baycom
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|BAYCOM_BH
)paren
suffix:semicolon
macro_line|#else /* BAYCOM_USE_BH */
id|tx_arbitrate
c_func
(paren
id|bc
)paren
suffix:semicolon
macro_line|#endif /* BAYCOM_USE_BH */
id|bc-&gt;modem.arb_divider
op_assign
id|bc-&gt;ch_params.slottime
op_star
l_int|6
suffix:semicolon
)brace
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|par96_check_lpt
r_static
r_int
id|par96_check_lpt
c_func
(paren
r_int
r_int
id|iobase
)paren
(brace
r_int
r_char
id|b1
comma
id|b2
suffix:semicolon
r_int
id|i
suffix:semicolon
id|b1
op_assign
id|inb
c_func
(paren
id|LPT_DATA
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|b2
op_assign
id|inb
c_func
(paren
id|LPT_CONTROL
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xaa
comma
id|LPT_DATA
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|i
op_assign
id|inb
c_func
(paren
id|LPT_DATA
c_func
(paren
id|iobase
)paren
)paren
op_eq
l_int|0xaa
suffix:semicolon
id|outb
c_func
(paren
l_int|0x55
comma
id|LPT_DATA
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|i
op_and_assign
id|inb
c_func
(paren
id|LPT_DATA
c_func
(paren
id|iobase
)paren
)paren
op_eq
l_int|0x55
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0a
comma
id|LPT_CONTROL
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|i
op_and_assign
(paren
id|inb
c_func
(paren
id|LPT_CONTROL
c_func
(paren
id|iobase
)paren
)paren
op_amp
l_int|0xf
)paren
op_eq
l_int|0x0a
suffix:semicolon
id|outb
c_func
(paren
l_int|0x05
comma
id|LPT_CONTROL
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|i
op_and_assign
(paren
id|inb
c_func
(paren
id|LPT_CONTROL
c_func
(paren
id|iobase
)paren
)paren
op_amp
l_int|0xf
)paren
op_eq
l_int|0x05
suffix:semicolon
id|outb
c_func
(paren
id|b1
comma
id|LPT_DATA
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|b2
comma
id|LPT_CONTROL
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
r_return
op_logical_neg
id|i
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|par96_allocate_resources
r_static
r_int
id|par96_allocate_resources
c_func
(paren
r_int
r_int
id|iobase
comma
r_int
r_int
id|irq
comma
r_int
r_int
id|options
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|iobase
op_logical_or
id|iobase
OG
l_int|0xfff
op_logical_or
id|irq
template_param
l_int|15
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|iobase
comma
id|PAR96_EXTENT
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|par96_check_lpt
c_func
(paren
id|iobase
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|request_region
c_func
(paren
id|iobase
comma
id|PAR96_EXTENT
comma
l_string|&quot;baycom_par96&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|LPT_CONTROL
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* disable interrupt */
id|outb
c_func
(paren
id|PAR96_PTT
op_or
id|PAR97_POWER
comma
id|LPT_DATA
c_func
(paren
id|iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* switch off PTT */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;baycom: par96 at iobase 0x%x irq %u options 0x%x&bslash;n&quot;
comma
id|iobase
comma
id|irq
comma
id|options
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|par96_deallocate_resources
r_static
r_void
id|par96_deallocate_resources
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
id|bc-&gt;modem_type
op_ne
id|BAYCOM_MODEM_PAR96
)paren
r_return
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|LPT_CONTROL
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* disable interrupt */
id|outb
c_func
(paren
id|PAR96_PTT
comma
id|LPT_DATA
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* switch off PTT */
multiline_comment|/* &n;&t; * this should prevent kernel: Trying to free IRQx&n;&t; * messages&n;&t; */
r_if
c_cond
(paren
id|bc-&gt;opened
OG
l_int|0
)paren
id|free_irq
c_func
(paren
id|bc-&gt;irq
comma
id|bc
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|bc-&gt;iobase
comma
id|PAR96_EXTENT
)paren
suffix:semicolon
id|bc-&gt;modem_type
op_assign
id|BAYCOM_MODEM_INVALID
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;baycom: release par96 at iobase 0x%x irq %u&bslash;n&quot;
comma
id|bc-&gt;iobase
comma
id|bc-&gt;irq
)paren
suffix:semicolon
id|bc-&gt;iobase
op_assign
id|bc-&gt;irq
op_assign
id|bc-&gt;options
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|par96_on_open
r_static
r_int
id|par96_on_open
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
id|bc-&gt;modem_type
op_ne
id|BAYCOM_MODEM_PAR96
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|LPT_CONTROL
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* disable interrupt */
multiline_comment|/* switch off PTT */
id|outb
c_func
(paren
id|PAR96_PTT
op_or
id|PAR97_POWER
comma
id|LPT_DATA
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|bc-&gt;irq
comma
id|baycom_par96_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;baycom_par96&quot;
comma
id|bc
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|outb
c_func
(paren
id|LPT_IRQ_ENABLE
comma
id|LPT_CONTROL
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* enable interrupt */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|par96_on_close
r_static
r_void
id|par96_on_close
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
id|bc-&gt;modem_type
op_ne
id|BAYCOM_MODEM_PAR96
)paren
r_return
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|LPT_CONTROL
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
multiline_comment|/* disable interrupt */
multiline_comment|/* switch off PTT */
id|outb
c_func
(paren
id|PAR96_PTT
op_or
id|PAR97_POWER
comma
id|LPT_DATA
c_func
(paren
id|bc-&gt;iobase
)paren
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|bc-&gt;irq
comma
id|bc
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * ===================== Bottom half (soft interrupt) ====================&n; */
macro_line|#ifdef BAYCOM_USE_BH
DECL|function|bh_receiver
r_static
r_void
id|bh_receiver
c_func
(paren
r_void
op_star
r_private
)paren
(brace
r_struct
id|baycom_state
op_star
id|bc
op_assign
(paren
r_struct
id|baycom_state
op_star
)paren
r_private
suffix:semicolon
r_int
r_int
id|temp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
id|bc-&gt;magic
op_ne
id|BAYCOM_MAGIC
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc-&gt;hdlc_rx.shreg2
)paren
r_return
suffix:semicolon
id|temp
op_assign
id|bc-&gt;hdlc_rx.shreg2
suffix:semicolon
id|bc-&gt;hdlc_rx.shreg2
op_assign
l_int|0
suffix:semicolon
id|hdlc_rx_word
c_func
(paren
id|bc
comma
id|temp
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|bh_transmitter
r_static
r_void
id|bh_transmitter
c_func
(paren
r_void
op_star
r_private
)paren
(brace
r_struct
id|baycom_state
op_star
id|bc
op_assign
(paren
r_struct
id|baycom_state
op_star
)paren
r_private
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
id|bc-&gt;magic
op_ne
id|BAYCOM_MAGIC
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;hdlc_tx.shreg2
)paren
r_return
suffix:semicolon
id|bc-&gt;hdlc_tx.shreg2
op_assign
id|hdlc_tx_word
c_func
(paren
id|bc
)paren
op_or
l_int|0x10000
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|bh_arbitrate
r_static
r_void
id|bh_arbitrate
c_func
(paren
r_void
op_star
r_private
)paren
(brace
r_struct
id|baycom_state
op_star
id|bc
op_assign
(paren
r_struct
id|baycom_state
op_star
)paren
r_private
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
id|bc-&gt;magic
op_ne
id|BAYCOM_MAGIC
)paren
r_return
suffix:semicolon
id|tx_arbitrate
c_func
(paren
id|bc
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|baycom_bottom_half
r_static
r_void
id|baycom_bottom_half
c_func
(paren
r_void
)paren
(brace
id|run_task_queue
c_func
(paren
op_amp
id|tq_baycom
)paren
suffix:semicolon
)brace
macro_line|#endif /* BAYCOM_USE_BH */
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * ===================== TTY interface routines ==========================&n; */
DECL|function|baycom_paranoia_check
r_static
r_inline
r_int
id|baycom_paranoia_check
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
comma
r_const
r_char
op_star
id|routine
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
id|bc-&gt;magic
op_ne
id|BAYCOM_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;baycom: bad magic number for baycom struct &quot;
l_string|&quot;in routine %s&bslash;n&quot;
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * Here the tty driver code starts&n; */
DECL|function|baycom_put_fend
r_static
r_void
id|baycom_put_fend
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
)paren
(brace
r_if
c_cond
(paren
id|bc-&gt;kiss_decode.wr
op_le
l_int|0
op_logical_or
(paren
id|bc-&gt;kiss_decode.pkt_buf
(braket
l_int|0
)braket
op_amp
l_int|0xf0
)paren
op_ne
l_int|0
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
id|bc-&gt;kiss_decode.pkt_buf
(braket
l_int|0
)braket
op_amp
l_int|0xf
)paren
(brace
r_case
id|KISS_CMD_DATA
suffix:colon
r_if
c_cond
(paren
id|bc-&gt;kiss_decode.wr
op_le
l_int|8
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|store_packet
c_func
(paren
op_amp
id|bc-&gt;tx_buf
comma
id|bc-&gt;kiss_decode.pkt_buf
op_plus
l_int|1
comma
l_int|0
comma
id|bc-&gt;kiss_decode.wr
op_minus
l_int|1
)paren
)paren
id|bc-&gt;stat.tx_bufferoverrun
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KISS_CMD_TXDELAY
suffix:colon
r_if
c_cond
(paren
id|bc-&gt;kiss_decode.wr
OL
l_int|2
)paren
r_break
suffix:semicolon
id|bc-&gt;ch_params.tx_delay
op_assign
id|bc-&gt;kiss_decode.pkt_buf
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#ifdef KISS_VERBOSE
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;baycom: TX delay = %ums&bslash;n&quot;
comma
id|bc-&gt;ch_params.tx_delay
op_star
l_int|10
)paren
suffix:semicolon
macro_line|#endif /* KISS_VERBOSE */
r_break
suffix:semicolon
r_case
id|KISS_CMD_PPERSIST
suffix:colon
r_if
c_cond
(paren
id|bc-&gt;kiss_decode.wr
OL
l_int|2
)paren
r_break
suffix:semicolon
id|bc-&gt;ch_params.ppersist
op_assign
id|bc-&gt;kiss_decode.pkt_buf
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#ifdef KISS_VERBOSE
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;baycom: p-persistence = %u&bslash;n&quot;
comma
id|bc-&gt;ch_params.ppersist
)paren
suffix:semicolon
macro_line|#endif /* KISS_VERBOSE */
r_break
suffix:semicolon
r_case
id|KISS_CMD_SLOTTIME
suffix:colon
r_if
c_cond
(paren
id|bc-&gt;kiss_decode.wr
OL
l_int|2
)paren
r_break
suffix:semicolon
id|bc-&gt;ch_params.slottime
op_assign
id|bc-&gt;kiss_decode.pkt_buf
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#ifdef KISS_VERBOSE
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;baycom: slottime = %ums&bslash;n&quot;
comma
id|bc-&gt;ch_params.slottime
op_star
l_int|10
)paren
suffix:semicolon
macro_line|#endif /* KISS_VERBOSE */
r_break
suffix:semicolon
r_case
id|KISS_CMD_TXTAIL
suffix:colon
r_if
c_cond
(paren
id|bc-&gt;kiss_decode.wr
OL
l_int|2
)paren
r_break
suffix:semicolon
id|bc-&gt;ch_params.tx_tail
op_assign
id|bc-&gt;kiss_decode.pkt_buf
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#ifdef KISS_VERBOSE
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;baycom: TX tail = %ums&bslash;n&quot;
comma
id|bc-&gt;ch_params.tx_tail
op_star
l_int|10
)paren
suffix:semicolon
macro_line|#endif /* KISS_VERBOSE */
r_break
suffix:semicolon
r_case
id|KISS_CMD_FULLDUP
suffix:colon
r_if
c_cond
(paren
id|bc-&gt;kiss_decode.wr
OL
l_int|2
)paren
r_break
suffix:semicolon
id|bc-&gt;ch_params.fulldup
op_assign
id|bc-&gt;kiss_decode.pkt_buf
(braket
l_int|1
)braket
suffix:semicolon
macro_line|#ifdef KISS_VERBOSE
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;baycom: %s duplex&bslash;n&quot;
comma
id|bc-&gt;ch_params.fulldup
ques
c_cond
l_string|&quot;full&quot;
suffix:colon
l_string|&quot;half&quot;
)paren
suffix:semicolon
macro_line|#endif /* KISS_VERBOSE */
r_break
suffix:semicolon
r_default
suffix:colon
macro_line|#ifdef KISS_VERBOSE
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;baycom: unhandled KISS packet code %u&bslash;n&quot;
comma
id|bc-&gt;kiss_decode.pkt_buf
(braket
l_int|0
)braket
op_amp
l_int|0xf
)paren
suffix:semicolon
macro_line|#endif /* KISS_VERBOSE */
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|baycom_put_char
r_static
r_void
id|baycom_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
r_struct
id|baycom_state
op_star
id|bc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|baycom_paranoia_check
c_func
(paren
id|bc
op_assign
id|tty-&gt;driver_data
comma
l_string|&quot;put_char&quot;
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
id|KISS_FEND
)paren
(brace
id|baycom_put_fend
c_func
(paren
id|bc
)paren
suffix:semicolon
id|bc-&gt;kiss_decode.wr
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;kiss_decode.escaped
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;kiss_decode.dec_state
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bc-&gt;kiss_decode.dec_state
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
id|KISS_FESC
)paren
(brace
id|bc-&gt;kiss_decode.escaped
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bc-&gt;kiss_decode.wr
op_ge
r_sizeof
(paren
id|bc-&gt;kiss_decode.pkt_buf
)paren
)paren
(brace
id|bc-&gt;kiss_decode.wr
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;kiss_decode.dec_state
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bc-&gt;kiss_decode.escaped
)paren
(brace
r_if
c_cond
(paren
id|ch
op_eq
id|KISS_TFEND
)paren
id|bc-&gt;kiss_decode.pkt_buf
(braket
id|bc-&gt;kiss_decode.wr
op_increment
)braket
op_assign
id|KISS_FEND
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ch
op_eq
id|KISS_TFESC
)paren
id|bc-&gt;kiss_decode.pkt_buf
(braket
id|bc-&gt;kiss_decode.wr
op_increment
)braket
op_assign
id|KISS_FESC
suffix:semicolon
r_else
(brace
id|bc-&gt;kiss_decode.wr
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;kiss_decode.dec_state
op_assign
l_int|0
suffix:semicolon
)brace
id|bc-&gt;kiss_decode.escaped
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|bc-&gt;kiss_decode.pkt_buf
(braket
id|bc-&gt;kiss_decode.wr
op_increment
)braket
op_assign
id|ch
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|baycom_write
r_static
r_int
id|baycom_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|c
suffix:semicolon
r_const
r_int
r_char
op_star
id|bp
suffix:semicolon
r_struct
id|baycom_state
op_star
id|bc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
op_logical_neg
id|buf
op_logical_or
id|count
op_le
l_int|0
)paren
r_return
id|count
suffix:semicolon
r_if
c_cond
(paren
id|baycom_paranoia_check
c_func
(paren
id|bc
op_assign
id|tty-&gt;driver_data
comma
l_string|&quot;write&quot;
)paren
)paren
r_return
id|count
suffix:semicolon
r_if
c_cond
(paren
id|from_user
)paren
(brace
r_for
c_loop
(paren
id|c
op_assign
id|count
comma
id|bp
op_assign
id|buf
suffix:semicolon
id|c
OG
l_int|0
suffix:semicolon
id|c
op_decrement
comma
id|bp
op_increment
)paren
(brace
id|baycom_put_char
c_func
(paren
id|tty
comma
id|get_user
c_func
(paren
id|bp
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_for
c_loop
(paren
id|c
op_assign
id|count
comma
id|bp
op_assign
id|buf
suffix:semicolon
id|c
OG
l_int|0
suffix:semicolon
id|c
op_decrement
comma
id|bp
op_increment
)paren
(brace
id|baycom_put_char
c_func
(paren
id|tty
comma
op_star
id|bp
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|baycom_write_room
r_static
r_int
id|baycom_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|free
suffix:semicolon
r_struct
id|baycom_state
op_star
id|bc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|baycom_paranoia_check
c_func
(paren
id|bc
op_assign
id|tty-&gt;driver_data
comma
l_string|&quot;write_room&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|free
op_assign
id|bc-&gt;tx_buf.rd
op_minus
id|bc-&gt;tx_buf.wr
suffix:semicolon
r_if
c_cond
(paren
id|free
op_le
l_int|0
)paren
(brace
id|free
op_assign
id|bc-&gt;tx_buf.buflen
op_minus
id|bc-&gt;tx_buf.wr
suffix:semicolon
r_if
c_cond
(paren
id|free
OL
id|bc-&gt;tx_buf.rd
)paren
id|free
op_assign
id|bc-&gt;tx_buf.rd
suffix:semicolon
multiline_comment|/* we may fold */
)brace
r_return
id|free
op_div
l_int|2
suffix:semicolon
multiline_comment|/* a rather pessimistic estimate */
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|baycom_chars_in_buffer
r_static
r_int
id|baycom_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_struct
id|baycom_state
op_star
id|bc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|baycom_paranoia_check
c_func
(paren
id|bc
op_assign
id|tty-&gt;driver_data
comma
l_string|&quot;chars_in_buffer&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|cnt
op_assign
id|bc-&gt;tx_buf.wr
op_minus
id|bc-&gt;tx_buf.rd
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OL
l_int|0
)paren
id|cnt
op_add_assign
id|bc-&gt;tx_buf.buflen
suffix:semicolon
r_return
id|cnt
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|baycom_flush_buffer
r_static
r_void
id|baycom_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|baycom_state
op_star
id|bc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|baycom_paranoia_check
c_func
(paren
id|bc
op_assign
id|tty-&gt;driver_data
comma
l_string|&quot;flush_buffer&quot;
)paren
)paren
r_return
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|baycom_dealloc_hw
r_static
r_inline
r_void
id|baycom_dealloc_hw
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bc
op_logical_or
id|bc-&gt;magic
op_ne
id|BAYCOM_MAGIC
op_logical_or
id|bc-&gt;modem_type
op_eq
id|BAYCOM_MODEM_INVALID
)paren
r_return
suffix:semicolon
r_switch
c_cond
(paren
id|bc-&gt;modem_type
)paren
(brace
r_case
id|BAYCOM_MODEM_SER12
suffix:colon
id|ser12_deallocate_resources
c_func
(paren
id|bc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BAYCOM_MODEM_PAR96
suffix:colon
id|par96_deallocate_resources
c_func
(paren
id|bc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|baycom_set_hardware
r_static
r_int
id|baycom_set_hardware
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
comma
r_int
r_int
id|modem_type
comma
r_int
r_int
id|iobase
comma
r_int
r_int
id|irq
comma
r_int
r_int
id|options
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|modem_type
op_eq
id|BAYCOM_MODEM_SER12
)paren
(brace
id|i
op_assign
id|ser12_allocate_resources
c_func
(paren
id|iobase
comma
id|irq
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
r_return
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|modem_type
op_eq
id|BAYCOM_MODEM_PAR96
)paren
(brace
id|i
op_assign
id|par96_allocate_resources
c_func
(paren
id|iobase
comma
id|irq
comma
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
r_return
id|i
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|modem_type
op_eq
id|BAYCOM_MODEM_INVALID
)paren
(brace
id|iobase
op_assign
id|irq
op_assign
id|options
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|baycom_dealloc_hw
c_func
(paren
id|bc
)paren
suffix:semicolon
id|bc-&gt;modem_type
op_assign
id|modem_type
suffix:semicolon
id|bc-&gt;iobase
op_assign
id|iobase
suffix:semicolon
id|bc-&gt;irq
op_assign
id|irq
suffix:semicolon
id|bc-&gt;options
op_assign
id|options
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;opened
OG
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|bc-&gt;modem_type
)paren
(brace
r_case
id|BAYCOM_MODEM_SER12
suffix:colon
id|i
op_assign
id|ser12_on_open
c_func
(paren
id|bc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BAYCOM_MODEM_PAR96
suffix:colon
id|i
op_assign
id|par96_on_open
c_func
(paren
id|bc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|baycom_ioctl
r_static
r_int
id|baycom_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|baycom_state
op_star
id|bc
suffix:semicolon
r_struct
id|baycom_params
id|par
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|baycom_paranoia_check
c_func
(paren
id|bc
op_assign
id|tty-&gt;driver_data
comma
l_string|&quot;ioctl&quot;
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_case
id|TIOCMGET
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|i
op_assign
(paren
id|bc-&gt;modem.dcd
ques
c_cond
id|TIOCM_CAR
suffix:colon
l_int|0
)paren
op_or
(paren
id|bc-&gt;hdlc_tx.ptt
ques
c_cond
id|TIOCM_RTS
suffix:colon
l_int|0
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|i
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BAYCOMCTL_GETDCD
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_char
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|put_user
c_func
(paren
id|bc-&gt;modem.dcd
comma
(paren
r_int
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
r_case
id|BAYCOMCTL_GETPTT
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_char
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|put_user
c_func
(paren
id|bc-&gt;hdlc_tx.ptt
comma
(paren
r_int
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
r_case
id|BAYCOMCTL_PARAM_TXDELAY
suffix:colon
r_if
c_cond
(paren
id|arg
OG
l_int|255
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|bc-&gt;ch_params.tx_delay
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BAYCOMCTL_PARAM_PPERSIST
suffix:colon
r_if
c_cond
(paren
id|arg
OG
l_int|255
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|bc-&gt;ch_params.ppersist
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BAYCOMCTL_PARAM_SLOTTIME
suffix:colon
r_if
c_cond
(paren
id|arg
OG
l_int|255
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|bc-&gt;ch_params.slottime
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BAYCOMCTL_PARAM_TXTAIL
suffix:colon
r_if
c_cond
(paren
id|arg
OG
l_int|255
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|bc-&gt;ch_params.tx_tail
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BAYCOMCTL_PARAM_FULLDUP
suffix:colon
id|bc-&gt;ch_params.fulldup
op_assign
id|arg
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BAYCOMCTL_CALIBRATE
suffix:colon
id|bc-&gt;calibrate
op_assign
id|arg
op_star
(paren
(paren
id|bc-&gt;modem_type
op_eq
id|BAYCOM_MODEM_PAR96
)paren
ques
c_cond
l_int|600
suffix:colon
l_int|75
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BAYCOMCTL_GETPARAMS
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|par
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|par.modem_type
op_assign
id|bc-&gt;modem_type
suffix:semicolon
id|par.iobase
op_assign
id|bc-&gt;iobase
suffix:semicolon
id|par.irq
op_assign
id|bc-&gt;irq
suffix:semicolon
id|par.options
op_assign
id|bc-&gt;options
suffix:semicolon
id|par.tx_delay
op_assign
id|bc-&gt;ch_params.tx_delay
suffix:semicolon
id|par.tx_tail
op_assign
id|bc-&gt;ch_params.tx_tail
suffix:semicolon
id|par.slottime
op_assign
id|bc-&gt;ch_params.slottime
suffix:semicolon
id|par.ppersist
op_assign
id|bc-&gt;ch_params.ppersist
suffix:semicolon
id|par.fulldup
op_assign
id|bc-&gt;ch_params.fulldup
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|par
comma
r_sizeof
(paren
id|par
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BAYCOMCTL_SETPARAMS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|par
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|copy_from_user
c_func
(paren
op_amp
id|par
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|par
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;baycom: changing hardware type: modem %u &quot;
l_string|&quot;iobase 0x%x irq %u options 0x%x&bslash;n&quot;
comma
id|par.modem_type
comma
id|par.iobase
comma
id|par.irq
comma
id|par.options
)paren
suffix:semicolon
id|i
op_assign
id|baycom_set_hardware
c_func
(paren
id|bc
comma
id|par.modem_type
comma
id|par.iobase
comma
id|par.irq
comma
id|par.options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|bc-&gt;ch_params.tx_delay
op_assign
id|par.tx_delay
suffix:semicolon
id|bc-&gt;ch_params.tx_tail
op_assign
id|par.tx_tail
suffix:semicolon
id|bc-&gt;ch_params.slottime
op_assign
id|par.slottime
suffix:semicolon
id|bc-&gt;ch_params.ppersist
op_assign
id|par.ppersist
suffix:semicolon
id|bc-&gt;ch_params.fulldup
op_assign
id|par.fulldup
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BAYCOMCTL_GETSTAT
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|baycom_statistics
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|bc-&gt;stat
comma
r_sizeof
(paren
r_struct
id|baycom_statistics
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef BAYCOM_DEBUG
r_case
id|BAYCOMCTL_GETSAMPLES
suffix:colon
r_if
c_cond
(paren
id|bc-&gt;bitbuf_channel.rd
op_eq
id|bc-&gt;bitbuf_channel.wr
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_char
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|put_user
c_func
(paren
id|bc-&gt;bitbuf_channel.buffer
(braket
id|bc-&gt;bitbuf_channel.rd
)braket
comma
(paren
r_int
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
id|bc-&gt;bitbuf_channel.rd
op_assign
(paren
id|bc-&gt;bitbuf_channel.rd
op_plus
l_int|1
)paren
op_mod
r_sizeof
(paren
id|bc-&gt;bitbuf_channel.buffer
)paren
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
r_case
id|BAYCOMCTL_GETBITS
suffix:colon
r_if
c_cond
(paren
id|bc-&gt;bitbuf_hdlc.rd
op_eq
id|bc-&gt;bitbuf_hdlc.wr
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_char
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|put_user
c_func
(paren
id|bc-&gt;bitbuf_hdlc.buffer
(braket
id|bc-&gt;bitbuf_hdlc.rd
)braket
comma
(paren
r_int
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
id|bc-&gt;bitbuf_hdlc.rd
op_assign
(paren
id|bc-&gt;bitbuf_hdlc.rd
op_plus
l_int|1
)paren
op_mod
r_sizeof
(paren
id|bc-&gt;bitbuf_hdlc.buffer
)paren
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
r_case
id|BAYCOMCTL_DEBUG1
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|put_user
c_func
(paren
(paren
id|bc-&gt;rx_buf.wr
op_minus
id|bc-&gt;rx_buf.rd
)paren
op_mod
id|bc-&gt;rx_buf.buflen
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
r_case
id|BAYCOMCTL_DEBUG2
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|put_user
c_func
(paren
id|bc-&gt;debug_vals.last_intcnt
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
r_case
id|BAYCOMCTL_DEBUG3
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|put_user
c_func
(paren
(paren
r_int
)paren
id|bc-&gt;debug_vals.last_pllcorr
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
macro_line|#endif /* BAYCOM_DEBUG */
)brace
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|baycom_open
r_int
id|baycom_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|line
suffix:semicolon
r_struct
id|baycom_state
op_star
id|bc
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|line
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
suffix:semicolon
r_if
c_cond
(paren
id|line
OL
l_int|0
op_logical_or
id|line
op_ge
id|NR_PORTS
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|bc
op_assign
id|baycom_state
op_plus
id|line
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;opened
OG
l_int|0
)paren
(brace
id|bc-&gt;opened
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * initialise some variables&n;&t; */
id|bc-&gt;calibrate
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * allocate the buffer space&n;&t; */
r_if
c_cond
(paren
id|bc-&gt;rx_buf.buffer
)paren
id|kfree_s
c_func
(paren
id|bc-&gt;rx_buf.buffer
comma
id|bc-&gt;rx_buf.buflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;tx_buf.buffer
)paren
id|kfree_s
c_func
(paren
id|bc-&gt;tx_buf.buffer
comma
id|bc-&gt;tx_buf.buflen
)paren
suffix:semicolon
id|bc-&gt;rx_buf.buflen
op_assign
id|BUFLEN_RX
suffix:semicolon
id|bc-&gt;tx_buf.buflen
op_assign
id|BUFLEN_TX
suffix:semicolon
id|bc-&gt;rx_buf.rd
op_assign
id|bc-&gt;rx_buf.wr
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;tx_buf.rd
op_assign
id|bc-&gt;tx_buf.wr
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;rx_buf.buffer
op_assign
id|kmalloc
c_func
(paren
id|bc-&gt;rx_buf.buflen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|bc-&gt;tx_buf.buffer
op_assign
id|kmalloc
c_func
(paren
id|bc-&gt;tx_buf.buflen
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc-&gt;rx_buf.buffer
op_logical_or
op_logical_neg
id|bc-&gt;tx_buf.buffer
)paren
(brace
r_if
c_cond
(paren
id|bc-&gt;rx_buf.buffer
)paren
id|kfree_s
c_func
(paren
id|bc-&gt;rx_buf.buffer
comma
id|bc-&gt;rx_buf.buflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;tx_buf.buffer
)paren
id|kfree_s
c_func
(paren
id|bc-&gt;tx_buf.buffer
comma
id|bc-&gt;tx_buf.buflen
)paren
suffix:semicolon
id|bc-&gt;rx_buf.buffer
op_assign
id|bc-&gt;tx_buf.buffer
op_assign
l_int|NULL
suffix:semicolon
id|bc-&gt;rx_buf.buflen
op_assign
id|bc-&gt;tx_buf.buflen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * check if the modem type has been set&n;&t; */
r_switch
c_cond
(paren
id|bc-&gt;modem_type
)paren
(brace
r_case
id|BAYCOM_MODEM_SER12
suffix:colon
id|i
op_assign
id|ser12_on_open
c_func
(paren
id|bc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BAYCOM_MODEM_PAR96
suffix:colon
id|i
op_assign
id|par96_on_open
c_func
(paren
id|bc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BAYCOM_MODEM_INVALID
suffix:colon
multiline_comment|/*&n;&t;&t; * may open even if no hardware specified, in order to&n;&t;&t; * subsequently allow the BAYCOMCTL_SETPARAMS ioctl&n;&t;&t; */
id|i
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|bc-&gt;opened
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|tty-&gt;driver_data
op_assign
id|bc
suffix:semicolon
id|bc-&gt;tty
op_assign
id|tty
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|baycom_close
r_static
r_void
id|baycom_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|baycom_state
op_star
id|bc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|baycom_paranoia_check
c_func
(paren
id|bc
op_assign
id|tty-&gt;driver_data
comma
l_string|&quot;close&quot;
)paren
)paren
r_return
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|bc-&gt;opened
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;opened
op_le
l_int|0
)paren
(brace
r_switch
c_cond
(paren
id|bc-&gt;modem_type
)paren
(brace
r_case
id|BAYCOM_MODEM_SER12
suffix:colon
id|ser12_on_close
c_func
(paren
id|bc
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BAYCOM_MODEM_PAR96
suffix:colon
id|par96_on_close
c_func
(paren
id|bc
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tty-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
id|bc-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|bc-&gt;opened
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * free the buffers &n;&t;&t; */
id|bc-&gt;rx_buf.rd
op_assign
id|bc-&gt;rx_buf.wr
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;tx_buf.rd
op_assign
id|bc-&gt;tx_buf.wr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;rx_buf.buffer
)paren
id|kfree_s
c_func
(paren
id|bc-&gt;rx_buf.buffer
comma
id|bc-&gt;rx_buf.buflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;tx_buf.buffer
)paren
id|kfree_s
c_func
(paren
id|bc-&gt;tx_buf.buffer
comma
id|bc-&gt;tx_buf.buflen
)paren
suffix:semicolon
id|bc-&gt;rx_buf.buffer
op_assign
id|bc-&gt;tx_buf.buffer
op_assign
l_int|NULL
suffix:semicolon
id|bc-&gt;rx_buf.buflen
op_assign
id|bc-&gt;tx_buf.buflen
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * And now the modules code and kernel interface.&n; */
DECL|function|init_channel
r_static
r_void
id|init_channel
c_func
(paren
r_struct
id|baycom_state
op_star
id|bc
)paren
(brace
r_struct
id|access_params
id|dflt_ch_params
op_assign
(brace
l_int|20
comma
l_int|2
comma
l_int|10
comma
l_int|40
comma
l_int|0
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bc
)paren
r_return
suffix:semicolon
id|bc-&gt;hdlc_rx.rx_state
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;hdlc_tx.tx_state
op_assign
id|bc-&gt;hdlc_tx.numflags
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;hdlc_tx.bitstream
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;hdlc_tx.current_byte
op_assign
id|bc-&gt;hdlc_tx.ptt
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|bc-&gt;modem
comma
l_int|0
comma
r_sizeof
(paren
id|bc-&gt;modem
)paren
)paren
suffix:semicolon
macro_line|#ifdef BAYCOM_DEBUG
id|bc-&gt;bitbuf_channel.rd
op_assign
id|bc-&gt;bitbuf_channel.wr
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;bitbuf_channel.shreg
op_assign
l_int|0x80
suffix:semicolon
id|bc-&gt;bitbuf_hdlc.rd
op_assign
id|bc-&gt;bitbuf_hdlc.wr
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;bitbuf_hdlc.shreg
op_assign
l_int|0x80
suffix:semicolon
macro_line|#endif /* BAYCOM_DEBUG */
id|bc-&gt;kiss_decode.dec_state
op_assign
id|bc-&gt;kiss_decode.escaped
op_assign
id|bc-&gt;kiss_decode.wr
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;ch_params
op_assign
id|dflt_ch_params
suffix:semicolon
macro_line|#ifdef BAYCOM_USE_BH
id|bc-&gt;tq_receiver.next
op_assign
id|bc-&gt;tq_transmitter.next
op_assign
id|bc-&gt;tq_arbitrate.next
op_assign
l_int|NULL
suffix:semicolon
id|bc-&gt;tq_receiver.sync
op_assign
id|bc-&gt;tq_transmitter.sync
op_assign
id|bc-&gt;tq_arbitrate.sync
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;tq_receiver.data
op_assign
id|bc-&gt;tq_transmitter.data
op_assign
id|bc-&gt;tq_arbitrate.data
op_assign
id|bc
suffix:semicolon
id|bc-&gt;tq_receiver.routine
op_assign
id|bh_receiver
suffix:semicolon
id|bc-&gt;tq_transmitter.routine
op_assign
id|bh_transmitter
suffix:semicolon
id|bc-&gt;tq_arbitrate.routine
op_assign
id|bh_arbitrate
suffix:semicolon
macro_line|#endif /* BAYCOM_USE_BH */
)brace
DECL|function|init_datastructs
r_static
r_void
id|init_datastructs
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|baycom_state
op_star
id|bc
op_assign
id|baycom_state
op_plus
id|i
suffix:semicolon
id|bc-&gt;magic
op_assign
id|BAYCOM_MAGIC
suffix:semicolon
id|bc-&gt;modem_type
op_assign
id|BAYCOM_MODEM_INVALID
suffix:semicolon
id|bc-&gt;iobase
op_assign
id|bc-&gt;irq
op_assign
id|bc-&gt;options
op_assign
id|bc-&gt;opened
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
id|bc-&gt;rx_buf.rd
op_assign
id|bc-&gt;rx_buf.wr
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;rx_buf.buflen
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;rx_buf.buffer
op_assign
l_int|NULL
suffix:semicolon
id|bc-&gt;tx_buf.rd
op_assign
id|bc-&gt;tx_buf.wr
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;tx_buf.buflen
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;tx_buf.buffer
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|bc-&gt;stat
comma
l_int|0
comma
r_sizeof
(paren
id|bc-&gt;stat
)paren
)paren
suffix:semicolon
id|init_channel
c_func
(paren
id|bc
)paren
suffix:semicolon
)brace
)brace
DECL|function|baycom_init
r_int
id|baycom_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/*&n;&t; * initialize the data structures&n;&t; */
id|init_datastructs
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * initialize bottom half handler&n; &t; */
macro_line|#ifdef BAYCOM_USE_BH
id|init_bh
c_func
(paren
id|BAYCOM_BH
comma
id|baycom_bottom_half
)paren
suffix:semicolon
macro_line|#endif /* BAYCOM_USE_BH */
multiline_comment|/*&n;&t; * register the driver as tty driver&n;&t; */
id|memset
c_func
(paren
op_amp
id|baycom_driver
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|baycom_driver.magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
id|baycom_driver.name
op_assign
l_string|&quot;baycom&quot;
suffix:semicolon
id|baycom_driver.major
op_assign
id|major
suffix:semicolon
id|baycom_driver.minor_start
op_assign
l_int|0
suffix:semicolon
id|baycom_driver.num
op_assign
id|NR_PORTS
suffix:semicolon
id|baycom_driver.type
op_assign
id|TTY_DRIVER_TYPE_BAYCOM
suffix:semicolon
id|baycom_driver.subtype
op_assign
id|BAYCOM_TYPE_NORMAL
suffix:semicolon
id|baycom_driver.init_termios.c_iflag
op_assign
l_int|0
suffix:semicolon
id|baycom_driver.init_termios.c_oflag
op_assign
l_int|0
suffix:semicolon
id|baycom_driver.init_termios.c_cflag
op_assign
id|CS8
op_or
id|B1200
op_or
id|CREAD
op_or
id|CLOCAL
suffix:semicolon
id|baycom_driver.init_termios.c_lflag
op_assign
l_int|0
suffix:semicolon
id|baycom_driver.flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
id|baycom_driver.refcount
op_assign
op_amp
id|baycom_refcount
suffix:semicolon
id|baycom_driver.table
op_assign
id|baycom_table
suffix:semicolon
id|baycom_driver.termios
op_assign
id|baycom_termios
suffix:semicolon
id|baycom_driver.termios_locked
op_assign
id|baycom_termios_locked
suffix:semicolon
multiline_comment|/*&n;&t; * the functions&n;&t; */
id|baycom_driver.open
op_assign
id|baycom_open
suffix:semicolon
id|baycom_driver.close
op_assign
id|baycom_close
suffix:semicolon
id|baycom_driver.write
op_assign
id|baycom_write
suffix:semicolon
id|baycom_driver.put_char
op_assign
id|baycom_put_char
suffix:semicolon
id|baycom_driver.flush_chars
op_assign
l_int|NULL
suffix:semicolon
id|baycom_driver.write_room
op_assign
id|baycom_write_room
suffix:semicolon
id|baycom_driver.chars_in_buffer
op_assign
id|baycom_chars_in_buffer
suffix:semicolon
id|baycom_driver.flush_buffer
op_assign
id|baycom_flush_buffer
suffix:semicolon
id|baycom_driver.ioctl
op_assign
id|baycom_ioctl
suffix:semicolon
multiline_comment|/*&n;&t; * cannot throttle the transmitter on this layer&n;&t; */
id|baycom_driver.throttle
op_assign
l_int|NULL
suffix:semicolon
id|baycom_driver.unthrottle
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * no special actions on termio changes&n;&t; */
id|baycom_driver.set_termios
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * no XON/XOFF and no hangup on the radio port&n;&t; */
id|baycom_driver.stop
op_assign
l_int|NULL
suffix:semicolon
id|baycom_driver.start
op_assign
l_int|NULL
suffix:semicolon
id|baycom_driver.hangup
op_assign
l_int|NULL
suffix:semicolon
id|baycom_driver.set_ldisc
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|baycom_driver
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;baycom: tty_register_driver failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_PORTS
op_logical_and
id|baycom_ports
(braket
id|i
)braket
dot
id|modem
op_ne
id|BAYCOM_MODEM_INVALID
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_assign
id|baycom_set_hardware
c_func
(paren
id|baycom_state
op_plus
id|i
comma
id|baycom_ports
(braket
id|i
)braket
dot
id|modem
comma
id|baycom_ports
(braket
id|i
)braket
dot
id|iobase
comma
id|baycom_ports
(braket
id|i
)braket
dot
id|irq
comma
id|baycom_ports
(braket
id|i
)braket
dot
id|options
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
l_int|0
)paren
(brace
r_const
r_char
op_star
id|s
suffix:semicolon
r_switch
c_cond
(paren
op_minus
id|j
)paren
(brace
r_case
id|ENXIO
suffix:colon
id|s
op_assign
l_string|&quot;invalid iobase and/or irq&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EACCES
suffix:colon
id|s
op_assign
l_string|&quot;io region already used&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EIO
suffix:colon
id|s
op_assign
l_string|&quot;no uart/lpt port at iobase&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EBUSY
suffix:colon
id|s
op_assign
l_string|&quot;interface already in use&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EINVAL
suffix:colon
id|s
op_assign
l_string|&quot;internal error&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|s
op_assign
l_string|&quot;unknown error&quot;
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;baycom: modem %u iobase 0x%x &quot;
l_string|&quot;irq %u: (%i) %s&bslash;n&quot;
comma
id|baycom_ports
(braket
id|i
)braket
dot
id|modem
comma
id|baycom_ports
(braket
id|i
)braket
dot
id|iobase
comma
id|baycom_ports
(braket
id|i
)braket
dot
id|irq
comma
id|j
comma
id|s
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
macro_line|#ifdef MODULE
DECL|variable|modem
r_int
id|modem
op_assign
id|BAYCOM_MODEM_INVALID
suffix:semicolon
DECL|variable|iobase
r_int
id|iobase
op_assign
l_int|0x3f8
suffix:semicolon
DECL|variable|irq
r_int
id|irq
op_assign
l_int|4
suffix:semicolon
DECL|variable|options
r_int
id|options
op_assign
id|BAYCOM_OPTIONS_SOFTDCD
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;baycom: init_module called&bslash;n&quot;
)paren
suffix:semicolon
id|baycom_ports
(braket
l_int|0
)braket
dot
id|modem
op_assign
id|modem
suffix:semicolon
id|baycom_ports
(braket
l_int|0
)braket
dot
id|iobase
op_assign
id|iobase
suffix:semicolon
id|baycom_ports
(braket
l_int|0
)braket
dot
id|irq
op_assign
id|irq
suffix:semicolon
id|baycom_ports
(braket
l_int|0
)braket
dot
id|options
op_assign
id|options
suffix:semicolon
id|baycom_ports
(braket
l_int|1
)braket
dot
id|modem
op_assign
id|BAYCOM_MODEM_INVALID
suffix:semicolon
id|i
op_assign
id|baycom_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;baycom: version 0.3; &quot;
l_string|&quot;(C) 1996 by Thomas Sailer HB9JNX, sailer@ife.ee.ethz.ch&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* --------------------------------------------------------------------- */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;baycom: cleanup_module called&bslash;n&quot;
)paren
suffix:semicolon
id|disable_bh
c_func
(paren
id|BAYCOM_BH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty_unregister_driver
c_func
(paren
op_amp
id|baycom_driver
)paren
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;baycom: failed to unregister tty &quot;
l_string|&quot;driver&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|baycom_state
op_star
id|bc
op_assign
id|baycom_state
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;magic
op_ne
id|BAYCOM_MAGIC
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;baycom: invalid magic in &quot;
l_string|&quot;cleanup_module&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|baycom_dealloc_hw
c_func
(paren
id|bc
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * free the buffers &n;&t;&t;&t; */
id|bc-&gt;rx_buf.rd
op_assign
id|bc-&gt;rx_buf.wr
op_assign
l_int|0
suffix:semicolon
id|bc-&gt;tx_buf.rd
op_assign
id|bc-&gt;tx_buf.wr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;rx_buf.buffer
)paren
id|kfree_s
c_func
(paren
id|bc-&gt;rx_buf.buffer
comma
id|bc-&gt;rx_buf.buflen
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bc-&gt;tx_buf.buffer
)paren
id|kfree_s
c_func
(paren
id|bc-&gt;tx_buf.buffer
comma
id|bc-&gt;tx_buf.buflen
)paren
suffix:semicolon
id|bc-&gt;rx_buf.buffer
op_assign
id|bc-&gt;tx_buf.buffer
op_assign
l_int|NULL
suffix:semicolon
id|bc-&gt;rx_buf.buflen
op_assign
id|bc-&gt;tx_buf.buflen
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
macro_line|#else /* MODULE */
multiline_comment|/* --------------------------------------------------------------------- */
multiline_comment|/*&n; * format: baycom=modem,io,irq,options[,modem,io,irq,options]&n; * modem=1: ser12, modem=2: par96&n; * options=0: hardware DCD, options=1: software DCD&n; */
DECL|function|baycom_setup
r_void
id|baycom_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_PORTS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|4
op_star
id|i
op_plus
l_int|4
)paren
(brace
id|baycom_ports
(braket
id|i
)braket
dot
id|modem
op_assign
id|ints
(braket
l_int|4
op_star
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|baycom_ports
(braket
id|i
)braket
dot
id|iobase
op_assign
id|ints
(braket
l_int|4
op_star
id|i
op_plus
l_int|2
)braket
suffix:semicolon
id|baycom_ports
(braket
id|i
)braket
dot
id|irq
op_assign
id|ints
(braket
l_int|4
op_star
id|i
op_plus
l_int|3
)braket
suffix:semicolon
id|baycom_ports
(braket
id|i
)braket
dot
id|options
op_assign
id|ints
(braket
l_int|4
op_star
id|i
op_plus
l_int|4
)braket
suffix:semicolon
)brace
r_else
id|baycom_ports
(braket
id|i
)braket
dot
id|modem
op_assign
id|BAYCOM_MODEM_INVALID
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/* --------------------------------------------------------------------- */
eof
