multiline_comment|/*&n;&n;&t;Hardware driver for Intel i810 Random Number Generator (RNG)&n;&t;Copyright 2000 Jeff Garzik &lt;jgarzik@mandrakesoft.com&gt;&n;&t;Copyright 2000 Philipp Rumpf &lt;prumpf@tux.org&gt;&n;&n;&t;Driver Web site:  http://gtf.org/garzik/drivers/i810_rng/&n;&n;&n;&n;&t;Based on:&n;&t;Intel 82802AB/82802AC Firmware Hub (FWH) Datasheet&n;&t;&t;May 1999 Order Number: 290658-002 R&n;&n;&t;Intel 82802 Firmware Hub: Random Number Generator&n;&t;Programmer&squot;s Reference Manual&n;&t;&t;December 1999 Order Number: 298029-001 R&n;&n;&t;Intel 82802 Firmware HUB Random Number Generator Driver&n;&t;Copyright (c) 2000 Matt Sottek &lt;msottek@quiknet.com&gt;&n;&n;&t;Special thanks to Matt Sottek.  I did the &quot;guts&quot;, he&n;&t;did the &quot;brains&quot; and all the testing.  (Anybody wanna send&n;&t;me an i810 or i820?)&n;&n;&t;----------------------------------------------------------&n;&n;&t;This software may be used and distributed according to the terms&n;        of the GNU Public License, incorporated herein by reference.&n;&n;&t;----------------------------------------------------------&n;&n;&t;From the firmware hub datasheet:&n;&n;&t;The Firmware Hub integrates a Random Number Generator (RNG)&n;&t;using thermal noise generated from inherently random quantum&n;&t;mechanical properties of silicon. When not generating new random&n;&t;bits the RNG circuitry will enter a low power state. Intel will&n;&t;provide a binary software driver to give third party software&n;&t;access to our RNG for use as a security feature. At this time,&n;&t;the RNG is only to be used with a system in an OS-present state.&n;&n;&t;----------------------------------------------------------&n;&n;&t;Theory of operation:&n;&n;&t;This driver has TWO modes of operation:&n;&n;&t;Mode 1&n;&t;------&n;&t;Character driver.  Using the standard open()&n;&t;and read() system calls, you can read random data from&n;&t;the i810 RNG device.  This data is NOT CHECKED by any&n;&t;fitness tests, and could potentially be bogus (if the&n;&t;hardware is faulty or has been tampered with).&n;&n;&t;/dev/intel_rng is char device major 10, minor 183.&n;&n;&n;&t;Mode 2&n;&t;------&n;&t;Injection of entropy into the kernel entropy pool via a&n;&t;timer function.&n;&n;&t;A timer is run at rng_timer_len intervals, reading 8 bits&n;&t;of data from the RNG.  If the RNG has previously passed a&n;&t;FIPS test, then the data will be added to the /dev/random&n;&t;entropy pool.  Then, those 8 bits are added to an internal&n;&t;test data pool.  When that pool is full, a FIPS test is&n;&t;run to verify that the last N bytes read are decently random.&n;&n;&t;Thus, the RNG will never be enabled until it passes a&n;&t;FIPS test.  And, data will stop flowing into the system&n;&t;entropy pool if the data is determined to be non-random.&n;&n;&t;Finally, note that the timer defaults to OFF.  This ensures&n;&t;that the system entropy pool will not be polluted with&n;&t;RNG-originated data unless a conscious decision is made&n;&t;by the user.&n;&n;&t;HOWEVER NOTE THAT UP TO 2499 BYTES OF DATA CAN BE BOGUS&n;&t;BEFORE THE SYSTEM WILL NOTICE VIA THE FIPS TEST.&n;&n;&t;----------------------------------------------------------&n;&n;&t;Driver notes:&n;&n;&t;* You may enable and disable the RNG timer via sysctl:&n;&n;&t;&t;# disable RNG&n;&t;&t;echo 0 &gt; /proc/sys/dev/i810_rng_timer&n;&n;&t;&t;# enable RNG&n;&t;&t;echo 1 &gt; /proc/sys/dev/i810_rng_timer&n;&n;&t;* The default number of entropy bits added by default is&n;&t;the full 8 bits.  If you wish to reduce this value for&n;&t;paranoia&squot;s sake, you can do so via sysctl as well:&n;&n;&t;&t;# Add only 4 bits of entropy to /dev/random&n;&t;&t;echo 4 &gt; /proc/sys/dev/i810_rng_entropy&n;&n;&t;* The default number of entropy bits can also be set via&n;&t;a module parameter &quot;rng_entropy&quot; at module load time.&n;&n;&t;* When the RNG timer is enabled, the driver reads 1 byte&n;&t;from the hardware RNG every N jiffies.  By default, every&n;&t;half-second.  If you would like to change the timer interval,&n;&t;do so via another sysctl:&n;&n;&t;&t;echo 200 &gt; /proc/sys/dev/i810_rng_interval&n;&n;&t;NOTE THIS VALUE IS IN JIFFIES, NOT SECONDS OR MILLISECONDS.&n;&t;Minimum interval is 1 jiffy, maximum interval is 24 hours.&n;&n;&t;* In order to unload the i810_rng module, you must first&n;&t;disable the hardware via sysctl i810_hw_enabled, as shown above,&n;&t;and make sure all users of the character device have closed&n;&n;&t;* The timer and the character device may be used simultaneously,&n;&t;if desired.&n;&n;&t;* FIXME: support poll()&n;&n;&t;* FIXME: should we be crazy and support mmap()?&n;&n;&t;* FIXME: It is possible for the timer function to read,&n;&t;and shove into the kernel entropy pool, 2499 bytes of data&n;&t;before the internal FIPS test notices that the data is bad.&n;&t;The kernel should handle this (I think???), but we should use a&n;&t;2500-byte array, and re-run the FIPS test for every byte read.&n;&t;This will slow things down but guarantee that bad data is&n;&t;never passed upstream.&n;&n;&t;* FIXME: module unload is racy.  To fix this, struct ctl_table&n;&t;needs an owner member a la struct file_operations.&n;&n;&t;* Since the RNG is accessed from a timer as well as normal&n;&t;kernel code, but not from interrupts, we use spin_lock_bh&n;&t;in regular code, and spin_lock in the timer function, to&n;&t;serialize access to the RNG hardware area.&n;&n;&t;----------------------------------------------------------&n;&n;&t;Change history:&n;&n;&t;Version 0.6.2:&n;&t;* Clean up spinlocks.  Since we don&squot;t have any interrupts&n;&t;  to worry about, but we do have a timer to worry about,&n;&t;  we use spin_lock_bh everywhere except the timer function&n;&t;  itself.&n;&t;* Fix module load/unload.&n;&t;* Fix timer function and h/w enable/disable logic&n;&t;* New timer interval sysctl&n;&t;* Clean up sysctl names&n;&n;&t;Version 0.9.0:&n;&t;* Don&squot;t register a pci_driver, because we are really&n;&t;  using PCI bridge vendor/device ids, and someone&n;&t;  may want to register a driver for the bridge. (bug fix)&n;&t;* Don&squot;t let the usage count go negative (bug fix)&n;&t;* Clean up spinlocks (bug fix)&n;&t;* Enable PCI device, if necessary (bug fix)&n;&t;* iounmap on module unload (bug fix)&n;&t;* If RNG chrdev is already in use when open(2) is called,&n;&t;  sleep until it is available.&n;&t;* Remove redundant globals rng_allocated, rng_use_count&n;&t;* Convert numeric globals to unsigned&n;&t;* Module unload cleanup&n;&n;&t;Version 0.9.1:&n;&t;* Support i815 chipsets too (Matt Sottek)&n;&t;* Fix reference counting when statically compiled (prumpf)&n;&t;* Rewrite rng_dev_read (prumpf)&n;&t;* Make module races less likely (prumpf)&n;&t;* Small miscellaneous bug fixes (prumpf)&n;&t;* Use pci table for PCI id list&n;&n;&t;Version 0.9.2:&n;&t;* Simplify open blocking logic&n;&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/sysctl.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/*&n; * core module and version information&n; */
DECL|macro|RNG_VERSION
mdefine_line|#define RNG_VERSION &quot;0.9.2&quot;
DECL|macro|RNG_MODULE_NAME
mdefine_line|#define RNG_MODULE_NAME &quot;i810_rng&quot;
DECL|macro|RNG_DRIVER_NAME
mdefine_line|#define RNG_DRIVER_NAME   RNG_MODULE_NAME &quot; hardware driver &quot; RNG_VERSION
DECL|macro|PFX
mdefine_line|#define PFX RNG_MODULE_NAME &quot;: &quot;
multiline_comment|/*&n; * debugging macros&n; */
DECL|macro|RNG_DEBUG
macro_line|#undef RNG_DEBUG /* define to 1 to enable copious debugging info */
macro_line|#ifdef RNG_DEBUG
multiline_comment|/* note: prints function name for you */
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(fmt, args...) printk(KERN_DEBUG &quot;%s: &quot; fmt, __FUNCTION__ , ## args)
macro_line|#else
DECL|macro|DPRINTK
mdefine_line|#define DPRINTK(fmt, args...)
macro_line|#endif
DECL|macro|RNG_NDEBUG
mdefine_line|#define RNG_NDEBUG 0        /* define to 1 to disable lightweight runtime checks */
macro_line|#if RNG_NDEBUG
DECL|macro|assert
mdefine_line|#define assert(expr)
macro_line|#else
DECL|macro|assert
mdefine_line|#define assert(expr) &bslash;&n;        if(!(expr)) {                                   &bslash;&n;        printk( &quot;Assertion failed! %s,%s,%s,line=%d&bslash;n&quot;, &bslash;&n;        #expr,__FILE__,__FUNCTION__,__LINE__);          &bslash;&n;        }
macro_line|#endif
multiline_comment|/*&n; * prototypes&n; */
r_static
r_void
id|rng_fips_test_store
(paren
r_int
id|rng_data
)paren
suffix:semicolon
r_static
r_void
id|rng_run_fips_test
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * RNG registers (offsets from rng_mem)&n; */
DECL|macro|RNG_HW_STATUS
mdefine_line|#define RNG_HW_STATUS&t;&t;&t;0
DECL|macro|RNG_PRESENT
mdefine_line|#define&t;&t;RNG_PRESENT&t;&t;0x40
DECL|macro|RNG_ENABLED
mdefine_line|#define&t;&t;RNG_ENABLED&t;&t;0x01
DECL|macro|RNG_STATUS
mdefine_line|#define RNG_STATUS&t;&t;&t;1
DECL|macro|RNG_DATA_PRESENT
mdefine_line|#define&t;&t;RNG_DATA_PRESENT&t;0x01
DECL|macro|RNG_DATA
mdefine_line|#define RNG_DATA&t;&t;&t;2
DECL|macro|RNG_ADDR
mdefine_line|#define RNG_ADDR&t;&t;&t;0xFFBC015F
DECL|macro|RNG_ADDR_LEN
mdefine_line|#define RNG_ADDR_LEN&t;&t;&t;3
DECL|macro|RNG_MAX_ENTROPY
mdefine_line|#define RNG_MAX_ENTROPY&t;&t;&t;8 /* max entropy h/w is capable of */
DECL|macro|RNG_MISCDEV_MINOR
mdefine_line|#define RNG_MISCDEV_MINOR&t;&t;183 /* official */
multiline_comment|/*&n; * Frequency that data is added to kernel entropy pool&n; * HZ&gt;&gt;1 == every half-second&n; */
DECL|macro|RNG_DEF_TIMER_LEN
mdefine_line|#define RNG_DEF_TIMER_LEN&t;&t;(HZ &gt;&gt; 1)
multiline_comment|/*&n; * number of bytes required for a FIPS test.&n; * do not alter unless you really, I mean&n; * REALLY know what you are doing.&n; */
DECL|macro|RNG_FIPS_TEST_THRESHOLD
mdefine_line|#define RNG_FIPS_TEST_THRESHOLD&t;2500
multiline_comment|/*&n; * various RNG status variables.  they are globals&n; * as we only support a single RNG device&n; */
DECL|variable|rng_hw_enabled
r_static
r_int
id|rng_hw_enabled
suffix:semicolon
multiline_comment|/* is the RNG h/w enabled? */
DECL|variable|rng_timer_enabled
r_static
r_int
id|rng_timer_enabled
suffix:semicolon
multiline_comment|/* is the RNG timer enabled? */
DECL|variable|rng_trusted
r_static
r_int
id|rng_trusted
suffix:semicolon
multiline_comment|/* does FIPS trust out data? */
DECL|variable|rng_enabled_sysctl
r_static
r_int
id|rng_enabled_sysctl
suffix:semicolon
multiline_comment|/* sysctl for enabling/disabling RNG */
DECL|variable|rng_entropy
r_static
r_int
r_int
id|rng_entropy
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* number of entropy bits we submit to /dev/random */
DECL|variable|rng_entropy_sysctl
r_static
r_int
r_int
id|rng_entropy_sysctl
suffix:semicolon
multiline_comment|/* sysctl for changing entropy bits */
DECL|variable|rng_interval_sysctl
r_static
r_int
r_int
id|rng_interval_sysctl
suffix:semicolon
multiline_comment|/* sysctl for changing timer interval */
DECL|variable|rng_have_mem_region
r_static
r_int
id|rng_have_mem_region
suffix:semicolon
multiline_comment|/* did we grab RNG region via request_mem_region? */
DECL|variable|rng_fips_counter
r_static
r_int
r_int
id|rng_fips_counter
suffix:semicolon
multiline_comment|/* size of internal FIPS test data pool */
DECL|variable|rng_timer_len
r_static
r_int
r_int
id|rng_timer_len
op_assign
id|RNG_DEF_TIMER_LEN
suffix:semicolon
multiline_comment|/* timer interval, in jiffies */
DECL|variable|rng_mem
r_static
r_void
op_star
id|rng_mem
suffix:semicolon
multiline_comment|/* token to our ioremap&squot;d RNG register area */
DECL|variable|rng_lock
r_static
id|spinlock_t
id|rng_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* hardware lock */
DECL|variable|rng_timer
r_static
r_struct
id|timer_list
id|rng_timer
suffix:semicolon
multiline_comment|/* kernel timer for RNG hardware reads and tests */
DECL|variable|rng_pdev
r_static
r_struct
id|pci_dev
op_star
id|rng_pdev
suffix:semicolon
multiline_comment|/* Firmware Hub PCI device found during PCI probe */
DECL|variable|rng_open_sem
r_static
r_struct
id|semaphore
id|rng_open_sem
suffix:semicolon
multiline_comment|/* Semaphore for serializing rng_open/release */
multiline_comment|/*&n; * inlined helper functions for accessing RNG registers&n; */
DECL|function|rng_hwstatus
r_static
r_inline
id|u8
id|rng_hwstatus
(paren
r_void
)paren
(brace
m_assert
(paren
id|rng_mem
op_ne
l_int|NULL
)paren
suffix:semicolon
r_return
id|readb
(paren
id|rng_mem
op_plus
id|RNG_HW_STATUS
)paren
suffix:semicolon
)brace
DECL|function|rng_hwstatus_set
r_static
r_inline
r_void
id|rng_hwstatus_set
(paren
id|u8
id|hw_status
)paren
(brace
m_assert
(paren
id|rng_mem
op_ne
l_int|NULL
)paren
suffix:semicolon
id|writeb
(paren
id|hw_status
comma
id|rng_mem
op_plus
id|RNG_HW_STATUS
)paren
suffix:semicolon
)brace
DECL|function|rng_data_present
r_static
r_inline
r_int
id|rng_data_present
(paren
r_void
)paren
(brace
m_assert
(paren
id|rng_mem
op_ne
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
id|rng_hw_enabled
op_eq
l_int|1
)paren
suffix:semicolon
r_return
(paren
id|readb
(paren
id|rng_mem
op_plus
id|RNG_STATUS
)paren
op_amp
id|RNG_DATA_PRESENT
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|rng_data_read
r_static
r_inline
r_int
id|rng_data_read
(paren
r_void
)paren
(brace
m_assert
(paren
id|rng_mem
op_ne
l_int|NULL
)paren
suffix:semicolon
m_assert
(paren
id|rng_hw_enabled
op_eq
l_int|1
)paren
suffix:semicolon
r_return
id|readb
(paren
id|rng_mem
op_plus
id|RNG_DATA
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * rng_timer_ticker - executes every rng_timer_len jiffies,&n; *&t;&t;      adds a single byte to system entropy&n; *&t;&t;      and internal FIPS test pools&n; */
DECL|function|rng_timer_tick
r_static
r_void
id|rng_timer_tick
(paren
r_int
r_int
id|data
)paren
(brace
r_int
id|rng_data
suffix:semicolon
id|spin_lock
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rng_data_present
(paren
)paren
)paren
(brace
multiline_comment|/* gimme some thermal noise, baby */
id|rng_data
op_assign
id|rng_data_read
(paren
)paren
suffix:semicolon
id|spin_unlock
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * if RNG has been verified in the past, add&n;&t;&t; * data just read to the /dev/random pool,&n;&t;&t; * with the entropy specified by the user&n;&t;&t; * via sysctl (defaults to 8 bits)&n;&t;&t; */
r_if
c_cond
(paren
id|rng_trusted
)paren
id|batch_entropy_store
(paren
id|rng_data
comma
id|jiffies
comma
id|rng_entropy
)paren
suffix:semicolon
multiline_comment|/* fitness testing via FIPS, if we have enough data */
id|rng_fips_test_store
(paren
id|rng_data
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rng_fips_counter
OG
id|RNG_FIPS_TEST_THRESHOLD
)paren
id|rng_run_fips_test
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* run the timer again, if enabled */
r_if
c_cond
(paren
id|rng_timer_enabled
)paren
(brace
id|rng_timer.expires
op_assign
id|jiffies
op_plus
id|rng_timer_len
suffix:semicolon
id|add_timer
(paren
op_amp
id|rng_timer
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * rng_enable - enable or disable the RNG hardware&n; */
DECL|function|rng_enable
r_static
r_int
id|rng_enable
(paren
r_int
id|enable
)paren
(brace
r_int
id|rc
op_assign
l_int|0
comma
id|action
op_assign
l_int|0
suffix:semicolon
id|u8
id|hw_status
comma
id|new_status
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
id|hw_status
op_assign
id|rng_hwstatus
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|enable
)paren
(brace
id|rng_hw_enabled
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|rng_hw_enabled
)paren
(brace
id|rng_hw_enabled
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rng_hw_enabled
op_logical_and
(paren
(paren
id|hw_status
op_amp
id|RNG_ENABLED
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|rng_hwstatus_set
(paren
id|hw_status
op_or
id|RNG_ENABLED
)paren
suffix:semicolon
id|action
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|rng_hw_enabled
op_logical_and
(paren
id|hw_status
op_amp
id|RNG_ENABLED
)paren
)paren
(brace
id|rng_hwstatus_set
(paren
id|hw_status
op_amp
op_complement
id|RNG_ENABLED
)paren
suffix:semicolon
id|action
op_assign
l_int|2
suffix:semicolon
)brace
id|new_status
op_assign
id|rng_hwstatus
(paren
)paren
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
l_int|1
)paren
id|printk
(paren
id|KERN_INFO
id|PFX
l_string|&quot;RNG h/w enabled&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|action
op_eq
l_int|2
)paren
id|printk
(paren
id|KERN_INFO
id|PFX
l_string|&quot;RNG h/w disabled&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* too bad C doesn&squot;t have ^^ */
r_if
c_cond
(paren
(paren
op_logical_neg
id|enable
)paren
op_ne
(paren
op_logical_neg
(paren
id|new_status
op_amp
id|RNG_ENABLED
)paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|PFX
l_string|&quot;Unable to %sable the RNG&bslash;n&quot;
comma
id|enable
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|DPRINTK
(paren
l_string|&quot;EXIT, returning %d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * rng_handle_sysctl_enable - handle a read or write of our enable/disable sysctl&n; */
DECL|function|rng_handle_sysctl_enable
r_static
r_int
id|rng_handle_sysctl_enable
(paren
id|ctl_table
op_star
id|table
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|lenp
)paren
(brace
r_int
id|enabled_save
comma
id|rc
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
id|rng_enabled_sysctl
op_assign
id|enabled_save
op_assign
id|rng_timer_enabled
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
id|rc
op_assign
id|proc_dointvec
(paren
id|table
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|enabled_save
op_ne
id|rng_enabled_sysctl
)paren
(brace
id|rng_timer_enabled
op_assign
id|rng_enabled_sysctl
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
multiline_comment|/* enable/disable hardware */
id|rng_enable
(paren
id|rng_enabled_sysctl
)paren
suffix:semicolon
multiline_comment|/* enable/disable timer */
r_if
c_cond
(paren
id|rng_enabled_sysctl
)paren
(brace
id|rng_timer.expires
op_assign
id|jiffies
op_plus
id|rng_timer_len
suffix:semicolon
id|add_timer
(paren
op_amp
id|rng_timer
)paren
suffix:semicolon
)brace
r_else
(brace
id|del_timer_sync
(paren
op_amp
id|rng_timer
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|spin_unlock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
)brace
multiline_comment|/* This needs to be in a higher layer */
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;EXIT, returning 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * rng_handle_sysctl_entropy - handle a read or write of our entropy bits sysctl&n; */
DECL|function|rng_handle_sysctl_entropy
r_static
r_int
id|rng_handle_sysctl_entropy
(paren
id|ctl_table
op_star
id|table
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|lenp
)paren
(brace
r_int
id|entropy_bits_save
comma
id|rc
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
id|rng_entropy_sysctl
op_assign
id|entropy_bits_save
op_assign
id|rng_entropy
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
id|rc
op_assign
id|proc_dointvec
(paren
id|table
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|entropy_bits_save
op_eq
id|rng_entropy_sysctl
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rng_entropy_sysctl
op_ge
l_int|0
)paren
op_logical_and
(paren
id|rng_entropy_sysctl
op_le
l_int|8
)paren
)paren
(brace
id|spin_lock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
id|rng_entropy
op_assign
id|rng_entropy_sysctl
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
id|PFX
l_string|&quot;entropy bits now %d&bslash;n&quot;
comma
id|rng_entropy_sysctl
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_INFO
id|PFX
l_string|&quot;ignoring invalid entropy setting (%d)&bslash;n&quot;
comma
id|rng_entropy_sysctl
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|DPRINTK
(paren
l_string|&quot;EXIT, returning 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * rng_handle_sysctl_interval - handle a read or write of our timer interval len sysctl&n; */
DECL|function|rng_handle_sysctl_interval
r_static
r_int
id|rng_handle_sysctl_interval
(paren
id|ctl_table
op_star
id|table
comma
r_int
id|write
comma
r_struct
id|file
op_star
id|filp
comma
r_void
op_star
id|buffer
comma
r_int
op_star
id|lenp
)paren
(brace
r_int
id|timer_len_save
comma
id|rc
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|spin_lock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
id|rng_interval_sysctl
op_assign
id|timer_len_save
op_assign
id|rng_timer_len
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
id|rc
op_assign
id|proc_dointvec
(paren
id|table
comma
id|write
comma
id|filp
comma
id|buffer
comma
id|lenp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|timer_len_save
op_eq
id|rng_interval_sysctl
)paren
r_goto
id|out
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rng_interval_sysctl
OG
l_int|0
)paren
op_logical_and
(paren
id|rng_interval_sysctl
OL
(paren
id|HZ
op_star
l_int|86400
)paren
)paren
)paren
(brace
id|spin_lock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
id|rng_timer_len
op_assign
id|rng_interval_sysctl
suffix:semicolon
id|spin_unlock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
id|PFX
l_string|&quot;timer interval now %d&bslash;n&quot;
comma
id|rng_interval_sysctl
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_INFO
id|PFX
l_string|&quot;ignoring invalid timer interval (%d)&bslash;n&quot;
comma
id|rng_interval_sysctl
)paren
suffix:semicolon
)brace
id|out
suffix:colon
id|DPRINTK
(paren
l_string|&quot;EXIT, returning 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * rng_sysctl - add or remove the rng sysctl&n; */
DECL|function|rng_sysctl
r_static
r_void
id|rng_sysctl
(paren
r_int
id|add
)paren
(brace
DECL|macro|DEV_I810_TIMER
mdefine_line|#define DEV_I810_TIMER&t;&t;1
DECL|macro|DEV_I810_ENTROPY
mdefine_line|#define DEV_I810_ENTROPY&t;2
DECL|macro|DEV_I810_INTERVAL
mdefine_line|#define DEV_I810_INTERVAL&t;3
multiline_comment|/* Definition of the sysctl */
multiline_comment|/* FIXME: use new field:value style of struct initialization */
r_static
id|ctl_table
id|rng_sysctls
(braket
)braket
op_assign
(brace
(brace
id|DEV_I810_TIMER
comma
multiline_comment|/* ID */
id|RNG_MODULE_NAME
l_string|&quot;_timer&quot;
comma
multiline_comment|/* name in /proc */
op_amp
id|rng_enabled_sysctl
comma
r_sizeof
(paren
id|rng_enabled_sysctl
)paren
comma
multiline_comment|/* data ptr, data size */
l_int|0644
comma
multiline_comment|/* mode */
l_int|0
comma
multiline_comment|/* child */
id|rng_handle_sysctl_enable
comma
multiline_comment|/* proc handler */
l_int|0
comma
multiline_comment|/* strategy */
l_int|0
comma
multiline_comment|/* proc control block */
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DEV_I810_ENTROPY
comma
multiline_comment|/* ID */
id|RNG_MODULE_NAME
l_string|&quot;_entropy&quot;
comma
multiline_comment|/* name in /proc */
op_amp
id|rng_entropy_sysctl
comma
r_sizeof
(paren
id|rng_entropy_sysctl
)paren
comma
multiline_comment|/* data ptr, data size */
l_int|0644
comma
multiline_comment|/* mode */
l_int|0
comma
multiline_comment|/* child */
id|rng_handle_sysctl_entropy
comma
multiline_comment|/* proc handler */
l_int|0
comma
multiline_comment|/* strategy */
l_int|0
comma
multiline_comment|/* proc control block */
l_int|0
comma
l_int|0
)brace
comma
(brace
id|DEV_I810_INTERVAL
comma
multiline_comment|/* ID */
id|RNG_MODULE_NAME
l_string|&quot;_interval&quot;
comma
multiline_comment|/* name in /proc */
op_amp
id|rng_interval_sysctl
comma
r_sizeof
(paren
id|rng_interval_sysctl
)paren
comma
multiline_comment|/* data ptr, data size */
l_int|0644
comma
multiline_comment|/* mode */
l_int|0
comma
multiline_comment|/* child */
id|rng_handle_sysctl_interval
comma
multiline_comment|/* proc handler */
l_int|0
comma
multiline_comment|/* strategy */
l_int|0
comma
multiline_comment|/* proc control block */
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* Define the parent file : /proc/sys/dev */
r_static
id|ctl_table
id|sysctls_root
(braket
)braket
op_assign
(brace
(brace
id|CTL_DEV
comma
l_string|&quot;dev&quot;
comma
l_int|NULL
comma
l_int|0
comma
l_int|0555
comma
id|rng_sysctls
)brace
comma
(brace
l_int|0
)brace
)brace
suffix:semicolon
r_static
r_struct
id|ctl_table_header
op_star
id|sysctls_root_header
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|add
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|sysctls_root_header
)paren
id|sysctls_root_header
op_assign
id|register_sysctl_table
(paren
id|sysctls_root
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sysctls_root_header
)paren
(brace
id|unregister_sysctl_table
(paren
id|sysctls_root_header
)paren
suffix:semicolon
id|sysctls_root_header
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
DECL|function|rng_dev_open
r_static
r_int
id|rng_dev_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|rc
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_READ
)paren
op_eq
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
id|rc
suffix:semicolon
multiline_comment|/* wait for device to become free */
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
id|down_trylock
(paren
op_amp
id|rng_open_sem
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|down_interruptible
(paren
op_amp
id|rng_open_sem
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rng_enable
(paren
l_int|1
)paren
)paren
(brace
id|rc
op_assign
op_minus
id|EIO
suffix:semicolon
r_goto
id|err_out
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
id|up
(paren
op_amp
id|rng_open_sem
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|rng_dev_release
r_static
r_int
id|rng_dev_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|rng_enable
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|up
(paren
op_amp
id|rng_open_sem
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rng_dev_read
r_static
id|ssize_t
id|rng_dev_read
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|size
comma
id|loff_t
op_star
id|offp
)paren
(brace
r_int
id|have_data
suffix:semicolon
id|u8
id|data
op_assign
l_int|0
suffix:semicolon
id|ssize_t
id|ret
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|size
)paren
(brace
id|spin_lock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
id|have_data
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rng_data_present
(paren
)paren
)paren
(brace
id|data
op_assign
id|rng_data_read
(paren
)paren
suffix:semicolon
id|have_data
op_assign
l_int|1
suffix:semicolon
)brace
id|spin_unlock_bh
(paren
op_amp
id|rng_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|have_data
)paren
(brace
r_if
c_cond
(paren
id|put_user
(paren
id|data
comma
id|buf
op_increment
)paren
)paren
(brace
id|ret
op_assign
id|ret
ques
c_cond
suffix:colon
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|size
op_decrement
suffix:semicolon
id|ret
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current-&gt;need_resched
)paren
id|schedule
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
r_return
id|ret
ques
c_cond
suffix:colon
op_minus
id|ERESTARTSYS
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
id|ret
ques
c_cond
suffix:colon
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * rng_init_one - look for and attempt to init a single RNG&n; */
DECL|function|rng_init_one
r_static
r_int
id|__init
id|rng_init_one
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
r_int
id|rc
suffix:semicolon
id|u8
id|hw_status
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
(paren
id|dev
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* XXX currently fails, investigate who has our mem region */
r_if
c_cond
(paren
id|request_mem_region
(paren
id|RNG_ADDR
comma
id|RNG_ADDR_LEN
comma
id|RNG_MODULE_NAME
)paren
)paren
id|rng_have_mem_region
op_assign
l_int|1
suffix:semicolon
id|rng_mem
op_assign
id|ioremap
(paren
id|RNG_ADDR
comma
id|RNG_ADDR_LEN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rng_mem
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|PFX
l_string|&quot;cannot ioremap RNG Memory&bslash;n&quot;
)paren
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;EXIT, returning -EBUSY&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_goto
id|err_out_free_res
suffix:semicolon
)brace
multiline_comment|/* Check for Intel 82802 */
id|hw_status
op_assign
id|rng_hwstatus
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hw_status
op_amp
id|RNG_PRESENT
)paren
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|PFX
l_string|&quot;RNG not detected&bslash;n&quot;
)paren
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;EXIT, returning -ENODEV&bslash;n&quot;
)paren
suffix:semicolon
id|rc
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|err_out_free_map
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rng_entropy
template_param
id|RNG_MAX_ENTROPY
)paren
id|rng_entropy
op_assign
id|RNG_MAX_ENTROPY
suffix:semicolon
multiline_comment|/* init core RNG timer, but do not add it */
id|init_timer
(paren
op_amp
id|rng_timer
)paren
suffix:semicolon
id|rng_timer.function
op_assign
id|rng_timer_tick
suffix:semicolon
multiline_comment|/* turn RNG h/w off, if it&squot;s on */
id|rc
op_assign
id|rng_enable
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|printk
(paren
id|KERN_ERR
id|PFX
l_string|&quot;cannot disable RNG, aborting&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|err_out_free_map
suffix:semicolon
)brace
multiline_comment|/* add sysctls */
id|rng_sysctl
(paren
l_int|1
)paren
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;EXIT, returning 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out_free_map
suffix:colon
id|iounmap
(paren
id|rng_mem
)paren
suffix:semicolon
id|err_out_free_res
suffix:colon
r_if
c_cond
(paren
id|rng_have_mem_region
)paren
id|release_mem_region
(paren
id|RNG_ADDR
comma
id|RNG_ADDR_LEN
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Data for PCI driver interface&n; *&n; * This data only exists for exporting the supported&n; * PCI ids via MODULE_DEVICE_TABLE.  We do not actually&n; * register a pci_driver, because someone else might one day&n; * want to register another driver on the same PCI id.&n; */
DECL|variable|__initdata
r_const
r_static
r_struct
id|pci_device_id
id|rng_pci_tbl
(braket
)braket
id|__initdata
op_assign
(brace
(brace
l_int|0x8086
comma
l_int|0x2418
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
)brace
comma
(brace
l_int|0x8086
comma
l_int|0x2428
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
)brace
comma
(brace
l_int|0x8086
comma
l_int|0x1130
comma
id|PCI_ANY_ID
comma
id|PCI_ANY_ID
comma
)brace
comma
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
id|MODULE_DEVICE_TABLE
(paren
id|pci
comma
id|rng_pci_tbl
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Jeff Garzik, Matt Sottek&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Intel i8xx chipset Random Number Generator (RNG) driver&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|rng_entropy
comma
l_string|&quot;1i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|rng_entropy
comma
l_string|&quot;Bits of entropy to add to random pool per RNG byte (range: 0-8, default 8)&quot;
)paren
suffix:semicolon
DECL|variable|rng_chrdev_ops
r_static
r_struct
id|file_operations
id|rng_chrdev_ops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|open
suffix:colon
id|rng_dev_open
comma
id|release
suffix:colon
id|rng_dev_release
comma
id|read
suffix:colon
id|rng_dev_read
comma
)brace
suffix:semicolon
DECL|variable|rng_miscdev
r_static
r_struct
id|miscdevice
id|rng_miscdev
op_assign
(brace
id|RNG_MISCDEV_MINOR
comma
id|RNG_MODULE_NAME
comma
op_amp
id|rng_chrdev_ops
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * rng_init - initialize RNG module&n; */
DECL|function|rng_init
r_static
r_int
id|__init
id|rng_init
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|init_MUTEX
(paren
op_amp
id|rng_open_sem
)paren
suffix:semicolon
id|pci_for_each_dev
c_func
(paren
id|pdev
)paren
(brace
r_if
c_cond
(paren
id|pci_match_device
(paren
id|rng_pci_tbl
comma
id|pdev
)paren
op_ne
l_int|NULL
)paren
r_goto
id|match
suffix:semicolon
)brace
id|DPRINTK
(paren
l_string|&quot;EXIT, returning -ENODEV&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
id|match
suffix:colon
id|rc
op_assign
id|rng_init_one
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
r_return
id|rc
suffix:semicolon
id|rc
op_assign
id|misc_register
(paren
op_amp
id|rng_miscdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|iounmap
(paren
id|rng_mem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rng_have_mem_region
)paren
id|release_mem_region
(paren
id|RNG_ADDR
comma
id|RNG_ADDR_LEN
)paren
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;EXIT, returning %d&bslash;n&quot;
comma
id|rc
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
id|printk
(paren
id|KERN_INFO
id|RNG_DRIVER_NAME
l_string|&quot; loaded&bslash;n&quot;
)paren
suffix:semicolon
id|rng_pdev
op_assign
id|pdev
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;EXIT, returning 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * rng_init - shutdown RNG module&n; */
DECL|function|rng_cleanup
r_static
r_void
id|__exit
id|rng_cleanup
(paren
r_void
)paren
(brace
id|DPRINTK
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
m_assert
(paren
id|rng_timer_enabled
op_eq
l_int|0
)paren
suffix:semicolon
m_assert
(paren
id|rng_hw_enabled
op_eq
l_int|0
)paren
suffix:semicolon
id|misc_deregister
(paren
op_amp
id|rng_miscdev
)paren
suffix:semicolon
id|rng_sysctl
(paren
l_int|0
)paren
suffix:semicolon
id|iounmap
(paren
id|rng_mem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rng_have_mem_region
)paren
id|release_mem_region
(paren
id|RNG_ADDR
comma
id|RNG_ADDR_LEN
)paren
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;EXIT&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|rng_init
id|module_init
(paren
id|rng_init
)paren
suffix:semicolon
DECL|variable|rng_cleanup
id|module_exit
(paren
id|rng_cleanup
)paren
suffix:semicolon
multiline_comment|/* These are the startup tests suggested by the FIPS 140-1 spec section&n;*  4.11.1 (http://csrc.nist.gov/fips/fips1401.htm)&n;*  The Monobit, Poker, Runs, and Long Runs tests are implemented below.&n;*  This test is run at periodic intervals to verify&n;*  data is sufficiently random. If the tests are failed the RNG module&n;*  will no longer submit data to the entropy pool, but the tests will&n;*  continue to run at the given interval. If at a later time the RNG&n;*  passes all tests it will be re-enabled for the next period.&n;*   The reason for this is that it is not unlikely that at some time&n;*  during normal operation one of the tests will fail. This does not&n;*  necessarily mean the RNG is not operating properly, it is just a&n;*  statistically rare event. In that case we don&squot;t want to forever&n;*  disable the RNG, we will just leave it disabled for the period of&n;*  time until the tests are rerun and passed.&n;*&n;*  For argument sake I tested /dev/urandom with these tests and it&n;*  took 142,095 tries before I got a failure, and urandom isn&squot;t as&n;*  random as random :)&n;*/
DECL|variable|poker
DECL|variable|runs
r_static
r_int
id|poker
(braket
l_int|16
)braket
op_assign
(brace
l_int|0
comma
)brace
comma
id|runs
(braket
l_int|12
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|ones
DECL|variable|rlength
DECL|variable|current_bit
DECL|variable|rng_test
r_static
r_int
id|ones
op_assign
l_int|0
comma
id|rlength
op_assign
op_minus
l_int|1
comma
id|current_bit
op_assign
l_int|0
comma
id|rng_test
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * rng_fips_test_store - store 8 bits of entropy in FIPS&n; * &t;&t;&t; internal test data pool&n; */
DECL|function|rng_fips_test_store
r_static
r_void
id|rng_fips_test_store
(paren
r_int
id|rng_data
)paren
(brace
r_int
id|j
suffix:semicolon
r_static
r_int
id|last_bit
op_assign
l_int|0
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;ENTER, rng_data = %d&bslash;n&quot;
comma
id|rng_data
)paren
suffix:semicolon
id|poker
(braket
id|rng_data
op_rshift
l_int|4
)braket
op_increment
suffix:semicolon
id|poker
(braket
id|rng_data
op_amp
l_int|15
)braket
op_increment
suffix:semicolon
multiline_comment|/* Note in the loop below rlength is always one less than the actual&n;&t;   run length. This makes things easier. */
id|last_bit
op_assign
(paren
id|rng_data
op_amp
l_int|128
)paren
op_rshift
l_int|7
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|7
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
id|ones
op_add_assign
id|current_bit
op_assign
(paren
id|rng_data
op_amp
l_int|1
op_lshift
id|j
)paren
op_rshift
id|j
suffix:semicolon
r_if
c_cond
(paren
id|current_bit
op_ne
id|last_bit
)paren
(brace
multiline_comment|/* If runlength is 1-6 count it in correct bucket. 0&squot;s go in&n;&t;&t;&t;   runs[0-5] 1&squot;s go in runs[6-11] hence the 6*current_bit below */
r_if
c_cond
(paren
id|rlength
OL
l_int|5
)paren
(brace
id|runs
(braket
id|rlength
op_plus
(paren
l_int|6
op_star
id|current_bit
)paren
)braket
op_increment
suffix:semicolon
)brace
r_else
(brace
id|runs
(braket
l_int|5
op_plus
(paren
l_int|6
op_star
id|current_bit
)paren
)braket
op_increment
suffix:semicolon
)brace
multiline_comment|/* Check if we just failed longrun test */
r_if
c_cond
(paren
id|rlength
op_ge
l_int|33
)paren
id|rng_test
op_and_assign
l_int|8
suffix:semicolon
id|rlength
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* flip the current run type */
id|last_bit
op_assign
id|current_bit
suffix:semicolon
)brace
r_else
(brace
id|rlength
op_increment
suffix:semicolon
)brace
)brace
id|DPRINTK
(paren
l_string|&quot;EXIT&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * now that we have some data, run a FIPS test&n; */
DECL|function|rng_run_fips_test
r_static
r_void
id|rng_run_fips_test
(paren
r_void
)paren
(brace
r_int
id|j
comma
id|i
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;ENTER&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* add in the last (possibly incomplete) run */
r_if
c_cond
(paren
id|rlength
OL
l_int|5
)paren
id|runs
(braket
id|rlength
op_plus
(paren
l_int|6
op_star
id|current_bit
)paren
)braket
op_increment
suffix:semicolon
r_else
(brace
id|runs
(braket
l_int|5
op_plus
(paren
l_int|6
op_star
id|current_bit
)paren
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rlength
op_ge
l_int|33
)paren
id|rng_test
op_and_assign
l_int|8
suffix:semicolon
)brace
multiline_comment|/* Ones test */
r_if
c_cond
(paren
(paren
id|ones
op_ge
l_int|10346
)paren
op_logical_or
(paren
id|ones
op_le
l_int|9654
)paren
)paren
id|rng_test
op_and_assign
l_int|1
suffix:semicolon
multiline_comment|/* Poker calcs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|j
op_add_assign
id|poker
(braket
id|i
)braket
op_star
id|poker
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|j
op_ge
l_int|1580457
)paren
op_logical_or
(paren
id|j
op_le
l_int|1562821
)paren
)paren
id|rng_test
op_and_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|runs
(braket
l_int|0
)braket
OL
l_int|2267
)paren
op_logical_or
(paren
id|runs
(braket
l_int|0
)braket
OG
l_int|2733
)paren
op_logical_or
(paren
id|runs
(braket
l_int|1
)braket
OL
l_int|1079
)paren
op_logical_or
(paren
id|runs
(braket
l_int|1
)braket
OG
l_int|1421
)paren
op_logical_or
(paren
id|runs
(braket
l_int|2
)braket
OL
l_int|502
)paren
op_logical_or
(paren
id|runs
(braket
l_int|2
)braket
OG
l_int|748
)paren
op_logical_or
(paren
id|runs
(braket
l_int|3
)braket
OL
l_int|223
)paren
op_logical_or
(paren
id|runs
(braket
l_int|3
)braket
OG
l_int|402
)paren
op_logical_or
(paren
id|runs
(braket
l_int|4
)braket
OL
l_int|90
)paren
op_logical_or
(paren
id|runs
(braket
l_int|4
)braket
OG
l_int|223
)paren
op_logical_or
(paren
id|runs
(braket
l_int|5
)braket
OL
l_int|90
)paren
op_logical_or
(paren
id|runs
(braket
l_int|5
)braket
OG
l_int|223
)paren
op_logical_or
(paren
id|runs
(braket
l_int|6
)braket
OL
l_int|2267
)paren
op_logical_or
(paren
id|runs
(braket
l_int|6
)braket
OG
l_int|2733
)paren
op_logical_or
(paren
id|runs
(braket
l_int|7
)braket
OL
l_int|1079
)paren
op_logical_or
(paren
id|runs
(braket
l_int|7
)braket
OG
l_int|1421
)paren
op_logical_or
(paren
id|runs
(braket
l_int|8
)braket
OL
l_int|502
)paren
op_logical_or
(paren
id|runs
(braket
l_int|8
)braket
OG
l_int|748
)paren
op_logical_or
(paren
id|runs
(braket
l_int|9
)braket
OL
l_int|223
)paren
op_logical_or
(paren
id|runs
(braket
l_int|9
)braket
OG
l_int|402
)paren
op_logical_or
(paren
id|runs
(braket
l_int|10
)braket
OL
l_int|90
)paren
op_logical_or
(paren
id|runs
(braket
l_int|10
)braket
OG
l_int|223
)paren
op_logical_or
(paren
id|runs
(braket
l_int|11
)braket
OL
l_int|90
)paren
op_logical_or
(paren
id|runs
(braket
l_int|11
)braket
OG
l_int|223
)paren
)paren
(brace
id|rng_test
op_and_assign
l_int|4
suffix:semicolon
)brace
id|rng_test
op_assign
op_logical_neg
id|rng_test
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;FIPS test %sed&bslash;n&quot;
comma
id|rng_test
ques
c_cond
l_string|&quot;pass&quot;
suffix:colon
l_string|&quot;fail&quot;
)paren
suffix:semicolon
multiline_comment|/* enable/disable RNG with results of the tests */
r_if
c_cond
(paren
id|rng_test
op_logical_and
op_logical_neg
id|rng_trusted
)paren
id|printk
(paren
id|KERN_WARNING
id|PFX
l_string|&quot;FIPS test passed, enabling RNG&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|rng_test
op_logical_and
id|rng_trusted
)paren
id|printk
(paren
id|KERN_WARNING
id|PFX
l_string|&quot;FIPS test failed, disabling RNG&bslash;n&quot;
)paren
suffix:semicolon
id|rng_trusted
op_assign
id|rng_test
suffix:semicolon
multiline_comment|/* finally, clear out FIPS variables for start of next run */
id|memset
(paren
id|poker
comma
l_int|0
comma
r_sizeof
(paren
id|poker
)paren
)paren
suffix:semicolon
id|memset
(paren
id|runs
comma
l_int|0
comma
r_sizeof
(paren
id|runs
)paren
)paren
suffix:semicolon
id|ones
op_assign
l_int|0
suffix:semicolon
id|rlength
op_assign
op_minus
l_int|1
suffix:semicolon
id|current_bit
op_assign
l_int|0
suffix:semicolon
id|rng_test
op_assign
l_int|0
suffix:semicolon
id|DPRINTK
(paren
l_string|&quot;EXIT&bslash;n&quot;
)paren
suffix:semicolon
)brace
eof
