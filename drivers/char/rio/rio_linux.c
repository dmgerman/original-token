multiline_comment|/* rio_linux.c -- Linux driver for the Specialix RIO series cards. &n; *&n; *&n; *   (C) 1999 R.E.Wolff@BitWizard.nl&n; *&n; * Specialix pays for the development and support of this driver.&n; * Please DO contact support@specialix.co.uk if you require&n; * support. But please read the documentation (rio.txt) first.&n; *&n; *&n; *&n; *      This program is free software; you can redistribute it and/or&n; *      modify it under the terms of the GNU General Public License as&n; *      published by the Free Software Foundation; either version 2 of&n; *      the License, or (at your option) any later version.&n; *&n; *      This program is distributed in the hope that it will be&n; *      useful, but WITHOUT ANY WARRANTY; without even the implied&n; *      warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR&n; *      PURPOSE.  See the GNU General Public License for more details.&n; *&n; *      You should have received a copy of the GNU General Public&n; *      License along with this program; if not, write to the Free&n; *      Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,&n; *      USA.&n; *&n; * Revision history:&n; * $Log: rio.c,v $&n; * Revision 1.1  1999/07/11 10:13:54  wolff&n; * Initial revision&n; *&n; * */
DECL|macro|RCS_ID
mdefine_line|#define RCS_ID &quot;$Id: rio.c,v 1.1 1999/07/11 10:13:54 wolff Exp wolff $&quot;
DECL|macro|RCS_REV
mdefine_line|#define RCS_REV &quot;$Revision: 1.1 $&quot;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt; 
macro_line|#include &lt;linux/kdev_t.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/compatmac.h&gt;
macro_line|#include &lt;linux/generic_serial.h&gt;
macro_line|#include &quot;linux_compat.h&quot;
macro_line|#include &quot;typdef.h&quot;
macro_line|#include &quot;pkt.h&quot;
macro_line|#include &quot;daemon.h&quot;
macro_line|#include &quot;rio.h&quot;
macro_line|#include &quot;riospace.h&quot;
macro_line|#include &quot;top.h&quot;
macro_line|#include &quot;cmdpkt.h&quot;
macro_line|#include &quot;map.h&quot;
macro_line|#include &quot;riotypes.h&quot;
macro_line|#include &quot;rup.h&quot;
macro_line|#include &quot;port.h&quot;
macro_line|#include &quot;riodrvr.h&quot;
macro_line|#include &quot;rioinfo.h&quot;
macro_line|#include &quot;func.h&quot;
macro_line|#include &quot;errors.h&quot;
macro_line|#include &quot;pci.h&quot;
macro_line|#include &quot;parmmap.h&quot;
macro_line|#include &quot;unixrup.h&quot;
macro_line|#include &quot;board.h&quot;
macro_line|#include &quot;host.h&quot;
macro_line|#include &quot;error.h&quot;
macro_line|#include &quot;phb.h&quot;
macro_line|#include &quot;link.h&quot;
macro_line|#include &quot;cmdblk.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;control.h&quot;
macro_line|#include &quot;cirrus.h&quot;
macro_line|#include &quot;rioioctl.h&quot;
macro_line|#include &quot;param.h&quot;
macro_line|#include &quot;list.h&quot;
macro_line|#include &quot;sam.h&quot;
macro_line|#include &quot;protsts.h&quot;
macro_line|#include &quot;rioboard.h&quot;
macro_line|#include &quot;rio_linux.h&quot;
multiline_comment|/* I don&squot;t think that this driver can handle more than 512 ports on&n;one machine.  Specialix specifies max 4 boards in one machine. I don&squot;t&n;know why. If you want to try anyway you&squot;ll have to increase the number&n;of boards in rio.h.  You&squot;ll have to allocate more majors if you need&n;more than 512 ports.... */
multiline_comment|/* ************************************************************** */
multiline_comment|/* * This section can be removed when 2.0 becomes outdated....  * */
multiline_comment|/* ************************************************************** */
macro_line|#if LINUX_VERSION_CODE &lt; 0x020100    /* Less than 2.1.0 */
DECL|macro|TWO_ZERO
mdefine_line|#define TWO_ZERO
macro_line|#else
macro_line|#if LINUX_VERSION_CODE &lt; 0x020209   /* less than 2.2.x */
macro_line|#warning &quot;Please use a recent 2.2.x kernel. &quot;
macro_line|#endif
macro_line|#endif
macro_line|#ifdef TWO_ZERO
multiline_comment|/* Here is the section that makes the 2.2 compatible driver source &n;   work for 2.0 too! We mostly try to adopt the &quot;new thingies&quot; from 2.2, &n;   and provide for compatibility stuff here if possible. */
macro_line|#include &lt;linux/bios32.h&gt;
DECL|macro|Get_user
mdefine_line|#define Get_user(a,b)                a = get_user(b)
DECL|macro|Put_user
mdefine_line|#define Put_user(a,b)                0,put_user(a,b)
DECL|macro|copy_to_user
mdefine_line|#define copy_to_user(a,b,c)          memcpy_tofs(a,b,c)
DECL|function|copy_from_user
r_static
r_inline
r_int
id|copy_from_user
c_func
(paren
r_void
op_star
id|to
comma
r_const
r_void
op_star
id|from
comma
r_int
id|c
)paren
(brace
id|memcpy_fromfs
c_func
(paren
id|to
comma
id|from
comma
id|c
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|pci_present
mdefine_line|#define pci_present                  pcibios_present
DECL|macro|pci_read_config_word
mdefine_line|#define pci_read_config_word         pcibios_read_config_word
DECL|macro|pci_read_config_dword
mdefine_line|#define pci_read_config_dword        pcibios_read_config_dword
DECL|function|get_irq
r_static
r_inline
r_int
r_char
id|get_irq
(paren
r_int
r_char
id|bus
comma
r_int
r_char
id|fn
)paren
(brace
r_int
r_char
id|t
suffix:semicolon
id|pcibios_read_config_byte
(paren
id|bus
comma
id|fn
comma
id|PCI_INTERRUPT_LINE
comma
op_amp
id|t
)paren
suffix:semicolon
r_return
id|t
suffix:semicolon
)brace
DECL|function|ioremap
r_static
r_inline
r_void
op_star
id|ioremap
c_func
(paren
r_int
r_int
id|base
comma
r_int
id|length
)paren
(brace
r_if
c_cond
(paren
id|base
OL
l_int|0x100000
)paren
r_return
(paren
r_void
op_star
)paren
id|base
suffix:semicolon
r_return
id|vremap
(paren
id|base
comma
id|length
)paren
suffix:semicolon
)brace
DECL|macro|my_iounmap
mdefine_line|#define my_iounmap(x, b)             (((long)x&lt;0x100000)?0:vfree ((void*)x))
DECL|macro|capable
mdefine_line|#define capable(x)                   suser()
DECL|macro|queue_task
mdefine_line|#define queue_task                   queue_task_irq_off
DECL|macro|tty_flip_buffer_push
mdefine_line|#define tty_flip_buffer_push(tty)    queue_task(&amp;tty-&gt;flip.tqueue, &amp;tq_timer)
DECL|macro|signal_pending
mdefine_line|#define signal_pending(current)      (current-&gt;signal &amp; ~current-&gt;blocked)
DECL|macro|schedule_timeout
mdefine_line|#define schedule_timeout(to)         do {current-&gt;timeout = jiffies + (to);schedule ();} while (0)
DECL|macro|time_after
mdefine_line|#define time_after(t1,t2)            (((long)t1-t2) &gt; 0)
DECL|macro|test_and_set_bit
mdefine_line|#define test_and_set_bit(nr, addr)   set_bit(nr, addr)
DECL|macro|test_and_clear_bit
mdefine_line|#define test_and_clear_bit(nr, addr) clear_bit(nr, addr)
multiline_comment|/* Not yet implemented on 2.0 */
DECL|macro|ASYNC_SPD_SHI
mdefine_line|#define ASYNC_SPD_SHI  -1
DECL|macro|ASYNC_SPD_WARP
mdefine_line|#define ASYNC_SPD_WARP -1
multiline_comment|/* Ugly hack: the driver_name doesn&squot;t exist in 2.0.x . So we define it&n;   to the &quot;name&quot; field that does exist. As long as the assignments are&n;   done in the right order, there is nothing to worry about. */
DECL|macro|driver_name
mdefine_line|#define driver_name           name 
multiline_comment|/* Should be in a header somewhere. They are in tty.h on 2.2 */
DECL|macro|TTY_HW_COOK_OUT
mdefine_line|#define TTY_HW_COOK_OUT       14 /* Flag to tell ntty what we can handle */
DECL|macro|TTY_HW_COOK_IN
mdefine_line|#define TTY_HW_COOK_IN        15 /* in hardware - output and input       */
multiline_comment|/* The return type of a &quot;close&quot; routine. */
DECL|macro|INT
mdefine_line|#define INT                   void
DECL|macro|NO_ERROR
mdefine_line|#define NO_ERROR              /* Nothing */
macro_line|#else
multiline_comment|/* The 2.2.x compatibility section. */
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|Get_user
mdefine_line|#define Get_user(a,b)         get_user(a,b)
DECL|macro|Put_user
mdefine_line|#define Put_user(a,b)         put_user(a,b)
DECL|macro|get_irq
mdefine_line|#define get_irq(pdev)         pdev-&gt;irq
DECL|macro|INT
mdefine_line|#define INT                   int
DECL|macro|NO_ERROR
mdefine_line|#define NO_ERROR              0              
DECL|macro|my_iounmap
mdefine_line|#define my_iounmap(x,b)       (iounmap((char *)(b)))
macro_line|#endif
multiline_comment|/* ************************************************************** */
multiline_comment|/* *                End of compatibility section..              * */
multiline_comment|/* ************************************************************** */
multiline_comment|/* Why the hell am I defining these here? */
DECL|macro|RIO_TYPE_NORMAL
mdefine_line|#define RIO_TYPE_NORMAL 1
DECL|macro|RIO_TYPE_CALLOUT
mdefine_line|#define RIO_TYPE_CALLOUT 2
macro_line|#ifndef RIO_NORMAL_MAJOR0
multiline_comment|/* This allows overriding on the compiler commandline, or in a &quot;major.h&quot; &n;   include or something like that */
DECL|macro|RIO_NORMAL_MAJOR0
mdefine_line|#define RIO_NORMAL_MAJOR0  154
DECL|macro|RIO_CALLOUT_MAJOR0
mdefine_line|#define RIO_CALLOUT_MAJOR0 155
DECL|macro|RIO_NORMAL_MAJOR1
mdefine_line|#define RIO_NORMAL_MAJOR1  156
DECL|macro|RIO_CALLOUT_MAJOR1
mdefine_line|#define RIO_CALLOUT_MAJOR1 157
macro_line|#endif
macro_line|#ifndef PCI_DEVICE_ID_SPECIALIX_SX_XIO_IO8
DECL|macro|PCI_DEVICE_ID_SPECIALIX_SX_XIO_IO8
mdefine_line|#define PCI_DEVICE_ID_SPECIALIX_SX_XIO_IO8 0x2000
macro_line|#endif
macro_line|#ifndef RIO_WINDOW_LEN 
DECL|macro|RIO_WINDOW_LEN
mdefine_line|#define RIO_WINDOW_LEN 0x10000
macro_line|#endif
multiline_comment|/* Configurable options: &n;   (Don&squot;t be too sure that it&squot;ll work if you toggle them) */
multiline_comment|/* Am I paranoid or not ? ;-) */
DECL|macro|RIO_PARANOIA_CHECK
macro_line|#undef RIO_PARANOIA_CHECK
multiline_comment|/* 20 -&gt; 2000 per second. The card should rate-limit interrupts at 1000&n;   Hz, but it is user configurable. I don&squot;t recommend going above 1000&n;   Hz. The interrupt ratelimit might trigger if the interrupt is&n;   shared with a very active other device. &n;   undef this if you want to disable the check....&n;*/
DECL|macro|IRQ_RATE_LIMIT
mdefine_line|#define IRQ_RATE_LIMIT 200
macro_line|#if 0
multiline_comment|/* Not implemented */
multiline_comment|/* &n; * The following defines are mostly for testing purposes. But if you need&n; * some nice reporting in your syslog, you can define them also.&n; */
mdefine_line|#define RIO_REPORT_FIFO
mdefine_line|#define RIO_REPORT_OVERRUN
macro_line|#endif 
multiline_comment|/* These constants are derived from SCO Source */
r_static
r_struct
id|Conf
DECL|variable|RIOConf
id|RIOConf
op_assign
(brace
multiline_comment|/* locator */
l_string|&quot;RIO Config here&quot;
comma
multiline_comment|/* startuptime */
id|HZ
op_star
l_int|2
comma
multiline_comment|/* how long to wait for card to run */
multiline_comment|/* slowcook */
l_int|0
comma
multiline_comment|/* TRUE -&gt; always use line disc. */
multiline_comment|/* intrpolltime */
l_int|1
comma
multiline_comment|/* The frequency of OUR polls */
multiline_comment|/* breakinterval */
l_int|25
comma
multiline_comment|/* x10 mS */
multiline_comment|/* timer */
l_int|10
comma
multiline_comment|/* mS */
multiline_comment|/* RtaLoadBase */
l_int|0x7000
comma
multiline_comment|/* HostLoadBase */
l_int|0x7C00
comma
multiline_comment|/* XpHz */
l_int|5
comma
multiline_comment|/* number of Xprint hits per second */
multiline_comment|/* XpCps */
l_int|120
comma
multiline_comment|/* Xprint characters per second */
multiline_comment|/* XpOn */
l_string|&quot;&bslash;033d#&quot;
comma
multiline_comment|/* start Xprint for a wyse 60 */
multiline_comment|/* XpOff */
l_string|&quot;&bslash;024&quot;
comma
multiline_comment|/* end Xprint for a wyse 60 */
multiline_comment|/* MaxXpCps */
l_int|2000
comma
multiline_comment|/* highest Xprint speed */
multiline_comment|/* MinXpCps */
l_int|10
comma
multiline_comment|/* slowest Xprint speed */
multiline_comment|/* SpinCmds */
l_int|1
comma
multiline_comment|/* non-zero for mega fast boots */
multiline_comment|/* First Addr */
l_int|0x0A0000
comma
multiline_comment|/* First address to look at */
multiline_comment|/* Last Addr */
l_int|0xFF0000
comma
multiline_comment|/* Last address looked at */
multiline_comment|/* BufferSize */
l_int|1024
comma
multiline_comment|/* Bytes per port of buffering */
multiline_comment|/* LowWater */
l_int|256
comma
multiline_comment|/* how much data left before wakeup */
multiline_comment|/* LineLength */
l_int|80
comma
multiline_comment|/* how wide is the console? */
multiline_comment|/* CmdTimeout */
id|HZ
comma
multiline_comment|/* how long a close command may take */
)brace
suffix:semicolon
multiline_comment|/* Function prototypes */
r_static
r_void
id|rio_disable_tx_interrupts
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|rio_enable_tx_interrupts
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|rio_disable_rx_interrupts
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|rio_enable_rx_interrupts
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_int
id|rio_get_CD
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|rio_shutdown_port
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_int
id|rio_set_real_termios
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|rio_hungup
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_void
id|rio_close
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_int
id|rio_chars_in_buffer
(paren
r_void
op_star
id|ptr
)paren
suffix:semicolon
r_static
r_int
id|rio_fw_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|rio_fw_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
id|INT
id|rio_fw_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_int
id|rio_init_drivers
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|my_hd
(paren
r_void
op_star
id|addr
comma
r_int
id|len
)paren
suffix:semicolon
DECL|variable|rio_driver
DECL|variable|rio_callout_driver
r_static
r_struct
id|tty_driver
id|rio_driver
comma
id|rio_callout_driver
suffix:semicolon
DECL|variable|rio_driver2
DECL|variable|rio_callout_driver2
r_static
r_struct
id|tty_driver
id|rio_driver2
comma
id|rio_callout_driver2
suffix:semicolon
DECL|variable|rio_table
r_static
r_struct
id|tty_struct
op_star
id|rio_table
(braket
id|RIO_NPORTS
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|rio_termios
r_static
r_struct
id|termios
op_star
op_star
id|rio_termios
suffix:semicolon
DECL|variable|rio_termios_locked
r_static
r_struct
id|termios
op_star
op_star
id|rio_termios_locked
suffix:semicolon
multiline_comment|/* The name &quot;p&quot; is a bit non-descript. But that&squot;s what the rio-lynxos&n;sources use all over the place. */
DECL|variable|p
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
multiline_comment|/* struct rio_board boards[RIO_HOSTS]; */
DECL|variable|rio_ports
r_struct
id|rio_port
op_star
id|rio_ports
suffix:semicolon
DECL|variable|rio_refcount
r_int
id|rio_refcount
suffix:semicolon
DECL|variable|rio_initialized
r_int
id|rio_initialized
op_assign
l_int|0
suffix:semicolon
DECL|variable|rio_nports
r_int
id|rio_nports
op_assign
l_int|0
suffix:semicolon
DECL|variable|rio_debug
r_int
id|rio_debug
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* You can have the driver poll your card. &n;    - Set rio_poll to 1 to poll every timer tick (10ms on Intel). &n;      This is used when the card cannot use an interrupt for some reason.&n;*/
DECL|variable|rio_poll
r_int
id|rio_poll
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* These are the only open spaces in my computer. Yours may have more&n;   or less.... */
DECL|variable|rio_probe_addrs
r_int
id|rio_probe_addrs
(braket
)braket
op_assign
(brace
l_int|0xc0000
comma
l_int|0xd0000
comma
l_int|0xe0000
)brace
suffix:semicolon
DECL|macro|NR_RIO_ADDRS
mdefine_line|#define NR_RIO_ADDRS (sizeof(rio_probe_addrs)/sizeof (int))
multiline_comment|/* Set the mask to all-ones. This alas, only supports 32 interrupts. &n;   Some architectures may need more. -- Changed to LONG to&n;   support up to 64 bits on 64bit architectures. -- REW 20/06/99 */
DECL|variable|rio_irqmask
r_int
id|rio_irqmask
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#ifndef TWO_ZERO
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|rio_poll
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|rio_debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|rio_irqmask
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
DECL|variable|rio_real_driver
r_static
r_struct
id|real_driver
id|rio_real_driver
op_assign
(brace
id|rio_disable_tx_interrupts
comma
id|rio_enable_tx_interrupts
comma
id|rio_disable_rx_interrupts
comma
id|rio_enable_rx_interrupts
comma
id|rio_get_CD
comma
id|rio_shutdown_port
comma
id|rio_set_real_termios
comma
id|rio_chars_in_buffer
comma
id|rio_close
comma
id|rio_hungup
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* &n;   This driver can spew a whole lot of debugging output at you. If you&n;   need maximum performance, you should disable the DEBUG define. To&n;   aid in debugging in the field, I&squot;m leaving the compile-time debug&n;   features enabled, and disable them &quot;runtime&quot;. That allows me to&n;   instruct people with problems to enable debugging without requiring&n;   them to recompile... &n;*/
DECL|macro|DEBUG
mdefine_line|#define DEBUG
macro_line|#ifdef DEBUG
DECL|macro|rio_dprintk
mdefine_line|#define rio_dprintk(f, str...) if (rio_debug &amp; f) printk (str)
macro_line|#else
DECL|macro|rio_dprintk
mdefine_line|#define rio_dprintk(f, str...) /* nothing */
macro_line|#endif
DECL|macro|func_enter
mdefine_line|#define func_enter() rio_dprintk (RIO_DEBUG_FLOW, &quot;rio: enter &quot; __FUNCTION__ &quot;&bslash;n&quot;)
DECL|macro|func_exit
mdefine_line|#define func_exit()  rio_dprintk (RIO_DEBUG_FLOW, &quot;rio: exit  &quot; __FUNCTION__ &quot;&bslash;n&quot;)
DECL|macro|func_enter2
mdefine_line|#define func_enter2() rio_dprintk (RIO_DEBUG_FLOW, &quot;rio: enter &quot; __FUNCTION__ &bslash;&n;                                  &quot;(port %d)&bslash;n&quot;, port-&gt;line)
multiline_comment|/* &n; *  Firmware loader driver specific routines&n; *&n; */
DECL|variable|rio_fw_fops
r_static
r_struct
id|file_operations
id|rio_fw_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/*&t;lseek&t;*/
l_int|NULL
comma
multiline_comment|/*&t;read&t;*/
l_int|NULL
comma
multiline_comment|/*&t;write&t;*/
l_int|NULL
comma
multiline_comment|/*&t;readdir&t;*/
l_int|NULL
comma
multiline_comment|/*&t;select&t;*/
id|rio_fw_ioctl
comma
l_int|NULL
comma
multiline_comment|/*&t;mmap&t;*/
id|rio_fw_open
comma
macro_line|#ifndef TWO_ZERO
l_int|NULL
comma
multiline_comment|/*&t;flush&t;*/
macro_line|#endif
id|rio_fw_release
comma
l_int|NULL
comma
multiline_comment|/*&t;fsync&t;*/
l_int|NULL
comma
multiline_comment|/*&t;fasync&t;*/
l_int|NULL
comma
multiline_comment|/*&t;check_media_change&t;*/
l_int|NULL
comma
multiline_comment|/*&t;revalidate&t;*/
)brace
suffix:semicolon
DECL|variable|rio_fw_device
r_struct
id|miscdevice
id|rio_fw_device
op_assign
(brace
id|RIOCTL_MISC_MINOR
comma
l_string|&quot;rioctl&quot;
comma
op_amp
id|rio_fw_fops
)brace
suffix:semicolon
macro_line|#ifdef RIO_PARANOIA_CHECK
multiline_comment|/* This doesn&squot;t work. Who&squot;s paranoid around here? Not me! */
DECL|function|rio_paranoia_check
r_static
r_inline
r_int
id|rio_paranoia_check
c_func
(paren
r_struct
id|rio_port
r_const
op_star
id|port
comma
id|kdev_t
id|device
comma
r_const
r_char
op_star
id|routine
)paren
(brace
r_static
r_const
r_char
op_star
id|badmagic
op_assign
id|KERN_ERR
l_string|&quot;rio: Warning: bad rio port magic number for device %s in %s&bslash;n&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|badinfo
op_assign
id|KERN_ERR
l_string|&quot;rio: Warning: null rio port for device %s in %s&bslash;n&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
(brace
id|printk
c_func
(paren
id|badinfo
comma
id|kdevname
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;magic
op_ne
id|RIO_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|badmagic
comma
id|kdevname
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
DECL|macro|rio_paranoia_check
mdefine_line|#define rio_paranoia_check(a,b,c) 0
macro_line|#endif
macro_line|#ifdef DEBUG
DECL|function|my_hd
r_void
id|my_hd
(paren
r_void
op_star
id|ad
comma
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|j
comma
id|ch
suffix:semicolon
r_int
r_char
op_star
id|addr
op_assign
id|ad
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_add_assign
l_int|16
)paren
(brace
id|printk
(paren
l_string|&quot;%08x &quot;
comma
(paren
r_int
)paren
id|addr
op_plus
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
(brace
id|printk
(paren
l_string|&quot;%02x %s&quot;
comma
id|addr
(braket
id|j
op_plus
id|i
)braket
comma
(paren
id|j
op_eq
l_int|7
)paren
ques
c_cond
l_string|&quot; &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
(brace
id|ch
op_assign
id|addr
(braket
id|j
op_plus
id|i
)braket
suffix:semicolon
id|printk
(paren
l_string|&quot;%c&quot;
comma
(paren
id|ch
OL
l_int|0x20
)paren
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
(paren
(paren
id|ch
OG
l_int|0x7f
)paren
ques
c_cond
l_char|&squot;.&squot;
suffix:colon
id|ch
)paren
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
DECL|macro|my_hd
mdefine_line|#define my_hd(ad,len) do{/* nothing*/ } while (0)
macro_line|#endif
multiline_comment|/* Delay a number of jiffies, allowing a signal to interrupt */
DECL|function|RIODelay
r_int
id|RIODelay
(paren
r_struct
id|Port
op_star
id|PortP
comma
r_int
id|njiffies
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_DELAY
comma
l_string|&quot;delaying %d jiffies&bslash;n&quot;
comma
id|njiffies
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|njiffies
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|RIO_FAIL
suffix:semicolon
r_else
r_return
op_logical_neg
id|RIO_FAIL
suffix:semicolon
)brace
multiline_comment|/* Delay a number of jiffies, disallowing a signal to interrupt */
DECL|function|RIODelay_ni
r_int
id|RIODelay_ni
(paren
r_struct
id|Port
op_star
id|PortP
comma
r_int
id|njiffies
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_DELAY
comma
l_string|&quot;delaying %d jiffies (ni)&bslash;n&quot;
comma
id|njiffies
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|njiffies
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
op_logical_neg
id|RIO_FAIL
suffix:semicolon
)brace
DECL|function|rio_minor
r_int
id|rio_minor
(paren
id|kdev_t
id|device
)paren
(brace
r_return
id|MINOR
(paren
id|device
)paren
op_plus
l_int|256
op_star
(paren
(paren
id|MAJOR
(paren
id|device
)paren
op_eq
id|RIO_NORMAL_MAJOR1
)paren
op_logical_or
(paren
id|MAJOR
(paren
id|device
)paren
op_eq
id|RIO_CALLOUT_MAJOR1
)paren
)paren
suffix:semicolon
)brace
DECL|function|rio_ismodem
r_int
id|rio_ismodem
(paren
id|kdev_t
id|device
)paren
(brace
r_return
(paren
id|MAJOR
(paren
id|device
)paren
op_ne
id|RIO_NORMAL_MAJOR0
)paren
op_logical_and
(paren
id|MAJOR
(paren
id|device
)paren
op_ne
id|RIO_NORMAL_MAJOR1
)paren
suffix:semicolon
)brace
DECL|function|rio_udelay
r_void
id|rio_udelay
(paren
r_int
id|usecs
)paren
(brace
id|udelay
(paren
id|usecs
)paren
suffix:semicolon
)brace
DECL|function|rio_inc_mod_count
r_void
id|rio_inc_mod_count
(paren
r_void
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|function|rio_dec_mod_count
r_void
id|rio_dec_mod_count
(paren
r_void
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|function|rio_set_real_termios
r_static
r_int
id|rio_set_real_termios
(paren
r_void
op_star
id|ptr
)paren
(brace
r_int
id|rv
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|rv
op_assign
id|RIOParam
c_func
(paren
(paren
r_struct
id|Port
op_star
)paren
id|ptr
comma
id|CONFIG
comma
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|rio_reset_interrupt
r_void
id|rio_reset_interrupt
(paren
r_struct
id|Host
op_star
id|HostP
)paren
(brace
r_switch
c_cond
(paren
id|HostP-&gt;Type
)paren
(brace
r_case
id|RIO_AT
suffix:colon
r_case
id|RIO_MCA
suffix:colon
r_case
id|RIO_PCI
suffix:colon
id|WBYTE
c_func
(paren
id|HostP-&gt;ResetInt
comma
l_int|0xff
)paren
suffix:semicolon
)brace
)brace
DECL|function|rio_interrupt
r_static
r_void
id|rio_interrupt
(paren
r_int
id|irq
comma
r_void
op_star
id|ptr
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
id|HostP
op_assign
op_amp
id|p-&gt;RIOHosts
(braket
(paren
r_int
)paren
id|ptr
)braket
suffix:semicolon
multiline_comment|/*   func_enter ();  */
id|rio_dprintk
(paren
id|RIO_DEBUG_IFLOW
comma
l_string|&quot;rio: enter rio_interrupt (%d/%d)&bslash;n&quot;
comma
id|irq
comma
id|HostP-&gt;Ivec
)paren
suffix:semicolon
multiline_comment|/* AAargh! The order in which to do these things is essential and&n;     not trivial. &n;     &n;     - Rate limit goes before &quot;recursive&quot;. Otherwise a series of&n;       recursive calls will hang the machine in the interrupt routine. &n;&n;     - hardware twiddling goes before &quot;recursive&quot;. Otherwise when we&n;       poll the card, and a recursive interrupt happens, we wont&n;       ack the card, so it might keep on interrupting us. (especially&n;       level sensitive interrupt systems like PCI).&n;&n;     - Rate limit goes before hardware twiddling. Otherwise we won&squot;t&n;       catch a card that has gone bonkers.&n;&n;     - The &quot;initialized&quot; test goes after the hardware twiddling. Otherwise&n;       the card will stick us in the interrupt routine again.&n;&n;     - The initialized test goes before recursive. &n;  */
macro_line|#ifdef IRQ_RATE_LIMIT
multiline_comment|/* Aaargh! I&squot;m ashamed. This costs more lines-of-code than the&n;     actual interrupt routine!. (Well, used to when I wrote that comment) */
(brace
r_static
r_int
id|lastjif
suffix:semicolon
r_static
r_int
id|nintr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|lastjif
op_eq
id|jiffies
)paren
(brace
r_if
c_cond
(paren
op_increment
id|nintr
OG
id|IRQ_RATE_LIMIT
)paren
(brace
id|free_irq
(paren
id|HostP-&gt;Ivec
comma
id|ptr
)paren
suffix:semicolon
id|printk
(paren
id|KERN_ERR
l_string|&quot;rio: Too many interrupts. Turning off interrupt %d.&bslash;n&quot;
comma
id|HostP-&gt;Ivec
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|lastjif
op_assign
id|jiffies
suffix:semicolon
id|nintr
op_assign
l_int|0
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|HostP-&gt;Ivec
op_eq
id|irq
)paren
(brace
multiline_comment|/* Tell the card we&squot;ve noticed the interrupt. */
id|rio_reset_interrupt
(paren
id|HostP
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|HostP-&gt;Flags
op_amp
id|RUN_STATE
)paren
op_ne
id|RC_RUNNING
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
(paren
id|RIO_BOARD_INTR_LOCK
comma
op_amp
id|HostP-&gt;locks
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;Recursive interrupt! (host %d/irq%d)&bslash;n&quot;
comma
(paren
r_int
)paren
id|ptr
comma
id|HostP-&gt;Ivec
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|RIOServiceHost
c_func
(paren
id|p
comma
id|HostP
comma
id|irq
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_IFLOW
comma
l_string|&quot;riointr() doing host %d type %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|ptr
comma
id|HostP-&gt;Type
)paren
suffix:semicolon
id|clear_bit
(paren
id|RIO_BOARD_INTR_LOCK
comma
op_amp
id|HostP-&gt;locks
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_IFLOW
comma
l_string|&quot;rio: exit rio_interrupt (%d/%d)&bslash;n&quot;
comma
id|irq
comma
id|HostP-&gt;Ivec
)paren
suffix:semicolon
multiline_comment|/*  func_exit ();  */
)brace
DECL|function|rio_pollfunc
r_static
r_void
id|rio_pollfunc
(paren
r_int
r_int
id|data
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|rio_interrupt
(paren
l_int|0
comma
(paren
r_void
op_star
)paren
id|data
comma
l_int|NULL
)paren
suffix:semicolon
id|p-&gt;RIOHosts
(braket
id|data
)braket
dot
id|timer.expires
op_assign
id|jiffies
op_plus
id|rio_poll
suffix:semicolon
id|add_timer
(paren
op_amp
id|p-&gt;RIOHosts
(braket
id|data
)braket
dot
id|timer
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* ********************************************************************** *&n; *                Here are the routines that actually                     *&n; *              interface with the generic_serial driver                  *&n; * ********************************************************************** */
multiline_comment|/* Ehhm. I don&squot;t know how to fiddle with interrupts on the Specialix &n;   cards. ....   Hmm. Ok I figured it out. You don&squot;t.  -- REW */
DECL|function|rio_disable_tx_interrupts
r_static
r_void
id|rio_disable_tx_interrupts
(paren
r_void
op_star
id|ptr
)paren
(brace
id|func_enter
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*  port-&gt;gs.flags &amp;= ~GS_TX_INTEN; */
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|rio_enable_tx_interrupts
r_static
r_void
id|rio_enable_tx_interrupts
(paren
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|Port
op_star
id|PortP
op_assign
id|ptr
suffix:semicolon
multiline_comment|/* int hn; */
id|func_enter
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* hn = PortP-&gt;HostP - p-&gt;RIOHosts;&n;&n;     rio_dprintk (RIO_DEBUG_TTY, &quot;Pushing host %d&bslash;n&quot;, hn);&n;     rio_interrupt (-1,(void *) hn, NULL); */
id|RIOTxEnable
c_func
(paren
(paren
r_char
op_star
)paren
id|PortP
)paren
suffix:semicolon
multiline_comment|/* &n;   * In general we cannot count on &quot;tx empty&quot; interrupts, although&n;   * the interrupt routine seems to be able to tell the difference. &n;   */
id|PortP-&gt;gs.flags
op_and_assign
op_complement
id|GS_TX_INTEN
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|rio_disable_rx_interrupts
r_static
r_void
id|rio_disable_rx_interrupts
(paren
r_void
op_star
id|ptr
)paren
(brace
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|rio_enable_rx_interrupts
r_static
r_void
id|rio_enable_rx_interrupts
(paren
r_void
op_star
id|ptr
)paren
(brace
multiline_comment|/*  struct rio_port *port = ptr; */
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Jeez. Isn&squot;t this simple?  */
DECL|function|rio_get_CD
r_static
r_int
id|rio_get_CD
(paren
r_void
op_star
id|ptr
)paren
(brace
r_struct
id|Port
op_star
id|PortP
op_assign
id|ptr
suffix:semicolon
r_int
id|rv
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|rv
op_assign
(paren
id|PortP-&gt;ModemState
op_amp
id|MSVR1_CD
)paren
op_ne
l_int|0
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INIT
comma
l_string|&quot;Getting CD status: %d&bslash;n&quot;
comma
id|rv
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
multiline_comment|/* Jeez. Isn&squot;t this simple? Actually, we can sync with the actual port&n;   by just pushing stuff into the queue going to the port... */
DECL|function|rio_chars_in_buffer
r_static
r_int
id|rio_chars_in_buffer
(paren
r_void
op_star
id|ptr
)paren
(brace
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Nothing special here... */
DECL|function|rio_shutdown_port
r_static
r_void
id|rio_shutdown_port
(paren
r_void
op_star
id|ptr
)paren
(brace
id|func_enter
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0
id|port-&gt;gs.flags
op_and_assign
op_complement
id|GS_ACTIVE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;gs.tty
)paren
(brace
id|printk
(paren
l_string|&quot;No tty.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|port-&gt;gs.tty-&gt;termios
)paren
(brace
id|printk
(paren
l_string|&quot;No termios.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|port-&gt;gs.tty-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
(brace
id|rio_setsignals
(paren
id|port
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* ********************************************************************** *&n; *                Here are the routines that actually                     *&n; *               interface with the rest of the system                    *&n; * ********************************************************************** */
DECL|function|rio_fw_open
r_static
r_int
id|rio_fw_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|rio_inc_mod_count
(paren
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rio_fw_release
r_static
id|INT
id|rio_fw_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|rio_dec_mod_count
(paren
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|NO_ERROR
suffix:semicolon
)brace
multiline_comment|/* I haven&squot;t the foggiest why the decrement use count has to happen&n;   here. The whole linux serial drivers stuff needs to be redesigned.&n;   My guess is that this is a hack to minimize the impact of a bug&n;   elsewhere. Thinking about it some more. (try it sometime) Try&n;   running minicom on a serial port that is driven by a modularized&n;   driver. Have the modem hangup. Then remove the driver module. Then&n;   exit minicom.  I expect an &quot;oops&quot;.  -- REW */
DECL|function|rio_hungup
r_static
r_void
id|rio_hungup
(paren
r_void
op_star
id|ptr
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
multiline_comment|/* rio_dec_mod_count (); */
id|func_exit
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* The standard serial_close would become shorter if you&squot;d wrap it like&n;   this. &n;   rs_close (...){save_flags;cli;real_close();dec_use_count;restore_flags;}&n; */
DECL|function|rio_close
r_static
r_void
id|rio_close
(paren
r_void
op_star
id|ptr
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
id|riotclose
(paren
id|ptr
)paren
suffix:semicolon
id|rio_dec_mod_count
(paren
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
)brace
DECL|function|rio_fw_ioctl
r_static
r_int
id|rio_fw_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* The &quot;dev&quot; argument isn&squot;t used. */
id|rc
op_assign
op_minus
id|riocontrol
(paren
id|p
comma
l_int|0
comma
id|cmd
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|suser
(paren
)paren
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|rio_ioctl
r_static
r_int
id|rio_ioctl
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
macro_line|#if 0
r_int
id|rc
suffix:semicolon
r_struct
id|rio_port
op_star
id|port
op_assign
id|tty-&gt;driver_data
suffix:semicolon
r_int
id|ival
suffix:semicolon
multiline_comment|/* func_enter2(); */
id|rc
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCGSOFTCAR
suffix:colon
id|rc
op_assign
id|Put_user
c_func
(paren
(paren
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSSOFTCAR
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|Get_user
c_func
(paren
id|ival
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|tty-&gt;termios-&gt;c_cflag
op_assign
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
op_complement
id|CLOCAL
)paren
op_or
(paren
id|ival
ques
c_cond
id|CLOCAL
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCGSERIAL
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|gs_getserial
c_func
(paren
op_amp
id|port-&gt;gs
comma
(paren
r_struct
id|serial_struct
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCSSERIAL
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|serial_struct
)paren
)paren
)paren
op_eq
l_int|0
)paren
id|rc
op_assign
id|gs_setserial
c_func
(paren
op_amp
id|port-&gt;gs
comma
(paren
r_struct
id|serial_struct
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TIOCMGET
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|ival
op_assign
id|rio_getsignals
c_func
(paren
id|port
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|ival
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMBIS
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|Get_user
c_func
(paren
id|ival
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|rio_setsignals
c_func
(paren
id|port
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
l_int|1
suffix:colon
op_minus
l_int|1
)paren
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
l_int|1
suffix:colon
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMBIC
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|Get_user
c_func
(paren
id|ival
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|rio_setsignals
c_func
(paren
id|port
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
)paren
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|TIOCMSET
suffix:colon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|Get_user
c_func
(paren
id|ival
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|rio_setsignals
c_func
(paren
id|port
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_DTR
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
comma
(paren
(paren
id|ival
op_amp
id|TIOCM_RTS
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|rc
op_assign
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* func_exit(); */
r_return
id|rc
suffix:semicolon
macro_line|#else
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* The throttle/unthrottle scheme for the Specialix card is different&n; * from other drivers and deserves some explanation. &n; * The Specialix hardware takes care of XON/XOFF&n; * and CTS/RTS flow control itself.  This means that all we have to&n; * do when signalled by the upper tty layer to throttle/unthrottle is&n; * to make a note of it here.  When we come to read characters from the&n; * rx buffers on the card (rio_receive_chars()) we look to see if the&n; * upper layer can accept more (as noted here in rio_rx_throt[]). &n; * If it can&squot;t we simply don&squot;t remove chars from the cards buffer. &n; * When the tty layer can accept chars, we again note that here and when&n; * rio_receive_chars() is called it will remove them from the cards buffer.&n; * The card will notice that a ports buffer has drained below some low&n; * water mark and will unflow control the line itself, using whatever&n; * flow control scheme is in use for that port. -- Simon Allen&n; */
DECL|function|rio_throttle
r_static
r_void
id|rio_throttle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|Port
op_star
id|port
op_assign
(paren
r_struct
id|Port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If the port is using any type of input flow&n;   * control then throttle the port.&n;   */
r_if
c_cond
(paren
(paren
id|tty-&gt;termios-&gt;c_cflag
op_amp
id|CRTSCTS
)paren
op_logical_or
(paren
id|I_IXOFF
c_func
(paren
id|tty
)paren
)paren
)paren
(brace
id|port-&gt;State
op_or_assign
id|RIO_THROTTLE_RX
suffix:semicolon
)brace
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|rio_unthrottle
r_static
r_void
id|rio_unthrottle
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|Port
op_star
id|port
op_assign
(paren
r_struct
id|Port
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Always unthrottle even if flow control is not enabled on&n;   * this port in case we disabled flow control while the port&n;   * was throttled&n;   */
id|port-&gt;State
op_and_assign
op_complement
id|RIO_THROTTLE_RX
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* ********************************************************************** *&n; *                    Here are the initialization routines.               *&n; * ********************************************************************** */
DECL|function|get_VPD_PROM
r_struct
id|vpd_prom
op_star
id|get_VPD_PROM
(paren
r_struct
id|Host
op_star
id|hp
)paren
(brace
r_static
r_struct
id|vpd_prom
id|vpdp
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_PROBE
comma
l_string|&quot;Going to verify vpd prom at %p.&bslash;n&quot;
comma
id|hp-&gt;Caddr
op_plus
id|RIO_VPD_ROM
)paren
suffix:semicolon
id|p
op_assign
(paren
r_char
op_star
)paren
op_amp
id|vpdp
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
r_struct
id|vpd_prom
)paren
suffix:semicolon
id|i
op_increment
)paren
op_star
id|p
op_increment
op_assign
id|readb
(paren
id|hp-&gt;Caddr
op_plus
id|RIO_VPD_ROM
op_plus
id|i
op_star
l_int|2
)paren
suffix:semicolon
multiline_comment|/* read_rio_byte (hp, RIO_VPD_ROM + i*2); */
multiline_comment|/* Terminate the identifier string. &n;     *** requires one extra byte in struct vpd_prom *** */
op_star
id|p
op_increment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rio_debug
op_amp
id|RIO_DEBUG_PROBE
)paren
id|my_hd
(paren
(paren
r_char
op_star
)paren
op_amp
id|vpdp
comma
l_int|0x20
)paren
suffix:semicolon
r_return
op_amp
id|vpdp
suffix:semicolon
)brace
DECL|function|rio_init_drivers
r_static
r_int
id|rio_init_drivers
c_func
(paren
r_void
)paren
(brace
r_int
id|error
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|rio_driver
comma
l_int|0
comma
r_sizeof
(paren
id|rio_driver
)paren
)paren
suffix:semicolon
id|rio_driver.magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
id|rio_driver.driver_name
op_assign
l_string|&quot;specialix_rio&quot;
suffix:semicolon
id|rio_driver.name
op_assign
l_string|&quot;ttySR&quot;
suffix:semicolon
id|rio_driver.major
op_assign
id|RIO_NORMAL_MAJOR0
suffix:semicolon
id|rio_driver.num
op_assign
l_int|256
suffix:semicolon
id|rio_driver.type
op_assign
id|TTY_DRIVER_TYPE_SERIAL
suffix:semicolon
id|rio_driver.subtype
op_assign
id|RIO_TYPE_NORMAL
suffix:semicolon
id|rio_driver.init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|rio_driver.init_termios.c_cflag
op_assign
id|B9600
op_or
id|CS8
op_or
id|CREAD
op_or
id|HUPCL
op_or
id|CLOCAL
suffix:semicolon
id|rio_driver.flags
op_assign
id|TTY_DRIVER_REAL_RAW
suffix:semicolon
id|rio_driver.refcount
op_assign
op_amp
id|rio_refcount
suffix:semicolon
id|rio_driver.table
op_assign
id|rio_table
suffix:semicolon
id|rio_driver.termios
op_assign
id|rio_termios
suffix:semicolon
id|rio_driver.termios_locked
op_assign
id|rio_termios_locked
suffix:semicolon
id|rio_driver.open
op_assign
id|riotopen
suffix:semicolon
id|rio_driver.close
op_assign
id|gs_close
suffix:semicolon
id|rio_driver.write
op_assign
id|gs_write
suffix:semicolon
id|rio_driver.put_char
op_assign
id|gs_put_char
suffix:semicolon
id|rio_driver.flush_chars
op_assign
id|gs_flush_chars
suffix:semicolon
id|rio_driver.write_room
op_assign
id|gs_write_room
suffix:semicolon
id|rio_driver.chars_in_buffer
op_assign
id|gs_chars_in_buffer
suffix:semicolon
id|rio_driver.flush_buffer
op_assign
id|gs_flush_buffer
suffix:semicolon
id|rio_driver.ioctl
op_assign
id|rio_ioctl
suffix:semicolon
id|rio_driver.throttle
op_assign
id|rio_throttle
suffix:semicolon
id|rio_driver.unthrottle
op_assign
id|rio_unthrottle
suffix:semicolon
id|rio_driver.set_termios
op_assign
id|gs_set_termios
suffix:semicolon
id|rio_driver.stop
op_assign
id|gs_stop
suffix:semicolon
id|rio_driver.start
op_assign
id|gs_start
suffix:semicolon
id|rio_driver.hangup
op_assign
id|gs_hangup
suffix:semicolon
id|rio_driver2
op_assign
id|rio_driver
suffix:semicolon
id|rio_driver.major
op_assign
id|RIO_NORMAL_MAJOR1
suffix:semicolon
id|rio_callout_driver
op_assign
id|rio_driver
suffix:semicolon
id|rio_callout_driver.name
op_assign
l_string|&quot;cusr&quot;
suffix:semicolon
id|rio_callout_driver.major
op_assign
id|RIO_CALLOUT_MAJOR0
suffix:semicolon
id|rio_callout_driver.subtype
op_assign
id|RIO_TYPE_CALLOUT
suffix:semicolon
id|rio_callout_driver2
op_assign
id|rio_callout_driver
suffix:semicolon
id|rio_callout_driver2.major
op_assign
id|RIO_CALLOUT_MAJOR1
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INIT
comma
l_string|&quot;set_termios = %p&bslash;n&quot;
comma
id|gs_set_termios
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|tty_register_driver
c_func
(paren
op_amp
id|rio_driver
)paren
)paren
)paren
r_goto
id|bad1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|tty_register_driver
c_func
(paren
op_amp
id|rio_driver2
)paren
)paren
)paren
r_goto
id|bad2
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|tty_register_driver
c_func
(paren
op_amp
id|rio_callout_driver
)paren
)paren
)paren
r_goto
id|bad3
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|tty_register_driver
c_func
(paren
op_amp
id|rio_callout_driver2
)paren
)paren
)paren
r_goto
id|bad4
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* &n; bad5:tty_unregister_driver (&amp;rio_callout_driver2); */
id|bad4
suffix:colon
id|tty_unregister_driver
(paren
op_amp
id|rio_callout_driver
)paren
suffix:semicolon
id|bad3
suffix:colon
id|tty_unregister_driver
(paren
op_amp
id|rio_driver2
)paren
suffix:semicolon
id|bad2
suffix:colon
id|tty_unregister_driver
(paren
op_amp
id|rio_driver
)paren
suffix:semicolon
id|bad1
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rio: Couldn&squot;t register a rio driver, error = %d&bslash;n&quot;
comma
id|error
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ckmalloc
r_static
r_void
op_star
id|ckmalloc
(paren
r_int
id|size
)paren
(brace
r_void
op_star
id|p
suffix:semicolon
id|p
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
id|size
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|rio_init_datastructures
r_static
r_int
id|rio_init_datastructures
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|Port
op_star
id|port
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Many drivers statically allocate the maximum number of ports&n;     There is no reason not to allocate them dynamically. Is there? -- REW */
multiline_comment|/* However, the RIO driver allows users to configure their first&n;     RTA as the ports numbered 504-511. We therefore need to allocate &n;     the whole range. :-(   -- REW */
DECL|macro|RI_SZ
mdefine_line|#define RI_SZ   sizeof(struct rio_info)
DECL|macro|HOST_SZ
mdefine_line|#define HOST_SZ sizeof(struct Host)
DECL|macro|PORT_SZ
mdefine_line|#define PORT_SZ sizeof(struct Port *)
DECL|macro|TMIO_SZ
mdefine_line|#define TMIO_SZ sizeof(struct termios *)
id|rio_dprintk
(paren
id|RIO_DEBUG_INIT
comma
l_string|&quot;getting : %d %d %d %d %d bytes&bslash;n&quot;
comma
id|RI_SZ
comma
id|RIO_HOSTS
op_star
id|HOST_SZ
comma
id|RIO_PORTS
op_star
id|PORT_SZ
comma
id|RIO_PORTS
op_star
id|TMIO_SZ
comma
id|RIO_PORTS
op_star
id|TMIO_SZ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p
op_assign
id|ckmalloc
(paren
id|RI_SZ
)paren
)paren
)paren
r_goto
id|free0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;RIOHosts
op_assign
id|ckmalloc
(paren
id|RIO_HOSTS
op_star
id|HOST_SZ
)paren
)paren
)paren
r_goto
id|free1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|p-&gt;RIOPortp
op_assign
id|ckmalloc
(paren
id|RIO_PORTS
op_star
id|PORT_SZ
)paren
)paren
)paren
r_goto
id|free2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rio_termios
op_assign
id|ckmalloc
(paren
id|RIO_PORTS
op_star
id|TMIO_SZ
)paren
)paren
)paren
r_goto
id|free3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|rio_termios_locked
op_assign
id|ckmalloc
(paren
id|RIO_PORTS
op_star
id|TMIO_SZ
)paren
)paren
)paren
r_goto
id|free4
suffix:semicolon
id|p-&gt;RIOConf
op_assign
id|RIOConf
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INIT
comma
l_string|&quot;Got : %p %p %p %p %p&bslash;n&quot;
comma
id|p
comma
id|p-&gt;RIOHosts
comma
id|p-&gt;RIOPortp
comma
id|rio_termios
comma
id|rio_termios
)paren
suffix:semicolon
multiline_comment|/* Adjust the values in the &quot;driver&quot; */
id|rio_driver.termios
op_assign
id|rio_termios
suffix:semicolon
id|rio_driver.termios_locked
op_assign
id|rio_termios_locked
suffix:semicolon
macro_line|#if 1
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RIO_PORTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|port
op_assign
id|p-&gt;RIOPortp
(braket
id|i
)braket
op_assign
id|ckmalloc
(paren
r_sizeof
(paren
r_struct
id|Port
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
(brace
r_goto
id|free6
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INIT
comma
l_string|&quot;initing port %d (%d)&bslash;n&quot;
comma
id|i
comma
id|port-&gt;Mapped
)paren
suffix:semicolon
id|port-&gt;PortNum
op_assign
id|i
suffix:semicolon
id|port-&gt;gs.callout_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|port-&gt;gs.normal_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|port-&gt;gs.magic
op_assign
id|RIO_MAGIC
suffix:semicolon
id|port-&gt;gs.close_delay
op_assign
id|HZ
op_div
l_int|2
suffix:semicolon
id|port-&gt;gs.closing_wait
op_assign
l_int|30
op_star
id|HZ
suffix:semicolon
id|port-&gt;gs.rd
op_assign
op_amp
id|rio_real_driver
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/* We could postpone initializing them to when they are configured. */
macro_line|#endif
r_if
c_cond
(paren
id|rio_debug
op_amp
id|RIO_DEBUG_INIT
)paren
(brace
id|my_hd
(paren
op_amp
id|rio_real_driver
comma
r_sizeof
(paren
id|rio_real_driver
)paren
)paren
suffix:semicolon
)brace
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|free6
suffix:colon
r_for
c_loop
(paren
id|i
op_decrement
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
id|kfree
(paren
id|p-&gt;RIOPortp
(braket
id|i
)braket
)paren
suffix:semicolon
multiline_comment|/*free5: */
id|kfree
(paren
id|rio_termios_locked
)paren
suffix:semicolon
id|free4
suffix:colon
id|kfree
(paren
id|rio_termios
)paren
suffix:semicolon
id|free3
suffix:colon
id|kfree
(paren
id|p-&gt;RIOPortp
)paren
suffix:semicolon
id|free2
suffix:colon
id|kfree
(paren
id|p-&gt;RIOHosts
)paren
suffix:semicolon
id|free1
suffix:colon
id|kfree
(paren
id|p
)paren
suffix:semicolon
id|free0
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_INIT
comma
l_string|&quot;Not enough memory! %p %p %p %p %p&bslash;n&quot;
comma
id|p
comma
id|p-&gt;RIOHosts
comma
id|p-&gt;RIOPortp
comma
id|rio_termios
comma
id|rio_termios
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|rio_release_drivers
r_static
r_void
id|rio_release_drivers
c_func
(paren
r_void
)paren
(brace
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|tty_unregister_driver
(paren
op_amp
id|rio_callout_driver2
)paren
suffix:semicolon
id|tty_unregister_driver
(paren
op_amp
id|rio_callout_driver
)paren
suffix:semicolon
id|tty_unregister_driver
(paren
op_amp
id|rio_driver2
)paren
suffix:semicolon
id|tty_unregister_driver
(paren
op_amp
id|rio_driver
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef TWO_ZERO
DECL|macro|PDEV
mdefine_line|#define PDEV unsigned char pci_bus, unsigned pci_fun
DECL|macro|pdev
mdefine_line|#define pdev pci_bus, pci_fun
macro_line|#else
DECL|macro|PDEV
mdefine_line|#define PDEV   struct pci_dev *pdev
macro_line|#endif
macro_line|#ifdef CONFIG_PCI
multiline_comment|/* This was written for SX, but applies to RIO too...&n;    (including bugs....)&n;&n;    There is another bit besides Bit 17. Turning that bit off&n;    (on boards shipped with the fix in the eeprom) results in a &n;    hang on the next access to the card. &n; */
multiline_comment|/******************************************************** &n; * Setting bit 17 in the CNTRL register of the PLX 9050  * &n; * chip forces a retry on writes while a read is pending.*&n; * This is to prevent the card locking up on Intel Xeon  *&n; * multiprocessor systems with the NX chipset.    -- NV  *&n; ********************************************************/
multiline_comment|/* Newer cards are produced with this bit set from the configuration&n;   EEprom.  As the bit is read/write for the CPU, we can fix it here,&n;   if we detect that it isn&squot;t set correctly. -- REW */
DECL|function|fix_rio_pci
r_void
id|fix_rio_pci
(paren
id|PDEV
)paren
(brace
r_int
r_int
id|hwbase
suffix:semicolon
r_int
r_int
id|rebase
suffix:semicolon
r_int
r_int
id|t
suffix:semicolon
DECL|macro|CNTRL_REG_OFFSET
mdefine_line|#define CNTRL_REG_OFFSET        0x50
DECL|macro|CNTRL_REG_GOODVALUE
mdefine_line|#define CNTRL_REG_GOODVALUE     0x00260000
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|hwbase
)paren
suffix:semicolon
id|hwbase
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|rebase
op_assign
(paren
id|ulong
)paren
id|ioremap
c_func
(paren
id|hwbase
comma
l_int|0x80
)paren
suffix:semicolon
id|t
op_assign
id|readl
(paren
id|rebase
op_plus
id|CNTRL_REG_OFFSET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_ne
id|CNTRL_REG_GOODVALUE
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;rio: performing cntrl reg fix: %08x -&gt; %08x&bslash;n&quot;
comma
id|t
comma
id|CNTRL_REG_GOODVALUE
)paren
suffix:semicolon
id|writel
(paren
id|CNTRL_REG_GOODVALUE
comma
id|rebase
op_plus
id|CNTRL_REG_OFFSET
)paren
suffix:semicolon
)brace
id|my_iounmap
(paren
id|hwbase
comma
id|rebase
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef MODULE
DECL|macro|rio_init
mdefine_line|#define rio_init init_module
macro_line|#endif
r_extern
r_int
id|gs_debug
suffix:semicolon
DECL|function|rio_init
r_int
id|rio_init
c_func
(paren
r_void
)paren
(brace
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|Host
op_star
id|hp
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_struct
id|vpd_prom
op_star
id|vpdp
suffix:semicolon
r_int
id|okboard
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
macro_line|#ifndef TWO_ZERO
r_struct
id|pci_dev
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
macro_line|#else
r_int
r_char
id|pci_bus
comma
id|pci_fun
suffix:semicolon
multiline_comment|/* in 2.2.x pdev is a pointer defining a PCI device. In 2.0 its the bus/fn */
macro_line|#endif
r_int
r_int
id|tint
suffix:semicolon
r_int
r_int
id|tshort
suffix:semicolon
macro_line|#endif
id|func_enter
c_func
(paren
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INIT
comma
l_string|&quot;Initing rio module... (rio_debug=%d)&bslash;n&quot;
comma
id|rio_debug
)paren
suffix:semicolon
id|gs_debug
op_assign
id|rio_debug
op_rshift
l_int|24
suffix:semicolon
r_if
c_cond
(paren
id|abs
(paren
(paren
r_int
)paren
(paren
op_amp
id|rio_debug
)paren
op_minus
id|rio_debug
)paren
OL
l_int|0x10000
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;rio: rio_debug is an address, instead of a value. &quot;
l_string|&quot;Assuming -1. Was %x/%p.&bslash;n&quot;
comma
id|rio_debug
comma
op_amp
id|rio_debug
)paren
suffix:semicolon
id|rio_debug
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|retval
op_assign
id|rio_init_datastructures
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
id|retval
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
r_if
c_cond
(paren
id|pci_present
(paren
)paren
)paren
(brace
multiline_comment|/* First look for the JET devices: */
macro_line|#ifndef TWO_ZERO
r_while
c_loop
(paren
(paren
id|pdev
op_assign
id|pci_find_device
(paren
id|PCI_VENDOR_ID_SPECIALIX
comma
id|PCI_DEVICE_ID_SPECIALIX_SX_XIO_IO8
comma
id|pdev
)paren
)paren
)paren
(brace
macro_line|#else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RIO_NBOARDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcibios_find_device
(paren
id|PCI_VENDOR_ID_SPECIALIX
comma
id|PCI_DEVICE_ID_SPECIALIX_SX_XIO_IO8
comma
id|i
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_fun
)paren
)paren
r_break
suffix:semicolon
macro_line|#endif
multiline_comment|/* Specialix has a whole bunch of cards with&n;         0x2000 as the device ID. They say its because&n;         the standard requires it. Stupid standard. */
multiline_comment|/* It seems that reading a word doesn&squot;t work reliably on 2.0.&n;         Also, reading a non-aligned dword doesn&squot;t work. So we read the&n;         whole dword at 0x2c and extract the word at 0x2e (SUBSYSTEM_ID)&n;         ourselves */
multiline_comment|/* I don&squot;t know why the define doesn&squot;t work, constant 0x2c does --REW */
id|pci_read_config_dword
(paren
id|pdev
comma
l_int|0x2c
comma
op_amp
id|tint
)paren
suffix:semicolon
id|tshort
op_assign
(paren
id|tint
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_PROBE
comma
l_string|&quot;Got a specialix card: %x.&bslash;n&quot;
comma
id|tint
)paren
suffix:semicolon
multiline_comment|/* rio_dprintk (RIO_DEBUG_PROBE, &quot;pdev = %d/%d  (%x)&bslash;n&quot;, pdev, tint); */
r_if
c_cond
(paren
id|tshort
op_ne
l_int|0x0100
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PROBE
comma
l_string|&quot;But it&squot;s not a RIO card (%d)...&bslash;n&quot;
comma
id|tshort
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PROBE
comma
l_string|&quot;cp1&bslash;n&quot;
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BASE_ADDRESS_2
comma
op_amp
id|tint
)paren
suffix:semicolon
id|hp
op_assign
op_amp
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
suffix:semicolon
id|hp-&gt;PaddrP
op_assign
id|tint
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|hp-&gt;Ivec
op_assign
id|get_irq
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
l_int|1
op_lshift
id|hp-&gt;Ivec
)paren
op_amp
id|rio_irqmask
)paren
op_eq
l_int|0
)paren
id|hp-&gt;Ivec
op_assign
l_int|0
suffix:semicolon
id|hp-&gt;CardP
op_assign
(paren
r_struct
id|DpRam
op_star
)paren
id|hp-&gt;Caddr
op_assign
id|ioremap
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|PaddrP
comma
id|RIO_WINDOW_LEN
)paren
suffix:semicolon
id|hp-&gt;Type
op_assign
id|RIO_PCI
suffix:semicolon
id|hp-&gt;Copy
op_assign
id|rio_pcicopy
suffix:semicolon
id|hp-&gt;Mode
op_assign
id|RIO_PCI_DEFAULT_MODE
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_PROBE
comma
l_string|&quot;Going to test it (%p/%p).&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|PaddrP
comma
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|Caddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RIOBoardTest
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|PaddrP
comma
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|Caddr
comma
id|RIO_PCI
comma
l_int|0
)paren
op_eq
id|RIO_SUCCESS
)paren
(brace
id|WBYTE
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|ResetInt
comma
l_int|0xff
)paren
suffix:semicolon
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|UniqueNum
op_assign
(paren
(paren
id|RBYTE
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|Unique
(braket
l_int|0
)braket
)paren
op_amp
l_int|0xFF
)paren
op_lshift
l_int|0
)paren
op_or
(paren
(paren
id|RBYTE
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|Unique
(braket
l_int|1
)braket
)paren
op_amp
l_int|0xFF
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|RBYTE
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|Unique
(braket
l_int|2
)braket
)paren
op_amp
l_int|0xFF
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|RBYTE
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|Unique
(braket
l_int|3
)braket
)paren
op_amp
l_int|0xFF
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_PROBE
comma
l_string|&quot;Hmm Tested ok, uniqid = %x.&bslash;n&quot;
comma
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|UniqueNum
)paren
suffix:semicolon
macro_line|#if 1
id|fix_rio_pci
(paren
id|pdev
)paren
suffix:semicolon
macro_line|#endif
id|p-&gt;RIOLastPCISearch
op_assign
id|RIO_SUCCESS
suffix:semicolon
id|p-&gt;RIONumHosts
op_increment
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
r_else
(brace
id|my_iounmap
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|PaddrP
comma
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|Caddr
)paren
suffix:semicolon
)brace
macro_line|#ifdef TWO_ZERO
)brace
multiline_comment|/* We have two variants with the opening brace, so to prevent */
macro_line|#else
)brace
multiline_comment|/* Emacs from getting confused we have two closing braces too. */
macro_line|#endif
multiline_comment|/* Then look for the older PCI card.... : */
macro_line|#ifndef TWO_ZERO
multiline_comment|/* These older PCI cards have problems (only byte-mode access is&n;     supported), which makes them a bit awkward to support. &n;     They also have problems sharing interrupts. Be careful. &n;     (The driver now refuses to share interrupts for these&n;     cards. This should be sufficient).&n;  */
multiline_comment|/* Then look for the older RIO/PCI devices: */
r_while
c_loop
(paren
(paren
id|pdev
op_assign
id|pci_find_device
(paren
id|PCI_VENDOR_ID_SPECIALIX
comma
id|PCI_DEVICE_ID_SPECIALIX_RIO
comma
id|pdev
)paren
)paren
)paren
(brace
macro_line|#else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|RIO_NBOARDS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcibios_find_device
(paren
id|PCI_VENDOR_ID_SPECIALIX
comma
id|PCI_DEVICE_ID_SPECIALIX_RIO
comma
id|i
comma
op_amp
id|pci_bus
comma
op_amp
id|pci_fun
)paren
)paren
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_RIO_OLDPCI
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|tint
)paren
suffix:semicolon
id|hp
op_assign
op_amp
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
suffix:semicolon
id|hp-&gt;PaddrP
op_assign
id|tint
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
suffix:semicolon
id|hp-&gt;Ivec
op_assign
id|get_irq
(paren
id|pdev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
l_int|1
op_lshift
id|hp-&gt;Ivec
)paren
op_amp
id|rio_irqmask
)paren
op_eq
l_int|0
)paren
id|hp-&gt;Ivec
op_assign
l_int|0
suffix:semicolon
id|hp-&gt;Ivec
op_or_assign
l_int|0x8000
suffix:semicolon
multiline_comment|/* Mark as non-sharable */
id|hp-&gt;CardP
op_assign
(paren
r_struct
id|DpRam
op_star
)paren
id|hp-&gt;Caddr
op_assign
id|ioremap
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|PaddrP
comma
id|RIO_WINDOW_LEN
)paren
suffix:semicolon
id|hp-&gt;Type
op_assign
id|RIO_PCI
suffix:semicolon
id|hp-&gt;Copy
op_assign
id|rio_pcicopy
suffix:semicolon
id|hp-&gt;Mode
op_assign
id|RIO_PCI_DEFAULT_MODE
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_PROBE
comma
l_string|&quot;Going to test it (%p/%p).&bslash;n&quot;
comma
(paren
r_void
op_star
)paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|PaddrP
comma
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|Caddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RIOBoardTest
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|PaddrP
comma
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|Caddr
comma
id|RIO_PCI
comma
l_int|0
)paren
op_eq
id|RIO_SUCCESS
)paren
(brace
id|WBYTE
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|ResetInt
comma
l_int|0xff
)paren
suffix:semicolon
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|UniqueNum
op_assign
(paren
(paren
id|RBYTE
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|Unique
(braket
l_int|0
)braket
)paren
op_amp
l_int|0xFF
)paren
op_lshift
l_int|0
)paren
op_or
(paren
(paren
id|RBYTE
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|Unique
(braket
l_int|1
)braket
)paren
op_amp
l_int|0xFF
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|RBYTE
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|Unique
(braket
l_int|2
)braket
)paren
op_amp
l_int|0xFF
)paren
op_lshift
l_int|16
)paren
op_or
(paren
(paren
id|RBYTE
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|Unique
(braket
l_int|3
)braket
)paren
op_amp
l_int|0xFF
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_PROBE
comma
l_string|&quot;Hmm Tested ok, uniqid = %x.&bslash;n&quot;
comma
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|UniqueNum
)paren
suffix:semicolon
id|p-&gt;RIOLastPCISearch
op_assign
id|RIO_SUCCESS
suffix:semicolon
id|p-&gt;RIONumHosts
op_increment
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
r_else
(brace
id|my_iounmap
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|PaddrP
comma
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|Caddr
)paren
suffix:semicolon
)brace
macro_line|#else
id|printk
(paren
id|KERN_ERR
l_string|&quot;Found an older RIO PCI card, but the driver is not &quot;
l_string|&quot;compiled to support it.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef TWO_ZERO
)brace
multiline_comment|/* We have two variants with the opening brace, so to prevent */
macro_line|#else
)brace
multiline_comment|/* Emacs from getting confused we have two closing braces too. */
macro_line|#endif
)brace
macro_line|#endif /* PCI */
multiline_comment|/* Now probe for ISA cards... */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_RIO_ADDRS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hp
op_assign
op_amp
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
suffix:semicolon
id|hp-&gt;PaddrP
op_assign
id|rio_probe_addrs
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* There was something about the IRQs of these cards. &squot;Forget what.--REW */
id|hp-&gt;Ivec
op_assign
l_int|0
suffix:semicolon
id|hp-&gt;CardP
op_assign
(paren
r_struct
id|DpRam
op_star
)paren
id|hp-&gt;Caddr
op_assign
id|ioremap
c_func
(paren
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|PaddrP
comma
id|RIO_WINDOW_LEN
)paren
suffix:semicolon
id|hp-&gt;Type
op_assign
id|RIO_AT
suffix:semicolon
id|hp-&gt;Copy
op_assign
id|rio_pcicopy
suffix:semicolon
id|hp-&gt;Mode
op_assign
l_int|0
suffix:semicolon
id|vpdp
op_assign
id|get_VPD_PROM
(paren
id|hp
)paren
suffix:semicolon
id|okboard
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|strncmp
(paren
id|vpdp-&gt;identifier
comma
id|RIO_ISA_IDENT
comma
l_int|16
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|strncmp
(paren
id|vpdp-&gt;identifier
comma
id|RIO_ISA2_IDENT
comma
l_int|16
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|strncmp
(paren
id|vpdp-&gt;identifier
comma
id|RIO_ISA3_IDENT
comma
l_int|16
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Board is present... */
r_if
c_cond
(paren
id|RIOBoardTest
(paren
id|hp-&gt;PaddrP
comma
id|hp-&gt;Caddr
comma
id|RIO_AT
comma
l_int|0
)paren
op_eq
id|RIO_SUCCESS
)paren
(brace
multiline_comment|/* ... and feeling fine!!!! */
id|rio_dprintk
(paren
id|RIO_DEBUG_PROBE
comma
l_string|&quot;Hmm Tested ok, uniqid = %x.&bslash;n&quot;
comma
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
)braket
dot
id|UniqueNum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RIOAssignAT
c_func
(paren
id|p
comma
id|hp-&gt;PaddrP
comma
id|hp-&gt;Caddr
comma
l_int|0
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PROBE
comma
l_string|&quot;Hmm Tested ok, host%d uniqid = %x.&bslash;n&quot;
comma
id|p-&gt;RIONumHosts
comma
id|p-&gt;RIOHosts
(braket
id|p-&gt;RIONumHosts
op_minus
l_int|1
)braket
dot
id|UniqueNum
)paren
suffix:semicolon
id|okboard
op_increment
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|okboard
)paren
id|my_iounmap
(paren
id|hp-&gt;PaddrP
comma
id|hp-&gt;Caddr
)paren
suffix:semicolon
)brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|p-&gt;RIONumHosts
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hp
op_assign
op_amp
id|p-&gt;RIOHosts
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hp-&gt;Ivec
)paren
(brace
r_int
id|mode
op_assign
id|SA_SHIRQ
suffix:semicolon
r_if
c_cond
(paren
id|hp-&gt;Ivec
op_amp
l_int|0x8000
)paren
(brace
id|mode
op_assign
l_int|0
suffix:semicolon
id|hp-&gt;Ivec
op_and_assign
l_int|0x7fff
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
(paren
id|hp-&gt;Ivec
comma
id|rio_interrupt
comma
id|mode
comma
l_string|&quot;rio&quot;
comma
(paren
r_void
op_star
)paren
id|i
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;rio: Cannot allocate irq %d.&bslash;n&quot;
comma
id|hp-&gt;Ivec
)paren
suffix:semicolon
id|hp-&gt;Ivec
op_assign
l_int|0
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INIT
comma
l_string|&quot;Got irq %d.&bslash;n&quot;
comma
id|hp-&gt;Ivec
)paren
suffix:semicolon
)brace
multiline_comment|/* Init the timer &quot;always&quot; to make sure that it can safely be &n;       deleted when we unload... */
id|init_timer
(paren
op_amp
id|hp-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hp-&gt;Ivec
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INIT
comma
l_string|&quot;Starting polling at %dj intervals.&bslash;n&quot;
comma
id|rio_poll
)paren
suffix:semicolon
id|hp-&gt;timer.data
op_assign
id|i
suffix:semicolon
id|hp-&gt;timer.function
op_assign
id|rio_pollfunc
suffix:semicolon
id|hp-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|rio_poll
suffix:semicolon
id|add_timer
(paren
op_amp
id|hp-&gt;timer
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|found
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;rio: total of %d boards detected.&bslash;n&quot;
comma
id|found
)paren
suffix:semicolon
r_if
c_cond
(paren
id|misc_register
c_func
(paren
op_amp
id|rio_fw_device
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RIO: Unable to register firmware loader driver.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|rio_init_drivers
(paren
)paren
suffix:semicolon
)brace
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
id|found
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|Host
op_star
id|hp
suffix:semicolon
id|func_enter
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|hp
op_assign
id|p-&gt;RIOHosts
suffix:semicolon
id|i
OL
id|p-&gt;RIONumHosts
suffix:semicolon
id|i
op_increment
comma
id|hp
op_increment
)paren
(brace
id|RIOHostReset
(paren
id|hp-&gt;Type
comma
id|hp-&gt;CardP
comma
id|hp-&gt;Slot
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hp-&gt;Ivec
)paren
(brace
id|free_irq
(paren
id|hp-&gt;Ivec
comma
(paren
r_void
op_star
)paren
id|i
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INIT
comma
l_string|&quot;freed irq %d.&bslash;n&quot;
comma
id|hp-&gt;Ivec
)paren
suffix:semicolon
)brace
multiline_comment|/* It is safe/allowed to del_timer a non-active timer */
id|del_timer
(paren
op_amp
id|hp-&gt;timer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|misc_deregister
c_func
(paren
op_amp
id|rio_fw_device
)paren
OL
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;rio: couldn&squot;t deregister control-device&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CLEANUP
comma
l_string|&quot;Cleaning up drivers&bslash;n&quot;
)paren
suffix:semicolon
id|rio_release_drivers
(paren
)paren
suffix:semicolon
multiline_comment|/* Release dynamically allocated memory */
id|kfree
(paren
id|rio_termios_locked
)paren
suffix:semicolon
id|kfree
(paren
id|rio_termios
)paren
suffix:semicolon
id|kfree
(paren
id|p-&gt;RIOPortp
)paren
suffix:semicolon
id|kfree
(paren
id|p-&gt;RIOHosts
)paren
suffix:semicolon
id|kfree
(paren
id|p
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Anybody who knows why this doesn&squot;t work for me, please tell me -- REW.&n; * Snatched from scsi.c (fixed one spelling error):&n; * Overrides for Emacs so that we follow Linus&squot; tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local Variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
