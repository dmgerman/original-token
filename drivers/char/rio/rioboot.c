multiline_comment|/*&n;** -----------------------------------------------------------------------------&n;**&n;**  Perle Specialix driver for Linux&n;**  Ported from existing RIO Driver for SCO sources.&n; *&n; *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.&n; *&n; *      This program is free software; you can redistribute it and/or modify&n; *      it under the terms of the GNU General Public License as published by&n; *      the Free Software Foundation; either version 2 of the License, or&n; *      (at your option) any later version.&n; *&n; *      This program is distributed in the hope that it will be useful,&n; *      but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *      GNU General Public License for more details.&n; *&n; *      You should have received a copy of the GNU General Public License&n; *      along with this program; if not, write to the Free Software&n; *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;**&n;**&t;Module&t;&t;: rioboot.c&n;**&t;SID&t;&t;: 1.3&n;**&t;Last Modified&t;: 11/6/98 10:33:36&n;**&t;Retrieved&t;: 11/6/98 10:33:48&n;**&n;**  ident @(#)rioboot.c&t;1.3&n;**&n;** -----------------------------------------------------------------------------&n;*/
macro_line|#ifdef SCCS_LABELS
DECL|variable|_rioboot_c_sccs_
r_static
r_char
op_star
id|_rioboot_c_sccs_
op_assign
l_string|&quot;@(#)rioboot.c&t;1.3&quot;
suffix:semicolon
macro_line|#endif
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/string.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/compatmac.h&gt;
macro_line|#include &lt;linux/generic_serial.h&gt;
macro_line|#include &quot;linux_compat.h&quot;
macro_line|#include &quot;rio_linux.h&quot;
macro_line|#include &quot;typdef.h&quot;
macro_line|#include &quot;pkt.h&quot;
macro_line|#include &quot;daemon.h&quot;
macro_line|#include &quot;rio.h&quot;
macro_line|#include &quot;riospace.h&quot;
macro_line|#include &quot;top.h&quot;
macro_line|#include &quot;cmdpkt.h&quot;
macro_line|#include &quot;map.h&quot;
macro_line|#include &quot;riotypes.h&quot;
macro_line|#include &quot;rup.h&quot;
macro_line|#include &quot;port.h&quot;
macro_line|#include &quot;riodrvr.h&quot;
macro_line|#include &quot;rioinfo.h&quot;
macro_line|#include &quot;func.h&quot;
macro_line|#include &quot;errors.h&quot;
macro_line|#include &quot;pci.h&quot;
macro_line|#include &quot;parmmap.h&quot;
macro_line|#include &quot;unixrup.h&quot;
macro_line|#include &quot;board.h&quot;
macro_line|#include &quot;host.h&quot;
macro_line|#include &quot;error.h&quot;
macro_line|#include &quot;phb.h&quot;
macro_line|#include &quot;link.h&quot;
macro_line|#include &quot;cmdblk.h&quot;
macro_line|#include &quot;route.h&quot;
r_static
id|uchar
DECL|variable|RIOAtVec2Ctrl
id|RIOAtVec2Ctrl
(braket
)braket
op_assign
(brace
multiline_comment|/* 0 */
id|INTERRUPT_DISABLE
comma
multiline_comment|/* 1 */
id|INTERRUPT_DISABLE
comma
multiline_comment|/* 2 */
id|INTERRUPT_DISABLE
comma
multiline_comment|/* 3 */
id|INTERRUPT_DISABLE
comma
multiline_comment|/* 4 */
id|INTERRUPT_DISABLE
comma
multiline_comment|/* 5 */
id|INTERRUPT_DISABLE
comma
multiline_comment|/* 6 */
id|INTERRUPT_DISABLE
comma
multiline_comment|/* 7 */
id|INTERRUPT_DISABLE
comma
multiline_comment|/* 8 */
id|INTERRUPT_DISABLE
comma
multiline_comment|/* 9 */
id|IRQ_9
op_or
id|INTERRUPT_ENABLE
comma
multiline_comment|/* 10 */
id|INTERRUPT_DISABLE
comma
multiline_comment|/* 11 */
id|IRQ_11
op_or
id|INTERRUPT_ENABLE
comma
multiline_comment|/* 12 */
id|IRQ_12
op_or
id|INTERRUPT_ENABLE
comma
multiline_comment|/* 13 */
id|INTERRUPT_DISABLE
comma
multiline_comment|/* 14 */
id|INTERRUPT_DISABLE
comma
multiline_comment|/* 15 */
id|IRQ_15
op_or
id|INTERRUPT_ENABLE
)brace
suffix:semicolon
multiline_comment|/*&n;** Load in the RTA boot code.&n;*/
r_int
DECL|function|RIOBootCodeRTA
id|RIOBootCodeRTA
c_func
(paren
id|p
comma
id|rbp
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
r_struct
id|DownLoad
op_star
id|rbp
suffix:semicolon
(brace
r_int
id|offset
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
multiline_comment|/* Linux doesn&squot;t allow you to disable interrupts during a&n;&t;   &quot;copyin&quot;. (Crash when a pagefault occurs). */
multiline_comment|/* disable(oldspl); */
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Data at user address 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|rbp-&gt;DataP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Check that we have set asside enough memory for this&n;&t;*/
r_if
c_cond
(paren
id|rbp-&gt;Count
OG
id|SIXTY_FOUR_K
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;RTA Boot Code Too Large!&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;RIOError.Error
op_assign
id|HOST_FILE_TOO_LARGE
suffix:semicolon
multiline_comment|/* restore(oldspl); */
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;RIOBooting
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;RTA Boot Code : BUSY BUSY BUSY!&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;RIOError.Error
op_assign
id|BOOT_IN_PROGRESS
suffix:semicolon
multiline_comment|/* restore(oldspl); */
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** The data we load in must end on a (RTA_BOOT_DATA_SIZE) byte boundary,&n;&t;** so calculate how far we have to move the data up the buffer&n;&t;** to achieve this.&n;&t;*/
id|offset
op_assign
(paren
id|RTA_BOOT_DATA_SIZE
op_minus
(paren
id|rbp-&gt;Count
op_mod
id|RTA_BOOT_DATA_SIZE
)paren
)paren
op_mod
id|RTA_BOOT_DATA_SIZE
suffix:semicolon
multiline_comment|/*&n;&t;** Be clean, and clear the &squot;unused&squot; portion of the boot buffer,&n;&t;** because it will (eventually) be part of the Rta run time environment&n;&t;** and so should be zeroed.&n;&t;*/
id|bzero
c_func
(paren
(paren
id|caddr_t
)paren
id|p-&gt;RIOBootPackets
comma
id|offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Copy the data from user space.&n;&t;*/
r_if
c_cond
(paren
id|copyin
c_func
(paren
(paren
r_int
)paren
id|rbp-&gt;DataP
comma
(paren
(paren
id|caddr_t
)paren
(paren
id|p-&gt;RIOBootPackets
)paren
)paren
op_plus
id|offset
comma
id|rbp-&gt;Count
)paren
op_eq
id|COPYFAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Bad data copy from user space&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;RIOError.Error
op_assign
id|COPYIN_FAILED
suffix:semicolon
multiline_comment|/* restore(oldspl); */
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Make sure that our copy of the size includes that offset we discussed&n;&t;** earlier.&n;&t;*/
id|p-&gt;RIONumBootPkts
op_assign
(paren
id|rbp-&gt;Count
op_plus
id|offset
)paren
op_div
id|RTA_BOOT_DATA_SIZE
suffix:semicolon
id|p-&gt;RIOBootCount
op_assign
id|rbp-&gt;Count
suffix:semicolon
multiline_comment|/* restore(oldspl); */
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rio_start_card_running
r_void
id|rio_start_card_running
(paren
r_struct
id|Host
op_star
id|HostP
)paren
(brace
id|func_enter
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|HostP-&gt;Type
)paren
(brace
r_case
id|RIO_AT
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Start ISA card running&bslash;n&quot;
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|HostP-&gt;Control
comma
id|BOOT_FROM_RAM
op_or
id|EXTERNAL_BUS_ON
op_or
id|HostP-&gt;Mode
op_or
id|RIOAtVec2Ctrl
(braket
id|HostP-&gt;Ivec
op_amp
l_int|0xF
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef FUTURE_RELEASE
r_case
id|RIO_MCA
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;** MCA handles IRQ vectors differently, so we don&squot;t write &n;&t;&t;&t;&t;** them to this register.&n;&t;&t;&t;&t;*/
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Start MCA card running&bslash;n&quot;
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|HostP-&gt;Control
comma
id|McaTpBootFromRam
op_or
id|McaTpBusEnable
op_or
id|HostP-&gt;Mode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RIO_EISA
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;** EISA is totally different and expects OUTBZs to turn it on.&n;&t;&t;&t;&t;*/
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Start EISA card running&bslash;n&quot;
)paren
suffix:semicolon
id|OUTBZ
c_func
(paren
id|HostP-&gt;Slot
comma
id|EISA_CONTROL_PORT
comma
id|HostP-&gt;Mode
op_or
id|RIOEisaVec2Ctrl
(braket
id|HostP-&gt;Ivec
)braket
op_or
id|EISA_TP_RUN
op_or
id|EISA_TP_BUS_ENABLE
op_or
id|EISA_TP_BOOT_FROM_RAM
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|RIO_PCI
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;** PCI is much the same as MCA. Everything is once again memory&n;&t;&t;&t;&t;** mapped, so we are writing to memory registers instead of io&n;&t;&t;&t;&t;** ports.&n;&t;&t;&t;&t;*/
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Start PCI card running&bslash;n&quot;
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|HostP-&gt;Control
comma
id|PCITpBootFromRam
op_or
id|PCITpBusEnable
op_or
id|HostP-&gt;Mode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Unknown host type %d&bslash;n&quot;
comma
id|HostP-&gt;Type
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* &n;&t;printk (KERN_INFO &quot;Done with starting the card&bslash;n&quot;);&n;&t;func_exit ();&n;*/
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;** Load in the host boot code - load it directly onto all halted hosts&n;** of the correct type.&n;**&n;** Put your rubber pants on before messing with this code - even the magic&n;** numbers have trouble understanding what they are doing here.&n;*/
r_int
DECL|function|RIOBootCodeHOST
id|RIOBootCodeHOST
c_func
(paren
id|p
comma
id|rbp
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
r_register
r_struct
id|DownLoad
op_star
id|rbp
suffix:semicolon
(brace
r_register
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
r_register
id|caddr_t
id|Cad
suffix:semicolon
r_register
id|PARM_MAP
op_star
id|ParmMapP
suffix:semicolon
r_register
r_int
id|RupN
suffix:semicolon
r_int
id|PortN
suffix:semicolon
id|uint
id|host
suffix:semicolon
id|caddr_t
id|StartP
suffix:semicolon
id|BYTE
op_star
id|DestP
suffix:semicolon
r_int
id|wait_count
suffix:semicolon
id|ushort
id|OldParmMap
suffix:semicolon
id|ushort
id|offset
suffix:semicolon
multiline_comment|/* It is very important that this is a ushort */
multiline_comment|/* uint byte; */
id|caddr_t
id|DownCode
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|HostP
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Assure the compiler we&squot;ve initialized it */
r_for
c_loop
(paren
id|host
op_assign
l_int|0
suffix:semicolon
id|host
OL
id|p-&gt;RIONumHosts
suffix:semicolon
id|host
op_increment
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Attempt to boot host %d&bslash;n&quot;
comma
id|host
)paren
suffix:semicolon
id|HostP
op_assign
op_amp
id|p-&gt;RIOHosts
(braket
id|host
)braket
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Host Type = 0x%x, Mode = 0x%x, IVec = 0x%x&bslash;n&quot;
comma
id|HostP-&gt;Type
comma
id|HostP-&gt;Mode
comma
id|HostP-&gt;Ivec
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|HostP-&gt;Flags
op_amp
id|RUN_STATE
)paren
op_ne
id|RC_WAITING
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;%s %d already running&bslash;n&quot;
comma
l_string|&quot;Host&quot;
comma
id|host
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;** Grab a 32 bit pointer to the card.&n;&t;&t;*/
id|Cad
op_assign
id|HostP-&gt;Caddr
suffix:semicolon
multiline_comment|/*&n;&t;&t;** We are going to (try) and load in rbp-&gt;Count bytes.&n;&t;&t;** The last byte will reside at p-&gt;RIOConf.HostLoadBase-1;&n;&t;&t;** Therefore, we need to start copying at address&n;&t;&t;** (caddr+p-&gt;RIOConf.HostLoadBase-rbp-&gt;Count)&n;&t;&t;*/
id|StartP
op_assign
(paren
id|caddr_t
)paren
op_amp
id|Cad
(braket
id|p-&gt;RIOConf.HostLoadBase
op_minus
id|rbp-&gt;Count
)braket
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;kernel virtual address for host is 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|Cad
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;kernel virtual address for download is 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|StartP
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;host loadbase is 0x%x&bslash;n&quot;
comma
id|p-&gt;RIOConf.HostLoadBase
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;size of download is 0x%x&bslash;n&quot;
comma
id|rbp-&gt;Count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;RIOConf.HostLoadBase
OL
id|rbp-&gt;Count
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Bin too large&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;RIOError.Error
op_assign
id|HOST_FILE_TOO_LARGE
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|EFBIG
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;** Ensure that the host really is stopped.&n;&t;&t;** Disable it&squot;s external bus &amp; twang its reset line.&n;&t;&t;*/
id|RIOHostReset
c_func
(paren
id|HostP-&gt;Type
comma
(paren
r_struct
id|DpRam
op_star
)paren
id|HostP-&gt;CardP
comma
id|HostP-&gt;Slot
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Copy the data directly from user space to the SRAM.&n;&t;&t;** This ain&squot;t going to be none too clever if the download&n;&t;&t;** code is bigger than this segment.&n;&t;&t;*/
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Copy in code&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** PCI hostcard can&squot;t cope with 32 bit accesses and so need to copy &n;&t;&t;** data to a local buffer, and then dripfeed the card.&n;&t;&t;*/
r_if
c_cond
(paren
id|HostP-&gt;Type
op_eq
id|RIO_PCI
)paren
(brace
multiline_comment|/* int offset; */
id|DownCode
op_assign
id|sysbrk
c_func
(paren
id|rbp-&gt;Count
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DownCode
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;No system memory available&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;RIOError.Error
op_assign
id|NOT_ENOUGH_CORE_FOR_PCI_COPY
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|ENOMEM
suffix:semicolon
)brace
id|bzero
c_func
(paren
id|DownCode
comma
id|rbp-&gt;Count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copyin
c_func
(paren
(paren
r_int
)paren
id|rbp-&gt;DataP
comma
id|DownCode
comma
id|rbp-&gt;Count
)paren
op_eq
id|COPYFAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Bad copyin of host data&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;RIOError.Error
op_assign
id|COPYIN_FAILED
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|EFAULT
suffix:semicolon
)brace
id|HostP
op_member_access_from_pointer
id|Copy
c_func
(paren
id|DownCode
comma
id|StartP
comma
id|rbp-&gt;Count
)paren
suffix:semicolon
id|sysfree
c_func
(paren
id|DownCode
comma
id|rbp-&gt;Count
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|copyin
c_func
(paren
(paren
r_int
)paren
id|rbp-&gt;DataP
comma
id|StartP
comma
id|rbp-&gt;Count
)paren
op_eq
id|COPYFAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Bad copyin of host data&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;RIOError.Error
op_assign
id|COPYIN_FAILED
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|EFAULT
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Copy completed&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;**&t;&t;&t;S T O P !&n;&t;&t;**&n;&t;&t;** Upto this point the code has been fairly rational, and possibly&n;&t;&t;** even straight forward. What follows is a pile of crud that will&n;&t;&t;** magically turn into six bytes of transputer assembler. Normally&n;&t;&t;** you would expect an array or something, but, being me, I have&n;&t;&t;** chosen [been told] to use a technique whereby the startup code&n;&t;&t;** will be correct if we change the loadbase for the code. Which&n;&t;&t;** brings us onto another issue - the loadbase is the *end* of the&n;&t;&t;** code, not the start.&n;&t;&t;**&n;&t;&t;** If I were you I wouldn&squot;t start from here.&n;&t;&t;*/
multiline_comment|/*&n;&t;&t;** We now need to insert a short boot section into&n;&t;&t;** the memory at the end of Sram2. This is normally (de)composed&n;&t;&t;** of the last eight bytes of the download code. The&n;&t;&t;** download has been assembled/compiled to expect to be&n;&t;&t;** loaded from 0x7FFF downwards. We have loaded it&n;&t;&t;** at some other address. The startup code goes into the small&n;&t;&t;** ram window at Sram2, in the last 8 bytes, which are really&n;&t;&t;** at addresses 0x7FF8-0x7FFF.&n;&t;&t;**&n;&t;&t;** If the loadbase is, say, 0x7C00, then we need to branch to&n;&t;&t;** address 0x7BFE to run the host.bin startup code. We assemble&n;&t;&t;** this jump manually.&n;&t;&t;**&n;&t;&t;** The two byte sequence 60 08 is loaded into memory at address&n;&t;&t;** 0x7FFE,F. This is a local branch to location 0x7FF8 (60 is nfix 0,&n;&t;&t;** which adds &squot;0&squot; to the .O register, complements .O, and then shifts&n;&t;&t;** it left by 4 bit positions, 08 is a jump .O+8 instruction. This will&n;&t;&t;** add 8 to .O (which was 0xFFF0), and will branch RELATIVE to the new&n;&t;&t;** location. Now, the branch starts from the value of .PC (or .IP or&n;&t;&t;** whatever the bloody register is called on this chip), and the .PC&n;&t;&t;** will be pointing to the location AFTER the branch, in this case&n;&t;&t;** .PC == 0x8000, so the branch will be to 0x8000+0xFFF8 = 0x7FF8.&n;&t;&t;**&n;&t;&t;** A long branch is coded at 0x7FF8. This consists of loading a four&n;&t;&t;** byte offset into .O using nfix (as above) and pfix operators. The&n;&t;&t;** pfix operates in exactly the same way as the nfix operator, but&n;&t;&t;** without the complement operation. The offset, of course, must be&n;&t;&t;** relative to the address of the byte AFTER the branch instruction,&n;&t;&t;** which will be (urm) 0x7FFC, so, our final destination of the branch&n;&t;&t;** (loadbase-2), has to be reached from here. Imagine that the loadbase&n;&t;&t;** is 0x7C00 (which it is), then we will need to branch to 0x7BFE (which&n;&t;&t;** is the first byte of the initial two byte short local branch of the&n;&t;&t;** download code).&n;&t;&t;**&n;&t;&t;** To code a jump from 0x7FFC (which is where the branch will start&n;&t;&t;** from) to 0x7BFE, we will need to branch 0xFC02 bytes (0x7FFC+0xFC02)=&n;&t;&t;** 0x7BFE.&n;&t;&t;** This will be coded as four bytes:&n;&t;&t;** 60 2C 20 02&n;&t;&t;** being nfix .O+0&n;&t;&t;**&t;   pfix .O+C&n;&t;&t;**&t;   pfix .O+0&n;&t;&t;**&t;   jump .O+2&n;&t;&t;**&n;&t;&t;** The nfix operator is used, so that the startup code will be&n;&t;&t;** compatible with the whole Tp family. (lies, damn lies, it&squot;ll never&n;&t;&t;** work in a month of Sundays).&n;&t;&t;**&n;&t;&t;** The nfix nyble is the 1s compliment of the nyble value you&n;&t;&t;** want to load - in this case we wanted &squot;F&squot; so we nfix loaded &squot;0&squot;.&n;&t;&t;*/
multiline_comment|/*&n;&t;&t;** Dest points to the top 8 bytes of Sram2. The Tp jumps&n;&t;&t;** to 0x7FFE at reset time, and starts executing. This is&n;&t;&t;** a short branch to 0x7FF8, where a long branch is coded.&n;&t;&t;*/
id|DestP
op_assign
(paren
id|BYTE
op_star
)paren
op_amp
id|Cad
(braket
l_int|0x7FF8
)braket
suffix:semicolon
multiline_comment|/* &lt;&lt;&lt;---- READ THE ABOVE COMMENTS */
DECL|macro|NFIX
mdefine_line|#define&t;NFIX(N)&t;(0x60 | (N))&t;/* .O  = (~(.O + N))&lt;&lt;4 */
DECL|macro|PFIX
mdefine_line|#define&t;PFIX(N)&t;(0x20 | (N))&t;/* .O  =   (.O + N)&lt;&lt;4  */
DECL|macro|JUMP
mdefine_line|#define&t;JUMP(N)&t;(0x00 | (N))&t;/* .PC =   .PC + .O&t; */
multiline_comment|/*&n;&t;&t;** 0x7FFC is the address of the location following the last byte of&n;&t;&t;** the four byte jump instruction.&n;&t;&t;** READ THE ABOVE COMMENTS&n;&t;&t;**&n;&t;&t;** offset is (TO-FROM) % MEMSIZE, but with compound buggering about.&n;&t;&t;** Memsize is 64K for this range of Tp, so offset is a short (unsigned,&n;&t;&t;** cos I don&squot;t understand 2&squot;s complement).&n;&t;&t;*/
id|offset
op_assign
(paren
id|p-&gt;RIOConf.HostLoadBase
op_minus
l_int|2
)paren
op_minus
l_int|0x7FFC
suffix:semicolon
id|WBYTE
c_func
(paren
id|DestP
(braket
l_int|0
)braket
comma
id|NFIX
c_func
(paren
(paren
(paren
id|ushort
)paren
(paren
op_complement
id|offset
)paren
op_rshift
(paren
id|ushort
)paren
l_int|12
)paren
op_amp
l_int|0xF
)paren
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|DestP
(braket
l_int|1
)braket
comma
id|PFIX
c_func
(paren
(paren
id|offset
op_rshift
l_int|8
)paren
op_amp
l_int|0xF
)paren
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|DestP
(braket
l_int|2
)braket
comma
id|PFIX
c_func
(paren
(paren
id|offset
op_rshift
l_int|4
)paren
op_amp
l_int|0xF
)paren
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|DestP
(braket
l_int|3
)braket
comma
id|JUMP
c_func
(paren
id|offset
op_amp
l_int|0xF
)paren
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|DestP
(braket
l_int|6
)braket
comma
id|NFIX
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|DestP
(braket
l_int|7
)braket
comma
id|JUMP
c_func
(paren
l_int|8
)paren
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;host loadbase is 0x%x&bslash;n&quot;
comma
id|p-&gt;RIOConf.HostLoadBase
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;startup offset is 0x%x&bslash;n&quot;
comma
id|offset
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Flag what is going on&n;&t;&t;*/
id|HostP-&gt;Flags
op_and_assign
op_complement
id|RUN_STATE
suffix:semicolon
id|HostP-&gt;Flags
op_or_assign
id|RC_STARTUP
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Grab a copy of the current ParmMap pointer, so we&n;&t;&t;** can tell when it has changed.&n;&t;&t;*/
id|OldParmMap
op_assign
id|RWORD
c_func
(paren
id|HostP-&gt;__ParmMapR
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Original parmmap is 0x%x&bslash;n&quot;
comma
id|OldParmMap
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** And start it running (I hope).&n;&t;&t;** As there is nothing dodgy or obscure about the&n;&t;&t;** above code, this is guaranteed to work every time.&n;&t;&t;*/
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Host Type = 0x%x, Mode = 0x%x, IVec = 0x%x&bslash;n&quot;
comma
id|HostP-&gt;Type
comma
id|HostP-&gt;Mode
comma
id|HostP-&gt;Ivec
)paren
suffix:semicolon
id|rio_start_card_running
c_func
(paren
id|HostP
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Set control port&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Now, wait for upto five seconds for the Tp to setup the parmmap&n;&t;&t;** pointer:&n;&t;&t;*/
r_for
c_loop
(paren
id|wait_count
op_assign
l_int|0
suffix:semicolon
(paren
id|wait_count
OL
id|p-&gt;RIOConf.StartupTime
)paren
op_logical_and
(paren
id|RWORD
c_func
(paren
id|HostP-&gt;__ParmMapR
)paren
op_eq
id|OldParmMap
)paren
suffix:semicolon
id|wait_count
op_increment
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Checkout %d, 0x%x&bslash;n&quot;
comma
id|wait_count
comma
id|RWORD
c_func
(paren
id|HostP-&gt;__ParmMapR
)paren
)paren
suffix:semicolon
id|delay
c_func
(paren
id|HostP
comma
id|HUNDRED_MS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;** If the parmmap pointer is unchanged, then the host code&n;&t;&t;** has crashed &amp; burned in a really spectacular way&n;&t;&t;*/
r_if
c_cond
(paren
id|RWORD
c_func
(paren
id|HostP-&gt;__ParmMapR
)paren
op_eq
id|OldParmMap
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;parmmap 0x%x&bslash;n&quot;
comma
id|RWORD
c_func
(paren
id|HostP-&gt;__ParmMapR
)paren
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;RIO Mesg Run Fail&bslash;n&quot;
)paren
suffix:semicolon
DECL|macro|HOST_DISABLE
mdefine_line|#define&t;HOST_DISABLE &bslash;&n;&t;&t;HostP-&gt;Flags &amp;= ~RUN_STATE; &bslash;&n;&t;&t;HostP-&gt;Flags |= RC_STUFFED; &bslash;&n;&t;&t;RIOHostReset( HostP-&gt;Type, (struct DpRam *)HostP-&gt;CardP, HostP-&gt;Slot );&bslash;&n;&t;&t;continue
id|HOST_DISABLE
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Running 0x%x&bslash;n&quot;
comma
id|RWORD
c_func
(paren
id|HostP-&gt;__ParmMapR
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Well, the board thought it was OK, and setup its parmmap&n;&t;&t;** pointer. For the time being, we will pretend that this&n;&t;&t;** board is running, and check out what the error flag says.&n;&t;&t;*/
multiline_comment|/*&n;&t;&t;** Grab a 32 bit pointer to the parmmap structure&n;&t;&t;*/
id|ParmMapP
op_assign
(paren
id|PARM_MAP
op_star
)paren
id|RIO_PTR
c_func
(paren
id|Cad
comma
id|RWORD
c_func
(paren
id|HostP-&gt;__ParmMapR
)paren
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;ParmMapP : %x&bslash;n&quot;
comma
(paren
r_int
)paren
id|ParmMapP
)paren
suffix:semicolon
id|ParmMapP
op_assign
(paren
id|PARM_MAP
op_star
)paren
(paren
(paren
r_int
r_int
)paren
id|Cad
op_plus
(paren
r_int
r_int
)paren
(paren
(paren
id|RWORD
c_func
(paren
(paren
id|HostP-&gt;__ParmMapR
)paren
)paren
)paren
op_amp
l_int|0xFFFF
)paren
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;ParmMapP : %x&bslash;n&quot;
comma
(paren
r_int
)paren
id|ParmMapP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** The links entry should be 0xFFFF; we set it up&n;&t;&t;** with a mask to say how many PHBs to use, and &n;&t;&t;** which links to use.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|RWORD
c_func
(paren
id|ParmMapP-&gt;links
)paren
op_amp
l_int|0xFFFF
)paren
op_ne
l_int|0xFFFF
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;RIO Mesg Run Fail %s&bslash;n&quot;
comma
id|HostP-&gt;Name
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Links = 0x%x&bslash;n&quot;
comma
id|RWORD
c_func
(paren
id|ParmMapP-&gt;links
)paren
)paren
suffix:semicolon
id|HOST_DISABLE
suffix:semicolon
)brace
id|WWORD
c_func
(paren
id|ParmMapP-&gt;links
comma
id|RIO_LINK_ENABLE
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** now wait for the card to set all the parmmap-&gt;XXX stuff&n;&t;&t;** this is a wait of upto two seconds....&n;&t;&t;*/
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Looking for init_done - %d ticks&bslash;n&quot;
comma
id|p-&gt;RIOConf.StartupTime
)paren
suffix:semicolon
id|HostP-&gt;timeout_id
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|wait_count
op_assign
l_int|0
suffix:semicolon
(paren
id|wait_count
OL
id|p-&gt;RIOConf.StartupTime
)paren
op_logical_and
op_logical_neg
id|RWORD
c_func
(paren
id|ParmMapP-&gt;init_done
)paren
suffix:semicolon
id|wait_count
op_increment
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Waiting for init_done&bslash;n&quot;
)paren
suffix:semicolon
id|delay
c_func
(paren
id|HostP
comma
id|HUNDRED_MS
)paren
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;OK! init_done!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RWORD
c_func
(paren
id|ParmMapP-&gt;error
)paren
op_ne
id|E_NO_ERROR
op_logical_or
op_logical_neg
id|RWORD
c_func
(paren
id|ParmMapP-&gt;init_done
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;RIO Mesg Run Fail %s&bslash;n&quot;
comma
id|HostP-&gt;Name
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Timedout waiting for init_done&bslash;n&quot;
)paren
suffix:semicolon
id|HOST_DISABLE
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Got init_done&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** It runs! It runs!&n;&t;&t;*/
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Host ID %x Running&bslash;n&quot;
comma
id|HostP-&gt;UniqueNum
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** set the time period between interrupts.&n;&t;&t;*/
id|WWORD
c_func
(paren
id|ParmMapP-&gt;timer
comma
(paren
r_int
)paren
id|p-&gt;RIOConf.Timer
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Translate all the 16 bit pointers in the __ParmMapR into&n;&t;&t;** 32 bit pointers for the driver.&n;&t;&t;*/
id|HostP-&gt;ParmMapP
op_assign
id|ParmMapP
suffix:semicolon
id|HostP-&gt;PhbP
op_assign
(paren
id|PHB
op_star
)paren
id|RIO_PTR
c_func
(paren
id|Cad
comma
id|RWORD
c_func
(paren
id|ParmMapP-&gt;phb_ptr
)paren
)paren
suffix:semicolon
id|HostP-&gt;RupP
op_assign
(paren
id|RUP
op_star
)paren
id|RIO_PTR
c_func
(paren
id|Cad
comma
id|RWORD
c_func
(paren
id|ParmMapP-&gt;rups
)paren
)paren
suffix:semicolon
id|HostP-&gt;PhbNumP
op_assign
(paren
id|ushort
op_star
)paren
id|RIO_PTR
c_func
(paren
id|Cad
comma
id|RWORD
c_func
(paren
id|ParmMapP-&gt;phb_num_ptr
)paren
)paren
suffix:semicolon
id|HostP-&gt;LinkStrP
op_assign
(paren
id|LPB
op_star
)paren
id|RIO_PTR
c_func
(paren
id|Cad
comma
id|RWORD
c_func
(paren
id|ParmMapP-&gt;link_str_ptr
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** point the UnixRups at the real Rups&n;&t;&t;*/
r_for
c_loop
(paren
id|RupN
op_assign
l_int|0
suffix:semicolon
id|RupN
OL
id|MAX_RUP
suffix:semicolon
id|RupN
op_increment
)paren
(brace
id|HostP-&gt;UnixRups
(braket
id|RupN
)braket
dot
id|RupP
op_assign
op_amp
id|HostP-&gt;RupP
(braket
id|RupN
)braket
suffix:semicolon
id|HostP-&gt;UnixRups
(braket
id|RupN
)braket
dot
id|Id
op_assign
id|RupN
op_plus
l_int|1
suffix:semicolon
id|HostP-&gt;UnixRups
(braket
id|RupN
)braket
dot
id|BaseSysPort
op_assign
id|NO_PORT
suffix:semicolon
id|HostP-&gt;UnixRups
(braket
id|RupN
)braket
dot
id|RupLock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
)brace
r_for
c_loop
(paren
id|RupN
op_assign
l_int|0
suffix:semicolon
id|RupN
OL
id|LINKS_PER_UNIT
suffix:semicolon
id|RupN
op_increment
)paren
(brace
id|HostP-&gt;UnixRups
(braket
id|RupN
op_plus
id|MAX_RUP
)braket
dot
id|RupP
op_assign
op_amp
id|HostP-&gt;LinkStrP
(braket
id|RupN
)braket
dot
id|rup
suffix:semicolon
id|HostP-&gt;UnixRups
(braket
id|RupN
op_plus
id|MAX_RUP
)braket
dot
id|Id
op_assign
l_int|0
suffix:semicolon
id|HostP-&gt;UnixRups
(braket
id|RupN
op_plus
id|MAX_RUP
)braket
dot
id|BaseSysPort
op_assign
id|NO_PORT
suffix:semicolon
id|HostP-&gt;UnixRups
(braket
id|RupN
op_plus
id|MAX_RUP
)braket
dot
id|RupLock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;** point the PortP-&gt;Phbs at the real Phbs&n;&t;&t;*/
r_for
c_loop
(paren
id|PortN
op_assign
id|p-&gt;RIOFirstPortsMapped
suffix:semicolon
id|PortN
OL
id|p-&gt;RIOLastPortsMapped
op_plus
id|PORTS_PER_RTA
suffix:semicolon
id|PortN
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;RIOPortp
(braket
id|PortN
)braket
op_member_access_from_pointer
id|HostP
op_eq
id|HostP
)paren
(brace
r_struct
id|Port
op_star
id|PortP
op_assign
id|p-&gt;RIOPortp
(braket
id|PortN
)braket
suffix:semicolon
r_struct
id|PHB
op_star
id|PhbP
suffix:semicolon
multiline_comment|/* int oldspl; */
r_if
c_cond
(paren
op_logical_neg
id|PortP-&gt;Mapped
)paren
r_continue
suffix:semicolon
id|PhbP
op_assign
op_amp
id|HostP-&gt;PhbP
(braket
id|PortP-&gt;HostPort
)braket
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
id|PortP-&gt;PhbP
op_assign
id|PhbP
suffix:semicolon
id|PortP-&gt;TxAdd
op_assign
(paren
id|WORD
op_star
)paren
id|RIO_PTR
c_func
(paren
id|Cad
comma
id|RWORD
c_func
(paren
id|PhbP-&gt;tx_add
)paren
)paren
suffix:semicolon
id|PortP-&gt;TxStart
op_assign
(paren
id|WORD
op_star
)paren
id|RIO_PTR
c_func
(paren
id|Cad
comma
id|RWORD
c_func
(paren
id|PhbP-&gt;tx_start
)paren
)paren
suffix:semicolon
id|PortP-&gt;TxEnd
op_assign
(paren
id|WORD
op_star
)paren
id|RIO_PTR
c_func
(paren
id|Cad
comma
id|RWORD
c_func
(paren
id|PhbP-&gt;tx_end
)paren
)paren
suffix:semicolon
id|PortP-&gt;RxRemove
op_assign
(paren
id|WORD
op_star
)paren
id|RIO_PTR
c_func
(paren
id|Cad
comma
id|RWORD
c_func
(paren
id|PhbP-&gt;rx_remove
)paren
)paren
suffix:semicolon
id|PortP-&gt;RxStart
op_assign
(paren
id|WORD
op_star
)paren
id|RIO_PTR
c_func
(paren
id|Cad
comma
id|RWORD
c_func
(paren
id|PhbP-&gt;rx_start
)paren
)paren
suffix:semicolon
id|PortP-&gt;RxEnd
op_assign
(paren
id|WORD
op_star
)paren
id|RIO_PTR
c_func
(paren
id|Cad
comma
id|RWORD
c_func
(paren
id|PhbP-&gt;rx_end
)paren
)paren
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;** point the UnixRup at the base SysPort&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|PortN
op_mod
id|PORTS_PER_RTA
)paren
)paren
id|HostP-&gt;UnixRups
(braket
id|PortP-&gt;RupNum
)braket
dot
id|BaseSysPort
op_assign
id|PortN
suffix:semicolon
)brace
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Set the card running... &bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** last thing - show the world that everything is in place&n;&t;&t;*/
id|HostP-&gt;Flags
op_and_assign
op_complement
id|RUN_STATE
suffix:semicolon
id|HostP-&gt;Flags
op_or_assign
id|RC_RUNNING
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** MPX always uses a poller. This is actually patched into the system&n;&t;** configuration and called directly from each clock tick.&n;&t;**&n;&t;*/
id|p-&gt;RIOPolling
op_assign
l_int|1
suffix:semicolon
id|p-&gt;RIOSystemUp
op_increment
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Done everything %x&bslash;n&quot;
comma
id|HostP-&gt;Ivec
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** Boot an RTA. If we have successfully processed this boot, then&n;** return 1. If we havent, then return 0.&n;*/
r_int
DECL|function|RIOBootRup
id|RIOBootRup
c_func
(paren
id|p
comma
id|Rup
comma
id|HostP
comma
id|PacketP
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
id|uint
id|Rup
suffix:semicolon
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
r_struct
id|PKT
op_star
id|PacketP
suffix:semicolon
(brace
r_struct
id|PktCmd
op_star
id|PktCmdP
op_assign
(paren
r_struct
id|PktCmd
op_star
)paren
id|PacketP-&gt;data
suffix:semicolon
r_struct
id|PktCmd_M
op_star
id|PktReplyP
suffix:semicolon
r_struct
id|CmdBlk
op_star
id|CmdBlkP
suffix:semicolon
id|uint
id|sequence
suffix:semicolon
macro_line|#ifdef CHECK
id|CheckHost
c_func
(paren
id|Host
)paren
suffix:semicolon
id|CheckRup
c_func
(paren
id|Rup
)paren
suffix:semicolon
id|CheckHostP
c_func
(paren
id|HostP
)paren
suffix:semicolon
id|CheckPacketP
c_func
(paren
id|PacketP
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;** If we haven&squot;t been told what to boot, we can&squot;t boot it.&n;&t;*/
r_if
c_cond
(paren
id|p-&gt;RIONumBootPkts
op_eq
l_int|0
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;No RTA code to download yet&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* rio_dprint(RIO_DEBUG_BOOT, NULL,DBG_BOOT,&quot;Incoming command packet&bslash;n&quot;); */
multiline_comment|/* ShowPacket( DBG_BOOT, PacketP ); */
multiline_comment|/*&n;&t;** Special case of boot completed - if we get one of these then we&n;&t;** don&squot;t need a command block. For all other cases we do, so handle&n;&t;** this first and then get a command block, then handle every other&n;&t;** case, relinquishing the command block if disaster strikes!&n;&t;*/
r_if
c_cond
(paren
(paren
id|RBYTE
c_func
(paren
id|PacketP-&gt;len
)paren
op_amp
id|PKT_CMD_BIT
)paren
op_logical_and
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;Command
)paren
op_eq
id|BOOT_COMPLETED
)paren
)paren
r_return
id|RIOBootComplete
c_func
(paren
id|p
comma
id|HostP
comma
id|Rup
comma
id|PktCmdP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** try to unhook a command block from the command free list.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|CmdBlkP
op_assign
id|RIOGetCmdBlk
c_func
(paren
)paren
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;No command blocks to boot RTA! come back later.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Fill in the default info on the command block&n;&t;*/
id|CmdBlkP-&gt;Packet.dest_unit
op_assign
id|Rup
OL
(paren
id|ushort
)paren
id|MAX_RUP
ques
c_cond
id|Rup
suffix:colon
l_int|0
suffix:semicolon
id|CmdBlkP-&gt;Packet.dest_port
op_assign
id|BOOT_RUP
suffix:semicolon
id|CmdBlkP-&gt;Packet.src_unit
op_assign
l_int|0
suffix:semicolon
id|CmdBlkP-&gt;Packet.src_port
op_assign
id|BOOT_RUP
suffix:semicolon
id|CmdBlkP-&gt;PreFuncP
op_assign
id|CmdBlkP-&gt;PostFuncP
op_assign
l_int|NULL
suffix:semicolon
id|PktReplyP
op_assign
(paren
r_struct
id|PktCmd_M
op_star
)paren
id|CmdBlkP-&gt;Packet.data
suffix:semicolon
multiline_comment|/*&n;&t;** process COMMANDS on the boot rup!&n;&t;*/
r_if
c_cond
(paren
id|RBYTE
c_func
(paren
id|PacketP-&gt;len
)paren
op_amp
id|PKT_CMD_BIT
)paren
(brace
multiline_comment|/*&n;&t;&t;** We only expect one type of command - a BOOT_REQUEST!&n;&t;&t;*/
r_if
c_cond
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;Command
)paren
op_ne
id|BOOT_REQUEST
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Unexpected command %d on BOOT RUP %d of host %d&bslash;n&quot;
comma
id|PktCmdP-&gt;Command
comma
id|Rup
comma
id|HostP
op_minus
id|p-&gt;RIOHosts
)paren
suffix:semicolon
id|ShowPacket
c_func
(paren
id|DBG_BOOT
comma
id|PacketP
)paren
suffix:semicolon
id|RIOFreeCmdBlk
c_func
(paren
id|CmdBlkP
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;** Build a Boot Sequence command block&n;&t;&t;**&n;&t;&t;** 02.03.1999 ARG - ESIL 0820 fix&n;&t;&t;** We no longer need to use &quot;Boot Mode&quot;, we&squot;ll always allow&n;&t;&t;** boot requests - the boot will not complete if the device&n;&t;&t;** appears in the bindings table.&n;&t;&t;** So, this conditional is not required ...&n;&t;&t;**&n;&t;&t;if (p-&gt;RIOBootMode == RC_BOOT_NONE)&n;&t;&t;&t;**&n;&t;&t;&t;** If the system is in slave mode, and a boot request is&n;&t;&t;&t;** received, set command to BOOT_ABORT so that the boot&n;&t;&t;&t;** will not complete.&n;&t;&t;&t;**&n;&t;&t;&t;PktReplyP-&gt;Command&t;&t;&t; = BOOT_ABORT;&n;&t;&t;else&n;&t;&t;**&n;&t;&t;** We&squot;ll just (always) set the command field in packet reply&n;&t;&t;** to allow an attempted boot sequence :&n;&t;&t;*/
id|PktReplyP-&gt;Command
op_assign
id|BOOT_SEQUENCE
suffix:semicolon
id|PktReplyP-&gt;BootSequence.NumPackets
op_assign
id|p-&gt;RIONumBootPkts
suffix:semicolon
id|PktReplyP-&gt;BootSequence.LoadBase
op_assign
id|p-&gt;RIOConf.RtaLoadBase
suffix:semicolon
id|PktReplyP-&gt;BootSequence.CodeSize
op_assign
id|p-&gt;RIOBootCount
suffix:semicolon
id|CmdBlkP-&gt;Packet.len
op_assign
id|BOOT_SEQUENCE_LEN
op_or
id|PKT_CMD_BIT
suffix:semicolon
id|bcopy
c_func
(paren
l_string|&quot;BOOT&quot;
comma
(paren
r_void
op_star
)paren
op_amp
id|CmdBlkP-&gt;Packet.data
(braket
id|BOOT_SEQUENCE_LEN
)braket
comma
l_int|4
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Boot RTA on Host %d Rup %d - %d (0x%x) packets to 0x%x&bslash;n&quot;
comma
id|HostP
op_minus
id|p-&gt;RIOHosts
comma
id|Rup
comma
id|p-&gt;RIONumBootPkts
comma
id|p-&gt;RIONumBootPkts
comma
id|p-&gt;RIOConf.RtaLoadBase
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** If this host is in slave mode, send the RTA an invalid boot&n;&t;&t;** sequence command block to force it to kill the boot. We wait&n;&t;&t;** for half a second before sending this packet to prevent the RTA&n;&t;&t;** attempting to boot too often. The master host should then grab&n;&t;&t;** the RTA and make it its own.&n;&t;&t;*/
id|p-&gt;RIOBooting
op_increment
suffix:semicolon
id|RIOQueueCmdBlk
c_func
(paren
id|HostP
comma
id|Rup
comma
id|CmdBlkP
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** It is a request for boot data.&n;&t;*/
id|sequence
op_assign
id|RWORD
c_func
(paren
id|PktCmdP-&gt;Sequence
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Boot block %d on Host %d Rup%d&bslash;n&quot;
comma
id|sequence
comma
id|HostP
op_minus
id|p-&gt;RIOHosts
comma
id|Rup
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sequence
op_ge
id|p-&gt;RIONumBootPkts
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Got a request for packet %d, max is %d&bslash;n&quot;
comma
id|sequence
comma
id|p-&gt;RIONumBootPkts
)paren
suffix:semicolon
id|ShowPacket
c_func
(paren
id|DBG_BOOT
comma
id|PacketP
)paren
suffix:semicolon
)brace
id|PktReplyP-&gt;Sequence
op_assign
id|sequence
suffix:semicolon
id|bcopy
c_func
(paren
id|p-&gt;RIOBootPackets
(braket
id|p-&gt;RIONumBootPkts
op_minus
id|sequence
op_minus
l_int|1
)braket
comma
id|PktReplyP-&gt;BootData
comma
id|RTA_BOOT_DATA_SIZE
)paren
suffix:semicolon
id|CmdBlkP-&gt;Packet.len
op_assign
id|PKT_MAX_DATA_LEN
suffix:semicolon
id|ShowPacket
c_func
(paren
id|DBG_BOOT
comma
op_amp
id|CmdBlkP-&gt;Packet
)paren
suffix:semicolon
id|RIOQueueCmdBlk
c_func
(paren
id|HostP
comma
id|Rup
comma
id|CmdBlkP
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;** This function is called when an RTA been booted.&n;** If booted by a host, HostP-&gt;HostUniqueNum is the booting host.&n;** If booted by an RTA, HostP-&gt;Mapping[Rup].RtaUniqueNum is the booting RTA.&n;** RtaUniq is the booted RTA.&n;*/
DECL|function|RIOBootComplete
r_int
id|RIOBootComplete
c_func
(paren
r_struct
id|rio_info
op_star
id|p
comma
r_struct
id|Host
op_star
id|HostP
comma
id|uint
id|Rup
comma
r_struct
id|PktCmd
op_star
id|PktCmdP
)paren
(brace
r_struct
id|Map
op_star
id|MapP
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|Map
op_star
id|MapP2
op_assign
l_int|NULL
suffix:semicolon
r_int
id|Flag
suffix:semicolon
r_int
id|found
suffix:semicolon
r_int
id|host
comma
id|rta
suffix:semicolon
r_int
id|EmptySlot
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|entry
comma
id|entry2
suffix:semicolon
r_char
op_star
id|MyType
comma
op_star
id|MyName
suffix:semicolon
id|uint
id|MyLink
suffix:semicolon
id|ushort
id|RtaType
suffix:semicolon
id|uint
id|RtaUniq
op_assign
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;UniqNum
(braket
l_int|0
)braket
)paren
)paren
op_plus
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;UniqNum
(braket
l_int|1
)braket
)paren
op_lshift
l_int|8
)paren
op_plus
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;UniqNum
(braket
l_int|2
)braket
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;UniqNum
(braket
l_int|3
)braket
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
multiline_comment|/* Was RIOBooting-- . That&squot;s bad. If an RTA sends two of them, the&n;&t;   driver will never think that the RTA has booted... -- REW */
id|p-&gt;RIOBooting
op_assign
l_int|0
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;RTA Boot completed - BootInProgress now %d&bslash;n&quot;
comma
id|p-&gt;RIOBooting
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Determine type of unit (16/8 port RTA).&n;&t;*/
id|RtaType
op_assign
id|GetUnitType
c_func
(paren
id|RtaUniq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Rup
op_ge
(paren
id|ushort
)paren
id|MAX_RUP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;RIO: Host %s has booted an RTA(%d) on link %c&bslash;n&quot;
comma
id|HostP-&gt;Name
comma
l_int|8
op_star
id|RtaType
comma
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;LinkNum
)paren
op_plus
l_char|&squot;A&squot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;RIO: RTA %s has booted an RTA(%d) on link %c&bslash;n&quot;
comma
id|HostP-&gt;Mapping
(braket
id|Rup
)braket
dot
id|Name
comma
l_int|8
op_star
id|RtaType
comma
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;LinkNum
)paren
op_plus
l_char|&squot;A&squot;
)paren
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;UniqNum is 0x%x&bslash;n&quot;
comma
id|RtaUniq
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|RtaUniq
op_eq
l_int|0x00000000
)paren
op_logical_or
(paren
id|RtaUniq
op_eq
l_int|0xffffffff
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Illegal RTA Uniq Number&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** If this RTA has just booted an RTA which doesn&squot;t belong to this&n;&t;** system, or the system is in slave mode, do not attempt to create&n;&t;** a new table entry for it.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|RIOBootOk
c_func
(paren
id|p
comma
id|HostP
comma
id|RtaUniq
)paren
)paren
(brace
id|MyLink
op_assign
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;LinkNum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Rup
OL
(paren
id|ushort
)paren
id|MAX_RUP
)paren
(brace
multiline_comment|/*&n;&t;&t;** RtaUniq was clone booted (by this RTA). Instruct this RTA&n;&t;&t;** to hold off further attempts to boot on this link for 30&n;&t;&t;** seconds.&n;&t;&t;*/
r_if
c_cond
(paren
id|RIOSuspendBootRta
c_func
(paren
id|HostP
comma
id|HostP-&gt;Mapping
(braket
id|Rup
)braket
dot
id|ID
comma
id|MyLink
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;RTA failed to suspend booting on link %c&bslash;n&quot;
comma
l_char|&squot;A&squot;
op_plus
id|MyLink
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;** RtaUniq was booted by this host. Set the booting link&n;&t;&t;** to hold off for 30 seconds to give another unit a&n;&t;&t;** chance to boot it.&n;&t;&t;*/
id|WWORD
c_func
(paren
id|HostP-&gt;LinkStrP
(braket
id|MyLink
)braket
dot
id|WaitNoBoot
comma
l_int|30
)paren
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;RTA %x not owned - suspend booting down link %c on unit %x&bslash;n&quot;
comma
id|RtaUniq
comma
l_char|&squot;A&squot;
op_plus
id|MyLink
comma
id|HostP-&gt;Mapping
(braket
id|Rup
)braket
dot
id|RtaUniqueNum
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Check for a SLOT_IN_USE entry for this RTA attached to the&n;&t;** current host card in the driver table.&n;&t;**&n;&t;** If it exists, make a note that we have booted it. Other parts of&n;&t;** the driver are interested in this information at a later date,&n;&t;** in particular when the booting RTA asks for an ID for this unit,&n;&t;** we must have set the BOOTED flag, and the NEWBOOT flag is used&n;&t;** to force an open on any ports that where previously open on this&n;&t;** unit.&n;&t;*/
r_for
c_loop
(paren
id|entry
op_assign
l_int|0
suffix:semicolon
id|entry
OL
id|MAX_RUP
suffix:semicolon
id|entry
op_increment
)paren
(brace
id|uint
id|sysport
suffix:semicolon
r_if
c_cond
(paren
(paren
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|Flags
op_amp
id|SLOT_IN_USE
)paren
op_logical_and
(paren
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|RtaUniqueNum
op_eq
id|RtaUniq
)paren
)paren
(brace
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|Flags
op_or_assign
id|RTA_BOOTED
op_or
id|RTA_NEWBOOT
suffix:semicolon
macro_line|#if NEED_TO_FIX
id|RIO_SV_BROADCAST
c_func
(paren
id|HostP-&gt;svFlags
(braket
id|entry
)braket
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|sysport
op_assign
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|SysPort
)paren
op_ne
id|NO_PORT
)paren
(brace
r_if
c_cond
(paren
id|sysport
OL
id|p-&gt;RIOFirstPortsBooted
)paren
id|p-&gt;RIOFirstPortsBooted
op_assign
id|sysport
suffix:semicolon
r_if
c_cond
(paren
id|sysport
OG
id|p-&gt;RIOLastPortsBooted
)paren
id|p-&gt;RIOLastPortsBooted
op_assign
id|sysport
suffix:semicolon
multiline_comment|/*&n;&t;&t;   ** For a 16 port RTA, check the second bank of 8 ports&n;&t;&t;   */
r_if
c_cond
(paren
id|RtaType
op_eq
id|TYPE_RTA16
)paren
(brace
id|entry2
op_assign
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|ID2
op_minus
l_int|1
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|Flags
op_or_assign
id|RTA_BOOTED
op_or
id|RTA_NEWBOOT
suffix:semicolon
macro_line|#if NEED_TO_FIX
id|RIO_SV_BROADCAST
c_func
(paren
id|HostP-&gt;svFlags
(braket
id|entry2
)braket
)paren
suffix:semicolon
macro_line|#endif
id|sysport
op_assign
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|SysPort
suffix:semicolon
r_if
c_cond
(paren
id|sysport
OL
id|p-&gt;RIOFirstPortsBooted
)paren
id|p-&gt;RIOFirstPortsBooted
op_assign
id|sysport
suffix:semicolon
r_if
c_cond
(paren
id|sysport
OG
id|p-&gt;RIOLastPortsBooted
)paren
id|p-&gt;RIOLastPortsBooted
op_assign
id|sysport
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|RtaType
op_eq
id|TYPE_RTA16
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;RTA will be given IDs %d+%d&bslash;n&quot;
comma
id|entry
op_plus
l_int|1
comma
id|entry2
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;RTA will be given ID %d&bslash;n&quot;
comma
id|entry
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|TRUE
suffix:semicolon
)brace
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;RTA not configured for this host&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Rup
op_ge
(paren
id|ushort
)paren
id|MAX_RUP
)paren
(brace
multiline_comment|/*&n;&t;    ** It was a host that did the booting&n;&t;    */
id|MyType
op_assign
l_string|&quot;Host&quot;
suffix:semicolon
id|MyName
op_assign
id|HostP-&gt;Name
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;    ** It was an RTA that did the booting&n;&t;    */
id|MyType
op_assign
l_string|&quot;RTA&quot;
suffix:semicolon
id|MyName
op_assign
id|HostP-&gt;Mapping
(braket
id|Rup
)braket
dot
id|Name
suffix:semicolon
)brace
macro_line|#ifdef CHECK
id|CheckString
c_func
(paren
id|MyType
)paren
suffix:semicolon
id|CheckString
c_func
(paren
id|MyName
)paren
suffix:semicolon
macro_line|#endif
id|MyLink
op_assign
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;LinkNum
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** There is no SLOT_IN_USE entry for this RTA attached to the current&n;&t;** host card in the driver table.&n;&t;**&n;&t;** Check for a SLOT_TENTATIVE entry for this RTA attached to the&n;&t;** current host card in the driver table.&n;&t;**&n;&t;** If we find one, then we re-use that slot.&n;&t;*/
r_for
c_loop
(paren
id|entry
op_assign
l_int|0
suffix:semicolon
id|entry
OL
id|MAX_RUP
suffix:semicolon
id|entry
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|Flags
op_amp
id|SLOT_TENTATIVE
)paren
op_logical_and
(paren
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|RtaUniqueNum
op_eq
id|RtaUniq
)paren
)paren
(brace
r_if
c_cond
(paren
id|RtaType
op_eq
id|TYPE_RTA16
)paren
(brace
id|entry2
op_assign
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|ID2
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|Flags
op_amp
id|SLOT_TENTATIVE
)paren
op_logical_and
(paren
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|RtaUniqueNum
op_eq
id|RtaUniq
)paren
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Found previous tentative slots (%d+%d)&bslash;n&quot;
comma
id|entry
comma
id|entry2
)paren
suffix:semicolon
r_else
r_continue
suffix:semicolon
)brace
r_else
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Found previous tentative slot (%d)&bslash;n&quot;
comma
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;RIONoMessage
)paren
id|cprintf
c_func
(paren
l_string|&quot;RTA connected to %s &squot;%s&squot; (%c) not configured.&bslash;n&quot;
comma
id|MyType
comma
id|MyName
comma
id|MyLink
op_plus
l_char|&squot;A&squot;
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;** There is no SLOT_IN_USE or SLOT_TENTATIVE entry for this RTA&n;&t;** attached to the current host card in the driver table.&n;&t;**&n;&t;** Check if there is a SLOT_IN_USE or SLOT_TENTATIVE entry on another&n;&t;** host for this RTA in the driver table.&n;&t;**&n;&t;** For a SLOT_IN_USE entry on another host, we need to delete the RTA&n;&t;** entry from the other host and add it to this host (using some of&n;&t;** the functions from table.c which do this).&n;&t;** For a SLOT_TENTATIVE entry on another host, we must cope with the&n;&t;** following scenario:&n;&t;**&n;&t;** + Plug 8 port RTA into host A. (This creates SLOT_TENTATIVE entry&n;&t;**   in table)&n;&t;** + Unplug RTA and plug into host B. (We now have 2 SLOT_TENTATIVE&n;&t;**   entries)&n;&t;** + Configure RTA on host B. (This slot now becomes SLOT_IN_USE)&n;&t;** + Unplug RTA and plug back into host A.&n;&t;** + Configure RTA on host A. We now have the same RTA configured&n;&t;**   with different ports on two different hosts.&n;&t;*/
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Have we seen RTA %x before?&bslash;n&quot;
comma
id|RtaUniq
)paren
suffix:semicolon
id|found
op_assign
l_int|0
suffix:semicolon
id|Flag
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Convince the compiler this variable is initialized */
r_for
c_loop
(paren
id|host
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|found
op_logical_and
(paren
id|host
OL
id|p-&gt;RIONumHosts
)paren
suffix:semicolon
id|host
op_increment
)paren
(brace
r_for
c_loop
(paren
id|rta
op_assign
l_int|0
suffix:semicolon
id|rta
OL
id|MAX_RUP
suffix:semicolon
id|rta
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;RIOHosts
(braket
id|host
)braket
dot
id|Mapping
(braket
id|rta
)braket
dot
id|Flags
op_amp
(paren
id|SLOT_IN_USE
op_or
id|SLOT_TENTATIVE
)paren
)paren
op_logical_and
(paren
id|p-&gt;RIOHosts
(braket
id|host
)braket
dot
id|Mapping
(braket
id|rta
)braket
dot
id|RtaUniqueNum
op_eq
id|RtaUniq
)paren
)paren
(brace
id|Flag
op_assign
id|p-&gt;RIOHosts
(braket
id|host
)braket
dot
id|Mapping
(braket
id|rta
)braket
dot
id|Flags
suffix:semicolon
id|MapP
op_assign
op_amp
id|p-&gt;RIOHosts
(braket
id|host
)braket
dot
id|Mapping
(braket
id|rta
)braket
suffix:semicolon
r_if
c_cond
(paren
id|RtaType
op_eq
id|TYPE_RTA16
)paren
(brace
id|MapP2
op_assign
op_amp
id|p-&gt;RIOHosts
(braket
id|host
)braket
dot
id|Mapping
(braket
id|MapP-&gt;ID2
op_minus
l_int|1
)braket
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;This RTA is units %d+%d from host %s&bslash;n&quot;
comma
id|rta
op_plus
l_int|1
comma
id|MapP-&gt;ID2
comma
id|p-&gt;RIOHosts
(braket
id|host
)braket
dot
id|Name
)paren
suffix:semicolon
)brace
r_else
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;This RTA is unit %d from host %s&bslash;n&quot;
comma
id|rta
op_plus
l_int|1
comma
id|p-&gt;RIOHosts
(braket
id|host
)braket
dot
id|Name
)paren
suffix:semicolon
id|found
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;** There is no SLOT_IN_USE or SLOT_TENTATIVE entry for this RTA&n;&t;** attached to the current host card in the driver table.&n;&t;**&n;&t;** If we have not found a SLOT_IN_USE or SLOT_TENTATIVE entry on&n;&t;** another host for this RTA in the driver table...&n;&t;**&n;&t;** Check for a SLOT_IN_USE entry for this RTA in the config table.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|MapP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Look for RTA %x in RIOSavedTable&bslash;n&quot;
comma
id|RtaUniq
)paren
suffix:semicolon
r_for
c_loop
(paren
id|rta
op_assign
l_int|0
suffix:semicolon
id|rta
OL
id|TOTAL_MAP_ENTRIES
suffix:semicolon
id|rta
op_increment
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;Check table entry %d (%x)&quot;
comma
id|rta
comma
id|p-&gt;RIOSavedTable
(braket
id|rta
)braket
dot
id|RtaUniqueNum
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|p-&gt;RIOSavedTable
(braket
id|rta
)braket
dot
id|Flags
op_amp
id|SLOT_IN_USE
)paren
op_logical_and
(paren
id|p-&gt;RIOSavedTable
(braket
id|rta
)braket
dot
id|RtaUniqueNum
op_eq
id|RtaUniq
)paren
)paren
(brace
id|MapP
op_assign
op_amp
id|p-&gt;RIOSavedTable
(braket
id|rta
)braket
suffix:semicolon
id|Flag
op_assign
id|p-&gt;RIOSavedTable
(braket
id|rta
)braket
dot
id|Flags
suffix:semicolon
r_if
c_cond
(paren
id|RtaType
op_eq
id|TYPE_RTA16
)paren
(brace
r_for
c_loop
(paren
id|entry2
op_assign
id|rta
op_plus
l_int|1
suffix:semicolon
id|entry2
OL
id|TOTAL_MAP_ENTRIES
suffix:semicolon
id|entry2
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;RIOSavedTable
(braket
id|entry2
)braket
dot
id|RtaUniqueNum
op_eq
id|RtaUniq
)paren
r_break
suffix:semicolon
)brace
id|MapP2
op_assign
op_amp
id|p-&gt;RIOSavedTable
(braket
id|entry2
)braket
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;This RTA is from table entries %d+%d&bslash;n&quot;
comma
id|rta
comma
id|entry2
)paren
suffix:semicolon
)brace
r_else
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;This RTA is from table entry %d&bslash;n&quot;
comma
id|rta
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;** There is no SLOT_IN_USE or SLOT_TENTATIVE entry for this RTA&n;&t;** attached to the current host card in the driver table.&n;&t;**&n;&t;** We may have found a SLOT_IN_USE entry on another host for this&n;&t;** RTA in the config table, or a SLOT_IN_USE or SLOT_TENTATIVE entry&n;&t;** on another host for this RTA in the driver table.&n;&t;**&n;&t;** Check the driver table for room to fit this newly discovered RTA.&n;&t;** RIOFindFreeID() first looks for free slots and if it does not&n;&t;** find any free slots it will then attempt to oust any&n;&t;** tentative entry in the table.&n;&t;*/
id|EmptySlot
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|RtaType
op_eq
id|TYPE_RTA16
)paren
(brace
r_if
c_cond
(paren
id|RIOFindFreeID
c_func
(paren
id|p
comma
id|HostP
comma
op_amp
id|entry
comma
op_amp
id|entry2
)paren
op_eq
l_int|0
)paren
(brace
id|RIODefaultName
c_func
(paren
id|p
comma
id|HostP
comma
id|entry
)paren
suffix:semicolon
id|FillSlot
c_func
(paren
id|entry
comma
id|entry2
comma
id|RtaUniq
comma
id|HostP
)paren
suffix:semicolon
id|EmptySlot
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|RIOFindFreeID
c_func
(paren
id|p
comma
id|HostP
comma
op_amp
id|entry
comma
l_int|NULL
)paren
op_eq
l_int|0
)paren
(brace
id|RIODefaultName
c_func
(paren
id|p
comma
id|HostP
comma
id|entry
)paren
suffix:semicolon
id|FillSlot
c_func
(paren
id|entry
comma
l_int|0
comma
id|RtaUniq
comma
id|HostP
)paren
suffix:semicolon
id|EmptySlot
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;** There is no SLOT_IN_USE or SLOT_TENTATIVE entry for this RTA&n;&t;** attached to the current host card in the driver table.&n;&t;**&n;&t;** If we found a SLOT_IN_USE entry on another host for this&n;&t;** RTA in the config or driver table, and there are enough free&n;&t;** slots in the driver table, then we need to move it over and&n;&t;** delete it from the other host.&n;&t;** If we found a SLOT_TENTATIVE entry on another host for this&n;&t;** RTA in the driver table, just delete the other host entry.&n;&t;*/
r_if
c_cond
(paren
id|EmptySlot
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|MapP
)paren
(brace
r_if
c_cond
(paren
id|Flag
op_amp
id|SLOT_IN_USE
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;This RTA configured on another host - move entry to current host (1)&bslash;n&quot;
)paren
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|SysPort
op_assign
id|MapP-&gt;SysPort
suffix:semicolon
id|CCOPY
c_func
(paren
id|MapP-&gt;Name
comma
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|Name
comma
id|MAX_NAME_LEN
)paren
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|Flags
op_assign
id|SLOT_IN_USE
op_or
id|RTA_BOOTED
op_or
id|RTA_NEWBOOT
suffix:semicolon
macro_line|#if NEED_TO_FIX
id|RIO_SV_BROADCAST
c_func
(paren
id|HostP-&gt;svFlags
(braket
id|entry
)braket
)paren
suffix:semicolon
macro_line|#endif
id|RIOReMapPorts
c_func
(paren
id|p
comma
id|HostP
comma
op_amp
id|HostP-&gt;Mapping
(braket
id|entry
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|SysPort
OL
id|p-&gt;RIOFirstPortsBooted
)paren
id|p-&gt;RIOFirstPortsBooted
op_assign
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|SysPort
suffix:semicolon
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|SysPort
OG
id|p-&gt;RIOLastPortsBooted
)paren
id|p-&gt;RIOLastPortsBooted
op_assign
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|SysPort
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;SysPort %d, Name %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|MapP-&gt;SysPort
comma
id|MapP-&gt;Name
)paren
suffix:semicolon
)brace
r_else
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;This RTA has a tentative entry on another host - delete that entry (1)&bslash;n&quot;
)paren
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|Flags
op_assign
id|SLOT_TENTATIVE
op_or
id|RTA_BOOTED
op_or
id|RTA_NEWBOOT
suffix:semicolon
macro_line|#if NEED_TO_FIX
id|RIO_SV_BROADCAST
c_func
(paren
id|HostP-&gt;svFlags
(braket
id|entry
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|RtaType
op_eq
id|TYPE_RTA16
)paren
(brace
r_if
c_cond
(paren
id|Flag
op_amp
id|SLOT_IN_USE
)paren
(brace
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|Flags
op_assign
id|SLOT_IN_USE
op_or
id|RTA_BOOTED
op_or
id|RTA_NEWBOOT
op_or
id|RTA16_SECOND_SLOT
suffix:semicolon
macro_line|#if NEED_TO_FIX
id|RIO_SV_BROADCAST
c_func
(paren
id|HostP-&gt;svFlags
(braket
id|entry2
)braket
)paren
suffix:semicolon
macro_line|#endif
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|SysPort
op_assign
id|MapP2-&gt;SysPort
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** Map second block of ttys for 16 port RTA&n;&t;&t;&t;*/
id|RIOReMapPorts
c_func
(paren
id|p
comma
id|HostP
comma
op_amp
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|SysPort
OL
id|p-&gt;RIOFirstPortsBooted
)paren
id|p-&gt;RIOFirstPortsBooted
op_assign
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|SysPort
suffix:semicolon
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|SysPort
OG
id|p-&gt;RIOLastPortsBooted
)paren
id|p-&gt;RIOLastPortsBooted
op_assign
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|SysPort
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;SysPort %d, Name %s&bslash;n&quot;
comma
(paren
r_int
)paren
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|SysPort
comma
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|Name
)paren
suffix:semicolon
)brace
r_else
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|Flags
op_assign
id|SLOT_TENTATIVE
op_or
id|RTA_BOOTED
op_or
id|RTA_NEWBOOT
op_or
id|RTA16_SECOND_SLOT
suffix:semicolon
macro_line|#if NEED_TO_FIX
id|RIO_SV_BROADCAST
c_func
(paren
id|HostP-&gt;svFlags
(braket
id|entry2
)braket
)paren
suffix:semicolon
macro_line|#endif
id|bzero
c_func
(paren
(paren
id|caddr_t
)paren
id|MapP2
comma
r_sizeof
(paren
r_struct
id|Map
)paren
)paren
suffix:semicolon
)brace
id|bzero
c_func
(paren
(paren
id|caddr_t
)paren
id|MapP
comma
r_sizeof
(paren
r_struct
id|Map
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;RIONoMessage
)paren
id|cprintf
c_func
(paren
l_string|&quot;An orphaned RTA has been adopted by %s &squot;%s&squot; (%c).&bslash;n&quot;
comma
id|MyType
comma
id|MyName
comma
id|MyLink
op_plus
l_char|&squot;A&squot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;RIONoMessage
)paren
id|cprintf
c_func
(paren
l_string|&quot;RTA connected to %s &squot;%s&squot; (%c) not configured.&bslash;n&quot;
comma
id|MyType
comma
id|MyName
comma
id|MyLink
op_plus
l_char|&squot;A&squot;
)paren
suffix:semicolon
id|RIOSetChange
c_func
(paren
id|p
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** There is no room in the driver table to make an entry for the&n;&t;** booted RTA. Keep a note of its Uniq Num in the overflow table,&n;&t;** so we can ignore it&squot;s ID requests.&n;&t;*/
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;RIONoMessage
)paren
id|cprintf
c_func
(paren
l_string|&quot;The RTA connected to %s &squot;%s&squot; (%c) cannot be configured.  You cannot configure more than 128 ports to one host card.&bslash;n&quot;
comma
id|MyType
comma
id|MyName
comma
id|MyLink
op_plus
l_char|&squot;A&squot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|entry
op_assign
l_int|0
suffix:semicolon
id|entry
OL
id|HostP-&gt;NumExtraBooted
suffix:semicolon
id|entry
op_increment
)paren
(brace
r_if
c_cond
(paren
id|HostP-&gt;ExtraUnits
(braket
id|entry
)braket
op_eq
id|RtaUniq
)paren
(brace
multiline_comment|/*&n;&t;&t;** already got it!&n;&t;&t;*/
r_return
id|TRUE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;** If there is room, add the unit to the list of extras&n;&t;*/
r_if
c_cond
(paren
id|HostP-&gt;NumExtraBooted
OL
id|MAX_EXTRA_UNITS
)paren
id|HostP-&gt;ExtraUnits
(braket
id|HostP-&gt;NumExtraBooted
op_increment
)braket
op_assign
id|RtaUniq
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;** If the RTA or its host appears in the RIOBindTab[] structure then&n;** we mustn&squot;t boot the RTA and should return FALSE.&n;** This operation is slightly different from the other drivers for RIO&n;** in that this is designed to work with the new utilities&n;** not config.rio and is FAR SIMPLER.&n;** We no longer support the RIOBootMode variable. It is all done from the&n;** &quot;boot/noboot&quot; field in the rio.cf file.&n;*/
r_int
DECL|function|RIOBootOk
id|RIOBootOk
c_func
(paren
id|p
comma
id|HostP
comma
id|RtaUniq
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
id|ulong
id|RtaUniq
suffix:semicolon
(brace
r_int
id|Entry
suffix:semicolon
id|uint
id|HostUniq
op_assign
id|HostP-&gt;UniqueNum
suffix:semicolon
multiline_comment|/*&n;&t;** Search bindings table for RTA or its parent.&n;&t;** If it exists, return 0, else 1.&n;&t;*/
r_for
c_loop
(paren
id|Entry
op_assign
l_int|0
suffix:semicolon
(paren
id|Entry
OL
id|MAX_RTA_BINDINGS
)paren
op_logical_and
(paren
id|p-&gt;RIOBindTab
(braket
id|Entry
)braket
op_ne
l_int|0
)paren
suffix:semicolon
id|Entry
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|p-&gt;RIOBindTab
(braket
id|Entry
)braket
op_eq
id|HostUniq
)paren
op_logical_or
(paren
id|p-&gt;RIOBindTab
(braket
id|Entry
)braket
op_eq
id|RtaUniq
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;** Make an empty slot tentative. If this is a 16 port RTA, make both&n;** slots tentative, and the second one RTA_SECOND_SLOT as well.&n;*/
r_void
DECL|function|FillSlot
id|FillSlot
c_func
(paren
id|entry
comma
id|entry2
comma
id|RtaUniq
comma
id|HostP
)paren
r_int
id|entry
suffix:semicolon
r_int
id|entry2
suffix:semicolon
id|uint
id|RtaUniq
suffix:semicolon
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
(brace
r_int
id|link
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_BOOT
comma
l_string|&quot;FillSlot(%d, %d, 0x%x...)&bslash;n&quot;
comma
id|entry
comma
id|entry2
comma
id|RtaUniq
)paren
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|Flags
op_assign
(paren
id|RTA_BOOTED
op_or
id|RTA_NEWBOOT
op_or
id|SLOT_TENTATIVE
)paren
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|SysPort
op_assign
id|NO_PORT
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|RtaUniqueNum
op_assign
id|RtaUniq
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|HostUniqueNum
op_assign
id|HostP-&gt;UniqueNum
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|ID
op_assign
id|entry
op_plus
l_int|1
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|ID2
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|entry2
)paren
(brace
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|Flags
op_assign
(paren
id|RTA_BOOTED
op_or
id|RTA_NEWBOOT
op_or
id|SLOT_TENTATIVE
op_or
id|RTA16_SECOND_SLOT
)paren
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|SysPort
op_assign
id|NO_PORT
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|RtaUniqueNum
op_assign
id|RtaUniq
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|HostUniqueNum
op_assign
id|HostP-&gt;UniqueNum
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|Name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|ID
op_assign
id|entry2
op_plus
l_int|1
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|ID2
op_assign
id|entry
op_plus
l_int|1
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|ID2
op_assign
id|entry2
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Must set these up, so that utilities show&n;&t;** topology of 16 port RTAs correctly&n;&t;*/
r_for
c_loop
(paren
id|link
op_assign
l_int|0
suffix:semicolon
id|link
OL
id|LINKS_PER_UNIT
suffix:semicolon
id|link
op_increment
)paren
(brace
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|Topology
(braket
id|link
)braket
dot
id|Unit
op_assign
id|ROUTE_DISCONNECT
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry
)braket
dot
id|Topology
(braket
id|link
)braket
dot
id|Link
op_assign
id|NO_LINK
suffix:semicolon
r_if
c_cond
(paren
id|entry2
)paren
(brace
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|Topology
(braket
id|link
)braket
dot
id|Unit
op_assign
id|ROUTE_DISCONNECT
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|entry2
)braket
dot
id|Topology
(braket
id|link
)braket
dot
id|Link
op_assign
id|NO_LINK
suffix:semicolon
)brace
)brace
)brace
macro_line|#if 0
multiline_comment|/*&n;&t;Function:&t;This function is to disable the disk interrupt &n;    Returns :   Nothing&n;*/
r_void
id|disable_interrupt
c_func
(paren
id|vector
)paren
r_int
id|vector
suffix:semicolon
(brace
r_int
id|ps
suffix:semicolon
r_int
id|val
suffix:semicolon
id|disable
c_func
(paren
id|ps
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vector
OG
l_int|40
)paren
(brace
id|val
op_assign
l_int|1
op_lshift
(paren
id|vector
op_minus
l_int|40
)paren
suffix:semicolon
id|__outb
c_func
(paren
id|S8259
op_plus
l_int|1
comma
id|__inb
c_func
(paren
id|S8259
op_plus
l_int|1
)paren
op_or
id|val
)paren
suffix:semicolon
)brace
r_else
(brace
id|val
op_assign
l_int|1
op_lshift
(paren
id|vector
op_minus
l_int|32
)paren
suffix:semicolon
id|__outb
c_func
(paren
id|M8259
op_plus
l_int|1
comma
id|__inb
c_func
(paren
id|M8259
op_plus
l_int|1
)paren
op_or
id|val
)paren
suffix:semicolon
)brace
id|restore
c_func
(paren
id|ps
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;Function:&t;This function is to enable the disk interrupt &n;    Returns :   Nothing&n;*/
r_void
id|enable_interrupt
c_func
(paren
id|vector
)paren
r_int
id|vector
suffix:semicolon
(brace
r_int
id|ps
suffix:semicolon
r_int
id|val
suffix:semicolon
id|disable
c_func
(paren
id|ps
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vector
OG
l_int|40
)paren
(brace
id|val
op_assign
l_int|1
op_lshift
(paren
id|vector
op_minus
l_int|40
)paren
suffix:semicolon
id|val
op_assign
op_complement
id|val
suffix:semicolon
id|__outb
c_func
(paren
id|S8259
op_plus
l_int|1
comma
id|__inb
c_func
(paren
id|S8259
op_plus
l_int|1
)paren
op_amp
id|val
)paren
suffix:semicolon
)brace
r_else
(brace
id|val
op_assign
l_int|1
op_lshift
(paren
id|vector
op_minus
l_int|32
)paren
suffix:semicolon
id|val
op_assign
op_complement
id|val
suffix:semicolon
id|__outb
c_func
(paren
id|M8259
op_plus
l_int|1
comma
id|__inb
c_func
(paren
id|M8259
op_plus
l_int|1
)paren
op_amp
id|val
)paren
suffix:semicolon
)brace
id|restore
c_func
(paren
id|ps
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
