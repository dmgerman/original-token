multiline_comment|/*&n;** -----------------------------------------------------------------------------&n;**&n;**  Perle Specialix driver for Linux&n;**  ported from the existing SCO driver source&n;**&n; *&n; *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.&n; *&n; *      This program is free software; you can redistribute it and/or modify&n; *      it under the terms of the GNU General Public License as published by&n; *      the Free Software Foundation; either version 2 of the License, or&n; *      (at your option) any later version.&n; *&n; *      This program is distributed in the hope that it will be useful,&n; *      but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *      GNU General Public License for more details.&n; *&n; *      You should have received a copy of the GNU General Public License&n; *      along with this program; if not, write to the Free Software&n; *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;**&n;**&t;Module&t;&t;: riocmd.c&n;**&t;SID&t;&t;: 1.2&n;**&t;Last Modified&t;: 11/6/98 10:33:41&n;**&t;Retrieved&t;: 11/6/98 10:33:49&n;**&n;**  ident @(#)riocmd.c&t;1.2&n;**&n;** -----------------------------------------------------------------------------&n;*/
macro_line|#ifdef SCCS_LABELS
DECL|variable|_riocmd_c_sccs_
r_static
r_char
op_star
id|_riocmd_c_sccs_
op_assign
l_string|&quot;@(#)riocmd.c&t;1.2&quot;
suffix:semicolon
macro_line|#endif
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/string.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/compatmac.h&gt;
macro_line|#include &lt;linux/generic_serial.h&gt;
macro_line|#include &quot;linux_compat.h&quot;
macro_line|#include &quot;rio_linux.h&quot;
macro_line|#include &quot;typdef.h&quot;
macro_line|#include &quot;pkt.h&quot;
macro_line|#include &quot;daemon.h&quot;
macro_line|#include &quot;rio.h&quot;
macro_line|#include &quot;riospace.h&quot;
macro_line|#include &quot;top.h&quot;
macro_line|#include &quot;cmdpkt.h&quot;
macro_line|#include &quot;map.h&quot;
macro_line|#include &quot;riotypes.h&quot;
macro_line|#include &quot;rup.h&quot;
macro_line|#include &quot;port.h&quot;
macro_line|#include &quot;riodrvr.h&quot;
macro_line|#include &quot;rioinfo.h&quot;
macro_line|#include &quot;func.h&quot;
macro_line|#include &quot;errors.h&quot;
macro_line|#include &quot;pci.h&quot;
macro_line|#include &quot;parmmap.h&quot;
macro_line|#include &quot;unixrup.h&quot;
macro_line|#include &quot;board.h&quot;
macro_line|#include &quot;host.h&quot;
macro_line|#include &quot;error.h&quot;
macro_line|#include &quot;phb.h&quot;
macro_line|#include &quot;link.h&quot;
macro_line|#include &quot;cmdblk.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;control.h&quot;
macro_line|#include &quot;cirrus.h&quot;
DECL|variable|IdRta
r_static
r_struct
id|IdentifyRta
id|IdRta
suffix:semicolon
DECL|variable|KillUnit
r_static
r_struct
id|KillNeighbour
id|KillUnit
suffix:semicolon
r_int
DECL|function|RIOFoadRta
id|RIOFoadRta
c_func
(paren
id|HostP
comma
id|MapP
)paren
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
r_struct
id|Map
op_star
id|MapP
suffix:semicolon
(brace
r_struct
id|CmdBlk
op_star
id|CmdBlkP
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;FOAD RTA&bslash;n&quot;
)paren
suffix:semicolon
id|CmdBlkP
op_assign
id|RIOGetCmdBlk
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CmdBlkP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;FOAD RTA: GetCmdBlk failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ENXIO
suffix:semicolon
)brace
id|CmdBlkP-&gt;Packet.dest_unit
op_assign
id|MapP-&gt;ID
suffix:semicolon
id|CmdBlkP-&gt;Packet.dest_port
op_assign
id|BOOT_RUP
suffix:semicolon
id|CmdBlkP-&gt;Packet.src_unit
op_assign
l_int|0
suffix:semicolon
id|CmdBlkP-&gt;Packet.src_port
op_assign
id|BOOT_RUP
suffix:semicolon
id|CmdBlkP-&gt;Packet.len
op_assign
l_int|0x84
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|0
)braket
op_assign
id|IFOAD
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|2
)braket
op_assign
id|IFOAD_MAGIC
op_amp
l_int|0xFF
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|3
)braket
op_assign
(paren
id|IFOAD_MAGIC
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|RIOQueueCmdBlk
c_func
(paren
id|HostP
comma
id|MapP-&gt;ID
op_minus
l_int|1
comma
id|CmdBlkP
)paren
op_eq
id|RIO_FAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;FOAD RTA: Failed to queue foad command&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|RIOZombieRta
id|RIOZombieRta
c_func
(paren
id|HostP
comma
id|MapP
)paren
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
r_struct
id|Map
op_star
id|MapP
suffix:semicolon
(brace
r_struct
id|CmdBlk
op_star
id|CmdBlkP
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;ZOMBIE RTA&bslash;n&quot;
)paren
suffix:semicolon
id|CmdBlkP
op_assign
id|RIOGetCmdBlk
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CmdBlkP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;ZOMBIE RTA: GetCmdBlk failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ENXIO
suffix:semicolon
)brace
id|CmdBlkP-&gt;Packet.dest_unit
op_assign
id|MapP-&gt;ID
suffix:semicolon
id|CmdBlkP-&gt;Packet.dest_port
op_assign
id|BOOT_RUP
suffix:semicolon
id|CmdBlkP-&gt;Packet.src_unit
op_assign
l_int|0
suffix:semicolon
id|CmdBlkP-&gt;Packet.src_port
op_assign
id|BOOT_RUP
suffix:semicolon
id|CmdBlkP-&gt;Packet.len
op_assign
l_int|0x84
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|0
)braket
op_assign
id|ZOMBIE
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|2
)braket
op_assign
id|ZOMBIE_MAGIC
op_amp
l_int|0xFF
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|3
)braket
op_assign
(paren
id|ZOMBIE_MAGIC
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|RIOQueueCmdBlk
c_func
(paren
id|HostP
comma
id|MapP-&gt;ID
op_minus
l_int|1
comma
id|CmdBlkP
)paren
op_eq
id|RIO_FAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;ZOMBIE RTA: Failed to queue zombie command&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|RIOCommandRta
id|RIOCommandRta
c_func
(paren
id|p
comma
id|RtaUnique
comma
id|func
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
id|uint
id|RtaUnique
suffix:semicolon
r_int
(paren
op_star
id|func
)paren
(paren
r_struct
id|Host
op_star
id|HostP
comma
r_struct
id|Map
op_star
id|MapP
)paren
suffix:semicolon
(brace
id|uint
id|Host
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Command RTA 0x%x func 0x%x&bslash;n&quot;
comma
id|RtaUnique
comma
(paren
r_int
)paren
id|func
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RtaUnique
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|Host
op_assign
l_int|0
suffix:semicolon
id|Host
OL
id|p-&gt;RIONumHosts
suffix:semicolon
id|Host
op_increment
)paren
(brace
id|uint
id|Rta
suffix:semicolon
r_struct
id|Host
op_star
id|HostP
op_assign
op_amp
id|p-&gt;RIOHosts
(braket
id|Host
)braket
suffix:semicolon
r_for
c_loop
(paren
id|Rta
op_assign
l_int|0
suffix:semicolon
id|Rta
OL
id|RTAS_PER_HOST
suffix:semicolon
id|Rta
op_increment
)paren
(brace
r_struct
id|Map
op_star
id|MapP
op_assign
op_amp
id|HostP-&gt;Mapping
(braket
id|Rta
)braket
suffix:semicolon
r_if
c_cond
(paren
id|MapP-&gt;RtaUniqueNum
op_eq
id|RtaUnique
)paren
(brace
id|uint
id|Link
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;** now, lets just check we have a route to it...&n;&t;&t;&t;&t;** IF the routing stuff is working, then one of the&n;&t;&t;&t;&t;** topology entries for this unit will have a legit&n;&t;&t;&t;&t;** route *somewhere*. We care not where - if its got&n;&t;&t;&t;&t;** any connections, we can get to it.&n;&t;&t;&t;&t;*/
r_for
c_loop
(paren
id|Link
op_assign
l_int|0
suffix:semicolon
id|Link
OL
id|LINKS_PER_UNIT
suffix:semicolon
id|Link
op_increment
)paren
(brace
r_if
c_cond
(paren
id|MapP-&gt;Topology
(braket
id|Link
)braket
dot
id|Unit
op_le
(paren
id|uchar
)paren
id|MAX_RUP
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;** Its worth trying the operation...&n;&t;&t;&t;&t;&t;&t;*/
r_return
(paren
op_star
id|func
)paren
(paren
id|HostP
comma
id|MapP
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
r_return
id|ENXIO
suffix:semicolon
)brace
r_int
DECL|function|RIOIdentifyRta
id|RIOIdentifyRta
c_func
(paren
id|p
comma
id|arg
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
id|caddr_t
id|arg
suffix:semicolon
(brace
id|uint
id|Host
suffix:semicolon
r_if
c_cond
(paren
id|copyin
c_func
(paren
(paren
r_int
)paren
id|arg
comma
(paren
id|caddr_t
)paren
op_amp
id|IdRta
comma
r_sizeof
(paren
id|IdRta
)paren
)paren
op_eq
id|COPYFAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;RIO_IDENTIFY_RTA copy failed&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;RIOError.Error
op_assign
id|COPYIN_FAILED
suffix:semicolon
r_return
id|EFAULT
suffix:semicolon
)brace
r_for
c_loop
(paren
id|Host
op_assign
l_int|0
suffix:semicolon
id|Host
OL
id|p-&gt;RIONumHosts
suffix:semicolon
id|Host
op_increment
)paren
(brace
id|uint
id|Rta
suffix:semicolon
r_struct
id|Host
op_star
id|HostP
op_assign
op_amp
id|p-&gt;RIOHosts
(braket
id|Host
)braket
suffix:semicolon
r_for
c_loop
(paren
id|Rta
op_assign
l_int|0
suffix:semicolon
id|Rta
OL
id|RTAS_PER_HOST
suffix:semicolon
id|Rta
op_increment
)paren
(brace
r_struct
id|Map
op_star
id|MapP
op_assign
op_amp
id|HostP-&gt;Mapping
(braket
id|Rta
)braket
suffix:semicolon
r_if
c_cond
(paren
id|MapP-&gt;RtaUniqueNum
op_eq
id|IdRta.RtaUnique
)paren
(brace
id|uint
id|Link
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;** now, lets just check we have a route to it...&n;&t;&t;&t;&t;** IF the routing stuff is working, then one of the&n;&t;&t;&t;&t;** topology entries for this unit will have a legit&n;&t;&t;&t;&t;** route *somewhere*. We care not where - if its got&n;&t;&t;&t;&t;** any connections, we can get to it.&n;&t;&t;&t;&t;*/
r_for
c_loop
(paren
id|Link
op_assign
l_int|0
suffix:semicolon
id|Link
OL
id|LINKS_PER_UNIT
suffix:semicolon
id|Link
op_increment
)paren
(brace
r_if
c_cond
(paren
id|MapP-&gt;Topology
(braket
id|Link
)braket
dot
id|Unit
op_le
(paren
id|uchar
)paren
id|MAX_RUP
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t;** Its worth trying the operation...&n;&t;&t;&t;&t;&t;&t;*/
r_struct
id|CmdBlk
op_star
id|CmdBlkP
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;IDENTIFY RTA&bslash;n&quot;
)paren
suffix:semicolon
id|CmdBlkP
op_assign
id|RIOGetCmdBlk
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CmdBlkP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;IDENTIFY RTA: GetCmdBlk failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ENXIO
suffix:semicolon
)brace
id|CmdBlkP-&gt;Packet.dest_unit
op_assign
id|MapP-&gt;ID
suffix:semicolon
id|CmdBlkP-&gt;Packet.dest_port
op_assign
id|BOOT_RUP
suffix:semicolon
id|CmdBlkP-&gt;Packet.src_unit
op_assign
l_int|0
suffix:semicolon
id|CmdBlkP-&gt;Packet.src_port
op_assign
id|BOOT_RUP
suffix:semicolon
id|CmdBlkP-&gt;Packet.len
op_assign
l_int|0x84
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|0
)braket
op_assign
id|IDENTIFY
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|2
)braket
op_assign
id|IdRta.ID
suffix:semicolon
r_if
c_cond
(paren
id|RIOQueueCmdBlk
c_func
(paren
id|HostP
comma
id|MapP-&gt;ID
op_minus
l_int|1
comma
id|CmdBlkP
)paren
op_eq
id|RIO_FAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;IDENTIFY RTA: Failed to queue command&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
r_return
id|ENOENT
suffix:semicolon
)brace
r_int
DECL|function|RIOKillNeighbour
id|RIOKillNeighbour
c_func
(paren
id|p
comma
id|arg
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
id|caddr_t
id|arg
suffix:semicolon
(brace
id|uint
id|Host
suffix:semicolon
id|uint
id|ID
suffix:semicolon
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
r_struct
id|CmdBlk
op_star
id|CmdBlkP
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;KILL HOST NEIGHBOUR&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copyin
c_func
(paren
(paren
r_int
)paren
id|arg
comma
(paren
id|caddr_t
)paren
op_amp
id|KillUnit
comma
r_sizeof
(paren
id|KillUnit
)paren
)paren
op_eq
id|COPYFAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;RIO_KILL_NEIGHBOUR copy failed&bslash;n&quot;
)paren
suffix:semicolon
id|p-&gt;RIOError.Error
op_assign
id|COPYIN_FAILED
suffix:semicolon
r_return
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|KillUnit.Link
OG
l_int|3
)paren
r_return
id|ENXIO
suffix:semicolon
id|CmdBlkP
op_assign
id|RIOGetCmdBlk
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CmdBlkP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;UFOAD: GetCmdBlk failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ENXIO
suffix:semicolon
)brace
id|CmdBlkP-&gt;Packet.dest_unit
op_assign
l_int|0
suffix:semicolon
id|CmdBlkP-&gt;Packet.src_unit
op_assign
l_int|0
suffix:semicolon
id|CmdBlkP-&gt;Packet.dest_port
op_assign
id|BOOT_RUP
suffix:semicolon
id|CmdBlkP-&gt;Packet.src_port
op_assign
id|BOOT_RUP
suffix:semicolon
id|CmdBlkP-&gt;Packet.len
op_assign
l_int|0x84
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|0
)braket
op_assign
id|UFOAD
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|1
)braket
op_assign
id|KillUnit.Link
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|2
)braket
op_assign
id|UFOAD_MAGIC
op_amp
l_int|0xFF
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|3
)braket
op_assign
(paren
id|UFOAD_MAGIC
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_for
c_loop
(paren
id|Host
op_assign
l_int|0
suffix:semicolon
id|Host
OL
id|p-&gt;RIONumHosts
suffix:semicolon
id|Host
op_increment
)paren
(brace
id|ID
op_assign
l_int|0
suffix:semicolon
id|HostP
op_assign
op_amp
id|p-&gt;RIOHosts
(braket
id|Host
)braket
suffix:semicolon
r_if
c_cond
(paren
id|HostP-&gt;UniqueNum
op_eq
id|KillUnit.UniqueNum
)paren
(brace
r_if
c_cond
(paren
id|RIOQueueCmdBlk
c_func
(paren
id|HostP
comma
id|RTAS_PER_HOST
op_plus
id|KillUnit.Link
comma
id|CmdBlkP
)paren
op_eq
id|RIO_FAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;UFOAD: Failed queue command&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|ID
op_assign
l_int|0
suffix:semicolon
id|ID
OL
id|RTAS_PER_HOST
suffix:semicolon
id|ID
op_increment
)paren
(brace
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|ID
)braket
dot
id|RtaUniqueNum
op_eq
id|KillUnit.UniqueNum
)paren
(brace
id|CmdBlkP-&gt;Packet.dest_unit
op_assign
id|ID
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|RIOQueueCmdBlk
c_func
(paren
id|HostP
comma
id|ID
comma
id|CmdBlkP
)paren
op_eq
id|RIO_FAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;UFOAD: Failed queue command&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
id|RIOFreeCmdBlk
c_func
(paren
id|CmdBlkP
)paren
suffix:semicolon
r_return
id|ENXIO
suffix:semicolon
)brace
r_int
DECL|function|RIOSuspendBootRta
id|RIOSuspendBootRta
c_func
(paren
id|HostP
comma
id|ID
comma
id|Link
)paren
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
r_int
id|ID
suffix:semicolon
r_int
id|Link
suffix:semicolon
(brace
r_struct
id|CmdBlk
op_star
id|CmdBlkP
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;SUSPEND BOOT ON RTA ID %d, link %c&bslash;n&quot;
comma
id|ID
comma
l_char|&squot;A&squot;
op_plus
id|Link
)paren
suffix:semicolon
id|CmdBlkP
op_assign
id|RIOGetCmdBlk
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CmdBlkP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;SUSPEND BOOT ON RTA: GetCmdBlk failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ENXIO
suffix:semicolon
)brace
id|CmdBlkP-&gt;Packet.dest_unit
op_assign
id|ID
suffix:semicolon
id|CmdBlkP-&gt;Packet.dest_port
op_assign
id|BOOT_RUP
suffix:semicolon
id|CmdBlkP-&gt;Packet.src_unit
op_assign
l_int|0
suffix:semicolon
id|CmdBlkP-&gt;Packet.src_port
op_assign
id|BOOT_RUP
suffix:semicolon
id|CmdBlkP-&gt;Packet.len
op_assign
l_int|0x84
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|0
)braket
op_assign
id|IWAIT
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|1
)braket
op_assign
id|Link
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|2
)braket
op_assign
id|IWAIT_MAGIC
op_amp
l_int|0xFF
suffix:semicolon
id|CmdBlkP-&gt;Packet.data
(braket
l_int|3
)braket
op_assign
(paren
id|IWAIT_MAGIC
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|RIOQueueCmdBlk
c_func
(paren
id|HostP
comma
id|ID
op_minus
l_int|1
comma
id|CmdBlkP
)paren
op_eq
id|RIO_FAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;SUSPEND BOOT ON RTA: Failed to queue iwait command&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_int
DECL|function|RIOFoadWakeup
id|RIOFoadWakeup
c_func
(paren
id|p
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
(brace
r_int
id|port
suffix:semicolon
r_register
r_struct
id|Port
op_star
id|PortP
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
l_int|0
suffix:semicolon
id|port
OL
id|RIO_PORTS
suffix:semicolon
id|port
op_increment
)paren
(brace
id|PortP
op_assign
id|p-&gt;RIOPortp
(braket
id|port
)braket
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
id|PortP-&gt;Config
op_assign
l_int|0
suffix:semicolon
id|PortP-&gt;State
op_assign
l_int|0
suffix:semicolon
id|PortP-&gt;InUse
op_assign
id|NOT_INUSE
suffix:semicolon
id|PortP-&gt;PortState
op_assign
l_int|0
suffix:semicolon
id|PortP-&gt;FlushCmdBodge
op_assign
l_int|0
suffix:semicolon
id|PortP-&gt;ModemLines
op_assign
l_int|0
suffix:semicolon
id|PortP-&gt;ModemState
op_assign
l_int|0
suffix:semicolon
id|PortP-&gt;CookMode
op_assign
l_int|0
suffix:semicolon
id|PortP-&gt;ParamSem
op_assign
l_int|0
suffix:semicolon
id|PortP-&gt;Mapped
op_assign
l_int|0
suffix:semicolon
id|PortP-&gt;WflushFlag
op_assign
l_int|0
suffix:semicolon
id|PortP-&gt;MagicFlags
op_assign
l_int|0
suffix:semicolon
id|PortP-&gt;RxDataStart
op_assign
l_int|0
suffix:semicolon
id|PortP-&gt;TxBufferIn
op_assign
l_int|0
suffix:semicolon
id|PortP-&gt;TxBufferOut
op_assign
l_int|0
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** Incoming command on the COMMAND_RUP to be processed.&n;*/
r_int
DECL|function|RIOCommandRup
id|RIOCommandRup
c_func
(paren
id|p
comma
id|Rup
comma
id|HostP
comma
id|PacketP
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
id|uint
id|Rup
suffix:semicolon
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
id|PKT
op_star
id|PacketP
suffix:semicolon
(brace
r_struct
id|PktCmd
op_star
id|PktCmdP
op_assign
(paren
r_struct
id|PktCmd
op_star
)paren
id|PacketP-&gt;data
suffix:semicolon
r_struct
id|Port
op_star
id|PortP
suffix:semicolon
r_struct
id|UnixRup
op_star
id|UnixRupP
suffix:semicolon
id|ushort
id|SysPort
suffix:semicolon
id|ushort
id|ReportedModemStatus
suffix:semicolon
id|ushort
id|rup
suffix:semicolon
id|ushort
id|subCommand
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
macro_line|#ifdef CHECK
id|CheckHost
c_func
(paren
id|Host
)paren
suffix:semicolon
id|CheckHostP
c_func
(paren
id|HostP
)paren
suffix:semicolon
id|CheckPacketP
c_func
(paren
id|PacketP
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;** 16 port RTA note:&n;&t;** Command rup packets coming from the RTA will have pkt-&gt;data[1] (which&n;&t;** translates to PktCmdP-&gt;PhbNum) set to the host port number for the&n;&t;** particular unit. To access the correct BaseSysPort for a 16 port RTA,&n;&t;** we can use PhbNum to get the rup number for the appropriate 8 port&n;&t;** block (for the first block, this should be equal to &squot;Rup&squot;).&n;&t;*/
id|rup
op_assign
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;PhbNum
)paren
op_div
(paren
id|ushort
)paren
id|PORTS_PER_RTA
suffix:semicolon
id|UnixRupP
op_assign
op_amp
id|HostP-&gt;UnixRups
(braket
id|rup
)braket
suffix:semicolon
id|SysPort
op_assign
id|UnixRupP-&gt;BaseSysPort
op_plus
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;PhbNum
)paren
op_mod
(paren
id|ushort
)paren
id|PORTS_PER_RTA
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Command on rup %d, port %d&bslash;n&quot;
comma
id|rup
comma
id|SysPort
)paren
suffix:semicolon
macro_line|#ifdef CHECK
id|CheckRup
c_func
(paren
id|rup
)paren
suffix:semicolon
id|CheckUnixRupP
c_func
(paren
id|UnixRupP
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|UnixRupP-&gt;BaseSysPort
op_eq
id|NO_PORT
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;OBSCURE ERROR!&bslash;n&quot;
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Diagnostics follow. Please WRITE THESE DOWN and report them to Specialix Technical Support&bslash;n&quot;
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;CONTROL information: Host number %d, name ``%s&squot;&squot;&bslash;n&quot;
comma
id|HostP
op_minus
id|p-&gt;RIOHosts
comma
id|HostP-&gt;Name
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;CONTROL information: Rup number  0x%x&bslash;n&quot;
comma
id|rup
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Rup
op_ge
(paren
id|ushort
)paren
id|MAX_RUP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;CONTROL information: This is the RUP for RTA ``%s&squot;&squot;&bslash;n&quot;
comma
id|HostP-&gt;Mapping
(braket
id|Rup
)braket
dot
id|Name
)paren
suffix:semicolon
)brace
r_else
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;CONTROL information: This is the RUP for link ``%c&squot;&squot; of host ``%s&squot;&squot;&bslash;n&quot;
comma
(paren
l_char|&squot;A&squot;
op_plus
id|Rup
op_minus
id|MAX_RUP
)paren
comma
id|HostP-&gt;Name
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;PACKET information: Destination 0x%x:0x%x&bslash;n&quot;
comma
id|PacketP-&gt;dest_unit
comma
id|PacketP-&gt;dest_port
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;PACKET information: Source&t;  0x%x:0x%x&bslash;n&quot;
comma
id|PacketP-&gt;src_unit
comma
id|PacketP-&gt;src_port
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;PACKET information: Length&t;  0x%x (%d)&bslash;n&quot;
comma
id|PacketP-&gt;len
comma
id|PacketP-&gt;len
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;PACKET information: Control&t; 0x%x (%d)&bslash;n&quot;
comma
id|PacketP-&gt;control
comma
id|PacketP-&gt;control
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;PACKET information: Check&t;   0x%x (%d)&bslash;n&quot;
comma
id|PacketP-&gt;csum
comma
id|PacketP-&gt;csum
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
"&quot;"
id|COMMAND
id|information
suffix:colon
id|Host
id|Port
id|Number
l_int|0
id|x
op_mod
id|x
comma
id|Command
id|Code
l_int|0
id|x
op_mod
id|x
"&bslash;"
id|n
"&quot;"
comma
id|PktCmdP-&gt;PhbNum
comma
id|PktCmdP-&gt;Command
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
macro_line|#ifdef CHECK
id|CheckSysPort
c_func
(paren
id|SysPort
)paren
suffix:semicolon
macro_line|#endif
id|PortP
op_assign
id|p-&gt;RIOPortp
(braket
id|SysPort
)braket
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;Command
)paren
)paren
(brace
r_case
id|BREAK_RECEIVED
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Received a break!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* If the current line disc. is not multi-threading and&n;&t;   &t;&t;&t;the current processor is not the default, reset rup_intr&n;&t;   &t;&t;&t;and return FALSE to ensure that the command packet is&n;&t;   &t;&t;&t;not freed. */
multiline_comment|/* Call tmgr HANGUP HERE */
multiline_comment|/* Fix this later when every thing works !!!! RAMRAJ */
r_break
suffix:semicolon
r_case
id|COMPLETE
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Command complete on phb %d host %d&bslash;n&quot;
comma
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;PhbNum
)paren
comma
id|HostP
op_minus
id|p-&gt;RIOHosts
)paren
suffix:semicolon
id|subCommand
op_assign
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;SubCommand
)paren
)paren
(brace
r_case
id|MEMDUMP
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Memory dump cmd (0x%x) from addr 0x%x&bslash;n&quot;
comma
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;SubCommand
)paren
comma
id|RWORD
c_func
(paren
id|PktCmdP-&gt;SubAddr
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ_REGISTER
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Read register (0x%x)&bslash;n&quot;
comma
id|RWORD
c_func
(paren
id|PktCmdP-&gt;SubAddr
)paren
)paren
suffix:semicolon
id|p-&gt;CdRegister
op_assign
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;ModemStatus
)paren
op_amp
id|MSVR1_HOST
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|subCommand
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|subCommand
)paren
r_break
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;New status is 0x%x was 0x%x&bslash;n&quot;
comma
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;PortStatus
)paren
comma
id|PortP-&gt;PortState
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PortP-&gt;PortState
op_ne
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;PortStatus
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Mark status &amp; wakeup&bslash;n&quot;
)paren
suffix:semicolon
id|PortP-&gt;PortState
op_assign
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;PortStatus
)paren
suffix:semicolon
multiline_comment|/* What should we do here ...&n;&t;&t;&t;&t;wakeup( &amp;PortP-&gt;PortState );&n;&t;&t;&t;&t;*/
)brace
r_else
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;No change&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|MODEM_STATUS
suffix:colon
multiline_comment|/*&n;&t;&t;&t;** Knock out the tbusy and tstop bits, as these are not relevant&n;&t;&t;&t;** to the check for modem status change (they&squot;re just there because&n;&t;&t;&t;** it&squot;s a convenient place to put them!).&n;&t;&t;&t;*/
id|ReportedModemStatus
op_assign
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;ModemStatus
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|PortP-&gt;ModemState
op_amp
id|MSVR1_HOST
)paren
op_eq
(paren
id|ReportedModemStatus
op_amp
id|MSVR1_HOST
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Modem status unchanged 0x%x&bslash;n&quot;
comma
id|PortP-&gt;ModemState
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;** Update ModemState just in case tbusy or tstop states have&n;&t;&t;&t;&t;** changed.&n;&t;&t;&t;&t;*/
id|PortP-&gt;ModemState
op_assign
id|ReportedModemStatus
suffix:semicolon
)brace
r_else
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Modem status change from 0x%x to 0x%x&bslash;n&quot;
comma
id|PortP-&gt;ModemState
comma
id|ReportedModemStatus
)paren
suffix:semicolon
id|PortP-&gt;ModemState
op_assign
id|ReportedModemStatus
suffix:semicolon
macro_line|#ifdef MODEM_SUPPORT
r_if
c_cond
(paren
id|PortP-&gt;Mapped
)paren
(brace
multiline_comment|/***********************************************************&bslash;&n;&t;&t;&t;&t;*************************************************************&n;&t;&t;&t;&t;***&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;   ***&n;&t;&t;&t;&t;***&t;&t;  M O D E M   S T A T E   C H A N G E&t;&t;  ***&n;&t;&t;&t;&t;***&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;   ***&n;&t;&t;&t;&t;*************************************************************&n;&t;&t;&t;&t;&bslash;***********************************************************/
multiline_comment|/*&n;&t;&t;&t;&t;** If the device is a modem, then check the modem&n;&t;&t;&t;&t;** carrier.&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;gs.tty
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|PortP-&gt;gs.tty-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
op_logical_and
(paren
(paren
id|PortP-&gt;State
op_amp
(paren
id|RIO_MOPEN
op_or
id|RIO_WOPEN
)paren
)paren
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Is there a Carrier?&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** Is there a carrier?&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;ModemState
op_amp
id|MSVR1_CD
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;** Has carrier just appeared?&n;&t;&t;&t;*/
r_if
c_cond
(paren
op_logical_neg
(paren
id|PortP-&gt;State
op_amp
id|RIO_CARR_ON
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Carrier just came up.&bslash;n&quot;
)paren
suffix:semicolon
id|PortP-&gt;State
op_or_assign
id|RIO_CARR_ON
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;** wakeup anyone in WOPEN&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;State
op_amp
(paren
id|PORT_ISOPEN
op_or
id|RIO_WOPEN
)paren
)paren
id|wake_up_interruptible
(paren
op_amp
id|PortP-&gt;gs.open_wait
)paren
suffix:semicolon
macro_line|#ifdef STATS
id|PortP-&gt;Stat.ModemOnCnt
op_increment
suffix:semicolon
macro_line|#endif
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;** Has carrier just dropped?&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;State
op_amp
id|RIO_CARR_ON
)paren
(brace
r_if
c_cond
(paren
id|PortP-&gt;State
op_amp
(paren
id|PORT_ISOPEN
op_or
id|RIO_WOPEN
op_or
id|RIO_MOPEN
)paren
)paren
id|tty_hangup
(paren
id|PortP-&gt;gs.tty
)paren
suffix:semicolon
id|PortP-&gt;State
op_and_assign
op_complement
id|RIO_CARR_ON
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Carrirer just went down&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef STATS
id|PortP-&gt;Stat.ModemOffCnt
op_increment
suffix:semicolon
macro_line|#endif
)brace
)brace
)brace
)brace
macro_line|#endif
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Unknown command %d on CMD_RUP of host %d&bslash;n&quot;
comma
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;Command
)paren
comma
id|HostP
op_minus
id|p-&gt;RIOHosts
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;** The command mechanism:&n;**&t;Each rup has a chain of commands associated with it.&n;**&t;This chain is maintained by routines in this file.&n;**&t;Periodically we are called and we run a quick check of all the&n;**&t;active chains to determine if there is a command to be executed,&n;**&t;and if the rup is ready to accept it.&n;**&n;*/
multiline_comment|/*&n;** Allocate an empty command block.&n;*/
r_struct
id|CmdBlk
op_star
DECL|function|RIOGetCmdBlk
id|RIOGetCmdBlk
c_func
(paren
)paren
(brace
r_struct
id|CmdBlk
op_star
id|CmdBlkP
suffix:semicolon
id|CmdBlkP
op_assign
(paren
r_struct
id|CmdBlk
op_star
)paren
id|sysbrk
c_func
(paren
r_sizeof
(paren
r_struct
id|CmdBlk
)paren
)paren
suffix:semicolon
id|bzero
c_func
(paren
id|CmdBlkP
comma
r_sizeof
(paren
r_struct
id|CmdBlk
)paren
)paren
suffix:semicolon
r_return
id|CmdBlkP
suffix:semicolon
)brace
multiline_comment|/*&n;** Return a block to the head of the free list.&n;*/
r_void
DECL|function|RIOFreeCmdBlk
id|RIOFreeCmdBlk
c_func
(paren
id|CmdBlkP
)paren
r_struct
id|CmdBlk
op_star
id|CmdBlkP
suffix:semicolon
(brace
id|sysfree
c_func
(paren
(paren
r_void
op_star
)paren
id|CmdBlkP
comma
r_sizeof
(paren
r_struct
id|CmdBlk
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** attach a command block to the list of commands to be performed for&n;** a given rup.&n;*/
r_int
DECL|function|RIOQueueCmdBlk
id|RIOQueueCmdBlk
c_func
(paren
id|HostP
comma
id|Rup
comma
id|CmdBlkP
)paren
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
id|uint
id|Rup
suffix:semicolon
r_struct
id|CmdBlk
op_star
id|CmdBlkP
suffix:semicolon
(brace
r_struct
id|CmdBlk
op_star
op_star
id|Base
suffix:semicolon
r_struct
id|UnixRup
op_star
id|UnixRupP
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef CHECK
id|CheckHostP
c_func
(paren
id|HostP
)paren
suffix:semicolon
id|CheckRup
c_func
(paren
id|Rup
)paren
suffix:semicolon
id|CheckCmdBlkP
c_func
(paren
id|CmdBlkP
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|Rup
op_ge
(paren
id|ushort
)paren
(paren
id|MAX_RUP
op_plus
id|LINKS_PER_UNIT
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Illegal rup number %d in RIOQueueCmdBlk&bslash;n&quot;
comma
id|Rup
)paren
suffix:semicolon
id|RIOFreeCmdBlk
c_func
(paren
id|CmdBlkP
)paren
suffix:semicolon
r_return
id|RIO_FAIL
suffix:semicolon
)brace
id|UnixRupP
op_assign
op_amp
id|HostP-&gt;UnixRups
(braket
id|Rup
)braket
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|UnixRupP-&gt;RupLock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** If the RUP is currently inactive, then put the request&n;&t;** straight on the RUP....&n;&t;*/
r_if
c_cond
(paren
(paren
id|UnixRupP-&gt;CmdsWaitingP
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|UnixRupP-&gt;CmdPendingP
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|RWORD
c_func
(paren
id|UnixRupP-&gt;RupP-&gt;txcontrol
)paren
op_eq
id|TX_RUP_INACTIVE
)paren
op_logical_and
(paren
id|CmdBlkP-&gt;PreFuncP
ques
c_cond
(paren
op_star
id|CmdBlkP-&gt;PreFuncP
)paren
(paren
id|CmdBlkP-&gt;PreArg
comma
id|CmdBlkP
)paren
suffix:colon
id|TRUE
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;RUP inactive-placing command straight on. Cmd byte is 0x%x&bslash;n&quot;
comma
id|CmdBlkP-&gt;Packet.data
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Whammy! blat that pack!&n;&t;&t;*/
id|HostP
op_member_access_from_pointer
id|Copy
c_func
(paren
(paren
id|caddr_t
)paren
op_amp
id|CmdBlkP-&gt;Packet
comma
id|RIO_PTR
c_func
(paren
id|HostP-&gt;Caddr
comma
id|UnixRupP-&gt;RupP-&gt;txpkt
)paren
comma
r_sizeof
(paren
id|PKT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** place command packet on the pending position.&n;&t;&t;*/
id|UnixRupP-&gt;CmdPendingP
op_assign
id|CmdBlkP
suffix:semicolon
multiline_comment|/*&n;&t;&t;** set the command register&n;&t;&t;*/
id|WWORD
c_func
(paren
id|UnixRupP-&gt;RupP-&gt;txcontrol
comma
id|TX_PACKET_READY
)paren
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|UnixRupP-&gt;RupLock
comma
id|flags
)paren
suffix:semicolon
r_return
id|RIO_SUCCESS
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;RUP active - en-queing&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UnixRupP-&gt;CmdsWaitingP
op_ne
l_int|NULL
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Rup active - command waiting&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UnixRupP-&gt;CmdPendingP
op_ne
l_int|NULL
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Rup active - command pending&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RWORD
c_func
(paren
id|UnixRupP-&gt;RupP-&gt;txcontrol
)paren
op_ne
id|TX_RUP_INACTIVE
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Rup active - command rup not ready&bslash;n&quot;
)paren
suffix:semicolon
id|Base
op_assign
op_amp
id|UnixRupP-&gt;CmdsWaitingP
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;First try to queue cmdblk 0x%x at 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|CmdBlkP
comma
(paren
r_int
)paren
id|Base
)paren
suffix:semicolon
r_while
c_loop
(paren
op_star
id|Base
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Command cmdblk 0x%x here&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
op_star
id|Base
)paren
)paren
suffix:semicolon
id|Base
op_assign
op_amp
(paren
(paren
op_star
id|Base
)paren
op_member_access_from_pointer
id|NextP
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Now try to queue cmd cmdblk 0x%x at 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|CmdBlkP
comma
(paren
r_int
)paren
id|Base
)paren
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Will queue cmdblk 0x%x at 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|CmdBlkP
comma
(paren
r_int
)paren
id|Base
)paren
suffix:semicolon
op_star
id|Base
op_assign
id|CmdBlkP
suffix:semicolon
id|CmdBlkP-&gt;NextP
op_assign
l_int|NULL
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|UnixRupP-&gt;RupLock
comma
id|flags
)paren
suffix:semicolon
r_return
id|RIO_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n;** Here we go - if there is an empty rup, fill it!&n;** must be called at splrio() or higher.&n;*/
r_void
DECL|function|RIOPollHostCommands
id|RIOPollHostCommands
c_func
(paren
id|p
comma
id|HostP
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
(brace
r_register
r_struct
id|CmdBlk
op_star
id|CmdBlkP
suffix:semicolon
r_register
r_struct
id|UnixRup
op_star
id|UnixRupP
suffix:semicolon
r_struct
id|PKT
op_star
id|PacketP
suffix:semicolon
id|ushort
id|Rup
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|Rup
op_assign
id|MAX_RUP
op_plus
id|LINKS_PER_UNIT
suffix:semicolon
r_do
(brace
multiline_comment|/* do this loop for each RUP */
multiline_comment|/*&n;&t;&t;** locate the rup we are processing &amp; lock it&n;&t;&t;*/
id|UnixRupP
op_assign
op_amp
id|HostP-&gt;UnixRups
(braket
op_decrement
id|Rup
)braket
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|UnixRupP-&gt;RupLock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** First check for incoming commands:&n;&t;&t;*/
r_if
c_cond
(paren
id|RWORD
c_func
(paren
id|UnixRupP-&gt;RupP-&gt;rxcontrol
)paren
op_ne
id|RX_RUP_INACTIVE
)paren
(brace
r_int
id|FreeMe
suffix:semicolon
id|PacketP
op_assign
(paren
id|PKT
op_star
)paren
id|RIO_PTR
c_func
(paren
id|HostP-&gt;Caddr
comma
id|RWORD
c_func
(paren
id|UnixRupP-&gt;RupP-&gt;rxpkt
)paren
)paren
suffix:semicolon
id|ShowPacket
c_func
(paren
id|DBG_CMD
comma
id|PacketP
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|RBYTE
c_func
(paren
id|PacketP-&gt;dest_port
)paren
)paren
(brace
r_case
id|BOOT_RUP
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Incoming Boot %s packet &squot;%x&squot;&bslash;n&quot;
comma
id|RBYTE
c_func
(paren
id|PacketP-&gt;len
)paren
op_amp
l_int|0x80
ques
c_cond
l_string|&quot;Command&quot;
suffix:colon
l_string|&quot;Data&quot;
comma
id|RBYTE
c_func
(paren
id|PacketP-&gt;data
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|UnixRupP-&gt;RupLock
comma
id|flags
)paren
suffix:semicolon
id|FreeMe
op_assign
id|RIOBootRup
c_func
(paren
id|p
comma
id|Rup
comma
id|HostP
comma
id|PacketP
)paren
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|UnixRupP-&gt;RupLock
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMMAND_RUP
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t;&t;** Free the RUP lock as loss of carrier causes a&n;&t;&t;&t;&t;&t;** ttyflush which will (eventually) call another&n;&t;&t;&t;&t;&t;** routine that uses the RUP lock.&n;&t;&t;&t;&t;&t;*/
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|UnixRupP-&gt;RupLock
comma
id|flags
)paren
suffix:semicolon
id|FreeMe
op_assign
id|RIOCommandRup
c_func
(paren
id|p
comma
id|Rup
comma
id|HostP
comma
id|PacketP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PacketP-&gt;data
(braket
l_int|5
)braket
op_eq
id|MEMDUMP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Memdump from 0x%x complete&bslash;n&quot;
comma
op_star
(paren
id|ushort
op_star
)paren
op_amp
(paren
id|PacketP-&gt;data
(braket
l_int|6
)braket
)paren
)paren
suffix:semicolon
id|HostP
op_member_access_from_pointer
id|Copy
c_func
(paren
(paren
id|caddr_t
)paren
op_amp
(paren
id|PacketP-&gt;data
(braket
l_int|8
)braket
)paren
comma
(paren
id|caddr_t
)paren
id|p-&gt;RIOMemDump
comma
l_int|32
)paren
suffix:semicolon
)brace
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|UnixRupP-&gt;RupLock
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ROUTE_RUP
suffix:colon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|UnixRupP-&gt;RupLock
comma
id|flags
)paren
suffix:semicolon
id|FreeMe
op_assign
id|RIORouteRup
c_func
(paren
id|p
comma
id|Rup
comma
id|HostP
comma
id|PacketP
)paren
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|UnixRupP-&gt;RupLock
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Unknown RUP %d&bslash;n&quot;
comma
id|RBYTE
c_func
(paren
id|PacketP-&gt;dest_port
)paren
)paren
suffix:semicolon
id|FreeMe
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FreeMe
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Free processed incoming command packet&bslash;n&quot;
)paren
suffix:semicolon
id|put_free_end
c_func
(paren
id|HostP
comma
id|PacketP
)paren
suffix:semicolon
id|WWORD
c_func
(paren
id|UnixRupP-&gt;RupP-&gt;rxcontrol
comma
id|RX_RUP_INACTIVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RWORD
c_func
(paren
id|UnixRupP-&gt;RupP-&gt;handshake
)paren
op_eq
id|PHB_HANDSHAKE_SET
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Handshake rup %d&bslash;n&quot;
comma
id|Rup
)paren
suffix:semicolon
id|WWORD
c_func
(paren
id|UnixRupP-&gt;RupP-&gt;handshake
comma
id|PHB_HANDSHAKE_SET
op_or
id|PHB_HANDSHAKE_RESET
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t;&t;** IF a command was running on the port, &n;&t;&t;** and it has completed, then tidy it up.&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|CmdBlkP
op_assign
id|UnixRupP-&gt;CmdPendingP
)paren
op_logical_and
multiline_comment|/* ASSIGN! */
(paren
id|RWORD
c_func
(paren
id|UnixRupP-&gt;RupP-&gt;txcontrol
)paren
op_eq
id|TX_RUP_INACTIVE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;** we are idle.&n;&t;&t;&t;** there is a command in pending.&n;&t;&t;&t;** Therefore, this command has finished.&n;&t;&t;&t;** So, wakeup whoever is waiting for it (and tell them&n;&t;&t;&t;** what happened).&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|CmdBlkP-&gt;Packet.dest_port
op_eq
id|BOOT_RUP
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Free Boot %s Command Block &squot;%x&squot;&bslash;n&quot;
comma
id|CmdBlkP-&gt;Packet.len
op_amp
l_int|0x80
ques
c_cond
l_string|&quot;Command&quot;
suffix:colon
l_string|&quot;Data&quot;
comma
id|CmdBlkP-&gt;Packet.data
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Command 0x%x completed&bslash;n&quot;
comma
(paren
r_int
)paren
id|CmdBlkP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** Clear the Rup lock to prevent mutual exclusion.&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|CmdBlkP-&gt;PostFuncP
)paren
(brace
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|UnixRupP-&gt;RupLock
comma
id|flags
)paren
suffix:semicolon
(paren
op_star
id|CmdBlkP-&gt;PostFuncP
)paren
(paren
id|CmdBlkP-&gt;PostArg
comma
id|CmdBlkP
)paren
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|UnixRupP-&gt;RupLock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;** ....clear the pending flag....&n;&t;&t;&t;*/
id|UnixRupP-&gt;CmdPendingP
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** ....and return the command block to the freelist.&n;&t;&t;&t;*/
id|RIOFreeCmdBlk
c_func
(paren
id|CmdBlkP
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;** If there is a command for this rup, and the rup&n;&t;&t;** is idle, then process the command&n;&t;&t;*/
r_if
c_cond
(paren
(paren
id|CmdBlkP
op_assign
id|UnixRupP-&gt;CmdsWaitingP
)paren
op_logical_and
multiline_comment|/* ASSIGN! */
(paren
id|UnixRupP-&gt;CmdPendingP
op_eq
l_int|NULL
)paren
op_logical_and
(paren
id|RWORD
c_func
(paren
id|UnixRupP-&gt;RupP-&gt;txcontrol
)paren
op_eq
id|TX_RUP_INACTIVE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;** if the pre-function is non-zero, call it.&n;&t;&t;&t;** If it returns RIO_FAIL then don&squot;t&n;&t;&t;&t;** send this command yet!&n;&t;&t;&t;*/
macro_line|#ifdef CHECK
id|CheckCmdBlkP
(paren
id|CmdBlkP
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|CmdBlkP-&gt;PreFuncP
ques
c_cond
(paren
op_star
id|CmdBlkP-&gt;PreFuncP
)paren
(paren
id|CmdBlkP-&gt;PreArg
comma
id|CmdBlkP
)paren
suffix:colon
id|TRUE
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Not ready to start command 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|CmdBlkP
)paren
suffix:semicolon
)brace
r_else
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Start new command 0x%x Cmd byte is 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|CmdBlkP
comma
id|CmdBlkP-&gt;Packet.data
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;** Whammy! blat that pack!&n;&t;&t;&t;&t;*/
macro_line|#ifdef CHECK
id|CheckPacketP
(paren
(paren
id|PKT
op_star
)paren
id|RIO_PTR
c_func
(paren
id|HostP-&gt;Caddr
comma
id|UnixRupP-&gt;RupP-&gt;txpkt
)paren
)paren
suffix:semicolon
macro_line|#endif
id|HostP
op_member_access_from_pointer
id|Copy
c_func
(paren
(paren
id|caddr_t
)paren
op_amp
id|CmdBlkP-&gt;Packet
comma
id|RIO_PTR
c_func
(paren
id|HostP-&gt;Caddr
comma
id|UnixRupP-&gt;RupP-&gt;txpkt
)paren
comma
r_sizeof
(paren
id|PKT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;** remove the command from the rup command queue...&n;&t;&t;&t;&t;*/
id|UnixRupP-&gt;CmdsWaitingP
op_assign
id|CmdBlkP-&gt;NextP
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;** ...and place it on the pending position.&n;&t;&t;&t;&t;*/
id|UnixRupP-&gt;CmdPendingP
op_assign
id|CmdBlkP
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;** set the command register&n;&t;&t;&t;&t;*/
id|WWORD
c_func
(paren
id|UnixRupP-&gt;RupP-&gt;txcontrol
comma
id|TX_PACKET_READY
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;** the command block will be freed&n;&t;&t;&t;&t;** when the command has been processed.&n;&t;&t;&t;&t;*/
)brace
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|UnixRupP-&gt;RupLock
comma
id|flags
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|Rup
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** Return the length of the named string&n;*/
r_int
DECL|function|RIOStrlen
id|RIOStrlen
c_func
(paren
id|Str
)paren
r_register
r_char
op_star
id|Str
suffix:semicolon
(brace
r_register
r_int
id|len
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
op_star
id|Str
op_increment
)paren
id|len
op_increment
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n;** compares s1 to s2 and return 0 if they match.&n;*/
r_int
DECL|function|RIOStrCmp
id|RIOStrCmp
c_func
(paren
id|s1
comma
id|s2
)paren
r_register
r_char
op_star
id|s1
suffix:semicolon
r_register
r_char
op_star
id|s2
suffix:semicolon
(brace
r_while
c_loop
(paren
op_star
id|s1
op_logical_and
op_star
id|s2
op_logical_and
op_star
id|s1
op_eq
op_star
id|s2
)paren
id|s1
op_increment
comma
id|s2
op_increment
suffix:semicolon
r_return
op_star
id|s1
op_minus
op_star
id|s2
suffix:semicolon
)brace
multiline_comment|/*&n;** compares s1 to s2 for upto n bytes and return 0 if they match.&n;*/
r_int
DECL|function|RIOStrnCmp
id|RIOStrnCmp
c_func
(paren
id|s1
comma
id|s2
comma
id|n
)paren
r_register
r_char
op_star
id|s1
suffix:semicolon
r_register
r_char
op_star
id|s2
suffix:semicolon
r_int
id|n
suffix:semicolon
(brace
r_while
c_loop
(paren
id|n
op_logical_and
op_star
id|s1
op_logical_and
op_star
id|s2
op_logical_and
op_star
id|s1
op_eq
op_star
id|s2
)paren
id|n
op_decrement
comma
id|s1
op_increment
comma
id|s2
op_increment
suffix:semicolon
r_return
id|n
ques
c_cond
op_star
id|s1
op_ne
op_star
id|s2
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** copy up to &squot;len&squot; bytes from &squot;from&squot; to &squot;to&squot;.&n;*/
r_void
DECL|function|RIOStrNCpy
id|RIOStrNCpy
c_func
(paren
id|to
comma
id|from
comma
id|len
)paren
r_char
op_star
id|to
suffix:semicolon
r_char
op_star
id|from
suffix:semicolon
r_int
id|len
suffix:semicolon
(brace
r_while
c_loop
(paren
id|len
op_decrement
op_logical_and
(paren
op_star
id|to
op_increment
op_assign
op_star
id|from
op_increment
)paren
)paren
suffix:semicolon
id|to
(braket
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
r_int
DECL|function|RIOWFlushMark
id|RIOWFlushMark
c_func
(paren
id|iPortP
comma
id|CmdBlkP
)paren
r_int
id|iPortP
suffix:semicolon
r_struct
id|CmdBlk
op_star
id|CmdBlkP
suffix:semicolon
(brace
r_struct
id|Port
op_star
id|PortP
op_assign
(paren
r_struct
id|Port
op_star
)paren
id|iPortP
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CHECK
id|CheckPortP
c_func
(paren
id|PortP
)paren
suffix:semicolon
macro_line|#endif
id|PortP-&gt;WflushFlag
op_increment
suffix:semicolon
id|PortP-&gt;MagicFlags
op_or_assign
id|MAGIC_FLUSH
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
r_return
id|RIOUnUse
c_func
(paren
id|iPortP
comma
id|CmdBlkP
)paren
suffix:semicolon
)brace
r_int
DECL|function|RIORFlushEnable
id|RIORFlushEnable
c_func
(paren
id|iPortP
comma
id|CmdBlkP
)paren
r_int
id|iPortP
suffix:semicolon
r_struct
id|CmdBlk
op_star
id|CmdBlkP
suffix:semicolon
(brace
r_struct
id|Port
op_star
id|PortP
op_assign
(paren
r_struct
id|Port
op_star
)paren
id|iPortP
suffix:semicolon
id|PKT
op_star
id|PacketP
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|can_remove_receive
c_func
(paren
op_amp
id|PacketP
comma
id|PortP
)paren
)paren
(brace
id|remove_receive
c_func
(paren
id|PortP
)paren
suffix:semicolon
id|ShowPacket
c_func
(paren
id|DBG_PROC
comma
id|PacketP
)paren
suffix:semicolon
id|put_free_end
c_func
(paren
id|PortP-&gt;HostP
comma
id|PacketP
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|RWORD
c_func
(paren
id|PortP-&gt;PhbP-&gt;handshake
)paren
op_eq
id|PHB_HANDSHAKE_SET
)paren
(brace
multiline_comment|/*&n;&t;&t;** MAGIC! (Basically, handshake the RX buffer, so that&n;&t;&t;** the RTAs upstream can be re-enabled.)&n;&t;&t;*/
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Util: Set RX handshake bit&bslash;n&quot;
)paren
suffix:semicolon
id|WWORD
c_func
(paren
id|PortP-&gt;PhbP-&gt;handshake
comma
id|PHB_HANDSHAKE_SET
op_or
id|PHB_HANDSHAKE_RESET
)paren
suffix:semicolon
)brace
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
r_return
id|RIOUnUse
c_func
(paren
id|iPortP
comma
id|CmdBlkP
)paren
suffix:semicolon
)brace
r_int
DECL|function|RIOUnUse
id|RIOUnUse
c_func
(paren
id|iPortP
comma
id|CmdBlkP
)paren
r_int
id|iPortP
suffix:semicolon
r_struct
id|CmdBlk
op_star
id|CmdBlkP
suffix:semicolon
(brace
r_struct
id|Port
op_star
id|PortP
op_assign
(paren
r_struct
id|Port
op_star
)paren
id|iPortP
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CHECK
id|CheckPortP
c_func
(paren
id|PortP
)paren
suffix:semicolon
macro_line|#endif
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Decrement in use count for port&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PortP-&gt;InUse
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|PortP-&gt;InUse
op_ne
id|NOT_INUSE
)paren
(brace
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;** While PortP-&gt;InUse is set (i.e. a preemptive command has been sent to&n;&t;** the RTA and is awaiting completion), any transmit data is prevented from&n;&t;** being transferred from the write queue into the transmit packets&n;&t;** (add_transmit) and no furthur transmit interrupt will be sent for that&n;&t;** data. The next interrupt will occur up to 500ms later (RIOIntr is called&n;&t;** twice a second as a saftey measure). This was the case when kermit was&n;&t;** used to send data into a RIO port. After each packet was sent, TCFLSH&n;&t;** was called to flush the read queue preemptively. PortP-&gt;InUse was&n;&t;** incremented, thereby blocking the 6 byte acknowledgement packet&n;&t;** transmitted back. This acknowledgment hung around for 500ms before&n;&t;** being sent, thus reducing input performance substantially!.&n;&t;** When PortP-&gt;InUse becomes NOT_INUSE, we must ensure that any data&n;&t;** hanging around in the transmit buffer is sent immediately.&n;&t;*/
id|WWORD
c_func
(paren
id|PortP-&gt;HostP-&gt;ParmMapP-&gt;tx_intr
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* What to do here ..&n;&t;wakeup( (caddr_t)&amp;(PortP-&gt;InUse) );&n;&t;*/
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|ShowPacket
id|ShowPacket
c_func
(paren
id|Flags
comma
id|PacketP
)paren
id|uint
id|Flags
suffix:semicolon
r_struct
id|PKT
op_star
id|PacketP
suffix:semicolon
(brace
)brace
multiline_comment|/*&n;** &n;** How to use this file:&n;** &n;** To send a command down a rup, you need to allocate a command block, fill&n;** in the packet information, fill in the command number, fill in the pre-&n;** and post- functions and arguments, and then add the command block to the&n;** queue of command blocks for the port in question. When the port is idle,&n;** then the pre-function will be called. If this returns RIO_FAIL then the&n;** command will be re-queued and tried again at a later date (probably in one&n;** clock tick). If the pre-function returns NOT RIO_FAIL, then the command&n;** packet will be queued on the RUP, and the txcontrol field set to the&n;** command number. When the txcontrol field has changed from being the&n;** command number, then the post-function will be called, with the argument&n;** specified earlier, a pointer to the command block, and the value of&n;** txcontrol.&n;** &n;** To allocate a command block, call RIOGetCmdBlk(). This returns a pointer&n;** to the command block structure allocated, or NULL if there aren&squot;t any.&n;** The block will have been zeroed for you.&n;** &n;** The structure has the following fields:&n;** &n;** struct CmdBlk&n;** {&n;**&t; struct CmdBlk *NextP;&t;&t;  ** Pointer to next command block   **&n;**&t; struct PKT&t; Packet;&t;&t;** A packet, to copy to the rup&t;**&n;**&t;&t;&t;int&t; (*PreFuncP)();  ** The func to call to check if OK **&n;**&t;&t;&t;int&t; PreArg;&t;&t;** The arg for the func&t;&t;&t;**&n;**&t;&t;&t;int&t; (*PostFuncP)(); ** The func to call when completed **&n;**&t;&t;&t;int&t; PostArg;&t;   ** The arg for the func&t;&t;&t;**&n;** };&n;** &n;** You need to fill in ALL fields EXCEPT NextP, which is used to link the&n;** blocks together either on the free list or on the Rup list.&n;** &n;** Packet is an actual packet structure to be filled in with the packet&n;** information associated with the command. You need to fill in everything,&n;** as the command processore doesn&squot;t process the command packet in any way.&n;** &n;** The PreFuncP is called before the packet is enqueued on the host rup.&n;** PreFuncP is called as (*PreFuncP)(PreArg, CmdBlkP);. PreFuncP must&n;** return !RIO_FAIL to have the packet queued on the rup, and RIO_FAIL&n;** if the packet is NOT to be queued.&n;** &n;** The PostFuncP is called when the command has completed. It is called&n;** as (*PostFuncP)(PostArg, CmdBlkP, txcontrol);. PostFuncP is not expected&n;** to return a value. PostFuncP does NOT need to free the command block,&n;** as this happens automatically after PostFuncP returns.&n;** &n;** Once the command block has been filled in, it is attached to the correct&n;** queue by calling RIOQueueCmdBlk( HostP, Rup, CmdBlkP ) where HostP is&n;** a pointer to the struct Host, Rup is the NUMBER of the rup (NOT a pointer&n;** to it!), and CmdBlkP is the pointer to the command block allocated using&n;** RIOGetCmdBlk().&n;** &n;*/
eof
