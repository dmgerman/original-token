multiline_comment|/*&n;** -----------------------------------------------------------------------------&n;**&n;**  Perle Specialix driver for Linux&n;**  Ported from existing RIO Driver for SCO sources.&n; *&n; *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.&n; *&n; *      This program is free software; you can redistribute it and/or modify&n; *      it under the terms of the GNU General Public License as published by&n; *      the Free Software Foundation; either version 2 of the License, or&n; *      (at your option) any later version.&n; *&n; *      This program is distributed in the hope that it will be useful,&n; *      but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *      GNU General Public License for more details.&n; *&n; *      You should have received a copy of the GNU General Public License&n; *      along with this program; if not, write to the Free Software&n; *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;**&n;**&t;Module&t;&t;: rioroute.c&n;**&t;SID&t;&t;: 1.3&n;**&t;Last Modified&t;: 11/6/98 10:33:46&n;**&t;Retrieved&t;: 11/6/98 10:33:50&n;**&n;**  ident @(#)rioroute.c&t;1.3&n;**&n;** -----------------------------------------------------------------------------&n;*/
macro_line|#ifdef SCCS_LABELS
DECL|variable|_rioroute_c_sccs_
r_static
r_char
op_star
id|_rioroute_c_sccs_
op_assign
l_string|&quot;@(#)rioroute.c&t;1.3&quot;
suffix:semicolon
macro_line|#endif
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/string.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/compatmac.h&gt;
macro_line|#include &lt;linux/generic_serial.h&gt;
macro_line|#include &quot;linux_compat.h&quot;
macro_line|#include &quot;rio_linux.h&quot;
macro_line|#include &quot;typdef.h&quot;
macro_line|#include &quot;pkt.h&quot;
macro_line|#include &quot;daemon.h&quot;
macro_line|#include &quot;rio.h&quot;
macro_line|#include &quot;riospace.h&quot;
macro_line|#include &quot;top.h&quot;
macro_line|#include &quot;cmdpkt.h&quot;
macro_line|#include &quot;map.h&quot;
macro_line|#include &quot;riotypes.h&quot;
macro_line|#include &quot;rup.h&quot;
macro_line|#include &quot;port.h&quot;
macro_line|#include &quot;riodrvr.h&quot;
macro_line|#include &quot;rioinfo.h&quot;
macro_line|#include &quot;func.h&quot;
macro_line|#include &quot;errors.h&quot;
macro_line|#include &quot;pci.h&quot;
macro_line|#include &quot;parmmap.h&quot;
macro_line|#include &quot;unixrup.h&quot;
macro_line|#include &quot;board.h&quot;
macro_line|#include &quot;host.h&quot;
macro_line|#include &quot;error.h&quot;
macro_line|#include &quot;phb.h&quot;
macro_line|#include &quot;link.h&quot;
macro_line|#include &quot;cmdblk.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;control.h&quot;
macro_line|#include &quot;cirrus.h&quot;
macro_line|#include &quot;rioioctl.h&quot;
macro_line|#include &quot;param.h&quot;
macro_line|#include &quot;list.h&quot;
macro_line|#include &quot;sam.h&quot;
multiline_comment|/*&n;** Incoming on the ROUTE_RUP&n;** I wrote this while I was tired. Forgive me.&n;*/
DECL|function|RIORouteRup
r_int
id|RIORouteRup
c_func
(paren
r_struct
id|rio_info
op_star
id|p
comma
id|uint
id|Rup
comma
r_struct
id|Host
op_star
id|HostP
comma
id|PKT
op_star
id|PacketP
)paren
(brace
r_struct
id|PktCmd
op_star
id|PktCmdP
op_assign
(paren
r_struct
id|PktCmd
op_star
)paren
id|PacketP-&gt;data
suffix:semicolon
r_struct
id|PktCmd_M
op_star
id|PktReplyP
suffix:semicolon
r_struct
id|CmdBlk
op_star
id|CmdBlkP
suffix:semicolon
r_struct
id|Port
op_star
id|PortP
suffix:semicolon
r_struct
id|Map
op_star
id|MapP
suffix:semicolon
r_struct
id|Top
op_star
id|TopP
suffix:semicolon
r_int
id|ThisLink
comma
id|ThisLinkMin
comma
id|ThisLinkMax
suffix:semicolon
r_int
id|port
suffix:semicolon
r_int
id|Mod
comma
id|Mod1
comma
id|Mod2
suffix:semicolon
id|ushort
id|RtaType
suffix:semicolon
id|uint
id|RtaUniq
suffix:semicolon
id|uint
id|ThisUnit
comma
id|ThisUnit2
suffix:semicolon
multiline_comment|/* 2 ids to accommodate 16 port RTA */
id|uint
id|OldUnit
comma
id|NewUnit
comma
id|OldLink
comma
id|NewLink
suffix:semicolon
r_char
op_star
id|MyType
comma
op_star
id|MyName
suffix:semicolon
r_int
id|Lies
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef STACK
id|RIOStackCheck
c_func
(paren
l_string|&quot;RIORouteRup&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CHECK
id|CheckPacketP
c_func
(paren
id|PacketP
)paren
suffix:semicolon
id|CheckHostP
c_func
(paren
id|HostP
)paren
suffix:semicolon
id|CheckRup
c_func
(paren
id|Rup
)paren
suffix:semicolon
id|CheckHost
c_func
(paren
id|Host
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;  ** Is this unit telling us it&squot;s current link topology?&n;  */
r_if
c_cond
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;Command
)paren
op_eq
id|ROUTE_TOPOLOGY
)paren
(brace
id|MapP
op_assign
id|HostP-&gt;Mapping
suffix:semicolon
multiline_comment|/*&n;    ** The packet can be sent either by the host or by an RTA.&n;    ** If it comes from the host, then we need to fill in the&n;    ** Topology array in the host structure. If it came in&n;    ** from an RTA then we need to fill in the Mapping structure&squot;s&n;    ** Topology array for the unit.&n;    */
r_if
c_cond
(paren
id|Rup
op_ge
(paren
id|ushort
)paren
id|MAX_RUP
)paren
(brace
id|ThisUnit
op_assign
id|HOST_ID
suffix:semicolon
id|TopP
op_assign
id|HostP-&gt;Topology
suffix:semicolon
id|MyType
op_assign
l_string|&quot;Host&quot;
suffix:semicolon
id|MyName
op_assign
id|HostP-&gt;Name
suffix:semicolon
id|ThisLinkMin
op_assign
id|ThisLinkMax
op_assign
id|Rup
op_minus
id|MAX_RUP
suffix:semicolon
)brace
r_else
(brace
id|ThisUnit
op_assign
id|Rup
op_plus
l_int|1
suffix:semicolon
id|TopP
op_assign
id|HostP-&gt;Mapping
(braket
id|Rup
)braket
dot
id|Topology
suffix:semicolon
id|MyType
op_assign
l_string|&quot;RTA&quot;
suffix:semicolon
id|MyName
op_assign
id|HostP-&gt;Mapping
(braket
id|Rup
)braket
dot
id|Name
suffix:semicolon
id|ThisLinkMin
op_assign
l_int|0
suffix:semicolon
id|ThisLinkMax
op_assign
id|LINKS_PER_UNIT
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;    ** Lies will not be tolerated.&n;    ** If any pair of links claim to be connected to the same&n;    ** place, then ignore this packet completely.&n;    */
id|Lies
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|ThisLink
op_assign
id|ThisLinkMin
op_plus
l_int|1
suffix:semicolon
id|ThisLink
op_le
id|ThisLinkMax
suffix:semicolon
id|ThisLink
op_increment
)paren
(brace
multiline_comment|/*&n;      ** it won&squot;t lie about network interconnect, total disconnects&n;      ** and no-IDs. (or at least, it doesn&squot;t *matter* if it does)&n;      */
r_if
c_cond
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
id|ThisLink
)braket
dot
id|Unit
)paren
OG
(paren
id|ushort
)paren
id|MAX_RUP
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|NewLink
op_assign
id|ThisLinkMin
suffix:semicolon
id|NewLink
OL
id|ThisLink
suffix:semicolon
id|NewLink
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
id|ThisLink
)braket
dot
id|Unit
)paren
op_eq
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
id|NewLink
)braket
dot
id|Unit
)paren
)paren
op_logical_and
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
id|ThisLink
)braket
dot
id|Link
)paren
op_eq
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
id|NewLink
)braket
dot
id|Link
)paren
)paren
)paren
(brace
id|Lies
op_increment
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|Lies
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;LIES! DAMN LIES! %d LIES!&bslash;n&quot;
comma
id|Lies
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;%d:%c %d:%c %d:%c %d:%c&bslash;n&quot;
comma
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
l_int|0
)braket
dot
id|Unit
)paren
comma
l_char|&squot;A&squot;
op_plus
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
l_int|0
)braket
dot
id|Link
)paren
comma
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
l_int|1
)braket
dot
id|Unit
)paren
comma
l_char|&squot;A&squot;
op_plus
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
l_int|1
)braket
dot
id|Link
)paren
comma
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
l_int|2
)braket
dot
id|Unit
)paren
comma
l_char|&squot;A&squot;
op_plus
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
l_int|2
)braket
dot
id|Link
)paren
comma
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
l_int|3
)braket
dot
id|Unit
)paren
comma
l_char|&squot;A&squot;
op_plus
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
l_int|3
)braket
dot
id|Link
)paren
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;    ** now, process each link.&n;    */
r_for
c_loop
(paren
id|ThisLink
op_assign
id|ThisLinkMin
suffix:semicolon
id|ThisLink
op_le
id|ThisLinkMax
suffix:semicolon
id|ThisLink
op_increment
)paren
(brace
multiline_comment|/*&n;      ** this is what it was connected to&n;      */
id|OldUnit
op_assign
id|TopP
(braket
id|ThisLink
)braket
dot
id|Unit
suffix:semicolon
id|OldLink
op_assign
id|TopP
(braket
id|ThisLink
)braket
dot
id|Link
suffix:semicolon
multiline_comment|/*&n;      ** this is what it is now connected to&n;      */
id|NewUnit
op_assign
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
id|ThisLink
)braket
dot
id|Unit
)paren
suffix:semicolon
id|NewLink
op_assign
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;RouteTopology
(braket
id|ThisLink
)braket
dot
id|Link
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OldUnit
op_ne
id|NewUnit
op_logical_or
id|OldLink
op_ne
id|NewLink
)paren
(brace
multiline_comment|/*&n;&t;** something has changed!&n;&t;*/
r_if
c_cond
(paren
id|NewUnit
OG
id|MAX_RUP
op_logical_and
id|NewUnit
op_ne
id|ROUTE_DISCONNECT
op_logical_and
id|NewUnit
op_ne
id|ROUTE_NO_ID
op_logical_and
id|NewUnit
op_ne
id|ROUTE_INTERCONNECT
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;I have a link from %s %s to unit %d:%d - I don&squot;t like it.&bslash;n&quot;
comma
id|MyType
comma
id|MyName
comma
id|NewUnit
comma
id|NewLink
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;  ** put the new values in&n;&t;  */
id|TopP
(braket
id|ThisLink
)braket
dot
id|Unit
op_assign
id|NewUnit
suffix:semicolon
id|TopP
(braket
id|ThisLink
)braket
dot
id|Link
op_assign
id|NewLink
suffix:semicolon
id|RIOSetChange
c_func
(paren
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OldUnit
op_le
id|MAX_RUP
)paren
(brace
multiline_comment|/*&n;&t;    ** If something has become bust, then re-enable them messages&n;&t;    */
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;RIONoMessage
)paren
id|RIOConCon
c_func
(paren
id|p
comma
id|HostP
comma
id|ThisUnit
comma
id|ThisLink
comma
id|OldUnit
comma
id|OldLink
comma
id|DISCONNECT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|NewUnit
op_le
id|MAX_RUP
)paren
op_logical_and
op_logical_neg
id|p-&gt;RIONoMessage
)paren
id|RIOConCon
c_func
(paren
id|p
comma
id|HostP
comma
id|ThisUnit
comma
id|ThisLink
comma
id|NewUnit
comma
id|NewLink
comma
id|CONNECT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NewUnit
op_eq
id|ROUTE_NO_ID
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;%s %s (%c) is connected to an unconfigured unit.&bslash;n&quot;
comma
id|MyType
comma
id|MyName
comma
l_char|&squot;A&squot;
op_plus
id|ThisLink
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NewUnit
op_eq
id|ROUTE_INTERCONNECT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;RIONoMessage
)paren
id|cprintf
c_func
(paren
l_string|&quot;%s &squot;%s&squot; (%c) is connected to another network.&bslash;n&quot;
comma
id|MyType
comma
id|MyName
comma
l_char|&squot;A&squot;
op_plus
id|ThisLink
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;  ** perform an update for &squot;the other end&squot;, so that these messages&n;&t;  ** only appears once. Only disconnect the other end if it is pointing&n;&t;  ** at us!&n;&t;  */
r_if
c_cond
(paren
id|OldUnit
op_eq
id|HOST_ID
)paren
(brace
r_if
c_cond
(paren
id|HostP-&gt;Topology
(braket
id|OldLink
)braket
dot
id|Unit
op_eq
id|ThisUnit
op_logical_and
id|HostP-&gt;Topology
(braket
id|OldLink
)braket
dot
id|Link
op_eq
id|ThisLink
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;SETTING HOST (%c) TO DISCONNECTED!&bslash;n&quot;
comma
id|OldLink
op_plus
l_char|&squot;A&squot;
)paren
suffix:semicolon
id|HostP-&gt;Topology
(braket
id|OldLink
)braket
dot
id|Unit
op_assign
id|ROUTE_DISCONNECT
suffix:semicolon
id|HostP-&gt;Topology
(braket
id|OldLink
)braket
dot
id|Link
op_assign
id|NO_LINK
suffix:semicolon
)brace
r_else
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;HOST(%c) WAS NOT CONNECTED TO %s (%c)!&bslash;n&quot;
comma
id|OldLink
op_plus
l_char|&squot;A&squot;
comma
id|HostP-&gt;Mapping
(braket
id|ThisUnit
op_minus
l_int|1
)braket
dot
id|Name
comma
id|ThisLink
op_plus
l_char|&squot;A&squot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|OldUnit
op_le
id|MAX_RUP
)paren
(brace
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|OldUnit
op_minus
l_int|1
)braket
dot
id|Topology
(braket
id|OldLink
)braket
dot
id|Unit
op_eq
id|ThisUnit
op_logical_and
id|HostP-&gt;Mapping
(braket
id|OldUnit
op_minus
l_int|1
)braket
dot
id|Topology
(braket
id|OldLink
)braket
dot
id|Link
op_eq
id|ThisLink
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;SETTING RTA %s (%c) TO DISCONNECTED!&bslash;n&quot;
comma
id|HostP-&gt;Mapping
(braket
id|OldUnit
op_minus
l_int|1
)braket
dot
id|Name
comma
id|OldLink
op_plus
l_char|&squot;A&squot;
)paren
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|OldUnit
op_minus
l_int|1
)braket
dot
id|Topology
(braket
id|OldLink
)braket
dot
id|Unit
op_assign
id|ROUTE_DISCONNECT
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|OldUnit
op_minus
l_int|1
)braket
dot
id|Topology
(braket
id|OldLink
)braket
dot
id|Link
op_assign
id|NO_LINK
suffix:semicolon
)brace
r_else
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;RTA %s (%c) WAS NOT CONNECTED TO %s (%c)&bslash;n&quot;
comma
id|HostP-&gt;Mapping
(braket
id|OldUnit
op_minus
l_int|1
)braket
dot
id|Name
comma
id|OldLink
op_plus
l_char|&squot;A&squot;
comma
id|HostP-&gt;Mapping
(braket
id|ThisUnit
op_minus
l_int|1
)braket
dot
id|Name
comma
id|ThisLink
op_plus
l_char|&squot;A&squot;
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|NewUnit
op_eq
id|HOST_ID
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;MARKING HOST (%c) CONNECTED TO %s (%c)&bslash;n&quot;
comma
id|NewLink
op_plus
l_char|&squot;A&squot;
comma
id|MyName
comma
id|ThisLink
op_plus
l_char|&squot;A&squot;
)paren
suffix:semicolon
id|HostP-&gt;Topology
(braket
id|NewLink
)braket
dot
id|Unit
op_assign
id|ThisUnit
suffix:semicolon
id|HostP-&gt;Topology
(braket
id|NewLink
)braket
dot
id|Link
op_assign
id|ThisLink
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|NewUnit
op_le
id|MAX_RUP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;MARKING RTA %s (%c) CONNECTED TO %s (%c)&bslash;n&quot;
comma
id|HostP-&gt;Mapping
(braket
id|NewUnit
op_minus
l_int|1
)braket
dot
id|Name
comma
id|NewLink
op_plus
l_char|&squot;A&squot;
comma
id|MyName
comma
id|ThisLink
op_plus
l_char|&squot;A&squot;
)paren
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|NewUnit
op_minus
l_int|1
)braket
dot
id|Topology
(braket
id|NewLink
)braket
dot
id|Unit
op_assign
id|ThisUnit
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|NewUnit
op_minus
l_int|1
)braket
dot
id|Topology
(braket
id|NewLink
)braket
dot
id|Link
op_assign
id|ThisLink
suffix:semicolon
)brace
)brace
id|RIOSetChange
c_func
(paren
id|p
)paren
suffix:semicolon
id|RIOCheckIsolated
c_func
(paren
id|p
comma
id|HostP
comma
id|OldUnit
)paren
suffix:semicolon
)brace
)brace
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;  ** The only other command we recognise is a route_request command&n;  */
r_if
c_cond
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;Command
)paren
op_ne
id|ROUTE_REQUEST
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Unknown command %d received on rup %d host %d ROUTE_RUP&bslash;n&quot;
comma
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;Command
)paren
comma
id|Rup
comma
(paren
r_int
)paren
id|HostP
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
id|RtaUniq
op_assign
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;UniqNum
(braket
l_int|0
)braket
)paren
)paren
op_plus
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;UniqNum
(braket
l_int|1
)braket
)paren
op_lshift
l_int|8
)paren
op_plus
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;UniqNum
(braket
l_int|2
)braket
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;UniqNum
(braket
l_int|3
)braket
)paren
op_lshift
l_int|24
)paren
suffix:semicolon
multiline_comment|/*&n;  ** Determine if 8 or 16 port RTA&n;  */
id|RtaType
op_assign
id|GetUnitType
c_func
(paren
id|RtaUniq
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Received a request for an ID for serial number %x&bslash;n&quot;
comma
id|RtaUniq
)paren
suffix:semicolon
id|Mod
op_assign
id|RBYTE
c_func
(paren
id|PktCmdP-&gt;ModuleTypes
)paren
suffix:semicolon
id|Mod1
op_assign
id|LONYBLE
c_func
(paren
id|Mod
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RtaType
op_eq
id|TYPE_RTA16
)paren
(brace
multiline_comment|/*&n;    ** Only one ident is set for a 16 port RTA. To make compatible&n;    ** with 8 port, set 2nd ident in Mod2 to the same as Mod1.&n;    */
id|Mod2
op_assign
id|Mod1
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Backplane type is %s (all ports)&bslash;n&quot;
comma
id|p-&gt;RIOModuleTypes
(braket
id|Mod1
)braket
dot
id|Name
)paren
suffix:semicolon
)brace
r_else
(brace
id|Mod2
op_assign
id|HINYBLE
c_func
(paren
id|Mod
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Module types are %s (ports 0-3) and %s (ports 4-7)&bslash;n&quot;
comma
id|p-&gt;RIOModuleTypes
(braket
id|Mod1
)braket
dot
id|Name
comma
id|p-&gt;RIOModuleTypes
(braket
id|Mod2
)braket
dot
id|Name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|RtaUniq
op_eq
l_int|0xffffffff
)paren
(brace
id|ShowPacket
c_func
(paren
id|DBG_SPECIAL
comma
id|PacketP
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;  ** try to unhook a command block from the command free list.&n;  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|CmdBlkP
op_assign
id|RIOGetCmdBlk
c_func
(paren
)paren
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;No command blocks to route RTA! come back later.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;  ** Fill in the default info on the command block&n;  */
id|CmdBlkP-&gt;Packet.dest_unit
op_assign
id|Rup
suffix:semicolon
id|CmdBlkP-&gt;Packet.dest_port
op_assign
id|ROUTE_RUP
suffix:semicolon
id|CmdBlkP-&gt;Packet.src_unit
op_assign
id|HOST_ID
suffix:semicolon
id|CmdBlkP-&gt;Packet.src_port
op_assign
id|ROUTE_RUP
suffix:semicolon
id|CmdBlkP-&gt;Packet.len
op_assign
id|PKT_CMD_BIT
op_or
l_int|1
suffix:semicolon
id|CmdBlkP-&gt;PreFuncP
op_assign
id|CmdBlkP-&gt;PostFuncP
op_assign
l_int|NULL
suffix:semicolon
id|PktReplyP
op_assign
(paren
r_struct
id|PktCmd_M
op_star
)paren
id|CmdBlkP-&gt;Packet.data
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RIOBootOk
c_func
(paren
id|p
comma
id|HostP
comma
id|RtaUniq
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;RTA %x tried to get an ID, but does not belong - FOAD it!&bslash;n&quot;
comma
id|RtaUniq
)paren
suffix:semicolon
id|PktReplyP-&gt;Command
op_assign
id|ROUTE_FOAD
suffix:semicolon
id|HostP
op_member_access_from_pointer
id|Copy
c_func
(paren
l_string|&quot;RT_FOAD&quot;
comma
id|PktReplyP-&gt;CommandText
comma
l_int|7
)paren
suffix:semicolon
id|RIOQueueCmdBlk
c_func
(paren
id|HostP
comma
id|Rup
comma
id|CmdBlkP
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;  ** Check to see if the RTA is configured for this host&n;  */
r_for
c_loop
(paren
id|ThisUnit
op_assign
l_int|0
suffix:semicolon
id|ThisUnit
OL
id|MAX_RUP
suffix:semicolon
id|ThisUnit
op_increment
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Entry %d Flags=%s %s UniqueNum=0x%x&bslash;n&quot;
comma
id|ThisUnit
comma
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|Flags
op_amp
id|SLOT_IN_USE
ques
c_cond
l_string|&quot;Slot-In-Use&quot;
suffix:colon
l_string|&quot;Not In Use&quot;
comma
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|Flags
op_amp
id|SLOT_TENTATIVE
ques
c_cond
l_string|&quot;Slot-Tentative&quot;
suffix:colon
l_string|&quot;Not Tentative&quot;
comma
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|RtaUniqueNum
)paren
suffix:semicolon
multiline_comment|/*&n;    ** We have an entry for it.&n;    */
r_if
c_cond
(paren
(paren
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|Flags
op_amp
(paren
id|SLOT_IN_USE
op_or
id|SLOT_TENTATIVE
)paren
)paren
op_logical_and
(paren
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|RtaUniqueNum
op_eq
id|RtaUniq
)paren
)paren
(brace
r_if
c_cond
(paren
id|RtaType
op_eq
id|TYPE_RTA16
)paren
(brace
id|ThisUnit2
op_assign
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|ID2
op_minus
l_int|1
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Found unit 0x%x at slots %d+%d&bslash;n&quot;
comma
id|RtaUniq
comma
id|ThisUnit
comma
id|ThisUnit2
)paren
suffix:semicolon
)brace
r_else
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Found unit 0x%x at slot %d&bslash;n&quot;
comma
id|RtaUniq
comma
id|ThisUnit
)paren
suffix:semicolon
multiline_comment|/*&n;      ** If we have no knowledge of booting it, then the host has&n;      ** been re-booted, and so we must kill the RTA, so that it&n;      ** will be booted again (potentially with new bins)&n;      ** and it will then re-ask for an ID, which we will service.&n;      */
r_if
c_cond
(paren
(paren
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|Flags
op_amp
id|SLOT_IN_USE
)paren
op_logical_and
op_logical_neg
(paren
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|Flags
op_amp
id|RTA_BOOTED
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|Flags
op_amp
id|MSG_DONE
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;RIONoMessage
)paren
id|cprintf
c_func
(paren
l_string|&quot;RTA &squot;%s&squot; is being updated.&bslash;n&quot;
comma
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|Name
)paren
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|Flags
op_or_assign
id|MSG_DONE
suffix:semicolon
)brace
id|PktReplyP-&gt;Command
op_assign
id|ROUTE_FOAD
suffix:semicolon
id|HostP
op_member_access_from_pointer
id|Copy
c_func
(paren
l_string|&quot;RT_FOAD&quot;
comma
id|PktReplyP-&gt;CommandText
comma
l_int|7
)paren
suffix:semicolon
id|RIOQueueCmdBlk
c_func
(paren
id|HostP
comma
id|Rup
comma
id|CmdBlkP
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/*&n;      ** Send the ID (entry) to this RTA. The ID number is implicit as&n;      ** the offset into the table. It is worth noting at this stage&n;      ** that offset zero in the table contains the entries for the&n;      ** RTA with ID 1!!!!&n;      */
id|PktReplyP-&gt;Command
op_assign
id|ROUTE_ALLOCATE
suffix:semicolon
id|PktReplyP-&gt;IDNum
op_assign
id|ThisUnit
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|RtaType
op_eq
id|TYPE_RTA16
)paren
(brace
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|Flags
op_amp
id|SLOT_IN_USE
)paren
multiline_comment|/*&n;&t;    ** Adjust the phb and tx pkt dest_units for 2nd block of 8&n;&t;    ** only if the RTA has ports associated (SLOT_IN_USE)&n;&t;    */
id|RIOFixPhbs
c_func
(paren
id|p
comma
id|HostP
comma
id|ThisUnit2
)paren
suffix:semicolon
id|PktReplyP-&gt;IDNum2
op_assign
id|ThisUnit2
op_plus
l_int|1
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;RTA &squot;%s&squot; has been allocated IDs %d+%d&bslash;n&quot;
comma
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|Name
comma
id|PktReplyP-&gt;IDNum
comma
id|PktReplyP-&gt;IDNum2
)paren
suffix:semicolon
)brace
r_else
(brace
id|PktReplyP-&gt;IDNum2
op_assign
id|ROUTE_NO_ID
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;RTA &squot;%s&squot; has been allocated ID %d&bslash;n&quot;
comma
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|Name
comma
id|PktReplyP-&gt;IDNum
)paren
suffix:semicolon
)brace
id|HostP
op_member_access_from_pointer
id|Copy
c_func
(paren
l_string|&quot;RT_ALLOCAT&quot;
comma
id|PktReplyP-&gt;CommandText
comma
l_int|10
)paren
suffix:semicolon
id|RIOQueueCmdBlk
c_func
(paren
id|HostP
comma
id|Rup
comma
id|CmdBlkP
)paren
suffix:semicolon
multiline_comment|/*&n;      ** If this is a freshly booted RTA, then we need to re-open&n;      ** the ports, if any where open, so that data may once more&n;      ** flow around the system!&n;      */
r_if
c_cond
(paren
(paren
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|Flags
op_amp
id|RTA_NEWBOOT
)paren
op_logical_and
(paren
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|SysPort
op_ne
id|NO_PORT
)paren
)paren
(brace
multiline_comment|/*&n;&t;** look at the ports associated with this beast and&n;&t;** see if any where open. If they was, then re-open&n;&t;** them, using the info from the tty flags.&n;&t;*/
r_for
c_loop
(paren
id|port
op_assign
l_int|0
suffix:semicolon
id|port
OL
id|PORTS_PER_RTA
suffix:semicolon
id|port
op_increment
)paren
(brace
id|PortP
op_assign
id|p-&gt;RIOPortp
(braket
id|port
op_plus
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|SysPort
)braket
suffix:semicolon
r_if
c_cond
(paren
id|PortP-&gt;State
op_amp
(paren
id|RIO_MOPEN
op_or
id|RIO_LOPEN
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Re-opened this port&bslash;n&quot;
)paren
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
id|PortP-&gt;MagicFlags
op_or_assign
id|MAGIC_REBOOT
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|RtaType
op_eq
id|TYPE_RTA16
)paren
(brace
r_for
c_loop
(paren
id|port
op_assign
l_int|0
suffix:semicolon
id|port
OL
id|PORTS_PER_RTA
suffix:semicolon
id|port
op_increment
)paren
(brace
id|PortP
op_assign
id|p-&gt;RIOPortp
(braket
id|port
op_plus
id|HostP-&gt;Mapping
(braket
id|ThisUnit2
)braket
dot
id|SysPort
)braket
suffix:semicolon
r_if
c_cond
(paren
id|PortP-&gt;State
op_amp
(paren
id|RIO_MOPEN
op_or
id|RIO_LOPEN
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Re-opened this port&bslash;n&quot;
)paren
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
id|PortP-&gt;MagicFlags
op_or_assign
id|MAGIC_REBOOT
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n;      ** keep a copy of the module types!&n;      */
id|HostP-&gt;UnixRups
(braket
id|ThisUnit
)braket
dot
id|ModTypes
op_assign
id|Mod
suffix:semicolon
r_if
c_cond
(paren
id|RtaType
op_eq
id|TYPE_RTA16
)paren
id|HostP-&gt;UnixRups
(braket
id|ThisUnit2
)braket
dot
id|ModTypes
op_assign
id|Mod
suffix:semicolon
multiline_comment|/*&n;      ** If either of the modules on this unit is read-only or write-only&n;      ** or none-xprint, then we need to transfer that info over to the&n;      ** relevent ports.&n;      */
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|SysPort
op_ne
id|NO_PORT
)paren
(brace
r_for
c_loop
(paren
id|port
op_assign
l_int|0
suffix:semicolon
id|port
OL
id|PORTS_PER_MODULE
suffix:semicolon
id|port
op_increment
)paren
(brace
id|p-&gt;RIOPortp
(braket
id|port
op_plus
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|SysPort
)braket
op_member_access_from_pointer
id|Config
op_and_assign
op_complement
id|RIO_NOMASK
suffix:semicolon
id|p-&gt;RIOPortp
(braket
id|port
op_plus
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|SysPort
)braket
op_member_access_from_pointer
id|Config
op_or_assign
id|p-&gt;RIOModuleTypes
(braket
id|Mod1
)braket
dot
id|Flags
(braket
id|port
)braket
suffix:semicolon
id|p-&gt;RIOPortp
(braket
id|port
op_plus
id|PORTS_PER_MODULE
op_plus
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|SysPort
)braket
op_member_access_from_pointer
id|Config
op_and_assign
op_complement
id|RIO_NOMASK
suffix:semicolon
id|p-&gt;RIOPortp
(braket
id|port
op_plus
id|PORTS_PER_MODULE
op_plus
id|HostP-&gt;Mapping
(braket
id|ThisUnit
)braket
dot
id|SysPort
)braket
op_member_access_from_pointer
id|Config
op_or_assign
id|p-&gt;RIOModuleTypes
(braket
id|Mod2
)braket
dot
id|Flags
(braket
id|port
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|RtaType
op_eq
id|TYPE_RTA16
)paren
(brace
r_for
c_loop
(paren
id|port
op_assign
l_int|0
suffix:semicolon
id|port
OL
id|PORTS_PER_MODULE
suffix:semicolon
id|port
op_increment
)paren
(brace
id|p-&gt;RIOPortp
(braket
id|port
op_plus
id|HostP-&gt;Mapping
(braket
id|ThisUnit2
)braket
dot
id|SysPort
)braket
op_member_access_from_pointer
id|Config
op_and_assign
op_complement
id|RIO_NOMASK
suffix:semicolon
id|p-&gt;RIOPortp
(braket
id|port
op_plus
id|HostP-&gt;Mapping
(braket
id|ThisUnit2
)braket
dot
id|SysPort
)braket
op_member_access_from_pointer
id|Config
op_or_assign
id|p-&gt;RIOModuleTypes
(braket
id|Mod1
)braket
dot
id|Flags
(braket
id|port
)braket
suffix:semicolon
id|p-&gt;RIOPortp
(braket
id|port
op_plus
id|PORTS_PER_MODULE
op_plus
id|HostP-&gt;Mapping
(braket
id|ThisUnit2
)braket
dot
id|SysPort
)braket
op_member_access_from_pointer
id|Config
op_and_assign
op_complement
id|RIO_NOMASK
suffix:semicolon
id|p-&gt;RIOPortp
(braket
id|port
op_plus
id|PORTS_PER_MODULE
op_plus
id|HostP-&gt;Mapping
(braket
id|ThisUnit2
)braket
dot
id|SysPort
)braket
op_member_access_from_pointer
id|Config
op_or_assign
id|p-&gt;RIOModuleTypes
(braket
id|Mod2
)braket
dot
id|Flags
(braket
id|port
)braket
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;      ** Job done, get on with the interrupts!&n;      */
r_return
id|TRUE
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;  ** There is no table entry for this RTA at all.&n;  **&n;  ** Lets check to see if we actually booted this unit - if not,&n;  ** then we reset it and it will go round the loop of being booted&n;  ** we can then worry about trying to fit it into the table.&n;  */
r_for
c_loop
(paren
id|ThisUnit
op_assign
l_int|0
suffix:semicolon
id|ThisUnit
OL
id|HostP-&gt;NumExtraBooted
suffix:semicolon
id|ThisUnit
op_increment
)paren
r_if
c_cond
(paren
id|HostP-&gt;ExtraUnits
(braket
id|ThisUnit
)braket
op_eq
id|RtaUniq
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ThisUnit
op_eq
id|HostP-&gt;NumExtraBooted
op_logical_and
id|ThisUnit
op_ne
id|MAX_EXTRA_UNITS
)paren
(brace
multiline_comment|/*&n;    ** if the unit wasn&squot;t in the table, and the table wasn&squot;t full, then&n;    ** we reset the unit, because we didn&squot;t boot it.&n;    ** However, if the table is full, it could be that we did boot&n;    ** this unit, and so we won&squot;t reboot it, because it isn&squot;t really&n;    ** all that disasterous to keep the old bins in most cases. This&n;    ** is a rather tacky feature, but we are on the edge of reallity&n;    ** here, because the implication is that someone has connected&n;    ** 16+MAX_EXTRA_UNITS onto one host.&n;    */
r_static
r_int
id|UnknownMesgDone
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|UnknownMesgDone
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|p-&gt;RIONoMessage
)paren
id|cprintf
c_func
(paren
l_string|&quot;One or more unknown RTAs are being updated.&bslash;n&quot;
)paren
suffix:semicolon
id|UnknownMesgDone
op_assign
l_int|1
suffix:semicolon
)brace
id|PktReplyP-&gt;Command
op_assign
id|ROUTE_FOAD
suffix:semicolon
id|HostP
op_member_access_from_pointer
id|Copy
c_func
(paren
l_string|&quot;RT_FOAD&quot;
comma
id|PktReplyP-&gt;CommandText
comma
l_int|7
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;    ** we did boot it (as an extra), and there may now be a table&n;    ** slot free (because of a delete), so we will try to make&n;    ** a tentative entry for it, so that the configurator can see it&n;    ** and fill in the details for us.&n;    */
r_if
c_cond
(paren
id|RtaType
op_eq
id|TYPE_RTA16
)paren
(brace
r_if
c_cond
(paren
id|RIOFindFreeID
c_func
(paren
id|p
comma
id|HostP
comma
op_amp
id|ThisUnit
comma
op_amp
id|ThisUnit2
)paren
op_eq
l_int|0
)paren
(brace
id|RIODefaultName
c_func
(paren
id|p
comma
id|HostP
comma
id|ThisUnit
)paren
suffix:semicolon
id|FillSlot
c_func
(paren
id|ThisUnit
comma
id|ThisUnit2
comma
id|RtaUniq
comma
id|HostP
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|RIOFindFreeID
c_func
(paren
id|p
comma
id|HostP
comma
op_amp
id|ThisUnit
comma
l_int|NULL
)paren
op_eq
l_int|0
)paren
(brace
id|RIODefaultName
c_func
(paren
id|p
comma
id|HostP
comma
id|ThisUnit
)paren
suffix:semicolon
id|FillSlot
c_func
(paren
id|ThisUnit
comma
l_int|0
comma
id|RtaUniq
comma
id|HostP
)paren
suffix:semicolon
)brace
)brace
id|PktReplyP-&gt;Command
op_assign
id|ROUTE_USED
suffix:semicolon
id|HostP
op_member_access_from_pointer
id|Copy
c_func
(paren
l_string|&quot;RT_USED&quot;
comma
id|PktReplyP-&gt;CommandText
comma
l_int|7
)paren
suffix:semicolon
)brace
id|RIOQueueCmdBlk
c_func
(paren
id|HostP
comma
id|Rup
comma
id|CmdBlkP
)paren
suffix:semicolon
r_return
id|TRUE
suffix:semicolon
)brace
r_void
DECL|function|RIOFixPhbs
id|RIOFixPhbs
c_func
(paren
id|p
comma
id|HostP
comma
id|unit
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
id|uint
id|unit
suffix:semicolon
(brace
id|ushort
id|link
comma
id|port
suffix:semicolon
r_struct
id|Port
op_star
id|PortP
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|PortN
op_assign
id|HostP-&gt;Mapping
(braket
id|unit
)braket
dot
id|SysPort
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;RIOFixPhbs unit %d sysport %d&bslash;n&quot;
comma
id|unit
comma
id|PortN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PortN
op_ne
op_minus
l_int|1
)paren
(brace
id|ushort
id|dest_unit
op_assign
id|HostP-&gt;Mapping
(braket
id|unit
)braket
dot
id|ID2
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Get the link number used for the 1st 8 phbs on this unit.&n;&t;&t;*/
id|PortP
op_assign
id|p-&gt;RIOPortp
(braket
id|HostP-&gt;Mapping
(braket
id|dest_unit
op_minus
l_int|1
)braket
dot
id|SysPort
)braket
suffix:semicolon
id|link
op_assign
id|RWORD
c_func
(paren
id|PortP-&gt;PhbP-&gt;link
)paren
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
l_int|0
suffix:semicolon
id|port
OL
id|PORTS_PER_RTA
suffix:semicolon
id|port
op_increment
comma
id|PortN
op_increment
)paren
(brace
id|ushort
id|dest_port
op_assign
id|port
op_plus
l_int|8
suffix:semicolon
macro_line|#if 0
id|uint
id|PktInt
suffix:semicolon
macro_line|#endif
id|WORD
op_star
id|TxPktP
suffix:semicolon
id|PKT
op_star
id|Pkt
suffix:semicolon
id|PortP
op_assign
id|p-&gt;RIOPortp
(braket
id|PortN
)braket
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** If RTA is not powered on, the tx packets will be&n;&t;&t;&t;** unset, so go no further.&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;TxStart
op_eq
l_int|0
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Tx pkts not set up yet&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;** For the second slot of a 16 port RTA, the driver needs to&n;&t;&t;&t;** sort out the phb to port mappings. The dest_unit for this&n;&t;&t;&t;** group of 8 phbs is set to the dest_unit of the accompanying&n;&t;&t;&t;** 8 port block. The dest_port of the second unit is set to&n;&t;&t;&t;** be in the range 8-15 (i.e. 8 is added). Thus, for a 16 port&n;&t;&t;&t;** RTA with IDs 5 and 6, traffic bound for port 6 of unit 6&n;&t;&t;&t;** (being the second map ID) will be sent to dest_unit 5, port&n;&t;&t;&t;** 14. When this RTA is deleted, dest_unit for ID 6 will be&n;&t;&t;&t;** restored, and the dest_port will be reduced by 8.&n;&t;&t;&t;** Transmit packets also have a destination field which needs&n;&t;&t;&t;** adjusting in the same manner.&n;&t;&t;&t;** Note that the unit/port bytes in &squot;dest&squot; are swapped.&n;&t;&t;&t;** We also need to adjust the phb and rup link numbers for the&n;&t;&t;&t;** second block of 8 ttys.&n;&t;&t;&t;*/
r_for
c_loop
(paren
id|TxPktP
op_assign
id|PortP-&gt;TxStart
suffix:semicolon
id|TxPktP
op_le
id|PortP-&gt;TxEnd
suffix:semicolon
id|TxPktP
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;** *TxPktP is the pointer to the transmit packet on the host&n;&t;&t;&t;&t;** card. This needs to be translated into a 32 bit pointer&n;&t;&t;&t;&t;** so it can be accessed from the driver.&n;&t;&t;&t;&t;*/
id|Pkt
op_assign
(paren
id|PKT
op_star
)paren
id|RIO_PTR
c_func
(paren
id|HostP-&gt;Caddr
comma
id|RINDW
c_func
(paren
id|TxPktP
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;** If the packet is used, reset it.&n;&t;&t;&t;&t;*/
id|Pkt
op_assign
(paren
id|PKT
op_star
)paren
(paren
(paren
id|uint
)paren
id|Pkt
op_amp
op_complement
id|PKT_IN_USE
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|Pkt-&gt;dest_unit
comma
id|dest_unit
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|Pkt-&gt;dest_port
comma
id|dest_port
)paren
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;phb dest: Old %x:%x New %x:%x&bslash;n&quot;
comma
id|RWORD
c_func
(paren
id|PortP-&gt;PhbP-&gt;destination
)paren
op_amp
l_int|0xff
comma
(paren
id|RWORD
c_func
(paren
id|PortP-&gt;PhbP-&gt;destination
)paren
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
id|dest_unit
comma
id|dest_port
)paren
suffix:semicolon
id|WWORD
c_func
(paren
id|PortP-&gt;PhbP-&gt;destination
comma
id|dest_unit
op_plus
(paren
id|dest_port
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
id|WWORD
c_func
(paren
id|PortP-&gt;PhbP-&gt;link
comma
id|link
)paren
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;** Now make sure the range of ports to be serviced includes&n;&t;&t;** the 2nd 8 on this 16 port RTA.&n;&t;&t;*/
r_if
c_cond
(paren
id|link
OG
l_int|3
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|unit
op_star
l_int|8
)paren
op_plus
l_int|7
)paren
OG
id|RWORD
c_func
(paren
id|HostP-&gt;LinkStrP
(braket
id|link
)braket
dot
id|last_port
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;last port on host link %d: %d&bslash;n&quot;
comma
id|link
comma
(paren
id|unit
op_star
l_int|8
)paren
op_plus
l_int|7
)paren
suffix:semicolon
id|WWORD
c_func
(paren
id|HostP-&gt;LinkStrP
(braket
id|link
)braket
dot
id|last_port
comma
(paren
id|unit
op_star
l_int|8
)paren
op_plus
l_int|7
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;** Check to see if the new disconnection has isolated this unit.&n;** If it has, then invalidate all its link information, and tell&n;** the world about it. This is done to ensure that the configurator&n;** only gets up-to-date information about what is going on.&n;*/
r_int
DECL|function|RIOCheckIsolated
id|RIOCheckIsolated
c_func
(paren
id|p
comma
id|HostP
comma
id|UnitId
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
id|uint
id|UnitId
suffix:semicolon
(brace
r_int
r_int
id|flags
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|HostP-&gt;HostLock
comma
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CHECK
id|CheckHostP
c_func
(paren
id|HostP
)paren
suffix:semicolon
id|CheckUnitId
c_func
(paren
id|UnitId
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|RIOCheck
c_func
(paren
id|HostP
comma
id|UnitId
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Unit %d is NOT isolated&bslash;n&quot;
comma
id|UnitId
)paren
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|HostP-&gt;HostLock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|RIOIsolate
c_func
(paren
id|p
comma
id|HostP
comma
id|UnitId
)paren
suffix:semicolon
id|RIOSetChange
c_func
(paren
id|p
)paren
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|HostP-&gt;HostLock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;** Invalidate all the link interconnectivity of this unit, and of&n;** all the units attached to it. This will mean that the entire&n;** subnet will re-introduce itself.&n;*/
r_int
DECL|function|RIOIsolate
id|RIOIsolate
c_func
(paren
id|p
comma
id|HostP
comma
id|UnitId
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
id|uint
id|UnitId
suffix:semicolon
(brace
id|uint
id|link
comma
id|unit
suffix:semicolon
macro_line|#ifdef CHECK
id|CheckHostP
c_func
(paren
id|HostP
)paren
suffix:semicolon
id|CheckUnitId
c_func
(paren
id|UnitId
)paren
suffix:semicolon
macro_line|#endif
id|UnitId
op_decrement
suffix:semicolon
multiline_comment|/* this trick relies on the Unit Id being UNSIGNED! */
r_if
c_cond
(paren
id|UnitId
OG
id|MAX_RUP
)paren
multiline_comment|/* dontcha just lurv unsigned maths! */
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|UnitId
)braket
dot
id|Flags
op_amp
id|BEEN_HERE
)paren
r_return
l_int|0
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|UnitId
)braket
dot
id|Flags
op_or_assign
id|BEEN_HERE
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;RIOPrintDisabled
op_eq
id|DO_PRINT
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;RIOMesgIsolated %s&quot;
comma
id|HostP-&gt;Mapping
(braket
id|UnitId
)braket
dot
id|Name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|link
op_assign
l_int|0
suffix:semicolon
id|link
OL
id|LINKS_PER_UNIT
suffix:semicolon
id|link
op_increment
)paren
(brace
id|unit
op_assign
id|HostP-&gt;Mapping
(braket
id|UnitId
)braket
dot
id|Topology
(braket
id|link
)braket
dot
id|Unit
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|UnitId
)braket
dot
id|Topology
(braket
id|link
)braket
dot
id|Unit
op_assign
id|ROUTE_DISCONNECT
suffix:semicolon
id|HostP-&gt;Mapping
(braket
id|UnitId
)braket
dot
id|Topology
(braket
id|link
)braket
dot
id|Link
op_assign
id|NO_LINK
suffix:semicolon
id|RIOIsolate
c_func
(paren
id|p
comma
id|HostP
comma
id|unit
)paren
suffix:semicolon
)brace
id|HostP-&gt;Mapping
(braket
id|UnitId
)braket
dot
id|Flags
op_and_assign
op_complement
id|BEEN_HERE
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_int
DECL|function|RIOCheck
id|RIOCheck
c_func
(paren
id|HostP
comma
id|UnitId
)paren
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
id|uint
id|UnitId
suffix:semicolon
(brace
r_int
r_char
id|link
suffix:semicolon
macro_line|#ifdef CHECK
id|CheckHostP
c_func
(paren
id|HostP
)paren
suffix:semicolon
id|CheckUnitId
c_func
(paren
id|UnitId
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* &t;rio_dprint(RIO_DEBUG_ROUTE, (&quot;Check to see if unit %d has a route to the host&bslash;n&quot;,UnitId)); */
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;RIOCheck : UnitID = %d&bslash;n&quot;
comma
id|UnitId
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UnitId
op_eq
id|HOST_ID
)paren
(brace
multiline_comment|/* rio_dprint(RIO_DEBUG_ROUTE, (&quot;Unit %d is NOT isolated - it IS the host!&bslash;n&quot;, UnitId)); */
r_return
l_int|1
suffix:semicolon
)brace
id|UnitId
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|UnitId
op_ge
id|MAX_RUP
)paren
(brace
multiline_comment|/* rio_dprint(RIO_DEBUG_ROUTE, (&quot;Unit %d - ignored.&bslash;n&quot;, UnitId)); */
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|link
op_assign
l_int|0
suffix:semicolon
id|link
OL
id|LINKS_PER_UNIT
suffix:semicolon
id|link
op_increment
)paren
(brace
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|UnitId
)braket
dot
id|Topology
(braket
id|link
)braket
dot
id|Unit
op_eq
id|HOST_ID
)paren
(brace
multiline_comment|/* rio_dprint(RIO_DEBUG_ROUTE, (&quot;Unit %d is connected directly to host via link (%c).&bslash;n&quot;, &n;&t;&t;&t;&t;&t;&t;UnitId, &squot;A&squot;+link)); */
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|UnitId
)braket
dot
id|Flags
op_amp
id|BEEN_HERE
)paren
(brace
multiline_comment|/* rio_dprint(RIO_DEBUG_ROUTE, (&quot;Been to Unit %d before - ignoring&bslash;n&quot;, UnitId)); */
r_return
l_int|0
suffix:semicolon
)brace
id|HostP-&gt;Mapping
(braket
id|UnitId
)braket
dot
id|Flags
op_or_assign
id|BEEN_HERE
suffix:semicolon
r_for
c_loop
(paren
id|link
op_assign
l_int|0
suffix:semicolon
id|link
OL
id|LINKS_PER_UNIT
suffix:semicolon
id|link
op_increment
)paren
(brace
multiline_comment|/* rio_dprint(RIO_DEBUG_ROUTE, (&quot;Unit %d check link (%c)&bslash;n&quot;, UnitId,&squot;A&squot;+link)); */
r_if
c_cond
(paren
id|RIOCheck
c_func
(paren
id|HostP
comma
id|HostP-&gt;Mapping
(braket
id|UnitId
)braket
dot
id|Topology
(braket
id|link
)braket
dot
id|Unit
)paren
)paren
(brace
multiline_comment|/* rio_dprint(RIO_DEBUG_ROUTE, (&quot;Unit %d is connected to something that knows the host via link (%c)&bslash;n&quot;, UnitId,link+&squot;A&squot;)); */
id|HostP-&gt;Mapping
(braket
id|UnitId
)braket
dot
id|Flags
op_and_assign
op_complement
id|BEEN_HERE
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
id|HostP-&gt;Mapping
(braket
id|UnitId
)braket
dot
id|Flags
op_and_assign
op_complement
id|BEEN_HERE
suffix:semicolon
multiline_comment|/* rio_dprint(RIO_DEBUG_ROUTE, (&quot;Unit %d DOESNT KNOW THE HOST!&bslash;n&quot;, UnitId)); */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** Returns the type of unit (host, 16/8 port RTA)&n;*/
id|uint
DECL|function|GetUnitType
id|GetUnitType
c_func
(paren
id|Uniq
)paren
id|uint
id|Uniq
suffix:semicolon
(brace
r_switch
c_cond
(paren
(paren
id|Uniq
op_rshift
l_int|28
)paren
op_amp
l_int|0xf
)paren
(brace
r_case
id|RIO_AT
suffix:colon
r_case
id|RIO_MCA
suffix:colon
r_case
id|RIO_EISA
suffix:colon
r_case
id|RIO_PCI
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Unit type: Host&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|TYPE_HOST
suffix:semicolon
r_case
id|RIO_RTA_16
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Unit type: 16 port RTA&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|TYPE_RTA16
suffix:semicolon
r_case
id|RIO_RTA
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Unit type: 8 port RTA&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|TYPE_RTA8
suffix:semicolon
r_default
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Unit type: Unrecognised&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|99
suffix:semicolon
)brace
)brace
r_int
DECL|function|RIOSetChange
id|RIOSetChange
c_func
(paren
id|p
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
(brace
r_if
c_cond
(paren
id|p-&gt;RIOQuickCheck
op_ne
id|NOT_CHANGED
)paren
r_return
l_int|0
suffix:semicolon
id|p-&gt;RIOQuickCheck
op_assign
id|CHANGED
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;RIOSignalProcess
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Send SIG-HUP&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;psignal( RIOSignalProcess, SIGHUP );&n;&t;&t;*/
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|RIOConCon
id|RIOConCon
c_func
(paren
id|p
comma
id|HostP
comma
id|FromId
comma
id|FromLink
comma
id|ToId
comma
id|ToLink
comma
id|Change
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
id|uint
id|FromId
suffix:semicolon
id|uint
id|FromLink
suffix:semicolon
id|uint
id|ToId
suffix:semicolon
id|uint
id|ToLink
suffix:semicolon
r_int
id|Change
suffix:semicolon
(brace
r_char
op_star
id|FromName
suffix:semicolon
r_char
op_star
id|FromType
suffix:semicolon
r_char
op_star
id|ToName
suffix:semicolon
r_char
op_star
id|ToType
suffix:semicolon
r_int
r_int
id|tp
suffix:semicolon
multiline_comment|/*&n;** 15.10.1998 ARG - ESIL 0759&n;** (Part) fix for port being trashed when opened whilst RTA &quot;disconnected&quot;&n;**&n;** What&squot;s this doing in here anyway ?&n;** It was causing the port to be &squot;unmapped&squot; if opened whilst RTA &quot;disconnected&quot;&n;**&n;** 09.12.1998 ARG - ESIL 0776 - part fix&n;** Okay, We&squot;ve found out what this was all about now !&n;** Someone had botched this to use RIOHalted to indicated the number of RTAs&n;** &squot;disconnected&squot;. The value in RIOHalted was then being used in the&n;** &squot;RIO_QUICK_CHECK&squot; ioctl. A none zero value indicating that a least one RTA&n;** is &squot;disconnected&squot;. The change was put in to satisfy a customer&squot;s needs.&n;** Having taken this bit of code out &squot;RIO_QUICK_CHECK&squot; now no longer works for&n;** the customer.&n;**&n;    if (Change == CONNECT) {&n;&t;&t;if (p-&gt;RIOHalted) p-&gt;RIOHalted --;&n;&t; }&n;&t; else {&n;&t;&t;p-&gt;RIOHalted ++;&n;&t; }&n;**&n;** So - we need to implement it slightly differently - a new member of the&n;** rio_info struct - RIORtaDisCons (RIO RTA connections) keeps track of RTA&n;** connections and disconnections. &n;*/
r_if
c_cond
(paren
id|Change
op_eq
id|CONNECT
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;RIORtaDisCons
)paren
id|p-&gt;RIORtaDisCons
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|p-&gt;RIORtaDisCons
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;RIOPrintDisabled
op_eq
id|DONT_PRINT
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|FromId
OG
id|ToId
)paren
(brace
id|tp
op_assign
id|FromId
suffix:semicolon
id|FromId
op_assign
id|ToId
suffix:semicolon
id|ToId
op_assign
id|tp
suffix:semicolon
id|tp
op_assign
id|FromLink
suffix:semicolon
id|FromLink
op_assign
id|ToLink
suffix:semicolon
id|ToLink
op_assign
id|tp
suffix:semicolon
)brace
id|FromName
op_assign
id|FromId
ques
c_cond
id|HostP-&gt;Mapping
(braket
id|FromId
op_minus
l_int|1
)braket
dot
id|Name
suffix:colon
id|HostP-&gt;Name
suffix:semicolon
id|FromType
op_assign
id|FromId
ques
c_cond
l_string|&quot;RTA&quot;
suffix:colon
l_string|&quot;HOST&quot;
suffix:semicolon
id|ToName
op_assign
id|ToId
ques
c_cond
id|HostP-&gt;Mapping
(braket
id|ToId
op_minus
l_int|1
)braket
dot
id|Name
suffix:colon
id|HostP-&gt;Name
suffix:semicolon
id|ToType
op_assign
id|ToId
ques
c_cond
l_string|&quot;RTA&quot;
suffix:colon
l_string|&quot;HOST&quot;
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Link between %s &squot;%s&squot; (%c) and %s &squot;%s&squot; (%c) %s.&bslash;n&quot;
comma
id|FromType
comma
id|FromName
comma
l_char|&squot;A&squot;
op_plus
id|FromLink
comma
id|ToType
comma
id|ToName
comma
l_char|&squot;A&squot;
op_plus
id|ToLink
comma
(paren
id|Change
op_eq
id|CONNECT
)paren
ques
c_cond
l_string|&quot;established&quot;
suffix:colon
l_string|&quot;disconnected&quot;
)paren
suffix:semicolon
id|cprintf
c_func
(paren
l_string|&quot;Link between %s &squot;%s&squot; (%c) and %s &squot;%s&squot; (%c) %s.&bslash;n&quot;
comma
id|FromType
comma
id|FromName
comma
l_char|&squot;A&squot;
op_plus
id|FromLink
comma
id|ToType
comma
id|ToName
comma
l_char|&squot;A&squot;
op_plus
id|ToLink
comma
(paren
id|Change
op_eq
id|CONNECT
)paren
ques
c_cond
l_string|&quot;established&quot;
suffix:colon
l_string|&quot;disconnected&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** RIORemoveFromSavedTable :&n;**&n;** Delete and RTA entry from the saved table given to us&n;** by the configuration program.&n;*/
r_int
DECL|function|RIORemoveFromSavedTable
id|RIORemoveFromSavedTable
c_func
(paren
r_struct
id|rio_info
op_star
id|p
comma
r_struct
id|Map
op_star
id|pMap
)paren
(brace
r_int
id|entry
suffix:semicolon
multiline_comment|/*&n;    ** We loop for all entries even after finding an entry and&n;    ** zeroing it because we may have two entries to delete if&n;    ** its a 16 port RTA.&n;    */
r_for
c_loop
(paren
id|entry
op_assign
l_int|0
suffix:semicolon
id|entry
OL
id|TOTAL_MAP_ENTRIES
suffix:semicolon
id|entry
op_increment
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;RIOSavedTable
(braket
id|entry
)braket
dot
id|RtaUniqueNum
op_eq
id|pMap-&gt;RtaUniqueNum
)paren
(brace
id|bzero
c_func
(paren
(paren
id|caddr_t
)paren
op_amp
id|p-&gt;RIOSavedTable
(braket
id|entry
)braket
comma
r_sizeof
(paren
r_struct
id|Map
)paren
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** RIOCheckDisconnected :&n;**&n;** Scan the unit links to and return zero if the unit is completely&n;** disconnected.&n;*/
r_int
DECL|function|RIOFreeDisconnected
id|RIOFreeDisconnected
c_func
(paren
r_struct
id|rio_info
op_star
id|p
comma
r_struct
id|Host
op_star
id|HostP
comma
r_int
id|unit
)paren
(brace
r_int
id|link
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;RIOFreeDisconnect unit %d&bslash;n&quot;
comma
id|unit
)paren
suffix:semicolon
multiline_comment|/*&n;    ** If the slot is tentative and does not belong to the&n;    ** second half of a 16 port RTA then scan to see if&n;    ** is disconnected.&n;    */
r_for
c_loop
(paren
id|link
op_assign
l_int|0
suffix:semicolon
id|link
OL
id|LINKS_PER_UNIT
suffix:semicolon
id|link
op_increment
)paren
(brace
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|unit
)braket
dot
id|Topology
(braket
id|link
)braket
dot
id|Unit
op_ne
id|ROUTE_DISCONNECT
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;    ** If not all links are disconnected then we can forget about it.&n;    */
r_if
c_cond
(paren
id|link
OL
id|LINKS_PER_UNIT
)paren
r_return
l_int|1
suffix:semicolon
macro_line|#if NEED_TO_FIX_THIS
multiline_comment|/* Ok so all the links are disconnected. But we may have only just&n;    ** made this slot tentative and not yet received a topology update.&n;    ** Lets check how long ago we made it tentative.&n;    */
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Just about to check LBOLT on entry %d&bslash;n&quot;
comma
id|unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv_getparm
c_func
(paren
id|LBOLT
comma
(paren
id|ulong_t
op_star
)paren
op_amp
id|current_time
)paren
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;drv_getparm(LBOLT,....) Failed.&bslash;n&quot;
)paren
suffix:semicolon
id|elapse_time
op_assign
id|current_time
op_minus
id|TentTime
(braket
id|unit
)braket
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;elapse %d = current %d - tent %d (%d usec)&bslash;n&quot;
comma
id|elapse_time
comma
id|current_time
comma
id|TentTime
(braket
id|unit
)braket
comma
id|drv_hztousec
c_func
(paren
id|elapse_time
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv_hztousec
c_func
(paren
id|elapse_time
)paren
OL
id|WAIT_TO_FINISH
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Skipping slot %d, not timed out yet %d&bslash;n&quot;
comma
id|unit
comma
id|drv_hztousec
c_func
(paren
id|elapse_time
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;    ** We have found an usable slot.&n;    ** If it is half of a 16 port RTA then delete the other half.&n;    */
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|unit
)braket
dot
id|ID2
op_ne
l_int|0
)paren
(brace
r_int
id|nOther
op_assign
(paren
id|HostP-&gt;Mapping
(braket
id|unit
)braket
dot
id|ID2
)paren
op_minus
l_int|1
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;RioFreedis second slot %d.&bslash;n&quot;
comma
id|nOther
)paren
suffix:semicolon
id|bzero
c_func
(paren
(paren
id|caddr_t
)paren
op_amp
id|HostP-&gt;Mapping
(braket
id|nOther
)braket
comma
r_sizeof
(paren
r_struct
id|Map
)paren
)paren
suffix:semicolon
)brace
id|RIORemoveFromSavedTable
c_func
(paren
id|p
comma
op_amp
id|HostP-&gt;Mapping
(braket
id|unit
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** RIOFindFreeID :&n;**&n;** This function scans the given host table for either one&n;** or two free unit ID&squot;s.&n;*/
r_int
DECL|function|RIOFindFreeID
id|RIOFindFreeID
c_func
(paren
r_struct
id|rio_info
op_star
id|p
comma
r_struct
id|Host
op_star
id|HostP
comma
id|uint
op_star
id|pID1
comma
id|uint
op_star
id|pID2
)paren
(brace
r_int
id|unit
comma
id|tempID
suffix:semicolon
multiline_comment|/*&n;    ** Initialise the ID&squot;s to MAX_RUP.&n;    ** We do this to make the loop for setting the ID&squot;s as simple as&n;    ** possible.&n;    */
op_star
id|pID1
op_assign
id|MAX_RUP
suffix:semicolon
r_if
c_cond
(paren
id|pID2
op_ne
l_int|NULL
)paren
op_star
id|pID2
op_assign
id|MAX_RUP
suffix:semicolon
multiline_comment|/*&n;    ** Scan all entries of the host mapping table for free slots.&n;    ** We scan for free slots first and then if that is not successful&n;    ** we start all over again looking for tentative slots we can re-use.&n;    */
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_RUP
suffix:semicolon
id|unit
op_increment
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Scanning unit %d&bslash;n&quot;
comma
id|unit
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** If the flags are zero then the slot is empty.&n;&t;*/
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|unit
)braket
dot
id|Flags
op_eq
l_int|0
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;      This slot is empty.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;    ** If we haven&squot;t allocated the first ID then do it now.&n;&t;    */
r_if
c_cond
(paren
op_star
id|pID1
op_eq
id|MAX_RUP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Make tentative entry for first unit %d&bslash;n&quot;
comma
id|unit
)paren
suffix:semicolon
op_star
id|pID1
op_assign
id|unit
suffix:semicolon
multiline_comment|/*&n;&t;&t;** If the second ID is not needed then we can return&n;&t;&t;** now.&n;&t;&t;*/
r_if
c_cond
(paren
id|pID2
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;** Allocate the second slot and return.&n;&t;&t;*/
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Make tentative entry for second unit %d&bslash;n&quot;
comma
id|unit
)paren
suffix:semicolon
op_star
id|pID2
op_assign
id|unit
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;    ** If we manage to come out of the free slot loop then we&n;    ** need to start all over again looking for tentative slots&n;    ** that we can re-use.&n;    */
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Starting to scan for tentative slots&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_RUP
suffix:semicolon
id|unit
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|HostP-&gt;Mapping
(braket
id|unit
)braket
dot
id|Flags
op_amp
id|SLOT_TENTATIVE
)paren
op_logical_or
(paren
id|HostP-&gt;Mapping
(braket
id|unit
)braket
dot
id|Flags
op_eq
l_int|0
)paren
)paren
op_logical_and
op_logical_neg
(paren
id|HostP-&gt;Mapping
(braket
id|unit
)braket
dot
id|Flags
op_amp
id|RTA16_SECOND_SLOT
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;    Slot %d looks promising.&bslash;n&quot;
comma
id|unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit
op_eq
op_star
id|pID1
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;    No it isn&squot;t, its the 1st half&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;    ** Slot is Tentative or Empty, but not a tentative second &n;&t;    ** slot of a 16 porter.&n;&t;    ** Attempt to free up this slot (and its parnter if&n;&t;    ** it is a 16 port slot. The second slot will become&n;&t;    ** empty after a call to RIOFreeDisconnected so thats why&n;&t;    ** we look for empty slots above  as well).&n;&t;    */
r_if
c_cond
(paren
id|HostP-&gt;Mapping
(braket
id|unit
)braket
dot
id|Flags
op_ne
l_int|0
)paren
r_if
c_cond
(paren
id|RIOFreeDisconnected
c_func
(paren
id|p
comma
id|HostP
comma
id|unit
)paren
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/*&n;&t;    ** If we haven&squot;t allocated the first ID then do it now.&n;&t;    */
r_if
c_cond
(paren
op_star
id|pID1
op_eq
id|MAX_RUP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Grab tentative entry for first unit %d&bslash;n&quot;
comma
id|unit
)paren
suffix:semicolon
op_star
id|pID1
op_assign
id|unit
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Clear out this slot now that we intend to use it.&n;&t;&t;*/
id|bzero
c_func
(paren
op_amp
id|HostP-&gt;Mapping
(braket
id|unit
)braket
comma
r_sizeof
(paren
r_struct
id|Map
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;** If the second ID is not needed then we can return&n;&t;&t;** now.&n;&t;&t;*/
r_if
c_cond
(paren
id|pID2
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;** Allocate the second slot and return.&n;&t;&t;*/
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Grab tentative/empty  entry for second unit %d&bslash;n&quot;
comma
id|unit
)paren
suffix:semicolon
op_star
id|pID2
op_assign
id|unit
suffix:semicolon
multiline_comment|/*&n;&t;&t;** Clear out this slot now that we intend to use it.&n;&t;&t;*/
id|bzero
c_func
(paren
op_amp
id|HostP-&gt;Mapping
(braket
id|unit
)braket
comma
r_sizeof
(paren
r_struct
id|Map
)paren
)paren
suffix:semicolon
multiline_comment|/* At this point under the right(wrong?) conditions&n;&t;&t;** we may have a first unit ID being higher than the&n;&t;&t;** second unit ID. This is a bad idea if we are about&n;&t;&t;** to fill the slots with a 16 port RTA.&n;&t;&t;** Better check and swap them over.&n;&t;&t;*/
r_if
c_cond
(paren
op_star
id|pID1
OG
op_star
id|pID2
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_ROUTE
comma
l_string|&quot;Swapping IDS %d %d&bslash;n&quot;
comma
op_star
id|pID1
comma
op_star
id|pID2
)paren
suffix:semicolon
id|tempID
op_assign
op_star
id|pID1
suffix:semicolon
op_star
id|pID1
op_assign
op_star
id|pID2
suffix:semicolon
op_star
id|pID2
op_assign
id|tempID
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;    ** If we manage to get to the end of the second loop then we&n;    ** can give up and return a failure.&n;    */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;** The link switch scenario.&n;**&n;** Rta Wun (A) is connected to Tuw (A).&n;** The tables are all up to date, and the system is OK.&n;**&n;** If Wun (A) is now moved to Wun (B) before Wun (A) can&n;** become disconnected, then the follow happens:&n;**&n;** Tuw (A) spots the change of unit:link at the other end&n;** of its link and Tuw sends a topology packet reflecting&n;** the change: Tuw (A) now disconnected from Wun (A), and&n;** this is closely followed by a packet indicating that &n;** Tuw (A) is now connected to Wun (B).&n;**&n;** Wun (B) will spot that it has now become connected, and&n;** Wun will send a topology packet, which indicates that&n;** both Wun (A) and Wun (B) is connected to Tuw (A).&n;**&n;** Eventually Wun (A) realises that it is now disconnected&n;** and Wun will send out a topology packet indicating that&n;** Wun (A) is now disconnected.&n;*/
eof
