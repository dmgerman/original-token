multiline_comment|/*&n;** -----------------------------------------------------------------------------&n;**&n;**  Perle Specialix driver for Linux&n;**  Ported from existing RIO Driver for SCO sources.&n; *&n; *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.&n; *&n; *      This program is free software; you can redistribute it and/or modify&n; *      it under the terms of the GNU General Public License as published by&n; *      the Free Software Foundation; either version 2 of the License, or&n; *      (at your option) any later version.&n; *&n; *      This program is distributed in the hope that it will be useful,&n; *      but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *      GNU General Public License for more details.&n; *&n; *      You should have received a copy of the GNU General Public License&n; *      along with this program; if not, write to the Free Software&n; *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;**&n;**&t;Module&t;&t;: rioparam.c&n;**&t;SID&t;&t;: 1.3&n;**&t;Last Modified&t;: 11/6/98 10:33:45&n;**&t;Retrieved&t;: 11/6/98 10:33:50&n;**&n;**  ident @(#)rioparam.c&t;1.3&n;**&n;** -----------------------------------------------------------------------------&n;*/
macro_line|#ifdef SCCS_LABELS
DECL|variable|_rioparam_c_sccs_
r_static
r_char
op_star
id|_rioparam_c_sccs_
op_assign
l_string|&quot;@(#)rioparam.c&t;1.3&quot;
suffix:semicolon
macro_line|#endif
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/string.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/compatmac.h&gt;
macro_line|#include &lt;linux/generic_serial.h&gt;
macro_line|#include &quot;linux_compat.h&quot;
macro_line|#include &quot;rio_linux.h&quot;
macro_line|#include &quot;typdef.h&quot;
macro_line|#include &quot;pkt.h&quot;
macro_line|#include &quot;daemon.h&quot;
macro_line|#include &quot;rio.h&quot;
macro_line|#include &quot;riospace.h&quot;
macro_line|#include &quot;top.h&quot;
macro_line|#include &quot;cmdpkt.h&quot;
macro_line|#include &quot;map.h&quot;
macro_line|#include &quot;riotypes.h&quot;
macro_line|#include &quot;rup.h&quot;
macro_line|#include &quot;port.h&quot;
macro_line|#include &quot;riodrvr.h&quot;
macro_line|#include &quot;rioinfo.h&quot;
macro_line|#include &quot;func.h&quot;
macro_line|#include &quot;errors.h&quot;
macro_line|#include &quot;pci.h&quot;
macro_line|#include &quot;parmmap.h&quot;
macro_line|#include &quot;unixrup.h&quot;
macro_line|#include &quot;board.h&quot;
macro_line|#include &quot;host.h&quot;
macro_line|#include &quot;error.h&quot;
macro_line|#include &quot;phb.h&quot;
macro_line|#include &quot;link.h&quot;
macro_line|#include &quot;cmdblk.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;control.h&quot;
macro_line|#include &quot;cirrus.h&quot;
macro_line|#include &quot;rioioctl.h&quot;
macro_line|#include &quot;param.h&quot;
macro_line|#include &quot;list.h&quot;
macro_line|#include &quot;sam.h&quot;
multiline_comment|/*&n;** The Scam, based on email from jeremyr@bugs.specialix.co.uk....&n;**&n;** To send a command on a particular port, you put a packet with the&n;** command bit set onto the port. The command bit is in the len field,&n;** and gets ORed in with the actual byte count.&n;**&n;** When you send a packet with the command bit set, then the first&n;** data byte ( data[0] ) is interpretted as the command to execute.&n;** It also governs what data structure overlay should accompany the packet.&n;** Commands are defined in cirrus/cirrus.h&n;**&n;** If you want the command to pre-emt data already on the queue for the&n;** port, set the pre-emptive bit in conjunction with the command bit.&n;** It is not defined what will happen if you set the preemptive bit&n;** on a packet that is NOT a command.&n;**&n;** Pre-emptive commands should be queued at the head of the queue using&n;** add_start(), whereas normal commands and data are enqueued using&n;** add_end().&n;**&n;** Most commands do not use the remaining bytes in the data array. The&n;** exceptions are OPEN MOPEN and CONFIG. (NB. As with the SI CONFIG and&n;** OPEN are currently analagous). With these three commands the following&n;** 11 data bytes are all used to pass config information such as baud rate etc.&n;** The fields are also defined in cirrus.h. Some contain straightforward&n;** information such as the transmit XON character. Two contain the transmit and&n;** receive baud rates respectively. For most baud rates there is a direct&n;** mapping between the rates defined in &lt;sys/termio.h&gt; and the byte in the&n;** packet. There are additional (non UNIX-standard) rates defined in&n;** /u/dos/rio/cirrus/h/brates.h.&n;**&n;** The rest of the data fields contain approximations to the Cirrus registers&n;** that are used to program number of bits etc. Each registers bit fields is&n;** defined in cirrus.h.&n;** &n;** NB. Only use those bits that are defined as being driver specific&n;** or common to the RTA and the driver.&n;** &n;** All commands going from RTA-&gt;Host will be dealt with by the Host code - you&n;** will never see them. As with the SI there will be three fields to look out&n;** for in each phb (not yet defined - needs defining a.s.a.p).&n;** &n;** modem_status&t;- current state of handshake pins.&n;**&n;** port_status&t; - current port status - equivalent to hi_stat for SI, indicates&n;** if port is IDLE_OPEN, IDLE_CLOSED etc.&n;**&n;** break_status&t;- bit X set if break has been received.&n;** &n;** Happy hacking.&n;** &n;*/
multiline_comment|/* &n;** RIOParam is used to open or configure a port. You pass it a PortP,&n;** which will have a tty struct attached to it. You also pass a command,&n;** either OPEN or CONFIG. The port&squot;s setup is taken from the t_ fields&n;** of the tty struct inside the PortP, and the port is either opened&n;** or re-configured. You must also tell RIOParam if the device is a modem&n;** device or not (i.e. top bit of minor number set or clear - take special&n;** care when deciding on this!).&n;** RIOParam neither flushes nor waits for drain, and is NOT preemptive.&n;**&n;** RIOParam assumes it will be called at splrio(), and also assumes&n;** that CookMode is set correctly in the port structure.&n;**&n;** NB. for MPX&n;**&t;tty lock must NOT have been previously acquired.&n;*/
r_int
DECL|function|RIOParam
id|RIOParam
c_func
(paren
id|PortP
comma
id|cmd
comma
id|Modem
comma
id|SleepFlag
)paren
r_struct
id|Port
op_star
id|PortP
suffix:semicolon
r_int
id|cmd
suffix:semicolon
r_int
id|Modem
suffix:semicolon
r_int
id|SleepFlag
suffix:semicolon
(brace
r_register
r_struct
id|tty_struct
op_star
id|TtyP
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_register
r_struct
id|phb_param
op_star
id|phb_param_ptr
suffix:semicolon
id|PKT
op_star
id|PacketP
suffix:semicolon
r_int
id|res
suffix:semicolon
id|uchar
id|Cor1
op_assign
l_int|0
comma
id|Cor2
op_assign
l_int|0
comma
id|Cor4
op_assign
l_int|0
comma
id|Cor5
op_assign
l_int|0
suffix:semicolon
id|uchar
id|TxXon
op_assign
l_int|0
comma
id|TxXoff
op_assign
l_int|0
comma
id|RxXon
op_assign
l_int|0
comma
id|RxXoff
op_assign
l_int|0
suffix:semicolon
id|uchar
id|LNext
op_assign
l_int|0
comma
id|TxBaud
op_assign
l_int|0
comma
id|RxBaud
op_assign
l_int|0
suffix:semicolon
r_int
id|retries
op_assign
l_int|0xff
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|func_enter
(paren
)paren
suffix:semicolon
id|TtyP
op_assign
id|PortP-&gt;gs.tty
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;RIOParam: Port:%d cmd:%d Modem:%d SleepFlag:%d Mapped: %d, tty=%p&bslash;n&quot;
comma
id|PortP-&gt;PortNum
comma
id|cmd
comma
id|Modem
comma
id|SleepFlag
comma
id|PortP-&gt;Mapped
comma
id|TtyP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TtyP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Can&squot;t call rioparam with null tty.&bslash;n&quot;
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|RIO_FAIL
suffix:semicolon
)brace
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|OPEN
)paren
(brace
multiline_comment|/*&n;&t;&t;** If the port is set to store or lock the parameters, and it is&n;&t;&t;** paramed with OPEN, we want to restore the saved port termio, but&n;&t;&t;** only if StoredTermio has been saved, i.e. NOT 1st open after reboot.&n;&t;&t;*/
macro_line|#if 0
r_if
c_cond
(paren
id|PortP-&gt;FirstOpen
)paren
(brace
id|PortP-&gt;StoredTty.iflag
op_assign
id|TtyP-&gt;tm.c_iflag
suffix:semicolon
id|PortP-&gt;StoredTty.oflag
op_assign
id|TtyP-&gt;tm.c_oflag
suffix:semicolon
id|PortP-&gt;StoredTty.cflag
op_assign
id|TtyP-&gt;tm.c_cflag
suffix:semicolon
id|PortP-&gt;StoredTty.lflag
op_assign
id|TtyP-&gt;tm.c_lflag
suffix:semicolon
id|PortP-&gt;StoredTty.line
op_assign
id|TtyP-&gt;tm.c_line
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NCC
op_plus
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|PortP-&gt;StoredTty.cc
(braket
id|i
)braket
op_assign
id|TtyP-&gt;tm.c_cc
(braket
id|i
)braket
suffix:semicolon
id|PortP-&gt;FirstOpen
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PortP-&gt;Store
op_logical_or
id|PortP-&gt;Lock
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;OPEN: Restoring stored/locked params&bslash;n&quot;
)paren
suffix:semicolon
id|TtyP-&gt;tm.c_iflag
op_assign
id|PortP-&gt;StoredTty.iflag
suffix:semicolon
id|TtyP-&gt;tm.c_oflag
op_assign
id|PortP-&gt;StoredTty.oflag
suffix:semicolon
id|TtyP-&gt;tm.c_cflag
op_assign
id|PortP-&gt;StoredTty.cflag
suffix:semicolon
id|TtyP-&gt;tm.c_lflag
op_assign
id|PortP-&gt;StoredTty.lflag
suffix:semicolon
id|TtyP-&gt;tm.c_line
op_assign
id|PortP-&gt;StoredTty.line
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NCC
op_plus
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|TtyP-&gt;tm.c_cc
(braket
id|i
)braket
op_assign
id|PortP-&gt;StoredTty.cc
(braket
id|i
)braket
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;&t;** wait for space&n;&t;*/
r_while
c_loop
(paren
op_logical_neg
(paren
id|res
op_assign
id|can_add_transmit
c_func
(paren
op_amp
id|PacketP
comma
id|PortP
)paren
)paren
op_logical_or
(paren
id|PortP-&gt;InUse
op_ne
id|NOT_INUSE
)paren
)paren
(brace
r_if
c_cond
(paren
id|retries
op_decrement
op_le
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PortP-&gt;InUse
op_ne
id|NOT_INUSE
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Port IN_USE for pre-emptive command&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Port has no space on transmit queue&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SleepFlag
op_ne
id|OK_TO_SLEEP
)paren
(brace
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
id|RIO_FAIL
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;wait for can_add_transmit&bslash;n&quot;
)paren
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
id|retval
op_assign
id|RIODelay
c_func
(paren
id|PortP
comma
id|HUNDRED_MS
)paren
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_eq
id|RIO_FAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;wait for can_add_transmit broken by signal&bslash;n&quot;
)paren
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
id|pseterr
c_func
(paren
id|EINTR
)paren
suffix:semicolon
id|func_exit
c_func
(paren
)paren
suffix:semicolon
r_return
id|RIO_FAIL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PortP-&gt;State
op_amp
id|RIO_DELETED
)paren
(brace
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|RIO_SUCCESS
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|res
)paren
(brace
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|RIO_FAIL
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;can_add_transmit() returns %x&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Packet is 0x%x&bslash;n&quot;
comma
(paren
r_int
)paren
id|PacketP
)paren
suffix:semicolon
id|phb_param_ptr
op_assign
(paren
r_struct
id|phb_param
op_star
)paren
id|PacketP-&gt;data
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t;** COR 1&n;&t;*/
r_if
c_cond
(paren
id|TtyP-&gt;tm.c_iflag
op_amp
id|INPCK
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Parity checking on input enabled&bslash;n&quot;
)paren
suffix:semicolon
id|Cor1
op_or_assign
id|COR1_INPCK
suffix:semicolon
)brace
macro_line|#endif
r_switch
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;5 bit data&bslash;n&quot;
)paren
suffix:semicolon
id|Cor1
op_or_assign
id|COR1_5BITS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|CS6
suffix:colon
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;6 bit data&bslash;n&quot;
)paren
suffix:semicolon
id|Cor1
op_or_assign
id|COR1_6BITS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|CS7
suffix:colon
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;7 bit data&bslash;n&quot;
)paren
suffix:semicolon
id|Cor1
op_or_assign
id|COR1_7BITS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|CS8
suffix:colon
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;8 bit data&bslash;n&quot;
)paren
suffix:semicolon
id|Cor1
op_or_assign
id|COR1_8BITS
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_cflag
op_amp
id|CSTOPB
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;2 stop bits&bslash;n&quot;
)paren
suffix:semicolon
id|Cor1
op_or_assign
id|COR1_2STOP
suffix:semicolon
)brace
r_else
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;1 stop bit&bslash;n&quot;
)paren
suffix:semicolon
id|Cor1
op_or_assign
id|COR1_1STOP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_cflag
op_amp
id|PARENB
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Enable parity&bslash;n&quot;
)paren
suffix:semicolon
id|Cor1
op_or_assign
id|COR1_NORMAL
suffix:semicolon
)brace
r_else
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Disable parity&bslash;n&quot;
)paren
suffix:semicolon
id|Cor1
op_or_assign
id|COR1_NOP
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_cflag
op_amp
id|PARODD
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Odd parity&bslash;n&quot;
)paren
suffix:semicolon
id|Cor1
op_or_assign
id|COR1_ODD
suffix:semicolon
)brace
r_else
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Even parity&bslash;n&quot;
)paren
suffix:semicolon
id|Cor1
op_or_assign
id|COR1_EVEN
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** COR 2&n;&t;*/
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_iflag
op_amp
id|IXON
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Enable start/stop output control&bslash;n&quot;
)paren
suffix:semicolon
id|Cor2
op_or_assign
id|COR2_IXON
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|PortP-&gt;Config
op_amp
id|RIO_IXON
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Force enable start/stop output control&bslash;n&quot;
)paren
suffix:semicolon
id|Cor2
op_or_assign
id|COR2_IXON
suffix:semicolon
)brace
r_else
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;IXON has been disabled.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_iflag
op_amp
id|IXANY
)paren
(brace
r_if
c_cond
(paren
id|PortP-&gt;Config
op_amp
id|RIO_IXANY
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Enable any key to restart output&bslash;n&quot;
)paren
suffix:semicolon
id|Cor2
op_or_assign
id|COR2_IXANY
suffix:semicolon
)brace
r_else
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;IXANY has been disabled due to sanity reasons.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_iflag
op_amp
id|IXOFF
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Enable start/stop input control 2&bslash;n&quot;
)paren
suffix:semicolon
id|Cor2
op_or_assign
id|COR2_IXOFF
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_cflag
op_amp
id|HUPCL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Hangup on last close&bslash;n&quot;
)paren
suffix:semicolon
id|Cor2
op_or_assign
id|COR2_HUPCL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|C_CRTSCTS
(paren
id|TtyP
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Rx hardware flow control enabled&bslash;n&quot;
)paren
suffix:semicolon
id|Cor2
op_or_assign
id|COR2_CTSFLOW
suffix:semicolon
id|Cor2
op_or_assign
id|COR2_RTSFLOW
suffix:semicolon
)brace
r_else
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Rx hardware flow control disabled&bslash;n&quot;
)paren
suffix:semicolon
id|Cor2
op_and_assign
op_complement
id|COR2_CTSFLOW
suffix:semicolon
id|Cor2
op_and_assign
op_complement
id|COR2_RTSFLOW
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_cflag
op_amp
id|CLOCAL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Local line&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Possible Modem line&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** COR 4 (there is no COR 3)&n;&t;*/
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_iflag
op_amp
id|IGNBRK
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Ignore break condition&bslash;n&quot;
)paren
suffix:semicolon
id|Cor4
op_or_assign
id|COR4_IGNBRK
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|TtyP-&gt;termios-&gt;c_iflag
op_amp
id|BRKINT
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Break generates NULL condition&bslash;n&quot;
)paren
suffix:semicolon
id|Cor4
op_or_assign
id|COR4_NBRKINT
suffix:semicolon
)brace
r_else
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Interrupt on&t;break condition&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_iflag
op_amp
id|INLCR
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Map newline to carriage return on input&bslash;n&quot;
)paren
suffix:semicolon
id|Cor4
op_or_assign
id|COR4_INLCR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_iflag
op_amp
id|IGNCR
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Ignore carriage return on input&bslash;n&quot;
)paren
suffix:semicolon
id|Cor4
op_or_assign
id|COR4_IGNCR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_iflag
op_amp
id|ICRNL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Map carriage return to newline on input&bslash;n&quot;
)paren
suffix:semicolon
id|Cor4
op_or_assign
id|COR4_ICRNL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_iflag
op_amp
id|IGNPAR
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Ignore characters with parity errors&bslash;n&quot;
)paren
suffix:semicolon
id|Cor4
op_or_assign
id|COR4_IGNPAR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_iflag
op_amp
id|PARMRK
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Mark parity errors&bslash;n&quot;
)paren
suffix:semicolon
id|Cor4
op_or_assign
id|COR4_PARMRK
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Set the RAISEMOD flag to ensure that the modem lines are raised&n;&t;** on reception of a config packet.&n;&t;** The download code handles the zero baud condition.&n;&t;*/
id|Cor4
op_or_assign
id|COR4_RAISEMOD
suffix:semicolon
multiline_comment|/*&n;&t;** COR 5&n;&t;*/
id|Cor5
op_assign
id|COR5_CMOE
suffix:semicolon
multiline_comment|/*&n;&t;** Set to monitor tbusy/tstop (or not).&n;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;MonitorTstate
)paren
id|Cor5
op_or_assign
id|COR5_TSTATE_ON
suffix:semicolon
r_else
id|Cor5
op_or_assign
id|COR5_TSTATE_OFF
suffix:semicolon
multiline_comment|/*&n;&t;** Could set LNE here if you wanted LNext processing. SVR4 will use it.&n;&t;*/
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_iflag
op_amp
id|ISTRIP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Strip input characters&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|PortP-&gt;State
op_amp
id|RIO_TRIAD_MODE
)paren
)paren
(brace
id|Cor5
op_or_assign
id|COR5_ISTRIP
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|ONLCR
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Map newline to carriage-return, newline on output&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PortP-&gt;CookMode
op_eq
id|COOK_MEDIUM
)paren
id|Cor5
op_or_assign
id|COR5_ONLCR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|OCRNL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Map carriage return to newline on output&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PortP-&gt;CookMode
op_eq
id|COOK_MEDIUM
)paren
id|Cor5
op_or_assign
id|COR5_OCRNL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|TABDLY
)paren
op_eq
id|TAB3
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Tab delay 3 set&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PortP-&gt;CookMode
op_eq
id|COOK_MEDIUM
)paren
id|Cor5
op_or_assign
id|COR5_TAB3
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Flow control bytes.&n;&t;*/
id|TxXon
op_assign
id|TtyP-&gt;termios-&gt;c_cc
(braket
id|VSTART
)braket
suffix:semicolon
id|TxXoff
op_assign
id|TtyP-&gt;termios-&gt;c_cc
(braket
id|VSTOP
)braket
suffix:semicolon
id|RxXon
op_assign
id|TtyP-&gt;termios-&gt;c_cc
(braket
id|VSTART
)braket
suffix:semicolon
id|RxXoff
op_assign
id|TtyP-&gt;termios-&gt;c_cc
(braket
id|VSTOP
)braket
suffix:semicolon
multiline_comment|/*&n;&t;** LNEXT byte&n;&t;*/
id|LNext
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;** Baud rate bytes&n;&t;*/
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Mapping of rx/tx baud %x (%x)&bslash;n&quot;
comma
id|TtyP-&gt;termios-&gt;c_cflag
comma
id|CBAUD
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_cflag
op_amp
id|CBAUD
)paren
(brace
DECL|macro|e
mdefine_line|#define e(b) case B ## b : RxBaud = TxBaud = RIO_B ## b ;break
id|e
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|75
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|110
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|134
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|150
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|200
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|300
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|600
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|1200
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|1800
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|2400
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|4800
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|9600
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|19200
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|38400
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|57600
)paren
suffix:semicolon
id|e
c_func
(paren
l_int|115200
)paren
suffix:semicolon
multiline_comment|/* e(230400);e(460800); e(921600);  */
)brace
multiline_comment|/* XXX MIssing conversion table. XXX */
multiline_comment|/* &t; (TtyP-&gt;termios-&gt;c_cflag &amp; V_CBAUD); */
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;tx baud 0x%x, rx baud 0x%x&bslash;n&quot;
comma
id|TxBaud
comma
id|RxBaud
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Leftovers&n;&t;*/
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_cflag
op_amp
id|CREAD
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Enable receiver&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef RCV1EN
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_cflag
op_amp
id|RCV1EN
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;RCV1EN (?)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XMT1EN
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_cflag
op_amp
id|XMT1EN
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;XMT1EN (?)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_cflag
op_amp
id|LOBLK
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;LOBLK - JCL output blocks when not current&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_lflag
op_amp
id|ISIG
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Input character signal generating enabled&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_lflag
op_amp
id|ICANON
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Canonical input: erase and kill enabled&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_lflag
op_amp
id|XCASE
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Canonical upper/lower presentation&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_lflag
op_amp
id|ECHO
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Enable input echo&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_lflag
op_amp
id|ECHOE
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Enable echo erase&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_lflag
op_amp
id|ECHOK
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Enable echo kill&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_lflag
op_amp
id|ECHONL
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Enable echo newline&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_lflag
op_amp
id|NOFLSH
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Disable flush after interrupt or quit&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef TOSTOP
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_lflag
op_amp
id|TOSTOP
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Send SIGTTOU for background output&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef XCLUDE
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_lflag
op_amp
id|XCLUDE
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Exclusive use of this line&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_iflag
op_amp
id|IUCLC
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Map uppercase to lowercase on input&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|OPOST
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Enable output post-processing&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|OLCUC
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Map lowercase to uppercase on output&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|ONOCR
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;No carriage return output at column 0&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|ONLRET
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Newline performs carriage return function&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|OFILL
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Use fill characters for delay&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|OFDEL
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Fill character is DEL&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|NLDLY
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Newline delay set&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|CRDLY
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Carriage return delay set&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|TABDLY
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Tab delay set&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|BSDLY
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Back-space delay set&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|VTDLY
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Vertical tab delay set&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TtyP-&gt;termios-&gt;c_oflag
op_amp
id|FFDLY
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;Form-feed delay set&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t;** These things are kind of useful in a later life!&n;&t;*/
id|PortP-&gt;Cor2Copy
op_assign
id|Cor2
suffix:semicolon
r_if
c_cond
(paren
id|PortP-&gt;State
op_amp
id|RIO_DELETED
)paren
(brace
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|RIO_FAIL
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** Actually write the info into the packet to be sent&n;&t;*/
id|WBYTE
c_func
(paren
id|phb_param_ptr-&gt;Cmd
comma
id|cmd
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|phb_param_ptr-&gt;Cor1
comma
id|Cor1
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|phb_param_ptr-&gt;Cor2
comma
id|Cor2
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|phb_param_ptr-&gt;Cor4
comma
id|Cor4
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|phb_param_ptr-&gt;Cor5
comma
id|Cor5
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|phb_param_ptr-&gt;TxXon
comma
id|TxXon
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|phb_param_ptr-&gt;RxXon
comma
id|RxXon
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|phb_param_ptr-&gt;TxXoff
comma
id|TxXoff
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|phb_param_ptr-&gt;RxXoff
comma
id|RxXoff
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|phb_param_ptr-&gt;LNext
comma
id|LNext
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|phb_param_ptr-&gt;TxBaud
comma
id|TxBaud
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|phb_param_ptr-&gt;RxBaud
comma
id|RxBaud
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Set the length/command field&n;&t;*/
id|WBYTE
c_func
(paren
id|PacketP-&gt;len
comma
l_int|12
op_or
id|PKT_CMD_BIT
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** The packet is formed - now, whack it off&n;&t;** to its final destination:&n;&t;*/
id|add_transmit
c_func
(paren
id|PortP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** Count characters transmitted for port statistics reporting&n;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;statsGather
)paren
id|PortP-&gt;txchars
op_add_assign
l_int|12
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;add_transmit returned.&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;** job done.&n;&t;*/
id|func_exit
(paren
)paren
suffix:semicolon
r_return
id|RIO_SUCCESS
suffix:semicolon
)brace
multiline_comment|/*&n;** We can add another packet to a transmit queue if the packet pointer pointed&n;** to by the TxAdd pointer has PKT_IN_USE clear in its address.&n;*/
r_int
DECL|function|can_add_transmit
id|can_add_transmit
c_func
(paren
id|PktP
comma
id|PortP
)paren
id|PKT
op_star
op_star
id|PktP
suffix:semicolon
r_struct
id|Port
op_star
id|PortP
suffix:semicolon
(brace
r_register
id|PKT
op_star
id|tp
suffix:semicolon
op_star
id|PktP
op_assign
id|tp
op_assign
(paren
id|PKT
op_star
)paren
id|RIO_PTR
c_func
(paren
id|PortP-&gt;Caddr
comma
id|RWORD
c_func
(paren
op_star
id|PortP-&gt;TxAdd
)paren
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
(paren
id|uint
)paren
id|tp
op_amp
id|PKT_IN_USE
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** To add a packet to the queue, you set the PKT_IN_USE bit in the address,&n;** and then move the TxAdd pointer along one position to point to the next&n;** packet pointer. You must wrap the pointer from the end back to the start.&n;*/
r_void
DECL|function|add_transmit
id|add_transmit
c_func
(paren
id|PortP
)paren
r_struct
id|Port
op_star
id|PortP
suffix:semicolon
(brace
r_if
c_cond
(paren
id|RWORD
c_func
(paren
op_star
id|PortP-&gt;TxAdd
)paren
op_amp
id|PKT_IN_USE
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_PARAM
comma
l_string|&quot;add_transmit: Packet has been stolen!&quot;
)paren
suffix:semicolon
)brace
id|WWORD
c_func
(paren
op_star
(paren
id|ushort
op_star
)paren
id|PortP-&gt;TxAdd
comma
id|RWORD
c_func
(paren
op_star
id|PortP-&gt;TxAdd
)paren
op_or
id|PKT_IN_USE
)paren
suffix:semicolon
id|PortP-&gt;TxAdd
op_assign
(paren
id|PortP-&gt;TxAdd
op_eq
id|PortP-&gt;TxEnd
)paren
ques
c_cond
id|PortP-&gt;TxStart
suffix:colon
id|PortP-&gt;TxAdd
op_plus
l_int|1
suffix:semicolon
id|WWORD
c_func
(paren
id|PortP-&gt;PhbP-&gt;tx_add
comma
id|RIO_OFF
c_func
(paren
id|PortP-&gt;Caddr
comma
id|PortP-&gt;TxAdd
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************&n; * Put a packet onto the end of the&n; * free list&n; ****************************************/
r_void
DECL|function|put_free_end
id|put_free_end
c_func
(paren
id|HostP
comma
id|PktP
)paren
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
id|PKT
op_star
id|PktP
suffix:semicolon
(brace
id|FREE_LIST
op_star
id|tmp_pointer
suffix:semicolon
id|ushort
id|old_end
comma
id|new_end
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|HostP-&gt;HostLock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/*************************************************&n;&t;* Put a packet back onto the back of the free list&n;&t;*&n;&t;************************************************/
id|rio_dprintk
(paren
id|RIO_DEBUG_PFE
comma
l_string|&quot;put_free_end(PktP=%x)&bslash;n&quot;
comma
(paren
r_int
)paren
id|PktP
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|old_end
op_assign
id|RWORD
c_func
(paren
id|HostP-&gt;ParmMapP-&gt;free_list_end
)paren
)paren
op_ne
id|TPNULL
)paren
(brace
id|new_end
op_assign
id|RIO_OFF
c_func
(paren
id|HostP-&gt;Caddr
comma
id|PktP
)paren
suffix:semicolon
id|tmp_pointer
op_assign
(paren
id|FREE_LIST
op_star
)paren
id|RIO_PTR
c_func
(paren
id|HostP-&gt;Caddr
comma
id|old_end
)paren
suffix:semicolon
id|WWORD
c_func
(paren
id|tmp_pointer-&gt;next
comma
id|new_end
)paren
suffix:semicolon
id|WWORD
c_func
(paren
(paren
(paren
id|FREE_LIST
op_star
)paren
id|PktP
)paren
op_member_access_from_pointer
id|prev
comma
id|old_end
)paren
suffix:semicolon
id|WWORD
c_func
(paren
(paren
(paren
id|FREE_LIST
op_star
)paren
id|PktP
)paren
op_member_access_from_pointer
id|next
comma
id|TPNULL
)paren
suffix:semicolon
id|WWORD
c_func
(paren
id|HostP-&gt;ParmMapP-&gt;free_list_end
comma
id|new_end
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* First packet on the free list this should never happen! */
id|rio_dprintk
(paren
id|RIO_DEBUG_PFE
comma
l_string|&quot;put_free_end(): This should never happen&bslash;n&quot;
)paren
suffix:semicolon
id|WWORD
c_func
(paren
id|HostP-&gt;ParmMapP-&gt;free_list_end
comma
id|RIO_OFF
c_func
(paren
id|HostP-&gt;Caddr
comma
id|PktP
)paren
)paren
suffix:semicolon
id|tmp_pointer
op_assign
(paren
id|FREE_LIST
op_star
)paren
id|PktP
suffix:semicolon
id|WWORD
c_func
(paren
id|tmp_pointer-&gt;prev
comma
id|TPNULL
)paren
suffix:semicolon
id|WWORD
c_func
(paren
id|tmp_pointer-&gt;next
comma
id|TPNULL
)paren
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_CMD
comma
l_string|&quot;Before unlock: %p&bslash;n&quot;
comma
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|HostP-&gt;HostLock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;** can_remove_receive(PktP,P) returns non-zero if PKT_IN_USE is set&n;** for the next packet on the queue. It will also set PktP to point to the&n;** relevent packet, [having cleared the PKT_IN_USE bit]. If PKT_IN_USE is clear,&n;** then can_remove_receive() returns 0.&n;*/
r_int
DECL|function|can_remove_receive
id|can_remove_receive
c_func
(paren
id|PktP
comma
id|PortP
)paren
id|PKT
op_star
op_star
id|PktP
suffix:semicolon
r_struct
id|Port
op_star
id|PortP
suffix:semicolon
(brace
r_if
c_cond
(paren
id|RWORD
c_func
(paren
op_star
id|PortP-&gt;RxRemove
)paren
op_amp
id|PKT_IN_USE
)paren
(brace
op_star
id|PktP
op_assign
(paren
id|PKT
op_star
)paren
id|RIO_PTR
c_func
(paren
id|PortP-&gt;Caddr
comma
id|RWORD
c_func
(paren
op_star
id|PortP-&gt;RxRemove
)paren
op_amp
op_complement
id|PKT_IN_USE
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;** To remove a packet from the receive queue you clear its PKT_IN_USE bit,&n;** and then bump the pointers. Once the pointers get to the end, they must&n;** be wrapped back to the start.&n;*/
r_void
DECL|function|remove_receive
id|remove_receive
c_func
(paren
id|PortP
)paren
r_struct
id|Port
op_star
id|PortP
suffix:semicolon
(brace
id|WWORD
c_func
(paren
op_star
id|PortP-&gt;RxRemove
comma
id|RWORD
c_func
(paren
op_star
id|PortP-&gt;RxRemove
)paren
op_amp
op_complement
id|PKT_IN_USE
)paren
suffix:semicolon
id|PortP-&gt;RxRemove
op_assign
(paren
id|PortP-&gt;RxRemove
op_eq
id|PortP-&gt;RxEnd
)paren
ques
c_cond
id|PortP-&gt;RxStart
suffix:colon
id|PortP-&gt;RxRemove
op_plus
l_int|1
suffix:semicolon
id|WWORD
c_func
(paren
id|PortP-&gt;PhbP-&gt;rx_remove
comma
id|RIO_OFF
c_func
(paren
id|PortP-&gt;Caddr
comma
id|PortP-&gt;RxRemove
)paren
)paren
suffix:semicolon
)brace
eof
