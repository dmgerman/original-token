multiline_comment|/*&n;** -----------------------------------------------------------------------------&n;**&n;**  Perle Specialix driver for Linux&n;**  Ported from existing RIO Driver for SCO sources.&n; *&n; *  (C) 1990 - 2000 Specialix International Ltd., Byfleet, Surrey, UK.&n; *&n; *      This program is free software; you can redistribute it and/or modify&n; *      it under the terms of the GNU General Public License as published by&n; *      the Free Software Foundation; either version 2 of the License, or&n; *      (at your option) any later version.&n; *&n; *      This program is distributed in the hope that it will be useful,&n; *      but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *      GNU General Public License for more details.&n; *&n; *      You should have received a copy of the GNU General Public License&n; *      along with this program; if not, write to the Free Software&n; *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;**&n;**&t;Module&t;&t;: riointr.c&n;**&t;SID&t;&t;: 1.2&n;**&t;Last Modified&t;: 11/6/98 10:33:44&n;**&t;Retrieved&t;: 11/6/98 10:33:49&n;**&n;**  ident @(#)riointr.c&t;1.2&n;**&n;** -----------------------------------------------------------------------------&n;*/
macro_line|#ifdef SCCS_LABELS
DECL|variable|_riointr_c_sccs_
r_static
r_char
op_star
id|_riointr_c_sccs_
op_assign
l_string|&quot;@(#)riointr.c&t;1.2&quot;
suffix:semicolon
macro_line|#endif
DECL|macro|__NO_VERSION__
mdefine_line|#define __NO_VERSION__
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/string.h&gt;
macro_line|#include &lt;asm/semaphore.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/termios.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/compatmac.h&gt;
macro_line|#include &lt;linux/generic_serial.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &quot;linux_compat.h&quot;
macro_line|#include &quot;rio_linux.h&quot;
macro_line|#include &quot;typdef.h&quot;
macro_line|#include &quot;pkt.h&quot;
macro_line|#include &quot;daemon.h&quot;
macro_line|#include &quot;rio.h&quot;
macro_line|#include &quot;riospace.h&quot;
macro_line|#include &quot;top.h&quot;
macro_line|#include &quot;cmdpkt.h&quot;
macro_line|#include &quot;map.h&quot;
macro_line|#include &quot;riotypes.h&quot;
macro_line|#include &quot;rup.h&quot;
macro_line|#include &quot;port.h&quot;
macro_line|#include &quot;riodrvr.h&quot;
macro_line|#include &quot;rioinfo.h&quot;
macro_line|#include &quot;func.h&quot;
macro_line|#include &quot;errors.h&quot;
macro_line|#include &quot;pci.h&quot;
macro_line|#include &quot;parmmap.h&quot;
macro_line|#include &quot;unixrup.h&quot;
macro_line|#include &quot;board.h&quot;
macro_line|#include &quot;host.h&quot;
macro_line|#include &quot;error.h&quot;
macro_line|#include &quot;phb.h&quot;
macro_line|#include &quot;link.h&quot;
macro_line|#include &quot;cmdblk.h&quot;
macro_line|#include &quot;route.h&quot;
macro_line|#include &quot;control.h&quot;
macro_line|#include &quot;cirrus.h&quot;
macro_line|#include &quot;rioioctl.h&quot;
multiline_comment|/*&n;** riopoll is called every clock tick. Once the /dev/rio device has been&n;** opened, and polldistributed( ) has been called, this routine is called&n;** every clock tick *by every cpu*. The &squot;interesting&squot; piece of code that&n;** manipulates &squot;RIONumCpus&squot; and &squot;RIOCpuCountdown&squot; is used to fair-share&n;** the work between the CPUs. If there are &squot;N&squot; cpus, then each poll time&n;** we increment a counter, modulo &squot;N-1&squot;. When this counter is 0, we call&n;** the interrupt handler. This has the effect that polls are serviced&n;** by processor &squot;N&squot;, &squot;N-1&squot;, &squot;N-2&squot;, ... &squot;0&squot;, round and round. Neat.&n;*/
r_void
DECL|function|riopoll
id|riopoll
c_func
(paren
id|p
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
(brace
r_int
id|host
suffix:semicolon
multiline_comment|/*&n;&t;** Here&squot;s the deal. We try to fair share as much as possible amongst&n;&t;** all the processors that are available. Since each processor &n;&t;** should generate HZ ticks per second and since we only need HZ ticks&n;&t;** in total for proper operation we simply attempt to cycle round each&n;&t;** processor in turn, using RIOCpuCountdown to decide whether to call&n;&t;** the interrupt routine. ( In fact the count zeroes when it reaches&n;&t;** one less than the total number of processors - so e.g. on a two&n;&t;** processor system RIOService will get called 2*HZ times per second. )&n;&t;** this_cpu (cur_cpu()) tells us the number of the current processor&n;&t;** as follows:&n;&t;**&n;&t;**&t;&t;0 - default CPU&n;&t;**&t;&t;1 - first extra CPU&n;&t;**&t;&t;2 - second extra CPU&n;&t;**&t;&t;etc.&n;&t;*/
multiline_comment|/*&n;&t;** okay, we&squot;ve got a cpu that hasn&squot;t had a go recently &n;&t;** - lets check to see what needs doing.&n;&t;*/
r_for
c_loop
(paren
id|host
op_assign
l_int|0
suffix:semicolon
id|host
OL
id|p-&gt;RIONumHosts
suffix:semicolon
id|host
op_increment
)paren
(brace
r_struct
id|Host
op_star
id|HostP
op_assign
op_amp
id|p-&gt;RIOHosts
(braket
id|host
)braket
suffix:semicolon
id|rio_spin_lock
c_func
(paren
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|HostP-&gt;Flags
op_amp
id|RUN_STATE
)paren
op_ne
id|RC_RUNNING
)paren
op_logical_or
id|HostP-&gt;InIntr
)paren
(brace
id|rio_spin_unlock
(paren
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|RWORD
c_func
(paren
id|HostP-&gt;ParmMapP-&gt;rup_intr
)paren
op_logical_or
id|RWORD
c_func
(paren
id|HostP-&gt;ParmMapP-&gt;rx_intr
)paren
op_logical_or
id|RWORD
c_func
(paren
id|HostP-&gt;ParmMapP-&gt;tx_intr
)paren
)paren
(brace
id|HostP-&gt;InIntr
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef FUTURE_RELEASE
r_if
c_cond
(paren
id|HostP-&gt;Type
op_eq
id|RIO_EISA
)paren
(brace
id|INBZ
c_func
(paren
id|HostP-&gt;Slot
comma
id|EISA_INTERRUPT_RESET
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif
id|WBYTE
c_func
(paren
id|HostP-&gt;ResetInt
comma
l_int|0xff
)paren
suffix:semicolon
id|rio_spin_lock
c_func
(paren
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
id|p-&gt;_RIO_Polled
op_increment
suffix:semicolon
id|RIOServiceHost
c_func
(paren
id|p
comma
id|HostP
comma
l_char|&squot;p&squot;
)paren
suffix:semicolon
id|rio_spin_lock
c_func
(paren
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
id|HostP-&gt;InIntr
op_assign
l_int|0
suffix:semicolon
id|rio_spin_unlock
(paren
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
)brace
)brace
id|rio_spin_unlock
(paren
op_amp
id|p-&gt;RIOIntrSem
)paren
suffix:semicolon
)brace
DECL|function|firstchars
r_char
op_star
id|firstchars
(paren
r_char
op_star
id|p
comma
r_int
id|nch
)paren
(brace
r_static
r_char
id|buf
(braket
l_int|2
)braket
(braket
l_int|128
)braket
suffix:semicolon
r_static
r_int
id|t
op_assign
l_int|0
suffix:semicolon
id|t
op_assign
op_logical_neg
id|t
suffix:semicolon
id|memcpy
(paren
id|buf
(braket
id|t
)braket
comma
id|p
comma
id|nch
)paren
suffix:semicolon
id|buf
(braket
id|t
)braket
(braket
id|nch
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|buf
(braket
id|t
)braket
suffix:semicolon
)brace
DECL|macro|INCR
mdefine_line|#define&t;INCR( P, I )&t;((P) = (((P)+(I)) &amp; p-&gt;RIOBufferMask))
multiline_comment|/* Enable and start the transmission of packets */
r_void
DECL|function|RIOTxEnable
id|RIOTxEnable
c_func
(paren
id|en
)paren
r_char
op_star
id|en
suffix:semicolon
(brace
r_struct
id|Port
op_star
id|PortP
suffix:semicolon
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
id|c
suffix:semicolon
r_struct
id|PKT
op_star
id|PacketP
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|PortP
op_assign
(paren
r_struct
id|Port
op_star
)paren
id|en
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|rio_info
op_star
)paren
id|PortP-&gt;p
suffix:semicolon
id|tty
op_assign
id|PortP-&gt;gs.tty
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;tx port %d: %d chars queued.&bslash;n&quot;
comma
id|PortP-&gt;PortNum
comma
id|PortP-&gt;gs.xmit_cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PortP-&gt;gs.xmit_cnt
)paren
r_return
suffix:semicolon
multiline_comment|/* This routine is an order of magnitude simpler than the specialix&n;     version. One of the disadvantages is that this version will send&n;     an incomplete packet (usually 64 bytes instead of 72) once for&n;     every 4k worth of data. Let&squot;s just say that this won&squot;t influence&n;     performance significantly..... */
id|rio_spin_lock_irqsave
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|can_add_transmit
c_func
(paren
op_amp
id|PacketP
comma
id|PortP
)paren
)paren
(brace
id|c
op_assign
id|PortP-&gt;gs.xmit_cnt
suffix:semicolon
r_if
c_cond
(paren
id|c
OG
id|PKT_MAX_DATA_LEN
)paren
id|c
op_assign
id|PKT_MAX_DATA_LEN
suffix:semicolon
multiline_comment|/* Don&squot;t copy past the end of the source buffer */
r_if
c_cond
(paren
id|c
OG
id|SERIAL_XMIT_SIZE
op_minus
id|PortP-&gt;gs.xmit_tail
)paren
id|c
op_assign
id|SERIAL_XMIT_SIZE
op_minus
id|PortP-&gt;gs.xmit_tail
suffix:semicolon
(brace
r_int
id|t
suffix:semicolon
id|t
op_assign
(paren
id|c
OG
l_int|10
)paren
ques
c_cond
l_int|10
suffix:colon
id|c
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;rio: tx port %d: copying %d chars: %s - %s&bslash;n&quot;
comma
id|PortP-&gt;PortNum
comma
id|c
comma
id|firstchars
(paren
id|PortP-&gt;gs.xmit_buf
op_plus
id|PortP-&gt;gs.xmit_tail
comma
id|t
)paren
comma
id|firstchars
(paren
id|PortP-&gt;gs.xmit_buf
op_plus
id|PortP-&gt;gs.xmit_tail
op_plus
id|c
op_minus
id|t
comma
id|t
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* If for one reason or another, we can&squot;t copy more data, &n;       we&squot;re done! */
r_if
c_cond
(paren
id|c
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|rio_memcpy_toio
(paren
id|PortP-&gt;HostP-&gt;Caddr
comma
(paren
id|caddr_t
)paren
id|PacketP-&gt;data
comma
id|PortP-&gt;gs.xmit_buf
op_plus
id|PortP-&gt;gs.xmit_tail
comma
id|c
)paren
suffix:semicolon
multiline_comment|/*    udelay (1); */
id|writeb
(paren
id|c
comma
op_amp
(paren
id|PacketP-&gt;len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|PortP-&gt;State
op_amp
id|RIO_DELETED
)paren
)paren
(brace
id|add_transmit
(paren
id|PortP
)paren
suffix:semicolon
multiline_comment|/*&n;      ** Count chars tx&squot;d for port statistics reporting&n;      */
r_if
c_cond
(paren
id|PortP-&gt;statsGather
)paren
id|PortP-&gt;txchars
op_add_assign
id|c
suffix:semicolon
)brace
id|PortP-&gt;gs.xmit_tail
op_assign
(paren
id|PortP-&gt;gs.xmit_tail
op_plus
id|c
)paren
op_amp
(paren
id|SERIAL_XMIT_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|PortP-&gt;gs.xmit_cnt
op_sub_assign
id|c
suffix:semicolon
)brace
id|rio_spin_unlock_irqrestore
c_func
(paren
op_amp
id|PortP-&gt;portSem
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PortP-&gt;gs.xmit_cnt
op_le
(paren
id|PortP-&gt;gs.wakeup_chars
op_plus
l_int|2
op_star
id|PKT_MAX_DATA_LEN
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;Waking up.... ldisc:%d (%d/%d)....&quot;
comma
(paren
r_int
)paren
(paren
id|PortP-&gt;gs.tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
comma
id|PortP-&gt;gs.wakeup_chars
comma
id|PortP-&gt;gs.xmit_cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|PortP-&gt;gs.tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|PortP-&gt;gs.tty-&gt;ldisc.write_wakeup
)paren
(paren
id|PortP-&gt;gs.tty-&gt;ldisc.write_wakeup
)paren
(paren
id|PortP-&gt;gs.tty
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;(%d/%d)&bslash;n&quot;
comma
id|PortP-&gt;gs.wakeup_chars
comma
id|PortP-&gt;gs.xmit_cnt
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|PortP-&gt;gs.tty-&gt;write_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;** When a real-life interrupt comes in here, we try to find out&n;** which host card it belongs to, and then service only that host&n;** Notice the cunning way that, once we&squot;ve found a candidate, we&n;** continue just in case we are sharing interrupts.&n;*/
r_void
DECL|function|riointr
id|riointr
c_func
(paren
id|p
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
(brace
r_int
id|host
suffix:semicolon
r_for
c_loop
(paren
id|host
op_assign
l_int|0
suffix:semicolon
id|host
OL
id|p-&gt;RIONumHosts
suffix:semicolon
id|host
op_increment
)paren
(brace
r_struct
id|Host
op_star
id|HostP
op_assign
op_amp
id|p-&gt;RIOHosts
(braket
id|host
)braket
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;riointr() doing host %d type %d&bslash;n&quot;
comma
id|host
comma
id|HostP-&gt;Type
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|HostP-&gt;Type
)paren
(brace
r_case
id|RIO_AT
suffix:colon
r_case
id|RIO_MCA
suffix:colon
r_case
id|RIO_PCI
suffix:colon
id|rio_spin_lock
c_func
(paren
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|HostP-&gt;ResetInt
comma
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HostP-&gt;InIntr
)paren
(brace
id|HostP-&gt;InIntr
op_assign
l_int|1
suffix:semicolon
id|rio_spin_unlock
(paren
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
id|p-&gt;_RIO_Interrupted
op_increment
suffix:semicolon
id|RIOServiceHost
c_func
(paren
id|p
comma
id|HostP
comma
l_char|&squot;i&squot;
)paren
suffix:semicolon
id|rio_spin_lock
c_func
(paren
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
id|HostP-&gt;InIntr
op_assign
l_int|0
suffix:semicolon
)brace
id|rio_spin_unlock
c_func
(paren
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef FUTURE_RELEASE
r_case
id|RIO_EISA
suffix:colon
r_if
c_cond
(paren
id|ivec
op_eq
id|HostP-&gt;Ivec
)paren
(brace
id|OldSpl
op_assign
id|LOCKB
c_func
(paren
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
id|INBZ
c_func
(paren
id|HostP-&gt;Slot
comma
id|EISA_INTERRUPT_RESET
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HostP-&gt;InIntr
)paren
(brace
id|HostP-&gt;InIntr
op_assign
l_int|1
suffix:semicolon
id|UNLOCKB
c_func
(paren
op_amp
id|HostP-&gt;HostLock
comma
id|OldSpl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|this_cpu
OL
id|RIO_CPU_LIMIT
)paren
(brace
r_int
id|intrSpl
op_assign
id|LOCKB
c_func
(paren
op_amp
id|RIOIntrLock
)paren
suffix:semicolon
id|UNLOCKB
c_func
(paren
op_amp
id|RIOIntrLock
comma
id|intrSpl
)paren
suffix:semicolon
)brace
id|p-&gt;_RIO_Interrupted
op_increment
suffix:semicolon
id|RIOServiceHost
c_func
(paren
id|HostP
comma
l_char|&squot;i&squot;
)paren
suffix:semicolon
id|OldSpl
op_assign
id|LOCKB
c_func
(paren
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
id|HostP-&gt;InIntr
op_assign
l_int|0
suffix:semicolon
)brace
id|UNLOCKB
c_func
(paren
op_amp
id|HostP-&gt;HostLock
comma
id|OldSpl
)paren
suffix:semicolon
id|done
op_increment
suffix:semicolon
)brace
r_break
suffix:semicolon
macro_line|#endif
)brace
id|HostP-&gt;IntSrvDone
op_increment
suffix:semicolon
)brace
macro_line|#ifdef FUTURE_RELEASE
r_if
c_cond
(paren
op_logical_neg
id|done
)paren
(brace
id|cmn_err
c_func
(paren
id|CE_WARN
comma
l_string|&quot;RIO: Interrupt received with vector 0x%x&bslash;n&quot;
comma
id|ivec
)paren
suffix:semicolon
id|cmn_err
c_func
(paren
id|CE_CONT
comma
l_string|&quot;&t; Valid vectors are:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|host
op_assign
l_int|0
suffix:semicolon
id|host
OL
id|RIONumHosts
suffix:semicolon
id|host
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|RIOHosts
(braket
id|host
)braket
dot
id|Type
)paren
(brace
r_case
id|RIO_AT
suffix:colon
r_case
id|RIO_MCA
suffix:colon
r_case
id|RIO_EISA
suffix:colon
id|cmn_err
c_func
(paren
id|CE_CONT
comma
l_string|&quot;0x%x &quot;
comma
id|RIOHosts
(braket
id|host
)braket
dot
id|Ivec
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RIO_PCI
suffix:colon
id|cmn_err
c_func
(paren
id|CE_CONT
comma
l_string|&quot;0x%x &quot;
comma
id|get_intr_arg
c_func
(paren
id|RIOHosts
(braket
id|host
)braket
dot
id|PciDevInfo.busnum
comma
id|IDIST_PCI_IRQ
c_func
(paren
id|RIOHosts
(braket
id|host
)braket
dot
id|PciDevInfo.slotnum
comma
id|RIOHosts
(braket
id|host
)braket
dot
id|PciDevInfo.funcnum
)paren
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|cmn_err
c_func
(paren
id|CE_CONT
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;** RIO Host Service routine. Does all the work traditionally associated with an&n;** interrupt.&n;*/
DECL|variable|RupIntr
r_static
r_int
id|RupIntr
suffix:semicolon
DECL|variable|RxIntr
r_static
r_int
id|RxIntr
suffix:semicolon
DECL|variable|TxIntr
r_static
r_int
id|TxIntr
suffix:semicolon
r_void
DECL|function|RIOServiceHost
id|RIOServiceHost
c_func
(paren
id|p
comma
id|HostP
comma
id|From
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
r_struct
id|Host
op_star
id|HostP
suffix:semicolon
r_int
id|From
suffix:semicolon
(brace
id|rio_spin_lock
(paren
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|HostP-&gt;Flags
op_amp
id|RUN_STATE
)paren
op_ne
id|RC_RUNNING
)paren
(brace
r_static
r_int
id|t
op_assign
l_int|0
suffix:semicolon
id|rio_spin_unlock
(paren
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|t
op_increment
op_mod
l_int|200
)paren
op_eq
l_int|0
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;Interrupt but host not running. flags=%x.&bslash;n&quot;
comma
(paren
r_int
)paren
id|HostP-&gt;Flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|rio_spin_unlock
(paren
op_amp
id|HostP-&gt;HostLock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RWORD
c_func
(paren
id|HostP-&gt;ParmMapP-&gt;rup_intr
)paren
)paren
(brace
id|WWORD
c_func
(paren
id|HostP-&gt;ParmMapP-&gt;rup_intr
comma
l_int|0
)paren
suffix:semicolon
id|p-&gt;RIORupCount
op_increment
suffix:semicolon
id|RupIntr
op_increment
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;rio: RUP interrupt on host %d&bslash;n&quot;
comma
id|HostP
op_minus
id|p-&gt;RIOHosts
)paren
suffix:semicolon
id|RIOPollHostCommands
c_func
(paren
id|p
comma
id|HostP
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|RWORD
c_func
(paren
id|HostP-&gt;ParmMapP-&gt;rx_intr
)paren
)paren
(brace
r_int
id|port
suffix:semicolon
id|WWORD
c_func
(paren
id|HostP-&gt;ParmMapP-&gt;rx_intr
comma
l_int|0
)paren
suffix:semicolon
id|p-&gt;RIORxCount
op_increment
suffix:semicolon
id|RxIntr
op_increment
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;rio: RX interrupt on host %d&bslash;n&quot;
comma
id|HostP
op_minus
id|p-&gt;RIOHosts
)paren
suffix:semicolon
multiline_comment|/*&n;    ** Loop through every port. If the port is mapped into&n;    ** the system ( i.e. has /dev/ttyXXXX associated ) then it is&n;    ** worth checking. If the port isn&squot;t open, grab any packets&n;    ** hanging on its receive queue and stuff them on the free&n;    ** list; check for commands on the way.&n;    */
r_for
c_loop
(paren
id|port
op_assign
id|p-&gt;RIOFirstPortsBooted
suffix:semicolon
id|port
OL
id|p-&gt;RIOLastPortsBooted
op_plus
id|PORTS_PER_RTA
suffix:semicolon
id|port
op_increment
)paren
(brace
r_struct
id|Port
op_star
id|PortP
op_assign
id|p-&gt;RIOPortp
(braket
id|port
)braket
suffix:semicolon
r_struct
id|tty_struct
op_star
id|ttyP
suffix:semicolon
r_struct
id|PKT
op_star
id|PacketP
suffix:semicolon
multiline_comment|/*&n;      ** not mapped in - most of the RIOPortp[] information&n;      ** has not been set up!&n;      ** Optimise: ports come in bundles of eight.&n;      */
r_if
c_cond
(paren
op_logical_neg
id|PortP-&gt;Mapped
)paren
(brace
id|port
op_add_assign
l_int|7
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* with the next port */
)brace
multiline_comment|/*&n;      ** If the host board isn&squot;t THIS host board, check the next one.&n;      ** optimise: ports come in bundles of eight.&n;      */
r_if
c_cond
(paren
id|PortP-&gt;HostP
op_ne
id|HostP
)paren
(brace
id|port
op_add_assign
l_int|7
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;      ** Let us see - is the port open? If not, then don&squot;t service it.&n;      */
r_if
c_cond
(paren
op_logical_neg
(paren
id|PortP-&gt;PortState
op_amp
id|PORT_ISOPEN
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;      ** find corresponding tty structure. The process of mapping&n;      ** the ports puts these here.&n;      */
id|ttyP
op_assign
id|PortP-&gt;gs.tty
suffix:semicolon
multiline_comment|/*&n;      ** Lock the port before we begin working on it.&n;      */
id|rio_spin_lock
c_func
(paren
op_amp
id|PortP-&gt;portSem
)paren
suffix:semicolon
multiline_comment|/*&n;      ** Process received data if there is any.&n;      */
r_if
c_cond
(paren
id|can_remove_receive
c_func
(paren
op_amp
id|PacketP
comma
id|PortP
)paren
)paren
id|RIOReceive
c_func
(paren
id|p
comma
id|PortP
)paren
suffix:semicolon
multiline_comment|/*&n;      ** If there is no data left to be read from the port, and&n;      ** it&squot;s handshake bit is set, then we must clear the handshake,&n;      ** so that that downstream RTA is re-enabled.&n;      */
r_if
c_cond
(paren
op_logical_neg
id|can_remove_receive
c_func
(paren
op_amp
id|PacketP
comma
id|PortP
)paren
op_logical_and
(paren
id|RWORD
c_func
(paren
id|PortP-&gt;PhbP-&gt;handshake
)paren
op_eq
id|PHB_HANDSHAKE_SET
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;** MAGIC! ( Basically, handshake the RX buffer, so that&n;&t;&t;&t;&t;** the RTAs upstream can be re-enabled. )&n;&t;&t;&t;&t;*/
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;Set RX handshake bit&bslash;n&quot;
)paren
suffix:semicolon
id|WWORD
c_func
(paren
id|PortP-&gt;PhbP-&gt;handshake
comma
id|PHB_HANDSHAKE_SET
op_or
id|PHB_HANDSHAKE_RESET
)paren
suffix:semicolon
)brace
id|rio_spin_unlock
c_func
(paren
op_amp
id|PortP-&gt;portSem
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|RWORD
c_func
(paren
id|HostP-&gt;ParmMapP-&gt;tx_intr
)paren
)paren
(brace
r_int
id|port
suffix:semicolon
id|WWORD
c_func
(paren
id|HostP-&gt;ParmMapP-&gt;tx_intr
comma
l_int|0
)paren
suffix:semicolon
id|p-&gt;RIOTxCount
op_increment
suffix:semicolon
id|TxIntr
op_increment
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;rio: TX interrupt on host %d&bslash;n&quot;
comma
id|HostP
op_minus
id|p-&gt;RIOHosts
)paren
suffix:semicolon
multiline_comment|/*&n;    ** Loop through every port.&n;    ** If the port is mapped into the system ( i.e. has /dev/ttyXXXX&n;    ** associated ) then it is worth checking.&n;    */
r_for
c_loop
(paren
id|port
op_assign
id|p-&gt;RIOFirstPortsBooted
suffix:semicolon
id|port
OL
id|p-&gt;RIOLastPortsBooted
op_plus
id|PORTS_PER_RTA
suffix:semicolon
id|port
op_increment
)paren
(brace
r_struct
id|Port
op_star
id|PortP
op_assign
id|p-&gt;RIOPortp
(braket
id|port
)braket
suffix:semicolon
r_struct
id|tty_struct
op_star
id|ttyP
suffix:semicolon
r_struct
id|PKT
op_star
id|PacketP
suffix:semicolon
multiline_comment|/*&n;      ** not mapped in - most of the RIOPortp[] information&n;      ** has not been set up!&n;      */
r_if
c_cond
(paren
op_logical_neg
id|PortP-&gt;Mapped
)paren
(brace
id|port
op_add_assign
l_int|7
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* with the next port */
)brace
multiline_comment|/*&n;      ** If the host board isn&squot;t running, then its data structures&n;      ** are no use to us - continue quietly.&n;      */
r_if
c_cond
(paren
id|PortP-&gt;HostP
op_ne
id|HostP
)paren
(brace
id|port
op_add_assign
l_int|7
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* with the next port */
)brace
multiline_comment|/*&n;      ** Let us see - is the port open? If not, then don&squot;t service it.&n;      */
r_if
c_cond
(paren
op_logical_neg
(paren
id|PortP-&gt;PortState
op_amp
id|PORT_ISOPEN
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;rio: Looking into port %d.&bslash;n&quot;
comma
id|port
)paren
suffix:semicolon
multiline_comment|/*&n;      ** Lock the port before we begin working on it.&n;      */
id|rio_spin_lock
c_func
(paren
op_amp
id|PortP-&gt;portSem
)paren
suffix:semicolon
multiline_comment|/*&n;      ** If we can&squot;t add anything to the transmit queue, then&n;      ** we need do none of this processing.&n;      */
r_if
c_cond
(paren
op_logical_neg
id|can_add_transmit
c_func
(paren
op_amp
id|PacketP
comma
id|PortP
)paren
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;Can&squot;t add to port, so skipping.&bslash;n&quot;
)paren
suffix:semicolon
id|rio_spin_unlock
c_func
(paren
op_amp
id|PortP-&gt;portSem
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;      ** find corresponding tty structure. The process of mapping&n;      ** the ports puts these here.&n;      */
id|ttyP
op_assign
id|PortP-&gt;gs.tty
suffix:semicolon
multiline_comment|/* If ttyP is NULL, the port is getting closed. Forget about it. */
r_if
c_cond
(paren
op_logical_neg
id|ttyP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;no tty, so skipping.&bslash;n&quot;
)paren
suffix:semicolon
id|rio_spin_unlock
c_func
(paren
op_amp
id|PortP-&gt;portSem
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;      ** If there is more room available we start up the transmit&n;      ** data process again. This can be direct I/O, if the cookmode&n;      ** is set to COOK_RAW or COOK_MEDIUM, or will be a call to the&n;      ** riotproc( T_OUTPUT ) if we are in COOK_WELL mode, to fetch&n;      ** characters via the line discipline. We must always call&n;      ** the line discipline,&n;      ** so that user input characters can be echoed correctly.&n;      **&n;      ** ++++ Update +++++&n;      ** With the advent of double buffering, we now see if&n;      ** TxBufferOut-In is non-zero. If so, then we copy a packet&n;      ** to the output place, and set it going. If this empties&n;      ** the buffer, then we must issue a wakeup( ) on OUT.&n;      ** If it frees space in the buffer then we must issue&n;      ** a wakeup( ) on IN.&n;      **&n;      ** ++++ Extra! Extra! If PortP-&gt;WflushFlag is set, then we&n;      ** have to send a WFLUSH command down the PHB, to mark the&n;      ** end point of a WFLUSH. We also need to clear out any&n;      ** data from the double buffer! ( note that WflushFlag is a&n;      ** *count* of the number of WFLUSH commands outstanding! )&n;      **&n;      ** ++++ And there&squot;s more!&n;      ** If an RTA is powered off, then on again, and rebooted,&n;      ** whilst it has ports open, then we need to re-open the ports.&n;      ** ( reasonable enough ). We can&squot;t do this when we spot the&n;      ** re-boot, in interrupt time, because the queue is probably&n;      ** full. So, when we come in here, we need to test if any&n;      ** ports are in this condition, and re-open the port before&n;      ** we try to send any more data to it. Now, the re-booted&n;      ** RTA will be discarding packets from the PHB until it&n;      ** receives this open packet, but don&squot;t worry tooo much&n;      ** about that. The one thing that is interesting is the&n;      ** combination of this effect and the WFLUSH effect!&n;      */
multiline_comment|/* For now don&squot;t handle RTA reboots. -- REW. &n;&t; Reenabled. Otherwise RTA reboots didn&squot;t work. Duh. -- REW */
r_if
c_cond
(paren
id|PortP-&gt;MagicFlags
)paren
(brace
macro_line|#if 1
r_if
c_cond
(paren
id|PortP-&gt;MagicFlags
op_amp
id|MAGIC_REBOOT
)paren
(brace
multiline_comment|/*&n;&t;  ** well, the RTA has been rebooted, and there is room&n;&t;  ** on its queue to add the open packet that is required.&n;&t;  **&n;&t;  ** The messy part of this line is trying to decide if&n;&t;  ** we need to call the Param function as a tty or as&n;&t;  ** a modem.&n;&t;  ** DONT USE CLOCAL AS A TEST FOR THIS!&n;&t;  **&n;&t;  ** If we can&squot;t param the port, then move on to the&n;&t;  ** next port.&n;&t;  */
id|PortP-&gt;InUse
op_assign
id|NOT_INUSE
suffix:semicolon
id|rio_spin_unlock
c_func
(paren
op_amp
id|PortP-&gt;portSem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RIOParam
c_func
(paren
id|PortP
comma
id|OPEN
comma
(paren
(paren
id|PortP-&gt;Cor2Copy
op_amp
(paren
id|COR2_RTSFLOW
op_or
id|COR2_CTSFLOW
)paren
)paren
op_eq
(paren
id|COR2_RTSFLOW
op_or
id|COR2_CTSFLOW
)paren
)paren
ques
c_cond
id|TRUE
suffix:colon
id|FALSE
comma
id|DONT_SLEEP
)paren
op_eq
id|RIO_FAIL
)paren
(brace
r_continue
suffix:semicolon
multiline_comment|/* with next port */
)brace
id|rio_spin_lock
c_func
(paren
op_amp
id|PortP-&gt;portSem
)paren
suffix:semicolon
id|PortP-&gt;MagicFlags
op_and_assign
op_complement
id|MAGIC_REBOOT
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n;&t;** As mentioned above, this is a tacky hack to cope&n;&t;** with WFLUSH&n;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;WflushFlag
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;Want to WFLUSH mark this port&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PortP-&gt;InUse
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;FAILS - PORT IS IN USE&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|PortP-&gt;WflushFlag
op_logical_and
id|can_add_transmit
c_func
(paren
op_amp
id|PacketP
comma
id|PortP
)paren
op_logical_and
(paren
id|PortP-&gt;InUse
op_eq
id|NOT_INUSE
)paren
)paren
(brace
r_int
id|p
suffix:semicolon
r_struct
id|PktCmd
op_star
id|PktCmdP
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;Add WFLUSH marker to data queue&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;  ** make it look just like a WFLUSH command&n;&t;  */
id|PktCmdP
op_assign
(paren
r_struct
id|PktCmd
op_star
)paren
op_amp
id|PacketP-&gt;data
(braket
l_int|0
)braket
suffix:semicolon
id|WBYTE
c_func
(paren
id|PktCmdP-&gt;Command
comma
id|WFLUSH
)paren
suffix:semicolon
id|p
op_assign
id|PortP-&gt;HostPort
op_mod
(paren
id|ushort
)paren
id|PORTS_PER_RTA
suffix:semicolon
multiline_comment|/*&n;&t;  ** If second block of ports for 16 port RTA, add 8&n;&t;  ** to index 8-15.&n;&t;  */
r_if
c_cond
(paren
id|PortP-&gt;SecondBlock
)paren
id|p
op_add_assign
id|PORTS_PER_RTA
suffix:semicolon
id|WBYTE
c_func
(paren
id|PktCmdP-&gt;PhbNum
comma
id|p
)paren
suffix:semicolon
multiline_comment|/*&n;&t;  ** to make debuggery easier&n;&t;  */
id|WBYTE
c_func
(paren
id|PacketP-&gt;data
(braket
l_int|2
)braket
comma
l_char|&squot;W&squot;
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|PacketP-&gt;data
(braket
l_int|3
)braket
comma
l_char|&squot;F&squot;
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|PacketP-&gt;data
(braket
l_int|4
)braket
comma
l_char|&squot;L&squot;
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|PacketP-&gt;data
(braket
l_int|5
)braket
comma
l_char|&squot;U&squot;
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|PacketP-&gt;data
(braket
l_int|6
)braket
comma
l_char|&squot;S&squot;
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|PacketP-&gt;data
(braket
l_int|7
)braket
comma
l_char|&squot;H&squot;
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|PacketP-&gt;data
(braket
l_int|8
)braket
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|PacketP-&gt;data
(braket
l_int|9
)braket
comma
l_char|&squot;0&squot;
op_plus
id|PortP-&gt;WflushFlag
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|PacketP-&gt;data
(braket
l_int|10
)braket
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|PacketP-&gt;data
(braket
l_int|11
)braket
comma
l_char|&squot; &squot;
)paren
suffix:semicolon
id|WBYTE
c_func
(paren
id|PacketP-&gt;data
(braket
l_int|12
)braket
comma
l_char|&squot;&bslash;0&squot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;  ** its two bytes long!&n;&t;  */
id|WBYTE
c_func
(paren
id|PacketP-&gt;len
comma
id|PKT_CMD_BIT
op_or
l_int|2
)paren
suffix:semicolon
multiline_comment|/*&n;&t;  ** queue it!&n;&t;  */
r_if
c_cond
(paren
op_logical_neg
(paren
id|PortP-&gt;State
op_amp
id|RIO_DELETED
)paren
)paren
(brace
id|add_transmit
c_func
(paren
id|PortP
)paren
suffix:semicolon
multiline_comment|/*&n;&t;    ** Count chars tx&squot;d for port statistics reporting&n;&t;    */
r_if
c_cond
(paren
id|PortP-&gt;statsGather
)paren
id|PortP-&gt;txchars
op_add_assign
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
(paren
id|PortP-&gt;WflushFlag
)paren
op_eq
l_int|0
)paren
(brace
id|PortP-&gt;MagicFlags
op_and_assign
op_complement
id|MAGIC_FLUSH
suffix:semicolon
)brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;Wflush count now stands at %d&bslash;n&quot;
comma
id|PortP-&gt;WflushFlag
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PortP-&gt;MagicFlags
op_amp
id|MORE_OUTPUT_EYGOR
)paren
(brace
r_if
c_cond
(paren
id|PortP-&gt;MagicFlags
op_amp
id|MAGIC_FLUSH
)paren
(brace
id|PortP-&gt;MagicFlags
op_or_assign
id|MORE_OUTPUT_EYGOR
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|can_add_transmit
c_func
(paren
op_amp
id|PacketP
comma
id|PortP
)paren
)paren
(brace
id|rio_spin_unlock
c_func
(paren
op_amp
id|PortP-&gt;portSem
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|rio_spin_unlock
c_func
(paren
op_amp
id|PortP-&gt;portSem
)paren
suffix:semicolon
id|RIOTxEnable
c_func
(paren
(paren
r_char
op_star
)paren
id|PortP
)paren
suffix:semicolon
id|rio_spin_lock
c_func
(paren
op_amp
id|PortP-&gt;portSem
)paren
suffix:semicolon
id|PortP-&gt;MagicFlags
op_and_assign
op_complement
id|MORE_OUTPUT_EYGOR
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;      ** If we can&squot;t add anything to the transmit queue, then&n;      ** we need do none of the remaining processing.&n;      */
r_if
c_cond
(paren
op_logical_neg
id|can_add_transmit
c_func
(paren
op_amp
id|PacketP
comma
id|PortP
)paren
)paren
(brace
id|rio_spin_unlock
c_func
(paren
op_amp
id|PortP-&gt;portSem
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|rio_spin_unlock
c_func
(paren
op_amp
id|PortP-&gt;portSem
)paren
suffix:semicolon
id|RIOTxEnable
c_func
(paren
(paren
r_char
op_star
)paren
id|PortP
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;** Routine for handling received data for clist drivers.&n;** NB: Called with the tty locked. The spl from the lockb( ) is passed.&n;** we return the ttySpl level that we re-locked at.&n;*/
r_void
DECL|function|RIOReceive
id|RIOReceive
c_func
(paren
id|p
comma
id|PortP
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
r_struct
id|Port
op_star
id|PortP
suffix:semicolon
(brace
r_struct
id|tty_struct
op_star
id|TtyP
suffix:semicolon
r_register
id|ushort
id|transCount
suffix:semicolon
r_struct
id|PKT
op_star
id|PacketP
suffix:semicolon
r_register
id|uint
id|DataCnt
suffix:semicolon
id|uchar
op_star
id|ptr
suffix:semicolon
r_int
id|copied
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|intCount
comma
id|RxIntCnt
suffix:semicolon
multiline_comment|/*&n;  ** The receive data process is to remove packets from the&n;  ** PHB until there aren&squot;t any more or the current cblock&n;  ** is full. When this occurs, there will be some left over&n;  ** data in the packet, that we must do something with.&n;  ** As we haven&squot;t unhooked the packet from the read list&n;  ** yet, we can just leave the packet there, having first&n;  ** made a note of how far we got. This means that we need&n;  ** a pointer per port saying where we start taking the&n;  ** data from - this will normally be zero, but when we&n;  ** run out of space it will be set to the offset of the&n;  ** next byte to copy from the packet data area. The packet&n;  ** length field is decremented by the number of bytes that&n;  ** we succesfully removed from the packet. When this reaches&n;  ** zero, we reset the offset pointer to be zero, and free&n;  ** the packet from the front of the queue.&n;  */
id|intCount
op_increment
suffix:semicolon
id|TtyP
op_assign
id|PortP-&gt;gs.tty
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|TtyP
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;RIOReceive: tty is null. &bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PortP-&gt;State
op_amp
id|RIO_THROTTLE_RX
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;RIOReceive: Throttled. Can&squot;t handle more input.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PortP-&gt;State
op_amp
id|RIO_DELETED
)paren
(brace
r_while
c_loop
(paren
id|can_remove_receive
c_func
(paren
op_amp
id|PacketP
comma
id|PortP
)paren
)paren
(brace
id|remove_receive
c_func
(paren
id|PortP
)paren
suffix:semicolon
id|put_free_end
c_func
(paren
id|PortP-&gt;HostP
comma
id|PacketP
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;      ** loop, just so long as:&n;      **   i ) there&squot;s some data ( i.e. can_remove_receive )&n;      **  ii ) we haven&squot;t been blocked&n;      ** iii ) there&squot;s somewhere to put the data&n;      **  iv ) we haven&squot;t outstayed our welcome&n;      */
id|transCount
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|can_remove_receive
c_func
(paren
op_amp
id|PacketP
comma
id|PortP
)paren
op_logical_and
id|transCount
)paren
(brace
macro_line|#ifdef STATS
id|PortP-&gt;Stat.RxIntCnt
op_increment
suffix:semicolon
macro_line|#endif /* STATS */
id|RxIntCnt
op_increment
suffix:semicolon
multiline_comment|/*&n;&t;  ** check that it is not a command!&n;&t;  */
r_if
c_cond
(paren
id|PacketP-&gt;len
op_amp
id|PKT_CMD_BIT
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;RIO: unexpected command packet received on PHB&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&t;    rio_dprint(RIO_DEBUG_INTR, (&quot; sysport   = %d&bslash;n&quot;, p-&gt;RIOPortp-&gt;PortNum)); */
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot; dest_unit = %d&bslash;n&quot;
comma
id|PacketP-&gt;dest_unit
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot; dest_port = %d&bslash;n&quot;
comma
id|PacketP-&gt;dest_port
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot; src_unit  = %d&bslash;n&quot;
comma
id|PacketP-&gt;src_unit
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot; src_port  = %d&bslash;n&quot;
comma
id|PacketP-&gt;src_port
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot; len&t;   = %d&bslash;n&quot;
comma
id|PacketP-&gt;len
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot; control   = %d&bslash;n&quot;
comma
id|PacketP-&gt;control
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot; csum&t;   = %d&bslash;n&quot;
comma
id|PacketP-&gt;csum
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;&t; data bytes: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|DataCnt
op_assign
l_int|0
suffix:semicolon
id|DataCnt
OL
id|PKT_MAX_DATA_LEN
suffix:semicolon
id|DataCnt
op_increment
)paren
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;%d&bslash;n&quot;
comma
id|PacketP-&gt;data
(braket
id|DataCnt
)braket
)paren
suffix:semicolon
id|remove_receive
c_func
(paren
id|PortP
)paren
suffix:semicolon
id|put_free_end
c_func
(paren
id|PortP-&gt;HostP
comma
id|PacketP
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* with next packet */
)brace
multiline_comment|/*&n;&t;  ** How many characters can we move &squot;upstream&squot; ?&n;&t;  **&n;&t;  ** Determine the minimum of the amount of data&n;&t;  ** available and the amount of space in which to&n;&t;  ** put it.&n;&t;  **&n;&t;  ** 1.&t;Get the packet length by masking &squot;len&squot;&n;&t;  **&t;for only the length bits.&n;&t;  ** 2.&t;Available space is [buffer size] - [space used]&n;&t;  **&n;&t;  ** Transfer count is the minimum of packet length&n;&t;  ** and available space.&n;&t;  */
id|transCount
op_assign
id|min
c_func
(paren
id|PacketP-&gt;len
op_amp
id|PKT_LEN_MASK
comma
id|TTY_FLIPBUF_SIZE
op_minus
id|TtyP-&gt;flip.count
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_REC
comma
l_string|&quot;port %d: Copy %d bytes&bslash;n&quot;
comma
id|PortP-&gt;PortNum
comma
id|transCount
)paren
suffix:semicolon
multiline_comment|/*&n;&t;  ** To use the following &squot;kkprintfs&squot; for debugging - change the &squot;#undef&squot;&n;&t;  ** to &squot;#define&squot;, (this is the only place ___DEBUG_IT___ occurs in the&n;&t;  ** driver).&n;&t;  */
DECL|macro|___DEBUG_IT___
macro_line|#undef ___DEBUG_IT___
macro_line|#ifdef ___DEBUG_IT___
id|kkprintf
c_func
(paren
l_string|&quot;I:%d R:%d P:%d Q:%d C:%d F:%x &quot;
comma
id|intCount
comma
id|RxIntCnt
comma
id|PortP-&gt;PortNum
comma
id|TtyP-&gt;rxqueue.count
comma
id|transCount
comma
id|TtyP-&gt;flags
)paren
suffix:semicolon
macro_line|#endif
id|ptr
op_assign
(paren
id|uchar
op_star
)paren
id|PacketP-&gt;data
op_plus
id|PortP-&gt;RxDataStart
suffix:semicolon
id|rio_memcpy_fromio
(paren
id|TtyP-&gt;flip.char_buf_ptr
comma
id|ptr
comma
id|transCount
)paren
suffix:semicolon
id|memset
c_func
(paren
id|TtyP-&gt;flip.flag_buf_ptr
comma
id|TTY_NORMAL
comma
id|transCount
)paren
suffix:semicolon
macro_line|#ifdef STATS
multiline_comment|/*&n;&t;  ** keep a count for statistical purposes&n;&t;  */
id|PortP-&gt;Stat.RxCharCnt
op_add_assign
id|transCount
suffix:semicolon
macro_line|#endif
id|PortP-&gt;RxDataStart
op_add_assign
id|transCount
suffix:semicolon
id|PacketP-&gt;len
op_sub_assign
id|transCount
suffix:semicolon
id|copied
op_add_assign
id|transCount
suffix:semicolon
id|TtyP-&gt;flip.count
op_add_assign
id|transCount
suffix:semicolon
id|TtyP-&gt;flip.char_buf_ptr
op_add_assign
id|transCount
suffix:semicolon
id|TtyP-&gt;flip.flag_buf_ptr
op_add_assign
id|transCount
suffix:semicolon
macro_line|#ifdef ___DEBUG_IT___
id|kkprintf
c_func
(paren
l_string|&quot;T:%d L:%d&bslash;n&quot;
comma
id|DataCnt
comma
id|PacketP-&gt;len
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|PacketP-&gt;len
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;** If we have emptied the packet, then we can&n;&t;&t;&t;&t;** free it, and reset the start pointer for&n;&t;&t;&t;&t;** the next packet.&n;&t;&t;&t;&t;*/
id|remove_receive
c_func
(paren
id|PortP
)paren
suffix:semicolon
id|put_free_end
c_func
(paren
id|PortP-&gt;HostP
comma
id|PacketP
)paren
suffix:semicolon
id|PortP-&gt;RxDataStart
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef STATS
multiline_comment|/*&n;&t;&t;&t;&t;** more lies ( oops, I mean statistics )&n;&t;&t;&t;&t;*/
id|PortP-&gt;Stat.RxPktCnt
op_increment
suffix:semicolon
macro_line|#endif /* STATS */
)brace
)brace
)brace
r_if
c_cond
(paren
id|copied
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_REC
comma
l_string|&quot;port %d: pushing tty flip buffer: %d total bytes copied.&bslash;n&quot;
comma
id|PortP-&gt;PortNum
comma
id|copied
)paren
suffix:semicolon
id|tty_flip_buffer_push
(paren
id|TtyP
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef FUTURE_RELEASE
multiline_comment|/*&n;** The proc routine called by the line discipline to do the work for it.&n;** The proc routine works hand in hand with the interrupt routine.&n;*/
r_int
DECL|function|riotproc
id|riotproc
c_func
(paren
id|p
comma
id|tp
comma
id|cmd
comma
id|port
)paren
r_struct
id|rio_info
op_star
id|p
suffix:semicolon
r_register
r_struct
id|ttystatics
op_star
id|tp
suffix:semicolon
r_int
id|cmd
suffix:semicolon
r_int
id|port
suffix:semicolon
(brace
r_register
r_struct
id|Port
op_star
id|PortP
suffix:semicolon
r_int
id|SysPort
suffix:semicolon
r_struct
id|PKT
op_star
id|PacketP
suffix:semicolon
id|SysPort
op_assign
id|port
suffix:semicolon
multiline_comment|/* Believe me, it works. */
r_if
c_cond
(paren
id|SysPort
OL
l_int|0
op_logical_or
id|SysPort
op_ge
id|RIO_PORTS
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;Illegal port %d derived from TTY in riotproc()&bslash;n&quot;
comma
id|SysPort
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|PortP
op_assign
id|p-&gt;RIOPortp
(braket
id|SysPort
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|uint
)paren
id|PortP-&gt;PhbP
OL
(paren
id|uint
)paren
id|PortP-&gt;Caddr
op_logical_or
(paren
id|uint
)paren
id|PortP-&gt;PhbP
op_ge
(paren
id|uint
)paren
id|PortP-&gt;Caddr
op_plus
id|SIXTY_FOUR_K
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;RIO: NULL or BAD PhbP on sys port %d in proc routine&bslash;n&quot;
comma
id|SysPort
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;&t; PortP = 0x%x&bslash;n&quot;
comma
id|PortP
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;&t; PortP-&gt;PhbP = 0x%x&bslash;n&quot;
comma
id|PortP-&gt;PhbP
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;&t; PortP-&gt;Caddr = 0x%x&bslash;n&quot;
comma
id|PortP-&gt;PhbP
)paren
suffix:semicolon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;&t; PortP-&gt;HostPort = 0x%x&bslash;n&quot;
comma
id|PortP-&gt;HostPort
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|T_WFLUSH
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;T_WFLUSH&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** Because of the spooky way the RIO works, we don&squot;t need&n;&t;&t;&t;** to issue a flush command on any of the SET*F commands,&n;&t;&t;&t;** as that causes trouble with getty and login, which issue&n;&t;&t;&t;** these commands to incur a READ flush, and rely on the fact&n;&t;&t;&t;** that the line discipline does a wait for drain for them.&n;&t;&t;&t;** As the rio doesn&squot;t wait for drain, the write flush would&n;&t;&t;&t;** destroy the Password: prompt. This isn&squot;t very friendly, so&n;&t;&t;&t;** here we only issue a WFLUSH command if we are in the interrupt&n;&t;&t;&t;** routine, or we aren&squot;t executing a SET*F command.&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;HostP-&gt;InIntr
op_logical_or
op_logical_neg
id|PortP-&gt;FlushCmdBodge
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;** form a wflush packet - 1 byte long, no data&n;&t;&t;&t;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;State
op_amp
id|RIO_DELETED
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;WFLUSH on deleted RTA&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|RIOPreemptiveCmd
c_func
(paren
id|p
comma
id|PortP
comma
id|WFLUSH
)paren
op_eq
id|RIO_FAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;T_WFLUSH Command failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;T_WFLUSH Command&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t;** WFLUSH operation - flush the data!&n;&t;&t;&t;&t;*/
id|PortP-&gt;TxBufferIn
op_assign
id|PortP-&gt;TxBufferOut
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;T_WFLUSH Command ignored&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;** sort out the line discipline&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;CookMode
op_eq
id|COOK_WELL
)paren
r_goto
id|start
suffix:semicolon
r_break
suffix:semicolon
r_case
id|T_RESUME
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;T_RESUME&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** send pre-emptive resume packet&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;State
op_amp
id|RIO_DELETED
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;RESUME on deleted RTA&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|RIOPreemptiveCmd
c_func
(paren
id|p
comma
id|PortP
comma
id|RESUME
)paren
op_eq
id|RIO_FAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;T_RESUME Command failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;** and re-start the sender software!&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;CookMode
op_eq
id|COOK_WELL
)paren
r_goto
id|start
suffix:semicolon
r_break
suffix:semicolon
r_case
id|T_TIME
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;T_TIME&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** T_TIME is called when xDLY is set in oflags and&n;&t;&t;&t;** the line discipline timeout has expired. It&squot;s&n;&t;&t;&t;** function in life is to clear the TIMEOUT flag&n;&t;&t;&t;** and to re-start output to the port.&n;&t;&t;&t;*/
multiline_comment|/*&n;&t;&t;&t;** Fall through and re-start output&n;&t;&t;&t;*/
r_case
id|T_OUTPUT
suffix:colon
id|start
suffix:colon
r_if
c_cond
(paren
id|PortP-&gt;MagicFlags
op_amp
id|MAGIC_FLUSH
)paren
(brace
id|PortP-&gt;MagicFlags
op_or_assign
id|MORE_OUTPUT_EYGOR
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|RIOTxEnable
c_func
(paren
(paren
r_char
op_star
)paren
id|PortP
)paren
suffix:semicolon
id|PortP-&gt;MagicFlags
op_and_assign
op_complement
id|MORE_OUTPUT_EYGOR
suffix:semicolon
multiline_comment|/*rio_dprint(RIO_DEBUG_INTR, PortP,DBG_PROC,&quot;T_OUTPUT finished&bslash;n&quot;);*/
r_break
suffix:semicolon
r_case
id|T_SUSPEND
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;T_SUSPEND&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** send a suspend pre-emptive packet.&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;State
op_amp
id|RIO_DELETED
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;SUSPEND deleted RTA&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|RIOPreemptiveCmd
c_func
(paren
id|p
comma
id|PortP
comma
id|SUSPEND
)paren
op_eq
id|RIO_FAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;T_SUSPEND Command failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;** done!&n;&t;&t;&t;*/
r_break
suffix:semicolon
r_case
id|T_BLOCK
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;T_BLOCK&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|T_RFLUSH
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;T_RFLUSH&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PortP-&gt;State
op_amp
id|RIO_DELETED
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;RFLUSH on deleted RTA&bslash;n&quot;
)paren
suffix:semicolon
id|PortP-&gt;RxDataStart
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|RIOPreemptiveCmd
c_func
(paren
id|p
comma
id|PortP
comma
id|RFLUSH
)paren
op_eq
id|RIO_FAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;T_RFLUSH Command failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|PortP-&gt;RxDataStart
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|can_remove_receive
c_func
(paren
op_amp
id|PacketP
comma
id|PortP
)paren
)paren
(brace
id|remove_receive
c_func
(paren
id|PortP
)paren
suffix:semicolon
id|ShowPacket
c_func
(paren
id|DBG_PROC
comma
id|PacketP
)paren
suffix:semicolon
id|put_free_end
c_func
(paren
id|PortP-&gt;HostP
comma
id|PacketP
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|PortP-&gt;PhbP-&gt;handshake
op_eq
id|PHB_HANDSHAKE_SET
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;** MAGIC!&n;&t;&t;&t;&t;&t;*/
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;Set receive handshake bit&bslash;n&quot;
)paren
suffix:semicolon
id|PortP-&gt;PhbP-&gt;handshake
op_or_assign
id|PHB_HANDSHAKE_RESET
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
multiline_comment|/* FALLTHROUGH */
r_case
id|T_UNBLOCK
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;T_UNBLOCK&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** If there is any data to receive set a timeout to service it.&n;&t;&t;&t;*/
id|RIOReceive
c_func
(paren
id|p
comma
id|PortP
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|T_BREAK
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;T_BREAK&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;** Send a break command. For Sys V&n;&t;&t;&t;** this is a timed break, so we&n;&t;&t;&t;** send a SBREAK[time] packet&n;&t;&t;&t;*/
multiline_comment|/*&n;&t;&t;&t;** Build a BREAK command&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|PortP-&gt;State
op_amp
id|RIO_DELETED
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;BREAK on deleted RTA&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|RIOShortCommand
c_func
(paren
id|PortP
comma
id|SBREAK
comma
l_int|2
comma
id|p-&gt;RIOConf.BreakInterval
)paren
op_eq
id|RIO_FAIL
)paren
(brace
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;SBREAK RIOShortCommand failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;** done!&n;&t;&t;&t;*/
r_break
suffix:semicolon
r_case
id|T_INPUT
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;Proc T_INPUT called - I don&squot;t know what to do!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|T_PARM
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;Proc T_PARM called - I don&squot;t know what to do!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|T_SWTCH
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;Proc T_SWTCH called - I don&squot;t know what to do!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|rio_dprintk
(paren
id|RIO_DEBUG_INTR
comma
l_string|&quot;Proc UNKNOWN command %d&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;** T_OUTPUT returns without passing through this point!&n;&t;*/
multiline_comment|/*rio_dprint(RIO_DEBUG_INTR, PortP,DBG_PROC,&quot;riotproc done&bslash;n&quot;);*/
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
eof
