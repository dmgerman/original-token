multiline_comment|/* Derived from Applicom driver ac.c for SCO Unix                            */
multiline_comment|/* Ported by David Woodhouse, Axiom (Cambridge) Ltd.                         */
multiline_comment|/* Dave@mvhi.com  30/8/98                                                    */
multiline_comment|/* $Id: ac.c,v 1.30 2000/03/22 16:03:57 dwmw2 Exp $&t;&t;&t;     */
multiline_comment|/* This module is for Linux 2.1 and 2.2 series kernels.                      */
multiline_comment|/*****************************************************************************/
multiline_comment|/* J PAGET 18/02/94 passage V2.4.2 ioctl avec code 2 reset to les interrupt  */
multiline_comment|/* ceci pour reseter correctement apres une sortie sauvage                   */
multiline_comment|/* J PAGET 02/05/94 passage V2.4.3 dans le traitement de d&squot;interruption,     */
multiline_comment|/* LoopCount n&squot;etait pas initialise a 0.                                     */
multiline_comment|/* F LAFORSE 04/07/95 version V2.6.0 lecture bidon apres acces a une carte   */
multiline_comment|/*           pour liberer le bus                                             */
multiline_comment|/* J.PAGET 19/11/95 version V2.6.1 Nombre, addresse,irq n&squot;est plus configure */
multiline_comment|/* et passe en argument a acinit, mais est scrute sur le bus pour s&squot;adapter  */
multiline_comment|/* au nombre de cartes presentes sur le bus. IOCL code 6 affichait V2.4.3    */
multiline_comment|/* F.LAFORSE 28/11/95 creation de fichiers acXX.o avec les differentes       */
multiline_comment|/* adresses de base des cartes, IOCTL 6 plus complet                         */
multiline_comment|/* J.PAGET le 19/08/96 copie de la version V2.6 en V2.8.0 sans modification  */
multiline_comment|/* de code autre que le texte V2.6.1 en V2.8.0                               */
multiline_comment|/*****************************************************************************/
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/compatmac.h&gt;
macro_line|#include &quot;applicom.h&quot;
macro_line|#if LINUX_VERSION_CODE &lt; 0x20300 
multiline_comment|/* These probably want adding to &lt;linux/compatmac.h&gt; */
DECL|macro|init_waitqueue_head
mdefine_line|#define init_waitqueue_head(x) do { *(x) = NULL; } while (0);
DECL|macro|PCI_BASE_ADDRESS
mdefine_line|#define PCI_BASE_ADDRESS(dev) (dev-&gt;base_address[0])
DECL|macro|DECLARE_WAIT_QUEUE_HEAD
mdefine_line|#define DECLARE_WAIT_QUEUE_HEAD(x) struct wait_queue *x
DECL|macro|__setup
mdefine_line|#define __setup(x,y) /* */
macro_line|#else
DECL|macro|PCI_BASE_ADDRESS
mdefine_line|#define PCI_BASE_ADDRESS(dev) (dev-&gt;resource[0].start)
macro_line|#endif
multiline_comment|/* NOTE: We use for loops with {write,read}b() instead of &n;   memcpy_{from,to}io throughout this driver. This is because&n;   the board doesn&squot;t correctly handle word accesses - only&n;   bytes. &n;*/
DECL|macro|DEBUG
macro_line|#undef DEBUG
DECL|macro|MAX_BOARD
mdefine_line|#define MAX_BOARD 8&t;&t;/* maximum of pc board possible */
DECL|macro|MAX_ISA_BOARD
mdefine_line|#define MAX_ISA_BOARD 4
DECL|macro|LEN_RAM_IO
mdefine_line|#define LEN_RAM_IO 0x800
DECL|macro|AC_MINOR
mdefine_line|#define AC_MINOR 157
macro_line|#ifndef PCI_VENDOR_ID_APPLICOM
DECL|macro|PCI_VENDOR_ID_APPLICOM
mdefine_line|#define PCI_VENDOR_ID_APPLICOM                0x1389
DECL|macro|PCI_DEVICE_ID_APPLICOM_PCIGENERIC
mdefine_line|#define PCI_DEVICE_ID_APPLICOM_PCIGENERIC     0x0001
DECL|macro|PCI_DEVICE_ID_APPLICOM_PCI2000IBS_CAN
mdefine_line|#define PCI_DEVICE_ID_APPLICOM_PCI2000IBS_CAN 0x0002
DECL|macro|PCI_DEVICE_ID_APPLICOM_PCI2000PFB
mdefine_line|#define PCI_DEVICE_ID_APPLICOM_PCI2000PFB     0x0003
macro_line|#endif
DECL|macro|MAX_PCI_DEVICE_NUM
mdefine_line|#define MAX_PCI_DEVICE_NUM 3
DECL|variable|applicom_pci_devnames
r_static
r_char
op_star
id|applicom_pci_devnames
(braket
)braket
op_assign
(brace
l_string|&quot;PCI board&quot;
comma
l_string|&quot;PCI2000IBS / PCI2000CAN&quot;
comma
l_string|&quot;PCI2000PFB&quot;
)brace
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;David Woodhouse &amp; Applicom International&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Driver for Applicom Profibus card&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|irq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|irq
comma
l_string|&quot;IRQ of the Applicom board&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|mem
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|mem
comma
l_string|&quot;Shared Memory Address of Applicom board&quot;
)paren
suffix:semicolon
id|MODULE_SUPPORTED_DEVICE
c_func
(paren
l_string|&quot;ac&quot;
)paren
suffix:semicolon
DECL|struct|applicom_board
r_struct
id|applicom_board
(brace
DECL|member|PhysIO
r_int
r_int
id|PhysIO
suffix:semicolon
DECL|member|RamIO
r_int
r_int
id|RamIO
suffix:semicolon
DECL|member|FlagSleepSend
id|wait_queue_head_t
id|FlagSleepSend
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|mutex
id|spinlock_t
id|mutex
suffix:semicolon
DECL|variable|apbs
)brace
id|apbs
(braket
id|MAX_BOARD
)braket
suffix:semicolon
DECL|variable|irq
r_static
r_int
r_int
id|irq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* interrupt number IRQ       */
DECL|variable|mem
r_static
r_int
r_int
id|mem
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* physical segment of board  */
DECL|variable|numboards
r_static
r_int
r_int
id|numboards
suffix:semicolon
multiline_comment|/* number of installed boards */
DECL|variable|Dummy
r_static
r_volatile
r_int
r_char
id|Dummy
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|FlagSleepRec
)paren
suffix:semicolon
DECL|variable|WriteErrorCount
r_static
r_int
r_int
id|WriteErrorCount
suffix:semicolon
multiline_comment|/* number of write error      */
DECL|variable|ReadErrorCount
r_static
r_int
r_int
id|ReadErrorCount
suffix:semicolon
multiline_comment|/* number of read error       */
DECL|variable|DeviceErrorCount
r_static
r_int
r_int
id|DeviceErrorCount
suffix:semicolon
multiline_comment|/* number of device error     */
r_static
id|loff_t
id|ac_llseek
c_func
(paren
r_struct
id|file
op_star
comma
id|loff_t
comma
r_int
)paren
suffix:semicolon
r_static
id|ssize_t
id|ac_read
(paren
r_struct
id|file
op_star
comma
r_char
op_star
comma
r_int
comma
id|loff_t
op_star
)paren
suffix:semicolon
r_static
id|ssize_t
id|ac_write
(paren
r_struct
id|file
op_star
comma
r_const
r_char
op_star
comma
r_int
comma
id|loff_t
op_star
)paren
suffix:semicolon
r_static
r_int
id|ac_ioctl
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_void
id|ac_interrupt
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
DECL|variable|ac_fops
r_struct
id|file_operations
id|ac_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|ac_llseek
comma
id|read
suffix:colon
id|ac_read
comma
id|write
suffix:colon
id|ac_write
comma
id|ioctl
suffix:colon
id|ac_ioctl
comma
)brace
suffix:semicolon
DECL|variable|ac_miscdev
r_struct
id|miscdevice
id|ac_miscdev
op_assign
(brace
id|AC_MINOR
comma
l_string|&quot;ac&quot;
comma
op_amp
id|ac_fops
)brace
suffix:semicolon
DECL|variable|dummy
r_static
r_int
id|dummy
suffix:semicolon
multiline_comment|/* dev_id for request_irq() */
DECL|function|ac_register_board
r_int
id|ac_register_board
c_func
(paren
r_int
r_int
id|physloc
comma
r_int
r_int
id|loc
comma
r_int
r_char
id|boardno
)paren
(brace
r_volatile
r_int
r_char
id|byte_reset_it
suffix:semicolon
r_if
c_cond
(paren
(paren
id|readb
c_func
(paren
id|loc
op_plus
id|CONF_END_TEST
)paren
op_ne
l_int|0x00
)paren
op_logical_or
(paren
id|readb
c_func
(paren
id|loc
op_plus
id|CONF_END_TEST
op_plus
l_int|1
)paren
op_ne
l_int|0x55
)paren
op_logical_or
(paren
id|readb
c_func
(paren
id|loc
op_plus
id|CONF_END_TEST
op_plus
l_int|2
)paren
op_ne
l_int|0xAA
)paren
op_logical_or
(paren
id|readb
c_func
(paren
id|loc
op_plus
id|CONF_END_TEST
op_plus
l_int|3
)paren
op_ne
l_int|0xFF
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|boardno
)paren
id|boardno
op_assign
id|readb
c_func
(paren
id|loc
op_plus
id|NUMCARD_OWNER_TO_PC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|boardno
op_logical_and
id|boardno
OG
id|MAX_BOARD
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Board #%d (at 0x%lx) is out of range (1 &lt;= x &lt;= %d).&bslash;n&quot;
comma
id|boardno
comma
id|physloc
comma
id|MAX_BOARD
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|apbs
(braket
id|boardno
op_minus
l_int|1
)braket
dot
id|RamIO
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Board #%d (at 0x%lx) conflicts with previous board #%d (at 0x%lx)&bslash;n&quot;
comma
id|boardno
comma
id|physloc
comma
id|boardno
comma
id|apbs
(braket
id|boardno
op_minus
l_int|1
)braket
dot
id|PhysIO
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|boardno
op_decrement
suffix:semicolon
id|apbs
(braket
id|boardno
)braket
dot
id|PhysIO
op_assign
id|physloc
suffix:semicolon
id|apbs
(braket
id|boardno
)braket
dot
id|RamIO
op_assign
id|loc
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|apbs
(braket
id|boardno
)braket
dot
id|FlagSleepSend
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|apbs
(braket
id|boardno
)braket
dot
id|mutex
)paren
suffix:semicolon
id|byte_reset_it
op_assign
id|readb
c_func
(paren
id|loc
op_plus
id|RAM_IT_TO_PC
)paren
suffix:semicolon
id|numboards
op_increment
suffix:semicolon
r_return
id|boardno
op_plus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|macro|applicom_init
mdefine_line|#define applicom_init init_module
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|misc_deregister
c_func
(paren
op_amp
id|ac_miscdev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_BOARD
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|apbs
(braket
id|i
)braket
dot
id|RamIO
)paren
r_continue
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|apbs
(braket
id|i
)braket
dot
id|irq
)paren
id|free_irq
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|irq
comma
op_amp
id|dummy
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;&t;&t;&t;/* MODULE */
DECL|function|applicom_init
r_int
id|__init
id|applicom_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|numisa
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_void
op_star
id|RamIO
suffix:semicolon
r_int
id|boardno
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Applicom driver: $Id: ac.c,v 1.30 2000/03/22 16:03:57 dwmw2 Exp $&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* No mem and irq given - check for a PCI card */
r_while
c_loop
(paren
(paren
id|dev
op_assign
id|pci_find_class
c_func
(paren
id|PCI_CLASS_OTHERS
op_lshift
l_int|16
comma
id|dev
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;vendor
op_ne
id|PCI_VENDOR_ID_APPLICOM
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;device
OG
id|MAX_PCI_DEVICE_NUM
op_logical_or
id|dev-&gt;device
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|dev
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|RamIO
op_assign
id|ioremap
c_func
(paren
id|PCI_BASE_ADDRESS
c_func
(paren
id|dev
)paren
comma
id|LEN_RAM_IO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RamIO
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ac.o: Failed to ioremap PCI memory space at 0x%lx&bslash;n&quot;
comma
id|PCI_BASE_ADDRESS
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Applicom %s found at mem 0x%lx, irq %d&bslash;n&quot;
comma
id|applicom_pci_devnames
(braket
id|dev-&gt;device
op_minus
l_int|1
)braket
comma
id|PCI_BASE_ADDRESS
c_func
(paren
id|dev
)paren
comma
id|dev-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|boardno
op_assign
id|ac_register_board
c_func
(paren
id|PCI_BASE_ADDRESS
c_func
(paren
id|dev
)paren
comma
(paren
r_int
r_int
)paren
id|RamIO
comma
l_int|0
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ac.o: PCI Applicom device doesn&squot;t have correct signature.&bslash;n&quot;
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|RamIO
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|dev-&gt;irq
comma
op_amp
id|ac_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;Applicom PCI&quot;
comma
op_amp
id|dummy
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Could not allocate IRQ %d for PCI Applicom device.&bslash;n&quot;
comma
id|dev-&gt;irq
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|RamIO
)paren
suffix:semicolon
id|apbs
(braket
id|boardno
op_minus
l_int|1
)braket
dot
id|RamIO
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Enable interrupts. */
id|writeb
c_func
(paren
l_int|0x40
comma
id|apbs
(braket
id|boardno
op_minus
l_int|1
)braket
dot
id|RamIO
op_plus
id|RAM_IT_FROM_PC
)paren
suffix:semicolon
id|apbs
(braket
id|boardno
op_minus
l_int|1
)braket
dot
id|irq
op_assign
id|dev-&gt;irq
suffix:semicolon
)brace
multiline_comment|/* Finished with PCI cards. If none registered, &n;&t; * and there was no mem/irq specified, exit */
r_if
c_cond
(paren
op_logical_neg
id|mem
op_logical_or
op_logical_neg
id|irq
)paren
(brace
r_if
c_cond
(paren
id|numboards
)paren
r_goto
id|fin
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ac.o: No PCI boards found.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ac.o: For an ISA board you must supply memory and irq parameters.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
)brace
multiline_comment|/* Now try the specified ISA cards */
id|RamIO
op_assign
id|ioremap
c_func
(paren
id|mem
comma
id|LEN_RAM_IO
op_star
id|MAX_ISA_BOARD
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RamIO
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ac.o: Failed to ioremap ISA memory space at 0x%lx&bslash;n&quot;
comma
id|mem
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_ISA_BOARD
suffix:semicolon
id|i
op_increment
)paren
(brace
id|RamIO
op_assign
id|ioremap
c_func
(paren
id|mem
op_plus
(paren
id|LEN_RAM_IO
op_star
id|i
)paren
comma
id|LEN_RAM_IO
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|RamIO
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ac.o: Failed to ioremap the ISA card&squot;s memory space (slot #%d)&bslash;n&quot;
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|boardno
op_assign
id|ac_register_board
c_func
(paren
(paren
r_int
r_int
)paren
id|mem
op_plus
(paren
id|LEN_RAM_IO
op_star
id|i
)paren
comma
(paren
r_int
r_int
)paren
id|RamIO
comma
id|i
op_plus
l_int|1
)paren
)paren
)paren
(brace
id|iounmap
c_func
(paren
id|RamIO
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Applicom ISA card found at mem 0x%lx, irq %d&bslash;n&quot;
comma
id|mem
op_plus
(paren
id|LEN_RAM_IO
op_star
id|i
)paren
comma
id|irq
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|numisa
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|irq
comma
op_amp
id|ac_interrupt
comma
id|SA_SHIRQ
comma
l_string|&quot;Applicom ISA&quot;
comma
op_amp
id|dummy
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Could not allocate IRQ %d for ISA Applicom device.&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|RamIO
)paren
suffix:semicolon
id|apbs
(braket
id|boardno
op_minus
l_int|1
)braket
dot
id|RamIO
op_assign
l_int|0
suffix:semicolon
)brace
id|apbs
(braket
id|boardno
op_minus
l_int|1
)braket
dot
id|irq
op_assign
id|irq
suffix:semicolon
)brace
r_else
id|apbs
(braket
id|boardno
op_minus
l_int|1
)braket
dot
id|irq
op_assign
l_int|0
suffix:semicolon
id|numisa
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|numisa
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ac.o: No valid ISA Applicom boards found at mem 0x%lx&bslash;n&quot;
comma
id|mem
)paren
suffix:semicolon
id|fin
suffix:colon
id|init_waitqueue_head
c_func
(paren
op_amp
id|FlagSleepRec
)paren
suffix:semicolon
id|WriteErrorCount
op_assign
l_int|0
suffix:semicolon
id|ReadErrorCount
op_assign
l_int|0
suffix:semicolon
id|DeviceErrorCount
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|numboards
)paren
(brace
id|misc_register
c_func
(paren
op_amp
id|ac_miscdev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_BOARD
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|serial
suffix:semicolon
r_char
id|boardname
(braket
(paren
id|SERIAL_NUMBER
op_minus
id|TYPE_CARD
)paren
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|apbs
(braket
id|i
)braket
dot
id|RamIO
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|serial
op_assign
l_int|0
suffix:semicolon
id|serial
OL
id|SERIAL_NUMBER
op_minus
id|TYPE_CARD
suffix:semicolon
id|serial
op_increment
)paren
id|boardname
(braket
id|serial
)braket
op_assign
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|TYPE_CARD
op_plus
id|serial
)paren
suffix:semicolon
id|boardname
(braket
id|serial
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Applicom board %d: %s, PROM V%d.%d&quot;
comma
id|i
op_plus
l_int|1
comma
id|boardname
comma
(paren
r_int
)paren
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|VERS
)paren
op_rshift
l_int|4
)paren
comma
(paren
r_int
)paren
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|VERS
)paren
op_amp
l_int|0xF
)paren
)paren
suffix:semicolon
id|serial
op_assign
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|SERIAL_NUMBER
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|SERIAL_NUMBER
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_plus
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|SERIAL_NUMBER
op_plus
l_int|2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot; S/N %d&bslash;n&quot;
comma
id|serial
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
macro_line|#ifndef MODULE
DECL|variable|applicom_init
id|__initcall
c_func
(paren
id|applicom_init
)paren
suffix:semicolon
macro_line|#endif
DECL|function|ac_llseek
r_static
id|loff_t
id|ac_llseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
DECL|function|ac_write
r_static
id|ssize_t
id|ac_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
r_int
id|NumCard
suffix:semicolon
multiline_comment|/* Board number 1 -&gt; 8           */
r_int
r_int
id|IndexCard
suffix:semicolon
multiline_comment|/* Index board number 0 -&gt; 7     */
r_int
r_char
id|TicCard
suffix:semicolon
multiline_comment|/* Board TIC to send             */
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* Current priority              */
r_struct
id|st_ram_io
id|st_loc
suffix:semicolon
r_struct
id|mailbox
id|tmpmailbox
suffix:semicolon
macro_line|#ifdef DEBUG
r_int
id|c
suffix:semicolon
macro_line|#endif
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ne
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
op_plus
r_sizeof
(paren
r_struct
id|mailbox
)paren
)paren
(brace
r_static
r_int
id|warncount
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|warncount
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Hmmm. write() of Applicom card, length %d != expected %d&bslash;n&quot;
comma
id|count
comma
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
op_plus
r_sizeof
(paren
r_struct
id|mailbox
)paren
)paren
suffix:semicolon
id|warncount
op_decrement
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|st_loc
comma
id|buf
comma
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmpmailbox
comma
op_amp
id|buf
(braket
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
)braket
comma
r_sizeof
(paren
r_struct
id|mailbox
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|NumCard
op_assign
id|st_loc.num_card
suffix:semicolon
multiline_comment|/* board number to send          */
id|TicCard
op_assign
id|st_loc.tic_des_from_pc
suffix:semicolon
multiline_comment|/* tic number to send            */
id|IndexCard
op_assign
id|NumCard
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|NumCard
OL
l_int|1
)paren
op_logical_or
(paren
id|NumCard
OG
id|MAX_BOARD
)paren
op_logical_or
op_logical_neg
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Write to applicom card #%d. struct st_ram_io follows:&quot;
comma
id|IndexCard
op_plus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
OL
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
suffix:semicolon
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n%5.5X: %2.2X&quot;
comma
id|c
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|st_loc
)paren
(braket
id|c
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|c
op_increment
suffix:semicolon
id|c
op_mod
l_int|8
op_logical_and
id|c
OL
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
suffix:semicolon
id|c
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %2.2X&quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|st_loc
)paren
(braket
id|c
)braket
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nstruct mailbox follows:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
OL
r_sizeof
(paren
r_struct
id|mailbox
)paren
suffix:semicolon
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n%5.5X: %2.2X&quot;
comma
id|c
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|tmpmailbox
)paren
(braket
id|c
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|c
op_increment
suffix:semicolon
id|c
op_mod
l_int|8
op_logical_and
id|c
OL
r_sizeof
(paren
r_struct
id|mailbox
)paren
suffix:semicolon
id|c
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %2.2X&quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|tmpmailbox
)paren
(braket
id|c
)braket
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|spin_lock_irqsave
c_func
(paren
op_amp
id|apbs
(braket
id|IndexCard
)braket
dot
id|mutex
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Test octet ready correct */
r_if
c_cond
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|DATA_FROM_PC_READY
)paren
OG
l_int|2
)paren
(brace
id|Dummy
op_assign
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|VERS
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|apbs
(braket
id|IndexCard
)braket
dot
id|mutex
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;APPLICOM driver write error board %d, DataFromPcReady = %d&bslash;n&quot;
comma
id|IndexCard
comma
(paren
r_int
)paren
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|DATA_FROM_PC_READY
)paren
)paren
suffix:semicolon
id|DeviceErrorCount
op_increment
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Place ourselves on the wait queue */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|apbs
(braket
id|IndexCard
)braket
dot
id|FlagSleepSend
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* Check whether the card is ready for us */
r_while
c_loop
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|DATA_FROM_PC_READY
)paren
op_ne
l_int|0
)paren
(brace
id|Dummy
op_assign
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|VERS
)paren
suffix:semicolon
multiline_comment|/* It&squot;s busy. Sleep. */
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|apbs
(braket
id|IndexCard
)braket
dot
id|mutex
comma
id|flags
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|apbs
(braket
id|IndexCard
)braket
dot
id|FlagSleepSend
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|apbs
(braket
id|IndexCard
)braket
dot
id|mutex
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* We may not have actually slept */
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|apbs
(braket
id|IndexCard
)braket
dot
id|FlagSleepSend
comma
op_amp
id|wait
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|1
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|DATA_FROM_PC_READY
)paren
suffix:semicolon
multiline_comment|/* Which is best - lock down the pages with rawio and then&n;&t;   copy directly, or use bounce buffers? For now we do the latter &n;&t;   because it works with 2.2 still */
(brace
r_int
r_char
op_star
id|from
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|tmpmailbox
suffix:semicolon
r_int
r_int
id|to
op_assign
(paren
r_int
r_int
)paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|RAM_FROM_PC
suffix:semicolon
r_int
id|c
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
OL
r_sizeof
(paren
r_struct
id|mailbox
)paren
suffix:semicolon
id|c
op_increment
)paren
id|writeb
c_func
(paren
op_star
(paren
id|from
op_increment
)paren
comma
id|to
op_increment
)paren
suffix:semicolon
)brace
id|writeb
c_func
(paren
l_int|0x20
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|TIC_OWNER_FROM_PC
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0xff
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|NUMCARD_OWNER_FROM_PC
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|TicCard
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|TIC_DES_FROM_PC
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|NumCard
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|NUMCARD_DES_FROM_PC
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|2
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|DATA_FROM_PC_READY
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|1
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|RAM_IT_FROM_PC
)paren
suffix:semicolon
id|Dummy
op_assign
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|VERS
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|apbs
(braket
id|IndexCard
)braket
dot
id|mutex
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|do_ac_read
r_static
r_int
id|do_ac_read
c_func
(paren
r_int
id|IndexCard
comma
r_char
op_star
id|buf
)paren
(brace
r_struct
id|st_ram_io
id|st_loc
suffix:semicolon
r_struct
id|mailbox
id|tmpmailbox
suffix:semicolon
multiline_comment|/* bounce buffer - can&squot;t copy to user space with cli() */
r_int
r_int
id|from
op_assign
(paren
r_int
r_int
)paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|RAM_TO_PC
suffix:semicolon
r_int
r_char
op_star
id|to
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|tmpmailbox
suffix:semicolon
macro_line|#ifdef DEBUG
r_int
id|c
suffix:semicolon
macro_line|#endif
id|st_loc.tic_owner_to_pc
op_assign
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|TIC_OWNER_TO_PC
)paren
suffix:semicolon
id|st_loc.numcard_owner_to_pc
op_assign
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|NUMCARD_OWNER_TO_PC
)paren
suffix:semicolon
(brace
r_int
id|c
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
OL
r_sizeof
(paren
r_struct
id|mailbox
)paren
suffix:semicolon
id|c
op_increment
)paren
op_star
(paren
id|to
op_increment
)paren
op_assign
id|readb
c_func
(paren
id|from
op_increment
)paren
suffix:semicolon
)brace
id|writeb
c_func
(paren
l_int|1
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|ACK_FROM_PC_READY
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|1
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|TYP_ACK_FROM_PC
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|IndexCard
op_plus
l_int|1
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|NUMCARD_ACK_FROM_PC
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|TIC_OWNER_TO_PC
)paren
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|TIC_ACK_FROM_PC
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|2
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|ACK_FROM_PC_READY
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|DATA_TO_PC_READY
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|2
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|RAM_IT_FROM_PC
)paren
suffix:semicolon
id|Dummy
op_assign
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|VERS
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;Read from applicom card #%d. struct st_ram_io follows:&quot;
comma
id|NumCard
)paren
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
OL
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
suffix:semicolon
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n%5.5X: %2.2X&quot;
comma
id|c
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|st_loc
)paren
(braket
id|c
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|c
op_increment
suffix:semicolon
id|c
op_mod
l_int|8
op_logical_and
id|c
OL
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
suffix:semicolon
id|c
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %2.2X&quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|st_loc
)paren
(braket
id|c
)braket
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nstruct mailbox follows:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|c
op_assign
l_int|0
suffix:semicolon
id|c
OL
r_sizeof
(paren
r_struct
id|mailbox
)paren
suffix:semicolon
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n%5.5X: %2.2X&quot;
comma
id|c
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|tmpmailbox
)paren
(braket
id|c
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|c
op_increment
suffix:semicolon
id|c
op_mod
l_int|8
op_logical_and
id|c
OL
r_sizeof
(paren
r_struct
id|mailbox
)paren
suffix:semicolon
id|c
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %2.2X&quot;
comma
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|tmpmailbox
)paren
(braket
id|c
)braket
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Je suis stupide. DW. */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|buf
comma
op_amp
id|st_loc
comma
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
op_amp
id|buf
(braket
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
)braket
comma
op_amp
id|tmpmailbox
comma
r_sizeof
(paren
r_struct
id|mailbox
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
(paren
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
op_plus
r_sizeof
(paren
r_struct
id|mailbox
)paren
)paren
suffix:semicolon
)brace
DECL|function|ac_read
r_static
id|ssize_t
id|ac_read
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ptr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
r_char
id|tmp
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_int
id|loopcount
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* No need to ratelimit this. Only root can trigger it anyway */
r_if
c_cond
(paren
id|count
op_ne
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
op_plus
r_sizeof
(paren
r_struct
id|mailbox
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Hmmm. read() of Applicom card, length %d != expected %d&bslash;n&quot;
comma
id|count
comma
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
op_plus
r_sizeof
(paren
r_struct
id|mailbox
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* Stick ourself on the wait queue */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|FlagSleepRec
comma
op_amp
id|wait
)paren
suffix:semicolon
multiline_comment|/* Scan each board, looking for one which has a packet for us */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_BOARD
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|apbs
(braket
id|i
)braket
dot
id|RamIO
)paren
r_continue
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|apbs
(braket
id|i
)braket
dot
id|mutex
comma
id|flags
)paren
suffix:semicolon
id|tmp
op_assign
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|DATA_TO_PC_READY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_eq
l_int|2
)paren
(brace
multiline_comment|/* Got a packet for us */
id|ret
op_assign
id|do_ac_read
c_func
(paren
id|i
comma
id|buf
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|apbs
(braket
id|i
)braket
dot
id|mutex
comma
id|flags
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|FlagSleepRec
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp
OG
l_int|2
)paren
(brace
multiline_comment|/* Got an error */
id|Dummy
op_assign
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|VERS
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|apbs
(braket
id|i
)braket
dot
id|mutex
comma
id|flags
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|FlagSleepRec
comma
op_amp
id|wait
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;APPLICOM driver read error board %d, DataToPcReady = %d&bslash;n&quot;
comma
id|i
comma
(paren
r_int
)paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|DATA_TO_PC_READY
)paren
)paren
suffix:semicolon
id|DeviceErrorCount
op_increment
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Nothing for us. Try the next board */
id|Dummy
op_assign
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|VERS
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|apbs
(braket
id|i
)braket
dot
id|mutex
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* per board */
multiline_comment|/* OK - No boards had data for us. Sleep now */
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|FlagSleepRec
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|loopcount
op_increment
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Looping in ac_read. loopcount %d&bslash;n&quot;
comma
id|loopcount
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
)brace
DECL|function|ac_interrupt
r_static
r_void
id|ac_interrupt
c_func
(paren
r_int
id|vec
comma
r_void
op_star
id|dev_instance
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|FlagInt
suffix:semicolon
r_int
r_int
id|LoopCount
suffix:semicolon
singleline_comment|//    printk(&quot;Applicom interrupt on IRQ %d occurred&bslash;n&quot;, vec);
id|LoopCount
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|FlagInt
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_BOARD
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Skip if this board doesn&squot;t exist */
r_if
c_cond
(paren
op_logical_neg
id|apbs
(braket
id|i
)braket
dot
id|RamIO
)paren
r_continue
suffix:semicolon
id|spin_lock
c_func
(paren
op_amp
id|apbs
(braket
id|i
)braket
dot
id|mutex
)paren
suffix:semicolon
multiline_comment|/* Skip if this board doesn&squot;t want attention */
r_if
c_cond
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|RAM_IT_TO_PC
)paren
op_eq
l_int|0
)paren
(brace
id|spin_unlock
c_func
(paren
op_amp
id|apbs
(braket
id|i
)braket
dot
id|mutex
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|FlagInt
op_assign
l_int|1
suffix:semicolon
id|writeb
c_func
(paren
l_int|0
comma
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|RAM_IT_TO_PC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|DATA_TO_PC_READY
)paren
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;APPLICOM driver interrupt err board %d, DataToPcReady = %d&bslash;n&quot;
comma
id|i
op_plus
l_int|1
comma
(paren
r_int
)paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|DATA_TO_PC_READY
)paren
)paren
suffix:semicolon
id|DeviceErrorCount
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|DATA_FROM_PC_READY
)paren
OG
l_int|2
)paren
op_logical_and
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|DATA_FROM_PC_READY
)paren
op_ne
l_int|6
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;APPLICOM driver interrupt err board %d, DataFromPcReady = %d&bslash;n&quot;
comma
id|i
op_plus
l_int|1
comma
(paren
r_int
)paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|DATA_FROM_PC_READY
)paren
)paren
suffix:semicolon
id|DeviceErrorCount
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|DATA_TO_PC_READY
)paren
op_eq
l_int|2
)paren
(brace
multiline_comment|/* mailbox sent by the card ?   */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|FlagSleepRec
)paren
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|FlagSleepRec
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|DATA_FROM_PC_READY
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* ram i/o free for write by pc ? */
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|apbs
(braket
id|i
)braket
dot
id|FlagSleepSend
)paren
)paren
(brace
multiline_comment|/* process sleep during read ?    */
id|wake_up_interruptible
c_func
(paren
op_amp
id|apbs
(braket
id|i
)braket
dot
id|FlagSleepSend
)paren
suffix:semicolon
)brace
)brace
id|Dummy
op_assign
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|VERS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|RAM_IT_TO_PC
)paren
)paren
(brace
multiline_comment|/* There&squot;s another int waiting on this card */
id|spin_unlock
c_func
(paren
op_amp
id|apbs
(braket
id|i
)braket
dot
id|mutex
)paren
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|spin_unlock
c_func
(paren
op_amp
id|apbs
(braket
id|i
)braket
dot
id|mutex
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|FlagInt
)paren
id|LoopCount
op_assign
l_int|0
suffix:semicolon
r_else
id|LoopCount
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
id|LoopCount
OL
l_int|2
)paren
(brace
suffix:semicolon
)brace
)brace
DECL|function|ac_ioctl
r_static
r_int
id|ac_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
multiline_comment|/* @ ADG ou ATO selon le cas */
r_int
id|i
suffix:semicolon
r_int
r_char
id|IndexCard
suffix:semicolon
r_int
r_int
id|pmem
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
r_volatile
r_int
r_char
id|byte_reset_it
suffix:semicolon
r_struct
id|st_ram_io
op_star
id|adgl
suffix:semicolon
multiline_comment|/* In general, the device is only openable by root anyway, so we&squot;re not&n;&t;   particularly concerned that bogus ioctls can flood the console. */
id|adgl
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|adgl
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|adgl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
)paren
)paren
(brace
id|kfree
c_func
(paren
id|adgl
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|IndexCard
op_assign
id|adgl-&gt;num_card
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
l_int|0
op_logical_and
id|cmd
op_ne
l_int|6
op_logical_and
(paren
(paren
id|IndexCard
op_ge
id|MAX_BOARD
)paren
op_logical_or
op_logical_neg
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
)paren
)paren
(brace
r_static
r_int
id|warncount
op_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|warncount
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;APPLICOM driver IOCTL, bad board number %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|IndexCard
op_plus
l_int|1
)paren
suffix:semicolon
id|warncount
op_decrement
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|adgl
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
l_int|0
suffix:colon
id|pmem
op_assign
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
suffix:semicolon
id|i
op_increment
)paren
(paren
(paren
r_int
r_char
op_star
)paren
id|adgl
)paren
(braket
id|i
)braket
op_assign
id|readb
c_func
(paren
id|pmem
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|adgl
comma
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|pmem
op_assign
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|CONF_END_TEST
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|adgl-&gt;conf_end_test
(braket
id|i
)braket
op_assign
id|readb
c_func
(paren
id|pmem
op_increment
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|adgl-&gt;error_code
(braket
id|i
)braket
op_assign
id|readb
c_func
(paren
id|pmem
op_increment
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|adgl-&gt;parameter_error
(braket
id|i
)braket
op_assign
id|readb
c_func
(paren
id|pmem
op_increment
)paren
suffix:semicolon
id|pmem
op_assign
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|VERS
suffix:semicolon
id|adgl-&gt;vers
op_assign
id|readb
c_func
(paren
id|pmem
)paren
suffix:semicolon
id|pmem
op_assign
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|TYPE_CARD
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|20
suffix:semicolon
id|i
op_increment
)paren
id|adgl-&gt;reserv1
(braket
id|i
)braket
op_assign
id|readb
c_func
(paren
id|pmem
op_increment
)paren
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
op_amp
id|adgl-&gt;reserv1
(braket
l_int|20
)braket
op_assign
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|SERIAL_NUMBER
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|SERIAL_NUMBER
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_plus
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|SERIAL_NUMBER
op_plus
l_int|2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|adgl
comma
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|pmem
op_assign
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|CONF_END_TEST
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
id|writeb
c_func
(paren
l_int|0xff
comma
id|pmem
op_increment
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|adgl-&gt;data_from_pc_ready
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|DATA_FROM_PC_READY
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|1
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|RAM_IT_FROM_PC
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_BOARD
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
)paren
(brace
id|byte_reset_it
op_assign
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|RAM_IT_TO_PC
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|pmem
op_assign
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|TIC_DES_FROM_PC
suffix:semicolon
id|writeb
c_func
(paren
id|adgl-&gt;tic_des_from_pc
comma
id|pmem
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|pmem
op_assign
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|TIC_OWNER_TO_PC
suffix:semicolon
id|adgl-&gt;tic_owner_to_pc
op_assign
id|readb
c_func
(paren
id|pmem
op_increment
)paren
suffix:semicolon
id|adgl-&gt;numcard_owner_to_pc
op_assign
id|readb
c_func
(paren
id|pmem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|adgl
comma
r_sizeof
(paren
r_struct
id|st_ram_io
)paren
)paren
)paren
id|ret
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|writeb
c_func
(paren
id|adgl-&gt;num_card
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|NUMCARD_OWNER_TO_PC
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|adgl-&gt;num_card
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|NUMCARD_DES_FROM_PC
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|adgl-&gt;num_card
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|NUMCARD_ACK_FROM_PC
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|4
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|DATA_FROM_PC_READY
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|1
comma
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|RAM_IT_FROM_PC
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;APPLICOM driver release .... V2.8.0 ($Revision: 1.30 $)&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Number of installed boards . %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|numboards
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Segment of board ........... %X&bslash;n&quot;
comma
(paren
r_int
)paren
id|mem
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Interrupt IRQ number ....... %d&bslash;n&quot;
comma
(paren
r_int
)paren
id|irq
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_BOARD
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|serial
suffix:semicolon
r_char
id|boardname
(braket
(paren
id|SERIAL_NUMBER
op_minus
id|TYPE_CARD
)paren
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|apbs
(braket
id|i
)braket
dot
id|RamIO
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|serial
op_assign
l_int|0
suffix:semicolon
id|serial
OL
id|SERIAL_NUMBER
op_minus
id|TYPE_CARD
suffix:semicolon
id|serial
op_increment
)paren
id|boardname
(braket
id|serial
)braket
op_assign
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|TYPE_CARD
op_plus
id|serial
)paren
suffix:semicolon
id|boardname
(braket
id|serial
)braket
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Prom version board %d ....... V%d.%d %s&quot;
comma
id|i
op_plus
l_int|1
comma
(paren
r_int
)paren
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|VERS
)paren
op_rshift
l_int|4
)paren
comma
(paren
r_int
)paren
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|VERS
)paren
op_amp
l_int|0xF
)paren
comma
id|boardname
)paren
suffix:semicolon
id|serial
op_assign
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|SERIAL_NUMBER
)paren
op_lshift
l_int|16
)paren
op_plus
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|SERIAL_NUMBER
op_plus
l_int|1
)paren
op_lshift
l_int|8
)paren
op_plus
(paren
id|readb
c_func
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_plus
id|SERIAL_NUMBER
op_plus
l_int|2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|serial
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot; S/N %d&bslash;n&quot;
comma
id|serial
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DeviceErrorCount
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;DeviceErrorCount ........... %d&bslash;n&quot;
comma
id|DeviceErrorCount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReadErrorCount
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ReadErrorCount ............. %d&bslash;n&quot;
comma
id|ReadErrorCount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|WriteErrorCount
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;WriteErrorCount ............ %d&bslash;n&quot;
comma
id|WriteErrorCount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|FlagSleepRec
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Process in read pending&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_BOARD
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|apbs
(braket
id|i
)braket
dot
id|RamIO
op_logical_and
id|waitqueue_active
c_func
(paren
op_amp
id|apbs
(braket
id|i
)braket
dot
id|FlagSleepSend
)paren
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Process in write pending board %d&bslash;n&quot;
comma
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;APPLICOM driver ioctl, unknown function code %d&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|Dummy
op_assign
id|readb
c_func
(paren
id|apbs
(braket
id|IndexCard
)braket
dot
id|RamIO
op_plus
id|VERS
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|adgl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifndef MODULE
DECL|function|applicom_setup
r_static
r_int
id|__init
id|applicom_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
l_int|4
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|str
comma
l_int|4
comma
id|ints
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Too many arguments to &squot;applicom=&squot;, expected mem,irq only.&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;applicom numargs: %d&bslash;n&quot;
comma
id|ints
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mem
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;applicom=&quot;
comma
id|applicom_setup
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;/* MODULE */
eof
