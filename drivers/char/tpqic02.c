multiline_comment|/* $Id: tpqic02.c,v 1.10 1997/01/26 07:13:20 davem Exp $&n; *&n; * Driver for tape drive support for Linux-i386&n; *&n; * Copyright (c) 1992--1996 by H. H. Bergman. All rights reserved.&n; * Current e-mail address: hennus@cybercomm.nl&n; *&n; * Distribution of this program in executable form is only allowed if&n; * all of the corresponding source files are made available through the same&n; * medium at no extra cost.&n; *&n; * I will not accept any responsibility for damage caused directly or&n; * indirectly by this program, or code derived from this program.&n; *&n; * Use this code at your own risk. Don&squot;t blame me if it destroys your data!&n; * Make sure you have a backup before you try this code.&n; *&n; * If you make changes to my code and redistribute it in source or binary&n; * form you must make it clear to even casual users of your code that you&n; * have modified my code, clearly point out what the changes exactly are&n; * (preferably in the form of a context diff file), how to undo your changes,&n; * where the original can be obtained, and that complaints/requests about the&n; * modified code should be directed to you instead of me.&n; *&n; * This driver was partially inspired by the &squot;wt&squot; driver in the 386BSD&n; * source distribution, which carries the following copyright notice:&n; *&n; *  Copyright (c) 1991 The Regents of the University of California.&n; *  All rights reserved.&n; *&n; * You are not allowed to change this line nor the text above.&n; *&n; * 1996/10/10   Emerald changes&n; *&n; * 1996/05/21&t;Misc changes+merges+cleanups + I/O reservations&n; *&n; * 1996/05/20&t;Module support patches submitted by Brian McCauley.&n; *&n; * 1994/05/03&t;Initial attempt at Mountain support for the Mountain 7150.&n; * Based on patches provided by Erik Jacobson. Still incomplete, I suppose.&n; *&n; * 1994/02/07&t;Archive changes &amp; some cleanups by Eddy Olk.&n; *&n; * 1994/01/19&t;Speed measuring stuff moved from aperf.h to delay.h.&n; *&t;&t;BogoMips (tm) introduced by Linus.&n; *&n; * 1993/01/25&t;Kernel udelay. Eof fixups.&n; * &n; * 1992/09/19&t;Some changes based on patches by Eddy Olk to support&n; * &t;&t;Archive SC402/SC499R controller cards.&n; *&n; * 1992/05/27&t;First release.&n; *&n; * 1992/05/26&t;Initial version. Copyright H. H. Bergman 1992&n; */
multiline_comment|/* After the legalese, now the important bits:&n; * &n; * This is a driver for the Wangtek 5150 tape drive with &n; * a QIC-02 controller for ISA-PC type computers.&n; * Hopefully it will work with other QIC-02 tape drives as well.&n; *&n; * Make sure your setup matches the configuration parameters.&n; * Also, be careful to avoid IO conflicts with other devices!&n; */
multiline_comment|/*&n;#define TDEBUG&n;*/
DECL|macro|REALLY_SLOW_IO
mdefine_line|#define REALLY_SLOW_IO&t;&t;/* it sure is ... */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/mtio.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/tpqic02.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt; 
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
multiline_comment|/* check existence of required configuration parameters */
macro_line|#if !defined(QIC02_CMD_PORT) || !defined(QIC02_TAPE_IRQ) || !defined(QIC02_TAPE_DMA)
macro_line|# error qic02_tape configuration error
macro_line|#endif
DECL|macro|TPQIC02_NAME
mdefine_line|#define TPQIC02_NAME&t;&quot;tpqic02&quot;
multiline_comment|/* Linux outb() commands have (value,port) as parameters.&n; * One might expect (port,value) instead, so beware!&n; */
macro_line|#ifdef CONFIG_QIC02_DYNCONF
multiline_comment|/* This holds the dynamic configuration info for the interface&n; * card+drive info if runtime configuration has been selected.&n; */
DECL|variable|qic02_tape_dynconf
r_static
r_struct
id|mtconfiginfo
id|qic02_tape_dynconf
op_assign
multiline_comment|/* user settable */
(brace
l_int|0
comma
l_int|0
comma
id|BOGUS_IRQ
comma
l_int|0
comma
l_int|0
comma
id|TPQD_DEFAULT_FLAGS
comma
)brace
suffix:semicolon
DECL|variable|qic02_tape_ccb
r_static
r_struct
id|qic02_ccb
id|qic02_tape_ccb
suffix:semicolon
multiline_comment|/* private stuff */
macro_line|#else
DECL|variable|qic02_tape_debug
r_int
r_int
id|qic02_tape_debug
op_assign
id|TPQD_DEFAULT_FLAGS
suffix:semicolon
macro_line|# if ((QIC02_TAPE_IFC!=WANGTEK) &amp;&amp; (QIC02_TAPE_IFC!=ARCHIVE) &amp;&amp; (QIC02_TAPE_IFC!=MOUNTAIN))
macro_line|#  error No valid interface card specified
macro_line|# endif
macro_line|#endif /* CONFIG_QIC02_DYNCONF */
DECL|variable|ctlbits
r_static
r_volatile
r_int
id|ctlbits
suffix:semicolon
multiline_comment|/* control reg bits for tape interface */
DECL|variable|qic02_tape_transfer
r_static
id|wait_queue_head_t
id|qic02_tape_transfer
suffix:semicolon
multiline_comment|/* sync rw with interrupts */
DECL|variable|ioctl_status
r_static
r_volatile
r_struct
id|mtget
id|ioctl_status
suffix:semicolon
multiline_comment|/* current generic status */
DECL|variable|tperror
r_static
r_volatile
r_struct
id|tpstatus
id|tperror
suffix:semicolon
multiline_comment|/* last drive status */
DECL|variable|rcs_revision
r_static
r_char
id|rcs_revision
(braket
)braket
op_assign
l_string|&quot;$Revision: 1.10 $&quot;
suffix:semicolon
DECL|variable|rcs_date
r_static
r_char
id|rcs_date
(braket
)braket
op_assign
l_string|&quot;$Date: 1997/01/26 07:13:20 $&quot;
suffix:semicolon
multiline_comment|/* Flag bits for status and outstanding requests.&n; * (Could all be put in one bit-field-struct.)&n; * Some variables need `volatile&squot; because they may be modified&n; * by an interrupt.&n; */
DECL|variable|status_dead
r_static
r_volatile
id|flag
id|status_dead
op_assign
id|YES
suffix:semicolon
multiline_comment|/* device is legally dead until proven alive */
DECL|variable|status_zombie
r_static
id|flag
id|status_zombie
op_assign
id|YES
suffix:semicolon
multiline_comment|/* it&squot;s `zombie&squot; until irq/dma allocated */
DECL|variable|status_bytes_wr
r_static
r_volatile
id|flag
id|status_bytes_wr
op_assign
id|NO
suffix:semicolon
multiline_comment|/* write FM at close or not */
DECL|variable|status_bytes_rd
r_static
r_volatile
id|flag
id|status_bytes_rd
op_assign
id|NO
suffix:semicolon
multiline_comment|/* (rd|wr) used for rewinding */
DECL|variable|status_cmd_pending
r_static
r_volatile
r_int
r_int
id|status_cmd_pending
suffix:semicolon
multiline_comment|/* cmd in progress */
DECL|variable|status_expect_int
r_static
r_volatile
id|flag
id|status_expect_int
op_assign
id|NO
suffix:semicolon
multiline_comment|/* ready for interrupts */
DECL|variable|status_timer_on
r_static
r_volatile
id|flag
id|status_timer_on
op_assign
id|NO
suffix:semicolon
multiline_comment|/* using time-out */
DECL|variable|status_error
r_static
r_volatile
r_int
id|status_error
suffix:semicolon
multiline_comment|/* int handler may detect error */
DECL|variable|status_eof_detected
r_static
r_volatile
id|flag
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
multiline_comment|/* end of file */
DECL|variable|status_eom_detected
r_static
r_volatile
id|flag
id|status_eom_detected
op_assign
id|NO
suffix:semicolon
multiline_comment|/* end of recorded media */
DECL|variable|status_eot_detected
r_static
r_volatile
id|flag
id|status_eot_detected
op_assign
id|NO
suffix:semicolon
multiline_comment|/* end of tape */
DECL|variable|doing_read
r_static
r_volatile
id|flag
id|doing_read
op_assign
id|NO
suffix:semicolon
DECL|variable|doing_write
r_static
r_volatile
id|flag
id|doing_write
op_assign
id|NO
suffix:semicolon
DECL|variable|dma_bytes_todo
r_static
r_volatile
r_int
r_int
id|dma_bytes_todo
suffix:semicolon
DECL|variable|dma_bytes_done
r_static
r_volatile
r_int
r_int
id|dma_bytes_done
suffix:semicolon
DECL|variable|dma_mode
r_static
r_volatile
r_int
id|dma_mode
suffix:semicolon
multiline_comment|/* !=0 also means DMA in use */
DECL|variable|need_rewind
r_static
id|flag
id|need_rewind
op_assign
id|YES
suffix:semicolon
DECL|variable|current_tape_dev
r_static
id|kdev_t
id|current_tape_dev
suffix:semicolon
DECL|variable|extra_blocks_left
r_static
r_int
id|extra_blocks_left
op_assign
id|BLOCKS_BEYOND_EW
suffix:semicolon
DECL|variable|tp_timer
r_static
r_struct
id|timer_list
id|tp_timer
suffix:semicolon
multiline_comment|/* return_*_eof:&n; *&t;NO:&t;not at EOF,&n; *&t;YES:&t;tell app EOF was reached (return 0).&n; *&n; * return_*_eof==YES &amp;&amp; reported_*_eof==NO  ==&gt;&n; *&t;return current buffer, next time(s) return EOF.&n; *&n; * return_*_eof==YES &amp;&amp; reported_*_eof==YES  ==&gt;&n; *&t;at EOF and application knows it, so we can&n; *&t;move on to the next file.&n; *&n; */
DECL|variable|return_read_eof
r_static
id|flag
id|return_read_eof
op_assign
id|NO
suffix:semicolon
multiline_comment|/* set to signal app EOF was reached */
DECL|variable|return_write_eof
r_static
id|flag
id|return_write_eof
op_assign
id|NO
suffix:semicolon
DECL|variable|reported_read_eof
r_static
id|flag
id|reported_read_eof
op_assign
id|NO
suffix:semicolon
multiline_comment|/* set when we&squot;ve done that */
DECL|variable|reported_write_eof
r_static
id|flag
id|reported_write_eof
op_assign
id|NO
suffix:semicolon
multiline_comment|/* This is for doing `mt seek &lt;blocknr&gt;&squot; */
DECL|variable|seek_addr_buf
r_static
r_char
id|seek_addr_buf
(braket
id|AR_SEEK_BUF_SIZE
)braket
suffix:semicolon
multiline_comment|/* In write mode, we have to write a File Mark after the last block written, &n; * when the tape device is closed. Tape repositioning and reading in write&n; * mode is allowed as long as no actual writing has been done. After writing&n; * the File Mark, repositioning and reading are allowed again.&n; */
DECL|variable|mode_access
r_static
r_int
id|mode_access
suffix:semicolon
multiline_comment|/* access mode: READ or WRITE */
r_static
r_int
id|qic02_get_resources
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|qic02_release_resources
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* This is a pointer to the actual kernel buffer where the interrupt routines&n; * read from/write to. It is needed because the DMA channels 1 and 3 cannot&n; * always access the user buffers. [The kernel buffer must reside in the&n; * lower 16MBytes of system memory because of the DMA controller.] The user&n; * must ensure that a large enough buffer is passed to the kernel, in order&n; * to reduce tape repositioning wear and tear.&n; */
DECL|variable|buffaddr
r_static
r_int
r_int
id|buffaddr
suffix:semicolon
multiline_comment|/* physical address of buffer */
multiline_comment|/* This translates minor numbers to the corresponding recording format: */
DECL|variable|format_names
r_static
r_const
r_char
op_star
id|format_names
(braket
)braket
op_assign
(brace
l_string|&quot;not set&quot;
comma
multiline_comment|/* for dumb drives unable to handle format selection */
l_string|&quot;11&quot;
comma
multiline_comment|/* extinct */
l_string|&quot;24&quot;
comma
l_string|&quot;120&quot;
comma
l_string|&quot;150&quot;
comma
l_string|&quot;300&quot;
comma
multiline_comment|/* untested. */
l_string|&quot;600&quot;
multiline_comment|/* untested. */
)brace
suffix:semicolon
multiline_comment|/* `exception_list&squot; is needed for exception status reporting.&n; * Exceptions 1..14 are defined by QIC-02 rev F.&n; * The drive status is matched sequentially to each entry,&n; * ignoring irrelevant bits, until a match is found. If no&n; * match is found, exception number 0 is used. (That should of&n; * course never happen...) The original table was based on the&n; * &quot;Exception Status Summary&quot; in QIC-02 rev F, but some changes&n; * were required to make it work with real-world drives.&n; *&n; * Exception 2 (CNI) is changed to also cover status 0x00e0 (mask USL),&n; * Exception 4 (EOM) is changed to also cover status 0x8288 (mask EOR),&n; * Exception 11 (FIL) is changed to also cover status 0x0089 (mask EOM).&n; * Exception 15 (EOR) is added for seek-to-end-of-data (catch EOR),&n; * Exception 16 (BOM) is added for beginning-of-media (catch BOM).&n; *&n; * Had to swap EXC_NDRV and EXC_NCART to ensure that extended EXC_NCART&n; * (because of the incorrect Wangtek status code) doesn&squot;t catch the&n; * EXC_NDRV first.&n; */
DECL|struct|exception_list_type
r_static
r_struct
id|exception_list_type
(brace
DECL|member|mask
DECL|member|code
r_int
r_int
id|mask
comma
id|code
suffix:semicolon
DECL|member|msg
r_const
r_char
op_star
id|msg
suffix:semicolon
multiline_comment|/* EXC_nr attribute should match with tpqic02.h */
DECL|variable|exception_list
)brace
id|exception_list
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
comma
l_string|&quot;Unknown exception status code&quot;
comma
multiline_comment|/* extra: 0 */
)brace
comma
(brace
op_complement
(paren
l_int|0
)paren
comma
id|TP_ST0
op_or
id|TP_CNI
op_or
id|TP_USL
op_or
id|TP_WRP
comma
l_string|&quot;Drive not online&quot;
multiline_comment|/* 1 */
)brace
comma
multiline_comment|/* Drive presence goes before cartridge presence. */
(brace
op_complement
(paren
id|TP_WRP
op_or
id|TP_USL
)paren
comma
id|TP_ST0
op_or
id|TP_CNI
comma
multiline_comment|/* My Wangtek 5150EQ sometimes reports a status code&n;&t;&t; * of 0x00e0, which is not a valid exception code, but&n;&t;&t; * I think it should be recognized as &quot;NO CARTRIDGE&quot;.&n;&t;&t; */
l_string|&quot;Cartridge not in place&quot;
multiline_comment|/* 2 */
)brace
comma
(brace
(paren
r_int
r_int
)paren
op_complement
(paren
id|TP_ST1
op_or
id|TP_BOM
)paren
comma
(paren
id|TP_ST0
op_or
id|TP_WRP
)paren
comma
l_string|&quot;Write protected cartridge&quot;
multiline_comment|/* 3 */
)brace
comma
(brace
(paren
r_int
r_int
)paren
op_complement
(paren
id|TP_ST1
op_or
id|TP_EOR
)paren
comma
(paren
id|TP_ST0
op_or
id|TP_EOM
)paren
comma
l_string|&quot;End of media&quot;
multiline_comment|/* 4 */
)brace
comma
(brace
op_complement
id|TP_WRP
comma
id|TP_ST0
op_or
id|TP_UDA
op_or
id|TP_ST1
op_or
id|TP_BOM
comma
l_string|&quot;Read or Write abort. Rewind tape.&quot;
multiline_comment|/* 5 */
)brace
comma
(brace
op_complement
id|TP_WRP
comma
id|TP_ST0
op_or
id|TP_UDA
comma
l_string|&quot;Read error. Bad block transferred.&quot;
multiline_comment|/* 6 */
)brace
comma
(brace
op_complement
id|TP_WRP
comma
id|TP_ST0
op_or
id|TP_UDA
op_or
id|TP_BNL
comma
l_string|&quot;Read error. Filler block transferred.&quot;
multiline_comment|/* 7 */
)brace
comma
(brace
op_complement
id|TP_WRP
comma
id|TP_ST0
op_or
id|TP_UDA
op_or
id|TP_BNL
op_or
id|TP_ST1
op_or
id|TP_NDT
comma
l_string|&quot;Read error. No data detected.&quot;
multiline_comment|/* 8 */
)brace
comma
(brace
op_complement
id|TP_WRP
comma
id|TP_ST0
op_or
id|TP_EOM
op_or
id|TP_UDA
op_or
id|TP_BNL
op_or
id|TP_ST1
op_or
id|TP_NDT
comma
l_string|&quot;Read error. No data detected. EOM.&quot;
multiline_comment|/* 9 */
)brace
comma
(brace
op_complement
(paren
id|TP_WRP
op_or
id|TP_MBD
op_or
id|TP_PAR
op_or
id|TP_EOR
)paren
comma
id|TP_ST0
op_or
id|TP_UDA
op_or
id|TP_BNL
op_or
id|TP_ST1
op_or
id|TP_NDT
op_or
id|TP_BOM
comma
l_string|&quot;Read error. No data detected. BOM.&quot;
multiline_comment|/* 10 */
)brace
comma
(brace
op_complement
(paren
id|TP_WRP
op_or
id|TP_EOM
)paren
comma
id|TP_ST0
op_or
id|TP_FIL
comma
multiline_comment|/* Status 0x0089 (EOM &amp; FM) is viewed as an FM,&n;&t;&t; * because it can only happen during a read.&n;&t;&t; * EOM is checked separately for an FM condition.&n;&t;&t; */
l_string|&quot;File mark detected&quot;
multiline_comment|/* 11 */
)brace
comma
(brace
op_complement
(paren
id|TP_ST0
op_or
id|TP_CNI
op_or
id|TP_USL
op_or
id|TP_WRP
op_or
id|TP_BOM
)paren
comma
id|TP_ST1
op_or
id|TP_ILL
comma
l_string|&quot;Illegal command&quot;
multiline_comment|/* 12 */
)brace
comma
(brace
op_complement
(paren
id|TP_ST0
op_or
id|TP_CNI
op_or
id|TP_USL
op_or
id|TP_WRP
op_or
id|TP_BOM
)paren
comma
id|TP_ST1
op_or
id|TP_POR
comma
l_string|&quot;Reset occurred&quot;
multiline_comment|/* 13 */
)brace
comma
(brace
op_complement
id|TP_WRP
comma
id|TP_ST0
op_or
id|TP_FIL
op_or
id|TP_MBD
comma
multiline_comment|/* NOTE: ST1 not set! */
l_string|&quot;Marginal block detected&quot;
multiline_comment|/* 14 */
)brace
comma
(brace
op_complement
(paren
id|TP_ST0
op_or
id|TP_WRP
op_or
id|TP_EOM
op_or
id|TP_UDA
op_or
id|TP_BNL
op_or
id|TP_FIL
op_or
id|TP_NDT
)paren
comma
id|TP_ST1
op_or
id|TP_EOR
comma
multiline_comment|/********** Is the extra TP_NDT really needed Eddy? **********/
l_string|&quot;End of recorded media&quot;
multiline_comment|/* extra: 15 */
)brace
comma
multiline_comment|/* 15 is returned when SEEKEOD completes successfully */
(brace
op_complement
(paren
id|TP_WRP
op_or
id|TP_ST0
)paren
comma
id|TP_ST1
op_or
id|TP_BOM
comma
l_string|&quot;Beginning of media&quot;
multiline_comment|/* extra: 16 */
)brace
)brace
suffix:semicolon
DECL|macro|NR_OF_EXC
mdefine_line|#define NR_OF_EXC&t;(sizeof(exception_list)/sizeof(struct exception_list_type))
multiline_comment|/* Compare expected struct size and actual struct size. This&n; * is useful to catch programs compiled with old #includes.&n; */
DECL|macro|CHECK_IOC_SIZE
mdefine_line|#define CHECK_IOC_SIZE(structure) &bslash;&n;&t;if (_IOC_SIZE(iocmd) != sizeof(struct structure)) { &bslash;&n;&t;&t;tpqputs(TPQD_ALWAYS, &quot;sizeof(struct &quot; #structure &bslash;&n;&t;&t;&t;&quot;) does not match!&quot;); &bslash;&n;&t;&t;return -EFAULT; &bslash;&n;&t;} &bslash;&n;
DECL|function|tpqputs
r_static
r_void
id|tpqputs
c_func
(paren
r_int
r_int
id|flags
comma
r_const
r_char
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|TPQD_ALWAYS
)paren
op_logical_or
(paren
id|flags
op_amp
id|QIC02_TAPE_DEBUG
)paren
)paren
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: %s&bslash;n&quot;
comma
id|s
)paren
suffix:semicolon
)brace
multiline_comment|/* tpqputs */
multiline_comment|/* Perform byte order swapping for a 16-bit word.&n; *&n; * [FIXME] This should probably be in include/asm/&n; * ([FIXME] i486 can do this faster)&n; */
DECL|function|byte_swap_w
r_static
r_inline
r_void
id|byte_swap_w
c_func
(paren
r_volatile
r_int
r_int
op_star
id|w
)paren
(brace
r_int
id|t
op_assign
op_star
id|w
suffix:semicolon
op_star
id|w
op_assign
(paren
id|t
op_rshift
l_int|8
)paren
op_or
(paren
(paren
id|t
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/* Init control register bits on interface card.&n; * For Archive, interrupts must be enabled explicitly.&n; * Wangtek interface card requires ONLINE to be set, Archive SC402/SC499R&n; * cards keep it active all the time.&n; */
DECL|function|ifc_init
r_static
r_void
id|ifc_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|WANGTEK
)paren
multiline_comment|/* || (QIC02_TAPE_IFC == EVEREX) */
(brace
id|ctlbits
op_assign
id|WT_CTL_ONLINE
suffix:semicolon
multiline_comment|/* online */
id|outb_p
c_func
(paren
id|ctlbits
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|ARCHIVE
)paren
(brace
id|ctlbits
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* no interrupts yet */
id|outb_p
c_func
(paren
id|ctlbits
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
id|AR_RESET_DMA_PORT
)paren
suffix:semicolon
multiline_comment|/* dummy write to reset DMA */
)brace
r_else
multiline_comment|/* MOUNTAIN */
(brace
id|ctlbits
op_assign
id|MTN_CTL_ONLINE
suffix:semicolon
multiline_comment|/* online, and logic enabled */
id|outb_p
c_func
(paren
id|ctlbits
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* ifc_init */
DECL|function|report_qic_exception
r_static
r_void
id|report_qic_exception
c_func
(paren
r_int
id|n
)paren
(brace
r_if
c_cond
(paren
id|n
op_ge
id|NR_OF_EXC
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Oops -- report_qic_exception&quot;
)paren
suffix:semicolon
id|n
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TPQDBG
c_func
(paren
id|SENSE_TEXT
)paren
op_logical_or
id|n
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: sense: %s&bslash;n&quot;
comma
id|exception_list
(braket
id|n
)braket
dot
id|msg
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* report_qic_exception */
multiline_comment|/* Try to map the drive-exception bits `s&squot; to a predefined &quot;exception number&quot;,&n; * by comparing the significant exception bits for each entry in the&n; * exception table (`exception_list[]&squot;).&n; * It is assumed that s!=0.&n; */
DECL|function|decode_qic_exception_nr
r_static
r_int
id|decode_qic_exception_nr
c_func
(paren
r_int
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|NR_OF_EXC
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|s
op_amp
id|exception_list
(braket
id|i
)braket
dot
id|mask
)paren
op_eq
id|exception_list
(braket
id|i
)braket
dot
id|code
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: decode_qic_exception_nr: exception(%x) not recognized&bslash;n&quot;
comma
id|s
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* decode_qic_exception_nr */
multiline_comment|/* Perform appropriate action for certain exceptions.&n; * should return a value to indicate stop/continue (in case of bad blocks)&n; */
DECL|function|handle_qic_exception
r_static
r_void
id|handle_qic_exception
c_func
(paren
r_int
id|exnr
comma
r_int
id|exbits
)paren
(brace
r_if
c_cond
(paren
id|exnr
op_eq
id|EXC_NCART
)paren
(brace
multiline_comment|/* Cartridge was changed. Redo sense().&n;&t; * EXC_NCART should be handled in open().&n;&t; * It is not permitted to remove the tape while&n;&t; * the tape driver has open files. &n;&t; */
id|need_rewind
op_assign
id|YES
suffix:semicolon
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
id|status_eom_detected
op_assign
id|NO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|exnr
op_eq
id|EXC_XFILLER
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;[Bad block -- filler data transferred.]&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|exnr
op_eq
id|EXC_XBAD
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;[CRC failed!]&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|exnr
op_eq
id|EXC_MARGINAL
)paren
(brace
multiline_comment|/* A marginal block behaves much like a FM.&n;&t; * User may continue reading, if desired.&n;&t; */
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;[Marginal block]&quot;
)paren
suffix:semicolon
id|doing_read
op_assign
id|NO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|exnr
op_eq
id|EXC_FM
)paren
(brace
id|doing_read
op_assign
id|NO
suffix:semicolon
)brace
)brace
multiline_comment|/* handle_qic_exception */
DECL|function|is_exception
r_static
r_inline
r_int
id|is_exception
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|QIC02_STAT_PORT
)paren
op_amp
id|QIC02_STAT_EXCEPTION
)paren
op_eq
l_int|0
suffix:semicolon
)brace
multiline_comment|/* is_exception */
multiline_comment|/* Reset the tape drive and controller.&n; * When reset fails, it marks  the drive as dead and all&n; * requests (except reset) are to be ignored (ENXIO).&n; */
DECL|function|tape_reset
r_static
r_int
id|tape_reset
c_func
(paren
r_int
id|verbose
)paren
(brace
id|ifc_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* reset interface card */
multiline_comment|/* assert reset */
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|MOUNTAIN
)paren
(brace
id|outb_p
c_func
(paren
id|ctlbits
op_amp
op_complement
id|MTN_QIC02_CTL_RESET_NOT
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* WANGTEK, ARCHIVE */
(brace
id|outb_p
c_func
(paren
id|ctlbits
op_or
id|QIC02_CTL_RESET
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
)brace
multiline_comment|/* Next, we need to wait &gt;=25 usec. */
id|udelay
c_func
(paren
l_int|30
)paren
suffix:semicolon
multiline_comment|/* after reset, we will be at BOT (modulo an automatic rewind) */
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
id|status_eom_detected
op_assign
id|NO
suffix:semicolon
id|status_cmd_pending
op_assign
l_int|0
suffix:semicolon
id|need_rewind
op_assign
id|YES
suffix:semicolon
id|doing_read
op_assign
id|doing_write
op_assign
id|NO
suffix:semicolon
id|ioctl_status.mt_fileno
op_assign
id|ioctl_status.mt_blkno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* de-assert reset */
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|MOUNTAIN
)paren
(brace
id|outb_p
c_func
(paren
id|ctlbits
op_or
id|MTN_QIC02_CTL_RESET_NOT
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
)brace
r_else
(brace
id|outb_p
c_func
(paren
id|ctlbits
op_amp
op_complement
id|QIC02_CTL_RESET
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
)brace
multiline_comment|/* KLUDGE FOR G++ BUG */
(brace
r_int
id|stat
op_assign
id|inb_p
c_func
(paren
id|QIC02_STAT_PORT
)paren
suffix:semicolon
id|status_dead
op_assign
(paren
(paren
id|stat
op_amp
id|QIC02_STAT_RESETMASK
)paren
op_ne
id|QIC02_STAT_RESETVAL
)paren
suffix:semicolon
)brace
multiline_comment|/* if successful, inb(STAT) returned RESETVAL */
r_if
c_cond
(paren
id|status_dead
op_eq
id|YES
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: reset failed!&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|verbose
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: reset successful&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
(paren
id|status_dead
op_eq
id|YES
)paren
ques
c_cond
id|TE_DEAD
suffix:colon
id|TE_OK
suffix:semicolon
)brace
multiline_comment|/* tape_reset */
multiline_comment|/* Notify tape drive of a new command. It only waits for the&n; * command to be accepted, not for the actual command to complete.&n; *&n; * Before calling this routine, QIC02_CMD_PORT must have been loaded&n; * with the command to be executed.&n; * After this routine, the exception bit must be checked.&n; * This routine is also used by rdstatus(), so in that case, any exception&n; * must be ignored (`ignore_ex&squot; flag).&n; */
DECL|function|notify_cmd
r_static
r_int
id|notify_cmd
c_func
(paren
r_char
id|cmd
comma
r_int
id|ignore_ex
)paren
(brace
r_int
id|i
suffix:semicolon
id|outb_p
c_func
(paren
id|cmd
comma
id|QIC02_CMD_PORT
)paren
suffix:semicolon
multiline_comment|/* output the command */
multiline_comment|/* wait 1 usec before asserting /REQUEST */
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|ignore_ex
)paren
op_logical_and
id|is_exception
c_func
(paren
)paren
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;*** exception detected in notify_cmd&quot;
)paren
suffix:semicolon
multiline_comment|/** force a reset here **/
r_if
c_cond
(paren
id|tape_reset
c_func
(paren
l_int|1
)paren
op_eq
id|TE_DEAD
)paren
r_return
id|TE_DEAD
suffix:semicolon
r_if
c_cond
(paren
id|is_exception
c_func
(paren
)paren
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;exception persists after reset.&quot;
)paren
suffix:semicolon
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot; ^ exception ignored.&quot;
)paren
suffix:semicolon
)brace
)brace
id|outb_p
c_func
(paren
id|ctlbits
op_or
id|QIC02_CTL_REQUEST
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
multiline_comment|/* set request bit */
id|i
op_assign
id|TAPE_NOTIFY_TIMEOUT
suffix:semicolon
multiline_comment|/* The specs say this takes about 500 usec, but there is no upper limit!&n;&t; * If the drive were busy retensioning or something like that,&n;&t; * it could be *much* longer!&n;&t; */
r_while
c_loop
(paren
(paren
id|inb_p
c_func
(paren
id|QIC02_STAT_PORT
)paren
op_amp
id|QIC02_STAT_READY
)paren
op_logical_and
(paren
op_decrement
id|i
OG
l_int|0
)paren
)paren
multiline_comment|/*skip*/
suffix:semicolon
multiline_comment|/* wait for ready */
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;timed out waiting for ready in notify_cmd&quot;
)paren
suffix:semicolon
id|status_dead
op_assign
id|YES
suffix:semicolon
r_return
id|TE_TIM
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|ctlbits
op_amp
op_complement
id|QIC02_CTL_REQUEST
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
multiline_comment|/* reset request bit */
id|i
op_assign
id|TAPE_NOTIFY_TIMEOUT
suffix:semicolon
multiline_comment|/* according to the specs this one should never time-out */
r_while
c_loop
(paren
(paren
(paren
id|inb_p
c_func
(paren
id|QIC02_STAT_PORT
)paren
op_amp
id|QIC02_STAT_READY
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
op_decrement
id|i
OG
l_int|0
)paren
)paren
multiline_comment|/*skip*/
suffix:semicolon
multiline_comment|/* wait for not ready */
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;timed out waiting for !ready in notify_cmd&quot;
)paren
suffix:semicolon
id|status_dead
op_assign
id|YES
suffix:semicolon
r_return
id|TE_TIM
suffix:semicolon
)brace
multiline_comment|/* command accepted */
r_return
id|TE_OK
suffix:semicolon
)brace
multiline_comment|/* notify_cmd */
multiline_comment|/* Wait for a command to complete, with timeout */
DECL|function|wait_for_ready
r_static
r_int
id|wait_for_ready
c_func
(paren
id|time_t
id|timeout
)paren
(brace
r_int
id|stat
suffix:semicolon
id|time_t
id|spin_t
suffix:semicolon
multiline_comment|/* Wait for ready or exception, without driving the loadavg up too much.&n;&t; * In most cases, the tape drive already has READY asserted,&n;&t; * so optimize for that case.&n;&t; *&n;&t; * First, busy wait a few usec:&n;&t; */
id|spin_t
op_assign
l_int|50
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|inb_p
c_func
(paren
id|QIC02_STAT_PORT
)paren
op_amp
id|QIC02_STAT_MASK
)paren
op_eq
id|QIC02_STAT_MASK
)paren
op_logical_and
(paren
op_decrement
id|spin_t
OG
l_int|0
)paren
)paren
multiline_comment|/*SKIP*/
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|QIC02_STAT_READY
)paren
op_eq
l_int|0
)paren
r_return
id|TE_OK
suffix:semicolon
multiline_comment|/* covers 99.99% of all calls */
multiline_comment|/* Then use schedule() a few times */
id|spin_t
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* max 0.03 sec busy waiting */
r_if
c_cond
(paren
id|spin_t
OG
id|timeout
)paren
id|spin_t
op_assign
id|timeout
suffix:semicolon
id|timeout
op_sub_assign
id|spin_t
suffix:semicolon
id|spin_t
op_add_assign
id|jiffies
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|inb_p
c_func
(paren
id|QIC02_STAT_PORT
)paren
op_amp
id|QIC02_STAT_MASK
)paren
op_eq
id|QIC02_STAT_MASK
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|spin_t
)paren
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* don&squot;t waste all the CPU time */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|QIC02_STAT_READY
)paren
op_eq
l_int|0
)paren
r_return
id|TE_OK
suffix:semicolon
multiline_comment|/* If we reach this point, we probably need to wait much longer, or&n;&t; * an exception occurred. Either case is not very time-critical.&n;&t; * Check the status port only a few times every second.&n;&t; * A interval of less than 0.10 sec will not be noticed by the user,&n;&t; * more than 0.40 sec may give noticeable delays.&n;&t; */
id|spin_t
op_add_assign
id|timeout
suffix:semicolon
id|TPQDEB
c_func
(paren
(brace
id|printk
c_func
(paren
l_string|&quot;wait_for_ready: additional timeout: %d&bslash;n&quot;
comma
id|spin_t
)paren
suffix:semicolon
)brace
)paren
multiline_comment|/* not ready and no exception &amp;&amp; timeout not expired yet */
r_while
c_loop
(paren
(paren
(paren
id|stat
op_assign
id|inb_p
c_func
(paren
id|QIC02_STAT_PORT
)paren
op_amp
id|QIC02_STAT_MASK
)paren
op_eq
id|QIC02_STAT_MASK
)paren
op_logical_and
id|time_before
c_func
(paren
id|jiffies
comma
id|spin_t
)paren
)paren
(brace
multiline_comment|/* be `nice` to other processes on long operations... */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
multiline_comment|/* nap 0.30 sec between checks, */
multiline_comment|/* but could be woken up earlier by signals... */
id|schedule_timeout
c_func
(paren
l_int|3
op_star
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
)brace
multiline_comment|/* don&squot;t use jiffies for this test because it may have changed by now */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|QIC02_STAT_MASK
)paren
op_eq
id|QIC02_STAT_MASK
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;wait_for_ready() timed out&quot;
)paren
suffix:semicolon
r_return
id|TE_TIM
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|QIC02_STAT_EXCEPTION
)paren
op_eq
l_int|0
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;exception detected after waiting_for_ready&quot;
)paren
suffix:semicolon
r_return
id|TE_EX
suffix:semicolon
)brace
r_else
(brace
r_return
id|TE_OK
suffix:semicolon
)brace
)brace
multiline_comment|/* wait_for_ready */
multiline_comment|/* Send some data to the drive */
DECL|function|send_qic02_data
r_static
r_int
id|send_qic02_data
c_func
(paren
r_char
id|sb
(braket
)braket
comma
r_int
id|size
comma
r_int
id|ignore_ex
)paren
(brace
r_int
id|i
comma
id|stat
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|stat
op_assign
id|wait_for_ready
c_func
(paren
id|TIM_S
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_ne
id|TE_OK
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|notify_cmd
c_func
(paren
id|sb
(braket
id|i
)braket
comma
id|ignore_ex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_ne
id|TE_OK
)paren
r_return
id|stat
suffix:semicolon
)brace
r_return
id|TE_OK
suffix:semicolon
)brace
multiline_comment|/* send_qic02_data */
multiline_comment|/* Send a QIC-02 command (`cmd&squot;) to the tape drive, with&n; * a time-out (`timeout&squot;).&n; * This one is also used by tp_sense(), so we must have&n; * a flag to disable exception checking (`ignore_ex&squot;). &n; *&n; * On entry, the controller is supposed to be READY.&n; */
DECL|function|send_qic02_cmd
r_static
r_int
id|send_qic02_cmd
c_func
(paren
r_int
id|cmd
comma
id|time_t
id|timeout
comma
r_int
id|ignore_ex
)paren
(brace
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|inb_p
c_func
(paren
id|QIC02_STAT_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|QIC02_STAT_EXCEPTION
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* if exception */
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;send_qic02_cmd: Exception!&quot;
)paren
suffix:semicolon
r_return
id|TE_EX
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_amp
id|QIC02_STAT_READY
)paren
(brace
multiline_comment|/* if not ready */
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;send_qic02_cmd: not Ready!&quot;
)paren
suffix:semicolon
r_return
id|TE_ERR
suffix:semicolon
)brace
multiline_comment|/* assert(ready &amp; !exception) */
multiline_comment|/* Remember current command for later re-use with dma transfers.&n;&t; * (For reading/writing multiple blocks.)&n;&t; */
id|status_cmd_pending
op_assign
id|cmd
suffix:semicolon
id|stat
op_assign
id|notify_cmd
c_func
(paren
id|cmd
comma
id|ignore_ex
)paren
suffix:semicolon
multiline_comment|/* tell drive new command was loaded, */
multiline_comment|/* inherit exception check. */
r_if
c_cond
(paren
id|TP_HAVE_SEEK
op_logical_and
(paren
id|cmd
op_eq
id|AR_QCMDV_SEEK_BLK
)paren
)paren
(brace
multiline_comment|/* This one needs to send 3 more bytes, MSB first */
id|stat
op_assign
id|send_qic02_data
c_func
(paren
id|seek_addr_buf
comma
r_sizeof
(paren
id|seek_addr_buf
)paren
comma
id|ignore_ex
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_ne
id|TE_OK
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;send_qic02_cmd failed&quot;
)paren
suffix:semicolon
)brace
r_return
id|stat
suffix:semicolon
)brace
multiline_comment|/* send_qic02_cmd */
multiline_comment|/* Get drive status. Assume drive is ready or has exception set.&n; * (or will be in &lt;1000 usec.)&n; * Extra parameters added because of &squot;Read Extended Status 3&squot; command.&n; */
DECL|function|rdstatus
r_static
r_int
id|rdstatus
c_func
(paren
r_char
op_star
id|stp
comma
r_int
id|size
comma
r_char
id|qcmd
)paren
(brace
r_int
id|s
comma
id|n
suffix:semicolon
r_char
op_star
id|q
op_assign
id|stp
suffix:semicolon
multiline_comment|/* Try to busy-wait a few (700) usec, after that de-schedule.&n;&t; *&n;&t; * The problem is, if we don&squot;t de-schedule, performance will&n;&t; * drop to zero when the drive is not responding and if we&n;&t; * de-schedule immediately, we waste a lot of time because a&n;&t; * task switch is much longer than we usually have to wait here.&n;&t; */
id|n
op_assign
l_int|1000
suffix:semicolon
multiline_comment|/* 500 is not enough on a 486/33 */
r_while
c_loop
(paren
(paren
id|n
OG
l_int|0
)paren
op_logical_and
(paren
(paren
id|inb_p
c_func
(paren
id|QIC02_STAT_PORT
)paren
op_amp
id|QIC02_STAT_MASK
)paren
op_eq
id|QIC02_STAT_MASK
)paren
)paren
id|n
op_decrement
suffix:semicolon
multiline_comment|/* wait for ready or exception or timeout */
r_if
c_cond
(paren
id|n
op_eq
l_int|0
)paren
(brace
multiline_comment|/* n (above) should be chosen such that on your machine&n;&t;&t; * you rarely ever see the message below, and it should&n;&t;&t; * be small enough to give reasonable response time.]&n;&t;&t; */
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;waiting looong in rdstatus() -- drive dead?&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|inb_p
c_func
(paren
id|QIC02_STAT_PORT
)paren
op_amp
id|QIC02_STAT_MASK
)paren
op_eq
id|QIC02_STAT_MASK
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;finished waiting in rdstatus()&quot;
)paren
suffix:semicolon
)brace
(paren
r_void
)paren
id|notify_cmd
c_func
(paren
id|qcmd
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* send read status command */
multiline_comment|/* ignore return code -- should always be ok, STAT may contain &n;&t; * exception flag from previous exception which we are trying to clear.&n;&t; */
r_if
c_cond
(paren
id|TP_DIAGS
c_func
(paren
id|current_tape_dev
)paren
)paren
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: reading status bytes: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|q
op_assign
id|stp
suffix:semicolon
id|q
OL
id|stp
op_plus
id|size
suffix:semicolon
id|q
op_increment
)paren
(brace
r_do
id|s
op_assign
id|inb_p
c_func
(paren
id|QIC02_STAT_PORT
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|s
op_amp
id|QIC02_STAT_MASK
)paren
op_eq
id|QIC02_STAT_MASK
)paren
suffix:semicolon
multiline_comment|/* wait for ready or exception */
r_if
c_cond
(paren
(paren
id|s
op_amp
id|QIC02_STAT_EXCEPTION
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* if exception */
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;rdstatus: exception error&quot;
)paren
suffix:semicolon
id|ioctl_status.mt_erreg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* dunno... */
r_return
id|TE_NS
suffix:semicolon
multiline_comment|/* error, shouldn&squot;t happen... */
)brace
op_star
id|q
op_assign
id|inb_p
c_func
(paren
id|QIC02_DATA_PORT
)paren
suffix:semicolon
multiline_comment|/* read status byte */
r_if
c_cond
(paren
id|TP_DIAGS
c_func
(paren
id|current_tape_dev
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;[%1d]=0x%x  &quot;
comma
id|q
op_minus
id|stp
comma
(paren
r_int
)paren
(paren
op_star
id|q
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ctlbits
op_or
id|QIC02_CTL_REQUEST
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
multiline_comment|/* set request */
r_while
c_loop
(paren
(paren
id|inb_p
c_func
(paren
id|QIC02_STAT_PORT
)paren
op_amp
id|QIC02_STAT_READY
)paren
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/* wait for not ready */
id|udelay
c_func
(paren
l_int|22
)paren
suffix:semicolon
multiline_comment|/* delay &gt;20 usec */
id|outb_p
c_func
(paren
id|ctlbits
op_amp
op_complement
id|QIC02_CTL_REQUEST
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
multiline_comment|/* un-set request */
)brace
multiline_comment|/* Specs say we should wait for READY here.&n;&t; * My drive doesn&squot;t seem to need it here yet, but others do?&n;&t; */
r_while
c_loop
(paren
id|inb_p
c_func
(paren
id|QIC02_STAT_PORT
)paren
op_amp
id|QIC02_STAT_READY
)paren
multiline_comment|/*skip*/
suffix:semicolon
multiline_comment|/* wait for ready */
r_if
c_cond
(paren
id|TP_DIAGS
c_func
(paren
id|current_tape_dev
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|TE_OK
suffix:semicolon
)brace
multiline_comment|/* rdstatus */
multiline_comment|/* Get standard status (6 bytes).&n; * The `.dec&squot; and `.urc&squot; fields are in MSB-first byte-order,&n; * so they have to be swapped first.&n; */
DECL|function|get_status
r_static
r_int
id|get_status
c_func
(paren
r_volatile
r_struct
id|tpstatus
op_star
id|stp
)paren
(brace
r_int
id|stat
op_assign
id|rdstatus
c_func
(paren
(paren
r_char
op_star
)paren
id|stp
comma
id|TPSTATSIZE
comma
id|QCMD_RD_STAT
)paren
suffix:semicolon
macro_line|#ifdef __i386__
id|byte_swap_w
c_func
(paren
op_amp
(paren
id|stp-&gt;dec
)paren
)paren
suffix:semicolon
id|byte_swap_w
c_func
(paren
op_amp
(paren
id|stp-&gt;urc
)paren
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* should probably swap status bytes #definition */
macro_line|#endif
r_return
id|stat
suffix:semicolon
)brace
multiline_comment|/* get_status */
macro_line|#if 0
multiline_comment|/* This fails for my Wangtek drive */
multiline_comment|/* get &quot;Extended Status Register 3&quot; (64 bytes)&n; *&n; * If the meaning of the returned bytes were known, the MT_TYPE&n; * identifier could be used to decode them, since they are&n; * &quot;vendor unique&quot;. :-(&n; */
r_static
r_int
id|get_ext_status3
c_func
(paren
r_void
)paren
(brace
r_char
id|vus
(braket
l_int|64
)braket
suffix:semicolon
multiline_comment|/* vendor unique status */
r_int
id|stat
comma
id|i
suffix:semicolon
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Attempting to read Extended Status 3...&quot;
)paren
suffix:semicolon
id|stat
op_assign
id|rdstatus
c_func
(paren
id|vus
comma
r_sizeof
(paren
id|vus
)paren
comma
id|QCMD_RD_STAT_X3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_ne
id|TE_OK
)paren
r_return
id|stat
suffix:semicolon
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Returned status bytes:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|vus
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_mod
l_int|8
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
id|TPQIC02_NAME
l_string|&quot;: %2d:&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %2x&quot;
comma
id|vus
(braket
id|i
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|TE_OK
suffix:semicolon
)brace
multiline_comment|/* get_ext_status3 */
macro_line|#endif
multiline_comment|/* Read drive status and set generic status too.&n; * NOTE: Once we do a tp_sense(), read/write transfers are killed.&n; */
DECL|function|tp_sense
r_static
r_int
id|tp_sense
c_func
(paren
r_int
id|ignore
)paren
(brace
r_int
id|err
op_assign
l_int|0
comma
id|exnr
op_assign
l_int|0
comma
id|gs
op_assign
l_int|0
suffix:semicolon
r_static
r_void
id|finish_rw
c_func
(paren
r_int
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TPQDBG
c_func
(paren
id|SENSE_TEXT
)paren
)paren
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: tp_sense(ignore=0x%x) enter&bslash;n&quot;
comma
id|ignore
)paren
suffix:semicolon
multiline_comment|/* sense() is not allowed during a read or write cycle */
r_if
c_cond
(paren
id|doing_write
op_eq
id|YES
)paren
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Warning: File Mark inserted because of sense() request&quot;
)paren
suffix:semicolon
multiline_comment|/* The extra test is to avoid calling finish_rw during booting */
r_if
c_cond
(paren
(paren
id|doing_read
op_ne
id|NO
)paren
op_logical_or
(paren
id|doing_write
op_ne
id|NO
)paren
)paren
id|finish_rw
c_func
(paren
id|QCMD_RD_STAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_status
c_func
(paren
op_amp
id|tperror
)paren
op_ne
id|TE_OK
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;tp_sense: could not read tape drive status&quot;
)paren
suffix:semicolon
r_return
id|TE_ERR
suffix:semicolon
)brace
id|err
op_assign
id|tperror.exs
suffix:semicolon
multiline_comment|/* get exception status bits */
r_if
c_cond
(paren
id|err
op_amp
(paren
id|TP_ST0
op_or
id|TP_ST1
)paren
)paren
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: tp_sense: status: %x, error count: %d, underruns: %d&bslash;n&quot;
comma
id|tperror.exs
comma
id|tperror.dec
comma
id|tperror.urc
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|tperror.dec
op_ne
l_int|0
)paren
op_logical_or
(paren
id|tperror.urc
op_ne
l_int|0
)paren
op_logical_or
id|TPQDBG
c_func
(paren
id|SENSE_CNTS
)paren
)paren
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: tp_sense: no hard errors, soft error count: %d, underruns: %d&bslash;n&quot;
comma
id|tperror.dec
comma
id|tperror.urc
)paren
suffix:semicolon
multiline_comment|/* Set generic status. HP-UX defines these, but some extra would &n;&t; * be useful. Problem is to remain compatible. [Do we want to be&n;&t; * compatible??]&n;&t; */
r_if
c_cond
(paren
id|err
op_amp
id|TP_ST0
)paren
(brace
r_if
c_cond
(paren
id|err
op_amp
id|TP_CNI
)paren
multiline_comment|/* no cartridge */
id|gs
op_or_assign
id|GMT_DR_OPEN
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status_dead
op_eq
id|NO
)paren
id|gs
op_or_assign
id|GMT_ONLINE
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* always online */
r_if
c_cond
(paren
id|err
op_amp
id|TP_USL
)paren
multiline_comment|/* not online */
id|gs
op_and_assign
op_complement
id|GMT_ONLINE
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|TP_WRP
)paren
id|gs
op_or_assign
id|GMT_WR_PROT
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|TP_EOM
)paren
(brace
multiline_comment|/* end of media */
id|gs
op_or_assign
id|GMT_EOT
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* not sure this is correct for writes */
id|status_eom_detected
op_assign
id|YES
suffix:semicolon
multiline_comment|/* I don&squot;t know whether drive always reports EOF at or before EOM. */
id|status_eof_detected
op_assign
id|YES
suffix:semicolon
)brace
multiline_comment|/** if (err &amp; TP_UDA) &quot;Unrecoverable data error&quot; **/
multiline_comment|/** if (err &amp; TP_BNL) &quot;Bad block not located&quot; **/
r_if
c_cond
(paren
id|err
op_amp
id|TP_FIL
)paren
(brace
id|gs
op_or_assign
id|GMT_EOF
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|status_eof_detected
op_assign
id|YES
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|err
op_amp
id|TP_ST1
)paren
(brace
multiline_comment|/** if (err &amp; TP_ILL) &quot;Illegal command&quot; **/
multiline_comment|/** if (err &amp; TP_NDT) &quot;No data detected&quot; **/
multiline_comment|/** if (err &amp; TP_MBD) &quot;Marginal block detected&quot; **/
r_if
c_cond
(paren
id|err
op_amp
id|TP_BOM
)paren
id|gs
op_or_assign
id|GMT_BOT
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* beginning of tape */
)brace
id|ioctl_status.mt_gstat
op_assign
id|gs
suffix:semicolon
id|ioctl_status.mt_dsreg
op_assign
id|tperror.exs
suffix:semicolon
multiline_comment|/* &quot;drive status&quot; */
id|ioctl_status.mt_erreg
op_assign
id|tperror.dec
suffix:semicolon
multiline_comment|/* &quot;sense key error&quot; */
r_if
c_cond
(paren
id|err
op_amp
(paren
id|TP_ST0
op_or
id|TP_ST1
)paren
)paren
(brace
multiline_comment|/* My Wangtek occasionally reports `status&squot; 1212 which should be ignored. */
id|exnr
op_assign
id|decode_qic_exception_nr
c_func
(paren
id|err
)paren
suffix:semicolon
id|handle_qic_exception
c_func
(paren
id|exnr
comma
id|err
)paren
suffix:semicolon
multiline_comment|/* update driver state wrt drive status */
id|report_qic_exception
c_func
(paren
id|exnr
)paren
suffix:semicolon
)brace
id|err
op_and_assign
op_complement
id|ignore
suffix:semicolon
multiline_comment|/* mask unwanted errors -- not the correct way, use exception nrs?? */
r_if
c_cond
(paren
(paren
(paren
id|err
op_amp
id|TP_ST0
)paren
op_logical_and
(paren
id|err
op_amp
id|REPORT_ERR0
)paren
)paren
op_logical_or
(paren
(paren
id|err
op_amp
id|TP_ST1
)paren
op_logical_and
(paren
id|err
op_amp
id|REPORT_ERR1
)paren
)paren
)paren
r_return
id|TE_ERR
suffix:semicolon
r_return
id|TE_OK
suffix:semicolon
)brace
multiline_comment|/* tp_sense */
multiline_comment|/* Wait for a wind or rewind operation to finish or&n; * to time-out. (May take very long).&n; */
DECL|function|wait_for_rewind
r_static
r_int
id|wait_for_rewind
c_func
(paren
id|time_t
id|timeout
)paren
(brace
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|inb
c_func
(paren
id|QIC02_STAT_PORT
)paren
op_amp
id|QIC02_STAT_MASK
suffix:semicolon
r_if
c_cond
(paren
id|TPQDBG
c_func
(paren
id|REWIND
)paren
)paren
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: Waiting for (re-)wind to finish: stat=0x%x&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
id|stat
op_assign
id|wait_for_ready
c_func
(paren
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_ne
id|TE_OK
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;(re-) winding failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|stat
suffix:semicolon
)brace
multiline_comment|/* wait_for_rewind */
multiline_comment|/* Perform a full QIC02 command, and wait for completion,&n; * check status when done. Complain about exceptions.&n; *&n; * This function should return an OS error code when&n; * something goes wrong, 0 otherwise.&n; */
DECL|function|ll_do_qic_cmd
r_static
r_int
id|ll_do_qic_cmd
c_func
(paren
r_int
id|cmd
comma
id|time_t
id|timeout
)paren
(brace
r_int
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|status_dead
op_eq
id|YES
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Drive is dead. Do a `mt reset`.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* User should do an MTRESET. */
)brace
id|stat
op_assign
id|wait_for_ready
c_func
(paren
id|timeout
)paren
suffix:semicolon
multiline_comment|/* wait for ready or exception */
r_if
c_cond
(paren
id|stat
op_eq
id|TE_EX
)paren
(brace
r_if
c_cond
(paren
id|tp_sense
c_func
(paren
id|TP_WRP
op_or
id|TP_BOM
op_or
id|TP_EOM
op_or
id|TP_FIL
)paren
op_ne
id|TE_OK
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* else nothing to worry about, I hope */
id|stat
op_assign
id|TE_OK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_ne
id|TE_OK
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: ll_do_qic_cmd(%x, %ld) failed&bslash;n&quot;
comma
id|cmd
comma
(paren
r_int
)paren
id|timeout
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#if OBSOLETE
multiline_comment|/* wait for ready since it may not be active immediately after reading status */
r_while
c_loop
(paren
(paren
id|inb_p
c_func
(paren
id|QIC02_STAT_PORT
)paren
op_amp
id|QIC02_STAT_READY
)paren
op_ne
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|stat
op_assign
id|send_qic02_cmd
c_func
(paren
id|cmd
comma
id|timeout
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* (checks for exceptions) */
r_if
c_cond
(paren
id|cmd
op_eq
id|QCMD_RD_FM
)paren
(brace
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
id|ioctl_status.mt_fileno
op_increment
suffix:semicolon
multiline_comment|/* Should update block count as well, but can&squot;t.&n;&t;&t; * Can do a `read address&squot; for some drives, when MTNOP is done.&n;&t;&t; */
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|QCMD_WRT_FM
)paren
(brace
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
id|ioctl_status.mt_fileno
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|QCMD_REWIND
)paren
op_logical_or
(paren
id|cmd
op_eq
id|QCMD_ERASE
)paren
op_logical_or
(paren
id|cmd
op_eq
id|QCMD_RETEN
)paren
)paren
(brace
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
id|status_eom_detected
op_assign
id|NO
suffix:semicolon
id|status_eot_detected
op_assign
id|NO
suffix:semicolon
id|need_rewind
op_assign
id|NO
suffix:semicolon
id|ioctl_status.mt_fileno
op_assign
id|ioctl_status.mt_blkno
op_assign
l_int|0
suffix:semicolon
id|extra_blocks_left
op_assign
id|BLOCKS_BEYOND_EW
suffix:semicolon
id|return_write_eof
op_assign
id|NO
suffix:semicolon
id|return_read_eof
op_assign
id|NO
suffix:semicolon
id|reported_read_eof
op_assign
id|NO
suffix:semicolon
id|reported_write_eof
op_assign
id|NO
suffix:semicolon
)brace
multiline_comment|/* sense() will set eof/eom as required */
r_if
c_cond
(paren
id|stat
op_eq
id|TE_EX
)paren
(brace
r_if
c_cond
(paren
id|tp_sense
c_func
(paren
id|TP_WRP
op_or
id|TP_BOM
op_or
id|TP_EOM
op_or
id|TP_FIL
)paren
op_ne
id|TE_OK
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: Exception persist in ll_do_qic_cmd[1](%x, %ld)&quot;
comma
id|cmd
comma
(paren
r_int
)paren
id|timeout
)paren
suffix:semicolon
id|status_dead
op_assign
id|YES
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* if rdstatus fails too, we&squot;re in trouble */
)brace
)brace
r_else
r_if
c_cond
(paren
id|stat
op_ne
id|TE_OK
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: ll_do_qic_cmd: send_qic02_cmd failed, stat = 0x%x&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/*** -EIO is probably not always appropriate */
)brace
r_if
c_cond
(paren
id|timeout
op_eq
id|TIM_R
)paren
id|stat
op_assign
id|wait_for_rewind
c_func
(paren
id|timeout
)paren
suffix:semicolon
r_else
id|stat
op_assign
id|wait_for_ready
c_func
(paren
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
id|TE_EX
)paren
(brace
r_if
c_cond
(paren
id|tp_sense
c_func
(paren
(paren
id|cmd
op_eq
id|QCMD_SEEK_EOD
ques
c_cond
multiline_comment|/*****************************/
id|TP_EOR
op_or
id|TP_NDT
op_or
id|TP_UDA
op_or
id|TP_BNL
op_or
id|TP_WRP
op_or
id|TP_BOM
op_or
id|TP_EOM
op_or
id|TP_FIL
suffix:colon
id|TP_WRP
op_or
id|TP_BOM
op_or
id|TP_EOM
op_or
id|TP_FIL
)paren
)paren
op_ne
id|TE_OK
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: Exception persist in ll_do_qic_cmd[2](%x, %ld)&bslash;n&quot;
comma
id|cmd
comma
(paren
r_int
)paren
id|timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
id|QCMD_RD_FM
)paren
id|status_dead
op_assign
id|YES
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* if rdstatus fails too, we&squot;re in trouble */
)brace
)brace
r_else
r_if
c_cond
(paren
id|stat
op_ne
id|TE_OK
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: ll_do_qic_cmd %x: wait failed, stat == 0x%x&bslash;n&quot;
comma
id|cmd
comma
id|stat
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ll_do_qic_cmd */
multiline_comment|/* &n; * Problem: What to do when the user cancels a read/write operation&n; * in-progress?&n; *&n; * &quot;Deactivating ONLINE during a READ also causes the&quot;&n; * &quot;tape to be rewound to BOT.&quot; Ditto for WRITEs, except&n; * a FM is written first. &quot;The host may alternatively terminate&n; * the READ/WRITE command by issuing a RFM/WFM command.&quot;&n; *&n; * For READs:&n; * Neither option will leave the tape positioned where it was.&n; * Another (better?) solution is to terminate the READ by two&n; * subsequent sense() operations, the first to stop the current&n; * READ cycle, the second to clear the `Illegal command&squot; exception,&n; * because the QIC-02 specs didn&squot;t anticipate this. This is&n; * delayed until actually needed, so a tar listing can be aborted&n; * by the user and continued later.&n; * If anybody has a better solution, let me know! [Also, let me&n; * know if your drive (mine is a Wangtek5150EQ) does not accept&n; * this sequence for canceling the read-cycle.]&n; *&n; * For WRITEs it&squot;s simple: Just do a WRITE_FM, leaving the tape&n; * positioned after the FM.&n; */
DECL|function|terminate_read
r_static
r_void
id|terminate_read
c_func
(paren
r_int
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|doing_read
op_eq
id|YES
)paren
(brace
id|doing_read
op_assign
id|NO
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
id|QCMD_RD_FM
)paren
(brace
multiline_comment|/* if the command is a RFM, there is no need to do this&n;&t;&t;&t; * because a RFM will legally terminate the read-cycle.&n;&t;&t;&t; */
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;terminating pending read-cycle&quot;
)paren
suffix:semicolon
multiline_comment|/* I&squot;m not too sure about this part  -- hhb */
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|MOUNTAIN
)paren
(brace
multiline_comment|/* Mountain reference says can terminate by de-asserting online */
id|ctlbits
op_and_assign
op_complement
id|MTN_QIC02_CTL_ONLINE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp_sense
c_func
(paren
id|TP_FIL
op_or
id|TP_EOM
op_or
id|TP_WRP
)paren
op_ne
id|TE_OK
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;finish_rw[read1]: ignore the 2 lines above&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_exception
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|tp_sense
c_func
(paren
id|TP_ILL
op_or
id|TP_FIL
op_or
id|TP_EOM
op_or
id|TP_WRP
)paren
op_ne
id|TE_OK
)paren
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;finish_rw[read2]: read cycle error&quot;
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
multiline_comment|/* terminate_read */
DECL|function|terminate_write
r_static
r_void
id|terminate_write
c_func
(paren
r_int
id|cmd
)paren
(brace
r_int
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|doing_write
op_eq
id|YES
)paren
(brace
id|doing_write
op_assign
id|NO
suffix:semicolon
multiline_comment|/* Finish writing by appending a FileMark at the end. */
r_if
c_cond
(paren
id|cmd
op_ne
id|QCMD_WRT_FM
)paren
(brace
multiline_comment|/* finish off write cycle */
id|stat
op_assign
id|ll_do_qic_cmd
c_func
(paren
id|QCMD_WRT_FM
comma
id|TIM_M
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_ne
id|TE_OK
)paren
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Couldn&squot;t finish write cycle properly&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|tp_sense
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* If there is an EOF token waiting to be returned to&n;&t;&t; * the (writing) application, discard it now.&n;&t;&t; * We could be at EOT, so don&squot;t reset return_write_eof.&n;&t;&t; */
id|reported_write_eof
op_assign
id|YES
suffix:semicolon
)brace
)brace
multiline_comment|/* terminate_write */
multiline_comment|/* terminate read or write cycle because of command `cmd&squot; */
DECL|function|finish_rw
r_static
r_void
id|finish_rw
c_func
(paren
r_int
id|cmd
)paren
(brace
r_if
c_cond
(paren
id|wait_for_ready
c_func
(paren
id|TIM_S
)paren
op_ne
id|TE_OK
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;error: drive not ready in finish_rw() !&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|terminate_read
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|terminate_write
c_func
(paren
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/* finish_rw */
multiline_comment|/* Perform a QIC command through ll_do_qic_cmd().&n; * If necessary, rewind the tape first.&n; * Return an OS error code if something goes wrong, 0 if all is well.&n; */
DECL|function|do_qic_cmd
r_static
r_int
id|do_qic_cmd
c_func
(paren
r_int
id|cmd
comma
id|time_t
id|timeout
)paren
(brace
r_int
id|stat
suffix:semicolon
id|finish_rw
c_func
(paren
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_rewind
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_REWIND
comma
l_string|&quot;Rewinding tape...&quot;
)paren
suffix:semicolon
id|stat
op_assign
id|ll_do_qic_cmd
c_func
(paren
id|QCMD_REWIND
comma
id|TIM_R
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: rewind failed in do_qic_cmd(). stat=0x%2x&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
id|need_rewind
op_assign
id|NO
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|QCMD_REWIND
)paren
multiline_comment|/* don&squot;t wind beyond BOT ;-) */
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|ll_do_qic_cmd
c_func
(paren
id|cmd
comma
id|timeout
)paren
suffix:semicolon
)brace
multiline_comment|/* do_qic_cmd */
multiline_comment|/* Not all ioctls are supported for all drives. Some rely on&n; * optional QIC-02 commands. Check tpqic02.h for configuration.&n; * Some of these commands may require ONLINE to be active.&n; */
DECL|function|do_ioctl_cmd
r_static
r_int
id|do_ioctl_cmd
c_func
(paren
r_int
id|cmd
)paren
(brace
r_int
id|stat
suffix:semicolon
multiline_comment|/* It is not permitted to read or wind the tape after bytes have&n;&t; * been written. It is not permitted to write the tape while in&n;&t; * read mode.&n;&t; * We try to be kind and allow reading again after writing a FM...&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|MTRESET
suffix:colon
multiline_comment|/* reset verbose */
r_return
(paren
id|tape_reset
c_func
(paren
l_int|1
)paren
op_eq
id|TE_OK
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
r_case
id|MTFSF
suffix:colon
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTFSF forward searching filemark&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode_access
op_eq
id|WRITE
)paren
op_logical_and
id|status_bytes_wr
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
id|do_qic_cmd
c_func
(paren
id|QCMD_RD_FM
comma
id|TIM_F
)paren
suffix:semicolon
r_case
id|MTBSF
suffix:colon
r_if
c_cond
(paren
id|TP_HAVE_BSF
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTBSF backward searching filemark -- optional command&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode_access
op_eq
id|WRITE
)paren
op_logical_and
id|status_bytes_wr
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|stat
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_RD_FM_BCK
comma
id|TIM_F
)paren
suffix:semicolon
)brace
r_else
(brace
id|stat
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
id|status_eom_detected
op_assign
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
r_return
id|stat
suffix:semicolon
r_case
id|MTFSR
suffix:colon
r_if
c_cond
(paren
id|TP_HAVE_FSR
)paren
(brace
multiline_comment|/* This is an optional QIC-02 command */
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTFSR forward space record&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode_access
op_eq
id|WRITE
)paren
op_logical_and
id|status_bytes_wr
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|stat
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_SPACE_FWD
comma
id|TIM_F
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/**** fake it by doing a read data block command? ******/
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTFSR not supported&quot;
)paren
suffix:semicolon
id|stat
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
r_return
id|stat
suffix:semicolon
r_case
id|MTBSR
suffix:colon
r_if
c_cond
(paren
id|TP_HAVE_BSR
)paren
(brace
multiline_comment|/* This is an optional QIC-02 command */
multiline_comment|/* we need this for appending files with GNU tar!! */
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTFSR backward space record&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode_access
op_eq
id|WRITE
)paren
op_logical_and
id|status_bytes_wr
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|stat
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_SPACE_BCK
comma
id|TIM_F
)paren
suffix:semicolon
)brace
r_else
(brace
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTBSR not supported&quot;
)paren
suffix:semicolon
id|stat
op_assign
op_minus
id|ENXIO
suffix:semicolon
)brace
id|status_eom_detected
op_assign
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
r_return
id|stat
suffix:semicolon
r_case
id|MTWEOF
suffix:colon
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTWEOF write eof mark&quot;
)paren
suffix:semicolon
multiline_comment|/* Plain GNU mt(1) 2.2 uses read-only mode for writing FM. :-( */
r_if
c_cond
(paren
id|mode_access
op_eq
id|READ
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* allow tape movement after writing FM */
id|status_bytes_rd
op_assign
id|status_bytes_wr
suffix:semicolon
multiline_comment|/* Kludge-O-Matic */
id|status_bytes_wr
op_assign
id|NO
suffix:semicolon
r_return
id|do_qic_cmd
c_func
(paren
id|QCMD_WRT_FM
comma
id|TIM_M
)paren
suffix:semicolon
multiline_comment|/* not sure what to do with status_bytes when WFM should fail */
r_case
id|MTREW
suffix:colon
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTREW rewinding tape&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode_access
op_eq
id|WRITE
)paren
op_logical_and
id|status_bytes_wr
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|status_eom_detected
op_assign
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
r_return
id|do_qic_cmd
c_func
(paren
id|QCMD_REWIND
comma
id|TIM_R
)paren
suffix:semicolon
r_case
id|MTOFFL
suffix:colon
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTOFFL rewinding &amp; going offline&quot;
)paren
suffix:semicolon
multiline_comment|/* Doing a drive select will clear (unlock) the current drive.&n;&t;&t;&t; * But that requires support for multiple drives and locking.&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|mode_access
op_eq
id|WRITE
)paren
op_logical_and
id|status_bytes_wr
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|status_eom_detected
op_assign
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
multiline_comment|/**** do rewind depending on minor bits??? ***/
id|stat
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_REWIND
comma
id|TIM_R
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
r_case
id|MTNOP
suffix:colon
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTNOP setting status only&quot;
)paren
suffix:semicolon
multiline_comment|/********** should do `read position&squot; for drives that support it **********/
r_return
(paren
id|tp_sense
c_func
(paren
op_minus
l_int|1
)paren
op_eq
id|TE_OK
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
multiline_comment|/**** check return codes ****/
r_case
id|MTRETEN
suffix:colon
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTRETEN retension tape&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode_access
op_eq
id|WRITE
)paren
op_logical_and
id|status_bytes_wr
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|status_eom_detected
op_assign
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
r_return
id|do_qic_cmd
c_func
(paren
id|QCMD_RETEN
comma
id|TIM_R
)paren
suffix:semicolon
r_case
id|MTBSFM
suffix:colon
multiline_comment|/* Think think is like MTBSF, except that&n;&t;&t;&t; * we shouldn&squot;t skip the FM. Tricky.&n;&t;&t;&t; * Maybe use RD_FM_BCK, then do a SPACE_FWD?&n;&t;&t;&t; */
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTBSFM not supported&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode_access
op_eq
id|WRITE
)paren
op_logical_and
id|status_bytes_wr
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
r_case
id|MTFSFM
suffix:colon
multiline_comment|/* I think this is like MTFSF, except that&n;&t;&t;&t; * we shouldn&squot;t skip the FM. Tricky.&n;&t;&t;&t; * Maybe use QCMD_RD_DATA until we get a TP_FIL exception?&n;&t;&t;&t; * But then the FM will have been skipped...&n;&t;&t;&t; * Maybe use RD_FM, then RD_FM_BCK, but not all&n;&t;&t;&t; * drives will support that!&n;&t;&t;&t; */
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTFSFM not supported&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode_access
op_eq
id|WRITE
)paren
op_logical_and
id|status_bytes_wr
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
r_case
id|MTEOM
suffix:colon
multiline_comment|/* This should leave the tape ready for appending&n;&t;&t;&t; * another file to the end, such that it would append&n;&t;&t;&t; * after the last FM on tape.&n;&t;&t;&t; */
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTEOM search for End Of recorded Media&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode_access
op_eq
id|WRITE
)paren
op_logical_and
id|status_bytes_wr
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|TP_HAVE_EOD
)paren
(brace
multiline_comment|/* Use faster seeking when possible.&n;&t;&t;&t;&t; * This requires the absence of data beyond the EOM.&n;&t;&t;&t;&t; * It seems that my drive does not always perform the&n;&t;&t;&t;&t; * SEEK_EOD correctly, unless it is preceded by a&n;&t;&t;&t;&t; * rewind command.&n;&t;&t;&t;&t; */
macro_line|# if 0
id|status_eom_detected
op_assign
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
macro_line|# endif
id|stat
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_REWIND
comma
id|TIM_R
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_SEEK_EOD
comma
id|TIM_F
)paren
suffix:semicolon
multiline_comment|/* After a successful seek, TP_EOR should be returned */
)brace
r_else
(brace
multiline_comment|/* else just seek until the drive returns exception &quot;No Data&quot; */
id|stat
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|stat
op_eq
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|status_eom_detected
)paren
)paren
(brace
id|stat
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_RD_FM
comma
id|TIM_F
)paren
suffix:semicolon
multiline_comment|/***** should use MTFSFM here???? ******/
)brace
r_if
c_cond
(paren
id|tperror.exs
op_amp
id|TP_NDT
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|stat
suffix:semicolon
r_case
id|MTERASE
suffix:colon
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTERASE -- ERASE TAPE !&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tperror.exs
op_amp
id|TP_ST0
)paren
op_logical_and
(paren
id|tperror.exs
op_amp
id|TP_WRP
)paren
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Cartridge is write-protected.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
r_else
(brace
id|time_t
id|t
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Plain GNU mt(1) 2.2 erases a tape in O_RDONLY. :-( */
r_if
c_cond
(paren
id|mode_access
op_eq
id|READ
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* give user a few seconds to pull out tape */
r_while
c_loop
(paren
id|jiffies
op_minus
id|t
OL
l_int|4
op_star
id|HZ
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* don&squot;t bother writing filemark first */
id|status_eom_detected
op_assign
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
r_return
id|do_qic_cmd
c_func
(paren
id|QCMD_ERASE
comma
id|TIM_R
)paren
suffix:semicolon
r_case
id|MTRAS1
suffix:colon
r_if
c_cond
(paren
id|TP_HAVE_RAS1
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTRAS1: non-destructive self test&quot;
)paren
suffix:semicolon
id|stat
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_SELF_TST1
comma
id|TIM_R
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_ne
l_int|0
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;RAS1 failed&quot;
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_return
(paren
id|tp_sense
c_func
(paren
l_int|0
)paren
op_eq
id|TE_OK
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* get_ext_status3(); */
)brace
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;RAS1 not supported&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
r_case
id|MTRAS2
suffix:colon
r_if
c_cond
(paren
id|TP_HAVE_RAS2
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTRAS2: destructive self test&quot;
)paren
suffix:semicolon
id|stat
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_SELF_TST2
comma
id|TIM_R
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_ne
l_int|0
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;RAS2 failed&quot;
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_return
(paren
id|tp_sense
c_func
(paren
l_int|0
)paren
op_eq
id|TE_OK
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* get_ext_status3(); */
)brace
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;RAS2 not supported&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
r_case
id|MTSEEK
suffix:colon
r_if
c_cond
(paren
id|TP_HAVE_SEEK
op_logical_and
(paren
id|QIC02_TAPE_IFC
op_eq
id|ARCHIVE
)paren
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTSEEK seeking block&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|mode_access
op_eq
id|WRITE
)paren
op_logical_and
id|status_bytes_wr
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* NOTE: address (24 bits) is in seek_addr_buf[] */
r_return
id|do_qic_cmd
c_func
(paren
id|AR_QCMDV_SEEK_BLK
comma
id|TIM_F
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|ENOTTY
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
)brace
multiline_comment|/* do_ioctl_cmd */
multiline_comment|/* dma_transfer(): This routine is called for every 512 bytes to be read&n; * from/written to the tape controller. Speed is important here!&n; * (There must be enough time left for the hd controller!)&n; * When other devices use DMA they must ensure they use un-interruptible&n; * double byte accesses to the DMA controller. Floppy.c is ok.&n; * Must have interrupts disabled when this function is invoked,&n; * otherwise, the double-byte transfers to the DMA controller will not&n; * be atomic. That could lead to nasty problems when they are interrupted&n; * by other DMA interrupt-routines.&n; *&n; * This routine merely does the least possible to keep&n; * the transfers going:&n; *&t;- set the DMA count register for the next 512 bytes&n; *&t;- adjust the DMA address and page registers&n; *&t;- adjust the timeout&n; *&t;- tell the tape controller to start transferring&n; * We assume the dma address and mode are, and remain, valid.&n; */
DECL|function|dma_transfer
r_static
r_inline
r_void
id|dma_transfer
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|WANGTEK
)paren
multiline_comment|/* or EVEREX */
id|outb_p
c_func
(paren
id|WT_CTL_ONLINE
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
multiline_comment|/* back to normal */
r_else
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|ARCHIVE
)paren
id|outb_p
c_func
(paren
l_int|0
comma
id|AR_RESET_DMA_PORT
)paren
suffix:semicolon
r_else
multiline_comment|/* QIC02_TAPE_IFC == MOUNTAIN */
id|outb_p
c_func
(paren
id|ctlbits
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|QIC02_TAPE_DMA
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|QIC02_TAPE_DMA
comma
id|dma_mode
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|QIC02_TAPE_DMA
comma
id|buffaddr
op_plus
id|dma_bytes_done
)paren
suffix:semicolon
multiline_comment|/* full address */
id|set_dma_count
c_func
(paren
id|QIC02_TAPE_DMA
comma
id|TAPE_BLKSIZE
)paren
suffix:semicolon
multiline_comment|/* start tape DMA controller */
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|WANGTEK
)paren
multiline_comment|/* or EVEREX */
id|outb_p
c_func
(paren
id|WT_CTL_DMA
op_or
id|WT_CTL_ONLINE
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
multiline_comment|/* trigger DMA transfer */
r_else
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|ARCHIVE
)paren
(brace
id|outb_p
c_func
(paren
id|AR_CTL_IEN
op_or
id|AR_CTL_DNIEN
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
multiline_comment|/* enable interrupts again */
id|outb_p
c_func
(paren
l_int|0
comma
id|AR_START_DMA_PORT
)paren
suffix:semicolon
multiline_comment|/* start DMA transfer */
multiline_comment|/* In dma_end() AR_RESET_DMA_PORT is written too. */
)brace
r_else
multiline_comment|/* QIC02_TAPE_IFC == MOUNTAIN */
(brace
id|inb
c_func
(paren
id|MTN_R_DESELECT_DMA_PORT
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|ctlbits
op_or
(paren
id|MTN_CTL_EXC_IEN
op_or
id|MTN_CTL_DNIEN
)paren
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
id|MTN_W_SELECT_DMA_PORT
)paren
suffix:semicolon
multiline_comment|/* start DMA transfer */
r_if
c_cond
(paren
id|dma_mode
op_eq
id|DMA_MODE_WRITE
)paren
id|outb_p
c_func
(paren
l_int|0
comma
id|MTN_W_DMA_WRITE_PORT
)paren
suffix:semicolon
multiline_comment|/* start DMA transfer */
)brace
multiline_comment|/* start computer DMA controller */
id|enable_dma
c_func
(paren
id|QIC02_TAPE_DMA
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* block transfer should start now, jumping to the &n;&t; * interrupt routine when done or an exception was detected.&n;&t; */
)brace
multiline_comment|/* dma_transfer */
multiline_comment|/* start_dma() sets a DMA transfer up between the tape controller and&n; * the kernel qic02_tape_buf buffer.&n; * Normally bytes_todo==dma_bytes_done at the end of a DMA transfer. If not,&n; * a filemark was read, or an attempt to write beyond the End Of Tape &n; * was made. [Or some other bad thing happened.]&n; * Must do a sense() before returning error.&n; */
DECL|function|start_dma
r_static
r_int
id|start_dma
c_func
(paren
r_int
id|mode
comma
r_int
r_int
id|bytes_todo
)paren
multiline_comment|/* assume &squot;bytes_todo&squot;&gt;0 */
(brace
r_int
id|stat
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|tpqputs
c_func
(paren
id|TPQD_DEBUG
comma
l_string|&quot;start_dma() enter&quot;
)paren
suffix:semicolon
id|TPQDEB
c_func
(paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: doing_read==%d, doing_write==%d&bslash;n&quot;
comma
id|doing_read
comma
id|doing_write
)paren
suffix:semicolon
)brace
)paren
id|dma_bytes_done
op_assign
l_int|0
suffix:semicolon
id|dma_bytes_todo
op_assign
id|bytes_todo
suffix:semicolon
id|status_error
op_assign
id|NO
suffix:semicolon
multiline_comment|/* dma_mode!=0 indicates that the dma controller is in use */
id|dma_mode
op_assign
(paren
id|mode
op_eq
id|WRITE
)paren
ques
c_cond
id|DMA_MODE_WRITE
suffix:colon
id|DMA_MODE_READ
suffix:semicolon
multiline_comment|/* Only give READ/WRITE DATA command to tape drive if we haven&squot;t&n;&t; * done that already. Otherwise the drive will rewind to the beginning&n;&t; * of the current file on tape. Any QIC command given other than&n;&t; * R/W FM will break the read/write transfer cycle.&n;&t; * do_qic_cmd() will terminate doing_{read,write}&n;&t; */
r_if
c_cond
(paren
(paren
id|doing_read
op_eq
id|NO
)paren
op_logical_and
(paren
id|doing_write
op_eq
id|NO
)paren
)paren
(brace
multiline_comment|/* First, we have to clear the status -- maybe remove TP_FIL???&n;&t;&t; */
macro_line|#if 0
multiline_comment|/* Next dummy get status is to make sure CNI is valid,&n;                   since we&squot;re only just starting a read/write it doesn&squot;t&n;                   matter some exceptions are cleared by reading the status;&n;                   we&squot;re only interested in CNI and WRP. -Eddy */
id|get_status
c_func
(paren
op_amp
id|tperror
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* TP_CNI should now be handled in open(). -Hennus */
macro_line|#endif
id|stat
op_assign
id|tp_sense
c_func
(paren
(paren
(paren
id|mode
op_eq
id|WRITE
)paren
ques
c_cond
l_int|0
suffix:colon
id|TP_WRP
)paren
op_or
id|TP_BOM
op_or
id|TP_FIL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_ne
id|TE_OK
)paren
r_return
id|stat
suffix:semicolon
macro_line|#if OBSOLETE
multiline_comment|/************* not needed iff rd_status() would wait for ready!!!!!! **********/
r_if
c_cond
(paren
id|wait_for_ready
c_func
(paren
id|TIM_S
)paren
op_ne
id|TE_OK
)paren
(brace
multiline_comment|/*** not sure this is needed ***/
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;wait_for_ready failed in start_dma&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|MOUNTAIN
)paren
(brace
multiline_comment|/* Set control bits to select ONLINE during command */
id|ctlbits
op_or_assign
id|MTN_QIC02_CTL_ONLINE
suffix:semicolon
)brace
multiline_comment|/* Tell the controller the data direction */
multiline_comment|/* r/w, timeout medium, check exceptions, sets status_cmd_pending. */
id|stat
op_assign
id|send_qic02_cmd
c_func
(paren
(paren
id|mode
op_eq
id|WRITE
)paren
ques
c_cond
id|QCMD_WRT_DATA
suffix:colon
id|QCMD_RD_DATA
comma
id|TIM_M
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_ne
id|TE_OK
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: start_dma: init %s failed&bslash;n&quot;
comma
(paren
id|mode
op_eq
id|WRITE
)paren
ques
c_cond
l_string|&quot;write&quot;
suffix:colon
l_string|&quot;read&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|tp_sense
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
multiline_comment|/* Do this last, because sense() will clear the doing_{read,write}&n;&t;&t; * flags, causing trouble next time around.&n;&t;&t; */
r_if
c_cond
(paren
id|wait_for_ready
c_func
(paren
id|TIM_M
)paren
op_ne
id|TE_OK
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|READ
suffix:colon
id|doing_read
op_assign
id|YES
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE
suffix:colon
id|doing_write
op_assign
id|YES
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: requested unknown mode %d&bslash;n&quot;
comma
id|mode
)paren
suffix:semicolon
id|panic
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: invalid mode in start_dma()&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|is_exception
c_func
(paren
)paren
)paren
(brace
multiline_comment|/* This is for Archive drives, to handle reads with 0 bytes&n;&t;&t; * left for the last read request.&n;&t;&t; *&n;&t;&t; * ******** this also affects EOF/EOT handling! ************&n;&t;&t; */
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;detected exception in start_dma() while transfer in progress&quot;
)paren
suffix:semicolon
id|status_error
op_assign
id|YES
suffix:semicolon
r_return
id|TE_END
suffix:semicolon
)brace
id|status_expect_int
op_assign
id|YES
suffix:semicolon
multiline_comment|/* This assumes tape is already positioned, but these&n;&t; * semi-&squot;intelligent&squot; drives are unpredictable...&n;&t; */
id|TIMERON
c_func
(paren
id|TIM_M
op_star
l_int|2
)paren
suffix:semicolon
multiline_comment|/* initiate first data block read from/write to the tape controller */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dma_transfer
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|TPQPUTS
c_func
(paren
l_string|&quot;start_dma() end&quot;
)paren
suffix:semicolon
r_return
id|TE_OK
suffix:semicolon
)brace
multiline_comment|/* start_dma */
multiline_comment|/* This cleans up after the dma transfer has completed&n; * (or failed). If an exception occurred, a sense()&n; * must be done. If the exception was caused by a FM,&n; * sense() will set `status_eof_detected&squot; and&n; * `status_eom_detected&squot;, as required.&n; */
DECL|function|end_dma
r_static
r_void
id|end_dma
c_func
(paren
r_int
r_int
op_star
id|bytes_done
)paren
(brace
r_int
id|stat
op_assign
id|TE_OK
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|TIMEROFF
suffix:semicolon
id|TPQPUTS
c_func
(paren
l_string|&quot;end_dma() enter&quot;
)paren
suffix:semicolon
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|QIC02_TAPE_DMA
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|QIC02_TAPE_DMA
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|WANGTEK
)paren
multiline_comment|/* or EVEREX */
id|outb_p
c_func
(paren
id|WT_CTL_ONLINE
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
multiline_comment|/* back to normal */
r_else
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|ARCHIVE
)paren
id|outb_p
c_func
(paren
l_int|0
comma
id|AR_RESET_DMA_PORT
)paren
suffix:semicolon
r_else
multiline_comment|/* QIC02_TAPE_IFC == MOUNTAIN */
(brace
multiline_comment|/* Clear control bits, de-select ONLINE during tp_sense */
id|ctlbits
op_and_assign
op_complement
id|MTN_QIC02_CTL_ONLINE
suffix:semicolon
)brace
id|stat
op_assign
id|wait_for_ready
c_func
(paren
id|TIM_M
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status_error
op_logical_or
(paren
id|stat
op_ne
id|TE_OK
)paren
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_DMAX
comma
l_string|&quot;DMA transfer exception&quot;
)paren
suffix:semicolon
id|stat
op_assign
id|tp_sense
c_func
(paren
(paren
id|dma_mode
op_eq
id|READ
)paren
ques
c_cond
id|TP_WRP
suffix:colon
l_int|0
)paren
suffix:semicolon
multiline_comment|/* no return here -- got to clean up first! */
)brace
r_else
multiline_comment|/* if (QIC02_TAPE_IFC == MOUNTAIN) */
(brace
id|outb_p
c_func
(paren
id|ctlbits
comma
id|QIC02_CTL_PORT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|MOUNTAIN
)paren
id|inb
c_func
(paren
id|MTN_R_DESELECT_DMA_PORT
)paren
suffix:semicolon
multiline_comment|/* take the tape controller offline */
multiline_comment|/* finish off DMA stuff */
id|dma_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Note: The drive is left on-line, ready for the next&n;&t; * data transfer.&n;&t; * If the next command to the drive does not continue&n;&t; * the pending cycle, it must do 2 sense()s first.&n;&t; */
op_star
id|bytes_done
op_assign
id|dma_bytes_done
suffix:semicolon
id|status_expect_int
op_assign
id|NO
suffix:semicolon
id|ioctl_status.mt_blkno
op_add_assign
(paren
id|dma_bytes_done
op_div
id|TAPE_BLKSIZE
)paren
suffix:semicolon
id|TPQPUTS
c_func
(paren
l_string|&quot;end_dma() exit&quot;
)paren
suffix:semicolon
multiline_comment|/*** could return stat here ***/
)brace
multiline_comment|/* end_dma */
multiline_comment|/*********** Below are the (public) OS-interface procedures ***********/
multiline_comment|/* qic02_tape_times_out() is called when a DMA transfer doesn&squot;t complete&n; * quickly enough. Usually this means there is something seriously wrong&n; * with the hardware/software, but it could just be that the controller&n; * has decided to do a long rewind, just when I didn&squot;t expect it.&n; * Just try again.&n; */
DECL|function|qic02_tape_times_out
r_static
r_void
id|qic02_tape_times_out
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;time-out in %s driver&bslash;n&quot;
comma
id|TPQIC02_NAME
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status_cmd_pending
OG
l_int|0
)paren
op_logical_or
id|dma_mode
)paren
(brace
multiline_comment|/* takes tooo long, shut it down */
id|status_dead
op_assign
id|YES
suffix:semicolon
id|status_cmd_pending
op_assign
l_int|0
suffix:semicolon
id|status_timer_on
op_assign
id|NO
suffix:semicolon
id|status_expect_int
op_assign
id|NO
suffix:semicolon
id|status_error
op_assign
id|YES
suffix:semicolon
r_if
c_cond
(paren
id|dma_mode
)paren
(brace
id|dma_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* signal end to read/write routine */
id|wake_up
c_func
(paren
op_amp
id|qic02_tape_transfer
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* qic02_tape_times_out */
multiline_comment|/*&n; * Interrupt handling:&n; *&n; * 1) Interrupt is generated iff at the end of &n; *    a 512-DMA-block transfer.&n; * 2) EXCEPTION is not raised unless something &n; *    is wrong or EOT/FM is detected.&n; * 3) FM EXCEPTION is set *after* the last byte has&n; *    been transferred by DMA. By the time the interrupt&n; *    is handled, the EXCEPTION may already be set.&n; *&n; * So,&n; * 1) On EXCEPTION, assume data has been transferred, so&n; *    continue as usual, but set a flag to indicate the&n; *    exception was detected.&n; *    Do a sense status when the flag is found set.&n; * 2) Do not attempt to continue a transfer after an exception.&n; *    [??? What about marginal blocks???????]&n; */
multiline_comment|/* qic02_tape_interrupt() is called when the tape controller completes &n; * a DMA transfer.&n; * We are not allowed to sleep here! &n; *&n; * Check if the transfer was successful, check if we need to transfer&n; * more. If the buffer contains enough data/is empty enough, signal the&n; * read/write() thread to copy to/from user space.&n; * When we are finished, set flags to indicate end, disable timer.&n; * NOTE: This *must* be fast! &n; */
DECL|function|qic02_tape_interrupt
r_static
r_void
id|qic02_tape_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|stat
comma
id|r
comma
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|TIMEROFF
suffix:semicolon
r_if
c_cond
(paren
id|status_expect_int
)paren
(brace
macro_line|#ifdef WANT_EXTRA_FULL_DEBUGGING
r_if
c_cond
(paren
id|TP_DIAGS
c_func
(paren
id|current_tape_dev
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;@&quot;
)paren
suffix:semicolon
macro_line|#endif
id|stat
op_assign
id|inb
c_func
(paren
id|QIC02_STAT_PORT
)paren
suffix:semicolon
multiline_comment|/* Knock, knock */
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|ARCHIVE
)paren
(brace
multiline_comment|/* &quot;Who&squot;s there?&quot; */
r_if
c_cond
(paren
(paren
(paren
id|stat
op_amp
(paren
id|AR_STAT_DMADONE
)paren
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
(paren
id|stat
op_amp
(paren
id|QIC02_STAT_EXCEPTION
)paren
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|TIMERCONT
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* &quot;Linux with IRQ sharing&quot; */
)brace
)brace
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|QIC02_STAT_EXCEPTION
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* exception occurred */
multiline_comment|/* Possible causes for an exception during a transfer:&n;&t;&t;&t; * &t;- during a write-cycle: end of tape (EW) hole detected.&n;&t;&t;&t; *&t;- during a read-cycle: filemark or EOD detected.&n;&t;&t;&t; *&t;- something went wrong&n;&t;&t;&t; * So don&squot;t continue with the next block.&n;&t;&t;&t; */
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;isr: exception on tape controller&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;      status %02x&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
id|status_error
op_assign
id|TE_EX
suffix:semicolon
id|dma_bytes_done
op_add_assign
id|TAPE_BLKSIZE
suffix:semicolon
id|dma_mode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* wake up rw() */
id|status_expect_int
op_assign
id|NO
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|qic02_tape_transfer
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* return if tape controller not ready, or&n;&t;&t; * if dma channel hasn&squot;t finished last byte yet.&n;&t;&t; */
id|r
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Skip next ready check for Archive controller because&n;&t;     * it may be busy reading ahead. Weird. --hhb&n;&t;     */
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|WANGTEK
)paren
multiline_comment|/* I think this is a drive-dependency, not IFC -- hhb */
r_if
c_cond
(paren
id|stat
op_amp
id|QIC02_STAT_READY
)paren
(brace
multiline_comment|/* not ready */
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;isr: ? Tape controller not ready&quot;
)paren
suffix:semicolon
id|r
op_assign
l_int|1
suffix:semicolon
)brace
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|get_dma_residue
c_func
(paren
id|QIC02_TAPE_DMA
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: dma_residue == %x !!!&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|r
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* big trouble, but can&squot;t do much about it... */
)brace
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
r_return
suffix:semicolon
multiline_comment|/* finish DMA cycle */
multiline_comment|/* no errors detected, continue */
id|dma_bytes_done
op_add_assign
id|TAPE_BLKSIZE
suffix:semicolon
r_if
c_cond
(paren
id|dma_bytes_done
op_ge
id|dma_bytes_todo
)paren
(brace
multiline_comment|/* finished! Wakeup rw() */
id|dma_mode
op_assign
l_int|0
suffix:semicolon
id|status_expect_int
op_assign
id|NO
suffix:semicolon
id|TPQPUTS
c_func
(paren
l_string|&quot;isr: dma_bytes_done&quot;
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|qic02_tape_transfer
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* start next transfer, account for track-switching time */
id|mod_timer
c_func
(paren
op_amp
id|tp_timer
comma
id|jiffies
op_plus
l_int|6
op_star
id|HZ
)paren
suffix:semicolon
id|dma_transfer
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: Unexpected interrupt, stat == %x&bslash;n&quot;
comma
id|inb
c_func
(paren
id|QIC02_STAT_PORT
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* qic02_tape_interrupt */
DECL|function|qic02_tape_lseek
r_static
r_int
r_int
id|qic02_tape_lseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* not supported */
)brace
multiline_comment|/* qic02_tape_lseek */
multiline_comment|/* read/write routines:&n; * This code copies between a kernel buffer and a user buffer. The &n; * actual data transfer is done using DMA and interrupts. Time-outs&n; * are also used.&n; *&n; * When a filemark is read, we return &squot;0 bytes read&squot; and continue with the&n; * next file after that.&n; * When EOM is read, we return &squot;0 bytes read&squot; twice.&n; * When the EOT marker is detected on writes, &squot;0 bytes read&squot; should be&n; * returned twice. If user program does a MTNOP after that, 2 additional&n; * blocks may be written.&t;------- FIXME: Implement this correctly  *************************************************&n; *&n; * Only read/writes in multiples of 512 bytes are accepted.&n; * When no bytes are available, we sleep() until they are. The controller will&n; * generate an interrupt, and we (should) get a wake_up() call.&n; *&n; * Simple buffering is used. User program should ensure that a large enough&n; * buffer is used. Usually the drive does some buffering as well (something&n; * like 4k or so).&n; *&n; * Scott S. Bertilson suggested to continue filling the user buffer, rather&n; * than waste time on a context switch, when the kernel buffer fills up.&n; */
multiline_comment|/*&n; * Problem: tar(1) doesn&squot;t always read the entire file. Sometimes the entire file&n; * has been read, but the EOF token is never returned to tar(1), simply because&n; * tar(1) knows it has already read all of the data it needs. So we must use&n; * open/release to reset the `reported_read_eof&squot; flag. If we don&squot;t, the next read&n; * request would return the EOF flag for the previous file.&n; */
DECL|function|qic02_tape_read
r_static
id|ssize_t
id|qic02_tape_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|err
suffix:semicolon
id|kdev_t
id|dev
op_assign
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
suffix:semicolon
r_int
r_int
id|flags
op_assign
id|filp-&gt;f_flags
suffix:semicolon
r_int
r_int
id|bytes_todo
comma
id|bytes_done
comma
id|total_bytes_done
op_assign
l_int|0
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|status_zombie
op_eq
id|YES
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;configs not set&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TP_DIAGS
c_func
(paren
id|current_tape_dev
)paren
)paren
multiline_comment|/* can&squot;t print a ``long long&squot;&squot; (for filp-&gt;f_pos), so chop it */
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: request READ, minor=%x, buf=%p, count=%lx&quot;
l_string|&quot;, pos=%lx, flags=%x&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|dev
)paren
comma
id|buf
comma
(paren
r_int
)paren
id|count
comma
(paren
r_int
r_int
)paren
id|filp-&gt;f_pos
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_mod
id|TAPE_BLKSIZE
)paren
multiline_comment|/* Only allow mod 512 bytes at a time. */
(brace
id|tpqputs
c_func
(paren
id|TPQD_BLKSZ
comma
l_string|&quot;Wrong block size&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Just assume everything is ok. Controller will scream if not. */
r_if
c_cond
(paren
id|status_bytes_wr
)paren
multiline_comment|/* Once written, no more reads, &squot;till after WFM. */
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
multiline_comment|/* This is rather ugly because it has to implement a finite state&n;     * machine in order to handle the EOF situations properly.&n;     */
r_while
c_loop
(paren
(paren
r_int
)paren
id|count
op_ge
l_int|0
)paren
(brace
id|bytes_done
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* see how much fits in the kernel buffer */
id|bytes_todo
op_assign
id|TPQBUF_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|bytes_todo
OG
id|count
)paren
(brace
id|bytes_todo
op_assign
id|count
suffix:semicolon
)brace
multiline_comment|/* Must ensure that user program sees exactly one EOF token (==0) */
r_if
c_cond
(paren
id|return_read_eof
op_eq
id|YES
)paren
(brace
r_if
c_cond
(paren
id|TPQDBG
c_func
(paren
id|DEBUG
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;read: return_read_eof==%d, reported_read_eof==%d, total_bytes_done==%lu&bslash;n&quot;
comma
id|return_read_eof
comma
id|reported_read_eof
comma
id|total_bytes_done
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reported_read_eof
op_eq
id|NO
)paren
(brace
multiline_comment|/* have not yet returned EOF to user program */
r_if
c_cond
(paren
id|total_bytes_done
OG
l_int|0
)paren
(brace
r_return
id|total_bytes_done
suffix:semicolon
multiline_comment|/* next time return EOF */
)brace
r_else
(brace
id|reported_read_eof
op_assign
id|YES
suffix:semicolon
multiline_comment|/* move on next time */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* return EOF */
)brace
)brace
r_else
(brace
multiline_comment|/* Application program has already received EOF&n;&t;&t; * (above), now continue with next file on tape,&n;&t;&t; * if possible.&n;&t;&t; * When the FM is reached, EXCEPTION is set,&n;&t;&t; * causing a sense(). Subsequent read/writes will&n;&t;&t; * continue after the FM.&n;&t;&t; */
multiline_comment|/*********** ?????????? this should check for (EOD|NDT), not EOM, &squot;cause we can read past EW: ************/
r_if
c_cond
(paren
id|status_eom_detected
)paren
(brace
multiline_comment|/* If EOM, nothing left to read, so keep returning EOFs.&n;&t;&t;     *** should probably set some flag to avoid clearing&n;&t;&t;     *** status_eom_detected through ioctls or something&n;&t;&t;     */
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* just eof, there may be more files ahead... */
id|return_read_eof
op_assign
id|NO
suffix:semicolon
id|reported_read_eof
op_assign
id|NO
suffix:semicolon
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
multiline_comment|/* reset this too */
multiline_comment|/*fall through*/
)brace
)brace
)brace
multiline_comment|/*****************************/
r_if
c_cond
(paren
id|bytes_todo
op_eq
l_int|0
)paren
(brace
r_return
id|total_bytes_done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bytes_todo
OG
l_int|0
)paren
(brace
multiline_comment|/* start reading data */
r_if
c_cond
(paren
id|is_exception
c_func
(paren
)paren
)paren
multiline_comment|/****************************************/
(brace
id|tpqputs
c_func
(paren
id|TPQD_DMAX
comma
l_string|&quot;is_exception() before start_dma()!&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************&n; ***** if start_dma() fails because the head is positioned 0 bytes&n; ***** before the FM, (causing EXCEPTION to be set) return_read_eof should&n; ***** be set to YES, and we should return total_bytes_done, rather than -ENXIO.&n; ***** The app should recognize this as an EOF condition.&n; ***************************************************************************/
id|stat
op_assign
id|start_dma
c_func
(paren
id|READ
comma
id|bytes_todo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
id|TE_OK
)paren
(brace
multiline_comment|/* Wait for transfer to complete, interrupt should wake us */
r_while
c_loop
(paren
id|dma_mode
op_ne
l_int|0
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|qic02_tape_transfer
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status_error
)paren
(brace
id|return_read_eof
op_assign
id|YES
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|stat
op_ne
id|TE_END
)paren
(brace
multiline_comment|/* should do sense() on error here */
macro_line|#if 0
r_return
op_minus
id|ENXIO
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;Trouble: stat==%02x&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
id|return_read_eof
op_assign
id|YES
suffix:semicolon
multiline_comment|/*************** check EOF/EOT handling!!!!!! **/
macro_line|#endif
)brace
id|end_dma
c_func
(paren
op_amp
id|bytes_done
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes_done
OG
id|bytes_todo
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;read: Oops, read more bytes than requested&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* copy buffer to user-space in one go */
r_if
c_cond
(paren
id|bytes_done
OG
l_int|0
)paren
(brace
id|err
op_assign
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|buf
comma
(paren
r_void
op_star
)paren
id|bus_to_virt
c_func
(paren
id|buffaddr
)paren
comma
id|bytes_done
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
macro_line|#if 1
multiline_comment|/* Checks Ton&squot;s patch below */
r_if
c_cond
(paren
(paren
id|return_read_eof
op_eq
id|NO
)paren
op_logical_and
(paren
id|status_eof_detected
op_eq
id|YES
)paren
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: read(): return_read_eof=%d, status_eof_detected=YES. return_read_eof:=YES&bslash;n&quot;
comma
id|return_read_eof
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|bytes_todo
op_ne
id|bytes_done
)paren
op_logical_or
(paren
id|status_eof_detected
op_eq
id|YES
)paren
)paren
(brace
multiline_comment|/* EOF or EOM detected. return EOF next time. */
id|return_read_eof
op_assign
id|YES
suffix:semicolon
)brace
)brace
multiline_comment|/* else: ignore read request for 0 bytes */
r_if
c_cond
(paren
id|bytes_done
OG
l_int|0
)paren
(brace
id|status_bytes_rd
op_assign
id|YES
suffix:semicolon
id|buf
op_add_assign
id|bytes_done
suffix:semicolon
op_star
id|ppos
op_add_assign
id|bytes_done
suffix:semicolon
id|total_bytes_done
op_add_assign
id|bytes_done
suffix:semicolon
id|count
op_sub_assign
id|bytes_done
suffix:semicolon
)brace
)brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;read request for &lt;0 bytes&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* qic02_tape_read */
multiline_comment|/* The drive detects near-EOT by means of the holes in the tape.&n; * When the holes are detected, there is some space left. The drive&n; * reports this as a TP_EOM exception. After clearing the exception,&n; * the drive should accept two extra blocks.&n; *&n; * It seems there are some archiver programs that would like to use the&n; * extra space for writing a continuation marker. The driver should return&n; * end-of-file to the user program on writes, when the holes are detected.&n; * If the user-program wants to use the extra space, it should use the&n; * MTNOP ioctl() to get the generic status register and may then continue&n; * writing (max 1kB).&t;----------- doesn&squot;t work yet...............&n; *&n; * EOF behaviour on writes:&n; * If there is enough room, write all of the data.&n; * If there is insufficient room, write as much as will fit and&n; * return the amount written. If the requested amount differs from the&n; * written amount, the application program should recognize that as the&n; * end of file. Subsequent writes will return -ENOSPC.&n; * Unless the minor bits specify a rewind-on-close, the tape will not&n; * be rewound when it is full. The user-program should do that, if desired.&n; * If the driver were to do that automatically, a user-program could be &n; * confused about the EOT/BOT condition after re-opening the tape device.&n; *&n; * Multiple volume support: Tar closes the tape device before prompting for&n; * the next tape. The user may then insert a new tape and tar will open the&n; * tape device again. The driver will detect an exception status in (No Cartridge)&n; * and force a rewind. After that tar may continue writing.&n; */
DECL|function|qic02_tape_write
r_static
id|ssize_t
id|qic02_tape_write
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|err
suffix:semicolon
id|kdev_t
id|dev
op_assign
id|filp-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
suffix:semicolon
r_int
r_int
id|flags
op_assign
id|filp-&gt;f_flags
suffix:semicolon
r_int
r_int
id|bytes_todo
comma
id|bytes_done
comma
id|total_bytes_done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status_zombie
op_eq
id|YES
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;configs not set&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TP_DIAGS
c_func
(paren
id|current_tape_dev
)paren
)paren
(brace
multiline_comment|/* can&squot;t print a ``long long&squot;&squot; (for filp-&gt;f_pos), so chop it */
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: request WRITE, minor=%x, buf=%p&quot;
l_string|&quot;, count=%lx, pos=%lx, flags=%x&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|dev
)paren
comma
id|buf
comma
(paren
r_int
)paren
id|count
comma
(paren
r_int
r_int
)paren
id|filp-&gt;f_pos
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_mod
id|TAPE_BLKSIZE
)paren
multiline_comment|/* only allow mod 512 bytes at a time */
(brace
id|tpqputs
c_func
(paren
id|TPQD_BLKSZ
comma
l_string|&quot;Wrong block size&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mode_access
op_eq
id|READ
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Not in write mode&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
multiline_comment|/* open() does a sense() and we can assume the tape isn&squot;t changed&n;     * between open() and release(), so the tperror.exs bits will still&n;     * be valid.&n;     */
r_if
c_cond
(paren
(paren
id|tperror.exs
op_amp
id|TP_ST0
)paren
op_logical_and
(paren
id|tperror.exs
op_amp
id|TP_WRP
)paren
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Cartridge is write-protected.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* don&squot;t even try when write protected */
)brace
r_if
c_cond
(paren
id|doing_read
op_eq
id|YES
)paren
(brace
id|terminate_read
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
r_int
)paren
id|count
op_ge
l_int|0
)paren
(brace
multiline_comment|/* see how much fits in the kernel buffer */
id|bytes_done
op_assign
l_int|0
suffix:semicolon
id|bytes_todo
op_assign
id|TPQBUF_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|bytes_todo
OG
id|count
)paren
(brace
id|bytes_todo
op_assign
id|count
suffix:semicolon
)brace
r_if
c_cond
(paren
id|return_write_eof
op_eq
id|YES
)paren
(brace
multiline_comment|/* return_write_eof should be reset on reverse tape movements. */
r_if
c_cond
(paren
id|reported_write_eof
op_eq
id|NO
)paren
(brace
r_if
c_cond
(paren
id|bytes_todo
OG
l_int|0
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;partial write&quot;
)paren
suffix:semicolon
multiline_comment|/* partial write signals EOF to user program */
)brace
id|reported_write_eof
op_assign
id|YES
suffix:semicolon
r_return
id|total_bytes_done
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|ENOSPC
suffix:semicolon
multiline_comment|/* return error */
)brace
)brace
multiline_comment|/* Quit when done. */
r_if
c_cond
(paren
id|bytes_todo
op_eq
l_int|0
)paren
(brace
r_return
id|total_bytes_done
suffix:semicolon
)brace
multiline_comment|/* copy from user to DMA buffer and initiate transfer. */
r_if
c_cond
(paren
id|bytes_todo
OG
l_int|0
)paren
(brace
id|err
op_assign
id|copy_from_user
c_func
(paren
(paren
r_void
op_star
)paren
id|bus_to_virt
c_func
(paren
id|buffaddr
)paren
comma
(paren
r_const
r_void
op_star
)paren
id|buf
comma
id|bytes_todo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/****************** similar problem with read() at FM could happen here at EOT.&n; ******************/
multiline_comment|/***** if at EOT, 0 bytes can be written. start_dma() will&n; ***** fail and write() will return ENXIO error&n; *****/
r_if
c_cond
(paren
id|start_dma
c_func
(paren
id|WRITE
comma
id|bytes_todo
)paren
op_ne
id|TE_OK
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;write: start_dma() failed&quot;
)paren
suffix:semicolon
multiline_comment|/* should do sense() on error here */
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/*********** FIXTHIS **************/
)brace
multiline_comment|/* Wait for write to complete, interrupt should wake us. */
r_while
c_loop
(paren
(paren
id|status_error
op_eq
l_int|0
)paren
op_logical_and
(paren
id|dma_mode
op_ne
l_int|0
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|qic02_tape_transfer
)paren
suffix:semicolon
)brace
id|end_dma
c_func
(paren
op_amp
id|bytes_done
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes_done
OG
id|bytes_todo
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;write: Oops, wrote more bytes than requested&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* If the dma-transfer was aborted because of an exception,&n;&t;     * status_error will have been set in the interrupt handler.&n;&t;     * Then end_dma() will do a sense().&n;&t;     * If the exception was EXC_EOM, the EW-hole was encountered&n;&t;     * and two more blocks could be written. For the time being we&squot;ll&n;&t;     * just consider this to be the EOT.&n;&t;     * Otherwise, something Bad happened, such as the maximum number&n;&t;     * of block-rewrites was exceeded. [e.g. A very bad spot on tape was&n;&t;     * encountered. Normally short dropouts are compensated for by&n;&t;     * rewriting the block in error, up to 16 times. I&squot;m not sure&n;&t;     * QIC-24 drives can do this.]&n;&t;     */
r_if
c_cond
(paren
id|status_error
)paren
(brace
r_if
c_cond
(paren
id|status_eom_detected
op_eq
id|YES
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;write: EW detected&quot;
)paren
suffix:semicolon
id|return_write_eof
op_assign
id|YES
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* probably EXC_RWA */
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;write: dma: error in writing&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|bytes_todo
op_ne
id|bytes_done
)paren
(brace
multiline_comment|/* EOF or EOM detected. return EOT next time. */
id|return_write_eof
op_assign
id|YES
suffix:semicolon
)brace
)brace
multiline_comment|/* else: ignore write request for 0 bytes. */
r_if
c_cond
(paren
id|bytes_done
OG
l_int|0
)paren
(brace
id|status_bytes_wr
op_assign
id|YES
suffix:semicolon
id|buf
op_add_assign
id|bytes_done
suffix:semicolon
op_star
id|ppos
op_add_assign
id|bytes_done
suffix:semicolon
id|total_bytes_done
op_add_assign
id|bytes_done
suffix:semicolon
id|count
op_sub_assign
id|bytes_done
suffix:semicolon
)brace
)brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;write request for &lt;0 bytes&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TPQDBG
c_func
(paren
id|DEBUG
)paren
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: status_bytes_wr %x, buf %p&quot;
l_string|&quot;, total_bytes_done %lx, count %lx&bslash;n&quot;
comma
id|status_bytes_wr
comma
id|buf
comma
id|total_bytes_done
comma
(paren
r_int
)paren
id|count
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* qic02_tape_write */
multiline_comment|/* qic02_tape_open()&n; * We allow the device to be opened, even if it is marked &squot;dead&squot; because&n; * we want to be able to reset the tape device without rebooting.&n; * Only one open tape file at a time, except when minor=255.&n; * Minor 255 is only allowed for resetting and always returns &lt;0.&n; * &n; * The density command is only allowed when TP_BOM is set. Thus, remember&n; * the most recently used minor bits. When they are different from the&n; * remembered values, rewind the tape and set the required density.&n; * Don&squot;t rewind if the minor bits specify density 0.&n; */
DECL|function|qic02_tape_open
r_static
r_int
id|qic02_tape_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_static
r_int
id|qic02_tape_open_no_use_count
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_int
id|open_error
suffix:semicolon
id|open_error
op_assign
id|qic02_tape_open_no_use_count
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
r_return
id|open_error
suffix:semicolon
)brace
DECL|function|qic02_tape_open_no_use_count
r_static
r_int
id|qic02_tape_open_no_use_count
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|kdev_t
id|dev
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
r_int
r_int
id|flags
op_assign
id|filp-&gt;f_flags
suffix:semicolon
r_int
r_int
id|dens
op_assign
l_int|0
suffix:semicolon
r_int
id|s
suffix:semicolon
r_if
c_cond
(paren
id|TP_DIAGS
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;qic02_tape_open: dev=%s, flags=%x     &quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
comma
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|dev
)paren
op_eq
l_int|255
)paren
multiline_comment|/* special case for resetting */
(brace
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
(brace
r_return
(paren
id|tape_reset
c_func
(paren
l_int|1
)paren
op_eq
id|TE_OK
)paren
ques
c_cond
op_minus
id|EAGAIN
suffix:colon
op_minus
id|ENXIO
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|status_dead
op_eq
id|YES
)paren
(brace
multiline_comment|/* Allow `mt reset&squot; ioctl() even when already open()ed. */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Only one at a time from here on... */
r_if
c_cond
(paren
id|file_count
c_func
(paren
id|filp
)paren
OG
l_int|1
)paren
multiline_comment|/* filp-&gt;f_count==1 for the first open() */
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status_zombie
op_eq
id|YES
)paren
(brace
multiline_comment|/* no irq/dma/port stuff allocated yet, no reset done&n;&t; * yet, so return until MTSETCONFIG has been done.&n;&t; */
r_return
l_int|0
suffix:semicolon
)brace
id|status_bytes_rd
op_assign
id|NO
suffix:semicolon
id|status_bytes_wr
op_assign
id|NO
suffix:semicolon
id|return_read_eof
op_assign
id|NO
suffix:semicolon
multiline_comment|/********????????????????*****/
id|return_write_eof
op_assign
(paren
id|status_eot_detected
)paren
ques
c_cond
id|YES
suffix:colon
id|NO
suffix:semicolon
multiline_comment|/* Clear this in case user app close()d before reading EOF token */
id|status_eof_detected
op_assign
id|NO
suffix:semicolon
id|reported_read_eof
op_assign
id|NO
suffix:semicolon
id|reported_write_eof
op_assign
id|NO
suffix:semicolon
r_switch
c_cond
(paren
id|flags
op_amp
id|O_ACCMODE
)paren
(brace
r_case
id|O_RDONLY
suffix:colon
id|mode_access
op_assign
id|READ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|O_WRONLY
suffix:colon
multiline_comment|/* Fallthru... Strictly speaking this is not correct... */
r_case
id|O_RDWR
suffix:colon
multiline_comment|/* Reads are allowed as long as nothing is written */
id|mode_access
op_assign
id|WRITE
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* This is to avoid tape-changed problems (TP_CNI exception).&n;     *&n;     * Since removing the cartridge will not raise an exception,&n;     * we always do a tp_sense() to make sure we have the proper&n;     * CNI status, the 2150L may need an additional sense.... - Eddy&n;     */
id|s
op_assign
id|tp_sense
c_func
(paren
id|TP_WRP
op_or
id|TP_EOM
op_or
id|TP_BOM
op_or
id|TP_CNI
op_or
id|TP_EOR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_eq
id|TE_OK
)paren
(brace
multiline_comment|/* Try to clear cartridge-changed status for Archive-2150L */
r_if
c_cond
(paren
(paren
id|tperror.exs
op_amp
id|TP_ST0
)paren
op_logical_and
(paren
id|tperror.exs
op_amp
id|TP_CNI
)paren
)paren
(brace
id|s
op_assign
id|tp_sense
c_func
(paren
id|TP_WRP
op_or
id|TP_EOM
op_or
id|TP_BOM
op_or
id|TP_CNI
op_or
id|TP_EOR
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|s
op_ne
id|TE_OK
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;open: sense() failed&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* exception bits should be up-to-date now, so check for&n;     * tape presence and exit if absent.&n;     * Even `mt stat&squot; will fail without a tape.&n;     */
r_if
c_cond
(paren
(paren
id|tperror.exs
op_amp
id|TP_ST0
)paren
op_logical_and
(paren
id|tperror.exs
op_amp
id|TP_CNI
)paren
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;No tape present.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* At this point we can assume that a tape is present and&n;     * that it will remain present until release() is called.&n;     */
multiline_comment|/* not allowed to do QCMD_DENS_* unless tape is rewound */
r_if
c_cond
(paren
(paren
id|TP_DENS
c_func
(paren
id|dev
)paren
op_ne
l_int|0
)paren
op_logical_and
(paren
id|TP_DENS
c_func
(paren
id|current_tape_dev
)paren
op_ne
id|TP_DENS
c_func
(paren
id|dev
)paren
)paren
)paren
(brace
multiline_comment|/* force rewind if minor bits have changed,&n;&t; * i.e. user wants to use tape in different format.&n;&t; * [assuming single drive operation]&n;&t; */
r_if
c_cond
(paren
id|TP_HAVE_DENS
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_REWIND
comma
l_string|&quot;Density minor bits have changed. Forcing rewind.&quot;
)paren
suffix:semicolon
id|need_rewind
op_assign
id|YES
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* density bits still the same, but TP_DIAGS bit &n;&t; * may have changed.&n;&t; */
id|current_tape_dev
op_assign
id|dev
suffix:semicolon
)brace
r_if
c_cond
(paren
id|need_rewind
op_eq
id|YES
)paren
multiline_comment|/***************** CHECK THIS!!!!!!!! **********/
(brace
id|s
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_REWIND
comma
id|TIM_R
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_ne
l_int|0
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;open: rewind failed&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
multiline_comment|/* Note: After a reset command, the controller will rewind the tape&n; *&t; just before performing any tape movement operation! ************ SO SET need_rewind flag!!!!!&n; */
r_if
c_cond
(paren
id|status_dead
op_eq
id|YES
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;open: tape dead, attempting reset&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape_reset
c_func
(paren
l_int|1
)paren
op_ne
id|TE_OK
)paren
(brace
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_else
(brace
id|status_dead
op_assign
id|NO
suffix:semicolon
r_if
c_cond
(paren
id|tp_sense
c_func
(paren
op_complement
(paren
id|TP_ST1
op_or
id|TP_ILL
)paren
)paren
op_ne
id|TE_OK
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;open: tp_sense() failed&bslash;n&quot;
)paren
suffix:semicolon
id|status_dead
op_assign
id|YES
suffix:semicolon
multiline_comment|/* try reset next time */
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* things should be ok, once we get here */
multiline_comment|/* set density: only allowed when TP_BOM status bit is set,&n;     * so we must have done a rewind by now. If not, just skip over.&n;     * Only give set density command when minor bits have changed.&n;     */
r_if
c_cond
(paren
id|TP_DENS
c_func
(paren
id|current_tape_dev
)paren
op_eq
id|TP_DENS
c_func
(paren
id|dev
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|current_tape_dev
op_assign
id|dev
suffix:semicolon
id|need_rewind
op_assign
id|NO
suffix:semicolon
r_if
c_cond
(paren
id|TP_HAVE_DENS
)paren
(brace
id|dens
op_assign
id|TP_DENS
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dens
OL
r_sizeof
(paren
id|format_names
)paren
op_div
r_sizeof
(paren
r_char
op_star
)paren
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: format: %s%s&bslash;n&quot;
comma
(paren
id|dens
op_ne
l_int|0
)paren
ques
c_cond
l_string|&quot;QIC-&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|format_names
(braket
id|dens
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|tpqputs
c_func
(paren
id|TPQD_REWIND
comma
l_string|&quot;Wait for retensioning...&quot;
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|TP_DENS
c_func
(paren
id|dev
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Minor 0 is for drives without set-density support */
id|s
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|s
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_DENS_11
comma
id|TIM_S
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|s
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_DENS_24
comma
id|TIM_S
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|s
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_DENS_120
comma
id|TIM_S
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|s
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_DENS_150
comma
id|TIM_S
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|s
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_DENS_300
comma
id|TIM_S
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|s
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_DENS_600
comma
id|TIM_S
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* otherwise do a retension before anything else */
id|s
op_assign
id|do_qic_cmd
c_func
(paren
id|QCMD_RETEN
comma
id|TIM_R
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s
op_ne
l_int|0
)paren
(brace
id|status_dead
op_assign
id|YES
suffix:semicolon
multiline_comment|/* force reset */
id|current_tape_dev
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* earlier 0xff80 */
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* qic02_tape_open */
DECL|function|qic02_tape_release
r_static
r_int
id|qic02_tape_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|kdev_t
id|dev
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|TP_DIAGS
c_func
(paren
id|dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;qic02_tape_release: dev=%s&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status_zombie
op_eq
id|NO
)paren
multiline_comment|/* don&squot;t rewind in zombie mode */
(brace
multiline_comment|/* Terminate any pending write cycle. Terminating the read-cycle&n;&t; * is delayed until it is required to do so for a new command.&n;&t; */
id|terminate_write
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status_dead
op_eq
id|YES
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;release: device dead!?&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Rewind only if minor number requires it AND &n;&t; * read/writes have been done. ************* IS THIS CORRECT??????????&n;&t; */
r_if
c_cond
(paren
(paren
id|TP_REWCLOSE
c_func
(paren
id|dev
)paren
)paren
op_logical_and
(paren
id|status_bytes_rd
op_or
id|status_bytes_wr
)paren
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_REWIND
comma
l_string|&quot;release: Doing rewind...&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|do_qic_cmd
c_func
(paren
id|QCMD_REWIND
comma
id|TIM_R
)paren
suffix:semicolon
)brace
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* qic02_tape_release */
macro_line|#ifdef CONFIG_QIC02_DYNCONF
multiline_comment|/* Set masks etc. based on the interface card type. */
DECL|function|update_ifc_masks
r_static
r_int
id|update_ifc_masks
c_func
(paren
r_int
id|ifc
)paren
(brace
id|QIC02_TAPE_IFC
op_assign
id|ifc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|QIC02_TAPE_IFC
op_eq
id|WANGTEK
)paren
op_logical_or
(paren
id|QIC02_TAPE_IFC
op_eq
id|EVEREX
)paren
)paren
(brace
id|QIC02_STAT_PORT
op_assign
id|QIC02_TAPE_PORT
suffix:semicolon
id|QIC02_CTL_PORT
op_assign
id|QIC02_TAPE_PORT
suffix:semicolon
id|QIC02_CMD_PORT
op_assign
id|QIC02_TAPE_PORT
op_plus
l_int|1
suffix:semicolon
id|QIC02_DATA_PORT
op_assign
id|QIC02_TAPE_PORT
op_plus
l_int|1
suffix:semicolon
id|QIC02_STAT_READY
op_assign
id|WT_QIC02_STAT_READY
suffix:semicolon
id|QIC02_STAT_EXCEPTION
op_assign
id|WT_QIC02_STAT_EXCEPTION
suffix:semicolon
id|QIC02_STAT_MASK
op_assign
id|WT_QIC02_STAT_MASK
suffix:semicolon
id|QIC02_STAT_RESETMASK
op_assign
id|WT_QIC02_STAT_RESETMASK
suffix:semicolon
id|QIC02_STAT_RESETVAL
op_assign
id|WT_QIC02_STAT_RESETVAL
suffix:semicolon
id|QIC02_CTL_RESET
op_assign
id|WT_QIC02_CTL_RESET
suffix:semicolon
id|QIC02_CTL_REQUEST
op_assign
id|WT_QIC02_CTL_REQUEST
suffix:semicolon
r_if
c_cond
(paren
id|QIC02_TAPE_DMA
op_eq
l_int|3
)paren
(brace
id|WT_CTL_DMA
op_assign
id|WT_CTL_DMA3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|QIC02_TAPE_DMA
op_eq
l_int|1
)paren
(brace
id|WT_CTL_DMA
op_assign
id|WT_CTL_DMA1
suffix:semicolon
)brace
r_else
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Unsupported or incorrect DMA channel&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|EVEREX
)paren
(brace
multiline_comment|/* Everex is a special case for Wangtek (actually&n;&t;     * it&squot;s the other way &squot;round, but I saw Wangtek first)&n;&t;     */
r_if
c_cond
(paren
id|QIC02_TAPE_DMA
op_eq
l_int|3
)paren
(brace
id|WT_CTL_DMA
op_assign
id|WT_CTL_DMA1
suffix:semicolon
)brace
multiline_comment|/* Fixup the kernel copy of the IFC type to that&n;&t;     * we don&squot;t have to distinguish between Wangtek and&n;&t;     * and Everex at runtime.&n;&t;     */
id|QIC02_TAPE_IFC
op_assign
id|WANGTEK
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|ARCHIVE
)paren
(brace
id|QIC02_STAT_PORT
op_assign
id|QIC02_TAPE_PORT
op_plus
l_int|1
suffix:semicolon
id|QIC02_CTL_PORT
op_assign
id|QIC02_TAPE_PORT
op_plus
l_int|1
suffix:semicolon
id|QIC02_CMD_PORT
op_assign
id|QIC02_TAPE_PORT
suffix:semicolon
id|QIC02_DATA_PORT
op_assign
id|QIC02_TAPE_PORT
suffix:semicolon
id|QIC02_STAT_READY
op_assign
id|AR_QIC02_STAT_READY
suffix:semicolon
id|QIC02_STAT_EXCEPTION
op_assign
id|AR_QIC02_STAT_EXCEPTION
suffix:semicolon
id|QIC02_STAT_MASK
op_assign
id|AR_QIC02_STAT_MASK
suffix:semicolon
id|QIC02_STAT_RESETMASK
op_assign
id|AR_QIC02_STAT_RESETMASK
suffix:semicolon
id|QIC02_STAT_RESETVAL
op_assign
id|AR_QIC02_STAT_RESETVAL
suffix:semicolon
id|QIC02_CTL_RESET
op_assign
id|AR_QIC02_CTL_RESET
suffix:semicolon
id|QIC02_CTL_REQUEST
op_assign
id|AR_QIC02_CTL_REQUEST
suffix:semicolon
r_if
c_cond
(paren
id|QIC02_TAPE_DMA
OG
l_int|3
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Unsupported or incorrect DMA channel&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|QIC02_TAPE_IFC
op_eq
id|MOUNTAIN
)paren
(brace
id|QIC02_STAT_PORT
op_assign
id|QIC02_TAPE_PORT
op_plus
l_int|1
suffix:semicolon
id|QIC02_CTL_PORT
op_assign
id|QIC02_TAPE_PORT
op_plus
l_int|1
suffix:semicolon
id|QIC02_CMD_PORT
op_assign
id|QIC02_TAPE_PORT
suffix:semicolon
id|QIC02_DATA_PORT
op_assign
id|QIC02_TAPE_PORT
suffix:semicolon
id|QIC02_STAT_READY
op_assign
id|MTN_QIC02_STAT_READY
suffix:semicolon
id|QIC02_STAT_EXCEPTION
op_assign
id|MTN_QIC02_STAT_EXCEPTION
suffix:semicolon
id|QIC02_STAT_MASK
op_assign
id|MTN_QIC02_STAT_MASK
suffix:semicolon
id|QIC02_STAT_RESETMASK
op_assign
id|MTN_QIC02_STAT_RESETMASK
suffix:semicolon
id|QIC02_STAT_RESETVAL
op_assign
id|MTN_QIC02_STAT_RESETVAL
suffix:semicolon
id|QIC02_CTL_RESET
op_assign
id|MTN_QIC02_CTL_RESET
suffix:semicolon
id|QIC02_CTL_REQUEST
op_assign
id|MTN_QIC02_CTL_REQUEST
suffix:semicolon
r_if
c_cond
(paren
id|QIC02_TAPE_DMA
OG
l_int|3
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Unsupported or incorrect DMA channel&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_else
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Invalid interface type&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_return
id|qic02_get_resources
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* update_ifc_masks */
macro_line|#endif
multiline_comment|/* ioctl allows user programs to rewind the tape and stuff like that */
DECL|function|qic02_tape_ioctl
r_static
r_int
id|qic02_tape_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|iocmd
comma
r_int
r_int
id|ioarg
)paren
(brace
r_int
id|error
suffix:semicolon
r_int
id|dev_maj
op_assign
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_int
id|c
suffix:semicolon
r_struct
id|mtop
id|operation
suffix:semicolon
r_int
r_char
id|blk_addr
(braket
l_int|6
)braket
suffix:semicolon
r_struct
id|mtpos
id|ioctl_tell
suffix:semicolon
r_if
c_cond
(paren
id|TP_DIAGS
c_func
(paren
id|current_tape_dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: ioctl(%4x, %4x, %4lx)&bslash;n&quot;
comma
id|dev_maj
comma
id|iocmd
comma
id|ioarg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_or
op_logical_neg
id|ioarg
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* check iocmd first */
r_if
c_cond
(paren
id|dev_maj
op_ne
id|QIC02_TAPE_MAJOR
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: Oops! Wrong device?&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* A panic() would be appropriate here */
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|c
op_assign
id|_IOC_NR
c_func
(paren
id|iocmd
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_QIC02_DYNCONF
r_if
c_cond
(paren
id|c
op_eq
id|_IOC_NR
c_func
(paren
id|MTIOCGETCONFIG
)paren
)paren
(brace
id|CHECK_IOC_SIZE
c_func
(paren
id|mtconfiginfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|ioarg
comma
(paren
r_char
op_star
)paren
op_amp
id|qic02_tape_dynconf
comma
r_sizeof
(paren
id|qic02_tape_dynconf
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
id|_IOC_NR
c_func
(paren
id|MTIOCSETCONFIG
)paren
)paren
(brace
multiline_comment|/* One should always do a MTIOCGETCONFIG first, then update&n;&t; * user-settings, then write back with MTIOCSETCONFIG.&n;&t; * The qic02conf program should re-open() the device before actual&n;&t; * use, to make sure everything is initialized.&n;&t; */
id|CHECK_IOC_SIZE
c_func
(paren
id|mtconfiginfo
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|doing_read
op_ne
id|NO
)paren
op_logical_or
(paren
id|doing_write
op_ne
id|NO
)paren
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status_zombie
op_eq
id|NO
)paren
(brace
id|qic02_release_resources
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* and go zombie */
)brace
multiline_comment|/* copy struct from user space to kernel space */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|qic02_tape_dynconf
comma
(paren
r_char
op_star
)paren
id|ioarg
comma
r_sizeof
(paren
id|qic02_tape_dynconf
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
id|update_ifc_masks
c_func
(paren
id|qic02_tape_dynconf.ifc_type
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status_zombie
op_eq
id|YES
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Configs not set&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|c
op_eq
id|_IOC_NR
c_func
(paren
id|MTIOCTOP
)paren
)paren
(brace
id|CHECK_IOC_SIZE
c_func
(paren
id|mtop
)paren
suffix:semicolon
multiline_comment|/* copy mtop struct from user space to kernel space */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|operation
comma
(paren
r_char
op_star
)paren
id|ioarg
comma
r_sizeof
(paren
id|operation
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* ---note: mt_count is signed, negative seeks must be&n;&t; * ---&t;    translated to seeks in opposite direction!&n;&t; * (only needed for Sun-programs, I think.)&n;&t; */
multiline_comment|/* ---note: MTFSF with count 0 should position the&n;&t; * ---&t;    tape at the beginning of the current file.&n;&t; */
r_if
c_cond
(paren
id|TP_DIAGS
c_func
(paren
id|current_tape_dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;OP op=%4x, count=%4x&bslash;n&quot;
comma
id|operation.mt_op
comma
id|operation.mt_count
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|operation.mt_count
OL
l_int|0
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Warning: negative mt_count ignored&quot;
)paren
suffix:semicolon
)brace
id|ioctl_status.mt_resid
op_assign
id|operation.mt_count
suffix:semicolon
r_if
c_cond
(paren
id|operation.mt_op
op_eq
id|MTSEEK
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|TP_HAVE_SEEK
)paren
(brace
r_return
op_minus
id|ENOTTY
suffix:semicolon
)brace
id|seek_addr_buf
(braket
l_int|0
)braket
op_assign
(paren
id|operation.mt_count
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|seek_addr_buf
(braket
l_int|1
)braket
op_assign
(paren
id|operation.mt_count
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|seek_addr_buf
(braket
l_int|2
)braket
op_assign
(paren
id|operation.mt_count
)paren
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|operation.mt_count
op_rshift
l_int|24
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|error
op_assign
id|do_ioctl_cmd
c_func
(paren
id|operation.mt_op
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ioctl_status.mt_resid
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
id|operation.mt_count
OG
l_int|0
)paren
(brace
id|operation.mt_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|error
op_assign
id|do_ioctl_cmd
c_func
(paren
id|operation.mt_op
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_return
id|error
suffix:semicolon
)brace
id|ioctl_status.mt_resid
op_assign
id|operation.mt_count
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
id|_IOC_NR
c_func
(paren
id|MTIOCGET
)paren
)paren
(brace
r_if
c_cond
(paren
id|TP_DIAGS
c_func
(paren
id|current_tape_dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;GET &quot;
)paren
suffix:semicolon
)brace
id|CHECK_IOC_SIZE
c_func
(paren
id|mtget
)paren
suffix:semicolon
multiline_comment|/* It appears (gmt(1)) that it is normal behaviour to&n;&t; * first set the status with MTNOP, and then to read&n;&t; * it out with MTIOCGET&n;&t; */
multiline_comment|/* copy results to user space */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|ioarg
comma
(paren
r_char
op_star
)paren
op_amp
id|ioctl_status
comma
r_sizeof
(paren
id|ioctl_status
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|TP_HAVE_TELL
op_logical_and
(paren
id|c
op_eq
id|_IOC_NR
c_func
(paren
id|MTIOCPOS
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|TP_DIAGS
c_func
(paren
id|current_tape_dev
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;POS &quot;
)paren
suffix:semicolon
)brace
id|CHECK_IOC_SIZE
c_func
(paren
id|mtpos
)paren
suffix:semicolon
id|tpqputs
c_func
(paren
id|TPQD_IOCTLS
comma
l_string|&quot;MTTELL reading block address&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|doing_read
op_eq
id|YES
)paren
op_logical_or
(paren
id|doing_write
op_eq
id|YES
)paren
)paren
(brace
id|finish_rw
c_func
(paren
id|AR_QCMDV_TELL_BLK
)paren
suffix:semicolon
)brace
id|c
op_assign
id|rdstatus
c_func
(paren
(paren
r_char
op_star
)paren
id|blk_addr
comma
r_sizeof
(paren
id|blk_addr
)paren
comma
id|AR_QCMDV_TELL_BLK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_ne
id|TE_OK
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|ioctl_tell.mt_blkno
op_assign
(paren
id|blk_addr
(braket
l_int|3
)braket
op_lshift
l_int|16
)paren
op_or
(paren
id|blk_addr
(braket
l_int|4
)braket
op_lshift
l_int|8
)paren
op_or
id|blk_addr
(braket
l_int|5
)braket
suffix:semicolon
multiline_comment|/* copy results to user space */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|ioarg
comma
(paren
r_char
op_star
)paren
op_amp
id|ioctl_tell
comma
r_sizeof
(paren
id|ioctl_tell
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|ENOTTY
suffix:semicolon
multiline_comment|/* Other cmds not supported. */
)brace
)brace
multiline_comment|/* qic02_tape_ioctl */
multiline_comment|/* These are (most) of the interface functions: */
DECL|variable|qic02_tape_fops
r_static
r_struct
id|file_operations
id|qic02_tape_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|qic02_tape_lseek
comma
multiline_comment|/* not allowed */
id|read
suffix:colon
id|qic02_tape_read
comma
id|write
suffix:colon
id|qic02_tape_write
comma
id|ioctl
suffix:colon
id|qic02_tape_ioctl
comma
id|open
suffix:colon
id|qic02_tape_open
comma
id|release
suffix:colon
id|qic02_tape_release
comma
)brace
suffix:semicolon
DECL|function|qic02_release_resources
r_static
r_void
id|qic02_release_resources
c_func
(paren
r_void
)paren
(brace
id|free_irq
c_func
(paren
id|QIC02_TAPE_IRQ
comma
l_int|NULL
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|QIC02_TAPE_DMA
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|QIC02_TAPE_PORT
comma
id|QIC02_TAPE_PORT_RANGE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffaddr
)paren
(brace
id|free_pages
c_func
(paren
id|buffaddr
comma
id|get_order
c_func
(paren
id|TPQBUF_SIZE
)paren
)paren
suffix:semicolon
)brace
id|buffaddr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Better to cause a panic than overwite someone else */
id|status_zombie
op_assign
id|YES
suffix:semicolon
)brace
multiline_comment|/* qic02_release_resources */
DECL|function|qic02_get_resources
r_static
r_int
id|qic02_get_resources
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* First perform some checks. If one of them fails,&n;     * the tape driver will not be registered to the system.&n;     */
r_if
c_cond
(paren
id|QIC02_TAPE_IRQ
OG
l_int|16
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;Bogus interrupt number.&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* for DYNCONF, allocating IO, DMA and IRQ should not be done until &n;     * the config parameters have been set using MTSETCONFIG.&n;     */
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|QIC02_TAPE_PORT
comma
id|QIC02_TAPE_PORT_RANGE
)paren
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: IO space at 0x%x [%d ports] already reserved&bslash;n&quot;
comma
id|QIC02_TAPE_PORT
comma
id|QIC02_TAPE_PORT_RANGE
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* get IRQ */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|QIC02_TAPE_IRQ
comma
id|qic02_tape_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;QIC-02&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: can&squot;t allocate IRQ%d for QIC-02 tape&bslash;n&quot;
comma
id|QIC02_TAPE_IRQ
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* After IRQ, allocate DMA channel */
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|QIC02_TAPE_DMA
comma
l_string|&quot;QIC-02&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: can&squot;t allocate DMA%d for QIC-02 tape&bslash;n&quot;
comma
id|QIC02_TAPE_DMA
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|QIC02_TAPE_IRQ
comma
l_int|NULL
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* Grab the IO region. We already made sure it&squot;s available. */
id|request_region
c_func
(paren
id|QIC02_TAPE_PORT
comma
id|QIC02_TAPE_PORT_RANGE
comma
id|TPQIC02_NAME
)paren
suffix:semicolon
multiline_comment|/* Setup the page-address for the dma transfer. */
multiline_comment|/*** TODO: does _get_dma_pages() really return the physical address?? ****/
id|buffaddr
op_assign
id|__get_dma_pages
c_func
(paren
id|GFP_KERNEL
comma
id|get_order
c_func
(paren
id|TPQBUF_SIZE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffaddr
)paren
(brace
id|qic02_release_resources
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* Not ideal, EAGAIN perhaps? */
)brace
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
id|buffaddr
comma
l_int|0
comma
id|TPQBUF_SIZE
)paren
suffix:semicolon
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: Settings: IRQ %d, DMA %d, IO 0x%x, IFC %s&bslash;n&quot;
comma
id|QIC02_TAPE_IRQ
comma
id|QIC02_TAPE_DMA
comma
(paren
(paren
id|QIC02_TAPE_IFC
op_eq
id|ARCHIVE
)paren
op_logical_or
(paren
id|QIC02_TAPE_IFC
op_eq
id|MOUNTAIN
)paren
)paren
ques
c_cond
id|QIC02_CMD_PORT
suffix:colon
id|QIC02_STAT_PORT
comma
(paren
id|QIC02_TAPE_IFC
op_eq
id|MOUNTAIN
)paren
ques
c_cond
l_string|&quot;Mountain&quot;
suffix:colon
(paren
(paren
id|QIC02_TAPE_IFC
op_eq
id|ARCHIVE
)paren
ques
c_cond
l_string|&quot;Archive&quot;
suffix:colon
l_string|&quot;Wangtek&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape_reset
c_func
(paren
l_int|0
)paren
op_ne
id|TE_OK
op_logical_or
id|tp_sense
c_func
(paren
id|TP_WRP
op_or
id|TP_POR
op_or
id|TP_CNI
)paren
op_ne
id|TE_OK
)paren
(brace
multiline_comment|/* No drive detected, so vanish */
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;No drive detected -- releasing IO/IRQ/DMA.&quot;
)paren
suffix:semicolon
id|status_dead
op_assign
id|YES
suffix:semicolon
id|qic02_release_resources
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* All should be ok now */
id|status_zombie
op_assign
id|NO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* qic02_get_resources */
DECL|function|qic02_tape_init
r_int
id|__init
id|qic02_tape_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|TPSTATSIZE
op_ne
l_int|6
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: internal error: tpstatus struct incorrect!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|TPQBUF_SIZE
OL
l_int|512
)paren
op_logical_or
(paren
id|TPQBUF_SIZE
op_ge
l_int|0x10000
)paren
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: internal error: DMA buffer size out of range&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|current_tape_dev
op_assign
id|MKDEV
c_func
(paren
id|QIC02_TAPE_MAJOR
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_QIC02_DYNCONF
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: IRQ %d, DMA %d, IO 0x%x, IFC %s, %s, %s&bslash;n&quot;
comma
id|QIC02_TAPE_IRQ
comma
id|QIC02_TAPE_DMA
comma
macro_line|# if QIC02_TAPE_IFC == WANGTEK
id|QIC02_STAT_PORT
comma
l_string|&quot;Wangtek&quot;
comma
macro_line|# elif QIC02_TAPE_IFC == ARCHIVE
id|QIC02_CMD_PORT
comma
l_string|&quot;Archive&quot;
comma
macro_line|# elif QIC02_TAPE_IFC == MOUNTAIN
id|QIC02_CMD_PORT
comma
l_string|&quot;Mountain&quot;
comma
macro_line|# else
macro_line|#  error
macro_line|# endif
id|rcs_revision
comma
id|rcs_date
)paren
suffix:semicolon
r_if
c_cond
(paren
id|qic02_get_resources
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#else
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: Runtime config, %s, %s&bslash;n&quot;
comma
id|rcs_revision
comma
id|rcs_date
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: DMA buffers: %u blocks&bslash;n&quot;
comma
id|NR_BLK_BUF
)paren
suffix:semicolon
multiline_comment|/* If we got this far, install driver functions */
r_if
c_cond
(paren
id|devfs_register_chrdev
c_func
(paren
id|QIC02_TAPE_MAJOR
comma
id|TPQIC02_NAME
comma
op_amp
id|qic02_tape_fops
)paren
)paren
(brace
id|printk
c_func
(paren
id|TPQIC02_NAME
l_string|&quot;: Unable to get chrdev major %d&bslash;n&quot;
comma
id|QIC02_TAPE_MAJOR
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_QIC02_DYNCONF
id|qic02_release_resources
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|devfs_register
(paren
l_int|NULL
comma
l_string|&quot;ntpqic11&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|QIC02_TAPE_MAJOR
comma
l_int|2
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
op_or
id|S_IWGRP
comma
op_amp
id|qic02_tape_fops
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register
(paren
l_int|NULL
comma
l_string|&quot;tpqic11&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|QIC02_TAPE_MAJOR
comma
l_int|3
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
op_or
id|S_IWGRP
comma
op_amp
id|qic02_tape_fops
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register
(paren
l_int|NULL
comma
l_string|&quot;ntpqic24&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|QIC02_TAPE_MAJOR
comma
l_int|4
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
op_or
id|S_IWGRP
comma
op_amp
id|qic02_tape_fops
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register
(paren
l_int|NULL
comma
l_string|&quot;tpqic24&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|QIC02_TAPE_MAJOR
comma
l_int|5
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
op_or
id|S_IWGRP
comma
op_amp
id|qic02_tape_fops
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register
(paren
l_int|NULL
comma
l_string|&quot;ntpqic120&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|QIC02_TAPE_MAJOR
comma
l_int|6
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
op_or
id|S_IWGRP
comma
op_amp
id|qic02_tape_fops
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register
(paren
l_int|NULL
comma
l_string|&quot;tpqic120&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|QIC02_TAPE_MAJOR
comma
l_int|7
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
op_or
id|S_IWGRP
comma
op_amp
id|qic02_tape_fops
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register
(paren
l_int|NULL
comma
l_string|&quot;ntpqic150&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|QIC02_TAPE_MAJOR
comma
l_int|8
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
op_or
id|S_IWGRP
comma
op_amp
id|qic02_tape_fops
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register
(paren
l_int|NULL
comma
l_string|&quot;tpqic150&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|QIC02_TAPE_MAJOR
comma
l_int|9
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
op_or
id|S_IWGRP
comma
op_amp
id|qic02_tape_fops
comma
l_int|NULL
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|qic02_tape_transfer
)paren
suffix:semicolon
multiline_comment|/* prepare timer */
id|TIMEROFF
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|tp_timer
)paren
suffix:semicolon
id|tp_timer.function
op_assign
id|qic02_tape_times_out
suffix:semicolon
macro_line|#ifndef CONFIG_QIC02_DYNCONF
r_if
c_cond
(paren
id|tape_reset
c_func
(paren
l_int|0
)paren
op_ne
id|TE_OK
op_logical_or
id|tp_sense
c_func
(paren
id|TP_WRP
op_or
id|TP_POR
op_or
id|TP_CNI
)paren
op_ne
id|TE_OK
)paren
(brace
multiline_comment|/* No drive detected, so vanish */
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;No drive detected -- driver going on vacation...&quot;
)paren
suffix:semicolon
id|qic02_release_resources
c_func
(paren
)paren
suffix:semicolon
id|status_dead
op_assign
id|YES
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|is_exception
c_func
(paren
)paren
)paren
(brace
id|tpqputs
c_func
(paren
id|TPQD_ALWAYS
comma
l_string|&quot;exception detected&bslash;n&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|tp_sense
c_func
(paren
id|TP_WRP
op_or
id|TP_POR
op_or
id|TP_CNI
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/* initialize generic status for ioctl requests */
id|ioctl_status.mt_type
op_assign
id|QIC02_TAPE_DRIVE
suffix:semicolon
multiline_comment|/* MT_IS* id nr */
id|ioctl_status.mt_resid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ---residual count */
id|ioctl_status.mt_gstat
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ---generic status */
id|ioctl_status.mt_erreg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* not used */
id|ioctl_status.mt_fileno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of current file on tape */
id|ioctl_status.mt_blkno
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* number of current (logical) block */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* qic02_tape_init */
macro_line|#ifdef MODULE
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|status_zombie
op_eq
id|NO
)paren
(brace
id|qic02_release_resources
c_func
(paren
)paren
suffix:semicolon
)brace
id|devfs_unregister_chrdev
c_func
(paren
id|QIC02_TAPE_MAJOR
comma
id|TPQIC02_NAME
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|devfs_find_handle
c_func
(paren
l_int|NULL
comma
l_string|&quot;ntpqic11&quot;
comma
id|QIC02_TAPE_MAJOR
comma
l_int|2
comma
id|DEVFS_SPECIAL_CHR
comma
l_int|0
)paren
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|devfs_find_handle
c_func
(paren
l_int|NULL
comma
l_string|&quot;tpqic11&quot;
comma
id|QIC02_TAPE_MAJOR
comma
l_int|3
comma
id|DEVFS_SPECIAL_CHR
comma
l_int|0
)paren
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|devfs_find_handle
c_func
(paren
l_int|NULL
comma
l_string|&quot;ntpqic24&quot;
comma
id|QIC02_TAPE_MAJOR
comma
l_int|4
comma
id|DEVFS_SPECIAL_CHR
comma
l_int|0
)paren
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|devfs_find_handle
c_func
(paren
l_int|NULL
comma
l_string|&quot;tpqic24&quot;
comma
id|QIC02_TAPE_MAJOR
comma
l_int|5
comma
id|DEVFS_SPECIAL_CHR
comma
l_int|0
)paren
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|devfs_find_handle
c_func
(paren
l_int|NULL
comma
l_string|&quot;ntpqic120&quot;
comma
id|QIC02_TAPE_MAJOR
comma
l_int|6
comma
id|DEVFS_SPECIAL_CHR
comma
l_int|0
)paren
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|devfs_find_handle
c_func
(paren
l_int|NULL
comma
l_string|&quot;tpqic120&quot;
comma
id|QIC02_TAPE_MAJOR
comma
l_int|7
comma
id|DEVFS_SPECIAL_CHR
comma
l_int|0
)paren
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|devfs_find_handle
c_func
(paren
l_int|NULL
comma
l_string|&quot;ntpqic150&quot;
comma
id|QIC02_TAPE_MAJOR
comma
l_int|8
comma
id|DEVFS_SPECIAL_CHR
comma
l_int|0
)paren
)paren
suffix:semicolon
id|devfs_unregister
c_func
(paren
id|devfs_find_handle
c_func
(paren
l_int|NULL
comma
l_string|&quot;tpqic150&quot;
comma
id|QIC02_TAPE_MAJOR
comma
l_int|9
comma
id|DEVFS_SPECIAL_CHR
comma
l_int|0
)paren
)paren
suffix:semicolon
)brace
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|retval
suffix:semicolon
id|retval
op_assign
id|qic02_tape_init
c_func
(paren
)paren
suffix:semicolon
macro_line|# ifdef CONFIG_QIC02_DYNCONF
multiline_comment|/* This allows the dynamic config program to setup the card&n;     * by presetting qic02_tape_dynconf via insmod&n;     */
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|qic02_tape_dynconf.ifc_type
)paren
(brace
id|retval
op_assign
id|update_ifc_masks
c_func
(paren
id|qic02_tape_dynconf.ifc_type
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|cleanup_module
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|# endif
r_return
id|retval
suffix:semicolon
)brace
macro_line|#endif
eof
