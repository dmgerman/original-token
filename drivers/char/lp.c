multiline_comment|/*&n; * Generic parallel printer driver&n; *&n; * Copyright (C) 1992 by Jim Weigand and Linus Torvalds&n; * Copyright (C) 1992,1993 by Michael K. Johnson&n; * - Thanks much to Gunter Windau for pointing out to me where the error&n; *   checking ought to be.&n; * Copyright (C) 1993 by Nigel Gamble (added interrupt code)&n; * Copyright (C) 1994 by Alan Cox (Modularised it)&n; * LPCAREFUL, LPABORT, LPGETSTATUS added by Chris Metcalf, metcalf@lcs.mit.edu&n; * Statistics and support for slow printers by Rob Janssen, rob@knoware.nl&n; * &quot;lp=&quot; command line parameters added by Grant Guenther, grant@torque.net&n; * lp_read (Status readback) support added by Carsten Gross,&n; *                                             carsten@sol.wohnheim.uni-ulm.de&n; * Support for parport by Philip Blundell &lt;Philip.Blundell@pobox.com&gt;&n; * Parport sharing hacking by Andrea Arcangeli&n; * Fixed kernel_(to/from)_user memory copy to check for errors&n; * &t;&t;&t;&t;by Riccardo Facchetti &lt;fizban@tin.it&gt;&n; * Redesigned interrupt handling for handle printers with buggy handshake&n; *&t;&t;&t;&t;by Andrea Arcangeli, 11 May 1998&n; * Full efficient handling of printer with buggy irq handshake (now I have&n; * understood the meaning of the strange handshake). This is done sending new&n; * characters if the interrupt is just happened, even if the printer say to&n; * be still BUSY. This is needed at least with Epson Stylus Color. To enable&n; * the new TRUST_IRQ mode read the `LP OPTIMIZATION&squot; section below...&n; * Fixed the irq on the rising edge of the strobe case.&n; * Obsoleted the CAREFUL flag since a printer that doesn&squot; t work with&n; * CAREFUL will block a bit after in lp_check_status().&n; *&t;&t;&t;&t;Andrea Arcangeli, 15 Oct 1998&n; */
multiline_comment|/* This driver should, in theory, work with any parallel port that has an&n; * appropriate low-level driver; all I/O is done through the parport&n; * abstraction layer.&n; *&n; * If this driver is built into the kernel, you can configure it using the&n; * kernel command-line.  For example:&n; *&n; *&t;lp=parport1,none,parport2&t;(bind lp0 to parport1, disable lp1 and&n; *&t;&t;&t;&t;&t; bind lp2 to parport2)&n; *&n; *&t;lp=auto&t;&t;&t;&t;(assign lp devices to all ports that&n; *&t;&t;&t;&t;         have printers attached, as determined&n; *&t;&t;&t;&t;&t; by the IEEE-1284 autoprobe)&n; * &n; *&t;lp=reset&t;&t;&t;(reset the printer during &n; *&t;&t;&t;&t;&t; initialisation)&n; *&n; *&t;lp=off&t;&t;&t;&t;(disable the printer driver entirely)&n; *&n; * If the driver is loaded as a module, similar functionality is available&n; * using module parameters.  The equivalent of the above commands would be:&n; *&n; *&t;# insmod lp.o parport=1,none,2&n; *&n; *&t;# insmod lp.o parport=auto&n; *&n; *&t;# insmod lp.o reset=1&n; */
multiline_comment|/*&n; * LP OPTIMIZATIONS&n; *&n; * - TRUST_IRQ flag&n; * &n; * Epson Stylus Color, HP and many other new printers want the TRUST_IRQ flag&n; * set when printing with interrupts. This is a long story. Such printers&n; * use a broken handshake (see the timing graph below) when printing with&n; * interrupts. The lp driver as default is just able to handle such bogus&n; * handshake, but setting such flag cause lp to go faster and probably do&n; * what such printers want (even if not documented).&n; *&n; * NOTE that setting the TRUST_IRQ flag in some printer can cause the irq&n; * printing to fail completly. You must try, to know if your printer&n; * will handle it. I suggest a graphics printing to force a major flow of&n; * characters to the printer for do the test. NOTE also that the TRUST_IRQ&n; * flag _should_ be fine everywhere but there is a lot of buggy hardware out&n; * there, so I am forced to implement it as a not-default thing.&n; * WARNING: before to do the test, be sure to have not played with the&n; * `-w&squot; parameter of tunelp!&n; *&n; * Note also that lp automagically warn you (with a KERN_WARNING) if it&n; * detects that you could _try_ to set the TRUST_IRQ flag to speed up the&n; * printing and decrease the CPU load.&n; *&n; * To set the TRUST_IRQ flag you can use this command:&n; *&n; * tunelp /dev/lp? -T on&n; *&n; * If you have an old tunelp executable you can (hack and) use this simple&n; * C lazy proggy to set the flag in the lp driver:&n;&n;-------------------------- cut here -------------------------------------&n;#include &lt;fcntl.h&gt;&n;#include &lt;sys/ioctl.h&gt;&n;&n;#define&t;LPTRUSTIRQ  0x060f&n;&n;int main(int argc, char **argv)&n;{&n;&t;int fd = open(&quot;/dev/lp0&quot;, O_RDONLY);&n;&t;ioctl(fd, LPTRUSTIRQ, argc - 1);&n;&t;if (argc - 1)&n;&t;&t;printf(&quot;trusting the irq&bslash;n&quot;);&n;&t;else&n;&t;&t;printf(&quot;untrusting the irq&bslash;n&quot;);&n;&t;return 0;&n;}&n;-------------------------- cut here -------------------------------------&n;&n; * - LP_WAIT time&n; *&n; * You can use this setting if your printer is fast enough and/or your&n; * machine is slow enough ;-).&n; *&n; * tunelp /dev/lp? -w 0&n; *&n; * - LP_CHAR tries&n; *&n; * If you print with irqs probably you can decrease the CPU load a lot using&n; * this setting. This is not the default because the printing is reported to&n; * be jerky somewhere...&n; *&n; * tunelp /dev/lp? -c 1&n; *&n; *&t;&t;&t;&t;&t;11 Nov 1998, Andrea Arcangeli&n; */
multiline_comment|/* COMPATIBILITY WITH OLD KERNELS&n; *&n; * Under Linux 2.0 and previous versions, lp devices were bound to ports at&n; * particular I/O addresses, as follows:&n; *&n; *&t;lp0&t;&t;0x3bc&n; *&t;lp1&t;&t;0x378&n; *&t;lp2&t;&t;0x278&n; *&n; * The new driver, by default, binds lp devices to parport devices as it&n; * finds them.  This means that if you only have one port, it will be bound&n; * to lp0 regardless of its I/O address.  If you need the old behaviour, you&n; * can force it using the parameters described above.&n; */
multiline_comment|/*&n; * The new interrupt handling code take care of the buggy handshake&n; * of some HP and Epson printer:&n; * ___&n; * ACK    _______________    ___________&n; *                       |__|&n; * ____&n; * BUSY   _________              _______&n; *                 |____________|&n; *&n; * I discovered this using the printer scanner that you can find at:&n; *&n; *&t;ftp://e-mind.com/pub/linux/pscan/&n; *&n; *&t;&t;&t;&t;&t;11 May 98, Andrea Arcangeli&n; *&n; * My printer scanner run on an Epson Stylus Color show that such printer&n; * generates the irq on the _rising_ edge of the STROBE. Now lp handle&n; * this case fine too.&n; *&n; *&t;&t;&t;&t;&t;15 Oct 1998, Andrea Arcangeli&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
DECL|macro|LP_STATS
macro_line|#undef LP_STATS
macro_line|#include &lt;linux/lp.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/* if you have more than 3 printers, remember to increase LP_NO */
DECL|macro|LP_NO
mdefine_line|#define LP_NO 3
DECL|variable|lp_table
r_struct
id|lp_struct
id|lp_table
(braket
id|LP_NO
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|LP_NO
op_minus
l_int|1
)braket
op_assign
(brace
l_int|NULL
comma
l_int|0
comma
id|LP_INIT_CHAR
comma
id|LP_INIT_TIME
comma
id|LP_INIT_WAIT
comma
l_int|NULL
comma
macro_line|#ifdef LP_STATS
l_int|0
comma
l_int|0
comma
(brace
l_int|0
)brace
comma
macro_line|#endif
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/* Test if printer is ready */
DECL|macro|LP_READY
mdefine_line|#define&t;LP_READY(status)&t;((status) &amp; LP_PBUSY)
multiline_comment|/* Test if the printer is not acking the strobe */
DECL|macro|LP_NO_ACKING
mdefine_line|#define&t;LP_NO_ACKING(status)&t;((status) &amp; LP_PACK)
multiline_comment|/* Test if the printer has error conditions */
DECL|macro|LP_NO_ERROR
mdefine_line|#define LP_NO_ERROR(status)&t;&t;&t;&t;&t;&bslash;&n;&t; (((status) &amp; (LP_POUTPA|LP_PSELECD|LP_PERRORP)) ==&t;&bslash;&n;&t; (LP_PSELECD|LP_PERRORP))
DECL|macro|LP_DEBUG
macro_line|#undef LP_DEBUG
DECL|macro|LP_READ_DEBUG
macro_line|#undef LP_READ_DEBUG
multiline_comment|/* --- parport support ----------------------------------------- */
DECL|function|lp_preempt
r_static
r_int
id|lp_preempt
c_func
(paren
r_void
op_star
id|handle
)paren
(brace
r_struct
id|lp_struct
op_star
id|lps
op_assign
(paren
r_struct
id|lp_struct
op_star
)paren
id|handle
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
(paren
op_amp
id|lps-&gt;wait_q
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|lps-&gt;wait_q
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t actually release the port now */
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|lp_parport_release
mdefine_line|#define lp_parport_release(x)&t;do { parport_release(lp_table[(x)].dev); } while (0);
DECL|macro|lp_parport_claim
mdefine_line|#define lp_parport_claim(x)&t;do { parport_claim_or_block(lp_table[(x)].dev); } while (0);
multiline_comment|/* --- low-level port access ----------------------------------- */
DECL|macro|r_dtr
mdefine_line|#define r_dtr(x)&t;(parport_read_data(lp_table[(x)].dev-&gt;port))
DECL|macro|r_str
mdefine_line|#define r_str(x)&t;(parport_read_status(lp_table[(x)].dev-&gt;port))
DECL|macro|w_ctr
mdefine_line|#define w_ctr(x,y)&t;do { parport_write_control(lp_table[(x)].dev-&gt;port, (y)); } while (0)
DECL|macro|w_dtr
mdefine_line|#define w_dtr(x,y)&t;do { parport_write_data(lp_table[(x)].dev-&gt;port, (y)); } while (0)
DECL|function|lp_yield
r_static
id|__inline__
r_void
id|lp_yield
(paren
r_int
id|minor
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|parport_yield_blocking
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev
)paren
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;need_resched
)paren
id|schedule
(paren
)paren
suffix:semicolon
)brace
r_else
id|lp_table
(braket
id|minor
)braket
dot
id|irq_missed
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|lp_schedule
r_static
id|__inline__
r_void
id|lp_schedule
c_func
(paren
r_int
id|minor
comma
r_int
id|timeout
)paren
(brace
r_struct
id|pardevice
op_star
id|dev
op_assign
id|lp_table
(braket
id|minor
)braket
dot
id|dev
suffix:semicolon
r_register
r_int
r_int
r_int
id|timeslip
op_assign
(paren
id|jiffies
op_minus
id|dev-&gt;time
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|timeslip
OG
id|dev-&gt;timeslice
)paren
op_logical_and
(paren
id|dev-&gt;port-&gt;waithead
op_ne
l_int|NULL
)paren
)paren
(brace
id|lp_parport_release
c_func
(paren
id|minor
)paren
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|irq_missed
op_assign
l_int|1
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
id|lp_parport_claim
c_func
(paren
id|minor
)paren
suffix:semicolon
)brace
r_else
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
)brace
DECL|function|lp_reset
r_static
r_int
id|lp_reset
c_func
(paren
r_int
id|minor
)paren
(brace
r_int
id|retval
suffix:semicolon
id|lp_parport_claim
(paren
id|minor
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
)paren
suffix:semicolon
id|udelay
(paren
id|LP_DELAY
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
)paren
suffix:semicolon
id|retval
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
id|lp_parport_release
(paren
id|minor
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|macro|lp_wait
mdefine_line|#define&t;lp_wait(minor)&t;udelay(LP_WAIT(minor))
DECL|function|lp_char
r_static
r_inline
r_int
id|lp_char
c_func
(paren
r_char
id|lpchar
comma
r_int
id|minor
)paren
(brace
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef LP_STATS
r_struct
id|lp_stats
op_star
id|stats
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
r_int
id|irq_ok
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Give a chance to other pardevice to run in the meantime.&n;&t;&t; */
id|lp_yield
c_func
(paren
id|minor
)paren
suffix:semicolon
id|status
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LP_NO_ERROR
c_func
(paren
id|status
)paren
)paren
(brace
r_if
c_cond
(paren
id|LP_READY
c_func
(paren
id|status
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * This is a crude hack that should be well known&n;&t;&t;&t; * at least by Epson device driver developers. -arca&n;&t;&t;&t; */
id|irq_ok
op_assign
(paren
op_logical_neg
id|LP_POLLED
c_func
(paren
id|minor
)paren
op_logical_and
id|LP_NO_ACKING
c_func
(paren
id|status
)paren
op_logical_and
id|lp_table
(braket
id|minor
)braket
dot
id|irq_detected
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_TRUST_IRQ
)paren
op_logical_and
id|irq_ok
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * NOTE: if you run with irqs you _must_ use&n;&t;&t; * `tunelp /dev/lp? -c 1&squot; to be rasonable efficient!&n;&t;&t; */
r_if
c_cond
(paren
op_increment
id|count
op_eq
id|LP_CHAR
c_func
(paren
id|minor
)paren
)paren
(brace
r_if
c_cond
(paren
id|irq_ok
)paren
(brace
r_static
r_int
id|first_time
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * The printer is using a buggy handshake, so&n;&t;&t;&t;&t; * revert to polling to not overload the&n;&t;&t;&t;&t; * machine and warn the user that its printer&n;&t;&t;&t;&t; * could get optimized trusting the irq. -arca&n;&t;&t;&t;&t; */
id|lp_table
(braket
id|minor
)braket
dot
id|irq_missed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|first_time
)paren
(brace
id|first_time
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;lp%d: the &quot;
l_string|&quot;printing could be optimized &quot;
l_string|&quot;using the TRUST_IRQ flag, &quot;
l_string|&quot;see the top of &quot;
l_string|&quot;linux/drivers/char/lp.c&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|w_dtr
c_func
(paren
id|minor
comma
id|lpchar
)paren
suffix:semicolon
macro_line|#ifdef LP_STATS
id|stats
op_assign
op_amp
id|LP_STAT
c_func
(paren
id|minor
)paren
suffix:semicolon
id|stats-&gt;chars
op_increment
suffix:semicolon
macro_line|#endif
multiline_comment|/* must wait before taking strobe high, and after taking strobe&n;&t;   low, according spec.  Some printers need it, others don&squot;t. */
id|lp_wait
c_func
(paren
id|minor
)paren
suffix:semicolon
multiline_comment|/* control port takes strobe high */
r_if
c_cond
(paren
id|LP_POLLED
c_func
(paren
id|minor
)paren
)paren
(brace
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
op_or
id|LP_PSTROBE
)paren
suffix:semicolon
id|lp_wait
c_func
(paren
id|minor
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Epson Stylus Color generate the IRQ on the rising edge of&n;&t;&t; * strobe so clean the irq&squot;s information before playing with&n;&t;&t; * the strobe. -arca&n;&t;&t; */
id|lp_table
(braket
id|minor
)braket
dot
id|irq_detected
op_assign
l_int|0
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|irq_missed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Be sure that the CPU doesn&squot; t reorder instructions. -arca&n;&t;&t; */
id|mb
c_func
(paren
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
op_or
id|LP_PSTROBE
op_or
id|LP_PINTEN
)paren
suffix:semicolon
id|lp_wait
c_func
(paren
id|minor
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
op_or
id|LP_PINTEN
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Give to the printer a chance to put BUSY low. Really we could&n;&t; * remove this because we could _guess_ that we are slower to reach&n;&t; * again lp_char() than the printer to put BUSY low, but I&squot; d like&n;&t; * to remove this variable from the function I go solve&n;&t; * when I read bug reports ;-). -arca&n;&t; */
id|lp_wait
c_func
(paren
id|minor
)paren
suffix:semicolon
macro_line|#ifdef LP_STATS
multiline_comment|/* update waittime statistics */
r_if
c_cond
(paren
id|count
OG
id|stats-&gt;maxwait
)paren
(brace
macro_line|#ifdef LP_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;lp%d success after %d counts.&bslash;n&quot;
comma
id|minor
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
id|stats-&gt;maxwait
op_assign
id|count
suffix:semicolon
)brace
id|count
op_mul_assign
l_int|256
suffix:semicolon
id|wait
op_assign
(paren
id|count
OG
id|stats-&gt;meanwait
)paren
ques
c_cond
id|count
op_minus
id|stats-&gt;meanwait
suffix:colon
id|stats-&gt;meanwait
op_minus
id|count
suffix:semicolon
id|stats-&gt;meanwait
op_assign
(paren
l_int|255
op_star
id|stats-&gt;meanwait
op_plus
id|count
op_plus
l_int|128
)paren
op_div
l_int|256
suffix:semicolon
id|stats-&gt;mdev
op_assign
(paren
(paren
l_int|127
op_star
id|stats-&gt;mdev
)paren
op_plus
id|wait
op_plus
l_int|64
)paren
op_div
l_int|128
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|lp_interrupt
r_static
r_void
id|lp_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|lp_struct
op_star
id|lp_dev
op_assign
(paren
r_struct
id|lp_struct
op_star
)paren
id|dev_id
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
(paren
op_amp
id|lp_dev-&gt;wait_q
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|lp_dev-&gt;wait_q
)paren
suffix:semicolon
id|lp_dev-&gt;irq_detected
op_assign
l_int|1
suffix:semicolon
id|lp_dev-&gt;irq_missed
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|lp_error
r_static
r_void
id|lp_error
c_func
(paren
r_int
id|minor
)paren
(brace
r_if
c_cond
(paren
id|LP_POLLED
c_func
(paren
id|minor
)paren
op_logical_or
id|LP_PREEMPTED
c_func
(paren
id|minor
)paren
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|lp_parport_release
c_func
(paren
id|minor
)paren
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|LP_TIMEOUT_POLLED
)paren
suffix:semicolon
id|lp_parport_claim
c_func
(paren
id|minor
)paren
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|irq_missed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|lp_check_status
r_static
r_int
id|lp_check_status
c_func
(paren
r_int
id|minor
)paren
(brace
r_int
r_int
id|last
op_assign
id|lp_table
(braket
id|minor
)braket
dot
id|last_error
suffix:semicolon
r_int
r_char
id|status
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|LP_POUTPA
)paren
)paren
(brace
r_if
c_cond
(paren
id|last
op_ne
id|LP_POUTPA
)paren
(brace
id|last
op_assign
id|LP_POUTPA
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d out of paper&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PSELECD
)paren
)paren
(brace
r_if
c_cond
(paren
id|last
op_ne
id|LP_PSELECD
)paren
(brace
id|last
op_assign
id|LP_PSELECD
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d off-line&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PERRORP
)paren
)paren
(brace
r_if
c_cond
(paren
id|last
op_ne
id|LP_PERRORP
)paren
(brace
id|last
op_assign
id|LP_PERRORP
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;lp%d on fire!&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
)brace
)brace
r_else
id|last
op_assign
l_int|0
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|last_error
op_assign
id|last
suffix:semicolon
r_if
c_cond
(paren
id|last
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_ABORT
)paren
r_return
l_int|1
suffix:semicolon
id|lp_error
c_func
(paren
id|minor
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lp_write_buf
r_static
r_int
id|lp_write_buf
c_func
(paren
r_int
r_int
id|minor
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|copy_size
suffix:semicolon
r_int
r_int
id|total_bytes_written
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|bytes_written
suffix:semicolon
r_struct
id|lp_struct
op_star
id|lp
op_assign
op_amp
id|lp_table
(braket
id|minor
)braket
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|LP_NO
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|lp-&gt;dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|last_error
op_assign
l_int|0
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|irq_detected
op_assign
l_int|0
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|irq_missed
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|LP_POLLED
c_func
(paren
id|minor
)paren
)paren
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
)paren
suffix:semicolon
r_else
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
op_or
id|LP_PINTEN
)paren
suffix:semicolon
r_do
(brace
id|bytes_written
op_assign
l_int|0
suffix:semicolon
id|copy_size
op_assign
(paren
id|count
op_le
id|LP_BUFFER_SIZE
ques
c_cond
id|count
suffix:colon
id|LP_BUFFER_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|lp-&gt;lp_buffer
comma
id|buf
comma
id|copy_size
)paren
)paren
(brace
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_while
c_loop
(paren
id|copy_size
)paren
(brace
r_if
c_cond
(paren
id|lp_char
c_func
(paren
id|lp-&gt;lp_buffer
(braket
id|bytes_written
)braket
comma
id|minor
)paren
)paren
(brace
op_decrement
id|copy_size
suffix:semicolon
op_increment
id|bytes_written
suffix:semicolon
macro_line|#ifdef LP_STATS
id|lp-&gt;runchars
op_increment
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
r_int
id|rc
op_assign
id|total_bytes_written
op_plus
id|bytes_written
suffix:semicolon
macro_line|#ifdef LP_STATS
r_if
c_cond
(paren
id|lp-&gt;runchars
OG
id|LP_STAT
c_func
(paren
id|minor
)paren
dot
id|maxrun
)paren
id|LP_STAT
c_func
(paren
id|minor
)paren
dot
id|maxrun
op_assign
id|lp-&gt;runchars
suffix:semicolon
id|LP_STAT
c_func
(paren
id|minor
)paren
dot
id|sleeps
op_increment
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|total_bytes_written
op_plus
id|bytes_written
)paren
r_return
id|total_bytes_written
op_plus
id|bytes_written
suffix:semicolon
r_else
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
macro_line|#ifdef LP_STATS
id|lp-&gt;runchars
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|lp_check_status
c_func
(paren
id|minor
)paren
)paren
(brace
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
)paren
suffix:semicolon
r_return
id|rc
ques
c_cond
id|rc
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|LP_POLLED
c_func
(paren
id|minor
)paren
op_logical_or
id|lp_table
(braket
id|minor
)braket
dot
id|irq_missed
)paren
(brace
id|lp_polling
suffix:colon
macro_line|#if defined(LP_DEBUG) &amp;&amp; defined(LP_STATS)
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;lp%d sleeping at %d characters for %d jiffies&bslash;n&quot;
comma
id|minor
comma
id|lp-&gt;runchars
comma
id|LP_TIME
c_func
(paren
id|minor
)paren
)paren
suffix:semicolon
macro_line|#endif
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|lp_schedule
c_func
(paren
id|minor
comma
id|LP_TIME
c_func
(paren
id|minor
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LP_PREEMPTED
c_func
(paren
id|minor
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * We can&squot; t sleep on the interrupt&n;&t;&t;&t;&t;&t;&t; * since another pardevice need the port.&n;&t;&t;&t;&t;&t;&t; * We must check this in a cli() protected&n;&t;&t;&t;&t;&t;&t; * envinroment to avoid parport sharing&n;&t;&t;&t;&t;&t;&t; * starvation.&n;&t;&t;&t;&t;&t;&t; */
id|sti
c_func
(paren
)paren
suffix:semicolon
r_goto
id|lp_polling
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|lp_table
(braket
id|minor
)braket
dot
id|irq_detected
)paren
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|lp-&gt;wait_q
comma
id|LP_TIMEOUT_INTERRUPT
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
)brace
id|total_bytes_written
op_add_assign
id|bytes_written
suffix:semicolon
id|buf
op_add_assign
id|bytes_written
suffix:semicolon
id|count
op_sub_assign
id|bytes_written
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
)paren
suffix:semicolon
r_return
id|total_bytes_written
suffix:semicolon
)brace
DECL|function|lp_write
r_static
id|ssize_t
id|lp_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
)paren
suffix:semicolon
id|ssize_t
id|retv
suffix:semicolon
macro_line|#ifdef LP_STATS
r_if
c_cond
(paren
id|jiffies
op_minus
id|lp_table
(braket
id|minor
)braket
dot
id|lastcall
OG
id|LP_TIME
c_func
(paren
id|minor
)paren
)paren
id|lp_table
(braket
id|minor
)braket
dot
id|runchars
op_assign
l_int|0
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|lastcall
op_assign
id|jiffies
suffix:semicolon
macro_line|#endif
multiline_comment|/* Claim Parport or sleep until it becomes available&n; &t; */
id|lp_parport_claim
(paren
id|minor
)paren
suffix:semicolon
id|retv
op_assign
id|lp_write_buf
c_func
(paren
id|minor
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|lp_parport_release
(paren
id|minor
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
DECL|function|lp_lseek
r_static
r_int
r_int
id|lp_lseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PRINTER_READBACK
DECL|function|lp_read_nibble
r_static
r_int
id|lp_read_nibble
c_func
(paren
r_int
id|minor
)paren
(brace
r_int
r_char
id|i
suffix:semicolon
id|i
op_assign
id|r_str
c_func
(paren
id|minor
)paren
op_rshift
l_int|3
suffix:semicolon
id|i
op_and_assign
op_complement
l_int|8
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|0x10
)paren
op_eq
l_int|0
)paren
id|i
op_or_assign
l_int|8
suffix:semicolon
r_return
(paren
id|i
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
DECL|function|lp_read_terminate
r_static
r_void
id|lp_read_terminate
c_func
(paren
r_struct
id|parport
op_star
id|port
)paren
(brace
id|parport_write_control
c_func
(paren
id|port
comma
(paren
id|parport_read_control
c_func
(paren
id|port
)paren
op_amp
op_complement
l_int|2
)paren
op_or
l_int|8
)paren
suffix:semicolon
multiline_comment|/* SelectIN high, AutoFeed low */
r_if
c_cond
(paren
id|parport_wait_peripheral
c_func
(paren
id|port
comma
l_int|0x80
comma
l_int|0
)paren
)paren
multiline_comment|/* timeout, SelectIN high, Autofeed low */
r_return
suffix:semicolon
id|parport_write_control
c_func
(paren
id|port
comma
id|parport_read_control
c_func
(paren
id|port
)paren
op_or
l_int|2
)paren
suffix:semicolon
multiline_comment|/* AutoFeed high */
id|parport_wait_peripheral
c_func
(paren
id|port
comma
l_int|0x80
comma
l_int|0x80
)paren
suffix:semicolon
multiline_comment|/* no timeout possible, Autofeed low, SelectIN high */
id|parport_write_control
c_func
(paren
id|port
comma
(paren
id|parport_read_control
c_func
(paren
id|port
)paren
op_amp
op_complement
l_int|2
)paren
op_or
l_int|8
)paren
suffix:semicolon
)brace
multiline_comment|/* Status readback confirming to ieee1284 */
DECL|function|lp_read
r_static
id|ssize_t
id|lp_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|length
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
)paren
suffix:semicolon
r_char
op_star
id|temp
op_assign
id|buf
suffix:semicolon
id|ssize_t
id|count
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|z
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|Byte
op_assign
l_int|0
suffix:semicolon
r_struct
id|parport
op_star
id|port
op_assign
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port
suffix:semicolon
id|lp_parport_claim
(paren
id|minor
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|parport_ieee1284_nibble_mode_ok
c_func
(paren
id|port
comma
l_int|0
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Handshake failed. */
id|lp_read_terminate
c_func
(paren
id|port
)paren
suffix:semicolon
id|lp_parport_release
(paren
id|minor
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* No data. */
id|lp_read_terminate
c_func
(paren
id|port
)paren
suffix:semicolon
id|lp_parport_release
(paren
id|minor
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Data available. */
multiline_comment|/* Hack: Wait 10ms (between events 6 and 7) */
id|schedule_timeout
c_func
(paren
(paren
id|HZ
op_plus
l_int|99
)paren
op_div
l_int|100
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|i
op_increment
)paren
(brace
id|parport_frob_control
c_func
(paren
id|port
comma
l_int|2
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* AutoFeed high */
r_if
c_cond
(paren
id|parport_wait_peripheral
c_func
(paren
id|port
comma
l_int|0x40
comma
l_int|0
)paren
)paren
(brace
macro_line|#ifdef LP_READ_DEBUG
multiline_comment|/* Some peripherals just time out when they&squot;ve sent&n;&t;&t;&t;   all their data.  */
id|printk
c_func
(paren
l_string|&quot;%s: read1 timeout.&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|parport_frob_control
c_func
(paren
id|port
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* AutoFeed low */
r_break
suffix:semicolon
)brace
id|z
op_assign
id|lp_read_nibble
c_func
(paren
id|minor
)paren
suffix:semicolon
id|parport_frob_control
c_func
(paren
id|port
comma
l_int|2
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* AutoFeed low */
r_if
c_cond
(paren
id|parport_wait_peripheral
c_func
(paren
id|port
comma
l_int|0x40
comma
l_int|0x40
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: read2 timeout.&bslash;n&quot;
comma
id|port-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|Byte
op_or_assign
(paren
id|z
op_lshift
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp
)paren
(brace
r_if
c_cond
(paren
id|__put_user
(paren
id|Byte
comma
id|temp
)paren
)paren
(brace
id|count
op_assign
op_minus
id|EFAULT
suffix:semicolon
id|temp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|temp
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
op_eq
id|length
)paren
id|temp
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Does the error line indicate end of data? */
r_if
c_cond
(paren
(paren
id|parport_read_status
c_func
(paren
id|port
)paren
op_amp
id|LP_PERRORP
)paren
op_eq
id|LP_PERRORP
)paren
r_break
suffix:semicolon
)brace
r_else
id|Byte
op_assign
id|z
suffix:semicolon
)brace
id|lp_read_terminate
c_func
(paren
id|port
)paren
suffix:semicolon
id|lp_parport_release
(paren
id|minor
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
macro_line|#endif
DECL|function|lp_open
r_static
r_int
id|lp_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|LP_NO
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_EXIST
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|LP_BUSY_BIT_POS
comma
op_amp
id|LP_F
c_func
(paren
id|minor
)paren
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* If ABORTOPEN is set and the printer is offline or out of paper,&n;&t;   we may still want to open it to perform ioctl()s.  Therefore we&n;&t;   have commandeered O_NONBLOCK, even though it is being used in&n;&t;   a non-standard manner.  This is strictly a Linux hack, and&n;&t;   should most likely only ever be used by the tunelp application. */
r_if
c_cond
(paren
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_ABORTOPEN
)paren
op_logical_and
op_logical_neg
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
)paren
(brace
r_int
id|status
suffix:semicolon
id|lp_parport_claim
(paren
id|minor
)paren
suffix:semicolon
id|status
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
id|lp_parport_release
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|LP_POUTPA
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d out of paper&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_BUSY
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PSELECD
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d off-line&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_BUSY
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PERRORP
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;lp%d printer error&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_BUSY
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|lp_table
(braket
id|minor
)braket
dot
id|lp_buffer
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|LP_BUFFER_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp_table
(braket
id|minor
)braket
dot
id|lp_buffer
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_BUSY
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lp_release
r_static
r_int
id|lp_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|kfree_s
c_func
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|lp_buffer
comma
id|LP_BUFFER_SIZE
)paren
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|lp_buffer
op_assign
l_int|NULL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_BUSY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lp_ioctl
r_static
r_int
id|lp_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_int
id|status
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef LP_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;lp%d ioctl, cmd: 0x%x, arg: 0x%x&bslash;n&quot;
comma
id|minor
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|minor
op_ge
id|LP_NO
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_EXIST
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|LPTIME
suffix:colon
id|LP_TIME
c_func
(paren
id|minor
)paren
op_assign
id|arg
op_star
id|HZ
op_div
l_int|100
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPCHAR
suffix:colon
id|LP_CHAR
c_func
(paren
id|minor
)paren
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPABORT
suffix:colon
r_if
c_cond
(paren
id|arg
)paren
id|LP_F
c_func
(paren
id|minor
)paren
op_or_assign
id|LP_ABORT
suffix:semicolon
r_else
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPABORTOPEN
suffix:colon
r_if
c_cond
(paren
id|arg
)paren
id|LP_F
c_func
(paren
id|minor
)paren
op_or_assign
id|LP_ABORTOPEN
suffix:semicolon
r_else
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_ABORTOPEN
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef OBSOLETED
r_case
id|LPCAREFUL
suffix:colon
r_if
c_cond
(paren
id|arg
)paren
id|LP_F
c_func
(paren
id|minor
)paren
op_or_assign
id|LP_CAREFUL
suffix:semicolon
r_else
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_CAREFUL
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|LPTRUSTIRQ
suffix:colon
r_if
c_cond
(paren
id|arg
)paren
id|LP_F
c_func
(paren
id|minor
)paren
op_or_assign
id|LP_TRUST_IRQ
suffix:semicolon
r_else
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_TRUST_IRQ
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPWAIT
suffix:colon
id|LP_WAIT
c_func
(paren
id|minor
)paren
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPSETIRQ
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPGETIRQ
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
comma
op_amp
id|LP_IRQ
c_func
(paren
id|minor
)paren
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPGETSTATUS
suffix:colon
id|lp_parport_claim
c_func
(paren
id|minor
)paren
suffix:semicolon
id|status
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
id|lp_parport_release
c_func
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
comma
op_amp
id|status
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPRESET
suffix:colon
id|lp_reset
c_func
(paren
id|minor
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef LP_STATS
r_case
id|LPGETSTATS
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
comma
op_amp
id|LP_STAT
c_func
(paren
id|minor
)paren
comma
r_sizeof
(paren
r_struct
id|lp_stats
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
id|memset
c_func
(paren
op_amp
id|LP_STAT
c_func
(paren
id|minor
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|lp_stats
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_case
id|LPGETFLAGS
suffix:colon
id|status
op_assign
id|LP_F
c_func
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
comma
op_amp
id|status
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|lp_fops
r_static
r_struct
id|file_operations
id|lp_fops
op_assign
(brace
id|lp_lseek
comma
macro_line|#ifdef CONFIG_PRINTER_READBACK
id|lp_read
comma
macro_line|#else
l_int|NULL
comma
macro_line|#endif
id|lp_write
comma
l_int|NULL
comma
multiline_comment|/* lp_readdir */
l_int|NULL
comma
multiline_comment|/* lp_poll */
id|lp_ioctl
comma
l_int|NULL
comma
multiline_comment|/* lp_mmap */
id|lp_open
comma
l_int|NULL
comma
multiline_comment|/* flush */
id|lp_release
)brace
suffix:semicolon
multiline_comment|/* --- initialisation code ------------------------------------- */
macro_line|#ifdef MODULE
DECL|variable|parport_nr
r_static
r_int
id|parport_nr
(braket
id|LP_NO
)braket
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|LP_NO
op_minus
l_int|1
)braket
op_assign
id|LP_PARPORT_UNSPEC
)brace
suffix:semicolon
DECL|variable|parport
r_static
r_char
op_star
id|parport
(braket
id|LP_NO
)braket
op_assign
(brace
l_int|NULL
comma
)brace
suffix:semicolon
DECL|variable|reset
r_static
r_int
id|reset
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|parport
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|LP_NO
)paren
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|reset
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#else
DECL|variable|__initdata
r_static
r_int
id|parport_nr
(braket
id|LP_NO
)braket
id|__initdata
op_assign
(brace
(braket
l_int|0
dot
dot
dot
id|LP_NO
op_minus
l_int|1
)braket
op_assign
id|LP_PARPORT_UNSPEC
)brace
suffix:semicolon
DECL|variable|__initdata
r_static
r_int
id|reset
id|__initdata
op_assign
l_int|0
suffix:semicolon
DECL|variable|parport_ptr
r_static
r_int
id|parport_ptr
op_assign
l_int|0
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|lp_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|str
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_or
id|ints
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* disable driver on &quot;lp=&quot; or &quot;lp=0&quot; */
id|parport_nr
(braket
l_int|0
)braket
op_assign
id|LP_PARPORT_OFF
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;warning: &squot;lp=0x%x&squot; is deprecated, ignored&bslash;n&quot;
comma
id|ints
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;parport&quot;
comma
l_int|7
)paren
)paren
(brace
r_int
id|n
op_assign
id|simple_strtoul
c_func
(paren
id|str
op_plus
l_int|7
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_ptr
OL
id|LP_NO
)paren
id|parport_nr
(braket
id|parport_ptr
op_increment
)braket
op_assign
id|n
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp: too many ports, %s ignored.&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;auto&quot;
)paren
)paren
(brace
id|parport_nr
(braket
l_int|0
)braket
op_assign
id|LP_PARPORT_AUTO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;none&quot;
)paren
)paren
(brace
id|parport_nr
(braket
id|parport_ptr
op_increment
)braket
op_assign
id|LP_PARPORT_NONE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;reset&quot;
)paren
)paren
(brace
id|reset
op_assign
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|lp_register
r_int
id|lp_register
c_func
(paren
r_int
id|nr
comma
r_struct
id|parport
op_star
id|port
)paren
(brace
id|lp_table
(braket
id|nr
)braket
dot
id|dev
op_assign
id|parport_register_device
c_func
(paren
id|port
comma
l_string|&quot;lp&quot;
comma
id|lp_preempt
comma
l_int|NULL
comma
id|lp_interrupt
comma
l_int|0
comma
(paren
r_void
op_star
)paren
op_amp
id|lp_table
(braket
id|nr
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|lp_table
(braket
id|nr
)braket
dot
id|dev
op_eq
l_int|NULL
)paren
r_return
l_int|1
suffix:semicolon
id|lp_table
(braket
id|nr
)braket
dot
id|flags
op_or_assign
id|LP_EXIST
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
id|lp_reset
c_func
(paren
id|nr
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d: using %s (%s).&bslash;n&quot;
comma
id|nr
comma
id|port-&gt;name
comma
(paren
id|port-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
)paren
ques
c_cond
l_string|&quot;polling&quot;
suffix:colon
l_string|&quot;interrupt-driven&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lp_init
r_int
id|lp_init
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_struct
id|parport
op_star
id|port
suffix:semicolon
r_switch
c_cond
(paren
id|parport_nr
(braket
l_int|0
)braket
)paren
(brace
r_case
id|LP_PARPORT_OFF
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|LP_PARPORT_UNSPEC
suffix:colon
r_case
id|LP_PARPORT_AUTO
suffix:colon
r_for
c_loop
(paren
id|port
op_assign
id|parport_enumerate
c_func
(paren
)paren
suffix:semicolon
id|port
suffix:semicolon
id|port
op_assign
id|port-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|parport_nr
(braket
l_int|0
)braket
op_eq
id|LP_PARPORT_AUTO
op_logical_and
id|port-&gt;probe_info
dot
r_class
op_ne
id|PARPORT_CLASS_PRINTER
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp_register
c_func
(paren
id|count
comma
id|port
)paren
)paren
r_if
c_cond
(paren
op_increment
id|count
op_eq
id|LP_NO
)paren
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LP_NO
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|parport_nr
(braket
id|i
)braket
op_ge
l_int|0
)paren
(brace
r_char
id|buffer
(braket
l_int|16
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;parport%d&quot;
comma
id|parport_nr
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
id|parport_enumerate
c_func
(paren
)paren
suffix:semicolon
id|port
suffix:semicolon
id|port
op_assign
id|port-&gt;next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|port-&gt;name
comma
id|buffer
)paren
)paren
(brace
(paren
r_void
)paren
id|lp_register
c_func
(paren
id|i
comma
id|port
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
r_if
c_cond
(paren
id|register_chrdev
c_func
(paren
id|LP_MAJOR
comma
l_string|&quot;lp&quot;
comma
op_amp
id|lp_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;lp: unable to get major %d&bslash;n&quot;
comma
id|LP_MAJOR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp: driver loaded but no devices found&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|parport
(braket
l_int|0
)braket
)paren
(brace
multiline_comment|/* The user gave some parameters.  Let&squot;s see what they were.  */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|parport
(braket
l_int|0
)braket
comma
l_string|&quot;auto&quot;
comma
l_int|4
)paren
)paren
id|parport_nr
(braket
l_int|0
)braket
op_assign
id|LP_PARPORT_AUTO
suffix:semicolon
r_else
(brace
r_int
id|n
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|LP_NO
op_logical_and
id|parport
(braket
id|n
)braket
suffix:semicolon
id|n
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|parport
(braket
id|n
)braket
comma
l_string|&quot;none&quot;
comma
l_int|4
)paren
)paren
id|parport_nr
(braket
id|n
)braket
op_assign
id|LP_PARPORT_NONE
suffix:semicolon
r_else
(brace
r_char
op_star
id|ep
suffix:semicolon
r_int
r_int
id|r
op_assign
id|simple_strtoul
c_func
(paren
id|parport
(braket
id|n
)braket
comma
op_amp
id|ep
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep
op_ne
id|parport
(braket
id|n
)braket
)paren
id|parport_nr
(braket
id|n
)braket
op_assign
id|r
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;lp: bad port specifier `%s&squot;&bslash;n&quot;
comma
id|parport
(braket
id|n
)braket
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
r_return
id|lp_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|offset
suffix:semicolon
id|unregister_chrdev
c_func
(paren
id|LP_MAJOR
comma
l_string|&quot;lp&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|LP_NO
suffix:semicolon
id|offset
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lp_table
(braket
id|offset
)braket
dot
id|dev
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|parport_unregister_device
c_func
(paren
id|lp_table
(braket
id|offset
)braket
dot
id|dev
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
