multiline_comment|/*&n; * Copyright (C) 1992 by Jim Weigand and Linus Torvalds&n; * Copyright (C) 1992,1993 by Michael K. Johnson&n; * - Thanks much to Gunter Windau for pointing out to me where the error&n; *   checking ought to be.&n; * Copyright (C) 1993 by Nigel Gamble (added interrupt code)&n; * Copyright (C) 1994 by Alan Cox (Modularised it)&n; * LPCAREFUL, LPABORT, LPGETSTATUS added by Chris Metcalf, metcalf@lcs.mit.edu&n; * Statistics and support for slow printers by Rob Janssen, rob@knoware.nl&n; * &quot;lp=&quot; command line parameters added by Grant Guenther, grant@torque.net&n; * lp_read (Status readback) support added by Carsten Gross,&n; *                                             carsten@sol.wohnheim.uni-ulm.de&n; * Support for parport by Philip Blundell &lt;Philip.Blundell@pobox.com&gt;&n; */
multiline_comment|/* This driver is about due for a rewrite. */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &lt;linux/lp.h&gt;
multiline_comment|/* if you have more than 3 printers, remember to increase LP_NO */
DECL|variable|lp_table
r_struct
id|lp_struct
id|lp_table
(braket
)braket
op_assign
(brace
(brace
l_int|NULL
comma
l_int|0
comma
id|LP_INIT_CHAR
comma
id|LP_INIT_TIME
comma
id|LP_INIT_WAIT
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|0
)brace
)brace
comma
(brace
l_int|NULL
comma
l_int|0
comma
id|LP_INIT_CHAR
comma
id|LP_INIT_TIME
comma
id|LP_INIT_WAIT
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|0
)brace
)brace
comma
(brace
l_int|NULL
comma
l_int|0
comma
id|LP_INIT_CHAR
comma
id|LP_INIT_TIME
comma
id|LP_INIT_WAIT
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|0
)brace
)brace
)brace
suffix:semicolon
DECL|macro|LP_NO
mdefine_line|#define LP_NO 3
multiline_comment|/* Device name */
DECL|variable|dev_name
r_static
r_char
op_star
id|dev_name
op_assign
l_string|&quot;lp&quot;
suffix:semicolon
multiline_comment|/* Test if printer is ready (and optionally has no error conditions) */
DECL|macro|LP_READY
mdefine_line|#define LP_READY(minor, status) &bslash;&n;  ((LP_F(minor) &amp; LP_CAREFUL) ? _LP_CAREFUL_READY(status) : (status &amp; LP_PBUSY))
DECL|macro|LP_CAREFUL_READY
mdefine_line|#define LP_CAREFUL_READY(minor, status) &bslash;&n;  ((LP_F(minor) &amp; LP_CAREFUL) ? _LP_CAREFUL_READY(status) : 1)
DECL|macro|_LP_CAREFUL_READY
mdefine_line|#define _LP_CAREFUL_READY(status) &bslash;&n;   (status &amp; (LP_PBUSY|LP_POUTPA|LP_PSELECD|LP_PERRORP)) == &bslash;&n;      (LP_PBUSY|LP_PSELECD|LP_PERRORP)
DECL|macro|LP_DEBUG
macro_line|#undef LP_DEBUG
DECL|macro|LP_READ_DEBUG
macro_line|#undef LP_READ_DEBUG
DECL|function|lp_reset
r_static
r_int
id|lp_reset
c_func
(paren
r_int
id|minor
)paren
(brace
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|LP_DELAY
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
)paren
suffix:semicolon
r_return
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
)brace
DECL|function|lp_char_polled
r_static
r_inline
r_int
id|lp_char_polled
c_func
(paren
r_char
id|lpchar
comma
r_int
id|minor
)paren
(brace
r_int
id|status
comma
id|wait
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|lp_stats
op_star
id|stats
suffix:semicolon
r_do
(brace
id|status
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|need_resched
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|LP_READY
c_func
(paren
id|minor
comma
id|status
)paren
op_logical_and
id|count
OL
id|LP_CHAR
c_func
(paren
id|minor
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
id|LP_CHAR
c_func
(paren
id|minor
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* we timed out, and the character was /not/ printed */
)brace
id|w_dtr
c_func
(paren
id|minor
comma
id|lpchar
)paren
suffix:semicolon
id|stats
op_assign
op_amp
id|LP_STAT
c_func
(paren
id|minor
)paren
suffix:semicolon
id|stats-&gt;chars
op_increment
suffix:semicolon
multiline_comment|/* must wait before taking strobe high, and after taking strobe&n;&t;   low, according spec.  Some printers need it, others don&squot;t. */
r_while
c_loop
(paren
id|wait
op_ne
id|LP_WAIT
c_func
(paren
id|minor
)paren
)paren
id|wait
op_increment
suffix:semicolon
multiline_comment|/* control port takes strobe high */
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
op_or
id|LP_PSTROBE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|wait
)paren
id|wait
op_decrement
suffix:semicolon
multiline_comment|/* take strobe low */
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
)paren
suffix:semicolon
multiline_comment|/* update waittime statistics */
r_if
c_cond
(paren
id|count
OG
id|stats-&gt;maxwait
)paren
(brace
macro_line|#ifdef LP_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;lp%d success after %d counts.&bslash;n&quot;
comma
id|minor
comma
id|count
)paren
suffix:semicolon
macro_line|#endif
id|stats-&gt;maxwait
op_assign
id|count
suffix:semicolon
)brace
id|count
op_mul_assign
l_int|256
suffix:semicolon
id|wait
op_assign
(paren
id|count
OG
id|stats-&gt;meanwait
)paren
ques
c_cond
id|count
op_minus
id|stats-&gt;meanwait
suffix:colon
id|stats-&gt;meanwait
op_minus
id|count
suffix:semicolon
id|stats-&gt;meanwait
op_assign
(paren
l_int|255
op_star
id|stats-&gt;meanwait
op_plus
id|count
op_plus
l_int|128
)paren
op_div
l_int|256
suffix:semicolon
id|stats-&gt;mdev
op_assign
(paren
(paren
l_int|127
op_star
id|stats-&gt;mdev
)paren
op_plus
id|wait
op_plus
l_int|64
)paren
op_div
l_int|128
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|lp_char_interrupt
r_static
r_inline
r_int
id|lp_char_interrupt
c_func
(paren
r_char
id|lpchar
comma
r_int
id|minor
)paren
(brace
r_int
id|wait
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_struct
id|lp_stats
op_star
id|stats
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|need_resched
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_assign
id|r_str
c_func
(paren
id|minor
)paren
)paren
op_amp
id|LP_PBUSY
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|LP_CAREFUL_READY
c_func
(paren
id|minor
comma
id|status
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|w_dtr
c_func
(paren
id|minor
comma
id|lpchar
)paren
suffix:semicolon
id|stats
op_assign
op_amp
id|LP_STAT
c_func
(paren
id|minor
)paren
suffix:semicolon
id|stats-&gt;chars
op_increment
suffix:semicolon
multiline_comment|/* must wait before taking strobe high, and after taking strobe&n;&t;&t;&t;   low, according spec.  Some printers need it, others don&squot;t. */
id|wait
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|wait
op_ne
id|LP_WAIT
c_func
(paren
id|minor
)paren
)paren
id|wait
op_increment
suffix:semicolon
multiline_comment|/* control port takes strobe high */
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
op_or
id|LP_PSTROBE
)paren
suffix:semicolon
r_while
c_loop
(paren
id|wait
)paren
id|wait
op_decrement
suffix:semicolon
multiline_comment|/* take strobe low */
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
)paren
suffix:semicolon
multiline_comment|/* update waittime statistics */
r_if
c_cond
(paren
id|count
)paren
(brace
r_if
c_cond
(paren
id|count
OG
id|stats-&gt;maxwait
)paren
id|stats-&gt;maxwait
op_assign
id|count
suffix:semicolon
id|count
op_mul_assign
l_int|256
suffix:semicolon
id|wait
op_assign
(paren
id|count
OG
id|stats-&gt;meanwait
)paren
ques
c_cond
id|count
op_minus
id|stats-&gt;meanwait
suffix:colon
id|stats-&gt;meanwait
op_minus
id|count
suffix:semicolon
id|stats-&gt;meanwait
op_assign
(paren
l_int|255
op_star
id|stats-&gt;meanwait
op_plus
id|count
op_plus
l_int|128
)paren
op_div
l_int|256
suffix:semicolon
id|stats-&gt;mdev
op_assign
(paren
(paren
l_int|127
op_star
id|stats-&gt;mdev
)paren
op_plus
id|wait
op_plus
l_int|64
)paren
op_div
l_int|128
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|count
op_increment
OL
id|LP_CHAR
c_func
(paren
id|minor
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lp_interrupt
r_static
r_void
id|lp_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|parport
op_star
id|pb
op_assign
(paren
r_struct
id|parport
op_star
)paren
id|dev_id
suffix:semicolon
r_struct
id|pardevice
op_star
id|pd
op_assign
id|pb-&gt;cad
suffix:semicolon
r_struct
id|lp_struct
op_star
id|lp_dev
op_assign
(paren
r_struct
id|lp_struct
op_star
)paren
id|pd
op_member_access_from_pointer
r_private
suffix:semicolon
r_if
c_cond
(paren
id|lp_dev-&gt;lp_wait_q
)paren
id|wake_up
c_func
(paren
op_amp
id|lp_dev-&gt;lp_wait_q
)paren
suffix:semicolon
)brace
DECL|function|lp_write_interrupt
r_static
r_inline
r_int
id|lp_write_interrupt
c_func
(paren
r_int
r_int
id|minor
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
r_int
id|copy_size
suffix:semicolon
r_int
r_int
id|total_bytes_written
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|bytes_written
suffix:semicolon
r_struct
id|lp_struct
op_star
id|lp
op_assign
op_amp
id|lp_table
(braket
id|minor
)braket
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|LP_NO
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_do
(brace
id|bytes_written
op_assign
l_int|0
suffix:semicolon
id|copy_size
op_assign
(paren
id|count
op_le
id|LP_BUFFER_SIZE
ques
c_cond
id|count
suffix:colon
id|LP_BUFFER_SIZE
)paren
suffix:semicolon
id|copy_from_user
c_func
(paren
id|lp-&gt;lp_buffer
comma
id|buf
comma
id|copy_size
)paren
suffix:semicolon
r_while
c_loop
(paren
id|copy_size
)paren
(brace
r_if
c_cond
(paren
id|lp_char_interrupt
c_func
(paren
id|lp-&gt;lp_buffer
(braket
id|bytes_written
)braket
comma
id|minor
)paren
)paren
(brace
op_decrement
id|copy_size
suffix:semicolon
op_increment
id|bytes_written
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|runchars
op_increment
suffix:semicolon
)brace
r_else
(brace
r_int
id|rc
op_assign
id|total_bytes_written
op_plus
id|bytes_written
suffix:semicolon
r_if
c_cond
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|runchars
OG
id|LP_STAT
c_func
(paren
id|minor
)paren
dot
id|maxrun
)paren
id|LP_STAT
c_func
(paren
id|minor
)paren
dot
id|maxrun
op_assign
id|lp_table
(braket
id|minor
)braket
dot
id|runchars
suffix:semicolon
id|status
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
id|LP_POUTPA
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d out of paper&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_ABORT
)paren
r_return
id|rc
ques
c_cond
id|rc
suffix:colon
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PSELECD
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d off-line&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_ABORT
)paren
r_return
id|rc
ques
c_cond
id|rc
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PERRORP
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;lp%d printer error&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_ABORT
)paren
r_return
id|rc
ques
c_cond
id|rc
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
id|LP_STAT
c_func
(paren
id|minor
)paren
dot
id|sleeps
op_increment
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
op_or
id|LP_PINTEN
)paren
suffix:semicolon
id|status
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PACK
)paren
op_logical_or
(paren
id|status
op_amp
id|LP_PBUSY
)paren
)paren
op_logical_and
id|LP_CAREFUL_READY
c_func
(paren
id|minor
comma
id|status
)paren
)paren
(brace
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|lp_table
(braket
id|minor
)braket
dot
id|runchars
op_assign
l_int|0
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|LP_TIMEOUT_INTERRUPT
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|lp-&gt;lp_wait_q
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|minor
comma
id|LP_PSELECP
op_or
id|LP_PINITP
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
r_if
c_cond
(paren
id|total_bytes_written
op_plus
id|bytes_written
)paren
r_return
id|total_bytes_written
op_plus
id|bytes_written
suffix:semicolon
r_else
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
)brace
)brace
id|total_bytes_written
op_add_assign
id|bytes_written
suffix:semicolon
id|buf
op_add_assign
id|bytes_written
suffix:semicolon
id|count
op_sub_assign
id|bytes_written
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
suffix:semicolon
r_return
id|total_bytes_written
suffix:semicolon
)brace
DECL|function|lp_write_polled
r_static
r_inline
r_int
id|lp_write_polled
c_func
(paren
r_int
r_int
id|minor
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|retval
comma
id|status
suffix:semicolon
r_char
id|c
suffix:semicolon
r_const
r_char
op_star
id|temp
suffix:semicolon
id|temp
op_assign
id|buf
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
id|get_user
c_func
(paren
id|c
comma
id|temp
)paren
suffix:semicolon
id|retval
op_assign
id|lp_char_polled
c_func
(paren
id|c
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* only update counting vars if character was printed */
r_if
c_cond
(paren
id|retval
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|temp
op_increment
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|runchars
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* if printer timed out */
r_if
c_cond
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|runchars
OG
id|LP_STAT
c_func
(paren
id|minor
)paren
dot
id|maxrun
)paren
id|LP_STAT
c_func
(paren
id|minor
)paren
dot
id|maxrun
op_assign
id|lp_table
(braket
id|minor
)braket
dot
id|runchars
suffix:semicolon
id|status
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|LP_POUTPA
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d out of paper&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_ABORT
)paren
(brace
r_return
id|temp
op_minus
id|buf
ques
c_cond
id|temp
op_minus
id|buf
suffix:colon
op_minus
id|ENOSPC
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|LP_TIMEOUT_POLLED
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PSELECD
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d off-line&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_ABORT
)paren
(brace
r_return
id|temp
op_minus
id|buf
ques
c_cond
id|temp
op_minus
id|buf
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|LP_TIMEOUT_POLLED
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* not offline or out of paper. on fire? */
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PERRORP
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;lp%d on fire&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_ABORT
)paren
(brace
r_return
id|temp
op_minus
id|buf
ques
c_cond
id|temp
op_minus
id|buf
suffix:colon
op_minus
id|EIO
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|LP_TIMEOUT_POLLED
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* check for signals before going to sleep */
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
r_if
c_cond
(paren
id|temp
op_ne
id|buf
)paren
r_return
id|temp
op_minus
id|buf
suffix:semicolon
r_else
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|LP_STAT
c_func
(paren
id|minor
)paren
dot
id|sleeps
op_increment
suffix:semicolon
macro_line|#ifdef LP_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;lp%d sleeping at %d characters for %d jiffies&bslash;n&quot;
comma
id|minor
comma
id|lp_table
(braket
id|minor
)braket
dot
id|runchars
comma
id|LP_TIME
c_func
(paren
id|minor
)paren
)paren
suffix:semicolon
macro_line|#endif
id|lp_table
(braket
id|minor
)braket
dot
id|runchars
op_assign
l_int|0
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|LP_TIME
c_func
(paren
id|minor
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_return
id|temp
op_minus
id|buf
suffix:semicolon
)brace
DECL|function|lp_write
r_static
r_int
id|lp_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_int
id|retv
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
op_minus
id|lp_table
(braket
id|minor
)braket
dot
id|lastcall
OG
id|LP_TIME
c_func
(paren
id|minor
)paren
)paren
id|lp_table
(braket
id|minor
)braket
dot
id|runchars
op_assign
l_int|0
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|lastcall
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* Claim Parport or sleep until it becomes available&n; &t; * (see lp_wakeup() for details)&n; &t; */
r_if
c_cond
(paren
id|parport_claim
c_func
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
dot
id|lp_wait_q
)paren
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|lp_wait_q
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|LP_IRQ
c_func
(paren
id|minor
)paren
OG
l_int|0
)paren
id|retv
op_assign
id|lp_write_interrupt
c_func
(paren
id|minor
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_else
id|retv
op_assign
id|lp_write_polled
c_func
(paren
id|minor
comma
id|buf
comma
id|count
)paren
suffix:semicolon
id|parport_release
c_func
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev
)paren
suffix:semicolon
r_return
id|retv
suffix:semicolon
)brace
DECL|function|lp_lseek
r_static
r_int
r_int
id|lp_lseek
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_PRINTER_READBACK
DECL|function|lp_read_nibble
r_static
r_int
id|lp_read_nibble
c_func
(paren
r_int
id|minor
)paren
(brace
r_int
r_char
id|i
suffix:semicolon
id|i
op_assign
id|r_str
c_func
(paren
id|minor
)paren
op_rshift
l_int|3
suffix:semicolon
id|i
op_and_assign
op_complement
l_int|8
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|0x10
)paren
op_eq
l_int|0
)paren
id|i
op_or_assign
l_int|8
suffix:semicolon
r_return
id|i
op_amp
l_int|0x0f
suffix:semicolon
)brace
DECL|function|lp_select_in_high
r_static
r_void
id|lp_select_in_high
c_func
(paren
r_int
id|minor
)paren
(brace
id|w_ctr
c_func
(paren
id|minor
comma
(paren
id|r_ctr
c_func
(paren
id|minor
)paren
op_or
l_int|8
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Status readback confirming to ieee1284 */
DECL|function|lp_read
r_static
r_int
id|lp_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
(brace
r_int
r_char
id|z
op_assign
l_int|0
comma
id|Byte
op_assign
l_int|0
comma
id|status
suffix:semicolon
r_char
op_star
id|temp
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
r_int
id|counter
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_int
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
multiline_comment|/* Claim Parport or sleep until it becomes available&n; &t; * (see lp_wakeup() for details)&n; &t; */
r_if
c_cond
(paren
id|parport_claim
c_func
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev
)paren
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|lp_table
(braket
id|minor
)braket
dot
id|lp_wait_q
)paren
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|lp_wait_q
op_assign
l_int|NULL
suffix:semicolon
)brace
id|temp
op_assign
id|buf
suffix:semicolon
macro_line|#ifdef LP_READ_DEBUG 
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d: read mode&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
macro_line|#endif
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|parport_ieee1284_nibble_mode_ok
c_func
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev-&gt;port
comma
l_int|0
)paren
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef LP_READ_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d: rejected IEEE1284 negotiation.&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
macro_line|#endif
id|lp_select_in_high
c_func
(paren
id|minor
)paren
suffix:semicolon
id|parport_release
c_func
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev
)paren
suffix:semicolon
r_return
id|temp
op_minus
id|buf
suffix:semicolon
multiline_comment|/*  End of file */
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
(paren
id|count
op_star
l_int|2
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|w_ctr
c_func
(paren
id|minor
comma
id|r_ctr
c_func
(paren
id|minor
)paren
op_or
l_int|2
)paren
suffix:semicolon
multiline_comment|/* AutoFeed high */
r_do
(brace
id|status
op_assign
(paren
id|r_str
c_func
(paren
id|minor
)paren
op_amp
l_int|0x40
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|50
)paren
suffix:semicolon
id|counter
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|need_resched
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|status
op_eq
l_int|0x40
)paren
op_logical_and
(paren
id|counter
OL
l_int|20
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_eq
l_int|20
)paren
(brace
multiline_comment|/* Timeout */
macro_line|#ifdef LP_READ_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;lp_read: (Autofeed high) timeout&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif&t;&t;
id|w_ctr
c_func
(paren
id|minor
comma
id|r_ctr
c_func
(paren
id|minor
)paren
op_amp
op_complement
l_int|2
)paren
suffix:semicolon
id|lp_select_in_high
c_func
(paren
id|minor
)paren
suffix:semicolon
id|parport_release
c_func
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev
)paren
suffix:semicolon
r_return
id|temp
op_minus
id|buf
suffix:semicolon
multiline_comment|/* end the read at timeout */
)brace
id|counter
op_assign
l_int|0
suffix:semicolon
id|z
op_assign
id|lp_read_nibble
c_func
(paren
id|minor
)paren
suffix:semicolon
id|w_ctr
c_func
(paren
id|minor
comma
id|r_ctr
c_func
(paren
id|minor
)paren
op_amp
op_complement
l_int|2
)paren
suffix:semicolon
multiline_comment|/* AutoFeed low */
r_do
(brace
id|status
op_assign
(paren
id|r_str
c_func
(paren
id|minor
)paren
op_amp
l_int|0x40
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|counter
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|need_resched
)paren
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|status
op_eq
l_int|0
)paren
op_logical_and
(paren
id|counter
OL
l_int|20
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_eq
l_int|20
)paren
(brace
multiline_comment|/* Timeout */
macro_line|#ifdef LP_READ_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;lp_read: (Autofeed low) timeout&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|lp_select_in_high
c_func
(paren
id|minor
)paren
suffix:semicolon
id|parport_release
c_func
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp
op_ne
id|buf
)paren
r_return
id|temp
op_minus
id|buf
suffix:semicolon
r_else
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|LP_TIME
c_func
(paren
id|minor
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|counter
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_amp
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
id|Byte
op_assign
(paren
id|Byte
op_or
id|z
op_lshift
l_int|4
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|Byte
comma
id|temp
)paren
suffix:semicolon
id|temp
op_increment
suffix:semicolon
)brace
r_else
id|Byte
op_assign
id|z
suffix:semicolon
)brace
id|lp_select_in_high
c_func
(paren
id|minor
)paren
suffix:semicolon
id|parport_release
c_func
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|dev
)paren
suffix:semicolon
r_return
id|temp
op_minus
id|buf
suffix:semicolon
)brace
macro_line|#endif
DECL|function|lp_open
r_static
r_int
id|lp_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|LP_NO
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_EXIST
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_BUSY
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* If ABORTOPEN is set and the printer is offline or out of paper,&n;&t;   we may still want to open it to perform ioctl()s.  Therefore we&n;&t;   have commandeered O_NONBLOCK, even though it is being used in&n;&t;   a non-standard manner.  This is strictly a Linux hack, and&n;&t;   should most likely only ever be used by the tunelp application. */
r_if
c_cond
(paren
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_ABORTOPEN
)paren
op_logical_and
op_logical_neg
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
)paren
(brace
r_int
id|status
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|LP_POUTPA
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d out of paper&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PSELECD
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d off-line&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|LP_PERRORP
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;lp%d printer error&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|LP_IRQ
c_func
(paren
id|minor
)paren
OG
l_int|0
)paren
(brace
id|lp_table
(braket
id|minor
)braket
dot
id|lp_buffer
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|LP_BUFFER_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp_table
(braket
id|minor
)braket
dot
id|lp_buffer
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
id|LP_F
c_func
(paren
id|minor
)paren
op_or_assign
id|LP_BUSY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lp_release
r_static
r_int
id|lp_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_int
r_int
id|irq
suffix:semicolon
r_if
c_cond
(paren
(paren
id|irq
op_assign
id|LP_IRQ
c_func
(paren
id|minor
)paren
)paren
)paren
(brace
id|kfree_s
c_func
(paren
id|lp_table
(braket
id|minor
)braket
dot
id|lp_buffer
comma
id|LP_BUFFER_SIZE
)paren
suffix:semicolon
id|lp_table
(braket
id|minor
)braket
dot
id|lp_buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_BUSY
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lp_ioctl
r_static
r_int
id|lp_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef LP_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;lp%d ioctl, cmd: 0x%x, arg: 0x%x&bslash;n&quot;
comma
id|minor
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|minor
op_ge
id|LP_NO
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
(paren
id|LP_F
c_func
(paren
id|minor
)paren
op_amp
id|LP_EXIST
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|LPTIME
suffix:colon
id|LP_TIME
c_func
(paren
id|minor
)paren
op_assign
id|arg
op_star
id|HZ
op_div
l_int|100
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPCHAR
suffix:colon
id|LP_CHAR
c_func
(paren
id|minor
)paren
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPABORT
suffix:colon
r_if
c_cond
(paren
id|arg
)paren
id|LP_F
c_func
(paren
id|minor
)paren
op_or_assign
id|LP_ABORT
suffix:semicolon
r_else
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_ABORT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPABORTOPEN
suffix:colon
r_if
c_cond
(paren
id|arg
)paren
id|LP_F
c_func
(paren
id|minor
)paren
op_or_assign
id|LP_ABORTOPEN
suffix:semicolon
r_else
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_ABORTOPEN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPCAREFUL
suffix:colon
r_if
c_cond
(paren
id|arg
)paren
id|LP_F
c_func
(paren
id|minor
)paren
op_or_assign
id|LP_CAREFUL
suffix:semicolon
r_else
id|LP_F
c_func
(paren
id|minor
)paren
op_and_assign
op_complement
id|LP_CAREFUL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPWAIT
suffix:colon
id|LP_WAIT
c_func
(paren
id|minor
)paren
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPSETIRQ
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPGETIRQ
suffix:colon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
comma
op_amp
id|LP_IRQ
c_func
(paren
id|minor
)paren
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPGETSTATUS
suffix:colon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
r_else
(brace
r_int
id|status
op_assign
id|r_str
c_func
(paren
id|minor
)paren
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
comma
op_amp
id|status
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|LPRESET
suffix:colon
id|lp_reset
c_func
(paren
id|minor
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LPGETSTATS
suffix:colon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|lp_stats
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
r_else
(brace
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
comma
op_amp
id|LP_STAT
c_func
(paren
id|minor
)paren
comma
r_sizeof
(paren
r_struct
id|lp_stats
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
)paren
id|memset
c_func
(paren
op_amp
id|LP_STAT
c_func
(paren
id|minor
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|lp_stats
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|LPGETFLAGS
suffix:colon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
r_else
(brace
r_int
id|status
op_assign
id|LP_F
c_func
(paren
id|minor
)paren
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
comma
op_amp
id|status
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|lp_fops
r_static
r_struct
id|file_operations
id|lp_fops
op_assign
(brace
id|lp_lseek
comma
macro_line|#ifdef CONFIG_PRINTER_READBACK
id|lp_read
comma
macro_line|#else
l_int|NULL
comma
macro_line|#endif
id|lp_write
comma
l_int|NULL
comma
multiline_comment|/* lp_readdir */
l_int|NULL
comma
multiline_comment|/* lp_poll */
id|lp_ioctl
comma
l_int|NULL
comma
multiline_comment|/* lp_mmap */
id|lp_open
comma
id|lp_release
)brace
suffix:semicolon
DECL|variable|parport
r_static
r_int
id|parport
(braket
id|LP_NO
)braket
op_assign
(brace
op_minus
l_int|1
comma
)brace
suffix:semicolon
macro_line|#ifdef MODULE
DECL|macro|lp_init
mdefine_line|#define lp_init init_module
id|MODULE_PARM
c_func
(paren
id|parport
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|LP_NO
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#else
DECL|variable|parport_ptr
r_static
r_int
id|parport_ptr
op_assign
l_int|0
suffix:semicolon
DECL|function|lp_setup
r_void
id|lp_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
multiline_comment|/* Ugh. */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|str
comma
l_string|&quot;parport&quot;
comma
l_int|7
)paren
)paren
(brace
r_int
id|n
op_assign
id|simple_strtoul
c_func
(paren
id|str
op_plus
l_int|7
comma
l_int|NULL
comma
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parport_ptr
OL
id|LP_NO
)paren
id|parport
(braket
id|parport_ptr
op_increment
)braket
op_assign
id|n
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp: too many ports, %s ignored.&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;auto&quot;
)paren
)paren
(brace
id|parport
(braket
l_int|0
)braket
op_assign
op_minus
l_int|3
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_eq
l_int|0
op_logical_or
id|ints
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* disable driver on &quot;parport=&quot; or &quot;parport=0&quot; */
id|parport
(braket
l_int|0
)braket
op_assign
op_minus
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;warning: &squot;lp=0x%x&squot; is deprecated, ignored&bslash;n&quot;
comma
id|ints
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif
DECL|function|lp_wakeup
r_int
id|lp_wakeup
c_func
(paren
r_void
op_star
id|ref
)paren
(brace
r_struct
id|lp_struct
op_star
id|lp_dev
op_assign
(paren
r_struct
id|lp_struct
op_star
)paren
id|ref
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|lp_dev-&gt;lp_wait_q
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Wake up whom? */
multiline_comment|/* Claim the Parport */
r_if
c_cond
(paren
id|parport_claim
c_func
(paren
id|lp_dev-&gt;dev
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Shouldn&squot;t happen */
id|wake_up
c_func
(paren
op_amp
id|lp_dev-&gt;lp_wait_q
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lp_searchfor
r_static
r_int
r_inline
id|lp_searchfor
c_func
(paren
r_int
id|list
(braket
)braket
comma
r_int
id|a
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|LP_NO
op_logical_and
id|list
(braket
id|i
)braket
op_ne
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|list
(braket
id|i
)braket
op_eq
id|a
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lp_init
r_int
id|lp_init
c_func
(paren
r_void
)paren
(brace
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|parport
op_star
id|pb
suffix:semicolon
r_if
c_cond
(paren
id|parport
(braket
l_int|0
)braket
op_eq
op_minus
l_int|2
)paren
r_return
l_int|0
suffix:semicolon
id|pb
op_assign
id|parport_enumerate
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pb
)paren
(brace
multiline_comment|/* We only understand PC-style ports. */
r_if
c_cond
(paren
id|pb-&gt;modes
op_amp
id|PARPORT_MODE_PCSPP
)paren
(brace
r_if
c_cond
(paren
id|parport
(braket
l_int|0
)braket
op_eq
op_minus
l_int|1
op_logical_or
id|lp_searchfor
c_func
(paren
id|parport
comma
id|count
)paren
op_logical_or
(paren
id|parport
(braket
l_int|0
)braket
op_eq
op_minus
l_int|3
op_logical_and
id|pb-&gt;probe_info
dot
r_class
op_eq
id|PARPORT_CLASS_PRINTER
)paren
)paren
(brace
id|lp_table
(braket
id|count
)braket
dot
id|dev
op_assign
id|parport_register_device
c_func
(paren
id|pb
comma
id|dev_name
comma
l_int|NULL
comma
id|lp_wakeup
comma
id|lp_interrupt
comma
id|PARPORT_DEV_TRAN
comma
(paren
r_void
op_star
)paren
op_amp
id|lp_table
(braket
id|count
)braket
)paren
suffix:semicolon
id|lp_table
(braket
id|count
)braket
dot
id|flags
op_or_assign
id|LP_EXIST
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp%d: using %s (%s).&bslash;n&quot;
comma
id|count
comma
id|pb-&gt;name
comma
(paren
id|pb-&gt;irq
op_eq
id|PARPORT_IRQ_NONE
)paren
ques
c_cond
l_string|&quot;polling&quot;
suffix:colon
l_string|&quot;interrupt-driven&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|count
op_eq
id|LP_NO
)paren
r_break
suffix:semicolon
)brace
id|pb
op_assign
id|pb-&gt;next
suffix:semicolon
)brace
multiline_comment|/* Successful specified devices increase count&n;  &t; * Unsuccessful specified devices increase failed&n;  &t; */
r_if
c_cond
(paren
id|count
)paren
(brace
r_if
c_cond
(paren
id|register_chrdev
c_func
(paren
id|LP_MAJOR
comma
l_string|&quot;lp&quot;
comma
op_amp
id|lp_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;lp: unable to get major %d&bslash;n&quot;
comma
id|LP_MAJOR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;lp: driver loaded but no devices found&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_return
l_int|0
suffix:semicolon
macro_line|#else&t;
r_return
l_int|1
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef MODULE
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|offset
suffix:semicolon
id|unregister_chrdev
c_func
(paren
id|LP_MAJOR
comma
l_string|&quot;lp&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|LP_NO
suffix:semicolon
id|offset
op_increment
)paren
(brace
r_if
c_cond
(paren
id|lp_table
(braket
id|offset
)braket
dot
id|dev
op_eq
l_int|NULL
)paren
r_continue
suffix:semicolon
id|parport_unregister_device
c_func
(paren
id|lp_table
(braket
id|offset
)braket
dot
id|dev
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
