multiline_comment|/*&n; * linux/kernel/chr_drv/keyboard.c&n; *&n; * Keyboard driver for Linux v0.99 using Latin-1.&n; *&n; * Written for linux by Johan Myreen as a translation from&n; * the assembly version by Linus (with diacriticals added)&n; *&n; * Some additional features added by Christoph Niemann (ChN), March 1993&n; * Loadable keymaps by Risto Kankkunen, May 1993&n; * Diacriticals redone &amp; other small changes, aeb@cwi.nl, June 1993&n; */
DECL|macro|KEYBOARD_IRQ
mdefine_line|#define KEYBOARD_IRQ 1
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &quot;kbd_kern.h&quot;
macro_line|#include &quot;diacr.h&quot;
DECL|macro|SIZE
mdefine_line|#define SIZE(x) (sizeof(x)/sizeof((x)[0]))
macro_line|#ifndef KBD_DEFMODE
DECL|macro|KBD_DEFMODE
mdefine_line|#define KBD_DEFMODE ((1 &lt;&lt; VC_REPEAT) | (1 &lt;&lt; VC_META))
macro_line|#endif
macro_line|#ifndef KBD_DEFLEDS
multiline_comment|/*&n; * Some laptops take the 789uiojklm,. keys as number pad when NumLock&n; * is on. This seems a good reason to start with NumLock off.&n; */
DECL|macro|KBD_DEFLEDS
mdefine_line|#define KBD_DEFLEDS 0
macro_line|#endif
macro_line|#ifndef KBD_DEFLOCK
DECL|macro|KBD_DEFLOCK
mdefine_line|#define KBD_DEFLOCK 0
macro_line|#endif
multiline_comment|/*&n; * The default IO slowdown is doing &squot;inb()&squot;s from 0x61, which should be&n; * safe. But as that is the keyboard controller chip address, we do our&n; * slowdowns here by doing short jumps: the keyboard controller should&n; * be able to keep up&n; */
DECL|macro|REALLY_SLOW_IO
mdefine_line|#define REALLY_SLOW_IO
DECL|macro|SLOW_IO_BY_JUMPING
mdefine_line|#define SLOW_IO_BY_JUMPING
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
r_extern
r_void
id|do_keyboard_interrupt
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|ctrl_alt_del
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|change_console
c_func
(paren
r_int
r_int
id|new_console
)paren
suffix:semicolon
r_extern
r_void
id|scrollback
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_void
id|scrollfront
c_func
(paren
r_int
)paren
suffix:semicolon
DECL|macro|fake_keyboard_interrupt
mdefine_line|#define fake_keyboard_interrupt() &bslash;&n;__asm__ __volatile__(&quot;int $0x21&quot;)
DECL|variable|kbd_read_mask
r_int
r_char
id|kbd_read_mask
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* modified by psaux.c */
multiline_comment|/*&n; * global state includes the following, and various static variables&n; * in this module: prev_scancode, shift_state, diacr, npadch,&n; *   dead_key_next, last_console&n; */
multiline_comment|/* shift state counters.. */
DECL|variable|k_down
r_static
r_int
r_char
id|k_down
(braket
id|NR_SHIFT
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* keyboard key bitmap */
DECL|variable|key_down
r_static
r_int
r_int
id|key_down
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|want_console
r_static
r_int
id|want_console
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|last_console
r_static
r_int
id|last_console
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* last used VC */
DECL|variable|dead_key_next
r_static
r_int
id|dead_key_next
op_assign
l_int|0
suffix:semicolon
DECL|variable|shift_state
r_static
r_int
id|shift_state
op_assign
l_int|0
suffix:semicolon
DECL|variable|npadch
r_static
r_int
id|npadch
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* -1 or number assembled on pad */
DECL|variable|diacr
r_static
r_int
r_char
id|diacr
op_assign
l_int|0
suffix:semicolon
DECL|variable|rep
r_static
r_char
id|rep
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* flag telling character repeat */
DECL|variable|kbd_table
r_struct
id|kbd_struct
id|kbd_table
(braket
id|NR_CONSOLES
)braket
suffix:semicolon
DECL|variable|kbd
r_static
r_struct
id|kbd_struct
op_star
id|kbd
op_assign
id|kbd_table
suffix:semicolon
DECL|variable|tty
r_static
r_struct
id|tty_struct
op_star
id|tty
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* used only by send_data - set by keyboard_interrupt */
DECL|variable|acknowledge
r_static
r_volatile
r_int
r_char
id|acknowledge
op_assign
l_int|0
suffix:semicolon
DECL|variable|resend
r_static
r_volatile
r_int
r_char
id|resend
op_assign
l_int|0
suffix:semicolon
DECL|typedef|k_hand
r_typedef
r_void
(paren
op_star
id|k_hand
)paren
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
DECL|typedef|k_handfn
r_typedef
r_void
(paren
id|k_handfn
)paren
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
r_static
id|k_handfn
DECL|variable|do_self
DECL|variable|do_fn
DECL|variable|do_spec
DECL|variable|do_pad
DECL|variable|do_dead
DECL|variable|do_cons
DECL|variable|do_cur
DECL|variable|do_shift
id|do_self
comma
id|do_fn
comma
id|do_spec
comma
id|do_pad
comma
id|do_dead
comma
id|do_cons
comma
id|do_cur
comma
id|do_shift
comma
DECL|variable|do_meta
DECL|variable|do_ascii
DECL|variable|do_lock
DECL|variable|do_lowercase
id|do_meta
comma
id|do_ascii
comma
id|do_lock
comma
id|do_lowercase
suffix:semicolon
DECL|variable|key_handler
r_static
id|k_hand
id|key_handler
(braket
)braket
op_assign
(brace
id|do_self
comma
id|do_fn
comma
id|do_spec
comma
id|do_pad
comma
id|do_dead
comma
id|do_cons
comma
id|do_cur
comma
id|do_shift
comma
id|do_meta
comma
id|do_ascii
comma
id|do_lock
comma
id|do_lowercase
)brace
suffix:semicolon
multiline_comment|/* maximum values each key_handler can handle */
DECL|variable|max_vals
r_const
r_int
id|max_vals
(braket
)braket
op_assign
(brace
l_int|255
comma
id|NR_FUNC
op_minus
l_int|1
comma
l_int|14
comma
l_int|17
comma
l_int|4
comma
l_int|255
comma
l_int|3
comma
id|NR_SHIFT
comma
l_int|255
comma
l_int|9
comma
l_int|3
comma
l_int|255
)brace
suffix:semicolon
DECL|variable|NR_TYPES
r_const
r_int
id|NR_TYPES
op_assign
id|SIZE
c_func
(paren
id|max_vals
)paren
suffix:semicolon
r_static
r_void
id|put_queue
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_int
r_char
id|handle_diacr
c_func
(paren
r_int
r_char
)paren
suffix:semicolon
multiline_comment|/* pt_regs - set by keyboard_interrupt(), used by show_ptregs() */
DECL|variable|pt_regs
r_static
r_struct
id|pt_regs
op_star
id|pt_regs
suffix:semicolon
DECL|variable|got_break
r_static
r_int
id|got_break
op_assign
l_int|0
suffix:semicolon
DECL|function|kb_wait
r_static
r_inline
r_void
id|kb_wait
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x10000
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
l_int|0x64
)paren
op_amp
l_int|0x02
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
DECL|function|send_cmd
r_static
r_inline
r_void
id|send_cmd
c_func
(paren
r_int
r_char
id|c
)paren
(brace
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|c
comma
l_int|0x64
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Translation of escaped scancodes to keysyms.&n; * This should be user-settable.&n; */
DECL|macro|E0_BASE
mdefine_line|#define E0_BASE 96
DECL|macro|E0_KPENTER
mdefine_line|#define E0_KPENTER (E0_BASE+0)
DECL|macro|E0_RCTRL
mdefine_line|#define E0_RCTRL   (E0_BASE+1)
DECL|macro|E0_KPSLASH
mdefine_line|#define E0_KPSLASH (E0_BASE+2)
DECL|macro|E0_PRSCR
mdefine_line|#define E0_PRSCR   (E0_BASE+3)
DECL|macro|E0_RALT
mdefine_line|#define E0_RALT    (E0_BASE+4)
DECL|macro|E0_BREAK
mdefine_line|#define E0_BREAK   (E0_BASE+5)  /* (control-pause) */
DECL|macro|E0_HOME
mdefine_line|#define E0_HOME    (E0_BASE+6)
DECL|macro|E0_UP
mdefine_line|#define E0_UP      (E0_BASE+7)
DECL|macro|E0_PGUP
mdefine_line|#define E0_PGUP    (E0_BASE+8)
DECL|macro|E0_LEFT
mdefine_line|#define E0_LEFT    (E0_BASE+9)
DECL|macro|E0_RIGHT
mdefine_line|#define E0_RIGHT   (E0_BASE+10)
DECL|macro|E0_END
mdefine_line|#define E0_END     (E0_BASE+11)
DECL|macro|E0_DOWN
mdefine_line|#define E0_DOWN    (E0_BASE+12)
DECL|macro|E0_PGDN
mdefine_line|#define E0_PGDN    (E0_BASE+13)
DECL|macro|E0_INS
mdefine_line|#define E0_INS     (E0_BASE+14)
DECL|macro|E0_DEL
mdefine_line|#define E0_DEL     (E0_BASE+15)
multiline_comment|/* BTC */
DECL|macro|E0_MACRO
mdefine_line|#define E0_MACRO   (E0_BASE+16)
multiline_comment|/* LK450 */
DECL|macro|E0_F13
mdefine_line|#define E0_F13     (E0_BASE+17)
DECL|macro|E0_F14
mdefine_line|#define E0_F14     (E0_BASE+18)
DECL|macro|E0_HELP
mdefine_line|#define E0_HELP    (E0_BASE+19)
DECL|macro|E0_DO
mdefine_line|#define E0_DO      (E0_BASE+20)
DECL|macro|E0_F17
mdefine_line|#define E0_F17     (E0_BASE+21)
DECL|macro|E0_KPMINPLUS
mdefine_line|#define E0_KPMINPLUS (E0_BASE+22)
DECL|macro|E1_PAUSE
mdefine_line|#define E1_PAUSE   (E0_BASE+23)
DECL|variable|e0_keys
r_static
r_int
r_char
id|e0_keys
(braket
l_int|128
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x00-0x07 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x08-0x0f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x10-0x17 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_KPENTER
comma
id|E0_RCTRL
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x18-0x1f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x20-0x27 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x28-0x2f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_KPSLASH
comma
l_int|0
comma
id|E0_PRSCR
comma
multiline_comment|/* 0x30-0x37 */
id|E0_RALT
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_F13
comma
id|E0_F14
comma
id|E0_HELP
comma
multiline_comment|/* 0x38-0x3f */
id|E0_DO
comma
id|E0_F17
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_BREAK
comma
id|E0_HOME
comma
multiline_comment|/* 0x40-0x47 */
id|E0_UP
comma
id|E0_PGUP
comma
l_int|0
comma
id|E0_LEFT
comma
l_int|0
comma
id|E0_RIGHT
comma
id|E0_KPMINPLUS
comma
id|E0_END
comma
multiline_comment|/* 0x48-0x4f */
id|E0_DOWN
comma
id|E0_PGDN
comma
id|E0_INS
comma
id|E0_DEL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x50-0x57 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x58-0x5f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x60-0x67 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_MACRO
comma
multiline_comment|/* 0x68-0x6f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x70-0x77 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
multiline_comment|/* 0x78-0x7f */
)brace
suffix:semicolon
DECL|function|keyboard_interrupt
r_static
r_void
id|keyboard_interrupt
c_func
(paren
r_int
id|int_pt_regs
)paren
(brace
r_int
r_char
id|scancode
suffix:semicolon
r_static
r_int
r_int
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* remember E0, E1 */
r_char
id|up_flag
suffix:semicolon
multiline_comment|/* 0 or 0200 */
r_char
id|raw_mode
suffix:semicolon
id|pt_regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|int_pt_regs
suffix:semicolon
id|send_cmd
c_func
(paren
l_int|0xAD
)paren
suffix:semicolon
multiline_comment|/* disable keyboard */
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
l_int|0x64
)paren
op_amp
id|kbd_read_mask
)paren
op_ne
l_int|0x01
)paren
r_goto
id|end_kbd_intr
suffix:semicolon
id|scancode
op_assign
id|inb
c_func
(paren
l_int|0x60
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|KEYBOARD_BH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xfa
)paren
(brace
id|acknowledge
op_assign
l_int|1
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xfe
)paren
(brace
id|resend
op_assign
l_int|1
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
id|tty
op_assign
id|TTY_TABLE
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|kbd
op_assign
id|kbd_table
op_plus
id|fg_console
suffix:semicolon
r_if
c_cond
(paren
(paren
id|raw_mode
op_assign
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_RAW
)paren
)paren
)paren
(brace
id|put_queue
c_func
(paren
id|scancode
)paren
suffix:semicolon
multiline_comment|/* we do not return yet, because we want to maintain&n;&t;&t;   the key_down array, so that we have the correct&n;&t;&t;   values when finishing RAW mode or when changing VT&squot;s */
)brace
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xe0
op_logical_or
id|scancode
op_eq
l_int|0xe1
)paren
(brace
id|prev_scancode
op_assign
id|scancode
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Convert scancode to keysym, using prev_scancode.&n; &t; */
id|up_flag
op_assign
(paren
id|scancode
op_amp
l_int|0200
)paren
suffix:semicolon
id|scancode
op_and_assign
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|prev_scancode
)paren
(brace
multiline_comment|/*&n;&t;   * usually it will be 0xe0, but a Pause key generates&n;&t;   * e1 1d 45 e1 9d c5 when pressed, and nothing when released&n;&t;   */
r_if
c_cond
(paren
id|prev_scancode
op_ne
l_int|0xe0
)paren
(brace
r_if
c_cond
(paren
id|prev_scancode
op_eq
l_int|0xe1
op_logical_and
id|scancode
op_eq
l_int|0x1d
)paren
(brace
id|prev_scancode
op_assign
l_int|0x100
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|prev_scancode
op_eq
l_int|0x100
op_logical_and
id|scancode
op_eq
l_int|0x45
)paren
(brace
id|scancode
op_assign
id|E1_PAUSE
suffix:semicolon
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;keyboard: unknown e1 escape sequence&bslash;n&quot;
)paren
suffix:semicolon
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
)brace
r_else
(brace
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;       *  The keyboard maintains its own internal caps lock and&n;&t;       *  num lock statuses. In caps lock mode E0 AA precedes make&n;&t;       *  code and E0 2A follows break code. In num lock mode,&n;&t;       *  E0 2A precedes make code and E0 AA follows break code.&n;&t;       *  We do our own book-keeping, so we will just ignore these.&n;&t;       */
multiline_comment|/*&n;&t;       *  For my keyboard there is no caps lock mode, but there are&n;&t;       *  both Shift-L and Shift-R modes. The former mode generates&n;&t;       *  E0 2A / E0 AA pairs, the latter E0 B6 / E0 36 pairs.&n;&t;       *  So, we should also ignore the latter. - aeb@cwi.nl&n;&t;       */
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0x2a
op_logical_or
id|scancode
op_eq
l_int|0x36
)paren
r_goto
id|end_kbd_intr
suffix:semicolon
r_if
c_cond
(paren
id|e0_keys
(braket
id|scancode
)braket
)paren
id|scancode
op_assign
id|e0_keys
(braket
id|scancode
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|raw_mode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;keyboard: unknown scancode e0 %02x&bslash;n&quot;
comma
id|scancode
)paren
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|scancode
op_ge
id|E0_BASE
op_logical_and
op_logical_neg
id|raw_mode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;keyboard: scancode (%02x) not in range 00 - %2x&bslash;n&quot;
comma
id|scancode
comma
id|E0_BASE
op_minus
l_int|1
)paren
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * At this point the variable `scancode&squot; contains the keysym.&n;&t; * We keep track of the up/down status of the key, and&n;&t; * return the keysym if in MEDIUMRAW mode.&n;&t; * (Note: earlier kernels had a bug and did not pass the up/down&n;&t; * bit to applications.)&n;&t; */
r_if
c_cond
(paren
id|up_flag
)paren
(brace
id|clear_bit
c_func
(paren
id|scancode
comma
id|key_down
)paren
suffix:semicolon
id|rep
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|rep
op_assign
id|set_bit
c_func
(paren
id|scancode
comma
id|key_down
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raw_mode
)paren
r_goto
id|end_kbd_intr
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_MEDIUMRAW
)paren
)paren
(brace
id|put_queue
c_func
(paren
id|scancode
op_plus
id|up_flag
)paren
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Small change in philosophy: earlier we defined repetition by&n;&t; *&t; rep = scancode == prev_keysym;&n;&t; *&t; prev_keysym = scancode;&n;&t; * but now by the fact that the depressed key was down already.&n;&t; * Does this ever make a difference?&n;&t; */
multiline_comment|/*&n; &t; *  Repeat a key only if the input buffers are empty or the&n; &t; *  characters get echoed locally. This makes key repeat usable&n; &t; *  with slow applications and under heavy loads.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rep
op_logical_or
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_REPEAT
)paren
op_logical_and
id|tty
op_logical_and
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
op_logical_or
(paren
id|EMPTY
c_func
(paren
op_amp
id|tty-&gt;secondary
)paren
op_logical_and
id|EMPTY
c_func
(paren
op_amp
id|tty-&gt;read_q
)paren
)paren
)paren
)paren
)paren
(brace
id|u_short
id|key_code
suffix:semicolon
id|u_char
id|type
suffix:semicolon
multiline_comment|/* the XOR below used to be an OR */
r_int
id|shift_final
op_assign
id|shift_state
op_xor
id|kbd-&gt;lockstate
suffix:semicolon
id|key_code
op_assign
id|key_map
(braket
id|shift_final
)braket
(braket
id|scancode
)braket
suffix:semicolon
id|type
op_assign
id|KTYP
c_func
(paren
id|key_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|KT_LETTER
)paren
(brace
id|type
op_assign
id|KT_LATIN
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
)paren
id|key_code
op_assign
id|key_map
(braket
id|shift_final
op_xor
(paren
l_int|1
op_lshift
id|KG_SHIFT
)paren
)braket
(braket
id|scancode
)braket
suffix:semicolon
)brace
(paren
op_star
id|key_handler
(braket
id|type
)braket
)paren
(paren
id|key_code
op_amp
l_int|0xff
comma
id|up_flag
)paren
suffix:semicolon
)brace
id|end_kbd_intr
suffix:colon
id|send_cmd
c_func
(paren
l_int|0xAE
)paren
suffix:semicolon
multiline_comment|/* enable keyboard */
)brace
DECL|function|put_queue
r_static
r_void
id|put_queue
c_func
(paren
r_int
id|ch
)paren
(brace
r_struct
id|tty_queue
op_star
id|qp
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|keypress_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|qp
op_assign
op_amp
id|tty-&gt;read_q
suffix:semicolon
r_if
c_cond
(paren
id|LEFT
c_func
(paren
id|qp
)paren
)paren
(brace
id|qp-&gt;buf
(braket
id|qp-&gt;head
)braket
op_assign
id|ch
suffix:semicolon
id|INC
c_func
(paren
id|qp-&gt;head
)paren
suffix:semicolon
)brace
)brace
DECL|function|puts_queue
r_static
r_void
id|puts_queue
c_func
(paren
r_char
op_star
id|cp
)paren
(brace
r_struct
id|tty_queue
op_star
id|qp
suffix:semicolon
r_char
id|ch
suffix:semicolon
multiline_comment|/* why interruptible here, plain wake_up above? */
id|wake_up_interruptible
c_func
(paren
op_amp
id|keypress_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|qp
op_assign
op_amp
id|tty-&gt;read_q
suffix:semicolon
r_while
c_loop
(paren
(paren
id|ch
op_assign
op_star
(paren
id|cp
op_increment
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|LEFT
c_func
(paren
id|qp
)paren
)paren
(brace
id|qp-&gt;buf
(braket
id|qp-&gt;head
)braket
op_assign
id|ch
suffix:semicolon
id|INC
c_func
(paren
id|qp-&gt;head
)paren
suffix:semicolon
)brace
)brace
)brace
DECL|function|applkey
r_static
r_void
id|applkey
c_func
(paren
r_int
id|key
comma
r_char
id|mode
)paren
(brace
r_static
r_char
id|buf
(braket
)braket
op_assign
(brace
l_int|0x1b
comma
l_char|&squot;O&squot;
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
(paren
id|mode
ques
c_cond
l_char|&squot;O&squot;
suffix:colon
l_char|&squot;[&squot;
)paren
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|key
suffix:semicolon
id|puts_queue
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
DECL|function|enter
r_static
r_void
id|enter
c_func
(paren
r_void
)paren
(brace
id|put_queue
c_func
(paren
l_int|13
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_CRLF
)paren
)paren
id|put_queue
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|caps_toggle
r_static
r_void
id|caps_toggle
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
id|chg_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
DECL|function|caps_on
r_static
r_void
id|caps_on
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
id|set_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
DECL|function|show_ptregs
r_static
r_void
id|show_ptregs
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pt_regs
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EIP: %04x:%08lx&quot;
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;cs
comma
id|pt_regs-&gt;eip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pt_regs-&gt;cs
op_amp
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot; ESP: %04x:%08lx&quot;
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;ss
comma
id|pt_regs-&gt;esp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; EFLAGS: %08lx&bslash;n&quot;
comma
id|pt_regs-&gt;eflags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EAX: %08lx EBX: %08lx ECX: %08lx EDX: %08lx&bslash;n&quot;
comma
id|pt_regs-&gt;orig_eax
comma
id|pt_regs-&gt;ebx
comma
id|pt_regs-&gt;ecx
comma
id|pt_regs-&gt;edx
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ESI: %08lx EDI: %08lx EBP: %08lx&quot;
comma
id|pt_regs-&gt;esi
comma
id|pt_regs-&gt;edi
comma
id|pt_regs-&gt;ebp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; DS: %04x ES: %04x FS: %04x GS: %04x&bslash;n&quot;
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;ds
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;es
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;fs
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;gs
)paren
suffix:semicolon
)brace
DECL|function|hold
r_static
r_void
id|hold
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|rep
op_logical_or
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Note: SCROLLOCK wil be set (cleared) by stop_tty (start_tty);&n;&t; * these routines are also activated by ^S/^Q.&n;&t; * (And SCROLLOCK can also be set by the ioctl KDSETLED.)&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;stopped
)paren
id|start_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_else
id|stop_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* unused at present - and the VC_PAUSE bit is not used anywhere either */
r_static
r_void
id|pause
c_func
(paren
r_void
)paren
(brace
id|chg_vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_PAUSE
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|num
r_static
r_void
id|num
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
)paren
(brace
id|applkey
c_func
(paren
l_char|&squot;P&squot;
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rep
)paren
multiline_comment|/* no autorepeat for numlock, ChN */
id|chg_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_NUMLOCK
)paren
suffix:semicolon
)brace
DECL|function|lastcons
r_static
r_void
id|lastcons
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* pressing alt-printscreen switches to the last used console, ChN */
id|want_console
op_assign
id|last_console
suffix:semicolon
)brace
DECL|function|send_intr
r_static
r_void
id|send_intr
c_func
(paren
r_void
)paren
(brace
id|got_break
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|scrll_forw
r_static
r_void
id|scrll_forw
c_func
(paren
r_void
)paren
(brace
id|scrollfront
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|scrll_back
r_static
r_void
id|scrll_back
c_func
(paren
r_void
)paren
(brace
id|scrollback
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|boot_it
r_static
r_void
id|boot_it
c_func
(paren
r_void
)paren
(brace
id|ctrl_alt_del
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|compose
r_static
r_void
id|compose
c_func
(paren
r_void
)paren
(brace
id|dead_key_next
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|do_spec
r_static
r_void
id|do_spec
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_typedef
r_void
(paren
op_star
id|fnp
)paren
(paren
r_void
)paren
suffix:semicolon
id|fnp
id|fn_table
(braket
)braket
op_assign
(brace
l_int|NULL
comma
id|enter
comma
id|show_ptregs
comma
id|show_mem
comma
id|show_state
comma
id|send_intr
comma
id|lastcons
comma
id|caps_toggle
comma
id|num
comma
id|hold
comma
id|scrll_forw
comma
id|scrll_back
comma
id|boot_it
comma
id|caps_on
comma
id|compose
)brace
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ge
id|SIZE
c_func
(paren
id|fn_table
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fn_table
(braket
id|value
)braket
)paren
r_return
suffix:semicolon
id|fn_table
(braket
id|value
)braket
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_lowercase
r_static
r_void
id|do_lowercase
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;keyboard.c: do_lowercase was called - impossible&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|do_self
r_static
r_void
id|do_self
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
multiline_comment|/* no action, if this is a key release */
r_if
c_cond
(paren
id|diacr
)paren
id|value
op_assign
id|handle_diacr
c_func
(paren
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dead_key_next
)paren
(brace
id|dead_key_next
op_assign
l_int|0
suffix:semicolon
id|diacr
op_assign
id|value
suffix:semicolon
r_return
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|value
)paren
suffix:semicolon
)brace
DECL|macro|A_GRAVE
mdefine_line|#define A_GRAVE  &squot;`&squot;
DECL|macro|A_ACUTE
mdefine_line|#define A_ACUTE  &squot;&bslash;&squot;&squot;
DECL|macro|A_CFLEX
mdefine_line|#define A_CFLEX  &squot;^&squot;
DECL|macro|A_TILDE
mdefine_line|#define A_TILDE  &squot;~&squot;
DECL|macro|A_DIAER
mdefine_line|#define A_DIAER  &squot;&quot;&squot;
DECL|variable|ret_diacr
r_static
r_int
r_char
id|ret_diacr
(braket
)braket
op_assign
(brace
id|A_GRAVE
comma
id|A_ACUTE
comma
id|A_CFLEX
comma
id|A_TILDE
comma
id|A_DIAER
)brace
suffix:semicolon
multiline_comment|/* If a dead key pressed twice, output a character corresponding to it,&t;*/
multiline_comment|/* otherwise just remember the dead key.&t;&t;&t;&t;*/
DECL|function|do_dead
r_static
r_void
id|do_dead
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|value
op_assign
id|ret_diacr
(braket
id|value
)braket
suffix:semicolon
r_if
c_cond
(paren
id|diacr
op_eq
id|value
)paren
(brace
multiline_comment|/* pressed twice */
id|diacr
op_assign
l_int|0
suffix:semicolon
id|put_queue
c_func
(paren
id|value
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|diacr
op_assign
id|value
suffix:semicolon
)brace
multiline_comment|/* If space is pressed, return the character corresponding the pending&t;*/
multiline_comment|/* dead key, otherwise try to combine the two.&t;&t;&t;&t;*/
DECL|function|handle_diacr
r_int
r_char
id|handle_diacr
c_func
(paren
r_int
r_char
id|ch
)paren
(brace
r_int
id|d
op_assign
id|diacr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|diacr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot; &squot;
)paren
r_return
id|d
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|accent_table_size
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|accent_table
(braket
id|i
)braket
dot
id|diacr
op_eq
id|d
op_logical_and
id|accent_table
(braket
id|i
)braket
dot
id|base
op_eq
id|ch
)paren
(brace
r_return
id|accent_table
(braket
id|i
)braket
dot
id|result
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|d
)paren
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
DECL|function|do_cons
r_static
r_void
id|do_cons
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|want_console
op_assign
id|value
suffix:semicolon
)brace
DECL|function|do_fn
r_static
r_void
id|do_fn
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
id|SIZE
c_func
(paren
id|func_table
)paren
)paren
id|puts_queue
c_func
(paren
id|func_table
(braket
id|value
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;do_fn called with value=%d&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|do_pad
r_static
r_void
id|do_pad
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_static
r_char
op_star
id|pad_chars
op_assign
l_string|&quot;0123456789+-*/&bslash;015,.?&quot;
suffix:semicolon
r_static
r_char
op_star
id|app_map
op_assign
l_string|&quot;pqrstuvwxylSRQMnn?&quot;
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
multiline_comment|/* no action, if this is a key release */
multiline_comment|/* kludge... shift forces cursor/number keys */
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
op_logical_and
op_logical_neg
id|k_down
(braket
id|KG_SHIFT
)braket
)paren
(brace
id|applkey
c_func
(paren
id|app_map
(braket
id|value
)braket
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_NUMLOCK
)paren
)paren
r_switch
c_cond
(paren
id|value
)paren
(brace
r_case
id|KVAL
c_func
(paren
id|K_PCOMMA
)paren
suffix:colon
r_case
id|KVAL
c_func
(paren
id|K_PDOT
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_REMOVE
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P0
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_INSERT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P1
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_SELECT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P2
)paren
suffix:colon
id|do_cur
c_func
(paren
id|KVAL
c_func
(paren
id|K_DOWN
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P3
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_PGDN
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P4
)paren
suffix:colon
id|do_cur
c_func
(paren
id|KVAL
c_func
(paren
id|K_LEFT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P6
)paren
suffix:colon
id|do_cur
c_func
(paren
id|KVAL
c_func
(paren
id|K_RIGHT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P7
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_FIND
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P8
)paren
suffix:colon
id|do_cur
c_func
(paren
id|KVAL
c_func
(paren
id|K_UP
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P9
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_PGUP
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P5
)paren
suffix:colon
id|applkey
c_func
(paren
l_char|&squot;G&squot;
comma
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|pad_chars
(braket
id|value
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
id|KVAL
c_func
(paren
id|K_PENTER
)paren
op_logical_and
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_CRLF
)paren
)paren
id|put_queue
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|do_cur
r_static
r_void
id|do_cur
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_static
r_char
op_star
id|cur_chars
op_assign
l_string|&quot;BDCA&quot;
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|applkey
c_func
(paren
id|cur_chars
(braket
id|value
)braket
comma
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_CKMODE
)paren
)paren
suffix:semicolon
)brace
DECL|function|do_shift
r_static
r_void
id|do_shift
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_int
id|old_state
op_assign
id|shift_state
suffix:semicolon
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
multiline_comment|/* kludge... */
r_if
c_cond
(paren
id|value
op_eq
id|KVAL
c_func
(paren
id|K_CAPSSHIFT
)paren
)paren
(brace
id|value
op_assign
id|KVAL
c_func
(paren
id|K_SHIFT
)paren
suffix:semicolon
id|clr_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up_flag
)paren
(brace
multiline_comment|/* handle the case that two shift or control&n;&t;&t;   keys are depressed simultaneously */
r_if
c_cond
(paren
id|k_down
(braket
id|value
)braket
)paren
id|k_down
(braket
id|value
)braket
op_decrement
suffix:semicolon
)brace
r_else
id|k_down
(braket
id|value
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|k_down
(braket
id|value
)braket
)paren
id|shift_state
op_or_assign
(paren
l_int|1
op_lshift
id|value
)paren
suffix:semicolon
r_else
id|shift_state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|value
)paren
suffix:semicolon
multiline_comment|/* kludge */
r_if
c_cond
(paren
id|up_flag
op_logical_and
id|shift_state
op_ne
id|old_state
op_logical_and
id|npadch
op_ne
op_minus
l_int|1
)paren
(brace
id|put_queue
c_func
(paren
id|npadch
)paren
suffix:semicolon
id|npadch
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* called after returning from RAW mode or when changing consoles -&n;   recompute k_down[] and shift_state from key_down[] */
DECL|function|compute_shiftstate
r_void
id|compute_shiftstate
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
comma
id|sym
comma
id|val
suffix:semicolon
id|shift_state
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SIZE
c_func
(paren
id|k_down
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|k_down
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SIZE
c_func
(paren
id|key_down
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|key_down
(braket
id|i
)braket
)paren
(brace
multiline_comment|/* skip this word if not a single bit on */
id|k
op_assign
(paren
id|i
op_lshift
l_int|5
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|32
suffix:semicolon
id|j
op_increment
comma
id|k
op_increment
)paren
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|k
comma
id|key_down
)paren
)paren
(brace
id|sym
op_assign
id|key_map
(braket
l_int|0
)braket
(braket
id|k
)braket
suffix:semicolon
r_if
c_cond
(paren
id|KTYP
c_func
(paren
id|sym
)paren
op_eq
id|KT_SHIFT
)paren
(brace
id|val
op_assign
id|KVAL
c_func
(paren
id|sym
)paren
suffix:semicolon
id|k_down
(braket
id|val
)braket
op_increment
suffix:semicolon
id|shift_state
op_or_assign
(paren
l_int|1
op_lshift
id|val
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|do_meta
r_static
r_void
id|do_meta
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_META
)paren
)paren
(brace
id|put_queue
c_func
(paren
l_char|&squot;&bslash;033&squot;
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|value
)paren
suffix:semicolon
)brace
r_else
id|put_queue
c_func
(paren
id|value
op_or
l_int|0x80
)paren
suffix:semicolon
)brace
DECL|function|do_ascii
r_static
r_void
id|do_ascii
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|npadch
op_eq
op_minus
l_int|1
)paren
id|npadch
op_assign
id|value
suffix:semicolon
r_else
id|npadch
op_assign
(paren
id|npadch
op_star
l_int|10
op_plus
id|value
)paren
op_mod
l_int|1000
suffix:semicolon
)brace
DECL|function|do_lock
r_static
r_void
id|do_lock
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
op_logical_or
id|rep
)paren
r_return
suffix:semicolon
id|chg_vc_kbd_lock
c_func
(paren
id|kbd
comma
id|value
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * send_data sends a character to the keyboard and waits&n; * for a acknowledge, possibly retrying if asked to. Returns&n; * the success status.&n; */
DECL|function|send_data
r_static
r_int
id|send_data
c_func
(paren
r_int
r_char
id|data
)paren
(brace
r_int
id|retries
op_assign
l_int|3
suffix:semicolon
r_int
id|i
suffix:semicolon
r_do
(brace
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|acknowledge
op_assign
l_int|0
suffix:semicolon
id|resend
op_assign
l_int|0
suffix:semicolon
id|outb_p
c_func
(paren
id|data
comma
l_int|0x60
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x20000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|inb_p
c_func
(paren
l_int|0x64
)paren
suffix:semicolon
multiline_comment|/* just as a delay */
r_if
c_cond
(paren
id|acknowledge
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|resend
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|resend
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retries
op_decrement
OG
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is the bottom half of the keyboard interrupt&n; * routine, and runs with all interrupts enabled. It does&n; * console changing, led setting and copy_to_cooked, which can&n; * take a reasonably long time.&n; *&n; * Aside from timing (which isn&squot;t really that important for&n; * keyboard interrupts as they happen often), using the software&n; * interrupt routines for this thing allows us to easily mask&n; * this when we don&squot;t want any of the above to happen. Not yet&n; * used, but this allows for easy and efficient race-condition&n; * prevention later on.&n; */
DECL|function|kbd_bh
r_static
r_void
id|kbd_bh
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_static
r_int
r_char
id|old_leds
op_assign
l_int|0xff
suffix:semicolon
r_int
r_char
id|leds
op_assign
id|kbd_table
(braket
id|fg_console
)braket
dot
id|ledstate
suffix:semicolon
r_if
c_cond
(paren
id|leds
op_ne
id|old_leds
)paren
(brace
id|old_leds
op_assign
id|leds
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|send_data
c_func
(paren
l_int|0xed
)paren
op_logical_or
op_logical_neg
id|send_data
c_func
(paren
id|leds
)paren
)paren
id|send_data
c_func
(paren
l_int|0xf4
)paren
suffix:semicolon
multiline_comment|/* re-enable kbd if any errors */
)brace
r_if
c_cond
(paren
id|want_console
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|want_console
op_ne
id|fg_console
)paren
(brace
id|last_console
op_assign
id|fg_console
suffix:semicolon
id|change_console
c_func
(paren
id|want_console
)paren
suffix:semicolon
)brace
id|want_console
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|got_break
)paren
(brace
r_if
c_cond
(paren
id|tty
op_logical_and
op_logical_neg
id|I_IGNBRK
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|I_BRKINT
c_func
(paren
id|tty
)paren
)paren
(brace
id|flush_input
c_func
(paren
id|tty
)paren
suffix:semicolon
id|flush_output
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;pgrp
OG
l_int|0
)paren
id|kill_pg
c_func
(paren
id|tty-&gt;pgrp
comma
id|SIGINT
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|LEFT
c_func
(paren
op_amp
id|tty-&gt;read_q
)paren
op_ge
l_int|2
)paren
(brace
id|set_bit
c_func
(paren
id|tty-&gt;read_q.head
comma
op_amp
id|tty-&gt;readq_flags
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|TTY_BREAK
)paren
suffix:semicolon
id|put_queue
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|got_break
op_assign
l_int|0
suffix:semicolon
)brace
id|do_keyboard_interrupt
c_func
(paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
l_int|0x64
)paren
op_amp
id|kbd_read_mask
)paren
op_eq
l_int|0x01
)paren
id|fake_keyboard_interrupt
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|no_idt
r_int
id|no_idt
(braket
l_int|2
)braket
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * This routine reboots the machine by asking the keyboard&n; * controller to pulse the reset-line low. We try that for a while,&n; * and if it doesn&squot;t work, we do some other stupid things.&n; */
DECL|function|hard_reset_now
r_void
id|hard_reset_now
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_extern
r_int
r_int
id|pg0
(braket
l_int|1024
)braket
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* rebooting needs to touch the page at absolute addr 0 */
id|pg0
(braket
l_int|0
)braket
op_assign
l_int|7
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
l_int|0x472
)paren
op_assign
l_int|0x1234
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|100000
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* nothing */
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0xfe
comma
l_int|0x64
)paren
suffix:semicolon
multiline_comment|/* pulse reset low */
)brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;tlidt _no_idt&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|kbd_init
r_int
r_int
id|kbd_init
c_func
(paren
r_int
r_int
id|kmem_start
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|kbd_struct
op_star
id|kbd
suffix:semicolon
id|kbd
op_assign
id|kbd_table
op_plus
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CONSOLES
suffix:semicolon
id|i
op_increment
comma
id|kbd
op_increment
)paren
(brace
id|kbd-&gt;ledstate
op_assign
id|KBD_DEFLEDS
suffix:semicolon
id|kbd-&gt;default_ledstate
op_assign
id|KBD_DEFLEDS
suffix:semicolon
id|kbd-&gt;lockstate
op_assign
id|KBD_DEFLOCK
suffix:semicolon
id|kbd-&gt;modeflags
op_assign
id|KBD_DEFMODE
suffix:semicolon
)brace
id|bh_base
(braket
id|KEYBOARD_BH
)braket
dot
id|routine
op_assign
id|kbd_bh
suffix:semicolon
id|request_irq
c_func
(paren
id|KEYBOARD_IRQ
comma
id|keyboard_interrupt
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|KEYBOARD_BH
)paren
suffix:semicolon
r_return
id|kmem_start
suffix:semicolon
)brace
eof
