multiline_comment|/*&n; * linux/drivers/char/keyboard.c&n; *&n; * Keyboard driver for Linux v0.99 using Latin-1.&n; *&n; * Written for linux by Johan Myreen as a translation from&n; * the assembly version by Linus (with diacriticals added)&n; *&n; * Some additional features added by Christoph Niemann (ChN), March 1993&n; *&n; * Loadable keymaps by Risto Kankkunen, May 1993&n; *&n; * Diacriticals redone &amp; other small changes, aeb@cwi.nl, June 1993&n; * Added decr/incr_console, dynamic keymaps, Unicode support,&n; * dynamic function/string keys, led setting,  Sept 1994&n; * &n; */
DECL|macro|KEYBOARD_IRQ
mdefine_line|#define KEYBOARD_IRQ 1
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &quot;kbd_kern.h&quot;
macro_line|#include &quot;diacr.h&quot;
macro_line|#include &quot;vt_kern.h&quot;
DECL|macro|SIZE
mdefine_line|#define SIZE(x) (sizeof(x)/sizeof((x)[0]))
DECL|macro|KBD_REPORT_ERR
mdefine_line|#define KBD_REPORT_ERR
DECL|macro|KBD_REPORT_UNKN
mdefine_line|#define KBD_REPORT_UNKN
multiline_comment|/* #define KBD_IS_FOCUS_9000 */
macro_line|#ifndef KBD_DEFMODE
DECL|macro|KBD_DEFMODE
mdefine_line|#define KBD_DEFMODE ((1 &lt;&lt; VC_REPEAT) | (1 &lt;&lt; VC_META))
macro_line|#endif
macro_line|#ifndef KBD_DEFLEDS
multiline_comment|/*&n; * Some laptops take the 789uiojklm,. keys as number pad when NumLock&n; * is on. This seems a good reason to start with NumLock off.&n; */
DECL|macro|KBD_DEFLEDS
mdefine_line|#define KBD_DEFLEDS 0
macro_line|#endif
macro_line|#ifndef KBD_DEFLOCK
DECL|macro|KBD_DEFLOCK
mdefine_line|#define KBD_DEFLOCK 0
macro_line|#endif
multiline_comment|/*&n; * The default IO slowdown is doing &squot;inb()&squot;s from 0x61, which should be&n; * safe. But as that is the keyboard controller chip address, we do our&n; * slowdowns here by doing short jumps: the keyboard controller should&n; * be able to keep up&n; */
DECL|macro|REALLY_SLOW_IO
mdefine_line|#define REALLY_SLOW_IO
DECL|macro|SLOW_IO_BY_JUMPING
mdefine_line|#define SLOW_IO_BY_JUMPING
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
r_extern
r_void
id|poke_blanked_console
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|ctrl_alt_del
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|reset_vc
c_func
(paren
r_int
r_int
id|new_console
)paren
suffix:semicolon
r_extern
r_void
id|change_console
c_func
(paren
r_int
r_int
id|new_console
)paren
suffix:semicolon
r_extern
r_void
id|scrollback
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_void
id|scrollfront
c_func
(paren
r_int
)paren
suffix:semicolon
r_extern
r_int
id|vc_cons_allocated
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|macro|fake_keyboard_interrupt
mdefine_line|#define fake_keyboard_interrupt() &bslash;&n;__asm__ __volatile__(&quot;int $0x21&quot;)
DECL|variable|kbd_read_mask
r_int
r_char
id|kbd_read_mask
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* modified by psaux.c */
multiline_comment|/*&n; * global state includes the following, and various static variables&n; * in this module: prev_scancode, shift_state, diacr, npadch,&n; *   dead_key_next, last_console&n; */
multiline_comment|/* shift state counters.. */
DECL|variable|k_down
r_static
r_int
r_char
id|k_down
(braket
id|NR_SHIFT
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* keyboard key bitmap */
DECL|variable|key_down
r_static
r_int
r_int
id|key_down
(braket
l_int|8
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|want_console
r_static
r_int
id|want_console
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|last_console
r_static
r_int
id|last_console
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* last used VC */
DECL|variable|dead_key_next
r_static
r_int
id|dead_key_next
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* &n; * In order to retrieve the shift_state (for the mouse server), either&n; * the variable must be global, or a new procedure must be created to &n; * return the value. I chose the former way.&n; */
DECL|variable|shift_state
multiline_comment|/*static*/
r_int
id|shift_state
op_assign
l_int|0
suffix:semicolon
DECL|variable|npadch
r_static
r_int
id|npadch
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* -1 or number assembled on pad */
DECL|variable|diacr
r_static
r_int
r_char
id|diacr
op_assign
l_int|0
suffix:semicolon
DECL|variable|rep
r_static
r_char
id|rep
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* flag telling character repeat */
DECL|variable|kbd_table
r_struct
id|kbd_struct
id|kbd_table
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
DECL|variable|ttytab
r_static
r_struct
id|tty_struct
op_star
op_star
id|ttytab
suffix:semicolon
DECL|variable|kbd
r_static
r_struct
id|kbd_struct
op_star
id|kbd
op_assign
id|kbd_table
suffix:semicolon
DECL|variable|tty
r_static
r_struct
id|tty_struct
op_star
id|tty
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* used only by send_data - set by keyboard_interrupt */
DECL|variable|reply_expected
r_static
r_volatile
r_int
r_char
id|reply_expected
op_assign
l_int|0
suffix:semicolon
DECL|variable|acknowledge
r_static
r_volatile
r_int
r_char
id|acknowledge
op_assign
l_int|0
suffix:semicolon
DECL|variable|resend
r_static
r_volatile
r_int
r_char
id|resend
op_assign
l_int|0
suffix:semicolon
DECL|typedef|k_hand
r_typedef
r_void
(paren
op_star
id|k_hand
)paren
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
DECL|typedef|k_handfn
r_typedef
r_void
(paren
id|k_handfn
)paren
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
suffix:semicolon
r_static
id|k_handfn
DECL|variable|do_self
DECL|variable|do_fn
DECL|variable|do_spec
DECL|variable|do_pad
DECL|variable|do_dead
DECL|variable|do_cons
DECL|variable|do_cur
DECL|variable|do_shift
id|do_self
comma
id|do_fn
comma
id|do_spec
comma
id|do_pad
comma
id|do_dead
comma
id|do_cons
comma
id|do_cur
comma
id|do_shift
comma
DECL|variable|do_meta
DECL|variable|do_ascii
DECL|variable|do_lock
DECL|variable|do_lowercase
DECL|variable|do_ignore
id|do_meta
comma
id|do_ascii
comma
id|do_lock
comma
id|do_lowercase
comma
id|do_ignore
suffix:semicolon
DECL|variable|key_handler
r_static
id|k_hand
id|key_handler
(braket
l_int|16
)braket
op_assign
(brace
id|do_self
comma
id|do_fn
comma
id|do_spec
comma
id|do_pad
comma
id|do_dead
comma
id|do_cons
comma
id|do_cur
comma
id|do_shift
comma
id|do_meta
comma
id|do_ascii
comma
id|do_lock
comma
id|do_lowercase
comma
id|do_ignore
comma
id|do_ignore
comma
id|do_ignore
comma
id|do_ignore
)brace
suffix:semicolon
DECL|typedef|void_fnp
r_typedef
r_void
(paren
op_star
id|void_fnp
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|typedef|void_fn
r_typedef
r_void
(paren
id|void_fn
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|variable|enter
DECL|variable|show_ptregs
DECL|variable|send_intr
DECL|variable|lastcons
DECL|variable|caps_toggle
r_static
id|void_fn
id|enter
comma
id|show_ptregs
comma
id|send_intr
comma
id|lastcons
comma
id|caps_toggle
comma
DECL|variable|num
DECL|variable|hold
DECL|variable|scroll_forw
DECL|variable|scroll_back
DECL|variable|boot_it
DECL|variable|caps_on
DECL|variable|compose
id|num
comma
id|hold
comma
id|scroll_forw
comma
id|scroll_back
comma
id|boot_it
comma
id|caps_on
comma
id|compose
comma
DECL|variable|SAK
DECL|variable|decr_console
DECL|variable|incr_console
id|SAK
comma
id|decr_console
comma
id|incr_console
suffix:semicolon
DECL|variable|spec_fn_table
r_static
id|void_fnp
id|spec_fn_table
(braket
)braket
op_assign
(brace
l_int|NULL
comma
id|enter
comma
id|show_ptregs
comma
id|show_mem
comma
id|show_state
comma
id|send_intr
comma
id|lastcons
comma
id|caps_toggle
comma
id|num
comma
id|hold
comma
id|scroll_forw
comma
id|scroll_back
comma
id|boot_it
comma
id|caps_on
comma
id|compose
comma
id|SAK
comma
id|decr_console
comma
id|incr_console
)brace
suffix:semicolon
multiline_comment|/* maximum values each key_handler can handle */
DECL|variable|max_vals
r_const
r_int
id|max_vals
(braket
)braket
op_assign
(brace
l_int|255
comma
id|SIZE
c_func
(paren
id|func_table
)paren
op_minus
l_int|1
comma
id|SIZE
c_func
(paren
id|spec_fn_table
)paren
op_minus
l_int|1
comma
id|NR_PAD
op_minus
l_int|1
comma
id|NR_DEAD
op_minus
l_int|1
comma
l_int|255
comma
l_int|3
comma
id|NR_SHIFT
op_minus
l_int|1
comma
l_int|255
comma
id|NR_ASCII
op_minus
l_int|1
comma
id|NR_LOCK
op_minus
l_int|1
comma
l_int|255
)brace
suffix:semicolon
DECL|variable|NR_TYPES
r_const
r_int
id|NR_TYPES
op_assign
id|SIZE
c_func
(paren
id|max_vals
)paren
suffix:semicolon
r_static
r_void
id|put_queue
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_int
r_char
id|handle_diacr
c_func
(paren
r_int
r_char
)paren
suffix:semicolon
multiline_comment|/* pt_regs - set by keyboard_interrupt(), used by show_ptregs() */
DECL|variable|pt_regs
r_static
r_struct
id|pt_regs
op_star
id|pt_regs
suffix:semicolon
DECL|function|kb_wait
r_static
r_inline
r_void
id|kb_wait
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x10000
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
l_int|0x64
)paren
op_amp
l_int|0x02
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
DECL|function|send_cmd
r_static
r_inline
r_void
id|send_cmd
c_func
(paren
r_int
r_char
id|c
)paren
(brace
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|c
comma
l_int|0x64
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Many other routines do put_queue, but I think either&n; * they produce ASCII, or they produce some user-assigned&n; * string, and in both cases we might assume that it is&n; * in utf-8 already.&n; */
DECL|function|to_utf8
r_void
id|to_utf8
c_func
(paren
id|ushort
id|c
)paren
(brace
r_if
c_cond
(paren
id|c
OL
l_int|0x80
)paren
id|put_queue
c_func
(paren
id|c
)paren
suffix:semicolon
multiline_comment|/*  0*******  */
r_else
r_if
c_cond
(paren
id|c
OL
l_int|0x800
)paren
(brace
id|put_queue
c_func
(paren
l_int|0xc0
op_or
(paren
id|c
op_rshift
l_int|6
)paren
)paren
suffix:semicolon
multiline_comment|/*  110***** 10******  */
id|put_queue
c_func
(paren
l_int|0x80
op_or
(paren
id|c
op_amp
l_int|0x3f
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|put_queue
c_func
(paren
l_int|0xe0
op_or
(paren
id|c
op_rshift
l_int|12
)paren
)paren
suffix:semicolon
multiline_comment|/*  1110**** 10****** 10******  */
id|put_queue
c_func
(paren
l_int|0x80
op_or
(paren
(paren
id|c
op_rshift
l_int|6
)paren
op_amp
l_int|0x3f
)paren
)paren
suffix:semicolon
id|put_queue
c_func
(paren
l_int|0x80
op_or
(paren
id|c
op_amp
l_int|0x3f
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* uft-8 is defined for words of up to 36 bits,&n;       but we need only 16 bits here */
)brace
multiline_comment|/*&n; * Translation of escaped scancodes to keysyms.&n; * This should be user-settable.&n; */
DECL|macro|E0_BASE
mdefine_line|#define E0_BASE 96
DECL|macro|E0_KPENTER
mdefine_line|#define E0_KPENTER (E0_BASE+0)
DECL|macro|E0_RCTRL
mdefine_line|#define E0_RCTRL   (E0_BASE+1)
DECL|macro|E0_KPSLASH
mdefine_line|#define E0_KPSLASH (E0_BASE+2)
DECL|macro|E0_PRSCR
mdefine_line|#define E0_PRSCR   (E0_BASE+3)
DECL|macro|E0_RALT
mdefine_line|#define E0_RALT    (E0_BASE+4)
DECL|macro|E0_BREAK
mdefine_line|#define E0_BREAK   (E0_BASE+5)  /* (control-pause) */
DECL|macro|E0_HOME
mdefine_line|#define E0_HOME    (E0_BASE+6)
DECL|macro|E0_UP
mdefine_line|#define E0_UP      (E0_BASE+7)
DECL|macro|E0_PGUP
mdefine_line|#define E0_PGUP    (E0_BASE+8)
DECL|macro|E0_LEFT
mdefine_line|#define E0_LEFT    (E0_BASE+9)
DECL|macro|E0_RIGHT
mdefine_line|#define E0_RIGHT   (E0_BASE+10)
DECL|macro|E0_END
mdefine_line|#define E0_END     (E0_BASE+11)
DECL|macro|E0_DOWN
mdefine_line|#define E0_DOWN    (E0_BASE+12)
DECL|macro|E0_PGDN
mdefine_line|#define E0_PGDN    (E0_BASE+13)
DECL|macro|E0_INS
mdefine_line|#define E0_INS     (E0_BASE+14)
DECL|macro|E0_DEL
mdefine_line|#define E0_DEL     (E0_BASE+15)
multiline_comment|/* BTC */
DECL|macro|E0_MACRO
mdefine_line|#define E0_MACRO   (E0_BASE+16)
multiline_comment|/* LK450 */
DECL|macro|E0_F13
mdefine_line|#define E0_F13     (E0_BASE+17)
DECL|macro|E0_F14
mdefine_line|#define E0_F14     (E0_BASE+18)
DECL|macro|E0_HELP
mdefine_line|#define E0_HELP    (E0_BASE+19)
DECL|macro|E0_DO
mdefine_line|#define E0_DO      (E0_BASE+20)
DECL|macro|E0_F17
mdefine_line|#define E0_F17     (E0_BASE+21)
DECL|macro|E0_KPMINPLUS
mdefine_line|#define E0_KPMINPLUS (E0_BASE+22)
DECL|macro|E1_PAUSE
mdefine_line|#define E1_PAUSE   (E0_BASE+23)&t;                      /* 119 */
DECL|variable|e0_keys
r_static
r_int
r_char
id|e0_keys
(braket
l_int|128
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x00-0x07 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x08-0x0f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x10-0x17 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_KPENTER
comma
id|E0_RCTRL
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x18-0x1f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x20-0x27 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x28-0x2f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_KPSLASH
comma
l_int|0
comma
id|E0_PRSCR
comma
multiline_comment|/* 0x30-0x37 */
id|E0_RALT
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_F13
comma
id|E0_F14
comma
id|E0_HELP
comma
multiline_comment|/* 0x38-0x3f */
id|E0_DO
comma
id|E0_F17
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_BREAK
comma
id|E0_HOME
comma
multiline_comment|/* 0x40-0x47 */
id|E0_UP
comma
id|E0_PGUP
comma
l_int|0
comma
id|E0_LEFT
comma
l_int|0
comma
id|E0_RIGHT
comma
id|E0_KPMINPLUS
comma
id|E0_END
comma
multiline_comment|/* 0x48-0x4f */
id|E0_DOWN
comma
id|E0_PGDN
comma
id|E0_INS
comma
id|E0_DEL
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x50-0x57 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x58-0x5f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x60-0x67 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|E0_MACRO
comma
multiline_comment|/* 0x68-0x6f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x70-0x77 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
multiline_comment|/* 0x78-0x7f */
)brace
suffix:semicolon
multiline_comment|/* kludge to stay below 128 - next time someone comes with a strange&n;   keyboard, key codes will have to become 2 (or 4) bytes. */
multiline_comment|/* Owners of a FOCUS 9000 can assign F1,F2-F8,F9-F12 to 85,89-95,120-123 */
multiline_comment|/* Owners of a certain Japanese keyboard can use 89 and 124 */
multiline_comment|/* Owners of a certain Brazilian keyboard can use 89 and 121 */
multiline_comment|/* Note: MEDIUMRAW mode will change, and all keycodes above 89 will change;&n;   this is only a temporary solution */
DECL|macro|SC_LIM
mdefine_line|#define SC_LIM 89
DECL|macro|FOCUS_PF1
mdefine_line|#define FOCUS_PF1 85           /* actual code! */
DECL|macro|FOCUS_PF2
mdefine_line|#define FOCUS_PF2 89
DECL|macro|FOCUS_PF3
mdefine_line|#define FOCUS_PF3 90
DECL|macro|FOCUS_PF4
mdefine_line|#define FOCUS_PF4 91
DECL|macro|FOCUS_PF5
mdefine_line|#define FOCUS_PF5 92
DECL|macro|FOCUS_PF6
mdefine_line|#define FOCUS_PF6 93
DECL|macro|FOCUS_PF7
mdefine_line|#define FOCUS_PF7 94
DECL|macro|FOCUS_PF8
mdefine_line|#define FOCUS_PF8 95
DECL|macro|FOCUS_PF9
mdefine_line|#define FOCUS_PF9 (E1_PAUSE + 1)
DECL|macro|FOCUS_PF10
mdefine_line|#define FOCUS_PF10 (E1_PAUSE + 2)
DECL|macro|FOCUS_PF11
mdefine_line|#define FOCUS_PF11 (E1_PAUSE + 3)
DECL|macro|FOCUS_PF12
mdefine_line|#define FOCUS_PF12 (E1_PAUSE + 4)                    /* 123 */
DECL|macro|JAP_86
mdefine_line|#define JAP_86     (E1_PAUSE + 5)                    /* 124 */
DECL|variable|high_keys
r_static
r_int
r_char
id|high_keys
(braket
l_int|128
op_minus
id|SC_LIM
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x59-0x5f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
multiline_comment|/* 0x60-0x67 */
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|FOCUS_PF11
comma
l_int|0
comma
id|FOCUS_PF12
comma
multiline_comment|/* 0x68-0x6f */
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|FOCUS_PF2
comma
id|FOCUS_PF9
comma
l_int|0
comma
l_int|0
comma
id|FOCUS_PF3
comma
multiline_comment|/* 0x70-0x77 */
id|FOCUS_PF4
comma
id|FOCUS_PF5
comma
id|FOCUS_PF6
comma
id|FOCUS_PF7
comma
multiline_comment|/* 0x78-0x7b */
id|FOCUS_PF8
comma
id|JAP_86
comma
id|FOCUS_PF10
comma
l_int|0
multiline_comment|/* 0x7c-0x7f */
)brace
suffix:semicolon
DECL|function|keyboard_interrupt
r_static
r_void
id|keyboard_interrupt
c_func
(paren
r_int
id|int_pt_regs
)paren
(brace
r_int
r_char
id|scancode
comma
id|keycode
suffix:semicolon
r_static
r_int
r_int
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* remember E0, E1 */
r_char
id|up_flag
suffix:semicolon
multiline_comment|/* 0 or 0200 */
r_char
id|raw_mode
suffix:semicolon
id|pt_regs
op_assign
(paren
r_struct
id|pt_regs
op_star
)paren
id|int_pt_regs
suffix:semicolon
id|send_cmd
c_func
(paren
l_int|0xAD
)paren
suffix:semicolon
multiline_comment|/* disable keyboard */
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
l_int|0x64
)paren
op_amp
id|kbd_read_mask
)paren
op_ne
l_int|0x01
)paren
r_goto
id|end_kbd_intr
suffix:semicolon
id|scancode
op_assign
id|inb
c_func
(paren
l_int|0x60
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|KEYBOARD_BH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reply_expected
)paren
(brace
multiline_comment|/* 0xfa, 0xfe only mean &quot;acknowledge&quot;, &quot;resend&quot; for most keyboards */
multiline_comment|/* but they are the key-up scancodes for PF6, PF10 on a FOCUS 9000 */
id|reply_expected
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xfa
)paren
(brace
id|acknowledge
op_assign
l_int|1
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xfe
)paren
(brace
id|resend
op_assign
l_int|1
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
multiline_comment|/* strange ... */
id|reply_expected
op_assign
l_int|1
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;keyboard reply expected - got %02x&bslash;n&quot;
comma
id|scancode
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef KBD_REPORT_ERR
id|printk
c_func
(paren
l_string|&quot;keyboard buffer overflow&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xff
)paren
(brace
multiline_comment|/* the calculator keys on a FOCUS 9000 generate 0xff */
macro_line|#ifndef KBD_IS_FOCUS_9000
macro_line|#ifdef KBD_REPORT_ERR
id|printk
c_func
(paren
l_string|&quot;keyboard error&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
id|tty
op_assign
id|ttytab
(braket
id|fg_console
)braket
suffix:semicolon
id|kbd
op_assign
id|kbd_table
op_plus
id|fg_console
suffix:semicolon
r_if
c_cond
(paren
(paren
id|raw_mode
op_assign
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_RAW
)paren
)paren
)paren
(brace
id|put_queue
c_func
(paren
id|scancode
)paren
suffix:semicolon
multiline_comment|/* we do not return yet, because we want to maintain&n;&t;&t;   the key_down array, so that we have the correct&n;&t;&t;   values when finishing RAW mode or when changing VT&squot;s */
)brace
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0xe0
op_logical_or
id|scancode
op_eq
l_int|0xe1
)paren
(brace
id|prev_scancode
op_assign
id|scancode
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Convert scancode to keycode, using prev_scancode.&n; &t; */
id|up_flag
op_assign
(paren
id|scancode
op_amp
l_int|0200
)paren
suffix:semicolon
id|scancode
op_and_assign
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|prev_scancode
)paren
(brace
multiline_comment|/*&n;&t;   * usually it will be 0xe0, but a Pause key generates&n;&t;   * e1 1d 45 e1 9d c5 when pressed, and nothing when released&n;&t;   */
r_if
c_cond
(paren
id|prev_scancode
op_ne
l_int|0xe0
)paren
(brace
r_if
c_cond
(paren
id|prev_scancode
op_eq
l_int|0xe1
op_logical_and
id|scancode
op_eq
l_int|0x1d
)paren
(brace
id|prev_scancode
op_assign
l_int|0x100
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|prev_scancode
op_eq
l_int|0x100
op_logical_and
id|scancode
op_eq
l_int|0x45
)paren
(brace
id|keycode
op_assign
id|E1_PAUSE
suffix:semicolon
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef KBD_REPORT_UNKN
id|printk
c_func
(paren
l_string|&quot;keyboard: unknown e1 escape sequence&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
)brace
r_else
(brace
id|prev_scancode
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;       *  The keyboard maintains its own internal caps lock and&n;&t;       *  num lock statuses. In caps lock mode E0 AA precedes make&n;&t;       *  code and E0 2A follows break code. In num lock mode,&n;&t;       *  E0 2A precedes make code and E0 AA follows break code.&n;&t;       *  We do our own book-keeping, so we will just ignore these.&n;&t;       */
multiline_comment|/*&n;&t;       *  For my keyboard there is no caps lock mode, but there are&n;&t;       *  both Shift-L and Shift-R modes. The former mode generates&n;&t;       *  E0 2A / E0 AA pairs, the latter E0 B6 / E0 36 pairs.&n;&t;       *  So, we should also ignore the latter. - aeb@cwi.nl&n;&t;       */
r_if
c_cond
(paren
id|scancode
op_eq
l_int|0x2a
op_logical_or
id|scancode
op_eq
l_int|0x36
)paren
r_goto
id|end_kbd_intr
suffix:semicolon
r_if
c_cond
(paren
id|e0_keys
(braket
id|scancode
)braket
)paren
id|keycode
op_assign
id|e0_keys
(braket
id|scancode
)braket
suffix:semicolon
r_else
(brace
macro_line|#ifdef KBD_REPORT_UNKN
r_if
c_cond
(paren
op_logical_neg
id|raw_mode
)paren
id|printk
c_func
(paren
l_string|&quot;keyboard: unknown scancode e0 %02x&bslash;n&quot;
comma
id|scancode
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|scancode
op_ge
id|SC_LIM
)paren
(brace
multiline_comment|/* This happens with the FOCUS 9000 keyboard&n;&t;       Its keys PF1..PF12 are reported to generate&n;&t;       55 73 77 78 79 7a 7b 7c 74 7e 6d 6f&n;&t;       Moreover, unless repeated, they do not generate&n;&t;       key-down events, so we have to zero up_flag below */
multiline_comment|/* Also, Japanese 86/106 keyboards are reported to&n;&t;       generate 0x73 and 0x7d for &bslash; - and &bslash; | respectively. */
multiline_comment|/* Also, some Brazilian keyboard is reported to produce&n;&t;       0x73 and 0x7e for &bslash; ? and KP-dot, respectively. */
id|keycode
op_assign
id|high_keys
(braket
id|scancode
op_minus
id|SC_LIM
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|keycode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|raw_mode
)paren
(brace
macro_line|#ifdef KBD_REPORT_UNKN
id|printk
c_func
(paren
l_string|&quot;keyboard: unrecognized scancode (%02x) - ignored&bslash;n&quot;
comma
id|scancode
)paren
suffix:semicolon
macro_line|#endif
)brace
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
)brace
r_else
id|keycode
op_assign
id|scancode
suffix:semicolon
multiline_comment|/*&n;&t; * At this point the variable `keycode&squot; contains the keycode.&n;&t; * Note: the keycode must not be 0.&n;&t; * We keep track of the up/down status of the key, and&n;&t; * return the keycode if in MEDIUMRAW mode.&n;&t; */
r_if
c_cond
(paren
id|up_flag
)paren
(brace
id|rep
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|clear_bit
c_func
(paren
id|keycode
comma
id|key_down
)paren
)paren
(brace
multiline_comment|/* unexpected, but this can happen:&n;&t;&t;       maybe this was a key release for a FOCUS 9000&n;&t;&t;       PF key; if we want to see it, we have to clear&n;&t;&t;       up_flag */
r_if
c_cond
(paren
id|keycode
op_ge
id|SC_LIM
op_logical_or
id|keycode
op_eq
l_int|85
)paren
id|up_flag
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
id|rep
op_assign
id|set_bit
c_func
(paren
id|keycode
comma
id|key_down
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raw_mode
)paren
r_goto
id|end_kbd_intr
suffix:semicolon
r_if
c_cond
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_MEDIUMRAW
)paren
(brace
multiline_comment|/* soon keycodes will require more than one byte */
id|put_queue
c_func
(paren
id|keycode
op_plus
id|up_flag
)paren
suffix:semicolon
r_goto
id|end_kbd_intr
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Small change in philosophy: earlier we defined repetition by&n;&t; *&t; rep = keycode == prev_keycode;&n;&t; *&t; prev_keycode = keycode;&n;&t; * but now by the fact that the depressed key was down already.&n;&t; * Does this ever make a difference? Yes.&n;&t; */
multiline_comment|/*&n; &t; *  Repeat a key only if the input buffers are empty or the&n; &t; *  characters get echoed locally. This makes key repeat usable&n; &t; *  with slow applications and under heavy loads.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|rep
op_logical_or
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_REPEAT
)paren
op_logical_and
id|tty
op_logical_and
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
op_logical_or
(paren
id|tty-&gt;driver
dot
id|chars_in_buffer
c_func
(paren
id|tty
)paren
op_eq
l_int|0
)paren
)paren
)paren
)paren
(brace
id|u_short
id|keysym
suffix:semicolon
id|u_char
id|type
suffix:semicolon
multiline_comment|/* the XOR below used to be an OR */
r_int
id|shift_final
op_assign
id|shift_state
op_xor
id|kbd-&gt;lockstate
suffix:semicolon
id|ushort
op_star
id|key_map
op_assign
id|key_maps
(braket
id|shift_final
)braket
suffix:semicolon
r_if
c_cond
(paren
id|key_map
op_ne
l_int|NULL
)paren
(brace
id|keysym
op_assign
id|key_map
(braket
id|keycode
)braket
suffix:semicolon
id|type
op_assign
id|KTYP
c_func
(paren
id|keysym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
l_int|0xf0
)paren
(brace
id|type
op_sub_assign
l_int|0xf0
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|KT_LETTER
)paren
(brace
id|type
op_assign
id|KT_LATIN
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
)paren
(brace
id|key_map
op_assign
id|key_maps
(braket
id|shift_final
op_xor
(paren
l_int|1
op_lshift
id|KG_SHIFT
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|key_map
)paren
id|keysym
op_assign
id|key_map
(braket
id|keycode
)braket
suffix:semicolon
)brace
)brace
(paren
op_star
id|key_handler
(braket
id|type
)braket
)paren
(paren
id|keysym
op_amp
l_int|0xff
comma
id|up_flag
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* maybe only if (kbd-&gt;kbdmode == VC_UNICODE) ? */
r_if
c_cond
(paren
op_logical_neg
id|up_flag
)paren
id|to_utf8
c_func
(paren
id|keysym
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* maybe beep? */
multiline_comment|/* we have at least to update shift_state */
macro_line|#if 0&t;&t;&t;/* how? two almost equivalent choices follow */
id|compute_shiftstate
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
id|keysym
op_assign
id|U
c_func
(paren
id|plain_map
(braket
id|keycode
)braket
)paren
suffix:semicolon
id|type
op_assign
id|KTYP
c_func
(paren
id|keysym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type
op_eq
id|KT_SHIFT
)paren
(paren
op_star
id|key_handler
(braket
id|type
)braket
)paren
(paren
id|keysym
op_amp
l_int|0xff
comma
id|up_flag
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
id|end_kbd_intr
suffix:colon
id|send_cmd
c_func
(paren
l_int|0xAE
)paren
suffix:semicolon
multiline_comment|/* enable keyboard */
)brace
DECL|function|put_queue
r_static
r_void
id|put_queue
c_func
(paren
r_int
id|ch
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|keypress_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
id|ch
comma
l_int|0
)paren
suffix:semicolon
id|tty_schedule_flip
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
)brace
DECL|function|puts_queue
r_static
r_void
id|puts_queue
c_func
(paren
r_char
op_star
id|cp
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|keypress_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
op_star
id|cp
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
op_star
id|cp
comma
l_int|0
)paren
suffix:semicolon
id|cp
op_increment
suffix:semicolon
)brace
id|tty_schedule_flip
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|applkey
r_static
r_void
id|applkey
c_func
(paren
r_int
id|key
comma
r_char
id|mode
)paren
(brace
r_static
r_char
id|buf
(braket
)braket
op_assign
(brace
l_int|0x1b
comma
l_char|&squot;O&squot;
comma
l_int|0x00
comma
l_int|0x00
)brace
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
(paren
id|mode
ques
c_cond
l_char|&squot;O&squot;
suffix:colon
l_char|&squot;[&squot;
)paren
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|key
suffix:semicolon
id|puts_queue
c_func
(paren
id|buf
)paren
suffix:semicolon
)brace
DECL|function|enter
r_static
r_void
id|enter
c_func
(paren
r_void
)paren
(brace
id|put_queue
c_func
(paren
l_int|13
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_CRLF
)paren
)paren
id|put_queue
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|caps_toggle
r_static
r_void
id|caps_toggle
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
id|chg_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
DECL|function|caps_on
r_static
r_void
id|caps_on
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
id|set_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
DECL|function|show_ptregs
r_static
r_void
id|show_ptregs
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pt_regs
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EIP: %04x:%08lx&quot;
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;cs
comma
id|pt_regs-&gt;eip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pt_regs-&gt;cs
op_amp
l_int|3
)paren
id|printk
c_func
(paren
l_string|&quot; ESP: %04x:%08lx&quot;
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;ss
comma
id|pt_regs-&gt;esp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; EFLAGS: %08lx&bslash;n&quot;
comma
id|pt_regs-&gt;eflags
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;EAX: %08lx EBX: %08lx ECX: %08lx EDX: %08lx&bslash;n&quot;
comma
id|pt_regs-&gt;orig_eax
comma
id|pt_regs-&gt;ebx
comma
id|pt_regs-&gt;ecx
comma
id|pt_regs-&gt;edx
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ESI: %08lx EDI: %08lx EBP: %08lx&quot;
comma
id|pt_regs-&gt;esi
comma
id|pt_regs-&gt;edi
comma
id|pt_regs-&gt;ebp
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; DS: %04x ES: %04x FS: %04x GS: %04x&bslash;n&quot;
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;ds
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;es
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;fs
comma
l_int|0xffff
op_amp
id|pt_regs-&gt;gs
)paren
suffix:semicolon
)brace
DECL|function|hold
r_static
r_void
id|hold
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|rep
op_logical_or
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * Note: SCROLLOCK will be set (cleared) by stop_tty (start_tty);&n;&t; * these routines are also activated by ^S/^Q.&n;&t; * (And SCROLLOCK can also be set by the ioctl KDSKBLED.)&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;stopped
)paren
id|start_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_else
id|stop_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|num
r_static
r_void
id|num
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
)paren
(brace
id|applkey
c_func
(paren
l_char|&squot;P&squot;
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|rep
)paren
multiline_comment|/* no autorepeat for numlock, ChN */
id|chg_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_NUMLOCK
)paren
suffix:semicolon
)brace
DECL|function|lastcons
r_static
r_void
id|lastcons
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* switch to the last used console, ChN */
id|want_console
op_assign
id|last_console
suffix:semicolon
)brace
DECL|function|decr_console
r_static
r_void
id|decr_console
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|fg_console
op_minus
l_int|1
suffix:semicolon
id|i
op_ne
id|fg_console
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
op_minus
l_int|1
)paren
id|i
op_assign
id|MAX_NR_CONSOLES
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|vc_cons_allocated
c_func
(paren
id|i
)paren
)paren
r_break
suffix:semicolon
)brace
id|want_console
op_assign
id|i
suffix:semicolon
)brace
DECL|function|incr_console
r_static
r_void
id|incr_console
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|fg_console
op_plus
l_int|1
suffix:semicolon
id|i
op_ne
id|fg_console
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_eq
id|MAX_NR_CONSOLES
)paren
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vc_cons_allocated
c_func
(paren
id|i
)paren
)paren
r_break
suffix:semicolon
)brace
id|want_console
op_assign
id|i
suffix:semicolon
)brace
DECL|function|send_intr
r_static
r_void
id|send_intr
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
(paren
id|tty-&gt;termios
op_logical_and
id|I_IGNBRK
c_func
(paren
id|tty
)paren
)paren
)paren
r_return
suffix:semicolon
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
l_int|0
comma
id|TTY_BREAK
)paren
suffix:semicolon
)brace
DECL|function|scroll_forw
r_static
r_void
id|scroll_forw
c_func
(paren
r_void
)paren
(brace
id|scrollfront
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|scroll_back
r_static
r_void
id|scroll_back
c_func
(paren
r_void
)paren
(brace
id|scrollback
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|boot_it
r_static
r_void
id|boot_it
c_func
(paren
r_void
)paren
(brace
id|ctrl_alt_del
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|compose
r_static
r_void
id|compose
c_func
(paren
r_void
)paren
(brace
id|dead_key_next
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|SAK
r_static
r_void
id|SAK
c_func
(paren
r_void
)paren
(brace
id|do_SAK
c_func
(paren
id|tty
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/*&n;&t; * Need to fix SAK handling to fix up RAW/MEDIUM_RAW and&n;&t; * vt_cons modes before we can enable RAW/MEDIUM_RAW SAK&n;&t; * handling.&n;&t; * &n;&t; * We should do this some day --- the whole point of a secure&n;&t; * attention key is that it should be guaranteed to always&n;&t; * work.&n;&t; */
id|reset_vc
c_func
(paren
id|fg_console
)paren
suffix:semicolon
id|unblank_screen
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* not in interrupt routine? */
macro_line|#endif
)brace
DECL|function|do_ignore
r_static
r_void
id|do_ignore
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
)brace
DECL|function|do_spec
r_static
r_void
id|do_spec
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|value
op_ge
id|SIZE
c_func
(paren
id|spec_fn_table
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|spec_fn_table
(braket
id|value
)braket
)paren
r_return
suffix:semicolon
id|spec_fn_table
(braket
id|value
)braket
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_lowercase
r_static
r_void
id|do_lowercase
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;keyboard.c: do_lowercase was called - impossible&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|do_self
r_static
r_void
id|do_self
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
multiline_comment|/* no action, if this is a key release */
r_if
c_cond
(paren
id|diacr
)paren
id|value
op_assign
id|handle_diacr
c_func
(paren
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dead_key_next
)paren
(brace
id|dead_key_next
op_assign
l_int|0
suffix:semicolon
id|diacr
op_assign
id|value
suffix:semicolon
r_return
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|value
)paren
suffix:semicolon
)brace
DECL|macro|A_GRAVE
mdefine_line|#define A_GRAVE  &squot;`&squot;
DECL|macro|A_ACUTE
mdefine_line|#define A_ACUTE  &squot;&bslash;&squot;&squot;
DECL|macro|A_CFLEX
mdefine_line|#define A_CFLEX  &squot;^&squot;
DECL|macro|A_TILDE
mdefine_line|#define A_TILDE  &squot;~&squot;
DECL|macro|A_DIAER
mdefine_line|#define A_DIAER  &squot;&quot;&squot;
DECL|variable|ret_diacr
r_static
r_int
r_char
id|ret_diacr
(braket
)braket
op_assign
(brace
id|A_GRAVE
comma
id|A_ACUTE
comma
id|A_CFLEX
comma
id|A_TILDE
comma
id|A_DIAER
)brace
suffix:semicolon
multiline_comment|/* If a dead key pressed twice, output a character corresponding to it,&t;*/
multiline_comment|/* otherwise just remember the dead key.&t;&t;&t;&t;*/
DECL|function|do_dead
r_static
r_void
id|do_dead
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|value
op_assign
id|ret_diacr
(braket
id|value
)braket
suffix:semicolon
r_if
c_cond
(paren
id|diacr
op_eq
id|value
)paren
(brace
multiline_comment|/* pressed twice */
id|diacr
op_assign
l_int|0
suffix:semicolon
id|put_queue
c_func
(paren
id|value
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|diacr
op_assign
id|value
suffix:semicolon
)brace
multiline_comment|/* If space is pressed, return the character corresponding the pending&t;*/
multiline_comment|/* dead key, otherwise try to combine the two.&t;&t;&t;&t;*/
DECL|function|handle_diacr
r_int
r_char
id|handle_diacr
c_func
(paren
r_int
r_char
id|ch
)paren
(brace
r_int
id|d
op_assign
id|diacr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|diacr
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ch
op_eq
l_char|&squot; &squot;
)paren
r_return
id|d
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|accent_table_size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|accent_table
(braket
id|i
)braket
dot
id|diacr
op_eq
id|d
op_logical_and
id|accent_table
(braket
id|i
)braket
dot
id|base
op_eq
id|ch
)paren
r_return
id|accent_table
(braket
id|i
)braket
dot
id|result
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|d
)paren
suffix:semicolon
r_return
id|ch
suffix:semicolon
)brace
DECL|function|do_cons
r_static
r_void
id|do_cons
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|want_console
op_assign
id|value
suffix:semicolon
)brace
DECL|function|do_fn
r_static
r_void
id|do_fn
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
id|SIZE
c_func
(paren
id|func_table
)paren
)paren
(brace
r_if
c_cond
(paren
id|func_table
(braket
id|value
)braket
)paren
id|puts_queue
c_func
(paren
id|func_table
(braket
id|value
)braket
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;do_fn called with value=%d&bslash;n&quot;
comma
id|value
)paren
suffix:semicolon
)brace
DECL|function|do_pad
r_static
r_void
id|do_pad
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_static
r_char
op_star
id|pad_chars
op_assign
l_string|&quot;0123456789+-*/&bslash;015,.?&quot;
suffix:semicolon
r_static
r_char
op_star
id|app_map
op_assign
l_string|&quot;pqrstuvwxylSRQMnn?&quot;
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
multiline_comment|/* no action, if this is a key release */
multiline_comment|/* kludge... shift forces cursor/number keys */
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
op_logical_and
op_logical_neg
id|k_down
(braket
id|KG_SHIFT
)braket
)paren
(brace
id|applkey
c_func
(paren
id|app_map
(braket
id|value
)braket
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_NUMLOCK
)paren
)paren
r_switch
c_cond
(paren
id|value
)paren
(brace
r_case
id|KVAL
c_func
(paren
id|K_PCOMMA
)paren
suffix:colon
r_case
id|KVAL
c_func
(paren
id|K_PDOT
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_REMOVE
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P0
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_INSERT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P1
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_SELECT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P2
)paren
suffix:colon
id|do_cur
c_func
(paren
id|KVAL
c_func
(paren
id|K_DOWN
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P3
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_PGDN
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P4
)paren
suffix:colon
id|do_cur
c_func
(paren
id|KVAL
c_func
(paren
id|K_LEFT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P6
)paren
suffix:colon
id|do_cur
c_func
(paren
id|KVAL
c_func
(paren
id|K_RIGHT
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P7
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_FIND
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P8
)paren
suffix:colon
id|do_cur
c_func
(paren
id|KVAL
c_func
(paren
id|K_UP
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P9
)paren
suffix:colon
id|do_fn
c_func
(paren
id|KVAL
c_func
(paren
id|K_PGUP
)paren
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|KVAL
c_func
(paren
id|K_P5
)paren
suffix:colon
id|applkey
c_func
(paren
l_char|&squot;G&squot;
comma
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_APPLIC
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|put_queue
c_func
(paren
id|pad_chars
(braket
id|value
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_eq
id|KVAL
c_func
(paren
id|K_PENTER
)paren
op_logical_and
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_CRLF
)paren
)paren
id|put_queue
c_func
(paren
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|do_cur
r_static
r_void
id|do_cur
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_static
r_char
op_star
id|cur_chars
op_assign
l_string|&quot;BDCA&quot;
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
id|applkey
c_func
(paren
id|cur_chars
(braket
id|value
)braket
comma
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_CKMODE
)paren
)paren
suffix:semicolon
)brace
DECL|function|do_shift
r_static
r_void
id|do_shift
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_int
id|old_state
op_assign
id|shift_state
suffix:semicolon
r_if
c_cond
(paren
id|rep
)paren
r_return
suffix:semicolon
multiline_comment|/* Mimic typewriter:&n;&t;   a CapsShift key acts like Shift but undoes CapsLock */
r_if
c_cond
(paren
id|value
op_eq
id|KVAL
c_func
(paren
id|K_CAPSSHIFT
)paren
)paren
(brace
id|value
op_assign
id|KVAL
c_func
(paren
id|K_SHIFT
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|up_flag
)paren
id|clr_vc_kbd_led
c_func
(paren
id|kbd
comma
id|VC_CAPSLOCK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|up_flag
)paren
(brace
multiline_comment|/* handle the case that two shift or control&n;&t;&t;   keys are depressed simultaneously */
r_if
c_cond
(paren
id|k_down
(braket
id|value
)braket
)paren
id|k_down
(braket
id|value
)braket
op_decrement
suffix:semicolon
)brace
r_else
id|k_down
(braket
id|value
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|k_down
(braket
id|value
)braket
)paren
id|shift_state
op_or_assign
(paren
l_int|1
op_lshift
id|value
)paren
suffix:semicolon
r_else
id|shift_state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|value
)paren
suffix:semicolon
multiline_comment|/* kludge */
r_if
c_cond
(paren
id|up_flag
op_logical_and
id|shift_state
op_ne
id|old_state
op_logical_and
id|npadch
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_UNICODE
)paren
id|to_utf8
c_func
(paren
id|npadch
op_amp
l_int|0xffff
)paren
suffix:semicolon
r_else
id|put_queue
c_func
(paren
id|npadch
op_amp
l_int|0xff
)paren
suffix:semicolon
id|npadch
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* called after returning from RAW mode or when changing consoles -&n;   recompute k_down[] and shift_state from key_down[] */
multiline_comment|/* maybe called when keymap is undefined, so that shiftkey release is seen */
DECL|function|compute_shiftstate
r_void
id|compute_shiftstate
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
comma
id|k
comma
id|sym
comma
id|val
suffix:semicolon
id|shift_state
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SIZE
c_func
(paren
id|k_down
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|k_down
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SIZE
c_func
(paren
id|key_down
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|key_down
(braket
id|i
)braket
)paren
(brace
multiline_comment|/* skip this word if not a single bit on */
id|k
op_assign
(paren
id|i
op_lshift
l_int|5
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|32
suffix:semicolon
id|j
op_increment
comma
id|k
op_increment
)paren
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|k
comma
id|key_down
)paren
)paren
(brace
id|sym
op_assign
id|U
c_func
(paren
id|plain_map
(braket
id|k
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|KTYP
c_func
(paren
id|sym
)paren
op_eq
id|KT_SHIFT
)paren
(brace
id|val
op_assign
id|KVAL
c_func
(paren
id|sym
)paren
suffix:semicolon
r_if
c_cond
(paren
id|val
op_eq
id|KVAL
c_func
(paren
id|K_CAPSSHIFT
)paren
)paren
id|val
op_assign
id|KVAL
c_func
(paren
id|K_SHIFT
)paren
suffix:semicolon
id|k_down
(braket
id|val
)braket
op_increment
suffix:semicolon
id|shift_state
op_or_assign
(paren
l_int|1
op_lshift
id|val
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|do_meta
r_static
r_void
id|do_meta
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_META
)paren
)paren
(brace
id|put_queue
c_func
(paren
l_char|&squot;&bslash;033&squot;
)paren
suffix:semicolon
id|put_queue
c_func
(paren
id|value
)paren
suffix:semicolon
)brace
r_else
id|put_queue
c_func
(paren
id|value
op_or
l_int|0x80
)paren
suffix:semicolon
)brace
DECL|function|do_ascii
r_static
r_void
id|do_ascii
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_int
id|base
suffix:semicolon
r_if
c_cond
(paren
id|up_flag
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|value
OL
l_int|10
)paren
multiline_comment|/* decimal input of code, while Alt depressed */
id|base
op_assign
l_int|10
suffix:semicolon
r_else
(brace
multiline_comment|/* hexadecimal input of code, while AltGr depressed */
id|value
op_sub_assign
l_int|10
suffix:semicolon
id|base
op_assign
l_int|16
suffix:semicolon
)brace
r_if
c_cond
(paren
id|npadch
op_eq
op_minus
l_int|1
)paren
id|npadch
op_assign
id|value
suffix:semicolon
r_else
id|npadch
op_assign
id|npadch
op_star
id|base
op_plus
id|value
suffix:semicolon
)brace
DECL|function|do_lock
r_static
r_void
id|do_lock
c_func
(paren
r_int
r_char
id|value
comma
r_char
id|up_flag
)paren
(brace
r_if
c_cond
(paren
id|up_flag
op_logical_or
id|rep
)paren
r_return
suffix:semicolon
id|chg_vc_kbd_lock
c_func
(paren
id|kbd
comma
id|value
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * send_data sends a character to the keyboard and waits&n; * for a acknowledge, possibly retrying if asked to. Returns&n; * the success status.&n; */
DECL|function|send_data
r_static
r_int
id|send_data
c_func
(paren
r_int
r_char
id|data
)paren
(brace
r_int
id|retries
op_assign
l_int|3
suffix:semicolon
r_int
id|i
suffix:semicolon
r_do
(brace
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
id|acknowledge
op_assign
l_int|0
suffix:semicolon
id|resend
op_assign
l_int|0
suffix:semicolon
id|reply_expected
op_assign
l_int|1
suffix:semicolon
id|outb_p
c_func
(paren
id|data
comma
l_int|0x60
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|0x20000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|inb_p
c_func
(paren
l_int|0x64
)paren
suffix:semicolon
multiline_comment|/* just as a delay */
r_if
c_cond
(paren
id|acknowledge
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|resend
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|resend
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|retries
op_decrement
OG
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The leds display either (i) the status of NumLock, CapsLock, ScrollLock,&n; * or (ii) whatever pattern of lights people want to show using KDSETLED,&n; * or (iii) specified bits of specified words in kernel memory.&n; */
DECL|variable|ledstate
r_static
r_int
r_char
id|ledstate
op_assign
l_int|0xff
suffix:semicolon
multiline_comment|/* undefined */
DECL|variable|ledioctl
r_static
r_int
r_char
id|ledioctl
suffix:semicolon
DECL|function|getledstate
r_int
r_char
id|getledstate
c_func
(paren
r_void
)paren
(brace
r_return
id|ledstate
suffix:semicolon
)brace
DECL|function|setledstate
r_void
id|setledstate
c_func
(paren
r_struct
id|kbd_struct
op_star
id|kbd
comma
r_int
r_int
id|led
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|led
op_amp
op_complement
l_int|7
)paren
)paren
(brace
id|ledioctl
op_assign
id|led
suffix:semicolon
id|kbd-&gt;ledmode
op_assign
id|LED_SHOW_IOCTL
suffix:semicolon
)brace
r_else
id|kbd-&gt;ledmode
op_assign
id|LED_SHOW_FLAGS
suffix:semicolon
id|set_leds
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|struct|ledptr
r_static
r_struct
id|ledptr
(brace
DECL|member|addr
r_int
r_int
op_star
id|addr
suffix:semicolon
DECL|member|mask
r_int
r_int
id|mask
suffix:semicolon
DECL|member|valid
r_int
r_char
id|valid
suffix:colon
l_int|1
suffix:semicolon
DECL|variable|ledptrs
)brace
id|ledptrs
(braket
l_int|3
)braket
suffix:semicolon
DECL|function|register_leds
r_void
id|register_leds
c_func
(paren
r_int
id|console
comma
r_int
r_int
id|led
comma
r_int
r_int
op_star
id|addr
comma
r_int
r_int
id|mask
)paren
(brace
r_struct
id|kbd_struct
op_star
id|kbd
op_assign
id|kbd_table
op_plus
id|console
suffix:semicolon
r_if
c_cond
(paren
id|led
OL
l_int|3
)paren
(brace
id|ledptrs
(braket
id|led
)braket
dot
id|addr
op_assign
id|addr
suffix:semicolon
id|ledptrs
(braket
id|led
)braket
dot
id|mask
op_assign
id|mask
suffix:semicolon
id|ledptrs
(braket
id|led
)braket
dot
id|valid
op_assign
l_int|1
suffix:semicolon
id|kbd-&gt;ledmode
op_assign
id|LED_SHOW_MEM
suffix:semicolon
)brace
r_else
id|kbd-&gt;ledmode
op_assign
id|LED_SHOW_FLAGS
suffix:semicolon
)brace
DECL|function|getleds
r_static
r_inline
r_int
r_char
(def_block
id|getleds
c_func
(paren
r_void
)paren
(brace
r_struct
id|kbd_struct
op_star
id|kbd
op_assign
id|kbd_table
op_plus
id|fg_console
suffix:semicolon
r_int
r_char
id|leds
suffix:semicolon
r_if
c_cond
(paren
id|kbd-&gt;ledmode
op_eq
id|LED_SHOW_IOCTL
)paren
r_return
id|ledioctl
suffix:semicolon
id|leds
op_assign
id|kbd-&gt;ledflagstate
suffix:semicolon
r_if
c_cond
(paren
id|kbd-&gt;ledmode
op_eq
id|LED_SHOW_MEM
)paren
(brace
r_if
c_cond
(paren
id|ledptrs
(braket
l_int|0
)braket
dot
id|valid
)paren
(brace
r_if
c_cond
(paren
op_star
id|ledptrs
(braket
l_int|0
)braket
dot
id|addr
op_amp
id|ledptrs
(braket
l_int|0
)braket
dot
id|mask
)paren
id|leds
op_or_assign
l_int|1
suffix:semicolon
r_else
id|leds
op_and_assign
op_complement
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ledptrs
(braket
l_int|1
)braket
dot
id|valid
)paren
(brace
r_if
c_cond
(paren
op_star
id|ledptrs
(braket
l_int|1
)braket
dot
id|addr
op_amp
id|ledptrs
(braket
l_int|1
)braket
dot
id|mask
)paren
id|leds
op_or_assign
l_int|2
suffix:semicolon
r_else
id|leds
op_and_assign
op_complement
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ledptrs
(braket
l_int|2
)braket
dot
id|valid
)paren
(brace
r_if
c_cond
(paren
op_star
id|ledptrs
(braket
l_int|2
)braket
dot
id|addr
op_amp
id|ledptrs
(braket
l_int|2
)braket
dot
id|mask
)paren
id|leds
op_or_assign
l_int|4
suffix:semicolon
r_else
id|leds
op_and_assign
op_complement
l_int|4
suffix:semicolon
)brace
)brace
r_return
id|leds
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * This routine is the bottom half of the keyboard interrupt&n; * routine, and runs with all interrupts enabled. It does&n; * console changing, led setting and copy_to_cooked, which can&n; * take a reasonably long time.&n; *&n; * Aside from timing (which isn&squot;t really that important for&n; * keyboard interrupts as they happen often), using the software&n; * interrupt routines for this thing allows us to easily mask&n; * this when we don&squot;t want any of the above to happen. Not yet&n; * used, but this allows for easy and efficient race-condition&n; * prevention later on.&n; */
DECL|function|kbd_bh
r_static
r_void
id|kbd_bh
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
r_int
r_char
id|leds
op_assign
id|getleds
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|leds
op_ne
id|ledstate
)paren
(brace
id|ledstate
op_assign
id|leds
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|send_data
c_func
(paren
l_int|0xed
)paren
op_logical_or
op_logical_neg
id|send_data
c_func
(paren
id|leds
)paren
)paren
id|send_data
c_func
(paren
l_int|0xf4
)paren
suffix:semicolon
multiline_comment|/* re-enable kbd if any errors */
)brace
r_if
c_cond
(paren
id|want_console
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|want_console
op_ne
id|fg_console
)paren
(brace
id|last_console
op_assign
id|fg_console
suffix:semicolon
id|change_console
c_func
(paren
id|want_console
)paren
suffix:semicolon
multiline_comment|/* we only changed when the console had already&n;&t;&t;&t;   been allocated - a new console is not created&n;&t;&t;&t;   in an interrupt routine */
)brace
id|want_console
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|poke_blanked_console
c_func
(paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
l_int|0x64
)paren
op_amp
id|kbd_read_mask
)paren
op_eq
l_int|0x01
)paren
id|fake_keyboard_interrupt
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|no_idt
r_int
id|no_idt
(braket
l_int|2
)braket
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * This routine reboots the machine by asking the keyboard&n; * controller to pulse the reset-line low. We try that for a while,&n; * and if it doesn&squot;t work, we do some other stupid things.&n; */
DECL|function|hard_reset_now
r_void
id|hard_reset_now
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_extern
r_int
r_int
id|pg0
(braket
l_int|1024
)braket
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* rebooting needs to touch the page at absolute addr 0 */
id|pg0
(braket
l_int|0
)braket
op_assign
l_int|7
suffix:semicolon
op_star
(paren
(paren
r_int
r_int
op_star
)paren
l_int|0x472
)paren
op_assign
l_int|0x1234
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|100
suffix:semicolon
id|i
op_increment
)paren
(brace
id|kb_wait
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|100000
suffix:semicolon
id|j
op_increment
)paren
(brace
multiline_comment|/* nothing */
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0xfe
comma
l_int|0x64
)paren
suffix:semicolon
multiline_comment|/* pulse reset low */
)brace
id|__asm__
c_func
(paren
l_string|&quot;&bslash;tlidt _no_idt&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|kbd_init
r_int
r_int
id|kbd_init
c_func
(paren
r_int
r_int
id|kmem_start
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|kbd_struct
id|kbd0
suffix:semicolon
r_extern
r_struct
id|tty_driver
id|console_driver
suffix:semicolon
id|kbd0.ledflagstate
op_assign
id|kbd0.default_ledflagstate
op_assign
id|KBD_DEFLEDS
suffix:semicolon
id|kbd0.ledmode
op_assign
id|LED_SHOW_FLAGS
suffix:semicolon
id|kbd0.lockstate
op_assign
id|KBD_DEFLOCK
suffix:semicolon
id|kbd0.modeflags
op_assign
id|KBD_DEFMODE
suffix:semicolon
id|kbd0.kbdmode
op_assign
id|VC_XLATE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_CONSOLES
suffix:semicolon
id|i
op_increment
)paren
id|kbd_table
(braket
id|i
)braket
op_assign
id|kbd0
suffix:semicolon
id|ttytab
op_assign
id|console_driver.table
suffix:semicolon
id|bh_base
(braket
id|KEYBOARD_BH
)braket
dot
id|routine
op_assign
id|kbd_bh
suffix:semicolon
id|request_irq
c_func
(paren
id|KEYBOARD_IRQ
comma
id|keyboard_interrupt
comma
l_int|0
comma
l_string|&quot;keyboard&quot;
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|KEYBOARD_BH
)paren
suffix:semicolon
r_return
id|kmem_start
suffix:semicolon
)brace
eof
