multiline_comment|/* toshiba.c -- Linux driver for accessing the SMM on Toshiba laptops&n; *&n; * Copyright (c) 1996-2000  Jonathan A. Buzzard (jonathan@buzzard.org.uk)&n; *&n; * Valuable assistance and patches from:&n; *     Tom May &lt;tom@you-bastards.com&gt;&n; *     Rob Napier &lt;rnapier@employees.org&gt;&n; *&n; * Fn status port numbers for machine ID&squot;s courtesy of&n; *     0xfc08: Garth Berry &lt;garth@itsbruce.net&gt;&n; *     0xfc11: Spencer Olson &lt;solson@novell.com&gt;&n; *     0xfc13: Claudius Frankewitz &lt;kryp@gmx.de&gt;&n; *     0xfc15: Tom May &lt;tom@you-bastards.com&gt;&n; *     0xfc17: Dave Konrad &lt;konrad@xenia.it&gt;&n; *     0xfc1a: George Betzos &lt;betzos@engr.colostate.edu&gt;&n; *     0xfc1d: Arthur Liu &lt;armie@slap.mine.nu&gt;&n; *&n; * WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING&n; *&n; *   This code is covered by the GNU GPL and you are free to make any&n; *   changes you wish to it under the terms of the license. However the&n; *   code has the potential to render your computer and/or someone else&squot;s&n; *   unusable. Please proceed with care when modifying the code.&n; *&n; * Note: Unfortunately the laptop hardware can close the System Configuration&n; *       Interface on it&squot;s own accord. It is therefore necessary for *all*&n; *       programs using this driver to be aware that *any* SCI call can fail at&n; *       *any* time. It is up to any program to be aware of this eventuality&n; *       and take appropriate steps.&n; *&n; * This program is free software; you can redistribute it and/or modify it&n; * under the terms of the GNU General Public License as published by the&n; * Free Software Foundation; either version 2, or (at your option) any&n; * later version.&n; *&n; * This program is distributed in the hope that it will be useful, but&n; * WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU&n; * General Public License for more details.&n; *&n; * The information used to write this driver has been obtained by reverse&n; * engineering the software supplied by Toshiba for their portable computers in&n; * strict accordance with the European Council Directive 92/250/EEC on the legal&n; * protection of computer programs, and it&squot;s implementation into English Law by&n; * the Copyright (Computer Programs) Regulations 1992 (S.I. 1992 No.3233).&n; *&n; */
DECL|macro|TOSH_VERSION
mdefine_line|#define TOSH_VERSION &quot;1.7 22/6/2000&quot;
DECL|macro|TOSH_DEBUG
mdefine_line|#define TOSH_DEBUG 0
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/stat.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/toshiba.h&gt;
DECL|macro|TOSH_MINOR_DEV
mdefine_line|#define TOSH_MINOR_DEV 181
DECL|variable|tosh_id
r_static
r_int
id|tosh_id
op_assign
l_int|0x0000
suffix:semicolon
DECL|variable|tosh_bios
r_static
r_int
id|tosh_bios
op_assign
l_int|0x0000
suffix:semicolon
DECL|variable|tosh_date
r_static
r_int
id|tosh_date
op_assign
l_int|0x0000
suffix:semicolon
DECL|variable|tosh_sci
r_static
r_int
id|tosh_sci
op_assign
l_int|0x0000
suffix:semicolon
DECL|variable|tosh_fan
r_static
r_int
id|tosh_fan
op_assign
l_int|0
suffix:semicolon
DECL|variable|tosh_fn
r_static
r_int
id|tosh_fn
op_assign
l_int|0
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|tosh_fn
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
r_static
r_int
id|tosh_get_info
c_func
(paren
r_char
op_star
comma
r_char
op_star
op_star
comma
id|off_t
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|tosh_ioctl
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
DECL|variable|tosh_fops
r_static
r_struct
id|file_operations
id|tosh_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|ioctl
suffix:colon
id|tosh_ioctl
comma
)brace
suffix:semicolon
DECL|variable|tosh_device
r_static
r_struct
id|miscdevice
id|tosh_device
op_assign
(brace
id|TOSH_MINOR_DEV
comma
l_string|&quot;toshiba&quot;
comma
op_amp
id|tosh_fops
)brace
suffix:semicolon
multiline_comment|/*&n; * Read the Fn key status&n; */
DECL|function|tosh_fn_status
r_static
r_int
id|tosh_fn_status
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|scan
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|tosh_fn
op_ne
l_int|0
)paren
(brace
id|scan
op_assign
id|inb
c_func
(paren
id|tosh_fn
)paren
suffix:semicolon
)brace
r_else
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x8e
comma
l_int|0xe4
)paren
suffix:semicolon
id|scan
op_assign
id|inb
c_func
(paren
l_int|0xe5
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_return
(paren
r_int
)paren
id|scan
suffix:semicolon
)brace
multiline_comment|/*&n; * At some point we need to emulate setting the HDD auto off times for&n; * the new laptops. We can do this by calling the ide_ioctl on /dev/hda.&n; * The values we need for the various times are&n; *&n; *    Disabled   0x00&n; *    1 minute   0x0c&n; *    3 minutes  0x24&n; *    5 minutes  0x3c&n; *   10 minutes  0x78&n; *   15 minutes  0xb4&n; *   20 minutes  0xf0&n; *   30 minutes  0xf1&n; *&n; */
multiline_comment|/*static int tosh_emulate_hdd(SMMRegisters *regs)&n;{&n;&t;return 0;&n;}*/
multiline_comment|/*&n; * For the Portage 610CT and the Tecra 700CS/700CDT emulate the HCI fan function&n; */
DECL|function|tosh_emulate_fan
r_static
r_int
id|tosh_emulate_fan
c_func
(paren
id|SMMRegisters
op_star
id|regs
)paren
(brace
r_int
r_int
id|eax
comma
id|ecx
comma
id|flags
suffix:semicolon
r_int
r_char
id|al
suffix:semicolon
id|eax
op_assign
id|regs-&gt;eax
op_amp
l_int|0xff00
suffix:semicolon
id|ecx
op_assign
id|regs-&gt;ecx
op_amp
l_int|0xffff
suffix:semicolon
multiline_comment|/* Portage 610CT */
r_if
c_cond
(paren
id|tosh_id
op_eq
l_int|0xfccb
)paren
(brace
r_if
c_cond
(paren
id|eax
op_eq
l_int|0xfe00
)paren
(brace
multiline_comment|/* fan status */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xbe
comma
l_int|0xe4
)paren
suffix:semicolon
id|al
op_assign
id|inb
c_func
(paren
l_int|0xe5
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|regs-&gt;eax
op_assign
l_int|0x00
suffix:semicolon
id|regs-&gt;ecx
op_assign
(paren
r_int
r_int
)paren
(paren
id|al
op_amp
l_int|0x01
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|eax
op_eq
l_int|0xff00
)paren
op_logical_and
(paren
id|ecx
op_eq
l_int|0x0000
)paren
)paren
(brace
multiline_comment|/* fan off */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xbe
comma
l_int|0xe4
)paren
suffix:semicolon
id|al
op_assign
id|inb
c_func
(paren
l_int|0xe5
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xbe
comma
l_int|0xe4
)paren
suffix:semicolon
id|outb
(paren
id|al
op_or
l_int|0x01
comma
l_int|0xe5
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|regs-&gt;eax
op_assign
l_int|0x00
suffix:semicolon
id|regs-&gt;ecx
op_assign
l_int|0x00
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|eax
op_eq
l_int|0xff00
)paren
op_logical_and
(paren
id|ecx
op_eq
l_int|0x0001
)paren
)paren
(brace
multiline_comment|/* fan on */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xbe
comma
l_int|0xe4
)paren
suffix:semicolon
id|al
op_assign
id|inb
c_func
(paren
l_int|0xe5
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xbe
comma
l_int|0xe4
)paren
suffix:semicolon
id|outb
c_func
(paren
id|al
op_amp
l_int|0xfe
comma
l_int|0xe5
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|regs-&gt;eax
op_assign
l_int|0x00
suffix:semicolon
id|regs-&gt;ecx
op_assign
l_int|0x01
suffix:semicolon
)brace
)brace
multiline_comment|/* Tecra 700CS/CDT */
r_if
c_cond
(paren
id|tosh_id
op_eq
l_int|0xfccc
)paren
(brace
r_if
c_cond
(paren
id|eax
op_eq
l_int|0xfe00
)paren
(brace
multiline_comment|/* fan status */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xe0
comma
l_int|0xe4
)paren
suffix:semicolon
id|al
op_assign
id|inb
c_func
(paren
l_int|0xe5
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|regs-&gt;eax
op_assign
l_int|0x00
suffix:semicolon
id|regs-&gt;ecx
op_assign
id|al
op_amp
l_int|0x01
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|eax
op_eq
l_int|0xff00
)paren
op_logical_and
(paren
id|ecx
op_eq
l_int|0x0000
)paren
)paren
(brace
multiline_comment|/* fan off */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xe0
comma
l_int|0xe4
)paren
suffix:semicolon
id|al
op_assign
id|inb
c_func
(paren
l_int|0xe5
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0xe0
op_or
(paren
(paren
id|al
op_amp
l_int|0xfe
)paren
op_lshift
l_int|8
)paren
comma
l_int|0xe4
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|regs-&gt;eax
op_assign
l_int|0x00
suffix:semicolon
id|regs-&gt;ecx
op_assign
l_int|0x00
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|eax
op_eq
l_int|0xff00
)paren
op_logical_and
(paren
id|ecx
op_eq
l_int|0x0001
)paren
)paren
(brace
multiline_comment|/* fan on */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xe0
comma
l_int|0xe4
)paren
suffix:semicolon
id|al
op_assign
id|inb
c_func
(paren
l_int|0xe5
)paren
suffix:semicolon
id|outw
c_func
(paren
l_int|0xe0
op_or
(paren
(paren
id|al
op_or
l_int|0x01
)paren
op_lshift
l_int|8
)paren
comma
l_int|0xe4
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|regs-&gt;eax
op_assign
l_int|0x00
suffix:semicolon
id|regs-&gt;ecx
op_assign
l_int|0x01
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Put the laptop into System Management Mode&n; */
DECL|function|tosh_smm
r_static
r_int
id|tosh_smm
c_func
(paren
id|SMMRegisters
op_star
id|regs
)paren
(brace
r_int
id|eax
suffix:semicolon
id|asm
(paren
l_string|&quot;# load the values into the registers&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;pushl %%eax&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;movl 0(%%eax),%%edx&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;push %%edx&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;movl 4(%%eax),%%ebx&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;movl 8(%%eax),%%ecx&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;movl 12(%%eax),%%edx&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;movl 16(%%eax),%%esi&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;movl 20(%%eax),%%edi&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;popl %%eax&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;# call the System Management mode&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;inb $0xb2,%%al&bslash;n&bslash;t&quot;
l_string|&quot;# fill out the memory with the values in the registers&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;xchgl %%eax,(%%esp)&bslash;n&bslash;t&quot;
l_string|&quot;movl %%ebx,4(%%eax)&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;movl %%ecx,8(%%eax)&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;movl %%edx,12(%%eax)&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;movl %%esi,16(%%eax)&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;movl %%edi,20(%%eax)&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;popl %%edx&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;movl %%edx,0(%%eax)&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;# setup the return value to the carry flag&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;lahf&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;shrl $8,%%eax&bslash;n&bslash;t&quot;
"&bslash;"
l_string|&quot;andl $1,%%eax&bslash;n&quot;
"&bslash;"
suffix:colon
l_string|&quot;=a&quot;
(paren
id|eax
)paren
suffix:colon
l_string|&quot;a&quot;
(paren
id|regs
)paren
suffix:colon
l_string|&quot;%ebx&quot;
comma
l_string|&quot;%ecx&quot;
comma
l_string|&quot;%edx&quot;
comma
l_string|&quot;%esi&quot;
comma
l_string|&quot;%edi&quot;
comma
l_string|&quot;memory&quot;
)paren
suffix:semicolon
r_return
id|eax
suffix:semicolon
)brace
DECL|function|tosh_ioctl
r_static
r_int
id|tosh_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|SMMRegisters
id|regs
suffix:semicolon
r_int
r_int
id|ax
comma
id|bx
suffix:semicolon
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|regs
comma
(paren
id|SMMRegisters
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|SMMRegisters
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TOSH_SMM
suffix:colon
id|ax
op_assign
id|regs.eax
op_amp
l_int|0xff00
suffix:semicolon
id|bx
op_assign
id|regs.ebx
op_amp
l_int|0xffff
suffix:semicolon
multiline_comment|/* block HCI calls to read/write memory &amp; PCI devices */
r_if
c_cond
(paren
(paren
(paren
id|ax
op_eq
l_int|0xff00
)paren
op_logical_or
(paren
id|ax
op_eq
l_int|0xfe00
)paren
)paren
op_logical_and
(paren
id|bx
OG
l_int|0x0069
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* do we need to emulate the fan ? */
r_if
c_cond
(paren
id|tosh_fan
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|ax
op_eq
l_int|0xf300
)paren
op_logical_or
(paren
id|ax
op_eq
l_int|0xf400
)paren
)paren
op_logical_and
(paren
id|bx
op_eq
l_int|0x0004
)paren
)paren
(brace
id|err
op_assign
id|tosh_emulate_fan
c_func
(paren
op_amp
id|regs
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|err
op_assign
id|tosh_smm
c_func
(paren
op_amp
id|regs
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
id|SMMRegisters
op_star
)paren
id|arg
comma
op_amp
id|regs
comma
r_sizeof
(paren
id|SMMRegisters
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
(paren
id|err
op_eq
l_int|0
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/*&n; * Print the information for /proc/toshiba&n; */
DECL|function|tosh_get_info
r_int
id|tosh_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|fpos
comma
r_int
id|length
)paren
(brace
r_char
op_star
id|temp
suffix:semicolon
r_int
id|key
suffix:semicolon
id|temp
op_assign
id|buffer
suffix:semicolon
id|key
op_assign
id|tosh_fn_status
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Arguments&n;&t;     0) Linux driver version (this will change if format changes)&n;&t;     1) Machine ID&n;&t;     2) SCI version&n;&t;     3) BIOS version (major, minor)&n;&t;     4) BIOS date (in SCI date format)&n;&t;     5) Fn Key status&n;&t;*/
id|temp
op_add_assign
id|sprintf
c_func
(paren
id|temp
comma
l_string|&quot;1.1 0x%04x %d.%d %d.%d 0x%04x 0x%02x&bslash;n&quot;
comma
id|tosh_id
comma
(paren
id|tosh_sci
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
comma
id|tosh_sci
op_amp
l_int|0xff
comma
(paren
id|tosh_bios
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
comma
id|tosh_bios
op_amp
l_int|0xff
comma
id|tosh_date
comma
id|key
)paren
suffix:semicolon
r_return
id|temp
op_minus
id|buffer
suffix:semicolon
)brace
multiline_comment|/*&n; * Determine which port to use for the Fn key status&n; */
DECL|function|tosh_set_fn_port
r_static
r_void
id|tosh_set_fn_port
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|tosh_id
)paren
(brace
r_case
l_int|0xfc11
suffix:colon
r_case
l_int|0xfc13
suffix:colon
r_case
l_int|0xfc15
suffix:colon
r_case
l_int|0xfc1a
suffix:colon
id|tosh_fn
op_assign
l_int|0x62
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xfc08
suffix:colon
r_case
l_int|0xfc17
suffix:colon
r_case
l_int|0xfc1d
suffix:colon
r_case
l_int|0xfcd1
suffix:colon
r_case
l_int|0xfce0
suffix:colon
r_case
l_int|0xfce2
suffix:colon
id|tosh_fn
op_assign
l_int|0x68
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|tosh_fn
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the machine identification number of the current model&n; */
DECL|function|tosh_get_machine_id
r_static
r_int
id|tosh_get_machine_id
c_func
(paren
r_void
)paren
(brace
r_int
id|id
suffix:semicolon
id|SMMRegisters
id|regs
suffix:semicolon
r_int
r_int
id|bx
comma
id|cx
suffix:semicolon
r_int
r_int
id|address
suffix:semicolon
id|id
op_assign
(paren
l_int|0x100
op_star
(paren
r_int
)paren
id|isa_readb
c_func
(paren
l_int|0xffffe
)paren
)paren
op_plus
(paren
(paren
r_int
)paren
id|isa_readb
c_func
(paren
l_int|0xffffa
)paren
)paren
suffix:semicolon
multiline_comment|/* do we have a SCTTable machine identication number on our hands */
r_if
c_cond
(paren
id|id
op_eq
l_int|0xfc2f
)paren
(brace
multiline_comment|/* start by getting a pointer into the BIOS */
id|regs.eax
op_assign
l_int|0xc000
suffix:semicolon
id|regs.ebx
op_assign
l_int|0x0000
suffix:semicolon
id|regs.ecx
op_assign
l_int|0x0000
suffix:semicolon
id|tosh_smm
c_func
(paren
op_amp
id|regs
)paren
suffix:semicolon
id|bx
op_assign
(paren
r_int
r_int
)paren
(paren
id|regs.ebx
op_amp
l_int|0xffff
)paren
suffix:semicolon
multiline_comment|/* At this point in the Toshiba routines under MS Windows&n;&t;&t;   the bx register holds 0xe6f5. However my code is producing&n;&t;&t;   a different value! For the time being I will just fudge the&n;&t;&t;   value. This has been verified on a Satellite Pro 430CDT,&n;&t;&t;   Tecra 750CDT, Tecra 780DVD and Satellite 310CDT. */
macro_line|#if TOSH_DEBUG
id|printk
c_func
(paren
l_string|&quot;toshiba: debugging ID ebx=0x%04x&bslash;n&quot;
comma
id|regs.ebx
)paren
suffix:semicolon
macro_line|#endif
id|bx
op_assign
l_int|0xe6f5
suffix:semicolon
multiline_comment|/* now twiddle with our pointer a bit */
id|address
op_assign
l_int|0x000f0000
op_plus
id|bx
suffix:semicolon
id|cx
op_assign
id|isa_readw
c_func
(paren
id|address
)paren
suffix:semicolon
id|address
op_assign
l_int|0x000f0009
op_plus
id|bx
op_plus
id|cx
suffix:semicolon
id|cx
op_assign
id|isa_readw
c_func
(paren
id|address
)paren
suffix:semicolon
id|address
op_assign
l_int|0x000f000a
op_plus
id|cx
suffix:semicolon
id|cx
op_assign
id|isa_readw
c_func
(paren
id|address
)paren
suffix:semicolon
multiline_comment|/* now construct our machine identification number */
id|id
op_assign
(paren
(paren
id|cx
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_plus
(paren
(paren
id|cx
op_amp
l_int|0xff00
)paren
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
r_return
id|id
suffix:semicolon
)brace
multiline_comment|/*&n; * Probe for the presence of a Toshiba laptop&n; *&n; *   returns and non-zero if unable to detect the presence of a Toshiba&n; *   laptop, otherwise zero and determines the Machine ID, BIOS version and&n; *   date, and SCI version.&n; */
DECL|function|tosh_probe
r_int
id|tosh_probe
c_func
(paren
r_void
)paren
(brace
r_int
id|major
comma
id|minor
comma
id|day
comma
id|year
comma
id|month
comma
id|flag
suffix:semicolon
id|SMMRegisters
id|regs
suffix:semicolon
multiline_comment|/* call the Toshiba SCI support check routine */
id|regs.eax
op_assign
l_int|0xf0f0
suffix:semicolon
id|regs.ebx
op_assign
l_int|0x0000
suffix:semicolon
id|regs.ecx
op_assign
l_int|0x0000
suffix:semicolon
id|flag
op_assign
id|tosh_smm
c_func
(paren
op_amp
id|regs
)paren
suffix:semicolon
multiline_comment|/* if this is not a Toshiba laptop carry flag is set and ah=0x86 */
r_if
c_cond
(paren
(paren
id|flag
op_eq
l_int|1
)paren
op_logical_or
(paren
(paren
id|regs.eax
op_amp
l_int|0xff00
)paren
op_eq
l_int|0x8600
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;toshiba: not a supported Toshiba laptop&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/* if we get this far then we are running on a Toshiba (probably)! */
id|tosh_sci
op_assign
id|regs.edx
op_amp
l_int|0xffff
suffix:semicolon
multiline_comment|/* next get the machine ID of the current laptop */
id|tosh_id
op_assign
id|tosh_get_machine_id
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* get the BIOS version */
id|major
op_assign
id|isa_readb
c_func
(paren
l_int|0xfe009
)paren
op_minus
l_char|&squot;0&squot;
suffix:semicolon
id|minor
op_assign
(paren
(paren
id|isa_readb
c_func
(paren
l_int|0xfe00b
)paren
op_minus
l_char|&squot;0&squot;
)paren
op_star
l_int|10
)paren
op_plus
(paren
id|isa_readb
c_func
(paren
l_int|0xfe00c
)paren
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
id|tosh_bios
op_assign
(paren
id|major
op_star
l_int|0x100
)paren
op_plus
id|minor
suffix:semicolon
multiline_comment|/* get the BIOS date */
id|day
op_assign
(paren
(paren
id|isa_readb
c_func
(paren
l_int|0xffff5
)paren
op_minus
l_char|&squot;0&squot;
)paren
op_star
l_int|10
)paren
op_plus
(paren
id|isa_readb
c_func
(paren
l_int|0xffff6
)paren
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
id|month
op_assign
(paren
(paren
id|isa_readb
c_func
(paren
l_int|0xffff8
)paren
op_minus
l_char|&squot;0&squot;
)paren
op_star
l_int|10
)paren
op_plus
(paren
id|isa_readb
c_func
(paren
l_int|0xffff9
)paren
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
id|year
op_assign
(paren
(paren
id|isa_readb
c_func
(paren
l_int|0xffffb
)paren
op_minus
l_char|&squot;0&squot;
)paren
op_star
l_int|10
)paren
op_plus
(paren
id|isa_readb
c_func
(paren
l_int|0xffffc
)paren
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
id|tosh_date
op_assign
(paren
(paren
(paren
id|year
op_minus
l_int|90
)paren
op_amp
l_int|0x1f
)paren
op_lshift
l_int|10
)paren
op_or
(paren
(paren
id|month
op_amp
l_int|0xf
)paren
op_lshift
l_int|6
)paren
op_or
(paren
(paren
id|day
op_amp
l_int|0x1f
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* in theory we should check the ports we are going to use for the&n;&t;   fn key detection (and the fan on the Portage 610/Tecra700), and&n;&t;   then request them to stop other drivers using them. However as&n;&t;   the keyboard driver grabs 0x60-0x6f and the pic driver grabs&n;&t;   0xa0-0xbf we can&squot;t. We just have to live dangerously and use the&n;&t;   ports anyway, oh boy! */
multiline_comment|/* do we need to emulate the fan? */
r_if
c_cond
(paren
(paren
id|tosh_id
op_eq
l_int|0xfccb
)paren
op_logical_or
(paren
id|tosh_id
op_eq
l_int|0xfccc
)paren
)paren
id|tosh_fan
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tosh_init
r_int
id|__init
id|tosh_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* are we running on a Toshiba laptop */
r_if
c_cond
(paren
id|tosh_probe
c_func
(paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Toshiba System Managment Mode driver v&quot;
id|TOSH_VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* set the port to use for Fn status if not specified as a parameter */
r_if
c_cond
(paren
id|tosh_fn
op_eq
l_int|0x00
)paren
id|tosh_set_fn_port
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* register the device file */
id|misc_register
c_func
(paren
op_amp
id|tosh_device
)paren
suffix:semicolon
multiline_comment|/* register the proc entry */
id|create_proc_info_entry
c_func
(paren
l_string|&quot;toshiba&quot;
comma
l_int|0
comma
l_int|NULL
comma
id|tosh_get_info
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_return
id|tosh_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* remove the proc entry */
id|remove_proc_entry
c_func
(paren
l_string|&quot;toshiba&quot;
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* unregister the device file */
id|misc_deregister
c_func
(paren
op_amp
id|tosh_device
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
