multiline_comment|/*&n; *  kernel/chr_drv/vt.c&n; *&n; *  Copyright (C) 1992 obz under the linux copyright&n; *  Dynamic diacritical handling - aeb@cwi.nl - Dec 1993&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kd.h&gt;
macro_line|#include &lt;linux/vt.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &quot;kbd_kern.h&quot;
macro_line|#include &quot;vt_kern.h&quot;
macro_line|#include &quot;diacr.h&quot;
r_extern
r_struct
id|tty_driver
id|console_driver
suffix:semicolon
multiline_comment|/*&n; * Console (vt and kd) routines, as defined by USL SVR4 manual, and by&n; * experimentation and study of X386 SYSV handling.&n; *&n; * One point of difference: SYSV vt&squot;s are /dev/vtX, which X &gt;= 0, and&n; * /dev/console is a separate ttyp. Under Linux, /dev/tty0 is /dev/console,&n; * and the vc start at /dev/ttyX, X &gt;= 1. We maintain that here, so we will&n; * always treat our set of vt as numbered 1..NR_CONSOLES (corresponding to&n; * ttys 0..NR_CONSOLES-1). Explicitly naming VT 0 is illegal, but using&n; * /dev/tty0 (fg_console) as a target is legal, since an implicit aliasing&n; * to the current console is done by the main ioctl code.&n; */
DECL|variable|vt_cons
r_struct
id|vt_struct
id|vt_cons
(braket
id|NR_CONSOLES
)braket
suffix:semicolon
id|asmlinkage
r_int
id|sys_ioperm
c_func
(paren
r_int
r_int
id|from
comma
r_int
r_int
id|num
comma
r_int
id|on
)paren
suffix:semicolon
r_extern
r_void
id|compute_shiftstate
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|change_console
c_func
(paren
r_int
r_int
id|new_console
)paren
suffix:semicolon
r_extern
r_void
id|complete_change_console
c_func
(paren
r_int
r_int
id|new_console
)paren
suffix:semicolon
r_extern
r_int
id|vt_waitactive
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * routines to load custom translation table and EGA/VGA font from console.c&n; */
r_extern
r_int
id|con_set_trans
c_func
(paren
r_char
op_star
id|table
)paren
suffix:semicolon
r_extern
r_int
id|con_get_trans
c_func
(paren
r_char
op_star
id|table
)paren
suffix:semicolon
r_extern
r_int
id|con_set_font
c_func
(paren
r_char
op_star
id|fontmap
)paren
suffix:semicolon
r_extern
r_int
id|con_get_font
c_func
(paren
r_char
op_star
id|fontmap
)paren
suffix:semicolon
multiline_comment|/*&n; * these are the valid i/o ports we&squot;re allowed to change. they map all the&n; * video ports&n; */
DECL|macro|GPFIRST
mdefine_line|#define GPFIRST 0x3b4
DECL|macro|GPLAST
mdefine_line|#define GPLAST 0x3df
DECL|macro|GPNUM
mdefine_line|#define GPNUM (GPLAST - GPFIRST + 1)
multiline_comment|/*&n; * Generates sound of some count for some number of clock ticks&n; * [count = 1193180 / frequency]&n; *&n; * If freq is 0, will turn off sound, else will turn it on for that time.&n; * If msec is 0, will return immediately, else will sleep for msec time, then&n; * turn sound off.&n; *&n; * We use the BEEP_TIMER vector since we&squot;re using the same method to&n; * generate sound, and we&squot;ll overwrite any beep in progress. That may&n; * be something to fix later, if we like.&n; *&n; * We also return immediately, which is what was implied within the X&n; * comments - KDMKTONE doesn&squot;t put the process to sleep.&n; */
r_static
r_void
DECL|function|kd_nosound
id|kd_nosound
c_func
(paren
r_int
r_int
id|ignored
)paren
(brace
multiline_comment|/* disable counter 2 */
id|outb
c_func
(paren
id|inb_p
c_func
(paren
l_int|0x61
)paren
op_amp
l_int|0xFC
comma
l_int|0x61
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_void
DECL|function|kd_mksound
id|kd_mksound
c_func
(paren
r_int
r_int
id|count
comma
r_int
r_int
id|ticks
)paren
(brace
r_static
r_struct
id|timer_list
id|sound_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|kd_nosound
)brace
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sound_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
multiline_comment|/* enable counter 2 */
id|outb_p
c_func
(paren
id|inb_p
c_func
(paren
l_int|0x61
)paren
op_or
l_int|3
comma
l_int|0x61
)paren
suffix:semicolon
multiline_comment|/* set command for counter 2, 2 byte write */
id|outb_p
c_func
(paren
l_int|0xB6
comma
l_int|0x43
)paren
suffix:semicolon
multiline_comment|/* select desired HZ */
id|outb_p
c_func
(paren
id|count
op_amp
l_int|0xff
comma
l_int|0x42
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|count
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
l_int|0x42
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ticks
)paren
(brace
id|sound_timer.expires
op_assign
id|ticks
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sound_timer
)paren
suffix:semicolon
)brace
)brace
r_else
id|kd_nosound
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * We handle the console-specific ioctl&squot;s here.  We allow the&n; * capability to modify any console, not just the fg_console. &n; */
DECL|function|vt_ioctl
r_int
id|vt_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|console
comma
id|i
suffix:semicolon
r_int
r_char
id|ucval
suffix:semicolon
r_struct
id|kbd_struct
op_star
id|kbd
suffix:semicolon
r_struct
id|vt_struct
op_star
id|vt
op_assign
id|tty-&gt;driver_data
suffix:semicolon
id|console
op_assign
id|vt-&gt;vc_num
suffix:semicolon
r_if
c_cond
(paren
id|console
OL
l_int|0
op_logical_or
id|console
op_ge
id|NR_CONSOLES
)paren
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
id|kbd
op_assign
id|kbd_table
op_plus
id|console
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|KIOCSOUND
suffix:colon
id|kd_mksound
c_func
(paren
(paren
r_int
r_int
)paren
id|arg
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|KDMKTONE
suffix:colon
(brace
r_int
r_int
id|ticks
op_assign
id|HZ
op_star
(paren
(paren
id|arg
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
op_div
l_int|1000
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Generate the tone for the appropriate number of ticks.&n;&t;&t; * If the time is zero, turn off sound ourselves.&n;&t;&t; */
id|kd_mksound
c_func
(paren
id|arg
op_amp
l_int|0xffff
comma
id|ticks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ticks
op_eq
l_int|0
)paren
id|kd_nosound
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDGKBTYPE
suffix:colon
multiline_comment|/*&n;&t;&t; * this is naive.&n;&t;&t; */
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_char
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|put_fs_byte
c_func
(paren
id|KB_101
comma
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
r_case
id|KDADDIO
suffix:colon
r_case
id|KDDELIO
suffix:colon
multiline_comment|/*&n;&t;&t; * KDADDIO and KDDELIO may be able to add ports beyond what&n;&t;&t; * we reject here, but to be safe...&n;&t;&t; */
r_if
c_cond
(paren
id|arg
template_param
id|GPLAST
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|sys_ioperm
c_func
(paren
id|arg
comma
l_int|1
comma
(paren
id|cmd
op_eq
id|KDADDIO
)paren
)paren
ques
c_cond
op_minus
id|ENXIO
suffix:colon
l_int|0
suffix:semicolon
r_case
id|KDENABIO
suffix:colon
r_case
id|KDDISABIO
suffix:colon
r_return
id|sys_ioperm
c_func
(paren
id|GPFIRST
comma
id|GPNUM
comma
(paren
id|cmd
op_eq
id|KDENABIO
)paren
)paren
ques
c_cond
op_minus
id|ENXIO
suffix:colon
l_int|0
suffix:semicolon
r_case
id|KDSETMODE
suffix:colon
multiline_comment|/*&n;&t;&t; * currently, setting the mode from KD_TEXT to KD_GRAPHICS&n;&t;&t; * doesn&squot;t do a whole lot. i&squot;m not sure if it should do any&n;&t;&t; * restoration of modes or what...&n;&t;&t; */
r_switch
c_cond
(paren
id|arg
)paren
(brace
r_case
id|KD_GRAPHICS
suffix:colon
r_break
suffix:semicolon
r_case
id|KD_TEXT0
suffix:colon
r_case
id|KD_TEXT1
suffix:colon
id|arg
op_assign
id|KD_TEXT
suffix:semicolon
r_case
id|KD_TEXT
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vt_cons
(braket
id|console
)braket
dot
id|vc_mode
op_eq
(paren
r_int
r_char
)paren
id|arg
)paren
r_return
l_int|0
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
dot
id|vc_mode
op_assign
(paren
r_int
r_char
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|console
op_ne
id|fg_console
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * explicitly blank/unblank the screen if switching modes&n;&t;&t; */
r_if
c_cond
(paren
id|arg
op_eq
id|KD_TEXT
)paren
id|unblank_screen
c_func
(paren
)paren
suffix:semicolon
r_else
(brace
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|BLANK_TIMER
)paren
suffix:semicolon
id|blank_screen
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|KDGETMODE
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|put_fs_long
c_func
(paren
id|vt_cons
(braket
id|console
)braket
dot
id|vc_mode
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
r_case
id|KDMAPDISP
suffix:colon
r_case
id|KDUNMAPDISP
suffix:colon
multiline_comment|/*&n;&t;&t; * these work like a combination of mmap and KDENABIO.&n;&t;&t; * this could be easily finished.&n;&t;&t; */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|KDSKBMODE
suffix:colon
r_switch
c_cond
(paren
id|arg
)paren
(brace
r_case
id|K_RAW
suffix:colon
id|set_vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_RAW
)paren
suffix:semicolon
id|clr_vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_MEDIUMRAW
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|K_MEDIUMRAW
suffix:colon
id|clr_vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_RAW
)paren
suffix:semicolon
id|set_vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_MEDIUMRAW
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|K_XLATE
suffix:colon
id|clr_vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_RAW
)paren
suffix:semicolon
id|clr_vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_MEDIUMRAW
)paren
suffix:semicolon
id|compute_shiftstate
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|KDGKBMODE
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|ucval
op_assign
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_RAW
)paren
ques
c_cond
id|K_RAW
suffix:colon
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_MEDIUMRAW
)paren
ques
c_cond
id|K_MEDIUMRAW
suffix:colon
id|K_XLATE
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|ucval
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
multiline_comment|/* this could be folded into KDSKBMODE, but for compatibility&n;&t;   reasons it is not so easy to fold KDGKBMETA into KDGKBMODE */
r_case
id|KDSKBMETA
suffix:colon
r_switch
c_cond
(paren
id|arg
)paren
(brace
r_case
id|K_METABIT
suffix:colon
id|clr_vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_META
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|K_ESCPREFIX
suffix:colon
id|set_vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_META
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|KDGKBMETA
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|ucval
op_assign
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_META
)paren
ques
c_cond
id|K_ESCPREFIX
suffix:colon
id|K_METABIT
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|ucval
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
r_case
id|KDGKBENT
suffix:colon
(brace
r_struct
id|kbentry
op_star
r_const
id|a
op_assign
(paren
r_struct
id|kbentry
op_star
)paren
id|arg
suffix:semicolon
id|u_char
id|s
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|a
comma
r_sizeof
(paren
r_struct
id|kbentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|get_fs_byte
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|a-&gt;kb_index
)paren
)paren
op_ge
id|NR_KEYS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s
op_assign
id|get_fs_byte
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|a-&gt;kb_table
)paren
)paren
op_ge
id|NR_KEYMAPS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|put_fs_word
c_func
(paren
id|key_map
(braket
id|s
)braket
(braket
id|i
)braket
comma
(paren
r_int
op_star
)paren
op_amp
id|a-&gt;kb_value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDSKBENT
suffix:colon
(brace
r_const
r_struct
id|kbentry
op_star
id|a
op_assign
(paren
r_struct
id|kbentry
op_star
)paren
id|arg
suffix:semicolon
id|u_char
id|s
suffix:semicolon
id|u_short
id|v
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|a
comma
r_sizeof
(paren
r_struct
id|kbentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|get_fs_byte
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|a-&gt;kb_index
)paren
)paren
op_ge
id|NR_KEYS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s
op_assign
id|get_fs_byte
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|a-&gt;kb_table
)paren
)paren
op_ge
id|NR_KEYMAPS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|KTYP
c_func
(paren
id|v
op_assign
id|get_fs_word
c_func
(paren
op_amp
id|a-&gt;kb_value
)paren
)paren
op_ge
id|NR_TYPES
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|KVAL
c_func
(paren
id|v
)paren
OG
id|max_vals
(braket
id|KTYP
c_func
(paren
id|v
)paren
)braket
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Only the Superuser can set or unset the Secure&n;&t;&t; * Attention Key.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|key_map
(braket
id|s
)braket
(braket
id|i
)braket
op_eq
id|K_SAK
)paren
op_logical_or
(paren
id|v
op_eq
id|K_SAK
)paren
)paren
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|key_map
(braket
id|s
)braket
(braket
id|i
)braket
op_assign
id|v
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDGKBSENT
suffix:colon
(brace
r_struct
id|kbsentry
op_star
id|a
op_assign
(paren
r_struct
id|kbsentry
op_star
)paren
id|arg
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
id|u_char
op_star
id|q
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|a
comma
r_sizeof
(paren
r_struct
id|kbsentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|get_fs_byte
c_func
(paren
op_amp
id|a-&gt;kb_func
)paren
)paren
op_ge
id|NR_FUNC
op_logical_or
id|i
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|q
op_assign
id|a-&gt;kb_string
suffix:semicolon
id|p
op_assign
id|func_table
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
multiline_comment|/* beware of tables generated for a smaller NR_FUNC */
id|printk
c_func
(paren
l_string|&quot;KDGKBSENT error: func_table[%d] is nil.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
op_star
id|p
suffix:semicolon
id|p
op_increment
)paren
id|put_fs_byte
c_func
(paren
op_star
id|p
comma
id|q
op_increment
)paren
suffix:semicolon
id|put_fs_byte
c_func
(paren
l_int|0
comma
id|q
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDSKBSENT
suffix:colon
(brace
r_struct
id|kbsentry
op_star
r_const
id|a
op_assign
(paren
r_struct
id|kbsentry
op_star
)paren
id|arg
suffix:semicolon
r_int
id|delta
suffix:semicolon
r_char
op_star
id|first_free
suffix:semicolon
r_int
id|k
suffix:semicolon
id|u_char
op_star
id|p
suffix:semicolon
r_char
op_star
id|q
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|a
comma
r_sizeof
(paren
r_struct
id|kbsentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|get_fs_byte
c_func
(paren
op_amp
id|a-&gt;kb_func
)paren
)paren
op_ge
id|NR_FUNC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|q
op_assign
id|func_table
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
(brace
multiline_comment|/* beware of tables generated for a smaller NR_FUNC */
id|printk
c_func
(paren
l_string|&quot;KDSKBSENT error: func_table[%d] is nil.&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|delta
op_assign
op_minus
id|strlen
c_func
(paren
id|q
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|a-&gt;kb_string
suffix:semicolon
id|get_fs_byte
c_func
(paren
id|p
)paren
suffix:semicolon
id|p
op_increment
)paren
id|delta
op_increment
suffix:semicolon
id|first_free
op_assign
id|func_table
(braket
id|NR_FUNC
op_minus
l_int|1
)braket
op_plus
id|strlen
c_func
(paren
id|func_table
(braket
id|NR_FUNC
op_minus
l_int|1
)braket
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|delta
OG
l_int|0
op_logical_and
id|first_free
op_plus
id|delta
OG
id|func_buf
op_plus
id|FUNC_BUFSIZE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|NR_FUNC
op_minus
l_int|1
)paren
(brace
id|memmove
c_func
(paren
id|func_table
(braket
id|i
op_plus
l_int|1
)braket
op_plus
id|delta
comma
id|func_table
(braket
id|i
op_plus
l_int|1
)braket
comma
id|first_free
op_minus
id|func_table
(braket
id|i
op_plus
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|k
OL
id|NR_FUNC
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|func_table
(braket
id|k
)braket
)paren
multiline_comment|/* just to be sure */
id|func_table
(braket
id|k
)braket
op_add_assign
id|delta
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
id|a-&gt;kb_string
comma
id|q
op_assign
id|func_table
(braket
id|i
)braket
suffix:semicolon
suffix:semicolon
id|p
op_increment
comma
id|q
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|q
op_assign
id|get_fs_byte
c_func
(paren
id|p
)paren
)paren
)paren
r_break
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDGKBDIACR
suffix:colon
(brace
r_struct
id|kbdiacrs
op_star
id|a
op_assign
(paren
r_struct
id|kbdiacrs
op_star
)paren
id|arg
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|a
comma
r_sizeof
(paren
r_struct
id|kbdiacrs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|put_fs_long
c_func
(paren
id|accent_table_size
comma
op_amp
id|a-&gt;kb_cnt
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|a-&gt;kbdiacr
comma
id|accent_table
comma
id|accent_table_size
op_star
r_sizeof
(paren
r_struct
id|kbdiacr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDSKBDIACR
suffix:colon
(brace
r_struct
id|kbdiacrs
op_star
id|a
op_assign
(paren
r_struct
id|kbdiacrs
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|ct
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|a
comma
r_sizeof
(paren
r_struct
id|kbdiacrs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|ct
op_assign
id|get_fs_long
c_func
(paren
op_amp
id|a-&gt;kb_cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ct
op_ge
id|MAX_DIACR
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|accent_table_size
op_assign
id|ct
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|accent_table
comma
id|a-&gt;kbdiacr
comma
id|ct
op_star
r_sizeof
(paren
r_struct
id|kbdiacr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDGETLED
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_char
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|put_fs_byte
c_func
(paren
id|kbd-&gt;ledstate
comma
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|KDSETLED
suffix:colon
r_if
c_cond
(paren
id|arg
op_amp
op_complement
l_int|7
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|kbd-&gt;ledstate
op_assign
id|arg
suffix:semicolon
id|set_leds
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|VT_SETMODE
suffix:colon
(brace
r_struct
id|vt_mode
op_star
id|vtmode
op_assign
(paren
r_struct
id|vt_mode
op_star
)paren
id|arg
suffix:semicolon
r_char
id|mode
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|vtmode
comma
r_sizeof
(paren
r_struct
id|vt_mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|mode
op_assign
id|get_fs_byte
c_func
(paren
op_amp
id|vtmode-&gt;mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_ne
id|VT_AUTO
op_logical_and
id|mode
op_ne
id|VT_PROCESS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
dot
id|vt_mode.mode
op_assign
id|mode
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
dot
id|vt_mode.waitv
op_assign
id|get_fs_byte
c_func
(paren
op_amp
id|vtmode-&gt;waitv
)paren
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
dot
id|vt_mode.relsig
op_assign
id|get_fs_word
c_func
(paren
op_amp
id|vtmode-&gt;relsig
)paren
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
dot
id|vt_mode.acqsig
op_assign
id|get_fs_word
c_func
(paren
op_amp
id|vtmode-&gt;acqsig
)paren
suffix:semicolon
multiline_comment|/* the frsig is ignored, so we set it to 0 */
id|vt_cons
(braket
id|console
)braket
dot
id|vt_mode.frsig
op_assign
l_int|0
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
dot
id|vt_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
dot
id|vt_newvt
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VT_GETMODE
suffix:colon
(brace
r_struct
id|vt_mode
op_star
id|vtmode
op_assign
(paren
r_struct
id|vt_mode
op_star
)paren
id|arg
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|vt_mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|put_fs_byte
c_func
(paren
id|vt_cons
(braket
id|console
)braket
dot
id|vt_mode.mode
comma
op_amp
id|vtmode-&gt;mode
)paren
suffix:semicolon
id|put_fs_byte
c_func
(paren
id|vt_cons
(braket
id|console
)braket
dot
id|vt_mode.waitv
comma
op_amp
id|vtmode-&gt;waitv
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
id|vt_cons
(braket
id|console
)braket
dot
id|vt_mode.relsig
comma
op_amp
id|vtmode-&gt;relsig
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
id|vt_cons
(braket
id|console
)braket
dot
id|vt_mode.acqsig
comma
op_amp
id|vtmode-&gt;acqsig
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
id|vt_cons
(braket
id|console
)braket
dot
id|vt_mode.frsig
comma
op_amp
id|vtmode-&gt;frsig
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Returns global vt state. Note that VT 0 is always open, since&n;&t; * it&squot;s an alias for the current VT, and people can&squot;t use it here.&n;&t; */
r_case
id|VT_GETSTATE
suffix:colon
(brace
r_struct
id|vt_stat
op_star
id|vtstat
op_assign
(paren
r_struct
id|vt_stat
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|state
comma
id|mask
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|vtstat
comma
r_sizeof
(paren
r_struct
id|vt_stat
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|put_fs_word
c_func
(paren
id|fg_console
op_plus
l_int|1
comma
op_amp
id|vtstat-&gt;v_active
)paren
suffix:semicolon
id|state
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* /dev/tty0 is always open */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|2
suffix:semicolon
id|i
OL
id|NR_CONSOLES
suffix:semicolon
op_increment
id|i
comma
id|mask
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|console_driver.table
(braket
id|i
)braket
op_logical_and
id|console_driver.table
(braket
id|i
)braket
op_member_access_from_pointer
id|count
OG
l_int|0
)paren
id|state
op_or_assign
id|mask
suffix:semicolon
id|put_fs_word
c_func
(paren
id|state
comma
op_amp
id|vtstat-&gt;v_state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Returns the first available (non-opened) console.&n;&t; */
r_case
id|VT_OPENQRY
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_CONSOLES
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
op_logical_neg
id|console_driver.table
(braket
id|i
)braket
op_logical_or
id|console_driver.table
(braket
id|i
)braket
op_member_access_from_pointer
id|count
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|put_fs_long
c_func
(paren
id|i
OL
id|NR_CONSOLES
ques
c_cond
(paren
id|i
op_plus
l_int|1
)paren
suffix:colon
op_minus
l_int|1
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * ioctl(fd, VT_ACTIVATE, num) will cause us to switch to vt # num,&n;&t; * with num &gt;= 1 (switches to vt 0, our console) are not allowed, just&n;&t; * to preserve sanity.&n;&t; */
r_case
id|VT_ACTIVATE
suffix:colon
r_if
c_cond
(paren
id|arg
op_eq
l_int|0
op_logical_or
id|arg
OG
id|NR_CONSOLES
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|change_console
c_func
(paren
id|arg
op_minus
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * wait until the specified VT has been activated&n;&t; */
r_case
id|VT_WAITACTIVE
suffix:colon
r_if
c_cond
(paren
id|arg
op_eq
l_int|0
op_logical_or
id|arg
OG
id|NR_CONSOLES
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_while
c_loop
(paren
id|fg_console
op_ne
id|arg
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|vt_waitactive
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If a vt is under process control, the kernel will not switch to it&n;&t; * immediately, but postpone the operation until the process calls this&n;&t; * ioctl, allowing the switch to complete.&n;&t; *&n;&t; * According to the X sources this is the behavior:&n;&t; *&t;0:&t;pending switch-from not OK&n;&t; *&t;1:&t;pending switch-from OK&n;&t; *&t;2:&t;completed switch-to OK&n;&t; */
r_case
id|VT_RELDISP
suffix:colon
r_if
c_cond
(paren
id|vt_cons
(braket
id|console
)braket
dot
id|vt_mode.mode
op_ne
id|VT_PROCESS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Switching-from response&n;&t;&t; */
r_if
c_cond
(paren
id|vt_cons
(braket
id|console
)braket
dot
id|vt_newvt
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|arg
op_eq
l_int|0
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * Switch disallowed, so forget we were trying&n;&t;&t;&t;&t; * to do it.&n;&t;&t;&t;&t; */
id|vt_cons
(braket
id|console
)braket
dot
id|vt_newvt
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The current vt has been released, so&n;&t;&t;&t;&t; * complete the switch.&n;&t;&t;&t;&t; */
r_int
id|newvt
op_assign
id|vt_cons
(braket
id|console
)braket
dot
id|vt_newvt
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
dot
id|vt_newvt
op_assign
op_minus
l_int|1
suffix:semicolon
id|complete_change_console
c_func
(paren
id|newvt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Switched-to response&n;&t;&t; */
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * If it&squot;s just an ACK, ignore it&n;&t;&t;&t; */
r_if
c_cond
(paren
id|arg
op_ne
id|VT_ACKACQ
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|PIO_FONT
suffix:colon
r_return
id|con_set_font
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
multiline_comment|/* con_set_font() defined in console.c */
r_case
id|GIO_FONT
suffix:colon
r_return
id|con_get_font
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
multiline_comment|/* con_get_font() defined in console.c */
r_case
id|PIO_SCRNMAP
suffix:colon
r_return
id|con_set_trans
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
multiline_comment|/* con_set_trans() defined in console.c */
r_case
id|GIO_SCRNMAP
suffix:colon
r_return
id|con_get_trans
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
multiline_comment|/* con_get_trans() defined in console.c */
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
)brace
eof
