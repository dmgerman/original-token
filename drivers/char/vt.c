multiline_comment|/*&n; *  linux/drivers/char/vt.c&n; *&n; *  Copyright (C) 1992 obz under the linux copyright&n; *&n; *  Dynamic diacritical handling - aeb@cwi.nl - Dec 1993&n; *  Dynamic keymap and string allocation - aeb@cwi.nl - May 1994&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kd.h&gt;
macro_line|#include &lt;linux/vt.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &quot;kbd_kern.h&quot;
macro_line|#include &quot;vt_kern.h&quot;
macro_line|#include &quot;diacr.h&quot;
macro_line|#include &quot;selection.h&quot;
r_extern
r_struct
id|tty_driver
id|console_driver
suffix:semicolon
DECL|macro|VT_IS_IN_USE
mdefine_line|#define VT_IS_IN_USE(i)&t;(console_driver.table[i] &amp;&amp; console_driver.table[i]-&gt;count)
DECL|macro|VT_BUSY
mdefine_line|#define VT_BUSY(i)&t;(VT_IS_IN_USE(i) || i == fg_console || i == sel_cons)
multiline_comment|/*&n; * Console (vt and kd) routines, as defined by USL SVR4 manual, and by&n; * experimentation and study of X386 SYSV handling.&n; *&n; * One point of difference: SYSV vt&squot;s are /dev/vtX, which X &gt;= 0, and&n; * /dev/console is a separate ttyp. Under Linux, /dev/tty0 is /dev/console,&n; * and the vc start at /dev/ttyX, X &gt;= 1. We maintain that here, so we will&n; * always treat our set of vt as numbered 1..MAX_NR_CONSOLES (corresponding to&n; * ttys 0..MAX_NR_CONSOLES-1). Explicitly naming VT 0 is illegal, but using&n; * /dev/tty0 (fg_console) as a target is legal, since an implicit aliasing&n; * to the current console is done by the main ioctl code.&n; */
DECL|variable|vt_cons
r_struct
id|vt_struct
op_star
id|vt_cons
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
id|asmlinkage
r_int
id|sys_ioperm
c_func
(paren
r_int
r_int
id|from
comma
r_int
r_int
id|num
comma
r_int
id|on
)paren
suffix:semicolon
r_extern
r_int
id|getkeycode
c_func
(paren
r_int
r_int
id|scancode
)paren
suffix:semicolon
r_extern
r_int
id|setkeycode
c_func
(paren
r_int
r_int
id|scancode
comma
r_int
r_int
id|keycode
)paren
suffix:semicolon
r_extern
r_void
id|compute_shiftstate
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|change_console
c_func
(paren
r_int
r_int
id|new_console
)paren
suffix:semicolon
r_extern
r_void
id|complete_change_console
c_func
(paren
r_int
r_int
id|new_console
)paren
suffix:semicolon
r_extern
r_int
id|vt_waitactive
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|do_blank_screen
c_func
(paren
r_int
id|nopowersave
)paren
suffix:semicolon
r_extern
r_int
r_int
id|keymap_count
suffix:semicolon
multiline_comment|/*&n; * routines to load custom translation table, EGA/VGA font and&n; * VGA colour palette from console.c&n; */
r_extern
r_int
id|con_set_trans_old
c_func
(paren
r_int
r_char
op_star
id|table
)paren
suffix:semicolon
r_extern
r_int
id|con_get_trans_old
c_func
(paren
r_int
r_char
op_star
id|table
)paren
suffix:semicolon
r_extern
r_int
id|con_set_trans_new
c_func
(paren
r_int
r_int
op_star
id|table
)paren
suffix:semicolon
r_extern
r_int
id|con_get_trans_new
c_func
(paren
r_int
r_int
op_star
id|table
)paren
suffix:semicolon
r_extern
r_void
id|con_clear_unimap
c_func
(paren
r_struct
id|unimapinit
op_star
id|ui
)paren
suffix:semicolon
r_extern
r_int
id|con_set_unimap
c_func
(paren
id|ushort
id|ct
comma
r_struct
id|unipair
op_star
id|list
)paren
suffix:semicolon
r_extern
r_int
id|con_get_unimap
c_func
(paren
id|ushort
id|ct
comma
id|ushort
op_star
id|uct
comma
r_struct
id|unipair
op_star
id|list
)paren
suffix:semicolon
r_extern
r_void
id|con_set_default_unimap
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|con_set_font
c_func
(paren
r_char
op_star
id|fontmap
comma
r_int
id|ch512
)paren
suffix:semicolon
r_extern
r_int
id|con_get_font
c_func
(paren
r_char
op_star
id|fontmap
)paren
suffix:semicolon
r_extern
r_int
id|con_set_cmap
c_func
(paren
r_int
r_char
op_star
id|cmap
)paren
suffix:semicolon
r_extern
r_int
id|con_get_cmap
c_func
(paren
r_int
r_char
op_star
id|cmap
)paren
suffix:semicolon
r_extern
r_void
id|reset_palette
c_func
(paren
r_int
id|currcons
)paren
suffix:semicolon
r_extern
r_int
id|con_adjust_height
c_func
(paren
r_int
r_int
id|fontheight
)paren
suffix:semicolon
r_extern
r_int
id|video_mode_512ch
suffix:semicolon
r_extern
r_int
r_int
id|video_font_height
suffix:semicolon
r_extern
r_int
r_int
id|default_font_height
suffix:semicolon
r_extern
r_int
r_int
id|video_scan_lines
suffix:semicolon
multiline_comment|/*&n; * these are the valid i/o ports we&squot;re allowed to change. they map all the&n; * video ports&n; */
DECL|macro|GPFIRST
mdefine_line|#define GPFIRST 0x3b4
DECL|macro|GPLAST
mdefine_line|#define GPLAST 0x3df
DECL|macro|GPNUM
mdefine_line|#define GPNUM (GPLAST - GPFIRST + 1)
multiline_comment|/*&n; * This function is called when the size of the physical screen has been&n; * changed.  If either the row or col argument is nonzero, set the appropriate&n; * entry in each winsize structure for all the virtual consoles, then&n; * send SIGWINCH to all processes with a virtual console as controlling&n; * tty.&n; */
r_static
r_int
DECL|function|kd_size_changed
id|kd_size_changed
c_func
(paren
r_int
id|row
comma
r_int
id|col
)paren
(brace
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|row
op_logical_and
op_logical_neg
id|col
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_CONSOLES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|console_driver.table
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|row
)paren
id|console_driver.table
(braket
id|i
)braket
op_member_access_from_pointer
id|winsize.ws_row
op_assign
id|row
suffix:semicolon
r_if
c_cond
(paren
id|col
)paren
id|console_driver.table
(braket
id|i
)braket
op_member_access_from_pointer
id|winsize.ws_col
op_assign
id|col
suffix:semicolon
)brace
)brace
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;tty
op_logical_and
id|MAJOR
c_func
(paren
id|p-&gt;tty-&gt;device
)paren
op_eq
id|TTY_MAJOR
op_logical_and
id|MINOR
c_func
(paren
id|p-&gt;tty-&gt;device
)paren
op_le
id|MAX_NR_CONSOLES
op_logical_and
id|MINOR
c_func
(paren
id|p-&gt;tty-&gt;device
)paren
)paren
(brace
id|send_sig
c_func
(paren
id|SIGWINCH
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Generates sound of some count for some number of clock ticks&n; * [count = 1193180 / frequency]&n; *&n; * If freq is 0, will turn off sound, else will turn it on for that time.&n; * If msec is 0, will return immediately, else will sleep for msec time, then&n; * turn sound off.&n; *&n; * We use the BEEP_TIMER vector since we&squot;re using the same method to&n; * generate sound, and we&squot;ll overwrite any beep in progress. That may&n; * be something to fix later, if we like.&n; *&n; * We also return immediately, which is what was implied within the X&n; * comments - KDMKTONE doesn&squot;t put the process to sleep.&n; */
r_static
r_void
DECL|function|kd_nosound
id|kd_nosound
c_func
(paren
r_int
r_int
id|ignored
)paren
(brace
multiline_comment|/* disable counter 2 */
id|outb
c_func
(paren
id|inb_p
c_func
(paren
l_int|0x61
)paren
op_amp
l_int|0xFC
comma
l_int|0x61
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_void
DECL|function|kd_mksound
id|kd_mksound
c_func
(paren
r_int
r_int
id|count
comma
r_int
r_int
id|ticks
)paren
(brace
r_static
r_struct
id|timer_list
id|sound_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|kd_nosound
)brace
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sound_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
multiline_comment|/* enable counter 2 */
id|outb_p
c_func
(paren
id|inb_p
c_func
(paren
l_int|0x61
)paren
op_or
l_int|3
comma
l_int|0x61
)paren
suffix:semicolon
multiline_comment|/* set command for counter 2, 2 byte write */
id|outb_p
c_func
(paren
l_int|0xB6
comma
l_int|0x43
)paren
suffix:semicolon
multiline_comment|/* select desired HZ */
id|outb_p
c_func
(paren
id|count
op_amp
l_int|0xff
comma
l_int|0x42
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|count
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
l_int|0x42
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ticks
)paren
(brace
id|sound_timer.expires
op_assign
id|jiffies
op_plus
id|ticks
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sound_timer
)paren
suffix:semicolon
)brace
)brace
r_else
id|kd_nosound
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * We handle the console-specific ioctl&squot;s here.  We allow the&n; * capability to modify any console, not just the fg_console. &n; */
DECL|function|vt_ioctl
r_int
id|vt_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|i
comma
id|perm
suffix:semicolon
r_int
r_int
id|console
suffix:semicolon
r_int
r_char
id|ucval
suffix:semicolon
r_struct
id|kbd_struct
op_star
id|kbd
suffix:semicolon
r_struct
id|vt_struct
op_star
id|vt
op_assign
(paren
r_struct
id|vt_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|console
op_assign
id|vt-&gt;vc_num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|console
)paren
)paren
multiline_comment|/* impossible? */
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
multiline_comment|/*&n;&t; * To have permissions to do most of the vt ioctls, we either have&n;&t; * to be the owner of the tty, or super-user.&n;&t; */
id|perm
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;tty
op_eq
id|tty
op_logical_or
id|suser
c_func
(paren
)paren
)paren
id|perm
op_assign
l_int|1
suffix:semicolon
id|kbd
op_assign
id|kbd_table
op_plus
id|console
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|KIOCSOUND
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|kd_mksound
c_func
(paren
(paren
r_int
r_int
)paren
id|arg
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|KDMKTONE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
(brace
r_int
r_int
id|ticks
op_assign
id|HZ
op_star
(paren
(paren
id|arg
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
op_div
l_int|1000
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Generate the tone for the appropriate number of ticks.&n;&t;&t; * If the time is zero, turn off sound ourselves.&n;&t;&t; */
id|kd_mksound
c_func
(paren
id|arg
op_amp
l_int|0xffff
comma
id|ticks
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ticks
op_eq
l_int|0
)paren
id|kd_nosound
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDGKBTYPE
suffix:colon
multiline_comment|/*&n;&t;&t; * this is naive.&n;&t;&t; */
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_char
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|put_user
c_func
(paren
id|KB_101
comma
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
r_case
id|KDADDIO
suffix:colon
r_case
id|KDDELIO
suffix:colon
multiline_comment|/*&n;&t;&t; * KDADDIO and KDDELIO may be able to add ports beyond what&n;&t;&t; * we reject here, but to be safe...&n;&t;&t; */
r_if
c_cond
(paren
id|arg
template_param
id|GPLAST
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|sys_ioperm
c_func
(paren
id|arg
comma
l_int|1
comma
(paren
id|cmd
op_eq
id|KDADDIO
)paren
)paren
ques
c_cond
op_minus
id|ENXIO
suffix:colon
l_int|0
suffix:semicolon
r_case
id|KDENABIO
suffix:colon
r_case
id|KDDISABIO
suffix:colon
r_return
id|sys_ioperm
c_func
(paren
id|GPFIRST
comma
id|GPNUM
comma
(paren
id|cmd
op_eq
id|KDENABIO
)paren
)paren
ques
c_cond
op_minus
id|ENXIO
suffix:colon
l_int|0
suffix:semicolon
r_case
id|KDSETMODE
suffix:colon
multiline_comment|/*&n;&t;&t; * currently, setting the mode from KD_TEXT to KD_GRAPHICS&n;&t;&t; * doesn&squot;t do a whole lot. i&squot;m not sure if it should do any&n;&t;&t; * restoration of modes or what...&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|arg
)paren
(brace
r_case
id|KD_GRAPHICS
suffix:colon
r_break
suffix:semicolon
r_case
id|KD_TEXT0
suffix:colon
r_case
id|KD_TEXT1
suffix:colon
id|arg
op_assign
id|KD_TEXT
suffix:semicolon
r_case
id|KD_TEXT
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vc_mode
op_eq
(paren
r_int
r_char
)paren
id|arg
)paren
r_return
l_int|0
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vc_mode
op_assign
(paren
r_int
r_char
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|console
op_ne
id|fg_console
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * explicitly blank/unblank the screen if switching modes&n;&t;&t; */
r_if
c_cond
(paren
id|arg
op_eq
id|KD_TEXT
)paren
id|do_unblank_screen
c_func
(paren
)paren
suffix:semicolon
r_else
id|do_blank_screen
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|KDGETMODE
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
id|put_user
c_func
(paren
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vc_mode
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
r_case
id|KDMAPDISP
suffix:colon
r_case
id|KDUNMAPDISP
suffix:colon
multiline_comment|/*&n;&t;&t; * these work like a combination of mmap and KDENABIO.&n;&t;&t; * this could be easily finished.&n;&t;&t; */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|KDSKBMODE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|arg
)paren
(brace
r_case
id|K_RAW
suffix:colon
id|kbd-&gt;kbdmode
op_assign
id|VC_RAW
suffix:semicolon
r_break
suffix:semicolon
r_case
id|K_MEDIUMRAW
suffix:colon
id|kbd-&gt;kbdmode
op_assign
id|VC_MEDIUMRAW
suffix:semicolon
r_break
suffix:semicolon
r_case
id|K_XLATE
suffix:colon
id|kbd-&gt;kbdmode
op_assign
id|VC_XLATE
suffix:semicolon
id|compute_shiftstate
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|K_UNICODE
suffix:colon
id|kbd-&gt;kbdmode
op_assign
id|VC_UNICODE
suffix:semicolon
id|compute_shiftstate
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|KDGKBMODE
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|ucval
op_assign
(paren
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_RAW
)paren
ques
c_cond
id|K_RAW
suffix:colon
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_MEDIUMRAW
)paren
ques
c_cond
id|K_MEDIUMRAW
suffix:colon
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_UNICODE
)paren
ques
c_cond
id|K_UNICODE
suffix:colon
id|K_XLATE
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|ucval
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
multiline_comment|/* this could be folded into KDSKBMODE, but for compatibility&n;&t;   reasons it is not so easy to fold KDGKBMETA into KDGKBMODE */
r_case
id|KDSKBMETA
suffix:colon
r_switch
c_cond
(paren
id|arg
)paren
(brace
r_case
id|K_METABIT
suffix:colon
id|clr_vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_META
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|K_ESCPREFIX
suffix:colon
id|set_vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_META
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|KDGKBMETA
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|ucval
op_assign
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_META
)paren
ques
c_cond
id|K_ESCPREFIX
suffix:colon
id|K_METABIT
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|ucval
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
r_case
id|KDGETKEYCODE
suffix:colon
(brace
r_struct
id|kbkeycode
op_star
r_const
id|a
op_assign
(paren
r_struct
id|kbkeycode
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|sc
suffix:semicolon
r_int
id|kc
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|a
comma
r_sizeof
(paren
r_struct
id|kbkeycode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|sc
op_assign
id|get_user
c_func
(paren
op_amp
id|a-&gt;scancode
)paren
suffix:semicolon
id|kc
op_assign
id|getkeycode
c_func
(paren
id|sc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kc
OL
l_int|0
)paren
r_return
id|kc
suffix:semicolon
id|put_user
c_func
(paren
id|kc
comma
op_amp
id|a-&gt;keycode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDSETKEYCODE
suffix:colon
(brace
r_struct
id|kbkeycode
op_star
r_const
id|a
op_assign
(paren
r_struct
id|kbkeycode
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|sc
comma
id|kc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|a
comma
r_sizeof
(paren
r_struct
id|kbkeycode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|sc
op_assign
id|get_user
c_func
(paren
op_amp
id|a-&gt;scancode
)paren
suffix:semicolon
id|kc
op_assign
id|get_user
c_func
(paren
op_amp
id|a-&gt;keycode
)paren
suffix:semicolon
r_return
id|setkeycode
c_func
(paren
id|sc
comma
id|kc
)paren
suffix:semicolon
)brace
r_case
id|KDGKBENT
suffix:colon
(brace
r_struct
id|kbentry
op_star
r_const
id|a
op_assign
(paren
r_struct
id|kbentry
op_star
)paren
id|arg
suffix:semicolon
id|ushort
op_star
id|key_map
comma
id|val
suffix:semicolon
id|u_char
id|s
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|a
comma
r_sizeof
(paren
r_struct
id|kbentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|get_user
c_func
(paren
op_amp
id|a-&gt;kb_index
)paren
)paren
op_ge
id|NR_KEYS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s
op_assign
id|get_user
c_func
(paren
op_amp
id|a-&gt;kb_table
)paren
)paren
op_ge
id|MAX_NR_KEYMAPS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|key_map
op_assign
id|key_maps
(braket
id|s
)braket
suffix:semicolon
r_if
c_cond
(paren
id|key_map
)paren
(brace
id|val
op_assign
id|U
c_func
(paren
id|key_map
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd-&gt;kbdmode
op_ne
id|VC_UNICODE
op_logical_and
id|KTYP
c_func
(paren
id|val
)paren
op_ge
id|NR_TYPES
)paren
id|val
op_assign
id|K_HOLE
suffix:semicolon
)brace
r_else
id|val
op_assign
(paren
id|i
ques
c_cond
id|K_HOLE
suffix:colon
id|K_NOSUCHMAP
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|val
comma
op_amp
id|a-&gt;kb_value
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDSKBENT
suffix:colon
(brace
r_const
r_struct
id|kbentry
op_star
id|a
op_assign
(paren
r_struct
id|kbentry
op_star
)paren
id|arg
suffix:semicolon
id|ushort
op_star
id|key_map
suffix:semicolon
id|u_char
id|s
suffix:semicolon
id|u_short
id|v
comma
id|ov
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_const
r_void
op_star
)paren
id|a
comma
r_sizeof
(paren
r_struct
id|kbentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|get_user
c_func
(paren
op_amp
id|a-&gt;kb_index
)paren
)paren
op_ge
id|NR_KEYS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|s
op_assign
id|get_user
c_func
(paren
op_amp
id|a-&gt;kb_table
)paren
)paren
op_ge
id|MAX_NR_KEYMAPS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|v
op_assign
id|get_user
c_func
(paren
op_amp
id|a-&gt;kb_value
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
op_logical_and
id|v
op_eq
id|K_NOSUCHMAP
)paren
(brace
multiline_comment|/* disallocate map */
id|key_map
op_assign
id|key_maps
(braket
id|s
)braket
suffix:semicolon
r_if
c_cond
(paren
id|s
op_logical_and
id|key_map
)paren
(brace
id|key_maps
(braket
id|s
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|key_map
(braket
l_int|0
)braket
op_eq
id|U
c_func
(paren
id|K_ALLOCATED
)paren
)paren
(brace
id|kfree_s
c_func
(paren
id|key_map
comma
r_sizeof
(paren
id|plain_map
)paren
)paren
suffix:semicolon
id|keymap_count
op_decrement
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|KTYP
c_func
(paren
id|v
)paren
OL
id|NR_TYPES
)paren
(brace
r_if
c_cond
(paren
id|KVAL
c_func
(paren
id|v
)paren
OG
id|max_vals
(braket
id|KTYP
c_func
(paren
id|v
)paren
)braket
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kbd-&gt;kbdmode
op_ne
id|VC_UNICODE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* assignment to entry 0 only tests validity of args */
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|key_map
op_assign
id|key_maps
(braket
id|s
)braket
)paren
)paren
(brace
r_int
id|j
suffix:semicolon
r_if
c_cond
(paren
id|keymap_count
op_ge
id|MAX_NR_OF_USER_KEYMAPS
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|key_map
op_assign
(paren
id|ushort
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|plain_map
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key_map
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|key_maps
(braket
id|s
)braket
op_assign
id|key_map
suffix:semicolon
id|key_map
(braket
l_int|0
)braket
op_assign
id|U
c_func
(paren
id|K_ALLOCATED
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
id|NR_KEYS
suffix:semicolon
id|j
op_increment
)paren
id|key_map
(braket
id|j
)braket
op_assign
id|U
c_func
(paren
id|K_HOLE
)paren
suffix:semicolon
id|keymap_count
op_increment
suffix:semicolon
)brace
id|ov
op_assign
id|U
c_func
(paren
id|key_map
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v
op_eq
id|ov
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* nothing to do */
multiline_comment|/*&n;&t;&t; * Only the Superuser can set or unset the Secure&n;&t;&t; * Attention Key.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|ov
op_eq
id|K_SAK
)paren
op_logical_or
(paren
id|v
op_eq
id|K_SAK
)paren
)paren
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|key_map
(braket
id|i
)braket
op_assign
id|U
c_func
(paren
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
op_logical_and
(paren
id|KTYP
c_func
(paren
id|ov
)paren
op_eq
id|KT_SHIFT
op_logical_or
id|KTYP
c_func
(paren
id|v
)paren
op_eq
id|KT_SHIFT
)paren
)paren
id|compute_shiftstate
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDGKBSENT
suffix:colon
(brace
r_struct
id|kbsentry
op_star
id|a
op_assign
(paren
r_struct
id|kbsentry
op_star
)paren
id|arg
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
id|u_char
op_star
id|q
suffix:semicolon
r_int
id|sz
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|a
comma
r_sizeof
(paren
r_struct
id|kbsentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|get_user
c_func
(paren
op_amp
id|a-&gt;kb_func
)paren
)paren
op_ge
id|MAX_NR_FUNC
op_logical_or
id|i
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|sz
op_assign
r_sizeof
(paren
id|a-&gt;kb_string
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* sz should have been&n;&t;&t;&t;&t;&t;&t;  a struct member */
id|q
op_assign
id|a-&gt;kb_string
suffix:semicolon
id|p
op_assign
id|func_table
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
r_for
c_loop
(paren
suffix:semicolon
op_star
id|p
op_logical_and
id|sz
suffix:semicolon
id|p
op_increment
comma
id|sz
op_decrement
)paren
id|put_user
c_func
(paren
op_star
id|p
comma
id|q
op_increment
)paren
suffix:semicolon
id|put_user
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|q
)paren
suffix:semicolon
r_return
(paren
(paren
id|p
op_logical_and
op_star
id|p
)paren
ques
c_cond
op_minus
id|EOVERFLOW
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_case
id|KDSKBSENT
suffix:colon
(brace
r_struct
id|kbsentry
op_star
r_const
id|a
op_assign
(paren
r_struct
id|kbsentry
op_star
)paren
id|arg
suffix:semicolon
r_int
id|delta
suffix:semicolon
r_char
op_star
id|first_free
comma
op_star
id|fj
comma
op_star
id|fnw
suffix:semicolon
r_int
id|j
comma
id|k
comma
id|sz
suffix:semicolon
id|u_char
op_star
id|p
suffix:semicolon
r_char
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|a
comma
r_sizeof
(paren
r_struct
id|kbsentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|get_user
c_func
(paren
op_amp
id|a-&gt;kb_func
)paren
)paren
op_ge
id|MAX_NR_FUNC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|q
op_assign
id|func_table
(braket
id|i
)braket
suffix:semicolon
id|first_free
op_assign
id|funcbufptr
op_plus
(paren
id|funcbufsize
op_minus
id|funcbufleft
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
OL
id|MAX_NR_FUNC
op_logical_and
op_logical_neg
id|func_table
(braket
id|j
)braket
suffix:semicolon
id|j
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
id|MAX_NR_FUNC
)paren
id|fj
op_assign
id|func_table
(braket
id|j
)braket
suffix:semicolon
r_else
id|fj
op_assign
id|first_free
suffix:semicolon
id|delta
op_assign
(paren
id|q
ques
c_cond
op_minus
id|strlen
c_func
(paren
id|q
)paren
suffix:colon
l_int|1
)paren
suffix:semicolon
id|sz
op_assign
r_sizeof
(paren
id|a-&gt;kb_string
)paren
suffix:semicolon
multiline_comment|/* sz should have been&n;&t;&t;&t;&t;&t;&t;   a struct member */
r_for
c_loop
(paren
id|p
op_assign
id|a-&gt;kb_string
suffix:semicolon
id|get_user
c_func
(paren
id|p
)paren
op_logical_and
id|sz
suffix:semicolon
id|p
op_increment
comma
id|sz
op_decrement
)paren
id|delta
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sz
)paren
r_return
op_minus
id|EOVERFLOW
suffix:semicolon
r_if
c_cond
(paren
id|delta
op_le
id|funcbufleft
)paren
(brace
multiline_comment|/* it fits in current buf */
r_if
c_cond
(paren
id|j
OL
id|MAX_NR_FUNC
)paren
(brace
id|memmove
c_func
(paren
id|fj
op_plus
id|delta
comma
id|fj
comma
id|first_free
op_minus
id|fj
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|j
suffix:semicolon
id|k
OL
id|MAX_NR_FUNC
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|func_table
(braket
id|k
)braket
)paren
id|func_table
(braket
id|k
)braket
op_add_assign
id|delta
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
id|func_table
(braket
id|i
)braket
op_assign
id|fj
suffix:semicolon
id|funcbufleft
op_sub_assign
id|delta
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* allocate a larger buffer */
id|sz
op_assign
l_int|256
suffix:semicolon
r_while
c_loop
(paren
id|sz
OL
id|funcbufsize
op_minus
id|funcbufleft
op_plus
id|delta
)paren
id|sz
op_lshift_assign
l_int|1
suffix:semicolon
id|fnw
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|sz
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fnw
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
id|func_table
(braket
id|i
)braket
op_assign
id|fj
suffix:semicolon
r_if
c_cond
(paren
id|fj
OG
id|funcbufptr
)paren
id|memmove
c_func
(paren
id|fnw
comma
id|funcbufptr
comma
id|fj
op_minus
id|funcbufptr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|j
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|func_table
(braket
id|k
)braket
)paren
id|func_table
(braket
id|k
)braket
op_assign
id|fnw
op_plus
(paren
id|func_table
(braket
id|k
)braket
op_minus
id|funcbufptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_free
OG
id|fj
)paren
(brace
id|memmove
c_func
(paren
id|fnw
op_plus
(paren
id|fj
op_minus
id|funcbufptr
)paren
op_plus
id|delta
comma
id|fj
comma
id|first_free
op_minus
id|fj
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|j
suffix:semicolon
id|k
OL
id|MAX_NR_FUNC
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|func_table
(braket
id|k
)braket
)paren
id|func_table
(braket
id|k
)braket
op_assign
id|fnw
op_plus
(paren
id|func_table
(braket
id|k
)braket
op_minus
id|funcbufptr
)paren
op_plus
id|delta
suffix:semicolon
)brace
r_if
c_cond
(paren
id|funcbufptr
op_ne
id|func_buf
)paren
id|kfree_s
c_func
(paren
id|funcbufptr
comma
id|funcbufsize
)paren
suffix:semicolon
id|funcbufptr
op_assign
id|fnw
suffix:semicolon
id|funcbufleft
op_assign
id|funcbufleft
op_minus
id|delta
op_plus
id|sz
op_minus
id|funcbufsize
suffix:semicolon
id|funcbufsize
op_assign
id|sz
suffix:semicolon
)brace
r_for
c_loop
(paren
id|p
op_assign
id|a-&gt;kb_string
comma
id|q
op_assign
id|func_table
(braket
id|i
)braket
suffix:semicolon
suffix:semicolon
id|p
op_increment
comma
id|q
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|q
op_assign
id|get_user
c_func
(paren
id|p
)paren
)paren
)paren
r_break
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDGKBDIACR
suffix:colon
(brace
r_struct
id|kbdiacrs
op_star
id|a
op_assign
(paren
r_struct
id|kbdiacrs
op_star
)paren
id|arg
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|a
comma
r_sizeof
(paren
r_struct
id|kbdiacrs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|put_user
c_func
(paren
id|accent_table_size
comma
op_amp
id|a-&gt;kb_cnt
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|a-&gt;kbdiacr
comma
id|accent_table
comma
id|accent_table_size
op_star
r_sizeof
(paren
r_struct
id|kbdiacr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDSKBDIACR
suffix:colon
(brace
r_struct
id|kbdiacrs
op_star
id|a
op_assign
(paren
r_struct
id|kbdiacrs
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|ct
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|a
comma
r_sizeof
(paren
r_struct
id|kbdiacrs
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|ct
op_assign
id|get_user
c_func
(paren
op_amp
id|a-&gt;kb_cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ct
op_ge
id|MAX_DIACR
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|accent_table_size
op_assign
id|ct
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|accent_table
comma
id|a-&gt;kbdiacr
comma
id|ct
op_star
r_sizeof
(paren
r_struct
id|kbdiacr
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* the ioctls below read/set the flags usually shown in the leds */
multiline_comment|/* don&squot;t use them - they will go away without warning */
r_case
id|KDGKBLED
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_char
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|put_user
c_func
(paren
id|kbd-&gt;ledflagstate
op_or
(paren
id|kbd-&gt;default_ledflagstate
op_lshift
l_int|4
)paren
comma
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|KDSKBLED
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_amp
op_complement
l_int|0x77
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|kbd-&gt;ledflagstate
op_assign
(paren
id|arg
op_amp
l_int|7
)paren
suffix:semicolon
id|kbd-&gt;default_ledflagstate
op_assign
(paren
(paren
id|arg
op_rshift
l_int|4
)paren
op_amp
l_int|7
)paren
suffix:semicolon
id|set_leds
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* the ioctls below only set the lights, not the functions */
multiline_comment|/* for those, see KDGKBLED and KDSKBLED above */
r_case
id|KDGETLED
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
r_char
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|put_user
c_func
(paren
id|getledstate
c_func
(paren
)paren
comma
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|KDSETLED
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|setledstate
c_func
(paren
id|kbd
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * A process can indicate its willingness to accept signals&n;&t; * generated by pressing an appropriate key combination.&n;&t; * Thus, one can have a daemon that e.g. spawns a new console&n;&t; * upon a keypress and then changes to it.&n;&t; * Probably init should be changed to do this (and have a&n;&t; * field ks (`keyboard signal&squot;) in inittab describing the&n;&t; * desired action), so that the number of background daemons&n;&t; * does not increase.&n;&t; */
r_case
id|KDSIGACCEPT
suffix:colon
(brace
r_extern
r_int
id|spawnpid
comma
id|spawnsig
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|arg
template_param
id|NSIG
op_logical_or
id|arg
op_eq
id|SIGKILL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spawnpid
op_assign
id|current-&gt;pid
suffix:semicolon
id|spawnsig
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VT_SETMODE
suffix:colon
(brace
r_struct
id|vt_mode
op_star
id|vtmode
op_assign
(paren
r_struct
id|vt_mode
op_star
)paren
id|arg
suffix:semicolon
r_char
id|mode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|vtmode
comma
r_sizeof
(paren
r_struct
id|vt_mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|mode
op_assign
id|get_user
c_func
(paren
op_amp
id|vtmode-&gt;mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
op_ne
id|VT_AUTO
op_logical_and
id|mode
op_ne
id|VT_PROCESS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode.mode
op_assign
id|mode
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode.waitv
op_assign
id|get_user
c_func
(paren
op_amp
id|vtmode-&gt;waitv
)paren
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode.relsig
op_assign
id|get_user
c_func
(paren
op_amp
id|vtmode-&gt;relsig
)paren
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode.acqsig
op_assign
id|get_user
c_func
(paren
op_amp
id|vtmode-&gt;acqsig
)paren
suffix:semicolon
multiline_comment|/* the frsig is ignored, so we set it to 0 */
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode.frsig
op_assign
l_int|0
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_pid
op_assign
id|current-&gt;pid
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_newvt
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VT_GETMODE
suffix:colon
(brace
r_struct
id|vt_mode
op_star
id|vtmode
op_assign
(paren
r_struct
id|vt_mode
op_star
)paren
id|arg
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|vt_mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|put_user
c_func
(paren
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode.mode
comma
op_amp
id|vtmode-&gt;mode
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode.waitv
comma
op_amp
id|vtmode-&gt;waitv
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode.relsig
comma
op_amp
id|vtmode-&gt;relsig
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode.acqsig
comma
op_amp
id|vtmode-&gt;acqsig
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode.frsig
comma
op_amp
id|vtmode-&gt;frsig
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Returns global vt state. Note that VT 0 is always open, since&n;&t; * it&squot;s an alias for the current VT, and people can&squot;t use it here.&n;&t; * We cannot return state for more than 16 VTs, since v_state is short.&n;&t; */
r_case
id|VT_GETSTATE
suffix:colon
(brace
r_struct
id|vt_stat
op_star
id|vtstat
op_assign
(paren
r_struct
id|vt_stat
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|state
comma
id|mask
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|vtstat
comma
r_sizeof
(paren
r_struct
id|vt_stat
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|put_user
c_func
(paren
id|fg_console
op_plus
l_int|1
comma
op_amp
id|vtstat-&gt;v_active
)paren
suffix:semicolon
id|state
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* /dev/tty0 is always open */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|2
suffix:semicolon
id|i
OL
id|MAX_NR_CONSOLES
op_logical_and
id|mask
suffix:semicolon
op_increment
id|i
comma
id|mask
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|VT_IS_IN_USE
c_func
(paren
id|i
)paren
)paren
id|state
op_or_assign
id|mask
suffix:semicolon
id|put_user
c_func
(paren
id|state
comma
op_amp
id|vtstat-&gt;v_state
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Returns the first available (non-opened) console.&n;&t; */
r_case
id|VT_OPENQRY
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_CONSOLES
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
op_logical_neg
id|VT_IS_IN_USE
c_func
(paren
id|i
)paren
)paren
r_break
suffix:semicolon
id|put_user
c_func
(paren
id|i
OL
id|MAX_NR_CONSOLES
ques
c_cond
(paren
id|i
op_plus
l_int|1
)paren
suffix:colon
op_minus
l_int|1
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * ioctl(fd, VT_ACTIVATE, num) will cause us to switch to vt # num,&n;&t; * with num &gt;= 1 (switches to vt 0, our console, are not allowed, just&n;&t; * to preserve sanity).&n;&t; */
r_case
id|VT_ACTIVATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
l_int|0
op_logical_or
id|arg
OG
id|MAX_NR_CONSOLES
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|arg
op_decrement
suffix:semicolon
id|i
op_assign
id|vc_allocate
c_func
(paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|change_console
c_func
(paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * wait until the specified VT has been activated&n;&t; */
r_case
id|VT_WAITACTIVE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
l_int|0
op_logical_or
id|arg
OG
id|MAX_NR_CONSOLES
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|arg
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|fg_console
op_ne
id|arg
)paren
(brace
r_if
c_cond
(paren
id|vt_waitactive
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * If a vt is under process control, the kernel will not switch to it&n;&t; * immediately, but postpone the operation until the process calls this&n;&t; * ioctl, allowing the switch to complete.&n;&t; *&n;&t; * According to the X sources this is the behavior:&n;&t; *&t;0:&t;pending switch-from not OK&n;&t; *&t;1:&t;pending switch-from OK&n;&t; *&t;2:&t;completed switch-to OK&n;&t; */
r_case
id|VT_RELDISP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode.mode
op_ne
id|VT_PROCESS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Switching-from response&n;&t;&t; */
r_if
c_cond
(paren
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_newvt
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|arg
op_eq
l_int|0
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * Switch disallowed, so forget we were trying&n;&t;&t;&t;&t; * to do it.&n;&t;&t;&t;&t; */
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_newvt
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The current vt has been released, so&n;&t;&t;&t;&t; * complete the switch.&n;&t;&t;&t;&t; */
r_int
id|newvt
op_assign
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_newvt
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_newvt
op_assign
op_minus
l_int|1
suffix:semicolon
id|i
op_assign
id|vc_allocate
c_func
(paren
id|newvt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|complete_change_console
c_func
(paren
id|newvt
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Switched-to response&n;&t;&t; */
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * If it&squot;s just an ACK, ignore it&n;&t;&t;&t; */
r_if
c_cond
(paren
id|arg
op_ne
id|VT_ACKACQ
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;  * Disallocate memory associated to VT (but leave VT1)&n;&t;  */
r_case
id|VT_DISALLOCATE
suffix:colon
r_if
c_cond
(paren
id|arg
OG
id|MAX_NR_CONSOLES
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
l_int|0
)paren
(brace
multiline_comment|/* disallocate all unused consoles, but leave 0 */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|MAX_NR_CONSOLES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|VT_BUSY
c_func
(paren
id|i
)paren
)paren
id|vc_disallocate
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* disallocate a single console, if possible */
id|arg
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|VT_BUSY
c_func
(paren
id|arg
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
multiline_comment|/* leave 0 */
id|vc_disallocate
c_func
(paren
id|arg
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|VT_RESIZE
suffix:colon
(brace
r_struct
id|vt_sizes
op_star
id|vtsizes
op_assign
(paren
r_struct
id|vt_sizes
op_star
)paren
id|arg
suffix:semicolon
id|ushort
id|ll
comma
id|cc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|vtsizes
comma
r_sizeof
(paren
r_struct
id|vt_sizes
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|ll
op_assign
id|get_user
c_func
(paren
op_amp
id|vtsizes-&gt;v_rows
)paren
suffix:semicolon
id|cc
op_assign
id|get_user
c_func
(paren
op_amp
id|vtsizes-&gt;v_cols
)paren
suffix:semicolon
id|i
op_assign
id|vc_resize
c_func
(paren
id|ll
comma
id|cc
)paren
suffix:semicolon
r_return
id|i
ques
c_cond
id|i
suffix:colon
id|kd_size_changed
c_func
(paren
id|ll
comma
id|cc
)paren
suffix:semicolon
)brace
r_case
id|VT_RESIZEX
suffix:colon
(brace
r_struct
id|vt_consize
op_star
id|vtconsize
op_assign
(paren
r_struct
id|vt_consize
op_star
)paren
id|arg
suffix:semicolon
id|ushort
id|ll
comma
id|cc
comma
id|vlin
comma
id|clin
comma
id|vcol
comma
id|ccol
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|vtconsize
comma
r_sizeof
(paren
r_struct
id|vt_consize
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|ll
op_assign
id|get_user
c_func
(paren
op_amp
id|vtconsize-&gt;v_rows
)paren
suffix:semicolon
id|cc
op_assign
id|get_user
c_func
(paren
op_amp
id|vtconsize-&gt;v_cols
)paren
suffix:semicolon
id|vlin
op_assign
id|get_user
c_func
(paren
op_amp
id|vtconsize-&gt;v_vlin
)paren
suffix:semicolon
id|clin
op_assign
id|get_user
c_func
(paren
op_amp
id|vtconsize-&gt;v_clin
)paren
suffix:semicolon
id|vcol
op_assign
id|get_user
c_func
(paren
op_amp
id|vtconsize-&gt;v_vcol
)paren
suffix:semicolon
id|ccol
op_assign
id|get_user
c_func
(paren
op_amp
id|vtconsize-&gt;v_ccol
)paren
suffix:semicolon
id|vlin
op_assign
id|vlin
ques
c_cond
id|vlin
suffix:colon
id|video_scan_lines
suffix:semicolon
r_if
c_cond
(paren
id|clin
)paren
(brace
r_if
c_cond
(paren
id|ll
)paren
(brace
r_if
c_cond
(paren
id|ll
op_ne
id|vlin
op_div
id|clin
)paren
r_return
id|EINVAL
suffix:semicolon
multiline_comment|/* Parameters don&squot;t add up */
)brace
r_else
id|ll
op_assign
id|vlin
op_div
id|clin
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vcol
op_logical_and
id|ccol
)paren
(brace
r_if
c_cond
(paren
id|cc
)paren
(brace
r_if
c_cond
(paren
id|cc
op_ne
id|vcol
op_div
id|ccol
)paren
r_return
id|EINVAL
suffix:semicolon
)brace
r_else
id|cc
op_assign
id|vcol
op_div
id|ccol
suffix:semicolon
)brace
r_if
c_cond
(paren
id|clin
OG
l_int|32
)paren
r_return
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vlin
)paren
id|video_scan_lines
op_assign
id|vlin
suffix:semicolon
r_if
c_cond
(paren
id|clin
)paren
id|video_font_height
op_assign
id|clin
suffix:semicolon
id|i
op_assign
id|vc_resize
c_func
(paren
id|ll
comma
id|cc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|kd_size_changed
c_func
(paren
id|ll
comma
id|cc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|PIO_FONT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vc_mode
op_ne
id|KD_TEXT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|con_set_font
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* con_set_font() defined in console.c */
r_case
id|GIO_FONT
suffix:colon
r_if
c_cond
(paren
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vc_mode
op_ne
id|KD_TEXT
op_logical_or
id|video_mode_512ch
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|con_get_font
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
multiline_comment|/* con_get_font() defined in console.c */
r_case
id|PIO_CMAP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|con_set_cmap
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
multiline_comment|/* con_set_cmap() defined in console.c */
r_case
id|GIO_CMAP
suffix:colon
r_return
id|con_get_cmap
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
multiline_comment|/* con_get_cmap() defined in console.c */
r_case
id|PIO_FONTX
suffix:colon
(brace
r_struct
id|consolefontdesc
id|cfdarg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vc_mode
op_ne
id|KD_TEXT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|consolefontdesc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|cfdarg
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|consolefontdesc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfdarg.charcount
op_eq
l_int|256
op_logical_or
id|cfdarg.charcount
op_eq
l_int|512
)paren
(brace
id|i
op_assign
id|con_set_font
c_func
(paren
id|cfdarg.chardata
comma
id|cfdarg.charcount
op_eq
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|i
op_assign
id|con_adjust_height
c_func
(paren
id|cfdarg.charheight
)paren
suffix:semicolon
r_return
(paren
id|i
op_le
l_int|0
)paren
ques
c_cond
id|i
suffix:colon
id|kd_size_changed
c_func
(paren
id|i
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_case
id|PIO_FONTRESET
suffix:colon
(brace
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vc_mode
op_ne
id|KD_TEXT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#ifdef BROKEN_GRAPHICS_PROGRAMS
multiline_comment|/* With BROKEN_GRAPHICS_PROGRAMS defined, the default&n;&t;&t;   font is not saved. */
r_return
op_minus
id|ENOSYS
suffix:semicolon
macro_line|#else
id|i
op_assign
id|con_set_font
c_func
(paren
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Set font to default */
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|i
op_assign
id|con_adjust_height
c_func
(paren
id|default_font_height
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|kd_size_changed
c_func
(paren
id|i
comma
l_int|0
)paren
suffix:semicolon
id|con_set_default_unimap
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#endif
)brace
r_case
id|GIO_FONTX
suffix:colon
(brace
r_struct
id|consolefontdesc
id|cfdarg
suffix:semicolon
r_int
id|nchar
suffix:semicolon
r_if
c_cond
(paren
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vc_mode
op_ne
id|KD_TEXT
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|consolefontdesc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|cfdarg
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|consolefontdesc
)paren
)paren
suffix:semicolon
id|i
op_assign
id|cfdarg.charcount
suffix:semicolon
id|cfdarg.charcount
op_assign
id|nchar
op_assign
id|video_mode_512ch
ques
c_cond
l_int|512
suffix:colon
l_int|256
suffix:semicolon
id|cfdarg.charheight
op_assign
id|video_font_height
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|cfdarg
comma
r_sizeof
(paren
r_struct
id|consolefontdesc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cfdarg.chardata
)paren
(brace
r_if
c_cond
(paren
id|i
OL
id|nchar
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_return
id|con_get_font
c_func
(paren
id|cfdarg.chardata
)paren
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|PIO_SCRNMAP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|con_set_trans_old
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|GIO_SCRNMAP
suffix:colon
r_return
id|con_get_trans_old
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|PIO_UNISCRNMAP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|con_set_trans_new
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|GIO_UNISCRNMAP
suffix:colon
r_return
id|con_get_trans_new
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|PIO_UNIMAPCLR
suffix:colon
(brace
r_struct
id|unimapinit
id|ui
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|unimapinit
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|ui
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|unimapinit
)paren
)paren
suffix:semicolon
id|con_clear_unimap
c_func
(paren
op_amp
id|ui
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|PIO_UNIMAP
suffix:colon
(brace
r_struct
id|unimapdesc
op_star
id|ud
suffix:semicolon
id|u_short
id|ct
suffix:semicolon
r_struct
id|unipair
op_star
id|list
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|unimapdesc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|ud
op_assign
(paren
r_struct
id|unimapdesc
op_star
)paren
id|arg
suffix:semicolon
id|ct
op_assign
id|get_user
c_func
(paren
op_amp
id|ud-&gt;entry_ct
)paren
suffix:semicolon
id|list
op_assign
id|get_user
c_func
(paren
op_amp
id|ud-&gt;entries
)paren
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|list
comma
id|ct
op_star
r_sizeof
(paren
r_struct
id|unipair
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_return
id|con_set_unimap
c_func
(paren
id|ct
comma
id|list
)paren
suffix:semicolon
)brace
r_case
id|GIO_UNIMAP
suffix:colon
(brace
r_struct
id|unimapdesc
op_star
id|ud
suffix:semicolon
id|u_short
id|ct
suffix:semicolon
r_struct
id|unipair
op_star
id|list
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|unimapdesc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
(brace
id|ud
op_assign
(paren
r_struct
id|unimapdesc
op_star
)paren
id|arg
suffix:semicolon
id|ct
op_assign
id|get_user
c_func
(paren
op_amp
id|ud-&gt;entry_ct
)paren
suffix:semicolon
id|list
op_assign
id|get_user
c_func
(paren
op_amp
id|ud-&gt;entries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ct
)paren
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|list
comma
id|ct
op_star
r_sizeof
(paren
r_struct
id|unipair
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_return
id|con_get_unimap
c_func
(paren
id|ct
comma
op_amp
(paren
id|ud-&gt;entry_ct
)paren
comma
id|list
)paren
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
)brace
eof
