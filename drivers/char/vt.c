multiline_comment|/*&n; *  linux/drivers/char/vt.c&n; *&n; *  Copyright (C) 1992 obz under the linux copyright&n; *&n; *  Dynamic diacritical handling - aeb@cwi.nl - Dec 1993&n; *  Dynamic keymap and string allocation - aeb@cwi.nl - May 1994&n; *  Restrict VT switching via ioctl() - grif@cs.ucr.edu - Dec 1995&n; *  Some code moved for less code duplication - Andi Kleen - Mar 1997&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kd.h&gt;
macro_line|#include &lt;linux/vt.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/console.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#if defined(__mc68000__) || defined(CONFIG_APUS)
macro_line|#include &lt;asm/machdep.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/kbd_kern.h&gt;
macro_line|#include &lt;linux/vt_kern.h&gt;
macro_line|#include &lt;linux/kbd_diacr.h&gt;
macro_line|#include &lt;linux/selection.h&gt;
macro_line|#ifdef CONFIG_FB_COMPAT_XPMAC
macro_line|#include &lt;asm/vc_ioctl.h&gt;
macro_line|#endif /* CONFIG_FB_COMPAT_XPMAC */
DECL|variable|vt_dont_switch
r_char
id|vt_dont_switch
suffix:semicolon
r_extern
r_struct
id|tty_driver
id|console_driver
suffix:semicolon
DECL|macro|VT_IS_IN_USE
mdefine_line|#define VT_IS_IN_USE(i)&t;(console_driver.table[i] &amp;&amp; console_driver.table[i]-&gt;count)
DECL|macro|VT_BUSY
mdefine_line|#define VT_BUSY(i)&t;(VT_IS_IN_USE(i) || i == fg_console || i == sel_cons)
multiline_comment|/*&n; * Console (vt and kd) routines, as defined by USL SVR4 manual, and by&n; * experimentation and study of X386 SYSV handling.&n; *&n; * One point of difference: SYSV vt&squot;s are /dev/vtX, which X &gt;= 0, and&n; * /dev/console is a separate ttyp. Under Linux, /dev/tty0 is /dev/console,&n; * and the vc start at /dev/ttyX, X &gt;= 1. We maintain that here, so we will&n; * always treat our set of vt as numbered 1..MAX_NR_CONSOLES (corresponding to&n; * ttys 0..MAX_NR_CONSOLES-1). Explicitly naming VT 0 is illegal, but using&n; * /dev/tty0 (fg_console) as a target is legal, since an implicit aliasing&n; * to the current console is done by the main ioctl code.&n; */
DECL|variable|vt_cons
r_struct
id|vt_struct
op_star
id|vt_cons
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
multiline_comment|/* Keyboard type: Default is KB_101, but can be set by machine&n; * specific code.&n; */
DECL|variable|keyboard_type
r_int
r_char
id|keyboard_type
op_assign
id|KB_101
suffix:semicolon
macro_line|#if !defined(__alpha__) &amp;&amp; !defined(__ia64__) &amp;&amp; !defined(__mips__) &amp;&amp; !defined(__arm__) &amp;&amp; !defined(__sh__)
id|asmlinkage
r_int
id|sys_ioperm
c_func
(paren
r_int
r_int
id|from
comma
r_int
r_int
id|num
comma
r_int
id|on
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|video_font_height
r_int
r_int
id|video_font_height
suffix:semicolon
DECL|variable|default_font_height
r_int
r_int
id|default_font_height
suffix:semicolon
DECL|variable|video_scan_lines
r_int
r_int
id|video_scan_lines
suffix:semicolon
multiline_comment|/*&n; * these are the valid i/o ports we&squot;re allowed to change. they map all the&n; * video ports&n; */
DECL|macro|GPFIRST
mdefine_line|#define GPFIRST 0x3b4
DECL|macro|GPLAST
mdefine_line|#define GPLAST 0x3df
DECL|macro|GPNUM
mdefine_line|#define GPNUM (GPLAST - GPFIRST + 1)
multiline_comment|/*&n; * Generates sound of some frequency for some number of clock ticks&n; *&n; * If freq is 0, will turn off sound, else will turn it on for that time.&n; * If msec is 0, will return immediately, else will sleep for msec time, then&n; * turn sound off.&n; *&n; * We also return immediately, which is what was implied within the X&n; * comments - KDMKTONE doesn&squot;t put the process to sleep.&n; */
macro_line|#if defined(__i386__) || defined(__alpha__) || defined(__powerpc__) &bslash;&n;    || (defined(__mips__) &amp;&amp; !defined(CONFIG_SGI_IP22)) &bslash;&n;    || (defined(__arm__) &amp;&amp; defined(CONFIG_HOST_FOOTBRIDGE))
r_static
r_void
DECL|function|kd_nosound
id|kd_nosound
c_func
(paren
r_int
r_int
id|ignored
)paren
(brace
multiline_comment|/* disable counter 2 */
id|outb
c_func
(paren
id|inb_p
c_func
(paren
l_int|0x61
)paren
op_amp
l_int|0xFC
comma
l_int|0x61
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_void
DECL|function|_kd_mksound
id|_kd_mksound
c_func
(paren
r_int
r_int
id|hz
comma
r_int
r_int
id|ticks
)paren
(brace
r_static
r_struct
id|timer_list
id|sound_timer
op_assign
(brace
id|function
suffix:colon
id|kd_nosound
)brace
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|hz
OG
l_int|20
op_logical_and
id|hz
OL
l_int|32767
)paren
id|count
op_assign
l_int|1193180
op_div
id|hz
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|sound_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
multiline_comment|/* enable counter 2 */
id|outb_p
c_func
(paren
id|inb_p
c_func
(paren
l_int|0x61
)paren
op_or
l_int|3
comma
l_int|0x61
)paren
suffix:semicolon
multiline_comment|/* set command for counter 2, 2 byte write */
id|outb_p
c_func
(paren
l_int|0xB6
comma
l_int|0x43
)paren
suffix:semicolon
multiline_comment|/* select desired HZ */
id|outb_p
c_func
(paren
id|count
op_amp
l_int|0xff
comma
l_int|0x42
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
id|count
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
comma
l_int|0x42
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ticks
)paren
(brace
id|sound_timer.expires
op_assign
id|jiffies
op_plus
id|ticks
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|sound_timer
)paren
suffix:semicolon
)brace
)brace
r_else
id|kd_nosound
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#else
r_void
DECL|function|_kd_mksound
id|_kd_mksound
c_func
(paren
r_int
r_int
id|hz
comma
r_int
r_int
id|ticks
)paren
(brace
)brace
macro_line|#endif
DECL|variable|kd_mksound
r_void
(paren
op_star
id|kd_mksound
)paren
(paren
r_int
r_int
id|hz
comma
r_int
r_int
id|ticks
)paren
op_assign
id|_kd_mksound
suffix:semicolon
DECL|macro|i
mdefine_line|#define i (tmp.kb_index)
DECL|macro|s
mdefine_line|#define s (tmp.kb_table)
DECL|macro|v
mdefine_line|#define v (tmp.kb_value)
r_static
r_inline
r_int
DECL|function|do_kdsk_ioctl
id|do_kdsk_ioctl
c_func
(paren
r_int
id|cmd
comma
r_struct
id|kbentry
op_star
id|user_kbe
comma
r_int
id|perm
comma
r_struct
id|kbd_struct
op_star
id|kbd
)paren
(brace
r_struct
id|kbentry
id|tmp
suffix:semicolon
id|ushort
op_star
id|key_map
comma
id|val
comma
id|ov
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|user_kbe
comma
r_sizeof
(paren
r_struct
id|kbentry
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|NR_KEYS
op_logical_or
id|s
op_ge
id|MAX_NR_KEYMAPS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|KDGKBENT
suffix:colon
id|key_map
op_assign
id|key_maps
(braket
id|s
)braket
suffix:semicolon
r_if
c_cond
(paren
id|key_map
)paren
(brace
id|val
op_assign
id|U
c_func
(paren
id|key_map
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd-&gt;kbdmode
op_ne
id|VC_UNICODE
op_logical_and
id|KTYP
c_func
(paren
id|val
)paren
op_ge
id|NR_TYPES
)paren
id|val
op_assign
id|K_HOLE
suffix:semicolon
)brace
r_else
id|val
op_assign
(paren
id|i
ques
c_cond
id|K_HOLE
suffix:colon
id|K_NOSUCHMAP
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|val
comma
op_amp
id|user_kbe-&gt;kb_value
)paren
suffix:semicolon
r_case
id|KDSKBENT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
op_logical_and
id|v
op_eq
id|K_NOSUCHMAP
)paren
(brace
multiline_comment|/* disallocate map */
id|key_map
op_assign
id|key_maps
(braket
id|s
)braket
suffix:semicolon
r_if
c_cond
(paren
id|s
op_logical_and
id|key_map
)paren
(brace
id|key_maps
(braket
id|s
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|key_map
(braket
l_int|0
)braket
op_eq
id|U
c_func
(paren
id|K_ALLOCATED
)paren
)paren
(brace
id|kfree
c_func
(paren
id|key_map
)paren
suffix:semicolon
id|keymap_count
op_decrement
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|KTYP
c_func
(paren
id|v
)paren
OL
id|NR_TYPES
)paren
(brace
r_if
c_cond
(paren
id|KVAL
c_func
(paren
id|v
)paren
OG
id|max_vals
(braket
id|KTYP
c_func
(paren
id|v
)paren
)braket
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kbd-&gt;kbdmode
op_ne
id|VC_UNICODE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* ++Geert: non-PC keyboards may generate keycode zero */
macro_line|#if !defined(__mc68000__) &amp;&amp; !defined(__powerpc__)
multiline_comment|/* assignment to entry 0 only tests validity of args */
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
r_break
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|key_map
op_assign
id|key_maps
(braket
id|s
)braket
)paren
)paren
(brace
r_int
id|j
suffix:semicolon
r_if
c_cond
(paren
id|keymap_count
op_ge
id|MAX_NR_OF_USER_KEYMAPS
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RESOURCE
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|key_map
op_assign
(paren
id|ushort
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|plain_map
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|key_map
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|key_maps
(braket
id|s
)braket
op_assign
id|key_map
suffix:semicolon
id|key_map
(braket
l_int|0
)braket
op_assign
id|U
c_func
(paren
id|K_ALLOCATED
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
id|NR_KEYS
suffix:semicolon
id|j
op_increment
)paren
id|key_map
(braket
id|j
)braket
op_assign
id|U
c_func
(paren
id|K_HOLE
)paren
suffix:semicolon
id|keymap_count
op_increment
suffix:semicolon
)brace
id|ov
op_assign
id|U
c_func
(paren
id|key_map
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v
op_eq
id|ov
)paren
r_break
suffix:semicolon
multiline_comment|/* nothing to do */
multiline_comment|/*&n;&t;&t; * Attention Key.&n;&t;&t; */
r_if
c_cond
(paren
(paren
(paren
id|ov
op_eq
id|K_SAK
)paren
op_logical_or
(paren
id|v
op_eq
id|K_SAK
)paren
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|key_map
(braket
id|i
)braket
op_assign
id|U
c_func
(paren
id|v
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s
op_logical_and
(paren
id|KTYP
c_func
(paren
id|ov
)paren
op_eq
id|KT_SHIFT
op_logical_or
id|KTYP
c_func
(paren
id|v
)paren
op_eq
id|KT_SHIFT
)paren
)paren
id|compute_shiftstate
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|i
macro_line|#undef i
DECL|macro|s
macro_line|#undef s
DECL|macro|v
macro_line|#undef v
r_static
r_inline
r_int
DECL|function|do_kbkeycode_ioctl
id|do_kbkeycode_ioctl
c_func
(paren
r_int
id|cmd
comma
r_struct
id|kbkeycode
op_star
id|user_kbkc
comma
r_int
id|perm
)paren
(brace
r_struct
id|kbkeycode
id|tmp
suffix:semicolon
r_int
id|kc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|user_kbkc
comma
r_sizeof
(paren
r_struct
id|kbkeycode
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|KDGETKEYCODE
suffix:colon
id|kc
op_assign
id|getkeycode
c_func
(paren
id|tmp.scancode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kc
op_ge
l_int|0
)paren
id|kc
op_assign
id|put_user
c_func
(paren
id|kc
comma
op_amp
id|user_kbkc-&gt;keycode
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KDSETKEYCODE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|kc
op_assign
id|setkeycode
c_func
(paren
id|tmp.scancode
comma
id|tmp.keycode
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|kc
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|do_kdgkb_ioctl
id|do_kdgkb_ioctl
c_func
(paren
r_int
id|cmd
comma
r_struct
id|kbsentry
op_star
id|user_kdgkb
comma
r_int
id|perm
)paren
(brace
r_struct
id|kbsentry
id|tmp
suffix:semicolon
r_char
op_star
id|p
suffix:semicolon
id|u_char
op_star
id|q
suffix:semicolon
r_int
id|sz
suffix:semicolon
r_int
id|delta
suffix:semicolon
r_char
op_star
id|first_free
comma
op_star
id|fj
comma
op_star
id|fnw
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|k
suffix:semicolon
multiline_comment|/* we mostly copy too much here (512bytes), but who cares ;) */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|user_kdgkb
comma
r_sizeof
(paren
r_struct
id|kbsentry
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|tmp.kb_string
(braket
r_sizeof
(paren
id|tmp.kb_string
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|tmp.kb_func
op_ge
id|MAX_NR_FUNC
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|i
op_assign
id|tmp.kb_func
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|KDGKBSENT
suffix:colon
id|sz
op_assign
r_sizeof
(paren
id|tmp.kb_string
)paren
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* sz should have been&n;&t;&t;&t;&t;&t;&t;  a struct member */
id|q
op_assign
id|user_kdgkb-&gt;kb_string
suffix:semicolon
id|p
op_assign
id|func_table
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
r_for
c_loop
(paren
suffix:semicolon
op_star
id|p
op_logical_and
id|sz
suffix:semicolon
id|p
op_increment
comma
id|sz
op_decrement
)paren
id|put_user
c_func
(paren
op_star
id|p
comma
id|q
op_increment
)paren
suffix:semicolon
id|put_user
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|q
)paren
suffix:semicolon
r_return
(paren
(paren
id|p
op_logical_and
op_star
id|p
)paren
ques
c_cond
op_minus
id|EOVERFLOW
suffix:colon
l_int|0
)paren
suffix:semicolon
r_case
id|KDSKBSENT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|q
op_assign
id|func_table
(braket
id|i
)braket
suffix:semicolon
id|first_free
op_assign
id|funcbufptr
op_plus
(paren
id|funcbufsize
op_minus
id|funcbufleft
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
OL
id|MAX_NR_FUNC
op_logical_and
op_logical_neg
id|func_table
(braket
id|j
)braket
suffix:semicolon
id|j
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
OL
id|MAX_NR_FUNC
)paren
id|fj
op_assign
id|func_table
(braket
id|j
)braket
suffix:semicolon
r_else
id|fj
op_assign
id|first_free
suffix:semicolon
id|delta
op_assign
(paren
id|q
ques
c_cond
op_minus
id|strlen
c_func
(paren
id|q
)paren
suffix:colon
l_int|1
)paren
op_plus
id|strlen
c_func
(paren
id|tmp.kb_string
)paren
suffix:semicolon
r_if
c_cond
(paren
id|delta
op_le
id|funcbufleft
)paren
(brace
multiline_comment|/* it fits in current buf */
r_if
c_cond
(paren
id|j
OL
id|MAX_NR_FUNC
)paren
(brace
id|memmove
c_func
(paren
id|fj
op_plus
id|delta
comma
id|fj
comma
id|first_free
op_minus
id|fj
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|j
suffix:semicolon
id|k
OL
id|MAX_NR_FUNC
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|func_table
(braket
id|k
)braket
)paren
id|func_table
(braket
id|k
)braket
op_add_assign
id|delta
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
id|func_table
(braket
id|i
)braket
op_assign
id|fj
suffix:semicolon
id|funcbufleft
op_sub_assign
id|delta
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* allocate a larger buffer */
id|sz
op_assign
l_int|256
suffix:semicolon
r_while
c_loop
(paren
id|sz
OL
id|funcbufsize
op_minus
id|funcbufleft
op_plus
id|delta
)paren
id|sz
op_lshift_assign
l_int|1
suffix:semicolon
id|fnw
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|sz
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fnw
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
id|func_table
(braket
id|i
)braket
op_assign
id|fj
suffix:semicolon
r_if
c_cond
(paren
id|fj
OG
id|funcbufptr
)paren
id|memmove
c_func
(paren
id|fnw
comma
id|funcbufptr
comma
id|fj
op_minus
id|funcbufptr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|j
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|func_table
(braket
id|k
)braket
)paren
id|func_table
(braket
id|k
)braket
op_assign
id|fnw
op_plus
(paren
id|func_table
(braket
id|k
)braket
op_minus
id|funcbufptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|first_free
OG
id|fj
)paren
(brace
id|memmove
c_func
(paren
id|fnw
op_plus
(paren
id|fj
op_minus
id|funcbufptr
)paren
op_plus
id|delta
comma
id|fj
comma
id|first_free
op_minus
id|fj
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
id|j
suffix:semicolon
id|k
OL
id|MAX_NR_FUNC
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
id|func_table
(braket
id|k
)braket
)paren
id|func_table
(braket
id|k
)braket
op_assign
id|fnw
op_plus
(paren
id|func_table
(braket
id|k
)braket
op_minus
id|funcbufptr
)paren
op_plus
id|delta
suffix:semicolon
)brace
r_if
c_cond
(paren
id|funcbufptr
op_ne
id|func_buf
)paren
id|kfree
c_func
(paren
id|funcbufptr
)paren
suffix:semicolon
id|funcbufptr
op_assign
id|fnw
suffix:semicolon
id|funcbufleft
op_assign
id|funcbufleft
op_minus
id|delta
op_plus
id|sz
op_minus
id|funcbufsize
suffix:semicolon
id|funcbufsize
op_assign
id|sz
suffix:semicolon
)brace
id|strcpy
c_func
(paren
id|func_table
(braket
id|i
)braket
comma
id|tmp.kb_string
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|do_fontx_ioctl
id|do_fontx_ioctl
c_func
(paren
r_int
id|cmd
comma
r_struct
id|consolefontdesc
op_star
id|user_cfd
comma
r_int
id|perm
)paren
(brace
r_struct
id|consolefontdesc
id|cfdarg
suffix:semicolon
r_struct
id|console_font_op
id|op
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|cfdarg
comma
id|user_cfd
comma
r_sizeof
(paren
r_struct
id|consolefontdesc
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PIO_FONTX
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|op.op
op_assign
id|KD_FONT_OP_SET
suffix:semicolon
id|op.flags
op_assign
id|KD_FONT_FLAG_OLD
suffix:semicolon
id|op.width
op_assign
l_int|8
suffix:semicolon
id|op.height
op_assign
id|cfdarg.charheight
suffix:semicolon
id|op.charcount
op_assign
id|cfdarg.charcount
suffix:semicolon
id|op.data
op_assign
id|cfdarg.chardata
suffix:semicolon
r_return
id|con_font_op
c_func
(paren
id|fg_console
comma
op_amp
id|op
)paren
suffix:semicolon
r_case
id|GIO_FONTX
suffix:colon
(brace
id|op.op
op_assign
id|KD_FONT_OP_GET
suffix:semicolon
id|op.flags
op_assign
id|KD_FONT_FLAG_OLD
suffix:semicolon
id|op.width
op_assign
l_int|8
suffix:semicolon
id|op.height
op_assign
id|cfdarg.charheight
suffix:semicolon
id|op.charcount
op_assign
id|cfdarg.charcount
suffix:semicolon
id|op.data
op_assign
id|cfdarg.chardata
suffix:semicolon
id|i
op_assign
id|con_font_op
c_func
(paren
id|fg_console
comma
op_amp
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|cfdarg.charheight
op_assign
id|op.height
suffix:semicolon
id|cfdarg.charcount
op_assign
id|op.charcount
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|user_cfd
comma
op_amp
id|cfdarg
comma
r_sizeof
(paren
r_struct
id|consolefontdesc
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|do_unimap_ioctl
id|do_unimap_ioctl
c_func
(paren
r_int
id|cmd
comma
r_struct
id|unimapdesc
op_star
id|user_ud
comma
r_int
id|perm
)paren
(brace
r_struct
id|unimapdesc
id|tmp
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
id|user_ud
comma
r_sizeof
id|tmp
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|tmp.entries
)paren
(brace
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|tmp.entries
comma
id|tmp.entry_ct
op_star
r_sizeof
(paren
r_struct
id|unipair
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|PIO_UNIMAP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|con_set_unimap
c_func
(paren
id|fg_console
comma
id|tmp.entry_ct
comma
id|tmp.entries
)paren
suffix:semicolon
r_case
id|GIO_UNIMAP
suffix:colon
r_return
id|con_get_unimap
c_func
(paren
id|fg_console
comma
id|tmp.entry_ct
comma
op_amp
(paren
id|user_ud-&gt;entry_ct
)paren
comma
id|tmp.entries
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * We handle the console-specific ioctl&squot;s here.  We allow the&n; * capability to modify any console, not just the fg_console. &n; */
DECL|function|vt_ioctl
r_int
id|vt_ioctl
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|i
comma
id|perm
suffix:semicolon
r_int
r_int
id|console
suffix:semicolon
r_int
r_char
id|ucval
suffix:semicolon
r_struct
id|kbd_struct
op_star
id|kbd
suffix:semicolon
r_struct
id|vt_struct
op_star
id|vt
op_assign
(paren
r_struct
id|vt_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|console
op_assign
id|vt-&gt;vc_num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|console
)paren
)paren
multiline_comment|/* impossible? */
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
multiline_comment|/*&n;&t; * To have permissions to do most of the vt ioctls, we either have&n;&t; * to be the owner of the tty, or super-user.&n;&t; */
id|perm
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;tty
op_eq
id|tty
op_logical_or
id|suser
c_func
(paren
)paren
)paren
id|perm
op_assign
l_int|1
suffix:semicolon
id|kbd
op_assign
id|kbd_table
op_plus
id|console
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|KIOCSOUND
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
id|arg
op_assign
l_int|1193180
op_div
id|arg
suffix:semicolon
id|kd_mksound
c_func
(paren
id|arg
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|KDMKTONE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
(brace
r_int
r_int
id|ticks
comma
id|count
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Generate the tone for the appropriate number of ticks.&n;&t;&t; * If the time is zero, turn off sound ourselves.&n;&t;&t; */
id|ticks
op_assign
id|HZ
op_star
(paren
(paren
id|arg
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
)paren
op_div
l_int|1000
suffix:semicolon
id|count
op_assign
id|ticks
ques
c_cond
(paren
id|arg
op_amp
l_int|0xffff
)paren
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
id|count
op_assign
l_int|1193180
op_div
id|count
suffix:semicolon
id|kd_mksound
c_func
(paren
id|count
comma
id|ticks
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDGKBTYPE
suffix:colon
multiline_comment|/*&n;&t;&t; * this is naive.&n;&t;&t; */
id|ucval
op_assign
id|keyboard_type
suffix:semicolon
r_goto
id|setchar
suffix:semicolon
macro_line|#if !defined(__alpha__) &amp;&amp; !defined(__ia64__) &amp;&amp; !defined(__mips__) &amp;&amp; !defined(__arm__) &amp;&amp; !defined(__sh__)
multiline_comment|/*&n;&t;&t; * These cannot be implemented on any machine that implements&n;&t;&t; * ioperm() in user level (such as Alpha PCs).&n;&t;&t; */
r_case
id|KDADDIO
suffix:colon
r_case
id|KDDELIO
suffix:colon
multiline_comment|/*&n;&t;&t; * KDADDIO and KDDELIO may be able to add ports beyond what&n;&t;&t; * we reject here, but to be safe...&n;&t;&t; */
r_if
c_cond
(paren
id|arg
template_param
id|GPLAST
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|sys_ioperm
c_func
(paren
id|arg
comma
l_int|1
comma
(paren
id|cmd
op_eq
id|KDADDIO
)paren
)paren
ques
c_cond
op_minus
id|ENXIO
suffix:colon
l_int|0
suffix:semicolon
r_case
id|KDENABIO
suffix:colon
r_case
id|KDDISABIO
suffix:colon
r_return
id|sys_ioperm
c_func
(paren
id|GPFIRST
comma
id|GPNUM
comma
(paren
id|cmd
op_eq
id|KDENABIO
)paren
)paren
ques
c_cond
op_minus
id|ENXIO
suffix:colon
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#if defined(__mc68000__) || defined(CONFIG_APUS)
multiline_comment|/* Linux/m68k interface for setting the keyboard delay/repeat rate */
r_case
id|KDKBDREP
suffix:colon
(brace
r_struct
id|kbd_repeat
id|kbrep
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mach_kbdrate
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|kbrep
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|kbd_repeat
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|i
op_assign
id|mach_kbdrate
c_func
(paren
op_amp
id|kbrep
)paren
)paren
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|kbrep
comma
r_sizeof
(paren
r_struct
id|kbd_repeat
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_case
id|KDSETMODE
suffix:colon
multiline_comment|/*&n;&t;&t; * currently, setting the mode from KD_TEXT to KD_GRAPHICS&n;&t;&t; * doesn&squot;t do a whole lot. i&squot;m not sure if it should do any&n;&t;&t; * restoration of modes or what...&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|arg
)paren
(brace
r_case
id|KD_GRAPHICS
suffix:colon
r_break
suffix:semicolon
r_case
id|KD_TEXT0
suffix:colon
r_case
id|KD_TEXT1
suffix:colon
id|arg
op_assign
id|KD_TEXT
suffix:semicolon
r_case
id|KD_TEXT
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vc_mode
op_eq
(paren
r_int
r_char
)paren
id|arg
)paren
r_return
l_int|0
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vc_mode
op_assign
(paren
r_int
r_char
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|console
op_ne
id|fg_console
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t; * explicitly blank/unblank the screen if switching modes&n;&t;&t; */
r_if
c_cond
(paren
id|arg
op_eq
id|KD_TEXT
)paren
id|unblank_screen
c_func
(paren
)paren
suffix:semicolon
r_else
id|do_blank_screen
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|KDGETMODE
suffix:colon
id|ucval
op_assign
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vc_mode
suffix:semicolon
r_goto
id|setint
suffix:semicolon
r_case
id|KDMAPDISP
suffix:colon
r_case
id|KDUNMAPDISP
suffix:colon
multiline_comment|/*&n;&t;&t; * these work like a combination of mmap and KDENABIO.&n;&t;&t; * this could be easily finished.&n;&t;&t; */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|KDSKBMODE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|arg
)paren
(brace
r_case
id|K_RAW
suffix:colon
id|kbd-&gt;kbdmode
op_assign
id|VC_RAW
suffix:semicolon
r_break
suffix:semicolon
r_case
id|K_MEDIUMRAW
suffix:colon
id|kbd-&gt;kbdmode
op_assign
id|VC_MEDIUMRAW
suffix:semicolon
r_break
suffix:semicolon
r_case
id|K_XLATE
suffix:colon
id|kbd-&gt;kbdmode
op_assign
id|VC_XLATE
suffix:semicolon
id|compute_shiftstate
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|K_UNICODE
suffix:colon
id|kbd-&gt;kbdmode
op_assign
id|VC_UNICODE
suffix:semicolon
id|compute_shiftstate
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|KDGKBMODE
suffix:colon
id|ucval
op_assign
(paren
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_RAW
)paren
ques
c_cond
id|K_RAW
suffix:colon
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_MEDIUMRAW
)paren
ques
c_cond
id|K_MEDIUMRAW
suffix:colon
(paren
id|kbd-&gt;kbdmode
op_eq
id|VC_UNICODE
)paren
ques
c_cond
id|K_UNICODE
suffix:colon
id|K_XLATE
)paren
suffix:semicolon
r_goto
id|setint
suffix:semicolon
multiline_comment|/* this could be folded into KDSKBMODE, but for compatibility&n;&t;   reasons it is not so easy to fold KDGKBMETA into KDGKBMODE */
r_case
id|KDSKBMETA
suffix:colon
r_switch
c_cond
(paren
id|arg
)paren
(brace
r_case
id|K_METABIT
suffix:colon
id|clr_vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_META
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|K_ESCPREFIX
suffix:colon
id|set_vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_META
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|KDGKBMETA
suffix:colon
id|ucval
op_assign
(paren
id|vc_kbd_mode
c_func
(paren
id|kbd
comma
id|VC_META
)paren
ques
c_cond
id|K_ESCPREFIX
suffix:colon
id|K_METABIT
)paren
suffix:semicolon
id|setint
suffix:colon
r_return
id|put_user
c_func
(paren
id|ucval
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|KDGETKEYCODE
suffix:colon
r_case
id|KDSETKEYCODE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
id|perm
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|do_kbkeycode_ioctl
c_func
(paren
id|cmd
comma
(paren
r_struct
id|kbkeycode
op_star
)paren
id|arg
comma
id|perm
)paren
suffix:semicolon
r_case
id|KDGKBENT
suffix:colon
r_case
id|KDSKBENT
suffix:colon
r_return
id|do_kdsk_ioctl
c_func
(paren
id|cmd
comma
(paren
r_struct
id|kbentry
op_star
)paren
id|arg
comma
id|perm
comma
id|kbd
)paren
suffix:semicolon
r_case
id|KDGKBSENT
suffix:colon
r_case
id|KDSKBSENT
suffix:colon
r_return
id|do_kdgkb_ioctl
c_func
(paren
id|cmd
comma
(paren
r_struct
id|kbsentry
op_star
)paren
id|arg
comma
id|perm
)paren
suffix:semicolon
r_case
id|KDGKBDIACR
suffix:colon
(brace
r_struct
id|kbdiacrs
op_star
id|a
op_assign
(paren
r_struct
id|kbdiacrs
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|accent_table_size
comma
op_amp
id|a-&gt;kb_cnt
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|a-&gt;kbdiacr
comma
id|accent_table
comma
id|accent_table_size
op_star
r_sizeof
(paren
r_struct
id|kbdiacr
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|KDSKBDIACR
suffix:colon
(brace
r_struct
id|kbdiacrs
op_star
id|a
op_assign
(paren
r_struct
id|kbdiacrs
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|ct
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|ct
comma
op_amp
id|a-&gt;kb_cnt
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|ct
op_ge
id|MAX_DIACR
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|accent_table_size
op_assign
id|ct
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|accent_table
comma
id|a-&gt;kbdiacr
comma
id|ct
op_star
r_sizeof
(paren
r_struct
id|kbdiacr
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* the ioctls below read/set the flags usually shown in the leds */
multiline_comment|/* don&squot;t use them - they will go away without warning */
r_case
id|KDGKBLED
suffix:colon
id|ucval
op_assign
id|kbd-&gt;ledflagstate
op_or
(paren
id|kbd-&gt;default_ledflagstate
op_lshift
l_int|4
)paren
suffix:semicolon
r_goto
id|setchar
suffix:semicolon
r_case
id|KDSKBLED
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_amp
op_complement
l_int|0x77
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|kbd-&gt;ledflagstate
op_assign
(paren
id|arg
op_amp
l_int|7
)paren
suffix:semicolon
id|kbd-&gt;default_ledflagstate
op_assign
(paren
(paren
id|arg
op_rshift
l_int|4
)paren
op_amp
l_int|7
)paren
suffix:semicolon
id|set_leds
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* the ioctls below only set the lights, not the functions */
multiline_comment|/* for those, see KDGKBLED and KDSKBLED above */
r_case
id|KDGETLED
suffix:colon
id|ucval
op_assign
id|getledstate
c_func
(paren
)paren
suffix:semicolon
id|setchar
suffix:colon
r_return
id|put_user
c_func
(paren
id|ucval
comma
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|KDSETLED
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|setledstate
c_func
(paren
id|kbd
comma
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * A process can indicate its willingness to accept signals&n;&t; * generated by pressing an appropriate key combination.&n;&t; * Thus, one can have a daemon that e.g. spawns a new console&n;&t; * upon a keypress and then changes to it.&n;&t; * Probably init should be changed to do this (and have a&n;&t; * field ks (`keyboard signal&squot;) in inittab describing the&n;&t; * desired action), so that the number of background daemons&n;&t; * does not increase.&n;&t; */
r_case
id|KDSIGACCEPT
suffix:colon
(brace
r_extern
r_int
id|spawnpid
comma
id|spawnsig
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
op_logical_or
op_logical_neg
id|capable
c_func
(paren
id|CAP_KILL
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|arg
template_param
id|_NSIG
op_logical_or
id|arg
op_eq
id|SIGKILL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|spawnpid
op_assign
id|current-&gt;pid
suffix:semicolon
id|spawnsig
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VT_SETMODE
suffix:colon
(brace
r_struct
id|vt_mode
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|tmp
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|vt_mode
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|tmp.mode
op_ne
id|VT_AUTO
op_logical_and
id|tmp.mode
op_ne
id|VT_PROCESS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode
op_assign
id|tmp
suffix:semicolon
multiline_comment|/* the frsig is ignored, so we set it to 0 */
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode.frsig
op_assign
l_int|0
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_pid
op_assign
id|current-&gt;pid
suffix:semicolon
multiline_comment|/* no switch is required -- saw@shade.msu.ru */
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_newvt
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VT_GETMODE
suffix:colon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
(paren
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode
)paren
comma
r_sizeof
(paren
r_struct
id|vt_mode
)paren
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Returns global vt state. Note that VT 0 is always open, since&n;&t; * it&squot;s an alias for the current VT, and people can&squot;t use it here.&n;&t; * We cannot return state for more than 16 VTs, since v_state is short.&n;&t; */
r_case
id|VT_GETSTATE
suffix:colon
(brace
r_struct
id|vt_stat
op_star
id|vtstat
op_assign
(paren
r_struct
id|vt_stat
op_star
)paren
id|arg
suffix:semicolon
r_int
r_int
id|state
comma
id|mask
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|vtstat
comma
r_sizeof
(paren
r_struct
id|vt_stat
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|put_user
c_func
(paren
id|fg_console
op_plus
l_int|1
comma
op_amp
id|vtstat-&gt;v_active
)paren
suffix:semicolon
id|state
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* /dev/tty0 is always open */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|2
suffix:semicolon
id|i
OL
id|MAX_NR_CONSOLES
op_logical_and
id|mask
suffix:semicolon
op_increment
id|i
comma
id|mask
op_lshift_assign
l_int|1
)paren
r_if
c_cond
(paren
id|VT_IS_IN_USE
c_func
(paren
id|i
)paren
)paren
id|state
op_or_assign
id|mask
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|state
comma
op_amp
id|vtstat-&gt;v_state
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Returns the first available (non-opened) console.&n;&t; */
r_case
id|VT_OPENQRY
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NR_CONSOLES
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
op_logical_neg
id|VT_IS_IN_USE
c_func
(paren
id|i
)paren
)paren
r_break
suffix:semicolon
id|ucval
op_assign
id|i
OL
id|MAX_NR_CONSOLES
ques
c_cond
(paren
id|i
op_plus
l_int|1
)paren
suffix:colon
op_minus
l_int|1
suffix:semicolon
r_goto
id|setint
suffix:semicolon
multiline_comment|/*&n;&t; * ioctl(fd, VT_ACTIVATE, num) will cause us to switch to vt # num,&n;&t; * with num &gt;= 1 (switches to vt 0, our console, are not allowed, just&n;&t; * to preserve sanity).&n;&t; */
r_case
id|VT_ACTIVATE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
l_int|0
op_logical_or
id|arg
OG
id|MAX_NR_CONSOLES
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|arg
op_decrement
suffix:semicolon
id|i
op_assign
id|vc_allocate
c_func
(paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|set_console
c_func
(paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * wait until the specified VT has been activated&n;&t; */
r_case
id|VT_WAITACTIVE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
l_int|0
op_logical_or
id|arg
OG
id|MAX_NR_CONSOLES
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_return
id|vt_waitactive
c_func
(paren
id|arg
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If a vt is under process control, the kernel will not switch to it&n;&t; * immediately, but postpone the operation until the process calls this&n;&t; * ioctl, allowing the switch to complete.&n;&t; *&n;&t; * According to the X sources this is the behavior:&n;&t; *&t;0:&t;pending switch-from not OK&n;&t; *&t;1:&t;pending switch-from OK&n;&t; *&t;2:&t;completed switch-to OK&n;&t; */
r_case
id|VT_RELDISP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_mode.mode
op_ne
id|VT_PROCESS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Switching-from response&n;&t;&t; */
r_if
c_cond
(paren
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_newvt
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|arg
op_eq
l_int|0
)paren
multiline_comment|/*&n;&t;&t;&t;&t; * Switch disallowed, so forget we were trying&n;&t;&t;&t;&t; * to do it.&n;&t;&t;&t;&t; */
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_newvt
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The current vt has been released, so&n;&t;&t;&t;&t; * complete the switch.&n;&t;&t;&t;&t; */
r_int
id|newvt
op_assign
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_newvt
suffix:semicolon
id|vt_cons
(braket
id|console
)braket
op_member_access_from_pointer
id|vt_newvt
op_assign
op_minus
l_int|1
suffix:semicolon
id|i
op_assign
id|vc_allocate
c_func
(paren
id|newvt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * When we actually do the console switch,&n;&t;&t;&t;&t; * make sure we are atomic with respect to&n;&t;&t;&t;&t; * other console switches..&n;&t;&t;&t;&t; */
id|spin_lock_irq
c_func
(paren
op_amp
id|console_lock
)paren
suffix:semicolon
id|complete_change_console
c_func
(paren
id|newvt
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|console_lock
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Switched-to response&n;&t;&t; */
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * If it&squot;s just an ACK, ignore it&n;&t;&t;&t; */
r_if
c_cond
(paren
id|arg
op_ne
id|VT_ACKACQ
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;  * Disallocate memory associated to VT (but leave VT1)&n;&t;  */
r_case
id|VT_DISALLOCATE
suffix:colon
r_if
c_cond
(paren
id|arg
OG
id|MAX_NR_CONSOLES
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
l_int|0
)paren
(brace
multiline_comment|/* disallocate all unused consoles, but leave 0 */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|MAX_NR_CONSOLES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|VT_BUSY
c_func
(paren
id|i
)paren
)paren
id|vc_disallocate
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* disallocate a single console, if possible */
id|arg
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|VT_BUSY
c_func
(paren
id|arg
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
multiline_comment|/* leave 0 */
id|vc_disallocate
c_func
(paren
id|arg
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|VT_RESIZE
suffix:colon
(brace
r_struct
id|vt_sizes
op_star
id|vtsizes
op_assign
(paren
r_struct
id|vt_sizes
op_star
)paren
id|arg
suffix:semicolon
id|ushort
id|ll
comma
id|cc
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|vtsizes
comma
r_sizeof
(paren
r_struct
id|vt_sizes
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|get_user
c_func
(paren
id|ll
comma
op_amp
id|vtsizes-&gt;v_rows
)paren
suffix:semicolon
id|get_user
c_func
(paren
id|cc
comma
op_amp
id|vtsizes-&gt;v_cols
)paren
suffix:semicolon
r_return
id|vc_resize_all
c_func
(paren
id|ll
comma
id|cc
)paren
suffix:semicolon
)brace
r_case
id|VT_RESIZEX
suffix:colon
(brace
r_struct
id|vt_consize
op_star
id|vtconsize
op_assign
(paren
r_struct
id|vt_consize
op_star
)paren
id|arg
suffix:semicolon
id|ushort
id|ll
comma
id|cc
comma
id|vlin
comma
id|clin
comma
id|vcol
comma
id|ccol
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|vtconsize
comma
r_sizeof
(paren
r_struct
id|vt_consize
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|get_user
c_func
(paren
id|ll
comma
op_amp
id|vtconsize-&gt;v_rows
)paren
suffix:semicolon
id|get_user
c_func
(paren
id|cc
comma
op_amp
id|vtconsize-&gt;v_cols
)paren
suffix:semicolon
id|get_user
c_func
(paren
id|vlin
comma
op_amp
id|vtconsize-&gt;v_vlin
)paren
suffix:semicolon
id|get_user
c_func
(paren
id|clin
comma
op_amp
id|vtconsize-&gt;v_clin
)paren
suffix:semicolon
id|get_user
c_func
(paren
id|vcol
comma
op_amp
id|vtconsize-&gt;v_vcol
)paren
suffix:semicolon
id|get_user
c_func
(paren
id|ccol
comma
op_amp
id|vtconsize-&gt;v_ccol
)paren
suffix:semicolon
id|vlin
op_assign
id|vlin
ques
c_cond
id|vlin
suffix:colon
id|video_scan_lines
suffix:semicolon
r_if
c_cond
(paren
id|clin
)paren
(brace
r_if
c_cond
(paren
id|ll
)paren
(brace
r_if
c_cond
(paren
id|ll
op_ne
id|vlin
op_div
id|clin
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Parameters don&squot;t add up */
)brace
r_else
id|ll
op_assign
id|vlin
op_div
id|clin
suffix:semicolon
)brace
r_if
c_cond
(paren
id|vcol
op_logical_and
id|ccol
)paren
(brace
r_if
c_cond
(paren
id|cc
)paren
(brace
r_if
c_cond
(paren
id|cc
op_ne
id|vcol
op_div
id|ccol
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
id|cc
op_assign
id|vcol
op_div
id|ccol
suffix:semicolon
)brace
r_if
c_cond
(paren
id|clin
OG
l_int|32
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|vlin
)paren
id|video_scan_lines
op_assign
id|vlin
suffix:semicolon
r_if
c_cond
(paren
id|clin
)paren
id|video_font_height
op_assign
id|clin
suffix:semicolon
r_return
id|vc_resize_all
c_func
(paren
id|ll
comma
id|cc
)paren
suffix:semicolon
)brace
r_case
id|PIO_FONT
suffix:colon
(brace
r_struct
id|console_font_op
id|op
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|op.op
op_assign
id|KD_FONT_OP_SET
suffix:semicolon
id|op.flags
op_assign
id|KD_FONT_FLAG_OLD
op_or
id|KD_FONT_FLAG_DONT_RECALC
suffix:semicolon
multiline_comment|/* Compatibility */
id|op.width
op_assign
l_int|8
suffix:semicolon
id|op.height
op_assign
l_int|0
suffix:semicolon
id|op.charcount
op_assign
l_int|256
suffix:semicolon
id|op.data
op_assign
(paren
r_char
op_star
)paren
id|arg
suffix:semicolon
r_return
id|con_font_op
c_func
(paren
id|fg_console
comma
op_amp
id|op
)paren
suffix:semicolon
)brace
r_case
id|GIO_FONT
suffix:colon
(brace
r_struct
id|console_font_op
id|op
suffix:semicolon
id|op.op
op_assign
id|KD_FONT_OP_GET
suffix:semicolon
id|op.flags
op_assign
id|KD_FONT_FLAG_OLD
suffix:semicolon
id|op.width
op_assign
l_int|8
suffix:semicolon
id|op.height
op_assign
l_int|32
suffix:semicolon
id|op.charcount
op_assign
l_int|256
suffix:semicolon
id|op.data
op_assign
(paren
r_char
op_star
)paren
id|arg
suffix:semicolon
r_return
id|con_font_op
c_func
(paren
id|fg_console
comma
op_amp
id|op
)paren
suffix:semicolon
)brace
r_case
id|PIO_CMAP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|con_set_cmap
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|GIO_CMAP
suffix:colon
r_return
id|con_get_cmap
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|PIO_FONTX
suffix:colon
r_case
id|GIO_FONTX
suffix:colon
r_return
id|do_fontx_ioctl
c_func
(paren
id|cmd
comma
(paren
r_struct
id|consolefontdesc
op_star
)paren
id|arg
comma
id|perm
)paren
suffix:semicolon
r_case
id|PIO_FONTRESET
suffix:colon
(brace
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
macro_line|#ifdef BROKEN_GRAPHICS_PROGRAMS
multiline_comment|/* With BROKEN_GRAPHICS_PROGRAMS defined, the default&n;&t;&t;   font is not saved. */
r_return
op_minus
id|ENOSYS
suffix:semicolon
macro_line|#else
(brace
r_struct
id|console_font_op
id|op
suffix:semicolon
id|op.op
op_assign
id|KD_FONT_OP_SET_DEFAULT
suffix:semicolon
id|op.data
op_assign
l_int|NULL
suffix:semicolon
id|i
op_assign
id|con_font_op
c_func
(paren
id|fg_console
comma
op_amp
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|con_set_default_unimap
c_func
(paren
id|fg_console
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
)brace
r_case
id|KDFONTOP
suffix:colon
(brace
r_struct
id|console_font_op
id|op
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|op
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|op
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
op_logical_and
id|op.op
op_ne
id|KD_FONT_OP_GET
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|con_font_op
c_func
(paren
id|console
comma
op_amp
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|op
comma
r_sizeof
(paren
id|op
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|PIO_SCRNMAP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|con_set_trans_old
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|GIO_SCRNMAP
suffix:colon
r_return
id|con_get_trans_old
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|PIO_UNISCRNMAP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|con_set_trans_new
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|GIO_UNISCRNMAP
suffix:colon
r_return
id|con_get_trans_new
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|PIO_UNIMAPCLR
suffix:colon
(brace
r_struct
id|unimapinit
id|ui
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|copy_from_user
c_func
(paren
op_amp
id|ui
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|unimapinit
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|con_clear_unimap
c_func
(paren
id|fg_console
comma
op_amp
id|ui
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|PIO_UNIMAP
suffix:colon
r_case
id|GIO_UNIMAP
suffix:colon
r_return
id|do_unimap_ioctl
c_func
(paren
id|cmd
comma
(paren
r_struct
id|unimapdesc
op_star
)paren
id|arg
comma
id|perm
)paren
suffix:semicolon
r_case
id|VT_LOCKSWITCH
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|vt_dont_switch
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|VT_UNLOCKSWITCH
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|vt_dont_switch
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_FB_COMPAT_XPMAC
r_case
id|VC_GETMODE
suffix:colon
(brace
r_struct
id|vc_mode
id|mode
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|vc_mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
l_int|0
)paren
id|i
op_assign
id|console_getmode
c_func
(paren
op_amp
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|mode
comma
r_sizeof
(paren
id|mode
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|VC_SETMODE
suffix:colon
r_case
id|VC_INQMODE
suffix:colon
(brace
r_struct
id|vc_mode
id|mode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|vc_mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|mode
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|mode
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|console_setmode
c_func
(paren
op_amp
id|mode
comma
id|cmd
op_eq
id|VC_SETMODE
)paren
suffix:semicolon
)brace
r_case
id|VC_SETCMAP
suffix:colon
(brace
r_int
r_char
id|cmap
(braket
l_int|3
)braket
(braket
l_int|256
)braket
comma
op_star
id|p
suffix:semicolon
r_int
id|n_entries
comma
id|cmap_size
comma
id|i
comma
id|j
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
(paren
r_int
r_int
)paren
id|VC_POWERMODE_INQUIRY
op_logical_or
id|arg
op_le
id|VESA_POWERDOWN
)paren
(brace
multiline_comment|/* compatibility hack: VC_POWERMODE&n;&t;&t;&t;&t;   was changed from 0x766a to 0x766c */
r_return
id|console_powermode
c_func
(paren
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
)brace
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|cmap_size
comma
(paren
r_int
op_star
)paren
id|arg
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|cmap_size
op_mod
l_int|3
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|n_entries
op_assign
id|cmap_size
op_div
l_int|3
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|n_entries
OG
l_int|256
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|p
op_assign
(paren
r_int
r_char
op_star
)paren
(paren
id|arg
op_plus
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|n_entries
suffix:semicolon
op_increment
id|j
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|cmap
(braket
id|i
)braket
(braket
id|j
)braket
comma
id|p
op_increment
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|console_setcmap
c_func
(paren
id|n_entries
comma
id|cmap
(braket
l_int|0
)braket
comma
id|cmap
(braket
l_int|1
)braket
comma
id|cmap
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
r_case
id|VC_GETCMAP
suffix:colon
multiline_comment|/* not implemented yet */
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
r_case
id|VC_POWERMODE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|perm
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
id|console_powermode
c_func
(paren
(paren
r_int
)paren
id|arg
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_FB_COMPAT_XPMAC */
r_default
suffix:colon
r_return
op_minus
id|ENOIOCTLCMD
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Sometimes we want to wait until a particular VT has been activated. We&n; * do it in a very simple manner. Everybody waits on a single queue and&n; * get woken up at once. Those that are satisfied go on with their business,&n; * while those not ready go back to sleep. Seems overkill to add a wait&n; * to each vt just for this - usually this does nothing!&n; */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|vt_activate_queue
)paren
suffix:semicolon
multiline_comment|/*&n; * Sleeps until a vt is activated, or the task is interrupted. Returns&n; * 0 if activation, -EINTR if interrupted.&n; */
DECL|function|vt_waitactive
r_int
id|vt_waitactive
c_func
(paren
r_int
id|vt
)paren
(brace
r_int
id|retval
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|vt_activate_queue
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|vt
op_eq
id|fg_console
)paren
r_break
suffix:semicolon
id|retval
op_assign
op_minus
id|EINTR
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|vt_activate_queue
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|macro|vt_wake_waitactive
mdefine_line|#define vt_wake_waitactive() wake_up(&amp;vt_activate_queue)
DECL|function|reset_vc
r_void
id|reset_vc
c_func
(paren
r_int
r_int
id|new_console
)paren
(brace
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vc_mode
op_assign
id|KD_TEXT
suffix:semicolon
id|kbd_table
(braket
id|new_console
)braket
dot
id|kbdmode
op_assign
id|VC_XLATE
suffix:semicolon
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_mode.mode
op_assign
id|VT_AUTO
suffix:semicolon
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_mode.waitv
op_assign
l_int|0
suffix:semicolon
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_mode.relsig
op_assign
l_int|0
suffix:semicolon
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_mode.acqsig
op_assign
l_int|0
suffix:semicolon
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_mode.frsig
op_assign
l_int|0
suffix:semicolon
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_pid
op_assign
op_minus
l_int|1
suffix:semicolon
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_newvt
op_assign
op_minus
l_int|1
suffix:semicolon
id|reset_palette
(paren
id|new_console
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Performs the back end of a vt switch&n; */
DECL|function|complete_change_console
r_void
id|complete_change_console
c_func
(paren
r_int
r_int
id|new_console
)paren
(brace
r_int
r_char
id|old_vc_mode
suffix:semicolon
id|last_console
op_assign
id|fg_console
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re switching, we could be going from KD_GRAPHICS to&n;&t; * KD_TEXT mode or vice versa, which means we need to blank or&n;&t; * unblank the screen later.&n;&t; */
id|old_vc_mode
op_assign
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vc_mode
suffix:semicolon
id|switch_screen
c_func
(paren
id|new_console
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this new console is under process control, send it a signal&n;&t; * telling it that it has acquired. Also check if it has died and&n;&t; * clean up (similar to logic employed in change_console())&n;&t; */
r_if
c_cond
(paren
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_mode.mode
op_eq
id|VT_PROCESS
)paren
(brace
multiline_comment|/*&n;&t;&t; * Send the signal as privileged - kill_proc() will&n;&t;&t; * tell us if the process has gone or something else&n;&t;&t; * is awry&n;&t;&t; */
r_if
c_cond
(paren
id|kill_proc
c_func
(paren
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_pid
comma
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_mode.acqsig
comma
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The controlling process has died, so we revert back to&n;&t;&t; * normal operation. In this case, we&squot;ll also change back&n;&t;&t; * to KD_TEXT mode. I&squot;m not sure if this is strictly correct&n;&t;&t; * but it saves the agony when the X server dies and the screen&n;&t;&t; * remains blanked due to KD_GRAPHICS! It would be nice to do&n;&t;&t; * this outside of VT_PROCESS but there is no single process&n;&t;&t; * to account for and tracking tty count may be undesirable.&n;&t;&t; */
id|reset_vc
c_func
(paren
id|new_console
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * We do this here because the controlling process above may have&n;&t; * gone, and so there is now a new vc_mode&n;&t; */
r_if
c_cond
(paren
id|old_vc_mode
op_ne
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vc_mode
)paren
(brace
r_if
c_cond
(paren
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vc_mode
op_eq
id|KD_TEXT
)paren
id|unblank_screen
c_func
(paren
)paren
suffix:semicolon
r_else
id|do_blank_screen
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Wake anyone waiting for their VT to activate&n;&t; */
id|vt_wake_waitactive
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Performs the front-end of a vt switch&n; */
DECL|function|change_console
r_void
id|change_console
c_func
(paren
r_int
r_int
id|new_console
)paren
(brace
r_if
c_cond
(paren
(paren
id|new_console
op_eq
id|fg_console
)paren
op_logical_or
(paren
id|vt_dont_switch
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|new_console
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If this vt is in process mode, then we need to handshake with&n;&t; * that process before switching. Essentially, we store where that&n;&t; * vt wants to switch to and wait for it to tell us when it&squot;s done&n;&t; * (via VT_RELDISP ioctl).&n;&t; *&n;&t; * We also check to see if the controlling process still exists.&n;&t; * If it doesn&squot;t, we reset this vt to auto mode and continue.&n;&t; * This is a cheap way to track process control. The worst thing&n;&t; * that can happen is: we send a signal to a process, it dies, and&n;&t; * the switch gets &quot;lost&quot; waiting for a response; hopefully, the&n;&t; * user will try again, we&squot;ll detect the process is gone (unless&n;&t; * the user waits just the right amount of time :-) and revert the&n;&t; * vt to auto control.&n;&t; */
r_if
c_cond
(paren
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vt_mode.mode
op_eq
id|VT_PROCESS
)paren
(brace
multiline_comment|/*&n;&t;&t; * Send the signal as privileged - kill_proc() will&n;&t;&t; * tell us if the process has gone or something else&n;&t;&t; * is awry&n;&t;&t; */
r_if
c_cond
(paren
id|kill_proc
c_func
(paren
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vt_pid
comma
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vt_mode.relsig
comma
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * It worked. Mark the vt to switch to and&n;&t;&t;&t; * return. The process needs to send us a&n;&t;&t;&t; * VT_RELDISP ioctl to complete the switch.&n;&t;&t;&t; */
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vt_newvt
op_assign
id|new_console
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The controlling process has died, so we revert back to&n;&t;&t; * normal operation. In this case, we&squot;ll also change back&n;&t;&t; * to KD_TEXT mode. I&squot;m not sure if this is strictly correct&n;&t;&t; * but it saves the agony when the X server dies and the screen&n;&t;&t; * remains blanked due to KD_GRAPHICS! It would be nice to do&n;&t;&t; * this outside of VT_PROCESS but there is no single process&n;&t;&t; * to account for and tracking tty count may be undesirable.&n;&t;&t; */
id|reset_vc
c_func
(paren
id|fg_console
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fall through to normal (VT_AUTO) handling of the switch...&n;&t;&t; */
)brace
multiline_comment|/*&n;&t; * Ignore all switches in KD_GRAPHICS+VT_AUTO mode&n;&t; */
r_if
c_cond
(paren
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vc_mode
op_eq
id|KD_GRAPHICS
)paren
r_return
suffix:semicolon
id|complete_change_console
c_func
(paren
id|new_console
)paren
suffix:semicolon
)brace
eof
