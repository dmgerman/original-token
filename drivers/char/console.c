multiline_comment|/*&n; *  linux/drivers/char/console.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; *&t;console.c&n; *&n; * This module exports the console io functions:&n; *&n; *     &squot;void do_keyboard_interrupt(void)&squot;&n; *&n; *     &squot;int vc_allocate(unsigned int console)&squot;&n; *     &squot;int vc_cons_allocated(unsigned int console)&squot;&n; *     &squot;int vc_resize(unsigned long lines, unsigned long cols)&squot;&n; *     &squot;void vc_disallocate(unsigned int currcons)&squot;&n; *&n; *     &squot;unsigned long con_init(unsigned long)&squot;&n; *     &squot;int con_open(struct tty_struct *tty, struct file * filp)&squot;&n; *     &squot;void con_write(struct tty_struct * tty)&squot;&n; *     &squot;void console_print(const char * b)&squot;&n; *     &squot;void update_screen(int new_console)&squot;&n; *&n; *     &squot;void do_blank_screen(int)&squot;&n; *     &squot;void do_unblank_screen(void)&squot;&n; *     &squot;void poke_blanked_console(void)&squot;&n; *&n; *     &squot;unsigned short *screen_pos(int currcons, int w_offset, int viewed)&squot;&n; *     &squot;void complement_pos(int currcons, int offset)&squot;&n; *     &squot;void invert_screen(int currcons, int offset, int count, int shift)&squot;&n; *&n; *     &squot;void scrollback(int lines)&squot;&n; *     &squot;void scrollfront(int lines)&squot;&n; *&n; *     &squot;void mouse_report(struct tty_struct * tty, int butt, int mrx, int mry)&squot;&n; *     &squot;int mouse_reporting(void)&squot;&n; *&n; * Hopefully this will be a rather complete VT102 implementation.&n; *&n; * Beeping thanks to John T Kohl.&n; *&n; * Virtual Consoles, Screen Blanking, Screen Dumping, Color, Graphics&n; *   Chars, and VT100 enhancements by Peter MacDonald.&n; *&n; * Copy and paste function by Andrew Haylett,&n; *   some enhancements by Alessandro Rubini.&n; *&n; * Code to check for different video-cards mostly by Galen Hunt,&n; * &lt;g-hunt@ee.utah.edu&gt;&n; *&n; * Rudimentary ISO 10646/Unicode/UTF-8 character set support by&n; * Markus Kuhn, &lt;mskuhn@immd4.informatik.uni-erlangen.de&gt;.&n; *&n; * Dynamic allocation of consoles, aeb@cwi.nl, May 1994&n; * Resizing of consoles, aeb, 940926&n; *&n; * Code for xterm like mouse click reporting by Peter Orbaek 20-Jul-94&n; * &lt;poe@daimi.aau.dk&gt;&n; *&n; * User-defined bell sound, new setterm control sequences and printk&n; * redirection by Martin Mares &lt;mj@k332.feld.cvut.cz&gt; 19-Nov-95&n; *&n; */
DECL|macro|BLANK
mdefine_line|#define BLANK 0x0020
multiline_comment|/* A bitmap for codes &lt;32. A bit of 1 indicates that the code&n; * corresponding to that bit number invokes some special action&n; * (such as cursor movement) and should not be displayed as a&n; * glyph unless the disp_ctrl mode is explicitly enabled.&n; */
DECL|macro|CTRL_ACTION
mdefine_line|#define CTRL_ACTION 0x0d00ff81
DECL|macro|CTRL_ALWAYS
mdefine_line|#define CTRL_ALWAYS 0x0800f501&t;/* Cannot be overridden by disp_ctrl */
multiline_comment|/*&n; * Here is the default bell parameters: 750HZ, 1/8th of a second&n; */
DECL|macro|DEFAULT_BELL_PITCH
mdefine_line|#define DEFAULT_BELL_PITCH&t;750
DECL|macro|DEFAULT_BELL_DURATION
mdefine_line|#define DEFAULT_BELL_DURATION&t;(HZ/8)
multiline_comment|/*&n; *  NOTE!!! We sometimes disable and enable interrupts for a short while&n; * (to put a word in video IO), but this will work even for keyboard&n; * interrupts. We know interrupts aren&squot;t enabled when getting a keyboard&n; * interrupt, as we use trap-gates. Hopefully all is well.&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/kd.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#ifdef CONFIG_APM
macro_line|#include &lt;linux/apm_bios.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &quot;kbd_kern.h&quot;
macro_line|#include &quot;vt_kern.h&quot;
macro_line|#include &quot;consolemap.h&quot;
macro_line|#include &quot;selection.h&quot;
macro_line|#include &quot;console_struct.h&quot;
macro_line|#ifndef MIN
DECL|macro|MIN
mdefine_line|#define MIN(a,b)&t;((a) &lt; (b) ? (a) : (b))
macro_line|#endif
DECL|variable|console_driver
r_struct
id|tty_driver
id|console_driver
suffix:semicolon
DECL|variable|console_refcount
r_static
r_int
id|console_refcount
suffix:semicolon
DECL|variable|console_table
r_static
r_struct
id|tty_struct
op_star
id|console_table
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
DECL|variable|console_termios
r_static
r_struct
id|termios
op_star
id|console_termios
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
DECL|variable|console_termios_locked
r_static
r_struct
id|termios
op_star
id|console_termios_locked
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
DECL|variable|vc_scrbuf
r_int
r_int
op_star
id|vc_scrbuf
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
DECL|variable|vc_cons
r_struct
id|vc
id|vc_cons
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
r_static
r_void
id|con_setsize
c_func
(paren
r_int
r_int
id|rows
comma
r_int
r_int
id|cols
)paren
suffix:semicolon
r_static
r_void
id|vc_init
c_func
(paren
r_int
r_int
id|console
comma
r_int
r_int
id|rows
comma
r_int
r_int
id|cols
comma
r_int
id|do_clear
)paren
suffix:semicolon
r_extern
r_void
id|get_scrmem
c_func
(paren
r_int
id|currcons
)paren
suffix:semicolon
r_extern
r_void
id|set_scrmem
c_func
(paren
r_int
id|currcons
comma
r_int
id|offset
)paren
suffix:semicolon
r_static
r_void
id|set_origin
c_func
(paren
r_int
id|currcons
)paren
suffix:semicolon
r_static
r_void
id|blank_screen
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|unblank_screen
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|change_console
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_extern
r_void
id|poke_blanked_console
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|gotoxy
c_func
(paren
r_int
id|currcons
comma
r_int
id|new_x
comma
r_int
id|new_y
)paren
suffix:semicolon
r_static
r_void
id|save_cur
c_func
(paren
r_int
id|currcons
)paren
suffix:semicolon
r_extern
r_void
id|set_cursor
c_func
(paren
r_int
id|currcons
)paren
suffix:semicolon
r_extern
r_void
id|hide_cursor
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|reset_terminal
c_func
(paren
r_int
id|currcons
comma
r_int
id|do_clear
)paren
suffix:semicolon
r_extern
r_void
id|reset_vc
c_func
(paren
r_int
r_int
id|new_console
)paren
suffix:semicolon
r_extern
r_void
id|vt_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|register_console
c_func
(paren
r_void
(paren
op_star
id|proc
)paren
(paren
r_const
r_char
op_star
)paren
)paren
suffix:semicolon
r_extern
r_void
id|vesa_blank
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|vesa_unblank
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|vesa_powerdown
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|compute_shiftstate
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|reset_palette
c_func
(paren
r_int
id|currcons
)paren
suffix:semicolon
r_extern
r_void
id|set_palette
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
r_int
id|con_type_init
c_func
(paren
r_int
r_int
comma
r_const
r_char
op_star
op_star
)paren
suffix:semicolon
r_extern
r_int
id|set_get_cmap
c_func
(paren
r_int
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_extern
r_int
id|set_get_font
c_func
(paren
r_int
r_char
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* Description of the hardware situation */
DECL|variable|video_type
r_int
r_char
id|video_type
suffix:semicolon
multiline_comment|/* Type of display being used&t;*/
DECL|variable|video_mem_base
r_int
r_int
id|video_mem_base
suffix:semicolon
multiline_comment|/* Base of video memory&t;&t;*/
DECL|variable|video_mem_term
r_int
r_int
id|video_mem_term
suffix:semicolon
multiline_comment|/* End of video memory&t;&t;*/
DECL|variable|video_port_reg
r_int
r_int
id|video_port_reg
suffix:semicolon
multiline_comment|/* Video register select port&t;*/
DECL|variable|video_port_val
r_int
r_int
id|video_port_val
suffix:semicolon
multiline_comment|/* Video register value port&t;*/
DECL|variable|video_num_columns
r_int
r_int
id|video_num_columns
suffix:semicolon
multiline_comment|/* Number of text columns&t;*/
DECL|variable|video_num_lines
r_int
r_int
id|video_num_lines
suffix:semicolon
multiline_comment|/* Number of text lines&t;&t;*/
DECL|variable|video_size_row
r_int
r_int
id|video_size_row
suffix:semicolon
DECL|variable|video_screen_size
r_int
r_int
id|video_screen_size
suffix:semicolon
DECL|variable|can_do_color
r_int
id|can_do_color
op_assign
l_int|0
suffix:semicolon
DECL|variable|printable
r_static
r_int
id|printable
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is console ready for printing? */
DECL|variable|video_mode_512ch
r_int
id|video_mode_512ch
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 512-character mode */
DECL|variable|video_font_height
r_int
r_int
id|video_font_height
suffix:semicolon
multiline_comment|/* Height of current screen font */
DECL|variable|video_scan_lines
r_int
r_int
id|video_scan_lines
suffix:semicolon
multiline_comment|/* Number of scan lines on screen */
DECL|variable|default_font_height
r_int
r_int
id|default_font_height
suffix:semicolon
multiline_comment|/* Height of default screen font */
DECL|variable|video_font_is_default
r_int
id|video_font_is_default
op_assign
l_int|1
suffix:semicolon
DECL|variable|console_charmask
r_static
r_int
r_int
id|console_charmask
op_assign
l_int|0x0ff
suffix:semicolon
multiline_comment|/* used by kbd_bh - set by keyboard_interrupt */
DECL|variable|do_poke_blanked_console
r_int
id|do_poke_blanked_console
op_assign
l_int|0
suffix:semicolon
DECL|variable|console_blanked
r_int
id|console_blanked
op_assign
l_int|0
suffix:semicolon
DECL|variable|blankinterval
r_static
r_int
id|blankinterval
op_assign
l_int|10
op_star
l_int|60
op_star
id|HZ
suffix:semicolon
DECL|variable|vesa_off_interval
r_static
r_int
id|vesa_off_interval
op_assign
l_int|0
suffix:semicolon
DECL|variable|blank_origin
DECL|variable|blank__origin
DECL|variable|unblank_origin
r_static
r_int
id|blank_origin
comma
id|blank__origin
comma
id|unblank_origin
suffix:semicolon
macro_line|#ifdef CONFIG_SERIAL_ECHO
macro_line|#include &lt;linux/serial_reg.h&gt;
r_extern
r_int
id|serial_echo_init
(paren
r_int
id|base
)paren
suffix:semicolon
r_extern
r_int
id|serial_echo_print
(paren
r_const
r_char
op_star
id|s
)paren
suffix:semicolon
multiline_comment|/*&n; * this defines the address for the port to which printk echoing is done&n; *  when CONFIG_SERIAL_ECHO is defined&n; */
DECL|macro|SERIAL_ECHO_PORT
mdefine_line|#define SERIAL_ECHO_PORT&t;0x3f8&t;/* COM1 */
DECL|variable|serial_echo_port
r_static
r_int
id|serial_echo_port
op_assign
l_int|0
suffix:semicolon
DECL|macro|serial_echo_outb
mdefine_line|#define serial_echo_outb(v,a) outb((v),(a)+serial_echo_port)
DECL|macro|serial_echo_inb
mdefine_line|#define serial_echo_inb(a)    inb((a)+serial_echo_port)
DECL|macro|BOTH_EMPTY
mdefine_line|#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
multiline_comment|/* Wait for transmitter &amp; holding register to empty */
DECL|macro|WAIT_FOR_XMITR
mdefine_line|#define WAIT_FOR_XMITR &bslash;&n; do { &bslash;&n;       lsr = serial_echo_inb(UART_LSR); &bslash;&n; } while ((lsr &amp; BOTH_EMPTY) != BOTH_EMPTY)
multiline_comment|/* These two functions abstract the actual communications with the&n; * debug port.&t;This is so we can change the underlying communications&n; * mechanism without modifying the rest of the code.&n; */
r_int
DECL|function|serial_echo_print
id|serial_echo_print
c_func
(paren
r_const
r_char
op_star
id|s
)paren
(brace
r_int
id|lsr
comma
id|ier
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|serial_echo_port
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First save the IER then disable the interrupts&n;&t; */
id|ier
op_assign
id|serial_echo_inb
c_func
(paren
id|UART_IER
)paren
suffix:semicolon
id|serial_echo_outb
c_func
(paren
l_int|0x00
comma
id|UART_IER
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now, do each character&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|s
suffix:semicolon
id|i
op_increment
comma
id|s
op_increment
)paren
(brace
id|WAIT_FOR_XMITR
suffix:semicolon
multiline_comment|/* Send the character out. */
id|serial_echo_outb
c_func
(paren
op_star
id|s
comma
id|UART_TX
)paren
suffix:semicolon
multiline_comment|/* if a LF, also do CR... */
r_if
c_cond
(paren
op_star
id|s
op_eq
l_int|10
)paren
(brace
id|WAIT_FOR_XMITR
suffix:semicolon
id|serial_echo_outb
c_func
(paren
l_int|13
comma
id|UART_TX
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Finally, Wait for transmitter &amp; holding register to empty&n;&t; *  and restore the IER&n;&t; */
r_do
(brace
id|lsr
op_assign
id|serial_echo_inb
c_func
(paren
id|UART_LSR
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|lsr
op_amp
id|BOTH_EMPTY
)paren
op_ne
id|BOTH_EMPTY
)paren
suffix:semicolon
id|serial_echo_outb
c_func
(paren
id|ier
comma
id|UART_IER
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_int
DECL|function|serial_echo_init
id|serial_echo_init
c_func
(paren
r_int
id|base
)paren
(brace
r_int
id|comstat
comma
id|hi
comma
id|lo
suffix:semicolon
r_if
c_cond
(paren
id|base
op_ne
l_int|0x2f8
op_logical_and
id|base
op_ne
l_int|0x3f8
)paren
(brace
id|serial_echo_port
op_assign
l_int|0
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
id|serial_echo_port
op_assign
id|base
suffix:semicolon
multiline_comment|/*&n;&t; * read the Divisor Latch&n;&t; */
id|comstat
op_assign
id|serial_echo_inb
c_func
(paren
id|UART_LCR
)paren
suffix:semicolon
id|serial_echo_outb
c_func
(paren
id|comstat
op_or
id|UART_LCR_DLAB
comma
id|UART_LCR
)paren
suffix:semicolon
id|hi
op_assign
id|serial_echo_inb
c_func
(paren
id|UART_DLM
)paren
suffix:semicolon
id|lo
op_assign
id|serial_echo_inb
c_func
(paren
id|UART_DLL
)paren
suffix:semicolon
id|serial_echo_outb
c_func
(paren
id|comstat
comma
id|UART_LCR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * now do hardwired init&n;&t; */
id|serial_echo_outb
c_func
(paren
l_int|0x03
comma
id|UART_LCR
)paren
suffix:semicolon
multiline_comment|/* No parity, 8 data bits, 1 stop */
id|serial_echo_outb
c_func
(paren
l_int|0x83
comma
id|UART_LCR
)paren
suffix:semicolon
multiline_comment|/* Access divisor latch */
id|serial_echo_outb
c_func
(paren
l_int|0x00
comma
id|UART_DLM
)paren
suffix:semicolon
multiline_comment|/* 9600 baud */
id|serial_echo_outb
c_func
(paren
l_int|0x0c
comma
id|UART_DLL
)paren
suffix:semicolon
id|serial_echo_outb
c_func
(paren
l_int|0x03
comma
id|UART_LCR
)paren
suffix:semicolon
multiline_comment|/* Done with divisor */
multiline_comment|/* Prior to disabling interrupts, read the LSR and RBR&n;&t; * registers&n;&t; */
id|comstat
op_assign
id|serial_echo_inb
c_func
(paren
id|UART_LSR
)paren
suffix:semicolon
multiline_comment|/* COM? LSR */
id|comstat
op_assign
id|serial_echo_inb
c_func
(paren
id|UART_RX
)paren
suffix:semicolon
multiline_comment|/* COM? RBR */
id|serial_echo_outb
c_func
(paren
l_int|0x00
comma
id|UART_IER
)paren
suffix:semicolon
multiline_comment|/* Disable all interrupts */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SERIAL_ECHO */
DECL|function|vc_cons_allocated
r_int
id|vc_cons_allocated
c_func
(paren
r_int
r_int
id|i
)paren
(brace
r_return
(paren
id|i
OL
id|MAX_NR_CONSOLES
op_logical_and
id|vc_cons
(braket
id|i
)braket
dot
id|d
)paren
suffix:semicolon
)brace
DECL|function|vc_allocate
r_int
id|vc_allocate
c_func
(paren
r_int
r_int
id|i
)paren
multiline_comment|/* return 0 on success */
(brace
r_if
c_cond
(paren
id|i
op_ge
id|MAX_NR_CONSOLES
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons
(braket
id|i
)braket
dot
id|d
)paren
(brace
r_int
id|p
comma
id|q
suffix:semicolon
multiline_comment|/* prevent users from taking too much memory */
r_if
c_cond
(paren
id|i
op_ge
id|MAX_NR_USER_CONSOLES
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* due to the granularity of kmalloc, we waste some memory here */
multiline_comment|/* the alloc is done in two steps, to optimize the common situation&n;&t;       of a 25x80 console (structsize=216, video_screen_size=4000) */
id|q
op_assign
(paren
r_int
)paren
id|kmalloc
c_func
(paren
id|video_screen_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|p
op_assign
(paren
r_int
)paren
id|kmalloc
c_func
(paren
id|structsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|kfree_s
c_func
(paren
(paren
r_char
op_star
)paren
id|q
comma
id|video_screen_size
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|vc_cons
(braket
id|i
)braket
dot
id|d
op_assign
(paren
r_struct
id|vc_data
op_star
)paren
id|p
suffix:semicolon
id|p
op_add_assign
r_sizeof
(paren
r_struct
id|vc_data
)paren
suffix:semicolon
id|vt_cons
(braket
id|i
)braket
op_assign
(paren
r_struct
id|vt_struct
op_star
)paren
id|p
suffix:semicolon
id|vc_scrbuf
(braket
id|i
)braket
op_assign
(paren
r_int
r_int
op_star
)paren
id|q
suffix:semicolon
id|vc_cons
(braket
id|i
)braket
dot
id|d-&gt;vc_kmalloced
op_assign
l_int|1
suffix:semicolon
id|vc_cons
(braket
id|i
)braket
dot
id|d-&gt;vc_screenbuf_size
op_assign
id|video_screen_size
suffix:semicolon
id|vc_init
(paren
id|i
comma
id|video_num_lines
comma
id|video_num_columns
comma
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Change # of rows and columns (0 means unchanged)&n; * [this is to be used together with some user program&n; * like resize that changes the hardware videomode]&n; */
DECL|function|vc_resize
r_int
id|vc_resize
c_func
(paren
r_int
r_int
id|lines
comma
r_int
r_int
id|cols
)paren
(brace
r_int
r_int
id|cc
comma
id|ll
comma
id|ss
comma
id|sr
suffix:semicolon
r_int
r_int
id|occ
comma
id|oll
comma
id|oss
comma
id|osr
suffix:semicolon
r_int
r_int
op_star
id|p
suffix:semicolon
r_int
r_int
id|currcons
comma
id|i
suffix:semicolon
r_int
r_int
op_star
id|newscreens
(braket
id|MAX_NR_CONSOLES
)braket
suffix:semicolon
r_int
id|ol
comma
id|nl
comma
id|rlth
comma
id|rrem
suffix:semicolon
id|cc
op_assign
(paren
id|cols
ques
c_cond
id|cols
suffix:colon
id|video_num_columns
)paren
suffix:semicolon
id|ll
op_assign
(paren
id|lines
ques
c_cond
id|lines
suffix:colon
id|video_num_lines
)paren
suffix:semicolon
id|sr
op_assign
id|cc
op_lshift
l_int|1
suffix:semicolon
id|ss
op_assign
id|sr
op_star
id|ll
suffix:semicolon
r_if
c_cond
(paren
id|ss
OG
id|video_mem_term
op_minus
id|video_mem_base
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
multiline_comment|/*&n;&t; * Some earlier version had all consoles of potentially&n;&t; * different sizes, but that was really messy.&n;&t; * So now we only change if there is room for all consoles&n;&t; * of the same size.&n;&t; */
r_for
c_loop
(paren
id|currcons
op_assign
l_int|0
suffix:semicolon
id|currcons
OL
id|MAX_NR_CONSOLES
suffix:semicolon
id|currcons
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|currcons
)paren
)paren
id|newscreens
(braket
id|currcons
)braket
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|kmalloc
c_func
(paren
id|ss
comma
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|currcons
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|newscreens
(braket
id|i
)braket
)paren
id|kfree_s
c_func
(paren
id|newscreens
(braket
id|i
)braket
comma
id|ss
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|newscreens
(braket
id|currcons
)braket
op_assign
id|p
suffix:semicolon
)brace
)brace
id|get_scrmem
c_func
(paren
id|fg_console
)paren
suffix:semicolon
id|oll
op_assign
id|video_num_lines
suffix:semicolon
id|occ
op_assign
id|video_num_columns
suffix:semicolon
id|osr
op_assign
id|video_size_row
suffix:semicolon
id|oss
op_assign
id|video_screen_size
suffix:semicolon
id|video_num_lines
op_assign
id|ll
suffix:semicolon
id|video_num_columns
op_assign
id|cc
suffix:semicolon
id|video_size_row
op_assign
id|sr
suffix:semicolon
id|video_screen_size
op_assign
id|ss
suffix:semicolon
r_for
c_loop
(paren
id|currcons
op_assign
l_int|0
suffix:semicolon
id|currcons
OL
id|MAX_NR_CONSOLES
suffix:semicolon
id|currcons
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|currcons
)paren
)paren
r_continue
suffix:semicolon
id|rlth
op_assign
id|MIN
c_func
(paren
id|osr
comma
id|sr
)paren
suffix:semicolon
id|rrem
op_assign
id|sr
op_minus
id|rlth
suffix:semicolon
id|ol
op_assign
id|origin
suffix:semicolon
id|nl
op_assign
(paren
r_int
)paren
id|newscreens
(braket
id|currcons
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ll
OL
id|oll
)paren
id|ol
op_add_assign
(paren
id|oll
op_minus
id|ll
)paren
op_star
id|osr
suffix:semicolon
r_while
c_loop
(paren
id|ol
OL
id|scr_end
)paren
(brace
id|memcpyw
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|nl
comma
(paren
r_int
r_int
op_star
)paren
id|ol
comma
id|rlth
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rrem
)paren
id|memsetw
c_func
(paren
(paren
r_void
op_star
)paren
(paren
id|nl
op_plus
id|rlth
)paren
comma
id|video_erase_char
comma
id|rrem
)paren
suffix:semicolon
id|ol
op_add_assign
id|osr
suffix:semicolon
id|nl
op_add_assign
id|sr
suffix:semicolon
)brace
r_if
c_cond
(paren
id|kmalloced
)paren
id|kfree_s
c_func
(paren
id|vc_scrbuf
(braket
id|currcons
)braket
comma
id|screenbuf_size
)paren
suffix:semicolon
id|vc_scrbuf
(braket
id|currcons
)braket
op_assign
id|newscreens
(braket
id|currcons
)braket
suffix:semicolon
id|kmalloced
op_assign
l_int|1
suffix:semicolon
id|screenbuf_size
op_assign
id|ss
suffix:semicolon
id|origin
op_assign
id|video_mem_start
op_assign
(paren
r_int
)paren
id|vc_scrbuf
(braket
id|currcons
)braket
suffix:semicolon
id|scr_end
op_assign
id|video_mem_end
op_assign
id|video_mem_start
op_plus
id|ss
suffix:semicolon
r_if
c_cond
(paren
id|scr_end
OG
id|nl
)paren
id|memsetw
c_func
(paren
(paren
r_void
op_star
)paren
id|nl
comma
id|video_erase_char
comma
id|scr_end
op_minus
id|nl
)paren
suffix:semicolon
multiline_comment|/* do part of a reset_terminal() */
id|top
op_assign
l_int|0
suffix:semicolon
id|bottom
op_assign
id|video_num_lines
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|x
comma
id|y
)paren
suffix:semicolon
id|save_cur
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
id|set_scrmem
c_func
(paren
id|fg_console
comma
l_int|0
)paren
suffix:semicolon
id|set_origin
c_func
(paren
id|fg_console
)paren
suffix:semicolon
id|set_cursor
c_func
(paren
id|fg_console
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|vc_disallocate
r_void
id|vc_disallocate
c_func
(paren
r_int
r_int
id|currcons
)paren
(brace
r_if
c_cond
(paren
id|vc_cons_allocated
c_func
(paren
id|currcons
)paren
)paren
(brace
r_if
c_cond
(paren
id|kmalloced
)paren
id|kfree_s
c_func
(paren
id|vc_scrbuf
(braket
id|currcons
)braket
comma
id|screenbuf_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ge
id|MIN_NR_CONSOLES
)paren
id|kfree_s
c_func
(paren
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
comma
id|structsize
)paren
suffix:semicolon
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|macro|set_kbd
mdefine_line|#define set_kbd(x) set_vc_kbd_mode(kbd_table+currcons,x)
DECL|macro|clr_kbd
mdefine_line|#define clr_kbd(x) clr_vc_kbd_mode(kbd_table+currcons,x)
DECL|macro|is_kbd
mdefine_line|#define is_kbd(x) vc_kbd_mode(kbd_table+currcons,x)
DECL|macro|decarm
mdefine_line|#define decarm&t;&t;VC_REPEAT
DECL|macro|decckm
mdefine_line|#define decckm&t;&t;VC_CKMODE
DECL|macro|kbdapplic
mdefine_line|#define kbdapplic&t;VC_APPLIC
DECL|macro|lnm
mdefine_line|#define lnm&t;&t;VC_CRLF
multiline_comment|/*&n; * this is what the terminal answers to a ESC-Z or csi0c query.&n; */
DECL|macro|VT100ID
mdefine_line|#define VT100ID &quot;&bslash;033[?1;2c&quot;
DECL|macro|VT102ID
mdefine_line|#define VT102ID &quot;&bslash;033[?6c&quot;
DECL|variable|color_table
r_int
r_char
id|color_table
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|4
comma
l_int|2
comma
l_int|6
comma
l_int|1
comma
l_int|5
comma
l_int|3
comma
l_int|7
comma
l_int|8
comma
l_int|12
comma
l_int|10
comma
l_int|14
comma
l_int|9
comma
l_int|13
comma
l_int|11
comma
l_int|15
)brace
suffix:semicolon
multiline_comment|/* the default colour table, for VGA+ colour systems */
DECL|variable|default_red
r_int
id|default_red
(braket
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0xff
)brace
suffix:semicolon
DECL|variable|default_grn
r_int
id|default_grn
(braket
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0x55
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
DECL|variable|default_blu
r_int
id|default_blu
(braket
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0xaa
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0x55
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
comma
l_int|0xff
)brace
suffix:semicolon
multiline_comment|/*&n; * gotoxy() must verify all boundaries, because the arguments&n; * might also be negative. If the given position is out of&n; * bounds, the cursor is placed at the nearest margin.&n; */
DECL|function|gotoxy
r_static
r_void
id|gotoxy
c_func
(paren
r_int
id|currcons
comma
r_int
id|new_x
comma
r_int
id|new_y
)paren
(brace
r_int
id|max_y
suffix:semicolon
r_if
c_cond
(paren
id|new_x
OL
l_int|0
)paren
id|x
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|new_x
op_ge
id|video_num_columns
)paren
id|x
op_assign
id|video_num_columns
op_minus
l_int|1
suffix:semicolon
r_else
id|x
op_assign
id|new_x
suffix:semicolon
r_if
c_cond
(paren
id|decom
)paren
(brace
id|new_y
op_add_assign
id|top
suffix:semicolon
id|max_y
op_assign
id|bottom
suffix:semicolon
)brace
r_else
id|max_y
op_assign
id|video_num_lines
suffix:semicolon
r_if
c_cond
(paren
id|new_y
OL
l_int|0
)paren
id|y
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
id|new_y
op_ge
id|max_y
)paren
id|y
op_assign
id|max_y
op_minus
l_int|1
suffix:semicolon
r_else
id|y
op_assign
id|new_y
suffix:semicolon
id|pos
op_assign
id|origin
op_plus
id|y
op_star
id|video_size_row
op_plus
(paren
id|x
op_lshift
l_int|1
)paren
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Hardware scrollback support&n; */
r_extern
r_void
id|__set_origin
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|__real_origin
r_int
r_int
id|__real_origin
suffix:semicolon
multiline_comment|/* offset of non-scrolled screen */
DECL|variable|__origin
r_int
r_int
id|__origin
suffix:semicolon
multiline_comment|/* offset of currently displayed screen */
DECL|variable|has_wrapped
r_int
r_char
id|has_wrapped
suffix:semicolon
multiline_comment|/* all of videomem is data of fg_console */
DECL|variable|hardscroll_enabled
r_static
r_int
r_char
id|hardscroll_enabled
suffix:semicolon
DECL|variable|hardscroll_disabled_by_init
r_static
r_int
r_char
id|hardscroll_disabled_by_init
op_assign
l_int|0
suffix:semicolon
DECL|function|no_scroll
r_void
id|no_scroll
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
multiline_comment|/*&n;   * Disabling scrollback is required for the Braillex ib80-piezo&n;   * Braille reader made by F.H. Papenmeier (Germany).&n;   * Use the &quot;no-scroll&quot; bootflag.&n;   */
id|hardscroll_disabled_by_init
op_assign
l_int|1
suffix:semicolon
id|hardscroll_enabled
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|scrolldelta
r_static
r_void
id|scrolldelta
c_func
(paren
r_int
id|lines
)paren
(brace
r_int
id|new_origin
suffix:semicolon
r_int
id|last_origin_rel
op_assign
(paren
(paren
(paren
id|video_mem_term
op_minus
id|video_mem_base
)paren
op_div
id|video_num_columns
op_div
l_int|2
)paren
op_minus
(paren
id|video_num_lines
op_minus
l_int|1
)paren
)paren
op_star
id|video_num_columns
suffix:semicolon
id|new_origin
op_assign
id|__origin
op_plus
id|lines
op_star
id|video_num_columns
suffix:semicolon
r_if
c_cond
(paren
id|__origin
OG
id|__real_origin
)paren
id|new_origin
op_sub_assign
id|last_origin_rel
suffix:semicolon
r_if
c_cond
(paren
id|new_origin
OL
l_int|0
)paren
(brace
r_int
id|s_top
op_assign
id|__real_origin
op_plus
id|video_num_lines
op_star
id|video_num_columns
suffix:semicolon
id|new_origin
op_add_assign
id|last_origin_rel
suffix:semicolon
r_if
c_cond
(paren
id|new_origin
OL
id|s_top
)paren
id|new_origin
op_assign
id|s_top
suffix:semicolon
r_if
c_cond
(paren
id|new_origin
OG
id|last_origin_rel
op_minus
id|video_num_columns
op_logical_or
id|has_wrapped
op_eq
l_int|0
)paren
id|new_origin
op_assign
l_int|0
suffix:semicolon
r_else
(brace
r_int
r_int
op_star
id|d
op_assign
(paren
r_int
r_int
op_star
)paren
id|video_mem_base
suffix:semicolon
r_int
r_int
op_star
id|s
op_assign
id|d
op_plus
id|last_origin_rel
suffix:semicolon
r_int
id|count
op_assign
(paren
id|video_num_lines
op_minus
l_int|1
)paren
op_star
id|video_num_columns
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|scr_writew
c_func
(paren
id|scr_readw
c_func
(paren
id|d
op_increment
)paren
comma
id|s
op_increment
)paren
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|new_origin
OG
id|__real_origin
)paren
id|new_origin
op_assign
id|__real_origin
suffix:semicolon
id|__set_origin
c_func
(paren
id|new_origin
)paren
suffix:semicolon
)brace
DECL|function|scrollback
r_void
id|scrollback
c_func
(paren
r_int
id|lines
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|lines
)paren
id|lines
op_assign
id|video_num_lines
op_div
l_int|2
suffix:semicolon
id|scrolldelta
c_func
(paren
op_minus
id|lines
)paren
suffix:semicolon
)brace
DECL|function|scrollfront
r_void
id|scrollfront
c_func
(paren
r_int
id|lines
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|lines
)paren
id|lines
op_assign
id|video_num_lines
op_div
l_int|2
suffix:semicolon
id|scrolldelta
c_func
(paren
id|lines
)paren
suffix:semicolon
)brace
DECL|function|set_origin
r_static
r_void
id|set_origin
c_func
(paren
r_int
id|currcons
)paren
(brace
r_if
c_cond
(paren
id|video_type
op_ne
id|VIDEO_TYPE_EGAC
op_logical_and
id|video_type
op_ne
id|VIDEO_TYPE_VGAC
op_logical_and
id|video_type
op_ne
id|VIDEO_TYPE_EGAM
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_ne
id|fg_console
op_logical_or
id|console_blanked
op_logical_or
id|vcmode
op_eq
id|KD_GRAPHICS
)paren
r_return
suffix:semicolon
id|__real_origin
op_assign
(paren
id|origin
op_minus
id|video_mem_base
)paren
op_rshift
l_int|1
suffix:semicolon
id|__set_origin
c_func
(paren
id|__real_origin
)paren
suffix:semicolon
)brace
DECL|function|scrup
r_void
id|scrup
c_func
(paren
r_int
id|currcons
comma
r_int
r_int
id|t
comma
r_int
r_int
id|b
)paren
(brace
r_int
id|hardscroll
op_assign
id|hardscroll_enabled
suffix:semicolon
r_if
c_cond
(paren
id|b
OG
id|video_num_lines
op_logical_or
id|t
op_ge
id|b
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|t
op_logical_or
id|b
op_ne
id|video_num_lines
)paren
id|hardscroll
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|hardscroll
)paren
(brace
id|origin
op_add_assign
id|video_size_row
suffix:semicolon
id|pos
op_add_assign
id|video_size_row
suffix:semicolon
id|scr_end
op_add_assign
id|video_size_row
suffix:semicolon
r_if
c_cond
(paren
id|scr_end
OG
id|video_mem_end
)paren
(brace
r_int
r_int
op_star
id|d
op_assign
(paren
r_int
r_int
op_star
)paren
id|video_mem_start
suffix:semicolon
r_int
r_int
op_star
id|s
op_assign
(paren
r_int
r_int
op_star
)paren
id|origin
suffix:semicolon
r_int
r_int
id|count
suffix:semicolon
id|count
op_assign
(paren
id|video_num_lines
op_minus
l_int|1
)paren
op_star
id|video_num_columns
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|scr_writew
c_func
(paren
id|scr_readw
c_func
(paren
id|s
op_increment
)paren
comma
id|d
op_increment
)paren
suffix:semicolon
)brace
id|count
op_assign
id|video_num_columns
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|scr_writew
c_func
(paren
id|video_erase_char
comma
id|d
op_increment
)paren
suffix:semicolon
)brace
id|scr_end
op_sub_assign
id|origin
op_minus
id|video_mem_start
suffix:semicolon
id|pos
op_sub_assign
id|origin
op_minus
id|video_mem_start
suffix:semicolon
id|origin
op_assign
id|video_mem_start
suffix:semicolon
id|has_scrolled
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|currcons
op_eq
id|fg_console
)paren
id|has_wrapped
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
op_star
id|d
suffix:semicolon
r_int
r_int
id|count
suffix:semicolon
id|d
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|scr_end
op_minus
id|video_size_row
)paren
suffix:semicolon
id|count
op_assign
id|video_num_columns
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|scr_writew
c_func
(paren
id|video_erase_char
comma
id|d
op_increment
)paren
suffix:semicolon
)brace
)brace
id|set_origin
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
op_star
id|d
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|origin
op_plus
id|video_size_row
op_star
id|t
)paren
suffix:semicolon
r_int
r_int
op_star
id|s
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|origin
op_plus
id|video_size_row
op_star
(paren
id|t
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_int
r_int
id|count
op_assign
(paren
id|b
op_minus
id|t
op_minus
l_int|1
)paren
op_star
id|video_num_columns
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|scr_writew
c_func
(paren
id|scr_readw
c_func
(paren
id|s
op_increment
)paren
comma
id|d
op_increment
)paren
suffix:semicolon
)brace
id|count
op_assign
id|video_num_columns
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|scr_writew
c_func
(paren
id|video_erase_char
comma
id|d
op_increment
)paren
suffix:semicolon
)brace
)brace
)brace
r_void
DECL|function|scrdown
id|scrdown
c_func
(paren
r_int
id|currcons
comma
r_int
r_int
id|t
comma
r_int
r_int
id|b
)paren
(brace
r_int
r_int
op_star
id|d
comma
op_star
id|s
suffix:semicolon
r_int
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
id|b
OG
id|video_num_lines
op_logical_or
id|t
op_ge
id|b
)paren
r_return
suffix:semicolon
id|d
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|origin
op_plus
id|video_size_row
op_star
id|b
)paren
suffix:semicolon
id|s
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|origin
op_plus
id|video_size_row
op_star
(paren
id|b
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|count
op_assign
(paren
id|b
op_minus
id|t
op_minus
l_int|1
)paren
op_star
id|video_num_columns
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|scr_writew
c_func
(paren
id|scr_readw
c_func
(paren
op_decrement
id|s
)paren
comma
op_decrement
id|d
)paren
suffix:semicolon
)brace
id|count
op_assign
id|video_num_columns
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|scr_writew
c_func
(paren
id|video_erase_char
comma
op_decrement
id|d
)paren
suffix:semicolon
)brace
id|has_scrolled
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|lf
r_static
r_void
id|lf
c_func
(paren
r_int
id|currcons
)paren
(brace
multiline_comment|/* don&squot;t scroll if above bottom of scrolling region, or&n;&t; * if below scrolling region&n;&t; */
r_if
c_cond
(paren
id|y
op_plus
l_int|1
op_eq
id|bottom
)paren
id|scrup
c_func
(paren
id|currcons
comma
id|top
comma
id|bottom
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|y
OL
id|video_num_lines
op_minus
l_int|1
)paren
(brace
id|y
op_increment
suffix:semicolon
id|pos
op_add_assign
id|video_size_row
suffix:semicolon
)brace
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|ri
r_static
r_void
id|ri
c_func
(paren
r_int
id|currcons
)paren
(brace
multiline_comment|/* don&squot;t scroll if below top of scrolling region, or&n;&t; * if above scrolling region&n;&t; */
r_if
c_cond
(paren
id|y
op_eq
id|top
)paren
id|scrdown
c_func
(paren
id|currcons
comma
id|top
comma
id|bottom
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|y
OG
l_int|0
)paren
(brace
id|y
op_decrement
suffix:semicolon
id|pos
op_sub_assign
id|video_size_row
suffix:semicolon
)brace
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|cr
r_static
r_inline
r_void
id|cr
c_func
(paren
r_int
id|currcons
)paren
(brace
id|pos
op_sub_assign
id|x
op_lshift
l_int|1
suffix:semicolon
id|need_wrap
op_assign
id|x
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|bs
r_static
r_inline
r_void
id|bs
c_func
(paren
r_int
id|currcons
)paren
(brace
r_if
c_cond
(paren
id|x
)paren
(brace
id|pos
op_sub_assign
l_int|2
suffix:semicolon
id|x
op_decrement
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|del
r_static
r_inline
r_void
id|del
c_func
(paren
r_int
id|currcons
)paren
(brace
multiline_comment|/* ignored */
)brace
DECL|function|csi_J
r_static
r_void
id|csi_J
c_func
(paren
r_int
id|currcons
comma
r_int
id|vpar
)paren
(brace
r_int
r_int
id|count
suffix:semicolon
r_int
r_int
op_star
id|start
suffix:semicolon
r_switch
c_cond
(paren
id|vpar
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* erase from cursor to end of display */
id|count
op_assign
(paren
id|scr_end
op_minus
id|pos
)paren
op_rshift
l_int|1
suffix:semicolon
id|start
op_assign
(paren
r_int
r_int
op_star
)paren
id|pos
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* erase from start to cursor */
id|count
op_assign
(paren
(paren
id|pos
op_minus
id|origin
)paren
op_rshift
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
id|start
op_assign
(paren
r_int
r_int
op_star
)paren
id|origin
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* erase whole display */
id|count
op_assign
id|video_num_columns
op_star
id|video_num_lines
suffix:semicolon
id|start
op_assign
(paren
r_int
r_int
op_star
)paren
id|origin
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|scr_writew
c_func
(paren
id|video_erase_char
comma
id|start
op_increment
)paren
suffix:semicolon
)brace
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|csi_K
r_static
r_void
id|csi_K
c_func
(paren
r_int
id|currcons
comma
r_int
id|vpar
)paren
(brace
r_int
r_int
id|count
suffix:semicolon
r_int
r_int
op_star
id|start
suffix:semicolon
r_switch
c_cond
(paren
id|vpar
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* erase from cursor to end of line */
id|count
op_assign
id|video_num_columns
op_minus
id|x
suffix:semicolon
id|start
op_assign
(paren
r_int
r_int
op_star
)paren
id|pos
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* erase from start of line to cursor */
id|start
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|pos
op_minus
(paren
id|x
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
id|count
op_assign
id|x
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* erase whole line */
id|start
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|pos
op_minus
(paren
id|x
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
id|count
op_assign
id|video_num_columns
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|scr_writew
c_func
(paren
id|video_erase_char
comma
id|start
op_increment
)paren
suffix:semicolon
)brace
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|csi_X
r_static
r_void
id|csi_X
c_func
(paren
r_int
id|currcons
comma
r_int
id|vpar
)paren
multiline_comment|/* erase the following vpar positions */
(brace
multiline_comment|/* not vt100? */
r_int
r_int
id|count
suffix:semicolon
r_int
r_int
op_star
id|start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vpar
)paren
id|vpar
op_increment
suffix:semicolon
id|start
op_assign
(paren
r_int
r_int
op_star
)paren
id|pos
suffix:semicolon
id|count
op_assign
(paren
id|vpar
OG
id|video_num_columns
op_minus
id|x
)paren
ques
c_cond
(paren
id|video_num_columns
op_minus
id|x
)paren
suffix:colon
id|vpar
suffix:semicolon
r_while
c_loop
(paren
id|count
)paren
(brace
id|count
op_decrement
suffix:semicolon
id|scr_writew
c_func
(paren
id|video_erase_char
comma
id|start
op_increment
)paren
suffix:semicolon
)brace
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|update_attr
r_static
r_void
id|update_attr
c_func
(paren
r_int
id|currcons
)paren
(brace
id|attr
op_assign
id|color
suffix:semicolon
r_if
c_cond
(paren
id|can_do_color
)paren
(brace
r_if
c_cond
(paren
id|underline
)paren
id|attr
op_assign
(paren
id|attr
op_amp
l_int|0xf0
)paren
op_or
id|ulcolor
suffix:semicolon
r_else
r_if
c_cond
(paren
id|intensity
op_eq
l_int|0
)paren
id|attr
op_assign
(paren
id|attr
op_amp
l_int|0xf0
)paren
op_or
id|halfcolor
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reverse
op_xor
id|decscnm
)paren
id|attr
op_assign
id|reverse_video_char
c_func
(paren
id|attr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blink
)paren
id|attr
op_xor_assign
l_int|0x80
suffix:semicolon
r_if
c_cond
(paren
id|intensity
op_eq
l_int|2
)paren
id|attr
op_xor_assign
l_int|0x08
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|can_do_color
)paren
(brace
r_if
c_cond
(paren
id|underline
)paren
id|attr
op_assign
(paren
id|attr
op_amp
l_int|0xf8
)paren
op_or
l_int|0x01
suffix:semicolon
r_else
r_if
c_cond
(paren
id|intensity
op_eq
l_int|0
)paren
id|attr
op_assign
(paren
id|attr
op_amp
l_int|0xf0
)paren
op_or
l_int|0x08
suffix:semicolon
)brace
r_if
c_cond
(paren
id|decscnm
)paren
id|video_erase_char
op_assign
(paren
id|reverse_video_char
c_func
(paren
id|color
)paren
op_lshift
l_int|8
)paren
op_or
l_char|&squot; &squot;
suffix:semicolon
r_else
id|video_erase_char
op_assign
(paren
id|color
op_lshift
l_int|8
)paren
op_or
l_char|&squot; &squot;
suffix:semicolon
)brace
DECL|function|default_attr
r_static
r_void
id|default_attr
c_func
(paren
r_int
id|currcons
)paren
(brace
id|intensity
op_assign
l_int|1
suffix:semicolon
id|underline
op_assign
l_int|0
suffix:semicolon
id|reverse
op_assign
l_int|0
suffix:semicolon
id|blink
op_assign
l_int|0
suffix:semicolon
id|color
op_assign
id|def_color
suffix:semicolon
)brace
DECL|function|csi_m
r_static
r_void
id|csi_m
c_func
(paren
r_int
id|currcons
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|npar
suffix:semicolon
id|i
op_increment
)paren
r_switch
c_cond
(paren
id|par
(braket
id|i
)braket
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* all attributes off */
id|default_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|intensity
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|intensity
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|underline
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|blink
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
id|reverse
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
multiline_comment|/* ANSI X3.64-1979 (SCO-ish?)&n;&t;&t;&t;&t;  * Select primary font, don&squot;t display&n;&t;&t;&t;&t;  * control chars if defined, don&squot;t set&n;&t;&t;&t;&t;  * bit 8 on output.&n;&t;&t;&t;&t;  */
id|translate
op_assign
id|set_translate
c_func
(paren
id|charset
op_eq
l_int|0
ques
c_cond
id|G0_charset
suffix:colon
id|G1_charset
)paren
suffix:semicolon
id|disp_ctrl
op_assign
l_int|0
suffix:semicolon
id|toggle_meta
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
multiline_comment|/* ANSI X3.64-1979 (SCO-ish?)&n;&t;&t;&t;&t;  * Select first alternate font, lets&n;&t;&t;&t;&t;  * chars &lt; 32 be displayed as ROM chars.&n;&t;&t;&t;&t;  */
id|translate
op_assign
id|set_translate
c_func
(paren
id|IBMPC_MAP
)paren
suffix:semicolon
id|disp_ctrl
op_assign
l_int|1
suffix:semicolon
id|toggle_meta
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
multiline_comment|/* ANSI X3.64-1979 (SCO-ish?)&n;&t;&t;&t;&t;  * Select second alternate font, toggle&n;&t;&t;&t;&t;  * high bit before displaying as ROM char.&n;&t;&t;&t;&t;  */
id|translate
op_assign
id|set_translate
c_func
(paren
id|IBMPC_MAP
)paren
suffix:semicolon
id|disp_ctrl
op_assign
l_int|1
suffix:semicolon
id|toggle_meta
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|21
suffix:colon
r_case
l_int|22
suffix:colon
id|intensity
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|24
suffix:colon
id|underline
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|25
suffix:colon
id|blink
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|27
suffix:colon
id|reverse
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|38
suffix:colon
multiline_comment|/* ANSI X3.64-1979 (SCO-ish?)&n;&t;&t;&t;&t;  * Enables underscore, white foreground&n;&t;&t;&t;&t;  * with white underscore (Linux - use&n;&t;&t;&t;&t;  * default foreground).&n;&t;&t;&t;&t;  */
id|color
op_assign
(paren
id|def_color
op_amp
l_int|0x0f
)paren
op_or
id|background
suffix:semicolon
id|underline
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|39
suffix:colon
multiline_comment|/* ANSI X3.64-1979 (SCO-ish?)&n;&t;&t;&t;&t;  * Disable underline option.&n;&t;&t;&t;&t;  * Reset colour to default? It did this&n;&t;&t;&t;&t;  * before...&n;&t;&t;&t;&t;  */
id|color
op_assign
(paren
id|def_color
op_amp
l_int|0x0f
)paren
op_or
id|background
suffix:semicolon
id|underline
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|49
suffix:colon
id|color
op_assign
(paren
id|def_color
op_amp
l_int|0xf0
)paren
op_or
id|foreground
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|par
(braket
id|i
)braket
op_ge
l_int|30
op_logical_and
id|par
(braket
id|i
)braket
op_le
l_int|37
)paren
id|color
op_assign
id|color_table
(braket
id|par
(braket
id|i
)braket
op_minus
l_int|30
)braket
op_or
id|background
suffix:semicolon
r_else
r_if
c_cond
(paren
id|par
(braket
id|i
)braket
op_ge
l_int|40
op_logical_and
id|par
(braket
id|i
)braket
op_le
l_int|47
)paren
id|color
op_assign
(paren
id|color_table
(braket
id|par
(braket
id|i
)braket
op_minus
l_int|40
)braket
op_lshift
l_int|4
)paren
op_or
id|foreground
suffix:semicolon
r_break
suffix:semicolon
)brace
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
DECL|function|respond_string
r_static
r_void
id|respond_string
c_func
(paren
r_const
r_char
op_star
id|p
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_while
c_loop
(paren
op_star
id|p
)paren
(brace
id|tty_insert_flip_char
c_func
(paren
id|tty
comma
op_star
id|p
comma
l_int|0
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
id|tty_schedule_flip
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|cursor_report
r_static
r_void
id|cursor_report
c_func
(paren
r_int
id|currcons
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_char
id|buf
(braket
l_int|40
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;&bslash;033[%ld;%ldR&quot;
comma
id|y
op_plus
(paren
id|decom
ques
c_cond
id|top
op_plus
l_int|1
suffix:colon
l_int|1
)paren
comma
id|x
op_plus
l_int|1
)paren
suffix:semicolon
id|respond_string
c_func
(paren
id|buf
comma
id|tty
)paren
suffix:semicolon
)brace
DECL|function|status_report
r_static
r_inline
r_void
id|status_report
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|respond_string
c_func
(paren
l_string|&quot;&bslash;033[0n&quot;
comma
id|tty
)paren
suffix:semicolon
multiline_comment|/* Terminal ok */
)brace
DECL|function|respond_ID
r_static
r_inline
r_void
id|respond_ID
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|respond_string
c_func
(paren
id|VT102ID
comma
id|tty
)paren
suffix:semicolon
)brace
DECL|function|mouse_report
r_void
id|mouse_report
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|butt
comma
r_int
id|mrx
comma
r_int
id|mry
)paren
(brace
r_char
id|buf
(braket
l_int|8
)braket
suffix:semicolon
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;&bslash;033[M%c%c%c&quot;
comma
(paren
r_char
)paren
(paren
l_char|&squot; &squot;
op_plus
id|butt
)paren
comma
(paren
r_char
)paren
(paren
l_char|&squot;!&squot;
op_plus
id|mrx
)paren
comma
(paren
r_char
)paren
(paren
l_char|&squot;!&squot;
op_plus
id|mry
)paren
)paren
suffix:semicolon
id|respond_string
c_func
(paren
id|buf
comma
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/* invoked via ioctl(TIOCLINUX) */
DECL|function|mouse_reporting
r_int
id|mouse_reporting
c_func
(paren
r_void
)paren
(brace
r_int
id|currcons
op_assign
id|fg_console
suffix:semicolon
r_return
id|report_mouse
suffix:semicolon
)brace
DECL|function|screenpos
r_static
r_inline
r_int
r_int
op_star
id|screenpos
c_func
(paren
r_int
id|currcons
comma
r_int
id|offset
comma
r_int
id|viewed
)paren
(brace
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|origin
op_plus
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|viewed
op_logical_and
id|currcons
op_eq
id|fg_console
)paren
id|p
op_sub_assign
(paren
id|__real_origin
op_minus
id|__origin
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/* Note: inverting the screen twice should revert to the original state */
DECL|function|invert_screen
r_void
id|invert_screen
c_func
(paren
r_int
id|currcons
comma
r_int
id|offset
comma
r_int
id|count
comma
r_int
id|viewed
)paren
(brace
r_int
r_int
op_star
id|p
suffix:semicolon
id|count
op_div_assign
l_int|2
suffix:semicolon
id|p
op_assign
id|screenpos
c_func
(paren
id|currcons
comma
id|offset
comma
id|viewed
)paren
suffix:semicolon
r_if
c_cond
(paren
id|can_do_color
)paren
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
r_int
r_int
id|old
op_assign
id|scr_readw
c_func
(paren
id|p
)paren
suffix:semicolon
id|scr_writew
c_func
(paren
id|reverse_video_short
c_func
(paren
id|old
)paren
comma
id|p
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
r_else
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
r_int
r_int
id|old
op_assign
id|scr_readw
c_func
(paren
id|p
)paren
suffix:semicolon
id|scr_writew
c_func
(paren
id|old
op_xor
(paren
(paren
(paren
id|old
op_amp
l_int|0x0700
)paren
op_eq
l_int|0x0100
)paren
ques
c_cond
l_int|0x7000
suffix:colon
l_int|0x7700
)paren
comma
id|p
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* used by selection: complement pointer position */
DECL|function|complement_pos
r_void
id|complement_pos
c_func
(paren
r_int
id|currcons
comma
r_int
id|offset
)paren
(brace
r_static
r_int
r_int
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_static
r_int
r_int
id|old
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|scr_writew
c_func
(paren
id|old
comma
id|p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|offset
op_eq
op_minus
l_int|1
)paren
id|p
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|p
op_assign
id|screenpos
c_func
(paren
id|currcons
comma
id|offset
comma
l_int|1
)paren
suffix:semicolon
id|old
op_assign
id|scr_readw
c_func
(paren
id|p
)paren
suffix:semicolon
id|scr_writew
c_func
(paren
id|old
op_xor
l_int|0x7700
comma
id|p
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* used by selection */
DECL|function|screen_word
r_int
r_int
id|screen_word
c_func
(paren
r_int
id|currcons
comma
r_int
id|offset
comma
r_int
id|viewed
)paren
(brace
r_return
id|scr_readw
c_func
(paren
id|screenpos
c_func
(paren
id|currcons
comma
id|offset
comma
id|viewed
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* used by selection - convert a screen word to a glyph number */
DECL|function|scrw2glyph
r_int
id|scrw2glyph
c_func
(paren
r_int
r_int
id|scr_word
)paren
(brace
r_return
(paren
id|video_mode_512ch
)paren
ques
c_cond
(paren
(paren
id|scr_word
op_amp
l_int|0x0800
)paren
op_rshift
l_int|3
)paren
op_plus
(paren
id|scr_word
op_amp
l_int|0x00ff
)paren
suffix:colon
id|scr_word
op_amp
l_int|0x00ff
suffix:semicolon
)brace
multiline_comment|/* used by vcs - note the word offset */
DECL|function|screen_pos
r_int
r_int
op_star
id|screen_pos
c_func
(paren
r_int
id|currcons
comma
r_int
id|w_offset
comma
r_int
id|viewed
)paren
(brace
r_return
id|screenpos
c_func
(paren
id|currcons
comma
l_int|2
op_star
id|w_offset
comma
id|viewed
)paren
suffix:semicolon
)brace
DECL|function|getconsxy
r_void
id|getconsxy
c_func
(paren
r_int
id|currcons
comma
r_char
op_star
id|p
)paren
(brace
id|p
(braket
l_int|0
)braket
op_assign
id|x
suffix:semicolon
id|p
(braket
l_int|1
)braket
op_assign
id|y
suffix:semicolon
)brace
DECL|function|putconsxy
r_void
id|putconsxy
c_func
(paren
r_int
id|currcons
comma
r_char
op_star
id|p
)paren
(brace
id|gotoxy
c_func
(paren
id|currcons
comma
id|p
(braket
l_int|0
)braket
comma
id|p
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|set_cursor
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
DECL|function|set_mode
r_static
r_void
id|set_mode
c_func
(paren
r_int
id|currcons
comma
r_int
id|on_off
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|npar
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ques
)paren
r_switch
c_cond
(paren
id|par
(braket
id|i
)braket
)paren
(brace
multiline_comment|/* DEC private modes set/reset */
r_case
l_int|1
suffix:colon
multiline_comment|/* Cursor keys send ^[Ox/^[[x */
r_if
c_cond
(paren
id|on_off
)paren
id|set_kbd
c_func
(paren
id|decckm
)paren
suffix:semicolon
r_else
id|clr_kbd
c_func
(paren
id|decckm
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* 80/132 mode switch unimplemented */
id|deccolm
op_assign
id|on_off
suffix:semicolon
macro_line|#if 0
(paren
r_void
)paren
id|vc_resize
c_func
(paren
id|video_num_lines
comma
id|deccolm
ques
c_cond
l_int|132
suffix:colon
l_int|80
)paren
suffix:semicolon
multiline_comment|/* this alone does not suffice; some user mode&n;&t;&t;&t;&t;   utility has to change the hardware regs */
macro_line|#endif
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
multiline_comment|/* Inverted screen on/off */
r_if
c_cond
(paren
id|decscnm
op_ne
id|on_off
)paren
(brace
id|decscnm
op_assign
id|on_off
suffix:semicolon
id|invert_screen
c_func
(paren
id|currcons
comma
l_int|0
comma
id|video_screen_size
comma
l_int|0
)paren
suffix:semicolon
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/* Origin relative/absolute */
id|decom
op_assign
id|on_off
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|7
suffix:colon
multiline_comment|/* Autowrap on/off */
id|decawm
op_assign
id|on_off
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* Autorepeat on/off */
r_if
c_cond
(paren
id|on_off
)paren
id|set_kbd
c_func
(paren
id|decarm
)paren
suffix:semicolon
r_else
id|clr_kbd
c_func
(paren
id|decarm
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
id|report_mouse
op_assign
id|on_off
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|25
suffix:colon
multiline_comment|/* Cursor on/off */
id|deccm
op_assign
id|on_off
suffix:semicolon
id|set_cursor
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1000
suffix:colon
id|report_mouse
op_assign
id|on_off
ques
c_cond
l_int|2
suffix:colon
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_switch
c_cond
(paren
id|par
(braket
id|i
)braket
)paren
(brace
multiline_comment|/* ANSI modes set/reset */
r_case
l_int|3
suffix:colon
multiline_comment|/* Monitor (display ctrls) */
id|disp_ctrl
op_assign
id|on_off
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
multiline_comment|/* Insert Mode on/off */
id|decim
op_assign
id|on_off
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|20
suffix:colon
multiline_comment|/* Lf, Enter == CrLf/Lf */
r_if
c_cond
(paren
id|on_off
)paren
id|set_kbd
c_func
(paren
id|lnm
)paren
suffix:semicolon
r_else
id|clr_kbd
c_func
(paren
id|lnm
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|setterm_command
r_static
r_void
id|setterm_command
c_func
(paren
r_int
id|currcons
)paren
(brace
r_switch
c_cond
(paren
id|par
(braket
l_int|0
)braket
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* set color for underline mode */
r_if
c_cond
(paren
id|can_do_color
op_logical_and
id|par
(braket
l_int|1
)braket
OL
l_int|16
)paren
(brace
id|ulcolor
op_assign
id|color_table
(braket
id|par
(braket
l_int|1
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
id|underline
)paren
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* set color for half intensity mode */
r_if
c_cond
(paren
id|can_do_color
op_logical_and
id|par
(braket
l_int|1
)braket
OL
l_int|16
)paren
(brace
id|halfcolor
op_assign
id|color_table
(braket
id|par
(braket
l_int|1
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
id|intensity
op_eq
l_int|0
)paren
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* store colors as defaults */
id|def_color
op_assign
id|attr
suffix:semicolon
id|default_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
suffix:colon
multiline_comment|/* set blanking interval */
id|blankinterval
op_assign
(paren
(paren
id|par
(braket
l_int|1
)braket
OL
l_int|60
)paren
ques
c_cond
id|par
(braket
l_int|1
)braket
suffix:colon
l_int|60
)paren
op_star
l_int|60
op_star
id|HZ
suffix:semicolon
id|poke_blanked_console
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|10
suffix:colon
multiline_comment|/* set bell frequency in Hz */
r_if
c_cond
(paren
id|npar
op_ge
l_int|1
)paren
id|bell_pitch
op_assign
id|par
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|bell_pitch
op_assign
id|DEFAULT_BELL_PITCH
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|11
suffix:colon
multiline_comment|/* set bell duration in msec */
r_if
c_cond
(paren
id|npar
op_ge
l_int|1
)paren
id|bell_duration
op_assign
(paren
id|par
(braket
l_int|1
)braket
OL
l_int|2000
)paren
ques
c_cond
id|par
(braket
l_int|1
)braket
op_star
id|HZ
op_div
l_int|1000
suffix:colon
l_int|0
suffix:semicolon
r_else
id|bell_duration
op_assign
id|DEFAULT_BELL_DURATION
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
multiline_comment|/* bring specified console to the front */
r_if
c_cond
(paren
id|par
(braket
l_int|1
)braket
op_ge
l_int|1
op_logical_and
id|vc_cons_allocated
c_func
(paren
id|par
(braket
l_int|1
)braket
op_minus
l_int|1
)paren
)paren
id|update_screen
c_func
(paren
id|par
(braket
l_int|1
)braket
op_minus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|13
suffix:colon
multiline_comment|/* unblank the screen */
id|unblank_screen
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|14
suffix:colon
multiline_comment|/* set vesa powerdown interval */
id|vesa_off_interval
op_assign
(paren
(paren
id|par
(braket
l_int|1
)braket
OL
l_int|60
)paren
ques
c_cond
id|par
(braket
l_int|1
)braket
suffix:colon
l_int|60
)paren
op_star
l_int|60
op_star
id|HZ
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|function|insert_char
r_static
r_void
id|insert_char
c_func
(paren
r_int
id|currcons
)paren
(brace
r_int
r_int
id|i
op_assign
id|x
suffix:semicolon
r_int
r_int
id|tmp
comma
id|old
op_assign
id|video_erase_char
suffix:semicolon
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|pos
suffix:semicolon
r_while
c_loop
(paren
id|i
op_increment
OL
id|video_num_columns
)paren
(brace
id|tmp
op_assign
id|scr_readw
c_func
(paren
id|p
)paren
suffix:semicolon
id|scr_writew
c_func
(paren
id|old
comma
id|p
)paren
suffix:semicolon
id|old
op_assign
id|tmp
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|insert_line
r_static
r_void
id|insert_line
c_func
(paren
r_int
id|currcons
)paren
(brace
id|scrdown
c_func
(paren
id|currcons
comma
id|y
comma
id|bottom
)paren
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|delete_char
r_static
r_void
id|delete_char
c_func
(paren
r_int
id|currcons
)paren
(brace
r_int
r_int
id|i
op_assign
id|x
suffix:semicolon
r_int
r_int
op_star
id|p
op_assign
(paren
r_int
r_int
op_star
)paren
id|pos
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|i
OL
id|video_num_columns
)paren
(brace
id|scr_writew
c_func
(paren
id|scr_readw
c_func
(paren
id|p
op_plus
l_int|1
)paren
comma
id|p
)paren
suffix:semicolon
id|p
op_increment
suffix:semicolon
)brace
id|scr_writew
c_func
(paren
id|video_erase_char
comma
id|p
)paren
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|delete_line
r_static
r_void
id|delete_line
c_func
(paren
r_int
id|currcons
)paren
(brace
id|scrup
c_func
(paren
id|currcons
comma
id|y
comma
id|bottom
)paren
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|csi_at
r_static
r_void
id|csi_at
c_func
(paren
r_int
id|currcons
comma
r_int
r_int
id|nr
)paren
(brace
r_if
c_cond
(paren
id|nr
OG
id|video_num_columns
)paren
id|nr
op_assign
id|video_num_columns
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
id|nr
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|nr
op_decrement
)paren
id|insert_char
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
DECL|function|csi_L
r_static
r_void
id|csi_L
c_func
(paren
r_int
id|currcons
comma
r_int
r_int
id|nr
)paren
(brace
r_if
c_cond
(paren
id|nr
OG
id|video_num_lines
)paren
id|nr
op_assign
id|video_num_lines
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
id|nr
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|nr
op_decrement
)paren
id|insert_line
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
DECL|function|csi_P
r_static
r_void
id|csi_P
c_func
(paren
r_int
id|currcons
comma
r_int
r_int
id|nr
)paren
(brace
r_if
c_cond
(paren
id|nr
OG
id|video_num_columns
)paren
id|nr
op_assign
id|video_num_columns
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
id|nr
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|nr
op_decrement
)paren
id|delete_char
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
DECL|function|csi_M
r_static
r_void
id|csi_M
c_func
(paren
r_int
id|currcons
comma
r_int
r_int
id|nr
)paren
(brace
r_if
c_cond
(paren
id|nr
OG
id|video_num_lines
)paren
id|nr
op_assign
id|video_num_lines
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
id|nr
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|nr
op_decrement
)paren
id|delete_line
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
DECL|function|save_cur
r_static
r_void
id|save_cur
c_func
(paren
r_int
id|currcons
)paren
(brace
id|saved_x
op_assign
id|x
suffix:semicolon
id|saved_y
op_assign
id|y
suffix:semicolon
id|s_intensity
op_assign
id|intensity
suffix:semicolon
id|s_underline
op_assign
id|underline
suffix:semicolon
id|s_blink
op_assign
id|blink
suffix:semicolon
id|s_reverse
op_assign
id|reverse
suffix:semicolon
id|s_charset
op_assign
id|charset
suffix:semicolon
id|s_color
op_assign
id|color
suffix:semicolon
id|saved_G0
op_assign
id|G0_charset
suffix:semicolon
id|saved_G1
op_assign
id|G1_charset
suffix:semicolon
)brace
DECL|function|restore_cur
r_static
r_void
id|restore_cur
c_func
(paren
r_int
id|currcons
)paren
(brace
id|gotoxy
c_func
(paren
id|currcons
comma
id|saved_x
comma
id|saved_y
)paren
suffix:semicolon
id|intensity
op_assign
id|s_intensity
suffix:semicolon
id|underline
op_assign
id|s_underline
suffix:semicolon
id|blink
op_assign
id|s_blink
suffix:semicolon
id|reverse
op_assign
id|s_reverse
suffix:semicolon
id|charset
op_assign
id|s_charset
suffix:semicolon
id|color
op_assign
id|s_color
suffix:semicolon
id|G0_charset
op_assign
id|saved_G0
suffix:semicolon
id|G1_charset
op_assign
id|saved_G1
suffix:semicolon
id|translate
op_assign
id|set_translate
c_func
(paren
id|charset
ques
c_cond
id|G1_charset
suffix:colon
id|G0_charset
)paren
suffix:semicolon
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
)brace
DECL|enumerator|ESnormal
DECL|enumerator|ESesc
DECL|enumerator|ESsquare
DECL|enumerator|ESgetpars
DECL|enumerator|ESgotpars
DECL|enumerator|ESfunckey
r_enum
(brace
id|ESnormal
comma
id|ESesc
comma
id|ESsquare
comma
id|ESgetpars
comma
id|ESgotpars
comma
id|ESfunckey
comma
DECL|enumerator|EShash
DECL|enumerator|ESsetG0
DECL|enumerator|ESsetG1
DECL|enumerator|ESpercent
DECL|enumerator|ESignore
DECL|enumerator|ESnonstd
id|EShash
comma
id|ESsetG0
comma
id|ESsetG1
comma
id|ESpercent
comma
id|ESignore
comma
id|ESnonstd
comma
DECL|enumerator|ESpalette
id|ESpalette
)brace
suffix:semicolon
DECL|function|reset_terminal
r_static
r_void
id|reset_terminal
c_func
(paren
r_int
id|currcons
comma
r_int
id|do_clear
)paren
(brace
id|top
op_assign
l_int|0
suffix:semicolon
id|bottom
op_assign
id|video_num_lines
suffix:semicolon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
id|ques
op_assign
l_int|0
suffix:semicolon
id|translate
op_assign
id|set_translate
c_func
(paren
id|LAT1_MAP
)paren
suffix:semicolon
id|G0_charset
op_assign
id|LAT1_MAP
suffix:semicolon
id|G1_charset
op_assign
id|GRAF_MAP
suffix:semicolon
id|charset
op_assign
l_int|0
suffix:semicolon
id|need_wrap
op_assign
l_int|0
suffix:semicolon
id|report_mouse
op_assign
l_int|0
suffix:semicolon
id|utf
op_assign
l_int|0
suffix:semicolon
id|utf_count
op_assign
l_int|0
suffix:semicolon
id|disp_ctrl
op_assign
l_int|0
suffix:semicolon
id|toggle_meta
op_assign
l_int|0
suffix:semicolon
id|decscnm
op_assign
l_int|0
suffix:semicolon
id|decom
op_assign
l_int|0
suffix:semicolon
id|decawm
op_assign
l_int|1
suffix:semicolon
id|deccm
op_assign
l_int|1
suffix:semicolon
id|decim
op_assign
l_int|0
suffix:semicolon
id|set_kbd
c_func
(paren
id|decarm
)paren
suffix:semicolon
id|clr_kbd
c_func
(paren
id|decckm
)paren
suffix:semicolon
id|clr_kbd
c_func
(paren
id|kbdapplic
)paren
suffix:semicolon
id|clr_kbd
c_func
(paren
id|lnm
)paren
suffix:semicolon
id|kbd_table
(braket
id|currcons
)braket
dot
id|lockstate
op_assign
l_int|0
suffix:semicolon
id|kbd_table
(braket
id|currcons
)braket
dot
id|slockstate
op_assign
l_int|0
suffix:semicolon
id|kbd_table
(braket
id|currcons
)braket
dot
id|ledmode
op_assign
id|LED_SHOW_FLAGS
suffix:semicolon
id|kbd_table
(braket
id|currcons
)braket
dot
id|ledflagstate
op_assign
id|kbd_table
(braket
id|currcons
)braket
dot
id|default_ledflagstate
suffix:semicolon
id|set_leds
c_func
(paren
)paren
suffix:semicolon
id|default_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|update_attr
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|tab_stop
(braket
l_int|0
)braket
op_assign
l_int|0x01010100
suffix:semicolon
id|tab_stop
(braket
l_int|1
)braket
op_assign
id|tab_stop
(braket
l_int|2
)braket
op_assign
id|tab_stop
(braket
l_int|3
)braket
op_assign
id|tab_stop
(braket
l_int|4
)braket
op_assign
l_int|0x01010101
suffix:semicolon
id|bell_pitch
op_assign
id|DEFAULT_BELL_PITCH
suffix:semicolon
id|bell_duration
op_assign
id|DEFAULT_BELL_DURATION
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|save_cur
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_clear
)paren
id|csi_J
c_func
(paren
id|currcons
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Turn the Scroll-Lock LED on when the tty is stopped&n; */
DECL|function|con_stop
r_static
r_void
id|con_stop
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|console_num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|console_num
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
(paren
id|tty-&gt;driver.minor_start
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|console_num
)paren
)paren
r_return
suffix:semicolon
id|set_vc_kbd_led
c_func
(paren
id|kbd_table
op_plus
id|console_num
comma
id|VC_SCROLLOCK
)paren
suffix:semicolon
id|set_leds
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Turn the Scroll-Lock LED off when the console is started&n; */
DECL|function|con_start
r_static
r_void
id|con_start
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|console_num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|console_num
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
(paren
id|tty-&gt;driver.minor_start
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|console_num
)paren
)paren
r_return
suffix:semicolon
id|clr_vc_kbd_led
c_func
(paren
id|kbd_table
op_plus
id|console_num
comma
id|VC_SCROLLOCK
)paren
suffix:semicolon
id|set_leds
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|con_write
r_static
r_int
id|con_write
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|from_user
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|c
comma
id|tc
comma
id|ok
comma
id|n
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|currcons
suffix:semicolon
r_struct
id|vt_struct
op_star
id|vt
op_assign
(paren
r_struct
id|vt_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|currcons
op_assign
id|vt-&gt;vc_num
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|currcons
)paren
)paren
(brace
multiline_comment|/* could this happen? */
r_static
r_int
id|error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
(brace
id|error
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;con_write: tty %d not allocated&bslash;n&quot;
comma
id|currcons
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|currcons
op_eq
id|sel_cons
)paren
id|clear_selection
c_func
(paren
)paren
suffix:semicolon
id|disable_bh
c_func
(paren
id|CONSOLE_BH
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|tty-&gt;stopped
op_logical_and
id|count
)paren
(brace
id|enable_bh
c_func
(paren
id|CONSOLE_BH
)paren
suffix:semicolon
id|c
op_assign
id|from_user
ques
c_cond
id|get_user
c_func
(paren
id|buf
)paren
suffix:colon
op_star
id|buf
suffix:semicolon
id|buf
op_increment
suffix:semicolon
id|n
op_increment
suffix:semicolon
id|count
op_decrement
suffix:semicolon
id|disable_bh
c_func
(paren
id|CONSOLE_BH
)paren
suffix:semicolon
r_if
c_cond
(paren
id|utf
)paren
(brace
multiline_comment|/* Combine UTF-8 into Unicode */
multiline_comment|/* Incomplete characters silently ignored */
r_if
c_cond
(paren
id|c
OG
l_int|0x7f
)paren
(brace
r_if
c_cond
(paren
id|utf_count
OG
l_int|0
op_logical_and
(paren
id|c
op_amp
l_int|0xc0
)paren
op_eq
l_int|0x80
)paren
(brace
id|utf_char
op_assign
(paren
id|utf_char
op_lshift
l_int|6
)paren
op_or
(paren
id|c
op_amp
l_int|0x3f
)paren
suffix:semicolon
id|utf_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|utf_count
op_eq
l_int|0
)paren
id|tc
op_assign
id|c
op_assign
id|utf_char
suffix:semicolon
r_else
r_continue
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xe0
)paren
op_eq
l_int|0xc0
)paren
(brace
id|utf_count
op_assign
l_int|1
suffix:semicolon
id|utf_char
op_assign
(paren
id|c
op_amp
l_int|0x1f
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xf0
)paren
op_eq
l_int|0xe0
)paren
(brace
id|utf_count
op_assign
l_int|2
suffix:semicolon
id|utf_char
op_assign
(paren
id|c
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xf8
)paren
op_eq
l_int|0xf0
)paren
(brace
id|utf_count
op_assign
l_int|3
suffix:semicolon
id|utf_char
op_assign
(paren
id|c
op_amp
l_int|0x07
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xfc
)paren
op_eq
l_int|0xf8
)paren
(brace
id|utf_count
op_assign
l_int|4
suffix:semicolon
id|utf_char
op_assign
(paren
id|c
op_amp
l_int|0x03
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|c
op_amp
l_int|0xfe
)paren
op_eq
l_int|0xfc
)paren
(brace
id|utf_count
op_assign
l_int|5
suffix:semicolon
id|utf_char
op_assign
(paren
id|c
op_amp
l_int|0x01
)paren
suffix:semicolon
)brace
r_else
id|utf_count
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_else
(brace
id|tc
op_assign
id|c
suffix:semicolon
id|utf_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* no utf */
id|tc
op_assign
id|translate
(braket
id|toggle_meta
ques
c_cond
(paren
id|c
op_or
l_int|0x80
)paren
suffix:colon
id|c
)braket
suffix:semicolon
)brace
multiline_comment|/* If the original code was &lt; 32 we only allow a&n;&t;&t; * glyph to be displayed if the code is not normally&n;&t;&t; * used (such as for cursor movement) or if the&n;&t;&t; * disp_ctrl mode has been explicitly enabled.&n;&t;&t; * Note: ESC is *never* allowed to be displayed as&n;&t;&t; * that would disable all escape sequences!&n;&t;&t; * To display font position 0x1B, go into UTF mode&n;&t;&t; * and display character U+F01B, or change the mapping.&n;&t;&t; */
id|ok
op_assign
(paren
id|tc
op_logical_and
(paren
id|c
op_ge
l_int|32
op_logical_or
(paren
op_logical_neg
id|utf
op_logical_and
op_logical_neg
(paren
(paren
(paren
id|disp_ctrl
ques
c_cond
id|CTRL_ALWAYS
suffix:colon
id|CTRL_ACTION
)paren
op_rshift
id|c
)paren
op_amp
l_int|1
)paren
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vc_state
op_eq
id|ESnormal
op_logical_and
id|ok
)paren
(brace
multiline_comment|/* Now try to find out how to display it */
id|tc
op_assign
id|conv_uni_to_pc
c_func
(paren
id|tc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tc
op_eq
op_minus
l_int|4
)paren
(brace
multiline_comment|/* If we got -4 (not found) then see if we have&n;&t;&t;&t;       defined a replacement character (U+FFFD) */
id|tc
op_assign
id|conv_uni_to_pc
c_func
(paren
l_int|0xfffd
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tc
op_eq
op_minus
l_int|3
)paren
(brace
multiline_comment|/* Bad hash table -- hope for the best */
id|tc
op_assign
id|c
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tc
op_amp
op_complement
id|console_charmask
)paren
r_continue
suffix:semicolon
multiline_comment|/* Conversion failed */
r_if
c_cond
(paren
id|need_wrap
)paren
(brace
id|cr
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|lf
c_func
(paren
id|currcons
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|decim
)paren
id|insert_char
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|scr_writew
c_func
(paren
id|video_mode_512ch
ques
c_cond
(paren
(paren
id|attr
op_amp
l_int|0xf7
)paren
op_lshift
l_int|8
)paren
op_plus
(paren
(paren
id|tc
op_amp
l_int|0x100
)paren
op_lshift
l_int|3
)paren
op_plus
(paren
id|tc
op_amp
l_int|0x0ff
)paren
suffix:colon
(paren
id|attr
op_lshift
l_int|8
)paren
op_plus
id|tc
comma
(paren
r_int
r_int
op_star
)paren
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
op_eq
id|video_num_columns
op_minus
l_int|1
)paren
id|need_wrap
op_assign
id|decawm
suffix:semicolon
r_else
(brace
id|x
op_increment
suffix:semicolon
id|pos
op_add_assign
l_int|2
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Control characters can be used in the _middle_&n;&t;&t; *  of an escape sequence.&n;&t;&t; */
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_int|7
suffix:colon
r_if
c_cond
(paren
id|bell_duration
)paren
id|kd_mksound
c_func
(paren
id|bell_pitch
comma
id|bell_duration
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|8
suffix:colon
id|bs
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|9
suffix:colon
id|pos
op_sub_assign
(paren
id|x
op_lshift
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|x
OL
id|video_num_columns
op_minus
l_int|1
)paren
(brace
id|x
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tab_stop
(braket
id|x
op_rshift
l_int|5
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|x
op_amp
l_int|31
)paren
)paren
)paren
r_break
suffix:semicolon
)brace
id|pos
op_add_assign
(paren
id|x
op_lshift
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|10
suffix:colon
r_case
l_int|11
suffix:colon
r_case
l_int|12
suffix:colon
id|lf
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_kbd
c_func
(paren
id|lnm
)paren
)paren
r_continue
suffix:semicolon
r_case
l_int|13
suffix:colon
id|cr
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|14
suffix:colon
id|charset
op_assign
l_int|1
suffix:semicolon
id|translate
op_assign
id|set_translate
c_func
(paren
id|G1_charset
)paren
suffix:semicolon
id|disp_ctrl
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|15
suffix:colon
id|charset
op_assign
l_int|0
suffix:semicolon
id|translate
op_assign
id|set_translate
c_func
(paren
id|G0_charset
)paren
suffix:semicolon
id|disp_ctrl
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|24
suffix:colon
r_case
l_int|26
suffix:colon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|27
suffix:colon
id|vc_state
op_assign
id|ESesc
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|127
suffix:colon
id|del
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_int|128
op_plus
l_int|27
suffix:colon
id|vc_state
op_assign
id|ESsquare
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|vc_state
)paren
(brace
r_case
id|ESesc
suffix:colon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;[&squot;
suffix:colon
id|vc_state
op_assign
id|ESsquare
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;]&squot;
suffix:colon
id|vc_state
op_assign
id|ESnonstd
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;%&squot;
suffix:colon
id|vc_state
op_assign
id|ESpercent
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;E&squot;
suffix:colon
id|cr
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|lf
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;M&squot;
suffix:colon
id|ri
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
id|lf
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;H&squot;
suffix:colon
id|tab_stop
(braket
id|x
op_rshift
l_int|5
)braket
op_or_assign
(paren
l_int|1
op_lshift
(paren
id|x
op_amp
l_int|31
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;Z&squot;
suffix:colon
id|respond_ID
c_func
(paren
id|tty
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;7&squot;
suffix:colon
id|save_cur
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;8&squot;
suffix:colon
id|restore_cur
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;(&squot;
suffix:colon
id|vc_state
op_assign
id|ESsetG0
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;)&squot;
suffix:colon
id|vc_state
op_assign
id|ESsetG1
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;#&squot;
suffix:colon
id|vc_state
op_assign
id|EShash
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
id|reset_terminal
c_func
(paren
id|currcons
comma
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;&gt;&squot;
suffix:colon
multiline_comment|/* Numeric keypad */
id|clr_kbd
c_func
(paren
id|kbdapplic
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;=&squot;
suffix:colon
multiline_comment|/* Appl. keypad */
id|set_kbd
c_func
(paren
id|kbdapplic
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
id|ESnonstd
suffix:colon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;P&squot;
)paren
(brace
multiline_comment|/* palette escape sequence */
r_for
c_loop
(paren
id|npar
op_assign
l_int|0
suffix:semicolon
id|npar
OL
id|NPAR
suffix:semicolon
id|npar
op_increment
)paren
id|par
(braket
id|npar
)braket
op_assign
l_int|0
suffix:semicolon
id|npar
op_assign
l_int|0
suffix:semicolon
id|vc_state
op_assign
id|ESpalette
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;R&squot;
)paren
(brace
multiline_comment|/* reset palette */
id|reset_palette
(paren
id|currcons
)paren
suffix:semicolon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
)brace
r_else
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|ESpalette
suffix:colon
r_if
c_cond
(paren
(paren
id|c
op_ge
l_char|&squot;0&squot;
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
op_logical_or
(paren
id|c
op_ge
l_char|&squot;A&squot;
op_logical_and
id|c
op_le
l_char|&squot;F&squot;
)paren
op_logical_or
(paren
id|c
op_ge
l_char|&squot;a&squot;
op_logical_and
id|c
op_le
l_char|&squot;f&squot;
)paren
)paren
(brace
id|par
(braket
id|npar
op_increment
)braket
op_assign
(paren
id|c
OG
l_char|&squot;9&squot;
ques
c_cond
(paren
id|c
op_amp
l_int|0xDF
)paren
op_minus
l_char|&squot;A&squot;
op_plus
l_int|10
suffix:colon
id|c
op_minus
l_char|&squot;0&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|npar
op_eq
l_int|7
)paren
(brace
r_int
id|i
op_assign
id|par
(braket
l_int|0
)braket
op_star
l_int|3
comma
id|j
op_assign
l_int|1
suffix:semicolon
id|palette
(braket
id|i
)braket
op_assign
l_int|16
op_star
id|par
(braket
id|j
op_increment
)braket
suffix:semicolon
id|palette
(braket
id|i
op_increment
)braket
op_add_assign
id|par
(braket
id|j
op_increment
)braket
suffix:semicolon
id|palette
(braket
id|i
)braket
op_assign
l_int|16
op_star
id|par
(braket
id|j
op_increment
)braket
suffix:semicolon
id|palette
(braket
id|i
op_increment
)braket
op_add_assign
id|par
(braket
id|j
op_increment
)braket
suffix:semicolon
id|palette
(braket
id|i
)braket
op_assign
l_int|16
op_star
id|par
(braket
id|j
op_increment
)braket
suffix:semicolon
id|palette
(braket
id|i
)braket
op_add_assign
id|par
(braket
id|j
)braket
suffix:semicolon
id|set_palette
c_func
(paren
)paren
suffix:semicolon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
)brace
)brace
r_else
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|ESsquare
suffix:colon
r_for
c_loop
(paren
id|npar
op_assign
l_int|0
suffix:semicolon
id|npar
OL
id|NPAR
suffix:semicolon
id|npar
op_increment
)paren
(brace
id|par
(braket
id|npar
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|npar
op_assign
l_int|0
suffix:semicolon
id|vc_state
op_assign
id|ESgetpars
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;[&squot;
)paren
(brace
multiline_comment|/* Function key */
id|vc_state
op_assign
id|ESfunckey
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|ques
op_assign
(paren
id|c
op_eq
l_char|&squot;?&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ques
)paren
r_continue
suffix:semicolon
r_case
id|ESgetpars
suffix:colon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;;&squot;
op_logical_and
id|npar
OL
id|NPAR
op_minus
l_int|1
)paren
(brace
id|npar
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_ge
l_char|&squot;0&squot;
op_logical_and
id|c
op_le
l_char|&squot;9&squot;
)paren
(brace
id|par
(braket
id|npar
)braket
op_mul_assign
l_int|10
suffix:semicolon
id|par
(braket
id|npar
)braket
op_add_assign
id|c
op_minus
l_char|&squot;0&squot;
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
id|vc_state
op_assign
id|ESgotpars
suffix:semicolon
r_case
id|ESgotpars
suffix:colon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;h&squot;
suffix:colon
id|set_mode
c_func
(paren
id|currcons
comma
l_int|1
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;l&squot;
suffix:colon
id|set_mode
c_func
(paren
id|currcons
comma
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;n&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|ques
)paren
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
op_eq
l_int|5
)paren
id|status_report
c_func
(paren
id|tty
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
op_eq
l_int|6
)paren
id|cursor_report
c_func
(paren
id|currcons
comma
id|tty
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ques
)paren
(brace
id|ques
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;G&squot;
suffix:colon
r_case
l_char|&squot;`&squot;
suffix:colon
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_decrement
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
comma
id|y
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;A&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|x
comma
id|y
op_minus
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;B&squot;
suffix:colon
r_case
l_char|&squot;e&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|x
comma
id|y
op_plus
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;C&squot;
suffix:colon
r_case
l_char|&squot;a&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|x
op_plus
id|par
(braket
l_int|0
)braket
comma
id|y
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;D&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|x
op_minus
id|par
(braket
l_int|0
)braket
comma
id|y
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;E&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
l_int|0
comma
id|y
op_plus
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;F&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_increment
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
l_int|0
comma
id|y
op_minus
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;d&squot;
suffix:colon
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_decrement
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|x
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;H&squot;
suffix:colon
r_case
l_char|&squot;f&squot;
suffix:colon
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|par
(braket
l_int|1
)braket
)paren
id|par
(braket
l_int|1
)braket
op_decrement
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|1
)braket
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;J&squot;
suffix:colon
id|csi_J
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;K&squot;
suffix:colon
id|csi_K
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;L&squot;
suffix:colon
id|csi_L
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;M&squot;
suffix:colon
id|csi_M
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;P&squot;
suffix:colon
id|csi_P
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;c&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|respond_ID
c_func
(paren
id|tty
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;g&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|tab_stop
(braket
id|x
op_rshift
l_int|5
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
(paren
id|x
op_amp
l_int|31
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
op_eq
l_int|3
)paren
(brace
id|tab_stop
(braket
l_int|0
)braket
op_assign
id|tab_stop
(braket
l_int|1
)braket
op_assign
id|tab_stop
(braket
l_int|2
)braket
op_assign
id|tab_stop
(braket
l_int|3
)braket
op_assign
id|tab_stop
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
l_char|&squot;m&squot;
suffix:colon
id|csi_m
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;q&squot;
suffix:colon
multiline_comment|/* DECLL - but only 3 leds */
multiline_comment|/* map 0,1,2,3 to 0,1,2,4 */
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
OL
l_int|4
)paren
id|setledstate
c_func
(paren
id|kbd_table
op_plus
id|currcons
comma
(paren
id|par
(braket
l_int|0
)braket
OL
l_int|3
)paren
ques
c_cond
id|par
(braket
l_int|0
)braket
suffix:colon
l_int|4
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;r&squot;
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|0
)braket
)paren
id|par
(braket
l_int|0
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|par
(braket
l_int|1
)braket
)paren
id|par
(braket
l_int|1
)braket
op_assign
id|video_num_lines
suffix:semicolon
multiline_comment|/* Minimum allowed region is 2 lines */
r_if
c_cond
(paren
id|par
(braket
l_int|0
)braket
OL
id|par
(braket
l_int|1
)braket
op_logical_and
id|par
(braket
l_int|1
)braket
op_le
id|video_num_lines
)paren
(brace
id|top
op_assign
id|par
(braket
l_int|0
)braket
op_minus
l_int|1
suffix:semicolon
id|bottom
op_assign
id|par
(braket
l_int|1
)braket
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
l_char|&squot;s&squot;
suffix:colon
id|save_cur
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;u&squot;
suffix:colon
id|restore_cur
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;X&squot;
suffix:colon
id|csi_X
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;@&squot;
suffix:colon
id|csi_at
c_func
(paren
id|currcons
comma
id|par
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;]&squot;
suffix:colon
multiline_comment|/* setterm functions */
id|setterm_command
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
id|ESpercent
suffix:colon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;@&squot;
suffix:colon
multiline_comment|/* defined in ISO 2022 */
id|utf
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
r_case
l_char|&squot;G&squot;
suffix:colon
multiline_comment|/* prelim official escape code */
r_case
l_char|&squot;8&squot;
suffix:colon
multiline_comment|/* retained for compatibility */
id|utf
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
id|ESfunckey
suffix:colon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|EShash
suffix:colon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;8&squot;
)paren
(brace
multiline_comment|/* DEC screen alignment test. kludge :-) */
id|video_erase_char
op_assign
(paren
id|video_erase_char
op_amp
l_int|0xff00
)paren
op_or
l_char|&squot;E&squot;
suffix:semicolon
id|csi_J
c_func
(paren
id|currcons
comma
l_int|2
)paren
suffix:semicolon
id|video_erase_char
op_assign
(paren
id|video_erase_char
op_amp
l_int|0xff00
)paren
op_or
l_char|&squot; &squot;
suffix:semicolon
)brace
r_continue
suffix:semicolon
r_case
id|ESsetG0
suffix:colon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;0&squot;
)paren
id|G0_charset
op_assign
id|GRAF_MAP
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;B&squot;
)paren
id|G0_charset
op_assign
id|LAT1_MAP
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;U&squot;
)paren
id|G0_charset
op_assign
id|IBMPC_MAP
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;K&squot;
)paren
id|G0_charset
op_assign
id|USER_MAP
suffix:semicolon
r_if
c_cond
(paren
id|charset
op_eq
l_int|0
)paren
id|translate
op_assign
id|set_translate
c_func
(paren
id|G0_charset
)paren
suffix:semicolon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_continue
suffix:semicolon
r_case
id|ESsetG1
suffix:colon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;0&squot;
)paren
id|G1_charset
op_assign
id|GRAF_MAP
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;B&squot;
)paren
id|G1_charset
op_assign
id|LAT1_MAP
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;U&squot;
)paren
id|G1_charset
op_assign
id|IBMPC_MAP
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;K&squot;
)paren
id|G1_charset
op_assign
id|USER_MAP
suffix:semicolon
r_if
c_cond
(paren
id|charset
op_eq
l_int|1
)paren
id|translate
op_assign
id|set_translate
c_func
(paren
id|G1_charset
)paren
suffix:semicolon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
r_continue
suffix:semicolon
r_default
suffix:colon
id|vc_state
op_assign
id|ESnormal
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|vcmode
op_ne
id|KD_GRAPHICS
)paren
id|set_cursor
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|enable_bh
c_func
(paren
id|CONSOLE_BH
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
DECL|function|con_write_room
r_static
r_int
id|con_write_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;stopped
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|4096
suffix:semicolon
multiline_comment|/* No limit, really; we&squot;re not buffering */
)brace
DECL|function|con_chars_in_buffer
r_static
r_int
id|con_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* we&squot;re not buffering */
)brace
DECL|function|poke_blanked_console
r_void
id|poke_blanked_console
c_func
(paren
r_void
)paren
(brace
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|BLANK_TIMER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vc_mode
op_eq
id|KD_GRAPHICS
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|console_blanked
)paren
(brace
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|fn
op_assign
id|unblank_screen
suffix:semicolon
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|expires
op_assign
l_int|0
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|BLANK_TIMER
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|blankinterval
)paren
(brace
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|blankinterval
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|BLANK_TIMER
suffix:semicolon
)brace
)brace
DECL|function|console_print
r_void
id|console_print
c_func
(paren
r_const
r_char
op_star
id|b
)paren
(brace
r_int
id|currcons
op_assign
id|fg_console
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
r_static
r_int
id|printing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|printable
op_logical_or
id|printing
)paren
r_return
suffix:semicolon
multiline_comment|/* console not yet initialized */
id|printing
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|kmsg_redirect
op_logical_and
id|vc_cons_allocated
c_func
(paren
id|kmsg_redirect
op_minus
l_int|1
)paren
)paren
id|currcons
op_assign
id|kmsg_redirect
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|currcons
)paren
)paren
(brace
multiline_comment|/* impossible */
id|printk
c_func
(paren
l_string|&quot;console_print: tty %d not allocated ??&bslash;n&quot;
comma
id|currcons
op_plus
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SERIAL_ECHO
id|serial_echo_print
c_func
(paren
id|b
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL_ECHO */
r_while
c_loop
(paren
(paren
id|c
op_assign
op_star
(paren
id|b
op_increment
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
l_int|10
op_logical_or
id|c
op_eq
l_int|13
op_logical_or
id|need_wrap
)paren
(brace
r_if
c_cond
(paren
id|c
op_ne
l_int|13
)paren
id|lf
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|cr
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|10
op_logical_or
id|c
op_eq
l_int|13
)paren
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_int|8
)paren
(brace
multiline_comment|/* backspace */
id|bs
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|scr_writew
c_func
(paren
(paren
id|attr
op_lshift
l_int|8
)paren
op_plus
id|c
comma
(paren
r_int
r_int
op_star
)paren
id|pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|x
op_eq
id|video_num_columns
op_minus
l_int|1
)paren
(brace
id|need_wrap
op_assign
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|x
op_increment
suffix:semicolon
id|pos
op_add_assign
l_int|2
suffix:semicolon
)brace
id|set_cursor
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|poke_blanked_console
c_func
(paren
)paren
suffix:semicolon
id|printing
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * con_throttle and con_unthrottle are only used for&n; * paste_selection(), which has to stuff in a large number of&n; * characters...&n; */
DECL|function|con_throttle
r_static
r_void
id|con_throttle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
)brace
DECL|function|con_unthrottle
r_static
r_void
id|con_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_struct
id|vt_struct
op_star
id|vt
op_assign
(paren
r_struct
id|vt_struct
op_star
)paren
id|tty-&gt;driver_data
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|vt-&gt;paste_wait
)paren
suffix:semicolon
)brace
DECL|function|vc_init
r_static
r_void
id|vc_init
c_func
(paren
r_int
r_int
id|currcons
comma
r_int
r_int
id|rows
comma
r_int
r_int
id|cols
comma
r_int
id|do_clear
)paren
(brace
r_int
id|base
op_assign
(paren
r_int
)paren
id|vc_scrbuf
(braket
id|currcons
)braket
suffix:semicolon
r_int
id|j
comma
id|k
suffix:semicolon
id|video_num_columns
op_assign
id|cols
suffix:semicolon
id|video_num_lines
op_assign
id|rows
suffix:semicolon
id|video_size_row
op_assign
id|cols
op_lshift
l_int|1
suffix:semicolon
id|video_screen_size
op_assign
id|video_num_lines
op_star
id|video_size_row
suffix:semicolon
id|pos
op_assign
id|origin
op_assign
id|video_mem_start
op_assign
id|base
suffix:semicolon
id|scr_end
op_assign
id|base
op_plus
id|video_screen_size
suffix:semicolon
id|video_mem_end
op_assign
id|base
op_plus
id|video_screen_size
suffix:semicolon
id|reset_vc
c_func
(paren
id|currcons
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|k
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
(brace
id|vc_cons
(braket
id|currcons
)braket
dot
id|d-&gt;vc_palette
(braket
id|k
op_increment
)braket
op_assign
id|default_red
(braket
id|j
)braket
suffix:semicolon
id|vc_cons
(braket
id|currcons
)braket
dot
id|d-&gt;vc_palette
(braket
id|k
op_increment
)braket
op_assign
id|default_grn
(braket
id|j
)braket
suffix:semicolon
id|vc_cons
(braket
id|currcons
)braket
dot
id|d-&gt;vc_palette
(braket
id|k
op_increment
)braket
op_assign
id|default_blu
(braket
id|j
)braket
suffix:semicolon
)brace
id|def_color
op_assign
l_int|0x07
suffix:semicolon
multiline_comment|/* white */
id|ulcolor
op_assign
l_int|0x0f
suffix:semicolon
multiline_comment|/* bold white */
id|halfcolor
op_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* grey */
id|vt_cons
(braket
id|currcons
)braket
op_member_access_from_pointer
id|paste_wait
op_assign
l_int|0
suffix:semicolon
id|reset_terminal
c_func
(paren
id|currcons
comma
id|do_clear
)paren
suffix:semicolon
)brace
DECL|function|con_setsize
r_static
r_void
id|con_setsize
c_func
(paren
r_int
r_int
id|rows
comma
r_int
r_int
id|cols
)paren
(brace
id|video_num_lines
op_assign
id|rows
suffix:semicolon
id|video_num_columns
op_assign
id|cols
suffix:semicolon
id|video_size_row
op_assign
l_int|2
op_star
id|cols
suffix:semicolon
id|video_screen_size
op_assign
id|video_num_lines
op_star
id|video_size_row
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the console switching bottom half handler.&n; *&n; * Doing console switching in a bottom half handler allows&n; * us to do the switches asynchronously (needed when we want&n; * to switch due to a keyboard interrupt), while still giving&n; * us the option to easily disable it to avoid races when we&n; * need to write to the console.&n; */
DECL|function|console_bh
r_static
r_void
id|console_bh
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|want_console
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|want_console
op_ne
id|fg_console
)paren
(brace
id|change_console
c_func
(paren
id|want_console
)paren
suffix:semicolon
multiline_comment|/* we only changed when the console had already&n;&t;&t;&t;   been allocated - a new console is not created&n;&t;&t;&t;   in an interrupt routine */
)brace
id|want_console
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|do_poke_blanked_console
)paren
(brace
multiline_comment|/* do not unblank for a LED change */
id|do_poke_blanked_console
op_assign
l_int|0
suffix:semicolon
id|poke_blanked_console
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *  unsigned long con_init(unsigned long);&n; *&n; * This routine initializes console interrupts, and does nothing&n; * else. If you want the screen to clear, call tty_write with&n; * the appropriate escape-sequence.&n; *&n; * Reads the information preserved by setup.s to determine the current display&n; * type and sets everything accordingly.&n; */
DECL|function|con_init
r_int
r_int
id|con_init
c_func
(paren
r_int
r_int
id|kmem_start
)paren
(brace
r_const
r_char
op_star
id|display_desc
op_assign
l_string|&quot;????&quot;
suffix:semicolon
r_int
id|currcons
op_assign
l_int|0
suffix:semicolon
r_int
id|orig_x
op_assign
id|ORIG_X
suffix:semicolon
r_int
id|orig_y
op_assign
id|ORIG_Y
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|console_driver
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_driver
)paren
)paren
suffix:semicolon
id|console_driver.magic
op_assign
id|TTY_DRIVER_MAGIC
suffix:semicolon
id|console_driver.name
op_assign
l_string|&quot;tty&quot;
suffix:semicolon
id|console_driver.name_base
op_assign
l_int|1
suffix:semicolon
id|console_driver.major
op_assign
id|TTY_MAJOR
suffix:semicolon
id|console_driver.minor_start
op_assign
l_int|1
suffix:semicolon
id|console_driver.num
op_assign
id|MAX_NR_CONSOLES
suffix:semicolon
id|console_driver.type
op_assign
id|TTY_DRIVER_TYPE_CONSOLE
suffix:semicolon
id|console_driver.init_termios
op_assign
id|tty_std_termios
suffix:semicolon
id|console_driver.flags
op_assign
id|TTY_DRIVER_REAL_RAW
op_or
id|TTY_DRIVER_RESET_TERMIOS
suffix:semicolon
id|console_driver.refcount
op_assign
op_amp
id|console_refcount
suffix:semicolon
id|console_driver.table
op_assign
id|console_table
suffix:semicolon
id|console_driver.termios
op_assign
id|console_termios
suffix:semicolon
id|console_driver.termios_locked
op_assign
id|console_termios_locked
suffix:semicolon
id|console_driver.open
op_assign
id|con_open
suffix:semicolon
id|console_driver.write
op_assign
id|con_write
suffix:semicolon
id|console_driver.write_room
op_assign
id|con_write_room
suffix:semicolon
id|console_driver.chars_in_buffer
op_assign
id|con_chars_in_buffer
suffix:semicolon
id|console_driver.ioctl
op_assign
id|vt_ioctl
suffix:semicolon
id|console_driver.stop
op_assign
id|con_stop
suffix:semicolon
id|console_driver.start
op_assign
id|con_start
suffix:semicolon
id|console_driver.throttle
op_assign
id|con_throttle
suffix:semicolon
id|console_driver.unthrottle
op_assign
id|con_unthrottle
suffix:semicolon
r_if
c_cond
(paren
id|tty_register_driver
c_func
(paren
op_amp
id|console_driver
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t register console driver&bslash;n&quot;
)paren
suffix:semicolon
id|con_setsize
c_func
(paren
id|ORIG_VIDEO_LINES
comma
id|ORIG_VIDEO_COLS
)paren
suffix:semicolon
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|fn
op_assign
id|blank_screen
suffix:semicolon
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|expires
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|blankinterval
)paren
(brace
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|blankinterval
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|BLANK_TIMER
suffix:semicolon
)brace
id|kmem_start
op_assign
id|con_type_init
c_func
(paren
id|kmem_start
comma
op_amp
id|display_desc
)paren
suffix:semicolon
id|hardscroll_enabled
op_assign
(paren
id|hardscroll_disabled_by_init
ques
c_cond
l_int|0
suffix:colon
(paren
id|video_type
op_eq
id|VIDEO_TYPE_EGAC
op_logical_or
id|video_type
op_eq
id|VIDEO_TYPE_VGAC
op_logical_or
id|video_type
op_eq
id|VIDEO_TYPE_EGAM
)paren
)paren
suffix:semicolon
id|has_wrapped
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Due to kmalloc roundup allocating statically is more efficient -&n;&t;   so provide MIN_NR_CONSOLES for people with very little memory */
r_for
c_loop
(paren
id|currcons
op_assign
l_int|0
suffix:semicolon
id|currcons
OL
id|MIN_NR_CONSOLES
suffix:semicolon
id|currcons
op_increment
)paren
(brace
r_int
id|j
comma
id|k
suffix:semicolon
id|vc_cons
(braket
id|currcons
)braket
dot
id|d
op_assign
(paren
r_struct
id|vc_data
op_star
)paren
id|kmem_start
suffix:semicolon
id|kmem_start
op_add_assign
r_sizeof
(paren
r_struct
id|vc_data
)paren
suffix:semicolon
id|vt_cons
(braket
id|currcons
)braket
op_assign
(paren
r_struct
id|vt_struct
op_star
)paren
id|kmem_start
suffix:semicolon
id|kmem_start
op_add_assign
r_sizeof
(paren
r_struct
id|vt_struct
)paren
suffix:semicolon
id|vc_scrbuf
(braket
id|currcons
)braket
op_assign
(paren
r_int
r_int
op_star
)paren
id|kmem_start
suffix:semicolon
id|kmem_start
op_add_assign
id|video_screen_size
suffix:semicolon
id|kmalloced
op_assign
l_int|0
suffix:semicolon
id|screenbuf_size
op_assign
id|video_screen_size
suffix:semicolon
id|vc_init
c_func
(paren
id|currcons
comma
id|video_num_lines
comma
id|video_num_columns
comma
id|currcons
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|k
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
(brace
id|vc_cons
(braket
id|currcons
)braket
dot
id|d-&gt;vc_palette
(braket
id|k
op_increment
)braket
op_assign
id|default_red
(braket
id|j
)braket
suffix:semicolon
id|vc_cons
(braket
id|currcons
)braket
dot
id|d-&gt;vc_palette
(braket
id|k
op_increment
)braket
op_assign
id|default_grn
(braket
id|j
)braket
suffix:semicolon
id|vc_cons
(braket
id|currcons
)braket
dot
id|d-&gt;vc_palette
(braket
id|k
op_increment
)braket
op_assign
id|default_blu
(braket
id|j
)braket
suffix:semicolon
)brace
)brace
id|currcons
op_assign
id|fg_console
op_assign
l_int|0
suffix:semicolon
id|video_mem_start
op_assign
id|video_mem_base
suffix:semicolon
id|video_mem_end
op_assign
id|video_mem_term
suffix:semicolon
id|origin
op_assign
id|video_mem_start
suffix:semicolon
id|scr_end
op_assign
id|video_mem_start
op_plus
id|video_num_lines
op_star
id|video_size_row
suffix:semicolon
id|gotoxy
c_func
(paren
id|currcons
comma
id|orig_x
comma
id|orig_y
)paren
suffix:semicolon
id|set_origin
c_func
(paren
id|currcons
)paren
suffix:semicolon
id|csi_J
c_func
(paren
id|currcons
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Figure out the size of the screen and screen font so we&n;&t;   can figure out the appropriate screen size should we load&n;&t;   a different font */
id|printable
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|video_type
op_eq
id|VIDEO_TYPE_VGAC
op_logical_or
id|video_type
op_eq
id|VIDEO_TYPE_EGAC
op_logical_or
id|video_type
op_eq
id|VIDEO_TYPE_EGAM
op_logical_or
id|video_type
op_eq
id|VIDEO_TYPE_TGAC
)paren
(brace
id|default_font_height
op_assign
id|video_font_height
op_assign
id|ORIG_VIDEO_POINTS
suffix:semicolon
multiline_comment|/* This may be suboptimal but is a safe bet - go with it */
id|video_scan_lines
op_assign
id|video_font_height
op_star
id|video_num_lines
suffix:semicolon
macro_line|#ifdef CONFIG_SERIAL_ECHO
id|serial_echo_init
c_func
(paren
id|SERIAL_ECHO_PORT
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_SERIAL_ECHO */
id|printk
c_func
(paren
l_string|&quot;Console: %ld point font, %ld scans&bslash;n&quot;
comma
id|video_font_height
comma
id|video_scan_lines
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Console: %s %s %ldx%ld, %d virtual console%s (max %d)&bslash;n&quot;
comma
id|can_do_color
ques
c_cond
l_string|&quot;colour&quot;
suffix:colon
l_string|&quot;mono&quot;
comma
id|display_desc
comma
id|video_num_columns
comma
id|video_num_lines
comma
id|MIN_NR_CONSOLES
comma
(paren
id|MIN_NR_CONSOLES
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;s&quot;
comma
id|MAX_NR_CONSOLES
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * can&squot;t register TGA yet, because PCI bus probe has *not* taken&n;&t; * place before con_init() gets called. Trigger the real TGA hw&n;&t; * initialization and register_console() event from&n;&t; * within the bus probing code... :-(&n;&t; */
r_if
c_cond
(paren
id|video_type
op_ne
id|VIDEO_TYPE_TGAC
)paren
id|register_console
c_func
(paren
id|console_print
)paren
suffix:semicolon
id|init_bh
c_func
(paren
id|CONSOLE_BH
comma
id|console_bh
)paren
suffix:semicolon
r_return
id|kmem_start
suffix:semicolon
)brace
DECL|function|vesa_powerdown_screen
r_void
id|vesa_powerdown_screen
c_func
(paren
r_void
)paren
(brace
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|BLANK_TIMER
)paren
suffix:semicolon
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|fn
op_assign
id|unblank_screen
suffix:semicolon
id|vesa_powerdown
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_blank_screen
r_void
id|do_blank_screen
c_func
(paren
r_int
id|nopowersave
)paren
(brace
r_int
id|currcons
suffix:semicolon
macro_line|#ifdef CONFIG_APM
r_if
c_cond
(paren
id|apm_display_blank
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|console_blanked
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|vesa_off_interval
op_logical_and
op_logical_neg
id|nopowersave
)paren
(brace
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|fn
op_assign
id|vesa_powerdown_screen
suffix:semicolon
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|vesa_off_interval
suffix:semicolon
id|timer_active
op_or_assign
(paren
l_int|1
op_lshift
id|BLANK_TIMER
)paren
suffix:semicolon
)brace
r_else
(brace
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|BLANK_TIMER
)paren
suffix:semicolon
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|fn
op_assign
id|unblank_screen
suffix:semicolon
)brace
multiline_comment|/* try not to lose information by blanking, and not to waste memory */
id|currcons
op_assign
id|fg_console
suffix:semicolon
id|has_scrolled
op_assign
l_int|0
suffix:semicolon
id|blank__origin
op_assign
id|__origin
suffix:semicolon
id|blank_origin
op_assign
id|origin
suffix:semicolon
id|set_origin
c_func
(paren
id|fg_console
)paren
suffix:semicolon
id|get_scrmem
c_func
(paren
id|fg_console
)paren
suffix:semicolon
id|unblank_origin
op_assign
id|origin
suffix:semicolon
id|memsetw
c_func
(paren
(paren
r_void
op_star
)paren
id|blank_origin
comma
id|BLANK
comma
l_int|2
op_star
id|video_num_lines
op_star
id|video_num_columns
)paren
suffix:semicolon
id|hide_cursor
c_func
(paren
)paren
suffix:semicolon
id|console_blanked
op_assign
id|fg_console
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nopowersave
)paren
(brace
id|vesa_blank
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_unblank_screen
r_void
id|do_unblank_screen
c_func
(paren
r_void
)paren
(brace
r_int
id|currcons
suffix:semicolon
r_int
id|resetorg
suffix:semicolon
r_int
id|offset
suffix:semicolon
macro_line|#ifdef CONFIG_APM
r_if
c_cond
(paren
id|apm_display_unblank
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|console_blanked
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|fg_console
)paren
)paren
(brace
multiline_comment|/* impossible */
id|printk
c_func
(paren
l_string|&quot;unblank_screen: tty %d not allocated ??&bslash;n&quot;
comma
id|fg_console
op_plus
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|fn
op_assign
id|blank_screen
suffix:semicolon
r_if
c_cond
(paren
id|blankinterval
)paren
(brace
id|timer_table
(braket
id|BLANK_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|blankinterval
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|BLANK_TIMER
suffix:semicolon
)brace
id|currcons
op_assign
id|fg_console
suffix:semicolon
id|offset
op_assign
l_int|0
suffix:semicolon
id|resetorg
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|console_blanked
op_eq
id|fg_console
op_plus
l_int|1
op_logical_and
id|origin
op_eq
id|unblank_origin
op_logical_and
op_logical_neg
id|has_scrolled
)paren
(brace
multiline_comment|/* try to restore the exact situation before blanking */
id|resetorg
op_assign
l_int|1
suffix:semicolon
id|offset
op_assign
(paren
id|blank_origin
op_minus
id|video_mem_base
)paren
op_minus
(paren
id|unblank_origin
op_minus
id|video_mem_start
)paren
suffix:semicolon
)brace
id|console_blanked
op_assign
l_int|0
suffix:semicolon
id|set_scrmem
c_func
(paren
id|fg_console
comma
id|offset
)paren
suffix:semicolon
id|set_origin
c_func
(paren
id|fg_console
)paren
suffix:semicolon
id|set_cursor
c_func
(paren
id|fg_console
)paren
suffix:semicolon
r_if
c_cond
(paren
id|resetorg
)paren
id|__set_origin
c_func
(paren
id|blank__origin
)paren
suffix:semicolon
id|vesa_unblank
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * If a blank_screen is due to a timer, then a power save is allowed.&n; * If it is related to console_switching, then avoid vesa_blank().&n; */
DECL|function|blank_screen
r_static
r_void
id|blank_screen
c_func
(paren
r_void
)paren
(brace
id|do_blank_screen
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|unblank_screen
r_static
r_void
id|unblank_screen
c_func
(paren
r_void
)paren
(brace
id|do_unblank_screen
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|update_screen
r_void
id|update_screen
c_func
(paren
r_int
id|new_console
)paren
(brace
r_static
r_int
id|lock
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|new_console
op_eq
id|fg_console
op_logical_or
id|lock
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|new_console
)paren
)paren
(brace
multiline_comment|/* strange ... */
id|printk
c_func
(paren
l_string|&quot;update_screen: tty %d not allocated ??&bslash;n&quot;
comma
id|new_console
op_plus
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lock
op_assign
l_int|1
suffix:semicolon
id|clear_selection
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|console_blanked
)paren
id|get_scrmem
c_func
(paren
id|fg_console
)paren
suffix:semicolon
r_else
id|console_blanked
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* no longer of the form console+1 */
id|fg_console
op_assign
id|new_console
suffix:semicolon
multiline_comment|/* this is the only (nonzero) assignment to fg_console */
multiline_comment|/* consequently, fg_console will always be allocated */
id|set_scrmem
c_func
(paren
id|fg_console
comma
l_int|0
)paren
suffix:semicolon
id|set_origin
c_func
(paren
id|fg_console
)paren
suffix:semicolon
id|set_cursor
c_func
(paren
id|fg_console
)paren
suffix:semicolon
id|set_leds
c_func
(paren
)paren
suffix:semicolon
id|compute_shiftstate
c_func
(paren
)paren
suffix:semicolon
id|lock
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Allocate the console screen memory.&n; */
DECL|function|con_open
r_int
id|con_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
r_int
id|idx
suffix:semicolon
r_int
id|i
suffix:semicolon
id|idx
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
suffix:semicolon
id|i
op_assign
id|vc_allocate
c_func
(paren
id|idx
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|vt_cons
(braket
id|idx
)braket
op_member_access_from_pointer
id|vc_num
op_assign
id|idx
suffix:semicolon
id|tty-&gt;driver_data
op_assign
id|vt_cons
(braket
id|idx
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;winsize.ws_row
op_logical_and
op_logical_neg
id|tty-&gt;winsize.ws_col
)paren
(brace
id|tty-&gt;winsize.ws_row
op_assign
id|video_num_lines
suffix:semicolon
id|tty-&gt;winsize.ws_col
op_assign
id|video_num_columns
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Load palette into the EGA/VGA DAC registers. arg points to a colour&n; * map, 3 bytes per colour, 16 colours, range from 0 to 255.&n; */
DECL|function|con_set_cmap
r_int
id|con_set_cmap
(paren
r_int
r_char
op_star
id|arg
)paren
(brace
r_return
id|set_get_cmap
(paren
id|arg
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|con_get_cmap
r_int
id|con_get_cmap
(paren
r_int
r_char
op_star
id|arg
)paren
(brace
r_return
id|set_get_cmap
(paren
id|arg
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|reset_palette
r_void
id|reset_palette
(paren
r_int
id|currcons
)paren
(brace
r_int
id|j
comma
id|k
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|k
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
(brace
id|palette
(braket
id|k
op_increment
)braket
op_assign
id|default_red
(braket
id|j
)braket
suffix:semicolon
id|palette
(braket
id|k
op_increment
)braket
op_assign
id|default_grn
(braket
id|j
)braket
suffix:semicolon
id|palette
(braket
id|k
op_increment
)braket
op_assign
id|default_blu
(braket
id|j
)braket
suffix:semicolon
)brace
id|set_palette
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Load font into the EGA/VGA character generator. arg points to a 8192&n; * byte map, 32 bytes per character. Only first H of them are used for&n; * 8xH fonts (0 &lt; H &lt;= 32).&n; */
DECL|function|con_set_font
r_int
id|con_set_font
(paren
r_char
op_star
id|arg
comma
r_int
id|ch512
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|set_get_font
(paren
id|arg
comma
l_int|1
comma
id|ch512
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|hashtable_contents_valid
op_assign
l_int|0
suffix:semicolon
id|video_mode_512ch
op_assign
id|ch512
suffix:semicolon
id|console_charmask
op_assign
id|ch512
ques
c_cond
l_int|0x1ff
suffix:colon
l_int|0x0ff
suffix:semicolon
)brace
r_return
id|i
suffix:semicolon
)brace
DECL|function|con_get_font
r_int
id|con_get_font
(paren
r_char
op_star
id|arg
)paren
(brace
r_return
id|set_get_font
(paren
id|arg
comma
l_int|0
comma
id|video_mode_512ch
)paren
suffix:semicolon
)brace
eof
