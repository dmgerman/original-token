multiline_comment|/*&n; * n_tty.c --- implements the N_TTY line discipline.&n; * &n; * This code used to be in tty_io.c, but things are getting hairy&n; * enough that it made sense to split things off.  (The N_TTY&n; * processing has changed so much that it&squot;s hardly recognizable,&n; * anyway...)&n; *&n; * Note that the open routine for N_TTY is guaranteed never to return&n; * an error.  This is because Linux will fall back to setting a line&n; * to N_TTY if it can not switch to any other line discipline.  &n; *&n; * Written by Theodore Ts&squot;o, Copyright 1994.&n; * &n; * This file also contains code originally written by Linus Torvalds,&n; * Copyright 1991, 1992, 1993, and by Julian Cowley, Copyright 1994.&n; * &n; * This file may be redistributed under the terms of the GNU Public&n; * License.&n; *&n; * Reduced memory usage for older ARM systems  - Russell King.&n; *&n; * 2000/01/20   Fixed SMP locking on put_tty_queue using bits of &n; *&t;&t;the patch by Andrew J. Kroll &lt;ag784@freenet.buffalo.edu&gt;&n; *&t;&t;who actually finally proved there really was a race.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/kd.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
DECL|macro|CONSOLE_DEV
mdefine_line|#define CONSOLE_DEV MKDEV(TTY_MAJOR,0)
DECL|macro|SYSCONS_DEV
mdefine_line|#define SYSCONS_DEV  MKDEV(TTYAUX_MAJOR,1)
macro_line|#ifndef MIN
DECL|macro|MIN
mdefine_line|#define MIN(a,b)&t;((a) &lt; (b) ? (a) : (b))
macro_line|#endif
multiline_comment|/* number of characters left in xmit buffer before select has we have room */
DECL|macro|WAKEUP_CHARS
mdefine_line|#define WAKEUP_CHARS 256
multiline_comment|/*&n; * This defines the low- and high-watermarks for throttling and&n; * unthrottling the TTY driver.  These watermarks are used for&n; * controlling the space in the read buffer.&n; */
DECL|macro|TTY_THRESHOLD_THROTTLE
mdefine_line|#define TTY_THRESHOLD_THROTTLE&t;&t;128 /* now based on remaining room */
DECL|macro|TTY_THRESHOLD_UNTHROTTLE
mdefine_line|#define TTY_THRESHOLD_UNTHROTTLE &t;128
DECL|function|alloc_buf
r_static
r_inline
r_int
r_char
op_star
id|alloc_buf
c_func
(paren
r_void
)paren
(brace
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
id|prio
op_assign
id|in_interrupt
c_func
(paren
)paren
ques
c_cond
id|GFP_ATOMIC
suffix:colon
id|GFP_KERNEL
suffix:semicolon
r_if
c_cond
(paren
id|PAGE_SIZE
op_ne
id|N_TTY_BUF_SIZE
)paren
(brace
id|p
op_assign
id|kmalloc
c_func
(paren
id|N_TTY_BUF_SIZE
comma
id|prio
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
id|memset
c_func
(paren
id|p
comma
l_int|0
comma
id|N_TTY_BUF_SIZE
)paren
suffix:semicolon
)brace
r_else
id|p
op_assign
(paren
r_int
r_char
op_star
)paren
id|get_zeroed_page
c_func
(paren
id|prio
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
DECL|function|free_buf
r_static
r_inline
r_void
id|free_buf
c_func
(paren
r_int
r_char
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
id|PAGE_SIZE
op_ne
id|N_TTY_BUF_SIZE
)paren
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_else
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buf
)paren
suffix:semicolon
)brace
DECL|function|put_tty_queue
r_static
r_inline
r_void
id|put_tty_queue
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The problem of stomping on the buffers ends here.&n;&t; *&t;Why didn&squot;t anyone see this one comming? --AJK&n;&t;*/
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;read_cnt
OL
id|N_TTY_BUF_SIZE
)paren
(brace
id|tty-&gt;read_buf
(braket
id|tty-&gt;read_head
)braket
op_assign
id|c
suffix:semicolon
id|tty-&gt;read_head
op_assign
(paren
id|tty-&gt;read_head
op_plus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_increment
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Check whether to call the driver.unthrottle function.&n; * We test the TTY_THROTTLED bit first so that it always&n; * indicates the current state.&n; */
DECL|function|check_unthrottle
r_static
r_void
id|check_unthrottle
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;count
op_logical_and
id|test_and_clear_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
op_logical_and
id|tty-&gt;driver.unthrottle
)paren
id|tty-&gt;driver
dot
id|unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Reset the read buffer counters, clear the flags, &n; * and make sure the driver is unthrottled. Called&n; * from n_tty_open() and n_tty_flush_buffer().&n; */
DECL|function|reset_buffer_flags
r_static
r_void
id|reset_buffer_flags
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
id|tty-&gt;read_tail
op_assign
id|tty-&gt;read_cnt
op_assign
l_int|0
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;canon_head
op_assign
id|tty-&gt;canon_data
op_assign
id|tty-&gt;erasing
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tty-&gt;read_flags
comma
l_int|0
comma
r_sizeof
id|tty-&gt;read_flags
)paren
suffix:semicolon
id|check_unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Flush the input buffer&n; */
DECL|function|n_tty_flush_buffer
r_void
id|n_tty_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
multiline_comment|/* clear everything and unthrottle the driver */
id|reset_buffer_flags
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;link
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;link-&gt;packet
)paren
(brace
id|tty-&gt;ctrl_status
op_or_assign
id|TIOCPKT_FLUSHREAD
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;link-&gt;read_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Return number of characters buffered to be delivered to user&n; */
DECL|function|n_tty_chars_in_buffer
id|ssize_t
id|n_tty_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|ssize_t
id|n
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;icanon
)paren
(brace
id|n
op_assign
id|tty-&gt;read_cnt
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tty-&gt;canon_data
)paren
(brace
id|n
op_assign
(paren
id|tty-&gt;canon_head
OG
id|tty-&gt;read_tail
)paren
ques
c_cond
id|tty-&gt;canon_head
op_minus
id|tty-&gt;read_tail
suffix:colon
id|tty-&gt;canon_head
op_plus
(paren
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_tail
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform OPOST processing.  Returns -1 when the output device is&n; * full and the character must be retried.&n; */
DECL|function|opost
r_static
r_int
id|opost
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|space
comma
id|spaces
suffix:semicolon
id|space
op_assign
id|tty-&gt;driver
dot
id|write_room
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|space
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|O_OPOST
c_func
(paren
id|tty
)paren
)paren
(brace
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
r_if
c_cond
(paren
id|O_ONLRET
c_func
(paren
id|tty
)paren
)paren
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|O_ONLCR
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|space
OL
l_int|2
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|tty-&gt;driver
dot
id|put_char
c_func
(paren
id|tty
comma
l_char|&squot;&bslash;r&squot;
)paren
suffix:semicolon
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
)brace
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;r&squot;
suffix:colon
r_if
c_cond
(paren
id|O_ONOCR
c_func
(paren
id|tty
)paren
op_logical_and
id|tty-&gt;column
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|O_OCRNL
c_func
(paren
id|tty
)paren
)paren
(brace
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_if
c_cond
(paren
id|O_ONLRET
c_func
(paren
id|tty
)paren
)paren
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
id|spaces
op_assign
l_int|8
op_minus
(paren
id|tty-&gt;column
op_amp
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|O_TABDLY
c_func
(paren
id|tty
)paren
op_eq
id|XTABS
)paren
(brace
r_if
c_cond
(paren
id|space
OL
id|spaces
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|tty-&gt;column
op_add_assign
id|spaces
suffix:semicolon
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
l_string|&quot;        &quot;
comma
id|spaces
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tty-&gt;column
op_add_assign
id|spaces
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;b&squot;
suffix:colon
r_if
c_cond
(paren
id|tty-&gt;column
OG
l_int|0
)paren
id|tty-&gt;column
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|O_OLCUC
c_func
(paren
id|tty
)paren
)paren
id|c
op_assign
id|toupper
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iscntrl
c_func
(paren
id|c
)paren
)paren
id|tty-&gt;column
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|tty-&gt;driver
dot
id|put_char
c_func
(paren
id|tty
comma
id|c
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * opost_block --- to speed up block console writes, among other&n; * things.&n; */
DECL|function|opost_block
r_static
id|ssize_t
id|opost_block
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|inbuf
comma
r_int
r_int
id|nr
)paren
(brace
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
r_int
id|space
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
op_star
id|cp
suffix:semicolon
id|space
op_assign
id|tty-&gt;driver
dot
id|write_room
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|space
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
id|space
)paren
id|nr
op_assign
id|space
suffix:semicolon
r_if
c_cond
(paren
id|nr
OG
r_sizeof
(paren
id|buf
)paren
)paren
id|nr
op_assign
r_sizeof
(paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buf
comma
id|inbuf
comma
id|nr
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|cp
op_assign
id|buf
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
comma
id|cp
op_increment
)paren
(brace
r_switch
c_cond
(paren
op_star
id|cp
)paren
(brace
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
r_if
c_cond
(paren
id|O_ONLRET
c_func
(paren
id|tty
)paren
)paren
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|O_ONLCR
c_func
(paren
id|tty
)paren
)paren
r_goto
id|break_out
suffix:semicolon
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;r&squot;
suffix:colon
r_if
c_cond
(paren
id|O_ONOCR
c_func
(paren
id|tty
)paren
op_logical_and
id|tty-&gt;column
op_eq
l_int|0
)paren
r_goto
id|break_out
suffix:semicolon
r_if
c_cond
(paren
id|O_OCRNL
c_func
(paren
id|tty
)paren
)paren
(brace
op_star
id|cp
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_if
c_cond
(paren
id|O_ONLRET
c_func
(paren
id|tty
)paren
)paren
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
r_goto
id|break_out
suffix:semicolon
r_case
l_char|&squot;&bslash;b&squot;
suffix:colon
r_if
c_cond
(paren
id|tty-&gt;column
OG
l_int|0
)paren
id|tty-&gt;column
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|O_OLCUC
c_func
(paren
id|tty
)paren
)paren
op_star
id|cp
op_assign
id|toupper
c_func
(paren
op_star
id|cp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iscntrl
c_func
(paren
op_star
id|cp
)paren
)paren
id|tty-&gt;column
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|break_out
suffix:colon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_chars
)paren
id|tty-&gt;driver
dot
id|flush_chars
c_func
(paren
id|tty
)paren
suffix:semicolon
id|i
op_assign
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
id|buf
comma
id|i
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|put_char
r_static
r_inline
r_void
id|put_char
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|tty-&gt;driver
dot
id|put_char
c_func
(paren
id|tty
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/* Must be called only when L_ECHO(tty) is true. */
DECL|function|echo_char
r_static
r_void
id|echo_char
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
op_logical_and
id|iscntrl
c_func
(paren
id|c
)paren
op_logical_and
id|c
op_ne
l_char|&squot;&bslash;t&squot;
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;^&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
id|c
op_xor
l_int|0100
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;column
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
id|opost
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
DECL|function|finish_erasing
r_static
r_inline
r_void
id|finish_erasing
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;erasing
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;/&squot;
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;column
op_add_assign
l_int|2
suffix:semicolon
id|tty-&gt;erasing
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|eraser
r_static
r_void
id|eraser
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_enum
(brace
id|ERASE
comma
id|WERASE
comma
id|KILL
)brace
id|kill_type
suffix:semicolon
r_int
id|head
comma
id|seen_alnums
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;read_head
op_eq
id|tty-&gt;canon_head
)paren
(brace
multiline_comment|/* opost(&squot;&bslash;a&squot;, tty); */
multiline_comment|/* what do you think? */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|ERASE_CHAR
c_func
(paren
id|tty
)paren
)paren
id|kill_type
op_assign
id|ERASE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
id|WERASE_CHAR
c_func
(paren
id|tty
)paren
)paren
id|kill_type
op_assign
id|WERASE
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_sub_assign
(paren
(paren
id|tty-&gt;read_head
op_minus
id|tty-&gt;canon_head
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
id|tty-&gt;canon_head
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|L_ECHOK
c_func
(paren
id|tty
)paren
op_logical_or
op_logical_neg
id|L_ECHOKE
c_func
(paren
id|tty
)paren
op_logical_or
op_logical_neg
id|L_ECHOE
c_func
(paren
id|tty
)paren
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_sub_assign
(paren
(paren
id|tty-&gt;read_head
op_minus
id|tty-&gt;canon_head
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
id|tty-&gt;canon_head
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
id|echo_char
c_func
(paren
id|KILL_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty
)paren
suffix:semicolon
multiline_comment|/* Add a newline if ECHOK is on and ECHOKE is off. */
r_if
c_cond
(paren
id|L_ECHOK
c_func
(paren
id|tty
)paren
)paren
id|opost
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kill_type
op_assign
id|KILL
suffix:semicolon
)brace
id|seen_alnums
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|tty-&gt;read_head
op_ne
id|tty-&gt;canon_head
)paren
(brace
id|head
op_assign
(paren
id|tty-&gt;read_head
op_minus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|c
op_assign
id|tty-&gt;read_buf
(braket
id|head
)braket
suffix:semicolon
r_if
c_cond
(paren
id|kill_type
op_eq
id|WERASE
)paren
(brace
multiline_comment|/* Equivalent to BSD&squot;s ALTWERASE. */
r_if
c_cond
(paren
id|isalnum
c_func
(paren
id|c
)paren
op_logical_or
id|c
op_eq
l_char|&squot;_&squot;
)paren
id|seen_alnums
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|seen_alnums
)paren
r_break
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
id|head
suffix:semicolon
id|tty-&gt;read_cnt
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|L_ECHOPRT
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;erasing
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;&bslash;&squot;
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;column
op_increment
suffix:semicolon
id|tty-&gt;erasing
op_assign
l_int|1
suffix:semicolon
)brace
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|kill_type
op_eq
id|ERASE
op_logical_and
op_logical_neg
id|L_ECHOE
c_func
(paren
id|tty
)paren
)paren
(brace
id|echo_char
c_func
(paren
id|ERASE_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
(brace
r_int
r_int
id|col
op_assign
id|tty-&gt;canon_column
suffix:semicolon
r_int
r_int
id|tail
op_assign
id|tty-&gt;canon_head
suffix:semicolon
multiline_comment|/* Find the column of the last char. */
r_while
c_loop
(paren
id|tail
op_ne
id|tty-&gt;read_head
)paren
(brace
id|c
op_assign
id|tty-&gt;read_buf
(braket
id|tail
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|col
op_assign
(paren
id|col
op_or
l_int|7
)paren
op_plus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|iscntrl
c_func
(paren
id|c
)paren
)paren
(brace
r_if
c_cond
(paren
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
)paren
id|col
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
id|col
op_increment
suffix:semicolon
id|tail
op_assign
(paren
id|tail
op_plus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* should never happen */
r_if
c_cond
(paren
id|tty-&gt;column
OG
l_int|0x80000000
)paren
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Now backup to that column. */
r_while
c_loop
(paren
id|tty-&gt;column
OG
id|col
)paren
(brace
multiline_comment|/* Can&squot;t use opost here. */
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;column
OG
l_int|0
)paren
id|tty-&gt;column
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|iscntrl
c_func
(paren
id|c
)paren
op_logical_and
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot; &squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;column
OG
l_int|0
)paren
id|tty-&gt;column
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|iscntrl
c_func
(paren
id|c
)paren
op_logical_or
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot; &squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;column
OG
l_int|0
)paren
id|tty-&gt;column
op_decrement
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|kill_type
op_eq
id|ERASE
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;read_head
op_eq
id|tty-&gt;canon_head
)paren
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|isig
r_static
r_inline
r_void
id|isig
c_func
(paren
r_int
id|sig
comma
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|flush
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;pgrp
OG
l_int|0
)paren
id|kill_pg
c_func
(paren
id|tty-&gt;pgrp
comma
id|sig
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flush
op_logical_or
op_logical_neg
id|L_NOFLSH
c_func
(paren
id|tty
)paren
)paren
(brace
id|n_tty_flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
)brace
DECL|function|n_tty_receive_break
r_static
r_inline
r_void
id|n_tty_receive_break
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|I_IGNBRK
c_func
(paren
id|tty
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|I_BRKINT
c_func
(paren
id|tty
)paren
)paren
(brace
id|isig
c_func
(paren
id|SIGINT
comma
id|tty
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;377&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|tty
)paren
suffix:semicolon
)brace
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
)brace
DECL|function|n_tty_receive_overrun
r_static
r_inline
r_void
id|n_tty_receive_overrun
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|tty-&gt;num_overrun
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|time_before
c_func
(paren
id|tty-&gt;overrun_time
comma
id|jiffies
op_minus
id|HZ
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %d input overrun(s)&bslash;n&quot;
comma
id|tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
comma
id|tty-&gt;num_overrun
)paren
suffix:semicolon
id|tty-&gt;overrun_time
op_assign
id|jiffies
suffix:semicolon
id|tty-&gt;num_overrun
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|n_tty_receive_parity_error
r_static
r_inline
r_void
id|n_tty_receive_parity_error
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|c
)paren
(brace
r_if
c_cond
(paren
id|I_IGNPAR
c_func
(paren
id|tty
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;377&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|I_INPCK
c_func
(paren
id|tty
)paren
)paren
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|tty
)paren
suffix:semicolon
r_else
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
)brace
DECL|function|n_tty_receive_char
r_static
r_inline
r_void
id|n_tty_receive_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|c
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;raw
)paren
(brace
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;stopped
op_logical_and
op_logical_neg
id|tty-&gt;flow_stopped
op_logical_and
id|I_IXON
c_func
(paren
id|tty
)paren
op_logical_and
id|I_IXANY
c_func
(paren
id|tty
)paren
)paren
(brace
id|start_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_ISTRIP
c_func
(paren
id|tty
)paren
)paren
id|c
op_and_assign
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|I_IUCLC
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
id|c
op_assign
id|tolower
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;closing
)paren
(brace
r_if
c_cond
(paren
id|I_IXON
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
id|START_CHAR
c_func
(paren
id|tty
)paren
)paren
id|start_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
id|STOP_CHAR
c_func
(paren
id|tty
)paren
)paren
id|stop_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the previous character was LNEXT, or we know that this&n;&t; * character is not one of the characters that we&squot;ll have to&n;&t; * handle specially, do shortcut processing to speed things&n;&t; * up.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|c
comma
op_amp
id|tty-&gt;process_char_map
)paren
op_logical_or
id|tty-&gt;lnext
)paren
(brace
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;lnext
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;a&squot;
comma
id|tty
)paren
suffix:semicolon
multiline_comment|/* beep if no space */
r_return
suffix:semicolon
)brace
multiline_comment|/* Record the column of first canon char. */
r_if
c_cond
(paren
id|tty-&gt;canon_head
op_eq
id|tty-&gt;read_head
)paren
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
suffix:semicolon
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
op_logical_and
id|c
op_eq
(paren
r_int
r_char
)paren
l_char|&squot;&bslash;377&squot;
)paren
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;r&squot;
)paren
(brace
r_if
c_cond
(paren
id|I_IGNCR
c_func
(paren
id|tty
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|I_ICRNL
c_func
(paren
id|tty
)paren
)paren
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
id|I_INLCR
c_func
(paren
id|tty
)paren
)paren
id|c
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
r_if
c_cond
(paren
id|I_IXON
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
id|START_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
id|start_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|STOP_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
id|stop_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|L_ISIG
c_func
(paren
id|tty
)paren
)paren
(brace
r_int
id|signal
suffix:semicolon
id|signal
op_assign
id|SIGINT
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|INTR_CHAR
c_func
(paren
id|tty
)paren
)paren
r_goto
id|send_signal
suffix:semicolon
id|signal
op_assign
id|SIGQUIT
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|QUIT_CHAR
c_func
(paren
id|tty
)paren
)paren
r_goto
id|send_signal
suffix:semicolon
id|signal
op_assign
id|SIGTSTP
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|SUSP_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
id|send_signal
suffix:colon
id|isig
c_func
(paren
id|signal
comma
id|tty
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tty-&gt;icanon
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
id|ERASE_CHAR
c_func
(paren
id|tty
)paren
op_logical_or
id|c
op_eq
id|KILL_CHAR
c_func
(paren
id|tty
)paren
op_logical_or
(paren
id|c
op_eq
id|WERASE_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
)paren
(brace
id|eraser
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|LNEXT_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
(brace
id|tty-&gt;lnext
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;^&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|REPRINT_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
id|L_ECHO
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
(brace
r_int
r_int
id|tail
op_assign
id|tty-&gt;canon_head
suffix:semicolon
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|opost
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|tty
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tail
op_ne
id|tty-&gt;read_head
)paren
(brace
id|echo_char
c_func
(paren
id|tty-&gt;read_buf
(braket
id|tail
)braket
comma
id|tty
)paren
suffix:semicolon
id|tail
op_assign
(paren
id|tail
op_plus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
op_logical_or
id|L_ECHONL
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;a&squot;
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|opost
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|tty
)paren
suffix:semicolon
)brace
r_goto
id|handle_newline
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|EOF_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;canon_head
op_ne
id|tty-&gt;read_head
)paren
id|set_bit
c_func
(paren
id|TTY_PUSH
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|c
op_assign
id|__DISABLED_CHAR
suffix:semicolon
r_goto
id|handle_newline
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|c
op_eq
id|EOL_CHAR
c_func
(paren
id|tty
)paren
)paren
op_logical_or
(paren
id|c
op_eq
id|EOL2_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * XXX are EOL_CHAR and EOL2_CHAR echoed?!?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;a&squot;
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Record the column of first canon char. */
r_if
c_cond
(paren
id|tty-&gt;canon_head
op_eq
id|tty-&gt;read_head
)paren
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
suffix:semicolon
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * XXX does PARMRK doubling happen for&n;&t;&t;&t; * EOL_CHAR and EOL2_CHAR?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
op_logical_and
id|c
op_eq
(paren
r_int
r_char
)paren
l_char|&squot;&bslash;377&squot;
)paren
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|handle_newline
suffix:colon
id|set_bit
c_func
(paren
id|tty-&gt;read_head
comma
op_amp
id|tty-&gt;read_flags
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;canon_head
op_assign
id|tty-&gt;read_head
suffix:semicolon
id|tty-&gt;canon_data
op_increment
suffix:semicolon
id|kill_fasync
c_func
(paren
op_amp
id|tty-&gt;fasync
comma
id|SIGIO
comma
id|POLL_IN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;a&squot;
comma
id|tty
)paren
suffix:semicolon
multiline_comment|/* beep if no space */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|opost
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|tty
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* Record the column of first canon char. */
r_if
c_cond
(paren
id|tty-&gt;canon_head
op_eq
id|tty-&gt;read_head
)paren
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
suffix:semicolon
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
op_logical_and
id|c
op_eq
(paren
r_int
r_char
)paren
l_char|&squot;&bslash;377&squot;
)paren
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
DECL|function|n_tty_receive_room
r_static
r_int
id|n_tty_receive_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|left
op_assign
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_cnt
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * If we are doing input canonicalization, and there are no&n;&t; * pending newlines, let characters through without limit, so&n;&t; * that erase characters will be handled.  Other excess&n;&t; * characters will be beeped.&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;icanon
op_logical_and
op_logical_neg
id|tty-&gt;canon_data
)paren
r_return
id|N_TTY_BUF_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|left
OG
l_int|0
)paren
r_return
id|left
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|n_tty_receive_buf
r_static
r_void
id|n_tty_receive_buf
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_int
r_char
op_star
id|cp
comma
r_char
op_star
id|fp
comma
r_int
id|count
)paren
(brace
r_const
r_int
r_char
op_star
id|p
suffix:semicolon
r_char
op_star
id|f
comma
id|flags
op_assign
id|TTY_NORMAL
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
r_int
r_int
id|cpuflags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_buf
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;real_raw
)paren
(brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|cpuflags
)paren
suffix:semicolon
id|i
op_assign
id|MIN
c_func
(paren
id|count
comma
id|MIN
c_func
(paren
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_cnt
comma
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_head
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tty-&gt;read_buf
op_plus
id|tty-&gt;read_head
comma
id|cp
comma
id|i
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
(paren
id|tty-&gt;read_head
op_plus
id|i
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_add_assign
id|i
suffix:semicolon
id|cp
op_add_assign
id|i
suffix:semicolon
id|count
op_sub_assign
id|i
suffix:semicolon
id|i
op_assign
id|MIN
c_func
(paren
id|count
comma
id|MIN
c_func
(paren
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_cnt
comma
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_head
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tty-&gt;read_buf
op_plus
id|tty-&gt;read_head
comma
id|cp
comma
id|i
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
(paren
id|tty-&gt;read_head
op_plus
id|i
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_add_assign
id|i
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|cpuflags
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
id|count
comma
id|p
op_assign
id|cp
comma
id|f
op_assign
id|fp
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
comma
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|f
)paren
id|flags
op_assign
op_star
id|f
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|flags
)paren
(brace
r_case
id|TTY_NORMAL
suffix:colon
id|n_tty_receive_char
c_func
(paren
id|tty
comma
op_star
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TTY_BREAK
suffix:colon
id|n_tty_receive_break
c_func
(paren
id|tty
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TTY_PARITY
suffix:colon
r_case
id|TTY_FRAME
suffix:colon
id|n_tty_receive_parity_error
c_func
(paren
id|tty
comma
op_star
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TTY_OVERRUN
suffix:colon
id|n_tty_receive_overrun
c_func
(paren
id|tty
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: unknown flag %d&bslash;n&quot;
comma
id|tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tty-&gt;driver.flush_chars
)paren
id|tty-&gt;driver
dot
id|flush_chars
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;icanon
op_logical_and
(paren
id|tty-&gt;read_cnt
op_ge
id|tty-&gt;minimum_to_wake
)paren
)paren
(brace
id|kill_fasync
c_func
(paren
op_amp
id|tty-&gt;fasync
comma
id|SIGIO
comma
id|POLL_IN
)paren
suffix:semicolon
r_if
c_cond
(paren
id|waitqueue_active
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check the remaining room for the input canonicalization&n;&t; * mode.  We don&squot;t want to throttle the driver if we&squot;re in&n;&t; * canonical mode and don&squot;t have a newline yet!&n;&t; */
r_if
c_cond
(paren
id|n_tty_receive_room
c_func
(paren
id|tty
)paren
OL
id|TTY_THRESHOLD_THROTTLE
)paren
(brace
multiline_comment|/* check TTY_THROTTLED first so it indicates our state */
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
op_logical_and
id|tty-&gt;driver.throttle
)paren
id|tty-&gt;driver
dot
id|throttle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
)brace
DECL|function|is_ignored
r_int
id|is_ignored
c_func
(paren
r_int
id|sig
)paren
(brace
r_return
(paren
id|sigismember
c_func
(paren
op_amp
id|current-&gt;blocked
comma
id|sig
)paren
op_logical_or
id|current-&gt;sig-&gt;action
(braket
id|sig
op_minus
l_int|1
)braket
dot
id|sa.sa_handler
op_eq
id|SIG_IGN
)paren
suffix:semicolon
)brace
DECL|function|n_tty_set_termios
r_static
r_void
id|n_tty_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|tty-&gt;icanon
op_assign
(paren
id|L_ICANON
c_func
(paren
id|tty
)paren
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_HW_COOK_IN
comma
op_amp
id|tty-&gt;flags
)paren
)paren
(brace
id|tty-&gt;raw
op_assign
l_int|1
suffix:semicolon
id|tty-&gt;real_raw
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_ISTRIP
c_func
(paren
id|tty
)paren
op_logical_or
id|I_IUCLC
c_func
(paren
id|tty
)paren
op_logical_or
id|I_IGNCR
c_func
(paren
id|tty
)paren
op_logical_or
id|I_ICRNL
c_func
(paren
id|tty
)paren
op_logical_or
id|I_INLCR
c_func
(paren
id|tty
)paren
op_logical_or
id|L_ICANON
c_func
(paren
id|tty
)paren
op_logical_or
id|I_IXON
c_func
(paren
id|tty
)paren
op_logical_or
id|L_ISIG
c_func
(paren
id|tty
)paren
op_logical_or
id|L_ECHO
c_func
(paren
id|tty
)paren
op_logical_or
id|I_PARMRK
c_func
(paren
id|tty
)paren
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tty-&gt;process_char_map
comma
l_int|0
comma
l_int|256
op_div
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|I_IGNCR
c_func
(paren
id|tty
)paren
op_logical_or
id|I_ICRNL
c_func
(paren
id|tty
)paren
)paren
id|set_bit
c_func
(paren
l_char|&squot;&bslash;r&squot;
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|I_INLCR
c_func
(paren
id|tty
)paren
)paren
id|set_bit
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_ICANON
c_func
(paren
id|tty
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|ERASE_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|KILL_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|EOF_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|EOL_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|WERASE_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|LNEXT_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|EOL2_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
id|set_bit
c_func
(paren
id|REPRINT_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|I_IXON
c_func
(paren
id|tty
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|START_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|STOP_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|L_ISIG
c_func
(paren
id|tty
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|INTR_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|QUIT_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SUSP_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|__DISABLED_CHAR
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|tty-&gt;raw
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;real_raw
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|tty-&gt;raw
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|I_IGNBRK
c_func
(paren
id|tty
)paren
op_logical_or
(paren
op_logical_neg
id|I_BRKINT
c_func
(paren
id|tty
)paren
op_logical_and
op_logical_neg
id|I_PARMRK
c_func
(paren
id|tty
)paren
)paren
)paren
op_logical_and
(paren
id|I_IGNPAR
c_func
(paren
id|tty
)paren
op_logical_or
op_logical_neg
id|I_INPCK
c_func
(paren
id|tty
)paren
)paren
op_logical_and
(paren
id|tty-&gt;driver.flags
op_amp
id|TTY_DRIVER_REAL_RAW
)paren
)paren
id|tty-&gt;real_raw
op_assign
l_int|1
suffix:semicolon
r_else
id|tty-&gt;real_raw
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|n_tty_close
r_static
r_void
id|n_tty_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|n_tty_flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;read_buf
)paren
(brace
id|free_buf
c_func
(paren
id|tty-&gt;read_buf
)paren
suffix:semicolon
id|tty-&gt;read_buf
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|n_tty_open
r_static
r_int
id|n_tty_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_buf
)paren
(brace
id|tty-&gt;read_buf
op_assign
id|alloc_buf
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|tty-&gt;read_buf
comma
l_int|0
comma
id|N_TTY_BUF_SIZE
)paren
suffix:semicolon
id|reset_buffer_flags
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
id|n_tty_set_termios
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
id|tty-&gt;minimum_to_wake
op_assign
l_int|1
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|input_available_p
r_static
r_inline
r_int
id|input_available_p
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|amt
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;icanon
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;canon_data
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
(paren
id|amt
ques
c_cond
id|amt
suffix:colon
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Helper function to speed up read_chan.  It is only called when&n; * ICANON is off; it copies characters straight from the tty queue to&n; * user space directly.  It can be profitably called twice; once to&n; * drain the space from the tail pointer to the (physical) end of the&n; * buffer, and once to drain the space from the (physical) beginning of&n; * the buffer to head pointer.&n; */
DECL|function|copy_from_read_buf
r_static
r_inline
r_int
id|copy_from_read_buf
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
op_star
op_star
id|b
comma
r_int
op_star
id|nr
)paren
(brace
r_int
id|retval
suffix:semicolon
id|ssize_t
id|n
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|n
op_assign
id|MIN
c_func
(paren
op_star
id|nr
comma
id|MIN
c_func
(paren
id|tty-&gt;read_cnt
comma
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_tail
)paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n
)paren
(brace
id|mb
c_func
(paren
)paren
suffix:semicolon
id|retval
op_assign
id|copy_to_user
c_func
(paren
op_star
id|b
comma
op_amp
id|tty-&gt;read_buf
(braket
id|tty-&gt;read_tail
)braket
comma
id|n
)paren
suffix:semicolon
id|n
op_sub_assign
id|retval
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;read_tail
op_assign
(paren
id|tty-&gt;read_tail
op_plus
id|n
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_sub_assign
id|n
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
op_star
id|b
op_add_assign
id|n
suffix:semicolon
op_star
id|nr
op_sub_assign
id|n
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
DECL|function|read_chan
r_static
id|ssize_t
id|read_chan
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_char
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_int
r_char
op_star
id|b
op_assign
id|buf
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
id|c
suffix:semicolon
r_int
id|minimum
comma
id|time
suffix:semicolon
id|ssize_t
id|retval
op_assign
l_int|0
suffix:semicolon
id|ssize_t
id|size
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|do_it_again
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_buf
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;n_tty_read_chan: called with read_buf == NULL?!?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Job control check -- must be done at start and after&n;&t;   every sleep (POSIX.1 7.1.1.4). */
multiline_comment|/* NOTE: not yet done after every sleep pending a thorough&n;&t;   check of the logic of this change. -- jlc */
multiline_comment|/* don&squot;t stop on /dev/console */
r_if
c_cond
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
op_ne
id|CONSOLE_DEV
op_logical_and
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
op_ne
id|SYSCONS_DEV
op_logical_and
id|current-&gt;tty
op_eq
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;pgrp
op_le
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;read_chan: tty-&gt;pgrp &lt;= 0!&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|current-&gt;pgrp
op_ne
id|tty-&gt;pgrp
)paren
(brace
r_if
c_cond
(paren
id|is_ignored
c_func
(paren
id|SIGTTIN
)paren
op_logical_or
id|is_orphaned_pgrp
c_func
(paren
id|current-&gt;pgrp
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|kill_pg
c_func
(paren
id|current-&gt;pgrp
comma
id|SIGTTIN
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
id|minimum
op_assign
id|time
op_assign
l_int|0
suffix:semicolon
id|timeout
op_assign
id|MAX_SCHEDULE_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;icanon
)paren
(brace
id|time
op_assign
(paren
id|HZ
op_div
l_int|10
)paren
op_star
id|TIME_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
id|minimum
op_assign
id|MIN_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minimum
)paren
(brace
r_if
c_cond
(paren
id|time
)paren
id|tty-&gt;minimum_to_wake
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|waitqueue_active
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
op_logical_or
(paren
id|tty-&gt;minimum_to_wake
OG
id|minimum
)paren
)paren
id|tty-&gt;minimum_to_wake
op_assign
id|minimum
suffix:semicolon
)brace
r_else
(brace
id|timeout
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|time
)paren
(brace
id|timeout
op_assign
id|time
suffix:semicolon
id|time
op_assign
l_int|0
suffix:semicolon
)brace
id|tty-&gt;minimum_to_wake
op_assign
id|minimum
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
r_if
c_cond
(paren
id|down_trylock
c_func
(paren
op_amp
id|tty-&gt;atomic_read
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|down_interruptible
c_func
(paren
op_amp
id|tty-&gt;atomic_read
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
id|add_wait_queue
c_func
(paren
op_amp
id|tty-&gt;read_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|TTY_DONT_FLIP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nr
)paren
(brace
multiline_comment|/* First test for status change. */
r_if
c_cond
(paren
id|tty-&gt;packet
op_logical_and
id|tty-&gt;link-&gt;ctrl_status
)paren
(brace
r_int
r_char
id|cs
suffix:semicolon
r_if
c_cond
(paren
id|b
op_ne
id|buf
)paren
r_break
suffix:semicolon
id|cs
op_assign
id|tty-&gt;link-&gt;ctrl_status
suffix:semicolon
id|tty-&gt;link-&gt;ctrl_status
op_assign
l_int|0
suffix:semicolon
id|put_user
c_func
(paren
id|cs
comma
id|b
op_increment
)paren
suffix:semicolon
id|nr
op_decrement
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* This statement must be first before checking for input&n;&t;&t;   so that any interrupt will set the state back to&n;&t;&t;   TASK_RUNNING. */
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|minimum
op_minus
(paren
id|b
op_minus
id|buf
)paren
)paren
OL
id|tty-&gt;minimum_to_wake
)paren
op_logical_and
(paren
(paren
id|minimum
op_minus
(paren
id|b
op_minus
id|buf
)paren
)paren
op_ge
l_int|1
)paren
)paren
id|tty-&gt;minimum_to_wake
op_assign
(paren
id|minimum
op_minus
(paren
id|b
op_minus
id|buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|input_available_p
c_func
(paren
id|tty
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_OTHER_CLOSED
comma
op_amp
id|tty-&gt;flags
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|file
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timeout
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|TTY_DONT_FLIP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|timeout
op_assign
id|schedule_timeout
c_func
(paren
id|timeout
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|TTY_DONT_FLIP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
multiline_comment|/* Deal with packet mode. */
r_if
c_cond
(paren
id|tty-&gt;packet
op_logical_and
id|b
op_eq
id|buf
)paren
(brace
id|put_user
c_func
(paren
id|TIOCPKT_DATA
comma
id|b
op_increment
)paren
suffix:semicolon
id|nr
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;icanon
)paren
(brace
multiline_comment|/* N.B. avoid overrun if nr == 0 */
r_while
c_loop
(paren
id|nr
op_logical_and
id|tty-&gt;read_cnt
)paren
(brace
r_int
id|eol
suffix:semicolon
id|eol
op_assign
id|test_and_clear_bit
c_func
(paren
id|tty-&gt;read_tail
comma
op_amp
id|tty-&gt;read_flags
)paren
suffix:semicolon
id|c
op_assign
id|tty-&gt;read_buf
(braket
id|tty-&gt;read_tail
)braket
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
id|tty-&gt;read_tail
op_assign
(paren
(paren
id|tty-&gt;read_tail
op_plus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|tty-&gt;read_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eol
op_logical_or
(paren
id|c
op_ne
id|__DISABLED_CHAR
)paren
)paren
(brace
id|put_user
c_func
(paren
id|c
comma
id|b
op_increment
)paren
suffix:semicolon
id|nr
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eol
)paren
(brace
multiline_comment|/* this test should be redundant:&n;&t;&t;&t;&t;&t; * we shouldn&squot;t be reading data if&n;&t;&t;&t;&t;&t; * canon_data is 0&n;&t;&t;&t;&t;&t; */
r_if
c_cond
(paren
op_decrement
id|tty-&gt;canon_data
OL
l_int|0
)paren
id|tty-&gt;canon_data
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_int
id|uncopied
suffix:semicolon
id|uncopied
op_assign
id|copy_from_read_buf
c_func
(paren
id|tty
comma
op_amp
id|b
comma
op_amp
id|nr
)paren
suffix:semicolon
id|uncopied
op_add_assign
id|copy_from_read_buf
c_func
(paren
id|tty
comma
op_amp
id|b
comma
op_amp
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uncopied
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* If there is enough space in the read buffer now, let the&n;&t;&t; * low-level driver know. We use n_tty_chars_in_buffer() to&n;&t;&t; * check the buffer, as it now knows about canonical mode.&n;&t;&t; * Otherwise, if the driver is throttled and the line is&n;&t;&t; * longer than TTY_THRESHOLD_UNTHROTTLE in canonical mode,&n;&t;&t; * we won&squot;t get any more characters.&n;&t;&t; */
r_if
c_cond
(paren
id|n_tty_chars_in_buffer
c_func
(paren
id|tty
)paren
op_le
id|TTY_THRESHOLD_UNTHROTTLE
)paren
id|check_unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|b
op_minus
id|buf
op_ge
id|minimum
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|time
)paren
id|timeout
op_assign
id|time
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|TTY_DONT_FLIP
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|tty-&gt;atomic_read
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|tty-&gt;read_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|waitqueue_active
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
)paren
id|tty-&gt;minimum_to_wake
op_assign
id|minimum
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|size
op_assign
id|b
op_minus
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|size
)paren
(brace
id|retval
op_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|nr
)paren
id|clear_bit
c_func
(paren
id|TTY_PUSH
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|test_and_clear_bit
c_func
(paren
id|TTY_PUSH
comma
op_amp
id|tty-&gt;flags
)paren
)paren
r_goto
id|do_it_again
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|write_chan
r_static
id|ssize_t
id|write_chan
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_int
r_char
op_star
id|buf
comma
r_int
id|nr
)paren
(brace
r_const
r_int
r_char
op_star
id|b
op_assign
id|buf
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
r_int
id|c
suffix:semicolon
id|ssize_t
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Job control check -- must be done at start (POSIX.1 7.1.1.4). */
r_if
c_cond
(paren
id|L_TOSTOP
c_func
(paren
id|tty
)paren
op_logical_and
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
op_ne
id|CONSOLE_DEV
op_logical_and
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
op_ne
id|SYSCONS_DEV
)paren
(brace
id|retval
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
)brace
id|add_wait_queue
c_func
(paren
op_amp
id|tty-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|file
)paren
op_logical_or
(paren
id|tty-&gt;link
op_logical_and
op_logical_neg
id|tty-&gt;link-&gt;count
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|O_OPOST
c_func
(paren
id|tty
)paren
op_logical_and
op_logical_neg
(paren
id|test_bit
c_func
(paren
id|TTY_HW_COOK_OUT
comma
op_amp
id|tty-&gt;flags
)paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|nr
OG
l_int|0
)paren
(brace
id|ssize_t
id|num
op_assign
id|opost_block
c_func
(paren
id|tty
comma
id|b
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num
OL
l_int|0
)paren
(brace
id|retval
op_assign
id|num
suffix:semicolon
r_goto
id|break_out
suffix:semicolon
)brace
id|b
op_add_assign
id|num
suffix:semicolon
id|nr
op_sub_assign
id|num
suffix:semicolon
r_if
c_cond
(paren
id|nr
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|get_user
c_func
(paren
id|c
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opost
c_func
(paren
id|c
comma
id|tty
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|b
op_increment
suffix:semicolon
id|nr
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;driver.flush_chars
)paren
id|tty-&gt;driver
dot
id|flush_chars
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_else
(brace
id|c
op_assign
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|1
comma
id|b
comma
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
OL
l_int|0
)paren
(brace
id|retval
op_assign
id|c
suffix:semicolon
r_goto
id|break_out
suffix:semicolon
)brace
id|b
op_add_assign
id|c
suffix:semicolon
id|nr
op_sub_assign
id|c
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|break_out
suffix:colon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|tty-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
(paren
id|b
op_minus
id|buf
)paren
ques
c_cond
id|b
op_minus
id|buf
suffix:colon
id|retval
suffix:semicolon
)brace
multiline_comment|/* Called without the kernel lock held - fine */
DECL|function|normal_poll
r_static
r_int
r_int
id|normal_poll
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|tty-&gt;read_wait
comma
id|wait
)paren
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|tty-&gt;write_wait
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|input_available_p
c_func
(paren
id|tty
comma
id|TIME_CHAR
c_func
(paren
id|tty
)paren
ques
c_cond
l_int|0
suffix:colon
id|MIN_CHAR
c_func
(paren
id|tty
)paren
)paren
)paren
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;packet
op_logical_and
id|tty-&gt;link-&gt;ctrl_status
)paren
id|mask
op_or_assign
id|POLLPRI
op_or
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|TTY_OTHER_CLOSED
comma
op_amp
id|tty-&gt;flags
)paren
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|file
)paren
)paren
id|mask
op_or_assign
id|POLLHUP
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_amp
(paren
id|POLLHUP
op_or
id|POLLIN
op_or
id|POLLRDNORM
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|MIN_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
op_logical_neg
id|TIME_CHAR
c_func
(paren
id|tty
)paren
)paren
id|tty-&gt;minimum_to_wake
op_assign
id|MIN_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
r_else
id|tty-&gt;minimum_to_wake
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;driver
dot
id|chars_in_buffer
c_func
(paren
id|tty
)paren
OL
id|WAKEUP_CHARS
)paren
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|variable|tty_ldisc_N_TTY
r_struct
id|tty_ldisc
id|tty_ldisc_N_TTY
op_assign
(brace
id|TTY_LDISC_MAGIC
comma
multiline_comment|/* magic */
l_string|&quot;n_tty&quot;
comma
multiline_comment|/* name */
l_int|0
comma
multiline_comment|/* num */
l_int|0
comma
multiline_comment|/* flags */
id|n_tty_open
comma
multiline_comment|/* open */
id|n_tty_close
comma
multiline_comment|/* close */
id|n_tty_flush_buffer
comma
multiline_comment|/* flush_buffer */
id|n_tty_chars_in_buffer
comma
multiline_comment|/* chars_in_buffer */
id|read_chan
comma
multiline_comment|/* read */
id|write_chan
comma
multiline_comment|/* write */
id|n_tty_ioctl
comma
multiline_comment|/* ioctl */
id|n_tty_set_termios
comma
multiline_comment|/* set_termios */
id|normal_poll
comma
multiline_comment|/* poll */
id|n_tty_receive_buf
comma
multiline_comment|/* receive_buf */
id|n_tty_receive_room
comma
multiline_comment|/* receive_room */
l_int|0
multiline_comment|/* write_wakeup */
)brace
suffix:semicolon
eof
