multiline_comment|/*&n; * n_tty.c --- implements the N_TTY line discipline.&n; * &n; * This code used to be in tty_io.c, but things are getting hairy&n; * enough that it made sense to split things off.  (The N_TTY&n; * processing has changed so much that it&squot;s hardly recognizable,&n; * anyway...)&n; *&n; * Note that the open routine for N_TTY is guaranteed never to return&n; * an error.  This is because Linux will fall back to setting a line&n; * to N_TTY if it can not switch to any other line discipline.  &n; *&n; * Written by Theodore Ts&squot;o, Copyright 1994.&n; * &n; * This file also contains code originally written by Linus Torvalds,&n; * Copyright 1991, 1992, 1993, and by Julian Cowley, Copyright 1994.&n; * &n; * This file may be redistributed under the terms of the GNU Public&n; * License.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/kd.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
DECL|macro|CONSOLE_DEV
mdefine_line|#define CONSOLE_DEV MKDEV(TTY_MAJOR,0)
macro_line|#ifndef MIN
DECL|macro|MIN
mdefine_line|#define MIN(a,b)&t;((a) &lt; (b) ? (a) : (b))
macro_line|#endif
multiline_comment|/* number of characters left in xmit buffer before select has we have room */
DECL|macro|WAKEUP_CHARS
mdefine_line|#define WAKEUP_CHARS 256
multiline_comment|/*&n; * This defines the low- and high-watermarks for throttling and&n; * unthrottling the TTY driver.  These watermarks are used for&n; * controlling the space in the read buffer.&n; */
DECL|macro|TTY_THRESHOLD_THROTTLE
mdefine_line|#define TTY_THRESHOLD_THROTTLE&t;&t;(N_TTY_BUF_SIZE - 128)
DECL|macro|TTY_THRESHOLD_UNTHROTTLE
mdefine_line|#define TTY_THRESHOLD_UNTHROTTLE &t;128
DECL|function|put_tty_queue
r_static
r_inline
r_void
id|put_tty_queue
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;read_cnt
OL
id|N_TTY_BUF_SIZE
)paren
(brace
id|tty-&gt;read_buf
(braket
id|tty-&gt;read_head
)braket
op_assign
id|c
suffix:semicolon
id|tty-&gt;read_head
op_assign
(paren
id|tty-&gt;read_head
op_plus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Flush the input buffer&n; */
DECL|function|n_tty_flush_buffer
r_void
id|n_tty_flush_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|tty-&gt;read_head
op_assign
id|tty-&gt;read_tail
op_assign
id|tty-&gt;read_cnt
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;canon_head
op_assign
id|tty-&gt;canon_data
op_assign
id|tty-&gt;erasing
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|tty-&gt;read_flags
comma
l_int|0
comma
r_sizeof
id|tty-&gt;read_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;link
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.unthrottle
)paren
(paren
id|tty-&gt;driver.unthrottle
)paren
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;link-&gt;packet
)paren
(brace
id|tty-&gt;ctrl_status
op_or_assign
id|TIOCPKT_FLUSHREAD
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;link-&gt;read_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Return number of characters buffered to be delivered to user&n; */
DECL|function|n_tty_chars_in_buffer
r_int
id|n_tty_chars_in_buffer
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_return
id|tty-&gt;read_cnt
suffix:semicolon
)brace
multiline_comment|/*&n; * Perform OPOST processing.  Returns -1 when the output device is&n; * full and the character must be retried.&n; */
DECL|function|opost
r_static
r_int
id|opost
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|space
comma
id|spaces
suffix:semicolon
id|space
op_assign
id|tty-&gt;driver
dot
id|write_room
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|space
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|O_OPOST
c_func
(paren
id|tty
)paren
)paren
(brace
r_switch
c_cond
(paren
id|c
)paren
(brace
r_case
l_char|&squot;&bslash;n&squot;
suffix:colon
r_if
c_cond
(paren
id|O_ONLRET
c_func
(paren
id|tty
)paren
)paren
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|O_ONLCR
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|space
OL
l_int|2
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|tty-&gt;driver
dot
id|put_char
c_func
(paren
id|tty
comma
l_char|&squot;&bslash;r&squot;
)paren
suffix:semicolon
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
)brace
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;r&squot;
suffix:colon
r_if
c_cond
(paren
id|O_ONOCR
c_func
(paren
id|tty
)paren
op_logical_and
id|tty-&gt;column
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|O_OCRNL
c_func
(paren
id|tty
)paren
)paren
(brace
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
r_if
c_cond
(paren
id|O_ONLRET
c_func
(paren
id|tty
)paren
)paren
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;t&squot;
suffix:colon
id|spaces
op_assign
l_int|8
op_minus
(paren
id|tty-&gt;column
op_amp
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|O_TABDLY
c_func
(paren
id|tty
)paren
op_eq
id|XTABS
)paren
(brace
r_if
c_cond
(paren
id|space
OL
id|spaces
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|tty-&gt;column
op_add_assign
id|spaces
suffix:semicolon
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
l_string|&quot;        &quot;
comma
id|spaces
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|tty-&gt;column
op_add_assign
id|spaces
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;&bslash;b&squot;
suffix:colon
r_if
c_cond
(paren
id|tty-&gt;column
OG
l_int|0
)paren
id|tty-&gt;column
op_decrement
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|O_OLCUC
c_func
(paren
id|tty
)paren
)paren
id|c
op_assign
id|toupper
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|iscntrl
c_func
(paren
id|c
)paren
)paren
id|tty-&gt;column
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|tty-&gt;driver
dot
id|put_char
c_func
(paren
id|tty
comma
id|c
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|put_char
r_static
r_inline
r_void
id|put_char
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|tty-&gt;driver
dot
id|put_char
c_func
(paren
id|tty
comma
id|c
)paren
suffix:semicolon
)brace
multiline_comment|/* Must be called only when L_ECHO(tty) is true. */
DECL|function|echo_char
r_static
r_void
id|echo_char
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
op_logical_and
id|iscntrl
c_func
(paren
id|c
)paren
op_logical_and
id|c
op_ne
l_char|&squot;&bslash;t&squot;
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;^&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
id|c
op_xor
l_int|0100
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;column
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
id|opost
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
DECL|function|finish_erasing
r_static
r_inline
r_void
id|finish_erasing
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;erasing
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;/&squot;
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;column
op_add_assign
l_int|2
suffix:semicolon
id|tty-&gt;erasing
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|eraser
r_static
r_void
id|eraser
c_func
(paren
r_int
r_char
id|c
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_enum
(brace
id|ERASE
comma
id|WERASE
comma
id|KILL
)brace
id|kill_type
suffix:semicolon
r_int
id|head
comma
id|seen_alnums
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;read_head
op_eq
id|tty-&gt;canon_head
)paren
(brace
multiline_comment|/* opost(&squot;&bslash;a&squot;, tty); */
multiline_comment|/* what do you think? */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|ERASE_CHAR
c_func
(paren
id|tty
)paren
)paren
id|kill_type
op_assign
id|ERASE
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
id|WERASE_CHAR
c_func
(paren
id|tty
)paren
)paren
id|kill_type
op_assign
id|WERASE
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
id|tty-&gt;read_cnt
op_sub_assign
(paren
(paren
id|tty-&gt;read_head
op_minus
id|tty-&gt;canon_head
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
id|tty-&gt;canon_head
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|L_ECHOK
c_func
(paren
id|tty
)paren
op_logical_or
op_logical_neg
id|L_ECHOKE
c_func
(paren
id|tty
)paren
)paren
(brace
id|tty-&gt;read_cnt
op_sub_assign
(paren
(paren
id|tty-&gt;read_head
op_minus
id|tty-&gt;canon_head
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
id|tty-&gt;canon_head
suffix:semicolon
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
id|echo_char
c_func
(paren
id|KILL_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty
)paren
suffix:semicolon
multiline_comment|/* Add a newline if ECHOK is on and ECHOKE is off. */
r_if
c_cond
(paren
id|L_ECHOK
c_func
(paren
id|tty
)paren
)paren
id|opost
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|kill_type
op_assign
id|KILL
suffix:semicolon
)brace
id|seen_alnums
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|tty-&gt;read_head
op_ne
id|tty-&gt;canon_head
)paren
(brace
id|head
op_assign
(paren
id|tty-&gt;read_head
op_minus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|c
op_assign
id|tty-&gt;read_buf
(braket
id|head
)braket
suffix:semicolon
r_if
c_cond
(paren
id|kill_type
op_eq
id|WERASE
)paren
(brace
multiline_comment|/* Equivalent to BSD&squot;s ALTWERASE. */
r_if
c_cond
(paren
id|isalnum
c_func
(paren
id|c
)paren
op_logical_or
id|c
op_eq
l_char|&squot;_&squot;
)paren
id|seen_alnums
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|seen_alnums
)paren
r_break
suffix:semicolon
)brace
id|tty-&gt;read_head
op_assign
id|head
suffix:semicolon
id|tty-&gt;read_cnt
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|L_ECHOPRT
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;erasing
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;&bslash;&squot;
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;column
op_increment
suffix:semicolon
id|tty-&gt;erasing
op_assign
l_int|1
suffix:semicolon
)brace
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|L_ECHOE
c_func
(paren
id|tty
)paren
)paren
(brace
id|echo_char
c_func
(paren
id|ERASE_CHAR
c_func
(paren
id|tty
)paren
comma
id|tty
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
(brace
r_int
r_int
id|col
op_assign
id|tty-&gt;canon_column
suffix:semicolon
r_int
r_int
id|tail
op_assign
id|tty-&gt;canon_head
suffix:semicolon
multiline_comment|/* Find the column of the last char. */
r_while
c_loop
(paren
id|tail
op_ne
id|tty-&gt;read_head
)paren
(brace
id|c
op_assign
id|tty-&gt;read_buf
(braket
id|tail
)braket
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;t&squot;
)paren
id|col
op_assign
(paren
id|col
op_or
l_int|7
)paren
op_plus
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|iscntrl
c_func
(paren
id|c
)paren
)paren
(brace
r_if
c_cond
(paren
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
)paren
id|col
op_add_assign
l_int|2
suffix:semicolon
)brace
r_else
id|col
op_increment
suffix:semicolon
id|tail
op_assign
(paren
id|tail
op_plus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Now backup to that column. */
r_while
c_loop
(paren
id|tty-&gt;column
OG
id|col
)paren
(brace
multiline_comment|/* Can&squot;t use opost here. */
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;column
op_decrement
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|iscntrl
c_func
(paren
id|c
)paren
op_logical_and
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot; &squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;column
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|iscntrl
c_func
(paren
id|c
)paren
op_logical_or
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot; &squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;column
op_decrement
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|kill_type
op_eq
id|ERASE
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;read_head
op_eq
id|tty-&gt;canon_head
)paren
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|isig
r_static
r_void
id|isig
c_func
(paren
r_int
id|sig
comma
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;pgrp
OG
l_int|0
)paren
id|kill_pg
c_func
(paren
id|tty-&gt;pgrp
comma
id|sig
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|L_NOFLSH
c_func
(paren
id|tty
)paren
)paren
(brace
id|n_tty_flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
)brace
DECL|function|n_tty_receive_break
r_static
r_inline
r_void
id|n_tty_receive_break
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|I_IGNBRK
c_func
(paren
id|tty
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|I_BRKINT
c_func
(paren
id|tty
)paren
)paren
(brace
id|isig
c_func
(paren
id|SIGINT
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;377&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|tty
)paren
suffix:semicolon
)brace
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
)brace
DECL|function|n_tty_receive_overrun
r_static
r_inline
r_void
id|n_tty_receive_overrun
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
id|tty-&gt;num_overrun
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;overrun_time
OL
(paren
id|jiffies
op_minus
id|HZ
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %d input overrun(s)&bslash;n&quot;
comma
id|_tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
comma
id|tty-&gt;num_overrun
)paren
suffix:semicolon
id|tty-&gt;overrun_time
op_assign
id|jiffies
suffix:semicolon
id|tty-&gt;num_overrun
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|n_tty_receive_parity_error
r_static
r_inline
r_void
id|n_tty_receive_parity_error
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|c
)paren
(brace
r_if
c_cond
(paren
id|I_IGNPAR
c_func
(paren
id|tty
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;377&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
r_else
id|put_tty_queue
c_func
(paren
l_char|&squot;&bslash;0&squot;
comma
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
)brace
DECL|function|n_tty_receive_char
r_static
r_inline
r_void
id|n_tty_receive_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|c
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;raw
)paren
(brace
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;stopped
op_logical_and
id|I_IXON
c_func
(paren
id|tty
)paren
op_logical_and
id|I_IXANY
c_func
(paren
id|tty
)paren
)paren
(brace
id|start_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_ISTRIP
c_func
(paren
id|tty
)paren
)paren
id|c
op_and_assign
l_int|0x7f
suffix:semicolon
r_if
c_cond
(paren
id|I_IUCLC
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
id|c
op_assign
id|tolower
c_func
(paren
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;closing
)paren
(brace
r_if
c_cond
(paren
id|I_IXON
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
id|START_CHAR
c_func
(paren
id|tty
)paren
)paren
id|start_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|c
op_eq
id|STOP_CHAR
c_func
(paren
id|tty
)paren
)paren
id|stop_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the previous character was LNEXT, or we know that this&n;&t; * character is not one of the characters that we&squot;ll have to&n;&t; * handle specially, do shortcut processing to speed things&n;&t; * up.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|c
comma
op_amp
id|tty-&gt;process_char_map
)paren
op_logical_or
id|tty-&gt;lnext
)paren
(brace
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;lnext
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;a&squot;
comma
id|tty
)paren
suffix:semicolon
multiline_comment|/* beep if no space */
r_return
suffix:semicolon
)brace
multiline_comment|/* Record the column of first canon char. */
r_if
c_cond
(paren
id|tty-&gt;canon_head
op_eq
id|tty-&gt;read_head
)paren
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
suffix:semicolon
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
op_logical_and
id|c
op_eq
(paren
r_int
r_char
)paren
l_char|&squot;&bslash;377&squot;
)paren
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;r&squot;
)paren
(brace
r_if
c_cond
(paren
id|I_IGNCR
c_func
(paren
id|tty
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|I_ICRNL
c_func
(paren
id|tty
)paren
)paren
id|c
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
op_logical_and
id|I_INLCR
c_func
(paren
id|tty
)paren
)paren
id|c
op_assign
l_char|&squot;&bslash;r&squot;
suffix:semicolon
r_if
c_cond
(paren
id|I_IXON
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
id|START_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
id|start_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|STOP_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
id|stop_tty
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|L_ISIG
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
id|INTR_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
id|isig
c_func
(paren
id|SIGINT
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|QUIT_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
id|isig
c_func
(paren
id|SIGQUIT
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|SUSP_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_orphaned_pgrp
c_func
(paren
id|tty-&gt;pgrp
)paren
)paren
id|isig
c_func
(paren
id|SIGTSTP
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|L_ICANON
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|c
op_eq
id|ERASE_CHAR
c_func
(paren
id|tty
)paren
op_logical_or
id|c
op_eq
id|KILL_CHAR
c_func
(paren
id|tty
)paren
op_logical_or
(paren
id|c
op_eq
id|WERASE_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
)paren
(brace
id|eraser
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|LNEXT_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
(brace
id|tty-&gt;lnext
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHOCTL
c_func
(paren
id|tty
)paren
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;^&squot;
comma
id|tty
)paren
suffix:semicolon
id|put_char
c_func
(paren
l_char|&squot;&bslash;b&squot;
comma
id|tty
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|REPRINT_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
id|L_ECHO
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
(brace
r_int
r_int
id|tail
op_assign
id|tty-&gt;canon_head
suffix:semicolon
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|opost
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|tty
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tail
op_ne
id|tty-&gt;read_head
)paren
(brace
id|echo_char
c_func
(paren
id|tty-&gt;read_buf
(braket
id|tail
)braket
comma
id|tty
)paren
suffix:semicolon
id|tail
op_assign
(paren
id|tail
op_plus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
(brace
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
op_logical_or
id|L_ECHONL
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;a&squot;
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|opost
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|tty
)paren
suffix:semicolon
)brace
r_goto
id|handle_newline
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
id|EOF_CHAR
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;canon_head
op_ne
id|tty-&gt;read_head
)paren
id|set_bit
c_func
(paren
id|TTY_PUSH
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
id|c
op_assign
id|__DISABLED_CHAR
suffix:semicolon
r_goto
id|handle_newline
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|c
op_eq
id|EOL_CHAR
c_func
(paren
id|tty
)paren
)paren
op_logical_or
(paren
id|c
op_eq
id|EOL2_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * XXX are EOL_CHAR and EOL2_CHAR echoed?!?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;a&squot;
comma
id|tty
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Record the column of first canon char. */
r_if
c_cond
(paren
id|tty-&gt;canon_head
op_eq
id|tty-&gt;read_head
)paren
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
suffix:semicolon
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * XXX does PARMRK doubling happen for&n;&t;&t;&t; * EOL_CHAR and EOL2_CHAR?&n;&t;&t;&t; */
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
op_logical_and
id|c
op_eq
(paren
r_int
r_char
)paren
l_char|&squot;&bslash;377&squot;
)paren
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|handle_newline
suffix:colon
id|set_bit
c_func
(paren
id|tty-&gt;read_head
comma
op_amp
id|tty-&gt;read_flags
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|tty-&gt;canon_head
op_assign
id|tty-&gt;read_head
suffix:semicolon
id|tty-&gt;canon_data
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;fasync
)paren
id|kill_fasync
c_func
(paren
id|tty-&gt;fasync
comma
id|SIGIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;read_wait
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|finish_erasing
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
(brace
id|put_char
c_func
(paren
l_char|&squot;&bslash;a&squot;
comma
id|tty
)paren
suffix:semicolon
multiline_comment|/* beep if no space */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot;&bslash;n&squot;
)paren
id|opost
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
id|tty
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* Record the column of first canon char. */
r_if
c_cond
(paren
id|tty-&gt;canon_head
op_eq
id|tty-&gt;read_head
)paren
id|tty-&gt;canon_column
op_assign
id|tty-&gt;column
suffix:semicolon
id|echo_char
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|I_PARMRK
c_func
(paren
id|tty
)paren
op_logical_and
id|c
op_eq
(paren
r_int
r_char
)paren
l_char|&squot;&bslash;377&squot;
)paren
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
id|put_tty_queue
c_func
(paren
id|c
comma
id|tty
)paren
suffix:semicolon
)brace
DECL|function|n_tty_receive_buf
r_static
r_void
id|n_tty_receive_buf
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
op_star
id|cp
comma
r_char
op_star
id|fp
comma
r_int
id|count
)paren
(brace
r_int
r_char
op_star
id|p
suffix:semicolon
r_char
op_star
id|f
comma
id|flags
op_assign
l_int|0
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_buf
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;real_raw
)paren
(brace
id|i
op_assign
id|MIN
c_func
(paren
id|count
comma
id|MIN
c_func
(paren
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_cnt
comma
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_head
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tty-&gt;read_buf
op_plus
id|tty-&gt;read_head
comma
id|cp
comma
id|i
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
(paren
id|tty-&gt;read_head
op_plus
id|i
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_add_assign
id|i
suffix:semicolon
id|cp
op_add_assign
id|i
suffix:semicolon
id|count
op_sub_assign
id|i
suffix:semicolon
id|i
op_assign
id|MIN
c_func
(paren
id|count
comma
id|MIN
c_func
(paren
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_cnt
comma
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_head
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tty-&gt;read_buf
op_plus
id|tty-&gt;read_head
comma
id|cp
comma
id|i
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
(paren
id|tty-&gt;read_head
op_plus
id|i
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_add_assign
id|i
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
id|count
comma
id|p
op_assign
id|cp
comma
id|f
op_assign
id|fp
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
comma
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
id|f
)paren
id|flags
op_assign
op_star
id|f
op_increment
suffix:semicolon
r_switch
c_cond
(paren
id|flags
)paren
(brace
r_case
id|TTY_NORMAL
suffix:colon
id|n_tty_receive_char
c_func
(paren
id|tty
comma
op_star
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TTY_BREAK
suffix:colon
id|n_tty_receive_break
c_func
(paren
id|tty
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TTY_PARITY
suffix:colon
r_case
id|TTY_FRAME
suffix:colon
id|n_tty_receive_parity_error
c_func
(paren
id|tty
comma
op_star
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TTY_OVERRUN
suffix:colon
id|n_tty_receive_overrun
c_func
(paren
id|tty
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: unknown flag %d&bslash;n&quot;
comma
id|tty_name
c_func
(paren
id|tty
)paren
comma
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tty-&gt;driver.flush_chars
)paren
id|tty-&gt;driver
dot
id|flush_chars
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;icanon
op_logical_and
(paren
id|tty-&gt;read_cnt
op_ge
id|tty-&gt;minimum_to_wake
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;fasync
)paren
id|kill_fasync
c_func
(paren
id|tty-&gt;fasync
comma
id|SIGIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;read_wait
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|tty-&gt;read_cnt
op_ge
id|TTY_THRESHOLD_THROTTLE
)paren
op_logical_and
id|tty-&gt;driver.throttle
op_logical_and
op_logical_neg
id|set_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
)paren
id|tty-&gt;driver
dot
id|throttle
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|n_tty_receive_room
r_static
r_int
id|n_tty_receive_room
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_int
id|left
op_assign
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_cnt
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * If we are doing input canonicalization, and there are no&n;&t; * pending newlines, let characters through without limit, so&n;&t; * that erase characters will be handled.  Other excess&n;&t; * characters will be beeped.&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;icanon
op_logical_and
op_logical_neg
id|tty-&gt;canon_data
)paren
r_return
id|N_TTY_BUF_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|left
OG
l_int|0
)paren
r_return
id|left
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|is_ignored
r_int
id|is_ignored
c_func
(paren
r_int
id|sig
)paren
(brace
r_return
(paren
(paren
id|current-&gt;blocked
op_amp
(paren
l_int|1
op_lshift
(paren
id|sig
op_minus
l_int|1
)paren
)paren
)paren
op_logical_or
(paren
id|current-&gt;sigaction
(braket
id|sig
op_minus
l_int|1
)braket
dot
id|sa_handler
op_eq
id|SIG_IGN
)paren
)paren
suffix:semicolon
)brace
DECL|function|n_tty_set_termios
r_static
r_void
id|n_tty_set_termios
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|termios
op_star
id|old
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|tty-&gt;icanon
op_assign
(paren
id|L_ICANON
c_func
(paren
id|tty
)paren
op_ne
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|I_ISTRIP
c_func
(paren
id|tty
)paren
op_logical_or
id|I_IUCLC
c_func
(paren
id|tty
)paren
op_logical_or
id|I_IGNCR
c_func
(paren
id|tty
)paren
op_logical_or
id|I_ICRNL
c_func
(paren
id|tty
)paren
op_logical_or
id|I_INLCR
c_func
(paren
id|tty
)paren
op_logical_or
id|L_ICANON
c_func
(paren
id|tty
)paren
op_logical_or
id|I_IXON
c_func
(paren
id|tty
)paren
op_logical_or
id|L_ISIG
c_func
(paren
id|tty
)paren
op_logical_or
id|L_ECHO
c_func
(paren
id|tty
)paren
op_logical_or
id|I_PARMRK
c_func
(paren
id|tty
)paren
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|tty-&gt;process_char_map
comma
l_int|0
comma
l_int|256
op_div
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|I_IGNCR
c_func
(paren
id|tty
)paren
op_logical_or
id|I_ICRNL
c_func
(paren
id|tty
)paren
)paren
id|set_bit
c_func
(paren
l_char|&squot;&bslash;r&squot;
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|I_INLCR
c_func
(paren
id|tty
)paren
)paren
id|set_bit
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_ICANON
c_func
(paren
id|tty
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|ERASE_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|KILL_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|EOF_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
l_char|&squot;&bslash;n&squot;
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|EOL_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_IEXTEN
c_func
(paren
id|tty
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|WERASE_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|LNEXT_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|EOL2_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
r_if
c_cond
(paren
id|L_ECHO
c_func
(paren
id|tty
)paren
)paren
id|set_bit
c_func
(paren
id|REPRINT_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|I_IXON
c_func
(paren
id|tty
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|START_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|STOP_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|L_ISIG
c_func
(paren
id|tty
)paren
)paren
(brace
id|set_bit
c_func
(paren
id|INTR_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|QUIT_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|SUSP_CHAR
c_func
(paren
id|tty
)paren
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
)brace
id|clear_bit
c_func
(paren
id|__DISABLED_CHAR
comma
op_amp
id|tty-&gt;process_char_map
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|tty-&gt;raw
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;real_raw
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|tty-&gt;raw
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|I_IGNBRK
c_func
(paren
id|tty
)paren
op_logical_or
(paren
op_logical_neg
id|I_BRKINT
c_func
(paren
id|tty
)paren
op_logical_and
op_logical_neg
id|I_PARMRK
c_func
(paren
id|tty
)paren
)paren
)paren
op_logical_and
(paren
id|I_IGNPAR
c_func
(paren
id|tty
)paren
op_logical_or
op_logical_neg
id|I_INPCK
c_func
(paren
id|tty
)paren
)paren
op_logical_and
(paren
id|tty-&gt;driver.flags
op_amp
id|TTY_DRIVER_REAL_RAW
)paren
)paren
id|tty-&gt;real_raw
op_assign
l_int|1
suffix:semicolon
r_else
id|tty-&gt;real_raw
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|n_tty_close
r_static
r_void
id|n_tty_close
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|n_tty_flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;read_buf
)paren
(brace
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|tty-&gt;read_buf
)paren
suffix:semicolon
id|tty-&gt;read_buf
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|n_tty_open
r_static
r_int
id|n_tty_open
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_buf
)paren
(brace
id|tty-&gt;read_buf
op_assign
(paren
r_int
r_char
op_star
)paren
id|get_free_page
c_func
(paren
id|intr_count
ques
c_cond
id|GFP_ATOMIC
suffix:colon
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_buf
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|memset
c_func
(paren
id|tty-&gt;read_buf
comma
l_int|0
comma
id|N_TTY_BUF_SIZE
)paren
suffix:semicolon
id|tty-&gt;read_head
op_assign
id|tty-&gt;read_tail
op_assign
id|tty-&gt;read_cnt
op_assign
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|tty-&gt;read_flags
comma
l_int|0
comma
r_sizeof
(paren
id|tty-&gt;read_flags
)paren
)paren
suffix:semicolon
id|n_tty_set_termios
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
id|tty-&gt;minimum_to_wake
op_assign
l_int|1
suffix:semicolon
id|tty-&gt;closing
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|input_available_p
r_static
r_inline
r_int
id|input_available_p
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|amt
)paren
(brace
r_if
c_cond
(paren
id|L_ICANON
c_func
(paren
id|tty
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;canon_data
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|tty-&gt;read_cnt
op_ge
(paren
id|amt
ques
c_cond
id|amt
suffix:colon
l_int|1
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Helper function to speed up read_chan.  It is only called when&n; * ICANON is off; it copies characters straight from the tty queue to&n; * user space directly.  It can be profitably called twice; once to&n; * drain the space from the tail pointer to the (physical) end of the&n; * buffer, and once to drain the space from the (physical) beginning of&n; * the buffer to head pointer.&n; */
DECL|function|copy_from_read_buf
r_static
r_inline
r_void
id|copy_from_read_buf
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
op_star
op_star
id|b
comma
r_int
r_int
op_star
id|nr
)paren
(brace
r_int
id|n
suffix:semicolon
id|n
op_assign
id|MIN
c_func
(paren
op_star
id|nr
comma
id|MIN
c_func
(paren
id|tty-&gt;read_cnt
comma
id|N_TTY_BUF_SIZE
op_minus
id|tty-&gt;read_tail
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
r_return
suffix:semicolon
id|memcpy_tofs
c_func
(paren
op_star
id|b
comma
op_amp
id|tty-&gt;read_buf
(braket
id|tty-&gt;read_tail
)braket
comma
id|n
)paren
suffix:semicolon
id|tty-&gt;read_tail
op_assign
(paren
id|tty-&gt;read_tail
op_plus
id|n
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_sub_assign
id|n
suffix:semicolon
op_star
id|b
op_add_assign
id|n
suffix:semicolon
op_star
id|nr
op_sub_assign
id|n
suffix:semicolon
)brace
DECL|function|read_chan
r_static
r_int
id|read_chan
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_char
op_star
id|buf
comma
r_int
r_int
id|nr
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_int
id|c
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|buf
suffix:semicolon
r_int
id|minimum
comma
id|time
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_int
id|size
suffix:semicolon
id|do_it_again
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_buf
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;n_tty_read_chan: called with read_buf == NULL?!?&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Job control check -- must be done at start and after&n;&t;   every sleep (POSIX.1 7.1.1.4). */
multiline_comment|/* NOTE: not yet done after every sleep pending a thorough&n;&t;   check of the logic of this change. -- jlc */
multiline_comment|/* don&squot;t stop on /dev/console */
r_if
c_cond
(paren
id|file-&gt;f_inode-&gt;i_rdev
op_ne
id|CONSOLE_DEV
op_logical_and
id|current-&gt;tty
op_eq
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;pgrp
op_le
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;read_chan: tty-&gt;pgrp &lt;= 0!&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|current-&gt;pgrp
op_ne
id|tty-&gt;pgrp
)paren
(brace
r_if
c_cond
(paren
id|is_ignored
c_func
(paren
id|SIGTTIN
)paren
op_logical_or
id|is_orphaned_pgrp
c_func
(paren
id|current-&gt;pgrp
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|kill_pg
c_func
(paren
id|current-&gt;pgrp
comma
id|SIGTTIN
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|L_ICANON
c_func
(paren
id|tty
)paren
)paren
(brace
id|minimum
op_assign
id|time
op_assign
l_int|0
suffix:semicolon
id|current-&gt;timeout
op_assign
(paren
r_int
r_int
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|time
op_assign
(paren
id|HZ
op_div
l_int|10
)paren
op_star
id|TIME_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
id|minimum
op_assign
id|MIN_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minimum
)paren
(brace
id|current-&gt;timeout
op_assign
(paren
r_int
r_int
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|time
)paren
id|tty-&gt;minimum_to_wake
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_wait
op_logical_or
(paren
id|tty-&gt;minimum_to_wake
OG
id|minimum
)paren
)paren
id|tty-&gt;minimum_to_wake
op_assign
id|minimum
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|time
)paren
(brace
id|current-&gt;timeout
op_assign
id|time
op_plus
id|jiffies
suffix:semicolon
id|time
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;minimum_to_wake
op_assign
id|minimum
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|add_wait_queue
c_func
(paren
op_amp
id|tty-&gt;read_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* First test for status change. */
r_if
c_cond
(paren
id|tty-&gt;packet
op_logical_and
id|tty-&gt;link-&gt;ctrl_status
)paren
(brace
r_if
c_cond
(paren
id|b
op_ne
id|buf
)paren
r_break
suffix:semicolon
id|put_user
c_func
(paren
id|tty-&gt;link-&gt;ctrl_status
comma
id|b
op_increment
)paren
suffix:semicolon
id|tty-&gt;link-&gt;ctrl_status
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* This statement must be first before checking for input&n;&t;&t;   so that any interrupt will set the state back to&n;&t;&t;   TASK_RUNNING. */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|minimum
op_minus
(paren
id|b
op_minus
id|buf
)paren
)paren
OL
id|tty-&gt;minimum_to_wake
)paren
op_logical_and
(paren
(paren
id|minimum
op_minus
(paren
id|b
op_minus
id|buf
)paren
)paren
op_ge
l_int|1
)paren
)paren
id|tty-&gt;minimum_to_wake
op_assign
(paren
id|minimum
op_minus
(paren
id|b
op_minus
id|buf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|input_available_p
c_func
(paren
id|tty
comma
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_SLAVE_CLOSED
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|file
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;timeout
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
multiline_comment|/* Deal with packet mode. */
r_if
c_cond
(paren
id|tty-&gt;packet
op_logical_and
id|b
op_eq
id|buf
)paren
(brace
id|put_user
c_func
(paren
id|TIOCPKT_DATA
comma
id|b
op_increment
)paren
suffix:semicolon
id|nr
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|L_ICANON
c_func
(paren
id|tty
)paren
)paren
(brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
id|eol
suffix:semicolon
id|disable_bh
c_func
(paren
id|TQUEUE_BH
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_cnt
)paren
(brace
id|enable_bh
c_func
(paren
id|TQUEUE_BH
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|eol
op_assign
id|clear_bit
c_func
(paren
id|tty-&gt;read_tail
comma
op_amp
id|tty-&gt;read_flags
)paren
suffix:semicolon
id|c
op_assign
id|tty-&gt;read_buf
(braket
id|tty-&gt;read_tail
)braket
suffix:semicolon
id|tty-&gt;read_tail
op_assign
(paren
(paren
id|tty-&gt;read_tail
op_plus
l_int|1
)paren
op_amp
(paren
id|N_TTY_BUF_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|tty-&gt;read_cnt
op_decrement
suffix:semicolon
id|enable_bh
c_func
(paren
id|TQUEUE_BH
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|eol
)paren
(brace
id|put_user
c_func
(paren
id|c
comma
id|b
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|nr
)paren
r_continue
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_decrement
id|tty-&gt;canon_data
OL
l_int|0
)paren
(brace
id|tty-&gt;canon_data
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c
op_ne
id|__DISABLED_CHAR
)paren
(brace
id|put_user
c_func
(paren
id|c
comma
id|b
op_increment
)paren
suffix:semicolon
id|nr
op_decrement
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|disable_bh
c_func
(paren
id|TQUEUE_BH
)paren
suffix:semicolon
id|copy_from_read_buf
c_func
(paren
id|tty
comma
op_amp
id|b
comma
op_amp
id|nr
)paren
suffix:semicolon
id|copy_from_read_buf
c_func
(paren
id|tty
comma
op_amp
id|b
comma
op_amp
id|nr
)paren
suffix:semicolon
id|enable_bh
c_func
(paren
id|TQUEUE_BH
)paren
suffix:semicolon
)brace
multiline_comment|/* If there is enough space in the read buffer now, let the&n;&t;&t;   low-level driver know. */
r_if
c_cond
(paren
id|tty-&gt;driver.unthrottle
op_logical_and
(paren
id|tty-&gt;read_cnt
op_le
id|TTY_THRESHOLD_UNTHROTTLE
)paren
op_logical_and
id|clear_bit
c_func
(paren
id|TTY_THROTTLED
comma
op_amp
id|tty-&gt;flags
)paren
)paren
id|tty-&gt;driver
dot
id|unthrottle
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|b
op_minus
id|buf
op_ge
id|minimum
op_logical_or
op_logical_neg
id|nr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|time
)paren
id|current-&gt;timeout
op_assign
id|time
op_plus
id|jiffies
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|tty-&gt;read_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_wait
)paren
id|tty-&gt;minimum_to_wake
op_assign
id|minimum
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
id|size
op_assign
id|b
op_minus
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|size
op_logical_and
id|nr
)paren
id|clear_bit
c_func
(paren
id|TTY_PUSH
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
op_logical_and
id|clear_bit
c_func
(paren
id|TTY_PUSH
comma
op_amp
id|tty-&gt;flags
)paren
)paren
r_goto
id|do_it_again
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
op_logical_and
op_logical_neg
id|retval
)paren
id|clear_bit
c_func
(paren
id|TTY_PUSH
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_return
(paren
id|size
ques
c_cond
id|size
suffix:colon
id|retval
)paren
suffix:semicolon
)brace
DECL|function|write_chan
r_static
r_int
id|write_chan
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_char
op_star
id|buf
comma
r_int
r_int
id|nr
)paren
(brace
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_int
id|c
suffix:semicolon
r_int
r_char
op_star
id|b
op_assign
id|buf
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Job control check -- must be done at start (POSIX.1 7.1.1.4). */
r_if
c_cond
(paren
id|L_TOSTOP
c_func
(paren
id|tty
)paren
op_logical_and
id|file-&gt;f_inode-&gt;i_rdev
op_ne
id|CONSOLE_DEV
)paren
(brace
id|retval
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
)brace
id|add_wait_queue
c_func
(paren
op_amp
id|tty-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|retval
op_assign
op_minus
id|ERESTARTSYS
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|file
)paren
op_logical_or
(paren
id|tty-&gt;link
op_logical_and
op_logical_neg
id|tty-&gt;link-&gt;count
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EIO
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|O_OPOST
c_func
(paren
id|tty
)paren
)paren
(brace
r_while
c_loop
(paren
id|nr
OG
l_int|0
)paren
(brace
id|c
op_assign
id|get_user
c_func
(paren
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opost
c_func
(paren
id|c
comma
id|tty
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|b
op_increment
suffix:semicolon
id|nr
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;driver.flush_chars
)paren
id|tty-&gt;driver
dot
id|flush_chars
c_func
(paren
id|tty
)paren
suffix:semicolon
)brace
r_else
(brace
id|c
op_assign
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|1
comma
id|b
comma
id|nr
)paren
suffix:semicolon
id|b
op_add_assign
id|c
suffix:semicolon
id|nr
op_sub_assign
id|c
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|nr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_break
suffix:semicolon
)brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|tty-&gt;write_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
(paren
id|b
op_minus
id|buf
)paren
ques
c_cond
id|b
op_minus
id|buf
suffix:colon
id|retval
suffix:semicolon
)brace
DECL|function|normal_select
r_static
r_int
id|normal_select
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
r_switch
c_cond
(paren
id|sel_type
)paren
(brace
r_case
id|SEL_IN
suffix:colon
r_if
c_cond
(paren
id|input_available_p
c_func
(paren
id|tty
comma
id|TIME_CHAR
c_func
(paren
id|tty
)paren
ques
c_cond
l_int|0
suffix:colon
id|MIN_CHAR
c_func
(paren
id|tty
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SEL_EX
suffix:colon
r_if
c_cond
(paren
id|tty-&gt;packet
op_logical_and
id|tty-&gt;link-&gt;ctrl_status
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_SLAVE_CLOSED
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tty_hung_up_p
c_func
(paren
id|file
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_wait
)paren
(brace
r_if
c_cond
(paren
id|MIN_CHAR
c_func
(paren
id|tty
)paren
op_logical_and
op_logical_neg
id|TIME_CHAR
c_func
(paren
id|tty
)paren
)paren
id|tty-&gt;minimum_to_wake
op_assign
id|MIN_CHAR
c_func
(paren
id|tty
)paren
suffix:semicolon
r_else
id|tty-&gt;minimum_to_wake
op_assign
l_int|1
suffix:semicolon
)brace
id|select_wait
c_func
(paren
op_amp
id|tty-&gt;read_wait
comma
id|wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SEL_OUT
suffix:colon
r_if
c_cond
(paren
id|tty-&gt;driver
dot
id|chars_in_buffer
c_func
(paren
id|tty
)paren
OL
id|WAKEUP_CHARS
)paren
r_return
l_int|1
suffix:semicolon
id|select_wait
c_func
(paren
op_amp
id|tty-&gt;write_wait
comma
id|wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|tty_ldisc_N_TTY
r_struct
id|tty_ldisc
id|tty_ldisc_N_TTY
op_assign
(brace
id|TTY_LDISC_MAGIC
comma
multiline_comment|/* magic */
l_int|0
comma
multiline_comment|/* num */
l_int|0
comma
multiline_comment|/* flags */
id|n_tty_open
comma
multiline_comment|/* open */
id|n_tty_close
comma
multiline_comment|/* close */
id|n_tty_flush_buffer
comma
multiline_comment|/* flush_buffer */
id|n_tty_chars_in_buffer
comma
multiline_comment|/* chars_in_buffer */
id|read_chan
comma
multiline_comment|/* read */
id|write_chan
comma
multiline_comment|/* write */
id|n_tty_ioctl
comma
multiline_comment|/* ioctl */
id|n_tty_set_termios
comma
multiline_comment|/* set_termios */
id|normal_select
comma
multiline_comment|/* select */
id|n_tty_receive_buf
comma
multiline_comment|/* receive_buf */
id|n_tty_receive_room
comma
multiline_comment|/* receive_room */
l_int|0
multiline_comment|/* write_wakeup */
)brace
suffix:semicolon
eof
