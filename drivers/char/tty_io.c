multiline_comment|/*&n; *  linux/drivers/char/tty_io.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; * &squot;tty_io.c&squot; gives an orthogonal feeling to tty&squot;s, be they consoles&n; * or rs-channels. It also implements echoing, cooked mode etc.&n; *&n; * Kill-line thanks to John T Kohl, who also corrected VMIN = VTIME = 0.&n; *&n; * Modified by Theodore Ts&squot;o, 9/14/92, to dynamically allocate the&n; * tty_struct and tty_queue structures.  Previously there was a array&n; * of 256 tty_struct&squot;s which was statically allocated, and the&n; * tty_queue structures were allocated at boot time.  Both are now&n; * dynamically allocated only when the tty is open.&n; *&n; * Also restructured routines so that there is more of a separation&n; * between the high-level tty routines (tty_io.c and tty_ioctl.c) and&n; * the low-level tty routines (serial.c, pty.c, console.c).  This&n; * makes for cleaner and more compact code.  -TYT, 9/17/92 &n; *&n; * Modified by Fred N. van Kempen, 01/29/93, to add line disciplines&n; * which can be dynamically activated and de-activated by the line&n; * discipline handling modules (like SLIP).&n; *&n; * NOTE: pay no attention to the line discipline code (yet); its&n; * interface is still subject to change in this version...&n; * -- TYT, 1/31/92&n; *&n; * Added functionality to the OPOST tty handling.  No delays, but all&n; * other bits should be there.&n; *&t;-- Nick Holloway &lt;alfie@dcs.warwick.ac.uk&gt;, 27th May 1993.&n; *&n; * Rewrote canonical mode and added more termios flags.&n; * &t;-- julian@uhunix.uhcc.hawaii.edu (J. Cowley), 13Jan94&n; *&n; * Reorganized FASYNC support so mouse code can share it.&n; *&t;-- ctm@ardi.com, 9Sep95&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/kd.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;linux/scc.h&gt;
macro_line|#include &quot;kbd_kern.h&quot;
macro_line|#include &quot;vt_kern.h&quot;
macro_line|#include &quot;selection.h&quot;
DECL|macro|CONSOLE_DEV
mdefine_line|#define CONSOLE_DEV MKDEV(TTY_MAJOR,0)
DECL|macro|TTY_DEV
mdefine_line|#define TTY_DEV MKDEV(TTYAUX_MAJOR,0)
DECL|macro|TTY_DEBUG_HANGUP
macro_line|#undef TTY_DEBUG_HANGUP
DECL|macro|TTY_PARANOIA_CHECK
mdefine_line|#define TTY_PARANOIA_CHECK
DECL|macro|CHECK_TTY_COUNT
mdefine_line|#define CHECK_TTY_COUNT
r_extern
r_void
id|do_blank_screen
c_func
(paren
r_int
id|nopowersave
)paren
suffix:semicolon
r_extern
r_void
id|set_vesa_blanking
c_func
(paren
r_const
r_int
r_int
id|arg
)paren
suffix:semicolon
DECL|variable|tty_std_termios
r_struct
id|termios
id|tty_std_termios
suffix:semicolon
multiline_comment|/* for the benefit of tty drivers  */
DECL|variable|tty_drivers
r_struct
id|tty_driver
op_star
id|tty_drivers
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* linked list of tty drivers */
DECL|variable|ldiscs
r_struct
id|tty_ldisc
id|ldiscs
(braket
id|NR_LDISCS
)braket
suffix:semicolon
multiline_comment|/* line disc dispatch table&t;*/
multiline_comment|/*&n; * fg_console is the current virtual console,&n; * last_console is the last used one&n; * redirect is the pseudo-tty that console output&n; * is redirected to if asked by TIOCCONS.&n; */
DECL|variable|fg_console
r_int
id|fg_console
op_assign
l_int|0
suffix:semicolon
DECL|variable|last_console
r_int
id|last_console
op_assign
l_int|0
suffix:semicolon
DECL|variable|redirect
r_struct
id|tty_struct
op_star
id|redirect
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|keypress_wait
r_struct
id|wait_queue
op_star
id|keypress_wait
op_assign
l_int|NULL
suffix:semicolon
r_static
r_void
id|initialize_tty_struct
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
suffix:semicolon
r_static
r_int
id|tty_read
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|tty_write
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_const
r_char
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|tty_select
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_int
comma
id|select_table
op_star
)paren
suffix:semicolon
r_static
r_int
id|tty_open
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_void
id|tty_release
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|tty_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|tty_fasync
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
)paren
suffix:semicolon
r_extern
r_void
id|reset_palette
c_func
(paren
r_int
id|currcons
)paren
suffix:semicolon
r_extern
r_void
id|set_palette
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifndef MIN
DECL|macro|MIN
mdefine_line|#define MIN(a,b)&t;((a) &lt; (b) ? (a) : (b))
macro_line|#endif
multiline_comment|/*&n; * These two routines return the name of tty.  tty_name() should NOT&n; * be used in interrupt drivers, since it&squot;s not re-entrant.  Use&n; * _tty_name() instead.&n; */
DECL|function|_tty_name
r_char
op_star
id|_tty_name
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_char
op_star
id|buf
)paren
(brace
r_if
c_cond
(paren
id|tty
)paren
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s%d&quot;
comma
id|tty-&gt;driver.name
comma
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
op_plus
id|tty-&gt;driver.name_base
)paren
suffix:semicolon
r_else
id|strcpy
c_func
(paren
id|buf
comma
l_string|&quot;NULL tty&quot;
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
DECL|function|tty_name
r_char
op_star
id|tty_name
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_static
r_char
id|buf
(braket
l_int|64
)braket
suffix:semicolon
r_return
id|_tty_name
c_func
(paren
id|tty
comma
id|buf
)paren
suffix:semicolon
)brace
DECL|function|tty_paranoia_check
r_inline
r_int
id|tty_paranoia_check
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
id|kdev_t
id|device
comma
r_const
r_char
op_star
id|routine
)paren
(brace
macro_line|#ifdef TTY_PARANOIA_CHECK
r_static
r_const
r_char
op_star
id|badmagic
op_assign
l_string|&quot;Warning: bad magic number for tty struct (%s) in %s&bslash;n&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|badtty
op_assign
l_string|&quot;Warning: null TTY for (%s) in %s&bslash;n&quot;
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
(brace
id|printk
c_func
(paren
id|badtty
comma
id|kdevname
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;magic
op_ne
id|TTY_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|badmagic
comma
id|kdevname
c_func
(paren
id|device
)paren
comma
id|routine
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|check_tty_count
r_static
r_int
id|check_tty_count
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_const
r_char
op_star
id|routine
)paren
(brace
macro_line|#ifdef CHECK_TTY_COUNT
r_struct
id|file
op_star
id|f
suffix:semicolon
r_int
id|i
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|f
op_assign
id|first_file
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_files
suffix:semicolon
id|i
op_increment
comma
id|f
op_assign
id|f-&gt;f_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|f-&gt;f_count
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|f-&gt;private_data
op_eq
id|tty
)paren
(brace
id|count
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|tty-&gt;driver.type
op_eq
id|TTY_DRIVER_TYPE_PTY
op_logical_and
id|tty-&gt;driver.subtype
op_eq
id|PTY_TYPE_SLAVE
op_logical_and
id|tty-&gt;link
op_logical_and
id|tty-&gt;link-&gt;count
)paren
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;count
op_ne
id|count
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: dev (%s) tty-&gt;count(%d) != #fd&squot;s(%d) in %s&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|tty-&gt;device
)paren
comma
id|tty-&gt;count
comma
id|count
comma
id|routine
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|tty_register_ldisc
r_int
id|tty_register_ldisc
c_func
(paren
r_int
id|disc
comma
r_struct
id|tty_ldisc
op_star
id|new_ldisc
)paren
(brace
r_if
c_cond
(paren
id|disc
OL
id|N_TTY
op_logical_or
id|disc
op_ge
id|NR_LDISCS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|new_ldisc
)paren
(brace
id|ldiscs
(braket
id|disc
)braket
op_assign
op_star
id|new_ldisc
suffix:semicolon
id|ldiscs
(braket
id|disc
)braket
dot
id|flags
op_or_assign
id|LDISC_FLAG_DEFINED
suffix:semicolon
id|ldiscs
(braket
id|disc
)braket
dot
id|num
op_assign
id|disc
suffix:semicolon
)brace
r_else
id|memset
c_func
(paren
op_amp
id|ldiscs
(braket
id|disc
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_ldisc
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Set the discipline of a tty line. */
DECL|function|tty_set_ldisc
r_static
r_int
id|tty_set_ldisc
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
id|ldisc
)paren
(brace
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
r_struct
id|tty_ldisc
id|o_ldisc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ldisc
OL
id|N_TTY
)paren
op_logical_or
(paren
id|ldisc
op_ge
id|NR_LDISCS
)paren
op_logical_or
op_logical_neg
(paren
id|ldiscs
(braket
id|ldisc
)braket
dot
id|flags
op_amp
id|LDISC_FLAG_DEFINED
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.num
op_eq
id|ldisc
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* We are already in the desired discipline */
id|o_ldisc
op_assign
id|tty-&gt;ldisc
suffix:semicolon
id|tty_wait_until_sent
c_func
(paren
id|tty
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Shutdown the current discipline. */
r_if
c_cond
(paren
id|tty-&gt;ldisc.close
)paren
(paren
id|tty-&gt;ldisc.close
)paren
(paren
id|tty
)paren
suffix:semicolon
multiline_comment|/* Now set up the new line discipline. */
id|tty-&gt;ldisc
op_assign
id|ldiscs
(braket
id|ldisc
)braket
suffix:semicolon
id|tty-&gt;termios-&gt;c_line
op_assign
id|ldisc
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.open
)paren
id|retval
op_assign
(paren
id|tty-&gt;ldisc.open
)paren
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
id|tty-&gt;ldisc
op_assign
id|o_ldisc
suffix:semicolon
id|tty-&gt;termios-&gt;c_line
op_assign
id|tty-&gt;ldisc.num
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.open
op_logical_and
(paren
id|tty-&gt;ldisc
dot
id|open
c_func
(paren
id|tty
)paren
OL
l_int|0
)paren
)paren
(brace
id|tty-&gt;ldisc
op_assign
id|ldiscs
(braket
id|N_TTY
)braket
suffix:semicolon
id|tty-&gt;termios-&gt;c_line
op_assign
id|N_TTY
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.open
)paren
(brace
r_int
id|r
op_assign
id|tty-&gt;ldisc
dot
id|open
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
OL
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Couldn&squot;t open N_TTY ldisc for &quot;
l_string|&quot;%s --- error %d.&quot;
comma
id|tty_name
c_func
(paren
id|tty
)paren
comma
id|r
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|tty-&gt;ldisc.num
op_ne
id|o_ldisc.num
op_logical_and
id|tty-&gt;driver.set_ldisc
)paren
id|tty-&gt;driver
dot
id|set_ldisc
c_func
(paren
id|tty
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine returns a tty driver structure, given a device number&n; */
DECL|function|get_tty_driver
r_struct
id|tty_driver
op_star
id|get_tty_driver
c_func
(paren
id|kdev_t
id|device
)paren
(brace
r_int
id|major
comma
id|minor
suffix:semicolon
r_struct
id|tty_driver
op_star
id|p
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|device
)paren
suffix:semicolon
id|major
op_assign
id|MAJOR
c_func
(paren
id|device
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|tty_drivers
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;major
op_ne
id|major
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|minor
OL
id|p-&gt;minor_start
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|p-&gt;minor_start
op_plus
id|p-&gt;num
)paren
r_continue
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * If we try to write to, or set the state of, a terminal and we&squot;re&n; * not in the foreground, send a SIGTTOU.  If the signal is blocked or&n; * ignored, go ahead and perform the operation.  (POSIX 7.2)&n; */
DECL|function|tty_check_change
r_int
id|tty_check_change
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;tty
op_ne
id|tty
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;pgrp
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;tty_check_change: tty-&gt;pgrp &lt;= 0!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current-&gt;pgrp
op_eq
id|tty-&gt;pgrp
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_ignored
c_func
(paren
id|SIGTTOU
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_orphaned_pgrp
c_func
(paren
id|current-&gt;pgrp
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
(paren
r_void
)paren
id|kill_pg
c_func
(paren
id|current-&gt;pgrp
comma
id|SIGTTOU
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
DECL|function|hung_up_tty_read
r_static
r_int
id|hung_up_tty_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hung_up_tty_write
r_static
r_int
id|hung_up_tty_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|hung_up_tty_select
r_static
r_int
id|hung_up_tty_select
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|hung_up_tty_ioctl
r_static
r_int
id|hung_up_tty_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|tty_lseek
r_static
r_int
id|tty_lseek
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|off_t
id|offset
comma
r_int
id|orig
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
DECL|variable|tty_fops
r_static
r_struct
id|file_operations
id|tty_fops
op_assign
(brace
id|tty_lseek
comma
id|tty_read
comma
id|tty_write
comma
l_int|NULL
comma
multiline_comment|/* tty_readdir */
id|tty_select
comma
id|tty_ioctl
comma
l_int|NULL
comma
multiline_comment|/* tty_mmap */
id|tty_open
comma
id|tty_release
comma
l_int|NULL
comma
multiline_comment|/* tty_fsync */
id|tty_fasync
)brace
suffix:semicolon
DECL|variable|hung_up_tty_fops
r_static
r_struct
id|file_operations
id|hung_up_tty_fops
op_assign
(brace
id|tty_lseek
comma
id|hung_up_tty_read
comma
id|hung_up_tty_write
comma
l_int|NULL
comma
multiline_comment|/* hung_up_tty_readdir */
id|hung_up_tty_select
comma
id|hung_up_tty_ioctl
comma
l_int|NULL
comma
multiline_comment|/* hung_up_tty_mmap */
l_int|NULL
comma
multiline_comment|/* hung_up_tty_open */
id|tty_release
comma
multiline_comment|/* hung_up_tty_release */
l_int|NULL
comma
multiline_comment|/* hung_up_tty_fsync  */
l_int|NULL
multiline_comment|/* hung_up_tty_fasync */
)brace
suffix:semicolon
DECL|function|do_tty_hangup
r_void
id|do_tty_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_struct
id|file_operations
op_star
id|fops
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|check_tty_count
c_func
(paren
id|tty
comma
l_string|&quot;do_tty_hangup&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|filp
op_assign
id|first_file
comma
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_files
suffix:semicolon
id|i
op_increment
comma
id|filp
op_assign
id|filp-&gt;f_next
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|filp-&gt;f_count
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;private_data
op_ne
id|tty
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_inode
op_logical_and
id|filp-&gt;f_inode-&gt;i_rdev
op_eq
id|CONSOLE_DEV
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_op
op_ne
op_amp
id|tty_fops
)paren
r_continue
suffix:semicolon
id|tty_fasync
c_func
(paren
id|filp-&gt;f_inode
comma
id|filp
comma
l_int|0
)paren
suffix:semicolon
id|filp-&gt;f_op
op_assign
id|fops
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;read_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Shutdown the current line discipline, and reset it to&n;&t; * N_TTY.&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;ldisc.num
op_ne
id|ldiscs
(braket
id|N_TTY
)braket
dot
id|num
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;ldisc.close
)paren
(paren
id|tty-&gt;ldisc.close
)paren
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;ldisc
op_assign
id|ldiscs
(braket
id|N_TTY
)braket
suffix:semicolon
id|tty-&gt;termios-&gt;c_line
op_assign
id|N_TTY
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.open
)paren
(brace
id|i
op_assign
(paren
id|tty-&gt;ldisc.open
)paren
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;do_tty_hangup: N_TTY open: error %d&bslash;n&quot;
comma
op_minus
id|i
)paren
suffix:semicolon
)brace
)brace
id|for_each_task
c_func
(paren
id|p
)paren
(brace
r_if
c_cond
(paren
(paren
id|tty-&gt;session
OG
l_int|0
)paren
op_logical_and
(paren
id|p-&gt;session
op_eq
id|tty-&gt;session
)paren
op_logical_and
id|p-&gt;leader
)paren
(brace
id|send_sig
c_func
(paren
id|SIGHUP
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
id|send_sig
c_func
(paren
id|SIGCONT
comma
id|p
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;pgrp
OG
l_int|0
)paren
id|p-&gt;tty_old_pgrp
op_assign
id|tty-&gt;pgrp
suffix:semicolon
)brace
r_if
c_cond
(paren
id|p-&gt;tty
op_eq
id|tty
)paren
id|p-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
)brace
id|tty-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;session
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;pgrp
op_assign
op_minus
l_int|1
suffix:semicolon
id|tty-&gt;ctrl_status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flags
op_amp
id|TTY_DRIVER_RESET_TERMIOS
)paren
op_star
id|tty-&gt;termios
op_assign
id|tty-&gt;driver.init_termios
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.hangup
)paren
(paren
id|tty-&gt;driver.hangup
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|tty_hangup
r_void
id|tty_hangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
macro_line|#ifdef TTY_DEBUG_HANGUP
id|printk
c_func
(paren
l_string|&quot;%s hangup...&bslash;n&quot;
comma
id|tty_name
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
macro_line|#endif
id|do_tty_hangup
c_func
(paren
id|tty
comma
op_amp
id|hung_up_tty_fops
)paren
suffix:semicolon
)brace
DECL|function|tty_vhangup
r_void
id|tty_vhangup
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
macro_line|#ifdef TTY_DEBUG_HANGUP
id|printk
c_func
(paren
l_string|&quot;%s vhangup...&bslash;n&quot;
comma
id|tty_name
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
macro_line|#endif
id|do_tty_hangup
c_func
(paren
id|tty
comma
op_amp
id|hung_up_tty_fops
)paren
suffix:semicolon
)brace
DECL|function|tty_hung_up_p
r_int
id|tty_hung_up_p
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
r_return
(paren
id|filp-&gt;f_op
op_eq
op_amp
id|hung_up_tty_fops
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is typically called only by the session leader, when&n; * it wants to disassociate itself from its controlling tty.&n; *&n; * It performs the following functions:&n; * &t;(1)  Sends a SIGHUP and SIGCONT to the foreground process group&n; * &t;(2)  Clears the tty from being controlling the session&n; * &t;(3)  Clears the controlling tty for all processes in the&n; * &t;&t;session group.&n; */
DECL|function|disassociate_ctty
r_void
id|disassociate_ctty
c_func
(paren
r_int
id|priv
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
id|current-&gt;tty
suffix:semicolon
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;tty_old_pgrp
)paren
(brace
id|kill_pg
c_func
(paren
id|current-&gt;tty_old_pgrp
comma
id|SIGHUP
comma
id|priv
)paren
suffix:semicolon
id|kill_pg
c_func
(paren
id|current-&gt;tty_old_pgrp
comma
id|SIGCONT
comma
id|priv
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;pgrp
OG
l_int|0
)paren
(brace
id|kill_pg
c_func
(paren
id|tty-&gt;pgrp
comma
id|SIGHUP
comma
id|priv
)paren
suffix:semicolon
id|kill_pg
c_func
(paren
id|tty-&gt;pgrp
comma
id|SIGCONT
comma
id|priv
)paren
suffix:semicolon
)brace
id|current-&gt;tty_old_pgrp
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;session
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;pgrp
op_assign
op_minus
l_int|1
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
r_if
c_cond
(paren
id|p-&gt;session
op_eq
id|current-&gt;session
)paren
id|p-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * Sometimes we want to wait until a particular VT has been activated. We&n; * do it in a very simple manner. Everybody waits on a single queue and&n; * get woken up at once. Those that are satisfied go on with their business,&n; * while those not ready go back to sleep. Seems overkill to add a wait&n; * to each vt just for this - usually this does nothing!&n; */
DECL|variable|vt_activate_queue
r_static
r_struct
id|wait_queue
op_star
id|vt_activate_queue
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n; * Sleeps until a vt is activated, or the task is interrupted. Returns&n; * 0 if activation, -1 if interrupted.&n; */
DECL|function|vt_waitactive
r_int
id|vt_waitactive
c_func
(paren
r_void
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|vt_activate_queue
)paren
suffix:semicolon
r_return
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
ques
c_cond
op_minus
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|macro|vt_wake_waitactive
mdefine_line|#define vt_wake_waitactive() wake_up(&amp;vt_activate_queue)
DECL|function|reset_vc
r_void
id|reset_vc
c_func
(paren
r_int
r_int
id|new_console
)paren
(brace
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vc_mode
op_assign
id|KD_TEXT
suffix:semicolon
id|kbd_table
(braket
id|new_console
)braket
dot
id|kbdmode
op_assign
id|VC_XLATE
suffix:semicolon
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_mode.mode
op_assign
id|VT_AUTO
suffix:semicolon
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_mode.waitv
op_assign
l_int|0
suffix:semicolon
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_mode.relsig
op_assign
l_int|0
suffix:semicolon
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_mode.acqsig
op_assign
l_int|0
suffix:semicolon
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_mode.frsig
op_assign
l_int|0
suffix:semicolon
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_pid
op_assign
op_minus
l_int|1
suffix:semicolon
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_newvt
op_assign
op_minus
l_int|1
suffix:semicolon
id|reset_palette
(paren
id|new_console
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Performs the back end of a vt switch&n; */
DECL|function|complete_change_console
r_void
id|complete_change_console
c_func
(paren
r_int
r_int
id|new_console
)paren
(brace
r_int
r_char
id|old_vc_mode
suffix:semicolon
r_if
c_cond
(paren
id|new_console
op_eq
id|fg_console
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|new_console
)paren
)paren
r_return
suffix:semicolon
id|last_console
op_assign
id|fg_console
suffix:semicolon
multiline_comment|/*&n;&t; * If we&squot;re switching, we could be going from KD_GRAPHICS to&n;&t; * KD_TEXT mode or vice versa, which means we need to blank or&n;&t; * unblank the screen later.&n;&t; */
id|old_vc_mode
op_assign
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vc_mode
suffix:semicolon
id|update_screen
c_func
(paren
id|new_console
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If this new console is under process control, send it a signal&n;&t; * telling it that it has acquired. Also check if it has died and&n;&t; * clean up (similar to logic employed in change_console())&n;&t; */
r_if
c_cond
(paren
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_mode.mode
op_eq
id|VT_PROCESS
)paren
(brace
multiline_comment|/*&n;&t;&t; * Send the signal as privileged - kill_proc() will&n;&t;&t; * tell us if the process has gone or something else&n;&t;&t; * is awry&n;&t;&t; */
r_if
c_cond
(paren
id|kill_proc
c_func
(paren
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_pid
comma
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vt_mode.acqsig
comma
l_int|1
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The controlling process has died, so we revert back to&n;&t;&t; * normal operation. In this case, we&squot;ll also change back&n;&t;&t; * to KD_TEXT mode. I&squot;m not sure if this is strictly correct&n;&t;&t; * but it saves the agony when the X server dies and the screen&n;&t;&t; * remains blanked due to KD_GRAPHICS! It would be nice to do&n;&t;&t; * this outside of VT_PROCESS but there is no single process&n;&t;&t; * to account for and tracking tty count may be undesirable.&n;&t;&t; */
id|reset_vc
c_func
(paren
id|new_console
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * We do this here because the controlling process above may have&n;&t; * gone, and so there is now a new vc_mode&n;&t; */
r_if
c_cond
(paren
id|old_vc_mode
op_ne
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vc_mode
)paren
(brace
r_if
c_cond
(paren
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vc_mode
op_eq
id|KD_TEXT
)paren
id|do_unblank_screen
c_func
(paren
)paren
suffix:semicolon
r_else
id|do_blank_screen
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the colour palette for this VT */
r_if
c_cond
(paren
id|vt_cons
(braket
id|new_console
)braket
op_member_access_from_pointer
id|vc_mode
op_eq
id|KD_TEXT
)paren
id|set_palette
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Wake anyone waiting for their VT to activate&n;&t; */
id|vt_wake_waitactive
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * Performs the front-end of a vt switch&n; */
DECL|function|change_console
r_void
id|change_console
c_func
(paren
r_int
r_int
id|new_console
)paren
(brace
r_if
c_cond
(paren
id|new_console
op_eq
id|fg_console
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|vc_cons_allocated
c_func
(paren
id|new_console
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If this vt is in process mode, then we need to handshake with&n;&t; * that process before switching. Essentially, we store where that&n;&t; * vt wants to switch to and wait for it to tell us when it&squot;s done&n;&t; * (via VT_RELDISP ioctl).&n;&t; *&n;&t; * We also check to see if the controlling process still exists.&n;&t; * If it doesn&squot;t, we reset this vt to auto mode and continue.&n;&t; * This is a cheap way to track process control. The worst thing&n;&t; * that can happen is: we send a signal to a process, it dies, and&n;&t; * the switch gets &quot;lost&quot; waiting for a response; hopefully, the&n;&t; * user will try again, we&squot;ll detect the process is gone (unless&n;&t; * the user waits just the right amount of time :-) and revert the&n;&t; * vt to auto control.&n;&t; */
r_if
c_cond
(paren
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vt_mode.mode
op_eq
id|VT_PROCESS
)paren
(brace
multiline_comment|/*&n;&t;&t; * Send the signal as privileged - kill_proc() will&n;&t;&t; * tell us if the process has gone or something else&n;&t;&t; * is awry&n;&t;&t; */
r_if
c_cond
(paren
id|kill_proc
c_func
(paren
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vt_pid
comma
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vt_mode.relsig
comma
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * It worked. Mark the vt to switch to and&n;&t;&t;&t; * return. The process needs to send us a&n;&t;&t;&t; * VT_RELDISP ioctl to complete the switch.&n;&t;&t;&t; */
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vt_newvt
op_assign
id|new_console
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The controlling process has died, so we revert back to&n;&t;&t; * normal operation. In this case, we&squot;ll also change back&n;&t;&t; * to KD_TEXT mode. I&squot;m not sure if this is strictly correct&n;&t;&t; * but it saves the agony when the X server dies and the screen&n;&t;&t; * remains blanked due to KD_GRAPHICS! It would be nice to do&n;&t;&t; * this outside of VT_PROCESS but there is no single process&n;&t;&t; * to account for and tracking tty count may be undesirable.&n;&t;&t; */
id|reset_vc
c_func
(paren
id|fg_console
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Fall through to normal (VT_AUTO) handling of the switch...&n;&t;&t; */
)brace
multiline_comment|/*&n;&t; * Ignore all switches in KD_GRAPHICS+VT_AUTO mode&n;&t; */
r_if
c_cond
(paren
id|vt_cons
(braket
id|fg_console
)braket
op_member_access_from_pointer
id|vc_mode
op_eq
id|KD_GRAPHICS
)paren
r_return
suffix:semicolon
id|complete_change_console
c_func
(paren
id|new_console
)paren
suffix:semicolon
)brace
DECL|function|wait_for_keypress
r_void
id|wait_for_keypress
c_func
(paren
r_void
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|keypress_wait
)paren
suffix:semicolon
)brace
DECL|function|stop_tty
r_void
id|stop_tty
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;stopped
)paren
r_return
suffix:semicolon
id|tty-&gt;stopped
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;link
op_logical_and
id|tty-&gt;link-&gt;packet
)paren
(brace
id|tty-&gt;ctrl_status
op_and_assign
op_complement
id|TIOCPKT_START
suffix:semicolon
id|tty-&gt;ctrl_status
op_or_assign
id|TIOCPKT_STOP
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;link-&gt;read_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;driver.stop
)paren
(paren
id|tty-&gt;driver.stop
)paren
(paren
id|tty
)paren
suffix:semicolon
)brace
DECL|function|start_tty
r_void
id|start_tty
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;stopped
)paren
r_return
suffix:semicolon
id|tty-&gt;stopped
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;link
op_logical_and
id|tty-&gt;link-&gt;packet
)paren
(brace
id|tty-&gt;ctrl_status
op_and_assign
op_complement
id|TIOCPKT_STOP
suffix:semicolon
id|tty-&gt;ctrl_status
op_or_assign
id|TIOCPKT_START
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;link-&gt;read_wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;driver.start
)paren
(paren
id|tty-&gt;driver.start
)paren
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_DO_WRITE_WAKEUP
)paren
)paren
op_logical_and
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty-&gt;ldisc.write_wakeup
)paren
(paren
id|tty
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|tty-&gt;write_wait
)paren
suffix:semicolon
)brace
DECL|function|tty_read
r_static
r_int
id|tty_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|tty_paranoia_check
c_func
(paren
id|tty
comma
id|inode-&gt;i_rdev
comma
l_string|&quot;tty_read&quot;
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* This check not only needs to be done before reading, but also&n;&t;   whenever read_chan() gets woken up after sleeping, so I&squot;ve&n;&t;   moved it to there.  This should only be done for the N_TTY&n;&t;   line discipline, anyway.  Same goes for write_chan(). -- jlc. */
macro_line|#if 0
r_if
c_cond
(paren
(paren
id|inode-&gt;i_rdev
op_ne
id|CONSOLE_DEV
)paren
op_logical_and
multiline_comment|/* don&squot;t stop on /dev/console */
(paren
id|tty-&gt;pgrp
OG
l_int|0
)paren
op_logical_and
(paren
id|current-&gt;tty
op_eq
id|tty
)paren
op_logical_and
(paren
id|tty-&gt;pgrp
op_ne
id|current-&gt;pgrp
)paren
)paren
r_if
c_cond
(paren
id|is_ignored
c_func
(paren
id|SIGTTIN
)paren
op_logical_or
id|is_orphaned_pgrp
c_func
(paren
id|current-&gt;pgrp
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_else
(brace
(paren
r_void
)paren
id|kill_pg
c_func
(paren
id|current-&gt;pgrp
comma
id|SIGTTIN
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|tty-&gt;ldisc.read
)paren
multiline_comment|/* XXX casts are for what kernel-wide prototypes should be. */
id|i
op_assign
(paren
id|tty-&gt;ldisc.read
)paren
(paren
id|tty
comma
id|file
comma
(paren
r_int
r_char
op_star
)paren
id|buf
comma
(paren
r_int
r_int
)paren
id|count
)paren
suffix:semicolon
r_else
id|i
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|inode-&gt;i_atime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|tty_write
r_static
r_int
id|tty_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|i
comma
id|is_console
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|is_console
op_assign
(paren
id|inode-&gt;i_rdev
op_eq
id|CONSOLE_DEV
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_console
op_logical_and
id|redirect
)paren
id|tty
op_assign
id|redirect
suffix:semicolon
r_else
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|tty_paranoia_check
c_func
(paren
id|tty
comma
id|inode-&gt;i_rdev
comma
l_string|&quot;tty_write&quot;
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
op_logical_or
op_logical_neg
id|tty-&gt;driver.write
op_logical_or
(paren
id|tty-&gt;flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_IO_ERROR
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|is_console
op_logical_and
id|L_TOSTOP
c_func
(paren
id|tty
)paren
op_logical_and
(paren
id|tty-&gt;pgrp
OG
l_int|0
)paren
op_logical_and
(paren
id|current-&gt;tty
op_eq
id|tty
)paren
op_logical_and
(paren
id|tty-&gt;pgrp
op_ne
id|current-&gt;pgrp
)paren
)paren
(brace
r_if
c_cond
(paren
id|is_orphaned_pgrp
c_func
(paren
id|current-&gt;pgrp
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_ignored
c_func
(paren
id|SIGTTOU
)paren
)paren
(brace
(paren
r_void
)paren
id|kill_pg
c_func
(paren
id|current-&gt;pgrp
comma
id|SIGTTOU
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|tty-&gt;ldisc.write
)paren
multiline_comment|/* XXX casts are for what kernel-wide prototypes should be. */
id|i
op_assign
(paren
id|tty-&gt;ldisc.write
)paren
(paren
id|tty
comma
id|file
comma
(paren
r_const
r_int
r_char
op_star
)paren
id|buf
comma
(paren
r_int
r_int
)paren
id|count
)paren
suffix:semicolon
r_else
id|i
op_assign
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
id|inode-&gt;i_mtime
op_assign
id|CURRENT_TIME
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/*&n; * This is so ripe with races that you should *really* not touch this&n; * unless you know exactly what you are doing. All the changes have to be&n; * made atomically, or there may be incorrect pointers all over the place.&n; */
DECL|function|init_dev
r_static
r_int
id|init_dev
c_func
(paren
id|kdev_t
id|device
comma
r_struct
id|tty_struct
op_star
op_star
id|ret_tty
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
comma
op_star
op_star
id|tty_loc
comma
op_star
id|o_tty
comma
op_star
op_star
id|o_tty_loc
suffix:semicolon
r_struct
id|termios
op_star
id|tp
comma
op_star
op_star
id|tp_loc
comma
op_star
id|o_tp
comma
op_star
op_star
id|o_tp_loc
suffix:semicolon
r_struct
id|termios
op_star
id|ltp
comma
op_star
op_star
id|ltp_loc
comma
op_star
id|o_ltp
comma
op_star
op_star
id|o_ltp_loc
suffix:semicolon
r_struct
id|tty_driver
op_star
id|driver
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_int
id|idx
suffix:semicolon
id|driver
op_assign
id|get_tty_driver
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|driver
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|idx
op_assign
id|MINOR
c_func
(paren
id|device
)paren
op_minus
id|driver-&gt;minor_start
suffix:semicolon
id|tty
op_assign
id|o_tty
op_assign
l_int|NULL
suffix:semicolon
id|tp
op_assign
id|o_tp
op_assign
l_int|NULL
suffix:semicolon
id|ltp
op_assign
id|o_ltp
op_assign
l_int|NULL
suffix:semicolon
id|o_tty_loc
op_assign
l_int|NULL
suffix:semicolon
id|o_tp_loc
op_assign
id|o_ltp_loc
op_assign
l_int|NULL
suffix:semicolon
id|tty_loc
op_assign
op_amp
id|driver-&gt;table
(braket
id|idx
)braket
suffix:semicolon
id|tp_loc
op_assign
op_amp
id|driver-&gt;termios
(braket
id|idx
)braket
suffix:semicolon
id|ltp_loc
op_assign
op_amp
id|driver-&gt;termios_locked
(braket
id|idx
)braket
suffix:semicolon
id|repeat
suffix:colon
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;type
op_eq
id|TTY_DRIVER_TYPE_PTY
op_logical_and
id|driver-&gt;subtype
op_eq
id|PTY_TYPE_MASTER
op_logical_and
op_star
id|tty_loc
op_logical_and
(paren
op_star
id|tty_loc
)paren
op_member_access_from_pointer
id|count
)paren
r_goto
id|end_init
suffix:semicolon
id|retval
op_assign
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|tty_loc
op_logical_and
op_logical_neg
id|tty
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
r_goto
id|end_init
suffix:semicolon
id|initialize_tty_struct
c_func
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;device
op_assign
id|device
suffix:semicolon
id|tty-&gt;driver
op_assign
op_star
id|driver
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|tp_loc
op_logical_and
op_logical_neg
id|tp
)paren
(brace
id|tp
op_assign
(paren
r_struct
id|termios
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|termios
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tp
)paren
r_goto
id|end_init
suffix:semicolon
op_star
id|tp
op_assign
id|driver-&gt;init_termios
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|ltp_loc
op_logical_and
op_logical_neg
id|ltp
)paren
(brace
id|ltp
op_assign
(paren
r_struct
id|termios
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|termios
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ltp
)paren
r_goto
id|end_init
suffix:semicolon
id|memset
c_func
(paren
id|ltp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver-&gt;type
op_eq
id|TTY_DRIVER_TYPE_PTY
)paren
(brace
id|o_tty_loc
op_assign
op_amp
id|driver-&gt;other-&gt;table
(braket
id|idx
)braket
suffix:semicolon
id|o_tp_loc
op_assign
op_amp
id|driver-&gt;other-&gt;termios
(braket
id|idx
)braket
suffix:semicolon
id|o_ltp_loc
op_assign
op_amp
id|driver-&gt;other-&gt;termios_locked
(braket
id|idx
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|o_tty_loc
op_logical_and
op_logical_neg
id|o_tty
)paren
(brace
id|kdev_t
id|o_device
suffix:semicolon
id|o_tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o_tty
)paren
r_goto
id|end_init
suffix:semicolon
id|o_device
op_assign
id|MKDEV
c_func
(paren
id|driver-&gt;other-&gt;major
comma
id|driver-&gt;other-&gt;minor_start
op_plus
id|idx
)paren
suffix:semicolon
id|initialize_tty_struct
c_func
(paren
id|o_tty
)paren
suffix:semicolon
id|o_tty-&gt;device
op_assign
id|o_device
suffix:semicolon
id|o_tty-&gt;driver
op_assign
op_star
id|driver-&gt;other
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|o_tp_loc
op_logical_and
op_logical_neg
id|o_tp
)paren
(brace
id|o_tp
op_assign
(paren
r_struct
id|termios
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|termios
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o_tp
)paren
r_goto
id|end_init
suffix:semicolon
op_star
id|o_tp
op_assign
id|driver-&gt;other-&gt;init_termios
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|o_ltp_loc
op_logical_and
op_logical_neg
id|o_ltp
)paren
(brace
id|o_ltp
op_assign
(paren
r_struct
id|termios
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|termios
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|o_ltp
)paren
r_goto
id|end_init
suffix:semicolon
id|memset
c_func
(paren
id|o_ltp
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
multiline_comment|/* Now we have allocated all the structures: update all the pointers.. */
r_if
c_cond
(paren
op_logical_neg
op_star
id|tp_loc
)paren
(brace
op_star
id|tp_loc
op_assign
id|tp
suffix:semicolon
id|tp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|ltp_loc
)paren
(brace
op_star
id|ltp_loc
op_assign
id|ltp
suffix:semicolon
id|ltp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|tty_loc
)paren
(brace
id|tty-&gt;termios
op_assign
op_star
id|tp_loc
suffix:semicolon
id|tty-&gt;termios_locked
op_assign
op_star
id|ltp_loc
suffix:semicolon
op_star
id|tty_loc
op_assign
id|tty
suffix:semicolon
(paren
op_star
id|driver-&gt;refcount
)paren
op_increment
suffix:semicolon
(paren
op_star
id|tty_loc
)paren
op_member_access_from_pointer
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.open
)paren
(brace
id|retval
op_assign
(paren
id|tty-&gt;ldisc.open
)paren
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
(paren
op_star
id|tty_loc
)paren
op_member_access_from_pointer
id|count
op_decrement
suffix:semicolon
id|tty
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|end_init
suffix:semicolon
)brace
)brace
id|tty
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
op_star
id|tty_loc
)paren
op_member_access_from_pointer
id|flags
op_amp
(paren
l_int|1
op_lshift
id|TTY_CLOSING
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Attempt to open closing tty %s.&bslash;n&quot;
comma
id|tty_name
c_func
(paren
op_star
id|tty_loc
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Ack!!!!  This should never happen!!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
(paren
op_star
id|tty_loc
)paren
op_member_access_from_pointer
id|count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|driver-&gt;type
op_eq
id|TTY_DRIVER_TYPE_PTY
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|o_tp_loc
)paren
(brace
op_star
id|o_tp_loc
op_assign
id|o_tp
suffix:semicolon
id|o_tp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|o_ltp_loc
)paren
(brace
op_star
id|o_ltp_loc
op_assign
id|o_ltp
suffix:semicolon
id|o_ltp
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|o_tty_loc
)paren
(brace
id|o_tty-&gt;termios
op_assign
op_star
id|o_tp_loc
suffix:semicolon
id|o_tty-&gt;termios_locked
op_assign
op_star
id|o_ltp_loc
suffix:semicolon
op_star
id|o_tty_loc
op_assign
id|o_tty
suffix:semicolon
(paren
op_star
id|driver-&gt;other-&gt;refcount
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|o_tty-&gt;ldisc.open
)paren
(brace
id|retval
op_assign
(paren
id|o_tty-&gt;ldisc.open
)paren
(paren
id|o_tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
(brace
(paren
op_star
id|tty_loc
)paren
op_member_access_from_pointer
id|count
op_decrement
suffix:semicolon
id|o_tty
op_assign
l_int|NULL
suffix:semicolon
r_goto
id|end_init
suffix:semicolon
)brace
)brace
id|o_tty
op_assign
l_int|NULL
suffix:semicolon
)brace
(paren
op_star
id|tty_loc
)paren
op_member_access_from_pointer
id|link
op_assign
op_star
id|o_tty_loc
suffix:semicolon
(paren
op_star
id|o_tty_loc
)paren
op_member_access_from_pointer
id|link
op_assign
op_star
id|tty_loc
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;subtype
op_eq
id|PTY_TYPE_MASTER
)paren
(paren
op_star
id|o_tty_loc
)paren
op_member_access_from_pointer
id|count
op_increment
suffix:semicolon
)brace
(paren
op_star
id|tty_loc
)paren
op_member_access_from_pointer
id|driver
op_assign
op_star
id|driver
suffix:semicolon
op_star
id|ret_tty
op_assign
op_star
id|tty_loc
suffix:semicolon
id|retval
op_assign
l_int|0
suffix:semicolon
id|end_init
suffix:colon
r_if
c_cond
(paren
id|tty
)paren
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o_tty
)paren
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|o_tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tp
)paren
id|kfree_s
c_func
(paren
id|tp
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o_tp
)paren
id|kfree_s
c_func
(paren
id|o_tp
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ltp
)paren
id|kfree_s
c_func
(paren
id|ltp
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|o_ltp
)paren
id|kfree_s
c_func
(paren
id|o_ltp
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Even releasing the tty structures is a tricky business.. We have&n; * to be very careful that the structures are all released at the&n; * same time, as interrupts might otherwise get the wrong pointers.&n; */
DECL|function|release_dev
r_static
r_void
id|release_dev
c_func
(paren
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
comma
op_star
id|o_tty
suffix:semicolon
r_struct
id|termios
op_star
id|tp
comma
op_star
id|o_tp
comma
op_star
id|ltp
comma
op_star
id|o_ltp
suffix:semicolon
r_struct
id|task_struct
op_star
op_star
id|p
suffix:semicolon
r_int
id|idx
suffix:semicolon
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|tty_paranoia_check
c_func
(paren
id|tty
comma
id|filp-&gt;f_inode-&gt;i_rdev
comma
l_string|&quot;release_dev&quot;
)paren
)paren
r_return
suffix:semicolon
id|check_tty_count
c_func
(paren
id|tty
comma
l_string|&quot;release_dev&quot;
)paren
suffix:semicolon
id|tty_fasync
c_func
(paren
id|filp-&gt;f_inode
comma
id|filp
comma
l_int|0
)paren
suffix:semicolon
id|tp
op_assign
id|tty-&gt;termios
suffix:semicolon
id|ltp
op_assign
id|tty-&gt;termios_locked
suffix:semicolon
id|idx
op_assign
id|MINOR
c_func
(paren
id|tty-&gt;device
)paren
op_minus
id|tty-&gt;driver.minor_start
suffix:semicolon
macro_line|#ifdef TTY_PARANOIA_CHECK
r_if
c_cond
(paren
id|idx
OL
l_int|0
op_logical_or
id|idx
op_ge
id|tty-&gt;driver.num
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;release_dev: bad idx when trying to free (%s)&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty
op_ne
id|tty-&gt;driver.table
(braket
id|idx
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;release_dev: driver.table[%d] not tty for (%s)&bslash;n&quot;
comma
id|idx
comma
id|kdevname
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tp
op_ne
id|tty-&gt;driver.termios
(braket
id|idx
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;release_dev: driver.termios[%d] not termios for (&quot;
l_string|&quot;%s)&bslash;n&quot;
comma
id|idx
comma
id|kdevname
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ltp
op_ne
id|tty-&gt;driver.termios_locked
(braket
id|idx
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;release_dev: driver.termios_locked[%d] not termios_locked for (&quot;
l_string|&quot;%s)&bslash;n&quot;
comma
id|idx
comma
id|kdevname
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef TTY_DEBUG_HANGUP
id|printk
c_func
(paren
l_string|&quot;release_dev of %s (tty count=%d)...&quot;
comma
id|tty_name
c_func
(paren
id|tty
)paren
comma
id|tty-&gt;count
)paren
suffix:semicolon
macro_line|#endif
id|o_tty
op_assign
id|tty-&gt;link
suffix:semicolon
id|o_tp
op_assign
(paren
id|o_tty
)paren
ques
c_cond
id|o_tty-&gt;termios
suffix:colon
l_int|NULL
suffix:semicolon
id|o_ltp
op_assign
(paren
id|o_tty
)paren
ques
c_cond
id|o_tty-&gt;termios_locked
suffix:colon
l_int|NULL
suffix:semicolon
macro_line|#ifdef TTY_PARANOIA_CHECK
r_if
c_cond
(paren
id|tty-&gt;driver.other
)paren
(brace
r_if
c_cond
(paren
id|o_tty
op_ne
id|tty-&gt;driver.other-&gt;table
(braket
id|idx
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;release_dev: other-&gt;table[%d] not o_tty for (&quot;
l_string|&quot;%s)&bslash;n&quot;
comma
id|idx
comma
id|kdevname
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|o_tp
op_ne
id|tty-&gt;driver.other-&gt;termios
(braket
id|idx
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;release_dev: other-&gt;termios[%d] not o_termios for (&quot;
l_string|&quot;%s)&bslash;n&quot;
comma
id|idx
comma
id|kdevname
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|o_ltp
op_ne
id|tty-&gt;driver.other-&gt;termios_locked
(braket
id|idx
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;release_dev: other-&gt;termios_locked[%d] not o_termios_locked for (&quot;
l_string|&quot;%s)&bslash;n&quot;
comma
id|idx
comma
id|kdevname
c_func
(paren
id|tty-&gt;device
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|o_tty-&gt;link
op_ne
id|tty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;release_dev: bad pty pointers&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|tty-&gt;driver.close
)paren
id|tty-&gt;driver
dot
id|close
c_func
(paren
id|tty
comma
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.type
op_eq
id|TTY_DRIVER_TYPE_PTY
op_logical_and
id|tty-&gt;driver.subtype
op_eq
id|PTY_TYPE_MASTER
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|tty-&gt;link-&gt;count
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;release_dev: bad pty slave count (%d) for %s&bslash;n&quot;
comma
id|tty-&gt;count
comma
id|tty_name
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
id|tty-&gt;link-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_decrement
id|tty-&gt;count
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;release_dev: bad tty-&gt;count (%d) for %s&bslash;n&quot;
comma
id|tty-&gt;count
comma
id|tty_name
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
id|tty-&gt;count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;count
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * We&squot;re committed; at this point, we must not block!&n;&t; */
r_if
c_cond
(paren
id|o_tty
)paren
(brace
r_if
c_cond
(paren
id|o_tty-&gt;count
)paren
r_return
suffix:semicolon
id|tty-&gt;driver.other-&gt;table
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
id|tty-&gt;driver.other-&gt;termios
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree_s
c_func
(paren
id|o_tp
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef TTY_DEBUG_HANGUP
id|printk
c_func
(paren
l_string|&quot;freeing tty structure...&quot;
)paren
suffix:semicolon
macro_line|#endif
id|tty-&gt;flags
op_or_assign
(paren
l_int|1
op_lshift
id|TTY_CLOSING
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure there aren&squot;t any processes that still think this&n;&t; * tty is their controlling tty.&n;&t; */
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|LAST_TASK
suffix:semicolon
id|p
OG
op_amp
id|FIRST_TASK
suffix:semicolon
op_decrement
id|p
)paren
(brace
r_if
c_cond
(paren
op_star
id|p
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|tty
op_eq
id|tty
)paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|tty
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|o_tty
op_logical_and
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|tty
op_eq
id|o_tty
)paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|tty
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Shutdown the current line discipline, and reset it to&n;&t; * N_TTY.&n;&t; */
r_if
c_cond
(paren
id|tty-&gt;ldisc.close
)paren
(paren
id|tty-&gt;ldisc.close
)paren
(paren
id|tty
)paren
suffix:semicolon
id|tty-&gt;ldisc
op_assign
id|ldiscs
(braket
id|N_TTY
)braket
suffix:semicolon
id|tty-&gt;termios-&gt;c_line
op_assign
id|N_TTY
suffix:semicolon
r_if
c_cond
(paren
id|o_tty
)paren
(brace
r_if
c_cond
(paren
id|o_tty-&gt;ldisc.close
)paren
(paren
id|o_tty-&gt;ldisc.close
)paren
(paren
id|o_tty
)paren
suffix:semicolon
id|o_tty-&gt;ldisc
op_assign
id|ldiscs
(braket
id|N_TTY
)braket
suffix:semicolon
)brace
id|tty-&gt;driver.table
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flags
op_amp
id|TTY_DRIVER_RESET_TERMIOS
)paren
(brace
id|tty-&gt;driver.termios
(braket
id|idx
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree_s
c_func
(paren
id|tp
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty
op_eq
id|redirect
op_logical_or
id|o_tty
op_eq
id|redirect
)paren
id|redirect
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure that the tty&squot;s task queue isn&squot;t activated.  If it&n;&t; * is, take it out of the linked list.&n;&t; */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flip.tqueue.sync
)paren
(brace
r_struct
id|tq_struct
op_star
id|tq
comma
op_star
id|prev
suffix:semicolon
r_for
c_loop
(paren
id|tq
op_assign
id|tq_timer
comma
id|prev
op_assign
l_int|0
suffix:semicolon
id|tq
suffix:semicolon
id|prev
op_assign
id|tq
comma
id|tq
op_assign
id|tq-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|tq
op_eq
op_amp
id|tty-&gt;flip.tqueue
)paren
(brace
r_if
c_cond
(paren
id|prev
)paren
id|prev-&gt;next
op_assign
id|tq-&gt;next
suffix:semicolon
r_else
id|tq_timer
op_assign
id|tq-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|tty-&gt;magic
op_assign
l_int|0
suffix:semicolon
(paren
op_star
id|tty-&gt;driver.refcount
)paren
op_decrement
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|tty
)paren
suffix:semicolon
id|filp-&gt;private_data
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|o_tty
)paren
(brace
id|o_tty-&gt;magic
op_assign
l_int|0
suffix:semicolon
(paren
op_star
id|o_tty-&gt;driver.refcount
)paren
op_decrement
suffix:semicolon
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|o_tty
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * tty_open and tty_release keep up the tty count that contains the&n; * number of opens done on a tty. We cannot use the inode-count, as&n; * different inodes might point to the same tty.&n; *&n; * Open-counting is needed for pty masters, as well as for keeping&n; * track of serial lines: DTR is dropped when the last close happens.&n; * (This is not done solely through tty-&gt;count, now.  - Ted 1/27/92)&n; *&n; * The termios state of a pty is reset on first open so that&n; * settings don&squot;t persist across reuse.&n; */
DECL|function|tty_open
r_static
r_int
id|tty_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
id|minor
suffix:semicolon
r_int
id|noctty
comma
id|retval
suffix:semicolon
id|kdev_t
id|device
suffix:semicolon
id|retry_open
suffix:colon
id|noctty
op_assign
id|filp-&gt;f_flags
op_amp
id|O_NOCTTY
suffix:semicolon
id|device
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
r_if
c_cond
(paren
id|device
op_eq
id|TTY_DEV
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;tty
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|device
op_assign
id|current-&gt;tty-&gt;device
suffix:semicolon
multiline_comment|/* noctty = 1; */
)brace
r_if
c_cond
(paren
id|device
op_eq
id|CONSOLE_DEV
)paren
(brace
id|device
op_assign
id|MKDEV
c_func
(paren
id|TTY_MAJOR
comma
id|fg_console
op_plus
l_int|1
)paren
suffix:semicolon
id|noctty
op_assign
l_int|1
suffix:semicolon
)brace
id|minor
op_assign
id|MINOR
c_func
(paren
id|device
)paren
suffix:semicolon
id|retval
op_assign
id|init_dev
c_func
(paren
id|device
comma
op_amp
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|filp-&gt;private_data
op_assign
id|tty
suffix:semicolon
id|check_tty_count
c_func
(paren
id|tty
comma
l_string|&quot;tty_open&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.type
op_eq
id|TTY_DRIVER_TYPE_PTY
op_logical_and
id|tty-&gt;driver.subtype
op_eq
id|PTY_TYPE_MASTER
)paren
id|noctty
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef TTY_DEBUG_HANGUP
id|printk
c_func
(paren
l_string|&quot;opening %s...&quot;
comma
id|tty_name
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|tty-&gt;driver.open
)paren
id|retval
op_assign
id|tty-&gt;driver
dot
id|open
c_func
(paren
id|tty
comma
id|filp
)paren
suffix:semicolon
r_else
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
op_logical_and
id|test_bit
c_func
(paren
id|TTY_EXCLUSIVE
comma
op_amp
id|tty-&gt;flags
)paren
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
id|retval
op_assign
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
macro_line|#ifdef TTY_DEBUG_HANGUP
id|printk
c_func
(paren
l_string|&quot;error %d in opening %s...&quot;
comma
id|retval
comma
id|tty_name
c_func
(paren
id|tty
)paren
)paren
suffix:semicolon
macro_line|#endif
id|release_dev
c_func
(paren
id|filp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|ERESTARTSYS
)paren
r_return
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
id|retval
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Need to reset f_op in case a hangup happened.&n;&t;&t; */
id|filp-&gt;f_op
op_assign
op_amp
id|tty_fops
suffix:semicolon
r_goto
id|retry_open
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|noctty
op_logical_and
id|current-&gt;leader
op_logical_and
op_logical_neg
id|current-&gt;tty
op_logical_and
id|tty-&gt;session
op_eq
l_int|0
)paren
(brace
id|current-&gt;tty
op_assign
id|tty
suffix:semicolon
id|current-&gt;tty_old_pgrp
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;session
op_assign
id|current-&gt;session
suffix:semicolon
id|tty-&gt;pgrp
op_assign
id|current-&gt;pgrp
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Note that releasing a pty master also releases the child, so&n; * we have to make the redirection checks after that and on both&n; * sides of a pty.&n; */
DECL|function|tty_release
r_static
r_void
id|tty_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|release_dev
c_func
(paren
id|filp
)paren
suffix:semicolon
)brace
DECL|function|tty_select
r_static
r_int
id|tty_select
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|tty_paranoia_check
c_func
(paren
id|tty
comma
id|inode-&gt;i_rdev
comma
l_string|&quot;tty_select&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.select
)paren
r_return
(paren
id|tty-&gt;ldisc.select
)paren
(paren
id|tty
comma
id|inode
comma
id|filp
comma
id|sel_type
comma
id|wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * fasync_helper() is used by some character device drivers (mainly mice)&n; * to set up the fasync queue. It returns negative on error, 0 if it did&n; * no changes and positive if it added/deleted the entry.&n; */
DECL|function|fasync_helper
r_int
id|fasync_helper
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
comma
r_struct
id|fasync_struct
op_star
op_star
id|fapp
)paren
(brace
r_struct
id|fasync_struct
op_star
id|fa
comma
op_star
op_star
id|fp
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_for
c_loop
(paren
id|fp
op_assign
id|fapp
suffix:semicolon
(paren
id|fa
op_assign
op_star
id|fp
)paren
op_ne
l_int|NULL
suffix:semicolon
id|fp
op_assign
op_amp
id|fa-&gt;fa_next
)paren
(brace
r_if
c_cond
(paren
id|fa-&gt;fa_file
op_eq
id|filp
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|on
)paren
(brace
r_if
c_cond
(paren
id|fa
)paren
r_return
l_int|0
suffix:semicolon
id|fa
op_assign
(paren
r_struct
id|fasync_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|fasync_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fa
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|fa-&gt;magic
op_assign
id|FASYNC_MAGIC
suffix:semicolon
id|fa-&gt;fa_file
op_assign
id|filp
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|fa-&gt;fa_next
op_assign
op_star
id|fapp
suffix:semicolon
op_star
id|fapp
op_assign
id|fa
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|fa
)paren
r_return
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
op_star
id|fp
op_assign
id|fa-&gt;fa_next
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|fa
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|tty_fasync
r_static
r_int
id|tty_fasync
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
id|on
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|filp-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|tty_paranoia_check
c_func
(paren
id|tty
comma
id|inode-&gt;i_rdev
comma
l_string|&quot;tty_fasync&quot;
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|retval
op_assign
id|fasync_helper
c_func
(paren
id|inode
comma
id|filp
comma
id|on
comma
op_amp
id|tty-&gt;fasync
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_le
l_int|0
)paren
r_return
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|on
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;read_wait
)paren
id|tty-&gt;minimum_to_wake
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_owner
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;pgrp
)paren
id|filp-&gt;f_owner
op_assign
op_minus
id|tty-&gt;pgrp
suffix:semicolon
r_else
id|filp-&gt;f_owner
op_assign
id|current-&gt;pid
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|tty-&gt;fasync
op_logical_and
op_logical_neg
id|tty-&gt;read_wait
)paren
id|tty-&gt;minimum_to_wake
op_assign
id|N_TTY_BUF_SIZE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/*&n; * XXX does anyone use this anymore?!?&n; */
r_static
r_int
id|do_get_ps_info
c_func
(paren
r_int
r_int
id|arg
)paren
(brace
r_struct
id|tstruct
(brace
r_int
id|flag
suffix:semicolon
r_int
id|present
(braket
id|NR_TASKS
)braket
suffix:semicolon
r_struct
id|task_struct
id|tasks
(braket
id|NR_TASKS
)braket
suffix:semicolon
)brace
suffix:semicolon
r_struct
id|tstruct
op_star
id|ts
op_assign
(paren
r_struct
id|tstruct
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|task_struct
op_star
op_star
id|p
suffix:semicolon
r_char
op_star
id|c
comma
op_star
id|d
suffix:semicolon
r_int
id|i
comma
id|n
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|tstruct
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|FIRST_TASK
suffix:semicolon
id|p
op_le
op_amp
id|LAST_TASK
suffix:semicolon
id|p
op_increment
comma
id|n
op_increment
)paren
r_if
c_cond
(paren
op_star
id|p
)paren
(brace
id|c
op_assign
(paren
r_char
op_star
)paren
(paren
op_star
id|p
)paren
suffix:semicolon
id|d
op_assign
(paren
r_char
op_star
)paren
(paren
id|ts-&gt;tasks
op_plus
id|n
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
r_struct
id|task_struct
)paren
suffix:semicolon
id|i
op_increment
)paren
id|put_user
c_func
(paren
op_star
id|c
op_increment
comma
id|d
op_increment
)paren
suffix:semicolon
id|put_user
c_func
(paren
l_int|1
comma
id|ts-&gt;present
op_plus
id|n
)paren
suffix:semicolon
)brace
r_else
id|put_user
c_func
(paren
l_int|0
comma
id|ts-&gt;present
op_plus
id|n
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|tty_ioctl
r_static
r_int
id|tty_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|tty_struct
op_star
id|tty
suffix:semicolon
r_struct
id|tty_struct
op_star
id|real_tty
suffix:semicolon
r_struct
id|winsize
id|tmp_ws
suffix:semicolon
id|pid_t
id|pgrp
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_char
id|mbz
op_assign
l_int|0
suffix:semicolon
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|tty_paranoia_check
c_func
(paren
id|tty
comma
id|inode-&gt;i_rdev
comma
l_string|&quot;tty_ioctl&quot;
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.type
op_eq
id|TTY_DRIVER_TYPE_PTY
op_logical_and
id|tty-&gt;driver.subtype
op_eq
id|PTY_TYPE_MASTER
)paren
id|real_tty
op_assign
id|tty-&gt;link
suffix:semicolon
r_else
id|real_tty
op_assign
id|tty
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|TIOCSTI
suffix:colon
r_if
c_cond
(paren
(paren
id|current-&gt;tty
op_ne
id|tty
)paren
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|ch
op_assign
id|get_user
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
id|tty-&gt;ldisc
dot
id|receive_buf
c_func
(paren
id|tty
comma
op_amp
id|ch
comma
op_amp
id|mbz
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCGWINSZ
suffix:colon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|winsize
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_struct
id|winsize
op_star
)paren
id|arg
comma
op_amp
id|tty-&gt;winsize
comma
r_sizeof
(paren
r_struct
id|winsize
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCSWINSZ
suffix:colon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|winsize
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|tmp_ws
comma
(paren
r_struct
id|winsize
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|winsize
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
op_amp
id|tmp_ws
comma
op_amp
id|tty-&gt;winsize
comma
r_sizeof
(paren
r_struct
id|winsize
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|tty-&gt;pgrp
OG
l_int|0
)paren
id|kill_pg
c_func
(paren
id|tty-&gt;pgrp
comma
id|SIGWINCH
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|real_tty-&gt;pgrp
op_ne
id|tty-&gt;pgrp
)paren
op_logical_and
(paren
id|real_tty-&gt;pgrp
OG
l_int|0
)paren
)paren
id|kill_pg
c_func
(paren
id|real_tty-&gt;pgrp
comma
id|SIGWINCH
comma
l_int|1
)paren
suffix:semicolon
)brace
id|tty-&gt;winsize
op_assign
id|tmp_ws
suffix:semicolon
id|real_tty-&gt;winsize
op_assign
id|tmp_ws
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCCONS
suffix:colon
r_if
c_cond
(paren
id|tty-&gt;driver.type
op_eq
id|TTY_DRIVER_TYPE_CONSOLE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|redirect
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|redirect
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|redirect
op_assign
id|real_tty
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FIONBIO
suffix:colon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|arg
op_assign
id|get_user
c_func
(paren
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
id|file-&gt;f_flags
op_or_assign
id|O_NONBLOCK
suffix:semicolon
r_else
id|file-&gt;f_flags
op_and_assign
op_complement
id|O_NONBLOCK
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCEXCL
suffix:colon
id|set_bit
c_func
(paren
id|TTY_EXCLUSIVE
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCNXCL
suffix:colon
id|clear_bit
c_func
(paren
id|TTY_EXCLUSIVE
comma
op_amp
id|tty-&gt;flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCNOTTY
suffix:colon
r_if
c_cond
(paren
id|current-&gt;tty
op_ne
id|tty
)paren
r_return
op_minus
id|ENOTTY
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;leader
)paren
id|disassociate_ctty
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|current-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCSCTTY
suffix:colon
r_if
c_cond
(paren
id|current-&gt;leader
op_logical_and
(paren
id|current-&gt;session
op_eq
id|tty-&gt;session
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * The process must be a session leader and&n;&t;&t;&t; * not have a controlling tty already.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;leader
op_logical_or
id|current-&gt;tty
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;session
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * This tty is already the controlling&n;&t;&t;&t;&t; * tty for another session group!&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|arg
op_eq
l_int|1
)paren
op_logical_and
id|suser
c_func
(paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Steal it away&n;&t;&t;&t;&t;&t; */
r_struct
id|task_struct
op_star
id|p
suffix:semicolon
id|for_each_task
c_func
(paren
id|p
)paren
r_if
c_cond
(paren
id|p-&gt;tty
op_eq
id|tty
)paren
id|p-&gt;tty
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|current-&gt;tty
op_assign
id|tty
suffix:semicolon
id|current-&gt;tty_old_pgrp
op_assign
l_int|0
suffix:semicolon
id|tty-&gt;session
op_assign
id|current-&gt;session
suffix:semicolon
id|tty-&gt;pgrp
op_assign
id|current-&gt;pgrp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCGPGRP
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * (tty == real_tty) is a cheap way of&n;&t;&t;&t; * testing if the tty is NOT a master pty.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|tty
op_eq
id|real_tty
op_logical_and
id|current-&gt;tty
op_ne
id|real_tty
)paren
r_return
op_minus
id|ENOTTY
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|pid_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|put_user
c_func
(paren
id|real_tty-&gt;pgrp
comma
(paren
id|pid_t
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCSPGRP
suffix:colon
id|retval
op_assign
id|tty_check_change
c_func
(paren
id|real_tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;tty
op_logical_or
(paren
id|current-&gt;tty
op_ne
id|real_tty
)paren
op_logical_or
(paren
id|real_tty-&gt;session
op_ne
id|current-&gt;session
)paren
)paren
r_return
op_minus
id|ENOTTY
suffix:semicolon
id|pgrp
op_assign
id|get_user
c_func
(paren
(paren
id|pid_t
op_star
)paren
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pgrp
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|session_of_pgrp
c_func
(paren
id|pgrp
)paren
op_ne
id|current-&gt;session
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|real_tty-&gt;pgrp
op_assign
id|pgrp
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCGETD
suffix:colon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|put_user
c_func
(paren
id|tty-&gt;ldisc.num
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|TIOCSETD
suffix:colon
id|retval
op_assign
id|tty_check_change
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|arg
op_assign
id|get_user
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
id|tty_set_ldisc
c_func
(paren
id|tty
comma
id|arg
)paren
suffix:semicolon
r_case
id|TIOCLINUX
suffix:colon
r_if
c_cond
(paren
id|tty-&gt;driver.type
op_ne
id|TTY_DRIVER_TYPE_CONSOLE
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;tty
op_ne
id|tty
op_logical_and
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
r_switch
c_cond
(paren
id|retval
op_assign
id|get_user
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
l_int|8
suffix:colon
r_case
l_int|9
suffix:colon
id|printk
c_func
(paren
l_string|&quot;TIOCLINUX (0/8/9) ioctl is gone - use /dev/vcs&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#if 0
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Deprecated TIOCLINUX (1) ioctl&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|do_get_ps_info
c_func
(paren
id|arg
)paren
suffix:semicolon
macro_line|#endif
r_case
l_int|2
suffix:colon
r_return
id|set_selection
c_func
(paren
id|arg
comma
id|tty
)paren
suffix:semicolon
r_case
l_int|3
suffix:colon
r_return
id|paste_selection
c_func
(paren
id|tty
)paren
suffix:semicolon
r_case
l_int|4
suffix:colon
id|do_unblank_screen
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
l_int|5
suffix:colon
r_return
id|sel_loadlut
c_func
(paren
id|arg
)paren
suffix:semicolon
r_case
l_int|6
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Make it possible to react to Shift+Mousebutton.&n;&t;&t;&t; * Note that &squot;shift_state&squot; is an undocumented&n;&t;&t;&t; * kernel-internal variable; programs not closely&n;&t;&t;&t; * related to the kernel should not use this.&n;&t;&t;&t; */
id|put_user
c_func
(paren
id|shift_state
comma
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
l_int|7
suffix:colon
id|put_user
c_func
(paren
id|mouse_reporting
c_func
(paren
)paren
comma
(paren
r_char
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
l_int|10
suffix:colon
id|set_vesa_blanking
c_func
(paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_case
id|TIOCTTYGSTRUCT
suffix:colon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|tty_struct
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_struct
id|tty_struct
op_star
)paren
id|arg
comma
id|tty
comma
r_sizeof
(paren
r_struct
id|tty_struct
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|tty-&gt;driver.ioctl
)paren
(brace
id|retval
op_assign
(paren
id|tty-&gt;driver.ioctl
)paren
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|ENOIOCTLCMD
)paren
r_return
id|retval
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tty-&gt;ldisc.ioctl
)paren
(brace
id|retval
op_assign
(paren
id|tty-&gt;ldisc.ioctl
)paren
(paren
id|tty
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
op_minus
id|ENOIOCTLCMD
)paren
r_return
id|retval
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This implements the &quot;Secure Attention Key&quot; ---  the idea is to&n; * prevent trojan horses by killing all processes associated with this&n; * tty when the user hits the &quot;Secure Attention Key&quot;.  Required for&n; * super-paranoid applications --- see the Orange Book for more details.&n; * &n; * This code could be nicer; ideally it should send a HUP, wait a few&n; * seconds, then send a INT, and then a KILL signal.  But you then&n; * have to coordinate with the init process, since all processes associated&n; * with the current tty must be dead before the new getty is allowed&n; * to spawn.&n; */
DECL|function|do_SAK
r_void
id|do_SAK
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
macro_line|#ifdef TTY_SOFT_SAK
id|tty_hangup
c_func
(paren
id|tty
)paren
suffix:semicolon
macro_line|#else
r_struct
id|task_struct
op_star
op_star
id|p
suffix:semicolon
r_int
id|session
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|file
op_star
id|filp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tty
)paren
r_return
suffix:semicolon
id|session
op_assign
id|tty-&gt;session
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;ldisc.flush_buffer
)paren
id|tty-&gt;ldisc
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;driver.flush_buffer
)paren
id|tty-&gt;driver
dot
id|flush_buffer
c_func
(paren
id|tty
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
op_amp
id|LAST_TASK
suffix:semicolon
id|p
OG
op_amp
id|FIRST_TASK
suffix:semicolon
op_decrement
id|p
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|p
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|tty
op_eq
id|tty
)paren
op_logical_or
(paren
(paren
id|session
OG
l_int|0
)paren
op_logical_and
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|session
op_eq
id|session
)paren
)paren
)paren
id|send_sig
c_func
(paren
id|SIGKILL
comma
op_star
id|p
comma
l_int|1
)paren
suffix:semicolon
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_OPEN
suffix:semicolon
id|i
op_increment
)paren
(brace
id|filp
op_assign
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|files-&gt;fd
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|filp
op_logical_and
(paren
id|filp-&gt;f_op
op_eq
op_amp
id|tty_fops
)paren
op_logical_and
(paren
id|filp-&gt;private_data
op_eq
id|tty
)paren
)paren
(brace
id|send_sig
c_func
(paren
id|SIGKILL
comma
op_star
id|p
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * This routine is called out of the software interrupt to flush data&n; * from the flip buffer to the line discipline.&n; */
DECL|function|flush_to_ldisc
r_static
r_void
id|flush_to_ldisc
c_func
(paren
r_void
op_star
id|private_
)paren
(brace
r_struct
id|tty_struct
op_star
id|tty
op_assign
(paren
r_struct
id|tty_struct
op_star
)paren
id|private_
suffix:semicolon
r_int
r_char
op_star
id|cp
suffix:semicolon
r_char
op_star
id|fp
suffix:semicolon
r_int
id|count
suffix:semicolon
r_if
c_cond
(paren
id|tty-&gt;flip.buf_num
)paren
(brace
id|cp
op_assign
id|tty-&gt;flip.char_buf
op_plus
id|TTY_FLIPBUF_SIZE
suffix:semicolon
id|fp
op_assign
id|tty-&gt;flip.flag_buf
op_plus
id|TTY_FLIPBUF_SIZE
suffix:semicolon
id|tty-&gt;flip.buf_num
op_assign
l_int|0
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_assign
id|tty-&gt;flip.char_buf
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|tty-&gt;flip.flag_buf
suffix:semicolon
)brace
r_else
(brace
id|cp
op_assign
id|tty-&gt;flip.char_buf
suffix:semicolon
id|fp
op_assign
id|tty-&gt;flip.flag_buf
suffix:semicolon
id|tty-&gt;flip.buf_num
op_assign
l_int|1
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_assign
id|tty-&gt;flip.char_buf
op_plus
id|TTY_FLIPBUF_SIZE
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|tty-&gt;flip.flag_buf
op_plus
id|TTY_FLIPBUF_SIZE
suffix:semicolon
)brace
id|count
op_assign
id|tty-&gt;flip.count
suffix:semicolon
id|tty-&gt;flip.count
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|count
OG
id|tty-&gt;max_flip_cnt
)paren
id|tty-&gt;max_flip_cnt
op_assign
id|count
suffix:semicolon
macro_line|#endif
id|tty-&gt;ldisc
dot
id|receive_buf
c_func
(paren
id|tty
comma
id|cp
comma
id|fp
comma
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This subroutine initializes a tty structure.&n; */
DECL|function|initialize_tty_struct
r_static
r_void
id|initialize_tty_struct
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
)paren
(brace
id|memset
c_func
(paren
id|tty
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|tty_struct
)paren
)paren
suffix:semicolon
id|tty-&gt;magic
op_assign
id|TTY_MAGIC
suffix:semicolon
id|tty-&gt;ldisc
op_assign
id|ldiscs
(braket
id|N_TTY
)braket
suffix:semicolon
id|tty-&gt;pgrp
op_assign
op_minus
l_int|1
suffix:semicolon
id|tty-&gt;flip.char_buf_ptr
op_assign
id|tty-&gt;flip.char_buf
suffix:semicolon
id|tty-&gt;flip.flag_buf_ptr
op_assign
id|tty-&gt;flip.flag_buf
suffix:semicolon
id|tty-&gt;flip.tqueue.routine
op_assign
id|flush_to_ldisc
suffix:semicolon
id|tty-&gt;flip.tqueue.data
op_assign
id|tty
suffix:semicolon
)brace
multiline_comment|/*&n; * The default put_char routine if the driver did not define one.&n; */
DECL|function|tty_default_put_char
r_void
id|tty_default_put_char
c_func
(paren
r_struct
id|tty_struct
op_star
id|tty
comma
r_int
r_char
id|ch
)paren
(brace
id|tty-&gt;driver
dot
id|write
c_func
(paren
id|tty
comma
l_int|0
comma
op_amp
id|ch
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by a tty driver to register itself.&n; */
DECL|function|tty_register_driver
r_int
id|tty_register_driver
c_func
(paren
r_struct
id|tty_driver
op_star
id|driver
)paren
(brace
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;flags
op_amp
id|TTY_DRIVER_INSTALLED
)paren
r_return
l_int|0
suffix:semicolon
id|error
op_assign
id|register_chrdev
c_func
(paren
id|driver-&gt;major
comma
id|driver-&gt;name
comma
op_amp
id|tty_fops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
OL
l_int|0
)paren
r_return
id|error
suffix:semicolon
r_else
r_if
c_cond
(paren
id|driver-&gt;major
op_eq
l_int|0
)paren
(brace
id|driver-&gt;major
op_assign
id|error
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|driver-&gt;put_char
)paren
id|driver-&gt;put_char
op_assign
id|tty_default_put_char
suffix:semicolon
id|driver-&gt;prev
op_assign
l_int|0
suffix:semicolon
id|driver-&gt;next
op_assign
id|tty_drivers
suffix:semicolon
r_if
c_cond
(paren
id|tty_drivers
)paren
id|tty_drivers-&gt;prev
op_assign
id|driver
suffix:semicolon
id|tty_drivers
op_assign
id|driver
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/*&n; * Called by a tty driver to unregister itself.&n; */
DECL|function|tty_unregister_driver
r_int
id|tty_unregister_driver
c_func
(paren
r_struct
id|tty_driver
op_star
id|driver
)paren
(brace
r_int
id|retval
suffix:semicolon
r_struct
id|tty_driver
op_star
id|p
suffix:semicolon
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|othername
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_star
id|driver-&gt;refcount
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
id|tty_drivers
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p
op_eq
id|driver
)paren
id|found
op_increment
suffix:semicolon
r_else
r_if
c_cond
(paren
id|p-&gt;major
op_eq
id|driver-&gt;major
)paren
id|othername
op_assign
id|p-&gt;name
suffix:semicolon
)brace
r_if
c_cond
(paren
id|othername
op_eq
l_int|NULL
)paren
(brace
id|retval
op_assign
id|unregister_chrdev
c_func
(paren
id|driver-&gt;major
comma
id|driver-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
id|retval
suffix:semicolon
)brace
r_else
id|register_chrdev
c_func
(paren
id|driver-&gt;major
comma
id|othername
comma
op_amp
id|tty_fops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;prev
)paren
id|driver-&gt;prev-&gt;next
op_assign
id|driver-&gt;next
suffix:semicolon
r_else
id|tty_drivers
op_assign
id|driver-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|driver-&gt;next
)paren
id|driver-&gt;next-&gt;prev
op_assign
id|driver-&gt;prev
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Initialize the console device. This is called *early*, so&n; * we can&squot;t necessarily depend on lots of kernel help here.&n; * Just do some early initializations, and do the complex setup&n; * later.&n; */
DECL|function|console_init
r_int
id|console_init
c_func
(paren
r_int
id|kmem_start
comma
r_int
id|kmem_end
)paren
(brace
multiline_comment|/* Setup the default TTY line discipline. */
id|memset
c_func
(paren
id|ldiscs
comma
l_int|0
comma
r_sizeof
(paren
id|ldiscs
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|tty_register_ldisc
c_func
(paren
id|N_TTY
comma
op_amp
id|tty_ldisc_N_TTY
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Set up the standard termios.  Individual tty drivers may &n;&t; * deviate from this; this is used as a template.&n;&t; */
id|memset
c_func
(paren
op_amp
id|tty_std_termios
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|termios
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|tty_std_termios.c_cc
comma
id|INIT_C_CC
comma
id|NCCS
)paren
suffix:semicolon
id|tty_std_termios.c_iflag
op_assign
id|ICRNL
op_or
id|IXON
suffix:semicolon
id|tty_std_termios.c_oflag
op_assign
id|OPOST
op_or
id|ONLCR
suffix:semicolon
id|tty_std_termios.c_cflag
op_assign
id|B38400
op_or
id|CS8
op_or
id|CREAD
suffix:semicolon
id|tty_std_termios.c_lflag
op_assign
id|ISIG
op_or
id|ICANON
op_or
id|ECHO
op_or
id|ECHOE
op_or
id|ECHOK
op_or
id|ECHOCTL
op_or
id|ECHOKE
op_or
id|IEXTEN
suffix:semicolon
multiline_comment|/*&n;&t; * set up the console device so that later boot sequences can &n;&t; * inform about problems etc..&n;&t; */
r_return
id|con_init
c_func
(paren
id|kmem_start
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Ok, now we can initialize the rest of the tty devices and can count&n; * on memory allocations, interrupts etc..&n; */
DECL|function|tty_init
r_int
id|tty_init
c_func
(paren
r_int
id|kmem_start
)paren
(brace
r_if
c_cond
(paren
r_sizeof
(paren
r_struct
id|tty_struct
)paren
OG
id|PAGE_SIZE
)paren
id|panic
c_func
(paren
l_string|&quot;size of tty structure &gt; PAGE_SIZE!&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_chrdev
c_func
(paren
id|TTY_MAJOR
comma
l_string|&quot;tty&quot;
comma
op_amp
id|tty_fops
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;unable to get major %d for tty device&quot;
comma
id|TTY_MAJOR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_chrdev
c_func
(paren
id|TTYAUX_MAJOR
comma
l_string|&quot;cua&quot;
comma
op_amp
id|tty_fops
)paren
)paren
id|panic
c_func
(paren
l_string|&quot;unable to get major %d for tty device&quot;
comma
id|TTYAUX_MAJOR
)paren
suffix:semicolon
id|kmem_start
op_assign
id|kbd_init
c_func
(paren
id|kmem_start
)paren
suffix:semicolon
id|kmem_start
op_assign
id|rs_init
c_func
(paren
id|kmem_start
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SCC
id|kmem_start
op_assign
id|scc_init
c_func
(paren
id|kmem_start
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_CYCLADES
id|kmem_start
op_assign
id|cy_init
c_func
(paren
id|kmem_start
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_STALLION
id|kmem_start
op_assign
id|stl_init
c_func
(paren
id|kmem_start
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ISTALLION
id|kmem_start
op_assign
id|stli_init
c_func
(paren
id|kmem_start
)paren
suffix:semicolon
macro_line|#endif
id|kmem_start
op_assign
id|pty_init
c_func
(paren
id|kmem_start
)paren
suffix:semicolon
id|kmem_start
op_assign
id|vcs_init
c_func
(paren
id|kmem_start
)paren
suffix:semicolon
r_return
id|kmem_start
suffix:semicolon
)brace
eof
