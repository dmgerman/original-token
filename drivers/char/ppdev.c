multiline_comment|/*&n; * linux/drivers/char/ppdev.c&n; *&n; * This is the code behind /dev/parport* -- it allows a user-space&n; * application to use the parport subsystem.&n; *&n; * Copyright (C) 1998-9 Tim Waugh &lt;tim@cyberelk.demon.co.uk&gt;&n; *&n; * This program is free software; you can redistribute it and/or&n; * modify it under the terms of the GNU General Public License&n; * as published by the Free Software Foundation; either version&n; * 2 of the License, or (at your option) any later version.&n; *&n; * A /dev/parportxy device node represents an arbitrary device (&squot;y&squot;)&n; * on port &squot;x&squot;.  The following operations are possible:&n; *&n; * open&t;&t;do nothing, set up default IEEE 1284 protocol to be COMPAT&n; * close&t;release port and unregister device (if necessary)&n; * ioctl&n; *   EXCL&t;register device exclusively (may fail)&n; *   CLAIM&t;(register device first time) parport_claim_or_block&n; *   RELEASE&t;parport_release&n; *   SETMODE&t;set the IEEE 1284 protocol to use for read/write&n; *   DATADIR&t;data_forward / data_reverse&n; *   WDATA&t;write_data&n; *   RDATA&t;read_data&n; *   WCONTROL&t;write_control&n; *   RCONTROL&t;read_control&n; *   FCONTROL&t;frob_control&n; *   RSTATUS&t;read_status&n; *   NEGOT&t;parport_negotiate&n; *   YIELD&t;parport_yield_blocking&n; * read/write&t;read or write in current IEEE 1284 protocol&n; * select&t;wait for interrupt (in readfds)&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/parport.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &quot;ppdev.h&quot;
DECL|macro|PP_VERSION
mdefine_line|#define PP_VERSION &quot;ppdev: user-space parallel port driver&quot;
DECL|macro|CHRDEV
mdefine_line|#define CHRDEV &quot;ppdev&quot;
macro_line|#ifndef min
DECL|macro|min
mdefine_line|#define min(a,b) ((a) &lt; (b) ? (a) : (b))
macro_line|#endif
DECL|struct|pp_struct
r_struct
id|pp_struct
(brace
DECL|member|pdev
r_struct
id|pardevice
op_star
id|pdev
suffix:semicolon
DECL|member|irq_wait
id|wait_queue_head_t
id|irq_wait
suffix:semicolon
DECL|member|got_irq
r_int
id|got_irq
suffix:semicolon
DECL|member|mode
r_int
id|mode
suffix:semicolon
DECL|member|flags
r_int
r_int
id|flags
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* pp_struct.flags bitfields */
DECL|macro|PP_CLAIMED
mdefine_line|#define PP_CLAIMED    (1&lt;&lt;0)
DECL|macro|PP_EXCL
mdefine_line|#define PP_EXCL       (1&lt;&lt;1)
multiline_comment|/* Other constants */
DECL|macro|PP_INTERRUPT_TIMEOUT
mdefine_line|#define PP_INTERRUPT_TIMEOUT (10 * HZ) /* 10s */
DECL|macro|PP_BUFFER_SIZE
mdefine_line|#define PP_BUFFER_SIZE 256
DECL|macro|PARDEVICE_MAX
mdefine_line|#define PARDEVICE_MAX 8
DECL|function|enable_irq
r_static
r_inline
r_void
id|enable_irq
(paren
r_struct
id|pp_struct
op_star
id|pp
)paren
(brace
r_struct
id|parport
op_star
id|port
op_assign
id|pp-&gt;pdev-&gt;port
suffix:semicolon
id|port-&gt;ops-&gt;enable_irq
(paren
id|port
)paren
suffix:semicolon
)brace
DECL|function|pp_lseek
r_static
id|loff_t
id|pp_lseek
(paren
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|offset
comma
r_int
id|origin
)paren
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
multiline_comment|/* This looks a bit like parport_read.  The difference is that we don&squot;t&n; * determine the mode to use from the port data, but rather from the&n; * mode the driver told us to use. */
DECL|function|do_read
r_static
id|ssize_t
id|do_read
(paren
r_struct
id|pp_struct
op_star
id|pp
comma
r_void
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|parport
op_star
comma
r_void
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_struct
id|parport
op_star
id|port
op_assign
id|pp-&gt;pdev-&gt;port
suffix:semicolon
r_int
id|addr
op_assign
id|pp-&gt;mode
op_amp
id|IEEE1284_ADDR
suffix:semicolon
r_int
id|mode
op_assign
id|pp-&gt;mode
op_amp
op_complement
(paren
id|IEEE1284_DEVICEID
op_or
id|IEEE1284_ADDR
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|IEEE1284_MODE_COMPAT
suffix:colon
multiline_comment|/* This is a write-only mode. */
r_return
op_minus
id|EIO
suffix:semicolon
r_case
id|IEEE1284_MODE_NIBBLE
suffix:colon
id|fn
op_assign
id|port-&gt;ops-&gt;nibble_read_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_BYTE
suffix:colon
id|fn
op_assign
id|port-&gt;ops-&gt;byte_read_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_EPP
suffix:colon
r_if
c_cond
(paren
id|addr
)paren
id|fn
op_assign
id|port-&gt;ops-&gt;epp_read_addr
suffix:semicolon
r_else
id|fn
op_assign
id|port-&gt;ops-&gt;epp_read_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_ECP
suffix:colon
r_case
id|IEEE1284_MODE_ECPRLE
suffix:colon
id|fn
op_assign
id|port-&gt;ops-&gt;ecp_read_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_ECPSWE
suffix:colon
id|fn
op_assign
id|parport_ieee1284_ecp_read_data
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: unknown mode 0x%02x&bslash;n&quot;
comma
id|pp-&gt;pdev-&gt;name
comma
id|pp-&gt;mode
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
(paren
op_star
id|fn
)paren
(paren
id|port
comma
id|buf
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* This looks a bit like parport_write.  The difference is that we don&squot;t&n; * determine the mode to use from the port data, but rather from the&n; * mode the driver told us to use. */
DECL|function|do_write
r_static
id|ssize_t
id|do_write
(paren
r_struct
id|pp_struct
op_star
id|pp
comma
r_const
r_void
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
(paren
op_star
id|fn
)paren
(paren
r_struct
id|parport
op_star
comma
r_const
r_void
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
r_struct
id|parport
op_star
id|port
op_assign
id|pp-&gt;pdev-&gt;port
suffix:semicolon
r_int
id|addr
op_assign
id|pp-&gt;mode
op_amp
id|IEEE1284_ADDR
suffix:semicolon
r_int
id|mode
op_assign
id|pp-&gt;mode
op_amp
op_complement
(paren
id|IEEE1284_DEVICEID
op_or
id|IEEE1284_ADDR
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|IEEE1284_MODE_NIBBLE
suffix:colon
r_case
id|IEEE1284_MODE_BYTE
suffix:colon
multiline_comment|/* Read-only modes. */
r_return
op_minus
id|EIO
suffix:semicolon
r_case
id|IEEE1284_MODE_COMPAT
suffix:colon
id|fn
op_assign
id|port-&gt;ops-&gt;compat_write_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_EPP
suffix:colon
r_if
c_cond
(paren
id|addr
)paren
id|fn
op_assign
id|port-&gt;ops-&gt;epp_write_addr
suffix:semicolon
r_else
id|fn
op_assign
id|port-&gt;ops-&gt;epp_write_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_ECP
suffix:colon
r_case
id|IEEE1284_MODE_ECPRLE
suffix:colon
r_if
c_cond
(paren
id|addr
)paren
id|fn
op_assign
id|port-&gt;ops-&gt;ecp_write_addr
suffix:semicolon
r_else
id|fn
op_assign
id|port-&gt;ops-&gt;ecp_write_data
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IEEE1284_MODE_ECPSWE
suffix:colon
r_if
c_cond
(paren
id|addr
)paren
id|fn
op_assign
id|parport_ieee1284_ecp_write_addr
suffix:semicolon
r_else
id|fn
op_assign
id|parport_ieee1284_ecp_write_data
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: unknown mode 0x%02x&bslash;n&quot;
comma
id|pp-&gt;pdev-&gt;name
comma
id|pp-&gt;mode
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
(paren
op_star
id|fn
)paren
(paren
id|port
comma
id|buf
comma
id|len
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|pp_read
r_static
id|ssize_t
id|pp_read
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|pp_struct
op_star
id|pp
op_assign
id|file-&gt;private_data
suffix:semicolon
r_char
op_star
id|kbuffer
suffix:semicolon
id|ssize_t
id|bytes_read
op_assign
l_int|0
suffix:semicolon
id|ssize_t
id|got
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pp-&gt;flags
op_amp
id|PP_CLAIMED
)paren
)paren
(brace
multiline_comment|/* Don&squot;t have the port claimed */
id|printk
(paren
id|KERN_DEBUG
id|CHRDEV
l_string|&quot;%x: claim the port first&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|kbuffer
op_assign
id|kmalloc
(paren
id|min
(paren
id|count
comma
id|PP_BUFFER_SIZE
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kbuffer
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_while
c_loop
(paren
id|bytes_read
OL
id|count
)paren
(brace
id|ssize_t
id|need
op_assign
id|min
c_func
(paren
id|count
op_minus
id|bytes_read
comma
id|PP_BUFFER_SIZE
)paren
suffix:semicolon
id|got
op_assign
id|do_read
(paren
id|pp
comma
id|kbuffer
comma
id|need
)paren
suffix:semicolon
r_if
c_cond
(paren
id|got
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bytes_read
)paren
id|bytes_read
op_assign
id|got
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
(paren
id|buf
op_plus
id|bytes_read
comma
id|kbuffer
comma
id|got
)paren
)paren
(brace
id|bytes_read
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bytes_read
op_add_assign
id|got
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bytes_read
)paren
id|bytes_read
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current-&gt;need_resched
)paren
id|schedule
(paren
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|kbuffer
)paren
suffix:semicolon
id|enable_irq
(paren
id|pp
)paren
suffix:semicolon
r_return
id|bytes_read
suffix:semicolon
)brace
DECL|function|pp_write
r_static
id|ssize_t
id|pp_write
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
(paren
id|file-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|pp_struct
op_star
id|pp
op_assign
id|file-&gt;private_data
suffix:semicolon
r_char
op_star
id|kbuffer
suffix:semicolon
id|ssize_t
id|bytes_written
op_assign
l_int|0
suffix:semicolon
id|ssize_t
id|wrote
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pp-&gt;flags
op_amp
id|PP_CLAIMED
)paren
)paren
(brace
multiline_comment|/* Don&squot;t have the port claimed */
id|printk
(paren
id|KERN_DEBUG
id|CHRDEV
l_string|&quot;%x: claim the port first&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|kbuffer
op_assign
id|kmalloc
(paren
id|min
(paren
id|count
comma
id|PP_BUFFER_SIZE
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|kbuffer
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_while
c_loop
(paren
id|bytes_written
OL
id|count
)paren
(brace
id|ssize_t
id|n
op_assign
id|min
c_func
(paren
id|count
op_minus
id|bytes_written
comma
id|PP_BUFFER_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
id|kbuffer
comma
id|buf
op_plus
id|bytes_written
comma
id|n
)paren
)paren
(brace
id|bytes_written
op_assign
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
id|wrote
op_assign
id|do_write
(paren
id|pp
comma
id|kbuffer
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wrote
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bytes_written
)paren
id|bytes_written
op_assign
id|wrote
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bytes_written
op_add_assign
id|wrote
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
(paren
id|current
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|bytes_written
)paren
id|bytes_written
op_assign
op_minus
id|EINTR
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current-&gt;need_resched
)paren
id|schedule
(paren
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|kbuffer
)paren
suffix:semicolon
id|enable_irq
(paren
id|pp
)paren
suffix:semicolon
r_return
id|bytes_written
suffix:semicolon
)brace
DECL|function|pp_irq
r_static
r_void
id|pp_irq
(paren
r_int
id|irq
comma
r_void
op_star
r_private
comma
r_struct
id|pt_regs
op_star
id|unused
)paren
(brace
r_struct
id|pp_struct
op_star
id|pp
op_assign
(paren
r_struct
id|pp_struct
op_star
)paren
r_private
suffix:semicolon
id|pp-&gt;got_irq
op_assign
l_int|1
suffix:semicolon
id|wake_up_interruptible
(paren
op_amp
id|pp-&gt;irq_wait
)paren
suffix:semicolon
)brace
DECL|function|register_device
r_static
r_int
id|register_device
(paren
r_int
id|minor
comma
r_struct
id|pp_struct
op_star
id|pp
)paren
(brace
r_struct
id|parport
op_star
id|port
suffix:semicolon
r_struct
id|pardevice
op_star
id|pdev
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
r_int
id|fl
suffix:semicolon
id|name
op_assign
id|kmalloc
(paren
id|strlen
(paren
id|CHRDEV
)paren
op_plus
l_int|3
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|name
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|sprintf
(paren
id|name
comma
id|CHRDEV
l_string|&quot;%x&quot;
comma
id|minor
)paren
suffix:semicolon
id|port
op_assign
id|parport_enumerate
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: use attach/detach */
r_while
c_loop
(paren
id|port
op_logical_and
id|port-&gt;number
op_ne
id|minor
)paren
id|port
op_assign
id|port-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|port
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: no associated port!&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|kfree
(paren
id|name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|fl
op_assign
(paren
id|pp-&gt;flags
op_amp
id|PP_EXCL
)paren
ques
c_cond
id|PARPORT_FLAG_EXCL
suffix:colon
l_int|0
suffix:semicolon
id|pdev
op_assign
id|parport_register_device
(paren
id|port
comma
id|name
comma
l_int|NULL
comma
l_int|NULL
comma
id|pp_irq
comma
id|fl
comma
id|pp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pdev
)paren
(brace
id|printk
(paren
id|KERN_WARNING
l_string|&quot;%s: failed to register device!&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|kfree
(paren
id|name
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|pp-&gt;pdev
op_assign
id|pdev
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
l_string|&quot;%s: registered pardevice&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pp_ioctl
r_static
r_int
id|pp_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|pp_struct
op_star
id|pp
op_assign
id|file-&gt;private_data
suffix:semicolon
r_struct
id|parport
op_star
id|port
suffix:semicolon
multiline_comment|/* First handle the cases that don&squot;t take arguments. */
r_if
c_cond
(paren
id|cmd
op_eq
id|PPCLAIM
)paren
(brace
r_if
c_cond
(paren
id|pp-&gt;flags
op_amp
id|PP_CLAIMED
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
id|CHRDEV
l_string|&quot;%x: you&squot;ve already got it!&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Deferred device registration. */
r_if
c_cond
(paren
op_logical_neg
id|pp-&gt;pdev
)paren
(brace
r_int
id|err
op_assign
id|register_device
(paren
id|minor
comma
id|pp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
)brace
id|parport_claim_or_block
(paren
id|pp-&gt;pdev
)paren
suffix:semicolon
id|pp-&gt;flags
op_or_assign
id|PP_CLAIMED
suffix:semicolon
multiline_comment|/* For interrupt-reporting to work, we need to be&n;&t;&t; * informed of each interrupt. */
id|enable_irq
(paren
id|pp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|PPEXCL
)paren
(brace
r_if
c_cond
(paren
id|pp-&gt;pdev
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
id|CHRDEV
l_string|&quot;%x: too late for PPEXCL; &quot;
l_string|&quot;already registered&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;flags
op_amp
id|PP_EXCL
)paren
multiline_comment|/* But it&squot;s not really an error. */
r_return
l_int|0
suffix:semicolon
multiline_comment|/* There&squot;s no chance of making the driver happy. */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Just remember to register the device exclusively&n;&t;&t; * when we finally do the registration. */
id|pp-&gt;flags
op_or_assign
id|PP_EXCL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|PPSETMODE
)paren
(brace
r_int
id|mode
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|mode
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|mode
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* FIXME: validate mode */
id|pp-&gt;mode
op_assign
id|mode
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Everything else requires the port to be claimed, so check&n;&t; * that now. */
r_if
c_cond
(paren
(paren
id|pp-&gt;flags
op_amp
id|PP_CLAIMED
)paren
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_DEBUG
id|CHRDEV
l_string|&quot;%x: claim the port first&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|port
op_assign
id|pp-&gt;pdev-&gt;port
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_int
r_char
id|reg
suffix:semicolon
r_int
r_char
id|mask
suffix:semicolon
r_int
id|mode
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_case
id|PPRSTATUS
suffix:colon
id|reg
op_assign
id|parport_read_status
(paren
id|port
)paren
suffix:semicolon
r_return
id|copy_to_user
(paren
(paren
r_int
r_char
op_star
)paren
id|arg
comma
op_amp
id|reg
comma
r_sizeof
(paren
id|reg
)paren
)paren
suffix:semicolon
r_case
id|PPRDATA
suffix:colon
id|reg
op_assign
id|parport_read_data
(paren
id|port
)paren
suffix:semicolon
r_return
id|copy_to_user
(paren
(paren
r_int
r_char
op_star
)paren
id|arg
comma
op_amp
id|reg
comma
r_sizeof
(paren
id|reg
)paren
)paren
suffix:semicolon
r_case
id|PPRCONTROL
suffix:colon
id|reg
op_assign
id|parport_read_control
(paren
id|port
)paren
suffix:semicolon
r_return
id|copy_to_user
(paren
(paren
r_int
r_char
op_star
)paren
id|arg
comma
op_amp
id|reg
comma
r_sizeof
(paren
id|reg
)paren
)paren
suffix:semicolon
r_case
id|PPYIELD
suffix:colon
id|parport_yield_blocking
(paren
id|pp-&gt;pdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|PPRELEASE
suffix:colon
id|parport_release
(paren
id|pp-&gt;pdev
)paren
suffix:semicolon
id|pp-&gt;flags
op_and_assign
op_complement
id|PP_CLAIMED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|PPWCONTROL
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|reg
comma
(paren
r_int
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|reg
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|parport_write_control
(paren
id|port
comma
id|reg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|PPWDATA
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|reg
comma
(paren
r_int
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|reg
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|parport_write_data
(paren
id|port
comma
id|reg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|PPFCONTROL
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|mask
comma
(paren
r_int
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|mask
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|reg
comma
l_int|1
op_plus
(paren
r_int
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|reg
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|parport_frob_control
(paren
id|port
comma
id|mask
comma
id|reg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|PPDATADIR
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|mode
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|mode
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|mode
)paren
id|port-&gt;ops-&gt;data_reverse
(paren
id|port
)paren
suffix:semicolon
r_else
id|port-&gt;ops-&gt;data_forward
(paren
id|port
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|PPNEGOT
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
(paren
op_amp
id|mode
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|mode
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* FIXME: validate mode */
id|ret
op_assign
id|parport_negotiate
(paren
id|port
comma
id|mode
)paren
suffix:semicolon
id|enable_irq
(paren
id|pp
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
id|KERN_DEBUG
id|CHRDEV
l_string|&quot;%x: What? (cmd=0x%x)&bslash;n&quot;
comma
id|minor
comma
id|cmd
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Keep the compiler happy */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pp_open
r_static
r_int
id|pp_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|pp_struct
op_star
id|pp
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|PARPORT_MAX
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|pp
op_assign
id|kmalloc
(paren
id|GFP_KERNEL
comma
r_sizeof
(paren
r_struct
id|pp_struct
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pp
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|pp-&gt;mode
op_assign
id|IEEE1284_MODE_COMPAT
suffix:semicolon
id|pp-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|pp-&gt;got_irq
op_assign
l_int|0
suffix:semicolon
id|init_waitqueue_head
(paren
op_amp
id|pp-&gt;irq_wait
)paren
suffix:semicolon
multiline_comment|/* Defer the actual device registration until the first claim.&n;&t; * That way, we know whether or not the driver wants to have&n;&t; * exclusive access to the port (PPEXCL).&n;&t; */
id|pp-&gt;pdev
op_assign
l_int|NULL
suffix:semicolon
id|file-&gt;private_data
op_assign
id|pp
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pp_release
r_static
r_int
id|pp_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|minor
op_assign
id|MINOR
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|pp_struct
op_star
id|pp
op_assign
id|file-&gt;private_data
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;flags
op_amp
id|PP_CLAIMED
)paren
(brace
id|parport_release
(paren
id|pp-&gt;pdev
)paren
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
id|CHRDEV
l_string|&quot;%x: released pardevice because &quot;
l_string|&quot;user-space forgot&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pp-&gt;pdev
)paren
(brace
id|kfree
(paren
id|pp-&gt;pdev-&gt;name
)paren
suffix:semicolon
id|parport_unregister_device
(paren
id|pp-&gt;pdev
)paren
suffix:semicolon
id|pp-&gt;pdev
op_assign
l_int|NULL
suffix:semicolon
id|printk
(paren
id|KERN_DEBUG
id|CHRDEV
l_string|&quot;%x: unregistered pardevice&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|pp
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pp_poll
r_static
r_int
r_int
id|pp_poll
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_struct
id|pp_struct
op_star
id|pp
op_assign
id|file-&gt;private_data
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pp-&gt;got_irq
)paren
(brace
id|pp-&gt;got_irq
op_assign
l_int|0
suffix:semicolon
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
id|poll_wait
(paren
id|file
comma
op_amp
id|pp-&gt;irq_wait
comma
id|wait
)paren
suffix:semicolon
r_return
id|mask
suffix:semicolon
)brace
DECL|variable|pp_fops
r_static
r_struct
id|file_operations
id|pp_fops
op_assign
(brace
id|pp_lseek
comma
id|pp_read
comma
id|pp_write
comma
l_int|NULL
comma
multiline_comment|/* pp_readdir */
id|pp_poll
comma
id|pp_ioctl
comma
l_int|NULL
comma
multiline_comment|/* pp_mmap */
id|pp_open
comma
l_int|NULL
comma
multiline_comment|/* pp_flush */
id|pp_release
)brace
suffix:semicolon
macro_line|#ifdef MODULE
DECL|macro|pp_init
mdefine_line|#define pp_init init_module
macro_line|#endif
DECL|function|pp_init
r_int
id|pp_init
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|register_chrdev
(paren
id|PP_MAJOR
comma
id|CHRDEV
comma
op_amp
id|pp_fops
)paren
)paren
(brace
id|printk
(paren
id|KERN_WARNING
id|CHRDEV
l_string|&quot;: unable to get major %d&bslash;n&quot;
comma
id|PP_MAJOR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
(paren
id|KERN_INFO
id|PP_VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|cleanup_module
r_void
id|cleanup_module
(paren
r_void
)paren
(brace
multiline_comment|/* Clean up all parport stuff */
id|unregister_chrdev
(paren
id|PP_MAJOR
comma
id|CHRDEV
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
eof
