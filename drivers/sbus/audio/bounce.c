multiline_comment|/*&n; * drivers/sbus/audio/bounce.c&n; *&n; * Copyright (C) 1996 Thomas K. Dyas (tdyas@noc.rutgers.edu)&n; *&n; * Simple bounce buffer allocator used for allocating pages for use in&n; * DMA and pseudo-DMA (byte-by-byte using an interrupt)&n; * applications. For safety, we do most operations in bottom half so&n; * we have some guarnatee of atomicity. System calls can do&n; * &quot;start_bh_atomic&quot; to get some atomicity.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &quot;bounce.h&quot;
DECL|variable|pages
r_static
r_struct
id|bounce_page
op_star
id|pages
(braket
id|NR_BOUNCE_PAGES
)braket
suffix:semicolon
DECL|variable|free_list_head
DECL|variable|free_list_tail
r_static
r_struct
id|bounce_page
op_star
id|free_list_head
comma
op_star
id|free_list_tail
suffix:semicolon
multiline_comment|/* Add a bounce page to the free list. */
DECL|function|add_bounce_page
r_static
r_void
id|add_bounce_page
c_func
(paren
r_struct
id|bounce_page
op_star
id|page
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG_BOUNCE
r_if
c_cond
(paren
id|page-&gt;next
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;add_bounce_page: page already on list from %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Case #1: Nothing on the list. */
r_if
c_cond
(paren
op_logical_neg
id|free_list_tail
)paren
(brace
macro_line|#ifdef DEBUG_BOUNCE
r_if
c_cond
(paren
id|free_list_head
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;add_bounce_page: inconsistent free list from %p&bslash;n&quot;
comma
id|__builtin_return_address
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|free_list_head
op_assign
id|free_list_tail
op_assign
id|page
suffix:semicolon
)brace
r_else
(brace
id|free_list_tail-&gt;next
op_assign
id|page
suffix:semicolon
id|page-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|free_list_tail
op_assign
id|page
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Remove a bounce page from the free list. */
DECL|function|next_bounce_page
r_static
r_struct
id|bounce_page
op_star
id|next_bounce_page
c_func
(paren
r_void
)paren
(brace
r_struct
id|bounce_page
op_star
id|p
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If the free list is empty, return empty handed. */
r_if
c_cond
(paren
op_logical_neg
id|free_list_head
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Remove the next available bounce page from the free list. */
id|p
op_assign
id|free_list_head
suffix:semicolon
multiline_comment|/* Update the free list pointers. */
id|free_list_head
op_assign
id|free_list_head-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|free_list_head
)paren
id|free_list_tail
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Return the page that we found. */
id|p-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/* Allocate the bounce buffers and the page lists. */
DECL|function|bounce_init
r_int
id|bounce_init
c_func
(paren
r_void
)paren
(brace
r_register
r_int
id|i
suffix:semicolon
multiline_comment|/* Allocate space for all of the bounce pages. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_BOUNCE_PAGES
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pages
(braket
id|i
)braket
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pages
(braket
id|i
)braket
)paren
(brace
r_register
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|i
suffix:semicolon
id|j
op_increment
)paren
id|free_page
c_func
(paren
id|pages
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
multiline_comment|/* Place all of the pages onto the free list. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_BOUNCE_PAGES
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|pages
(braket
id|i
)braket
op_member_access_from_pointer
id|next
op_assign
id|pages
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
id|pages
(braket
id|NR_BOUNCE_BUFFERS
op_minus
l_int|1
)braket
op_member_access_from_pointer
id|next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Setup pointers to the free list head and tail. */
id|free_list_head
op_assign
id|pages
(braket
l_int|0
)braket
suffix:semicolon
id|free_list_tail
op_assign
id|pages
(braket
id|NR_BOUNCE_BUFFERS
op_minus
l_int|1
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Allocate a bounce buffer to a process. */
DECL|function|get_bounce_page
r_struct
id|bounce_page
op_star
id|get_bounce_page
c_func
(paren
r_int
id|timeout
)paren
(brace
r_struct
id|bounce_page
op_star
id|p
suffix:semicolon
r_int
id|tries
suffix:semicolon
r_do
(brace
multiline_comment|/* Do not allow interrupts to muck with the lists. */
id|start_bh_atomic
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Check to see if a bounce page is available. */
id|p
op_assign
id|next_bounce_page
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
)paren
(brace
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
r_return
id|p
suffix:semicolon
)brace
multiline_comment|/* No bounce page was available. Sleep and wait for one. */
id|end_bh_atomic
c_func
(paren
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|10
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* If we received a signal, then bail out. */
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|jiffies
op_le
id|timeout
)paren
suffix:semicolon
multiline_comment|/* We did not find anything before the timeout. */
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* Return a bounce buffer to the free list. */
DECL|function|put_bounce_page
r_void
id|put_bounce_page
c_func
(paren
r_struct
id|bounce_page
op_star
id|page
)paren
(brace
id|add_bounce_page
c_func
(paren
id|page
)paren
suffix:semicolon
)brace
eof
