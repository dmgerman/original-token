multiline_comment|/* $Id: audio.c,v 1.56 2000/10/19 00:50:02 davem Exp $&n; * drivers/sbus/audio/audio.c&n; *&n; * Copyright 1996 Thomas K. Dyas (tdyas@noc.rutgers.edu)&n; * Copyright 1997,1998,1999 Derrick J. Brashear (shadow@dementia.org)&n; * Copyright 1997 Brent Baccala (baccala@freesoft.org)&n; * &n; * Mixer code adapted from code contributed by and&n; * Copyright 1998 Michael Mraka (michael@fi.muni.cz)&n; * and with fixes from Michael Shuey (shuey@ecn.purdue.edu)&n; * The mixer code cheats; Sparc hardware doesn&squot;t generally allow independent&n; * line control, and this fakes it badly.&n; *&n; * SNDCTL_DSP_SETFMT based on code contributed by&n; * Ion Badulescu (ionut@moisil.cs.columbia.edu)&n; *&n; * This is the audio midlayer that sits between the VFS character&n; * devices and the low-level audio hardware device drivers.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/soundcard.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;asm/delay.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/audioio.h&gt;
DECL|macro|__AUDIO_DEBUG
macro_line|#undef __AUDIO_DEBUG
DECL|macro|__AUDIO_ERROR
mdefine_line|#define __AUDIO_ERROR
DECL|macro|__AUDIO_TRACE
macro_line|#undef __AUDIO_TRACE
DECL|macro|__AUDIO_OSSDEBUG
macro_line|#undef __AUDIO_OSSDEBUG
macro_line|#ifdef __AUDIO_DEBUG
DECL|macro|dprintk
mdefine_line|#define dprintk(x) printk x
macro_line|#else
DECL|macro|dprintk
mdefine_line|#define dprintk(x)
macro_line|#endif
macro_line|#ifdef __AUDIO_OSSDEBUG
DECL|macro|oprintk
mdefine_line|#define oprintk(x) printk x
macro_line|#else
DECL|macro|oprintk
mdefine_line|#define oprintk(x)
macro_line|#endif
macro_line|#ifdef __AUDIO_ERROR
DECL|macro|eprintk
mdefine_line|#define eprintk(x) printk x
macro_line|#else
DECL|macro|eprintk
mdefine_line|#define eprintk(x)
macro_line|#endif
macro_line|#ifdef __AUDIO_TRACE
DECL|macro|tprintk
mdefine_line|#define tprintk(x) printk x
macro_line|#else
DECL|macro|tprintk
mdefine_line|#define tprintk(x)
macro_line|#endif
r_static
r_int
id|lis_get_elist_ent
c_func
(paren
id|strevent_t
op_star
id|list
comma
id|pid_t
id|pid
)paren
suffix:semicolon
r_static
r_int
id|lis_add_to_elist
c_func
(paren
id|strevent_t
op_star
op_star
id|list
comma
id|pid_t
id|pid
comma
r_int
id|events
)paren
suffix:semicolon
r_static
r_int
id|lis_del_from_elist
c_func
(paren
id|strevent_t
op_star
op_star
id|list
comma
id|pid_t
id|pid
comma
r_int
id|events
)paren
suffix:semicolon
r_static
r_void
id|lis_free_elist
c_func
(paren
id|strevent_t
op_star
op_star
id|list
)paren
suffix:semicolon
r_static
r_void
id|kill_procs
c_func
(paren
r_struct
id|strevent
op_star
id|elist
comma
r_int
id|sig
comma
r_int
id|e
)paren
suffix:semicolon
DECL|variable|drivers
r_static
r_struct
id|sparcaudio_driver
op_star
id|drivers
(braket
id|SPARCAUDIO_MAX_DEVICES
)braket
suffix:semicolon
DECL|variable|devfs_handle
r_static
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
multiline_comment|/* This crap to be pulled off into a local include file */
macro_line|#if defined (LINUX_VERSION_CODE) &amp;&amp; LINUX_VERSION_CODE &lt; 0x20100
DECL|macro|COPY_IN
mdefine_line|#define COPY_IN(arg, get) verify_area(VERIFY_READ, (void *)arg, sizeof(long)); memcpy_fromfs(&amp;get, (long *)arg, sizeof(get));
DECL|macro|COPY_OUT
mdefine_line|#define COPY_OUT(arg, ret) verify_area(VERIFY_WRITE, (void *)arg, sizeof(long)); memcpy_tofs((long *)arg, &amp;ret, sizeof(ret));
DECL|macro|copy_to_user
mdefine_line|#define copy_to_user memcpy_tofs
DECL|macro|copy_from_user
mdefine_line|#define copy_from_user memcpy_fromfs
DECL|macro|signal_pending
mdefine_line|#define signal_pending(x) (((x)-&gt;signal) &amp; ~((x)-&gt;blocked))
macro_line|#else
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/poll.h&gt;
DECL|macro|COPY_IN
mdefine_line|#define COPY_IN(arg, get) get_user(get, (int *)arg)
DECL|macro|COPY_OUT
mdefine_line|#define COPY_OUT(arg, ret) put_user(ret, (int *)arg)
DECL|macro|sparcaudio_select
mdefine_line|#define sparcaudio_select sparcaudio_poll
macro_line|#endif
DECL|function|sparcaudio_output_done
r_void
id|sparcaudio_output_done
c_func
(paren
r_struct
id|sparcaudio_driver
op_star
id|drv
comma
r_int
id|status
)paren
(brace
multiline_comment|/* If !status, just restart current output.&n;         * If status &amp; 1, a buffer is finished; make it available again.&n;         * If status &amp; 2, a buffer was claimed for DMA and is still in use.&n;         *&n;         * The playing_count for non-DMA hardware should never be non-zero.&n;         * Value of status for non-DMA hardware should always be 1.&n;         */
r_if
c_cond
(paren
id|status
op_amp
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|drv-&gt;playing_count
)paren
(brace
id|drv-&gt;playing_count
op_decrement
suffix:semicolon
)brace
r_else
(brace
id|drv-&gt;output_count
op_decrement
suffix:semicolon
id|drv-&gt;output_size
op_sub_assign
id|drv-&gt;output_sizes
(braket
id|drv-&gt;output_front
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;output_notify
(braket
id|drv-&gt;output_front
)braket
op_eq
l_int|1
)paren
(brace
id|drv-&gt;output_eof
op_increment
suffix:semicolon
id|drv-&gt;output_notify
(braket
id|drv-&gt;output_front
)braket
op_assign
l_int|0
suffix:semicolon
id|kill_procs
c_func
(paren
id|drv-&gt;sd_siglist
comma
id|SIGPOLL
comma
id|S_MSG
)paren
suffix:semicolon
)brace
id|drv-&gt;output_front
op_assign
(paren
id|drv-&gt;output_front
op_plus
l_int|1
)paren
op_mod
id|drv-&gt;num_output_buffers
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|status
op_amp
l_int|2
)paren
(brace
id|drv-&gt;output_count
op_decrement
suffix:semicolon
id|drv-&gt;playing_count
op_increment
suffix:semicolon
id|drv-&gt;output_size
op_sub_assign
id|drv-&gt;output_sizes
(braket
id|drv-&gt;output_front
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;output_notify
(braket
id|drv-&gt;output_front
)braket
op_eq
l_int|1
)paren
(brace
id|drv-&gt;output_eof
op_increment
suffix:semicolon
id|drv-&gt;output_notify
(braket
id|drv-&gt;output_front
)braket
op_assign
l_int|0
suffix:semicolon
id|kill_procs
c_func
(paren
id|drv-&gt;sd_siglist
comma
id|SIGPOLL
comma
id|S_MSG
)paren
suffix:semicolon
)brace
id|drv-&gt;output_front
op_assign
(paren
id|drv-&gt;output_front
op_plus
l_int|1
)paren
op_mod
id|drv-&gt;num_output_buffers
suffix:semicolon
)brace
multiline_comment|/* If we&squot;ve played everything go inactive. */
r_if
c_cond
(paren
(paren
id|drv-&gt;output_count
OL
l_int|1
)paren
op_logical_and
(paren
id|drv-&gt;playing_count
OL
l_int|1
)paren
)paren
id|drv-&gt;output_active
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If we got back a buffer, see if anyone wants to write to it */
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|1
)paren
op_logical_or
(paren
(paren
id|drv-&gt;output_count
op_plus
id|drv-&gt;playing_count
)paren
OL
id|drv-&gt;num_output_buffers
)paren
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|drv-&gt;output_write_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* If the output queue is empty, shut down the driver. */
r_if
c_cond
(paren
(paren
id|drv-&gt;output_count
OL
l_int|1
)paren
op_logical_and
(paren
id|drv-&gt;playing_count
OL
l_int|1
)paren
)paren
(brace
id|kill_procs
c_func
(paren
id|drv-&gt;sd_siglist
comma
id|SIGPOLL
comma
id|S_MSG
)paren
suffix:semicolon
multiline_comment|/* Stop the lowlevel driver from outputing. */
multiline_comment|/* drv-&gt;ops-&gt;stop_output(drv); Should not be necessary  -- DJB 5/25/98 */
id|drv-&gt;output_active
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Wake up any waiting writers or syncers and return. */
id|wake_up_interruptible
c_func
(paren
op_amp
id|drv-&gt;output_write_wait
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|drv-&gt;output_drain_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Start next block of output if we have it */
r_if
c_cond
(paren
id|drv-&gt;output_count
OG
l_int|0
)paren
(brace
id|drv-&gt;ops
op_member_access_from_pointer
id|start_output
c_func
(paren
id|drv
comma
id|drv-&gt;output_buffers
(braket
id|drv-&gt;output_front
)braket
comma
id|drv-&gt;output_sizes
(braket
id|drv-&gt;output_front
)braket
)paren
suffix:semicolon
id|drv-&gt;output_active
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|drv-&gt;output_active
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|sparcaudio_input_done
r_void
id|sparcaudio_input_done
c_func
(paren
r_struct
id|sparcaudio_driver
op_star
id|drv
comma
r_int
id|status
)paren
(brace
multiline_comment|/* Deal with the weird case here */
r_if
c_cond
(paren
id|drv-&gt;duplex
op_eq
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|drv-&gt;input_count
OL
id|drv-&gt;num_input_buffers
)paren
id|drv-&gt;input_count
op_increment
suffix:semicolon
id|drv-&gt;ops
op_member_access_from_pointer
id|start_input
c_func
(paren
id|drv
comma
id|drv-&gt;input_buffers
(braket
id|drv-&gt;input_front
)braket
comma
id|drv-&gt;input_buffer_size
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|drv-&gt;input_read_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* If status % 2, they filled a buffer for us. &n;         * If status &amp; 2, they took a buffer from us.&n;         */
r_if
c_cond
(paren
(paren
id|status
op_mod
l_int|2
)paren
op_eq
l_int|1
)paren
(brace
id|drv-&gt;input_count
op_increment
suffix:semicolon
id|drv-&gt;recording_count
op_decrement
suffix:semicolon
id|drv-&gt;input_size
op_add_assign
id|drv-&gt;input_buffer_size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
OG
l_int|1
)paren
(brace
id|drv-&gt;recording_count
op_increment
suffix:semicolon
id|drv-&gt;input_front
op_assign
(paren
id|drv-&gt;input_front
op_plus
l_int|1
)paren
op_mod
id|drv-&gt;num_input_buffers
suffix:semicolon
)brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;f%d r%d c%d u%d&bslash;n&quot;
comma
id|drv-&gt;input_front
comma
id|drv-&gt;input_rear
comma
id|drv-&gt;input_count
comma
id|drv-&gt;recording_count
)paren
)paren
suffix:semicolon
multiline_comment|/* If the input queue is full, shutdown the driver. */
r_if
c_cond
(paren
(paren
id|drv-&gt;input_count
op_plus
id|drv-&gt;recording_count
)paren
op_eq
id|drv-&gt;num_input_buffers
)paren
(brace
id|kill_procs
c_func
(paren
id|drv-&gt;sd_siglist
comma
id|SIGPOLL
comma
id|S_MSG
)paren
suffix:semicolon
multiline_comment|/* Stop the lowlevel driver from inputing. */
id|drv-&gt;ops
op_member_access_from_pointer
id|stop_input
c_func
(paren
id|drv
)paren
suffix:semicolon
id|drv-&gt;input_active
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, give the driver the next buffer. */
id|drv-&gt;ops
op_member_access_from_pointer
id|start_input
c_func
(paren
id|drv
comma
id|drv-&gt;input_buffers
(braket
id|drv-&gt;input_front
)braket
comma
id|drv-&gt;input_buffer_size
)paren
suffix:semicolon
)brace
multiline_comment|/* Wake up any tasks that are waiting. */
id|wake_up_interruptible
c_func
(paren
op_amp
id|drv-&gt;input_read_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;VFS layer interface&n; */
macro_line|#if defined (LINUX_VERSION_CODE) &amp;&amp; LINUX_VERSION_CODE &lt; 0x20100
DECL|function|sparcaudio_select
r_static
r_int
id|sparcaudio_select
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
id|sel_type
comma
id|select_table
op_star
id|wait
)paren
(brace
r_struct
id|sparcaudio_driver
op_star
id|drv
op_assign
id|drivers
(braket
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
id|SPARCAUDIO_DEVICE_SHIFT
)paren
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|sel_type
)paren
(brace
r_case
id|SEL_IN
suffix:colon
r_if
c_cond
(paren
(paren
(paren
op_logical_neg
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
op_logical_and
id|drv-&gt;input_count
)paren
op_logical_or
(paren
id|drv-&gt;input_size
OG
id|drv-&gt;buffer_size
)paren
)paren
(brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;read ready: c%d o%d&bslash;n&quot;
comma
id|drv-&gt;input_count
comma
id|drv-&gt;input_offset
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|select_wait
c_func
(paren
op_amp
id|drv-&gt;input_read_wait
comma
id|wait
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SEL_OUT
suffix:colon
id|dprintk
c_func
(paren
(paren
l_string|&quot;sel out: c%d o%d p%d&bslash;n&quot;
comma
id|drv-&gt;output_count
comma
id|drv-&gt;output_offset
comma
id|drv-&gt;playing_count
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drv-&gt;output_count
op_plus
id|drv-&gt;playing_count
)paren
OL
(paren
id|drv-&gt;num_output_buffers
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|select_wait
c_func
(paren
op_amp
id|drv-&gt;output_write_wait
comma
id|wait
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SEL_EX
suffix:colon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else
DECL|function|sparcaudio_poll
r_static
r_int
r_int
id|sparcaudio_poll
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|poll_table
op_star
id|wait
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|0
suffix:semicolon
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_struct
id|sparcaudio_driver
op_star
id|drv
op_assign
id|drivers
(braket
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
id|SPARCAUDIO_DEVICE_SHIFT
)paren
)braket
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|drv-&gt;input_read_wait
comma
id|wait
)paren
suffix:semicolon
id|poll_wait
c_func
(paren
id|file
comma
op_amp
id|drv-&gt;output_write_wait
comma
id|wait
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
op_logical_neg
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
op_logical_and
id|drv-&gt;input_count
)paren
op_logical_or
(paren
id|drv-&gt;input_size
OG
id|drv-&gt;buffer_size
)paren
)paren
(brace
id|mask
op_or_assign
id|POLLIN
op_or
id|POLLRDNORM
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|drv-&gt;output_count
op_plus
id|drv-&gt;playing_count
)paren
OL
(paren
id|drv-&gt;num_output_buffers
)paren
)paren
(brace
id|mask
op_or_assign
id|POLLOUT
op_or
id|POLLWRNORM
suffix:semicolon
)brace
r_return
id|mask
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if defined (LINUX_VERSION_CODE) &amp;&amp; LINUX_VERSION_CODE &lt; 0x20100
DECL|function|sparcaudio_lseek
r_static
r_int
id|sparcaudio_lseek
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|off_t
id|offset
comma
r_int
id|origin
)paren
macro_line|#else
r_static
id|loff_t
id|sparcaudio_lseek
c_func
(paren
r_struct
id|file
op_star
id|file
comma
id|loff_t
id|offset
comma
r_int
id|origin
)paren
macro_line|#endif
(brace
r_return
op_minus
id|ESPIPE
suffix:semicolon
)brace
macro_line|#if defined (LINUX_VERSION_CODE) &amp;&amp; LINUX_VERSION_CODE &lt; 0x20100
DECL|function|sparcaudio_read
r_static
r_int
id|sparcaudio_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
macro_line|#else
r_static
id|ssize_t
id|sparcaudio_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
macro_line|#endif
(brace
macro_line|#if defined (LINUX_VERSION_CODE) &amp;&amp; LINUX_VERSION_CODE &gt; 0x200ff
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
macro_line|#endif
r_struct
id|sparcaudio_driver
op_star
id|drv
op_assign
id|drivers
(braket
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
id|SPARCAUDIO_DEVICE_SHIFT
)paren
)braket
suffix:semicolon
r_int
id|bytes_to_copy
comma
id|bytes_read
op_assign
l_int|0
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
op_logical_and
(paren
id|drv-&gt;input_size
OL
id|count
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|drv-&gt;input_count
op_eq
l_int|0
)paren
(brace
multiline_comment|/* This *should* never happen. */
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Warning: audio input leak!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|drv-&gt;input_read_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|bytes_to_copy
op_assign
id|drv-&gt;input_buffer_size
op_minus
id|drv-&gt;input_offset
suffix:semicolon
r_if
c_cond
(paren
id|bytes_to_copy
OG
id|count
)paren
id|bytes_to_copy
op_assign
id|count
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|buf
comma
id|bytes_to_copy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|copy_to_user
c_func
(paren
id|buf
comma
id|drv-&gt;input_buffers
(braket
id|drv-&gt;input_rear
)braket
op_plus
id|drv-&gt;input_offset
comma
id|bytes_to_copy
)paren
suffix:semicolon
id|drv-&gt;input_offset
op_add_assign
id|bytes_to_copy
suffix:semicolon
id|drv-&gt;input_size
op_sub_assign
id|bytes_to_copy
suffix:semicolon
id|buf
op_add_assign
id|bytes_to_copy
suffix:semicolon
id|count
op_sub_assign
id|bytes_to_copy
suffix:semicolon
id|bytes_read
op_add_assign
id|bytes_to_copy
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;input_offset
op_ge
id|drv-&gt;input_buffer_size
)paren
(brace
id|drv-&gt;input_rear
op_assign
(paren
id|drv-&gt;input_rear
op_plus
l_int|1
)paren
op_mod
id|drv-&gt;num_input_buffers
suffix:semicolon
id|drv-&gt;input_count
op_decrement
suffix:semicolon
id|drv-&gt;input_offset
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If we&squot;re in &quot;loop audio&quot; mode, try waking up the other side&n;                 * in case they&squot;re waiting for us to eat a block. &n;                 */
r_if
c_cond
(paren
id|drv-&gt;duplex
op_eq
l_int|2
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|drv-&gt;output_write_wait
)paren
suffix:semicolon
)brace
r_return
id|bytes_read
suffix:semicolon
)brace
DECL|function|sparcaudio_sync_output
r_static
r_void
id|sparcaudio_sync_output
c_func
(paren
r_struct
id|sparcaudio_driver
op_star
id|drv
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
multiline_comment|/* If the low-level driver is not active, activate it. */
id|save_and_cli
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|drv-&gt;output_active
)paren
op_logical_and
(paren
id|drv-&gt;output_count
OG
l_int|0
)paren
)paren
(brace
id|drv-&gt;ops
op_member_access_from_pointer
id|start_output
c_func
(paren
id|drv
comma
id|drv-&gt;output_buffers
(braket
id|drv-&gt;output_front
)braket
comma
id|drv-&gt;output_sizes
(braket
id|drv-&gt;output_front
)braket
)paren
suffix:semicolon
id|drv-&gt;output_active
op_assign
l_int|1
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#if defined (LINUX_VERSION_CODE) &amp;&amp; LINUX_VERSION_CODE &lt; 0x20100
DECL|function|sparcaudio_write
r_static
r_int
id|sparcaudio_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
macro_line|#else
r_static
id|ssize_t
id|sparcaudio_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
macro_line|#endif
(brace
macro_line|#if defined (LINUX_VERSION_CODE) &amp;&amp; LINUX_VERSION_CODE &gt; 0x200ff
r_struct
id|inode
op_star
id|inode
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
macro_line|#endif
r_struct
id|sparcaudio_driver
op_star
id|drv
op_assign
id|drivers
(braket
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
id|SPARCAUDIO_DEVICE_SHIFT
)paren
)braket
suffix:semicolon
r_int
id|bytes_written
op_assign
l_int|0
comma
id|bytes_to_copy
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* A signal they want notification when this is processed. Too bad&n;         * sys_write doesn&squot;t tell us unless you patch it, in 2.0 kernels.&n;         */
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
macro_line|#ifndef notdef
id|drv-&gt;output_eof
op_increment
suffix:semicolon
id|kill_procs
c_func
(paren
id|drv-&gt;sd_siglist
comma
id|SIGPOLL
comma
id|S_MSG
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* Nice code, but the world isn&squot;t ready yet... */
id|drv-&gt;output_notify
(braket
id|drv-&gt;output_rear
)braket
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Loop until all output is written to device. */
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
multiline_comment|/* Check to make sure that an output buffer is available. */
r_if
c_cond
(paren
id|drv-&gt;num_output_buffers
op_eq
(paren
id|drv-&gt;output_count
op_plus
id|drv-&gt;playing_count
)paren
)paren
(brace
multiline_comment|/* We need buffers, so... */
id|sparcaudio_sync_output
c_func
(paren
id|drv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|drv-&gt;output_write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|bytes_written
OG
l_int|0
ques
c_cond
id|bytes_written
suffix:colon
op_minus
id|EINTR
suffix:semicolon
)brace
multiline_comment|/* No buffers were freed. Go back to sleep */
r_if
c_cond
(paren
id|drv-&gt;num_output_buffers
op_eq
(paren
id|drv-&gt;output_count
op_plus
id|drv-&gt;playing_count
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Deal with the weird case of a reader in the write area by trying to&n;                 * let them keep ahead of us... Go to sleep until they start servicing.&n;                 */
r_if
c_cond
(paren
(paren
id|drv-&gt;duplex
op_eq
l_int|2
)paren
op_logical_and
(paren
id|drv-&gt;flags
op_amp
id|SDF_OPEN_READ
)paren
op_logical_and
(paren
id|drv-&gt;output_rear
op_eq
id|drv-&gt;input_rear
)paren
op_logical_and
(paren
id|drv-&gt;input_count
OG
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|drv-&gt;output_write_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
id|bytes_written
OG
l_int|0
ques
c_cond
id|bytes_written
suffix:colon
op_minus
id|EINTR
suffix:semicolon
)brace
multiline_comment|/* Determine how much we can copy in this iteration. */
id|bytes_to_copy
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|bytes_to_copy
OG
id|drv-&gt;output_buffer_size
op_minus
id|drv-&gt;output_offset
)paren
id|bytes_to_copy
op_assign
id|drv-&gt;output_buffer_size
op_minus
id|drv-&gt;output_offset
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|buf
comma
id|bytes_to_copy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|copy_from_user
c_func
(paren
id|drv-&gt;output_buffers
(braket
id|drv-&gt;output_rear
)braket
op_plus
id|drv-&gt;output_offset
comma
id|buf
comma
id|bytes_to_copy
)paren
suffix:semicolon
multiline_comment|/* Update the queue pointers. */
id|buf
op_add_assign
id|bytes_to_copy
suffix:semicolon
id|count
op_sub_assign
id|bytes_to_copy
suffix:semicolon
id|bytes_written
op_add_assign
id|bytes_to_copy
suffix:semicolon
multiline_comment|/* A block can get orphaned in a flush and not cleaned up. */
r_if
c_cond
(paren
id|drv-&gt;output_offset
)paren
id|drv-&gt;output_sizes
(braket
id|drv-&gt;output_rear
)braket
op_add_assign
id|bytes_to_copy
suffix:semicolon
r_else
id|drv-&gt;output_sizes
(braket
id|drv-&gt;output_rear
)braket
op_assign
id|bytes_to_copy
suffix:semicolon
id|drv-&gt;output_notify
(braket
id|drv-&gt;output_rear
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;output_sizes
(braket
id|drv-&gt;output_rear
)braket
op_eq
id|drv-&gt;output_buffer_size
)paren
(brace
id|drv-&gt;output_rear
op_assign
(paren
id|drv-&gt;output_rear
op_plus
l_int|1
)paren
op_mod
id|drv-&gt;num_output_buffers
suffix:semicolon
id|drv-&gt;output_count
op_increment
suffix:semicolon
id|drv-&gt;output_offset
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|drv-&gt;output_offset
op_add_assign
id|bytes_to_copy
suffix:semicolon
)brace
id|drv-&gt;output_size
op_add_assign
id|bytes_to_copy
suffix:semicolon
)brace
id|sparcaudio_sync_output
c_func
(paren
id|drv
)paren
suffix:semicolon
multiline_comment|/* Return the number of bytes written to the caller. */
r_return
id|bytes_written
suffix:semicolon
)brace
multiline_comment|/* Add these in as new devices are supported. Belongs in audioio.h, actually */
DECL|macro|MONO_DEVICES
mdefine_line|#define MONO_DEVICES (SOUND_MASK_SPEAKER | SOUND_MASK_MIC)
DECL|function|sparcaudio_mixer_ioctl
r_static
r_int
id|sparcaudio_mixer_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
op_star
id|arg
)paren
(brace
r_struct
id|sparcaudio_driver
op_star
id|drv
op_assign
id|drivers
(braket
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
id|SPARCAUDIO_DEVICE_SHIFT
)paren
)braket
suffix:semicolon
r_int
r_int
id|i
op_assign
l_int|0
comma
id|j
op_assign
l_int|0
comma
id|l
op_assign
l_int|0
comma
id|m
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|k
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|_SIOC_DIR
c_func
(paren
id|cmd
)paren
op_amp
id|_SIOC_WRITE
)paren
id|drv-&gt;mixer_modify_counter
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|SOUND_MIXER_INFO
)paren
(brace
id|audio_device_t
id|tmp
suffix:semicolon
id|mixer_info
id|info
suffix:semicolon
r_int
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;sunaudio_getdev
)paren
(brace
id|drv-&gt;ops
op_member_access_from_pointer
id|sunaudio_getdev
c_func
(paren
id|drv
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|info
comma
l_int|0
comma
r_sizeof
(paren
id|info
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|info.id
comma
id|tmp.name
comma
r_sizeof
(paren
id|info.id
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|info.name
comma
l_string|&quot;Sparc Audio&quot;
comma
r_sizeof
(paren
id|info.name
)paren
)paren
suffix:semicolon
id|info.modify_counter
op_assign
id|drv-&gt;mixer_modify_counter
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
op_amp
id|info
comma
r_sizeof
(paren
id|info
)paren
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EFAULT
suffix:semicolon
)brace
r_else
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SOUND_MIXER_WRITE_RECLEV
suffix:colon
r_if
c_cond
(paren
id|COPY_IN
c_func
(paren
id|arg
comma
id|k
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|iretry
suffix:colon
id|oprintk
c_func
(paren
(paren
l_string|&quot;setting input volume (0x%x)&quot;
comma
id|k
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_channels
)paren
id|j
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_channels
c_func
(paren
id|drv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_volume
)paren
id|l
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_volume
c_func
(paren
id|drv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_balance
)paren
id|m
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_balance
c_func
(paren
id|drv
)paren
suffix:semicolon
id|i
op_assign
id|OSS_TO_GAIN
c_func
(paren
id|k
)paren
suffix:semicolon
id|j
op_assign
id|OSS_TO_BAL
c_func
(paren
id|k
)paren
suffix:semicolon
id|oprintk
c_func
(paren
(paren
l_string|&quot; for stereo to to %d (bal %d):&quot;
comma
id|i
comma
id|j
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_input_volume
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_volume
c_func
(paren
id|drv
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_input_balance
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_balance
c_func
(paren
id|drv
comma
id|j
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_READ_RECLEV
suffix:colon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_volume
)paren
id|i
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_volume
c_func
(paren
id|drv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_balance
)paren
id|j
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_balance
c_func
(paren
id|drv
)paren
suffix:semicolon
id|oprintk
c_func
(paren
(paren
l_string|&quot; got (0x%x)&bslash;n&quot;
comma
id|BAL_TO_OSS
c_func
(paren
id|i
comma
id|j
)paren
)paren
)paren
suffix:semicolon
id|i
op_assign
id|BAL_TO_OSS
c_func
(paren
id|i
comma
id|j
)paren
suffix:semicolon
multiline_comment|/* Try to be reasonable about volume changes */
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|SOUND_MIXER_WRITE_RECLEV
)paren
op_logical_and
(paren
id|i
op_ne
id|k
)paren
op_logical_and
(paren
id|i
op_eq
id|BAL_TO_OSS
c_func
(paren
id|l
comma
id|m
)paren
)paren
)paren
(brace
id|k
op_add_assign
(paren
id|OSS_LEFT
c_func
(paren
id|k
)paren
OG
id|OSS_LEFT
c_func
(paren
id|i
)paren
)paren
ques
c_cond
l_int|256
suffix:colon
op_minus
l_int|256
suffix:semicolon
id|k
op_add_assign
(paren
id|OSS_RIGHT
c_func
(paren
id|k
)paren
OG
id|OSS_RIGHT
c_func
(paren
id|i
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|oprintk
c_func
(paren
(paren
l_string|&quot; try 0x%x&bslash;n&quot;
comma
id|k
)paren
)paren
suffix:semicolon
r_goto
id|iretry
suffix:semicolon
)brace
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|i
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_VOLUME
suffix:colon
r_if
c_cond
(paren
id|COPY_IN
c_func
(paren
id|arg
comma
id|k
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_muted
op_logical_and
id|drv-&gt;ops-&gt;set_output_muted
)paren
(brace
id|i
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_muted
c_func
(paren
id|drv
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|k
op_eq
l_int|0
)paren
op_logical_or
(paren
(paren
id|i
op_eq
l_int|0
)paren
op_logical_and
(paren
id|OSS_LEFT
c_func
(paren
id|k
)paren
OL
l_int|100
)paren
)paren
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_muted
c_func
(paren
id|drv
comma
l_int|1
)paren
suffix:semicolon
r_else
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_muted
c_func
(paren
id|drv
comma
l_int|0
)paren
suffix:semicolon
)brace
r_case
id|SOUND_MIXER_READ_VOLUME
suffix:colon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_muted
)paren
id|i
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_muted
c_func
(paren
id|drv
)paren
suffix:semicolon
id|k
op_assign
l_int|0x6464
op_star
(paren
l_int|1
op_minus
id|i
)paren
suffix:semicolon
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|k
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_PCM
suffix:colon
r_if
c_cond
(paren
id|COPY_IN
c_func
(paren
id|arg
comma
id|k
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|oretry
suffix:colon
id|oprintk
c_func
(paren
(paren
l_string|&quot;setting output volume (0x%x)&bslash;n&quot;
comma
id|k
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_channels
)paren
id|j
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_channels
c_func
(paren
id|drv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_volume
)paren
id|l
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_volume
c_func
(paren
id|drv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_balance
)paren
id|m
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_balance
c_func
(paren
id|drv
)paren
suffix:semicolon
id|oprintk
c_func
(paren
(paren
l_string|&quot; started as (0x%x)&bslash;n&quot;
comma
id|BAL_TO_OSS
c_func
(paren
id|l
comma
id|m
)paren
)paren
)paren
suffix:semicolon
id|i
op_assign
id|OSS_TO_GAIN
c_func
(paren
id|k
)paren
suffix:semicolon
id|j
op_assign
id|OSS_TO_BAL
c_func
(paren
id|k
)paren
suffix:semicolon
id|oprintk
c_func
(paren
(paren
l_string|&quot; for stereo to %d (bal %d)&bslash;n&quot;
comma
id|i
comma
id|j
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_output_volume
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_volume
c_func
(paren
id|drv
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_output_balance
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_balance
c_func
(paren
id|drv
comma
id|j
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_READ_PCM
suffix:colon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_volume
)paren
id|i
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_volume
c_func
(paren
id|drv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_balance
)paren
id|j
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_balance
c_func
(paren
id|drv
)paren
suffix:semicolon
id|oprintk
c_func
(paren
(paren
l_string|&quot; got 0x%x&bslash;n&quot;
comma
id|BAL_TO_OSS
c_func
(paren
id|i
comma
id|j
)paren
)paren
)paren
suffix:semicolon
id|i
op_assign
id|BAL_TO_OSS
c_func
(paren
id|i
comma
id|j
)paren
suffix:semicolon
multiline_comment|/* Try to be reasonable about volume changes */
r_if
c_cond
(paren
(paren
id|cmd
op_eq
id|SOUND_MIXER_WRITE_PCM
)paren
op_logical_and
(paren
id|i
op_ne
id|k
)paren
op_logical_and
(paren
id|i
op_eq
id|BAL_TO_OSS
c_func
(paren
id|l
comma
id|m
)paren
)paren
)paren
(brace
id|k
op_add_assign
(paren
id|OSS_LEFT
c_func
(paren
id|k
)paren
OG
id|OSS_LEFT
c_func
(paren
id|i
)paren
)paren
ques
c_cond
l_int|256
suffix:colon
op_minus
l_int|256
suffix:semicolon
id|k
op_add_assign
(paren
id|OSS_RIGHT
c_func
(paren
id|k
)paren
OG
id|OSS_RIGHT
c_func
(paren
id|i
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
op_minus
l_int|1
suffix:semicolon
id|oprintk
c_func
(paren
(paren
l_string|&quot; try 0x%x&bslash;n&quot;
comma
id|k
)paren
)paren
suffix:semicolon
r_goto
id|oretry
suffix:semicolon
)brace
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|i
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_READ_SPEAKER
suffix:colon
id|k
op_assign
id|OSS_PORT_AUDIO
c_func
(paren
id|drv
comma
id|AUDIO_SPEAKER
)paren
suffix:semicolon
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|k
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_READ_MIC
suffix:colon
id|k
op_assign
id|OSS_IPORT_AUDIO
c_func
(paren
id|drv
comma
id|AUDIO_MICROPHONE
)paren
suffix:semicolon
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|k
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_READ_CD
suffix:colon
id|k
op_assign
id|OSS_IPORT_AUDIO
c_func
(paren
id|drv
comma
id|AUDIO_CD
)paren
suffix:semicolon
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|k
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_READ_LINE
suffix:colon
id|k
op_assign
id|OSS_IPORT_AUDIO
c_func
(paren
id|drv
comma
id|AUDIO_LINE_IN
)paren
suffix:semicolon
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|k
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_READ_LINE1
suffix:colon
id|k
op_assign
id|OSS_PORT_AUDIO
c_func
(paren
id|drv
comma
id|AUDIO_HEADPHONE
)paren
suffix:semicolon
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|k
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_READ_LINE2
suffix:colon
id|k
op_assign
id|OSS_PORT_AUDIO
c_func
(paren
id|drv
comma
id|AUDIO_LINE_OUT
)paren
suffix:semicolon
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|k
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_MIC
suffix:colon
r_case
id|SOUND_MIXER_WRITE_CD
suffix:colon
r_case
id|SOUND_MIXER_WRITE_LINE
suffix:colon
r_case
id|SOUND_MIXER_WRITE_LINE1
suffix:colon
r_case
id|SOUND_MIXER_WRITE_LINE2
suffix:colon
r_case
id|SOUND_MIXER_WRITE_SPEAKER
suffix:colon
r_if
c_cond
(paren
id|COPY_IN
c_func
(paren
id|arg
comma
id|k
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|OSS_TWIDDLE_IPORT
c_func
(paren
id|drv
comma
id|cmd
comma
id|SOUND_MIXER_WRITE_LINE
comma
id|AUDIO_LINE_IN
comma
id|k
)paren
suffix:semicolon
id|OSS_TWIDDLE_IPORT
c_func
(paren
id|drv
comma
id|cmd
comma
id|SOUND_MIXER_WRITE_MIC
comma
id|AUDIO_MICROPHONE
comma
id|k
)paren
suffix:semicolon
id|OSS_TWIDDLE_IPORT
c_func
(paren
id|drv
comma
id|cmd
comma
id|SOUND_MIXER_WRITE_CD
comma
id|AUDIO_CD
comma
id|k
)paren
suffix:semicolon
id|OSS_TWIDDLE_PORT
c_func
(paren
id|drv
comma
id|cmd
comma
id|SOUND_MIXER_WRITE_SPEAKER
comma
id|AUDIO_SPEAKER
comma
id|k
)paren
suffix:semicolon
id|OSS_TWIDDLE_PORT
c_func
(paren
id|drv
comma
id|cmd
comma
id|SOUND_MIXER_WRITE_LINE1
comma
id|AUDIO_HEADPHONE
comma
id|k
)paren
suffix:semicolon
id|OSS_TWIDDLE_PORT
c_func
(paren
id|drv
comma
id|cmd
comma
id|SOUND_MIXER_WRITE_LINE2
comma
id|AUDIO_LINE_OUT
comma
id|k
)paren
suffix:semicolon
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|k
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_READ_RECSRC
suffix:colon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_port
)paren
id|i
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_port
c_func
(paren
id|drv
)paren
suffix:semicolon
multiline_comment|/* only one should ever be selected */
r_if
c_cond
(paren
id|i
op_amp
id|AUDIO_CD
)paren
id|j
op_assign
id|SOUND_MASK_CD
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|AUDIO_LINE_IN
)paren
id|j
op_assign
id|SOUND_MASK_LINE
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|AUDIO_MICROPHONE
)paren
id|j
op_assign
id|SOUND_MASK_MIC
suffix:semicolon
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|j
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_WRITE_RECSRC
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_input_port
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|COPY_IN
c_func
(paren
id|arg
comma
id|k
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
multiline_comment|/* only one should ever be selected */
r_if
c_cond
(paren
id|k
op_amp
id|SOUND_MASK_CD
)paren
id|j
op_assign
id|AUDIO_CD
suffix:semicolon
r_if
c_cond
(paren
id|k
op_amp
id|SOUND_MASK_LINE
)paren
id|j
op_assign
id|AUDIO_LINE_IN
suffix:semicolon
r_if
c_cond
(paren
id|k
op_amp
id|SOUND_MASK_MIC
)paren
id|j
op_assign
id|AUDIO_MICROPHONE
suffix:semicolon
id|oprintk
c_func
(paren
(paren
l_string|&quot;setting inport to %d&bslash;n&quot;
comma
id|j
)paren
)paren
suffix:semicolon
id|i
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_port
c_func
(paren
id|drv
comma
id|j
)paren
suffix:semicolon
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|i
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_READ_RECMASK
suffix:colon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_ports
)paren
id|i
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_ports
c_func
(paren
id|drv
)paren
suffix:semicolon
multiline_comment|/* what do we support? */
r_if
c_cond
(paren
id|i
op_amp
id|AUDIO_MICROPHONE
)paren
id|j
op_or_assign
id|SOUND_MASK_MIC
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|AUDIO_LINE_IN
)paren
id|j
op_or_assign
id|SOUND_MASK_LINE
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|AUDIO_CD
)paren
id|j
op_or_assign
id|SOUND_MASK_CD
suffix:semicolon
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|j
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_READ_CAPS
suffix:colon
multiline_comment|/* mixer capabilities */
id|i
op_assign
id|SOUND_CAP_EXCL_INPUT
suffix:semicolon
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|i
)paren
suffix:semicolon
r_case
id|SOUND_MIXER_READ_DEVMASK
suffix:colon
multiline_comment|/* all supported devices */
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_ports
)paren
id|i
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_ports
c_func
(paren
id|drv
)paren
suffix:semicolon
multiline_comment|/* what do we support? */
r_if
c_cond
(paren
id|i
op_amp
id|AUDIO_MICROPHONE
)paren
id|j
op_or_assign
id|SOUND_MASK_MIC
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|AUDIO_LINE_IN
)paren
id|j
op_or_assign
id|SOUND_MASK_LINE
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|AUDIO_CD
)paren
id|j
op_or_assign
id|SOUND_MASK_CD
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_ports
)paren
id|i
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_ports
c_func
(paren
id|drv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|AUDIO_SPEAKER
)paren
id|j
op_or_assign
id|SOUND_MASK_SPEAKER
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|AUDIO_HEADPHONE
)paren
id|j
op_or_assign
id|SOUND_MASK_LINE1
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|AUDIO_LINE_OUT
)paren
id|j
op_or_assign
id|SOUND_MASK_LINE2
suffix:semicolon
id|j
op_or_assign
id|SOUND_MASK_VOLUME
suffix:semicolon
r_case
id|SOUND_MIXER_READ_STEREODEVS
suffix:colon
multiline_comment|/* what supports stereo */
id|j
op_or_assign
id|SOUND_MASK_PCM
op_or
id|SOUND_MASK_RECLEV
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|SOUND_MIXER_READ_STEREODEVS
)paren
id|j
op_and_assign
op_complement
(paren
id|MONO_DEVICES
)paren
suffix:semicolon
r_return
id|COPY_OUT
c_func
(paren
id|arg
comma
id|j
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
suffix:semicolon
)brace
multiline_comment|/* AUDIO_SETINFO uses these to set values if possible. */
r_static
id|__inline__
r_int
DECL|function|__sparcaudio_if_set_do
id|__sparcaudio_if_set_do
c_func
(paren
r_struct
id|sparcaudio_driver
op_star
id|drv
comma
r_int
(paren
op_star
id|set_function
)paren
(paren
r_struct
id|sparcaudio_driver
op_star
comma
r_int
)paren
comma
r_int
(paren
op_star
id|get_function
)paren
(paren
r_struct
id|sparcaudio_driver
op_star
)paren
comma
r_int
r_int
id|value
)paren
(brace
r_if
c_cond
(paren
id|set_function
op_logical_and
id|Modify
c_func
(paren
id|value
)paren
)paren
r_return
(paren
r_int
)paren
id|set_function
c_func
(paren
id|drv
comma
id|value
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|get_function
)paren
r_return
(paren
r_int
)paren
id|get_function
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|__inline__
r_int
DECL|function|__sparcaudio_if_setc_do
id|__sparcaudio_if_setc_do
c_func
(paren
r_struct
id|sparcaudio_driver
op_star
id|drv
comma
r_int
(paren
op_star
id|set_function
)paren
(paren
r_struct
id|sparcaudio_driver
op_star
comma
r_int
)paren
comma
r_int
(paren
op_star
id|get_function
)paren
(paren
r_struct
id|sparcaudio_driver
op_star
)paren
comma
r_int
r_char
id|value
)paren
(brace
r_if
c_cond
(paren
id|set_function
op_logical_and
id|Modifyc
c_func
(paren
id|value
)paren
)paren
r_return
(paren
r_char
)paren
id|set_function
c_func
(paren
id|drv
comma
(paren
r_int
)paren
id|value
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|get_function
)paren
r_return
(paren
r_char
)paren
id|get_function
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* I_FLUSH, I_{G,S}ETSIG, I_NREAD provided for SunOS compatibility&n; *&n; * I must admit I&squot;m quite ashamed of the state of the ioctl handling,&n; * but I do have several optimizations which I&squot;m planning. -- DJB&n; */
DECL|function|sparcaudio_ioctl
r_static
r_int
id|sparcaudio_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|retval
op_assign
l_int|0
comma
id|i
comma
id|j
comma
id|k
suffix:semicolon
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|audio_info
id|ainfo
suffix:semicolon
id|audio_buf_info
id|binfo
suffix:semicolon
id|count_info
id|cinfo
suffix:semicolon
r_struct
id|sparcaudio_driver
op_star
id|drv
op_assign
id|drivers
(braket
(paren
id|minor
op_rshift
id|SPARCAUDIO_DEVICE_SHIFT
)paren
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|minor
op_amp
l_int|0xf
)paren
(brace
r_case
id|SPARCAUDIO_MIXER_MINOR
suffix:colon
r_return
id|sparcaudio_mixer_ioctl
c_func
(paren
id|inode
comma
id|file
comma
id|cmd
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|SPARCAUDIO_DSP16_MINOR
suffix:colon
r_case
id|SPARCAUDIO_DSP_MINOR
suffix:colon
r_case
id|SPARCAUDIO_AUDIO_MINOR
suffix:colon
r_case
id|SPARCAUDIO_AUDIOCTL_MINOR
suffix:colon
multiline_comment|/* According to the OSS prog int, you can mixer ioctl /dev/dsp */
r_if
c_cond
(paren
id|_IOC_TYPE
c_func
(paren
id|cmd
)paren
op_eq
l_char|&squot;M&squot;
)paren
r_return
id|sparcaudio_mixer_ioctl
c_func
(paren
id|inode
comma
id|file
comma
id|cmd
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|I_GETSIG
suffix:colon
r_case
id|I_GETSIG_SOLARIS
suffix:colon
id|j
op_assign
(paren
r_int
)paren
id|lis_get_elist_ent
c_func
(paren
id|drv-&gt;sd_siglist
comma
id|current-&gt;pid
)paren
suffix:semicolon
id|COPY_OUT
c_func
(paren
id|arg
comma
id|j
)paren
suffix:semicolon
id|retval
op_assign
id|drv-&gt;input_count
suffix:semicolon
r_break
suffix:semicolon
r_case
id|I_SETSIG
suffix:colon
r_case
id|I_SETSIG_SOLARIS
suffix:colon
r_if
c_cond
(paren
(paren
id|minor
op_amp
l_int|0xf
)paren
op_eq
id|SPARCAUDIO_AUDIOCTL_MINOR
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
(brace
r_if
c_cond
(paren
id|lis_del_from_elist
c_func
(paren
op_amp
(paren
id|drv-&gt;sd_siglist
)paren
comma
id|current-&gt;pid
comma
id|S_ALL
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|drv-&gt;sd_siglist
)paren
(brace
id|drv-&gt;sd_sigflags
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|lis_add_to_elist
c_func
(paren
op_amp
(paren
id|drv-&gt;sd_siglist
)paren
comma
id|current-&gt;pid
comma
(paren
r_int
)paren
id|arg
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_else
(brace
(paren
(paren
id|drv-&gt;sd_sigflags
)paren
op_or_assign
(paren
id|arg
)paren
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|I_NREAD
suffix:colon
r_case
id|I_NREAD_SOLARIS
suffix:colon
multiline_comment|/* According to the Solaris man page, this copies out&n;                         * the size of the first streams buffer and returns &n;                         * the number of streams messages on the read queue as&n;                         * as its retval. (streamio(7I)) This should work.&n;                         */
id|j
op_assign
(paren
id|drv-&gt;input_count
OG
l_int|0
)paren
ques
c_cond
id|drv-&gt;input_buffer_size
suffix:colon
l_int|0
suffix:semicolon
id|COPY_OUT
c_func
(paren
id|arg
comma
id|j
)paren
suffix:semicolon
id|retval
op_assign
id|drv-&gt;input_count
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* A poor substitute until we do true resizable buffers. */
r_case
id|SNDCTL_DSP_GETISPACE
suffix:colon
id|binfo.fragstotal
op_assign
id|drv-&gt;num_input_buffers
suffix:semicolon
id|binfo.fragments
op_assign
id|drv-&gt;num_input_buffers
op_minus
(paren
id|drv-&gt;input_count
op_plus
id|drv-&gt;recording_count
)paren
suffix:semicolon
id|binfo.fragsize
op_assign
id|drv-&gt;input_buffer_size
suffix:semicolon
id|binfo.bytes
op_assign
id|binfo.fragments
op_star
id|binfo.fragsize
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|binfo
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_break
suffix:semicolon
id|copy_to_user
c_func
(paren
op_amp
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
(braket
l_int|0
)braket
comma
(paren
r_char
op_star
)paren
op_amp
id|binfo
comma
r_sizeof
(paren
id|binfo
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETOSPACE
suffix:colon
id|binfo.fragstotal
op_assign
id|drv-&gt;num_output_buffers
suffix:semicolon
id|binfo.fragments
op_assign
id|drv-&gt;num_output_buffers
op_minus
(paren
id|drv-&gt;output_count
op_plus
id|drv-&gt;playing_count
op_plus
(paren
id|drv-&gt;output_offset
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|binfo.fragsize
op_assign
id|drv-&gt;output_buffer_size
suffix:semicolon
id|binfo.bytes
op_assign
id|binfo.fragments
op_star
id|binfo.fragsize
op_plus
(paren
id|drv-&gt;output_buffer_size
op_minus
id|drv-&gt;output_offset
)paren
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|binfo
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_break
suffix:semicolon
id|copy_to_user
c_func
(paren
op_amp
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
(braket
l_int|0
)braket
comma
(paren
r_char
op_star
)paren
op_amp
id|binfo
comma
r_sizeof
(paren
id|binfo
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETIPTR
suffix:colon
r_case
id|SNDCTL_DSP_GETOPTR
suffix:colon
multiline_comment|/* int bytes (number of bytes read/written since last)&n;                         * int blocks (number of frags read/wrote since last call)&n;                         * int ptr (current position of dma in buffer)&n;                         */
id|retval
op_assign
l_int|0
suffix:semicolon
id|cinfo.bytes
op_assign
l_int|0
suffix:semicolon
id|cinfo.ptr
op_assign
l_int|0
suffix:semicolon
id|cinfo.blocks
op_assign
l_int|0
suffix:semicolon
id|cinfo.bytes
op_add_assign
id|cinfo.ptr
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_break
suffix:semicolon
id|copy_to_user
c_func
(paren
op_amp
(paren
(paren
r_char
op_star
)paren
id|arg
)paren
(braket
l_int|0
)braket
comma
(paren
r_char
op_star
)paren
op_amp
id|cinfo
comma
r_sizeof
(paren
id|cinfo
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFRAGMENT
suffix:colon
multiline_comment|/* XXX Small hack to get ESD/Enlightenment to work.  --DaveM */
id|retval
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SUBDIVIDE
suffix:colon
multiline_comment|/* I don&squot;t understand what I need to do yet. */
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETTRIGGER
suffix:colon
multiline_comment|/* This may not be 100% correct */
r_if
c_cond
(paren
(paren
id|arg
op_amp
id|PCM_ENABLE_INPUT
)paren
op_logical_and
id|drv-&gt;ops-&gt;get_input_pause
op_logical_and
id|drv-&gt;ops-&gt;set_input_pause
)paren
(brace
r_if
c_cond
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_pause
c_func
(paren
id|drv
)paren
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_pause
c_func
(paren
id|drv
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_pause
c_func
(paren
id|drv
)paren
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_pause
c_func
(paren
id|drv
comma
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|arg
op_amp
id|PCM_ENABLE_OUTPUT
)paren
op_logical_and
id|drv-&gt;ops-&gt;get_output_pause
op_logical_and
id|drv-&gt;ops-&gt;set_output_pause
)paren
(brace
r_if
c_cond
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_pause
c_func
(paren
id|drv
)paren
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_pause
c_func
(paren
id|drv
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_pause
c_func
(paren
id|drv
)paren
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_pause
c_func
(paren
id|drv
comma
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETTRIGGER
suffix:colon
id|j
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_pause
)paren
(brace
r_if
c_cond
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_pause
c_func
(paren
id|drv
)paren
)paren
id|j
op_assign
id|PCM_ENABLE_INPUT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_pause
)paren
(brace
r_if
c_cond
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_pause
c_func
(paren
id|drv
)paren
)paren
id|j
op_or_assign
id|PCM_ENABLE_OUTPUT
suffix:semicolon
)brace
id|COPY_OUT
c_func
(paren
id|arg
comma
id|j
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETBLKSIZE
suffix:colon
id|j
op_assign
id|drv-&gt;input_buffer_size
suffix:semicolon
id|COPY_OUT
c_func
(paren
id|arg
comma
id|j
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SPEED
suffix:colon
r_if
c_cond
(paren
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_output_rate
)paren
op_logical_and
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_input_rate
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|COPY_IN
c_func
(paren
id|arg
comma
id|i
)paren
suffix:semicolon
id|tprintk
c_func
(paren
(paren
l_string|&quot;setting speed to %d&bslash;n&quot;
comma
id|i
)paren
)paren
suffix:semicolon
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_rate
c_func
(paren
id|drv
comma
id|i
)paren
suffix:semicolon
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_rate
c_func
(paren
id|drv
comma
id|i
)paren
suffix:semicolon
id|j
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_rate
c_func
(paren
id|drv
)paren
suffix:semicolon
id|COPY_OUT
c_func
(paren
id|arg
comma
id|j
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETCAPS
suffix:colon
multiline_comment|/* All Sparc audio hardware is full duplex.&n;                         * 4231 supports DMA pointer reading, 7930 is byte at a time.&n;                         * Pause functionality emulates trigger&n;                         */
id|j
op_assign
id|DSP_CAP_DUPLEX
op_or
id|DSP_CAP_TRIGGER
op_or
id|DSP_CAP_REALTIME
suffix:semicolon
id|COPY_OUT
c_func
(paren
id|arg
comma
id|j
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_GETFMTS
suffix:colon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_formats
)paren
(brace
id|j
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_formats
c_func
(paren
id|drv
)paren
suffix:semicolon
id|COPY_OUT
c_func
(paren
id|arg
comma
id|j
)paren
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_SETFMT
suffix:colon
multiline_comment|/* need to decode into encoding, precision */
id|COPY_IN
c_func
(paren
id|arg
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* handle special case here */
r_if
c_cond
(paren
id|i
op_eq
id|AFMT_QUERY
)paren
(brace
id|j
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_encoding
c_func
(paren
id|drv
)paren
suffix:semicolon
id|k
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_precision
c_func
(paren
id|drv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
id|AUDIO_ENCODING_DVI
)paren
(brace
id|i
op_assign
id|AFMT_IMA_ADPCM
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|k
op_eq
l_int|8
)paren
(brace
r_switch
c_cond
(paren
id|j
)paren
(brace
r_case
id|AUDIO_ENCODING_ULAW
suffix:colon
id|i
op_assign
id|AFMT_MU_LAW
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIO_ENCODING_ALAW
suffix:colon
id|i
op_assign
id|AFMT_A_LAW
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIO_ENCODING_LINEAR8
suffix:colon
id|i
op_assign
id|AFMT_U8
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|k
op_eq
l_int|16
)paren
(brace
r_switch
c_cond
(paren
id|j
)paren
(brace
r_case
id|AUDIO_ENCODING_LINEAR
suffix:colon
id|i
op_assign
id|AFMT_S16_BE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIO_ENCODING_LINEARLE
suffix:colon
id|i
op_assign
id|AFMT_S16_LE
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
)brace
id|COPY_OUT
c_func
(paren
id|arg
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Without these there&squot;s no point in trying */
r_if
c_cond
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_input_precision
op_logical_or
op_logical_neg
id|drv-&gt;ops-&gt;set_input_encoding
op_logical_or
op_logical_neg
id|drv-&gt;ops-&gt;set_output_precision
op_logical_or
op_logical_neg
id|drv-&gt;ops-&gt;set_output_encoding
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;missing set routines: failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_formats
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|get_formats
c_func
(paren
id|drv
)paren
op_amp
id|i
)paren
)paren
(brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;format not supported&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|i
)paren
(brace
r_case
id|AFMT_S16_LE
suffix:colon
id|ainfo.record.precision
op_assign
id|ainfo.play.precision
op_assign
l_int|16
suffix:semicolon
id|ainfo.record.encoding
op_assign
id|ainfo.play.encoding
op_assign
id|AUDIO_ENCODING_LINEARLE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_S16_BE
suffix:colon
id|ainfo.record.precision
op_assign
id|ainfo.play.precision
op_assign
l_int|16
suffix:semicolon
id|ainfo.record.encoding
op_assign
id|ainfo.play.encoding
op_assign
id|AUDIO_ENCODING_LINEAR
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_MU_LAW
suffix:colon
id|ainfo.record.precision
op_assign
id|ainfo.play.precision
op_assign
l_int|8
suffix:semicolon
id|ainfo.record.encoding
op_assign
id|ainfo.play.encoding
op_assign
id|AUDIO_ENCODING_ULAW
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_A_LAW
suffix:colon
id|ainfo.record.precision
op_assign
id|ainfo.play.precision
op_assign
l_int|8
suffix:semicolon
id|ainfo.record.encoding
op_assign
id|ainfo.play.encoding
op_assign
id|AUDIO_ENCODING_ALAW
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFMT_U8
suffix:colon
id|ainfo.record.precision
op_assign
id|ainfo.play.precision
op_assign
l_int|8
suffix:semicolon
id|ainfo.record.encoding
op_assign
id|ainfo.play.encoding
op_assign
id|AUDIO_ENCODING_LINEAR8
suffix:semicolon
r_break
suffix:semicolon
)brace
suffix:semicolon
id|tprintk
c_func
(paren
(paren
l_string|&quot;setting fmt to enc %d pr %d&bslash;n&quot;
comma
id|ainfo.play.encoding
comma
id|ainfo.play.precision
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_precision
c_func
(paren
id|drv
comma
id|ainfo.record.precision
)paren
OL
l_int|0
)paren
op_logical_or
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_precision
c_func
(paren
id|drv
comma
id|ainfo.play.precision
)paren
OL
l_int|0
)paren
op_logical_or
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_encoding
c_func
(paren
id|drv
comma
id|ainfo.record.encoding
)paren
OL
l_int|0
)paren
op_logical_or
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_encoding
c_func
(paren
id|drv
comma
id|ainfo.play.encoding
)paren
OL
l_int|0
)paren
)paren
(brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;setting format: failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|COPY_OUT
c_func
(paren
id|arg
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_CHANNELS
suffix:colon
r_if
c_cond
(paren
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_output_channels
)paren
op_logical_and
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_input_channels
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|COPY_IN
c_func
(paren
id|arg
comma
id|i
)paren
suffix:semicolon
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_channels
c_func
(paren
id|drv
comma
id|i
)paren
suffix:semicolon
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_channels
c_func
(paren
id|drv
comma
id|i
)paren
suffix:semicolon
id|i
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_channels
c_func
(paren
id|drv
)paren
suffix:semicolon
id|COPY_OUT
c_func
(paren
id|arg
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_STEREO
suffix:colon
r_if
c_cond
(paren
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_output_channels
)paren
op_logical_and
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_input_channels
)paren
)paren
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|COPY_IN
c_func
(paren
id|arg
comma
id|i
)paren
suffix:semicolon
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_channels
c_func
(paren
id|drv
comma
(paren
id|i
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_channels
c_func
(paren
id|drv
comma
(paren
id|i
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|i
op_assign
(paren
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_channels
c_func
(paren
id|drv
)paren
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|COPY_OUT
c_func
(paren
id|arg
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_POST
suffix:colon
r_case
id|SNDCTL_DSP_SYNC
suffix:colon
r_case
id|AUDIO_DRAIN
suffix:colon
multiline_comment|/* Deal with weirdness so we can fill buffers */
r_if
c_cond
(paren
id|drv-&gt;output_offset
)paren
(brace
id|drv-&gt;output_offset
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_rear
op_assign
(paren
id|drv-&gt;output_rear
op_plus
l_int|1
)paren
op_mod
id|drv-&gt;num_output_buffers
suffix:semicolon
id|drv-&gt;output_count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drv-&gt;output_count
OG
l_int|0
)paren
(brace
id|sparcaudio_sync_output
c_func
(paren
id|drv
)paren
suffix:semicolon
multiline_comment|/* Only pause for DRAIN/SYNC, not POST */
r_if
c_cond
(paren
id|cmd
op_ne
id|SNDCTL_DSP_POST
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|drv-&gt;output_drain_wait
)paren
suffix:semicolon
id|retval
op_assign
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
ques
c_cond
op_minus
id|EINTR
suffix:colon
l_int|0
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|I_FLUSH
suffix:colon
r_case
id|I_FLUSH_SOLARIS
suffix:colon
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|arg
op_eq
id|FLUSHW
)paren
op_logical_or
(paren
(paren
r_int
r_int
)paren
id|arg
op_eq
id|FLUSHRW
)paren
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|sparcaudio_sync_output
c_func
(paren
id|drv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;output_active
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|drv-&gt;output_write_wait
)paren
suffix:semicolon
id|drv-&gt;ops
op_member_access_from_pointer
id|stop_output
c_func
(paren
id|drv
)paren
suffix:semicolon
)brace
id|drv-&gt;output_offset
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_active
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_front
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_rear
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_count
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_size
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;playing_count
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_eof
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|arg
op_eq
id|FLUSHR
)paren
op_logical_or
(paren
(paren
r_int
r_int
)paren
id|arg
op_eq
id|FLUSHRW
)paren
)paren
(brace
r_if
c_cond
(paren
id|drv-&gt;input_active
op_logical_and
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|drv-&gt;input_read_wait
)paren
suffix:semicolon
id|drv-&gt;ops
op_member_access_from_pointer
id|stop_input
c_func
(paren
id|drv
)paren
suffix:semicolon
id|drv-&gt;input_active
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_front
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_rear
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_count
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_size
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_offset
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;recording_count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
op_logical_and
(paren
id|drv-&gt;flags
op_amp
id|SDF_OPEN_READ
)paren
)paren
(brace
r_if
c_cond
(paren
id|drv-&gt;duplex
op_eq
l_int|2
)paren
id|drv-&gt;input_count
op_assign
id|drv-&gt;output_count
suffix:semicolon
id|drv-&gt;ops
op_member_access_from_pointer
id|start_input
c_func
(paren
id|drv
comma
id|drv-&gt;input_buffers
(braket
id|drv-&gt;input_front
)braket
comma
id|drv-&gt;input_buffer_size
)paren
suffix:semicolon
id|drv-&gt;input_active
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|arg
op_eq
id|FLUSHW
)paren
op_logical_or
(paren
(paren
r_int
r_int
)paren
id|arg
op_eq
id|FLUSHRW
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|drv-&gt;flags
op_amp
id|SDF_OPEN_WRITE
)paren
)paren
(brace
id|kill_procs
c_func
(paren
id|drv-&gt;sd_siglist
comma
id|SIGPOLL
comma
id|S_MSG
)paren
suffix:semicolon
id|sparcaudio_sync_output
c_func
(paren
id|drv
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|SNDCTL_DSP_RESET
suffix:colon
r_case
id|AUDIO_FLUSH
suffix:colon
r_if
c_cond
(paren
id|drv-&gt;output_active
op_logical_and
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|drv-&gt;output_write_wait
)paren
suffix:semicolon
id|drv-&gt;ops
op_member_access_from_pointer
id|stop_output
c_func
(paren
id|drv
)paren
suffix:semicolon
id|drv-&gt;output_active
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_front
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_rear
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_count
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_size
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;playing_count
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_offset
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_eof
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drv-&gt;input_active
op_logical_and
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
)paren
(brace
id|wake_up_interruptible
c_func
(paren
op_amp
id|drv-&gt;input_read_wait
)paren
suffix:semicolon
id|drv-&gt;ops
op_member_access_from_pointer
id|stop_input
c_func
(paren
id|drv
)paren
suffix:semicolon
id|drv-&gt;input_active
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_front
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_rear
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_count
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_size
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_offset
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;recording_count
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
op_logical_and
op_logical_neg
(paren
id|drv-&gt;flags
op_amp
id|SDF_OPEN_READ
)paren
)paren
(brace
id|drv-&gt;ops
op_member_access_from_pointer
id|start_input
c_func
(paren
id|drv
comma
id|drv-&gt;input_buffers
(braket
id|drv-&gt;input_front
)braket
comma
id|drv-&gt;input_buffer_size
)paren
suffix:semicolon
id|drv-&gt;input_active
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
op_logical_and
op_logical_neg
(paren
id|drv-&gt;flags
op_amp
id|SDF_OPEN_WRITE
)paren
)paren
(brace
id|sparcaudio_sync_output
c_func
(paren
id|drv
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AUDIO_GETDEV
suffix:colon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;sunaudio_getdev
)paren
(brace
id|audio_device_t
id|tmp
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|audio_device_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|sunaudio_getdev
c_func
(paren
id|drv
comma
op_amp
id|tmp
)paren
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
id|audio_device_t
op_star
)paren
id|arg
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AUDIO_GETDEV_SUNOS
suffix:colon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;sunaudio_getdev_sunos
)paren
(brace
r_int
id|tmp
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|sunaudio_getdev_sunos
c_func
(paren
id|drv
)paren
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|copy_to_user
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
comma
op_amp
id|tmp
comma
r_sizeof
(paren
id|tmp
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AUDIO_GETINFO
suffix:colon
id|AUDIO_INITINFO
c_func
(paren
op_amp
id|ainfo
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_rate
)paren
id|ainfo.record.sample_rate
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_rate
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.record.sample_rate
op_assign
(paren
l_int|8000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_channels
)paren
id|ainfo.record.channels
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_channels
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.record.channels
op_assign
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_precision
)paren
id|ainfo.record.precision
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_precision
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.record.precision
op_assign
(paren
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_encoding
)paren
id|ainfo.record.encoding
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_encoding
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.record.encoding
op_assign
(paren
id|AUDIO_ENCODING_ULAW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_volume
)paren
id|ainfo.record.gain
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_volume
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.record.gain
op_assign
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_port
)paren
id|ainfo.record.port
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_port
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.record.port
op_assign
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_ports
)paren
id|ainfo.record.avail_ports
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_ports
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.record.avail_ports
op_assign
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* To make e.g. vat happy, we let them think they control this */
id|ainfo.record.buffer_size
op_assign
id|drv-&gt;buffer_size
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_samples
)paren
id|ainfo.record.samples
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_samples
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.record.samples
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This is undefined in the record context in Solaris */
id|ainfo.record.eof
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_pause
)paren
id|ainfo.record.pause
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_pause
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.record.pause
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_error
)paren
id|ainfo.record.error
op_assign
(paren
r_int
r_char
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_error
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.record.error
op_assign
l_int|0
suffix:semicolon
id|ainfo.record.waiting
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_balance
)paren
id|ainfo.record.balance
op_assign
(paren
r_int
r_char
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_balance
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.record.balance
op_assign
(paren
r_int
r_char
)paren
(paren
id|AUDIO_MID_BALANCE
)paren
suffix:semicolon
id|ainfo.record.minordev
op_assign
l_int|4
op_plus
(paren
id|minor
op_lshift
id|SPARCAUDIO_DEVICE_SHIFT
)paren
suffix:semicolon
id|ainfo.record.open
op_assign
(paren
id|drv-&gt;flags
op_amp
id|SDF_OPEN_READ
)paren
suffix:semicolon
id|ainfo.record.active
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_rate
)paren
id|ainfo.play.sample_rate
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_rate
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.play.sample_rate
op_assign
(paren
l_int|8000
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_channels
)paren
id|ainfo.play.channels
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_channels
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.play.channels
op_assign
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_precision
)paren
id|ainfo.play.precision
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_precision
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.play.precision
op_assign
(paren
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_encoding
)paren
id|ainfo.play.encoding
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_encoding
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.play.encoding
op_assign
(paren
id|AUDIO_ENCODING_ULAW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_volume
)paren
id|ainfo.play.gain
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_volume
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.play.gain
op_assign
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_port
)paren
id|ainfo.play.port
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_port
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.play.port
op_assign
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_ports
)paren
id|ainfo.play.avail_ports
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_ports
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.play.avail_ports
op_assign
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* This is not defined in the play context in Solaris */
id|ainfo.play.buffer_size
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_samples
)paren
id|ainfo.play.samples
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_samples
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.play.samples
op_assign
l_int|0
suffix:semicolon
id|ainfo.play.eof
op_assign
id|drv-&gt;output_eof
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_pause
)paren
id|ainfo.play.pause
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_pause
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.play.pause
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_error
)paren
id|ainfo.play.error
op_assign
(paren
r_int
r_char
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_error
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.play.error
op_assign
l_int|0
suffix:semicolon
id|ainfo.play.waiting
op_assign
id|waitqueue_active
c_func
(paren
op_amp
id|drv-&gt;open_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_balance
)paren
id|ainfo.play.balance
op_assign
(paren
r_int
r_char
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_balance
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.play.balance
op_assign
(paren
r_int
r_char
)paren
(paren
id|AUDIO_MID_BALANCE
)paren
suffix:semicolon
id|ainfo.play.minordev
op_assign
l_int|4
op_plus
(paren
id|minor
op_lshift
id|SPARCAUDIO_DEVICE_SHIFT
)paren
suffix:semicolon
id|ainfo.play.open
op_assign
(paren
id|drv-&gt;flags
op_amp
id|SDF_OPEN_WRITE
)paren
suffix:semicolon
id|ainfo.play.active
op_assign
id|drv-&gt;output_active
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_monitor_volume
)paren
id|ainfo.monitor_gain
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_monitor_volume
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.monitor_gain
op_assign
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_muted
)paren
id|ainfo.output_muted
op_assign
(paren
r_int
r_char
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_muted
c_func
(paren
id|drv
)paren
suffix:semicolon
r_else
id|ainfo.output_muted
op_assign
(paren
r_int
r_char
)paren
(paren
l_int|0
)paren
suffix:semicolon
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|audio_info
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_break
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_struct
id|audio_info
op_star
)paren
id|arg
comma
op_amp
id|ainfo
comma
r_sizeof
(paren
id|ainfo
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AUDIO_SETINFO
suffix:colon
(brace
id|audio_info_t
id|curinfo
comma
id|newinfo
suffix:semicolon
r_if
c_cond
(paren
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
id|audio_info_t
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|audio_info_t
)paren
)paren
)paren
(brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;verify_area failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|copy_from_user
c_func
(paren
op_amp
id|ainfo
comma
(paren
id|audio_info_t
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|audio_info_t
)paren
)paren
suffix:semicolon
multiline_comment|/* Without these there&squot;s no point in trying */
r_if
c_cond
(paren
op_logical_neg
id|drv-&gt;ops-&gt;get_input_precision
op_logical_or
op_logical_neg
id|drv-&gt;ops-&gt;get_input_channels
op_logical_or
op_logical_neg
id|drv-&gt;ops-&gt;get_input_rate
op_logical_or
op_logical_neg
id|drv-&gt;ops-&gt;get_input_encoding
op_logical_or
op_logical_neg
id|drv-&gt;ops-&gt;get_output_precision
op_logical_or
op_logical_neg
id|drv-&gt;ops-&gt;get_output_channels
op_logical_or
op_logical_neg
id|drv-&gt;ops-&gt;get_output_rate
op_logical_or
op_logical_neg
id|drv-&gt;ops-&gt;get_output_encoding
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;missing get routines: failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Do bounds checking for things which always apply.&n;                         * Follow with enforcement of basic tenets of certain&n;                         * encodings. Everything over and above generic is&n;                         * enforced by the driver, which can assume that&n;                         * Martian cases are taken care of here.&n;                         */
r_if
c_cond
(paren
id|Modify
c_func
(paren
id|ainfo.play.gain
)paren
op_logical_and
(paren
(paren
id|ainfo.play.gain
OG
id|AUDIO_MAX_GAIN
)paren
op_logical_or
(paren
id|ainfo.play.gain
OL
id|AUDIO_MIN_GAIN
)paren
)paren
)paren
(brace
multiline_comment|/* Need to differentiate this from e.g. the above error */
id|eprintk
c_func
(paren
(paren
l_string|&quot;play gain bounds: failed %d&bslash;n&quot;
comma
id|ainfo.play.gain
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Modify
c_func
(paren
id|ainfo.record.gain
)paren
op_logical_and
(paren
(paren
id|ainfo.record.gain
OG
id|AUDIO_MAX_GAIN
)paren
op_logical_or
(paren
id|ainfo.record.gain
OL
id|AUDIO_MIN_GAIN
)paren
)paren
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;rec gain bounds: failed %d&bslash;n&quot;
comma
id|ainfo.record.gain
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Modify
c_func
(paren
id|ainfo.monitor_gain
)paren
op_logical_and
(paren
(paren
id|ainfo.monitor_gain
OG
id|AUDIO_MAX_GAIN
)paren
op_logical_or
(paren
id|ainfo.monitor_gain
OL
id|AUDIO_MIN_GAIN
)paren
)paren
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;monitor gain bounds: failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t need to check less than zero on these */
r_if
c_cond
(paren
id|Modifyc
c_func
(paren
id|ainfo.play.balance
)paren
op_logical_and
(paren
id|ainfo.play.balance
OG
id|AUDIO_RIGHT_BALANCE
)paren
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;play balance bounds: %d failed&bslash;n&quot;
comma
(paren
r_int
)paren
id|ainfo.play.balance
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Modifyc
c_func
(paren
id|ainfo.record.balance
)paren
op_logical_and
(paren
id|ainfo.record.balance
OG
id|AUDIO_RIGHT_BALANCE
)paren
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;rec balance bounds: failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* If any of these changed, record them all, then make&n;                         * changes atomically. If something fails, back it all out.&n;                         */
r_if
c_cond
(paren
id|Modify
c_func
(paren
id|ainfo.record.precision
)paren
op_logical_or
id|Modify
c_func
(paren
id|ainfo.record.sample_rate
)paren
op_logical_or
id|Modify
c_func
(paren
id|ainfo.record.channels
)paren
op_logical_or
id|Modify
c_func
(paren
id|ainfo.record.encoding
)paren
op_logical_or
id|Modify
c_func
(paren
id|ainfo.play.precision
)paren
op_logical_or
id|Modify
c_func
(paren
id|ainfo.play.sample_rate
)paren
op_logical_or
id|Modify
c_func
(paren
id|ainfo.play.channels
)paren
op_logical_or
id|Modify
c_func
(paren
id|ainfo.play.encoding
)paren
)paren
(brace
multiline_comment|/* If they&squot;re trying to change something we&n;                                 * have no routine for, they lose.&n;                                 */
r_if
c_cond
(paren
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_input_encoding
op_logical_and
id|Modify
c_func
(paren
id|ainfo.record.encoding
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_input_rate
op_logical_and
id|Modify
c_func
(paren
id|ainfo.record.sample_rate
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_input_precision
op_logical_and
id|Modify
c_func
(paren
id|ainfo.record.precision
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_input_channels
op_logical_and
id|Modify
c_func
(paren
id|ainfo.record.channels
)paren
)paren
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;rec set no routines: failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|curinfo.record.encoding
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_encoding
c_func
(paren
id|drv
)paren
suffix:semicolon
id|curinfo.record.sample_rate
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_rate
c_func
(paren
id|drv
)paren
suffix:semicolon
id|curinfo.record.precision
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_precision
c_func
(paren
id|drv
)paren
suffix:semicolon
id|curinfo.record.channels
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_channels
c_func
(paren
id|drv
)paren
suffix:semicolon
id|newinfo.record.encoding
op_assign
id|Modify
c_func
(paren
id|ainfo.record.encoding
)paren
ques
c_cond
id|ainfo.record.encoding
suffix:colon
id|curinfo.record.encoding
suffix:semicolon
id|newinfo.record.sample_rate
op_assign
id|Modify
c_func
(paren
id|ainfo.record.sample_rate
)paren
ques
c_cond
id|ainfo.record.sample_rate
suffix:colon
id|curinfo.record.sample_rate
suffix:semicolon
id|newinfo.record.precision
op_assign
id|Modify
c_func
(paren
id|ainfo.record.precision
)paren
ques
c_cond
id|ainfo.record.precision
suffix:colon
id|curinfo.record.precision
suffix:semicolon
id|newinfo.record.channels
op_assign
id|Modify
c_func
(paren
id|ainfo.record.channels
)paren
ques
c_cond
id|ainfo.record.channels
suffix:colon
id|curinfo.record.channels
suffix:semicolon
r_switch
c_cond
(paren
id|newinfo.record.encoding
)paren
(brace
r_case
id|AUDIO_ENCODING_ALAW
suffix:colon
r_case
id|AUDIO_ENCODING_ULAW
suffix:colon
r_if
c_cond
(paren
id|newinfo.record.precision
op_ne
l_int|8
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;rec law precision bounds: &quot;
l_string|&quot;failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newinfo.record.channels
op_ne
l_int|1
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;rec law channel bounds: &quot;
l_string|&quot;failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AUDIO_ENCODING_LINEAR
suffix:colon
r_case
id|AUDIO_ENCODING_LINEARLE
suffix:colon
r_if
c_cond
(paren
id|newinfo.record.precision
op_ne
l_int|16
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;rec lin precision bounds: &quot;
l_string|&quot;failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newinfo.record.channels
op_ne
l_int|1
op_logical_and
id|newinfo.record.channels
op_ne
l_int|2
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;rec lin channel bounds: &quot;
l_string|&quot;failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AUDIO_ENCODING_LINEAR8
suffix:colon
r_if
c_cond
(paren
id|newinfo.record.precision
op_ne
l_int|8
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;rec lin8 precision bounds: &quot;
l_string|&quot;failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newinfo.record.channels
op_ne
l_int|1
op_logical_and
id|newinfo.record.channels
op_ne
l_int|2
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;rec lin8 channel bounds: &quot;
l_string|&quot;failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* If they&squot;re trying to change something we&n;                                 * have no routine for, they lose.&n;                                 */
r_if
c_cond
(paren
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_output_encoding
op_logical_and
id|Modify
c_func
(paren
id|ainfo.play.encoding
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_output_rate
op_logical_and
id|Modify
c_func
(paren
id|ainfo.play.sample_rate
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_output_precision
op_logical_and
id|Modify
c_func
(paren
id|ainfo.play.precision
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|drv-&gt;ops-&gt;set_output_channels
op_logical_and
id|Modify
c_func
(paren
id|ainfo.play.channels
)paren
)paren
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;play set no routine: failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
id|curinfo.play.encoding
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_encoding
c_func
(paren
id|drv
)paren
suffix:semicolon
id|curinfo.play.sample_rate
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_rate
c_func
(paren
id|drv
)paren
suffix:semicolon
id|curinfo.play.precision
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_precision
c_func
(paren
id|drv
)paren
suffix:semicolon
id|curinfo.play.channels
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_channels
c_func
(paren
id|drv
)paren
suffix:semicolon
id|newinfo.play.encoding
op_assign
id|Modify
c_func
(paren
id|ainfo.play.encoding
)paren
ques
c_cond
id|ainfo.play.encoding
suffix:colon
id|curinfo.play.encoding
suffix:semicolon
id|newinfo.play.sample_rate
op_assign
id|Modify
c_func
(paren
id|ainfo.play.sample_rate
)paren
ques
c_cond
id|ainfo.play.sample_rate
suffix:colon
id|curinfo.play.sample_rate
suffix:semicolon
id|newinfo.play.precision
op_assign
id|Modify
c_func
(paren
id|ainfo.play.precision
)paren
ques
c_cond
id|ainfo.play.precision
suffix:colon
id|curinfo.play.precision
suffix:semicolon
id|newinfo.play.channels
op_assign
id|Modify
c_func
(paren
id|ainfo.play.channels
)paren
ques
c_cond
id|ainfo.play.channels
suffix:colon
id|curinfo.play.channels
suffix:semicolon
r_switch
c_cond
(paren
id|newinfo.play.encoding
)paren
(brace
r_case
id|AUDIO_ENCODING_ALAW
suffix:colon
r_case
id|AUDIO_ENCODING_ULAW
suffix:colon
r_if
c_cond
(paren
id|newinfo.play.precision
op_ne
l_int|8
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;play law precision bounds: &quot;
l_string|&quot;failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newinfo.play.channels
op_ne
l_int|1
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;play law channel bounds: &quot;
l_string|&quot;failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AUDIO_ENCODING_LINEAR
suffix:colon
r_case
id|AUDIO_ENCODING_LINEARLE
suffix:colon
r_if
c_cond
(paren
id|newinfo.play.precision
op_ne
l_int|16
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;play lin precision bounds: &quot;
l_string|&quot;failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newinfo.play.channels
op_ne
l_int|1
op_logical_and
id|newinfo.play.channels
op_ne
l_int|2
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;play lin channel bounds: &quot;
l_string|&quot;failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AUDIO_ENCODING_LINEAR8
suffix:colon
r_if
c_cond
(paren
id|newinfo.play.precision
op_ne
l_int|8
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;play lin8 precision bounds: &quot;
l_string|&quot;failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|newinfo.play.channels
op_ne
l_int|1
op_logical_and
id|newinfo.play.channels
op_ne
l_int|2
)paren
(brace
id|eprintk
c_func
(paren
(paren
l_string|&quot;play lin8 channel bounds: &quot;
l_string|&quot;failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* If we got this far, we&squot;re at least sane with&n;                                 * respect to generics. Try the changes.&n;                                 */
r_if
c_cond
(paren
(paren
id|drv-&gt;ops-&gt;set_input_channels
op_logical_and
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_channels
c_func
(paren
id|drv
comma
id|newinfo.record.channels
)paren
OL
l_int|0
)paren
)paren
op_logical_or
(paren
id|drv-&gt;ops-&gt;set_output_channels
op_logical_and
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_channels
c_func
(paren
id|drv
comma
id|newinfo.play.channels
)paren
OL
l_int|0
)paren
)paren
op_logical_or
(paren
id|drv-&gt;ops-&gt;set_input_rate
op_logical_and
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_rate
c_func
(paren
id|drv
comma
id|newinfo.record.sample_rate
)paren
OL
l_int|0
)paren
)paren
op_logical_or
(paren
id|drv-&gt;ops-&gt;set_output_rate
op_logical_and
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_rate
c_func
(paren
id|drv
comma
id|newinfo.play.sample_rate
)paren
OL
l_int|0
)paren
)paren
op_logical_or
(paren
id|drv-&gt;ops-&gt;set_input_precision
op_logical_and
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_precision
c_func
(paren
id|drv
comma
id|newinfo.record.precision
)paren
OL
l_int|0
)paren
)paren
op_logical_or
(paren
id|drv-&gt;ops-&gt;set_output_precision
op_logical_and
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_precision
c_func
(paren
id|drv
comma
id|newinfo.play.precision
)paren
OL
l_int|0
)paren
)paren
op_logical_or
(paren
id|drv-&gt;ops-&gt;set_input_encoding
op_logical_and
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_encoding
c_func
(paren
id|drv
comma
id|newinfo.record.encoding
)paren
OL
l_int|0
)paren
)paren
op_logical_or
(paren
id|drv-&gt;ops-&gt;set_output_encoding
op_logical_and
(paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_encoding
c_func
(paren
id|drv
comma
id|newinfo.play.encoding
)paren
OL
l_int|0
)paren
)paren
)paren
(brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;setting format: failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Pray we can set it all back. If not, uh... */
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_input_channels
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_channels
c_func
(paren
id|drv
comma
id|curinfo.record.channels
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_output_channels
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_channels
c_func
(paren
id|drv
comma
id|curinfo.play.channels
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_input_rate
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_rate
c_func
(paren
id|drv
comma
id|curinfo.record.sample_rate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_output_rate
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_rate
c_func
(paren
id|drv
comma
id|curinfo.play.sample_rate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_input_precision
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_precision
c_func
(paren
id|drv
comma
id|curinfo.record.precision
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_output_precision
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_precision
c_func
(paren
id|drv
comma
id|curinfo.play.precision
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_input_encoding
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_encoding
c_func
(paren
id|drv
comma
id|curinfo.record.encoding
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_output_encoding
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_encoding
c_func
(paren
id|drv
comma
id|curinfo.play.encoding
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_break
suffix:semicolon
id|newinfo.record.balance
op_assign
id|__sparcaudio_if_setc_do
c_func
(paren
id|drv
comma
id|drv-&gt;ops-&gt;set_input_balance
comma
id|drv-&gt;ops-&gt;get_input_balance
comma
id|ainfo.record.balance
)paren
suffix:semicolon
id|newinfo.play.balance
op_assign
id|__sparcaudio_if_setc_do
c_func
(paren
id|drv
comma
id|drv-&gt;ops-&gt;set_output_balance
comma
id|drv-&gt;ops-&gt;get_output_balance
comma
id|ainfo.play.balance
)paren
suffix:semicolon
id|newinfo.record.error
op_assign
id|__sparcaudio_if_setc_do
c_func
(paren
id|drv
comma
id|drv-&gt;ops-&gt;set_input_error
comma
id|drv-&gt;ops-&gt;get_input_error
comma
id|ainfo.record.error
)paren
suffix:semicolon
id|newinfo.play.error
op_assign
id|__sparcaudio_if_setc_do
c_func
(paren
id|drv
comma
id|drv-&gt;ops-&gt;set_output_error
comma
id|drv-&gt;ops-&gt;get_output_error
comma
id|ainfo.play.error
)paren
suffix:semicolon
id|newinfo.output_muted
op_assign
id|__sparcaudio_if_setc_do
c_func
(paren
id|drv
comma
id|drv-&gt;ops-&gt;set_output_muted
comma
id|drv-&gt;ops-&gt;get_output_muted
comma
id|ainfo.output_muted
)paren
suffix:semicolon
id|newinfo.record.gain
op_assign
id|__sparcaudio_if_set_do
c_func
(paren
id|drv
comma
id|drv-&gt;ops-&gt;set_input_volume
comma
id|drv-&gt;ops-&gt;get_input_volume
comma
id|ainfo.record.gain
)paren
suffix:semicolon
id|newinfo.play.gain
op_assign
id|__sparcaudio_if_set_do
c_func
(paren
id|drv
comma
id|drv-&gt;ops-&gt;set_output_volume
comma
id|drv-&gt;ops-&gt;get_output_volume
comma
id|ainfo.play.gain
)paren
suffix:semicolon
id|newinfo.record.port
op_assign
id|__sparcaudio_if_set_do
c_func
(paren
id|drv
comma
id|drv-&gt;ops-&gt;set_input_port
comma
id|drv-&gt;ops-&gt;get_input_port
comma
id|ainfo.record.port
)paren
suffix:semicolon
id|newinfo.play.port
op_assign
id|__sparcaudio_if_set_do
c_func
(paren
id|drv
comma
id|drv-&gt;ops-&gt;set_output_port
comma
id|drv-&gt;ops-&gt;get_output_port
comma
id|ainfo.play.port
)paren
suffix:semicolon
id|newinfo.record.samples
op_assign
id|__sparcaudio_if_set_do
c_func
(paren
id|drv
comma
id|drv-&gt;ops-&gt;set_input_samples
comma
id|drv-&gt;ops-&gt;get_input_samples
comma
id|ainfo.record.samples
)paren
suffix:semicolon
id|newinfo.play.samples
op_assign
id|__sparcaudio_if_set_do
c_func
(paren
id|drv
comma
id|drv-&gt;ops-&gt;set_output_samples
comma
id|drv-&gt;ops-&gt;get_output_samples
comma
id|ainfo.play.samples
)paren
suffix:semicolon
id|newinfo.monitor_gain
op_assign
id|__sparcaudio_if_set_do
c_func
(paren
id|drv
comma
id|drv-&gt;ops-&gt;set_monitor_volume
comma
id|drv-&gt;ops-&gt;get_monitor_volume
comma
id|ainfo.monitor_gain
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Modify
c_func
(paren
id|ainfo.record.buffer_size
)paren
)paren
(brace
multiline_comment|/* Should sanity check this */
id|newinfo.record.buffer_size
op_assign
id|ainfo.record.buffer_size
suffix:semicolon
id|drv-&gt;buffer_size
op_assign
id|ainfo.record.buffer_size
suffix:semicolon
)brace
r_else
(brace
id|newinfo.record.buffer_size
op_assign
id|drv-&gt;buffer_size
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Modify
c_func
(paren
id|ainfo.play.eof
)paren
)paren
(brace
id|ainfo.play.eof
op_assign
id|newinfo.play.eof
suffix:semicolon
id|newinfo.play.eof
op_assign
id|drv-&gt;output_eof
suffix:semicolon
id|drv-&gt;output_eof
op_assign
id|ainfo.play.eof
suffix:semicolon
)brace
r_else
(brace
id|newinfo.play.eof
op_assign
id|drv-&gt;output_eof
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drv-&gt;flags
op_amp
id|SDF_OPEN_READ
)paren
(brace
id|newinfo.record.pause
op_assign
id|__sparcaudio_if_setc_do
c_func
(paren
id|drv
comma
id|drv-&gt;ops-&gt;set_input_pause
comma
id|drv-&gt;ops-&gt;get_input_pause
comma
id|ainfo.record.pause
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_input_pause
)paren
(brace
id|newinfo.record.pause
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_input_pause
c_func
(paren
id|drv
)paren
suffix:semicolon
)brace
r_else
(brace
id|newinfo.record.pause
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drv-&gt;flags
op_amp
id|SDF_OPEN_WRITE
)paren
(brace
id|newinfo.play.pause
op_assign
id|__sparcaudio_if_setc_do
c_func
(paren
id|drv
comma
id|drv-&gt;ops-&gt;set_output_pause
comma
id|drv-&gt;ops-&gt;get_output_pause
comma
id|ainfo.play.pause
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;get_output_pause
)paren
(brace
id|newinfo.play.pause
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|get_output_pause
c_func
(paren
id|drv
)paren
suffix:semicolon
)brace
r_else
(brace
id|newinfo.play.pause
op_assign
l_int|0
suffix:semicolon
)brace
id|retval
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|audio_info
)paren
)paren
suffix:semicolon
multiline_comment|/* Even if we fail, if we made changes let&squot;s try notification */
r_if
c_cond
(paren
op_logical_neg
id|retval
)paren
id|copy_to_user
c_func
(paren
(paren
r_struct
id|audio_info
op_star
)paren
id|arg
comma
op_amp
id|newinfo
comma
r_sizeof
(paren
id|newinfo
)paren
)paren
suffix:semicolon
macro_line|#ifdef REAL_AUDIO_SIGNALS
id|kill_procs
c_func
(paren
id|drv-&gt;sd_siglist
comma
id|SIGPOLL
comma
id|S_MSG
)paren
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
)brace
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;ioctl
)paren
id|retval
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|ioctl
c_func
(paren
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
comma
id|drv
)paren
suffix:semicolon
r_else
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPARCAUDIO_STATUS_MINOR
suffix:colon
id|eprintk
c_func
(paren
(paren
l_string|&quot;status minor not yet implemented&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
r_default
suffix:colon
id|eprintk
c_func
(paren
(paren
l_string|&quot;unknown minor device number&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|retval
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|sparcaudioctl_fops
r_static
r_struct
id|file_operations
id|sparcaudioctl_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|poll
suffix:colon
id|sparcaudio_select
comma
id|ioctl
suffix:colon
id|sparcaudio_ioctl
comma
)brace
suffix:semicolon
DECL|function|sparcaudio_open
r_static
r_int
id|sparcaudio_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|sparcaudio_driver
op_star
id|drv
op_assign
id|drivers
(braket
(paren
id|minor
op_rshift
id|SPARCAUDIO_DEVICE_SHIFT
)paren
)braket
suffix:semicolon
r_int
id|err
suffix:semicolon
multiline_comment|/* A low-level audio driver must exist. */
r_if
c_cond
(paren
op_logical_neg
id|drv
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#ifdef S_ZERO_WR
multiline_comment|/* This is how 2.0 ended up dealing with 0 len writes */
id|inode-&gt;i_flags
op_or_assign
id|S_ZERO_WR
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|minor
op_amp
l_int|0xf
)paren
(brace
r_case
id|SPARCAUDIO_AUDIOCTL_MINOR
suffix:colon
id|file-&gt;f_op
op_assign
op_amp
id|sparcaudioctl_fops
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPARCAUDIO_DSP16_MINOR
suffix:colon
r_case
id|SPARCAUDIO_DSP_MINOR
suffix:colon
r_case
id|SPARCAUDIO_AUDIO_MINOR
suffix:colon
multiline_comment|/* If the driver is busy, then wait to get through. */
id|retry_open
suffix:colon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
op_logical_and
id|drv-&gt;flags
op_amp
id|SDF_OPEN_READ
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* If something is now waiting, signal control device */
id|kill_procs
c_func
(paren
id|drv-&gt;sd_siglist
comma
id|SIGPOLL
comma
id|S_MSG
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|drv-&gt;open_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
r_goto
id|retry_open
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
op_logical_and
id|drv-&gt;flags
op_amp
id|SDF_OPEN_WRITE
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_flags
op_amp
id|O_NONBLOCK
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* If something is now waiting, signal control device */
id|kill_procs
c_func
(paren
id|drv-&gt;sd_siglist
comma
id|SIGPOLL
comma
id|S_MSG
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|drv-&gt;open_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|EINTR
suffix:semicolon
r_goto
id|retry_open
suffix:semicolon
)brace
multiline_comment|/* Allow the low-level driver to initialize itself. */
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;open
)paren
(brace
id|err
op_assign
id|drv-&gt;ops
op_member_access_from_pointer
id|open
c_func
(paren
id|inode
comma
id|file
comma
id|drv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
OL
l_int|0
)paren
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/* Mark the driver as locked for read and/or write. */
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
id|drv-&gt;input_offset
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_front
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_rear
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_count
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_size
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;recording_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear pause */
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_input_pause
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_pause
c_func
(paren
id|drv
comma
l_int|0
)paren
suffix:semicolon
id|drv-&gt;ops
op_member_access_from_pointer
id|start_input
c_func
(paren
id|drv
comma
id|drv-&gt;input_buffers
(braket
id|drv-&gt;input_front
)braket
comma
id|drv-&gt;input_buffer_size
)paren
suffix:semicolon
id|drv-&gt;input_active
op_assign
l_int|1
suffix:semicolon
id|drv-&gt;flags
op_or_assign
id|SDF_OPEN_READ
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
id|drv-&gt;output_offset
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_eof
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;playing_count
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_size
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_front
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_rear
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_count
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_active
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Clear pause */
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_output_pause
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_pause
c_func
(paren
id|drv
comma
l_int|0
)paren
suffix:semicolon
id|drv-&gt;flags
op_or_assign
id|SDF_OPEN_WRITE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|SPARCAUDIO_MIXER_MINOR
suffix:colon
id|file-&gt;f_op
op_assign
op_amp
id|sparcaudioctl_fops
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* From the dbri driver:&n;         * SunOS 5.5.1 audio(7I) man page says:&n;         * &quot;Upon the initial open() of the audio device, the driver&n;         *  will reset the data format of the device to the default&n;         *  state of 8-bit, 8KHz, mono u-law data.&quot;&n;         *&n;         * Of course, we only do this for /dev/audio, and assume&n;         * OSS semantics on /dev/dsp&n;         */
r_if
c_cond
(paren
(paren
id|minor
op_amp
l_int|0xf
)paren
op_eq
id|SPARCAUDIO_AUDIO_MINOR
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_output_channels
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_channels
c_func
(paren
id|drv
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_output_encoding
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_encoding
c_func
(paren
id|drv
comma
id|AUDIO_ENCODING_ULAW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_output_rate
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_output_rate
c_func
(paren
id|drv
comma
l_int|8000
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_input_channels
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_channels
c_func
(paren
id|drv
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_input_encoding
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_encoding
c_func
(paren
id|drv
comma
id|AUDIO_ENCODING_ULAW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;set_input_rate
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|set_input_rate
c_func
(paren
id|drv
comma
l_int|8000
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Success! */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sparcaudio_release
r_static
r_int
id|sparcaudio_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_struct
id|sparcaudio_driver
op_star
id|drv
op_assign
id|drivers
(braket
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
id|SPARCAUDIO_DEVICE_SHIFT
)paren
)braket
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
(brace
multiline_comment|/* Stop input */
id|drv-&gt;ops
op_member_access_from_pointer
id|stop_input
c_func
(paren
id|drv
)paren
suffix:semicolon
id|drv-&gt;input_active
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
(brace
multiline_comment|/* Anything in the queue? */
r_if
c_cond
(paren
id|drv-&gt;output_offset
)paren
(brace
id|drv-&gt;output_offset
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_rear
op_assign
(paren
id|drv-&gt;output_rear
op_plus
l_int|1
)paren
op_mod
id|drv-&gt;num_output_buffers
suffix:semicolon
id|drv-&gt;output_count
op_increment
suffix:semicolon
)brace
id|sparcaudio_sync_output
c_func
(paren
id|drv
)paren
suffix:semicolon
multiline_comment|/* Wait for any output still in the queue to be played. */
r_if
c_cond
(paren
(paren
id|drv-&gt;output_count
OG
l_int|0
)paren
op_logical_or
(paren
id|drv-&gt;playing_count
OG
l_int|0
)paren
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
id|drv-&gt;output_drain_wait
)paren
suffix:semicolon
multiline_comment|/* Force any output to be stopped. */
id|drv-&gt;ops
op_member_access_from_pointer
id|stop_output
c_func
(paren
id|drv
)paren
suffix:semicolon
id|drv-&gt;output_active
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;playing_count
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_eof
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Let the low-level driver do any release processing. */
r_if
c_cond
(paren
id|drv-&gt;ops-&gt;release
)paren
id|drv-&gt;ops
op_member_access_from_pointer
id|release
c_func
(paren
id|inode
comma
id|file
comma
id|drv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_READ
)paren
id|drv-&gt;flags
op_and_assign
op_complement
(paren
id|SDF_OPEN_READ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
id|drv-&gt;flags
op_and_assign
op_complement
(paren
id|SDF_OPEN_WRITE
)paren
suffix:semicolon
multiline_comment|/* Status changed. Signal control device */
id|kill_procs
c_func
(paren
id|drv-&gt;sd_siglist
comma
id|SIGPOLL
comma
id|S_MSG
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|drv-&gt;open_wait
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|sparcaudio_fops
r_static
r_struct
id|file_operations
id|sparcaudio_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|llseek
suffix:colon
id|sparcaudio_lseek
comma
id|read
suffix:colon
id|sparcaudio_read
comma
id|write
suffix:colon
id|sparcaudio_write
comma
id|poll
suffix:colon
id|sparcaudio_select
comma
id|ioctl
suffix:colon
id|sparcaudio_ioctl
comma
id|open
suffix:colon
id|sparcaudio_open
comma
id|release
suffix:colon
id|sparcaudio_release
comma
)brace
suffix:semicolon
r_static
r_struct
(brace
DECL|member|minor
r_int
r_int
id|minor
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|mode
id|umode_t
id|mode
suffix:semicolon
DECL|variable|dev_list
)brace
id|dev_list
(braket
)braket
op_assign
(brace
(brace
id|SPARCAUDIO_MIXER_MINOR
comma
l_string|&quot;mixer&quot;
comma
id|S_IWUSR
op_or
id|S_IRUGO
)brace
comma
(brace
id|SPARCAUDIO_DSP_MINOR
comma
l_string|&quot;dsp&quot;
comma
id|S_IWUGO
op_or
id|S_IRUSR
op_or
id|S_IRGRP
)brace
comma
(brace
id|SPARCAUDIO_AUDIO_MINOR
comma
l_string|&quot;audio&quot;
comma
id|S_IWUGO
op_or
id|S_IRUSR
op_or
id|S_IRGRP
)brace
comma
(brace
id|SPARCAUDIO_DSP16_MINOR
comma
l_string|&quot;dspW&quot;
comma
id|S_IWUGO
op_or
id|S_IRUSR
op_or
id|S_IRGRP
)brace
comma
(brace
id|SPARCAUDIO_STATUS_MINOR
comma
l_string|&quot;status&quot;
comma
id|S_IRUGO
)brace
comma
(brace
id|SPARCAUDIO_AUDIOCTL_MINOR
comma
l_string|&quot;audioctl&quot;
comma
id|S_IRUGO
)brace
)brace
suffix:semicolon
DECL|function|sparcaudio_mkname
r_static
r_void
id|sparcaudio_mkname
(paren
r_char
op_star
id|buf
comma
r_char
op_star
id|name
comma
r_int
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev
)paren
id|sprintf
(paren
id|buf
comma
l_string|&quot;%s%d&quot;
comma
id|name
comma
id|dev
)paren
suffix:semicolon
r_else
id|sprintf
(paren
id|buf
comma
l_string|&quot;%s&quot;
comma
id|name
)paren
suffix:semicolon
)brace
DECL|function|register_sparcaudio_driver
r_int
id|register_sparcaudio_driver
c_func
(paren
r_struct
id|sparcaudio_driver
op_star
id|drv
comma
r_int
id|duplex
)paren
(brace
r_int
id|i
comma
id|dev
suffix:semicolon
r_int
r_int
id|minor
suffix:semicolon
r_char
id|name_buf
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* If we&squot;ve used up SPARCAUDIO_MAX_DEVICES, fail */
r_for
c_loop
(paren
id|dev
op_assign
l_int|0
suffix:semicolon
id|dev
OL
id|SPARCAUDIO_MAX_DEVICES
suffix:semicolon
id|dev
op_increment
)paren
(brace
r_if
c_cond
(paren
id|drivers
(braket
id|dev
)braket
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drivers
(braket
id|dev
)braket
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* Ensure that the driver has a proper operations structure. */
r_if
c_cond
(paren
op_logical_neg
id|drv-&gt;ops
op_logical_or
op_logical_neg
id|drv-&gt;ops-&gt;start_output
op_logical_or
op_logical_neg
id|drv-&gt;ops-&gt;stop_output
op_logical_or
op_logical_neg
id|drv-&gt;ops-&gt;start_input
op_logical_or
op_logical_neg
id|drv-&gt;ops-&gt;stop_input
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Register ourselves with devfs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|dev_list
)paren
op_div
r_sizeof
(paren
op_star
id|dev_list
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sparcaudio_mkname
(paren
id|name_buf
comma
id|dev_list
(braket
id|i
)braket
dot
id|name
comma
id|dev
)paren
suffix:semicolon
id|minor
op_assign
(paren
id|dev
op_lshift
id|SPARCAUDIO_DEVICE_SHIFT
)paren
op_or
id|dev_list
(braket
id|i
)braket
dot
id|minor
suffix:semicolon
id|devfs_register
(paren
id|devfs_handle
comma
id|name_buf
comma
id|DEVFS_FL_NONE
comma
id|SOUND_MAJOR
comma
id|minor
comma
id|S_IFCHR
op_or
id|dev_list
(braket
id|i
)braket
dot
id|mode
comma
op_amp
id|sparcaudio_fops
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Setup the circular queues of output and input buffers&n;         *&n;         * Each buffer is a single page, but output buffers might&n;         * be partially filled (by a write with count &lt; output_buffer_size),&n;         * so each output buffer also has a paired output size.&n;         *&n;         * Input buffers, on the other hand, always fill completely,&n;         * so we don&squot;t need input counts - each contains input_buffer_size&n;         * bytes of audio data.&n;         *&n;         * TODO: Make number of input/output buffers tunable parameters&n;         */
macro_line|#if defined (LINUX_VERSION_CODE) &amp;&amp; LINUX_VERSION_CODE &gt; 0x202ff
id|init_waitqueue_head
c_func
(paren
op_amp
id|drv-&gt;open_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|drv-&gt;output_write_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|drv-&gt;output_drain_wait
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|drv-&gt;input_read_wait
)paren
suffix:semicolon
macro_line|#endif
id|drv-&gt;num_output_buffers
op_assign
l_int|8
suffix:semicolon
id|drv-&gt;output_buffer_size
op_assign
(paren
l_int|4096
op_star
l_int|2
)paren
suffix:semicolon
id|drv-&gt;playing_count
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_offset
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_eof
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_front
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_rear
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_count
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_active
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_buffers
op_assign
id|kmalloc
c_func
(paren
id|drv-&gt;num_output_buffers
op_star
r_sizeof
(paren
id|__u8
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|drv-&gt;output_sizes
op_assign
id|kmalloc
c_func
(paren
id|drv-&gt;num_output_buffers
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|drv-&gt;output_notify
op_assign
id|kmalloc
c_func
(paren
id|drv-&gt;num_output_buffers
op_star
r_sizeof
(paren
r_char
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drv-&gt;output_buffers
op_logical_or
op_logical_neg
id|drv-&gt;output_sizes
op_logical_or
op_logical_neg
id|drv-&gt;output_notify
)paren
r_goto
id|kmalloc_failed1
suffix:semicolon
id|drv-&gt;output_buffer
op_assign
id|kmalloc
c_func
(paren
(paren
id|drv-&gt;output_buffer_size
op_star
id|drv-&gt;num_output_buffers
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drv-&gt;output_buffer
)paren
r_goto
id|kmalloc_failed2
suffix:semicolon
multiline_comment|/* Allocate the pages for each output buffer. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|drv-&gt;num_output_buffers
suffix:semicolon
id|i
op_increment
)paren
(brace
id|drv-&gt;output_buffers
(braket
id|i
)braket
op_assign
(paren
r_void
op_star
)paren
(paren
id|drv-&gt;output_buffer
op_plus
(paren
id|i
op_star
id|drv-&gt;output_buffer_size
)paren
)paren
suffix:semicolon
id|drv-&gt;output_sizes
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;output_notify
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Setup the circular queue of input buffers. */
id|drv-&gt;num_input_buffers
op_assign
l_int|8
suffix:semicolon
id|drv-&gt;input_buffer_size
op_assign
(paren
l_int|4096
op_star
l_int|2
)paren
suffix:semicolon
id|drv-&gt;recording_count
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_front
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_rear
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_count
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_offset
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_size
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_active
op_assign
l_int|0
suffix:semicolon
id|drv-&gt;input_buffers
op_assign
id|kmalloc
c_func
(paren
id|drv-&gt;num_input_buffers
op_star
r_sizeof
(paren
id|__u8
op_star
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|drv-&gt;input_sizes
op_assign
id|kmalloc
c_func
(paren
id|drv-&gt;num_input_buffers
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drv-&gt;input_buffers
op_logical_or
op_logical_neg
id|drv-&gt;input_sizes
)paren
r_goto
id|kmalloc_failed3
suffix:semicolon
multiline_comment|/* Allocate the pages for each input buffer. */
r_if
c_cond
(paren
id|duplex
op_eq
l_int|1
)paren
(brace
id|drv-&gt;input_buffer
op_assign
id|kmalloc
c_func
(paren
(paren
id|drv-&gt;input_buffer_size
op_star
id|drv-&gt;num_input_buffers
)paren
comma
id|GFP_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drv-&gt;input_buffer
)paren
r_goto
id|kmalloc_failed4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|drv-&gt;num_input_buffers
suffix:semicolon
id|i
op_increment
)paren
id|drv-&gt;input_buffers
(braket
id|i
)braket
op_assign
(paren
r_void
op_star
)paren
(paren
id|drv-&gt;input_buffer
op_plus
(paren
id|i
op_star
id|drv-&gt;input_buffer_size
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|duplex
op_eq
l_int|2
)paren
(brace
id|drv-&gt;input_buffer
op_assign
id|drv-&gt;output_buffer
suffix:semicolon
id|drv-&gt;input_buffer_size
op_assign
id|drv-&gt;output_buffer_size
suffix:semicolon
id|drv-&gt;num_input_buffers
op_assign
id|drv-&gt;num_output_buffers
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|drv-&gt;num_input_buffers
suffix:semicolon
id|i
op_increment
)paren
id|drv-&gt;input_buffers
(braket
id|i
)braket
op_assign
id|drv-&gt;output_buffers
(braket
id|i
)braket
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|drv-&gt;num_input_buffers
suffix:semicolon
id|i
op_increment
)paren
id|drv-&gt;input_buffers
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Take note of our duplexity */
id|drv-&gt;duplex
op_assign
id|duplex
suffix:semicolon
multiline_comment|/* Ensure that the driver is marked as not being open. */
id|drv-&gt;flags
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* Take driver slot, note which we took */
id|drv-&gt;index
op_assign
id|dev
suffix:semicolon
id|drivers
(braket
id|dev
)braket
op_assign
id|drv
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|kmalloc_failed4
suffix:colon
id|kfree
c_func
(paren
id|drv-&gt;input_buffer
)paren
suffix:semicolon
id|kmalloc_failed3
suffix:colon
r_if
c_cond
(paren
id|drv-&gt;input_sizes
)paren
id|kfree
c_func
(paren
id|drv-&gt;input_sizes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;input_buffers
)paren
id|kfree
c_func
(paren
id|drv-&gt;input_buffers
)paren
suffix:semicolon
id|i
op_assign
id|drv-&gt;num_output_buffers
suffix:semicolon
id|kmalloc_failed2
suffix:colon
id|kfree
c_func
(paren
id|drv-&gt;output_buffer
)paren
suffix:semicolon
id|kmalloc_failed1
suffix:colon
r_if
c_cond
(paren
id|drv-&gt;output_buffers
)paren
id|kfree
c_func
(paren
id|drv-&gt;output_buffers
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;output_sizes
)paren
id|kfree
c_func
(paren
id|drv-&gt;output_sizes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drv-&gt;output_notify
)paren
id|kfree
c_func
(paren
id|drv-&gt;output_notify
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|unregister_sparcaudio_driver
r_int
id|unregister_sparcaudio_driver
c_func
(paren
r_struct
id|sparcaudio_driver
op_star
id|drv
comma
r_int
id|duplex
)paren
(brace
id|devfs_handle_t
id|de
suffix:semicolon
r_int
id|i
suffix:semicolon
r_char
id|name_buf
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* Figure out which driver is unregistering */
r_if
c_cond
(paren
id|drivers
(braket
id|drv-&gt;index
)braket
op_ne
id|drv
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* Deallocate the queue of output buffers. */
id|kfree
c_func
(paren
id|drv-&gt;output_buffer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|drv-&gt;output_buffers
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|drv-&gt;output_sizes
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|drv-&gt;output_notify
)paren
suffix:semicolon
multiline_comment|/* Deallocate the queue of input buffers. */
r_if
c_cond
(paren
id|duplex
op_eq
l_int|1
)paren
(brace
id|kfree
c_func
(paren
id|drv-&gt;input_buffer
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|drv-&gt;input_sizes
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|drv-&gt;input_buffers
)paren
suffix:semicolon
r_if
c_cond
(paren
op_amp
(paren
id|drv-&gt;sd_siglist
)paren
op_ne
l_int|NULL
)paren
id|lis_free_elist
c_func
(paren
op_amp
(paren
id|drv-&gt;sd_siglist
)paren
)paren
suffix:semicolon
multiline_comment|/* Unregister ourselves with devfs */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|dev_list
)paren
op_div
r_sizeof
(paren
op_star
id|dev_list
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sparcaudio_mkname
(paren
id|name_buf
comma
id|dev_list
(braket
id|i
)braket
dot
id|name
comma
id|drv-&gt;index
)paren
suffix:semicolon
id|de
op_assign
id|devfs_find_handle
(paren
id|devfs_handle
comma
id|name_buf
comma
l_int|0
comma
l_int|0
comma
id|DEVFS_SPECIAL_CHR
comma
l_int|0
)paren
suffix:semicolon
id|devfs_unregister
(paren
id|de
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
multiline_comment|/* Null the appropriate driver */
id|drivers
(braket
id|drv-&gt;index
)braket
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|register_sparcaudio_driver
id|EXPORT_SYMBOL
c_func
(paren
id|register_sparcaudio_driver
)paren
suffix:semicolon
DECL|variable|unregister_sparcaudio_driver
id|EXPORT_SYMBOL
c_func
(paren
id|unregister_sparcaudio_driver
)paren
suffix:semicolon
DECL|variable|sparcaudio_output_done
id|EXPORT_SYMBOL
c_func
(paren
id|sparcaudio_output_done
)paren
suffix:semicolon
DECL|variable|sparcaudio_input_done
id|EXPORT_SYMBOL
c_func
(paren
id|sparcaudio_input_done
)paren
suffix:semicolon
DECL|function|sparcaudio_init
r_static
r_int
id|__init
id|sparcaudio_init
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Register our character device driver with the VFS. */
r_if
c_cond
(paren
id|devfs_register_chrdev
c_func
(paren
id|SOUND_MAJOR
comma
l_string|&quot;sparcaudio&quot;
comma
op_amp
id|sparcaudio_fops
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|devfs_handle
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;sound&quot;
comma
l_int|NULL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_SPARCAUDIO_AMD7930
id|amd7930_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SPARCAUDIO_DBRI
id|dbri_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SPARCAUDIO_CS4231
id|cs4231_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SPARCAUDIO_DUMMY
id|dummy_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|sparcaudio_exit
r_static
r_void
id|__exit
id|sparcaudio_exit
c_func
(paren
r_void
)paren
(brace
id|devfs_unregister_chrdev
c_func
(paren
id|SOUND_MAJOR
comma
l_string|&quot;sparcaudio&quot;
)paren
suffix:semicolon
id|devfs_unregister
(paren
id|devfs_handle
)paren
suffix:semicolon
)brace
id|module_init
c_func
(paren
id|sparcaudio_init
)paren
id|module_exit
c_func
(paren
id|sparcaudio_exit
)paren
multiline_comment|/*&n; * Code from Linux Streams, Copyright 1995 by&n; * Graham Wheeler, Francisco J. Ballesteros, Denis Froschauer&n; * and available under GPL &n; */
r_static
r_int
DECL|function|lis_add_to_elist
id|lis_add_to_elist
c_func
(paren
id|strevent_t
op_star
op_star
id|list
comma
id|pid_t
id|pid
comma
r_int
id|events
)paren
(brace
id|strevent_t
op_star
id|ev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_star
id|list
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|ev
op_assign
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|se_next
suffix:semicolon
id|ev
op_ne
op_star
id|list
op_logical_and
id|ev-&gt;se_pid
OL
id|pid
suffix:semicolon
id|ev
op_assign
id|ev-&gt;se_next
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ev
op_eq
l_int|NULL
op_logical_or
id|ev
op_eq
op_star
id|list
)paren
(brace
multiline_comment|/* no slot for pid in list */
id|ev
op_assign
(paren
id|strevent_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|strevent_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ev
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|list
)paren
(brace
multiline_comment|/* create dummy head node */
id|strevent_t
op_star
id|hd
suffix:semicolon
id|hd
op_assign
(paren
id|strevent_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|strevent_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|ev
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
(paren
op_star
id|list
op_assign
id|hd
)paren
op_member_access_from_pointer
id|se_pid
op_assign
l_int|0
suffix:semicolon
id|hd-&gt;se_next
op_assign
id|hd-&gt;se_prev
op_assign
id|hd
suffix:semicolon
multiline_comment|/* empty list */
)brace
multiline_comment|/* link node last in the list */
id|ev-&gt;se_prev
op_assign
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|se_prev
suffix:semicolon
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|se_prev-&gt;se_next
op_assign
id|ev
suffix:semicolon
(paren
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|se_prev
op_assign
id|ev
)paren
op_member_access_from_pointer
id|se_next
op_assign
op_star
id|list
suffix:semicolon
id|ev-&gt;se_pid
op_assign
id|pid
suffix:semicolon
id|ev-&gt;se_evs
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ev-&gt;se_pid
op_ne
id|pid
)paren
(brace
multiline_comment|/* link node in the middle of the list */
id|strevent_t
op_star
r_new
suffix:semicolon
r_new
op_assign
(paren
id|strevent_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|strevent_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
r_new
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_new
op_member_access_from_pointer
id|se_prev
op_assign
id|ev-&gt;se_prev
suffix:semicolon
r_new
op_member_access_from_pointer
id|se_next
op_assign
id|ev
suffix:semicolon
id|ev-&gt;se_prev-&gt;se_next
op_assign
r_new
suffix:semicolon
id|ev-&gt;se_prev
op_assign
r_new
suffix:semicolon
id|ev
op_assign
r_new
suffix:semicolon
multiline_comment|/* use new element */
id|ev-&gt;se_pid
op_assign
id|pid
suffix:semicolon
id|ev-&gt;se_evs
op_assign
l_int|0
suffix:semicolon
)brace
id|ev-&gt;se_evs
op_or_assign
id|events
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|lis_del_from_elist
id|lis_del_from_elist
c_func
(paren
id|strevent_t
op_star
op_star
id|list
comma
id|pid_t
id|pid
comma
r_int
id|events
)paren
(brace
id|strevent_t
op_star
id|ev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_star
id|list
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|ev
op_assign
(paren
op_star
id|list
)paren
op_member_access_from_pointer
id|se_next
suffix:semicolon
id|ev
op_ne
op_star
id|list
op_logical_and
id|ev-&gt;se_pid
OL
id|pid
suffix:semicolon
id|ev
op_assign
id|ev-&gt;se_next
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ev
op_eq
l_int|NULL
op_logical_or
id|ev
op_eq
op_star
id|list
op_logical_or
id|ev-&gt;se_pid
op_ne
id|pid
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ev-&gt;se_evs
op_and_assign
op_complement
id|events
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* unlink */
r_if
c_cond
(paren
id|ev-&gt;se_next
)paren
multiline_comment|/* should always be true */
id|ev-&gt;se_next-&gt;se_prev
op_assign
id|ev-&gt;se_prev
suffix:semicolon
r_if
c_cond
(paren
id|ev-&gt;se_prev
)paren
multiline_comment|/* should always be true */
id|ev-&gt;se_prev-&gt;se_next
op_assign
id|ev-&gt;se_next
suffix:semicolon
id|kfree
c_func
(paren
id|ev
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|lis_free_elist
id|lis_free_elist
c_func
(paren
id|strevent_t
op_star
op_star
id|list
)paren
(brace
id|strevent_t
op_star
id|ev
suffix:semicolon
id|strevent_t
op_star
id|nxt
suffix:semicolon
r_for
c_loop
(paren
id|ev
op_assign
op_star
id|list
suffix:semicolon
id|ev
op_ne
l_int|NULL
suffix:semicolon
)paren
(brace
id|nxt
op_assign
id|ev-&gt;se_next
suffix:semicolon
id|kfree
c_func
(paren
id|ev
)paren
suffix:semicolon
id|ev
op_assign
id|nxt
suffix:semicolon
r_if
c_cond
(paren
id|ev
op_eq
op_star
id|list
)paren
r_break
suffix:semicolon
multiline_comment|/* all done */
)brace
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
)brace
r_static
r_int
DECL|function|lis_get_elist_ent
id|lis_get_elist_ent
c_func
(paren
id|strevent_t
op_star
id|list
comma
id|pid_t
id|pid
)paren
(brace
id|strevent_t
op_star
id|ev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|list
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|ev
op_assign
id|list-&gt;se_next
suffix:semicolon
id|ev
op_ne
id|list
op_logical_and
id|ev-&gt;se_pid
OL
id|pid
suffix:semicolon
id|ev
op_assign
id|ev-&gt;se_next
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ev
op_ne
id|list
op_logical_and
id|ev-&gt;se_pid
op_eq
id|pid
)paren
r_return
id|ev-&gt;se_evs
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|kill_procs
id|kill_procs
c_func
(paren
r_struct
id|strevent
op_star
id|elist
comma
r_int
id|sig
comma
r_int
id|e
)paren
(brace
id|strevent_t
op_star
id|ev
suffix:semicolon
r_int
id|res
suffix:semicolon
r_if
c_cond
(paren
id|elist
)paren
(brace
r_for
c_loop
(paren
id|ev
op_assign
id|elist-&gt;se_next
suffix:semicolon
id|ev
op_ne
id|elist
suffix:semicolon
id|ev
op_assign
id|ev-&gt;se_next
)paren
r_if
c_cond
(paren
(paren
id|ev-&gt;se_evs
op_amp
id|e
)paren
op_ne
l_int|0
)paren
(brace
id|res
op_assign
id|kill_proc
c_func
(paren
id|ev-&gt;se_pid
comma
id|SIGPOLL
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|res
OL
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|res
op_eq
op_minus
l_int|3
)paren
(brace
id|lis_del_from_elist
c_func
(paren
op_amp
id|elist
comma
id|ev-&gt;se_pid
comma
id|S_ALL
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|dprintk
c_func
(paren
(paren
l_string|&quot;kill_proc: errno %d&bslash;n&quot;
comma
id|res
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * Overrides for Emacs so that we follow Linus&squot;s tabbing style.&n; * Emacs will notice this stuff at the end of the file and automatically&n; * adjust the settings for this buffer only.  This must remain at the end&n; * of the file.&n; * ---------------------------------------------------------------------------&n; * Local variables:&n; * c-indent-level: 4&n; * c-brace-imaginary-offset: 0&n; * c-brace-offset: -4&n; * c-argdecl-indent: 4&n; * c-label-offset: -4&n; * c-continued-statement-offset: 4&n; * c-continued-brace-offset: 0&n; * indent-tabs-mode: nil&n; * tab-width: 8&n; * End:&n; */
eof
