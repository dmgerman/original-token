multiline_comment|/* $Id: su.c,v 1.8 1998/04/01 05:07:50 ecd Exp $&n; * su.c: Small serial driver for keyboard/mouse interface on Ultra/AX&n; *&n; * Copyright (C) 1997  Eddie C. Dost  (ecd@skynet.be)&n; *&n; * This is mainly a very stripped down version of drivers/char/serial.c,&n; * credits go to authors mentioned therein.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/serial.h&gt;
macro_line|#include &lt;linux/serial_reg.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/oplib.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/ebus.h&gt;
macro_line|#include &quot;sunserial.h&quot;
macro_line|#include &quot;sunkbd.h&quot;
macro_line|#include &quot;sunmouse.h&quot;
DECL|variable|serial_name
r_static
r_char
op_star
id|serial_name
op_assign
l_string|&quot;kbd/mouse serial driver&quot;
suffix:semicolon
DECL|variable|serial_version
r_static
r_char
op_star
id|serial_version
op_assign
l_string|&quot;1.0&quot;
suffix:semicolon
multiline_comment|/* Set of debugging defines */
DECL|macro|SERIAL_DEBUG_INTR
macro_line|#undef SERIAL_DEBUG_INTR
DECL|macro|SERIAL_DEBUG_OPEN
macro_line|#undef SERIAL_DEBUG_OPEN
multiline_comment|/* We are on a NS PC87303 clocked with 24.0 MHz, which results&n; * in a UART clock of 1.8462 MHz.&n; */
DECL|macro|BAUD_BASE
mdefine_line|#define BAUD_BASE&t;(1846200 / 16)
DECL|struct|su_struct
r_struct
id|su_struct
(brace
DECL|member|magic
r_int
id|magic
suffix:semicolon
DECL|member|port
r_int
r_int
id|port
suffix:semicolon
DECL|member|baud_base
r_int
id|baud_base
suffix:semicolon
DECL|member|type
r_int
id|type
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
DECL|member|IER
r_int
r_char
id|IER
suffix:semicolon
DECL|member|MCR
r_int
r_char
id|MCR
suffix:semicolon
DECL|member|line
r_int
id|line
suffix:semicolon
DECL|member|cflag
r_int
id|cflag
suffix:semicolon
DECL|member|kbd_node
r_int
id|kbd_node
suffix:semicolon
DECL|member|ms_node
r_int
id|ms_node
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|16
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|su_table
r_static
r_struct
id|su_struct
id|su_table
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
comma
id|BAUD_BASE
comma
id|PORT_UNKNOWN
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
id|BAUD_BASE
comma
id|PORT_UNKNOWN
)brace
)brace
suffix:semicolon
DECL|macro|NR_PORTS
mdefine_line|#define NR_PORTS (sizeof(su_table) / sizeof(struct su_struct))
r_static
r_void
id|autoconfig
c_func
(paren
r_struct
id|su_struct
op_star
id|info
)paren
suffix:semicolon
r_static
r_void
id|change_speed
c_func
(paren
r_struct
id|su_struct
op_star
id|info
)paren
suffix:semicolon
multiline_comment|/*&n; * Here we define the default xmit fifo size used for each type of&n; * UART&n; */
DECL|variable|uart_config
r_static
r_struct
id|serial_uart_config
id|uart_config
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;unknown&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;8250&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;16450&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;16550&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;16550A&quot;
comma
l_int|16
comma
id|UART_CLEAR_FIFO
op_or
id|UART_USE_FIFO
)brace
comma
(brace
l_string|&quot;cirrus&quot;
comma
l_int|1
comma
l_int|0
)brace
comma
(brace
l_string|&quot;ST16650&quot;
comma
l_int|1
comma
id|UART_CLEAR_FIFO
op_or
id|UART_STARTECH
)brace
comma
(brace
l_string|&quot;ST16650V2&quot;
comma
l_int|32
comma
id|UART_CLEAR_FIFO
op_or
id|UART_USE_FIFO
op_or
id|UART_STARTECH
)brace
comma
(brace
l_string|&quot;TI16750&quot;
comma
l_int|64
comma
id|UART_CLEAR_FIFO
op_or
id|UART_USE_FIFO
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * This is used to figure out the divisor speeds and the timeouts&n; */
DECL|variable|baud_table
r_static
r_int
id|baud_table
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|50
comma
l_int|75
comma
l_int|110
comma
l_int|134
comma
l_int|150
comma
l_int|200
comma
l_int|300
comma
l_int|600
comma
l_int|1200
comma
l_int|1800
comma
l_int|2400
comma
l_int|4800
comma
l_int|9600
comma
l_int|19200
comma
l_int|38400
comma
l_int|57600
comma
l_int|115200
comma
l_int|230400
comma
l_int|460800
comma
l_int|0
)brace
suffix:semicolon
r_static
r_inline
DECL|function|su_inb
r_int
r_int
id|su_inb
c_func
(paren
r_struct
id|su_struct
op_star
id|info
comma
r_int
r_int
id|offset
)paren
(brace
r_return
id|inb
c_func
(paren
id|info-&gt;port
op_plus
id|offset
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|su_outb
id|su_outb
c_func
(paren
r_struct
id|su_struct
op_star
id|info
comma
r_int
r_int
id|offset
comma
r_int
id|value
)paren
(brace
id|outb
c_func
(paren
id|value
comma
id|info-&gt;port
op_plus
id|offset
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|receive_chars
id|receive_chars
c_func
(paren
r_struct
id|su_struct
op_star
id|info
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
r_char
id|status
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|ch
suffix:semicolon
r_do
(brace
id|ch
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_RX
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_INTR
id|printk
c_func
(paren
l_string|&quot;DR%02x:%02x...&quot;
comma
id|ch
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|info-&gt;kbd_node
)paren
(brace
r_if
c_cond
(paren
id|ch
op_eq
id|SUNKBD_RESET
)paren
(brace
id|l1a_state.kbd_id
op_assign
l_int|1
suffix:semicolon
id|l1a_state.l1_down
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|l1a_state.kbd_id
)paren
(brace
id|l1a_state.kbd_id
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ch
op_eq
id|SUNKBD_L1
)paren
(brace
id|l1a_state.l1_down
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ch
op_eq
(paren
id|SUNKBD_L1
op_or
id|SUNKBD_UP
)paren
)paren
(brace
id|l1a_state.l1_down
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ch
op_eq
id|SUNKBD_A
op_logical_and
id|l1a_state.l1_down
)paren
(brace
multiline_comment|/* whee... */
id|batten_down_hatches
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Continue execution... */
id|l1a_state.l1_down
op_assign
l_int|0
suffix:semicolon
id|l1a_state.kbd_id
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sunkbd_inchar
c_func
(paren
id|ch
comma
id|regs
)paren
suffix:semicolon
)brace
r_else
(brace
id|sun_mouse_inbyte
c_func
(paren
id|ch
)paren
suffix:semicolon
)brace
id|status
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_LSR
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|status
op_amp
id|UART_LSR_DR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the serial driver&squot;s generic interrupt routine&n; */
r_static
r_void
DECL|function|su_interrupt
id|su_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|su_struct
op_star
id|info
op_assign
(paren
r_struct
id|su_struct
op_star
)paren
id|dev_id
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_INTR
id|printk
c_func
(paren
l_string|&quot;su_interrupt(%d)...&quot;
comma
id|irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|su_inb
c_func
(paren
id|info
comma
id|UART_IIR
)paren
op_amp
id|UART_IIR_NO_INT
)paren
r_return
suffix:semicolon
id|status
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_LSR
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_INTR
id|printk
c_func
(paren
l_string|&quot;status = %x...&quot;
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|status
op_amp
id|UART_LSR_DR
)paren
id|receive_chars
c_func
(paren
id|info
comma
id|regs
)paren
suffix:semicolon
macro_line|#ifdef SERIAL_DEBUG_INTR
id|printk
c_func
(paren
l_string|&quot;end.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_int
DECL|function|startup
id|startup
c_func
(paren
r_struct
id|su_struct
op_star
id|info
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;flags
op_amp
id|ASYNC_INITIALIZED
)paren
(brace
r_goto
id|errout
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;port
op_logical_or
op_logical_neg
id|info-&gt;type
)paren
(brace
r_goto
id|errout
suffix:semicolon
)brace
macro_line|#ifdef SERIAL_DEBUG_OPEN
id|printk
c_func
(paren
l_string|&quot;starting up su%d (irq %x)...&quot;
comma
id|info-&gt;line
comma
id|info-&gt;irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|info-&gt;type
op_eq
id|PORT_16750
)paren
id|su_outb
c_func
(paren
id|info
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the FIFO buffers and disable them&n;&t; * (they will be reenabled in change_speed())&n;&t; */
r_if
c_cond
(paren
id|uart_config
(braket
id|info-&gt;type
)braket
dot
id|flags
op_amp
id|UART_CLEAR_FIFO
)paren
id|su_outb
c_func
(paren
id|info
comma
id|UART_FCR
comma
(paren
id|UART_FCR_CLEAR_RCVR
op_or
id|UART_FCR_CLEAR_XMIT
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * At this point there&squot;s no way the LSR could still be 0xFF;&n;&t; * if it is, then bail out, because there&squot;s likely no UART&n;&t; * here.&n;&t; */
r_if
c_cond
(paren
id|su_inb
c_func
(paren
id|info
comma
id|UART_LSR
)paren
op_eq
l_int|0xff
)paren
(brace
id|retval
op_assign
op_minus
id|ENODEV
suffix:semicolon
r_goto
id|errout
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate the IRQ if necessary&n;&t; */
id|retval
op_assign
id|request_irq
c_func
(paren
id|info-&gt;irq
comma
id|su_interrupt
comma
id|SA_SHIRQ
comma
id|info-&gt;name
comma
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_goto
id|errout
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the interrupt registers.&n;&t; */
id|su_inb
c_func
(paren
id|info
comma
id|UART_RX
)paren
suffix:semicolon
id|su_inb
c_func
(paren
id|info
comma
id|UART_IIR
)paren
suffix:semicolon
id|su_inb
c_func
(paren
id|info
comma
id|UART_MSR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now, initialize the UART &n;&t; */
id|su_outb
c_func
(paren
id|info
comma
id|UART_LCR
comma
id|UART_LCR_WLEN8
)paren
suffix:semicolon
multiline_comment|/* reset DLAB */
id|info-&gt;MCR
op_assign
id|UART_MCR_OUT2
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_MCR
comma
id|info-&gt;MCR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Finally, enable interrupts&n;&t; */
id|info-&gt;IER
op_assign
id|UART_IER_RLSI
op_or
id|UART_IER_RDI
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_IER
comma
id|info-&gt;IER
)paren
suffix:semicolon
multiline_comment|/* enable interrupts */
multiline_comment|/*&n;&t; * And clear the interrupt registers again for luck.&n;&t; */
id|su_inb
c_func
(paren
id|info
comma
id|UART_LSR
)paren
suffix:semicolon
id|su_inb
c_func
(paren
id|info
comma
id|UART_RX
)paren
suffix:semicolon
id|su_inb
c_func
(paren
id|info
comma
id|UART_IIR
)paren
suffix:semicolon
id|su_inb
c_func
(paren
id|info
comma
id|UART_MSR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * and set the speed of the serial port&n;&t; */
id|change_speed
c_func
(paren
id|info
)paren
suffix:semicolon
id|info-&gt;flags
op_or_assign
id|ASYNC_INITIALIZED
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|errout
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called to set the UART divisor registers to match&n; * the specified baud rate for a serial port.&n; */
r_static
r_void
DECL|function|change_speed
id|change_speed
c_func
(paren
r_struct
id|su_struct
op_star
id|info
)paren
(brace
r_int
r_char
id|cval
comma
id|fcr
op_assign
l_int|0
suffix:semicolon
r_int
id|quot
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* byte size and parity */
r_switch
c_cond
(paren
id|info-&gt;cflag
op_amp
id|CSIZE
)paren
(brace
r_case
id|CS5
suffix:colon
id|cval
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS6
suffix:colon
id|cval
op_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS7
suffix:colon
id|cval
op_assign
l_int|0x02
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CS8
suffix:colon
id|cval
op_assign
l_int|0x03
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Never happens, but GCC is too dumb to figure it out */
r_default
suffix:colon
id|cval
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;cflag
op_amp
id|CSTOPB
)paren
(brace
id|cval
op_or_assign
l_int|0x04
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;cflag
op_amp
id|PARENB
)paren
(brace
id|cval
op_or_assign
id|UART_LCR_PARITY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|info-&gt;cflag
op_amp
id|PARODD
)paren
)paren
id|cval
op_or_assign
id|UART_LCR_EPAR
suffix:semicolon
macro_line|#ifdef CMSPAR
r_if
c_cond
(paren
id|info-&gt;cflag
op_amp
id|CMSPAR
)paren
id|cval
op_or_assign
id|UART_LCR_SPAR
suffix:semicolon
macro_line|#endif
multiline_comment|/* Determine divisor based on baud rate */
id|i
op_assign
id|info-&gt;cflag
op_amp
id|CBAUD
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|CBAUDEX
)paren
(brace
id|i
op_and_assign
op_complement
id|CBAUDEX
suffix:semicolon
r_if
c_cond
(paren
id|i
template_param
l_int|4
)paren
id|info-&gt;cflag
op_and_assign
op_complement
id|CBAUDEX
suffix:semicolon
r_else
id|i
op_add_assign
l_int|15
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|quot
)paren
(brace
r_if
c_cond
(paren
id|baud_table
(braket
id|i
)braket
op_eq
l_int|134
)paren
multiline_comment|/* Special case since 134 is really 134.5 */
id|quot
op_assign
(paren
l_int|2
op_star
id|info-&gt;baud_base
op_div
l_int|269
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|baud_table
(braket
id|i
)braket
)paren
id|quot
op_assign
id|info-&gt;baud_base
op_div
id|baud_table
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* If the quotient is ever zero, default to 1200 bps */
r_if
c_cond
(paren
op_logical_neg
id|quot
)paren
id|quot
op_assign
id|info-&gt;baud_base
op_div
l_int|1200
suffix:semicolon
)brace
multiline_comment|/* Set up FIFO&squot;s */
r_if
c_cond
(paren
id|uart_config
(braket
id|info-&gt;type
)braket
dot
id|flags
op_amp
id|UART_USE_FIFO
)paren
id|fcr
op_assign
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR_TRIGGER_1
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_IER
comma
id|info-&gt;IER
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_LCR
comma
id|cval
op_or
id|UART_LCR_DLAB
)paren
suffix:semicolon
multiline_comment|/* set DLAB */
id|su_outb
c_func
(paren
id|info
comma
id|UART_DLL
comma
id|quot
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* LS of divisor */
id|su_outb
c_func
(paren
id|info
comma
id|UART_DLM
comma
id|quot
op_rshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* MS of divisor */
r_if
c_cond
(paren
id|info-&gt;type
op_eq
id|PORT_16750
)paren
id|su_outb
c_func
(paren
id|info
comma
id|UART_FCR
comma
id|fcr
)paren
suffix:semicolon
multiline_comment|/* set fcr */
id|su_outb
c_func
(paren
id|info
comma
id|UART_LCR
comma
id|cval
)paren
suffix:semicolon
multiline_comment|/* reset DLAB */
r_if
c_cond
(paren
id|info-&gt;type
op_ne
id|PORT_16750
)paren
id|su_outb
c_func
(paren
id|info
comma
id|UART_FCR
comma
id|fcr
)paren
suffix:semicolon
multiline_comment|/* set fcr */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|su_put_char
id|su_put_char
c_func
(paren
r_int
r_char
id|c
)paren
(brace
r_struct
id|su_struct
op_star
id|info
op_assign
id|su_table
suffix:semicolon
r_int
id|lsr
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;kbd_node
)paren
op_increment
id|info
suffix:semicolon
r_do
(brace
id|lsr
op_assign
id|inb
c_func
(paren
id|info-&gt;port
op_plus
id|UART_LSR
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
(paren
id|lsr
op_amp
id|UART_LSR_THRE
)paren
)paren
suffix:semicolon
multiline_comment|/* Send the character out. */
id|su_outb
c_func
(paren
id|info
comma
id|UART_TX
comma
id|c
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|su_change_mouse_baud
id|su_change_mouse_baud
c_func
(paren
r_int
id|baud
)paren
(brace
r_struct
id|su_struct
op_star
id|info
op_assign
id|su_table
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info-&gt;ms_node
)paren
op_increment
id|info
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|info
)paren
r_return
suffix:semicolon
id|info-&gt;cflag
op_and_assign
op_complement
(paren
id|CBAUDEX
op_or
id|CBAUD
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|baud
)paren
(brace
r_case
l_int|1200
suffix:colon
id|info-&gt;cflag
op_or_assign
id|B1200
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2400
suffix:colon
id|info-&gt;cflag
op_or_assign
id|B2400
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4800
suffix:colon
id|info-&gt;cflag
op_or_assign
id|B4800
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9600
suffix:colon
id|info-&gt;cflag
op_or_assign
id|B9600
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;su_change_mouse_baud: unknown baud rate %d, &quot;
l_string|&quot;defaulting to 1200&bslash;n&quot;
comma
id|baud
)paren
suffix:semicolon
id|info-&gt;cflag
op_or_assign
l_int|1200
suffix:semicolon
r_break
suffix:semicolon
)brace
id|change_speed
c_func
(paren
id|info
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine prints out the appropriate serial driver version&n; * number, and identifies which options were configured into this&n; * driver.&n; */
r_static
r_inline
r_void
DECL|function|show_su_version
id|show_su_version
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s version %s&bslash;n&quot;
comma
id|serial_name
comma
id|serial_version
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called by su_init() to initialize a specific serial&n; * port.  It determines what type of UART chip this serial port is&n; * using: 8250, 16450, 16550, 16550A.  The important question is&n; * whether or not this UART is a 16550A or not, since this will&n; * determine whether or not we can use its FIFO features or not.&n; */
r_static
r_void
DECL|function|autoconfig
id|autoconfig
c_func
(paren
r_struct
id|su_struct
op_star
id|info
)paren
(brace
r_int
r_char
id|status1
comma
id|status2
comma
id|scratch
comma
id|scratch2
suffix:semicolon
r_struct
id|linux_ebus_device
op_star
id|dev
suffix:semicolon
r_struct
id|linux_ebus
op_star
id|ebus
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|for_all_ebusdev
c_func
(paren
id|dev
comma
id|ebus
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|dev-&gt;prom_name
comma
l_string|&quot;su&quot;
comma
l_int|2
)paren
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;prom_node
op_eq
id|info-&gt;kbd_node
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;prom_node
op_eq
id|info-&gt;ms_node
)paren
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
r_return
suffix:semicolon
id|info-&gt;port
op_assign
id|dev-&gt;base_address
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|info-&gt;port
comma
l_int|8
)paren
)paren
r_return
suffix:semicolon
id|info-&gt;irq
op_assign
id|dev-&gt;irqs
(braket
l_int|0
)braket
suffix:semicolon
macro_line|#ifdef DEBUG_SERIAL_OPEN
id|printk
c_func
(paren
l_string|&quot;Found &squot;su&squot; at %016lx IRQ %08x&bslash;n&quot;
comma
id|dev-&gt;base_address
(braket
l_int|0
)braket
comma
id|dev-&gt;irqs
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif
id|info-&gt;magic
op_assign
id|SERIAL_MAGIC
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Do a simple existence test first; if we fail this, there&squot;s&n;&t; * no point trying anything else.&n;&t; *&n;&t; * 0x80 is used as a nonsense port to prevent against false&n;&t; * positives due to ISA bus float.  The assumption is that&n;&t; * 0x80 is a non-existent port; which should be safe since&n;&t; * include/asm/io.h also makes this assumption.&n;&t; */
id|scratch
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_IER
)paren
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_IER
comma
l_int|0
)paren
suffix:semicolon
id|scratch2
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_IER
)paren
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_IER
comma
id|scratch
)paren
suffix:semicolon
r_if
c_cond
(paren
id|scratch2
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* We failed; there&squot;s nothing here */
)brace
id|scratch
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_MCR
)paren
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_MCR
comma
id|UART_MCR_LOOP
op_or
id|scratch
)paren
suffix:semicolon
id|scratch2
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_MSR
)paren
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_MCR
comma
id|UART_MCR_LOOP
op_or
l_int|0x0A
)paren
suffix:semicolon
id|status1
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_MSR
)paren
op_amp
l_int|0xF0
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_MCR
comma
id|scratch
)paren
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_MSR
comma
id|scratch2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status1
op_ne
l_int|0x90
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|scratch2
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_LCR
)paren
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
multiline_comment|/* set up for StarTech test */
id|su_outb
c_func
(paren
id|info
comma
id|UART_EFR
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* EFR is the same as FCR */
id|su_outb
c_func
(paren
id|info
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
id|scratch
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_IIR
)paren
op_rshift
l_int|6
suffix:semicolon
r_switch
c_cond
(paren
id|scratch
)paren
(brace
r_case
l_int|0
suffix:colon
id|info-&gt;type
op_assign
id|PORT_16450
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|info-&gt;type
op_assign
id|PORT_UNKNOWN
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|info-&gt;type
op_assign
id|PORT_16550
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|info-&gt;type
op_assign
id|PORT_16550A
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;type
op_eq
id|PORT_16550A
)paren
(brace
multiline_comment|/* Check for Startech UART&squot;s */
id|su_outb
c_func
(paren
id|info
comma
id|UART_LCR
comma
id|scratch2
op_or
id|UART_LCR_DLAB
)paren
suffix:semicolon
r_if
c_cond
(paren
id|su_inb
c_func
(paren
id|info
comma
id|UART_EFR
)paren
op_eq
l_int|0
)paren
(brace
id|info-&gt;type
op_assign
id|PORT_16650
suffix:semicolon
)brace
r_else
(brace
id|su_outb
c_func
(paren
id|info
comma
id|UART_LCR
comma
l_int|0xBF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|su_inb
c_func
(paren
id|info
comma
id|UART_EFR
)paren
op_eq
l_int|0
)paren
id|info-&gt;type
op_assign
id|PORT_16650V2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|info-&gt;type
op_eq
id|PORT_16550A
)paren
(brace
multiline_comment|/* Check for TI 16750 */
id|su_outb
c_func
(paren
id|info
comma
id|UART_LCR
comma
id|scratch2
op_or
id|UART_LCR_DLAB
)paren
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
op_or
id|UART_FCR7_64BYTE
)paren
suffix:semicolon
id|scratch
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_IIR
)paren
op_rshift
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|scratch
op_eq
l_int|7
)paren
(brace
id|su_outb
c_func
(paren
id|info
comma
id|UART_LCR
comma
l_int|0
)paren
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
id|scratch
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_IIR
)paren
op_rshift
l_int|5
suffix:semicolon
r_if
c_cond
(paren
id|scratch
op_eq
l_int|6
)paren
id|info-&gt;type
op_assign
id|PORT_16750
suffix:semicolon
)brace
id|su_outb
c_func
(paren
id|info
comma
id|UART_FCR
comma
id|UART_FCR_ENABLE_FIFO
)paren
suffix:semicolon
)brace
id|su_outb
c_func
(paren
id|info
comma
id|UART_LCR
comma
id|scratch2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;type
op_eq
id|PORT_16450
)paren
(brace
id|scratch
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_SCR
)paren
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_SCR
comma
l_int|0xa5
)paren
suffix:semicolon
id|status1
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_SCR
)paren
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_SCR
comma
l_int|0x5a
)paren
suffix:semicolon
id|status2
op_assign
id|su_inb
c_func
(paren
id|info
comma
id|UART_SCR
)paren
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_SCR
comma
id|scratch
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status1
op_ne
l_int|0xa5
)paren
op_logical_or
(paren
id|status2
op_ne
l_int|0x5a
)paren
)paren
id|info-&gt;type
op_assign
id|PORT_8250
suffix:semicolon
)brace
r_if
c_cond
(paren
id|info-&gt;type
op_eq
id|PORT_UNKNOWN
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|info-&gt;name
comma
l_string|&quot;su(%s)&quot;
comma
id|info-&gt;ms_node
ques
c_cond
l_string|&quot;mouse&quot;
suffix:colon
l_string|&quot;kbd&quot;
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|info-&gt;port
comma
l_int|8
comma
id|info-&gt;name
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Reset the UART.&n;&t; */
id|su_outb
c_func
(paren
id|info
comma
id|UART_MCR
comma
l_int|0x00
)paren
suffix:semicolon
id|su_outb
c_func
(paren
id|info
comma
id|UART_FCR
comma
(paren
id|UART_FCR_CLEAR_RCVR
op_or
id|UART_FCR_CLEAR_XMIT
)paren
)paren
suffix:semicolon
id|su_inb
c_func
(paren
id|info
comma
id|UART_RX
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The serial driver boot-time initialization code!&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|su_init
c_func
(paren
r_void
)paren
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|su_struct
op_star
id|info
suffix:semicolon
id|show_su_version
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|info
op_assign
id|su_table
suffix:semicolon
id|i
OL
id|NR_PORTS
suffix:semicolon
id|i
op_increment
comma
id|info
op_increment
)paren
(brace
id|info-&gt;line
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;kbd_node
)paren
id|info-&gt;cflag
op_assign
id|B1200
op_or
id|CS8
op_or
id|CREAD
suffix:semicolon
r_else
id|info-&gt;cflag
op_assign
id|B4800
op_or
id|CS8
op_or
id|CREAD
suffix:semicolon
id|autoconfig
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;type
op_eq
id|PORT_UNKNOWN
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s at %16lx (irq = %08x) is a %s&bslash;n&quot;
comma
id|info-&gt;name
comma
id|info-&gt;port
comma
id|info-&gt;irq
comma
id|uart_config
(braket
id|info-&gt;type
)braket
dot
id|name
)paren
suffix:semicolon
id|startup
c_func
(paren
id|info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;kbd_node
)paren
id|keyboard_zsinit
c_func
(paren
id|su_put_char
)paren
suffix:semicolon
r_else
id|sun_mouse_zsinit
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|su_probe
(paren
r_int
r_int
op_star
id|memory_start
)paren
)paren
(brace
r_struct
id|su_struct
op_star
id|info
op_assign
id|su_table
suffix:semicolon
r_int
id|node
comma
id|enode
comma
id|tnode
comma
id|sunode
suffix:semicolon
r_int
id|kbnode
op_assign
l_int|0
comma
id|msnode
op_assign
l_int|0
suffix:semicolon
r_int
id|devices
op_assign
l_int|0
suffix:semicolon
r_char
id|prop
(braket
l_int|128
)braket
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/*&n;&t; * Get the nodes for keyboard and mouse from &squot;aliases&squot;...&n;&t; */
id|node
op_assign
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
suffix:semicolon
id|node
op_assign
id|prom_searchsiblings
c_func
(paren
id|node
comma
l_string|&quot;aliases&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|len
op_assign
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;keyboard&quot;
comma
id|prop
comma
r_sizeof
(paren
id|prop
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|prop
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|kbnode
op_assign
id|prom_finddevice
c_func
(paren
id|prop
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|kbnode
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|len
op_assign
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;mouse&quot;
comma
id|prop
comma
r_sizeof
(paren
id|prop
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|prop
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
id|msnode
op_assign
id|prom_finddevice
c_func
(paren
id|prop
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|msnode
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/*&n;&t; * Find matching EBus nodes...&n;&t; */
id|node
op_assign
id|prom_getchild
c_func
(paren
id|prom_root_node
)paren
suffix:semicolon
id|node
op_assign
id|prom_searchsiblings
c_func
(paren
id|node
comma
l_string|&quot;pci&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for SUNW,sabre on Ultra 5/10/AXi.&n;&t; */
id|len
op_assign
id|prom_getproperty
c_func
(paren
id|node
comma
l_string|&quot;model&quot;
comma
id|prop
comma
r_sizeof
(paren
id|prop
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|len
OG
l_int|0
)paren
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|prop
comma
l_string|&quot;SUNW,sabre&quot;
comma
id|len
)paren
)paren
(brace
id|node
op_assign
id|prom_getchild
c_func
(paren
id|node
)paren
suffix:semicolon
id|node
op_assign
id|prom_searchsiblings
c_func
(paren
id|node
comma
l_string|&quot;pci&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For each PCI bus...&n;&t; */
r_while
c_loop
(paren
id|node
)paren
(brace
id|enode
op_assign
id|prom_getchild
c_func
(paren
id|node
)paren
suffix:semicolon
id|enode
op_assign
id|prom_searchsiblings
c_func
(paren
id|enode
comma
l_string|&quot;ebus&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * For each EBus on this PCI...&n;&t;&t; */
r_while
c_loop
(paren
id|enode
)paren
(brace
id|sunode
op_assign
id|prom_getchild
c_func
(paren
id|enode
)paren
suffix:semicolon
id|tnode
op_assign
id|prom_searchsiblings
c_func
(paren
id|sunode
comma
l_string|&quot;su&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tnode
)paren
id|tnode
op_assign
id|prom_searchsiblings
c_func
(paren
id|sunode
comma
l_string|&quot;su_pnp&quot;
)paren
suffix:semicolon
id|sunode
op_assign
id|tnode
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * For each &squot;su&squot; on this EBus...&n;&t;&t;&t; */
r_while
c_loop
(paren
id|sunode
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Does it match?&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|sunode
op_eq
id|kbnode
)paren
(brace
id|info-&gt;kbd_node
op_assign
id|sunode
suffix:semicolon
op_increment
id|info
suffix:semicolon
op_increment
id|devices
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sunode
op_eq
id|msnode
)paren
(brace
id|info-&gt;ms_node
op_assign
id|sunode
suffix:semicolon
op_increment
id|info
suffix:semicolon
op_increment
id|devices
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Found everything we need?&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|devices
op_eq
id|NR_PORTS
)paren
r_goto
id|found
suffix:semicolon
id|sunode
op_assign
id|prom_getsibling
c_func
(paren
id|sunode
)paren
suffix:semicolon
id|tnode
op_assign
id|prom_searchsiblings
c_func
(paren
id|sunode
comma
l_string|&quot;su&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tnode
)paren
id|tnode
op_assign
id|prom_searchsiblings
c_func
(paren
id|sunode
comma
l_string|&quot;su_pnp&quot;
)paren
suffix:semicolon
id|sunode
op_assign
id|tnode
suffix:semicolon
)brace
id|enode
op_assign
id|prom_getsibling
c_func
(paren
id|enode
)paren
suffix:semicolon
id|enode
op_assign
id|prom_searchsiblings
c_func
(paren
id|enode
comma
l_string|&quot;ebus&quot;
)paren
suffix:semicolon
)brace
id|node
op_assign
id|prom_getsibling
c_func
(paren
id|node
)paren
suffix:semicolon
id|node
op_assign
id|prom_searchsiblings
c_func
(paren
id|node
comma
l_string|&quot;pci&quot;
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENODEV
suffix:semicolon
id|found
suffix:colon
id|sunserial_setinitfunc
c_func
(paren
id|memory_start
comma
id|su_init
)paren
suffix:semicolon
id|rs_ops.rs_change_mouse_baud
op_assign
id|su_change_mouse_baud
suffix:semicolon
id|sunkbd_setinitfunc
c_func
(paren
id|memory_start
comma
id|sun_kbd_init
)paren
suffix:semicolon
id|kbd_ops.compute_shiftstate
op_assign
id|sun_compute_shiftstate
suffix:semicolon
id|kbd_ops.setledstate
op_assign
id|sun_setledstate
suffix:semicolon
id|kbd_ops.getledstate
op_assign
id|sun_getledstate
suffix:semicolon
id|kbd_ops.setkeycode
op_assign
id|sun_setkeycode
suffix:semicolon
id|kbd_ops.getkeycode
op_assign
id|sun_getkeycode
suffix:semicolon
id|sunkbd_install_keymaps
c_func
(paren
id|memory_start
comma
id|sun_key_maps
comma
id|sun_keymap_count
comma
id|sun_func_buf
comma
id|sun_func_table
comma
id|sun_funcbufsize
comma
id|sun_funcbufleft
comma
id|sun_accent_table
comma
id|sun_accent_table_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
