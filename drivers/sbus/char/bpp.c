multiline_comment|/*&n; * drivers/sbus/char/bpp.c&n; *&n; * Copyright (c) 1995 Picture Elements&n; *      Stephen Williams (steve@icarus.com)&n; *      Gus Baldauf (gbaldauf@ix.netcom.com)&n; *&n; * Linux/SPARC port by Peter Zaitcev.&n; * Integration into SPARC tree by Tom Dyas.&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#if defined(__i386__)
macro_line|# include &lt;asm/system.h&gt;
macro_line|# include &lt;asm/segment.h&gt;
macro_line|#endif
macro_line|#if defined(__sparc__)
macro_line|# include &lt;linux/init.h&gt;
macro_line|# include &lt;linux/delay.h&gt;         /* udelay() */
macro_line|# include &lt;asm/oplib.h&gt;           /* OpenProm Library */
macro_line|# include &lt;asm/sbus.h&gt;
macro_line|#endif
macro_line|#include &lt;asm/bpp.h&gt;
DECL|macro|BPP_PROBE_CODE
mdefine_line|#define BPP_PROBE_CODE 0x55
DECL|macro|BPP_DELAY
mdefine_line|#define BPP_DELAY 100
DECL|variable|BPP_MAJOR
r_static
r_const
r_int
id|BPP_MAJOR
op_assign
id|LP_MAJOR
suffix:semicolon
DECL|variable|dev_name
r_static
r_const
r_char
op_star
id|dev_name
op_assign
l_string|&quot;bpp&quot;
suffix:semicolon
multiline_comment|/* When switching from compatibility to a mode where I can read, try&n;   the following mode first. */
multiline_comment|/* const unsigned char DEFAULT_ECP = 0x10; */
DECL|variable|DEFAULT_ECP
r_static
r_const
r_int
r_char
id|DEFAULT_ECP
op_assign
l_int|0x30
suffix:semicolon
DECL|variable|DEFAULT_NIBBLE
r_static
r_const
r_int
r_char
id|DEFAULT_NIBBLE
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/*&n; * These are 1284 time constraints, in units of jiffies.&n; */
DECL|variable|TIME_PSetup
r_static
r_const
r_int
r_int
id|TIME_PSetup
op_assign
l_int|1
suffix:semicolon
DECL|variable|TIME_PResponse
r_static
r_const
r_int
r_int
id|TIME_PResponse
op_assign
l_int|6
suffix:semicolon
DECL|variable|TIME_IDLE_LIMIT
r_static
r_const
r_int
r_int
id|TIME_IDLE_LIMIT
op_assign
l_int|2000
suffix:semicolon
multiline_comment|/*&n; * One instance per supported subdevice...&n; */
DECL|macro|BPP_NO
macro_line|# define BPP_NO 3
DECL|enum|IEEE_Mode
DECL|enumerator|COMPATIBILITY
DECL|enumerator|NIBBLE
DECL|enumerator|ECP
DECL|enumerator|ECP_RLE
DECL|enumerator|EPP
r_enum
id|IEEE_Mode
(brace
id|COMPATIBILITY
comma
id|NIBBLE
comma
id|ECP
comma
id|ECP_RLE
comma
id|EPP
)brace
suffix:semicolon
DECL|struct|inst
r_struct
id|inst
(brace
DECL|member|present
r_int
id|present
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* True if the hardware exists */
DECL|member|enhanced
r_int
id|enhanced
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* True if the hardware in &quot;enhanced&quot; */
DECL|member|opened
r_int
id|opened
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* True if the device is opened already */
DECL|member|run_flag
r_int
id|run_flag
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* True if waiting for a repeate byte */
DECL|member|direction
r_int
r_char
id|direction
suffix:semicolon
multiline_comment|/* 0 --&gt; out, 0x20 --&gt; IN */
DECL|member|pp_state
r_int
r_char
id|pp_state
suffix:semicolon
multiline_comment|/* State of host controlled pins. */
DECL|member|mode
r_enum
id|IEEE_Mode
id|mode
suffix:semicolon
DECL|member|run_length
r_int
r_char
id|run_length
suffix:semicolon
DECL|member|repeat_byte
r_int
r_char
id|repeat_byte
suffix:semicolon
multiline_comment|/* These members manage timeouts for programmed delays */
DECL|member|wait_queue
id|wait_queue_head_t
id|wait_queue
suffix:semicolon
DECL|member|timer_list
r_struct
id|timer_list
id|timer_list
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|instances
r_static
r_struct
id|inst
id|instances
(braket
id|BPP_NO
)braket
suffix:semicolon
macro_line|#if defined(__i386__)
DECL|variable|base_addrs
r_const
r_int
r_int
id|base_addrs
(braket
id|BPP_NO
)braket
op_assign
(brace
l_int|0x278
comma
l_int|0x378
comma
l_int|0x3bc
)brace
suffix:semicolon
multiline_comment|/*&n; * These are for data access.&n; * Control lines accesses are hidden in set_bits() and get_bits().&n; * The exeption is the probe procedure, which is system-dependent.&n; */
DECL|macro|bpp_outb_p
mdefine_line|#define bpp_outb_p(data, base)  outb_p((data), (base))
DECL|macro|bpp_inb
mdefine_line|#define bpp_inb(base)  inb(base)
DECL|macro|bpp_inb_p
mdefine_line|#define bpp_inb_p(base)  inb_p(base)
multiline_comment|/*&n; * This method takes the pin values mask and sets the hardware pins to&n; * the requested value: 1 == high voltage, 0 == low voltage. This&n; * burries the annoying PC bit inversion and preserves the direction&n; * flag.&n; */
DECL|function|set_pins
r_static
r_void
id|set_pins
c_func
(paren
r_int
r_int
id|pins
comma
r_int
id|minor
)paren
(brace
r_int
r_char
id|bits
op_assign
id|instances
(braket
id|minor
)braket
dot
id|direction
suffix:semicolon
multiline_comment|/* == 0x20 */
r_if
c_cond
(paren
op_logical_neg
(paren
id|pins
op_amp
id|BPP_PP_nStrobe
)paren
)paren
id|bits
op_or_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pins
op_amp
id|BPP_PP_nAutoFd
)paren
)paren
id|bits
op_or_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|pins
op_amp
id|BPP_PP_nInit
)paren
id|bits
op_or_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pins
op_amp
id|BPP_PP_nSelectIn
)paren
)paren
id|bits
op_or_assign
l_int|8
suffix:semicolon
id|instances
(braket
id|minor
)braket
dot
id|pp_state
op_assign
id|bits
suffix:semicolon
id|outb_p
c_func
(paren
id|bits
comma
id|base_addrs
(braket
id|minor
)braket
op_plus
l_int|2
)paren
suffix:semicolon
)brace
DECL|function|get_pins
r_static
r_int
r_int
id|get_pins
c_func
(paren
r_int
id|minor
)paren
(brace
r_int
r_int
id|bits
op_assign
l_int|0
suffix:semicolon
r_int
id|value
op_assign
id|instances
(braket
id|minor
)braket
dot
id|pp_state
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|value
op_amp
l_int|0x01
)paren
)paren
id|bits
op_or_assign
id|BPP_PP_nStrobe
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|value
op_amp
l_int|0x02
)paren
)paren
id|bits
op_or_assign
id|BPP_PP_nAutoFd
suffix:semicolon
r_if
c_cond
(paren
id|value
op_amp
l_int|0x04
)paren
id|bits
op_or_assign
id|BPP_PP_nInit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|value
op_amp
l_int|0x08
)paren
)paren
id|bits
op_or_assign
id|BPP_PP_nSelectIn
suffix:semicolon
id|value
op_assign
id|inb_p
c_func
(paren
id|base_addrs
(braket
id|minor
)braket
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value
op_amp
l_int|0x08
)paren
id|bits
op_or_assign
id|BPP_GP_nFault
suffix:semicolon
r_if
c_cond
(paren
id|value
op_amp
l_int|0x10
)paren
id|bits
op_or_assign
id|BPP_GP_Select
suffix:semicolon
r_if
c_cond
(paren
id|value
op_amp
l_int|0x20
)paren
id|bits
op_or_assign
id|BPP_GP_PError
suffix:semicolon
r_if
c_cond
(paren
id|value
op_amp
l_int|0x40
)paren
id|bits
op_or_assign
id|BPP_GP_nAck
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|value
op_amp
l_int|0x80
)paren
)paren
id|bits
op_or_assign
id|BPP_GP_Busy
suffix:semicolon
r_return
id|bits
suffix:semicolon
)brace
macro_line|#endif /* __i386__ */
macro_line|#if defined(__sparc__)
multiline_comment|/*&n; * Register block&n; */
multiline_comment|/* DMA registers */
DECL|macro|BPP_CSR
mdefine_line|#define BPP_CSR      0x00
DECL|macro|BPP_ADDR
mdefine_line|#define BPP_ADDR     0x04
DECL|macro|BPP_BCNT
mdefine_line|#define BPP_BCNT     0x08
DECL|macro|BPP_TST_CSR
mdefine_line|#define BPP_TST_CSR  0x0C
multiline_comment|/* Parallel Port registers */
DECL|macro|BPP_HCR
mdefine_line|#define BPP_HCR      0x10
DECL|macro|BPP_OCR
mdefine_line|#define BPP_OCR      0x12
DECL|macro|BPP_DR
mdefine_line|#define BPP_DR       0x14
DECL|macro|BPP_TCR
mdefine_line|#define BPP_TCR      0x15
DECL|macro|BPP_OR
mdefine_line|#define BPP_OR       0x16
DECL|macro|BPP_IR
mdefine_line|#define BPP_IR       0x17
DECL|macro|BPP_ICR
mdefine_line|#define BPP_ICR      0x18
DECL|macro|BPP_SIZE
mdefine_line|#define BPP_SIZE     0x1A
multiline_comment|/* BPP_CSR.  Bits of type RW1 are cleared with writting &squot;1&squot;. */
DECL|macro|P_DEV_ID_MASK
mdefine_line|#define P_DEV_ID_MASK   0xf0000000      /* R   */
DECL|macro|P_DEV_ID_ZEBRA
mdefine_line|#define P_DEV_ID_ZEBRA  0x40000000
DECL|macro|P_DEV_ID_L64854
mdefine_line|#define P_DEV_ID_L64854 0xa0000000      /*      == NCR 89C100+89C105. Pity. */
DECL|macro|P_NA_LOADED
mdefine_line|#define P_NA_LOADED     0x08000000      /* R    NA wirtten but was not used */
DECL|macro|P_A_LOADED
mdefine_line|#define P_A_LOADED      0x04000000      /* R    */
DECL|macro|P_DMA_ON
mdefine_line|#define P_DMA_ON        0x02000000      /* R    DMA is not disabled */
DECL|macro|P_EN_NEXT
mdefine_line|#define P_EN_NEXT       0x01000000      /* RW   */
DECL|macro|P_TCI_DIS
mdefine_line|#define P_TCI_DIS       0x00800000      /* RW   TCI forbidden from interrupts */
DECL|macro|P_DIAG
mdefine_line|#define P_DIAG          0x00100000      /* RW   Disables draining and resetting&n;                                                of P-FIFO on loading of P_ADDR*/
DECL|macro|P_BURST_SIZE
mdefine_line|#define P_BURST_SIZE    0x000c0000      /* RW   SBus burst size */
DECL|macro|P_BURST_8
mdefine_line|#define P_BURST_8       0x00000000
DECL|macro|P_BURST_4
mdefine_line|#define P_BURST_4       0x00040000
DECL|macro|P_BURST_1
mdefine_line|#define P_BURST_1       0x00080000      /*      &quot;No burst&quot; write */
DECL|macro|P_TC
mdefine_line|#define P_TC            0x00004000      /* RW1  Term Count, can be cleared when&n;                                           P_EN_NEXT=1 */
DECL|macro|P_EN_CNT
mdefine_line|#define P_EN_CNT        0x00002000      /* RW   */
DECL|macro|P_EN_DMA
mdefine_line|#define P_EN_DMA        0x00000200      /* RW   */
DECL|macro|P_WRITE
mdefine_line|#define P_WRITE         0x00000100      /* R    DMA dir, 1=to ram, 0=to port */
DECL|macro|P_RESET
mdefine_line|#define P_RESET         0x00000080      /* RW   */
DECL|macro|P_SLAVE_ERR
mdefine_line|#define P_SLAVE_ERR     0x00000040      /* RW1  Access size error */
DECL|macro|P_INVALIDATE
mdefine_line|#define P_INVALIDATE    0x00000020      /* W    Drop P-FIFO */
DECL|macro|P_INT_EN
mdefine_line|#define P_INT_EN        0x00000010      /* RW   OK to P_INT_PEND||P_ERR_PEND */
DECL|macro|P_DRAINING
mdefine_line|#define P_DRAINING      0x0000000c      /* R    P-FIFO is draining to memory */
DECL|macro|P_ERR_PEND
mdefine_line|#define P_ERR_PEND      0x00000002      /* R    */
DECL|macro|P_INT_PEND
mdefine_line|#define P_INT_PEND      0x00000001      /* R    */
multiline_comment|/* BPP_HCR. Time is in increments of SBus clock. */
DECL|macro|P_HCR_TEST
mdefine_line|#define P_HCR_TEST      0x8000      /* Allows buried counters to be read */
DECL|macro|P_HCR_DSW
mdefine_line|#define P_HCR_DSW       0x7f00      /* Data strobe width (in ticks) */
DECL|macro|P_HCR_DDS
mdefine_line|#define P_HCR_DDS       0x007f      /* Data setup before strobe (in ticks) */
multiline_comment|/* BPP_OCR. */
DECL|macro|P_OCR_MEM_CLR
mdefine_line|#define P_OCR_MEM_CLR   0x8000
DECL|macro|P_OCR_DATA_SRC
mdefine_line|#define P_OCR_DATA_SRC  0x4000      /* )                  */
DECL|macro|P_OCR_DS_DSEL
mdefine_line|#define P_OCR_DS_DSEL   0x2000      /* )  Bidirectional      */
DECL|macro|P_OCR_BUSY_DSEL
mdefine_line|#define P_OCR_BUSY_DSEL 0x1000      /* )    selects            */
DECL|macro|P_OCR_ACK_DSEL
mdefine_line|#define P_OCR_ACK_DSEL  0x0800      /* )                  */
DECL|macro|P_OCR_EN_DIAG
mdefine_line|#define P_OCR_EN_DIAG   0x0400
DECL|macro|P_OCR_BUSY_OP
mdefine_line|#define P_OCR_BUSY_OP   0x0200      /* Busy operation */
DECL|macro|P_OCR_ACK_OP
mdefine_line|#define P_OCR_ACK_OP    0x0100      /* Ack operation */
DECL|macro|P_OCR_SRST
mdefine_line|#define P_OCR_SRST      0x0080      /* Reset state machines. Not selfcleaning. */
DECL|macro|P_OCR_IDLE
mdefine_line|#define P_OCR_IDLE      0x0008      /* PP data transfer state machine is idle */
DECL|macro|P_OCR_V_ILCK
mdefine_line|#define P_OCR_V_ILCK    0x0002      /* Versatec faded. Zebra only. */
DECL|macro|P_OCR_EN_VER
mdefine_line|#define P_OCR_EN_VER    0x0001      /* Enable Versatec (0 - enable). Zebra only. */
multiline_comment|/* BPP_TCR */
DECL|macro|P_TCR_DIR
mdefine_line|#define P_TCR_DIR       0x08
DECL|macro|P_TCR_BUSY
mdefine_line|#define P_TCR_BUSY      0x04
DECL|macro|P_TCR_ACK
mdefine_line|#define P_TCR_ACK       0x02
DECL|macro|P_TCR_DS
mdefine_line|#define P_TCR_DS        0x01        /* Strobe */
multiline_comment|/* BPP_OR */
DECL|macro|P_OR_V3
mdefine_line|#define P_OR_V3         0x20        /* )                 */
DECL|macro|P_OR_V2
mdefine_line|#define P_OR_V2         0x10        /* ) on Zebra only   */
DECL|macro|P_OR_V1
mdefine_line|#define P_OR_V1         0x08        /* )                 */
DECL|macro|P_OR_INIT
mdefine_line|#define P_OR_INIT       0x04
DECL|macro|P_OR_AFXN
mdefine_line|#define P_OR_AFXN       0x02        /* Auto Feed */
DECL|macro|P_OR_SLCT_IN
mdefine_line|#define P_OR_SLCT_IN    0x01
multiline_comment|/* BPP_IR */
DECL|macro|P_IR_PE
mdefine_line|#define P_IR_PE         0x04
DECL|macro|P_IR_SLCT
mdefine_line|#define P_IR_SLCT       0x02
DECL|macro|P_IR_ERR
mdefine_line|#define P_IR_ERR        0x01
multiline_comment|/* BPP_ICR */
DECL|macro|P_DS_IRQ
mdefine_line|#define P_DS_IRQ        0x8000      /* RW1  */
DECL|macro|P_ACK_IRQ
mdefine_line|#define P_ACK_IRQ       0x4000      /* RW1  */
DECL|macro|P_BUSY_IRQ
mdefine_line|#define P_BUSY_IRQ      0x2000      /* RW1  */
DECL|macro|P_PE_IRQ
mdefine_line|#define P_PE_IRQ        0x1000      /* RW1  */
DECL|macro|P_SLCT_IRQ
mdefine_line|#define P_SLCT_IRQ      0x0800      /* RW1  */
DECL|macro|P_ERR_IRQ
mdefine_line|#define P_ERR_IRQ       0x0400      /* RW1  */
DECL|macro|P_DS_IRQ_EN
mdefine_line|#define P_DS_IRQ_EN     0x0200      /* RW   Always on rising edge */
DECL|macro|P_ACK_IRQ_EN
mdefine_line|#define P_ACK_IRQ_EN    0x0100      /* RW   Always on rising edge */
DECL|macro|P_BUSY_IRP
mdefine_line|#define P_BUSY_IRP      0x0080      /* RW   1= rising edge */
DECL|macro|P_BUSY_IRQ_EN
mdefine_line|#define P_BUSY_IRQ_EN   0x0040      /* RW   */
DECL|macro|P_PE_IRP
mdefine_line|#define P_PE_IRP        0x0020      /* RW   1= rising edge */
DECL|macro|P_PE_IRQ_EN
mdefine_line|#define P_PE_IRQ_EN     0x0010      /* RW   */
DECL|macro|P_SLCT_IRP
mdefine_line|#define P_SLCT_IRP      0x0008      /* RW   1= rising edge */
DECL|macro|P_SLCT_IRQ_EN
mdefine_line|#define P_SLCT_IRQ_EN   0x0004      /* RW   */
DECL|macro|P_ERR_IRP
mdefine_line|#define P_ERR_IRP       0x0002      /* RW1  1= rising edge */
DECL|macro|P_ERR_IRQ_EN
mdefine_line|#define P_ERR_IRQ_EN    0x0001      /* RW   */
DECL|variable|base_addrs
r_int
r_int
id|base_addrs
(braket
id|BPP_NO
)braket
suffix:semicolon
DECL|macro|bpp_outb_p
mdefine_line|#define bpp_outb_p(data, base)&t;sbus_writeb(data, (base) + BPP_DR)
DECL|macro|bpp_inb_p
mdefine_line|#define bpp_inb_p(base)&t;&t;sbus_readb((base) + BPP_DR)
DECL|macro|bpp_inb
mdefine_line|#define bpp_inb(base)&t;&t;sbus_readb((base) + BPP_DR)
DECL|function|set_pins
r_static
r_void
id|set_pins
c_func
(paren
r_int
r_int
id|pins
comma
r_int
id|minor
)paren
(brace
r_int
r_int
id|base
op_assign
id|base_addrs
(braket
id|minor
)braket
suffix:semicolon
r_int
r_char
id|bits_tcr
op_assign
l_int|0
comma
id|bits_or
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|instances
(braket
id|minor
)braket
dot
id|direction
op_amp
l_int|0x20
)paren
id|bits_tcr
op_or_assign
id|P_TCR_DIR
suffix:semicolon
r_if
c_cond
(paren
id|pins
op_amp
id|BPP_PP_nStrobe
)paren
id|bits_tcr
op_or_assign
id|P_TCR_DS
suffix:semicolon
r_if
c_cond
(paren
id|pins
op_amp
id|BPP_PP_nAutoFd
)paren
id|bits_or
op_or_assign
id|P_OR_AFXN
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pins
op_amp
id|BPP_PP_nInit
)paren
)paren
id|bits_or
op_or_assign
id|P_OR_INIT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|pins
op_amp
id|BPP_PP_nSelectIn
)paren
)paren
id|bits_or
op_or_assign
id|P_OR_SLCT_IN
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|bits_or
comma
id|base
op_plus
id|BPP_OR
)paren
suffix:semicolon
id|sbus_writeb
c_func
(paren
id|bits_tcr
comma
id|base
op_plus
id|BPP_TCR
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * i386 people read output pins from a software image.&n; * We may get them back from hardware.&n; * Again, inversion of pins must he buried here.&n; */
DECL|function|get_pins
r_static
r_int
r_int
id|get_pins
c_func
(paren
r_int
id|minor
)paren
(brace
r_int
r_int
id|base
op_assign
id|base_addrs
(braket
id|minor
)braket
suffix:semicolon
r_int
r_int
id|bits
op_assign
l_int|0
suffix:semicolon
r_int
id|value_tcr
op_assign
id|sbus_readb
c_func
(paren
id|base
op_plus
id|BPP_TCR
)paren
suffix:semicolon
r_int
id|value_ir
op_assign
id|sbus_readb
c_func
(paren
id|base
op_plus
id|BPP_IR
)paren
suffix:semicolon
r_int
id|value_or
op_assign
id|sbus_readb
c_func
(paren
id|base
op_plus
id|BPP_OR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|value_tcr
op_amp
id|P_TCR_DS
)paren
id|bits
op_or_assign
id|BPP_PP_nStrobe
suffix:semicolon
r_if
c_cond
(paren
id|value_or
op_amp
id|P_OR_AFXN
)paren
id|bits
op_or_assign
id|BPP_PP_nAutoFd
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|value_or
op_amp
id|P_OR_INIT
)paren
)paren
id|bits
op_or_assign
id|BPP_PP_nInit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|value_or
op_amp
id|P_OR_SLCT_IN
)paren
)paren
id|bits
op_or_assign
id|BPP_PP_nSelectIn
suffix:semicolon
r_if
c_cond
(paren
id|value_ir
op_amp
id|P_IR_ERR
)paren
id|bits
op_or_assign
id|BPP_GP_nFault
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|value_ir
op_amp
id|P_IR_SLCT
)paren
)paren
id|bits
op_or_assign
id|BPP_GP_Select
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|value_ir
op_amp
id|P_IR_PE
)paren
)paren
id|bits
op_or_assign
id|BPP_GP_PError
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|value_tcr
op_amp
id|P_TCR_ACK
)paren
)paren
id|bits
op_or_assign
id|BPP_GP_nAck
suffix:semicolon
r_if
c_cond
(paren
id|value_tcr
op_amp
id|P_TCR_BUSY
)paren
id|bits
op_or_assign
id|BPP_GP_Busy
suffix:semicolon
r_return
id|bits
suffix:semicolon
)brace
macro_line|#endif /* __sparc__ */
DECL|function|bpp_wake_up
r_static
r_void
id|bpp_wake_up
c_func
(paren
r_int
r_int
id|val
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|instances
(braket
id|val
)braket
dot
id|wait_queue
)paren
suffix:semicolon
)brace
DECL|function|snooze
r_static
r_void
id|snooze
c_func
(paren
r_int
r_int
id|snooze_time
comma
r_int
id|minor
)paren
(brace
id|instances
(braket
id|minor
)braket
dot
id|timer_list.expires
op_assign
id|jiffies
op_plus
id|snooze_time
op_plus
l_int|1
suffix:semicolon
id|instances
(braket
id|minor
)braket
dot
id|timer_list.data
op_assign
id|minor
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|instances
(braket
id|minor
)braket
dot
id|timer_list
)paren
suffix:semicolon
id|sleep_on
(paren
op_amp
id|instances
(braket
id|minor
)braket
dot
id|wait_queue
)paren
suffix:semicolon
)brace
DECL|function|wait_for
r_static
r_int
id|wait_for
c_func
(paren
r_int
r_int
id|set
comma
r_int
r_int
id|clr
comma
r_int
r_int
id|delay
comma
r_int
id|minor
)paren
(brace
r_int
r_int
id|pins
op_assign
id|get_pins
c_func
(paren
id|minor
)paren
suffix:semicolon
r_int
r_int
id|extime
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;       * Try a real fast scan for the first jiffy, in case the device&n;       * responds real good. The first while loop guesses an expire&n;       * time accounting for possible wraparound of jiffies.&n;       */
r_while
c_loop
(paren
id|time_after_eq
c_func
(paren
id|jiffies
comma
id|extime
)paren
)paren
id|extime
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|extime
)paren
)paren
op_logical_and
(paren
(paren
(paren
id|pins
op_amp
id|set
)paren
op_ne
id|set
)paren
op_logical_or
(paren
(paren
id|pins
op_amp
id|clr
)paren
op_ne
l_int|0
)paren
)paren
)paren
(brace
id|pins
op_assign
id|get_pins
c_func
(paren
id|minor
)paren
suffix:semicolon
)brace
id|delay
op_sub_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;       * If my delay expired or the pins are still not where I want&n;       * them, then resort to using the timer and greatly reduce my&n;       * sample rate. If the peripheral is going to be slow, this will&n;       * give the CPU up to some more worthy process.&n;       */
r_while
c_loop
(paren
id|delay
op_logical_and
(paren
(paren
(paren
id|pins
op_amp
id|set
)paren
op_ne
id|set
)paren
op_logical_or
(paren
(paren
id|pins
op_amp
id|clr
)paren
op_ne
l_int|0
)paren
)paren
)paren
(brace
id|snooze
c_func
(paren
l_int|1
comma
id|minor
)paren
suffix:semicolon
id|pins
op_assign
id|get_pins
c_func
(paren
id|minor
)paren
suffix:semicolon
id|delay
op_sub_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|delay
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_else
r_return
id|pins
suffix:semicolon
)brace
multiline_comment|/*&n; * Return ZERO(0) If the negotiation succeeds, an errno otherwise. An&n; * errno means something broke, and I do not yet know how to fix it.&n; */
DECL|function|negotiate
r_static
r_int
id|negotiate
c_func
(paren
r_int
r_char
id|mode
comma
r_int
id|minor
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
r_int
id|pins
op_assign
id|get_pins
c_func
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pins
op_amp
id|BPP_PP_nSelectIn
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* Event 0: Write the mode to the data lines */
id|bpp_outb_p
c_func
(paren
id|mode
comma
id|base_addrs
(braket
id|minor
)braket
)paren
suffix:semicolon
id|snooze
c_func
(paren
id|TIME_PSetup
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Event 1: Strobe the mode code into the peripheral */
id|set_pins
c_func
(paren
id|BPP_PP_nSelectIn
op_or
id|BPP_PP_nStrobe
op_or
id|BPP_PP_nInit
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Wait for Event 2: Peripheral responds as a 1284 device. */
id|rc
op_assign
id|wait_for
c_func
(paren
id|BPP_GP_PError
op_or
id|BPP_GP_Select
op_or
id|BPP_GP_nFault
comma
id|BPP_GP_nAck
comma
id|TIME_PResponse
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
multiline_comment|/* Event 3: latch extensibility request */
id|set_pins
c_func
(paren
id|BPP_PP_nSelectIn
op_or
id|BPP_PP_nInit
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* ... quick nap while peripheral ponders the byte i&squot;m sending...*/
id|snooze
c_func
(paren
l_int|1
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Event 4: restore strobe, to ACK peripheral&squot;s response. */
id|set_pins
c_func
(paren
id|BPP_PP_nSelectIn
op_or
id|BPP_PP_nAutoFd
op_or
id|BPP_PP_nStrobe
op_or
id|BPP_PP_nInit
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Wait for Event 6: Peripheral latches response bits */
id|rc
op_assign
id|wait_for
c_func
(paren
id|BPP_GP_nAck
comma
l_int|0
comma
id|TIME_PSetup
op_plus
id|TIME_PResponse
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* A 1284 device cannot refuse nibble mode */
r_if
c_cond
(paren
id|mode
op_eq
id|DEFAULT_NIBBLE
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pins
op_amp
id|BPP_GP_Select
)paren
r_return
l_int|0
suffix:semicolon
r_return
op_minus
id|EPROTONOSUPPORT
suffix:semicolon
)brace
DECL|function|terminate
r_static
r_int
id|terminate
c_func
(paren
r_int
id|minor
)paren
(brace
r_int
id|rc
suffix:semicolon
multiline_comment|/* Event 22: Request termination of 1284 mode */
id|set_pins
c_func
(paren
id|BPP_PP_nAutoFd
op_or
id|BPP_PP_nStrobe
op_or
id|BPP_PP_nInit
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Wait for Events 23 and 24: ACK termination request. */
id|rc
op_assign
id|wait_for
c_func
(paren
id|BPP_GP_Busy
op_or
id|BPP_GP_nFault
comma
id|BPP_GP_nAck
comma
id|TIME_PSetup
op_plus
id|TIME_PResponse
comma
id|minor
)paren
suffix:semicolon
id|instances
(braket
id|minor
)braket
dot
id|direction
op_assign
l_int|0
suffix:semicolon
id|instances
(braket
id|minor
)braket
dot
id|mode
op_assign
id|COMPATIBILITY
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Event 25: Handshake by lowering nAutoFd */
id|set_pins
c_func
(paren
id|BPP_PP_nStrobe
op_or
id|BPP_PP_nInit
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Event 26: Peripheral wiggles lines... */
multiline_comment|/* Event 27: Peripheral sets nAck HIGH to ack handshake */
id|rc
op_assign
id|wait_for
c_func
(paren
id|BPP_GP_nAck
comma
l_int|0
comma
id|TIME_PResponse
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
(brace
id|set_pins
c_func
(paren
id|BPP_PP_nAutoFd
op_or
id|BPP_PP_nStrobe
op_or
id|BPP_PP_nInit
comma
id|minor
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Event 28: Finish phase by raising nAutoFd */
id|set_pins
c_func
(paren
id|BPP_PP_nAutoFd
op_or
id|BPP_PP_nStrobe
op_or
id|BPP_PP_nInit
comma
id|minor
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Allow only one process to open the device at a time.&n; */
DECL|function|bpp_open
r_static
r_int
id|bpp_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|f
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|BPP_NO
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|instances
(braket
id|minor
)braket
dot
id|present
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|instances
(braket
id|minor
)braket
dot
id|opened
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|instances
(braket
id|minor
)braket
dot
id|opened
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * When the process closes the device, this method is called to clean&n; * up and reset the hardware. Always leave the device in compatibility&n; * mode as this is a reasonable place to clean up from messes made by&n; * ioctls, or other mayhem.&n; */
DECL|function|bpp_release
r_static
r_int
id|bpp_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|f
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
id|instances
(braket
id|minor
)braket
dot
id|opened
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|instances
(braket
id|minor
)braket
dot
id|mode
op_ne
id|COMPATIBILITY
)paren
id|terminate
c_func
(paren
id|minor
)paren
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_nibble
r_static
r_int
id|read_nibble
c_func
(paren
r_int
id|minor
comma
r_char
op_star
id|c
comma
r_int
r_int
id|cnt
)paren
(brace
r_int
r_int
id|remaining
op_assign
id|cnt
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_while
c_loop
(paren
id|remaining
OG
l_int|0
)paren
(brace
r_int
r_char
id|byte
op_assign
l_int|0
suffix:semicolon
r_int
id|pins
suffix:semicolon
multiline_comment|/* Event 7: request nibble */
id|set_pins
c_func
(paren
id|BPP_PP_nSelectIn
op_or
id|BPP_PP_nStrobe
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Wait for event 9: Peripher strobes first nibble */
id|pins
op_assign
id|wait_for
c_func
(paren
l_int|0
comma
id|BPP_GP_nAck
comma
id|TIME_IDLE_LIMIT
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pins
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
multiline_comment|/* Event 10: I handshake nibble */
id|set_pins
c_func
(paren
id|BPP_PP_nSelectIn
op_or
id|BPP_PP_nStrobe
op_or
id|BPP_PP_nAutoFd
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pins
op_amp
id|BPP_GP_nFault
)paren
id|byte
op_or_assign
l_int|0x01
suffix:semicolon
r_if
c_cond
(paren
id|pins
op_amp
id|BPP_GP_Select
)paren
id|byte
op_or_assign
l_int|0x02
suffix:semicolon
r_if
c_cond
(paren
id|pins
op_amp
id|BPP_GP_PError
)paren
id|byte
op_or_assign
l_int|0x04
suffix:semicolon
r_if
c_cond
(paren
id|pins
op_amp
id|BPP_GP_Busy
)paren
id|byte
op_or_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* Wait for event 11: Peripheral handshakes nibble */
id|rc
op_assign
id|wait_for
c_func
(paren
id|BPP_GP_nAck
comma
l_int|0
comma
id|TIME_PResponse
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Event 7: request nibble */
id|set_pins
c_func
(paren
id|BPP_PP_nSelectIn
op_or
id|BPP_PP_nStrobe
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Wait for event 9: Peripher strobes first nibble */
id|pins
op_assign
id|wait_for
c_func
(paren
l_int|0
comma
id|BPP_GP_nAck
comma
id|TIME_PResponse
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
multiline_comment|/* Event 10: I handshake nibble */
id|set_pins
c_func
(paren
id|BPP_PP_nSelectIn
op_or
id|BPP_PP_nStrobe
op_or
id|BPP_PP_nAutoFd
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pins
op_amp
id|BPP_GP_nFault
)paren
id|byte
op_or_assign
l_int|0x10
suffix:semicolon
r_if
c_cond
(paren
id|pins
op_amp
id|BPP_GP_Select
)paren
id|byte
op_or_assign
l_int|0x20
suffix:semicolon
r_if
c_cond
(paren
id|pins
op_amp
id|BPP_GP_PError
)paren
id|byte
op_or_assign
l_int|0x40
suffix:semicolon
r_if
c_cond
(paren
id|pins
op_amp
id|BPP_GP_Busy
)paren
id|byte
op_or_assign
l_int|0x80
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|byte
comma
id|c
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|c
op_add_assign
l_int|1
suffix:semicolon
id|remaining
op_sub_assign
l_int|1
suffix:semicolon
multiline_comment|/* Wait for event 11: Peripheral handshakes nibble */
id|rc
op_assign
id|wait_for
c_func
(paren
id|BPP_GP_nAck
comma
l_int|0
comma
id|TIME_PResponse
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
id|cnt
op_minus
id|remaining
suffix:semicolon
)brace
DECL|function|read_ecp
r_static
r_int
id|read_ecp
c_func
(paren
r_int
id|minor
comma
r_char
op_star
id|c
comma
r_int
r_int
id|cnt
)paren
(brace
r_int
r_int
id|remaining
suffix:semicolon
r_int
id|rc
suffix:semicolon
multiline_comment|/* Turn ECP mode from forward to reverse if needed. */
r_if
c_cond
(paren
op_logical_neg
id|instances
(braket
id|minor
)braket
dot
id|direction
)paren
(brace
r_int
r_int
id|pins
op_assign
id|get_pins
c_func
(paren
id|minor
)paren
suffix:semicolon
multiline_comment|/* Event 38: Turn the bus around */
id|instances
(braket
id|minor
)braket
dot
id|direction
op_assign
l_int|0x20
suffix:semicolon
id|pins
op_and_assign
op_complement
id|BPP_PP_nAutoFd
suffix:semicolon
id|set_pins
c_func
(paren
id|pins
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Event 39: Set pins for reverse mode. */
id|snooze
c_func
(paren
id|TIME_PSetup
comma
id|minor
)paren
suffix:semicolon
id|set_pins
c_func
(paren
id|BPP_PP_nStrobe
op_or
id|BPP_PP_nSelectIn
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Wait for event 40: Peripheral ready to be strobed */
id|rc
op_assign
id|wait_for
c_func
(paren
l_int|0
comma
id|BPP_GP_PError
comma
id|TIME_PResponse
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
)brace
id|remaining
op_assign
id|cnt
suffix:semicolon
r_while
c_loop
(paren
id|remaining
OG
l_int|0
)paren
(brace
multiline_comment|/* If there is a run length for a repeated byte, repeat */
multiline_comment|/* that byte a few times. */
r_if
c_cond
(paren
id|instances
(braket
id|minor
)braket
dot
id|run_length
op_logical_and
op_logical_neg
id|instances
(braket
id|minor
)braket
dot
id|run_flag
)paren
(brace
r_char
id|buffer
(braket
l_int|128
)braket
suffix:semicolon
r_int
id|idx
suffix:semicolon
r_int
id|repeat
op_assign
id|remaining
OL
id|instances
(braket
id|minor
)braket
dot
id|run_length
ques
c_cond
id|remaining
suffix:colon
id|instances
(braket
id|minor
)braket
dot
id|run_length
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|repeat
suffix:semicolon
id|idx
op_add_assign
l_int|1
)paren
id|buffer
(braket
id|idx
)braket
op_assign
id|instances
(braket
id|minor
)braket
dot
id|repeat_byte
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|c
comma
id|buffer
comma
id|repeat
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|remaining
op_sub_assign
id|repeat
suffix:semicolon
id|c
op_add_assign
id|repeat
suffix:semicolon
id|instances
(braket
id|minor
)braket
dot
id|run_length
op_sub_assign
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|remaining
op_eq
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Wait for Event 43: Data active on the bus. */
id|rc
op_assign
id|wait_for
c_func
(paren
l_int|0
comma
id|BPP_GP_nAck
comma
id|TIME_IDLE_LIMIT
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_amp
id|BPP_GP_Busy
)paren
(brace
multiline_comment|/* OK, this is data. read it in. */
r_int
r_char
id|byte
op_assign
id|bpp_inb
c_func
(paren
id|base_addrs
(braket
id|minor
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|byte
comma
id|c
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|c
op_add_assign
l_int|1
suffix:semicolon
id|remaining
op_sub_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|instances
(braket
id|minor
)braket
dot
id|run_flag
)paren
(brace
id|instances
(braket
id|minor
)braket
dot
id|repeat_byte
op_assign
id|byte
suffix:semicolon
id|instances
(braket
id|minor
)braket
dot
id|run_flag
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_int
r_char
id|byte
op_assign
id|bpp_inb
c_func
(paren
id|base_addrs
(braket
id|minor
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|byte
op_amp
l_int|0x80
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bpp%d: &quot;
l_string|&quot;Ignoring ECP channel %u from device.&bslash;n&quot;
comma
id|minor
comma
id|byte
op_amp
l_int|0x7f
)paren
suffix:semicolon
)brace
r_else
(brace
id|instances
(braket
id|minor
)braket
dot
id|run_length
op_assign
id|byte
suffix:semicolon
id|instances
(braket
id|minor
)braket
dot
id|run_flag
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* Event 44: I got it. */
id|set_pins
c_func
(paren
id|BPP_PP_nStrobe
op_or
id|BPP_PP_nAutoFd
op_or
id|BPP_PP_nSelectIn
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Wait for event 45: peripheral handshake */
id|rc
op_assign
id|wait_for
c_func
(paren
id|BPP_GP_nAck
comma
l_int|0
comma
id|TIME_PResponse
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
multiline_comment|/* Event 46: Finish handshake */
id|set_pins
c_func
(paren
id|BPP_PP_nStrobe
op_or
id|BPP_PP_nSelectIn
comma
id|minor
)paren
suffix:semicolon
)brace
r_return
id|cnt
op_minus
id|remaining
suffix:semicolon
)brace
DECL|function|bpp_read
r_static
id|ssize_t
id|bpp_read
c_func
(paren
r_struct
id|file
op_star
id|f
comma
r_char
op_star
id|c
comma
r_int
id|cnt
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|rc
suffix:semicolon
r_const
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|f-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|BPP_NO
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|instances
(braket
id|minor
)braket
dot
id|present
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|instances
(braket
id|minor
)braket
dot
id|mode
)paren
(brace
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
id|instances
(braket
id|minor
)braket
dot
id|mode
op_ne
id|COMPATIBILITY
)paren
id|terminate
c_func
(paren
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instances
(braket
id|minor
)braket
dot
id|enhanced
)paren
(brace
multiline_comment|/* For now, do all reads with ECP-RLE mode */
r_int
r_int
id|pins
suffix:semicolon
id|rc
op_assign
id|negotiate
c_func
(paren
id|DEFAULT_ECP
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_break
suffix:semicolon
id|instances
(braket
id|minor
)braket
dot
id|mode
op_assign
id|ECP_RLE
suffix:semicolon
multiline_comment|/* Event 30: set nAutoFd low to setup for ECP mode */
id|pins
op_assign
id|get_pins
c_func
(paren
id|minor
)paren
suffix:semicolon
id|pins
op_and_assign
op_complement
id|BPP_PP_nAutoFd
suffix:semicolon
id|set_pins
c_func
(paren
id|pins
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Wait for Event 31: peripheral ready */
id|rc
op_assign
id|wait_for
c_func
(paren
id|BPP_GP_PError
comma
l_int|0
comma
id|TIME_PResponse
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
id|rc
op_assign
id|read_ecp
c_func
(paren
id|minor
comma
id|c
comma
id|cnt
)paren
suffix:semicolon
)brace
r_else
(brace
id|rc
op_assign
id|negotiate
c_func
(paren
id|DEFAULT_NIBBLE
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_break
suffix:semicolon
id|instances
(braket
id|minor
)braket
dot
id|mode
op_assign
id|NIBBLE
suffix:semicolon
id|rc
op_assign
id|read_nibble
c_func
(paren
id|minor
comma
id|c
comma
id|cnt
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|NIBBLE
suffix:colon
id|rc
op_assign
id|read_nibble
c_func
(paren
id|minor
comma
id|c
comma
id|cnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ECP
suffix:colon
r_case
id|ECP_RLE
suffix:colon
id|rc
op_assign
id|read_ecp
c_func
(paren
id|minor
comma
id|c
comma
id|cnt
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * Compatibility mode handshaking is a matter of writing data,&n; * strobing it, and waiting for the printer to stop being busy.&n; */
DECL|function|write_compat
r_static
r_int
id|write_compat
c_func
(paren
r_int
id|minor
comma
r_const
r_char
op_star
id|c
comma
r_int
r_int
id|cnt
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
r_int
id|pins
op_assign
id|get_pins
c_func
(paren
id|minor
)paren
suffix:semicolon
r_int
r_int
id|remaining
op_assign
id|cnt
suffix:semicolon
r_while
c_loop
(paren
id|remaining
OG
l_int|0
)paren
(brace
r_int
r_char
id|byte
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|byte
comma
id|c
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|c
op_add_assign
l_int|1
suffix:semicolon
id|rc
op_assign
id|wait_for
c_func
(paren
id|BPP_GP_nAck
comma
id|BPP_GP_Busy
comma
id|TIME_IDLE_LIMIT
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
id|bpp_outb_p
c_func
(paren
id|byte
comma
id|base_addrs
(braket
id|minor
)braket
)paren
suffix:semicolon
id|remaining
op_sub_assign
l_int|1
suffix:semicolon
multiline_comment|/* snooze(1, minor); */
id|pins
op_and_assign
op_complement
id|BPP_PP_nStrobe
suffix:semicolon
id|set_pins
c_func
(paren
id|pins
comma
id|minor
)paren
suffix:semicolon
id|rc
op_assign
id|wait_for
c_func
(paren
id|BPP_GP_Busy
comma
l_int|0
comma
id|TIME_PResponse
comma
id|minor
)paren
suffix:semicolon
id|pins
op_or_assign
id|BPP_PP_nStrobe
suffix:semicolon
id|set_pins
c_func
(paren
id|pins
comma
id|minor
)paren
suffix:semicolon
)brace
r_return
id|cnt
op_minus
id|remaining
suffix:semicolon
)brace
multiline_comment|/*&n; * Write data using ECP mode. Watch out that the port may be set up&n; * for reading. If so, turn the port around.&n; */
DECL|function|write_ecp
r_static
r_int
id|write_ecp
c_func
(paren
r_int
id|minor
comma
r_const
r_char
op_star
id|c
comma
r_int
r_int
id|cnt
)paren
(brace
r_int
r_int
id|pins
op_assign
id|get_pins
c_func
(paren
id|minor
)paren
suffix:semicolon
r_int
r_int
id|remaining
op_assign
id|cnt
suffix:semicolon
r_if
c_cond
(paren
id|instances
(braket
id|minor
)braket
dot
id|direction
)paren
(brace
r_int
id|rc
suffix:semicolon
multiline_comment|/* Event 47 Request bus be turned around */
id|pins
op_or_assign
id|BPP_PP_nInit
suffix:semicolon
id|set_pins
c_func
(paren
id|pins
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Wait for Event 49: Peripheral relinquished bus */
id|rc
op_assign
id|wait_for
c_func
(paren
id|BPP_GP_PError
comma
l_int|0
comma
id|TIME_PResponse
comma
id|minor
)paren
suffix:semicolon
id|pins
op_or_assign
id|BPP_PP_nAutoFd
suffix:semicolon
id|instances
(braket
id|minor
)braket
dot
id|direction
op_assign
l_int|0
suffix:semicolon
id|set_pins
c_func
(paren
id|pins
comma
id|minor
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|remaining
OG
l_int|0
)paren
(brace
r_int
r_char
id|byte
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
id|get_user
c_func
(paren
id|byte
comma
id|c
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|rc
op_assign
id|wait_for
c_func
(paren
l_int|0
comma
id|BPP_GP_Busy
comma
id|TIME_PResponse
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|ETIMEDOUT
suffix:semicolon
id|c
op_add_assign
l_int|1
suffix:semicolon
id|bpp_outb_p
c_func
(paren
id|byte
comma
id|base_addrs
(braket
id|minor
)braket
)paren
suffix:semicolon
id|pins
op_and_assign
op_complement
id|BPP_PP_nStrobe
suffix:semicolon
id|set_pins
c_func
(paren
id|pins
comma
id|minor
)paren
suffix:semicolon
id|pins
op_or_assign
id|BPP_PP_nStrobe
suffix:semicolon
id|rc
op_assign
id|wait_for
c_func
(paren
id|BPP_GP_Busy
comma
l_int|0
comma
id|TIME_PResponse
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|set_pins
c_func
(paren
id|pins
comma
id|minor
)paren
suffix:semicolon
)brace
r_return
id|cnt
op_minus
id|remaining
suffix:semicolon
)brace
multiline_comment|/*&n; * Write to the peripheral. Be sensitive of the current mode. If I&squot;m&n; * in a mode that can be turned around (ECP) then just do&n; * that. Otherwise, terminate and do my writing in compat mode. This&n; * is the safest course as any device can handle it.&n; */
DECL|function|bpp_write
r_static
id|ssize_t
id|bpp_write
c_func
(paren
r_struct
id|file
op_star
id|f
comma
r_const
r_char
op_star
id|c
comma
r_int
id|cnt
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|errno
op_assign
l_int|0
suffix:semicolon
r_const
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|f-&gt;f_dentry-&gt;d_inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|BPP_NO
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|instances
(braket
id|minor
)braket
dot
id|present
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|instances
(braket
id|minor
)braket
dot
id|mode
)paren
(brace
r_case
id|ECP
suffix:colon
r_case
id|ECP_RLE
suffix:colon
id|errno
op_assign
id|write_ecp
c_func
(paren
id|minor
comma
id|c
comma
id|cnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COMPATIBILITY
suffix:colon
id|errno
op_assign
id|write_compat
c_func
(paren
id|minor
comma
id|c
comma
id|cnt
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|terminate
c_func
(paren
id|minor
)paren
suffix:semicolon
id|errno
op_assign
id|write_compat
c_func
(paren
id|minor
comma
id|c
comma
id|cnt
)paren
suffix:semicolon
)brace
r_return
id|errno
suffix:semicolon
)brace
DECL|function|bpp_ioctl
r_static
r_int
id|bpp_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|f
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|errno
op_assign
l_int|0
suffix:semicolon
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|BPP_NO
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|instances
(braket
id|minor
)braket
dot
id|present
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|BPP_PUT_PINS
suffix:colon
id|set_pins
c_func
(paren
id|arg
comma
id|minor
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BPP_GET_PINS
suffix:colon
id|errno
op_assign
id|get_pins
c_func
(paren
id|minor
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BPP_PUT_DATA
suffix:colon
id|bpp_outb_p
c_func
(paren
id|arg
comma
id|base_addrs
(braket
id|minor
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BPP_GET_DATA
suffix:colon
id|errno
op_assign
id|bpp_inb_p
c_func
(paren
id|base_addrs
(braket
id|minor
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BPP_SET_INPUT
suffix:colon
r_if
c_cond
(paren
id|arg
)paren
r_if
c_cond
(paren
id|instances
(braket
id|minor
)braket
dot
id|enhanced
)paren
(brace
r_int
r_int
id|bits
op_assign
id|get_pins
c_func
(paren
id|minor
)paren
suffix:semicolon
id|instances
(braket
id|minor
)braket
dot
id|direction
op_assign
l_int|0x20
suffix:semicolon
id|set_pins
c_func
(paren
id|bits
comma
id|minor
)paren
suffix:semicolon
)brace
r_else
(brace
id|errno
op_assign
op_minus
id|ENOTTY
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|bits
op_assign
id|get_pins
c_func
(paren
id|minor
)paren
suffix:semicolon
id|instances
(braket
id|minor
)braket
dot
id|direction
op_assign
l_int|0x00
suffix:semicolon
id|set_pins
c_func
(paren
id|bits
comma
id|minor
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|errno
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|errno
suffix:semicolon
)brace
DECL|variable|bpp_fops
r_static
r_struct
id|file_operations
id|bpp_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|read
suffix:colon
id|bpp_read
comma
id|write
suffix:colon
id|bpp_write
comma
id|ioctl
suffix:colon
id|bpp_ioctl
comma
id|open
suffix:colon
id|bpp_open
comma
id|release
suffix:colon
id|bpp_release
comma
)brace
suffix:semicolon
macro_line|#if defined(__i386__)
DECL|macro|collectLptPorts
mdefine_line|#define collectLptPorts()  {}
DECL|function|probeLptPort
r_static
r_void
id|probeLptPort
c_func
(paren
r_int
id|idx
)paren
(brace
r_int
r_int
id|testvalue
suffix:semicolon
r_const
r_int
r_int
id|lpAddr
op_assign
id|base_addrs
(braket
id|idx
)braket
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|present
op_assign
l_int|0
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|enhanced
op_assign
l_int|0
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|direction
op_assign
l_int|0
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|mode
op_assign
id|COMPATIBILITY
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|wait_queue
op_assign
l_int|0
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|run_length
op_assign
l_int|0
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|run_flag
op_assign
l_int|0
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|instances
(braket
id|idx
)braket
dot
id|timer_list
)paren
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|timer_list.function
op_assign
id|bpp_wake_up
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|lpAddr
comma
l_int|3
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;       * First, make sure the instance exists. Do this by writing to&n;       * the data latch and reading the value back. If the port *is*&n;       * present, test to see if it supports extended-mode&n;       * operation. This will be required for IEEE1284 reverse&n;       * transfers.&n;       */
id|outb_p
c_func
(paren
id|BPP_PROBE_CODE
comma
id|lpAddr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|testvalue
op_assign
l_int|0
suffix:semicolon
id|testvalue
OL
id|BPP_DELAY
suffix:semicolon
id|testvalue
op_increment
)paren
suffix:semicolon
id|testvalue
op_assign
id|inb_p
c_func
(paren
id|lpAddr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|testvalue
op_eq
id|BPP_PROBE_CODE
)paren
(brace
r_int
id|save
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|present
op_assign
l_int|1
suffix:semicolon
id|request_region
c_func
(paren
id|lpAddr
comma
l_int|3
comma
id|dev_name
)paren
suffix:semicolon
id|save
op_assign
id|inb_p
c_func
(paren
id|lpAddr
op_plus
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|testvalue
op_assign
l_int|0
suffix:semicolon
id|testvalue
OL
id|BPP_DELAY
suffix:semicolon
id|testvalue
op_increment
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|save
op_or
l_int|0x20
comma
id|lpAddr
op_plus
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|testvalue
op_assign
l_int|0
suffix:semicolon
id|testvalue
OL
id|BPP_DELAY
suffix:semicolon
id|testvalue
op_increment
)paren
suffix:semicolon
id|outb_p
c_func
(paren
op_complement
id|BPP_PROBE_CODE
comma
id|lpAddr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|testvalue
op_assign
l_int|0
suffix:semicolon
id|testvalue
OL
id|BPP_DELAY
suffix:semicolon
id|testvalue
op_increment
)paren
suffix:semicolon
id|testvalue
op_assign
id|inb_p
c_func
(paren
id|lpAddr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|testvalue
op_amp
l_int|0xff
)paren
op_eq
(paren
l_int|0xff
op_amp
op_complement
id|BPP_PROBE_CODE
)paren
)paren
id|instances
(braket
id|idx
)braket
dot
id|enhanced
op_assign
l_int|0
suffix:semicolon
r_else
id|instances
(braket
id|idx
)braket
dot
id|enhanced
op_assign
l_int|1
suffix:semicolon
id|outb_p
c_func
(paren
id|save
comma
id|lpAddr
op_plus
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;       * Leave the port in compat idle mode.&n;       */
id|set_pins
c_func
(paren
id|BPP_PP_nAutoFd
op_or
id|BPP_PP_nStrobe
op_or
id|BPP_PP_nInit
comma
id|idx
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bpp%d: Port at 0x%03x: Enhanced mode %s&bslash;n&quot;
comma
id|idx
comma
id|base_addrs
(braket
id|idx
)braket
comma
id|instances
(braket
id|idx
)braket
dot
id|enhanced
ques
c_cond
l_string|&quot;SUPPORTED&quot;
suffix:colon
l_string|&quot;UNAVAILABLE&quot;
)paren
suffix:semicolon
)brace
DECL|function|freeLptPort
r_static
r_inline
r_void
id|freeLptPort
c_func
(paren
r_int
id|idx
)paren
(brace
id|release_region
c_func
(paren
id|base_addrs
(braket
id|idx
)braket
comma
l_int|3
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if defined(__sparc__)
DECL|function|map_bpp
r_static
r_int
r_int
id|map_bpp
c_func
(paren
r_struct
id|sbus_dev
op_star
id|dev
comma
r_int
id|idx
)paren
(brace
r_return
id|sbus_ioremap
c_func
(paren
op_amp
id|dev-&gt;resource
(braket
l_int|0
)braket
comma
l_int|0
comma
id|BPP_SIZE
comma
l_string|&quot;bpp&quot;
)paren
suffix:semicolon
)brace
DECL|function|collectLptPorts
r_static
r_int
id|collectLptPorts
c_func
(paren
r_void
)paren
(brace
r_struct
id|sbus_bus
op_star
id|bus
suffix:semicolon
r_struct
id|sbus_dev
op_star
id|dev
suffix:semicolon
r_int
id|count
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
id|for_all_sbusdev
c_func
(paren
id|dev
comma
id|bus
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|dev-&gt;prom_name
comma
l_string|&quot;SUNW,bpp&quot;
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|count
op_ge
id|BPP_NO
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;bpp: More than %d bpp ports,&quot;
l_string|&quot; rest is ignored&bslash;n&quot;
comma
id|BPP_NO
)paren
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
id|base_addrs
(braket
id|count
)braket
op_assign
id|map_bpp
c_func
(paren
id|dev
comma
id|count
)paren
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
)brace
r_return
id|count
suffix:semicolon
)brace
DECL|function|probeLptPort
r_static
r_void
id|probeLptPort
c_func
(paren
r_int
id|idx
)paren
(brace
r_int
r_int
id|rp
op_assign
id|base_addrs
(braket
id|idx
)braket
suffix:semicolon
id|__u32
id|csr
suffix:semicolon
r_char
op_star
id|brand
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|present
op_assign
l_int|0
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|enhanced
op_assign
l_int|0
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|direction
op_assign
l_int|0
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|mode
op_assign
id|COMPATIBILITY
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|instances
(braket
id|idx
)braket
dot
id|wait_queue
)paren
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|run_length
op_assign
l_int|0
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|run_flag
op_assign
l_int|0
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|instances
(braket
id|idx
)braket
dot
id|timer_list
)paren
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|timer_list.function
op_assign
id|bpp_wake_up
suffix:semicolon
r_if
c_cond
(paren
id|rp
op_eq
l_int|0
)paren
r_return
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|present
op_assign
l_int|1
suffix:semicolon
id|instances
(braket
id|idx
)braket
dot
id|enhanced
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Sure */
id|csr
op_assign
id|sbus_readl
c_func
(paren
id|rp
op_plus
id|BPP_CSR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|csr
op_amp
id|P_DRAINING
)paren
op_ne
l_int|0
op_logical_and
(paren
id|csr
op_amp
id|P_ERR_PEND
)paren
op_eq
l_int|0
)paren
(brace
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|csr
op_assign
id|sbus_readl
c_func
(paren
id|rp
op_plus
id|BPP_CSR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|csr
op_amp
id|P_DRAINING
)paren
op_ne
l_int|0
op_logical_and
(paren
id|csr
op_amp
id|P_ERR_PEND
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bpp%d: DRAINING still active (0x%08x)&bslash;n&quot;
comma
id|idx
comma
id|csr
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;bpp%d: reset with 0x%08x ..&quot;
comma
id|idx
comma
id|csr
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
(paren
id|csr
op_or
id|P_RESET
)paren
op_amp
op_complement
id|P_INT_EN
comma
id|rp
op_plus
id|BPP_CSR
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
id|sbus_writel
c_func
(paren
id|sbus_readl
c_func
(paren
id|rp
op_plus
id|BPP_CSR
)paren
op_amp
op_complement
id|P_RESET
comma
id|rp
op_plus
id|BPP_CSR
)paren
suffix:semicolon
id|csr
op_assign
id|sbus_readl
c_func
(paren
id|rp
op_plus
id|BPP_CSR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; done with csr=0x%08x ocr=0x%04x&bslash;n&quot;
comma
id|csr
comma
id|sbus_readw
c_func
(paren
id|rp
op_plus
id|BPP_OCR
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|csr
op_amp
id|P_DEV_ID_MASK
)paren
(brace
r_case
id|P_DEV_ID_ZEBRA
suffix:colon
id|brand
op_assign
l_string|&quot;Zebra&quot;
suffix:semicolon
r_break
suffix:semicolon
r_case
id|P_DEV_ID_L64854
suffix:colon
id|brand
op_assign
l_string|&quot;DMA2&quot;
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|brand
op_assign
l_string|&quot;Unknown&quot;
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;bpp%d: %s at 0x%lx&bslash;n&quot;
comma
id|idx
comma
id|brand
comma
id|rp
)paren
suffix:semicolon
multiline_comment|/*&n;       * Leave the port in compat idle mode.&n;       */
id|set_pins
c_func
(paren
id|BPP_PP_nAutoFd
op_or
id|BPP_PP_nStrobe
op_or
id|BPP_PP_nInit
comma
id|idx
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|freeLptPort
r_static
r_inline
r_void
id|freeLptPort
c_func
(paren
r_int
id|idx
)paren
(brace
id|sbus_iounmap
c_func
(paren
id|base_addrs
(braket
id|idx
)braket
comma
id|BPP_SIZE
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|devfs_handle
r_static
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
DECL|function|bpp_init
r_static
r_int
id|__init
id|bpp_init
c_func
(paren
r_void
)paren
(brace
r_int
id|rc
suffix:semicolon
r_int
id|idx
suffix:semicolon
id|rc
op_assign
id|collectLptPorts
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
op_eq
l_int|0
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|rc
op_assign
id|devfs_register_chrdev
c_func
(paren
id|BPP_MAJOR
comma
id|dev_name
comma
op_amp
id|bpp_fops
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
OL
l_int|0
)paren
r_return
id|rc
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|BPP_NO
suffix:semicolon
id|idx
op_add_assign
l_int|1
)paren
(brace
id|instances
(braket
id|idx
)braket
dot
id|opened
op_assign
l_int|0
suffix:semicolon
id|probeLptPort
c_func
(paren
id|idx
)paren
suffix:semicolon
)brace
id|devfs_handle
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;bpp&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register_series
(paren
id|devfs_handle
comma
l_string|&quot;%u&quot;
comma
id|BPP_NO
comma
id|DEVFS_FL_DEFAULT
comma
id|BPP_MAJOR
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|bpp_fops
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bpp_cleanup
r_static
r_void
id|__exit
id|bpp_cleanup
c_func
(paren
r_void
)paren
(brace
r_int
id|idx
suffix:semicolon
id|devfs_unregister
(paren
id|devfs_handle
)paren
suffix:semicolon
id|devfs_unregister_chrdev
c_func
(paren
id|BPP_MAJOR
comma
id|dev_name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|idx
op_assign
l_int|0
suffix:semicolon
id|idx
OL
id|BPP_NO
suffix:semicolon
id|idx
op_add_assign
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|instances
(braket
id|idx
)braket
dot
id|present
)paren
id|freeLptPort
c_func
(paren
id|idx
)paren
suffix:semicolon
)brace
)brace
DECL|variable|bpp_init
id|module_init
c_func
(paren
id|bpp_init
)paren
suffix:semicolon
DECL|variable|bpp_cleanup
id|module_exit
c_func
(paren
id|bpp_cleanup
)paren
suffix:semicolon
eof
