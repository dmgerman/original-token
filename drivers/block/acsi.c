multiline_comment|/*&n; * acsi.c -- Device driver for Atari ACSI hard disks&n; *&n; * Copyright 1994 Roman Hodek &lt;Roman.Hodek@informatik.uni-erlangen.de&gt;&n; *&n; * Some parts are based on hd.c by Linus Torvalds&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file COPYING in the main directory of this archive for&n; * more details.&n; *&n; */
multiline_comment|/*&n; * Still to in this file:&n; *  - If a command ends with an error status (!= 0), the following&n; *    REQUEST SENSE commands (4 to fill the ST-DMA FIFO) are done by&n; *    polling the _IRQ signal (not interrupt-driven). This should be&n; *    avoided in future because it takes up a non-neglectible time in&n; *    the interrupt service routine while interrupts are disabled.&n; *    Maybe a timer interrupt will get lost :-(&n; */
multiline_comment|/*&n; * General notes:&n; *&n; *  - All ACSI devices (disks, CD-ROMs, ...) use major number 28.&n; *    Minors are organized like it is with SCSI: The upper 4 bits&n; *    identify the device, the lower 4 bits the partition.&n; *    The device numbers (the upper 4 bits) are given in the same&n; *    order as the devices are found on the bus.&n; *  - Up to 8 LUNs are supported for each target (if CONFIG_ACSI_MULTI_LUN&n; *    is defined), but only a total of 16 devices (due to minor&n; *    numbers...). Note that Atari allows only a maximum of 4 targets&n; *    (i.e. controllers, not devices) on the ACSI bus!&n; *  - A optimizing scheme similar to SCSI scatter-gather is implemented.&n; *  - Removable media are supported. After a medium change to device&n; *    is reinitialized (partition check etc.). Also, if the device&n; *    knows the PREVENT/ALLOW MEDIUM REMOVAL command, the door should&n; *    be locked and unlocked when mounting the first or unmounting the&n; *    last filesystem on the device. The code is untested, because I&n; *    don&squot;t have a removable hard disk.&n; *&n; */
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR ACSI_MAJOR
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;scsi/scsi.h&gt; /* for SCSI_IOCTL_GET_IDLUN */
DECL|typedef|Scsi_Device
r_typedef
r_void
id|Scsi_Device
suffix:semicolon
multiline_comment|/* hack to avoid including scsi.h */
macro_line|#include &lt;scsi/scsi_ioctl.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt; /* for HDIO_GETGEO */
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/atarihw.h&gt;
macro_line|#include &lt;asm/atariints.h&gt;
macro_line|#include &lt;asm/atari_acsi.h&gt;
macro_line|#include &lt;asm/atari_stdma.h&gt;
macro_line|#include &lt;asm/atari_stram.h&gt;
DECL|macro|DEBUG
mdefine_line|#define DEBUG
DECL|macro|DEBUG_DETECT
macro_line|#undef DEBUG_DETECT
DECL|macro|NO_WRITE
macro_line|#undef NO_WRITE
DECL|macro|MAX_ERRORS
mdefine_line|#define MAX_ERRORS     &t;&t;8&t;/* Max read/write errors/sector */
DECL|macro|MAX_LUN
mdefine_line|#define MAX_LUN&t;&t;&t;&t;8&t;/* Max LUNs per target */
DECL|macro|MAX_DEV
mdefine_line|#define MAX_DEV&t;&t;   &t;&t;16
DECL|macro|ACSI_BUFFER_SIZE
mdefine_line|#define ACSI_BUFFER_SIZE&t;&t;&t;(16*1024) /* &quot;normal&quot; ACSI buffer size */
DECL|macro|ACSI_BUFFER_MINSIZE
mdefine_line|#define ACSI_BUFFER_MINSIZE&t;&t;&t;(2048) &t;  /* min. buf size if ext. DMA */
DECL|macro|ACSI_BUFFER_SIZE_ORDER
mdefine_line|#define ACSI_BUFFER_SIZE_ORDER&t; &t;2&t;&t;  /* order size for above */
DECL|macro|ACSI_BUFFER_MINSIZE_ORDER
mdefine_line|#define ACSI_BUFFER_MINSIZE_ORDER&t;0 &t;  &t;  /* order size for above */
DECL|macro|ACSI_BUFFER_SECTORS
mdefine_line|#define ACSI_BUFFER_SECTORS&t;(ACSI_BUFFER_SIZE/512)
DECL|macro|ACSI_BUFFER_ORDER
mdefine_line|#define ACSI_BUFFER_ORDER &bslash;&n;&t;(ATARIHW_PRESENT(EXTD_DMA) ? &bslash;&n;&t; ACSI_BUFFER_MINSIZE_ORDER : &bslash;&n;&t; ACSI_BUFFER_SIZE_ORDER)
DECL|macro|ACSI_TIMEOUT
mdefine_line|#define ACSI_TIMEOUT&t;&t;(4*HZ)
multiline_comment|/* minimum delay between two commands */
DECL|macro|COMMAND_DELAY
mdefine_line|#define COMMAND_DELAY 500
r_typedef
r_enum
(brace
DECL|enumerator|NONE
DECL|enumerator|HARDDISK
DECL|enumerator|CDROM
id|NONE
comma
id|HARDDISK
comma
id|CDROM
DECL|typedef|ACSI_TYPE
)brace
id|ACSI_TYPE
suffix:semicolon
DECL|struct|acsi_info_struct
r_struct
id|acsi_info_struct
(brace
DECL|member|type
id|ACSI_TYPE
id|type
suffix:semicolon
multiline_comment|/* type of device */
DECL|member|target
r_int
id|target
suffix:semicolon
multiline_comment|/* target number */
DECL|member|lun
r_int
id|lun
suffix:semicolon
multiline_comment|/* LUN in target controller */
DECL|member|removable
r_int
id|removable
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Flag for removable media */
DECL|member|read_only
r_int
id|read_only
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Flag for read only devices */
DECL|member|old_atari_disk
r_int
id|old_atari_disk
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Is an old Atari disk       */
DECL|member|changed
r_int
id|changed
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Medium has been changed */
DECL|member|size
r_int
r_int
id|size
suffix:semicolon
multiline_comment|/* #blocks */
DECL|variable|acsi_info
)brace
id|acsi_info
(braket
id|MAX_DEV
)braket
suffix:semicolon
multiline_comment|/*&n; *&t;SENSE KEYS&n; */
DECL|macro|NO_SENSE
mdefine_line|#define NO_SENSE&t;&t;0x00
DECL|macro|RECOVERED_ERROR
mdefine_line|#define RECOVERED_ERROR &t;0x01
DECL|macro|NOT_READY
mdefine_line|#define NOT_READY&t;&t;0x02
DECL|macro|MEDIUM_ERROR
mdefine_line|#define MEDIUM_ERROR&t;&t;0x03
DECL|macro|HARDWARE_ERROR
mdefine_line|#define HARDWARE_ERROR&t;&t;0x04
DECL|macro|ILLEGAL_REQUEST
mdefine_line|#define ILLEGAL_REQUEST &t;0x05
DECL|macro|UNIT_ATTENTION
mdefine_line|#define UNIT_ATTENTION&t;&t;0x06
DECL|macro|DATA_PROTECT
mdefine_line|#define DATA_PROTECT&t;&t;0x07
DECL|macro|BLANK_CHECK
mdefine_line|#define BLANK_CHECK&t;&t;0x08
DECL|macro|COPY_ABORTED
mdefine_line|#define COPY_ABORTED&t;&t;0x0a
DECL|macro|ABORTED_COMMAND
mdefine_line|#define ABORTED_COMMAND &t;0x0b
DECL|macro|VOLUME_OVERFLOW
mdefine_line|#define VOLUME_OVERFLOW &t;0x0d
DECL|macro|MISCOMPARE
mdefine_line|#define MISCOMPARE&t;&t;0x0e
multiline_comment|/*&n; *&t;DEVICE TYPES&n; */
DECL|macro|TYPE_DISK
mdefine_line|#define TYPE_DISK&t;0x00
DECL|macro|TYPE_TAPE
mdefine_line|#define TYPE_TAPE&t;0x01
DECL|macro|TYPE_WORM
mdefine_line|#define TYPE_WORM&t;0x04
DECL|macro|TYPE_ROM
mdefine_line|#define TYPE_ROM&t;0x05
DECL|macro|TYPE_MOD
mdefine_line|#define TYPE_MOD&t;0x07
DECL|macro|TYPE_NO_LUN
mdefine_line|#define TYPE_NO_LUN&t;0x7f
multiline_comment|/* The data returned by MODE SENSE differ between the old Atari&n; * hard disks and SCSI disks connected to ACSI. In the following, both&n; * formats are defined and some macros to operate on them potably.&n; */
r_typedef
r_struct
(brace
DECL|member|dummy
r_int
r_int
id|dummy
(braket
l_int|2
)braket
suffix:semicolon
DECL|member|sector_size
r_int
r_int
id|sector_size
suffix:semicolon
DECL|member|format_code
r_int
r_char
id|format_code
suffix:semicolon
DECL|macro|ATARI_SENSE_FORMAT_FIX
mdefine_line|#define ATARI_SENSE_FORMAT_FIX&t;1&t;
DECL|macro|ATARI_SENSE_FORMAT_CHNG
mdefine_line|#define ATARI_SENSE_FORMAT_CHNG&t;2
DECL|member|cylinders_h
r_int
r_char
id|cylinders_h
suffix:semicolon
DECL|member|cylinders_l
r_int
r_char
id|cylinders_l
suffix:semicolon
DECL|member|heads
r_int
r_char
id|heads
suffix:semicolon
DECL|member|reduced_h
r_int
r_char
id|reduced_h
suffix:semicolon
DECL|member|reduced_l
r_int
r_char
id|reduced_l
suffix:semicolon
DECL|member|precomp_h
r_int
r_char
id|precomp_h
suffix:semicolon
DECL|member|precomp_l
r_int
r_char
id|precomp_l
suffix:semicolon
DECL|member|landing_zone
r_int
r_char
id|landing_zone
suffix:semicolon
DECL|member|steprate
r_int
r_char
id|steprate
suffix:semicolon
DECL|member|type
r_int
r_char
id|type
suffix:semicolon
DECL|macro|ATARI_SENSE_TYPE_FIXCHNG_MASK
mdefine_line|#define ATARI_SENSE_TYPE_FIXCHNG_MASK&t;&t;4
DECL|macro|ATARI_SENSE_TYPE_SOFTHARD_MASK
mdefine_line|#define ATARI_SENSE_TYPE_SOFTHARD_MASK&t;&t;8
DECL|macro|ATARI_SENSE_TYPE_FIX
mdefine_line|#define ATARI_SENSE_TYPE_FIX&t;&t;&t;&t;4
DECL|macro|ATARI_SENSE_TYPE_CHNG
mdefine_line|#define ATARI_SENSE_TYPE_CHNG&t;&t;&t;&t;0
DECL|macro|ATARI_SENSE_TYPE_SOFT
mdefine_line|#define ATARI_SENSE_TYPE_SOFT&t;&t;&t;&t;0
DECL|macro|ATARI_SENSE_TYPE_HARD
mdefine_line|#define ATARI_SENSE_TYPE_HARD&t;&t;&t;&t;8
DECL|member|sectors
r_int
r_char
id|sectors
suffix:semicolon
DECL|typedef|ATARI_SENSE_DATA
)brace
id|ATARI_SENSE_DATA
suffix:semicolon
DECL|macro|ATARI_CAPACITY
mdefine_line|#define ATARI_CAPACITY(sd) &bslash;&n;&t;(((int)((sd).cylinders_h&lt;&lt;8)|(sd).cylinders_l) * &bslash;&n;&t; (sd).heads * (sd).sectors)
r_typedef
r_struct
(brace
DECL|member|dummy1
r_int
r_char
id|dummy1
suffix:semicolon
DECL|member|medium_type
r_int
r_char
id|medium_type
suffix:semicolon
DECL|member|dummy2
r_int
r_char
id|dummy2
suffix:semicolon
DECL|member|descriptor_size
r_int
r_char
id|descriptor_size
suffix:semicolon
DECL|member|block_count
r_int
r_int
id|block_count
suffix:semicolon
DECL|member|sector_size
r_int
r_int
id|sector_size
suffix:semicolon
multiline_comment|/* Page 0 data */
DECL|member|page_code
r_int
r_char
id|page_code
suffix:semicolon
DECL|member|page_size
r_int
r_char
id|page_size
suffix:semicolon
DECL|member|page_flags
r_int
r_char
id|page_flags
suffix:semicolon
DECL|member|qualifier
r_int
r_char
id|qualifier
suffix:semicolon
DECL|typedef|SCSI_SENSE_DATA
)brace
id|SCSI_SENSE_DATA
suffix:semicolon
DECL|macro|SCSI_CAPACITY
mdefine_line|#define SCSI_CAPACITY(sd) &t;((sd).block_count &amp; 0xffffff)
r_typedef
r_union
(brace
DECL|member|atari
id|ATARI_SENSE_DATA
id|atari
suffix:semicolon
DECL|member|scsi
id|SCSI_SENSE_DATA
id|scsi
suffix:semicolon
DECL|typedef|SENSE_DATA
)brace
id|SENSE_DATA
suffix:semicolon
DECL|macro|SENSE_TYPE_UNKNOWN
mdefine_line|#define SENSE_TYPE_UNKNOWN&t;0
DECL|macro|SENSE_TYPE_ATARI
mdefine_line|#define SENSE_TYPE_ATARI&t;1
DECL|macro|SENSE_TYPE_SCSI
mdefine_line|#define SENSE_TYPE_SCSI&t;&t;2
DECL|macro|SENSE_TYPE
mdefine_line|#define SENSE_TYPE(sd)&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(((sd).atari.dummy[0] == 8 &amp;&amp;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;  ((sd).atari.format_code == 1 ||&t;&t;&t;&t;&t;&t;&bslash;&n;&t;   (sd).atari.format_code == 2)) ? SENSE_TYPE_ATARI :&t;&bslash;&n;&t; ((sd).scsi.dummy1 &gt;= 11) ? SENSE_TYPE_SCSI :&t;&t;&t;&bslash;&n;&t; SENSE_TYPE_UNKNOWN)
DECL|macro|CAPACITY
mdefine_line|#define CAPACITY(sd)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(SENSE_TYPE(sd) == SENSE_TYPE_ATARI ?&t;&t;&bslash;&n;&t; ATARI_CAPACITY((sd).atari) :&t;&t;&t;&t;&bslash;&n;&t; SCSI_CAPACITY((sd).scsi))
DECL|macro|SECTOR_SIZE
mdefine_line|#define SECTOR_SIZE(sd)&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;(SENSE_TYPE(sd) == SENSE_TYPE_ATARI ?&t;&t;&bslash;&n;&t; (sd).atari.sector_size :&t;&t;&t;&t;&t;&bslash;&n;&t; (sd).scsi.sector_size &amp; 0xffffff)
multiline_comment|/* Default size if capacity cannot be determined (1 GByte) */
DECL|macro|DEFAULT_SIZE
mdefine_line|#define&t;DEFAULT_SIZE&t;0x1fffff
DECL|macro|CARTRCH_STAT
mdefine_line|#define CARTRCH_STAT(dev,buf)&t;&t;&t;&t;&t;&bslash;&n;&t;(acsi_info[(dev)].old_atari_disk ?&t;&t;&t;&bslash;&n;&t; (((buf)[0] &amp; 0x7f) == 0x28) :&t;&t;&t;&t;&t;&bslash;&n;&t; ((((buf)[0] &amp; 0x70) == 0x70) ?&t;&t;&t;&t;&t;&bslash;&n;&t;  (((buf)[2] &amp; 0x0f) == 0x06) :&t;&t;&t;&t;&t;&bslash;&n;&t;  (((buf)[0] &amp; 0x0f) == 0x06)))&t;&t;&t;&t;&t;&bslash;&n;
multiline_comment|/* These two are also exported to other drivers that work on the ACSI bus and&n; * need an ST-RAM buffer. */
DECL|variable|acsi_buffer
r_char
op_star
id|acsi_buffer
suffix:semicolon
DECL|variable|phys_acsi_buffer
r_int
r_int
id|phys_acsi_buffer
suffix:semicolon
DECL|variable|NDevices
r_static
r_int
id|NDevices
op_assign
l_int|0
suffix:semicolon
DECL|variable|acsi_sizes
r_static
r_int
id|acsi_sizes
(braket
id|MAX_DEV
op_lshift
l_int|4
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|acsi_blocksizes
r_static
r_int
id|acsi_blocksizes
(braket
id|MAX_DEV
op_lshift
l_int|4
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|acsi_part
r_static
r_struct
id|hd_struct
id|acsi_part
(braket
id|MAX_DEV
op_lshift
l_int|4
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
DECL|variable|access_count
r_static
r_int
id|access_count
(braket
id|MAX_DEV
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|busy
r_static
r_char
id|busy
(braket
id|MAX_DEV
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|busy_wait
)paren
suffix:semicolon
DECL|variable|CurrentNReq
r_static
r_int
id|CurrentNReq
suffix:semicolon
DECL|variable|CurrentNSect
r_static
r_int
id|CurrentNSect
suffix:semicolon
DECL|variable|CurrentBuffer
r_static
r_char
op_star
id|CurrentBuffer
suffix:semicolon
DECL|macro|SET_TIMER
mdefine_line|#define SET_TIMER()&t;mod_timer(&amp;acsi_timer, jiffies + ACSI_TIMEOUT)
DECL|macro|CLEAR_TIMER
mdefine_line|#define CLEAR_TIMER()&t;del_timer(&amp;acsi_timer)
DECL|variable|STramMask
r_static
r_int
r_int
id|STramMask
suffix:semicolon
DECL|macro|STRAM_ADDR
mdefine_line|#define STRAM_ADDR(a)&t;(((a) &amp; STramMask) == 0)
multiline_comment|/* ACSI commands */
DECL|variable|tur_cmd
r_static
r_char
id|tur_cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|modesense_cmd
r_static
r_char
id|modesense_cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x1a
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|24
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|modeselect_cmd
r_static
r_char
id|modeselect_cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x15
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|12
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|inquiry_cmd
r_static
r_char
id|inquiry_cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x12
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|reqsense_cmd
r_static
r_char
id|reqsense_cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x03
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|4
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|read_cmd
r_static
r_char
id|read_cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x08
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|write_cmd
r_static
r_char
id|write_cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x0a
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|pa_med_rem_cmd
r_static
r_char
id|pa_med_rem_cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x1e
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|macro|CMDSET_TARG_LUN
mdefine_line|#define CMDSET_TARG_LUN(cmd,targ,lun)&t;&t;&t;&bslash;&n;    do {&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;cmd[0] = (cmd[0] &amp; ~0xe0) | (targ)&lt;&lt;5;&t;&bslash;&n;&t;&t;cmd[1] = (cmd[1] &amp; ~0xe0) | (lun)&lt;&lt;5;&t;&bslash;&n;&t;} while(0)
DECL|macro|CMDSET_BLOCK
mdefine_line|#define CMDSET_BLOCK(cmd,blk)&t;&t;&t;&t;&t;&t;&bslash;&n;    do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;unsigned long __blk = (blk);&t;&t;&t;&t;&bslash;&n;&t;&t;cmd[3] = __blk; __blk &gt;&gt;= 8;&t;&t;&t;&t;&bslash;&n;&t;&t;cmd[2] = __blk; __blk &gt;&gt;= 8;&t;&t;&t;&t;&bslash;&n;&t;&t;cmd[1] = (cmd[1] &amp; 0xe0) | (__blk &amp; 0x1f);&t;&bslash;&n;&t;} while(0)
DECL|macro|CMDSET_LEN
mdefine_line|#define CMDSET_LEN(cmd,len)&t;&t;&t;&t;&t;&t;&bslash;&n;&t;do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;cmd[4] = (len);&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;} while(0)
DECL|macro|min
mdefine_line|#define min(a,b)&t;(((a)&lt;(b))?(a):(b))
multiline_comment|/* ACSI errors (from REQUEST SENSE); There are two tables, one for the&n; * old Atari disks and one for SCSI on ACSI disks.&n; */
DECL|struct|acsi_error
r_struct
id|acsi_error
(brace
DECL|member|code
r_int
r_char
id|code
suffix:semicolon
DECL|member|text
r_const
r_char
op_star
id|text
suffix:semicolon
DECL|variable|atari_acsi_errors
)brace
id|atari_acsi_errors
(braket
)braket
op_assign
(brace
(brace
l_int|0x00
comma
l_string|&quot;No error (??)&quot;
)brace
comma
(brace
l_int|0x01
comma
l_string|&quot;No index pulses&quot;
)brace
comma
(brace
l_int|0x02
comma
l_string|&quot;Seek not complete&quot;
)brace
comma
(brace
l_int|0x03
comma
l_string|&quot;Write fault&quot;
)brace
comma
(brace
l_int|0x04
comma
l_string|&quot;Drive not ready&quot;
)brace
comma
(brace
l_int|0x06
comma
l_string|&quot;No Track 00 signal&quot;
)brace
comma
(brace
l_int|0x10
comma
l_string|&quot;ECC error in ID field&quot;
)brace
comma
(brace
l_int|0x11
comma
l_string|&quot;Uncorrectable data error&quot;
)brace
comma
(brace
l_int|0x12
comma
l_string|&quot;ID field address mark not found&quot;
)brace
comma
(brace
l_int|0x13
comma
l_string|&quot;Data field address mark not found&quot;
)brace
comma
(brace
l_int|0x14
comma
l_string|&quot;Record not found&quot;
)brace
comma
(brace
l_int|0x15
comma
l_string|&quot;Seek error&quot;
)brace
comma
(brace
l_int|0x18
comma
l_string|&quot;Data check in no retry mode&quot;
)brace
comma
(brace
l_int|0x19
comma
l_string|&quot;ECC error during verify&quot;
)brace
comma
(brace
l_int|0x1a
comma
l_string|&quot;Access to bad block&quot;
)brace
comma
(brace
l_int|0x1c
comma
l_string|&quot;Unformatted or bad format&quot;
)brace
comma
(brace
l_int|0x20
comma
l_string|&quot;Invalid command&quot;
)brace
comma
(brace
l_int|0x21
comma
l_string|&quot;Invalid block address&quot;
)brace
comma
(brace
l_int|0x23
comma
l_string|&quot;Volume overflow&quot;
)brace
comma
(brace
l_int|0x24
comma
l_string|&quot;Invalid argument&quot;
)brace
comma
(brace
l_int|0x25
comma
l_string|&quot;Invalid drive number&quot;
)brace
comma
(brace
l_int|0x26
comma
l_string|&quot;Byte zero parity check&quot;
)brace
comma
(brace
l_int|0x28
comma
l_string|&quot;Cartride changed&quot;
)brace
comma
(brace
l_int|0x2c
comma
l_string|&quot;Error count overflow&quot;
)brace
comma
(brace
l_int|0x30
comma
l_string|&quot;Controller selftest failed&quot;
)brace
)brace
comma
DECL|variable|scsi_acsi_errors
id|scsi_acsi_errors
(braket
)braket
op_assign
(brace
(brace
l_int|0x00
comma
l_string|&quot;No error (??)&quot;
)brace
comma
(brace
l_int|0x01
comma
l_string|&quot;Recovered error&quot;
)brace
comma
(brace
l_int|0x02
comma
l_string|&quot;Drive not ready&quot;
)brace
comma
(brace
l_int|0x03
comma
l_string|&quot;Uncorrectable medium error&quot;
)brace
comma
(brace
l_int|0x04
comma
l_string|&quot;Hardware error&quot;
)brace
comma
(brace
l_int|0x05
comma
l_string|&quot;Illegal request&quot;
)brace
comma
(brace
l_int|0x06
comma
l_string|&quot;Unit attention (Reset or cartridge changed)&quot;
)brace
comma
(brace
l_int|0x07
comma
l_string|&quot;Data protection&quot;
)brace
comma
(brace
l_int|0x08
comma
l_string|&quot;Blank check&quot;
)brace
comma
(brace
l_int|0x0b
comma
l_string|&quot;Aborted Command&quot;
)brace
comma
(brace
l_int|0x0d
comma
l_string|&quot;Volume overflow&quot;
)brace
)brace
suffix:semicolon
multiline_comment|/***************************** Prototypes *****************************/
r_static
r_int
id|acsicmd_dma
c_func
(paren
r_const
r_char
op_star
id|cmd
comma
r_char
op_star
id|buffer
comma
r_int
id|blocks
comma
r_int
id|rwflag
comma
r_int
id|enable
)paren
suffix:semicolon
r_static
r_int
id|acsi_reqsense
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|targ
comma
r_int
id|lun
)paren
suffix:semicolon
r_static
r_void
id|acsi_print_error
c_func
(paren
r_const
r_int
r_char
op_star
id|errblk
comma
r_int
id|dev
)paren
suffix:semicolon
r_static
r_void
id|acsi_interrupt
(paren
r_int
id|irq
comma
r_void
op_star
id|data
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
suffix:semicolon
r_static
r_void
id|unexpected_acsi_interrupt
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|bad_rw_intr
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|read_intr
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|write_intr
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|acsi_times_out
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
r_static
r_void
id|copy_to_acsibuffer
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|copy_from_acsibuffer
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_end_requests
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_acsi_request
c_func
(paren
id|request_queue_t
op_star
)paren
suffix:semicolon
r_static
r_void
id|redo_acsi_request
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|acsi_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|acsi_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_int
id|acsi_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_void
id|acsi_prevent_removal
c_func
(paren
r_int
id|target
comma
r_int
id|flag
)paren
suffix:semicolon
r_static
r_int
id|acsi_change_blk_size
c_func
(paren
r_int
id|target
comma
r_int
id|lun
)paren
suffix:semicolon
r_static
r_int
id|acsi_mode_sense
c_func
(paren
r_int
id|target
comma
r_int
id|lun
comma
id|SENSE_DATA
op_star
id|sd
)paren
suffix:semicolon
r_static
r_void
id|acsi_geninit
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|revalidate_acsidisk
c_func
(paren
r_int
id|dev
comma
r_int
id|maxusage
)paren
suffix:semicolon
r_static
r_int
id|acsi_revalidate
(paren
id|dev_t
)paren
suffix:semicolon
multiline_comment|/************************* End of Prototypes **************************/
DECL|variable|acsi_timer
r_struct
id|timer_list
id|acsi_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|acsi_times_out
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_ATARI_SLM
r_extern
r_int
id|attach_slm
c_func
(paren
r_int
id|target
comma
r_int
id|lun
)paren
suffix:semicolon
r_extern
r_int
id|slm_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
"&f;"
multiline_comment|/***********************************************************************&n; *&n; *   ACSI primitives&n; *&n; **********************************************************************/
multiline_comment|/*&n; * The following two functions wait for _IRQ to become Low or High,&n; * resp., with a timeout. The &squot;timeout&squot; parameter is in jiffies&n; * (10ms).&n; * If the functions are called with timer interrupts on (int level &lt;&n; * 6), the timeout is based on the &squot;jiffies&squot; variable to provide exact&n; * timeouts for device probing etc.&n; * If interrupts are disabled, the number of tries is based on the&n; * &squot;loops_per_jiffy&squot; variable. A rough estimation is sufficient here...&n; */
DECL|macro|INT_LEVEL
mdefine_line|#define INT_LEVEL&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;({&t;unsigned __sr;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;__asm__ __volatile__ ( &quot;movew&t;%/sr,%0&quot; : &quot;=dm&quot; (__sr) );&t;&bslash;&n;&t;&t;(__sr &gt;&gt; 8) &amp; 7;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;})
DECL|function|acsi_wait_for_IRQ
r_int
id|acsi_wait_for_IRQ
c_func
(paren
r_int
id|timeout
)paren
(brace
r_if
c_cond
(paren
id|INT_LEVEL
OL
l_int|6
)paren
(brace
r_int
r_int
id|maxjif
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|maxjif
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|mfp.par_dt_reg
op_amp
l_int|0x20
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_int
id|tries
op_assign
id|loops_per_jiffy
op_div
l_int|8
op_star
id|timeout
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|tries
op_ge
l_int|0
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|mfp.par_dt_reg
op_amp
l_int|0x20
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* timeout! */
)brace
DECL|function|acsi_wait_for_noIRQ
r_int
id|acsi_wait_for_noIRQ
c_func
(paren
r_int
id|timeout
)paren
(brace
r_if
c_cond
(paren
id|INT_LEVEL
OL
l_int|6
)paren
(brace
r_int
r_int
id|maxjif
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|maxjif
)paren
)paren
r_if
c_cond
(paren
id|mfp.par_dt_reg
op_amp
l_int|0x20
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_int
id|tries
op_assign
id|loops_per_jiffy
op_star
id|timeout
op_div
l_int|8
suffix:semicolon
r_while
c_loop
(paren
id|tries
op_decrement
op_ge
l_int|0
)paren
r_if
c_cond
(paren
id|mfp.par_dt_reg
op_amp
l_int|0x20
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* timeout! */
)brace
DECL|variable|start_time
r_static
r_struct
id|timeval
id|start_time
suffix:semicolon
r_void
DECL|function|acsi_delay_start
id|acsi_delay_start
c_func
(paren
r_void
)paren
(brace
id|do_gettimeofday
c_func
(paren
op_amp
id|start_time
)paren
suffix:semicolon
)brace
multiline_comment|/* wait from acsi_delay_start to now usec (&lt;1E6) usec */
r_void
DECL|function|acsi_delay_end
id|acsi_delay_end
c_func
(paren
r_int
id|usec
)paren
(brace
r_struct
id|timeval
id|end_time
suffix:semicolon
r_int
id|deltau
comma
id|deltas
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|end_time
)paren
suffix:semicolon
id|deltau
op_assign
id|end_time.tv_usec
op_minus
id|start_time.tv_usec
suffix:semicolon
id|deltas
op_assign
id|end_time.tv_sec
op_minus
id|start_time.tv_sec
suffix:semicolon
r_if
c_cond
(paren
id|deltas
OG
l_int|1
op_logical_or
id|deltas
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|deltas
OG
l_int|0
)paren
id|deltau
op_add_assign
l_int|1000
op_star
l_int|1000
suffix:semicolon
r_if
c_cond
(paren
id|deltau
op_ge
id|usec
)paren
r_return
suffix:semicolon
id|udelay
c_func
(paren
id|usec
op_minus
id|deltau
)paren
suffix:semicolon
)brace
multiline_comment|/* acsicmd_dma() sends an ACSI command and sets up the DMA to transfer&n; * &squot;blocks&squot; blocks of 512 bytes from/to &squot;buffer&squot;.&n; * Because the _IRQ signal is used for handshaking the command bytes,&n; * the ACSI interrupt has to be disabled in this function. If the end&n; * of the operation should be signalled by a real interrupt, it has to be&n; * reenabled afterwards.&n; */
DECL|function|acsicmd_dma
r_static
r_int
id|acsicmd_dma
c_func
(paren
r_const
r_char
op_star
id|cmd
comma
r_char
op_star
id|buffer
comma
r_int
id|blocks
comma
r_int
id|rwflag
comma
r_int
id|enable
)paren
(brace
r_int
r_int
id|flags
comma
id|paddr
suffix:semicolon
r_int
id|i
suffix:semicolon
macro_line|#ifdef NO_WRITE
r_if
c_cond
(paren
id|rwflag
op_logical_or
op_star
id|cmd
op_eq
l_int|0x0a
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ACSI: Write commands disabled!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|rwflag
op_assign
id|rwflag
ques
c_cond
l_int|0x100
suffix:colon
l_int|0
suffix:semicolon
id|paddr
op_assign
id|virt_to_phys
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|acsi_delay_end
c_func
(paren
id|COMMAND_DELAY
)paren
suffix:semicolon
id|DISABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Low on A1 */
id|dma_wd.dma_mode_status
op_assign
l_int|0x88
op_or
id|rwflag
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set DMA address */
id|dma_wd.dma_lo
op_assign
(paren
r_int
r_char
)paren
id|paddr
suffix:semicolon
id|paddr
op_rshift_assign
l_int|8
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|dma_wd.dma_md
op_assign
(paren
r_int
r_char
)paren
id|paddr
suffix:semicolon
id|paddr
op_rshift_assign
l_int|8
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|EXTD_DMA
)paren
)paren
id|st_dma_ext_dmahi
op_assign
(paren
r_int
r_int
)paren
id|paddr
suffix:semicolon
r_else
id|dma_wd.dma_hi
op_assign
(paren
r_int
r_char
)paren
id|paddr
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* send the command bytes except the last */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
op_increment
id|i
)paren
(brace
id|DMA_LONG_WRITE
c_func
(paren
op_star
id|cmd
op_increment
comma
l_int|0x8a
op_or
id|rwflag
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
id|HZ
op_div
l_int|2
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* timeout */
)brace
multiline_comment|/* Clear FIFO and switch DMA to correct direction */
id|dma_wd.dma_mode_status
op_assign
l_int|0x92
op_or
(paren
id|rwflag
op_xor
l_int|0x100
)paren
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|dma_wd.dma_mode_status
op_assign
l_int|0x92
op_or
id|rwflag
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* How many sectors for DMA */
id|dma_wd.fdc_acces_seccount
op_assign
id|blocks
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* send last command byte */
id|dma_wd.dma_mode_status
op_assign
l_int|0x8a
op_or
id|rwflag
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|DMA_LONG_WRITE
c_func
(paren
op_star
id|cmd
op_increment
comma
l_int|0x0a
op_or
id|rwflag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|enable
)paren
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|80
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * acsicmd_nodma() sends an ACSI command that requires no DMA.&n; */
DECL|function|acsicmd_nodma
r_int
id|acsicmd_nodma
c_func
(paren
r_const
r_char
op_star
id|cmd
comma
r_int
id|enable
)paren
(brace
r_int
id|i
suffix:semicolon
id|acsi_delay_end
c_func
(paren
id|COMMAND_DELAY
)paren
suffix:semicolon
id|DISABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* send first command byte */
id|dma_wd.dma_mode_status
op_assign
l_int|0x88
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|DMA_LONG_WRITE
c_func
(paren
op_star
id|cmd
op_increment
comma
l_int|0x8a
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
id|HZ
op_div
l_int|2
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* timeout */
multiline_comment|/* send the intermediate command bytes */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
op_increment
id|i
)paren
(brace
id|DMA_LONG_WRITE
c_func
(paren
op_star
id|cmd
op_increment
comma
l_int|0x8a
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
id|HZ
op_div
l_int|2
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* timeout */
)brace
multiline_comment|/* send last command byte */
id|DMA_LONG_WRITE
c_func
(paren
op_star
id|cmd
op_increment
comma
l_int|0x0a
)paren
suffix:semicolon
r_if
c_cond
(paren
id|enable
)paren
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|80
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Note that the ACSI interrupt is still disabled after this&n;&t; * function. If you want to get the IRQ delivered, enable it manually!&n;&t; */
)brace
DECL|function|acsi_reqsense
r_static
r_int
id|acsi_reqsense
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|targ
comma
r_int
id|lun
)paren
(brace
id|CMDSET_TARG_LUN
c_func
(paren
id|reqsense_cmd
comma
id|targ
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsicmd_dma
c_func
(paren
id|reqsense_cmd
comma
id|buffer
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
l_int|10
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|acsi_getstatus
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsicmd_nodma
c_func
(paren
id|reqsense_cmd
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
l_int|10
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|acsi_getstatus
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsicmd_nodma
c_func
(paren
id|reqsense_cmd
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
l_int|10
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|acsi_getstatus
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsicmd_nodma
c_func
(paren
id|reqsense_cmd
comma
l_int|0
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
l_int|10
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|acsi_getstatus
c_func
(paren
)paren
suffix:semicolon
id|dma_cache_maintenance
c_func
(paren
id|virt_to_phys
c_func
(paren
id|buffer
)paren
comma
l_int|16
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * ACSI status phase: get the status byte from the bus&n; *&n; * I&squot;ve seen several times that a 0xff status is read, propably due to&n; * a timing error. In this case, the procedure is repeated after the&n; * next _IRQ edge.&n; */
DECL|function|acsi_getstatus
r_int
id|acsi_getstatus
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
id|DISABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
l_int|100
)paren
)paren
(brace
id|acsi_delay_start
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|dma_wd.dma_mode_status
op_assign
l_int|0x8a
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|dma_wd.fdc_acces_seccount
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0xff
)paren
r_break
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ACSI: skipping 0xff status byte&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|udelay
c_func
(paren
l_int|40
)paren
suffix:semicolon
id|acsi_wait_for_noIRQ
c_func
(paren
l_int|20
)paren
suffix:semicolon
)brace
id|dma_wd.dma_mode_status
op_assign
l_int|0x80
suffix:semicolon
id|udelay
c_func
(paren
l_int|40
)paren
suffix:semicolon
id|acsi_wait_for_noIRQ
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|acsi_delay_start
c_func
(paren
)paren
suffix:semicolon
r_return
id|status
op_amp
l_int|0x1f
suffix:semicolon
multiline_comment|/* mask of the device# */
)brace
macro_line|#if (defined(CONFIG_ATARI_SLM) || defined(CONFIG_ATARI_SLM_MODULE))
multiline_comment|/* Receive data in an extended status phase. Needed by SLM printer. */
DECL|function|acsi_extstatus
r_int
id|acsi_extstatus
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|cnt
)paren
(brace
r_int
id|status
suffix:semicolon
id|DISABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|80
)paren
suffix:semicolon
r_while
c_loop
(paren
id|cnt
op_decrement
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
l_int|40
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|dma_wd.dma_mode_status
op_assign
l_int|0x8a
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|dma_wd.fdc_acces_seccount
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
op_star
id|buffer
op_increment
op_assign
id|status
op_amp
l_int|0xff
suffix:semicolon
id|udelay
c_func
(paren
l_int|40
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Finish an extended status phase */
DECL|function|acsi_end_extstatus
r_void
id|acsi_end_extstatus
c_func
(paren
r_void
)paren
(brace
id|dma_wd.dma_mode_status
op_assign
l_int|0x80
suffix:semicolon
id|udelay
c_func
(paren
l_int|40
)paren
suffix:semicolon
id|acsi_wait_for_noIRQ
c_func
(paren
l_int|20
)paren
suffix:semicolon
id|acsi_delay_start
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Send data in an extended command phase */
DECL|function|acsi_extcmd
r_int
id|acsi_extcmd
c_func
(paren
r_int
r_char
op_star
id|buffer
comma
r_int
id|cnt
)paren
(brace
r_while
c_loop
(paren
id|cnt
op_decrement
OG
l_int|0
)paren
(brace
id|DMA_LONG_WRITE
c_func
(paren
op_star
id|buffer
op_increment
comma
l_int|0x8a
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
id|HZ
op_div
l_int|2
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* timeout */
)brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif
DECL|function|acsi_print_error
r_static
r_void
id|acsi_print_error
c_func
(paren
r_const
r_int
r_char
op_star
id|errblk
comma
r_int
id|dev
)paren
(brace
r_int
id|atari_err
comma
id|i
comma
id|errcode
suffix:semicolon
r_struct
id|acsi_error
op_star
id|arr
suffix:semicolon
id|atari_err
op_assign
id|acsi_info
(braket
id|dev
)braket
dot
id|old_atari_disk
suffix:semicolon
r_if
c_cond
(paren
id|atari_err
)paren
id|errcode
op_assign
id|errblk
(braket
l_int|0
)braket
op_amp
l_int|0x7f
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|errblk
(braket
l_int|0
)braket
op_amp
l_int|0x70
)paren
op_eq
l_int|0x70
)paren
id|errcode
op_assign
id|errblk
(braket
l_int|2
)braket
op_amp
l_int|0x0f
suffix:semicolon
r_else
id|errcode
op_assign
id|errblk
(braket
l_int|0
)braket
op_amp
l_int|0x0f
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ACSI error 0x%02x&quot;
comma
id|errcode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|errblk
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
id|printk
c_func
(paren
l_string|&quot; for sector %d&quot;
comma
(paren
(paren
id|errblk
(braket
l_int|1
)braket
op_amp
l_int|0x1f
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|errblk
(braket
l_int|2
)braket
op_lshift
l_int|8
)paren
op_or
id|errblk
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|arr
op_assign
id|atari_err
ques
c_cond
id|atari_acsi_errors
suffix:colon
id|scsi_acsi_errors
suffix:semicolon
id|i
op_assign
id|atari_err
ques
c_cond
r_sizeof
(paren
id|atari_acsi_errors
)paren
op_div
r_sizeof
(paren
op_star
id|atari_acsi_errors
)paren
suffix:colon
r_sizeof
(paren
id|scsi_acsi_errors
)paren
op_div
r_sizeof
(paren
op_star
id|scsi_acsi_errors
)paren
suffix:semicolon
r_for
c_loop
(paren
op_decrement
id|i
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
op_decrement
id|i
)paren
r_if
c_cond
(paren
id|arr
(braket
id|i
)braket
dot
id|code
op_eq
id|errcode
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;: %s&bslash;n&quot;
comma
id|arr
(braket
id|i
)braket
dot
id|text
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************&n; *&n; * ACSI interrupt routine&n; *   Test, if this is a ACSI interrupt and call the irq handler&n; *   Otherwise ignore this interrupt.&n; *&n; *******************************************************************/
DECL|function|acsi_interrupt
r_static
r_void
id|acsi_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|data
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_void
(paren
op_star
id|acsi_irq_handler
)paren
(paren
r_void
)paren
op_assign
id|DEVICE_INTR
suffix:semicolon
id|DEVICE_INTR
op_assign
l_int|NULL
suffix:semicolon
id|CLEAR_TIMER
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsi_irq_handler
)paren
id|acsi_irq_handler
op_assign
id|unexpected_acsi_interrupt
suffix:semicolon
id|acsi_irq_handler
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************&n; *&n; * The Interrupt handlers&n; *&n; *******************************************************************/
DECL|function|unexpected_acsi_interrupt
r_static
r_void
id|unexpected_acsi_interrupt
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Unexpected ACSI interrupt&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* This function is called in case of errors. Because we cannot reset&n; * the ACSI bus or a single device, there is no other choice than&n; * retrying several times :-(&n; */
DECL|function|bad_rw_intr
r_static
r_void
id|bad_rw_intr
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|QUEUE_EMPTY
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|CURRENT-&gt;errors
op_ge
id|MAX_ERRORS
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Otherwise just retry */
)brace
DECL|function|read_intr
r_static
r_void
id|read_intr
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|acsi_getstatus
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
r_int
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ad%c: &quot;
comma
id|dev
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsi_reqsense
c_func
(paren
id|acsi_buffer
comma
id|acsi_info
(braket
id|dev
)braket
dot
id|target
comma
id|acsi_info
(braket
id|dev
)braket
dot
id|lun
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;ACSI error and REQUEST SENSE failed (status=0x%02x)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_else
(brace
id|acsi_print_error
c_func
(paren
id|acsi_buffer
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CARTRCH_STAT
c_func
(paren
id|dev
comma
id|acsi_buffer
)paren
)paren
id|acsi_info
(braket
id|dev
)braket
dot
id|changed
op_assign
l_int|1
suffix:semicolon
)brace
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|bad_rw_intr
c_func
(paren
)paren
suffix:semicolon
id|redo_acsi_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dma_cache_maintenance
c_func
(paren
id|virt_to_phys
c_func
(paren
id|CurrentBuffer
)paren
comma
id|CurrentNSect
op_star
l_int|512
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CurrentBuffer
op_eq
id|acsi_buffer
)paren
id|copy_from_acsibuffer
c_func
(paren
)paren
suffix:semicolon
id|do_end_requests
c_func
(paren
)paren
suffix:semicolon
id|redo_acsi_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|write_intr
r_static
r_void
id|write_intr
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
id|status
op_assign
id|acsi_getstatus
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_ne
l_int|0
)paren
(brace
r_int
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ad%c: &quot;
comma
id|dev
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsi_reqsense
c_func
(paren
id|acsi_buffer
comma
id|acsi_info
(braket
id|dev
)braket
dot
id|target
comma
id|acsi_info
(braket
id|dev
)braket
dot
id|lun
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;ACSI error and REQUEST SENSE failed (status=0x%02x)&bslash;n&quot;
comma
id|status
)paren
suffix:semicolon
r_else
(brace
id|acsi_print_error
c_func
(paren
id|acsi_buffer
comma
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CARTRCH_STAT
c_func
(paren
id|dev
comma
id|acsi_buffer
)paren
)paren
id|acsi_info
(braket
id|dev
)braket
dot
id|changed
op_assign
l_int|1
suffix:semicolon
)brace
id|bad_rw_intr
c_func
(paren
)paren
suffix:semicolon
id|redo_acsi_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|do_end_requests
c_func
(paren
)paren
suffix:semicolon
id|redo_acsi_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|acsi_times_out
r_static
r_void
id|acsi_times_out
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
id|DISABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DEVICE_INTR
)paren
r_return
suffix:semicolon
id|DEVICE_INTR
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ACSI timeout&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|QUEUE_EMPTY
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|CURRENT-&gt;errors
op_ge
id|MAX_ERRORS
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ACSI: too many errors.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|redo_acsi_request
c_func
(paren
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/***********************************************************************&n; *&n; *  Scatter-gather utility functions&n; *&n; ***********************************************************************/
DECL|function|copy_to_acsibuffer
r_static
r_void
id|copy_to_acsibuffer
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|src
comma
op_star
id|dst
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|src
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|dst
op_assign
id|acsi_buffer
suffix:semicolon
id|bh
op_assign
id|CURRENT-&gt;bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
id|CurrentNSect
op_star
l_int|512
)paren
suffix:semicolon
r_else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CurrentNReq
suffix:semicolon
op_increment
id|i
)paren
(brace
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
id|dst
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_reqnext
)paren
)paren
id|src
op_assign
id|bh-&gt;b_data
suffix:semicolon
)brace
)brace
DECL|function|copy_from_acsibuffer
r_static
r_void
id|copy_from_acsibuffer
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|src
comma
op_star
id|dst
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|dst
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|src
op_assign
id|acsi_buffer
suffix:semicolon
id|bh
op_assign
id|CURRENT-&gt;bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
id|CurrentNSect
op_star
l_int|512
)paren
suffix:semicolon
r_else
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CurrentNReq
suffix:semicolon
op_increment
id|i
)paren
(brace
id|memcpy
c_func
(paren
id|dst
comma
id|src
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
id|src
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_reqnext
)paren
)paren
id|dst
op_assign
id|bh-&gt;b_data
suffix:semicolon
)brace
)brace
DECL|function|do_end_requests
r_static
r_void
id|do_end_requests
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CURRENT-&gt;bh
)paren
(brace
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|CurrentNSect
suffix:semicolon
id|CURRENT-&gt;current_nr_sectors
op_sub_assign
id|CurrentNSect
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|CurrentNSect
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;nr_sectors
op_eq
l_int|0
)paren
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CurrentNReq
suffix:semicolon
op_increment
id|i
)paren
(brace
id|n
op_assign
id|CURRENT-&gt;bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|n
suffix:semicolon
id|CURRENT-&gt;current_nr_sectors
op_sub_assign
id|n
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|n
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
)brace
)brace
"&f;"
multiline_comment|/***********************************************************************&n; *&n; *  do_acsi_request and friends&n; *&n; ***********************************************************************/
DECL|function|do_acsi_request
r_static
r_void
id|do_acsi_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
id|stdma_lock
c_func
(paren
id|acsi_interrupt
comma
l_int|NULL
)paren
suffix:semicolon
id|redo_acsi_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|redo_acsi_request
r_static
r_void
id|redo_acsi_request
c_func
(paren
r_void
)paren
(brace
r_int
id|block
comma
id|dev
comma
id|target
comma
id|lun
comma
id|nsect
suffix:semicolon
r_char
op_star
id|buffer
suffix:semicolon
r_int
r_int
id|pbuffer
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|QUEUE_EMPTY
op_logical_and
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|DEVICE_INTR
)paren
(brace
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEVICE_INTR
)paren
r_return
suffix:semicolon
id|repeat
suffix:colon
id|CLEAR_TIMER
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Another check here: An interrupt or timer event could have&n;&t; * happened since the last check!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|QUEUE_EMPTY
op_logical_and
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|DEVICE_INTR
)paren
(brace
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DEVICE_INTR
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|QUEUE_EMPTY
)paren
(brace
id|CLEAR_INTR
suffix:semicolon
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
op_ne
id|MAJOR_NR
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: request list destroyed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|CURRENT-&gt;bh
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|CURRENT-&gt;bh
)paren
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
)brace
id|dev
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
suffix:semicolon
id|block
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
r_if
c_cond
(paren
id|DEVICE_NR
c_func
(paren
id|dev
)paren
op_ge
id|NDevices
op_logical_or
id|block
op_plus
id|CURRENT-&gt;nr_sectors
op_ge
id|acsi_part
(braket
id|dev
)braket
dot
id|nr_sects
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;ad%c: attempted access for blocks %d...%ld past end of device at block %ld.&bslash;n&quot;
comma
id|DEVICE_NR
c_func
(paren
id|dev
)paren
op_plus
l_char|&squot;a&squot;
comma
id|block
comma
id|block
op_plus
id|CURRENT-&gt;nr_sectors
op_minus
l_int|1
comma
id|acsi_part
(braket
id|dev
)braket
dot
id|nr_sects
)paren
suffix:semicolon
macro_line|#endif
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|acsi_info
(braket
id|DEVICE_NR
c_func
(paren
id|dev
)paren
)braket
dot
id|changed
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ad%c: request denied because cartridge has &quot;
l_string|&quot;been changed.&bslash;n&quot;
comma
id|DEVICE_NR
c_func
(paren
id|dev
)paren
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|block
op_add_assign
id|acsi_part
(braket
id|dev
)braket
dot
id|start_sect
suffix:semicolon
id|target
op_assign
id|acsi_info
(braket
id|DEVICE_NR
c_func
(paren
id|dev
)paren
)braket
dot
id|target
suffix:semicolon
id|lun
op_assign
id|acsi_info
(braket
id|DEVICE_NR
c_func
(paren
id|dev
)paren
)braket
dot
id|lun
suffix:semicolon
multiline_comment|/* Find out how many sectors should be transferred from/to&n;&t; * consecutive buffers and thus can be done with a single command.&n;&t; */
id|buffer
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|pbuffer
op_assign
id|virt_to_phys
c_func
(paren
id|buffer
)paren
suffix:semicolon
id|nsect
op_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|CurrentNReq
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|CURRENT-&gt;bh
)paren
op_logical_and
id|bh
op_ne
id|CURRENT-&gt;bhtail
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|STRAM_ADDR
c_func
(paren
id|pbuffer
)paren
)paren
(brace
multiline_comment|/* If transfer is done via the ACSI buffer anyway, we can&n;&t;&t;&t; * assemble as much bh&squot;s as fit in the buffer.&n;&t;&t;&t; */
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_reqnext
)paren
)paren
(brace
r_if
c_cond
(paren
id|nsect
op_plus
(paren
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
OG
id|ACSI_BUFFER_SECTORS
)paren
r_break
suffix:semicolon
id|nsect
op_add_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
op_increment
id|CurrentNReq
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_eq
id|CURRENT-&gt;bhtail
)paren
r_break
suffix:semicolon
)brace
id|buffer
op_assign
id|acsi_buffer
suffix:semicolon
id|pbuffer
op_assign
id|phys_acsi_buffer
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|pendadr
comma
id|pnewadr
suffix:semicolon
id|pendadr
op_assign
id|pbuffer
op_plus
id|nsect
op_star
l_int|512
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_reqnext
)paren
)paren
(brace
id|pnewadr
op_assign
id|virt_to_phys
c_func
(paren
id|bh-&gt;b_data
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|STRAM_ADDR
c_func
(paren
id|pnewadr
)paren
op_logical_or
id|pendadr
op_ne
id|pnewadr
)paren
r_break
suffix:semicolon
id|nsect
op_add_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|pendadr
op_assign
id|pnewadr
op_plus
id|bh-&gt;b_size
suffix:semicolon
op_increment
id|CurrentNReq
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_eq
id|CURRENT-&gt;bhtail
)paren
r_break
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|STRAM_ADDR
c_func
(paren
id|pbuffer
)paren
)paren
(brace
id|buffer
op_assign
id|acsi_buffer
suffix:semicolon
id|pbuffer
op_assign
id|phys_acsi_buffer
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|ACSI_BUFFER_SECTORS
)paren
id|nsect
op_assign
id|ACSI_BUFFER_SECTORS
suffix:semicolon
)brace
)brace
id|CurrentBuffer
op_assign
id|buffer
suffix:semicolon
id|CurrentNSect
op_assign
id|nsect
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|WRITE
)paren
(brace
id|CMDSET_TARG_LUN
c_func
(paren
id|write_cmd
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|CMDSET_BLOCK
c_func
(paren
id|write_cmd
comma
id|block
)paren
suffix:semicolon
id|CMDSET_LEN
c_func
(paren
id|write_cmd
comma
id|nsect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buffer
op_eq
id|acsi_buffer
)paren
id|copy_to_acsibuffer
c_func
(paren
)paren
suffix:semicolon
id|dma_cache_maintenance
c_func
(paren
id|pbuffer
comma
id|nsect
op_star
l_int|512
comma
l_int|1
)paren
suffix:semicolon
id|SET_INTR
c_func
(paren
id|write_intr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsicmd_dma
c_func
(paren
id|write_cmd
comma
id|buffer
comma
id|nsect
comma
l_int|1
comma
l_int|1
)paren
)paren
(brace
id|CLEAR_INTR
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ACSI (write): Timeout in command block&bslash;n&quot;
)paren
suffix:semicolon
id|bad_rw_intr
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|SET_TIMER
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|READ
)paren
(brace
id|CMDSET_TARG_LUN
c_func
(paren
id|read_cmd
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|CMDSET_BLOCK
c_func
(paren
id|read_cmd
comma
id|block
)paren
suffix:semicolon
id|CMDSET_LEN
c_func
(paren
id|read_cmd
comma
id|nsect
)paren
suffix:semicolon
id|SET_INTR
c_func
(paren
id|read_intr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsicmd_dma
c_func
(paren
id|read_cmd
comma
id|buffer
comma
id|nsect
comma
l_int|0
comma
l_int|1
)paren
)paren
(brace
id|CLEAR_INTR
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ACSI (read): Timeout in command block&bslash;n&quot;
)paren
suffix:semicolon
id|bad_rw_intr
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|SET_TIMER
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|panic
c_func
(paren
l_string|&quot;unknown ACSI command&quot;
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/***********************************************************************&n; *&n; *  Misc functions: ioctl, open, release, check_change, ...&n; *&n; ***********************************************************************/
DECL|function|acsi_ioctl
r_static
r_int
id|acsi_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ge
id|NDevices
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
multiline_comment|/* HDIO_GETGEO is supported more for getting the partition&squot;s&n;&t;&t; * start sector... */
(brace
r_struct
id|hd_geometry
op_star
id|geo
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
multiline_comment|/* just fake some geometry here, it&squot;s nonsense anyway; to make it&n;&t;&t; * easy, use Adaptec&squot;s usual 64/32 mapping */
id|put_user
c_func
(paren
l_int|64
comma
op_amp
id|geo-&gt;heads
)paren
suffix:semicolon
id|put_user
c_func
(paren
l_int|32
comma
op_amp
id|geo-&gt;sectors
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|acsi_info
(braket
id|dev
)braket
dot
id|size
op_rshift
l_int|11
comma
op_amp
id|geo-&gt;cylinders
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|acsi_part
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|start_sect
comma
op_amp
id|geo-&gt;start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|SCSI_IOCTL_GET_IDLUN
suffix:colon
multiline_comment|/* SCSI compatible GET_IDLUN call to get target&squot;s ID and LUN number */
id|put_user
c_func
(paren
id|acsi_info
(braket
id|dev
)braket
dot
id|target
op_or
(paren
id|acsi_info
(braket
id|dev
)braket
dot
id|lun
op_lshift
l_int|8
)paren
comma
op_amp
(paren
(paren
id|Scsi_Idlun
op_star
)paren
id|arg
)paren
op_member_access_from_pointer
id|dev_id
)paren
suffix:semicolon
id|put_user
c_func
(paren
l_int|0
comma
op_amp
(paren
(paren
id|Scsi_Idlun
op_star
)paren
id|arg
)paren
op_member_access_from_pointer
id|host_unique_id
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
multiline_comment|/* Return device size */
r_return
id|put_user
c_func
(paren
id|acsi_part
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|nr_sects
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|BLKROSET
suffix:colon
r_case
id|BLKROGET
suffix:colon
r_case
id|BLKFLSBUF
suffix:colon
r_case
id|BLKPG
suffix:colon
r_return
id|blk_ioctl
c_func
(paren
id|inode-&gt;i_rdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_case
id|BLKRRPART
suffix:colon
multiline_comment|/* Re-read partition tables */
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
id|revalidate_acsidisk
c_func
(paren
id|inode-&gt;i_rdev
comma
l_int|1
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Open a device, check for read-only and lock the medium if it is&n; * removable.&n; *&n; * Changes by Martin Rogge, 9th Aug 1995:&n; * Check whether check_disk_change (and therefore revalidate_acsidisk)&n; * was successful. They fail when there is no medium in the drive.&n; *&n; * The problem of media being changed during an operation can be &n; * ignored because of the prevent_removal code.&n; *&n; * Added check for the validity of the device number.&n; *&n; */
DECL|function|acsi_open
r_static
r_int
id|acsi_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|device
suffix:semicolon
r_struct
id|acsi_info_struct
op_star
id|aip
suffix:semicolon
id|device
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
op_ge
id|NDevices
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|aip
op_assign
op_amp
id|acsi_info
(braket
id|device
)braket
suffix:semicolon
r_while
c_loop
(paren
id|busy
(braket
id|device
)braket
)paren
id|sleep_on
c_func
(paren
op_amp
id|busy_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|access_count
(braket
id|device
)braket
op_eq
l_int|0
op_logical_and
id|aip-&gt;removable
)paren
(brace
macro_line|#if 0
id|aip-&gt;changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* safety first */
macro_line|#endif
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aip-&gt;changed
)paren
multiline_comment|/* revalidate was not successful (no medium) */
r_return
op_minus
id|ENXIO
suffix:semicolon
id|acsi_prevent_removal
c_func
(paren
id|device
comma
l_int|1
)paren
suffix:semicolon
)brace
id|access_count
(braket
id|device
)braket
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|filp
op_logical_and
id|filp-&gt;f_mode
)paren
(brace
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|aip-&gt;read_only
)paren
(brace
id|acsi_release
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Releasing a block device means we sync() it, so that it can safely&n; * be forgotten about...&n; */
DECL|function|acsi_release
r_static
r_int
id|acsi_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|device
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|access_count
(braket
id|device
)braket
op_eq
l_int|0
op_logical_and
id|acsi_info
(braket
id|device
)braket
dot
id|removable
)paren
id|acsi_prevent_removal
c_func
(paren
id|device
comma
l_int|0
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Prevent or allow a media change for removable devices.&n; */
DECL|function|acsi_prevent_removal
r_static
r_void
id|acsi_prevent_removal
c_func
(paren
r_int
id|device
comma
r_int
id|flag
)paren
(brace
id|stdma_lock
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|CMDSET_TARG_LUN
c_func
(paren
id|pa_med_rem_cmd
comma
id|acsi_info
(braket
id|device
)braket
dot
id|target
comma
id|acsi_info
(braket
id|device
)braket
dot
id|lun
)paren
suffix:semicolon
id|CMDSET_LEN
c_func
(paren
id|pa_med_rem_cmd
comma
id|flag
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acsicmd_nodma
c_func
(paren
id|pa_med_rem_cmd
comma
l_int|0
)paren
op_logical_and
id|acsi_wait_for_IRQ
c_func
(paren
l_int|3
op_star
id|HZ
)paren
)paren
id|acsi_getstatus
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Do not report errors -- some devices may not know this command. */
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|acsi_media_change
r_static
r_int
id|acsi_media_change
(paren
id|dev_t
id|dev
)paren
(brace
r_int
id|device
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_struct
id|acsi_info_struct
op_star
id|aip
suffix:semicolon
id|aip
op_assign
op_amp
id|acsi_info
(braket
id|device
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aip-&gt;removable
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|aip-&gt;changed
)paren
multiline_comment|/* We can be sure that the medium has been changed -- REQUEST&n;&t;&t; * SENSE has reported this earlier.&n;&t;&t; */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* If the flag isn&squot;t set, make a test by reading block 0.&n;&t; * If errors happen, it seems to be better to say &quot;changed&quot;...&n;&t; */
id|stdma_lock
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|CMDSET_TARG_LUN
c_func
(paren
id|read_cmd
comma
id|aip-&gt;target
comma
id|aip-&gt;lun
)paren
suffix:semicolon
id|CMDSET_BLOCK
c_func
(paren
id|read_cmd
comma
l_int|0
)paren
suffix:semicolon
id|CMDSET_LEN
c_func
(paren
id|read_cmd
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acsicmd_dma
c_func
(paren
id|read_cmd
comma
id|acsi_buffer
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
op_logical_and
id|acsi_wait_for_IRQ
c_func
(paren
l_int|3
op_star
id|HZ
)paren
)paren
(brace
r_if
c_cond
(paren
id|acsi_getstatus
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|acsi_reqsense
c_func
(paren
id|acsi_buffer
comma
id|aip-&gt;target
comma
id|aip-&gt;lun
)paren
)paren
(brace
r_if
c_cond
(paren
id|CARTRCH_STAT
c_func
(paren
id|device
comma
id|acsi_buffer
)paren
)paren
id|aip-&gt;changed
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ad%c: REQUEST SENSE failed in test for &quot;
l_string|&quot;medium change; assuming a change&bslash;n&quot;
comma
id|device
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
id|aip-&gt;changed
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ad%c: Test for medium changed timed out; &quot;
l_string|&quot;assuming a change&bslash;n&quot;
comma
id|device
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
id|aip-&gt;changed
op_assign
l_int|1
suffix:semicolon
)brace
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Now, after reading a block, the changed status is surely valid. */
r_return
id|aip-&gt;changed
suffix:semicolon
)brace
DECL|function|acsi_change_blk_size
r_static
r_int
id|acsi_change_blk_size
c_func
(paren
r_int
id|target
comma
r_int
id|lun
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|12
suffix:semicolon
id|i
op_increment
)paren
id|acsi_buffer
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|acsi_buffer
(braket
l_int|3
)braket
op_assign
l_int|8
suffix:semicolon
id|acsi_buffer
(braket
l_int|10
)braket
op_assign
l_int|2
suffix:semicolon
id|CMDSET_TARG_LUN
c_func
(paren
id|modeselect_cmd
comma
id|target
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsicmd_dma
c_func
(paren
id|modeselect_cmd
comma
id|acsi_buffer
comma
l_int|1
comma
l_int|1
comma
l_int|0
)paren
op_logical_or
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
l_int|3
op_star
id|HZ
)paren
op_logical_or
id|acsi_getstatus
c_func
(paren
)paren
op_ne
l_int|0
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|acsi_mode_sense
r_static
r_int
id|acsi_mode_sense
c_func
(paren
r_int
id|target
comma
r_int
id|lun
comma
id|SENSE_DATA
op_star
id|sd
)paren
(brace
r_int
id|page
suffix:semicolon
id|CMDSET_TARG_LUN
c_func
(paren
id|modesense_cmd
comma
id|target
comma
id|lun
)paren
suffix:semicolon
r_for
c_loop
(paren
id|page
op_assign
l_int|0
suffix:semicolon
id|page
OL
l_int|4
suffix:semicolon
id|page
op_increment
)paren
(brace
id|modesense_cmd
(braket
l_int|2
)braket
op_assign
id|page
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsicmd_dma
c_func
(paren
id|modesense_cmd
comma
id|acsi_buffer
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
op_logical_or
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
l_int|3
op_star
id|HZ
)paren
op_logical_or
id|acsi_getstatus
c_func
(paren
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* read twice to jump over the second 16-byte border! */
id|udelay
c_func
(paren
l_int|300
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acsi_wait_for_noIRQ
c_func
(paren
l_int|20
)paren
op_logical_and
id|acsicmd_nodma
c_func
(paren
id|modesense_cmd
comma
l_int|0
)paren
op_logical_and
id|acsi_wait_for_IRQ
c_func
(paren
l_int|3
op_star
id|HZ
)paren
op_logical_and
id|acsi_getstatus
c_func
(paren
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|page
op_eq
l_int|4
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|dma_cache_maintenance
c_func
(paren
id|phys_acsi_buffer
comma
r_sizeof
(paren
id|SENSE_DATA
)paren
comma
l_int|0
)paren
suffix:semicolon
op_star
id|sd
op_assign
op_star
(paren
id|SENSE_DATA
op_star
)paren
id|acsi_buffer
suffix:semicolon
multiline_comment|/* Validity check, depending on type of data */
r_switch
c_cond
(paren
id|SENSE_TYPE
c_func
(paren
op_star
id|sd
)paren
)paren
(brace
r_case
id|SENSE_TYPE_ATARI
suffix:colon
r_if
c_cond
(paren
id|CAPACITY
c_func
(paren
op_star
id|sd
)paren
op_eq
l_int|0
)paren
r_goto
id|invalid_sense
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SENSE_TYPE_SCSI
suffix:colon
r_if
c_cond
(paren
id|sd-&gt;scsi.descriptor_size
op_ne
l_int|8
)paren
r_goto
id|invalid_sense
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SENSE_TYPE_UNKNOWN
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ACSI target %d, lun %d: Cannot interpret &quot;
l_string|&quot;sense data&bslash;n&quot;
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|invalid_sense
suffix:colon
macro_line|#ifdef DEBUG
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Mode sense data for ACSI target %d, lun %d seem not valid:&quot;
comma
id|target
comma
id|lun
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|SENSE_DATA
)paren
suffix:semicolon
op_increment
id|i
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%02x &quot;
comma
(paren
r_int
r_char
)paren
id|acsi_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*******************************************************************&n; *&n; *  Initialization&n; *&n; ********************************************************************/
r_extern
r_struct
id|block_device_operations
id|acsi_fops
suffix:semicolon
DECL|variable|acsi_gendisk
r_static
r_struct
id|gendisk
id|acsi_gendisk
op_assign
(brace
id|MAJOR_NR
comma
multiline_comment|/* Major number */
l_string|&quot;ad&quot;
comma
multiline_comment|/* Major name */
l_int|4
comma
multiline_comment|/* Bits to shift to get real from partition */
l_int|1
op_lshift
l_int|4
comma
multiline_comment|/* Number of partitions per real */
id|acsi_part
comma
multiline_comment|/* hd struct */
id|acsi_sizes
comma
multiline_comment|/* block sizes */
l_int|0
comma
multiline_comment|/* number */
(paren
r_void
op_star
)paren
id|acsi_info
comma
multiline_comment|/* internal */
l_int|NULL
comma
multiline_comment|/* next */
op_amp
id|acsi_fops
comma
multiline_comment|/* file operations */
)brace
suffix:semicolon
DECL|macro|MAX_SCSI_DEVICE_CODE
mdefine_line|#define MAX_SCSI_DEVICE_CODE 10
DECL|variable|scsi_device_types
r_static
r_const
r_char
op_star
r_const
id|scsi_device_types
(braket
id|MAX_SCSI_DEVICE_CODE
)braket
op_assign
(brace
l_string|&quot;Direct-Access    &quot;
comma
l_string|&quot;Sequential-Access&quot;
comma
l_string|&quot;Printer          &quot;
comma
l_string|&quot;Processor        &quot;
comma
l_string|&quot;WORM             &quot;
comma
l_string|&quot;CD-ROM           &quot;
comma
l_string|&quot;Scanner          &quot;
comma
l_string|&quot;Optical Device   &quot;
comma
l_string|&quot;Medium Changer   &quot;
comma
l_string|&quot;Communications   &quot;
)brace
suffix:semicolon
DECL|function|print_inquiry
r_static
r_void
id|print_inquiry
c_func
(paren
r_int
r_char
op_star
id|data
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Vendor: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|8
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Model: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|16
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  Rev: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|32
suffix:semicolon
id|i
OL
l_int|36
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|data
(braket
id|i
)braket
op_ge
l_int|0x20
op_logical_and
id|i
OL
id|data
(braket
l_int|4
)braket
op_plus
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|data
(braket
id|i
)braket
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|i
op_assign
id|data
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Type:   %s &quot;
comma
(paren
id|i
OL
id|MAX_SCSI_DEVICE_CODE
ques
c_cond
id|scsi_device_types
(braket
id|i
)braket
suffix:colon
l_string|&quot;Unknown          &quot;
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                 ANSI SCSI revision: %02x&quot;
comma
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|data
(braket
l_int|2
)braket
op_amp
l_int|0x07
)paren
op_eq
l_int|1
op_logical_and
(paren
id|data
(braket
l_int|3
)braket
op_amp
l_int|0x0f
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot; CCS&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Changes by Martin Rogge, 9th Aug 1995: &n; * acsi_devinit has been taken out of acsi_geninit, because it needs &n; * to be called from revalidate_acsidisk. The result of request sense &n; * is now checked for DRIVE NOT READY.&n; *&n; * The structure *aip is only valid when acsi_devinit returns &n; * DEV_SUPPORTED. &n; *&n; */
DECL|macro|DEV_NONE
mdefine_line|#define DEV_NONE&t;0
DECL|macro|DEV_UNKNOWN
mdefine_line|#define DEV_UNKNOWN&t;1
DECL|macro|DEV_SUPPORTED
mdefine_line|#define DEV_SUPPORTED&t;2
DECL|macro|DEV_SLM
mdefine_line|#define DEV_SLM&t;&t;3
DECL|function|acsi_devinit
r_static
r_int
id|acsi_devinit
c_func
(paren
r_struct
id|acsi_info_struct
op_star
id|aip
)paren
(brace
r_int
id|status
comma
id|got_inquiry
suffix:semicolon
id|SENSE_DATA
id|sense
suffix:semicolon
r_int
r_char
id|reqsense
comma
id|extsense
suffix:semicolon
multiline_comment|/*****************************************************************/
multiline_comment|/* Do a TEST UNIT READY command to test the presence of a device */
multiline_comment|/*****************************************************************/
id|CMDSET_TARG_LUN
c_func
(paren
id|tur_cmd
comma
id|aip-&gt;target
comma
id|aip-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsicmd_nodma
c_func
(paren
id|tur_cmd
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* timed out -&gt; no device here */
macro_line|#ifdef DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;target %d lun %d: timeout&bslash;n&quot;
comma
id|aip-&gt;target
comma
id|aip-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
r_return
id|DEV_NONE
suffix:semicolon
)brace
multiline_comment|/*************************/
multiline_comment|/* Read the ACSI status. */
multiline_comment|/*************************/
id|status
op_assign
id|acsi_getstatus
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
r_if
c_cond
(paren
id|status
op_eq
l_int|0x12
)paren
(brace
multiline_comment|/* The SLM printer should be the only device that&n;&t;&t;&t; * responds with the error code in the status byte. In&n;&t;&t;&t; * correct status bytes, bit 4 is never set.&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Detected SLM printer at id %d lun %d&bslash;n&quot;
comma
id|aip-&gt;target
comma
id|aip-&gt;lun
)paren
suffix:semicolon
r_return
id|DEV_SLM
suffix:semicolon
)brace
multiline_comment|/* ignore CHECK CONDITION, since some devices send a&n;&t;&t;   UNIT ATTENTION */
r_if
c_cond
(paren
(paren
id|status
op_amp
l_int|0x1e
)paren
op_ne
l_int|0x2
)paren
(brace
macro_line|#ifdef DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;target %d lun %d: status %d&bslash;n&quot;
comma
id|aip-&gt;target
comma
id|aip-&gt;lun
comma
id|status
)paren
suffix:semicolon
macro_line|#endif
r_return
id|DEV_UNKNOWN
suffix:semicolon
)brace
)brace
multiline_comment|/*******************************/
multiline_comment|/* Do a REQUEST SENSE command. */
multiline_comment|/*******************************/
r_if
c_cond
(paren
op_logical_neg
id|acsi_reqsense
c_func
(paren
id|acsi_buffer
comma
id|aip-&gt;target
comma
id|aip-&gt;lun
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;acsi_reqsense failed&bslash;n&quot;
)paren
suffix:semicolon
id|acsi_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|acsi_buffer
(braket
l_int|2
)braket
op_assign
id|UNIT_ATTENTION
suffix:semicolon
)brace
id|reqsense
op_assign
id|acsi_buffer
(braket
l_int|0
)braket
suffix:semicolon
id|extsense
op_assign
id|acsi_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|status
)paren
(brace
r_if
c_cond
(paren
(paren
id|reqsense
op_amp
l_int|0x70
)paren
op_eq
l_int|0x70
)paren
(brace
multiline_comment|/* extended sense */
r_if
c_cond
(paren
id|extsense
op_ne
id|UNIT_ATTENTION
op_logical_and
id|extsense
op_ne
id|NOT_READY
)paren
(brace
macro_line|#ifdef DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;target %d lun %d: extended sense %d&bslash;n&quot;
comma
id|aip-&gt;target
comma
id|aip-&gt;lun
comma
id|extsense
)paren
suffix:semicolon
macro_line|#endif
r_return
id|DEV_UNKNOWN
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|reqsense
op_amp
l_int|0x7f
)paren
(brace
macro_line|#ifdef DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;target %d lun %d: sense %d&bslash;n&quot;
comma
id|aip-&gt;target
comma
id|aip-&gt;lun
comma
id|reqsense
)paren
suffix:semicolon
macro_line|#endif
r_return
id|DEV_UNKNOWN
suffix:semicolon
)brace
)brace
)brace
r_else
r_if
c_cond
(paren
id|reqsense
op_eq
l_int|0x4
)paren
(brace
multiline_comment|/* SH204 Bug workaround */
macro_line|#ifdef DEBUG_DETECT
id|printk
c_func
(paren
l_string|&quot;target %d lun %d status=0 sense=4&bslash;n&quot;
comma
id|aip-&gt;target
comma
id|aip-&gt;lun
)paren
suffix:semicolon
macro_line|#endif
r_return
id|DEV_UNKNOWN
suffix:semicolon
)brace
multiline_comment|/***********************************************************/
multiline_comment|/* Do an INQUIRY command to get more infos on this device. */
multiline_comment|/***********************************************************/
multiline_comment|/* Assume default values */
id|aip-&gt;removable
op_assign
l_int|1
suffix:semicolon
id|aip-&gt;read_only
op_assign
l_int|0
suffix:semicolon
id|aip-&gt;old_atari_disk
op_assign
l_int|0
suffix:semicolon
id|aip-&gt;changed
op_assign
(paren
id|extsense
op_eq
id|NOT_READY
)paren
suffix:semicolon
multiline_comment|/* medium inserted? */
id|aip-&gt;size
op_assign
id|DEFAULT_SIZE
suffix:semicolon
id|got_inquiry
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fake inquiry result for old atari disks */
id|memcpy
c_func
(paren
id|acsi_buffer
comma
l_string|&quot;&bslash;000&bslash;000&bslash;001&bslash;000    Adaptec 40xx&quot;
l_string|&quot;                    &quot;
comma
l_int|40
)paren
suffix:semicolon
id|CMDSET_TARG_LUN
c_func
(paren
id|inquiry_cmd
comma
id|aip-&gt;target
comma
id|aip-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acsicmd_dma
c_func
(paren
id|inquiry_cmd
comma
id|acsi_buffer
comma
l_int|1
comma
l_int|0
comma
l_int|0
)paren
op_logical_and
id|acsi_getstatus
c_func
(paren
)paren
op_eq
l_int|0
)paren
(brace
id|acsicmd_nodma
c_func
(paren
id|inquiry_cmd
comma
l_int|0
)paren
suffix:semicolon
id|acsi_getstatus
c_func
(paren
)paren
suffix:semicolon
id|dma_cache_maintenance
c_func
(paren
id|phys_acsi_buffer
comma
l_int|256
comma
l_int|0
)paren
suffix:semicolon
id|got_inquiry
op_assign
l_int|1
suffix:semicolon
id|aip-&gt;removable
op_assign
op_logical_neg
op_logical_neg
(paren
id|acsi_buffer
(braket
l_int|1
)braket
op_amp
l_int|0x80
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aip-&gt;type
op_eq
id|NONE
)paren
multiline_comment|/* only at boot time */
id|print_inquiry
c_func
(paren
id|acsi_buffer
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|acsi_buffer
(braket
l_int|0
)braket
)paren
(brace
r_case
id|TYPE_DISK
suffix:colon
id|aip-&gt;type
op_assign
id|HARDDISK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|TYPE_ROM
suffix:colon
id|aip-&gt;type
op_assign
id|CDROM
suffix:semicolon
id|aip-&gt;read_only
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
id|DEV_UNKNOWN
suffix:semicolon
)brace
multiline_comment|/****************************/
multiline_comment|/* Do a MODE SENSE command. */
multiline_comment|/****************************/
r_if
c_cond
(paren
op_logical_neg
id|acsi_mode_sense
c_func
(paren
id|aip-&gt;target
comma
id|aip-&gt;lun
comma
op_amp
id|sense
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No mode sense data.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|DEV_UNKNOWN
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|SECTOR_SIZE
c_func
(paren
id|sense
)paren
op_ne
l_int|512
)paren
op_logical_and
(paren
(paren
id|aip-&gt;type
op_ne
id|CDROM
)paren
op_logical_or
op_logical_neg
id|acsi_change_blk_size
c_func
(paren
id|aip-&gt;target
comma
id|aip-&gt;lun
)paren
op_logical_or
op_logical_neg
id|acsi_mode_sense
c_func
(paren
id|aip-&gt;target
comma
id|aip-&gt;lun
comma
op_amp
id|sense
)paren
op_logical_or
(paren
id|SECTOR_SIZE
c_func
(paren
id|sense
)paren
op_ne
l_int|512
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Sector size != 512 not supported.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|DEV_UNKNOWN
suffix:semicolon
)brace
multiline_comment|/* There are disks out there that claim to have 0 sectors... */
r_if
c_cond
(paren
id|CAPACITY
c_func
(paren
id|sense
)paren
)paren
id|aip-&gt;size
op_assign
id|CAPACITY
c_func
(paren
id|sense
)paren
suffix:semicolon
multiline_comment|/* else keep DEFAULT_SIZE */
r_if
c_cond
(paren
op_logical_neg
id|got_inquiry
op_logical_and
id|SENSE_TYPE
c_func
(paren
id|sense
)paren
op_eq
id|SENSE_TYPE_ATARI
)paren
(brace
multiline_comment|/* If INQUIRY failed and the sense data suggest an old&n;&t;&t; * Atari disk (SH20x, Megafile), the disk is not removable&n;&t;&t; */
id|aip-&gt;removable
op_assign
l_int|0
suffix:semicolon
id|aip-&gt;old_atari_disk
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/******************/
multiline_comment|/* We&squot;ve done it. */
multiline_comment|/******************/
r_return
id|DEV_SUPPORTED
suffix:semicolon
)brace
DECL|variable|acsi_delay_start
id|EXPORT_SYMBOL
c_func
(paren
id|acsi_delay_start
)paren
suffix:semicolon
DECL|variable|acsi_delay_end
id|EXPORT_SYMBOL
c_func
(paren
id|acsi_delay_end
)paren
suffix:semicolon
DECL|variable|acsi_wait_for_IRQ
id|EXPORT_SYMBOL
c_func
(paren
id|acsi_wait_for_IRQ
)paren
suffix:semicolon
DECL|variable|acsi_wait_for_noIRQ
id|EXPORT_SYMBOL
c_func
(paren
id|acsi_wait_for_noIRQ
)paren
suffix:semicolon
DECL|variable|acsicmd_nodma
id|EXPORT_SYMBOL
c_func
(paren
id|acsicmd_nodma
)paren
suffix:semicolon
DECL|variable|acsi_getstatus
id|EXPORT_SYMBOL
c_func
(paren
id|acsi_getstatus
)paren
suffix:semicolon
DECL|variable|acsi_buffer
id|EXPORT_SYMBOL
c_func
(paren
id|acsi_buffer
)paren
suffix:semicolon
DECL|variable|phys_acsi_buffer
id|EXPORT_SYMBOL
c_func
(paren
id|phys_acsi_buffer
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_ATARI_SLM_MODULE
r_void
id|acsi_attach_SLMs
c_func
(paren
r_int
(paren
op_star
id|attach_func
)paren
(paren
r_int
comma
r_int
)paren
)paren
suffix:semicolon
DECL|variable|acsi_extstatus
id|EXPORT_SYMBOL
c_func
(paren
id|acsi_extstatus
)paren
suffix:semicolon
DECL|variable|acsi_end_extstatus
id|EXPORT_SYMBOL
c_func
(paren
id|acsi_end_extstatus
)paren
suffix:semicolon
DECL|variable|acsi_extcmd
id|EXPORT_SYMBOL
c_func
(paren
id|acsi_extcmd
)paren
suffix:semicolon
DECL|variable|acsi_attach_SLMs
id|EXPORT_SYMBOL
c_func
(paren
id|acsi_attach_SLMs
)paren
suffix:semicolon
multiline_comment|/* to remember IDs of SLM devices, SLM module is loaded later&n; * (index is target#, contents is lun#, -1 means &quot;no SLM&quot;) */
DECL|variable|SLM_devices
r_int
id|SLM_devices
(braket
l_int|8
)braket
suffix:semicolon
macro_line|#endif
DECL|variable|acsi_fops
r_static
r_struct
id|block_device_operations
id|acsi_fops
op_assign
(brace
id|open
suffix:colon
id|acsi_open
comma
id|release
suffix:colon
id|acsi_release
comma
id|ioctl
suffix:colon
id|acsi_ioctl
comma
id|check_media_change
suffix:colon
id|acsi_media_change
comma
id|revalidate
suffix:colon
id|acsi_revalidate
comma
)brace
suffix:semicolon
DECL|function|acsi_geninit
r_static
r_void
id|acsi_geninit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|target
comma
id|lun
suffix:semicolon
r_struct
id|acsi_info_struct
op_star
id|aip
suffix:semicolon
macro_line|#ifdef CONFIG_ATARI_SLM
r_int
id|n_slm
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Probing ACSI devices:&bslash;n&quot;
)paren
suffix:semicolon
id|NDevices
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_ATARI_SLM_MODULE
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
(brace
id|SLM_devices
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif
id|stdma_lock
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|target
op_assign
l_int|0
suffix:semicolon
id|target
OL
l_int|8
op_logical_and
id|NDevices
OL
id|MAX_DEV
suffix:semicolon
op_increment
id|target
)paren
(brace
id|lun
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|aip
op_assign
op_amp
id|acsi_info
(braket
id|NDevices
)braket
suffix:semicolon
id|aip-&gt;type
op_assign
id|NONE
suffix:semicolon
id|aip-&gt;target
op_assign
id|target
suffix:semicolon
id|aip-&gt;lun
op_assign
id|lun
suffix:semicolon
id|i
op_assign
id|acsi_devinit
c_func
(paren
id|aip
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|i
)paren
(brace
r_case
id|DEV_SUPPORTED
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Detected &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|aip-&gt;type
)paren
(brace
r_case
id|HARDDISK
suffix:colon
id|printk
c_func
(paren
l_string|&quot;disk&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROM
suffix:colon
id|printk
c_func
(paren
l_string|&quot;cdrom&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
id|printk
c_func
(paren
l_string|&quot; ad%c at id %d lun %d &quot;
comma
l_char|&squot;a&squot;
op_plus
id|NDevices
comma
id|target
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aip-&gt;removable
)paren
id|printk
c_func
(paren
l_string|&quot;(removable) &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aip-&gt;read_only
)paren
id|printk
c_func
(paren
l_string|&quot;(read-only) &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aip-&gt;size
op_eq
id|DEFAULT_SIZE
)paren
id|printk
c_func
(paren
l_string|&quot; unkown size, using default &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%ld MByte&bslash;n&quot;
comma
(paren
id|aip-&gt;size
op_star
l_int|512
op_plus
l_int|1024
op_star
l_int|1024
op_div
l_int|2
)paren
op_div
(paren
l_int|1024
op_star
l_int|1024
)paren
)paren
suffix:semicolon
id|NDevices
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DEV_SLM
suffix:colon
macro_line|#ifdef CONFIG_ATARI_SLM
id|n_slm
op_add_assign
id|attach_slm
c_func
(paren
id|target
comma
id|lun
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ATARI_SLM_MODULE
id|SLM_devices
(braket
id|target
)braket
op_assign
id|lun
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
multiline_comment|/* neither of the above: fall through to unknown device */
r_case
id|DEV_UNKNOWN
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Detected unsupported device at &quot;
l_string|&quot;id %d lun %d&bslash;n&quot;
comma
id|target
comma
id|lun
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_ACSI_MULTI_LUN
r_while
c_loop
(paren
id|i
op_ne
id|DEV_NONE
op_logical_and
op_increment
id|lun
OL
id|MAX_LUN
)paren
suffix:semicolon
macro_line|#else
r_while
c_loop
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* reenable interrupt */
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_ATARI_SLM
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Found %d ACSI device(s) total.&bslash;n&quot;
comma
id|NDevices
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Found %d ACSI device(s) and %d SLM printer(s) total.&bslash;n&quot;
comma
id|NDevices
comma
id|n_slm
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|MAX_DEV
op_lshift
l_int|4
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|acsi_blocksizes
(braket
id|i
)braket
op_assign
l_int|1024
suffix:semicolon
)brace
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|acsi_blocksizes
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NDevices
suffix:semicolon
op_increment
id|i
)paren
(brace
id|register_disk
c_func
(paren
op_amp
id|acsi_gendisk
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|i
op_lshift
l_int|4
)paren
comma
(paren
id|acsi_info
(braket
id|i
)braket
dot
id|type
op_eq
id|HARDDISK
)paren
ques
c_cond
l_int|1
op_lshift
l_int|4
suffix:colon
l_int|1
comma
op_amp
id|acsi_fops
comma
id|acsi_info
(braket
id|i
)braket
dot
id|size
)paren
suffix:semicolon
)brace
id|acsi_gendisk.nr_real
op_assign
id|NDevices
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_ATARI_SLM_MODULE
multiline_comment|/* call attach_slm() for each device that is a printer; needed for init of SLM&n; * driver as a module, since it&squot;s not yet present if acsi.c is inited and thus&n; * the bus gets scanned. */
DECL|function|acsi_attach_SLMs
r_void
id|acsi_attach_SLMs
c_func
(paren
r_int
(paren
op_star
id|attach_func
)paren
(paren
r_int
comma
r_int
)paren
)paren
(brace
r_int
id|i
comma
id|n
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
r_if
c_cond
(paren
id|SLM_devices
(braket
id|i
)braket
op_ge
l_int|0
)paren
id|n
op_add_assign
(paren
op_star
id|attach_func
)paren
(paren
id|i
comma
id|SLM_devices
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Found %d SLM printer(s) total.&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ATARI_SLM_MODULE */
DECL|function|acsi_init
r_int
id|acsi_init
c_func
(paren
r_void
)paren
(brace
r_int
id|err
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MACH_IS_ATARI
op_logical_or
op_logical_neg
id|ATARIHW_PRESENT
c_func
(paren
id|ACSI
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|devfs_register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;ad&quot;
comma
op_amp
id|acsi_fops
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to get major %d for ACSI&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|acsi_buffer
op_assign
(paren
r_char
op_star
)paren
id|atari_stram_alloc
c_func
(paren
id|ACSI_BUFFER_SIZE
comma
l_string|&quot;acsi&quot;
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to get ACSI ST-Ram buffer.&bslash;n&quot;
)paren
suffix:semicolon
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;ad&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|phys_acsi_buffer
op_assign
id|virt_to_phys
c_func
(paren
id|acsi_buffer
)paren
suffix:semicolon
id|STramMask
op_assign
id|ATARIHW_PRESENT
c_func
(paren
id|EXTD_DMA
)paren
ques
c_cond
l_int|0x00000000
suffix:colon
l_int|0xff000000
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|DEVICE_REQUEST
)paren
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* 8 sector (4kB) read-ahead */
id|acsi_gendisk.next
op_assign
id|gendisk_head
suffix:semicolon
id|gendisk_head
op_assign
op_amp
id|acsi_gendisk
suffix:semicolon
macro_line|#ifdef CONFIG_ATARI_SLM
id|err
op_assign
id|slm_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|acsi_geninit
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|acsi_init
c_func
(paren
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ACSI driver loaded as module.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|gendisk
op_star
op_star
id|gdp
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|acsi_timer
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
id|atari_stram_free
c_func
(paren
id|acsi_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;ad&quot;
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;acsi: cleanup_module failed&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|gdp
op_assign
op_amp
id|gendisk_head
suffix:semicolon
op_star
id|gdp
suffix:semicolon
id|gdp
op_assign
op_amp
(paren
(paren
op_star
id|gdp
)paren
op_member_access_from_pointer
id|next
)paren
)paren
r_if
c_cond
(paren
op_star
id|gdp
op_eq
op_amp
id|acsi_gendisk
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|gdp
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;acsi: entry in disk chain missing!&bslash;n&quot;
)paren
suffix:semicolon
r_else
op_star
id|gdp
op_assign
(paren
op_star
id|gdp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|DEVICE_BUSY
mdefine_line|#define DEVICE_BUSY busy[device]
DECL|macro|USAGE
mdefine_line|#define USAGE access_count[device]
DECL|macro|GENDISK_STRUCT
mdefine_line|#define GENDISK_STRUCT acsi_gendisk
multiline_comment|/*&n; * This routine is called to flush all partitions and partition tables&n; * for a changed scsi disk, and then re-read the new partition table.&n; * If we are revalidating a disk because of a media change, then we&n; * enter with usage == 0.  If we are using an ioctl, we automatically have&n; * usage == 1 (we need an open channel to use an ioctl :-), so this&n; * is our limit.&n; *&n; * Changes by Martin Rogge, 9th Aug 1995: &n; * got cd-roms to work by calling acsi_devinit. There are only two problems:&n; * First, if there is no medium inserted, the status will remain &quot;changed&quot;.&n; * That is no problem at all, but our design of three-valued logic (medium&n; * changed, medium not changed, no medium inserted).&n; * Secondly the check could fail completely and the drive could deliver&n; * nonsensical data, which could mess up the acsi_info[] structure. In&n; * that case we try to make the entry safe.&n; *&n; */
DECL|function|revalidate_acsidisk
r_static
r_int
id|revalidate_acsidisk
c_func
(paren
r_int
id|dev
comma
r_int
id|maxusage
)paren
(brace
r_int
id|device
suffix:semicolon
r_struct
id|gendisk
op_star
id|gdev
suffix:semicolon
r_int
id|max_p
comma
id|start
comma
id|i
suffix:semicolon
r_struct
id|acsi_info_struct
op_star
id|aip
suffix:semicolon
id|device
op_assign
id|DEVICE_NR
c_func
(paren
id|MINOR
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|aip
op_assign
op_amp
id|acsi_info
(braket
id|device
)braket
suffix:semicolon
id|gdev
op_assign
op_amp
id|GENDISK_STRUCT
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEVICE_BUSY
op_logical_or
id|USAGE
OG
id|maxusage
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
suffix:semicolon
id|DEVICE_BUSY
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|max_p
op_assign
id|gdev-&gt;max_p
suffix:semicolon
id|start
op_assign
id|device
op_lshift
id|gdev-&gt;minor_shift
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|max_p
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|gdev-&gt;part
(braket
id|start
op_plus
id|i
)braket
dot
id|nr_sects
op_ne
l_int|0
)paren
(brace
id|kdev_t
id|devp
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|start
op_plus
id|i
)paren
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|get_super
c_func
(paren
id|devp
)paren
suffix:semicolon
id|fsync_dev
c_func
(paren
id|devp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
)paren
id|invalidate_inodes
c_func
(paren
id|sb
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|devp
)paren
suffix:semicolon
id|gdev-&gt;part
(braket
id|start
op_plus
id|i
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
)brace
id|gdev-&gt;part
(braket
id|start
op_plus
id|i
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
)brace
suffix:semicolon
id|stdma_lock
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acsi_devinit
c_func
(paren
id|aip
)paren
op_ne
id|DEV_SUPPORTED
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ACSI: revalidate failed for target %d lun %d&bslash;n&quot;
comma
id|aip-&gt;target
comma
id|aip-&gt;lun
)paren
suffix:semicolon
id|aip-&gt;size
op_assign
l_int|0
suffix:semicolon
id|aip-&gt;read_only
op_assign
l_int|1
suffix:semicolon
id|aip-&gt;removable
op_assign
l_int|1
suffix:semicolon
id|aip-&gt;changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* next acsi_open will try again... */
)brace
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
id|grok_partitions
c_func
(paren
id|gdev
comma
id|device
comma
(paren
id|aip-&gt;type
op_eq
id|HARDDISK
)paren
ques
c_cond
l_int|1
op_lshift
l_int|4
suffix:colon
l_int|1
comma
id|aip-&gt;size
)paren
suffix:semicolon
id|DEVICE_BUSY
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|busy_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|acsi_revalidate
r_static
r_int
id|acsi_revalidate
(paren
id|dev_t
id|dev
)paren
(brace
r_return
id|revalidate_acsidisk
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
eof
