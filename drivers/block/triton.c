multiline_comment|/*&n; *  linux/drivers/block/triton.c&t;Version 2.10  April 22, 1997&n; *&n; *  Copyright (c) 1995-1997  Mark Lord&n; *  May be copied or modified under the terms of the GNU General Public License&n; */
multiline_comment|/*&n; * This module provides support for the bus-master IDE DMA function&n; * of the Intel PCI Triton chipset families, which use the PIIX (i82371FB,&n; * for the 430 FX chipset), the PIIX3 (i82371SB for the 430 HX/VX and &n; * 440 chipsets), and the PIIX4 (i82371AB for the 430 TX chipset).&n; *&n; * &quot;PIIX&quot; stands for &quot;PCI ISA IDE Xcellerator&quot;.&n; *&n; * Pretty much the same code could work for other IDE PCI bus-mastering chipsets.&n; * Look for DMA support for this someday in the not too distant future.&n; *&n; * DMA is supported for all IDE devices (disk drives, cdroms, tapes, floppies).&n; *&n; * Up to four drives may be enabled for DMA, and the PIIX* chips&n; * will arbitrate the PCI bus among them.  Note that the PIIX/PIIX3&n; * provides a single &quot;line buffer&quot; for the BM IDE function, so performance of&n; * multiple (two) drives doing DMA simultaneously will suffer somewhat,&n; * as they contest for that resource bottleneck.  This is handled transparently&n; * inside the PIIX/PIIX3.  The PIIX4 does not have this problem.&n; *&n; * By default, DMA support is prepared for use, but is currently enabled only&n; * for drives which support DMA mode2 (multi/single word), or which are&n; * recognized as &quot;good&quot; (see table below).  Drives with only mode0 or mode1&n; * (multi/single word) DMA should also work with this chipset/driver (eg. MC2112A)&n; * but are not enabled by default.  Use &quot;hdparm -i&quot; to view modes supported&n; * by a given drive.&n; *&n; * The hdparm-2.4 (or later) utility can be used for manually enabling/disabling&n; * DMA support, but must be (re-)compiled against this kernel version or later.&n; *&n; * To enable DMA, use &quot;hdparm -d1 /dev/hd?&quot; on a per-drive basis after booting.&n; * If problems arise, ide.c will disable DMA operation after a few retries.&n; * This error recovery mechanism works and has been extremely well exercised.&n; *&n; * IDE drives, depending on their vintage, may support several different modes&n; * of DMA operation.  The boot-time modes are indicated with a &quot;*&quot; in&n; * the &quot;hdparm -i&quot; listing, and can be changed with *knowledgeable* use of&n; * the &quot;hdparm -X&quot; feature.  There is seldom a need to do this, as drives&n; * normally power-up with their &quot;best&quot; PIO/DMA modes enabled.&n; *&n; * Testing has been done with a rather extensive number of drives,&n; * with Quantum &amp; Western Digital models generally outperforming the pack,&n; * and Fujitsu &amp; Conner (and some Seagate which are really Conner) drives&n; * showing more lackluster throughput.&n; *&n; * Keep an eye on /var/adm/messages for &quot;DMA disabled&quot; messages.&n; *&n; * Some people have reported trouble with Intel Zappa motherboards.&n; * This can be fixed by upgrading the AMI BIOS to version 1.00.04.BS0,&n; * available from ftp://ftp.intel.com/pub/bios/10004bs0.exe&n; * (thanks to Glen Morrell &lt;glen@spin.Stanford.edu&gt; for researching this).&n; *&n; * Thanks to &quot;Christopher J. Reimer&quot; &lt;reimer@doe.carleton.ca&gt; for fixing the&n; * problem with some (all?) ACER motherboards/BIOSs.&n; *&n; * Thanks to &quot;Benoit Poulot-Cazajous&quot; &lt;poulot@chorus.fr&gt; for testing&n; * &quot;TX&quot; chipset compatibility and for providing patches for the &quot;TX&quot; chipset.&n; *&n; * And, yes, Intel Zappa boards really *do* use both PIIX IDE ports.&n; */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &quot;ide.h&quot;
macro_line|#include &quot;ide_modes.h&quot;
DECL|macro|DISPLAY_PIIX_TIMINGS
mdefine_line|#define DISPLAY_PIIX_TIMINGS&t;/* define this to display timings */
multiline_comment|/*&n; * good_dma_drives() lists the model names (from &quot;hdparm -i&quot;)&n; * of drives which do not support mode2 DMA but which are&n; * known to work fine with this interface under Linux.&n; */
DECL|variable|good_dma_drives
r_const
r_char
op_star
id|good_dma_drives
(braket
)braket
op_assign
(brace
l_string|&quot;Micropolis 2112A&quot;
comma
l_string|&quot;CONNER CTMA 4000&quot;
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; * Our Physical Region Descriptor (PRD) table should be large enough&n; * to handle the biggest I/O request we are likely to see.  Since requests&n; * can have no more than 256 sectors, and since the typical blocksize is&n; * two sectors, we could get by with a limit of 128 entries here for the&n; * usual worst case.  Most requests seem to include some contiguous blocks,&n; * further reducing the number of table entries required.&n; *&n; * The driver reverts to PIO mode for individual requests that exceed&n; * this limit (possible with 512 byte blocksizes, eg. MSDOS f/s), so handling&n; * 100% of all crazy scenarios here is not necessary.&n; *&n; * As it turns out though, we must allocate a full 4KB page for this,&n; * so the two PRD tables (ide0 &amp; ide1) will each get half of that,&n; * allowing each to have about 256 entries (8 bytes each) from this.&n; */
DECL|macro|PRD_BYTES
mdefine_line|#define PRD_BYTES&t;8
DECL|macro|PRD_ENTRIES
mdefine_line|#define PRD_ENTRIES&t;(PAGE_SIZE / (2 * PRD_BYTES))
multiline_comment|/*&n; * Interface to access piix registers&n; */
DECL|variable|piix_key
r_static
r_int
r_int
id|piix_key
suffix:semicolon
DECL|macro|PIIX_FLAGS_FAST_PIO
mdefine_line|#define PIIX_FLAGS_FAST_PIO&t;1
DECL|macro|PIIX_FLAGS_USE_IORDY
mdefine_line|#define PIIX_FLAGS_USE_IORDY&t;2
DECL|macro|PIIX_FLAGS_PREFETCH
mdefine_line|#define PIIX_FLAGS_PREFETCH&t;4
DECL|macro|PIIX_FLAGS_FAST_DMA
mdefine_line|#define PIIX_FLAGS_FAST_DMA&t;8
DECL|union|chip_en_reg_u
r_union
id|chip_en_reg_u
(brace
r_struct
(brace
DECL|member|d0_flags
r_int
id|d0_flags
suffix:colon
l_int|4
suffix:semicolon
DECL|member|d1_flags
r_int
id|d1_flags
suffix:colon
l_int|4
suffix:semicolon
DECL|member|recovery
r_int
id|recovery
suffix:colon
l_int|2
suffix:semicolon
DECL|member|reserved
r_int
id|reserved
suffix:colon
l_int|2
suffix:semicolon
DECL|member|sample
r_int
id|sample
suffix:colon
l_int|2
suffix:semicolon
DECL|member|sidetim_enabled
r_int
id|sidetim_enabled
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ports_enabled
r_int
id|ports_enabled
suffix:colon
l_int|1
suffix:semicolon
DECL|member|piix_s
)brace
id|piix_s
suffix:semicolon
r_struct
(brace
DECL|member|sec_en
r_int
id|sec_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pri_en
r_int
id|pri_en
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reserved
r_int
id|reserved
suffix:colon
l_int|14
suffix:semicolon
DECL|member|via_s
)brace
id|via_s
suffix:semicolon
)brace
suffix:semicolon
DECL|typedef|piix_timing_t
r_typedef
r_union
id|chip_en_reg_u
id|piix_timing_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|pri_recovery
r_int
id|pri_recovery
suffix:colon
l_int|2
suffix:semicolon
DECL|member|pri_sample
r_int
id|pri_sample
suffix:colon
l_int|2
suffix:semicolon
DECL|member|sec_recovery
r_int
id|sec_recovery
suffix:colon
l_int|2
suffix:semicolon
DECL|member|sec_sample
r_int
id|sec_sample
suffix:colon
l_int|2
suffix:semicolon
DECL|typedef|piix_sidetim_t
)brace
id|piix_sidetim_t
suffix:semicolon
multiline_comment|/*&n; * We currently can handle only one PIIX chip here&n; */
DECL|variable|piix_pci_bus
r_static
id|piix_pci_bus
op_assign
l_int|0
suffix:semicolon
DECL|variable|piix_pci_fn
r_static
id|piix_pci_fn
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|config_drive_for_dma
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * dma_intr() is the handler for disk read/write DMA interrupts&n; */
DECL|function|dma_intr
r_static
r_void
id|dma_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
comma
id|dma_stat
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
r_int
id|dma_base
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dma_base
suffix:semicolon
id|dma_stat
op_assign
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* get DMA status */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_amp
op_complement
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* stop DMA operation */
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* get drive status */
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|dma_stat
op_amp
l_int|7
)paren
op_eq
l_int|4
)paren
(brace
multiline_comment|/* verify good DMA status */
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|i
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: bad DMA status: 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|dma_stat
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;dma_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * build_dmatable() prepares a dma request.&n; * Returns 0 if all went okay, returns 1 otherwise.&n; */
DECL|function|build_dmatable
r_static
r_int
id|build_dmatable
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|rq-&gt;bh
suffix:semicolon
r_int
r_int
id|size
comma
id|addr
comma
op_star
id|table
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmatable
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * Determine addr and size of next buffer area.  We assume that&n;&t;&t; * individual virtual buffers are always composed linearly in&n;&t;&t; * physical memory.  For example, we assume that any 8kB buffer&n;&t;&t; * is always composed of two adjacent physical 4kB pages rather&n;&t;&t; * than two possibly non-adjacent physical 4kB pages.&n;&t;&t; */
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* paging requests have (rq-&gt;bh == NULL) */
id|addr
op_assign
id|virt_to_bus
(paren
id|rq-&gt;buffer
)paren
suffix:semicolon
id|size
op_assign
id|rq-&gt;nr_sectors
op_lshift
l_int|9
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* group sequential buffers into one large buffer */
id|addr
op_assign
id|virt_to_bus
(paren
id|bh-&gt;b_data
)paren
suffix:semicolon
id|size
op_assign
id|bh-&gt;b_size
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_reqnext
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_plus
id|size
)paren
op_ne
id|virt_to_bus
(paren
id|bh-&gt;b_data
)paren
)paren
r_break
suffix:semicolon
id|size
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Fill in the dma table, without crossing any 64kB boundaries.&n;&t;&t; * We assume 16-bit alignment of all blocks.&n;&t;&t; */
r_while
c_loop
(paren
id|size
)paren
(brace
r_if
c_cond
(paren
op_increment
id|count
op_ge
id|PRD_ENTRIES
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DMA table too small&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* revert to PIO for this request */
)brace
r_else
(brace
r_int
r_int
id|bcount
op_assign
l_int|0x10000
op_minus
(paren
id|addr
op_amp
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcount
OG
id|size
)paren
id|bcount
op_assign
id|size
suffix:semicolon
op_star
id|table
op_increment
op_assign
id|addr
suffix:semicolon
op_star
id|table
op_increment
op_assign
id|bcount
op_amp
l_int|0xffff
suffix:semicolon
id|addr
op_add_assign
id|bcount
suffix:semicolon
id|size
op_sub_assign
id|bcount
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
op_star
op_decrement
id|table
op_or_assign
l_int|0x80000000
suffix:semicolon
multiline_comment|/* set End-Of-Table (EOT) bit */
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: empty DMA table?&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* let the PIO routines handle this weirdness */
)brace
multiline_comment|/*&n; * piix_dmaproc() initiates/aborts DMA read/write operations on a drive.&n; *&n; * The caller is assumed to have selected the drive and programmed the drive&squot;s&n; * sector address using CHS or LBA.  All that remains is to prepare for DMA&n; * and then issue the actual read/write DMA/PIO command to the drive.&n; *&n; * For ATAPI devices, we just prepare for DMA and return. The caller should&n; * then issue the packet command to the drive and call us again with&n; * ide_dma_begin afterwards.&n; *&n; * Returns 0 if all went well.&n; * Returns 1 if DMA read/write could not be started, in which case&n; * the caller should revert to PIO for the current request.&n; */
DECL|function|piix_dmaproc
r_static
r_int
id|piix_dmaproc
(paren
id|ide_dma_action_t
id|func
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
r_int
id|dma_base
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dma_base
suffix:semicolon
r_int
r_int
id|reading
op_assign
(paren
l_int|1
op_lshift
l_int|3
)paren
suffix:semicolon
id|piix_timing_t
id|timing
suffix:semicolon
r_int
r_int
id|reg
suffix:semicolon
id|byte
id|dflags
suffix:semicolon
r_switch
c_cond
(paren
id|func
)paren
(brace
r_case
id|ide_dma_off
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: DMA disabled&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_case
id|ide_dma_on
suffix:colon
id|drive-&gt;using_dma
op_assign
(paren
id|func
op_eq
id|ide_dma_on
)paren
suffix:semicolon
id|reg
op_assign
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
l_int|0x170
)paren
ques
c_cond
l_int|0x42
suffix:colon
l_int|0x40
suffix:semicolon
r_if
c_cond
(paren
id|pcibios_read_config_word
c_func
(paren
id|piix_pci_bus
comma
id|piix_pci_fn
comma
id|reg
comma
(paren
r_int
op_star
)paren
op_amp
id|timing
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: pcibios read failed&bslash;n&quot;
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|dflags
op_assign
id|drive-&gt;select.b.unit
ques
c_cond
id|timing.piix_s.d1_flags
suffix:colon
id|timing.piix_s.d0_flags
suffix:semicolon
r_if
c_cond
(paren
id|dflags
op_amp
id|PIIX_FLAGS_FAST_PIO
)paren
(brace
r_if
c_cond
(paren
id|func
op_eq
id|ide_dma_on
op_logical_and
id|drive-&gt;media
op_eq
id|ide_disk
)paren
id|dflags
op_or_assign
id|PIIX_FLAGS_FAST_DMA
suffix:semicolon
r_else
id|dflags
op_and_assign
op_complement
id|PIIX_FLAGS_FAST_DMA
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;select.b.unit
op_eq
l_int|0
)paren
id|timing.piix_s.d0_flags
op_assign
id|dflags
suffix:semicolon
r_else
id|timing.piix_s.d1_flags
op_assign
id|dflags
suffix:semicolon
r_if
c_cond
(paren
id|pcibios_write_config_word
c_func
(paren
id|piix_pci_bus
comma
id|piix_pci_fn
comma
id|reg
comma
op_star
(paren
r_int
op_star
)paren
op_amp
id|timing
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: pcibios write failed&bslash;n&quot;
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|ide_dma_abort
suffix:colon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_amp
op_complement
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* stop DMA */
r_return
l_int|0
suffix:semicolon
r_case
id|ide_dma_check
suffix:colon
r_return
id|config_drive_for_dma
(paren
id|drive
)paren
suffix:semicolon
r_case
id|ide_dma_write
suffix:colon
id|reading
op_assign
l_int|0
suffix:semicolon
r_case
id|ide_dma_read
suffix:colon
r_break
suffix:semicolon
r_case
id|ide_dma_status_bad
suffix:colon
r_return
(paren
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_amp
l_int|7
)paren
op_ne
l_int|4
)paren
suffix:semicolon
multiline_comment|/* verify good DMA status */
r_case
id|ide_dma_transferred
suffix:colon
macro_line|#if 0
r_return
(paren
id|number
id|of
id|bytes
id|actually
id|transferred
)paren
suffix:semicolon
macro_line|#else
r_return
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_case
id|ide_dma_begin
suffix:colon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_or
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* begin DMA */
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;piix_dmaproc: unsupported func: %d&bslash;n&quot;
comma
id|func
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|build_dmatable
(paren
id|drive
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|outl
c_func
(paren
id|virt_to_bus
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmatable
)paren
comma
id|dma_base
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* PRD table */
id|outb
c_func
(paren
id|reading
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* specify r/w */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_or
l_int|0x06
comma
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* clear status bits */
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_return
l_int|0
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|dma_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
multiline_comment|/* issue cmd to drive */
id|OUT_BYTE
c_func
(paren
id|reading
ques
c_cond
id|WIN_READDMA
suffix:colon
id|WIN_WRITEDMA
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_or
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* begin DMA */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|config_drive_for_dma
r_static
r_int
id|config_drive_for_dma
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_const
r_char
op_star
op_star
id|list
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_if
c_cond
(paren
id|id
op_logical_and
(paren
id|id-&gt;capability
op_amp
l_int|1
)paren
)paren
(brace
multiline_comment|/* Enable DMA on any drive that supports mode2 (multi/single word) DMA */
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
r_if
c_cond
(paren
(paren
id|id-&gt;dma_mword
op_amp
l_int|0x404
)paren
op_eq
l_int|0x404
op_logical_or
(paren
id|id-&gt;dma_1word
op_amp
l_int|0x404
)paren
op_eq
l_int|0x404
)paren
r_return
id|piix_dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* Consult the list of known &quot;good&quot; drives */
id|list
op_assign
id|good_dma_drives
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|list
op_increment
comma
id|id-&gt;model
)paren
)paren
r_return
id|piix_dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
)brace
)brace
r_return
id|piix_dmaproc
c_func
(paren
id|ide_dma_off
comma
id|drive
)paren
suffix:semicolon
)brace
macro_line|#ifdef DISPLAY_PIIX_TIMINGS
multiline_comment|/*&n; * print_piix_drive_flags() displays the currently programmed options&n; * in the PIIX/PIIX3/PIIX4 for a given drive.&n; */
DECL|function|print_piix_drive_flags
r_static
r_void
id|print_piix_drive_flags
(paren
r_const
r_char
op_star
id|unit
comma
id|byte
id|dflags
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;         %s &quot;
comma
id|unit
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fastDMA=%s&quot;
comma
(paren
id|dflags
op_amp
id|PIIX_FLAGS_FAST_PIO
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; PreFetch=%s&quot;
comma
(paren
id|dflags
op_amp
id|PIIX_FLAGS_PREFETCH
)paren
ques
c_cond
l_string|&quot;on &quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; IORDY=%s&quot;
comma
(paren
id|dflags
op_amp
id|PIIX_FLAGS_USE_IORDY
)paren
ques
c_cond
l_string|&quot;on &quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; fastPIO=%s&bslash;n&quot;
comma
(paren
(paren
id|dflags
op_amp
(paren
id|PIIX_FLAGS_FAST_PIO
op_or
id|PIIX_FLAGS_FAST_DMA
)paren
)paren
op_eq
id|PIIX_FLAGS_FAST_PIO
)paren
ques
c_cond
l_string|&quot;on &quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* DISPLAY_PIIX_TIMINGS */
DECL|function|init_piix_dma
r_static
r_void
id|init_piix_dma
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_int
r_int
id|base
)paren
(brace
r_static
r_int
r_int
id|dmatable
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    %s: BM-DMA at 0x%04x-0x%04x&quot;
comma
id|hwif-&gt;name
comma
id|base
comma
id|base
op_plus
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|base
comma
l_int|8
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; -- ERROR, PORTS ALREADY IN USE&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|request_region
c_func
(paren
id|base
comma
l_int|8
comma
l_string|&quot;IDE DMA&quot;
)paren
suffix:semicolon
id|hwif-&gt;dma_base
op_assign
id|base
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmatable
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The BM-DMA uses a full 32-bits, so we can&n;&t;&t;&t; * safely use __get_free_page() here instead&n;&t;&t;&t; * of __get_dma_pages() -- no ISA limitations.&n;&t;&t;&t; */
id|dmatable
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmatable
)paren
(brace
id|hwif-&gt;dmatable
op_assign
(paren
r_int
r_int
op_star
)paren
id|dmatable
suffix:semicolon
id|dmatable
op_add_assign
(paren
id|PRD_ENTRIES
op_star
id|PRD_BYTES
)paren
suffix:semicolon
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hwif-&gt;dmatable
)paren
comma
id|base
op_plus
l_int|4
)paren
suffix:semicolon
id|hwif-&gt;dmaproc
op_assign
op_amp
id|piix_dmaproc
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* The next two functions were stolen from cmd640.c, with&n;   a few modifications  */
DECL|function|put_piix_reg
r_static
r_void
id|put_piix_reg
(paren
r_int
r_int
id|reg
comma
r_int
id|val
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outl_p
c_func
(paren
(paren
id|reg
op_amp
l_int|0xfc
)paren
op_or
id|piix_key
comma
l_int|0xcf8
)paren
suffix:semicolon
id|outl_p
c_func
(paren
id|val
comma
(paren
id|reg
op_amp
l_int|3
)paren
op_or
l_int|0xcfc
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|get_piix_reg
r_static
r_int
id|get_piix_reg
(paren
r_int
r_int
id|reg
)paren
(brace
r_int
id|b
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outl_p
c_func
(paren
(paren
id|reg
op_amp
l_int|0xfc
)paren
op_or
id|piix_key
comma
l_int|0xcf8
)paren
suffix:semicolon
id|b
op_assign
id|inl_p
c_func
(paren
(paren
id|reg
op_amp
l_int|3
)paren
op_or
l_int|0xcfc
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
multiline_comment|/*&n; * Search for an (apparently) unused block of I/O space&n; * of &quot;size&quot; bytes in length.&n; */
DECL|function|find_free_region
r_static
r_int
id|find_free_region
(paren
r_int
r_int
id|size
)paren
(brace
r_int
r_int
id|i
comma
id|base
op_assign
l_int|0xe800
suffix:semicolon
r_for
c_loop
(paren
id|base
op_assign
l_int|0xe800
suffix:semicolon
id|base
OG
l_int|0
suffix:semicolon
id|base
op_sub_assign
l_int|0x800
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|check_region
c_func
(paren
id|base
comma
id|size
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|base
op_plus
id|i
)paren
op_ne
l_int|0xff
)paren
r_goto
id|next
suffix:semicolon
)brace
r_return
id|base
suffix:semicolon
multiline_comment|/* success */
)brace
id|next
suffix:colon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* failure */
)brace
multiline_comment|/*&n; * ide_init_triton() prepares the IDE driver for DMA operation.&n; * This routine is called once, from ide.c during driver initialization,&n; * for each triton chipset which is found (unlikely to be more than one).&n; */
DECL|function|ide_init_triton
r_void
id|ide_init_triton
(paren
id|byte
id|bus
comma
id|byte
id|fn
)paren
(brace
r_int
id|rc
op_assign
l_int|0
comma
id|h
suffix:semicolon
r_int
id|dma_enabled
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|pcicmd
comma
id|devid
suffix:semicolon
r_int
r_int
id|bmiba
suffix:semicolon
r_const
r_char
op_star
id|chipset
op_assign
l_string|&quot;ide&quot;
suffix:semicolon
id|piix_timing_t
id|timings
(braket
l_int|2
)braket
suffix:semicolon
id|piix_pci_bus
op_assign
id|bus
suffix:semicolon
id|piix_pci_fn
op_assign
id|fn
suffix:semicolon
r_if
c_cond
(paren
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x02
comma
op_amp
id|devid
)paren
)paren
r_goto
id|quit
suffix:semicolon
r_if
c_cond
(paren
id|devid
op_eq
id|PCI_DEVICE_ID_INTEL_82371AB
)paren
id|chipset
op_assign
l_string|&quot;PIIX4&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|devid
op_eq
id|PCI_DEVICE_ID_INTEL_82371SB_1
)paren
id|chipset
op_assign
l_string|&quot;PIIX3&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|devid
op_eq
id|PCI_DEVICE_ID_INTEL_82371_1
)paren
id|chipset
op_assign
l_string|&quot;PIIX&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|devid
op_eq
id|PCI_DEVICE_ID_VIA_82C586_1
)paren
id|chipset
op_assign
l_string|&quot;VP1&quot;
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Unknown PCI IDE interface 0x%x&bslash;n&quot;
comma
id|devid
)paren
suffix:semicolon
r_goto
id|quit
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: bus-master IDE device on PCI bus %d function %d&bslash;n&quot;
comma
id|chipset
comma
id|bus
comma
id|fn
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * See if IDE ports are enabled&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x04
comma
op_amp
id|pcicmd
)paren
)paren
)paren
r_goto
id|quit
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcicmd
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: IDE ports are not enabled (BIOS)&bslash;n&quot;
comma
id|chipset
)paren
suffix:semicolon
r_goto
id|quit
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devid
op_eq
id|PCI_DEVICE_ID_VIA_82C586_1
)paren
(brace
multiline_comment|/* pri and sec channel enables are in port 0x40 */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x40
comma
(paren
r_int
op_star
)paren
op_amp
id|timings
(braket
l_int|0
)braket
)paren
)paren
)paren
r_goto
id|quit
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|timings
(braket
l_int|0
)braket
dot
id|via_s.pri_en
op_logical_and
(paren
op_logical_neg
id|timings
(braket
l_int|0
)braket
dot
id|via_s.sec_en
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: neither IDE port is enabled&bslash;n&quot;
comma
id|chipset
)paren
suffix:semicolon
r_goto
id|quit
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* INTEL piix */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x40
comma
(paren
r_int
op_star
)paren
op_amp
id|timings
(braket
l_int|0
)braket
)paren
)paren
)paren
r_goto
id|quit
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x42
comma
(paren
r_int
op_star
)paren
op_amp
id|timings
(braket
l_int|1
)braket
)paren
)paren
)paren
r_goto
id|quit
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|timings
(braket
l_int|0
)braket
dot
id|piix_s.ports_enabled
)paren
op_logical_and
(paren
op_logical_neg
id|timings
(braket
l_int|1
)braket
dot
id|piix_s.ports_enabled
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: neither IDE port is enabled&bslash;n&quot;
comma
id|chipset
)paren
suffix:semicolon
r_goto
id|quit
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * See if Bus-Mastered DMA is enabled&n;&t; */
r_if
c_cond
(paren
(paren
id|pcicmd
op_amp
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: bus-master DMA feature is not enabled (BIOS)&bslash;n&quot;
comma
id|chipset
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Get the bmiba base address&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x20
comma
op_amp
id|bmiba
)paren
)paren
)paren
r_goto
id|quit
suffix:semicolon
id|bmiba
op_and_assign
l_int|0xfff0
suffix:semicolon
multiline_comment|/* extract port base address */
r_if
c_cond
(paren
id|bmiba
)paren
(brace
id|dma_enabled
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|base
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: bus-master base address is invalid (0x%04x, BIOS problem)&bslash;n&quot;
comma
id|chipset
comma
id|bmiba
)paren
suffix:semicolon
id|base
op_assign
id|find_free_region
c_func
(paren
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: bypassing BIOS; setting bus-master base address to 0x%04x&bslash;n&quot;
comma
id|chipset
comma
id|base
)paren
suffix:semicolon
id|piix_key
op_assign
l_int|0x80000000
op_plus
(paren
id|fn
op_star
l_int|0x100
)paren
suffix:semicolon
id|put_piix_reg
c_func
(paren
l_int|0x04
comma
id|get_piix_reg
c_func
(paren
l_int|0x04
)paren
op_amp
op_complement
l_int|5
)paren
suffix:semicolon
id|put_piix_reg
c_func
(paren
l_int|0x20
comma
(paren
id|get_piix_reg
c_func
(paren
l_int|0x20
)paren
op_amp
l_int|0xFFFF000F
)paren
op_or
id|base
op_or
l_int|1
)paren
suffix:semicolon
id|put_piix_reg
c_func
(paren
l_int|0x04
comma
id|get_piix_reg
c_func
(paren
l_int|0x04
)paren
op_or
l_int|5
)paren
suffix:semicolon
id|bmiba
op_assign
id|get_piix_reg
c_func
(paren
l_int|0x20
)paren
op_amp
l_int|0x0000FFF0
suffix:semicolon
r_if
c_cond
(paren
id|bmiba
op_eq
id|base
op_logical_and
(paren
id|get_piix_reg
c_func
(paren
l_int|0x04
)paren
op_amp
l_int|5
)paren
op_eq
l_int|5
)paren
id|dma_enabled
op_assign
l_int|1
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%s: operation failed&bslash;n&quot;
comma
id|chipset
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dma_enabled
)paren
id|printk
c_func
(paren
l_string|&quot;%s: DMA is disabled (BIOS)&bslash;n&quot;
comma
id|chipset
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Save the dma_base port addr for each interface&n;&t; */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
r_int
r_int
id|pri_sec
suffix:semicolon
id|piix_timing_t
id|timing
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
(brace
r_case
l_int|0x1f0
suffix:colon
id|pri_sec
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x170
suffix:colon
id|pri_sec
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devid
op_eq
id|PCI_DEVICE_ID_VIA_82C586_1
)paren
(brace
id|timing
op_assign
id|timings
(braket
l_int|0
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|h
)paren
(brace
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|timing.piix_s.ports_enabled
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;port 0 DMA not enabled&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|timing.piix_s.sidetim_enabled
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;port 1 DMA not enabled&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|hwif-&gt;chipset
op_assign
id|ide_via
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* PIIX */
id|timing
op_assign
id|timings
(braket
id|pri_sec
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|timing.piix_s.ports_enabled
)paren
multiline_comment|/* interface disabled? */
r_continue
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|ide_triton
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma_enabled
)paren
id|init_piix_dma
c_func
(paren
id|hwif
comma
id|bmiba
op_plus
(paren
id|pri_sec
ques
c_cond
l_int|8
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#ifdef DISPLAY_PIIX_TIMINGS
multiline_comment|/*&n;&t;&t; * Display drive timings/modes&n;&t;&t; */
(brace
r_const
r_char
op_star
id|slave
suffix:semicolon
id|piix_sidetim_t
id|sidetim
suffix:semicolon
id|byte
id|sample
op_assign
l_int|5
op_minus
id|timing.piix_s.sample
suffix:semicolon
id|byte
id|recovery
op_assign
l_int|4
op_minus
id|timing.piix_s.recovery
suffix:semicolon
r_int
r_int
id|drvtim
suffix:semicolon
r_if
c_cond
(paren
id|devid
op_eq
id|PCI_DEVICE_ID_VIA_82C586_1
)paren
(brace
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x48
comma
op_amp
id|drvtim
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pri_sec
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;    %s master: active_pulse_CLKs=%d, recovery_CLKs=%d&bslash;n&quot;
comma
id|hwif-&gt;name
comma
l_int|1
op_plus
(paren
id|drvtim
op_rshift
l_int|28
)paren
comma
l_int|1
op_plus
(paren
(paren
id|drvtim
op_amp
l_int|0x0f000000
)paren
op_rshift
l_int|24
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    %s slave: active_pulse_CLKs=%d, recovery_CLKs=%d&bslash;n&quot;
comma
id|hwif-&gt;name
comma
l_int|1
op_plus
(paren
(paren
id|drvtim
op_amp
l_int|0xf00000
)paren
op_rshift
l_int|20
)paren
comma
l_int|1
op_plus
(paren
(paren
id|drvtim
op_amp
l_int|0x0f0000
)paren
op_rshift
l_int|16
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;    %s master: active_pulse_CLKs=%d, recovery_CLKs=%d&bslash;n&quot;
comma
id|hwif-&gt;name
comma
l_int|1
op_plus
(paren
(paren
id|drvtim
op_amp
l_int|0xf000
)paren
op_rshift
l_int|12
)paren
comma
l_int|1
op_plus
(paren
(paren
id|drvtim
op_amp
l_int|0x0f00
)paren
op_rshift
l_int|8
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    %s slave: active_pulse_CLKs=%d, recovery_CLKs=%d&bslash;n&quot;
comma
id|hwif-&gt;name
comma
l_int|1
op_plus
(paren
(paren
id|drvtim
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
comma
l_int|1
op_plus
(paren
id|drvtim
op_amp
l_int|0x0f
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|devid
op_eq
id|PCI_DEVICE_ID_INTEL_82371SB_1
op_logical_or
id|devid
op_eq
id|PCI_DEVICE_ID_INTEL_82371AB
)paren
op_logical_and
id|timing.piix_s.sidetim_enabled
op_logical_and
op_logical_neg
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x44
comma
(paren
id|byte
op_star
)paren
op_amp
id|sidetim
)paren
)paren
id|slave
op_assign
l_string|&quot;&quot;
suffix:semicolon
multiline_comment|/* PIIX3 and later */
r_else
id|slave
op_assign
l_string|&quot;/slave&quot;
suffix:semicolon
multiline_comment|/* PIIX, or PIIX3 in compatibility mode */
id|printk
c_func
(paren
l_string|&quot;    %s master%s: sample_CLKs=%d, recovery_CLKs=%d&bslash;n&quot;
comma
id|hwif-&gt;name
comma
id|slave
comma
id|sample
comma
id|recovery
)paren
suffix:semicolon
id|print_piix_drive_flags
(paren
l_string|&quot;master:&quot;
comma
id|timing.piix_s.d0_flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|slave
)paren
(brace
r_if
c_cond
(paren
id|pri_sec
op_eq
l_int|0
)paren
(brace
id|sample
op_assign
l_int|5
op_minus
id|sidetim.pri_sample
suffix:semicolon
id|recovery
op_assign
l_int|4
op_minus
id|sidetim.pri_recovery
suffix:semicolon
)brace
r_else
(brace
id|sample
op_assign
l_int|5
op_minus
id|sidetim.sec_sample
suffix:semicolon
id|recovery
op_assign
l_int|4
op_minus
id|sidetim.sec_recovery
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;         slave : sample_CLKs=%d, recovery_CLKs=%d&bslash;n&quot;
comma
id|sample
comma
id|recovery
)paren
suffix:semicolon
)brace
id|print_piix_drive_flags
(paren
l_string|&quot;slave :&quot;
comma
id|timing.piix_s.d1_flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* DISPLAY_PIIX_TIMINGS */
)brace
id|quit
suffix:colon
r_if
c_cond
(paren
id|rc
)paren
id|printk
c_func
(paren
l_string|&quot;%s: pcibios access failed - %s&bslash;n&quot;
comma
id|chipset
comma
id|pcibios_strerror
c_func
(paren
id|rc
)paren
)paren
suffix:semicolon
)brace
eof
