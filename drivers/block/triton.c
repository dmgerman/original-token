multiline_comment|/*&n; *  linux/drivers/block/triton.c&t;Version 1.10  Apr 3, 1996&n; *&n; *  Copyright (c) 1995-1996  Mark Lord&n; *  May be copied or modified under the terms of the GNU General Public License&n; */
multiline_comment|/*&n; * This module provides support for the Bus Master IDE DMA function&n; * of the Intel PCI Triton chipset (82371FB).&n; *&n; * DMA is currently supported only for hard disk drives (not cdroms).&n; *&n; * Support for cdroms will likely be added at a later date,&n; * after broader experience has been obtained with hard disks.&n; *&n; * Up to four drives may be enabled for DMA, and the Triton chipset will&n; * (hopefully) arbitrate the PCI bus among them.  Note that the 82371FB chip&n; * provides a single &quot;line buffer&quot; for the BM IDE function, so performance of&n; * multiple (two) drives doing DMA simultaneously will suffer somewhat,&n; * as they contest for that resource bottleneck.  This is handled transparently&n; * inside the 82371FB chip.&n; *&n; * By default, DMA support is prepared for use, but is currently enabled only&n; * for drives which support multi-word DMA mode2 (mword2), or which are&n; * recognized as &quot;good&quot; (see table below).  Drives with only mode0 or mode1&n; * (single or multi) DMA should also work with this chipset/driver (eg. MC2112A)&n; * but are not enabled by default.  Use &quot;hdparm -i&quot; to view modes supported&n; * by a given drive.&n; *&n; * The hdparm-2.4 (or later) utility can be used for manually enabling/disabling&n; * DMA support, but must be (re-)compiled against this kernel version or later.&n; *&n; * To enable DMA, use &quot;hdparm -d1 /dev/hd?&quot; on a per-drive basis after booting.&n; * If problems arise, ide.c will disable DMA operation after a few retries.&n; * This error recovery mechanism works and has been extremely well exercised.&n; *&n; * IDE drives, depending on their vintage, may support several different modes&n; * of DMA operation.  The boot-time modes are indicated with a &quot;*&quot; in&n; * the &quot;hdparm -i&quot; listing, and can be changed with *knowledgeable* use of&n; * the &quot;hdparm -X&quot; feature.  There is seldom a need to do this, as drives&n; * normally power-up with their &quot;best&quot; PIO/DMA modes enabled.&n; *&n; * Testing was done with an ASUS P55TP4XE/100 system and the following drives:&n; *&n; *   Quantum Fireball 1080A (1Gig w/83kB buffer), DMA mode2, PIO mode4.&n; *&t;- DMA mode2 works well (7.4MB/sec), despite the tiny on-drive buffer.&n; *&t;- This drive also does PIO mode4, at about the same speed as DMA mode2.&n; *&t;  An awesome drive for the price!&n; *&n; *   Fujitsu M1606TA (1Gig w/256kB buffer), DMA mode2, PIO mode4.&n; *&t;- DMA mode2 gives horrible performance (1.6MB/sec), despite the good&n; *&t;  size of the on-drive buffer and a boasted 10ms average access time.&n; *&t;- PIO mode4 was better, but peaked at a mere 4.5MB/sec.&n; *&n; *   Micropolis MC2112A (1Gig w/508kB buffer), drive pre-dates EIDE and ATA2.&n; *&t;- DMA works fine (2.2MB/sec), probably due to the large on-drive buffer.&n; *&t;- This older drive can also be tweaked for fastPIO (3.7MB/sec) by using&n; *&t;  maximum clock settings (5,4) and setting all flags except prefetch.&n; *&n; *   Western Digital AC31000H (1Gig w/128kB buffer), DMA mode1, PIO mode3.&n; *&t;- DMA does not work reliably.  The drive appears to be somewhat tardy&n; *&t;  in deasserting DMARQ at the end of a sector.  This is evident in&n; *&t;  the observation that WRITEs work most of the time, depending on&n; *&t;  cache-buffer occupancy, but multi-sector reads seldom work.&n; *&n; * Testing was done with a Gigabyte GA-586 ATE system and the following drive:&n; * (Uwe Bonnes - bon@elektron.ikp.physik.th-darmstadt.de)&n; *&n; *   Western Digital AC31600H (1.6Gig w/128kB buffer), DMA mode2, PIO mode4.&n; *&t;- much better than its 1Gig cousin, this drive is reported to work&n; *&t;  very well with DMA (7.3MB/sec).&n; *&n; * Other drives:&n; *&n; *   Maxtor 7540AV (515Meg w/32kB buffer), DMA modes mword0/sword2, PIO mode3.&n; *&t;- a budget drive, with budget performance, around 3MB/sec.&n; *&n; *   Western Digital AC2850F (814Meg w/64kB buffer), DMA mode1, PIO mode3.&n; *&t;- another &quot;caviar&quot; drive, similar to the AC31000, except that this one&n; *&t;  worked with DMA in at least one system.  Throughput is about 3.8MB/sec&n; *&t;  for both DMA and PIO.&n; *&n; *   Conner CFS850A (812Meg w/64kB buffer), DMA mode2, PIO mode4.&n; *&t;- like most Conner models, this drive proves that even a fast interface&n; *&t;  cannot improve slow media.  Both DMA and PIO peak around 3.5MB/sec.&n; *&n; *   Maxtor 71260AT (1204Meg w/256kB buffer), DMA mword0/sword2, PIO mode3.&n; *&t;- works with DMA, on some systems (but not always on others, eg. Dell),&n; *&t;giving 3-4MB/sec performance, about the same as mode3.&n; *&n; * If you have any drive models to add, email your results to:  mlord@pobox.com&n; * Keep an eye on /var/adm/messages for &quot;DMA disabled&quot; messages.&n; *&n; * Some people have reported trouble with Intel Zappa motherboards.&n; * This can be fixed by upgrading the AMI BIOS to version 1.00.04.BS0,&n; * available from ftp://ftp.intel.com/pub/bios/10004bs0.exe&n; * (thanks to Glen Morrell &lt;glen@spin.Stanford.edu&gt; for researching this).&n; *&n; * And, yes, Intel Zappa boards really *do* use the Triton IDE ports.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &quot;ide.h&quot;
multiline_comment|/*&n; * good_dma_drives() lists the model names (from &quot;hdparm -i&quot;)&n; * of drives which do not support mword2 DMA but which are&n; * known to work fine with this interface under Linux.&n; */
DECL|variable|good_dma_drives
r_const
r_char
op_star
id|good_dma_drives
(braket
)braket
op_assign
(brace
l_string|&quot;Micropolis 2112A&quot;
comma
l_string|&quot;CONNER CTMA 4000&quot;
)brace
suffix:semicolon
multiline_comment|/*&n; * Our Physical Region Descriptor (PRD) table should be large enough&n; * to handle the biggest I/O request we are likely to see.  Since requests&n; * can have no more than 256 sectors, and since the typical blocksize is&n; * two sectors, we could get by with a limit of 128 entries here for the&n; * usual worst case.  Most requests seem to include some contiguous blocks,&n; * further reducing the number of table entries required.&n; *&n; * The driver reverts to PIO mode for individual requests that exceed&n; * this limit (possible with 512 byte blocksizes, eg. MSDOS f/s), so handling&n; * 100% of all crazy scenarios here is not necessary.&n; *&n; * As it turns out though, we must allocate a full 4KB page for this,&n; * so the two PRD tables (ide0 &amp; ide1) will each get half of that,&n; * allowing each to have about 256 entries (8 bytes each) from this.&n; */
DECL|macro|PRD_BYTES
mdefine_line|#define PRD_BYTES&t;8
DECL|macro|PRD_ENTRIES
mdefine_line|#define PRD_ENTRIES&t;(PAGE_SIZE / (2 * PRD_BYTES))
DECL|macro|DEFAULT_BMIBA
mdefine_line|#define DEFAULT_BMIBA&t;0xe800&t;/* in case BIOS did not init it */
multiline_comment|/*&n; * dma_intr() is the handler for disk read/write DMA interrupts&n; */
DECL|function|dma_intr
r_static
r_void
id|dma_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
comma
id|dma_stat
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
r_int
id|dma_base
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dma_base
suffix:semicolon
id|dma_stat
op_assign
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* get DMA status */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_amp
op_complement
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* stop DMA operation */
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* get drive status */
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|dma_stat
op_amp
l_int|7
)paren
op_eq
l_int|4
)paren
(brace
multiline_comment|/* verify good DMA status */
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|i
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: bad DMA status: 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|dma_stat
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;dma_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * build_dmatable() prepares a dma request.&n; * Returns 0 if all went okay, returns 1 otherwise.&n; */
DECL|function|build_dmatable
r_static
r_int
id|build_dmatable
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|rq-&gt;bh
suffix:semicolon
r_int
r_int
id|size
comma
id|addr
comma
op_star
id|table
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmatable
suffix:semicolon
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * Determine addr and size of next buffer area.  We assume that&n;&t;&t; * individual virtual buffers are always composed linearly in&n;&t;&t; * physical memory.  For example, we assume that any 8kB buffer&n;&t;&t; * is always composed of two adjacent physical 4kB pages rather&n;&t;&t; * than two possibly non-adjacent physical 4kB pages.&n;&t;&t; */
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* paging and tape requests have (rq-&gt;bh == NULL) */
id|addr
op_assign
id|virt_to_bus
(paren
id|rq-&gt;buffer
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDETAPE
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_tape
)paren
id|size
op_assign
id|drive-&gt;tape.pc-&gt;request_transfer
suffix:semicolon
r_else
macro_line|#endif /* CONFIG_BLK_DEV_IDETAPE */&t;
id|size
op_assign
id|rq-&gt;nr_sectors
op_lshift
l_int|9
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* group sequential buffers into one large buffer */
id|addr
op_assign
id|virt_to_bus
(paren
id|bh-&gt;b_data
)paren
suffix:semicolon
id|size
op_assign
id|bh-&gt;b_size
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_reqnext
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_plus
id|size
)paren
op_ne
id|virt_to_bus
(paren
id|bh-&gt;b_data
)paren
)paren
r_break
suffix:semicolon
id|size
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Fill in the dma table, without crossing any 64kB boundaries.&n;&t;&t; * We assume 16-bit alignment of all blocks.&n;&t;&t; */
r_while
c_loop
(paren
id|size
)paren
(brace
r_if
c_cond
(paren
op_increment
id|count
op_ge
id|PRD_ENTRIES
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DMA table too small&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* revert to PIO for this request */
)brace
r_else
(brace
r_int
r_int
id|bcount
op_assign
l_int|0x10000
op_minus
(paren
id|addr
op_amp
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcount
OG
id|size
)paren
id|bcount
op_assign
id|size
suffix:semicolon
op_star
id|table
op_increment
op_assign
id|addr
suffix:semicolon
op_star
id|table
op_increment
op_assign
id|bcount
suffix:semicolon
id|addr
op_add_assign
id|bcount
suffix:semicolon
id|size
op_sub_assign
id|bcount
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
op_star
op_decrement
id|table
op_or_assign
l_int|0x80000000
suffix:semicolon
multiline_comment|/* set End-Of-Table (EOT) bit */
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: empty DMA table?&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* let the PIO routines handle this weirdness */
)brace
DECL|function|config_drive_for_dma
r_static
r_int
id|config_drive_for_dma
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_const
r_char
op_star
op_star
id|list
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_if
c_cond
(paren
id|id
op_logical_and
(paren
id|id-&gt;capability
op_amp
l_int|1
)paren
)paren
(brace
multiline_comment|/* Enable DMA on any drive that supports mword2 DMA */
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
op_logical_and
(paren
id|id-&gt;dma_mword
op_amp
l_int|0x404
)paren
op_eq
l_int|0x404
)paren
(brace
id|drive-&gt;using_dma
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* DMA enabled */
)brace
multiline_comment|/* Consult the list of known &quot;good&quot; drives */
id|list
op_assign
id|good_dma_drives
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|list
op_increment
comma
id|id-&gt;model
)paren
)paren
(brace
id|drive-&gt;using_dma
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* DMA enabled */
)brace
)brace
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* DMA not enabled */
)brace
multiline_comment|/*&n; * triton_dmaproc() initiates/aborts DMA read/write operations on a drive.&n; *&n; * The caller is assumed to have selected the drive and programmed the drive&squot;s&n; * sector address using CHS or LBA.  All that remains is to prepare for DMA&n; * and then issue the actual read/write DMA/PIO command to the drive.&n; *&n; * For ATAPI devices, we just prepare for DMA and return. The caller should&n; * then issue the packet command to the drive and call us again with&n; * ide_dma_begin afterwards.&n; *&n; * Returns 0 if all went well.&n; * Returns 1 if DMA read/write could not be started, in which case&n; * the caller should revert to PIO for the current request.&n; */
DECL|function|triton_dmaproc
r_static
r_int
id|triton_dmaproc
(paren
id|ide_dma_action_t
id|func
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
r_int
id|dma_base
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dma_base
suffix:semicolon
r_int
r_int
id|reading
op_assign
(paren
l_int|1
op_lshift
l_int|3
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|func
)paren
(brace
r_case
id|ide_dma_abort
suffix:colon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_amp
op_complement
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* stop DMA */
r_return
l_int|0
suffix:semicolon
r_case
id|ide_dma_check
suffix:colon
r_return
id|config_drive_for_dma
(paren
id|drive
)paren
suffix:semicolon
r_case
id|ide_dma_write
suffix:colon
id|reading
op_assign
l_int|0
suffix:semicolon
r_case
id|ide_dma_read
suffix:colon
r_break
suffix:semicolon
r_case
id|ide_dma_status_bad
suffix:colon
r_return
(paren
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_amp
l_int|7
)paren
op_ne
l_int|4
)paren
suffix:semicolon
multiline_comment|/* verify good DMA status */
r_case
id|ide_dma_transferred
suffix:colon
macro_line|#if 0
r_return
(paren
id|number
id|of
id|bytes
id|actually
id|transferred
)paren
suffix:semicolon
macro_line|#else
r_return
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_case
id|ide_dma_begin
suffix:colon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_or
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* begin DMA */
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;triton_dmaproc: unsupported func: %d&bslash;n&quot;
comma
id|func
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|build_dmatable
(paren
id|drive
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|outl
c_func
(paren
id|virt_to_bus
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmatable
)paren
comma
id|dma_base
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* PRD table */
id|outb
c_func
(paren
id|reading
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* specify r/w */
id|outb
c_func
(paren
l_int|0x26
comma
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* clear status bits */
macro_line|#ifdef CONFIG_BLK_DEV_IDEATAPI
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEATAPI */&t;
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|dma_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
multiline_comment|/* issue cmd to drive */
id|OUT_BYTE
c_func
(paren
id|reading
ques
c_cond
id|WIN_READDMA
suffix:colon
id|WIN_WRITEDMA
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_or
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* begin DMA */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * print_triton_drive_flags() displays the currently programmed options&n; * in the 430FX (Triton) chipset for a given drive.&n; *&n; *&t;If fastDMA  is &quot;no&quot;, then slow ISA timings are used for DMA data xfers.&n; *&t;If fastPIO  is &quot;no&quot;, then slow ISA timings are used for PIO data xfers.&n; *&t;If IORDY    is &quot;no&quot;, then IORDY is assumed to always be asserted.&n; *&t;If PreFetch is &quot;no&quot;, then data pre-fetch/post are not used.&n; *&n; * When &quot;fastPIO&quot; and/or &quot;fastDMA&quot; are &quot;yes&quot;, then faster PCI timings and&n; * back-to-back 16-bit data transfers are enabled, using the sample_CLKs&n; * and recovery_CLKs (PCI clock cycles) timing parameters for that interface.&n; */
DECL|function|print_triton_drive_flags
r_static
r_void
id|print_triton_drive_flags
(paren
r_int
r_int
id|unit
comma
id|byte
id|flags
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;         %s &quot;
comma
id|unit
ques
c_cond
l_string|&quot;slave :&quot;
suffix:colon
l_string|&quot;master:&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fastDMA=%s&quot;
comma
(paren
id|flags
op_amp
l_int|9
)paren
ques
c_cond
l_string|&quot;on &quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; PreFetch=%s&quot;
comma
(paren
id|flags
op_amp
l_int|4
)paren
ques
c_cond
l_string|&quot;on &quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; IORDY=%s&quot;
comma
(paren
id|flags
op_amp
l_int|2
)paren
ques
c_cond
l_string|&quot;on &quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; fastPIO=%s&bslash;n&quot;
comma
(paren
(paren
id|flags
op_amp
l_int|9
)paren
op_eq
l_int|1
)paren
ques
c_cond
l_string|&quot;on &quot;
suffix:colon
l_string|&quot;off&quot;
)paren
suffix:semicolon
)brace
DECL|function|init_triton_dma
r_static
r_void
id|init_triton_dma
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_int
r_int
id|base
)paren
(brace
r_static
r_int
r_int
id|dmatable
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    %s: BM-DMA at 0x%04x-0x%04x&quot;
comma
id|hwif-&gt;name
comma
id|base
comma
id|base
op_plus
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|base
comma
l_int|8
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; -- ERROR, PORTS ALREADY IN USE&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|request_region
c_func
(paren
id|base
comma
l_int|8
comma
l_string|&quot;IDE DMA&quot;
)paren
suffix:semicolon
id|hwif-&gt;dma_base
op_assign
id|base
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dmatable
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Since we know we are on a PCI bus, we could&n;&t;&t;&t; * actually use __get_free_pages() here instead&n;&t;&t;&t; * of __get_dma_pages() -- no ISA limitations.&n;&t;&t;&t; */
id|dmatable
op_assign
id|__get_dma_pages
c_func
(paren
id|GFP_KERNEL
comma
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dmatable
)paren
(brace
id|hwif-&gt;dmatable
op_assign
(paren
r_int
r_int
op_star
)paren
id|dmatable
suffix:semicolon
id|dmatable
op_add_assign
(paren
id|PRD_ENTRIES
op_star
id|PRD_BYTES
)paren
suffix:semicolon
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hwif-&gt;dmatable
)paren
comma
id|base
op_plus
l_int|4
)paren
suffix:semicolon
id|hwif-&gt;dmaproc
op_assign
op_amp
id|triton_dmaproc
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_init_triton() prepares the IDE driver for DMA operation.&n; * This routine is called once, from ide.c during driver initialization,&n; * for each triton chipset which is found (unlikely to be more than one).&n; */
DECL|function|ide_init_triton
r_void
id|ide_init_triton
(paren
id|byte
id|bus
comma
id|byte
id|fn
)paren
(brace
r_int
id|rc
op_assign
l_int|0
comma
id|h
suffix:semicolon
r_int
id|dma_enabled
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|pcicmd
suffix:semicolon
r_int
r_int
id|bmiba
comma
id|timings
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ide: 430FX (Triton) on PCI bus %d function %d&bslash;n&quot;
comma
id|bus
comma
id|fn
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * See if IDE and BM-DMA features are enabled:&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x04
comma
op_amp
id|pcicmd
)paren
)paren
)paren
r_goto
id|quit
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pcicmd
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide: ports are not enabled (BIOS)&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|quit
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|pcicmd
op_amp
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide: BM-DMA feature is not enabled (BIOS)&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Get the bmiba base address&n;&t;&t; */
r_int
id|try_again
op_assign
l_int|1
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x20
comma
op_amp
id|bmiba
)paren
)paren
)paren
r_goto
id|quit
suffix:semicolon
id|bmiba
op_and_assign
l_int|0xfff0
suffix:semicolon
multiline_comment|/* extract port base address */
r_if
c_cond
(paren
id|bmiba
)paren
(brace
id|dma_enabled
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;ide: BM-DMA base register is invalid (0x%04x, PnP BIOS problem)&bslash;n&quot;
comma
id|bmiba
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|DEFAULT_BMIBA
)paren
op_ne
l_int|0xff
op_logical_or
op_logical_neg
id|try_again
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ide: setting BM-DMA base register to 0x%04x&bslash;n&quot;
comma
id|DEFAULT_BMIBA
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|pcibios_write_config_word
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x04
comma
id|pcicmd
op_amp
op_complement
l_int|1
)paren
)paren
)paren
r_goto
id|quit
suffix:semicolon
id|rc
op_assign
id|pcibios_write_config_dword
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x20
comma
id|DEFAULT_BMIBA
op_or
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibios_write_config_word
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x04
comma
id|pcicmd
op_or
l_int|5
)paren
op_logical_or
id|rc
)paren
r_goto
id|quit
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|try_again
op_decrement
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * See if ide port(s) are enabled&n;&t; */
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x40
comma
op_amp
id|timings
)paren
)paren
)paren
r_goto
id|quit
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|timings
op_amp
l_int|0x80008000
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide: neither port is enabled&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|quit
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Save the dma_base port addr for each interface&n;&t; */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|byte
id|s_clks
comma
id|r_clks
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_int
r_int
id|time
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_base
op_eq
l_int|0x1f0
)paren
(brace
id|time
op_assign
id|timings
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
(paren
id|timings
op_amp
l_int|0x8000
)paren
op_eq
l_int|0
)paren
multiline_comment|/* interface enabled? */
r_continue
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|ide_triton
suffix:semicolon
r_if
c_cond
(paren
id|dma_enabled
)paren
id|init_triton_dma
c_func
(paren
id|hwif
comma
id|bmiba
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hwif-&gt;io_base
op_eq
l_int|0x170
)paren
(brace
id|time
op_assign
id|timings
op_rshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
(paren
id|timings
op_amp
l_int|0x8000
)paren
op_eq
l_int|0
)paren
multiline_comment|/* interface enabled? */
r_continue
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|ide_triton
suffix:semicolon
r_if
c_cond
(paren
id|dma_enabled
)paren
id|init_triton_dma
c_func
(paren
id|hwif
comma
id|bmiba
op_plus
l_int|8
)paren
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
id|s_clks
op_assign
(paren
(paren
op_complement
id|time
op_rshift
l_int|12
)paren
op_amp
l_int|3
)paren
op_plus
l_int|2
suffix:semicolon
id|r_clks
op_assign
(paren
(paren
op_complement
id|time
op_rshift
l_int|8
)paren
op_amp
l_int|3
)paren
op_plus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    %s timing: (0x%04x) sample_CLKs=%d, recovery_CLKs=%d&bslash;n&quot;
comma
id|hwif-&gt;name
comma
id|time
comma
id|s_clks
comma
id|r_clks
)paren
suffix:semicolon
id|print_triton_drive_flags
(paren
l_int|0
comma
id|time
op_amp
l_int|0xf
)paren
suffix:semicolon
id|print_triton_drive_flags
(paren
l_int|1
comma
(paren
id|time
op_rshift
l_int|4
)paren
op_amp
l_int|0xf
)paren
suffix:semicolon
)brace
id|quit
suffix:colon
r_if
c_cond
(paren
id|rc
)paren
id|printk
c_func
(paren
l_string|&quot;ide: pcibios access failed - %s&bslash;n&quot;
comma
id|pcibios_strerror
c_func
(paren
id|rc
)paren
)paren
suffix:semicolon
)brace
eof
