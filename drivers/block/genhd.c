multiline_comment|/*&n; *  Code extracted from&n; *  linux/kernel/hd.c&n; *&n; *  Copyright (C) 1991-1998  Linus Torvalds&n; *&n; *&n; *  Thanks to Branko Lankester, lankeste@fwi.uva.nl, who found a bug&n; *  in the early extended-partition checks and added DM partitions&n; *&n; *  Support for DiskManager v6.0x added by Mark Lord,&n; *  with information provided by OnTrack.  This now works for linux fdisk&n; *  and LILO, as well as loadlin and bootln.  Note that disks other than&n; *  /dev/hda *must* have a &quot;DOS&quot; type 0x51 partition in the first slot (hda1).&n; *&n; *  More flexible handling of extended partitions - aeb, 950831&n; *&n; *  Check partition table on IDE disks for common CHS translations&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/*&n; * Many architectures don&squot;t like unaligned accesses, which is&n; * frequently the case with the nr_sects and start_sect partition&n; * table entries.&n; */
macro_line|#include &lt;asm/unaligned.h&gt;
DECL|macro|SYS_IND
mdefine_line|#define SYS_IND(p)&t;(get_unaligned(&amp;p-&gt;sys_ind))
DECL|macro|NR_SECTS
mdefine_line|#define NR_SECTS(p)&t;({ __typeof__(p-&gt;nr_sects) __a =&t;&bslash;&n;&t;&t;&t;&t;get_unaligned(&amp;p-&gt;nr_sects);&t;&bslash;&n;&t;&t;&t;&t;le32_to_cpu(__a); &bslash;&n;&t;&t;&t;})
DECL|macro|START_SECT
mdefine_line|#define START_SECT(p)&t;({ __typeof__(p-&gt;start_sect) __a =&t;&bslash;&n;&t;&t;&t;&t;get_unaligned(&amp;p-&gt;start_sect);&t;&bslash;&n;&t;&t;&t;&t;le32_to_cpu(__a); &bslash;&n;&t;&t;&t;})
DECL|variable|gendisk_head
r_struct
id|gendisk
op_star
id|gendisk_head
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|current_minor
r_static
r_int
id|current_minor
op_assign
l_int|0
suffix:semicolon
r_extern
r_int
op_star
id|blk_size
(braket
)braket
suffix:semicolon
r_extern
r_void
id|rd_load
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_void
id|initrd_load
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|chr_dev_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|blk_dev_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|scsi_dev_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_extern
r_int
id|net_dev_init
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * disk_name() is used by genhd.c and md.c.&n; * It formats the devicename of the indicated disk&n; * into the supplied buffer, and returns a pointer&n; * to that same buffer (for convenience).&n; */
DECL|function|disk_name
r_char
op_star
id|disk_name
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_int
id|minor
comma
r_char
op_star
id|buf
)paren
(brace
r_int
r_int
id|part
suffix:semicolon
r_const
r_char
op_star
id|maj
op_assign
id|hd-&gt;major_name
suffix:semicolon
r_char
id|unit
op_assign
(paren
id|minor
op_rshift
id|hd-&gt;minor_shift
)paren
op_plus
l_char|&squot;a&squot;
suffix:semicolon
multiline_comment|/*&n;&t; * IDE devices use multiple major numbers, but the drives&n;&t; * are named as:  {hda,hdb}, {hdc,hdd}, {hde,hdf}, {hdg,hdh}..&n;&t; * This requires special handling here.&n;&t; */
r_switch
c_cond
(paren
id|hd-&gt;major
)paren
(brace
r_case
id|IDE3_MAJOR
suffix:colon
id|unit
op_add_assign
l_int|2
suffix:semicolon
r_case
id|IDE2_MAJOR
suffix:colon
id|unit
op_add_assign
l_int|2
suffix:semicolon
r_case
id|IDE1_MAJOR
suffix:colon
id|unit
op_add_assign
l_int|2
suffix:semicolon
r_case
id|IDE0_MAJOR
suffix:colon
id|maj
op_assign
l_string|&quot;hd&quot;
suffix:semicolon
)brace
id|part
op_assign
id|minor
op_amp
(paren
(paren
l_int|1
op_lshift
id|hd-&gt;minor_shift
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|part
)paren
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s%c%d&quot;
comma
id|maj
comma
id|unit
comma
id|part
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;%s%c&quot;
comma
id|maj
comma
id|unit
)paren
suffix:semicolon
r_return
id|buf
suffix:semicolon
)brace
DECL|function|add_partition
r_static
r_void
id|add_partition
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_int
id|minor
comma
r_int
id|start
comma
r_int
id|size
)paren
(brace
r_char
id|buf
(braket
l_int|8
)braket
suffix:semicolon
id|hd-&gt;part
(braket
id|minor
)braket
dot
id|start_sect
op_assign
id|start
suffix:semicolon
id|hd-&gt;part
(braket
id|minor
)braket
dot
id|nr_sects
op_assign
id|size
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %s&quot;
comma
id|disk_name
c_func
(paren
id|hd
comma
id|minor
comma
id|buf
)paren
)paren
suffix:semicolon
)brace
DECL|function|is_extended_partition
r_static
r_inline
r_int
id|is_extended_partition
c_func
(paren
r_struct
id|partition
op_star
id|p
)paren
(brace
r_return
(paren
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|DOS_EXTENDED_PARTITION
op_logical_or
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|WIN98_EXTENDED_PARTITION
op_logical_or
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|LINUX_EXTENDED_PARTITION
)paren
suffix:semicolon
)brace
DECL|function|get_ptable_blocksize
r_static
r_int
r_int
id|get_ptable_blocksize
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|ret
op_assign
l_int|1024
suffix:semicolon
multiline_comment|/*&n;   * See whether the low-level driver has given us a minumum blocksize.&n;   * If so, check to see whether it is larger than the default of 1024.&n;   */
r_if
c_cond
(paren
op_logical_neg
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n;   * Check for certain special power of two sizes that we allow.&n;   * With anything larger than 1024, we must force the blocksize up to&n;   * the natural blocksize for the device so that we don&squot;t have to try&n;   * and read partial sectors.  Anything smaller should be just fine.&n;   */
r_switch
c_cond
(paren
id|blksize_size
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
)paren
(brace
r_case
l_int|2048
suffix:colon
id|ret
op_assign
l_int|2048
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4096
suffix:colon
id|ret
op_assign
l_int|4096
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|8192
suffix:colon
id|ret
op_assign
l_int|8192
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1024
suffix:colon
r_case
l_int|512
suffix:colon
r_case
l_int|256
suffix:colon
r_case
l_int|0
suffix:colon
multiline_comment|/*&n;       * These are all OK.&n;       */
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Strange blocksize for partition table&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MSDOS_PARTITION
multiline_comment|/*&n; * Create devices for each logical partition in an extended partition.&n; * The logical partitions form a linked list, with each entry being&n; * a partition table with two entries.  The first entry&n; * is the real data partition (with a start relative to the partition&n; * table start).  The second is a pointer to the next logical partition&n; * (with a start relative to the entire extended partition).&n; * We do not create a Linux partition for the partition tables, but&n; * only for the actual data partitions.&n; */
DECL|macro|MSDOS_LABEL_MAGIC
mdefine_line|#define MSDOS_LABEL_MAGIC&t;&t;0xAA55
DECL|function|extended_partition
r_static
r_void
id|extended_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
id|kdev_t
id|dev
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|partition
op_star
id|p
suffix:semicolon
r_int
r_int
id|first_sector
comma
id|first_size
comma
id|this_sector
comma
id|this_size
suffix:semicolon
r_int
id|mask
op_assign
(paren
l_int|1
op_lshift
id|hd-&gt;minor_shift
)paren
op_minus
l_int|1
suffix:semicolon
r_int
id|i
suffix:semicolon
id|first_sector
op_assign
id|hd-&gt;part
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
dot
id|start_sect
suffix:semicolon
id|first_size
op_assign
id|hd-&gt;part
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
dot
id|nr_sects
suffix:semicolon
id|this_sector
op_assign
id|first_sector
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|current_minor
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
l_int|0
comma
id|get_ptable_blocksize
c_func
(paren
id|dev
)paren
)paren
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t;   * This block is from a device that we&squot;re about to stomp on.&n;&t;   * So make sure nobody thinks this block is usable.&n;&t;   */
id|bh-&gt;b_state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|bh-&gt;b_data
op_plus
l_int|510
)paren
)paren
op_ne
id|cpu_to_le16
c_func
(paren
id|MSDOS_LABEL_MAGIC
)paren
)paren
r_goto
id|done
suffix:semicolon
id|p
op_assign
(paren
r_struct
id|partition
op_star
)paren
(paren
l_int|0x1BE
op_plus
id|bh-&gt;b_data
)paren
suffix:semicolon
id|this_size
op_assign
id|hd-&gt;part
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
dot
id|nr_sects
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Usually, the first entry is the real data partition,&n;&t;&t; * the 2nd entry is the next extended partition, or empty,&n;&t;&t; * and the 3rd and 4th entries are unused.&n;&t;&t; * However, DRDOS sometimes has the extended partition as&n;&t;&t; * the first entry (when the data partition is empty),&n;&t;&t; * and OS/2 seems to use all four entries.&n;&t;&t; */
multiline_comment|/* &n;&t;&t; * First process the data partition(s)&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|NR_SECTS
c_func
(paren
id|p
)paren
op_logical_or
id|is_extended_partition
c_func
(paren
id|p
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* Check the 3rd and 4th entries -&n;&t;&t;       these sometimes contain random garbage */
r_if
c_cond
(paren
id|i
op_ge
l_int|2
op_logical_and
id|START_SECT
c_func
(paren
id|p
)paren
op_plus
id|NR_SECTS
c_func
(paren
id|p
)paren
OG
id|this_size
op_logical_and
(paren
id|this_sector
op_plus
id|START_SECT
c_func
(paren
id|p
)paren
template_param
id|first_sector
op_plus
id|first_size
)paren
)paren
r_continue
suffix:semicolon
id|add_partition
c_func
(paren
id|hd
comma
id|current_minor
comma
id|this_sector
op_plus
id|START_SECT
c_func
(paren
id|p
)paren
comma
id|NR_SECTS
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
id|current_minor
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current_minor
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Next, process the (first) extended partition, if present.&n;&t;&t; * (So far, there seems to be no reason to make&n;&t;&t; *  extended_partition()  recursive and allow a tree&n;&t;&t; *  of extended partitions.)&n;&t;&t; * It should be a link to the next logical partition.&n;&t;&t; * Create a minor for this just long enough to get the next&n;&t;&t; * partition table.  The minor will be reused for the next&n;&t;&t; * data partition.&n;&t;&t; */
id|p
op_sub_assign
l_int|4
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
r_if
c_cond
(paren
id|NR_SECTS
c_func
(paren
id|p
)paren
op_logical_and
id|is_extended_partition
c_func
(paren
id|p
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
l_int|4
)paren
r_goto
id|done
suffix:semicolon
multiline_comment|/* nothing left to do */
id|hd-&gt;part
(braket
id|current_minor
)braket
dot
id|nr_sects
op_assign
id|NR_SECTS
c_func
(paren
id|p
)paren
suffix:semicolon
id|hd-&gt;part
(braket
id|current_minor
)braket
dot
id|start_sect
op_assign
id|first_sector
op_plus
id|START_SECT
c_func
(paren
id|p
)paren
suffix:semicolon
id|this_sector
op_assign
id|first_sector
op_plus
id|START_SECT
c_func
(paren
id|p
)paren
suffix:semicolon
id|dev
op_assign
id|MKDEV
c_func
(paren
id|hd-&gt;major
comma
id|current_minor
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|done
suffix:colon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_SOLARIS_X86_PARTITION
r_static
r_void
DECL|function|solaris_x86_partition
id|solaris_x86_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
id|kdev_t
id|dev
comma
r_int
id|offset
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|solaris_x86_vtoc
op_star
id|v
suffix:semicolon
r_struct
id|solaris_x86_slice
op_star
id|s
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
l_int|0
comma
id|get_ptable_blocksize
c_func
(paren
id|dev
)paren
)paren
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|v
op_assign
(paren
r_struct
id|solaris_x86_vtoc
op_star
)paren
(paren
id|bh-&gt;b_data
op_plus
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v-&gt;v_sanity
op_ne
id|SOLARIS_X86_VTOC_SANE
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; &lt;solaris:&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|v-&gt;v_version
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  cannot handle version %ld vtoc&gt;&quot;
comma
id|v-&gt;v_version
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|SOLARIS_X86_NUMSLICE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|s
op_assign
op_amp
id|v-&gt;v_slice
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;s_size
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; [s%d]&quot;
comma
id|i
)paren
suffix:semicolon
multiline_comment|/* solaris partitions are relative to current MS-DOS&n;&t;&t; * one but add_partition starts relative to sector&n;&t;&t; * zero of the disk.  Therefore, must add the offset&n;&t;&t; * of the current partition */
id|add_partition
c_func
(paren
id|hd
comma
id|current_minor
comma
id|s-&gt;s_start
op_plus
id|offset
comma
id|s-&gt;s_size
)paren
suffix:semicolon
id|current_minor
op_increment
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &gt;&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BSD_DISKLABEL
multiline_comment|/* &n; * Create devices for BSD partitions listed in a disklabel, under a&n; * dos-like partition. See extended_partition() for more information.&n; */
DECL|function|bsd_disklabel_partition
r_static
r_void
id|bsd_disklabel_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
id|kdev_t
id|dev
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|bsd_disklabel
op_star
id|l
suffix:semicolon
r_struct
id|bsd_partition
op_star
id|p
suffix:semicolon
r_int
id|mask
op_assign
(paren
l_int|1
op_lshift
id|hd-&gt;minor_shift
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
l_int|0
comma
id|get_ptable_blocksize
c_func
(paren
id|dev
)paren
)paren
)paren
)paren
r_return
suffix:semicolon
id|bh-&gt;b_state
op_assign
l_int|0
suffix:semicolon
id|l
op_assign
(paren
r_struct
id|bsd_disklabel
op_star
)paren
(paren
id|bh-&gt;b_data
op_plus
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
id|l-&gt;d_magic
op_ne
id|BSD_DISKMAGIC
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|p
op_assign
op_amp
id|l-&gt;d_partitions
(braket
l_int|0
)braket
suffix:semicolon
r_while
c_loop
(paren
id|p
op_minus
op_amp
id|l-&gt;d_partitions
(braket
l_int|0
)braket
op_le
id|BSD_MAXPARTITIONS
)paren
(brace
r_if
c_cond
(paren
(paren
id|current_minor
op_amp
id|mask
)paren
op_ge
(paren
l_int|4
op_plus
id|hd-&gt;max_p
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|p-&gt;p_fstype
op_ne
id|BSD_FS_UNUSED
)paren
(brace
id|add_partition
c_func
(paren
id|hd
comma
id|current_minor
comma
id|p-&gt;p_offset
comma
id|p-&gt;p_size
)paren
suffix:semicolon
id|current_minor
op_increment
suffix:semicolon
)brace
id|p
op_increment
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|msdos_partition
r_static
r_int
id|msdos_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
id|kdev_t
id|dev
comma
r_int
r_int
id|first_sector
)paren
(brace
r_int
id|i
comma
id|minor
op_assign
id|current_minor
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|partition
op_star
id|p
suffix:semicolon
r_int
r_char
op_star
id|data
suffix:semicolon
r_int
id|mask
op_assign
(paren
l_int|1
op_lshift
id|hd-&gt;minor_shift
)paren
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDE
r_int
id|tested_for_xlate
op_assign
l_int|0
suffix:semicolon
id|read_mbr
suffix:colon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
l_int|0
comma
id|get_ptable_blocksize
c_func
(paren
id|dev
)paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; unable to read partition table&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|data
op_assign
id|bh-&gt;b_data
suffix:semicolon
multiline_comment|/* In some cases we modify the geometry    */
multiline_comment|/*  of the drive (below), so ensure that   */
multiline_comment|/*  nobody else tries to re-use this data. */
id|bh-&gt;b_state
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDE
id|check_table
suffix:colon
macro_line|#endif
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
l_int|0x1fe
op_plus
id|data
)paren
op_ne
id|cpu_to_le16
c_func
(paren
id|MSDOS_LABEL_MAGIC
)paren
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|p
op_assign
(paren
r_struct
id|partition
op_star
)paren
(paren
l_int|0x1be
op_plus
id|data
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDE
r_if
c_cond
(paren
op_logical_neg
id|tested_for_xlate
op_increment
)paren
(brace
multiline_comment|/* Do this only once per disk */
multiline_comment|/*&n;&t;&t; * Look for various forms of IDE disk geometry translation&n;&t;&t; */
r_extern
r_int
id|ide_xlate_1024
c_func
(paren
id|kdev_t
comma
r_int
comma
r_const
r_char
op_star
)paren
suffix:semicolon
r_int
r_int
id|sig
op_assign
id|le16_to_cpu
c_func
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|data
op_plus
l_int|2
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|EZD_PARTITION
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The remainder of the disk must be accessed using&n;&t;&t;&t; * a translated geometry that reduces the number of &n;&t;&t;&t; * apparent cylinders to less than 1024 if possible.&n;&t;&t;&t; *&n;&t;&t;&t; * ide_xlate_1024() will take care of the necessary&n;&t;&t;&t; * adjustments to fool fdisk/LILO and partition check.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ide_xlate_1024
c_func
(paren
id|dev
comma
op_minus
l_int|1
comma
l_string|&quot; [EZD]&quot;
)paren
)paren
(brace
id|data
op_add_assign
l_int|512
suffix:semicolon
r_goto
id|check_table
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|DM6_PARTITION
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Everything on the disk is offset by 63 sectors,&n;&t;&t;&t; * including a &quot;new&quot; MBR with its own partition table,&n;&t;&t;&t; * and the remainder of the disk must be accessed using&n;&t;&t;&t; * a translated geometry that reduces the number of &n;&t;&t;&t; * apparent cylinders to less than 1024 if possible.&n;&t;&t;&t; *&n;&t;&t;&t; * ide_xlate_1024() will take care of the necessary&n;&t;&t;&t; * adjustments to fool fdisk/LILO and partition check.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|ide_xlate_1024
c_func
(paren
id|dev
comma
l_int|1
comma
l_string|&quot; [DM6:DDO]&quot;
)paren
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_goto
id|read_mbr
suffix:semicolon
multiline_comment|/* start over with new MBR */
)brace
)brace
r_else
r_if
c_cond
(paren
id|sig
op_le
l_int|0x1ae
op_logical_and
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|data
op_plus
id|sig
)paren
op_eq
id|cpu_to_le16
c_func
(paren
l_int|0x55AA
)paren
op_logical_and
(paren
l_int|1
op_amp
op_star
(paren
r_int
r_char
op_star
)paren
(paren
id|data
op_plus
id|sig
op_plus
l_int|2
)paren
)paren
)paren
(brace
multiline_comment|/* DM6 signature in MBR, courtesy of OnTrack */
(paren
r_void
)paren
id|ide_xlate_1024
(paren
id|dev
comma
l_int|0
comma
l_string|&quot; [DM6:MBR]&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|DM6_AUX1PARTITION
op_logical_or
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|DM6_AUX3PARTITION
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * DM6 on other than the first (boot) drive&n;&t;&t;&t; */
(paren
r_void
)paren
id|ide_xlate_1024
c_func
(paren
id|dev
comma
l_int|0
comma
l_string|&quot; [DM6:AUX]&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Examine the partition table for common translations.&n;&t;&t;&t; * This is necessary for drives for situations where&n;&t;&t;&t; * the translated geometry is unavailable from the BIOS.&n;&t;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|partition
op_star
id|q
op_assign
op_amp
id|p
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|NR_SECTS
c_func
(paren
id|q
)paren
op_logical_and
(paren
id|q-&gt;sector
op_amp
l_int|63
)paren
op_eq
l_int|1
op_logical_and
(paren
id|q-&gt;end_sector
op_amp
l_int|63
)paren
op_eq
l_int|63
)paren
(brace
r_int
r_int
id|heads
op_assign
id|q-&gt;end_head
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|heads
op_eq
l_int|32
op_logical_or
id|heads
op_eq
l_int|64
op_logical_or
id|heads
op_eq
l_int|128
op_logical_or
id|heads
op_eq
l_int|255
)paren
(brace
(paren
r_void
)paren
id|ide_xlate_1024
c_func
(paren
id|dev
comma
id|heads
comma
l_string|&quot; [PTBL]&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
)brace
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDE */
id|current_minor
op_add_assign
l_int|4
suffix:semicolon
multiline_comment|/* first &quot;extra&quot; minor (for extended partitions) */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
l_int|4
suffix:semicolon
id|minor
op_increment
comma
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|NR_SECTS
c_func
(paren
id|p
)paren
)paren
r_continue
suffix:semicolon
id|add_partition
c_func
(paren
id|hd
comma
id|minor
comma
id|first_sector
op_plus
id|START_SECT
c_func
(paren
id|p
)paren
comma
id|NR_SECTS
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|is_extended_partition
c_func
(paren
id|p
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; &lt;&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If we are rereading the partition table, we need&n;&t;&t;&t; * to set the size of the partition so that we will&n;&t;&t;&t; * be able to bread the block containing the extended&n;&t;&t;&t; * partition info.&n;&t;&t;&t; */
id|hd-&gt;sizes
(braket
id|minor
)braket
op_assign
id|hd-&gt;part
(braket
id|minor
)braket
dot
id|nr_sects
op_rshift
(paren
id|BLOCK_SIZE_BITS
op_minus
l_int|9
)paren
suffix:semicolon
id|extended_partition
c_func
(paren
id|hd
comma
id|MKDEV
c_func
(paren
id|hd-&gt;major
comma
id|minor
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &gt;&quot;
)paren
suffix:semicolon
multiline_comment|/* prevent someone doing mkfs or mkswap on an&n;&t;&t;&t;   extended partition, but leave room for LILO */
r_if
c_cond
(paren
id|hd-&gt;part
(braket
id|minor
)braket
dot
id|nr_sects
OG
l_int|2
)paren
id|hd-&gt;part
(braket
id|minor
)braket
dot
id|nr_sects
op_assign
l_int|2
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BSD_DISKLABEL
r_if
c_cond
(paren
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|BSD_PARTITION
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; &lt;&quot;
)paren
suffix:semicolon
id|bsd_disklabel_partition
c_func
(paren
id|hd
comma
id|MKDEV
c_func
(paren
id|hd-&gt;major
comma
id|minor
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; &gt;&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_SOLARIS_X86_PARTITION
multiline_comment|/* james@bpgc.com: Solaris has a nasty indicator: 0x82&n;&t;&t; * which also means linux swap.  For that reason, all&n;&t;&t; * of the prints are done inside the&n;&t;&t; * solaris_x86_partition routine */
r_if
c_cond
(paren
id|SYS_IND
c_func
(paren
id|p
)paren
op_eq
id|SOLARIS_X86_PARTITION
)paren
(brace
id|solaris_x86_partition
c_func
(paren
id|hd
comma
id|MKDEV
c_func
(paren
id|hd-&gt;major
comma
id|minor
)paren
comma
id|first_sector
op_plus
id|START_SECT
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n;&t; *  Check for old-style Disk Manager partition table&n;&t; */
r_if
c_cond
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|data
op_plus
l_int|0xfc
)paren
op_eq
id|cpu_to_le16
c_func
(paren
id|MSDOS_LABEL_MAGIC
)paren
)paren
(brace
id|p
op_assign
(paren
r_struct
id|partition
op_star
)paren
(paren
l_int|0x1be
op_plus
id|data
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|4
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
comma
id|current_minor
op_increment
)paren
(brace
id|p
op_decrement
suffix:semicolon
r_if
c_cond
(paren
(paren
id|current_minor
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|START_SECT
c_func
(paren
id|p
)paren
op_logical_and
id|NR_SECTS
c_func
(paren
id|p
)paren
)paren
)paren
r_continue
suffix:semicolon
id|add_partition
c_func
(paren
id|hd
comma
id|current_minor
comma
id|START_SECT
c_func
(paren
id|p
)paren
comma
id|NR_SECTS
c_func
(paren
id|p
)paren
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MSDOS_PARTITION */
macro_line|#ifdef CONFIG_OSF_PARTITION
DECL|function|osf_partition
r_static
r_int
id|osf_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
r_int
r_int
id|dev
comma
r_int
r_int
id|first_sector
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|mask
op_assign
(paren
l_int|1
op_lshift
id|hd-&gt;minor_shift
)paren
op_minus
l_int|1
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|disklabel
(brace
id|u32
id|d_magic
suffix:semicolon
id|u16
id|d_type
comma
id|d_subtype
suffix:semicolon
id|u8
id|d_typename
(braket
l_int|16
)braket
suffix:semicolon
id|u8
id|d_packname
(braket
l_int|16
)braket
suffix:semicolon
id|u32
id|d_secsize
suffix:semicolon
id|u32
id|d_nsectors
suffix:semicolon
id|u32
id|d_ntracks
suffix:semicolon
id|u32
id|d_ncylinders
suffix:semicolon
id|u32
id|d_secpercyl
suffix:semicolon
id|u32
id|d_secprtunit
suffix:semicolon
id|u16
id|d_sparespertrack
suffix:semicolon
id|u16
id|d_sparespercyl
suffix:semicolon
id|u32
id|d_acylinders
suffix:semicolon
id|u16
id|d_rpm
comma
id|d_interleave
comma
id|d_trackskew
comma
id|d_cylskew
suffix:semicolon
id|u32
id|d_headswitch
comma
id|d_trkseek
comma
id|d_flags
suffix:semicolon
id|u32
id|d_drivedata
(braket
l_int|5
)braket
suffix:semicolon
id|u32
id|d_spare
(braket
l_int|5
)braket
suffix:semicolon
id|u32
id|d_magic2
suffix:semicolon
id|u16
id|d_checksum
suffix:semicolon
id|u16
id|d_npartitions
suffix:semicolon
id|u32
id|d_bbsize
comma
id|d_sbsize
suffix:semicolon
r_struct
id|d_partition
(brace
id|u32
id|p_size
suffix:semicolon
id|u32
id|p_offset
suffix:semicolon
id|u32
id|p_fsize
suffix:semicolon
id|u8
id|p_fstype
suffix:semicolon
id|u8
id|p_frag
suffix:semicolon
id|u16
id|p_cpg
suffix:semicolon
)brace
id|d_partitions
(braket
l_int|8
)braket
suffix:semicolon
)brace
op_star
id|label
suffix:semicolon
r_struct
id|d_partition
op_star
id|partition
suffix:semicolon
DECL|macro|DISKLABELMAGIC
mdefine_line|#define DISKLABELMAGIC (0x82564557UL)
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
l_int|0
comma
id|get_ptable_blocksize
c_func
(paren
id|dev
)paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unable to read partition table&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|label
op_assign
(paren
r_struct
id|disklabel
op_star
)paren
(paren
id|bh-&gt;b_data
op_plus
l_int|64
)paren
suffix:semicolon
id|partition
op_assign
id|label-&gt;d_partitions
suffix:semicolon
r_if
c_cond
(paren
id|label-&gt;d_magic
op_ne
id|DISKLABELMAGIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;magic: %08x&bslash;n&quot;
comma
id|label-&gt;d_magic
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|label-&gt;d_magic2
op_ne
id|DISKLABELMAGIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;magic2: %08x&bslash;n&quot;
comma
id|label-&gt;d_magic2
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|label-&gt;d_npartitions
suffix:semicolon
id|i
op_increment
comma
id|partition
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|current_minor
op_amp
id|mask
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|partition-&gt;p_size
)paren
id|add_partition
c_func
(paren
id|hd
comma
id|current_minor
comma
id|first_sector
op_plus
id|partition-&gt;p_offset
comma
id|partition-&gt;p_size
)paren
suffix:semicolon
id|current_minor
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_OSF_PARTITION */
macro_line|#ifdef CONFIG_SUN_PARTITION
DECL|function|sun_partition
r_static
r_int
id|sun_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
id|kdev_t
id|dev
comma
r_int
r_int
id|first_sector
)paren
(brace
r_int
id|i
comma
id|csum
suffix:semicolon
r_int
r_int
op_star
id|ush
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|sun_disklabel
(brace
r_int
r_char
id|info
(braket
l_int|128
)braket
suffix:semicolon
multiline_comment|/* Informative text string */
r_int
r_char
id|spare
(braket
l_int|292
)braket
suffix:semicolon
multiline_comment|/* Boot information etc. */
r_int
r_int
id|rspeed
suffix:semicolon
multiline_comment|/* Disk rotational speed */
r_int
r_int
id|pcylcount
suffix:semicolon
multiline_comment|/* Physical cylinder count */
r_int
r_int
id|sparecyl
suffix:semicolon
multiline_comment|/* extra sects per cylinder */
r_int
r_char
id|spare2
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* More magic... */
r_int
r_int
id|ilfact
suffix:semicolon
multiline_comment|/* Interleave factor */
r_int
r_int
id|ncyl
suffix:semicolon
multiline_comment|/* Data cylinder count */
r_int
r_int
id|nacyl
suffix:semicolon
multiline_comment|/* Alt. cylinder count */
r_int
r_int
id|ntrks
suffix:semicolon
multiline_comment|/* Tracks per cylinder */
r_int
r_int
id|nsect
suffix:semicolon
multiline_comment|/* Sectors per track */
r_int
r_char
id|spare3
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Even more magic... */
r_struct
id|sun_partition
(brace
id|__u32
id|start_cylinder
suffix:semicolon
id|__u32
id|num_sectors
suffix:semicolon
)brace
id|partitions
(braket
l_int|8
)braket
suffix:semicolon
r_int
r_int
id|magic
suffix:semicolon
multiline_comment|/* Magic number */
r_int
r_int
id|csum
suffix:semicolon
multiline_comment|/* Label xor&squot;d checksum */
)brace
op_star
id|label
suffix:semicolon
r_struct
id|sun_partition
op_star
id|p
suffix:semicolon
r_int
r_int
id|spc
suffix:semicolon
DECL|macro|SUN_LABEL_MAGIC
mdefine_line|#define SUN_LABEL_MAGIC          0xDABE
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
l_int|0
comma
id|get_ptable_blocksize
c_func
(paren
id|dev
)paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Dev %s: unable to read partition table&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|label
op_assign
(paren
r_struct
id|sun_disklabel
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
id|p
op_assign
id|label-&gt;partitions
suffix:semicolon
r_if
c_cond
(paren
id|be16_to_cpu
c_func
(paren
id|label-&gt;magic
)paren
op_ne
id|SUN_LABEL_MAGIC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Dev %s Sun disklabel: bad magic %04x&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
comma
id|be16_to_cpu
c_func
(paren
id|label-&gt;magic
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Look at the checksum */
id|ush
op_assign
(paren
(paren
r_int
r_int
op_star
)paren
(paren
id|label
op_plus
l_int|1
)paren
)paren
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|csum
op_assign
l_int|0
suffix:semicolon
id|ush
op_ge
(paren
(paren
r_int
r_int
op_star
)paren
id|label
)paren
suffix:semicolon
)paren
(brace
id|csum
op_xor_assign
op_star
id|ush
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|csum
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Dev %s Sun disklabel: Csum bad, label corrupted&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* All Sun disks have 8 partition entries */
id|spc
op_assign
id|be16_to_cpu
c_func
(paren
id|label-&gt;ntrks
)paren
op_star
id|be16_to_cpu
c_func
(paren
id|label-&gt;nsect
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
comma
id|p
op_increment
)paren
(brace
r_int
r_int
id|st_sector
suffix:semicolon
r_int
id|num_sectors
suffix:semicolon
id|st_sector
op_assign
id|first_sector
op_plus
id|be32_to_cpu
c_func
(paren
id|p-&gt;start_cylinder
)paren
op_star
id|spc
suffix:semicolon
id|num_sectors
op_assign
id|be32_to_cpu
c_func
(paren
id|p-&gt;num_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|num_sectors
)paren
id|add_partition
c_func
(paren
id|hd
comma
id|current_minor
comma
id|st_sector
comma
id|num_sectors
)paren
suffix:semicolon
id|current_minor
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_SUN_PARTITION */
macro_line|#ifdef CONFIG_AMIGA_PARTITION
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;linux/affs_hardblocks.h&gt;
r_static
id|__inline__
id|u32
DECL|function|checksum_block
id|checksum_block
c_func
(paren
id|u32
op_star
id|m
comma
r_int
id|size
)paren
(brace
id|u32
id|sum
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|size
op_decrement
)paren
id|sum
op_add_assign
id|htonl
c_func
(paren
op_star
id|m
op_increment
)paren
suffix:semicolon
r_return
id|sum
suffix:semicolon
)brace
r_static
r_int
DECL|function|amiga_partition
id|amiga_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
id|kdev_t
id|dev
comma
r_int
r_int
id|first_sector
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|RigidDiskBlock
op_star
id|rdb
suffix:semicolon
r_struct
id|PartitionBlock
op_star
id|pb
suffix:semicolon
r_int
id|start_sect
suffix:semicolon
r_int
id|nr_sects
suffix:semicolon
r_int
id|blk
suffix:semicolon
r_int
id|part
comma
id|res
suffix:semicolon
id|set_blocksize
c_func
(paren
id|dev
comma
l_int|512
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|blk
op_assign
l_int|0
suffix:semicolon
id|blk
OL
id|RDB_ALLOCATION_LIMIT
suffix:semicolon
id|blk
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
id|blk
comma
l_int|512
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Dev %s: unable to read RDB block %d&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
comma
id|blk
)paren
suffix:semicolon
r_goto
id|rdb_done
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
(paren
id|u32
op_star
)paren
id|bh-&gt;b_data
op_eq
id|htonl
c_func
(paren
id|IDNAME_RIGIDDISK
)paren
)paren
(brace
id|rdb
op_assign
(paren
r_struct
id|RigidDiskBlock
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|checksum_block
c_func
(paren
(paren
id|u32
op_star
)paren
id|bh-&gt;b_data
comma
id|htonl
c_func
(paren
id|rdb-&gt;rdb_SummedLongs
)paren
op_amp
l_int|0x7F
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Dev %s: RDB in block %d has bad checksum&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
comma
id|blk
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; RDSK&quot;
)paren
suffix:semicolon
id|blk
op_assign
id|htonl
c_func
(paren
id|rdb-&gt;rdb_PartitionList
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_for
c_loop
(paren
id|part
op_assign
l_int|1
suffix:semicolon
id|blk
OG
l_int|0
op_logical_and
id|part
op_le
l_int|16
suffix:semicolon
id|part
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
id|blk
comma
l_int|512
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Dev %s: unable to read partition block %d&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
comma
id|blk
)paren
suffix:semicolon
r_goto
id|rdb_done
suffix:semicolon
)brace
id|pb
op_assign
(paren
r_struct
id|PartitionBlock
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
id|blk
op_assign
id|htonl
c_func
(paren
id|pb-&gt;pb_Next
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pb-&gt;pb_ID
op_eq
id|htonl
c_func
(paren
id|IDNAME_PARTITION
)paren
op_logical_and
id|checksum_block
c_func
(paren
(paren
id|u32
op_star
)paren
id|pb
comma
id|htonl
c_func
(paren
id|pb-&gt;pb_SummedLongs
)paren
op_amp
l_int|0x7F
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Tell Kernel about it */
r_if
c_cond
(paren
op_logical_neg
(paren
id|nr_sects
op_assign
(paren
id|htonl
c_func
(paren
id|pb-&gt;pb_Environment
(braket
l_int|10
)braket
)paren
op_plus
l_int|1
op_minus
id|htonl
c_func
(paren
id|pb-&gt;pb_Environment
(braket
l_int|9
)braket
)paren
)paren
op_star
id|htonl
c_func
(paren
id|pb-&gt;pb_Environment
(braket
l_int|3
)braket
)paren
op_star
id|htonl
c_func
(paren
id|pb-&gt;pb_Environment
(braket
l_int|5
)braket
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|start_sect
op_assign
id|htonl
c_func
(paren
id|pb-&gt;pb_Environment
(braket
l_int|9
)braket
)paren
op_star
id|htonl
c_func
(paren
id|pb-&gt;pb_Environment
(braket
l_int|3
)braket
)paren
op_star
id|htonl
c_func
(paren
id|pb-&gt;pb_Environment
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|add_partition
c_func
(paren
id|hd
comma
id|current_minor
comma
id|start_sect
comma
id|nr_sects
)paren
suffix:semicolon
id|current_minor
op_increment
suffix:semicolon
id|res
op_assign
l_int|1
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|rdb_done
suffix:colon
id|set_blocksize
c_func
(paren
id|dev
comma
id|BLOCK_SIZE
)paren
suffix:semicolon
r_return
id|res
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_AMIGA_PARTITION */
macro_line|#ifdef CONFIG_MAC_PARTITION
macro_line|#include &lt;linux/ctype.h&gt;
multiline_comment|/*&n; * Code to understand MacOS partition tables.&n; */
DECL|macro|MAC_PARTITION_MAGIC
mdefine_line|#define MAC_PARTITION_MAGIC&t;0x504d
multiline_comment|/* type field value for A/UX or other Unix partitions */
DECL|macro|APPLE_AUX_TYPE
mdefine_line|#define APPLE_AUX_TYPE&t;&quot;Apple_UNIX_SVR2&quot;
DECL|struct|mac_partition
r_struct
id|mac_partition
(brace
DECL|member|signature
id|__u16
id|signature
suffix:semicolon
multiline_comment|/* expected to be MAC_PARTITION_MAGIC */
DECL|member|res1
id|__u16
id|res1
suffix:semicolon
DECL|member|map_count
id|__u32
id|map_count
suffix:semicolon
multiline_comment|/* # blocks in partition map */
DECL|member|start_block
id|__u32
id|start_block
suffix:semicolon
multiline_comment|/* absolute starting block # of partition */
DECL|member|block_count
id|__u32
id|block_count
suffix:semicolon
multiline_comment|/* number of blocks in partition */
DECL|member|name
r_char
id|name
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* partition name */
DECL|member|type
r_char
id|type
(braket
l_int|32
)braket
suffix:semicolon
multiline_comment|/* string type description */
DECL|member|data_start
id|__u32
id|data_start
suffix:semicolon
multiline_comment|/* rel block # of first data block */
DECL|member|data_count
id|__u32
id|data_count
suffix:semicolon
multiline_comment|/* number of data blocks */
DECL|member|status
id|__u32
id|status
suffix:semicolon
multiline_comment|/* partition status bits */
DECL|member|boot_start
id|__u32
id|boot_start
suffix:semicolon
DECL|member|boot_size
id|__u32
id|boot_size
suffix:semicolon
DECL|member|boot_load
id|__u32
id|boot_load
suffix:semicolon
DECL|member|boot_load2
id|__u32
id|boot_load2
suffix:semicolon
DECL|member|boot_entry
id|__u32
id|boot_entry
suffix:semicolon
DECL|member|boot_entry2
id|__u32
id|boot_entry2
suffix:semicolon
DECL|member|boot_cksum
id|__u32
id|boot_cksum
suffix:semicolon
DECL|member|processor
r_char
id|processor
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* identifies ISA of boot */
multiline_comment|/* there is more stuff after this that we don&squot;t need */
)brace
suffix:semicolon
DECL|macro|MAC_STATUS_BOOTABLE
mdefine_line|#define MAC_STATUS_BOOTABLE&t;8&t;/* partition is bootable */
DECL|macro|MAC_DRIVER_MAGIC
mdefine_line|#define MAC_DRIVER_MAGIC&t;0x4552
multiline_comment|/* Driver descriptor structure, in block 0 */
DECL|struct|mac_driver_desc
r_struct
id|mac_driver_desc
(brace
DECL|member|signature
id|__u16
id|signature
suffix:semicolon
multiline_comment|/* expected to be MAC_DRIVER_MAGIC */
DECL|member|block_size
id|__u16
id|block_size
suffix:semicolon
DECL|member|block_count
id|__u32
id|block_count
suffix:semicolon
multiline_comment|/* ... more stuff */
)brace
suffix:semicolon
DECL|function|mac_partition
r_static
r_int
id|mac_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
id|kdev_t
id|dev
comma
r_int
r_int
id|fsec
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|blk
comma
id|blocks_in_map
suffix:semicolon
r_int
id|dev_bsize
comma
id|dev_pos
comma
id|pos
suffix:semicolon
r_int
id|secsize
suffix:semicolon
macro_line|#ifdef CONFIG_PMAC
r_int
id|first_bootable
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
r_struct
id|mac_partition
op_star
id|part
suffix:semicolon
r_struct
id|mac_driver_desc
op_star
id|md
suffix:semicolon
id|dev_bsize
op_assign
id|get_ptable_blocksize
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev_pos
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get 0th block and look at the first partition map entry. */
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
l_int|0
comma
id|dev_bsize
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: error reading partition table&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|md
op_assign
(paren
r_struct
id|mac_driver_desc
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
r_if
c_cond
(paren
id|be16_to_cpu
c_func
(paren
id|md-&gt;signature
)paren
op_ne
id|MAC_DRIVER_MAGIC
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|secsize
op_assign
id|be16_to_cpu
c_func
(paren
id|md-&gt;block_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|secsize
op_ge
id|dev_bsize
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|dev_pos
op_assign
id|secsize
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
id|secsize
op_div
id|dev_bsize
comma
id|dev_bsize
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: error reading partition table&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|part
op_assign
(paren
r_struct
id|mac_partition
op_star
)paren
(paren
id|bh-&gt;b_data
op_plus
id|secsize
op_minus
id|dev_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|be16_to_cpu
c_func
(paren
id|part-&gt;signature
)paren
op_ne
id|MAC_PARTITION_MAGIC
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* not a MacOS disk */
)brace
id|blocks_in_map
op_assign
id|be32_to_cpu
c_func
(paren
id|part-&gt;map_count
)paren
suffix:semicolon
r_for
c_loop
(paren
id|blk
op_assign
l_int|1
suffix:semicolon
id|blk
op_le
id|blocks_in_map
suffix:semicolon
op_increment
id|blk
)paren
(brace
id|pos
op_assign
id|blk
op_star
id|secsize
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|dev_pos
op_plus
id|dev_bsize
)paren
(brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|dev_pos
op_assign
id|pos
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
id|pos
op_div
id|dev_bsize
comma
id|dev_bsize
)paren
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: error reading partition table&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|part
op_assign
(paren
r_struct
id|mac_partition
op_star
)paren
(paren
id|bh-&gt;b_data
op_plus
id|pos
op_minus
id|dev_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|be16_to_cpu
c_func
(paren
id|part-&gt;signature
)paren
op_ne
id|MAC_PARTITION_MAGIC
)paren
r_break
suffix:semicolon
id|blocks_in_map
op_assign
id|be32_to_cpu
c_func
(paren
id|part-&gt;map_count
)paren
suffix:semicolon
id|add_partition
c_func
(paren
id|hd
comma
id|current_minor
comma
id|fsec
op_plus
id|be32_to_cpu
c_func
(paren
id|part-&gt;start_block
)paren
op_star
(paren
id|secsize
op_div
l_int|512
)paren
comma
id|be32_to_cpu
c_func
(paren
id|part-&gt;block_count
)paren
op_star
(paren
id|secsize
op_div
l_int|512
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PMAC
multiline_comment|/*&n;&t;&t; * If this is the first bootable partition, tell the&n;&t;&t; * setup code, in case it wants to make this the root.&n;&t;&t; */
r_if
c_cond
(paren
id|first_bootable
op_logical_and
(paren
id|be32_to_cpu
c_func
(paren
id|part-&gt;status
)paren
op_amp
id|MAC_STATUS_BOOTABLE
)paren
op_logical_and
id|strcasecmp
c_func
(paren
id|part-&gt;processor
comma
l_string|&quot;powerpc&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|note_bootable_part
c_func
(paren
id|dev
comma
id|blk
)paren
suffix:semicolon
id|first_bootable
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PMAC */
op_increment
id|current_minor
suffix:semicolon
)brace
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MAC_PARTITION */
macro_line|#ifdef CONFIG_ATARI_PARTITION
macro_line|#include &lt;asm/atari_rootsec.h&gt;
multiline_comment|/* ++guenther: this should be settable by the user (&quot;make config&quot;)?.&n; */
DECL|macro|ICD_PARTS
mdefine_line|#define ICD_PARTS
DECL|function|atari_partition
r_static
r_int
id|atari_partition
(paren
r_struct
id|gendisk
op_star
id|hd
comma
id|kdev_t
id|dev
comma
r_int
r_int
id|first_sector
)paren
(brace
r_int
id|minor
op_assign
id|current_minor
comma
id|m_lim
op_assign
id|current_minor
op_plus
id|hd-&gt;max_p
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|rootsector
op_star
id|rs
suffix:semicolon
r_struct
id|partition_info
op_star
id|pi
suffix:semicolon
id|ulong
id|extensect
suffix:semicolon
macro_line|#ifdef ICD_PARTS
r_int
id|part_fmt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 0:unknown, 1:AHDI, 2:ICD/Supra */
macro_line|#endif
id|bh
op_assign
id|bread
(paren
id|dev
comma
l_int|0
comma
id|get_ptable_blocksize
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|printk
(paren
l_string|&quot; unable to read block 0&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|rs
op_assign
(paren
r_struct
id|rootsector
op_star
)paren
id|bh-&gt;b_data
suffix:semicolon
id|pi
op_assign
op_amp
id|rs-&gt;part
(braket
l_int|0
)braket
suffix:semicolon
id|printk
(paren
l_string|&quot; AHDI&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|pi
OL
op_amp
id|rs-&gt;part
(braket
l_int|4
)braket
op_logical_and
id|minor
OL
id|m_lim
suffix:semicolon
id|minor
op_increment
comma
id|pi
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pi-&gt;flg
op_amp
l_int|1
)paren
multiline_comment|/* active partition */
(brace
r_if
c_cond
(paren
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;XGM&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
multiline_comment|/* extension partition */
(brace
r_struct
id|rootsector
op_star
id|xrs
suffix:semicolon
r_struct
id|buffer_head
op_star
id|xbh
suffix:semicolon
id|ulong
id|partsect
suffix:semicolon
macro_line|#ifdef ICD_PARTS
id|part_fmt
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot; XGM&lt;&quot;
)paren
suffix:semicolon
id|partsect
op_assign
id|extensect
op_assign
id|pi-&gt;st
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|xbh
op_assign
id|bread
(paren
id|dev
comma
id|partsect
op_div
l_int|2
comma
l_int|1024
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|xbh
)paren
(brace
id|printk
(paren
l_string|&quot; block %ld read failed&bslash;n&quot;
comma
id|partsect
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|partsect
op_amp
l_int|1
)paren
id|xrs
op_assign
(paren
r_struct
id|rootsector
op_star
)paren
op_amp
id|xbh-&gt;b_data
(braket
l_int|512
)braket
suffix:semicolon
r_else
id|xrs
op_assign
(paren
r_struct
id|rootsector
op_star
)paren
op_amp
id|xbh-&gt;b_data
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* ++roman: sanity check: bit 0 of flg field must be set */
r_if
c_cond
(paren
op_logical_neg
(paren
id|xrs-&gt;part
(braket
l_int|0
)braket
dot
id|flg
op_amp
l_int|1
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nFirst sub-partition in extended partition is not valid!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|add_partition
c_func
(paren
id|hd
comma
id|minor
comma
id|partsect
op_plus
id|xrs-&gt;part
(braket
l_int|0
)braket
dot
id|st
comma
id|xrs-&gt;part
(braket
l_int|0
)braket
dot
id|siz
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|xrs-&gt;part
(braket
l_int|1
)braket
dot
id|flg
op_amp
l_int|1
)paren
)paren
(brace
multiline_comment|/* end of linked partition list */
id|brelse
c_func
(paren
id|xbh
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|xrs-&gt;part
(braket
l_int|1
)braket
dot
id|id
comma
l_string|&quot;XGM&quot;
comma
l_int|3
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nID of extended partition is not XGM!&bslash;n&quot;
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|xbh
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|partsect
op_assign
id|xrs-&gt;part
(braket
l_int|1
)braket
dot
id|st
op_plus
id|extensect
suffix:semicolon
id|brelse
(paren
id|xbh
)paren
suffix:semicolon
id|minor
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|m_lim
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nMaximum number of partitions reached!&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot; &gt;&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* we don&squot;t care about other id&squot;s */
id|add_partition
(paren
id|hd
comma
id|minor
comma
id|pi-&gt;st
comma
id|pi-&gt;siz
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#ifdef ICD_PARTS
r_if
c_cond
(paren
id|part_fmt
op_ne
l_int|1
)paren
multiline_comment|/* no extended partitions -&gt; test ICD-format */
(brace
id|pi
op_assign
op_amp
id|rs-&gt;icdpart
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* sanity check: no ICD format if first partition invalid */
r_if
c_cond
(paren
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;GEM&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;BGM&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;LNX&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;SWP&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;RAW&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; ICD&lt;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|pi
OL
op_amp
id|rs-&gt;icdpart
(braket
l_int|8
)braket
op_logical_and
id|minor
OL
id|m_lim
suffix:semicolon
id|minor
op_increment
comma
id|pi
op_increment
)paren
(brace
multiline_comment|/* accept only GEM,BGM,RAW,LNX,SWP partitions */
r_if
c_cond
(paren
id|pi-&gt;flg
op_amp
l_int|1
op_logical_and
(paren
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;GEM&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;BGM&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;LNX&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;SWP&quot;
comma
l_int|3
)paren
op_eq
l_int|0
op_logical_or
id|memcmp
(paren
id|pi-&gt;id
comma
l_string|&quot;RAW&quot;
comma
l_int|3
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|part_fmt
op_assign
l_int|2
suffix:semicolon
id|add_partition
(paren
id|hd
comma
id|minor
comma
id|pi-&gt;st
comma
id|pi-&gt;siz
)paren
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot; &gt;&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
id|brelse
(paren
id|bh
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_ATARI_PARTITION */
DECL|function|check_partition
r_static
r_void
id|check_partition
c_func
(paren
r_struct
id|gendisk
op_star
id|hd
comma
id|kdev_t
id|dev
)paren
(brace
r_static
r_int
id|first_time
op_assign
l_int|1
suffix:semicolon
r_int
r_int
id|first_sector
suffix:semicolon
r_char
id|buf
(braket
l_int|8
)braket
suffix:semicolon
r_if
c_cond
(paren
id|first_time
)paren
id|printk
c_func
(paren
l_string|&quot;Partition check:&bslash;n&quot;
)paren
suffix:semicolon
id|first_time
op_assign
l_int|0
suffix:semicolon
id|first_sector
op_assign
id|hd-&gt;part
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
dot
id|start_sect
suffix:semicolon
multiline_comment|/*&n;&t; * This is a kludge to allow the partition check to be&n;&t; * skipped for specific drives (e.g. IDE CD-ROM drives)&n;&t; */
r_if
c_cond
(paren
(paren
r_int
)paren
id|first_sector
op_eq
op_minus
l_int|1
)paren
(brace
id|hd-&gt;part
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; %s:&quot;
comma
id|disk_name
c_func
(paren
id|hd
comma
id|MINOR
c_func
(paren
id|dev
)paren
comma
id|buf
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MSDOS_PARTITION
r_if
c_cond
(paren
id|msdos_partition
c_func
(paren
id|hd
comma
id|dev
comma
id|first_sector
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_OSF_PARTITION
r_if
c_cond
(paren
id|osf_partition
c_func
(paren
id|hd
comma
id|dev
comma
id|first_sector
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SUN_PARTITION
r_if
c_cond
(paren
id|sun_partition
c_func
(paren
id|hd
comma
id|dev
comma
id|first_sector
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_AMIGA_PARTITION
r_if
c_cond
(paren
id|amiga_partition
c_func
(paren
id|hd
comma
id|dev
comma
id|first_sector
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_ATARI_PARTITION
r_if
c_cond
(paren
id|atari_partition
c_func
(paren
id|hd
comma
id|dev
comma
id|first_sector
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_MAC_PARTITION
r_if
c_cond
(paren
id|mac_partition
c_func
(paren
id|hd
comma
id|dev
comma
id|first_sector
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot; unknown partition table&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* This function is used to re-read partition tables for removable disks.&n;   Much of the cleanup from the old partition tables should have already been&n;   done */
multiline_comment|/* This function will re-read the partition tables for a given device,&n;and set things back up again.  There are some important caveats,&n;however.  You must ensure that no one is using the device, and no one&n;can start using the device while this function is being executed. */
DECL|function|resetup_one_dev
r_void
id|resetup_one_dev
c_func
(paren
r_struct
id|gendisk
op_star
id|dev
comma
r_int
id|drive
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|first_minor
op_assign
id|drive
op_lshift
id|dev-&gt;minor_shift
suffix:semicolon
r_int
id|end_minor
op_assign
id|first_minor
op_plus
id|dev-&gt;max_p
suffix:semicolon
id|blk_size
(braket
id|dev-&gt;major
)braket
op_assign
l_int|NULL
suffix:semicolon
id|current_minor
op_assign
l_int|1
op_plus
id|first_minor
suffix:semicolon
id|check_partition
c_func
(paren
id|dev
comma
id|MKDEV
c_func
(paren
id|dev-&gt;major
comma
id|first_minor
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; &t; * We need to set the sizes array before we will be able to access&n; &t; * any of the partitions on this device.&n; &t; */
r_if
c_cond
(paren
id|dev-&gt;sizes
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* optional safeguard in ll_rw_blk.c */
r_for
c_loop
(paren
id|i
op_assign
id|first_minor
suffix:semicolon
id|i
OL
id|end_minor
suffix:semicolon
id|i
op_increment
)paren
id|dev-&gt;sizes
(braket
id|i
)braket
op_assign
id|dev-&gt;part
(braket
id|i
)braket
dot
id|nr_sects
op_rshift
(paren
id|BLOCK_SIZE_BITS
op_minus
l_int|9
)paren
suffix:semicolon
id|blk_size
(braket
id|dev-&gt;major
)braket
op_assign
id|dev-&gt;sizes
suffix:semicolon
)brace
)brace
DECL|function|setup_dev
r_static
r_inline
r_void
id|setup_dev
c_func
(paren
r_struct
id|gendisk
op_star
id|dev
)paren
(brace
r_int
id|i
comma
id|drive
suffix:semicolon
r_int
id|end_minor
op_assign
id|dev-&gt;max_nr
op_star
id|dev-&gt;max_p
suffix:semicolon
id|blk_size
(braket
id|dev-&gt;major
)braket
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|end_minor
suffix:semicolon
id|i
op_increment
)paren
(brace
id|dev-&gt;part
(braket
id|i
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;part
(braket
id|i
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
)brace
id|dev
op_member_access_from_pointer
id|init
c_func
(paren
id|dev
)paren
suffix:semicolon
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|dev-&gt;nr_real
suffix:semicolon
id|drive
op_increment
)paren
(brace
r_int
id|first_minor
op_assign
id|drive
op_lshift
id|dev-&gt;minor_shift
suffix:semicolon
id|current_minor
op_assign
l_int|1
op_plus
id|first_minor
suffix:semicolon
id|check_partition
c_func
(paren
id|dev
comma
id|MKDEV
c_func
(paren
id|dev-&gt;major
comma
id|first_minor
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;sizes
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* optional safeguard in ll_rw_blk.c */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|end_minor
suffix:semicolon
id|i
op_increment
)paren
id|dev-&gt;sizes
(braket
id|i
)braket
op_assign
id|dev-&gt;part
(braket
id|i
)braket
dot
id|nr_sects
op_rshift
(paren
id|BLOCK_SIZE_BITS
op_minus
l_int|9
)paren
suffix:semicolon
id|blk_size
(braket
id|dev-&gt;major
)braket
op_assign
id|dev-&gt;sizes
suffix:semicolon
)brace
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|device_setup
c_func
(paren
r_void
)paren
)paren
(brace
r_extern
r_void
id|console_map_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PARPORT
r_extern
r_int
id|parport_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_MD_BOOT
r_extern
r_void
id|md_setup_drive
c_func
(paren
r_void
)paren
id|__init
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_FC4_SOC
r_extern
r_int
id|soc_probe
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_struct
id|gendisk
op_star
id|p
suffix:semicolon
r_int
id|nr
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef CONFIG_PARPORT
id|parport_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|chr_dev_init
c_func
(paren
)paren
suffix:semicolon
id|blk_dev_init
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_FC4_SOC
multiline_comment|/* This has to be done before scsi_dev_init */
id|soc_probe
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SCSI
id|scsi_dev_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_INET
id|net_dev_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_VT
id|console_map_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|p
op_assign
id|gendisk_head
suffix:semicolon
id|p
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
id|setup_dev
c_func
(paren
id|p
)paren
suffix:semicolon
id|nr
op_add_assign
id|p-&gt;nr_real
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_RAM
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|initrd_start
op_logical_and
id|mount_initrd
)paren
id|initrd_load
c_func
(paren
)paren
suffix:semicolon
r_else
macro_line|#endif
id|rd_load
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_MD_BOOT
id|md_setup_drive
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
