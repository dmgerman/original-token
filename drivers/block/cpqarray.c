multiline_comment|/*&n; *    Disk Array driver for Compaq SMART2 Controllers&n; *    Copyright 1998 Compaq Computer Corporation&n; *&n; *    This program is free software; you can redistribute it and/or modify&n; *    it under the terms of the GNU General Public License as published by&n; *    the Free Software Foundation; either version 2 of the License, or&n; *    (at your option) any later version.&n; *&n; *    This program is distributed in the hope that it will be useful,&n; *    but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or&n; *    NON INFRINGEMENT.  See the GNU General Public License for more details.&n; *&n; *    You should have received a copy of the GNU General Public License&n; *    along with this program; if not, write to the Free Software&n; *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *    Questions/Comments/Bugfixes to arrays@compaq.com&n; *&n; *    If you want to make changes, improve or add functionality to this&n; *    driver, you&squot;ll probably need the Compaq Array Controller Interface&n; *    Specificiation (Document number ECG086/1198)&n; */
macro_line|#include &lt;linux/config.h&gt;&t;/* CONFIG_PROC_FS */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|macro|SMART2_DRIVER_VERSION
mdefine_line|#define SMART2_DRIVER_VERSION(maj,min,submin) ((maj&lt;&lt;16)|(min&lt;&lt;8)|(submin))
DECL|macro|DRIVER_NAME
mdefine_line|#define DRIVER_NAME &quot;Compaq SMART2 Driver (v 2.4.1)&quot;
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION SMART2_DRIVER_VERSION(2,4,1)
multiline_comment|/* Embedded module documentation macros - see modules.h */
multiline_comment|/* Original author Chris Frantz - Compaq Computer Corporation */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Compaq Computer Corporation&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Driver for Compaq Smart2 Array Controllers&quot;
)paren
suffix:semicolon
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR COMPAQ_SMART2_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &quot;cpqarray.h&quot;
macro_line|#include &quot;ida_cmd.h&quot;
macro_line|#include &quot;smart1,2.h&quot;
macro_line|#include &quot;ida_ioctl.h&quot;
DECL|macro|READ_AHEAD
mdefine_line|#define READ_AHEAD&t;128
DECL|macro|NR_CMDS
mdefine_line|#define NR_CMDS&t;&t;128 /* This could probably go as high as ~400 */
DECL|macro|MAX_CTLR
mdefine_line|#define MAX_CTLR&t;8
DECL|macro|CTLR_SHIFT
mdefine_line|#define CTLR_SHIFT&t;8
DECL|variable|nr_ctlr
r_static
r_int
id|nr_ctlr
suffix:semicolon
DECL|variable|hba
r_static
id|ctlr_info_t
op_star
id|hba
(braket
id|MAX_CTLR
)braket
suffix:semicolon
DECL|variable|eisa
r_static
r_int
id|eisa
(braket
l_int|8
)braket
suffix:semicolon
DECL|macro|NR_PRODUCTS
mdefine_line|#define NR_PRODUCTS (sizeof(products)/sizeof(struct board_type))
multiline_comment|/*  board_id = Subsystem Device ID &amp; Vendor ID&n; *  product = Marketing Name for the board&n; *  access = Address of the struct of function pointers &n; */
DECL|variable|products
r_static
r_struct
id|board_type
id|products
(braket
)braket
op_assign
(brace
(brace
l_int|0x0040110E
comma
l_string|&quot;IDA&quot;
comma
op_amp
id|smart1_access
)brace
comma
(brace
l_int|0x0140110E
comma
l_string|&quot;IDA-2&quot;
comma
op_amp
id|smart1_access
)brace
comma
(brace
l_int|0x1040110E
comma
l_string|&quot;IAES&quot;
comma
op_amp
id|smart1_access
)brace
comma
(brace
l_int|0x2040110E
comma
l_string|&quot;SMART&quot;
comma
op_amp
id|smart1_access
)brace
comma
(brace
l_int|0x3040110E
comma
l_string|&quot;SMART-2/E&quot;
comma
op_amp
id|smart2e_access
)brace
comma
(brace
l_int|0x40300E11
comma
l_string|&quot;SMART-2/P&quot;
comma
op_amp
id|smart2_access
)brace
comma
(brace
l_int|0x40310E11
comma
l_string|&quot;SMART-2SL&quot;
comma
op_amp
id|smart2_access
)brace
comma
(brace
l_int|0x40320E11
comma
l_string|&quot;Smart Array 3200&quot;
comma
op_amp
id|smart2_access
)brace
comma
(brace
l_int|0x40330E11
comma
l_string|&quot;Smart Array 3100ES&quot;
comma
op_amp
id|smart2_access
)brace
comma
(brace
l_int|0x40340E11
comma
l_string|&quot;Smart Array 221&quot;
comma
op_amp
id|smart2_access
)brace
comma
(brace
l_int|0x40400E11
comma
l_string|&quot;Integrated Array&quot;
comma
op_amp
id|smart4_access
)brace
comma
(brace
l_int|0x40480E11
comma
l_string|&quot;Compaq Raid LC2&quot;
comma
op_amp
id|smart4_access
)brace
comma
(brace
l_int|0x40500E11
comma
l_string|&quot;Smart Array 4200&quot;
comma
op_amp
id|smart4_access
)brace
comma
(brace
l_int|0x40510E11
comma
l_string|&quot;Smart Array 4250ES&quot;
comma
op_amp
id|smart4_access
)brace
comma
(brace
l_int|0x40580E11
comma
l_string|&quot;Smart Array 431&quot;
comma
op_amp
id|smart4_access
)brace
comma
)brace
suffix:semicolon
DECL|variable|ida
r_static
r_struct
id|hd_struct
op_star
id|ida
suffix:semicolon
DECL|variable|ida_sizes
r_static
r_int
op_star
id|ida_sizes
suffix:semicolon
DECL|variable|ida_blocksizes
r_static
r_int
op_star
id|ida_blocksizes
suffix:semicolon
DECL|variable|ida_hardsizes
r_static
r_int
op_star
id|ida_hardsizes
suffix:semicolon
DECL|variable|ida_gendisk
r_static
r_struct
id|gendisk
id|ida_gendisk
(braket
id|MAX_CTLR
)braket
suffix:semicolon
DECL|variable|proc_array
r_static
r_struct
id|proc_dir_entry
op_star
id|proc_array
suffix:semicolon
multiline_comment|/* Debug... */
DECL|macro|DBG
mdefine_line|#define DBG(s)&t;do { s } while(0)
multiline_comment|/* Debug (general info)... */
DECL|macro|DBGINFO
mdefine_line|#define DBGINFO(s) do { } while(0)
multiline_comment|/* Debug Paranoid... */
DECL|macro|DBGP
mdefine_line|#define DBGP(s)  do { } while(0)
multiline_comment|/* Debug Extra Paranoid... */
DECL|macro|DBGPX
mdefine_line|#define DBGPX(s) do { } while(0)
r_int
id|cpqarray_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|cpqarray_pci_detect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|cpqarray_pci_init
c_func
(paren
id|ctlr_info_t
op_star
id|c
comma
r_struct
id|pci_dev
op_star
id|pdev
)paren
suffix:semicolon
r_static
r_void
op_star
id|remap_pci_mem
c_func
(paren
id|ulong
id|base
comma
id|ulong
id|size
)paren
suffix:semicolon
r_static
r_int
id|cpqarray_eisa_detect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|pollcomplete
c_func
(paren
r_int
id|ctlr
)paren
suffix:semicolon
r_static
r_void
id|getgeometry
c_func
(paren
r_int
id|ctlr
)paren
suffix:semicolon
r_static
r_void
id|start_fwbk
c_func
(paren
r_int
id|ctlr
)paren
suffix:semicolon
r_static
id|cmdlist_t
op_star
id|cmd_alloc
c_func
(paren
id|ctlr_info_t
op_star
id|h
)paren
suffix:semicolon
r_static
r_void
id|cmd_free
c_func
(paren
id|ctlr_info_t
op_star
id|h
comma
id|cmdlist_t
op_star
id|c
)paren
suffix:semicolon
r_static
r_int
id|sendcmd
c_func
(paren
id|__u8
id|cmd
comma
r_int
id|ctlr
comma
r_void
op_star
id|buff
comma
r_int
id|size
comma
r_int
r_int
id|blk
comma
r_int
r_int
id|blkcnt
comma
r_int
r_int
id|log_unit
)paren
suffix:semicolon
r_static
r_int
id|ida_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
)paren
suffix:semicolon
r_static
r_int
id|ida_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
)paren
suffix:semicolon
r_static
r_int
id|ida_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|ida_ctlr_ioctl
c_func
(paren
r_int
id|ctlr
comma
r_int
id|dsk
comma
id|ida_ioctl_t
op_star
id|io
)paren
suffix:semicolon
r_static
r_void
id|do_ida_request
c_func
(paren
r_int
id|i
)paren
suffix:semicolon
multiline_comment|/*&n; * This is a hack.  This driver eats a major number for each controller, and&n; * sets blkdev[xxx].request_fn to each one of these so the real request&n; * function knows what controller its working with.&n; */
DECL|macro|DO_IDA_REQUEST
mdefine_line|#define DO_IDA_REQUEST(x) { do_ida_request(x); }
r_static
r_void
id|do_ida_request0
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_IDA_REQUEST
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_static
r_void
id|do_ida_request1
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_IDA_REQUEST
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_static
r_void
id|do_ida_request2
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_IDA_REQUEST
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_static
r_void
id|do_ida_request3
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_IDA_REQUEST
c_func
(paren
l_int|3
)paren
suffix:semicolon
r_static
r_void
id|do_ida_request4
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_IDA_REQUEST
c_func
(paren
l_int|4
)paren
suffix:semicolon
r_static
r_void
id|do_ida_request5
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_IDA_REQUEST
c_func
(paren
l_int|5
)paren
suffix:semicolon
r_static
r_void
id|do_ida_request6
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_IDA_REQUEST
c_func
(paren
l_int|6
)paren
suffix:semicolon
r_static
r_void
id|do_ida_request7
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_IDA_REQUEST
c_func
(paren
l_int|7
)paren
suffix:semicolon
r_static
r_void
id|start_io
c_func
(paren
id|ctlr_info_t
op_star
id|h
)paren
suffix:semicolon
r_static
r_inline
r_void
id|addQ
c_func
(paren
id|cmdlist_t
op_star
op_star
id|Qptr
comma
id|cmdlist_t
op_star
id|c
)paren
suffix:semicolon
r_static
r_inline
id|cmdlist_t
op_star
id|removeQ
c_func
(paren
id|cmdlist_t
op_star
op_star
id|Qptr
comma
id|cmdlist_t
op_star
id|c
)paren
suffix:semicolon
r_static
r_inline
r_void
id|complete_buffers
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|ok
)paren
suffix:semicolon
r_static
r_inline
r_void
id|complete_command
c_func
(paren
id|cmdlist_t
op_star
id|cmd
comma
r_int
id|timeout
)paren
suffix:semicolon
r_static
r_void
id|do_ida_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|ida_timer
c_func
(paren
r_int
r_int
id|tdata
)paren
suffix:semicolon
r_static
r_int
id|frevalidate_logvol
c_func
(paren
id|kdev_t
id|dev
)paren
suffix:semicolon
r_static
r_int
id|revalidate_logvol
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|maxusage
)paren
suffix:semicolon
r_static
r_int
id|revalidate_allvol
c_func
(paren
id|kdev_t
id|dev
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_static
r_void
id|ida_procinit
c_func
(paren
r_int
id|i
)paren
suffix:semicolon
r_static
r_int
id|ida_proc_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
macro_line|#else
DECL|function|ida_procinit
r_static
r_void
id|ida_procinit
c_func
(paren
r_int
id|i
)paren
(brace
)brace
DECL|function|ida_proc_get_info
r_static
r_int
id|ida_proc_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
DECL|function|ida_geninit
r_static
r_void
id|ida_geninit
c_func
(paren
r_int
id|ctlr
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
id|drv_info_t
op_star
id|drv
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NWD
suffix:semicolon
id|i
op_increment
)paren
(brace
id|drv
op_assign
op_amp
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drv-&gt;nr_blks
)paren
r_continue
suffix:semicolon
id|ida
(braket
(paren
id|ctlr
op_lshift
id|CTLR_SHIFT
)paren
op_plus
(paren
id|i
op_lshift
id|NWD_SHIFT
)paren
)braket
dot
id|nr_sects
op_assign
id|ida_sizes
(braket
(paren
id|ctlr
op_lshift
id|CTLR_SHIFT
)paren
op_plus
(paren
id|i
op_lshift
id|NWD_SHIFT
)paren
)braket
op_assign
id|drv-&gt;nr_blks
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
(brace
id|ida_blocksizes
(braket
(paren
id|ctlr
op_lshift
id|CTLR_SHIFT
)paren
op_plus
(paren
id|i
op_lshift
id|NWD_SHIFT
)paren
op_plus
id|j
)braket
op_assign
l_int|1024
suffix:semicolon
id|ida_hardsizes
(braket
(paren
id|ctlr
op_lshift
id|CTLR_SHIFT
)paren
op_plus
(paren
id|i
op_lshift
id|NWD_SHIFT
)paren
op_plus
id|j
)braket
op_assign
id|drv-&gt;blk_size
suffix:semicolon
)brace
id|ida_gendisk
(braket
id|ctlr
)braket
dot
id|nr_real
op_increment
suffix:semicolon
)brace
)brace
DECL|variable|ida_fops
r_static
r_struct
id|block_device_operations
id|ida_fops
op_assign
(brace
id|open
suffix:colon
id|ida_open
comma
id|release
suffix:colon
id|ida_release
comma
id|ioctl
suffix:colon
id|ida_ioctl
comma
id|revalidate
suffix:colon
id|frevalidate_logvol
comma
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
multiline_comment|/*&n; * Get us a file in /proc/array that says something about each controller.&n; * Create /proc/array if it doesn&squot;t exist yet.&n; */
DECL|function|ida_procinit
r_static
r_void
id|__init
id|ida_procinit
c_func
(paren
r_int
id|i
)paren
(brace
r_if
c_cond
(paren
id|proc_array
op_eq
l_int|NULL
)paren
(brace
id|proc_array
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;driver/array&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|proc_array
)paren
r_return
suffix:semicolon
)brace
id|create_proc_read_entry
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
comma
l_int|0
comma
id|proc_array
comma
id|ida_proc_get_info
comma
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Report information about this controller.&n; */
DECL|function|ida_proc_get_info
r_static
r_int
id|ida_proc_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|size
comma
id|i
comma
id|ctlr
suffix:semicolon
id|ctlr_info_t
op_star
id|h
op_assign
(paren
id|ctlr_info_t
op_star
)paren
id|data
suffix:semicolon
id|drv_info_t
op_star
id|drv
suffix:semicolon
macro_line|#ifdef CPQ_PROC_PRINT_QUEUES
id|cmdlist_t
op_star
id|c
suffix:semicolon
macro_line|#endif
id|ctlr
op_assign
id|h-&gt;ctlr
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%s:  Compaq %s Controller&bslash;n&quot;
l_string|&quot;       Board ID: %08lx&bslash;n&quot;
l_string|&quot;       Firmware Revision: %c%c%c%c&bslash;n&quot;
l_string|&quot;       Controller Sig: %08lx&bslash;n&quot;
l_string|&quot;       Memory Address: %08lx&bslash;n&quot;
l_string|&quot;       I/O Port: %04x&bslash;n&quot;
l_string|&quot;       IRQ: %x&bslash;n&quot;
l_string|&quot;       Logical drives: %d&bslash;n&quot;
l_string|&quot;       Physical drives: %d&bslash;n&bslash;n&quot;
l_string|&quot;       Current Q depth: %d&bslash;n&quot;
l_string|&quot;       Max Q depth since init: %d&bslash;n&bslash;n&quot;
comma
id|h-&gt;devname
comma
id|h-&gt;product_name
comma
(paren
r_int
r_int
)paren
id|h-&gt;board_id
comma
id|h-&gt;firm_rev
(braket
l_int|0
)braket
comma
id|h-&gt;firm_rev
(braket
l_int|1
)braket
comma
id|h-&gt;firm_rev
(braket
l_int|2
)braket
comma
id|h-&gt;firm_rev
(braket
l_int|3
)braket
comma
(paren
r_int
r_int
)paren
id|h-&gt;ctlr_sig
comma
(paren
r_int
r_int
)paren
id|h-&gt;vaddr
comma
(paren
r_int
r_int
)paren
id|h-&gt;ioaddr
comma
(paren
r_int
r_int
)paren
id|h-&gt;intr
comma
id|h-&gt;log_drives
comma
id|h-&gt;phys_drives
comma
id|h-&gt;Qdepth
comma
id|h-&gt;maxQsinceinit
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Logical Drive Info:&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|h-&gt;log_drives
suffix:semicolon
id|i
op_increment
)paren
(brace
id|drv
op_assign
op_amp
id|h-&gt;drv
(braket
id|i
)braket
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;ida/c%dd%d: blksz=%d nr_blks=%d&bslash;n&quot;
comma
id|ctlr
comma
id|i
comma
id|drv-&gt;blk_size
comma
id|drv-&gt;nr_blks
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
)brace
macro_line|#ifdef CPQ_PROC_PRINT_QUEUES
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;nCurrent Queues:&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|c
op_assign
id|h-&gt;reqQ
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;reqQ = %p&quot;
comma
id|c
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
id|c
op_assign
id|c-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|c
op_logical_and
id|c
op_ne
id|h-&gt;reqQ
)paren
(brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;-&gt;%p&quot;
comma
id|c
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|c
op_assign
id|c-&gt;next
suffix:semicolon
)brace
id|c
op_assign
id|h-&gt;cmpQ
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;ncmpQ = %p&quot;
comma
id|c
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
id|c
)paren
id|c
op_assign
id|c-&gt;next
suffix:semicolon
r_while
c_loop
(paren
id|c
op_logical_and
id|c
op_ne
id|h-&gt;cmpQ
)paren
(brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;-&gt;%p&quot;
comma
id|c
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
id|c
op_assign
id|c-&gt;next
suffix:semicolon
)brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
macro_line|#endif
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;nr_allocs = %d&bslash;nnr_frees = %d&bslash;n&quot;
comma
id|h-&gt;nr_allocs
comma
id|h-&gt;nr_frees
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_FS */
macro_line|#ifdef MODULE
id|MODULE_PARM
c_func
(paren
id|eisa
comma
l_string|&quot;1-8i&quot;
)paren
suffix:semicolon
id|EXPORT_NO_SYMBOLS
suffix:semicolon
multiline_comment|/* This is a bit of a hack... */
DECL|function|init_module
r_int
id|__init
id|init_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|cpqarray_init
c_func
(paren
)paren
op_eq
l_int|0
)paren
multiline_comment|/* all the block dev numbers already used */
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* or no controllers were found */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|gendisk
op_star
id|g
suffix:semicolon
id|remove_proc_entry
c_func
(paren
l_string|&quot;driver/array&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_ctlr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|access
dot
id|set_intr_mask
c_func
(paren
id|hba
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|intr
comma
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
id|iounmap
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|vaddr
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
op_plus
id|i
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|timer
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
op_plus
id|i
)paren
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
comma
id|proc_array
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gendisk_head
op_eq
op_amp
id|ida_gendisk
(braket
id|i
)braket
)paren
(brace
id|gendisk_head
op_assign
id|ida_gendisk
(braket
id|i
)braket
dot
id|next
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|g
op_assign
id|gendisk_head
suffix:semicolon
id|g
suffix:semicolon
id|g
op_assign
id|g-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|g-&gt;next
op_eq
op_amp
id|ida_gendisk
(braket
id|i
)braket
)paren
(brace
id|g-&gt;next
op_assign
id|ida_gendisk
(braket
id|i
)braket
dot
id|next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
id|kfree
c_func
(paren
id|ida
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ida_sizes
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ida_hardsizes
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ida_blocksizes
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; *  This is it.  Find all the controllers and register them.  I really hate&n; *  stealing all these major device numbers.&n; *  returns the number of block devices registered.&n; */
DECL|function|cpqarray_init
r_int
id|__init
id|cpqarray_init
c_func
(paren
r_void
)paren
(brace
r_void
(paren
op_star
id|request_fns
(braket
id|MAX_CTLR
)braket
)paren
(paren
id|request_queue_t
op_star
)paren
op_assign
(brace
id|do_ida_request0
comma
id|do_ida_request1
comma
id|do_ida_request2
comma
id|do_ida_request3
comma
id|do_ida_request4
comma
id|do_ida_request5
comma
id|do_ida_request6
comma
id|do_ida_request7
comma
)brace
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_int
id|num_cntlrs_reg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* detect controllers */
id|cpqarray_pci_detect
c_func
(paren
)paren
suffix:semicolon
id|cpqarray_eisa_detect
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_ctlr
op_eq
l_int|0
)paren
r_return
id|num_cntlrs_reg
suffix:semicolon
id|printk
c_func
(paren
id|DRIVER_NAME
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Found %d controller(s)&bslash;n&quot;
comma
id|nr_ctlr
)paren
suffix:semicolon
multiline_comment|/* allocate space for disk structs */
id|ida
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|hd_struct
)paren
op_star
id|nr_ctlr
op_star
id|NWD
op_star
l_int|16
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ida
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: out of memory&quot;
)paren
suffix:semicolon
r_return
id|num_cntlrs_reg
suffix:semicolon
)brace
id|ida_sizes
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_int
)paren
op_star
id|nr_ctlr
op_star
id|NWD
op_star
l_int|16
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ida_sizes
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|ida
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: out of memory&quot;
)paren
suffix:semicolon
r_return
id|num_cntlrs_reg
suffix:semicolon
)brace
id|ida_blocksizes
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_int
)paren
op_star
id|nr_ctlr
op_star
id|NWD
op_star
l_int|16
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ida_blocksizes
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|ida
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ida_sizes
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: out of memory&quot;
)paren
suffix:semicolon
r_return
id|num_cntlrs_reg
suffix:semicolon
)brace
id|ida_hardsizes
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_int
)paren
op_star
id|nr_ctlr
op_star
id|NWD
op_star
l_int|16
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ida_hardsizes
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|ida
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ida_sizes
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ida_blocksizes
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: out of memory&quot;
)paren
suffix:semicolon
r_return
id|num_cntlrs_reg
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ida
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|hd_struct
)paren
op_star
id|nr_ctlr
op_star
id|NWD
op_star
l_int|16
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ida_sizes
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
id|nr_ctlr
op_star
id|NWD
op_star
l_int|16
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ida_blocksizes
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
id|nr_ctlr
op_star
id|NWD
op_star
l_int|16
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ida_hardsizes
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
id|nr_ctlr
op_star
id|NWD
op_star
l_int|16
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ida_gendisk
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|gendisk
)paren
op_star
id|MAX_CTLR
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * register block devices&n;&t; * Find disks and fill in structs&n;&t; * Get an interrupt, set the Q depth and get into /proc&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_ctlr
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* If this successful it should insure that we are the only */
multiline_comment|/* instance of the driver */
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
op_plus
id|i
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
comma
op_amp
id|ida_fops
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: Unable to get major number %d for ida&bslash;n&quot;
comma
id|MAJOR_NR
op_plus
id|i
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|access
dot
id|set_intr_mask
c_func
(paren
id|hba
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|intr
comma
id|do_ida_intr
comma
id|SA_INTERRUPT
op_or
id|SA_SHIRQ
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
comma
id|hba
(braket
id|i
)braket
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: Unable to get irq %d for %s&bslash;n&quot;
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|intr
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
op_plus
id|i
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|num_cntlrs_reg
op_increment
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
op_assign
(paren
id|cmdlist_t
op_star
)paren
id|kmalloc
c_func
(paren
id|NR_CMDS
op_star
r_sizeof
(paren
id|cmdlist_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
op_assign
(paren
id|__u32
op_star
)paren
id|kmalloc
c_func
(paren
(paren
(paren
id|NR_CMDS
op_plus
l_int|31
)paren
op_div
l_int|32
)paren
op_star
r_sizeof
(paren
id|__u32
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
op_eq
l_int|NULL
op_logical_or
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
op_eq
l_int|NULL
)paren
(brace
id|nr_ctlr
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
)paren
(brace
id|kfree
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
)paren
(brace
id|kfree
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
)paren
suffix:semicolon
)brace
id|free_irq
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|intr
comma
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
op_plus
id|i
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
suffix:semicolon
id|num_cntlrs_reg
op_decrement
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: out of memory&quot;
)paren
suffix:semicolon
multiline_comment|/* If num_cntlrs_reg == 0, no controllers worked. &n;&t;&t;&t; *&t;init_module will fail, so clean up global &n;&t;&t;&t; *&t;memory that clean_module would do.&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|num_cntlrs_reg
op_eq
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|ida
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ida_sizes
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ida_hardsizes
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ida_blocksizes
)paren
suffix:semicolon
)brace
r_return
id|num_cntlrs_reg
suffix:semicolon
)brace
id|memset
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
comma
l_int|0
comma
id|NR_CMDS
op_star
r_sizeof
(paren
id|cmdlist_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
comma
l_int|0
comma
(paren
(paren
id|NR_CMDS
op_plus
l_int|31
)paren
op_div
l_int|32
)paren
op_star
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cpqarray: Finding drives on %s&quot;
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
suffix:semicolon
id|getgeometry
c_func
(paren
id|i
)paren
suffix:semicolon
id|start_fwbk
c_func
(paren
id|i
)paren
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|access
dot
id|set_intr_mask
c_func
(paren
id|hba
(braket
id|i
)braket
comma
id|FIFO_NOT_EMPTY
)paren
suffix:semicolon
id|ida_procinit
c_func
(paren
id|i
)paren
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
op_plus
id|i
)paren
comma
id|request_fns
(braket
id|i
)braket
)paren
suffix:semicolon
id|blk_queue_headactive
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
op_plus
id|i
)paren
comma
l_int|0
)paren
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
op_plus
id|i
)braket
op_assign
id|ida_blocksizes
op_plus
(paren
id|i
op_star
l_int|256
)paren
suffix:semicolon
id|hardsect_size
(braket
id|MAJOR_NR
op_plus
id|i
)braket
op_assign
id|ida_hardsizes
op_plus
(paren
id|i
op_star
l_int|256
)paren
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
op_plus
id|i
)braket
op_assign
id|READ_AHEAD
suffix:semicolon
id|ida_gendisk
(braket
id|i
)braket
dot
id|major
op_assign
id|MAJOR_NR
op_plus
id|i
suffix:semicolon
id|ida_gendisk
(braket
id|i
)braket
dot
id|major_name
op_assign
l_string|&quot;ida&quot;
suffix:semicolon
id|ida_gendisk
(braket
id|i
)braket
dot
id|minor_shift
op_assign
id|NWD_SHIFT
suffix:semicolon
id|ida_gendisk
(braket
id|i
)braket
dot
id|max_p
op_assign
l_int|16
suffix:semicolon
id|ida_gendisk
(braket
id|i
)braket
dot
id|part
op_assign
id|ida
op_plus
(paren
id|i
op_star
l_int|256
)paren
suffix:semicolon
id|ida_gendisk
(braket
id|i
)braket
dot
id|sizes
op_assign
id|ida_sizes
op_plus
(paren
id|i
op_star
l_int|256
)paren
suffix:semicolon
id|ida_gendisk
(braket
id|i
)braket
dot
id|nr_real
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get on the disk list */
id|ida_gendisk
(braket
id|i
)braket
dot
id|next
op_assign
id|gendisk_head
suffix:semicolon
id|gendisk_head
op_assign
op_amp
id|ida_gendisk
(braket
id|i
)braket
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|timer
)paren
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|timer.expires
op_assign
id|jiffies
op_plus
id|IDA_TIMER
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|timer.data
op_assign
(paren
r_int
r_int
)paren
id|hba
(braket
id|i
)braket
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|timer.function
op_assign
id|ida_timer
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|timer
)paren
suffix:semicolon
id|ida_geninit
c_func
(paren
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NWD
suffix:semicolon
id|j
op_increment
)paren
(brace
id|register_disk
c_func
(paren
op_amp
id|ida_gendisk
(braket
id|i
)braket
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
op_plus
id|i
comma
id|j
op_lshift
l_int|4
)paren
comma
l_int|16
comma
op_amp
id|ida_fops
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|drv
(braket
id|j
)braket
dot
id|nr_blks
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* done ! */
r_return
id|num_cntlrs_reg
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the controller and initialize it&n; *  Cannot use the class code to search, because older array controllers use&n; *    0x018000 and new ones use 0x010400.  So I might as well search for each&n; *    each device IDs, being there are only going to be three of them. &n; */
DECL|function|cpqarray_pci_detect
r_static
r_int
id|cpqarray_pci_detect
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
DECL|macro|IDA_BOARD_TYPES
mdefine_line|#define IDA_BOARD_TYPES 3
r_static
r_int
id|ida_vendor_id
(braket
id|IDA_BOARD_TYPES
)braket
op_assign
(brace
id|PCI_VENDOR_ID_DEC
comma
id|PCI_VENDOR_ID_NCR
comma
id|PCI_VENDOR_ID_COMPAQ
)brace
suffix:semicolon
r_static
r_int
id|ida_device_id
(braket
id|IDA_BOARD_TYPES
)braket
op_assign
(brace
id|PCI_DEVICE_ID_COMPAQ_42XX
comma
id|PCI_DEVICE_ID_NCR_53C1510
comma
id|PCI_DEVICE_ID_COMPAQ_SMART2P
)brace
suffix:semicolon
r_int
id|brdtype
suffix:semicolon
multiline_comment|/* search for all PCI board types that could be for this driver */
r_for
c_loop
(paren
id|brdtype
op_assign
l_int|0
suffix:semicolon
id|brdtype
OL
id|IDA_BOARD_TYPES
suffix:semicolon
id|brdtype
op_increment
)paren
(brace
id|pdev
op_assign
id|pci_find_device
c_func
(paren
id|ida_vendor_id
(braket
id|brdtype
)braket
comma
id|ida_device_id
(braket
id|brdtype
)braket
comma
l_int|NULL
)paren
suffix:semicolon
r_while
c_loop
(paren
id|pdev
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cpqarray: Device %x has been found at %x %x&bslash;n&quot;
comma
id|ida_vendor_id
(braket
id|brdtype
)braket
comma
id|pdev-&gt;bus-&gt;number
comma
id|pdev-&gt;devfn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_ctlr
op_eq
l_int|8
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: This driver&quot;
l_string|&quot; supports a maximum of 8 controllers.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* if it is a PCI_DEVICE_ID_NCR_53C1510, make sure it&squot;s &t;&t;&t;&t;the Compaq version of the chip */
r_if
c_cond
(paren
id|ida_device_id
(braket
id|brdtype
)braket
op_eq
id|PCI_DEVICE_ID_NCR_53C1510
)paren
(brace
r_int
r_int
id|subvendor
op_assign
id|pdev-&gt;subsystem_vendor
suffix:semicolon
r_if
c_cond
(paren
id|subvendor
op_ne
id|PCI_VENDOR_ID_COMPAQ
)paren
(brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cpqarray: not a Compaq integrated array controller&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
id|hba
(braket
id|nr_ctlr
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ctlr_info_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hba
(braket
id|nr_ctlr
)braket
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|memset
c_func
(paren
id|hba
(braket
id|nr_ctlr
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|ctlr_info_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cpqarray_pci_init
c_func
(paren
id|hba
(braket
id|nr_ctlr
)braket
comma
id|pdev
)paren
op_ne
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|hba
(braket
id|nr_ctlr
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|hba
(braket
id|nr_ctlr
)braket
op_member_access_from_pointer
id|devname
comma
l_string|&quot;ida%d&quot;
comma
id|nr_ctlr
)paren
suffix:semicolon
id|hba
(braket
id|nr_ctlr
)braket
op_member_access_from_pointer
id|ctlr
op_assign
id|nr_ctlr
suffix:semicolon
id|nr_ctlr
op_increment
suffix:semicolon
id|pdev
op_assign
id|pci_find_device
c_func
(paren
id|ida_vendor_id
(braket
id|brdtype
)braket
comma
id|ida_device_id
(braket
id|brdtype
)braket
comma
id|pdev
)paren
suffix:semicolon
)brace
)brace
r_return
id|nr_ctlr
suffix:semicolon
)brace
multiline_comment|/*&n; * Find the IO address of the controller, its IRQ and so forth.  Fill&n; * in some basic stuff into the ctlr_info_t structure.&n; */
DECL|function|cpqarray_pci_init
r_static
r_int
id|cpqarray_pci_init
c_func
(paren
id|ctlr_info_t
op_star
id|c
comma
r_struct
id|pci_dev
op_star
id|pdev
)paren
(brace
id|ushort
id|vendor_id
comma
id|device_id
comma
id|command
suffix:semicolon
id|unchar
id|cache_line_size
comma
id|latency_timer
suffix:semicolon
id|unchar
id|irq
comma
id|revision
suffix:semicolon
r_int
r_int
id|addr
(braket
l_int|6
)braket
suffix:semicolon
id|__u32
id|board_id
suffix:semicolon
r_int
id|i
suffix:semicolon
id|c-&gt;pci_dev
op_assign
id|pdev
suffix:semicolon
id|vendor_id
op_assign
id|pdev-&gt;vendor
suffix:semicolon
id|device_id
op_assign
id|pdev-&gt;device
suffix:semicolon
id|irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|addr
(braket
id|i
)braket
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
op_amp
id|command
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CACHE_LINE_SIZE
comma
op_amp
id|cache_line_size
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|latency_timer
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
l_int|0x2c
comma
op_amp
id|board_id
)paren
suffix:semicolon
id|DBGINFO
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;vendor_id = %x&bslash;n&quot;
comma
id|vendor_id
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;device_id = %x&bslash;n&quot;
comma
id|device_id
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;command = %x&bslash;n&quot;
comma
id|command
)paren
suffix:semicolon
r_for
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;addr[%d] = %lx&bslash;n&quot;
comma
id|i
comma
id|addr
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;revision = %x&bslash;n&quot;
comma
id|revision
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;irq = %x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cache_line_size = %x&bslash;n&quot;
comma
id|cache_line_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;latency_timer = %x&bslash;n&quot;
comma
id|latency_timer
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;board_id = %x&bslash;n&quot;
comma
id|board_id
)paren
suffix:semicolon
)paren
suffix:semicolon
id|c-&gt;intr
op_assign
id|irq
suffix:semicolon
id|c-&gt;ioaddr
op_assign
id|addr
(braket
l_int|0
)braket
suffix:semicolon
id|c-&gt;paddr
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|pci_resource_flags
c_func
(paren
id|pdev
comma
id|i
)paren
op_amp
id|IORESOURCE_MEM
)paren
(brace
id|c-&gt;paddr
op_assign
id|pci_resource_start
(paren
id|pdev
comma
id|i
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;paddr
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|c-&gt;vaddr
op_assign
id|remap_pci_mem
c_func
(paren
id|c-&gt;paddr
comma
l_int|128
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c-&gt;vaddr
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|c-&gt;board_id
op_assign
id|board_id
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_PRODUCTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|board_id
op_eq
id|products
(braket
id|i
)braket
dot
id|board_id
)paren
(brace
id|c-&gt;product_name
op_assign
id|products
(braket
id|i
)braket
dot
id|product_name
suffix:semicolon
id|c-&gt;access
op_assign
op_star
(paren
id|products
(braket
id|i
)braket
dot
id|access
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|NR_PRODUCTS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Sorry, I don&squot;t know how&quot;
l_string|&quot; to access the SMART Array controller %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|board_id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Map (physical) PCI mem into (virtual) kernel space&n; */
DECL|function|remap_pci_mem
r_static
r_void
op_star
id|remap_pci_mem
c_func
(paren
id|ulong
id|base
comma
id|ulong
id|size
)paren
(brace
id|ulong
id|page_base
op_assign
(paren
(paren
id|ulong
)paren
id|base
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|ulong
id|page_offs
op_assign
(paren
(paren
id|ulong
)paren
id|base
)paren
op_minus
id|page_base
suffix:semicolon
r_void
op_star
id|page_remapped
op_assign
id|ioremap
c_func
(paren
id|page_base
comma
id|page_offs
op_plus
id|size
)paren
suffix:semicolon
r_return
(paren
id|page_remapped
ques
c_cond
(paren
id|page_remapped
op_plus
id|page_offs
)paren
suffix:colon
l_int|NULL
)paren
suffix:semicolon
)brace
macro_line|#ifndef MODULE
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,3,13)
multiline_comment|/*&n; * Config string is a comma seperated set of i/o addresses of EISA cards.&n; */
DECL|function|cpqarray_setup
r_static
r_int
id|cpqarray_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|i
comma
id|ints
(braket
l_int|9
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ints
(braket
l_int|0
)braket
op_logical_and
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|eisa
(braket
id|i
)braket
op_assign
id|ints
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;smart2=&quot;
comma
id|cpqarray_setup
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/*&n; * Copy the contents of the ints[] array passed to us by init.&n; */
DECL|function|cpqarray_setup
r_void
id|cpqarray_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ints
(braket
l_int|0
)braket
op_logical_and
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|eisa
(braket
id|i
)braket
op_assign
id|ints
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n; * Find an EISA controller&squot;s signature.  Set up an hba if we find it.&n; */
DECL|function|cpqarray_eisa_detect
r_static
r_int
id|cpqarray_eisa_detect
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|j
suffix:semicolon
id|__u32
id|board_id
suffix:semicolon
r_int
id|intr
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
l_int|8
op_logical_and
id|eisa
(braket
id|i
)braket
)paren
(brace
r_if
c_cond
(paren
id|nr_ctlr
op_eq
l_int|8
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: This driver supports&quot;
l_string|&quot; a maximum of 8 controllers.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|board_id
op_assign
id|inl
c_func
(paren
id|eisa
(braket
id|i
)braket
op_plus
l_int|0xC80
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NR_PRODUCTS
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|board_id
op_eq
id|products
(braket
id|j
)braket
dot
id|board_id
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|j
op_eq
id|NR_PRODUCTS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Sorry, I don&squot;t know how&quot;
l_string|&quot; to access the SMART Array controller %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|board_id
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|hba
(braket
id|nr_ctlr
)braket
op_assign
(paren
id|ctlr_info_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ctlr_info_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hba
(braket
id|nr_ctlr
)braket
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|memset
c_func
(paren
id|hba
(braket
id|nr_ctlr
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|ctlr_info_t
)paren
)paren
suffix:semicolon
id|hba
(braket
id|nr_ctlr
)braket
op_member_access_from_pointer
id|ioaddr
op_assign
id|eisa
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Read the config register to find our interrupt&n;&t;&t; */
id|intr
op_assign
id|inb
c_func
(paren
id|eisa
(braket
id|i
)braket
op_plus
l_int|0xCC0
)paren
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|intr
op_amp
l_int|1
)paren
id|intr
op_assign
l_int|11
suffix:semicolon
r_else
r_if
c_cond
(paren
id|intr
op_amp
l_int|2
)paren
id|intr
op_assign
l_int|10
suffix:semicolon
r_else
r_if
c_cond
(paren
id|intr
op_amp
l_int|4
)paren
id|intr
op_assign
l_int|14
suffix:semicolon
r_else
r_if
c_cond
(paren
id|intr
op_amp
l_int|8
)paren
id|intr
op_assign
l_int|15
suffix:semicolon
id|hba
(braket
id|nr_ctlr
)braket
op_member_access_from_pointer
id|intr
op_assign
id|intr
suffix:semicolon
id|sprintf
c_func
(paren
id|hba
(braket
id|nr_ctlr
)braket
op_member_access_from_pointer
id|devname
comma
l_string|&quot;ida%d&quot;
comma
id|nr_ctlr
)paren
suffix:semicolon
id|hba
(braket
id|nr_ctlr
)braket
op_member_access_from_pointer
id|product_name
op_assign
id|products
(braket
id|j
)braket
dot
id|product_name
suffix:semicolon
id|hba
(braket
id|nr_ctlr
)braket
op_member_access_from_pointer
id|access
op_assign
op_star
(paren
id|products
(braket
id|j
)braket
dot
id|access
)paren
suffix:semicolon
id|hba
(braket
id|nr_ctlr
)braket
op_member_access_from_pointer
id|ctlr
op_assign
id|nr_ctlr
suffix:semicolon
id|hba
(braket
id|nr_ctlr
)braket
op_member_access_from_pointer
id|board_id
op_assign
id|board_id
suffix:semicolon
id|hba
(braket
id|nr_ctlr
)braket
op_member_access_from_pointer
id|pci_dev
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* not PCI */
id|DBGINFO
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;i = %d, j = %d&bslash;n&quot;
comma
id|i
comma
id|j
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;irq = %x&bslash;n&quot;
comma
id|intr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;product name = %s&bslash;n&quot;
comma
id|products
(braket
id|j
)braket
dot
id|product_name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;board_id = %x&bslash;n&quot;
comma
id|board_id
)paren
suffix:semicolon
)paren
suffix:semicolon
id|nr_ctlr
op_increment
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_return
id|nr_ctlr
suffix:semicolon
)brace
multiline_comment|/*&n; * Open.  Make sure the device is really there.&n; */
DECL|function|ida_open
r_static
r_int
id|ida_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
r_int
id|ctlr
op_assign
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_minus
id|MAJOR_NR
suffix:semicolon
r_int
id|dsk
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
id|NWD_SHIFT
suffix:semicolon
id|DBGINFO
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;ida_open %x (%x:%x)&bslash;n&quot;
comma
id|inode-&gt;i_rdev
comma
id|ctlr
comma
id|dsk
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ctlr
OG
id|MAX_CTLR
op_logical_or
id|hba
(braket
id|ctlr
)braket
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
op_logical_and
id|ida_sizes
(braket
(paren
id|ctlr
op_lshift
id|CTLR_SHIFT
)paren
op_plus
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/*&n;&t; * Root is allowed to open raw volume zero even if its not configured&n;&t; * so array config can still work.  I don&squot;t think I really like this,&n;&t; * but I&squot;m already using way to many device nodes to claim another one&n;&t; * for &quot;raw controller&quot;.&n;&t; */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
op_logical_and
id|ida_sizes
(braket
(paren
id|ctlr
op_lshift
id|CTLR_SHIFT
)paren
op_plus
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
op_eq
l_int|0
op_logical_and
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
dot
id|usage_count
op_increment
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|usage_count
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close.  Sync first.&n; */
DECL|function|ida_release
r_static
r_int
id|ida_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
r_int
id|ctlr
op_assign
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_minus
id|MAJOR_NR
suffix:semicolon
r_int
id|dsk
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
id|NWD_SHIFT
suffix:semicolon
id|DBGINFO
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;ida_release %x (%x:%x)&bslash;n&quot;
comma
id|inode-&gt;i_rdev
comma
id|ctlr
comma
id|dsk
)paren
)paren
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
dot
id|usage_count
op_decrement
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|usage_count
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Enqueuing and dequeuing functions for cmdlists.&n; */
DECL|function|addQ
r_static
r_inline
r_void
id|addQ
c_func
(paren
id|cmdlist_t
op_star
op_star
id|Qptr
comma
id|cmdlist_t
op_star
id|c
)paren
(brace
r_if
c_cond
(paren
op_star
id|Qptr
op_eq
l_int|NULL
)paren
(brace
op_star
id|Qptr
op_assign
id|c
suffix:semicolon
id|c-&gt;next
op_assign
id|c-&gt;prev
op_assign
id|c
suffix:semicolon
)brace
r_else
(brace
id|c-&gt;prev
op_assign
(paren
op_star
id|Qptr
)paren
op_member_access_from_pointer
id|prev
suffix:semicolon
id|c-&gt;next
op_assign
(paren
op_star
id|Qptr
)paren
suffix:semicolon
(paren
op_star
id|Qptr
)paren
op_member_access_from_pointer
id|prev-&gt;next
op_assign
id|c
suffix:semicolon
(paren
op_star
id|Qptr
)paren
op_member_access_from_pointer
id|prev
op_assign
id|c
suffix:semicolon
)brace
)brace
DECL|function|removeQ
r_static
r_inline
id|cmdlist_t
op_star
id|removeQ
c_func
(paren
id|cmdlist_t
op_star
op_star
id|Qptr
comma
id|cmdlist_t
op_star
id|c
)paren
(brace
r_if
c_cond
(paren
id|c
op_logical_and
id|c-&gt;next
op_ne
id|c
)paren
(brace
r_if
c_cond
(paren
op_star
id|Qptr
op_eq
id|c
)paren
op_star
id|Qptr
op_assign
id|c-&gt;next
suffix:semicolon
id|c-&gt;prev-&gt;next
op_assign
id|c-&gt;next
suffix:semicolon
id|c-&gt;next-&gt;prev
op_assign
id|c-&gt;prev
suffix:semicolon
)brace
r_else
(brace
op_star
id|Qptr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
multiline_comment|/*&n; * Get a request and submit it to the controller.&n; * This routine needs to grab all the requests it possibly can from the&n; * req Q and submit them.  Interrupts are off (and need to be off) when you&n; * are in here (either via the dummy do_ida_request functions or by being&n; * called from the interrupt handler&n; */
DECL|function|do_ida_request
r_static
r_void
id|do_ida_request
c_func
(paren
r_int
id|ctlr
)paren
(brace
id|ctlr_info_t
op_star
id|h
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
id|cmdlist_t
op_star
id|c
suffix:semicolon
r_int
id|seg
comma
id|sect
suffix:semicolon
r_char
op_star
id|lastdataend
suffix:semicolon
r_struct
id|list_head
op_star
id|queue_head
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|request
op_star
id|creq
suffix:semicolon
id|queue_head
op_assign
op_amp
id|blk_dev
(braket
id|MAJOR_NR
op_plus
id|ctlr
)braket
dot
id|request_queue.queue_head
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|queue_head
)paren
)paren
(brace
id|start_io
c_func
(paren
id|h
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|creq
op_assign
id|blkdev_entry_next_request
c_func
(paren
id|queue_head
)paren
suffix:semicolon
r_if
c_cond
(paren
id|creq-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
id|start_io
c_func
(paren
id|h
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ctlr
op_ne
id|MAJOR
c_func
(paren
id|creq-&gt;rq_dev
)paren
op_minus
id|MAJOR_NR
op_logical_or
id|ctlr
OG
id|nr_ctlr
op_logical_or
id|h
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;doreq cmd for %d, %x at %p&bslash;n&quot;
comma
id|ctlr
comma
id|creq-&gt;rq_dev
comma
id|creq
)paren
suffix:semicolon
id|complete_buffers
c_func
(paren
id|creq-&gt;bh
comma
l_int|0
)paren
suffix:semicolon
id|start_io
c_func
(paren
id|h
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|c
op_assign
id|cmd_alloc
c_func
(paren
id|h
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|start_io
c_func
(paren
id|h
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|bh
op_assign
id|creq-&gt;bh
suffix:semicolon
id|c-&gt;ctlr
op_assign
id|ctlr
suffix:semicolon
id|c-&gt;hdr.unit
op_assign
id|MINOR
c_func
(paren
id|creq-&gt;rq_dev
)paren
op_rshift
id|NWD_SHIFT
suffix:semicolon
id|c-&gt;hdr.size
op_assign
r_sizeof
(paren
id|rblk_t
)paren
op_rshift
l_int|2
suffix:semicolon
id|c-&gt;size
op_add_assign
r_sizeof
(paren
id|rblk_t
)paren
suffix:semicolon
id|c-&gt;req.hdr.blk
op_assign
id|ida
(braket
(paren
id|ctlr
op_lshift
id|CTLR_SHIFT
)paren
op_plus
id|MINOR
c_func
(paren
id|creq-&gt;rq_dev
)paren
)braket
dot
id|start_sect
op_plus
id|creq-&gt;sector
suffix:semicolon
id|c-&gt;bh
op_assign
id|bh
suffix:semicolon
id|DBGPX
c_func
(paren
r_if
(paren
id|bh
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;bh == NULL?&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sector=%d, nr_sectors=%d&bslash;n&quot;
comma
id|creq-&gt;sector
comma
id|creq-&gt;nr_sectors
)paren
suffix:semicolon
)paren
suffix:semicolon
id|seg
op_assign
l_int|0
suffix:semicolon
id|lastdataend
op_assign
l_int|NULL
suffix:semicolon
id|sect
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|bh
)paren
(brace
id|sect
op_add_assign
id|bh-&gt;b_size
op_div
l_int|512
suffix:semicolon
id|DBGPX
c_func
(paren
r_if
(paren
id|bh-&gt;b_size
op_mod
l_int|512
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Oh damn.  %d+%d, size = %d&bslash;n&quot;
comma
id|creq-&gt;sector
comma
id|sect
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;b_size %% 512 != 0&quot;
)paren
suffix:semicolon
)brace
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_data
op_eq
id|lastdataend
)paren
(brace
id|c-&gt;req.sg
(braket
id|seg
op_minus
l_int|1
)braket
dot
id|size
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
id|lastdataend
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
)brace
r_else
(brace
id|c-&gt;req.sg
(braket
id|seg
)braket
dot
id|size
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|c-&gt;req.sg
(braket
id|seg
)braket
dot
id|addr
op_assign
(paren
id|__u32
)paren
id|virt_to_bus
c_func
(paren
id|bh-&gt;b_data
)paren
suffix:semicolon
id|lastdataend
op_assign
id|bh-&gt;b_data
op_plus
id|bh-&gt;b_size
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|seg
op_eq
id|SG_MAX
)paren
r_break
suffix:semicolon
)brace
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
id|DBGPX
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;Submitting %d sectors in %d segments&bslash;n&quot;
comma
id|sect
comma
id|seg
)paren
suffix:semicolon
)paren
suffix:semicolon
id|c-&gt;req.hdr.sg_cnt
op_assign
id|seg
suffix:semicolon
id|c-&gt;req.hdr.blk_cnt
op_assign
id|sect
suffix:semicolon
id|creq-&gt;sector
op_add_assign
id|sect
suffix:semicolon
id|creq-&gt;nr_sectors
op_sub_assign
id|sect
suffix:semicolon
multiline_comment|/* Ready the next request:&n;&t; * Fix up creq if we still have more buffers in the buffer chain, or&n;&t; * mark this request as done and ready the next one.&n;         */
r_if
c_cond
(paren
id|creq-&gt;nr_sectors
)paren
(brace
id|DBGPX
c_func
(paren
r_if
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sector=%d, nr_sectors=%d, sect=%d, seg=%d&bslash;n&quot;
comma
id|creq-&gt;sector
comma
id|creq-&gt;nr_sectors
comma
id|sect
comma
id|seg
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;mother...&quot;
)paren
suffix:semicolon
)brace
)paren
suffix:semicolon
id|creq-&gt;bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|DBGPX
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;More to do on same request %p&bslash;n&quot;
comma
id|creq
)paren
suffix:semicolon
)paren
suffix:semicolon
)brace
r_else
(brace
id|DBGPX
c_func
(paren
id|printk
c_func
(paren
l_string|&quot;Done with %p&bslash;n&quot;
comma
id|creq
)paren
suffix:semicolon
)paren
suffix:semicolon
id|blkdev_dequeue_request
c_func
(paren
id|creq
)paren
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|creq
)paren
suffix:semicolon
)brace
id|c-&gt;req.hdr.cmd
op_assign
(paren
id|creq-&gt;cmd
op_eq
id|READ
)paren
ques
c_cond
id|IDA_READ
suffix:colon
id|IDA_WRITE
suffix:semicolon
id|c-&gt;type
op_assign
id|CMD_RWREQ
suffix:semicolon
multiline_comment|/* Put the request on the tail of the request queue */
id|addQ
c_func
(paren
op_amp
id|h-&gt;reqQ
comma
id|c
)paren
suffix:semicolon
id|h-&gt;Qdepth
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|h-&gt;Qdepth
OG
id|h-&gt;maxQsinceinit
)paren
id|h-&gt;maxQsinceinit
op_assign
id|h-&gt;Qdepth
suffix:semicolon
id|start_io
c_func
(paren
id|h
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * start_io submits everything on a controller&squot;s request queue&n; * and moves it to the completion queue.&n; *&n; * Interrupts had better be off if you&squot;re in here&n; */
DECL|function|start_io
r_static
r_void
id|start_io
c_func
(paren
id|ctlr_info_t
op_star
id|h
)paren
(brace
id|cmdlist_t
op_star
id|c
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
id|h-&gt;reqQ
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Can&squot;t do anything if we&squot;re busy */
r_if
c_cond
(paren
id|h-&gt;access
dot
id|fifo_full
c_func
(paren
id|h
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* Get the first entry from the request Q */
id|removeQ
c_func
(paren
op_amp
id|h-&gt;reqQ
comma
id|c
)paren
suffix:semicolon
id|h-&gt;Qdepth
op_decrement
suffix:semicolon
multiline_comment|/* Tell the controller to do our bidding */
id|h-&gt;access
dot
id|submit_command
c_func
(paren
id|h
comma
id|c
)paren
suffix:semicolon
multiline_comment|/* Get onto the completion Q */
id|addQ
c_func
(paren
op_amp
id|h-&gt;cmpQ
comma
id|c
)paren
suffix:semicolon
)brace
)brace
DECL|function|complete_buffers
r_static
r_inline
r_void
id|complete_buffers
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|ok
)paren
(brace
r_struct
id|buffer_head
op_star
id|xbh
suffix:semicolon
r_while
c_loop
(paren
id|bh
)paren
(brace
id|xbh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|bh
comma
id|ok
)paren
suffix:semicolon
id|bh
op_assign
id|xbh
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Mark all buffers that cmd was responsible for&n; */
DECL|function|complete_command
r_static
r_inline
r_void
id|complete_command
c_func
(paren
id|cmdlist_t
op_star
id|cmd
comma
r_int
id|timeout
)paren
(brace
r_int
id|ok
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;req.hdr.rcode
op_amp
id|RCODE_NONFATAL
op_logical_and
(paren
id|hba
(braket
id|cmd-&gt;ctlr
)braket
op_member_access_from_pointer
id|misc_tflags
op_amp
id|MISC_NONFATAL_WARN
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Non Fatal error on ida/c%dd%d&bslash;n&quot;
comma
id|cmd-&gt;ctlr
comma
id|cmd-&gt;hdr.unit
)paren
suffix:semicolon
id|hba
(braket
id|cmd-&gt;ctlr
)braket
op_member_access_from_pointer
id|misc_tflags
op_or_assign
id|MISC_NONFATAL_WARN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd-&gt;req.hdr.rcode
op_amp
id|RCODE_FATAL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Fatal error on ida/c%dd%d&bslash;n&quot;
comma
id|cmd-&gt;ctlr
comma
id|cmd-&gt;hdr.unit
)paren
suffix:semicolon
id|ok
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd-&gt;req.hdr.rcode
op_amp
id|RCODE_INVREQ
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Invalid request on ida/c%dd%d = (cmd=%x sect=%d cnt=%d sg=%d ret=%x)&bslash;n&quot;
comma
id|cmd-&gt;ctlr
comma
id|cmd-&gt;hdr.unit
comma
id|cmd-&gt;req.hdr.cmd
comma
id|cmd-&gt;req.hdr.blk
comma
id|cmd-&gt;req.hdr.blk_cnt
comma
id|cmd-&gt;req.hdr.sg_cnt
comma
id|cmd-&gt;req.hdr.rcode
)paren
suffix:semicolon
id|ok
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|timeout
)paren
id|ok
op_assign
l_int|0
suffix:semicolon
id|complete_buffers
c_func
(paren
id|cmd-&gt;bh
comma
id|ok
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  The controller will interrupt us upon completion of commands.&n; *  Find the command on the completion queue, remove it, tell the OS and&n; *  try to queue up more IO&n; */
DECL|function|do_ida_intr
r_static
r_void
id|do_ida_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|ctlr_info_t
op_star
id|h
op_assign
id|dev_id
suffix:semicolon
id|cmdlist_t
op_star
id|c
suffix:semicolon
r_int
r_int
id|istat
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|__u32
id|a
comma
id|a1
suffix:semicolon
id|istat
op_assign
id|h-&gt;access
dot
id|intr_pending
c_func
(paren
id|h
)paren
suffix:semicolon
multiline_comment|/* Is this interrupt for us? */
r_if
c_cond
(paren
id|istat
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If there are completed commands in the completion queue,&n;&t; * we had better do something about it.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|istat
op_amp
id|FIFO_NOT_EMPTY
)paren
(brace
r_while
c_loop
(paren
(paren
id|a
op_assign
id|h-&gt;access
dot
id|command_completed
c_func
(paren
id|h
)paren
)paren
)paren
(brace
id|a1
op_assign
id|a
suffix:semicolon
id|a
op_and_assign
op_complement
l_int|3
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_assign
id|h-&gt;cmpQ
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Completion of %08lx ignored&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|a1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c-&gt;busaddr
op_ne
id|a
)paren
(brace
id|c
op_assign
id|c-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|h-&gt;cmpQ
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we&squot;ve found the command, take it off the&n;&t;&t;&t; * completion Q and free it&n;&t;&t;&t; */
r_if
c_cond
(paren
id|c-&gt;busaddr
op_eq
id|a
)paren
(brace
id|removeQ
c_func
(paren
op_amp
id|h-&gt;cmpQ
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;type
op_eq
id|CMD_RWREQ
)paren
(brace
id|complete_command
c_func
(paren
id|c
comma
l_int|0
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|h
comma
id|c
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c-&gt;type
op_eq
id|CMD_IOCTL_PEND
)paren
(brace
id|c-&gt;type
op_assign
id|CMD_IOCTL_DONE
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * See if we can queue up some more IO&n;&t; */
id|do_ida_request
c_func
(paren
id|h-&gt;ctlr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This timer was for timing out requests that haven&squot;t happened after&n; * IDA_TIMEOUT.  That wasn&squot;t such a good idea.  This timer is used to&n; * reset a flags structure so we don&squot;t flood the user with&n; * &quot;Non-Fatal error&quot; messages.&n; */
DECL|function|ida_timer
r_static
r_void
id|ida_timer
c_func
(paren
r_int
r_int
id|tdata
)paren
(brace
id|ctlr_info_t
op_star
id|h
op_assign
(paren
id|ctlr_info_t
op_star
)paren
id|tdata
suffix:semicolon
id|h-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|IDA_TIMER
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|h-&gt;timer
)paren
suffix:semicolon
id|h-&gt;misc_tflags
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *  ida_ioctl does some miscellaneous stuff like reporting drive geometry,&n; *  setting readahead and submitting commands from userspace to the controller.&n; */
DECL|function|ida_ioctl
r_static
r_int
id|ida_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|ctlr
op_assign
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_minus
id|MAJOR_NR
suffix:semicolon
r_int
id|dsk
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
id|NWD_SHIFT
suffix:semicolon
r_int
id|error
suffix:semicolon
r_int
id|diskinfo
(braket
l_int|4
)braket
suffix:semicolon
r_struct
id|hd_geometry
op_star
id|geo
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
id|ida_ioctl_t
op_star
id|io
op_assign
(paren
id|ida_ioctl_t
op_star
)paren
id|arg
suffix:semicolon
id|ida_ioctl_t
id|my_io
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
r_if
c_cond
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
dot
id|cylinders
)paren
(brace
id|diskinfo
(braket
l_int|0
)braket
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
dot
id|heads
suffix:semicolon
id|diskinfo
(braket
l_int|1
)braket
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
dot
id|sectors
suffix:semicolon
id|diskinfo
(braket
l_int|2
)braket
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
dot
id|cylinders
suffix:semicolon
)brace
r_else
(brace
id|diskinfo
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
id|diskinfo
(braket
l_int|1
)braket
op_assign
l_int|0x3f
suffix:semicolon
id|diskinfo
(braket
l_int|2
)braket
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
dot
id|nr_blks
op_div
(paren
l_int|0xff
op_star
l_int|0x3f
)paren
suffix:semicolon
)brace
id|put_user
c_func
(paren
id|diskinfo
(braket
l_int|0
)braket
comma
op_amp
id|geo-&gt;heads
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|diskinfo
(braket
l_int|1
)braket
comma
op_amp
id|geo-&gt;sectors
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|diskinfo
(braket
l_int|2
)braket
comma
op_amp
id|geo-&gt;cylinders
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|ida
(braket
(paren
id|ctlr
op_lshift
id|CTLR_SHIFT
)paren
op_plus
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|start_sect
comma
op_amp
id|geo-&gt;start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|IDAGETDRVINFO
suffix:colon
r_return
id|copy_to_user
c_func
(paren
op_amp
id|io-&gt;c.drv
comma
op_amp
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
comma
r_sizeof
(paren
id|drv_info_t
)paren
)paren
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|put_user
c_func
(paren
id|ida
(braket
(paren
id|ctlr
op_lshift
id|CTLR_SHIFT
)paren
op_plus
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|nr_sects
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRRPART
suffix:colon
r_return
id|revalidate_logvol
c_func
(paren
id|inode-&gt;i_rdev
comma
l_int|1
)paren
suffix:semicolon
r_case
id|IDAPASSTHRU
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|error
op_assign
id|copy_from_user
c_func
(paren
op_amp
id|my_io
comma
id|io
comma
r_sizeof
(paren
id|my_io
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|ida_ctlr_ioctl
c_func
(paren
id|ctlr
comma
id|dsk
comma
op_amp
id|my_io
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
)paren
r_return
id|error
suffix:semicolon
id|error
op_assign
id|copy_to_user
c_func
(paren
id|io
comma
op_amp
id|my_io
comma
r_sizeof
(paren
id|my_io
)paren
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
r_case
id|IDAGETCTLRSIG
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|put_user
c_func
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|ctlr_sig
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|IDAREVALIDATEVOLS
suffix:colon
r_return
id|revalidate_allvol
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_case
id|IDADRIVERVERSION
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|put_user
c_func
(paren
id|DRIVER_VERSION
comma
(paren
r_int
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|IDAGETPCIINFO
suffix:colon
(brace
id|ida_pci_info_struct
id|pciinfo
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pciinfo.bus
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|pci_dev-&gt;bus-&gt;number
suffix:semicolon
id|pciinfo.dev_fn
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|pci_dev-&gt;devfn
suffix:semicolon
id|pciinfo.board_id
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|board_id
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|pciinfo
comma
r_sizeof
(paren
id|ida_pci_info_struct
)paren
)paren
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|BLKFLSBUF
suffix:colon
r_case
id|BLKROSET
suffix:colon
r_case
id|BLKROGET
suffix:colon
r_case
id|BLKRASET
suffix:colon
r_case
id|BLKRAGET
suffix:colon
r_case
id|BLKPG
suffix:colon
r_return
id|blk_ioctl
c_func
(paren
id|inode-&gt;i_rdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * ida_ctlr_ioctl is for passing commands to the controller from userspace.&n; * The command block (io) has already been copied to kernel space for us,&n; * however, any elements in the sglist need to be copied to kernel space&n; * or copied back to userspace.&n; *&n; * Only root may perform a controller passthru command, however I&squot;m not doing&n; * any serious sanity checking on the arguments.  Doing an IDA_WRITE_MEDIA and&n; * putting a 64M buffer in the sglist is probably a *bad* idea.&n; */
DECL|function|ida_ctlr_ioctl
r_static
r_int
id|ida_ctlr_ioctl
c_func
(paren
r_int
id|ctlr
comma
r_int
id|dsk
comma
id|ida_ioctl_t
op_star
id|io
)paren
(brace
id|ctlr_info_t
op_star
id|h
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
id|cmdlist_t
op_star
id|c
suffix:semicolon
r_void
op_star
id|p
op_assign
l_int|NULL
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|error
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_assign
id|cmd_alloc
c_func
(paren
l_int|NULL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|c-&gt;ctlr
op_assign
id|ctlr
suffix:semicolon
id|c-&gt;hdr.unit
op_assign
(paren
id|io-&gt;unit
op_amp
id|UNITVALID
)paren
ques
c_cond
(paren
id|io-&gt;unit
op_amp
op_complement
id|UNITVALID
)paren
suffix:colon
id|dsk
suffix:semicolon
id|c-&gt;hdr.size
op_assign
r_sizeof
(paren
id|rblk_t
)paren
op_rshift
l_int|2
suffix:semicolon
id|c-&gt;size
op_add_assign
r_sizeof
(paren
id|rblk_t
)paren
suffix:semicolon
id|c-&gt;req.hdr.cmd
op_assign
id|io-&gt;cmd
suffix:semicolon
id|c-&gt;req.hdr.blk
op_assign
id|io-&gt;blk
suffix:semicolon
id|c-&gt;req.hdr.blk_cnt
op_assign
id|io-&gt;blk_cnt
suffix:semicolon
id|c-&gt;type
op_assign
id|CMD_IOCTL_PEND
suffix:semicolon
multiline_comment|/* Pre submit processing */
r_switch
c_cond
(paren
id|io-&gt;cmd
)paren
(brace
r_case
id|PASSTHRU_A
suffix:colon
id|p
op_assign
id|kmalloc
c_func
(paren
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|cmd_free
c_func
(paren
l_int|NULL
comma
id|c
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|copy_from_user
c_func
(paren
id|p
comma
(paren
r_void
op_star
)paren
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|addr
comma
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
)paren
suffix:semicolon
id|c-&gt;req.hdr.blk
op_assign
id|virt_to_bus
c_func
(paren
op_amp
(paren
id|io-&gt;c
)paren
)paren
suffix:semicolon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
op_assign
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|virt_to_bus
c_func
(paren
id|p
)paren
suffix:semicolon
id|c-&gt;req.hdr.sg_cnt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IDA_READ
suffix:colon
id|p
op_assign
id|kmalloc
c_func
(paren
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|cmd_free
c_func
(paren
l_int|NULL
comma
id|c
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
op_assign
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|virt_to_bus
c_func
(paren
id|p
)paren
suffix:semicolon
id|c-&gt;req.hdr.sg_cnt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IDA_WRITE
suffix:colon
r_case
id|IDA_WRITE_MEDIA
suffix:colon
r_case
id|DIAG_PASS_THRU
suffix:colon
id|p
op_assign
id|kmalloc
c_func
(paren
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
(brace
id|error
op_assign
op_minus
id|ENOMEM
suffix:semicolon
id|cmd_free
c_func
(paren
l_int|NULL
comma
id|c
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
id|copy_from_user
c_func
(paren
id|p
comma
(paren
r_void
op_star
)paren
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|addr
comma
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
)paren
suffix:semicolon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
op_assign
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
suffix:semicolon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|virt_to_bus
c_func
(paren
id|p
)paren
suffix:semicolon
id|c-&gt;req.hdr.sg_cnt
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
op_assign
r_sizeof
(paren
id|io-&gt;c
)paren
suffix:semicolon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|addr
op_assign
id|virt_to_bus
c_func
(paren
op_amp
id|io-&gt;c
)paren
suffix:semicolon
id|c-&gt;req.hdr.sg_cnt
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Put the request on the tail of the request queue */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|addQ
c_func
(paren
op_amp
id|h-&gt;reqQ
comma
id|c
)paren
suffix:semicolon
id|h-&gt;Qdepth
op_increment
suffix:semicolon
id|start_io
c_func
(paren
id|h
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Wait for completion */
r_while
c_loop
(paren
id|c-&gt;type
op_ne
id|CMD_IOCTL_DONE
)paren
(brace
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Post submit processing */
r_switch
c_cond
(paren
id|io-&gt;cmd
)paren
(brace
r_case
id|PASSTHRU_A
suffix:colon
r_case
id|IDA_READ
suffix:colon
r_case
id|DIAG_PASS_THRU
suffix:colon
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|addr
comma
id|p
comma
id|io-&gt;sg
(braket
l_int|0
)braket
dot
id|size
)paren
suffix:semicolon
multiline_comment|/* fall through and free p */
r_case
id|IDA_WRITE
suffix:colon
r_case
id|IDA_WRITE_MEDIA
suffix:colon
id|kfree
c_func
(paren
id|p
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* Nothing to do */
)brace
id|io-&gt;rcode
op_assign
id|c-&gt;req.hdr.rcode
suffix:semicolon
id|cmd_free
c_func
(paren
l_int|NULL
comma
id|c
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Commands are pre-allocated in a large block.  Here we use a simple bitmap&n; * scheme to suballocte them to the driver.  Operations that are not time&n; * critical (and can wait for kmalloc and possibly sleep) can pass in NULL&n; * as the first argument to get a new command.&n; */
DECL|function|cmd_alloc
r_static
id|cmdlist_t
op_star
id|cmd_alloc
c_func
(paren
id|ctlr_info_t
op_star
id|h
)paren
(brace
id|cmdlist_t
op_star
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|h
op_eq
l_int|NULL
)paren
(brace
id|c
op_assign
(paren
id|cmdlist_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|cmdlist_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
r_do
(brace
id|i
op_assign
id|find_first_zero_bit
c_func
(paren
id|h-&gt;cmd_pool_bits
comma
id|NR_CMDS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|NR_CMDS
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|test_and_set_bit
c_func
(paren
id|i
op_mod
l_int|32
comma
id|h-&gt;cmd_pool_bits
op_plus
(paren
id|i
op_div
l_int|32
)paren
)paren
op_ne
l_int|0
)paren
(brace
suffix:semicolon
)brace
id|c
op_assign
id|h-&gt;cmd_pool
op_plus
id|i
suffix:semicolon
id|h-&gt;nr_allocs
op_increment
suffix:semicolon
)brace
id|memset
c_func
(paren
id|c
comma
l_int|0
comma
r_sizeof
(paren
id|cmdlist_t
)paren
)paren
suffix:semicolon
id|c-&gt;busaddr
op_assign
id|virt_to_bus
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
DECL|function|cmd_free
r_static
r_void
id|cmd_free
c_func
(paren
id|ctlr_info_t
op_star
id|h
comma
id|cmdlist_t
op_star
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|h
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_else
(brace
id|i
op_assign
id|c
op_minus
id|h-&gt;cmd_pool
suffix:semicolon
id|clear_bit
c_func
(paren
id|i
op_mod
l_int|32
comma
id|h-&gt;cmd_pool_bits
op_plus
(paren
id|i
op_div
l_int|32
)paren
)paren
suffix:semicolon
id|h-&gt;nr_frees
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/***********************************************************************&n;    name:        sendcmd&n;    Send a command to an IDA using the memory mapped FIFO interface&n;    and wait for it to complete.  &n;    This routine should only be called at init time.&n;***********************************************************************/
DECL|function|sendcmd
r_static
r_int
id|sendcmd
c_func
(paren
id|__u8
id|cmd
comma
r_int
id|ctlr
comma
r_void
op_star
id|buff
comma
r_int
id|size
comma
r_int
r_int
id|blk
comma
r_int
r_int
id|blkcnt
comma
r_int
r_int
id|log_unit
)paren
(brace
id|cmdlist_t
op_star
id|c
suffix:semicolon
r_int
id|complete
suffix:semicolon
r_int
r_int
id|temp
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
id|ctlr_info_t
op_star
id|info_p
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
id|c
op_assign
id|cmd_alloc
c_func
(paren
id|info_p
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
(brace
r_return
id|IO_ERROR
suffix:semicolon
)brace
id|c-&gt;ctlr
op_assign
id|ctlr
suffix:semicolon
id|c-&gt;hdr.unit
op_assign
id|log_unit
suffix:semicolon
id|c-&gt;hdr.prio
op_assign
l_int|0
suffix:semicolon
id|c-&gt;hdr.size
op_assign
r_sizeof
(paren
id|rblk_t
)paren
op_rshift
l_int|2
suffix:semicolon
id|c-&gt;size
op_add_assign
r_sizeof
(paren
id|rblk_t
)paren
suffix:semicolon
multiline_comment|/* The request information. */
id|c-&gt;req.hdr.next
op_assign
l_int|0
suffix:semicolon
id|c-&gt;req.hdr.rcode
op_assign
l_int|0
suffix:semicolon
id|c-&gt;req.bp
op_assign
l_int|0
suffix:semicolon
id|c-&gt;req.hdr.sg_cnt
op_assign
l_int|1
suffix:semicolon
id|c-&gt;req.hdr.reserved
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|size
op_eq
l_int|0
)paren
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
op_assign
l_int|512
suffix:semicolon
r_else
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|size
op_assign
id|size
suffix:semicolon
id|c-&gt;req.hdr.blk
op_assign
id|blk
suffix:semicolon
id|c-&gt;req.hdr.blk_cnt
op_assign
id|blkcnt
suffix:semicolon
id|c-&gt;req.hdr.cmd
op_assign
(paren
r_int
r_char
)paren
id|cmd
suffix:semicolon
id|c-&gt;req.sg
(braket
l_int|0
)braket
dot
id|addr
op_assign
(paren
id|__u32
)paren
id|virt_to_bus
c_func
(paren
id|buff
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Disable interrupt&n;&t; */
id|info_p-&gt;access
dot
id|set_intr_mask
c_func
(paren
id|info_p
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Make sure there is room in the command FIFO */
multiline_comment|/* Actually it should be completely empty at this time. */
r_for
c_loop
(paren
id|i
op_assign
l_int|200000
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|temp
op_assign
id|info_p-&gt;access
dot
id|fifo_full
c_func
(paren
id|info_p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp
op_ne
l_int|0
)paren
(brace
r_break
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|DBG
c_func
(paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray ida%d: idaSendPciCmd FIFO full,&quot;
l_string|&quot; waiting!&bslash;n&quot;
comma
id|ctlr
)paren
suffix:semicolon
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Send the cmd&n;&t; */
id|info_p-&gt;access
dot
id|submit_command
c_func
(paren
id|info_p
comma
id|c
)paren
suffix:semicolon
id|complete
op_assign
id|pollcomplete
c_func
(paren
id|ctlr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|complete
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|complete
op_ne
id|c-&gt;busaddr
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray ida%d: idaSendPciCmd &quot;
l_string|&quot;Invalid command list address returned! (%08lx)&bslash;n&quot;
comma
id|ctlr
comma
(paren
r_int
r_int
)paren
id|complete
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|info_p
comma
id|c
)paren
suffix:semicolon
r_return
(paren
id|IO_ERROR
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray ida%d: idaSendPciCmd Timeout out, &quot;
l_string|&quot;No command list address returned!&bslash;n&quot;
comma
id|ctlr
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|info_p
comma
id|c
)paren
suffix:semicolon
r_return
(paren
id|IO_ERROR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|c-&gt;req.hdr.rcode
op_amp
l_int|0x00FE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|c-&gt;req.hdr.rcode
op_amp
id|BIG_PROBLEM
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray ida%d: idaSendPciCmd, error: &quot;
l_string|&quot;Controller failed at init time &quot;
l_string|&quot;cmd: 0x%x, return code = 0x%x&bslash;n&quot;
comma
id|ctlr
comma
id|c-&gt;req.hdr.cmd
comma
id|c-&gt;req.hdr.rcode
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|info_p
comma
id|c
)paren
suffix:semicolon
r_return
(paren
id|IO_ERROR
)paren
suffix:semicolon
)brace
)brace
id|cmd_free
c_func
(paren
id|info_p
comma
id|c
)paren
suffix:semicolon
r_return
(paren
id|IO_OK
)paren
suffix:semicolon
)brace
DECL|function|frevalidate_logvol
r_static
r_int
id|frevalidate_logvol
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_return
id|revalidate_logvol
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * revalidate_allvol is for online array config utilities.  After a&n; * utility reconfigures the drives in the array, it can use this function&n; * (through an ioctl) to make the driver zap any previous disk structs for&n; * that controller and get new ones.&n; *&n; * Right now I&squot;m using the getgeometry() function to do this, but this&n; * function should probably be finer grained and allow you to revalidate one&n; * particualar logical volume (instead of all of them on a particular&n; * controller).&n; */
DECL|function|revalidate_allvol
r_static
r_int
id|revalidate_allvol
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|ctlr
comma
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ctlr
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
op_minus
id|MAJOR_NR
suffix:semicolon
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|dev
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|usage_count
OG
l_int|1
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Device busy for volume&quot;
l_string|&quot; revalidation (usage=%d)&bslash;n&quot;
comma
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|usage_count
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|usage_count
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Set the partition and block size structures for all volumes&n;&t; * on this controller to zero.  We will reread all of this data&n;&t; */
id|memset
c_func
(paren
id|ida
op_plus
(paren
id|ctlr
op_star
l_int|256
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|hd_struct
)paren
op_star
id|NWD
op_star
l_int|16
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ida_sizes
op_plus
(paren
id|ctlr
op_star
l_int|256
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
id|NWD
op_star
l_int|16
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ida_blocksizes
op_plus
(paren
id|ctlr
op_star
l_int|256
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
id|NWD
op_star
l_int|16
)paren
suffix:semicolon
id|memset
c_func
(paren
id|ida_hardsizes
op_plus
(paren
id|ctlr
op_star
l_int|256
)paren
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
id|NWD
op_star
l_int|16
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
comma
l_int|0
comma
r_sizeof
(paren
id|drv_info_t
)paren
op_star
id|NWD
)paren
suffix:semicolon
id|ida_gendisk
(braket
id|ctlr
)braket
dot
id|nr_real
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Tell the array controller not to give us any interupts while&n;&t; * we check the new geometry.  Then turn interrupts back on when&n;&t; * we&squot;re done.&n;&t; */
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|access
dot
id|set_intr_mask
c_func
(paren
id|hba
(braket
id|ctlr
)braket
comma
l_int|0
)paren
suffix:semicolon
id|getgeometry
c_func
(paren
id|ctlr
)paren
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|access
dot
id|set_intr_mask
c_func
(paren
id|hba
(braket
id|ctlr
)braket
comma
id|FIFO_NOT_EMPTY
)paren
suffix:semicolon
id|ida_geninit
c_func
(paren
id|ctlr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NWD
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ida_sizes
(braket
(paren
id|ctlr
op_lshift
id|CTLR_SHIFT
)paren
op_plus
(paren
id|i
op_lshift
id|NWD_SHIFT
)paren
)braket
)paren
id|revalidate_logvol
c_func
(paren
id|dev
op_plus
(paren
id|i
op_lshift
id|NWD_SHIFT
)paren
comma
l_int|2
)paren
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|usage_count
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Borrowed and adapted from sd.c */
DECL|function|revalidate_logvol
r_static
r_int
id|revalidate_logvol
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|maxusage
)paren
(brace
r_int
id|ctlr
comma
id|target
suffix:semicolon
r_struct
id|gendisk
op_star
id|gdev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|max_p
suffix:semicolon
r_int
id|start
suffix:semicolon
r_int
id|i
suffix:semicolon
id|target
op_assign
id|DEVICE_NR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ctlr
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
op_minus
id|MAJOR_NR
suffix:semicolon
id|gdev
op_assign
op_amp
id|ida_gendisk
(braket
id|ctlr
)braket
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|target
)braket
dot
id|usage_count
OG
id|maxusage
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Device busy for &quot;
l_string|&quot;revalidation (usage=%d)&bslash;n&quot;
comma
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|target
)braket
dot
id|usage_count
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|target
)braket
dot
id|usage_count
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|max_p
op_assign
id|gdev-&gt;max_p
suffix:semicolon
id|start
op_assign
id|target
op_lshift
id|gdev-&gt;minor_shift
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|max_p
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|minor
op_assign
id|start
op_plus
id|i
suffix:semicolon
id|kdev_t
id|devi
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
op_plus
id|ctlr
comma
id|minor
)paren
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|get_super
c_func
(paren
id|devi
)paren
suffix:semicolon
id|sync_dev
c_func
(paren
id|devi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
)paren
id|invalidate_inodes
c_func
(paren
id|sb
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|devi
)paren
suffix:semicolon
id|gdev-&gt;part
(braket
id|minor
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|gdev-&gt;part
(braket
id|minor
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset the blocksize so we can read the partition table */
id|blksize_size
(braket
id|MAJOR_NR
op_plus
id|ctlr
)braket
(braket
id|minor
)braket
op_assign
l_int|1024
suffix:semicolon
)brace
multiline_comment|/* 16 minors per disk... */
id|grok_partitions
c_func
(paren
id|gdev
comma
id|target
comma
l_int|16
comma
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|target
)braket
dot
id|nr_blks
)paren
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|target
)braket
dot
id|usage_count
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/********************************************************************&n;    name: pollcomplete&n;    Wait polling for a command to complete.&n;    The memory mapped FIFO is polled for the completion.&n;    Used only at init time, interrupts disabled.&n; ********************************************************************/
DECL|function|pollcomplete
r_static
r_int
id|pollcomplete
c_func
(paren
r_int
id|ctlr
)paren
(brace
r_int
id|done
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Wait (up to 2 seconds) for a command to complete */
r_for
c_loop
(paren
id|i
op_assign
l_int|200000
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|done
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|access
dot
id|command_completed
c_func
(paren
id|hba
(braket
id|ctlr
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
op_eq
l_int|0
)paren
(brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* a short fixed delay */
)brace
r_else
r_return
(paren
id|done
)paren
suffix:semicolon
)brace
multiline_comment|/* Invalid address to tell caller we ran out of time */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*****************************************************************&n;    start_fwbk&n;    Starts controller firmwares background processing. &n;    Currently only the Integrated Raid controller needs this done.&n;    If the PCI mem address registers are written to after this, &n;&t; data corruption may occur&n;*****************************************************************/
DECL|function|start_fwbk
r_static
r_void
id|start_fwbk
c_func
(paren
r_int
id|ctlr
)paren
(brace
id|id_ctlr_t
op_star
id|id_ctlr_buf
suffix:semicolon
r_int
id|ret_code
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|board_id
op_ne
l_int|0x40400E11
)paren
op_logical_and
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|board_id
op_ne
l_int|0x40480E11
)paren
)paren
(brace
multiline_comment|/* Not a Integrated Raid, so there is nothing for us to do */
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cpqarray: Starting firmware&squot;s background&quot;
l_string|&quot; processing&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Command does not return anything, but idasend command needs a &n;&t;&t;buffer */
id|id_ctlr_buf
op_assign
(paren
id|id_ctlr_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|id_ctlr_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id_ctlr_buf
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Out of memory. &quot;
l_string|&quot;Unable to start background processing.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ret_code
op_assign
id|sendcmd
c_func
(paren
id|RESUME_BACKGROUND_ACTIVITY
comma
id|ctlr
comma
id|id_ctlr_buf
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_code
op_ne
id|IO_OK
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Unable to start&quot;
l_string|&quot; background processing&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|id_ctlr_buf
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************&n;    getgeometry&n;    Get ida logical volume geometry from the controller &n;    This is a large bit of code which once existed in two flavors,&n;    It is used only at init time.&n;*****************************************************************/
DECL|function|getgeometry
r_static
r_void
id|getgeometry
c_func
(paren
r_int
id|ctlr
)paren
(brace
id|id_log_drv_t
op_star
id|id_ldrive
suffix:semicolon
id|id_ctlr_t
op_star
id|id_ctlr_buf
suffix:semicolon
id|sense_log_drv_stat_t
op_star
id|id_lstatus_buf
suffix:semicolon
id|config_t
op_star
id|sense_config_buf
suffix:semicolon
r_int
r_int
id|log_unit
comma
id|log_index
suffix:semicolon
r_int
id|ret_code
comma
id|size
suffix:semicolon
id|drv_info_t
op_star
id|drv
suffix:semicolon
id|ctlr_info_t
op_star
id|info_p
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|info_p-&gt;log_drv_map
op_assign
l_int|0
suffix:semicolon
id|id_ldrive
op_assign
(paren
id|id_log_drv_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|id_log_drv_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id_ldrive
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray:  out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|id_ctlr_buf
op_assign
(paren
id|id_ctlr_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|id_ctlr_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id_ctlr_buf
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|id_ldrive
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray:  out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|id_lstatus_buf
op_assign
(paren
id|sense_log_drv_stat_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|sense_log_drv_stat_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id_lstatus_buf
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|id_ctlr_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ldrive
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray:  out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sense_config_buf
op_assign
(paren
id|config_t
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|config_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sense_config_buf
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|id_lstatus_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ctlr_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ldrive
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray:  out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|id_ldrive
comma
l_int|0
comma
r_sizeof
(paren
id|id_log_drv_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|id_ctlr_buf
comma
l_int|0
comma
r_sizeof
(paren
id|id_ctlr_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|id_lstatus_buf
comma
l_int|0
comma
r_sizeof
(paren
id|sense_log_drv_stat_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|sense_config_buf
comma
l_int|0
comma
r_sizeof
(paren
id|config_t
)paren
)paren
suffix:semicolon
id|info_p-&gt;phys_drives
op_assign
l_int|0
suffix:semicolon
id|info_p-&gt;log_drv_map
op_assign
l_int|0
suffix:semicolon
id|info_p-&gt;drv_assign_map
op_assign
l_int|0
suffix:semicolon
id|info_p-&gt;drv_spare_map
op_assign
l_int|0
suffix:semicolon
id|info_p-&gt;mp_failed_drv_map
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* only initialized here */
multiline_comment|/* Get controllers info for this logical drive */
id|ret_code
op_assign
id|sendcmd
c_func
(paren
id|ID_CTLR
comma
id|ctlr
comma
id|id_ctlr_buf
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_code
op_eq
id|IO_ERROR
)paren
(brace
multiline_comment|/*&n;&t;&t; * If can&squot;t get controller info, set the logical drive map to 0,&n;&t;&t; * so the idastubopen will fail on all logical drives&n;&t;&t; * on the controller.&n;&t;&t; */
multiline_comment|/* Free all the buffers and return */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: error sending ID controller&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sense_config_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_lstatus_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ctlr_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ldrive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|info_p-&gt;log_drives
op_assign
id|id_ctlr_buf-&gt;nr_drvs
suffix:semicolon
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|info_p-&gt;firm_rev
(braket
id|i
)braket
op_assign
id|id_ctlr_buf-&gt;firm_rev
(braket
id|i
)braket
suffix:semicolon
)brace
id|info_p-&gt;ctlr_sig
op_assign
id|id_ctlr_buf-&gt;cfg_sig
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; (%s)&bslash;n&quot;
comma
id|info_p-&gt;product_name
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize logical drive map to zero&n;&t; */
id|log_index
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Get drive geometry for all logical drives&n;&t; */
r_if
c_cond
(paren
id|id_ctlr_buf-&gt;nr_drvs
OG
l_int|16
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray ida%d:  This driver supports &quot;
l_string|&quot;16 logical drives per controller.&bslash;n.  &quot;
l_string|&quot; Additional drives will not be &quot;
l_string|&quot;detected&bslash;n&quot;
comma
id|ctlr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|log_unit
op_assign
l_int|0
suffix:semicolon
(paren
id|log_index
OL
id|id_ctlr_buf-&gt;nr_drvs
)paren
op_logical_and
(paren
id|log_unit
OL
id|NWD
)paren
suffix:semicolon
id|log_unit
op_increment
)paren
(brace
id|size
op_assign
r_sizeof
(paren
id|sense_log_drv_stat_t
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;   Send &quot;Identify logical drive status&quot; cmd&n;&t;&t; */
id|ret_code
op_assign
id|sendcmd
c_func
(paren
id|SENSE_LOG_DRV_STAT
comma
id|ctlr
comma
id|id_lstatus_buf
comma
id|size
comma
l_int|0
comma
l_int|0
comma
id|log_unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_code
op_eq
id|IO_ERROR
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;   If can&squot;t get logical drive status, set&n;&t;&t;&t;   the logical drive map to 0, so the&n;&t;&t;&t;   idastubopen will fail for all logical drives&n;&t;&t;&t;   on the controller. &n;&t;&t;&t; */
id|info_p-&gt;log_drv_map
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray ida%d: idaGetGeometry - Controller&quot;
l_string|&quot; failed to report status of logical drive %d&bslash;n&quot;
l_string|&quot;Access to this controller has been disabled&bslash;n&quot;
comma
id|ctlr
comma
id|log_unit
)paren
suffix:semicolon
multiline_comment|/* Free all the buffers and return */
id|kfree
c_func
(paren
id|sense_config_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_lstatus_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ctlr_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ldrive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;   Make sure the logical drive is configured&n;&t;&t; */
r_if
c_cond
(paren
id|id_lstatus_buf-&gt;status
op_ne
id|LOG_NOT_CONF
)paren
(brace
id|ret_code
op_assign
id|sendcmd
c_func
(paren
id|ID_LOG_DRV
comma
id|ctlr
comma
id|id_ldrive
comma
r_sizeof
(paren
id|id_log_drv_t
)paren
comma
l_int|0
comma
l_int|0
comma
id|log_unit
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;   If error, the bit for this&n;&t;&t;&t;   logical drive won&squot;t be set and&n;&t;&t;&t;   idastubopen will return error. &n;&t;&t;&t; */
r_if
c_cond
(paren
id|ret_code
op_ne
id|IO_ERROR
)paren
(brace
id|drv
op_assign
op_amp
id|info_p-&gt;drv
(braket
id|log_unit
)braket
suffix:semicolon
id|drv-&gt;blk_size
op_assign
id|id_ldrive-&gt;blk_size
suffix:semicolon
id|drv-&gt;nr_blks
op_assign
id|id_ldrive-&gt;nr_blks
suffix:semicolon
id|drv-&gt;cylinders
op_assign
id|id_ldrive-&gt;drv.cyl
suffix:semicolon
id|drv-&gt;heads
op_assign
id|id_ldrive-&gt;drv.heads
suffix:semicolon
id|drv-&gt;sectors
op_assign
id|id_ldrive-&gt;drv.sect_per_track
suffix:semicolon
id|info_p-&gt;log_drv_map
op_or_assign
(paren
l_int|1
op_lshift
id|log_unit
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;cpqarray ida/c%dd%d: blksz=%d nr_blks=%d&bslash;n&quot;
comma
id|ctlr
comma
id|log_unit
comma
id|drv-&gt;blk_size
comma
id|drv-&gt;nr_blks
)paren
suffix:semicolon
id|ret_code
op_assign
id|sendcmd
c_func
(paren
id|SENSE_CONFIG
comma
id|ctlr
comma
id|sense_config_buf
comma
r_sizeof
(paren
id|config_t
)paren
comma
l_int|0
comma
l_int|0
comma
id|log_unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret_code
op_eq
id|IO_ERROR
)paren
(brace
id|info_p-&gt;log_drv_map
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Free all the buffers and return */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cpqarray: error sending sense config&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|sense_config_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_lstatus_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ctlr_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ldrive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|info_p-&gt;phys_drives
op_assign
id|sense_config_buf-&gt;ctlr_phys_drv
suffix:semicolon
id|info_p-&gt;drv_assign_map
op_or_assign
id|sense_config_buf-&gt;drv_asgn_map
suffix:semicolon
id|info_p-&gt;drv_assign_map
op_or_assign
id|sense_config_buf-&gt;spare_asgn_map
suffix:semicolon
id|info_p-&gt;drv_spare_map
op_or_assign
id|sense_config_buf-&gt;spare_asgn_map
suffix:semicolon
)brace
multiline_comment|/* end of if no error on id_ldrive */
id|log_index
op_assign
id|log_index
op_plus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* end of if logical drive configured */
)brace
multiline_comment|/* end of for log_unit */
id|kfree
c_func
(paren
id|sense_config_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ldrive
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_lstatus_buf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|id_ctlr_buf
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
eof
