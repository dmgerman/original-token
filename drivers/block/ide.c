multiline_comment|/*&n; *  linux/drivers/block/ide.c&t;Version 3.5  December 30, 1994&n; *&n; *  Copyright (C) 1994  Linus Torvalds &amp; authors (see below)&n; */
multiline_comment|/*&n; * This is the dual IDE interface driver, as evolved from hd.c.  &n; * It supports up to two IDE interfaces, on one or two IRQs (usually 14 &amp; 15).&n; * There can be up to two drives per interface, as per the ATA-2 spec.&n; *&n; * Primary   i/f: ide0: major=3;  (hda)         minor=0, (hdb)         minor=64&n; * Secondary i/f: ide1: major=22; (hdc or hd1a) minor=0, (hdd or hd1b) minor=64&n; *&n; *  From hd.c:&n; *  |&n; *  | It traverses the request-list, using interrupts to jump between functions.&n; *  | As nearly all functions can be called within interrupts, we may not sleep.&n; *  | Special care is recommended.  Have Fun!&n; *  |&n; *  | modified by Drew Eckhardt to check nr of hd&squot;s from the CMOS.&n; *  |&n; *  | Thanks to Branko Lankester, lankeste@fwi.uva.nl, who found a bug&n; *  | in the early extended-partition checks and added DM partitions.&n; *  |&n; *  | Early work on error handling by Mika Liljeberg (liljeber@cs.Helsinki.FI).&n; *  |&n; *  | IRQ-unmask, drive-id, multiple-mode, support for &quot;&gt;16 heads&quot;,&n; *  | and general streamlining by Mark Lord (mlord@bnr.ca).&n; *&n; *  October, 1994 -- Complete line-by-line overhaul for linux 1.3.x, by:&n; *&n; *&t;Mark Lord&t;(mlord@bnr.ca)&t;&t;&t;(IDE Perf.Pkg)&n; *&t;Delman Lee&t;(delman@mipg.upenn.edu)&t;&t;(&quot;Mr. atdisk2&quot;)&n; *&t;Petri Mattila&t;(ptjmatti@kruuna.helsinki.fi)&t;(EIDE stuff)&n; *&t;Scott Snyder&t;(snyder@fnald0.fnal.gov)&t;(ATAPI IDE cd-rom)&n; *&n; *  This was a rewrite of just about everything from hd.c, though some original&n; *  code is still sprinkled about.  Think of it as a major evolution, with &n; *  inspiration from lots of linux users, esp.  hamish@zot.apana.org.au&n; *&n; *  Version 1.0 ALPHA&t;initial code, primary i/f working okay&n; *  Version 1.1 ALPHA&t;fixes for dual i/f&n; *  Version 1.2 ALPHA&t;first serious attempt at sharing irqs&n; *  Version 1.3 BETA&t;dual i/f on shared irq tested &amp; working!&n; *  Version 1.4 BETA&t;added auto probing for irq(s)&n; *  Version 1.5 BETA&t;added ALPHA (untested) support for IDE cd-roms,&n; *&t;&t;&t;fixed hd.c coexistance bug, other minor stuff&n; *  Version 1.6 BETA&t;fix link error when cd-rom not configured&n; *  Version 2.0 BETA&t;lots of minor fixes; remove annoying messages; ...&n; *  Version 2.2 BETA&t;fixed reset_drives; major overhaul of autoprobing&n; *  Version 2.3 BETA&t;set DEFAULT_UNMASK_INTR to 0 again; cosmetic changes&n; *  Version 2.4 BETA&t;added debounce on reading of drive status reg,&n; *&t;&t;&t;added config flags to remove unwanted features&n; *  Version 2.5 BETA&t;fixed problem with leftover phantom IRQ after probe,&n; *&t;&t;&t;allow &quot;set_geometry&quot; even when in LBA (as per spec(?)),&n; *&t;&t;&t;assorted miscellaneous tweaks.&n; *  Version 2.6 BETA&t;more config flag stuff, another probing tweak,&n; *  (not released)&t;multmode now defaults to status quo from boot time,&n; *&t;&t;&t;moved &gt;16heads check to init time, rearranged reset code&n; *&t;&t;&t;added HDIO_DRIVE_CMD, removed standby/xfermode stuff&n; *&t;&t;&t;hopefully fixed ATAPI probing code, added hdx=cdrom&n; *  Version 2.7 BETA&t;fixed invocation of cdrom_setup()&n; *  Version 2.8 BETA&t;fixed compile error for DISK_RECOVERY_TIME&gt;0&n; *&t;&t;&t;fixed incorrect drive selection in DO_DRIVE_CMD (Bug!)&n; *  Version 2.9 BETA&t;more work on ATAPI CDROM recognition&n; *  (not released)&t;changed init order so partition checks go in sequence&n; *  Version 3.0 BETA&t;included ide-cd.c update from Steve with Mitsumi fixes&n; *&t;&t;&t;attempt to fix byte-swap problem with Mitsumi id_info&n; *&t;&t;&t;ensure drives on second i/f get initialized on boot&n; *&t;&t;&t;preliminary compile-time support for 32bit IDE i/f chips&n; *&t;&t;&t;added check_region() and snarf_region() to probes&n; *  Version 3.1 BETA&t;ensure drives on *both* i/f get initialized on boot&n; *&t;&t;&t;fix byte-swap problem with Mitsumi id_info&n; *&t;&t;&t;changed ide_timermask into ide_timerbit&n; *&t;&t;&t;get rid of unexpected interrupts after probing&n; *&t;&t;&t;don&squot;t wait for READY_STAT on cdrom drives&n; *  Version 3.2 BETA&t;Ooops.. mistakenly left VLB_32BIT_IDE on by default&n; *&t;&t;&t;new ide-cd.c from Scott&n; *  Version 3.3 BETA&t;fix compiling with PROBE_FOR_IRQS==0&n; *  (sent to Linus)&t;tweak in do_probe() to fix Delman&squot;s DRDY problem&n; *  Version 3.4 BETA&t;removed &quot;444&quot; debug message&n; *  (sent to Linus)&n; *  Version 3.5&t;&t;correct the bios_cyl field if it&squot;s too small&n; *&t;&t;&t; (to help fdisk with brain-dead BIOSs)&n; *&n; *  In progress:  special 32-bit controller-type detection &amp; support&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/system.h&gt;
multiline_comment|/*****************************************************************************&n; * IDE driver configuration options (play with these as desired):&n; */
DECL|macro|REALLY_SLOW_IO
macro_line|#undef&t;REALLY_SLOW_IO&t;&t;&t;/* define if ide ports are very slow */
DECL|macro|REALLY_FAST_IO
macro_line|#undef&t;REALLY_FAST_IO&t;&t;&t;/* define if ide ports are perfect */
DECL|macro|INITIAL_MULT_COUNT
macro_line|#undef&t;INITIAL_MULT_COUNT&t;&t;/* define to override status quo */
macro_line|#ifndef VLB_32BIT_IDE&t;&t;&t;/* 0 for safety, 1 for 32-bit chipset:*/
DECL|macro|VLB_32BIT_IDE
mdefine_line|#define VLB_32BIT_IDE&t;&t;0&t;/*   Winbond 83759F or OPTi 82C621 */
macro_line|#endif
macro_line|#ifndef DISK_RECOVERY_TIME&t;&t;/* min. delay between IO for hardware */
DECL|macro|DISK_RECOVERY_TIME
mdefine_line|#define DISK_RECOVERY_TIME&t;0&t;/*  that needs it. */
macro_line|#endif
macro_line|#ifndef OK_TO_RESET_CONTROLLER&t;&t;/* needed for good error recovery */
DECL|macro|OK_TO_RESET_CONTROLLER
mdefine_line|#define OK_TO_RESET_CONTROLLER&t;1&t;/* 0 for use with AH2372A/B interface */
macro_line|#endif
macro_line|#ifndef SUPPORT_TWO_INTERFACES&t;&t;/* 1 to support one/two interfaces */
DECL|macro|SUPPORT_TWO_INTERFACES
mdefine_line|#define SUPPORT_TWO_INTERFACES&t;1&t;/* 0 for a smaller, faster kernel */
macro_line|#endif
macro_line|#ifndef OPTIMIZE_IRQS&t;&t;&t;/* 1 for slightly faster code */
DECL|macro|OPTIMIZE_IRQS
mdefine_line|#define OPTIMIZE_IRQS&t;&t;1&t;/* 0 to reduce kernel size */
macro_line|#endif
macro_line|#ifndef SUPPORT_SHARING_IRQ&t;&t;/* 1 to allow two IDE i/f on one IRQ */
DECL|macro|SUPPORT_SHARING_IRQ
mdefine_line|#define SUPPORT_SHARING_IRQ&t;1&t;/* 0 to reduce kernel size */
macro_line|#endif
macro_line|#ifndef FANCY_STATUS_DUMPS&t;&t;/* 1 for human-readable drive errors */
DECL|macro|FANCY_STATUS_DUMPS
mdefine_line|#define FANCY_STATUS_DUMPS&t;1&t;/* 0 to reduce kernel size */
macro_line|#endif
DECL|macro|PROBE_FOR_IRQS
mdefine_line|#define PROBE_FOR_IRQS&t;&t;1&t;/* 0 to force use of defaults below */
DECL|macro|DEFAULT_IDE0_IRQ
mdefine_line|#define DEFAULT_IDE0_IRQ&t;14&t;/* in case irq-probe fails */
DECL|macro|DEFAULT_IDE1_IRQ
mdefine_line|#define DEFAULT_IDE1_IRQ&t;15&t;/* in case irq-probe fails */
multiline_comment|/*&n; *  &quot;No user-serviceable parts&quot; beyond this point  :)&n; ******************************************************************************&n; */
multiline_comment|/*&n; * Need to change these elsewhere in the kernel (someday)&n; */
macro_line|#ifndef IDE0_TIMER
DECL|macro|IDE0_TIMER
mdefine_line|#define&t;IDE0_TIMER&t;&t;HD_TIMER
DECL|macro|IDE1_TIMER
mdefine_line|#define IDE1_TIMER&t;&t;HD_TIMER2
macro_line|#endif
DECL|macro|IDE_DRIVE_CMD
mdefine_line|#define IDE_DRIVE_CMD&t;&t;99&t;/* some local magic */
multiline_comment|/*&n; * Ensure that various configuration flags have compatible settings&n; */
macro_line|#ifdef REALLY_SLOW_IO
DECL|macro|REALLY_FAST_IO
macro_line|#undef REALLY_FAST_IO
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_HD
DECL|macro|SUPPORT_TWO_INTERFACES
macro_line|#undef  SUPPORT_TWO_INTERFACES
DECL|macro|SUPPORT_TWO_INTERFACES
mdefine_line|#define SUPPORT_TWO_INTERFACES&t;0
macro_line|#endif&t;/* CONFIG_BLK_DEV_HD */
macro_line|#if SUPPORT_TWO_INTERFACES
DECL|macro|HWIF
mdefine_line|#define HWIF&t;&t;&t;hwif
DECL|macro|DEV_HWIF
mdefine_line|#define DEV_HWIF&t;&t;(dev-&gt;hwif)
macro_line|#else
DECL|macro|OPTIMIZE_IRQS
macro_line|#undef&t;OPTIMIZE_IRQS
DECL|macro|OPTIMIZE_IRQS
mdefine_line|#define&t;OPTIMIZE_IRQS&t;&t;0
DECL|macro|SUPPORT_SHARING_IRQ
macro_line|#undef&t;SUPPORT_SHARING_IRQ
DECL|macro|SUPPORT_SHARING_IRQ
mdefine_line|#define&t;SUPPORT_SHARING_IRQ&t;0
macro_line|#ifdef CONFIG_BLK_DEV_HD
DECL|macro|HWIF
mdefine_line|#define HWIF&t;&t;&t;1
macro_line|#else
DECL|macro|HWIF
mdefine_line|#define HWIF&t;&t;&t;0
macro_line|#endif&t;/* CONFIG_BLK_DEV_HD */
DECL|macro|DEV_HWIF
mdefine_line|#define DEV_HWIF&t;&t;HWIF
macro_line|#endif&t;/* SUPPORT_TWO_INTERFACES */
multiline_comment|/*&n; * Definitions for accessing IDE controller registers&n; */
DECL|typedef|byte
r_typedef
r_int
r_char
id|byte
suffix:semicolon
multiline_comment|/* used everywhere */
DECL|macro|IDE_PORT
mdefine_line|#define IDE_PORT(p,hwif) ((p)^((hwif)&lt;&lt;7)) /* IDE0: p^0x00 , IDE1: p^0x80 */
macro_line|#ifdef REALLY_FAST_IO
DECL|macro|OUT_BYTE
mdefine_line|#define OUT_BYTE(b,p)&t;&t;outb((b),IDE_PORT(p,DEV_HWIF))
DECL|macro|IN_BYTE
mdefine_line|#define IN_BYTE(p,hwif)&t;&t;(byte)inb(IDE_PORT(p,hwif))
macro_line|#else
DECL|macro|OUT_BYTE
mdefine_line|#define OUT_BYTE(b,p)&t;&t;outb_p((b),IDE_PORT(p,DEV_HWIF))
DECL|macro|IN_BYTE
mdefine_line|#define IN_BYTE(p,hwif)&t;&t;(byte)inb_p(IDE_PORT(p,hwif))
macro_line|#endif /* REALLY_FAST_IO */
macro_line|#if VLB_32BIT_IDE
DECL|macro|OUT_SECTORS
mdefine_line|#define OUT_SECTORS(b,n)&t;outsl(IDE_PORT(HD_DATA,DEV_HWIF),(b),(n)&lt;&lt;7)
DECL|macro|IN_SECTORS
mdefine_line|#define IN_SECTORS(b,n)&t;&t;insl(IDE_PORT(HD_DATA,DEV_HWIF),(b),(n)&lt;&lt;7)
macro_line|#else
DECL|macro|OUT_SECTORS
mdefine_line|#define OUT_SECTORS(b,n)&t;outsw(IDE_PORT(HD_DATA,DEV_HWIF),(b),(n)&lt;&lt;8)
DECL|macro|IN_SECTORS
mdefine_line|#define IN_SECTORS(b,n)&t;&t;insw(IDE_PORT(HD_DATA,DEV_HWIF),(b),(n)&lt;&lt;8)
macro_line|#endif&t;/* VLB_32BIT_IDE */
DECL|macro|GET_ERR
mdefine_line|#define GET_ERR(hwif)&t;&t;IN_BYTE(HD_ERROR,hwif)
DECL|macro|GET_STAT
mdefine_line|#define GET_STAT(hwif)&t;&t;IN_BYTE(HD_STATUS,hwif)
DECL|macro|OK_STAT
mdefine_line|#define OK_STAT(stat,good,bad)&t;(((stat)&amp;((good)|(bad)))==(good))
DECL|macro|BAD_RW_STAT
mdefine_line|#define BAD_RW_STAT&t;&t;(BUSY_STAT   | ERR_STAT  | WRERR_STAT)
DECL|macro|BAD_STAT
mdefine_line|#define BAD_STAT&t;&t;(BAD_RW_STAT | DRQ_STAT)
DECL|macro|DRIVE_READY
mdefine_line|#define DRIVE_READY&t;&t;(READY_STAT  | SEEK_STAT)
DECL|macro|DATA_READY
mdefine_line|#define DATA_READY&t;&t;(DRIVE_READY | DRQ_STAT)
multiline_comment|/*&n; * Some more useful definitions&n; */
DECL|macro|BIOS_SECTORS
mdefine_line|#define BIOS_SECTORS(dev)&t;(dev-&gt;bios_head*dev-&gt;bios_sect*dev-&gt;bios_cyl)
DECL|macro|HD_NAME
mdefine_line|#define HD_NAME&t;&t;&quot;hd&quot;&t;/* the same for both i/f;  see also genhd.c */
DECL|macro|PARTN_BITS
mdefine_line|#define PARTN_BITS&t;6&t;/* number of minor dev bits for partitions */
DECL|macro|PARTN_MASK
mdefine_line|#define PARTN_MASK&t;((1&lt;&lt;PARTN_BITS)-1)&t;/* a useful bit mask */
DECL|macro|MAX_DRIVES
mdefine_line|#define MAX_DRIVES&t;2&t;/* per interface; 2 assumed by lots of code */
multiline_comment|/*&n; * Timeouts for various operations:&n; */
DECL|macro|WAIT_DRQ
mdefine_line|#define&t;WAIT_DRQ&t;3&t;/* 30msec - spec allows up to 20ms */
DECL|macro|WAIT_READY
mdefine_line|#define WAIT_READY&t;3&t;/* 30msec - should be instantaneous */
DECL|macro|WAIT_PIDENTIFY
mdefine_line|#define&t;WAIT_PIDENTIFY&t;50&t;/* 500msec - should be less than 3ms (?) */
DECL|macro|WAIT_WORSTCASE
mdefine_line|#define&t;WAIT_WORSTCASE&t;3000&t;/* 30sec  - worst case when spinning up */
DECL|macro|WAIT_CMD
mdefine_line|#define&t;WAIT_CMD&t;1000&t;/* 10sec  - maximum wait for an IRQ to happen */
multiline_comment|/*&n; * Now for the data we need to maintain per-device:  ide_dev_t&n; *&n; * For fast indexing, sizeof(ide_dev_t) = 32 = power_of_2;&n; * Everything is carefully aligned on appropriate boundaries,&n; *  and several fields are placed for optimal (gcc) access.&n; */
DECL|enumerator|disk
DECL|enumerator|cdrom
DECL|typedef|dev_type
r_typedef
r_enum
(brace
id|disk
comma
id|cdrom
)brace
id|dev_type
suffix:semicolon
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* all of the bits together */
r_struct
(brace
DECL|member|set_geometry
r_int
id|set_geometry
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* respecify drive geometry */
DECL|member|recalibrate
r_int
id|recalibrate
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* seek to cyl 0      */
DECL|member|set_multmode
r_int
id|set_multmode
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* set multmode count */
DECL|member|reserved
r_int
id|reserved
suffix:colon
l_int|5
suffix:semicolon
multiline_comment|/* unused */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|special_t
)brace
id|special_t
suffix:semicolon
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* all of the bits together */
r_struct
(brace
DECL|member|head
r_int
id|head
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* always zeros here */
DECL|member|drive
r_int
id|drive
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* drive number */
DECL|member|bit5
r_int
id|bit5
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* always 1 */
DECL|member|lba
r_int
id|lba
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* LBA instead of CHS */
DECL|member|bit7
r_int
id|bit7
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* always 1 */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|select_t
)brace
id|select_t
suffix:semicolon
r_typedef
r_struct
(brace
DECL|member|hwif
id|byte
id|hwif
suffix:semicolon
multiline_comment|/* first field gets very fast access */
DECL|member|unmask
id|byte
id|unmask
suffix:semicolon
multiline_comment|/* pretty quick access to this also */
DECL|member|type
id|dev_type
id|type
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* disk or cdrom (or tape, floppy..) */
DECL|member|present
r_int
id|present
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* drive is physically present */
DECL|member|keep_settings
r_int
id|keep_settings
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* restore settings after drive reset */
DECL|member|busy
r_int
id|busy
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* mutex for ide_open, revalidate_.. */
DECL|member|reserved0
r_int
id|reserved0
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* unused */
DECL|member|special
id|special_t
id|special
suffix:semicolon
multiline_comment|/* special action flags */
DECL|member|select
id|select_t
id|select
suffix:semicolon
multiline_comment|/* basic drive/head select reg value */
DECL|member|mult_count
DECL|member|reserved1
DECL|member|reserved2
id|byte
id|mult_count
comma
id|reserved1
comma
id|reserved2
suffix:semicolon
DECL|member|usage
DECL|member|mult_req
DECL|member|wpcom
DECL|member|ctl
id|byte
id|usage
comma
id|mult_req
comma
id|wpcom
comma
id|ctl
suffix:semicolon
DECL|member|head
DECL|member|sect
DECL|member|bios_head
DECL|member|bios_sect
id|byte
id|head
comma
id|sect
comma
id|bios_head
comma
id|bios_sect
suffix:semicolon
DECL|member|cyl
DECL|member|bios_cyl
r_int
r_int
id|cyl
comma
id|bios_cyl
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|id
r_struct
id|hd_driveid
op_star
id|id
suffix:semicolon
DECL|member|wqueue
r_struct
id|wait_queue
op_star
id|wqueue
suffix:semicolon
DECL|typedef|ide_dev_t
)brace
id|ide_dev_t
suffix:semicolon
multiline_comment|/*&n; * Stuff prefixed by &quot;ide_&quot; is indexed by the IDE interface number: 0 or 1&n; */
DECL|variable|ide_major
r_static
r_const
id|byte
id|ide_major
(braket
l_int|2
)braket
op_assign
(brace
id|IDE0_MAJOR
comma
id|IDE1_MAJOR
)brace
suffix:semicolon
DECL|variable|ide_irq
r_static
id|byte
id|ide_irq
(braket
l_int|2
)braket
op_assign
(brace
id|DEFAULT_IDE0_IRQ
comma
id|DEFAULT_IDE1_IRQ
)brace
suffix:semicolon
DECL|variable|ide_hd
r_static
r_struct
id|hd_struct
id|ide_hd
(braket
l_int|2
)braket
(braket
id|MAX_DRIVES
op_lshift
id|PARTN_BITS
)braket
op_assign
(brace
(brace
(brace
l_int|0
comma
l_int|0
)brace
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|ide_sizes
r_static
r_int
id|ide_sizes
(braket
l_int|2
)braket
(braket
id|MAX_DRIVES
op_lshift
id|PARTN_BITS
)braket
op_assign
(brace
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|ide_blksizes
r_static
r_int
id|ide_blksizes
(braket
l_int|2
)braket
(braket
id|MAX_DRIVES
op_lshift
id|PARTN_BITS
)braket
op_assign
(brace
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|ide_capacity
r_static
r_int
r_int
id|ide_capacity
(braket
l_int|2
)braket
(braket
id|MAX_DRIVES
)braket
op_assign
(brace
(brace
l_int|0
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|ide_dev
r_static
id|ide_dev_t
id|ide_dev
(braket
l_int|2
)braket
(braket
id|MAX_DRIVES
)braket
op_assign
(brace
(brace
(brace
l_int|0
comma
)brace
comma
)brace
comma
)brace
suffix:semicolon
DECL|variable|ide_cur_dev
r_static
id|ide_dev_t
op_star
id|ide_cur_dev
(braket
l_int|2
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|ide_handler
r_static
r_void
(paren
op_star
id|ide_handler
(braket
l_int|2
)braket
)paren
(paren
id|ide_dev_t
op_star
)paren
op_assign
(brace
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|ide_cur_rq
r_static
r_struct
id|request
op_star
id|ide_cur_rq
(braket
l_int|2
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* current request */
DECL|variable|ide_write_rq
r_static
r_struct
id|request
id|ide_write_rq
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* copy of *ide_cur_rq for WRITEs */
DECL|variable|ide_timer
r_static
r_const
r_int
id|ide_timer
(braket
l_int|2
)braket
op_assign
(brace
id|IDE0_TIMER
comma
id|IDE1_TIMER
)brace
suffix:semicolon
DECL|variable|ide_timerbit
r_static
r_const
r_int
id|ide_timerbit
(braket
l_int|2
)braket
op_assign
(brace
(paren
l_int|1
op_lshift
id|IDE0_TIMER
)paren
comma
(paren
l_int|1
op_lshift
id|IDE1_TIMER
)paren
)brace
suffix:semicolon
DECL|variable|ide_name
r_static
r_const
r_char
op_star
id|ide_name
(braket
l_int|2
)braket
op_assign
(brace
l_string|&quot;ide0&quot;
comma
l_string|&quot;ide1&quot;
)brace
suffix:semicolon
DECL|variable|ide_devname
r_static
r_const
r_char
op_star
id|ide_devname
(braket
l_int|2
)braket
(braket
id|MAX_DRIVES
)braket
op_assign
multiline_comment|/* for printk()&squot;s */
(brace
(brace
id|HD_NAME
l_string|&quot;a&quot;
comma
id|HD_NAME
l_string|&quot;b&quot;
)brace
comma
(brace
id|HD_NAME
l_string|&quot;c&quot;
comma
id|HD_NAME
l_string|&quot;d&quot;
)brace
)brace
suffix:semicolon
DECL|variable|unsupported
r_static
r_const
r_char
op_star
id|unsupported
op_assign
l_string|&quot; not supported by this kernel&bslash;n&quot;
suffix:semicolon
macro_line|#if SUPPORT_SHARING_IRQ
DECL|variable|sharing_single_irq
r_static
id|byte
id|sharing_single_irq
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for two i/f on one IRQ */
DECL|variable|current_hwif
r_static
r_volatile
id|byte
id|current_hwif
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for two i/f on one IRQ */
macro_line|#endif /* SUPPORT_SHARING_IRQ */
multiline_comment|/*&n; * This structure is used to register our block device(s) with the kernel:&n; */
r_static
r_void
id|ide0_geninit
c_func
(paren
r_void
)paren
comma
id|ide1_geninit
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|ide_gendisk
r_static
r_struct
id|gendisk
id|ide_gendisk
(braket
l_int|2
)braket
op_assign
(brace
(brace
id|IDE0_MAJOR
comma
multiline_comment|/* major number */
id|HD_NAME
comma
multiline_comment|/* same as below; see genhd.c before changing */
id|PARTN_BITS
comma
multiline_comment|/* minor_shift (to extract minor number) */
l_int|1
op_lshift
id|PARTN_BITS
comma
multiline_comment|/* max_p (number of partitions per real) */
id|MAX_DRIVES
comma
multiline_comment|/* maximum number of real drives */
id|ide0_geninit
comma
multiline_comment|/* init function */
id|ide_hd
(braket
l_int|0
)braket
comma
multiline_comment|/* hd_struct */
id|ide_sizes
(braket
l_int|0
)braket
comma
multiline_comment|/* block sizes */
l_int|0
comma
multiline_comment|/* nr_real (number of drives present) */
id|ide_dev
(braket
l_int|0
)braket
comma
multiline_comment|/* ptr to internal data structure */
l_int|NULL
multiline_comment|/* next */
)brace
comma
(brace
id|IDE1_MAJOR
comma
multiline_comment|/* major number */
id|HD_NAME
comma
multiline_comment|/* same as above; see genhd.c before changing */
id|PARTN_BITS
comma
multiline_comment|/* minor_shift (to extract minor number) */
l_int|1
op_lshift
id|PARTN_BITS
comma
multiline_comment|/* max_p (number of partitions per real) */
id|MAX_DRIVES
comma
multiline_comment|/* maximum number of real drives */
id|ide1_geninit
comma
multiline_comment|/* init function */
id|ide_hd
(braket
l_int|1
)braket
comma
multiline_comment|/* hd_struct */
id|ide_sizes
(braket
l_int|1
)braket
comma
multiline_comment|/* block sizes */
l_int|0
comma
multiline_comment|/* nr_real (number of drives present) */
id|ide_dev
(braket
l_int|1
)braket
comma
multiline_comment|/* ptr to internal data structure */
l_int|NULL
multiline_comment|/* next */
)brace
)brace
suffix:semicolon
multiline_comment|/*&n; * One final include file, which references some of the data/defns from above&n; */
DECL|macro|IDE_DRIVER
mdefine_line|#define&t;IDE_DRIVER&t;/* &quot;parameter&quot; for blk.h */
macro_line|#include &quot;blk.h&quot;
multiline_comment|/*&n; * For really screwy hardware (hey, at least it *can* be used with Linux!&n; */
macro_line|#if (DISK_RECOVERY_TIME &gt; 0)
DECL|variable|ide_lastreq
r_static
r_int
r_int
id|ide_lastreq
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* completion time of last I/O */
DECL|macro|SET_DISK_RECOVERY_TIMER
mdefine_line|#define SET_DISK_RECOVERY_TIMER  ide_lastreq[DEV_HWIF] = read_timer();
DECL|function|read_timer
r_static
r_int
r_int
id|read_timer
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|t
comma
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|t
op_assign
id|jiffies
op_star
l_int|11932
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
l_int|0x43
)paren
suffix:semicolon
id|i
op_assign
id|inb_p
c_func
(paren
l_int|0x40
)paren
suffix:semicolon
id|i
op_or_assign
id|inb
c_func
(paren
l_int|0x40
)paren
op_lshift
l_int|8
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|t
op_minus
id|i
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|SET_DISK_RECOVERY_TIMER
mdefine_line|#define SET_DISK_RECOVERY_TIMER&t;/* nothing */
macro_line|#endif /* DISK_RECOVERY_TIME */
multiline_comment|/*&n; * The heart of the driver, referenced from lots of other routines:&n; */
r_static
r_void
id|do_request
(paren
id|byte
id|hwif
)paren
suffix:semicolon
DECL|macro|DO_REQUEST
mdefine_line|#define DO_REQUEST {SET_DISK_RECOVERY_TIMER do_request(DEV_HWIF);}
multiline_comment|/*&n; * This is a macro rather than an inline to permit better gcc code.&n; * Caller MUST do sti() before invoking WAIT_STAT() (for jiffies to work).&n; *&n; * This route should get fixed to not hog the cpu during extra long waits..&n; * That could be done by busy-waiting for the first jiffy or two, and then&n; * setting a timer to wake up at half second intervals thereafter,&n; * until WAIT_WORSTCASE is achieved, before timing out.&n; */
DECL|macro|WAIT_STAT
mdefine_line|#define WAIT_STAT(dev,good,bad,timeout,msg,label)&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;byte stat;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;udelay(1);&t;/* spec allows drive 400ns to assert &quot;BUSY&quot; */&t;&bslash;&n;&t;if (GET_STAT(DEV_HWIF) &amp; BUSY_STAT) {&t;&t;&t;&t;&bslash;&n;&t;&t;unsigned long timer = jiffies + timeout;&t;&t;&bslash;&n;&t;&t;do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;&t;if ((GET_STAT(DEV_HWIF) &amp; BUSY_STAT) == 0)&t;&bslash;&n;&t;&t;&t;&t;break;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;} while (timer &gt; jiffies);&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;udelay(1);&t;/* spec allows 400ns for status to stabilize */&t;&bslash;&n;&t;if (!OK_STAT(stat=GET_STAT(DEV_HWIF), good, bad)) {&t;&t;&bslash;&n;&t;&t;ide_error(dev, msg &quot; error&quot;, stat);&t;&t;&t;&bslash;&n;&t;&t;goto label;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;}
multiline_comment|/*&n; * This should get invoked on every exit path from the driver.&n; */
DECL|function|start_ide_timer
r_static
r_inline
r_void
id|start_ide_timer
(paren
id|byte
id|hwif
)paren
(brace
r_if
c_cond
(paren
id|ide_handler
(braket
id|HWIF
)braket
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* waiting for an irq? */
id|timer_table
(braket
id|ide_timer
(braket
id|HWIF
)braket
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|WAIT_CMD
suffix:semicolon
id|timer_active
op_or_assign
id|ide_timerbit
(braket
id|HWIF
)braket
suffix:semicolon
)brace
)brace
DECL|function|do_ide_reset
r_static
r_void
id|do_ide_reset
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
id|byte
id|tmp
suffix:semicolon
r_int
r_int
id|timer
comma
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|tmp
op_assign
l_int|0
suffix:semicolon
id|tmp
OL
id|MAX_DRIVES
suffix:semicolon
id|tmp
op_increment
)paren
(brace
id|ide_dev_t
op_star
id|rdev
op_assign
op_amp
id|ide_dev
(braket
id|DEV_HWIF
)braket
(braket
id|tmp
)braket
suffix:semicolon
id|rdev-&gt;special.b.set_geometry
op_assign
l_int|1
suffix:semicolon
id|rdev-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
id|rdev-&gt;special.b.set_multmode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|OK_TO_RESET_CONTROLLER
)paren
id|rdev-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdev-&gt;keep_settings
)paren
(brace
id|rdev-&gt;mult_req
op_assign
l_int|0
suffix:semicolon
id|rdev-&gt;unmask
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rdev-&gt;mult_req
op_ne
id|rdev-&gt;mult_count
)paren
id|rdev-&gt;special.b.set_multmode
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#if OK_TO_RESET_CONTROLLER
id|cli
c_func
(paren
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|dev-&gt;ctl
op_or
l_int|6
comma
id|HD_CMD
)paren
suffix:semicolon
multiline_comment|/* set nIEN, set SRST */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* more than enough time */
id|OUT_BYTE
c_func
(paren
id|dev-&gt;ctl
op_or
l_int|2
comma
id|HD_CMD
)paren
suffix:semicolon
multiline_comment|/* clear SRST */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* more than enough time */
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* needed for jiffies */
r_for
c_loop
(paren
id|timer
op_assign
id|jiffies
op_plus
id|WAIT_WORSTCASE
suffix:semicolon
id|timer
OG
id|jiffies
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|GET_STAT
c_func
(paren
id|DEV_HWIF
)paren
op_amp
id|BUSY_STAT
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: do_ide_reset: &quot;
comma
id|ide_name
(braket
id|DEV_HWIF
)braket
)paren
suffix:semicolon
multiline_comment|/* ATAPI devices usually do *not* assert READY after a reset */
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|tmp
op_assign
id|GET_STAT
c_func
(paren
id|DEV_HWIF
)paren
comma
l_int|0
comma
id|BUSY_STAT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;timed out, status=0x%02x&bslash;n&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|tmp
op_assign
id|GET_ERR
c_func
(paren
id|DEV_HWIF
)paren
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;success&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: &quot;
comma
id|ide_devname
(braket
id|DEV_HWIF
)braket
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|tmp
op_amp
l_int|0x7f
)paren
(brace
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;passed&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;formatter device error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
l_string|&quot;sector buffer error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ECC circuitry error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printk
c_func
(paren
l_string|&quot;controlling MPU error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;error (0x%02x?)&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp
op_amp
l_int|0x80
)paren
id|printk
c_func
(paren
l_string|&quot;; %s: error&quot;
comma
id|ide_devname
(braket
id|DEV_HWIF
)braket
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* OK_TO_RESET_CONTROLLER */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Clean up after success/failure of an explicit (ioctl) drive cmd&n; */
DECL|function|end_drive_cmd
r_static
r_void
id|end_drive_cmd
(paren
id|ide_dev_t
op_star
id|dev
comma
id|byte
id|stat
comma
id|byte
id|err
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|ide_cur_rq
(braket
id|DEV_HWIF
)braket
suffix:semicolon
id|byte
op_star
id|args
op_assign
(paren
id|byte
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|rq-&gt;errors
op_assign
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
)paren
(brace
id|args
(braket
l_int|0
)braket
op_assign
id|stat
suffix:semicolon
id|args
(braket
l_int|1
)braket
op_assign
id|err
suffix:semicolon
id|args
(braket
l_int|2
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|HD_NSECTOR
comma
id|DEV_HWIF
)paren
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|up
c_func
(paren
id|rq-&gt;sem
)paren
suffix:semicolon
id|ide_cur_rq
(braket
id|DEV_HWIF
)braket
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Error reporting, in human readable form (luxurious, but a memory hog).&n; */
DECL|function|dump_status
r_static
id|byte
id|dump_status
(paren
id|byte
id|hwif
comma
r_const
r_char
op_star
id|msg
comma
id|byte
id|stat
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|byte
id|err
op_assign
l_int|0
suffix:semicolon
id|ide_dev_t
op_star
id|dev
op_assign
id|ide_cur_dev
(braket
id|HWIF
)braket
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
id|dev
ques
c_cond
id|dev-&gt;name
suffix:colon
id|ide_name
(braket
id|HWIF
)braket
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s: status=0x%02x&quot;
comma
id|name
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
r_if
c_cond
(paren
id|dev
op_logical_and
id|dev-&gt;type
op_eq
id|disk
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Busy &quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|READY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DriveReady &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;WriteFault &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|SEEK_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;SeekComplete &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DataRequest &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ECC_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;CorrectedError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|INDEX_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Index &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Error &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
(paren
id|BUSY_STAT
op_or
id|ERR_STAT
)paren
)paren
op_eq
id|ERR_STAT
)paren
(brace
id|err
op_assign
id|GET_ERR
c_func
(paren
id|HWIF
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s: error=0x%02x&quot;
comma
id|name
comma
id|msg
comma
id|err
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
r_if
c_cond
(paren
id|dev
op_logical_and
id|dev-&gt;type
op_eq
id|disk
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|BBD_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;BadSector &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ECC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;UncorrectableError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ID_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;SectorIdNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ABRT_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;DriveStatusError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;TrackZeroNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|MARK_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;AddrMarkNotFound &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ECC_ERR
op_or
id|ID_ERR
op_or
id|MARK_ERR
)paren
)paren
(brace
id|byte
id|cur
op_assign
id|IN_BYTE
c_func
(paren
id|HD_CURRENT
comma
id|HWIF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_amp
l_int|0x40
)paren
(brace
multiline_comment|/* using LBA? */
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%ld&quot;
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|cur
op_amp
l_int|0xf
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|HD_HCYL
comma
id|HWIF
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|HD_LCYL
comma
id|HWIF
)paren
op_lshift
l_int|8
)paren
op_or
id|IN_BYTE
c_func
(paren
id|HD_SECTOR
comma
id|HWIF
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, CHS=%d/%d/%d&quot;
comma
(paren
id|IN_BYTE
c_func
(paren
id|HD_HCYL
comma
id|HWIF
)paren
op_lshift
l_int|8
)paren
op_plus
id|IN_BYTE
c_func
(paren
id|HD_LCYL
comma
id|HWIF
)paren
comma
id|cur
op_amp
l_int|0xf
comma
id|IN_BYTE
c_func
(paren
id|HD_SECTOR
comma
id|HWIF
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ide_cur_rq
(braket
id|HWIF
)braket
)paren
id|printk
c_func
(paren
l_string|&quot;, sector=%ld&quot;
comma
id|ide_cur_rq
(braket
id|HWIF
)braket
op_member_access_from_pointer
id|sector
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_error() takes action based on the error returned by the controller.&n; */
DECL|macro|ERROR_MAX
mdefine_line|#define ERROR_MAX&t;8&t;/* Max read/write errors per sector */
DECL|macro|ERROR_RESET
mdefine_line|#define ERROR_RESET&t;3&t;/* Reset controller every 4th retry */
DECL|macro|ERROR_RECAL
mdefine_line|#define ERROR_RECAL&t;1&t;/* Recalibrate every 2nd retry */
DECL|function|ide_error
r_static
r_void
id|ide_error
(paren
id|ide_dev_t
op_star
id|dev
comma
r_const
r_char
op_star
id|msg
comma
id|byte
id|stat
)paren
(brace
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|byte
id|err
suffix:semicolon
id|err
op_assign
id|dump_status
c_func
(paren
id|DEV_HWIF
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq
op_assign
id|ide_cur_rq
(braket
id|DEV_HWIF
)braket
)paren
op_eq
l_int|NULL
op_logical_or
id|dev
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|IDE_DRIVE_CMD
)paren
(brace
multiline_comment|/* never retry an explicit DRIVE_CMD */
id|end_drive_cmd
c_func
(paren
id|dev
comma
id|stat
comma
id|err
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|disk
op_logical_and
(paren
id|stat
op_amp
id|ERR_STAT
)paren
)paren
(brace
multiline_comment|/* err has different meaning on cdrom */
r_if
c_cond
(paren
id|err
op_amp
id|BBD_ERR
)paren
multiline_comment|/* retries won&squot;t help this! */
id|rq-&gt;errors
op_assign
id|ERROR_MAX
suffix:semicolon
r_else
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
multiline_comment|/* help it find track zero */
id|rq-&gt;errors
op_or_assign
id|ERROR_RECAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_logical_and
id|rq-&gt;cmd
op_eq
id|READ
)paren
(brace
r_int
id|i
op_assign
id|dev-&gt;mult_count
ques
c_cond
id|dev-&gt;mult_count
op_lshift
l_int|8
suffix:colon
l_int|1
op_lshift
l_int|8
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
multiline_comment|/* try to flush data */
(paren
r_void
)paren
id|IN_BYTE
c_func
(paren
id|HD_DATA
comma
id|dev-&gt;hwif
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GET_STAT
c_func
(paren
id|dev-&gt;hwif
)paren
op_amp
(paren
id|BUSY_STAT
op_or
id|DRQ_STAT
)paren
)paren
id|rq-&gt;errors
op_or_assign
id|ERROR_RESET
suffix:semicolon
multiline_comment|/* Mmmm.. timing problem */
r_if
c_cond
(paren
id|rq-&gt;errors
op_ge
id|ERROR_MAX
)paren
id|end_request
c_func
(paren
l_int|0
comma
id|DEV_HWIF
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RESET
)paren
op_eq
id|ERROR_RESET
)paren
id|do_ide_reset
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RECAL
)paren
op_eq
id|ERROR_RECAL
)paren
id|dev-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
op_increment
id|rq-&gt;errors
suffix:semicolon
)brace
)brace
DECL|function|read_intr
r_static
r_void
id|read_intr
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|msect
comma
id|nsect
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
id|DEV_HWIF
)paren
comma
id|DATA_READY
comma
id|BAD_RW_STAT
)paren
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|ide_error
c_func
(paren
id|dev
comma
l_string|&quot;read_intr&quot;
comma
id|stat
)paren
suffix:semicolon
id|DO_REQUEST
suffix:semicolon
r_return
suffix:semicolon
)brace
id|msect
op_assign
id|dev-&gt;mult_count
suffix:semicolon
id|read_next
suffix:colon
id|rq
op_assign
id|ide_cur_rq
(braket
id|DEV_HWIF
)braket
suffix:semicolon
r_if
c_cond
(paren
id|msect
)paren
(brace
r_if
c_cond
(paren
(paren
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
)paren
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|msect
op_sub_assign
id|nsect
suffix:semicolon
)brace
r_else
id|nsect
op_assign
l_int|1
suffix:semicolon
id|IN_SECTORS
c_func
(paren
id|rq-&gt;buffer
comma
id|nsect
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s:  read: sectors(%ld-%ld), buffer=0x%08lx, remaining=%ld&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rq-&gt;sector
comma
id|rq-&gt;sector
op_plus
id|nsect
op_minus
l_int|1
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
op_plus
(paren
id|nsect
op_lshift
l_int|9
)paren
comma
id|rq-&gt;nr_sectors
op_minus
id|nsect
)paren
suffix:semicolon
macro_line|#endif
id|rq-&gt;sector
op_add_assign
id|nsect
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|nsect
op_lshift
l_int|9
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
(paren
id|rq-&gt;nr_sectors
op_sub_assign
id|nsect
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
)paren
op_le
l_int|0
)paren
id|end_request
c_func
(paren
l_int|1
comma
id|DEV_HWIF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|msect
)paren
r_goto
id|read_next
suffix:semicolon
id|ide_handler
(braket
id|DEV_HWIF
)braket
op_assign
op_amp
id|read_intr
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* (void) GET_STAT(DEV_HWIF); */
multiline_comment|/* hd.c did this */
id|DO_REQUEST
suffix:semicolon
)brace
DECL|function|write_intr
r_static
r_void
id|write_intr
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|ide_cur_rq
(braket
id|DEV_HWIF
)braket
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
id|DEV_HWIF
)paren
comma
id|DRIVE_READY
comma
id|BAD_RW_STAT
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: write: sector %ld, buffer=0x%08lx, remaining=%ld&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rq-&gt;sector
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
comma
id|rq-&gt;nr_sectors
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|rq-&gt;nr_sectors
op_eq
l_int|1
)paren
op_xor
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|rq-&gt;sector
op_increment
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
l_int|512
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
op_decrement
id|rq-&gt;nr_sectors
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_le
l_int|0
)paren
id|end_request
c_func
(paren
l_int|1
comma
id|DEV_HWIF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
id|ide_handler
(braket
id|DEV_HWIF
)braket
op_assign
op_amp
id|write_intr
suffix:semicolon
id|OUT_SECTORS
c_func
(paren
id|rq-&gt;buffer
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DO_REQUEST
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|ide_error
c_func
(paren
id|dev
comma
l_string|&quot;write_intr&quot;
comma
id|stat
)paren
suffix:semicolon
id|DO_REQUEST
suffix:semicolon
)brace
DECL|function|multwrite
r_static
r_void
id|multwrite
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
op_amp
id|ide_write_rq
(braket
id|DEV_HWIF
)braket
suffix:semicolon
r_int
r_int
id|mcount
op_assign
id|dev-&gt;mult_count
suffix:semicolon
r_do
(brace
r_int
r_int
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|mcount
)paren
id|nsect
op_assign
id|mcount
suffix:semicolon
id|mcount
op_sub_assign
id|nsect
suffix:semicolon
id|OUT_SECTORS
c_func
(paren
id|rq-&gt;buffer
comma
id|nsect
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: multwrite: sector %ld, buffer=0x%08lx, count=%d, remaining=%ld&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rq-&gt;sector
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
comma
id|nsect
comma
id|rq-&gt;nr_sectors
op_minus
id|nsect
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|rq-&gt;nr_sectors
op_sub_assign
id|nsect
)paren
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|rq-&gt;bh
op_assign
id|rq-&gt;bh-&gt;b_reqnext
)paren
op_ne
l_int|NULL
)paren
(brace
id|rq-&gt;current_nr_sectors
op_assign
id|rq-&gt;bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|rq-&gt;buffer
op_assign
id|rq-&gt;bh-&gt;b_data
suffix:semicolon
)brace
r_else
(brace
id|panic
c_func
(paren
l_string|&quot;%s: buffer list corrupted&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|rq-&gt;buffer
op_add_assign
id|nsect
op_lshift
l_int|9
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|mcount
)paren
suffix:semicolon
)brace
DECL|function|multwrite_intr
r_static
r_void
id|multwrite_intr
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
op_amp
id|ide_write_rq
(braket
id|DEV_HWIF
)braket
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
id|DEV_HWIF
)paren
comma
id|DRIVE_READY
comma
id|BAD_RW_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;nr_sectors
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;mult_count
)paren
id|multwrite
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ide_handler
(braket
id|DEV_HWIF
)braket
op_assign
op_amp
id|multwrite_intr
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;nr_sectors
)paren
(brace
multiline_comment|/* all done? */
id|rq
op_assign
id|ide_cur_rq
(braket
id|DEV_HWIF
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|i
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
comma
id|DEV_HWIF
)paren
suffix:semicolon
)brace
id|DO_REQUEST
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|ide_error
c_func
(paren
id|dev
comma
l_string|&quot;multwrite_intr&quot;
comma
id|stat
)paren
suffix:semicolon
id|DO_REQUEST
suffix:semicolon
)brace
multiline_comment|/*&n; * Issue a simple drive command&n; * The drive must be selected beforehand.&n; */
DECL|function|ide_cmd
r_static
r_inline
r_void
id|ide_cmd
c_func
(paren
id|ide_dev_t
op_star
id|dev
comma
id|byte
id|cmd
comma
id|byte
id|nsect
comma
r_void
(paren
op_star
id|handler
)paren
(paren
id|ide_dev_t
op_star
id|dev
)paren
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|dev-&gt;ctl
comma
id|HD_CMD
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|nsect
comma
id|HD_NSECTOR
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|cmd
comma
id|HD_COMMAND
)paren
suffix:semicolon
id|ide_handler
(braket
id|DEV_HWIF
)braket
op_assign
id|handler
suffix:semicolon
)brace
DECL|function|set_multmode_intr
r_static
r_void
id|set_multmode_intr
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
id|DEV_HWIF
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
id|dev-&gt;mult_req
op_assign
id|dev-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
(paren
r_void
)paren
id|dump_status
c_func
(paren
id|DEV_HWIF
comma
l_string|&quot;set_multmode&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;mult_count
op_assign
id|dev-&gt;mult_req
)paren
)paren
id|printk
(paren
l_string|&quot;  %s: enabled %d-sector multiple mode&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;mult_count
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;  %s: disabled multiple mode&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
id|DO_REQUEST
suffix:semicolon
)brace
DECL|function|set_geometry_intr
r_static
r_void
id|set_geometry_intr
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
id|DEV_HWIF
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
id|ide_error
c_func
(paren
id|dev
comma
l_string|&quot;set_geometry_intr&quot;
comma
id|stat
)paren
suffix:semicolon
id|DO_REQUEST
suffix:semicolon
)brace
DECL|function|recal_intr
r_static
r_void
id|recal_intr
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
id|DEV_HWIF
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
id|ide_error
c_func
(paren
id|dev
comma
l_string|&quot;recal_intr&quot;
comma
id|stat
)paren
suffix:semicolon
id|DO_REQUEST
suffix:semicolon
)brace
DECL|function|drive_cmd_intr
r_static
r_void
id|drive_cmd_intr
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
id|DEV_HWIF
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
id|ide_error
c_func
(paren
id|dev
comma
l_string|&quot;drive_cmd&quot;
comma
id|stat
)paren
suffix:semicolon
multiline_comment|/* calls end_drive_cmd() */
r_else
id|end_drive_cmd
(paren
id|dev
comma
id|stat
comma
id|GET_ERR
c_func
(paren
id|DEV_HWIF
)paren
)paren
suffix:semicolon
id|DO_REQUEST
suffix:semicolon
)brace
DECL|function|timer_expiry
r_static
r_void
id|timer_expiry
(paren
id|byte
id|hwif
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_handler
(braket
id|HWIF
)braket
op_eq
l_int|NULL
op_logical_or
(paren
id|timer_active
op_amp
id|ide_timerbit
(braket
id|HWIF
)braket
)paren
)paren
(brace
multiline_comment|/* The drive must have responded just as the timer expired */
id|sti
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: marginal timeout&bslash;n&quot;
comma
id|ide_name
(braket
id|HWIF
)braket
)paren
suffix:semicolon
)brace
r_else
(brace
id|ide_handler
(braket
id|HWIF
)braket
op_assign
l_int|NULL
suffix:semicolon
id|disable_irq
c_func
(paren
id|ide_irq
(braket
id|HWIF
)braket
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|ide_error
c_func
(paren
id|ide_cur_dev
(braket
id|HWIF
)braket
comma
l_string|&quot;timeout&quot;
comma
id|GET_STAT
c_func
(paren
id|HWIF
)paren
)paren
suffix:semicolon
id|do_request
c_func
(paren
id|HWIF
)paren
suffix:semicolon
macro_line|#if SUPPORT_SHARING_IRQ
r_if
c_cond
(paren
id|sharing_single_irq
)paren
multiline_comment|/* this line is indeed necessary */
id|hwif
op_assign
id|current_hwif
suffix:semicolon
macro_line|#endif /* SUPPORT_SHARING_IRQ */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|start_ide_timer
c_func
(paren
id|HWIF
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|ide_irq
(braket
id|HWIF
)braket
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|ide0_timer_expiry
r_static
r_void
id|ide0_timer_expiry
(paren
r_void
)paren
multiline_comment|/* invoked from sched.c */
(brace
id|timer_expiry
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|ide1_timer_expiry
r_static
r_void
id|ide1_timer_expiry
(paren
r_void
)paren
multiline_comment|/* invoked from sched.c */
(brace
id|timer_expiry
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|do_special
r_static
r_int
id|do_special
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
id|special_t
op_star
id|s
op_assign
op_amp
id|dev-&gt;special
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: do_special: 0x%02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|s-&gt;all
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|s-&gt;b.set_geometry
)paren
(brace
id|s-&gt;b.set_geometry
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|disk
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|dev-&gt;sect
comma
id|HD_SECTOR
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|dev-&gt;cyl
comma
id|HD_LCYL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|dev-&gt;cyl
op_rshift
l_int|8
comma
id|HD_HCYL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
(paren
(paren
id|dev-&gt;head
op_minus
l_int|1
)paren
op_or
id|dev-&gt;select.all
)paren
op_amp
l_int|0xBF
comma
id|HD_CURRENT
)paren
suffix:semicolon
id|ide_cmd
c_func
(paren
id|dev
comma
id|WIN_SPECIFY
comma
id|dev-&gt;sect
comma
op_amp
id|set_geometry_intr
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;b.recalibrate
)paren
(brace
id|s-&gt;b.recalibrate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|disk
)paren
id|ide_cmd
c_func
(paren
id|dev
comma
id|WIN_RESTORE
comma
id|dev-&gt;sect
comma
op_amp
id|recal_intr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;b.set_multmode
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;id
op_logical_and
id|dev-&gt;id-&gt;max_multsect
op_logical_and
id|dev-&gt;type
op_eq
id|disk
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;mult_req
OG
id|dev-&gt;id-&gt;max_multsect
)paren
id|dev-&gt;mult_req
op_assign
id|dev-&gt;id-&gt;max_multsect
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mult_req
op_ne
id|dev-&gt;mult_count
)paren
id|ide_cmd
c_func
(paren
id|dev
comma
id|WIN_SETMULT
comma
id|dev-&gt;mult_req
comma
op_amp
id|set_multmode_intr
)paren
suffix:semicolon
)brace
r_else
(brace
id|dev-&gt;mult_req
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: multmode not supported by this device&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
id|s-&gt;b.set_multmode
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|s-&gt;all
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: bad special flag: 0x%02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|s-&gt;all
)paren
suffix:semicolon
id|s-&gt;all
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
(paren
id|ide_handler
(braket
id|DEV_HWIF
)braket
op_eq
l_int|NULL
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
DECL|function|wait_stat
r_static
id|byte
id|wait_stat
(paren
id|ide_dev_t
op_star
id|dev
comma
id|byte
id|good
comma
id|byte
id|bad
comma
r_int
r_int
id|timeout
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|WAIT_STAT
c_func
(paren
id|dev
comma
id|good
comma
id|bad
comma
id|timeout
comma
l_string|&quot;status&quot;
comma
id|error
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|error
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#include &quot;ide-cd.c&quot;
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
DECL|function|do_rw_disk
r_static
r_inline
r_int
id|do_rw_disk
(paren
id|ide_dev_t
op_star
id|dev
comma
r_struct
id|request
op_star
id|rq
comma
r_int
r_int
id|block
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|dev-&gt;ctl
comma
id|HD_CMD
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|rq-&gt;nr_sectors
comma
id|HD_NSECTOR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;select.b.lba
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: %sing: LBAsect=%ld, sectors=%ld, buffer=0x%08lx&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|rq-&gt;cmd
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;writ&quot;
comma
id|block
comma
id|rq-&gt;nr_sectors
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
)paren
suffix:semicolon
macro_line|#endif
id|OUT_BYTE
c_func
(paren
id|block
comma
id|HD_SECTOR
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|block
op_rshift_assign
l_int|8
comma
id|HD_LCYL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|block
op_rshift_assign
l_int|8
comma
id|HD_HCYL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
(paren
(paren
id|block
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
)paren
op_or
id|dev-&gt;select.all
comma
id|HD_CURRENT
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|sect
comma
id|head
comma
id|cyl
comma
id|track
suffix:semicolon
id|track
op_assign
id|block
op_div
id|dev-&gt;sect
suffix:semicolon
id|sect
op_assign
id|block
op_mod
id|dev-&gt;sect
op_plus
l_int|1
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|sect
comma
id|HD_SECTOR
)paren
suffix:semicolon
id|head
op_assign
id|track
op_mod
id|dev-&gt;head
suffix:semicolon
id|cyl
op_assign
id|track
op_div
id|dev-&gt;head
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|cyl
comma
id|HD_LCYL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|cyl
op_rshift
l_int|8
comma
id|HD_HCYL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|head
op_or
id|dev-&gt;select.all
comma
id|HD_CURRENT
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: %sing: CHS=%d/%d/%d, sectors=%ld, buffer=0x%08lx&bslash;n&quot;
comma
id|dev-&gt;name
comma
(paren
id|rq-&gt;cmd
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;writ&quot;
comma
id|cyl
comma
id|head
comma
id|sect
comma
id|rq-&gt;nr_sectors
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|READ
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|dev-&gt;mult_count
ques
c_cond
id|WIN_MULTREAD
suffix:colon
id|WIN_READ
comma
id|HD_COMMAND
)paren
suffix:semicolon
id|ide_handler
(braket
id|DEV_HWIF
)braket
op_assign
op_amp
id|read_intr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|WRITE
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|dev-&gt;wpcom
comma
id|HD_PRECOMP
)paren
suffix:semicolon
multiline_comment|/* for ancient drives */
id|OUT_BYTE
c_func
(paren
id|dev-&gt;mult_count
ques
c_cond
id|WIN_MULTWRITE
suffix:colon
id|WIN_WRITE
comma
id|HD_COMMAND
)paren
suffix:semicolon
id|WAIT_STAT
c_func
(paren
id|dev
comma
id|DATA_READY
comma
id|BAD_RW_STAT
comma
id|WAIT_DRQ
comma
l_string|&quot;DRQ&quot;
comma
id|error
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;unmask
)paren
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;mult_count
)paren
(brace
id|ide_write_rq
(braket
id|DEV_HWIF
)braket
op_assign
op_star
id|rq
suffix:semicolon
multiline_comment|/* scratchpad */
id|multwrite
c_func
(paren
id|dev
)paren
suffix:semicolon
id|ide_handler
(braket
id|DEV_HWIF
)braket
op_assign
op_amp
id|multwrite_intr
suffix:semicolon
)brace
r_else
(brace
id|OUT_SECTORS
c_func
(paren
id|rq-&gt;buffer
comma
l_int|1
)paren
suffix:semicolon
id|ide_handler
(braket
id|DEV_HWIF
)braket
op_assign
op_amp
id|write_intr
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef IDE_DRIVE_CMD
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|IDE_DRIVE_CMD
)paren
(brace
id|byte
op_star
id|args
op_assign
id|rq-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
id|args
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|args
(braket
l_int|2
)braket
comma
id|HD_FEATURE
)paren
suffix:semicolon
id|ide_cmd
c_func
(paren
id|dev
comma
id|args
(braket
l_int|0
)braket
comma
id|args
(braket
l_int|1
)braket
comma
op_amp
id|drive_cmd_intr
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: DRIVE_CMD cmd=0x%02x sc=0x%02x fr=0x%02x&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|args
(braket
l_int|0
)braket
comma
id|args
(braket
l_int|1
)braket
comma
id|args
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: DRIVE_CMD (null)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|end_drive_cmd
c_func
(paren
id|dev
comma
id|GET_STAT
c_func
(paren
id|DEV_HWIF
)paren
comma
id|GET_ERR
c_func
(paren
id|DEV_HWIF
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* IDE_DRIVE_CMD */
id|printk
c_func
(paren
l_string|&quot;%s: bad command: %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rq-&gt;cmd
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
comma
id|DEV_HWIF
)paren
suffix:semicolon
id|error
suffix:colon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * The driver enables interrupts as much as possible.  In order to do this,&n; * (a) the device-interrupt is always masked before entry, and&n; * (b) the timeout-interrupt is always disabled before entry.&n; *&n; * Interrupts are still masked (by default) whenever we are exchanging&n; * data/cmds with a drive, because some drives seem to have very poor&n; * tolerance for latency during I/O.  For devices which don&squot;t suffer from&n; * this problem (most don&squot;t), the ide_dev[][].unmask flag can be set to permit&n; * other interrupts during data/cmd transfers by using the &quot;hdparm&quot; utility.&n; */
DECL|function|do_request
r_static
r_void
id|do_request
(paren
id|byte
id|hwif
)paren
(brace
r_int
r_int
id|minor
comma
id|drive
suffix:semicolon
r_int
r_int
id|block
comma
id|blockend
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|ide_dev_t
op_star
id|dev
suffix:semicolon
id|repeat
suffix:colon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#if SUPPORT_SHARING_IRQ
id|current_hwif
op_assign
id|hwif
suffix:semicolon
multiline_comment|/* used *only* when sharing_single_irq==1 */
macro_line|#endif /* SUPPORT_SHARING_IRQ */
r_if
c_cond
(paren
(paren
id|rq
op_assign
id|ide_cur_rq
(braket
id|HWIF
)braket
)paren
op_eq
l_int|NULL
)paren
(brace
id|rq
op_assign
id|blk_dev
(braket
id|ide_major
(braket
id|HWIF
)braket
)braket
dot
id|current_request
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|rq-&gt;dev
OL
l_int|0
)paren
)paren
(brace
macro_line|#if SUPPORT_SHARING_IRQ
r_if
c_cond
(paren
id|sharing_single_irq
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|ide_cur_dev
(braket
id|hwif
)braket
)paren
)paren
multiline_comment|/* disable irq */
id|OUT_BYTE
c_func
(paren
id|dev-&gt;ctl
op_or
l_int|2
comma
id|HD_CMD
)paren
suffix:semicolon
id|rq
op_assign
id|blk_dev
(braket
id|ide_major
(braket
id|hwif
op_xor_assign
l_int|1
)braket
)braket
dot
id|current_request
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq
op_ne
l_int|NULL
)paren
op_logical_and
(paren
id|rq-&gt;dev
op_ge
l_int|0
)paren
)paren
r_goto
id|repeat
suffix:semicolon
)brace
macro_line|#endif /* SUPPORT_SHARING_IRQ */
r_return
suffix:semicolon
)brace
id|blk_dev
(braket
id|ide_major
(braket
id|HWIF
)braket
)braket
dot
id|current_request
op_assign
id|rq-&gt;next
suffix:semicolon
id|ide_cur_rq
(braket
id|HWIF
)braket
op_assign
id|rq
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: do_request: current=0x%08lx&bslash;n&quot;
comma
id|ide_name
(braket
id|HWIF
)braket
comma
(paren
r_int
r_int
)paren
id|rq
)paren
suffix:semicolon
macro_line|#endif
id|minor
op_assign
id|MINOR
c_func
(paren
id|rq-&gt;dev
)paren
suffix:semicolon
id|drive
op_assign
id|minor
op_rshift
id|PARTN_BITS
suffix:semicolon
id|ide_cur_dev
(braket
id|HWIF
)braket
op_assign
id|dev
op_assign
op_amp
id|ide_dev
(braket
id|HWIF
)braket
(braket
id|drive
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|MAJOR
c_func
(paren
id|rq-&gt;dev
)paren
op_ne
id|ide_major
(braket
id|HWIF
)braket
)paren
op_logical_or
(paren
id|drive
op_ge
id|MAX_DRIVES
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: bad device number: 0x%04x&bslash;n&quot;
comma
id|ide_name
(braket
id|HWIF
)braket
comma
id|rq-&gt;dev
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
comma
id|HWIF
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;bh
op_logical_and
op_logical_neg
id|rq-&gt;bh-&gt;b_lock
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: block not locked&bslash;n&quot;
comma
id|ide_name
(braket
id|HWIF
)braket
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
comma
id|HWIF
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|block
op_assign
id|rq-&gt;sector
suffix:semicolon
id|blockend
op_assign
id|block
op_plus
id|rq-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
(paren
id|blockend
OL
id|block
)paren
op_logical_or
(paren
id|blockend
OG
id|ide_hd
(braket
id|HWIF
)braket
(braket
id|minor
)braket
dot
id|nr_sects
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: bad access: block=%ld, count=%ld&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|block
comma
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
comma
id|HWIF
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|block
op_add_assign
id|ide_hd
(braket
id|HWIF
)braket
(braket
id|minor
)braket
dot
id|start_sect
suffix:semicolon
macro_line|#if (DISK_RECOVERY_TIME &gt; 0)
r_while
c_loop
(paren
(paren
id|read_timer
c_func
(paren
)paren
op_minus
id|ide_lastreq
(braket
id|HWIF
)braket
)paren
OL
id|DISK_RECOVERY_TIME
)paren
suffix:semicolon
macro_line|#endif
id|OUT_BYTE
c_func
(paren
id|dev-&gt;select.all
comma
id|HD_CURRENT
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
id|WAIT_STAT
c_func
(paren
id|dev
comma
(paren
id|dev-&gt;type
op_eq
id|cdrom
)paren
ques
c_cond
l_int|0
suffix:colon
id|READY_STAT
comma
id|BUSY_STAT
op_or
id|DRQ_STAT
comma
id|WAIT_READY
comma
l_string|&quot;DRDY&quot;
comma
id|repeat
)paren
suffix:semicolon
macro_line|#else
id|WAIT_STAT
c_func
(paren
id|dev
comma
id|READY_STAT
comma
id|BUSY_STAT
op_or
id|DRQ_STAT
comma
id|WAIT_READY
comma
l_string|&quot;DRDY&quot;
comma
id|repeat
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;special.all
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|disk
)paren
(brace
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
r_if
c_cond
(paren
id|do_rw_disk
c_func
(paren
id|dev
comma
id|rq
comma
id|block
)paren
)paren
r_goto
id|repeat
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
)brace
r_else
(brace
r_if
c_cond
(paren
id|do_rw_cdrom
c_func
(paren
id|dev
comma
id|block
)paren
)paren
r_goto
id|repeat
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
)brace
r_else
(brace
r_if
c_cond
(paren
id|do_special
c_func
(paren
id|dev
)paren
)paren
r_goto
id|repeat
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is a macro rather than an inline function to&n; * prevent gcc from over-optimizing accesses to current_hwif,&n; * which may have a different value on exit from do_request().&n; */
DECL|macro|DO_IDE_REQUEST
mdefine_line|#define DO_IDE_REQUEST(hwif)&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&bslash;&n;&t;if (ide_handler[hwif] == NULL) {&t;&bslash;&n;&t;&t;disable_irq(ide_irq[hwif]);&t;&bslash;&n;&t;&t;do_request(hwif);&t;&t;&bslash;&n;&t;&t;cli();&t;&t;&t;&t;&bslash;&n;&t;&t;start_ide_timer(hwif);&t;&t;&bslash;&n;&t;&t;enable_irq(ide_irq[hwif]);&t;&bslash;&n;&t;}&t;&t;&t;&t;&t;&bslash;&n;}
macro_line|#if SUPPORT_TWO_INTERFACES
DECL|function|do_ide0_request
r_static
r_void
id|do_ide0_request
(paren
r_void
)paren
multiline_comment|/* invoked with cli() */
(brace
id|DO_IDE_REQUEST
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|do_ide1_request
r_static
r_void
id|do_ide1_request
(paren
r_void
)paren
multiline_comment|/* invoked with cli() */
(brace
id|DO_IDE_REQUEST
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#else
DECL|macro|do_ide1_request
mdefine_line|#define do_ide1_request&t;do_ide0_request
DECL|function|do_ide0_request
r_static
r_void
id|do_ide0_request
(paren
r_void
)paren
multiline_comment|/* invoked with cli() */
(brace
id|DO_IDE_REQUEST
c_func
(paren
id|HWIF
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* SUPPORT_TWO_INTERFACES */
macro_line|#if SUPPORT_SHARING_IRQ
DECL|function|do_shared_request
r_static
r_void
id|do_shared_request
(paren
r_void
)paren
multiline_comment|/* invoked with cli() */
(brace
id|DO_IDE_REQUEST
c_func
(paren
id|current_hwif
)paren
suffix:semicolon
)brace
macro_line|#endif /* SUPPORT_SHARING_IRQ */
multiline_comment|/*&n; * There&squot;s nothing really useful we can do with an unexpected interrupt,&n; * other than reading the status register (to clear it), and logging it.&n; * There should be no way that an irq can happen before we&squot;re ready for it,&n; * so we needn&squot;t worry much about losing an &quot;important&quot; interrupt here.&n; *&n; * On laptops (and &quot;green&quot; PCs), an unexpected interrupt occurs whenever the&n; * drive enters &quot;idle&quot;, &quot;standby&quot;, or &quot;sleep&quot; mode, so if the status looks&n; * &quot;good&quot;, we just ignore the interrupt completely.&n; */
DECL|function|unexpected_intr
r_static
r_void
id|unexpected_intr
(paren
id|byte
id|hwif
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
id|HWIF
)paren
comma
id|DRIVE_READY
comma
id|BAD_STAT
)paren
)paren
(paren
r_void
)paren
id|dump_status
c_func
(paren
id|HWIF
comma
l_string|&quot;unexpected_intr&quot;
comma
id|stat
)paren
suffix:semicolon
macro_line|#if SUPPORT_SHARING_IRQ
r_if
c_cond
(paren
id|sharing_single_irq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
id|hwif
op_xor
l_int|1
)paren
comma
id|DRIVE_READY
comma
id|BAD_STAT
)paren
)paren
(paren
r_void
)paren
id|dump_status
c_func
(paren
id|hwif
op_xor
l_int|1
comma
l_string|&quot;unexpected_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
macro_line|#endif /* SUPPORT_SHARING_IRQ */
)brace
multiline_comment|/*&n; * This is a macro rather than an inline function to&n; * prevent gcc from over-optimizing accesses to current_hwif,&n; * which may have a different value on exit from handler().&n; */
DECL|macro|IDE_INTR
mdefine_line|#define IDE_INTR(hwif)&t;&t;&t;&t;&t;&bslash;&n;{&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;ide_dev_t *dev;&t;&t;&t;&t;&t;&bslash;&n;&t;void (*handler)(ide_dev_t *);&t;&t;&t;&bslash;&n;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;timer_active &amp;= ~ide_timerbit[hwif];&t;&t;&bslash;&n;&t;if ((handler = ide_handler[hwif]) != NULL) {&t;&bslash;&n;&t;&t;ide_handler[hwif] = NULL;&t;&t;&bslash;&n;&t;&t;dev = ide_cur_dev[hwif];&t;&t;&bslash;&n;&t;&t;if (dev-&gt;unmask)&t;&t;&t;&bslash;&n;&t;&t;&t;sti();&t;&t;&t;&t;&bslash;&n;&t;&t;handler(dev);&t;&t;&t;&t;&bslash;&n;&t;} else&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;unexpected_intr(hwif);&t;&t;&t;&bslash;&n;&t;cli();&t;&t;&t;&t;&t;&t;&bslash;&n;&t;start_ide_timer(hwif);&t;&t;&t;&t;&bslash;&n;}
macro_line|#if OPTIMIZE_IRQS
multiline_comment|/* entry point for all interrupts on ide0 when sharing_single_irq==0 */
DECL|function|ide0_intr
r_static
r_void
id|ide0_intr
(paren
r_int
id|irq
)paren
(brace
id|IDE_INTR
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* entry point for all interrupts on ide1 when sharing_single_irq==0 */
DECL|function|ide1_intr
r_static
r_void
id|ide1_intr
(paren
r_int
id|irq
)paren
(brace
id|IDE_INTR
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#else&t;/* OPTIMIZE_IRQS */
DECL|macro|ide0_intr
mdefine_line|#define ide0_intr&t;ide_intr
DECL|macro|ide1_intr
mdefine_line|#define ide1_intr&t;ide_intr
multiline_comment|/* entry point for all interrupts when sharing_single_irq==0 */
DECL|function|ide_intr
r_static
r_void
id|ide_intr
(paren
r_int
id|irq
)paren
(brace
macro_line|#if SUPPORT_TWO_INTERFACES
id|byte
id|hwif
op_assign
(paren
id|irq
op_ne
id|ide_irq
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif&t;/* SUPPORT_TWO_INTERFACES */
id|IDE_INTR
c_func
(paren
id|HWIF
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* OPTIMIZE_IRQS */
macro_line|#if SUPPORT_SHARING_IRQ
multiline_comment|/* entry point for all interrupts on ide0/ide1 when sharing_single_irq==1 */
DECL|function|ide_shared_intr
r_static
r_void
id|ide_shared_intr
(paren
r_int
id|irq
)paren
(brace
id|IDE_INTR
c_func
(paren
id|current_hwif
)paren
suffix:semicolon
)brace
macro_line|#endif /* SUPPORT_SHARING_IRQ */
DECL|function|get_info_ptr
r_static
id|ide_dev_t
op_star
id|get_info_ptr
(paren
r_int
id|i_rdev
)paren
(brace
r_int
r_int
id|drive
op_assign
id|DEVICE_NR
c_func
(paren
id|i_rdev
)paren
suffix:semicolon
id|ide_dev_t
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|drive
OL
id|MAX_DRIVES
)paren
(brace
r_switch
c_cond
(paren
id|MAJOR
c_func
(paren
id|i_rdev
)paren
)paren
(brace
r_case
id|IDE0_MAJOR
suffix:colon
id|dev
op_assign
op_amp
id|ide_dev
(braket
l_int|0
)braket
(braket
id|drive
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;present
)paren
r_return
id|dev
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IDE1_MAJOR
suffix:colon
id|dev
op_assign
op_amp
id|ide_dev
(braket
l_int|1
)braket
(braket
id|drive
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;present
)paren
r_return
id|dev
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|ide_open
r_static
r_int
id|ide_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|ide_dev_t
op_star
id|dev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|get_info_ptr
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|dev-&gt;busy
)paren
id|sleep_on
c_func
(paren
op_amp
id|dev-&gt;wqueue
)paren
suffix:semicolon
id|dev-&gt;usage
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|cdrom
)paren
r_return
id|cdrom_open
(paren
id|inode
comma
id|filp
comma
id|dev
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Releasing a block device means we sync() it, so that it can safely&n; * be forgotten about...&n; */
DECL|function|ide_release
r_static
r_void
id|ide_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|ide_dev_t
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|get_info_ptr
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|sync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|dev-&gt;usage
op_decrement
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|cdrom
)paren
id|cdrom_release
(paren
id|inode
comma
id|file
comma
id|dev
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
)brace
)brace
multiline_comment|/*&n; * This routine is called to flush all partitions and partition tables&n; * for a changed disk, and then re-read the new partition table.&n; * If we are revalidating a disk because of a media change, then we&n; * enter with usage == 0.  If we are using an ioctl, we automatically have&n; * usage == 1 (we need an open channel to use an ioctl :-), so this&n; * is our limit.&n; */
DECL|function|revalidate_disk
r_static
r_int
id|revalidate_disk
c_func
(paren
r_int
id|i_rdev
)paren
(brace
r_int
r_int
id|i
comma
id|major
comma
id|start
comma
id|drive
op_assign
id|DEVICE_NR
c_func
(paren
id|i_rdev
)paren
suffix:semicolon
id|ide_dev_t
op_star
id|dev
suffix:semicolon
r_struct
id|gendisk
op_star
id|gd
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|get_info_ptr
c_func
(paren
id|i_rdev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;busy
op_logical_or
(paren
id|dev-&gt;usage
OG
l_int|1
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
suffix:semicolon
id|dev-&gt;busy
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|gd
op_assign
op_amp
id|ide_gendisk
(braket
id|DEV_HWIF
)braket
suffix:semicolon
id|major
op_assign
id|ide_major
(braket
id|DEV_HWIF
)braket
op_lshift
l_int|8
suffix:semicolon
id|start
op_assign
id|drive
op_lshift
id|PARTN_BITS
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
l_int|1
op_lshift
id|PARTN_BITS
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
r_int
id|minor
op_assign
id|start
op_plus
id|i
suffix:semicolon
id|sync_dev
(paren
id|major
op_or
id|minor
)paren
suffix:semicolon
id|invalidate_inodes
(paren
id|major
op_or
id|minor
)paren
suffix:semicolon
id|invalidate_buffers
(paren
id|major
op_or
id|minor
)paren
suffix:semicolon
id|gd-&gt;part
(braket
id|minor
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|gd-&gt;part
(braket
id|minor
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
)brace
suffix:semicolon
id|gd-&gt;part
(braket
id|start
)braket
dot
id|nr_sects
op_assign
id|ide_capacity
(braket
id|DEV_HWIF
)braket
(braket
id|drive
)braket
suffix:semicolon
id|resetup_one_dev
c_func
(paren
id|gd
comma
id|drive
)paren
suffix:semicolon
id|dev-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|dev-&gt;wqueue
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This function issues a specific IDE drive command onto the&n; * tail of the request queue, and waits for it to be completed.&n; * If arg is NULL, it goes through all the motions,&n; * but without actually sending a command to the drive.&n; */
DECL|function|do_drive_cmd
r_static
r_int
id|do_drive_cmd
c_func
(paren
r_int
id|dev
comma
r_char
op_star
id|args
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|request
id|rq
comma
op_star
id|cur_rq
suffix:semicolon
r_struct
id|blk_dev_struct
op_star
id|bdev
suffix:semicolon
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
multiline_comment|/* build up a special request, and add it to the queue */
id|rq.buffer
op_assign
id|args
suffix:semicolon
id|rq.cmd
op_assign
id|IDE_DRIVE_CMD
suffix:semicolon
id|rq.errors
op_assign
l_int|0
suffix:semicolon
id|rq.sector
op_assign
l_int|0
suffix:semicolon
id|rq.nr_sectors
op_assign
l_int|0
suffix:semicolon
id|rq.current_nr_sectors
op_assign
l_int|0
suffix:semicolon
id|rq.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|rq.bh
op_assign
l_int|NULL
suffix:semicolon
id|rq.bhtail
op_assign
l_int|NULL
suffix:semicolon
id|rq.next
op_assign
l_int|NULL
suffix:semicolon
id|rq.dev
op_assign
id|dev
suffix:semicolon
id|bdev
op_assign
op_amp
id|blk_dev
(braket
id|major
)braket
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|cur_rq
op_assign
id|bdev-&gt;current_request
suffix:semicolon
r_if
c_cond
(paren
id|cur_rq
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* empty request list? */
id|bdev-&gt;current_request
op_assign
op_amp
id|rq
suffix:semicolon
multiline_comment|/* service ours immediately */
id|bdev
op_member_access_from_pointer
id|request_fn
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
id|cur_rq-&gt;next
op_ne
l_int|NULL
)paren
multiline_comment|/* find end of request list */
id|cur_rq
op_assign
id|cur_rq-&gt;next
suffix:semicolon
id|cur_rq-&gt;next
op_assign
op_amp
id|rq
suffix:semicolon
multiline_comment|/* add rq to the end */
)brace
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
multiline_comment|/* wait for it to be serviced */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|rq.errors
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* return -EIO if errors */
)brace
DECL|function|write_fs_long
r_static
r_int
id|write_fs_long
(paren
r_int
r_int
id|useraddr
comma
r_int
id|value
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
r_int
op_star
)paren
id|useraddr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|useraddr
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
id|put_fs_long
c_func
(paren
(paren
r_int
)paren
id|value
comma
(paren
r_int
op_star
)paren
id|useraddr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_ioctl
r_static
r_int
id|ide_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|hd_geometry
op_star
id|loc
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
r_int
id|err
suffix:semicolon
id|ide_dev_t
op_star
id|dev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_or
op_logical_neg
id|inode-&gt;i_rdev
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|get_info_ptr
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|loc
op_logical_or
id|dev-&gt;type
op_ne
id|disk
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|loc
comma
r_sizeof
(paren
op_star
id|loc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|put_fs_byte
c_func
(paren
id|dev-&gt;bios_head
comma
(paren
r_char
op_star
)paren
op_amp
id|loc-&gt;heads
)paren
suffix:semicolon
id|put_fs_byte
c_func
(paren
id|dev-&gt;bios_sect
comma
(paren
r_char
op_star
)paren
op_amp
id|loc-&gt;sectors
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
id|dev-&gt;bios_cyl
comma
(paren
r_int
op_star
)paren
op_amp
id|loc-&gt;cylinders
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
(paren
r_int
)paren
id|ide_hd
(braket
id|DEV_HWIF
)braket
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|start_sect
comma
(paren
r_int
op_star
)paren
op_amp
id|loc-&gt;start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKFLSBUF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRASET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
OG
l_int|0xff
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRAGET
suffix:colon
r_return
id|write_fs_long
c_func
(paren
id|arg
comma
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
)paren
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
multiline_comment|/* Return device size */
r_return
id|write_fs_long
c_func
(paren
id|arg
comma
id|ide_hd
(braket
id|DEV_HWIF
)braket
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|nr_sects
)paren
suffix:semicolon
r_case
id|BLKRRPART
suffix:colon
multiline_comment|/* Re-read partition tables */
r_return
id|revalidate_disk
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_case
id|HDIO_GET_KEEPSETTINGS
suffix:colon
r_return
id|write_fs_long
c_func
(paren
id|arg
comma
id|dev-&gt;keep_settings
)paren
suffix:semicolon
r_case
id|HDIO_GET_UNMASKINTR
suffix:colon
r_return
id|write_fs_long
c_func
(paren
id|arg
comma
id|dev-&gt;unmask
)paren
suffix:semicolon
r_case
id|HDIO_GET_MULTCOUNT
suffix:colon
r_return
id|write_fs_long
c_func
(paren
id|arg
comma
id|dev-&gt;mult_count
)paren
suffix:semicolon
r_case
id|HDIO_GET_IDENTITY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
op_logical_or
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;id
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMSG
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
op_star
id|dev-&gt;id
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
(paren
r_char
op_star
)paren
id|dev-&gt;id
comma
r_sizeof
(paren
op_star
id|dev-&gt;id
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|HDIO_SET_KEEPSETTINGS
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg
OG
l_int|1
)paren
op_logical_or
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dev-&gt;keep_settings
op_assign
id|arg
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|HDIO_SET_UNMASKINTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
(paren
id|arg
OG
l_int|1
)paren
op_logical_or
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dev-&gt;unmask
op_assign
id|arg
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|HDIO_SET_MULTCOUNT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev-&gt;id
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|arg
OG
id|dev-&gt;id-&gt;max_multsect
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;special.b.set_multmode
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|dev-&gt;mult_req
op_assign
id|arg
suffix:semicolon
id|dev-&gt;special.b.set_multmode
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|do_drive_cmd
(paren
id|inode-&gt;i_rdev
comma
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
id|dev-&gt;mult_count
op_eq
id|arg
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
macro_line|#ifdef IDE_DRIVE_CMD
r_case
id|HDIO_DRIVE_CMD
suffix:colon
(brace
r_int
r_int
id|args
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
r_int
op_star
)paren
id|arg
)paren
id|err
op_assign
id|do_drive_cmd
c_func
(paren
id|inode-&gt;i_rdev
comma
l_int|NULL
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
)paren
(brace
id|args
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|err
op_assign
id|do_drive_cmd
c_func
(paren
id|inode-&gt;i_rdev
comma
(paren
r_char
op_star
)paren
op_amp
id|args
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|args
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
)brace
)brace
r_return
id|err
suffix:semicolon
)brace
macro_line|#endif /* IDE_DRIVE_CMD */
id|RO_IOCTLS
c_func
(paren
id|inode-&gt;i_rdev
comma
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
(brace
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|cdrom
)paren
r_return
id|ide_cdrom_ioctl
c_func
(paren
id|dev
comma
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDECD */
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
DECL|function|ide_check_media_change
r_static
r_int
id|ide_check_media_change
(paren
id|dev_t
id|full_dev
)paren
(brace
id|ide_dev_t
op_star
id|dev
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_assign
id|get_info_ptr
c_func
(paren
id|full_dev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;type
op_ne
id|cdrom
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|cdrom_check_media_change
(paren
id|dev
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
DECL|function|fixstring
r_static
r_void
id|fixstring
(paren
id|byte
op_star
id|s
comma
r_int
id|bytecount
comma
r_int
id|byteswap
)paren
(brace
id|byte
op_star
id|p
comma
op_star
id|end
op_assign
op_amp
id|s
(braket
id|bytecount
op_and_assign
op_complement
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bytecount must be even */
r_if
c_cond
(paren
id|byteswap
)paren
(brace
multiline_comment|/* convert from big-endian to little-endian */
r_for
c_loop
(paren
id|p
op_assign
id|end
suffix:semicolon
id|p
op_ne
id|s
suffix:semicolon
)paren
(brace
r_int
r_int
op_star
id|pp
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|p
op_sub_assign
l_int|2
)paren
suffix:semicolon
op_star
id|pp
op_assign
(paren
op_star
id|pp
op_rshift
l_int|8
)paren
op_or
(paren
op_star
id|pp
op_lshift
l_int|8
)paren
suffix:semicolon
)brace
)brace
id|p
op_assign
id|s
suffix:semicolon
multiline_comment|/* strip leading blanks */
r_while
c_loop
(paren
id|s
op_ne
id|end
op_logical_and
op_star
id|s
op_eq
l_char|&squot; &squot;
)paren
op_increment
id|s
suffix:semicolon
multiline_comment|/* compress internal blanks and strip trailing blanks */
r_while
c_loop
(paren
id|s
op_ne
id|end
op_logical_and
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
op_star
id|s
op_increment
op_ne
l_char|&squot; &squot;
op_logical_or
(paren
id|s
op_ne
id|end
op_logical_and
op_star
id|s
op_logical_and
op_star
id|s
op_ne
l_char|&squot; &squot;
)paren
)paren
op_star
id|p
op_increment
op_assign
op_star
(paren
id|s
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* wipe out trailing garbage */
r_while
c_loop
(paren
id|p
op_ne
id|end
)paren
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
DECL|function|fix_lba_capacity
r_static
r_int
r_int
id|fix_lba_capacity
(paren
r_struct
id|hd_driveid
op_star
id|id
)paren
(brace
r_int
r_int
id|lba_sects
op_assign
id|id-&gt;lba_capacity
suffix:semicolon
r_int
r_int
id|chs_sects
op_assign
id|id-&gt;cyls
op_star
id|id-&gt;heads
op_star
id|id-&gt;sectors
suffix:semicolon
r_int
r_int
id|_15_percent
op_assign
id|chs_sects
op_div
l_int|10
suffix:semicolon
multiline_comment|/* perform a rough sanity check on lba_sects:  within 15% is &quot;okay&quot; */
r_if
c_cond
(paren
(paren
id|lba_sects
op_minus
id|chs_sects
)paren
OL
id|_15_percent
)paren
r_return
id|lba_sects
suffix:semicolon
multiline_comment|/* some drives have the word order reversed */
id|lba_sects
op_assign
(paren
id|lba_sects
op_lshift
l_int|16
)paren
op_or
(paren
id|lba_sects
op_rshift
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lba_sects
op_minus
id|chs_sects
)paren
OL
id|_15_percent
)paren
r_return
(paren
id|id-&gt;lba_capacity
op_assign
id|lba_sects
)paren
suffix:semicolon
multiline_comment|/* play it safe and assume lba capacity is the same as chs capacity */
r_return
id|chs_sects
suffix:semicolon
)brace
DECL|variable|probe_mem_start
r_static
r_int
r_int
id|probe_mem_start
suffix:semicolon
multiline_comment|/* used by drive/irq probing routines */
DECL|function|do_identify
r_static
r_void
id|do_identify
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
r_int
id|bswap
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
suffix:semicolon
r_int
r_int
id|capacity
comma
id|check
suffix:semicolon
id|id
op_assign
id|dev-&gt;id
op_assign
(paren
r_struct
id|hd_driveid
op_star
)paren
id|probe_mem_start
suffix:semicolon
multiline_comment|/* kmalloc() */
id|probe_mem_start
op_add_assign
l_int|512
suffix:semicolon
id|IN_SECTORS
c_func
(paren
id|id
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* read 512 bytes of id info */
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Everything except ATAPI seems to use big-endian string ordering,&n;&t; * whereas the NEC and Vertos ATAPI drives both use little-endian.&n;&t; * Latest reports indicate that some Mitsumi ATAPI use big-endian.&n;&t; */
id|bswap
op_assign
(paren
id|id-&gt;config
op_amp
l_int|0x8000
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bswap
op_logical_and
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;F&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;X&squot;
)paren
id|bswap
op_assign
l_int|0
suffix:semicolon
id|fixstring
(paren
id|id-&gt;serial_no
comma
r_sizeof
(paren
id|id-&gt;serial_no
)paren
comma
id|bswap
)paren
suffix:semicolon
id|fixstring
(paren
id|id-&gt;fw_rev
comma
r_sizeof
(paren
id|id-&gt;fw_rev
)paren
comma
id|bswap
)paren
suffix:semicolon
id|fixstring
(paren
id|id-&gt;model
comma
r_sizeof
(paren
id|id-&gt;model
)paren
comma
id|bswap
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Check for ATAPI device (such as an NEC-260 IDE cdrom drive)&n;&t; */
r_if
c_cond
(paren
id|id-&gt;config
op_amp
l_int|0x8000
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
id|byte
id|type
op_assign
(paren
id|id-&gt;config
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
suffix:semicolon
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
id|printk
c_func
(paren
l_string|&quot;%s: %s, ATAPI,&quot;
comma
id|dev-&gt;name
comma
id|id-&gt;model
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|type
op_eq
l_int|0
op_logical_or
id|type
op_eq
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot; CDROM drive&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; UNKNOWN device&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;type
op_assign
id|cdrom
suffix:semicolon
multiline_comment|/* until we do it &quot;correctly&quot; above */
id|dev-&gt;present
op_assign
l_int|1
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|unsupported
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * for Quantum drives, and also for drives not known to the BIOS:&n;&t; */
id|dev-&gt;special.b.set_geometry
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Gather up the geometry info.&n;&t; */
id|dev-&gt;type
op_assign
id|disk
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;present
)paren
(brace
id|dev-&gt;present
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;cyl
op_assign
id|dev-&gt;bios_cyl
op_assign
id|id-&gt;cyls
suffix:semicolon
id|dev-&gt;head
op_assign
id|dev-&gt;bios_head
op_assign
id|id-&gt;heads
suffix:semicolon
id|dev-&gt;sect
op_assign
id|dev-&gt;bios_sect
op_assign
id|id-&gt;sectors
suffix:semicolon
)brace
id|capacity
op_assign
id|BIOS_SECTORS
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* default value */
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|1
)paren
op_logical_and
id|id-&gt;cur_cyls
op_logical_and
id|id-&gt;cur_heads
op_logical_and
(paren
id|id-&gt;cur_heads
op_le
l_int|16
)paren
op_logical_and
id|id-&gt;cur_sectors
)paren
(brace
multiline_comment|/*&n;&t;&t; * Extract the physical drive geometry for our use.&n;&t;&t; * Note that we purposely do *not* update the bios info.&n;&t;&t; * This way, programs that use it (like fdisk) will &n;&t;&t; * still have the same logical view as the BIOS does,&n;&t;&t; * which keeps the partition table from being screwed.&n;&t;&t; *&n;&t;&t; * An exception to this is the cylinder count,&n;&t;&t; * which we reexamine later on to correct for 1024 limitations.&n;&t;&t; */
id|dev-&gt;cyl
op_assign
id|id-&gt;cur_cyls
suffix:semicolon
id|dev-&gt;head
op_assign
id|id-&gt;cur_heads
suffix:semicolon
id|dev-&gt;sect
op_assign
id|id-&gt;cur_sectors
suffix:semicolon
id|capacity
op_assign
id|dev-&gt;cyl
op_star
id|dev-&gt;head
op_star
id|dev-&gt;sect
suffix:semicolon
multiline_comment|/* check for word-swapped &quot;capacity&quot; field in id information */
id|check
op_assign
(paren
id|id-&gt;cur_capacity0
op_lshift
l_int|16
)paren
op_or
id|id-&gt;cur_capacity1
suffix:semicolon
r_if
c_cond
(paren
id|check
op_eq
id|capacity
)paren
multiline_comment|/* was it swapped? */
op_star
(paren
(paren
r_int
op_star
)paren
op_amp
id|id-&gt;cur_capacity0
)paren
op_assign
id|capacity
suffix:semicolon
multiline_comment|/* fix it */
)brace
r_if
c_cond
(paren
id|id-&gt;capability
op_amp
l_int|2
)paren
(brace
multiline_comment|/* use LBA if the drive supports it */
id|capacity
op_assign
id|fix_lba_capacity
c_func
(paren
id|id
)paren
suffix:semicolon
id|dev-&gt;select.b.lba
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;head
op_logical_or
id|dev-&gt;head
OG
l_int|16
)paren
(brace
id|dev-&gt;cyl
op_assign
id|id-&gt;cyls
suffix:semicolon
multiline_comment|/* WIN_SPECIFY needs a valid */
id|dev-&gt;head
op_assign
id|id-&gt;heads
suffix:semicolon
multiline_comment|/*  geometry or it fails.  */
id|dev-&gt;sect
op_assign
id|id-&gt;sectors
suffix:semicolon
)brace
)brace
multiline_comment|/* Correct the number of cyls if the bios value is too small */
r_if
c_cond
(paren
id|dev-&gt;sect
op_eq
id|dev-&gt;bios_sect
op_logical_and
id|dev-&gt;head
op_eq
id|dev-&gt;bios_head
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;cyl
OG
id|dev-&gt;bios_cyl
)paren
(brace
id|dev-&gt;bios_cyl
op_assign
id|dev-&gt;cyl
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|id-&gt;capability
op_amp
l_int|2
)paren
)paren
multiline_comment|/* if NOT using LBA */
id|capacity
op_assign
id|BIOS_SECTORS
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
)brace
id|ide_capacity
(braket
id|DEV_HWIF
)braket
(braket
id|dev-&gt;select.b.drive
)braket
op_assign
id|capacity
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: %.40s, %ldMB w/%dKB Cache, %sCHS=%d/%d/%d&quot;
comma
id|dev-&gt;name
comma
id|id-&gt;model
comma
id|capacity
op_div
l_int|2048L
comma
id|id-&gt;buf_size
op_div
l_int|2
comma
id|dev-&gt;select.b.lba
ques
c_cond
l_string|&quot;LBA, &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|dev-&gt;bios_cyl
comma
id|dev-&gt;bios_head
comma
id|dev-&gt;bios_sect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;max_multsect
)paren
(brace
multiline_comment|/*&n;&t;&t; * Keep current multiplemode setting, if any (from DOS/BIOS):&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|id-&gt;multsect_valid
op_amp
l_int|1
)paren
op_logical_and
id|id-&gt;multsect
)paren
id|dev-&gt;mult_count
op_assign
id|id-&gt;multsect
suffix:semicolon
multiline_comment|/* current setting */
macro_line|#ifdef INITIAL_MULT_COUNT
r_if
c_cond
(paren
id|INITIAL_MULT_COUNT
op_le
id|id-&gt;max_multsect
)paren
id|dev-&gt;mult_req
op_assign
id|INITIAL_MULT_COUNT
suffix:semicolon
r_else
id|dev-&gt;mult_req
op_assign
id|id-&gt;max_multsect
suffix:semicolon
macro_line|#else&t;/* use existing setting from DOS/BIOS: */
r_if
c_cond
(paren
id|dev-&gt;mult_count
op_le
id|id-&gt;max_multsect
)paren
multiline_comment|/* valid? */
id|dev-&gt;mult_req
op_assign
id|dev-&gt;mult_count
suffix:semicolon
multiline_comment|/* keep it */
macro_line|#endif&t;/* INITIAL_MULT_COUNT */
r_if
c_cond
(paren
id|dev-&gt;mult_req
op_ne
id|dev-&gt;mult_count
)paren
id|dev-&gt;special.b.set_multmode
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, Mult=%d/%d&quot;
comma
id|dev-&gt;mult_req
comma
id|id-&gt;max_multsect
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|delay_10ms
r_static
r_void
id|delay_10ms
(paren
r_void
)paren
(brace
r_int
r_int
id|timer
op_assign
id|jiffies
op_plus
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|timer
OG
id|jiffies
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine has the difficult job of finding a drive if it exists,&n; * without getting hung up if it doesn&squot;t exist, and without leaving any IRQs&n; * dangling to haunt us later.  The last point actually occured in v2.3, and&n; * is the reason for the slightly complex exit sequence.  If a drive is &quot;known&quot;&n; * to exist (from CMOS or kernel parameters), but does not respond right away,&n; * the probe will &quot;hang in there&quot; for the maximum wait time (about 30 seconds).&n; * Otherwise, it will exit much more quickly.&n; *&n; * Returns 1 if device present but not identified.  Returns 0 otherwise.&n; */
DECL|function|do_probe
r_static
r_int
id|do_probe
(paren
id|ide_dev_t
op_star
id|dev
comma
id|byte
id|probe_cmd
)paren
(brace
r_int
r_int
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|timer
comma
id|timeout
suffix:semicolon
macro_line|#if PROBE_FOR_IRQS
r_int
r_int
id|irqs
op_assign
l_int|0
suffix:semicolon
r_static
id|byte
id|okstat
comma
id|irq_probed
(braket
l_int|2
)braket
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
macro_line|#endif&t;/* PROBE_FOR_IRQS */
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|dev-&gt;present
)paren
(brace
r_if
c_cond
(paren
(paren
id|dev-&gt;type
op_eq
id|disk
)paren
op_xor
(paren
id|probe_cmd
op_eq
id|WIN_IDENTIFY
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* pointless to probe */
)brace
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
macro_line|#if DEBUG
id|printk
c_func
(paren
l_string|&quot;probing for %s: present=%d, type=%s, probetype=%s&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;present
comma
id|dev-&gt;type
ques
c_cond
l_string|&quot;cdrom&quot;
suffix:colon
l_string|&quot;disk&quot;
comma
(paren
id|probe_cmd
op_eq
id|WIN_IDENTIFY
)paren
ques
c_cond
l_string|&quot;ATA&quot;
suffix:colon
l_string|&quot;ATAPI&quot;
)paren
suffix:semicolon
macro_line|#endif
id|OUT_BYTE
c_func
(paren
id|dev-&gt;select.all
comma
id|HD_CURRENT
)paren
suffix:semicolon
multiline_comment|/* select target drive */
id|delay_10ms
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for BUSY_STAT */
r_if
c_cond
(paren
id|IN_BYTE
c_func
(paren
id|HD_CURRENT
comma
id|DEV_HWIF
)paren
op_ne
id|dev-&gt;select.all
op_logical_and
op_logical_neg
id|dev-&gt;present
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* no i/f present: avoid killing ethernet cards */
id|timeout
op_assign
id|WAIT_WORSTCASE
suffix:semicolon
id|okstat
op_assign
id|READY_STAT
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|probe_cmd
op_eq
id|WIN_PIDENTIFY
)paren
(brace
id|timeout
op_assign
id|WAIT_PIDENTIFY
suffix:semicolon
id|okstat
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|GET_STAT
c_func
(paren
id|DEV_HWIF
)paren
comma
id|okstat
comma
id|BUSY_STAT
)paren
op_logical_and
op_logical_neg
id|dev-&gt;present
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|probe_cmd
op_eq
id|WIN_IDENTIFY
)paren
multiline_comment|/* get rid of this line? */
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
r_goto
id|done_probe
suffix:semicolon
multiline_comment|/* no drive present */
)brace
id|OUT_BYTE
c_func
(paren
id|dev-&gt;ctl
op_or
l_int|2
comma
id|HD_CMD
)paren
suffix:semicolon
multiline_comment|/* disable device irq */
macro_line|#if PROBE_FOR_IRQS
r_if
c_cond
(paren
op_logical_neg
id|irq_probed
(braket
id|DEV_HWIF
)braket
)paren
(brace
multiline_comment|/* already probed for IRQ? */
id|irqs
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* start monitoring irqs */
id|OUT_BYTE
c_func
(paren
id|dev-&gt;ctl
comma
id|HD_CMD
)paren
suffix:semicolon
multiline_comment|/* enable device irq */
)brace
macro_line|#endif&t;/* PROBE_FOR_IRQS */
id|OUT_BYTE
c_func
(paren
id|probe_cmd
comma
id|HD_COMMAND
)paren
suffix:semicolon
multiline_comment|/* ask drive for ID */
id|delay_10ms
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for BUSY_STAT */
r_for
c_loop
(paren
id|timer
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|timer
OG
id|jiffies
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
(paren
id|IN_BYTE
c_func
(paren
id|HD_ALTSTATUS
comma
id|DEV_HWIF
)paren
op_amp
id|BUSY_STAT
)paren
op_eq
l_int|0
)paren
(brace
id|delay_10ms
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for IRQ &amp; DATA_READY */
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|GET_STAT
c_func
(paren
id|DEV_HWIF
)paren
comma
id|DATA_READY
comma
id|BAD_RW_STAT
)paren
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* some sys need this */
id|do_identify
c_func
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* drive returned ID */
)brace
r_else
id|rc
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* drive refused ID */
macro_line|#if PROBE_FOR_IRQS
r_if
c_cond
(paren
op_logical_neg
id|irq_probed
(braket
id|DEV_HWIF
)braket
)paren
(brace
id|irqs
op_assign
id|probe_irq_off
c_func
(paren
id|irqs
)paren
suffix:semicolon
multiline_comment|/* end probe */
r_if
c_cond
(paren
id|irqs
OG
l_int|0
)paren
(brace
id|irq_probed
(braket
id|DEV_HWIF
)braket
op_assign
l_int|1
suffix:semicolon
id|ide_irq
(braket
id|DEV_HWIF
)braket
op_assign
id|irqs
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;%s: IRQ probe failed (%d)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|irqs
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* PROBE_FOR_IRQS */
r_goto
id|done_probe
suffix:semicolon
)brace
)brace
multiline_comment|/* dev-&gt;present = 0; */
multiline_comment|/* it ain&squot;t there */
macro_line|#if PROBE_FOR_IRQS
r_if
c_cond
(paren
op_logical_neg
id|irq_probed
(braket
id|DEV_HWIF
)braket
)paren
(paren
r_void
)paren
id|probe_irq_off
c_func
(paren
id|irqs
)paren
suffix:semicolon
multiline_comment|/* stop probing */
macro_line|#endif&t;/* PROBE_FOR_IRQS */
id|done_probe
suffix:colon
id|OUT_BYTE
c_func
(paren
id|dev-&gt;ctl
op_or
l_int|2
comma
id|HD_CMD
)paren
suffix:semicolon
multiline_comment|/* disable device irq */
id|delay_10ms
c_func
(paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|GET_STAT
c_func
(paren
id|DEV_HWIF
)paren
suffix:semicolon
multiline_comment|/* ensure drive irq is clear */
r_if
c_cond
(paren
id|dev-&gt;select.b.drive
op_eq
l_int|1
)paren
(brace
id|OUT_BYTE
c_func
(paren
l_int|0xa0
comma
id|HD_CURRENT
)paren
suffix:semicolon
multiline_comment|/* exit with drive0 selected */
id|delay_10ms
c_func
(paren
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|dev-&gt;ctl
op_or
l_int|2
comma
id|HD_CMD
)paren
suffix:semicolon
multiline_comment|/* disable device irq */
id|delay_10ms
c_func
(paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|GET_STAT
c_func
(paren
id|DEV_HWIF
)paren
suffix:semicolon
multiline_comment|/* ensure drive irq is clear */
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|probe_drive
r_static
id|byte
id|probe_drive
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|do_probe
c_func
(paren
id|dev
comma
id|WIN_IDENTIFY
)paren
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|do_probe
c_func
(paren
id|dev
comma
id|WIN_PIDENTIFY
)paren
)paren
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
r_if
c_cond
(paren
id|dev-&gt;present
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|disk
)paren
(brace
id|printk
(paren
l_string|&quot;%s: non-IDE device, CHS=%d/%d/%d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;cyl
comma
id|dev-&gt;head
comma
id|dev-&gt;sect
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_else
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|cdrom
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ATAPI cdrom (?)&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
r_else
(brace
id|dev-&gt;present
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* nuke it */
)brace
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;present
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* drive not found */
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|cdrom
)paren
id|cdrom_setup
c_func
(paren
id|dev
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|disk
op_logical_and
op_logical_neg
id|dev-&gt;select.b.lba
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dev-&gt;head
op_logical_or
id|dev-&gt;head
OG
l_int|16
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: cannot handle disk with %d physical heads&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|dev-&gt;head
)paren
suffix:semicolon
id|dev-&gt;present
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* drive found */
)brace
DECL|function|probe_hw_for_drives
r_static
r_void
id|probe_hw_for_drives
(paren
id|byte
id|hwif
)paren
(brace
id|ide_dev_t
op_star
id|devs
op_assign
op_amp
id|ide_dev
(braket
id|HWIF
)braket
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* for convenience */
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|IDE_PORT
c_func
(paren
id|HD_DATA
comma
id|HWIF
)paren
comma
l_int|8
)paren
op_logical_or
id|check_region
c_func
(paren
id|IDE_PORT
c_func
(paren
id|HD_CMD
comma
id|HWIF
)paren
comma
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|devs
(braket
l_int|0
)braket
dot
id|present
op_logical_or
id|devs
(braket
l_int|1
)braket
dot
id|present
)paren
id|printk
c_func
(paren
l_string|&quot;ERROR: &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: port(s) already in use&bslash;n&quot;
comma
id|ide_name
(braket
id|HWIF
)braket
)paren
suffix:semicolon
id|devs
(braket
l_int|0
)braket
dot
id|present
op_assign
l_int|0
suffix:semicolon
id|devs
(braket
l_int|1
)braket
dot
id|present
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* needed for jiffies and irq probing */
multiline_comment|/* second drive can only exist if first drive was present */
r_if
c_cond
(paren
id|probe_drive
c_func
(paren
op_amp
id|devs
(braket
l_int|0
)braket
)paren
op_logical_or
id|devs
(braket
l_int|1
)braket
dot
id|present
)paren
(paren
r_void
)paren
id|probe_drive
c_func
(paren
op_amp
id|devs
(braket
l_int|1
)braket
)paren
suffix:semicolon
macro_line|#if PROBE_FOR_IRQS
(paren
r_void
)paren
id|probe_irq_off
c_func
(paren
id|probe_irq_on
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* clear dangling irqs */
macro_line|#endif&t;/* PROBE_FOR_IRQS */
r_if
c_cond
(paren
id|devs
(braket
l_int|0
)braket
dot
id|present
op_logical_or
id|devs
(braket
l_int|1
)braket
dot
id|present
)paren
(brace
id|snarf_region
c_func
(paren
id|IDE_PORT
c_func
(paren
id|HD_DATA
comma
id|HWIF
)paren
comma
l_int|8
)paren
suffix:semicolon
id|snarf_region
c_func
(paren
id|IDE_PORT
c_func
(paren
id|HD_CMD
comma
id|HWIF
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
)brace
DECL|variable|next_drive
r_static
r_int
id|next_drive
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* used by the ide_setup() routines below */
DECL|function|ide_setup
r_void
id|ide_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|ide_dev_t
op_star
id|dev
suffix:semicolon
r_const
r_char
op_star
id|p
(braket
)braket
op_assign
(brace
l_string|&quot;cyls&quot;
comma
l_string|&quot;heads&quot;
comma
l_string|&quot;sects&quot;
comma
l_string|&quot;wpcom&quot;
comma
l_string|&quot;irq&quot;
)brace
suffix:semicolon
r_int
id|i
comma
id|hwif
comma
id|drive
op_assign
id|next_drive
op_increment
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_HD
r_extern
r_void
id|hd_setup
c_func
(paren
r_char
op_star
comma
r_int
op_star
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
OL
l_int|2
)paren
(brace
id|hd_setup
(paren
id|str
comma
id|ints
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_HD */
id|hwif
op_assign
(paren
id|drive
OG
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: &quot;
comma
id|ide_name
(braket
id|hwif
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
OG
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;too many drives defined&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|drive
op_assign
id|drive
op_amp
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: &quot;
comma
id|ide_devname
(braket
id|hwif
)braket
(braket
id|drive
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|SUPPORT_TWO_INTERFACES
op_logical_and
id|hwif
op_ne
id|HWIF
)paren
(brace
id|printk
c_func
(paren
id|unsupported
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev
op_assign
op_amp
id|ide_dev
(braket
id|hwif
)braket
(braket
id|drive
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;present
)paren
id|printk
c_func
(paren
l_string|&quot;(redefined) &quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|str
comma
l_string|&quot;cdrom&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cdrom&bslash;n&quot;
)paren
suffix:semicolon
id|dev-&gt;present
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* force autoprobe to find it */
id|dev-&gt;type
op_assign
id|cdrom
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
template_param
l_int|5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bad parms, expected: cyls,heads,sects[,wpcom[,irq]]&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_increment
OL
id|ints
(braket
l_int|0
)braket
suffix:semicolon
)paren
id|printk
c_func
(paren
l_string|&quot;%s=%d%c&quot;
comma
id|p
(braket
id|i
op_minus
l_int|1
)braket
comma
id|ints
(braket
id|i
)braket
comma
id|i
OL
id|ints
(braket
l_int|0
)braket
ques
c_cond
l_char|&squot;,&squot;
suffix:colon
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
id|dev-&gt;type
op_assign
id|disk
suffix:semicolon
id|dev-&gt;cyl
op_assign
id|dev-&gt;bios_cyl
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|dev-&gt;head
op_assign
id|dev-&gt;bios_head
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
id|dev-&gt;ctl
op_assign
(paren
id|ints
(braket
l_int|2
)braket
OG
l_int|8
ques
c_cond
l_int|8
suffix:colon
l_int|0
)paren
suffix:semicolon
id|dev-&gt;sect
op_assign
id|dev-&gt;bios_sect
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
id|dev-&gt;wpcom
op_assign
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|4
)paren
ques
c_cond
id|ints
(braket
l_int|4
)braket
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|5
)paren
id|ide_irq
(braket
id|HWIF
)braket
op_assign
id|ints
(braket
l_int|5
)braket
suffix:semicolon
id|ide_capacity
(braket
id|HWIF
)braket
(braket
id|drive
)braket
op_assign
id|BIOS_SECTORS
c_func
(paren
id|dev
)paren
suffix:semicolon
id|dev-&gt;present
op_assign
l_int|1
suffix:semicolon
)brace
)brace
DECL|function|hda_setup
r_void
id|hda_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|next_drive
op_assign
l_int|0
suffix:semicolon
id|ide_setup
(paren
id|str
comma
id|ints
)paren
suffix:semicolon
)brace
DECL|function|hdb_setup
r_void
id|hdb_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|next_drive
op_assign
l_int|1
suffix:semicolon
id|ide_setup
(paren
id|str
comma
id|ints
)paren
suffix:semicolon
)brace
DECL|function|hdc_setup
r_void
id|hdc_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|next_drive
op_assign
l_int|2
suffix:semicolon
id|ide_setup
(paren
id|str
comma
id|ints
)paren
suffix:semicolon
)brace
DECL|function|hdd_setup
r_void
id|hdd_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|next_drive
op_assign
l_int|3
suffix:semicolon
id|ide_setup
(paren
id|str
comma
id|ints
)paren
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_BLK_DEV_HD
multiline_comment|/*&n; * We query CMOS about hard disks : it could be that we have a SCSI/ESDI/etc&n; * controller that is BIOS compatible with ST-506, and thus showing up in our&n; * BIOS table, but not register compatible, and therefore not present in CMOS.&n; *&n; * Furthermore, we will assume that our ST-506 drives &lt;if any&gt; are the primary&n; * drives in the system -- the ones reflected as drive 1 or 2.  The first&n; * drive is stored in the high nibble of CMOS byte 0x12, the second in the low&n; * nibble.  This will be either a 4 bit drive type or 0xf indicating use byte&n; * 0x19 for an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.  A non-zero value &n; * means we have an AT controller hard disk for that drive.&n; */
r_extern
r_struct
id|drive_info_struct
id|drive_info
suffix:semicolon
DECL|function|probe_cmos_for_drives
r_static
r_void
id|probe_cmos_for_drives
(paren
r_void
)paren
(brace
id|byte
id|drive
comma
id|cmos_disks
comma
op_star
id|BIOS
op_assign
(paren
id|byte
op_star
)paren
op_amp
id|drive_info
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x12
comma
l_int|0x70
)paren
suffix:semicolon
multiline_comment|/* specify CMOS address 0x12 */
id|cmos_disks
op_assign
id|inb_p
c_func
(paren
l_int|0x71
)paren
suffix:semicolon
multiline_comment|/* read the data from 0x12 */
multiline_comment|/* Extract drive geometry from CMOS+BIOS if not already setup */
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|MAX_DRIVES
suffix:semicolon
id|drive
op_increment
)paren
(brace
id|ide_dev_t
op_star
id|dev
op_assign
op_amp
id|ide_dev
(braket
l_int|0
)braket
(braket
id|drive
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmos_disks
op_amp
(paren
l_int|0xf0
op_rshift
(paren
id|drive
op_star
l_int|4
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|dev-&gt;present
)paren
(brace
id|dev-&gt;cyl
op_assign
id|dev-&gt;bios_cyl
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|BIOS
suffix:semicolon
id|dev-&gt;head
op_assign
id|dev-&gt;bios_head
op_assign
op_star
(paren
id|BIOS
op_plus
l_int|2
)paren
suffix:semicolon
id|dev-&gt;sect
op_assign
id|dev-&gt;bios_sect
op_assign
op_star
(paren
id|BIOS
op_plus
l_int|14
)paren
suffix:semicolon
id|dev-&gt;wpcom
op_assign
(paren
op_star
(paren
r_int
r_int
op_star
)paren
(paren
id|BIOS
op_plus
l_int|5
)paren
)paren
op_rshift
l_int|2
suffix:semicolon
id|dev-&gt;ctl
op_assign
op_star
(paren
id|BIOS
op_plus
l_int|8
)paren
suffix:semicolon
id|dev-&gt;wpcom
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;type
op_assign
id|disk
suffix:semicolon
id|dev-&gt;present
op_assign
l_int|1
suffix:semicolon
id|ide_capacity
(braket
l_int|0
)braket
(braket
id|drive
)braket
op_assign
id|BIOS_SECTORS
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
id|BIOS
op_add_assign
l_int|16
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* CONFIG_BLK_DEV_HD */
DECL|function|init_ide_data
r_static
r_void
id|init_ide_data
(paren
id|byte
id|hwif
)paren
(brace
r_int
id|drive
suffix:semicolon
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
(paren
id|MAX_DRIVES
op_lshift
id|PARTN_BITS
)paren
suffix:semicolon
id|drive
op_increment
)paren
id|ide_blksizes
(braket
id|hwif
)braket
(braket
id|drive
)braket
op_assign
l_int|1024
suffix:semicolon
id|blksize_size
(braket
id|ide_major
(braket
id|hwif
)braket
)braket
op_assign
id|ide_blksizes
(braket
id|hwif
)braket
suffix:semicolon
multiline_comment|/* Initialize non-geometry fields -- ide_setup() runs before we do */
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|MAX_DRIVES
suffix:semicolon
id|drive
op_increment
)paren
(brace
id|ide_dev_t
op_star
id|dev
op_assign
op_amp
id|ide_dev
(braket
id|hwif
)braket
(braket
id|drive
)braket
suffix:semicolon
id|dev-&gt;select.all
op_assign
(paren
id|drive
op_lshift
l_int|4
)paren
op_or
l_int|0xa0
suffix:semicolon
id|dev-&gt;hwif
op_assign
id|hwif
suffix:semicolon
id|dev-&gt;unmask
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set by do_identify() */
id|dev-&gt;mult_req
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* set by do_identify() */
id|dev-&gt;usage
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;id
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;ctl
op_assign
l_int|0x08
suffix:semicolon
id|dev-&gt;wqueue
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;special.all
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
id|dev-&gt;keep_settings
op_assign
l_int|0
suffix:semicolon
id|ide_hd
(braket
id|hwif
)braket
(braket
id|drive
op_lshift
id|PARTN_BITS
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;name
op_assign
id|ide_devname
(braket
id|hwif
)braket
(braket
id|drive
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is the harddisk IRQ description. The SA_INTERRUPT in sa_flags&n; * means we enter the IRQ-handler with interrupts disabled: this is bad for&n; * interrupt latency, but anything else has led to problems on some&n; * machines.  We enable interrupts as much as we can safely do in most places.&n; */
DECL|function|setup_irq
r_static
id|byte
id|setup_irq
(paren
id|byte
id|hwif
)paren
(brace
r_static
id|byte
id|rc
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_const
r_char
op_star
id|msg
op_assign
l_string|&quot;&quot;
comma
op_star
id|primary_secondary
(braket
)braket
op_assign
(brace
l_string|&quot;primary&quot;
comma
l_string|&quot;secondary&quot;
)brace
suffix:semicolon
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
)paren
op_assign
id|HWIF
ques
c_cond
op_amp
id|ide1_intr
suffix:colon
op_amp
id|ide0_intr
suffix:semicolon
macro_line|#if SUPPORT_SHARING_IRQ
r_if
c_cond
(paren
id|sharing_single_irq
)paren
(brace
r_if
c_cond
(paren
id|HWIF
op_ne
l_int|0
op_logical_and
op_logical_neg
id|rc
)paren
(brace
multiline_comment|/* IRQ already allocated? */
id|msg
op_assign
l_string|&quot; (shared with ide0)&quot;
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|handler
op_assign
op_amp
id|ide_shared_intr
suffix:semicolon
)brace
macro_line|#endif /* SUPPORT_SHARING_IRQ */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|request_irq
c_func
(paren
id|ide_irq
(braket
id|HWIF
)braket
comma
id|handler
comma
id|SA_INTERRUPT
comma
id|ide_name
(braket
id|HWIF
)braket
)paren
)paren
)paren
id|msg
op_assign
l_string|&quot;:  FAILED! unable to allocate IRQ&quot;
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#if SUPPORT_SHARING_IRQ
id|done
suffix:colon
macro_line|#endif /* SUPPORT_SHARING_IRQ */
id|printk
c_func
(paren
l_string|&quot;%s: %s interface on irq %d%s&bslash;n&quot;
comma
id|ide_name
(braket
id|HWIF
)braket
comma
id|primary_secondary
(braket
id|HWIF
)braket
comma
id|ide_irq
(braket
id|HWIF
)braket
comma
id|msg
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|ide_geninit
r_static
r_void
id|ide_geninit
c_func
(paren
id|byte
id|hwif
)paren
(brace
r_static
r_int
id|drive
suffix:semicolon
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|MAX_DRIVES
suffix:semicolon
id|drive
op_increment
)paren
(brace
id|ide_dev_t
op_star
id|dev
op_assign
op_amp
id|ide_dev
(braket
id|HWIF
)braket
(braket
id|drive
)braket
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;present
)paren
(brace
id|ide_hd
(braket
id|HWIF
)braket
(braket
id|drive
op_lshift
id|PARTN_BITS
)braket
dot
id|nr_sects
op_assign
id|ide_capacity
(braket
id|HWIF
)braket
(braket
id|drive
)braket
suffix:semicolon
multiline_comment|/* Skip partition check for cdroms. */
r_if
c_cond
(paren
id|dev-&gt;type
op_eq
id|cdrom
)paren
id|ide_hd
(braket
id|HWIF
)braket
(braket
id|drive
op_lshift
id|PARTN_BITS
)braket
dot
id|start_sect
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
)brace
)brace
DECL|function|ide0_geninit
r_static
r_void
id|ide0_geninit
c_func
(paren
r_void
)paren
(brace
id|ide_geninit
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|ide1_geninit
r_static
r_void
id|ide1_geninit
c_func
(paren
r_void
)paren
(brace
id|ide_geninit
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|variable|ide_fops
r_static
r_struct
id|file_operations
id|ide_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|ide_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|ide_open
comma
multiline_comment|/* open */
id|ide_release
comma
multiline_comment|/* release */
id|block_fsync
multiline_comment|/* fsync */
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
comma
l_int|NULL
comma
multiline_comment|/* fasync */
id|ide_check_media_change
comma
multiline_comment|/* check_media_change */
l_int|NULL
multiline_comment|/* revalidate */
macro_line|#endif CONFIG_BLK_DEV_IDECD
)brace
suffix:semicolon
multiline_comment|/*&n; * This is gets invoked once during initialization, to set *everything* up&n; */
DECL|function|ide_init
r_int
r_int
id|ide_init
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
(brace
id|byte
id|hwif
suffix:semicolon
r_for
c_loop
(paren
id|hwif
op_assign
l_int|0
suffix:semicolon
id|hwif
OL
l_int|2
suffix:semicolon
id|hwif
op_increment
)paren
(brace
id|init_ide_data
(paren
id|hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SUPPORT_TWO_INTERFACES
op_logical_or
id|hwif
op_eq
id|HWIF
)paren
(brace
r_if
c_cond
(paren
id|hwif
op_eq
l_int|0
)paren
macro_line|#ifdef CONFIG_BLK_DEV_HD
r_continue
suffix:semicolon
macro_line|#else
id|probe_cmos_for_drives
(paren
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLJ_DEV_HD */
id|probe_mem_start
op_assign
(paren
id|mem_start
op_plus
l_int|3uL
)paren
op_amp
op_complement
l_int|3uL
suffix:semicolon
id|probe_hw_for_drives
(paren
id|hwif
)paren
suffix:semicolon
id|mem_start
op_assign
id|probe_mem_start
suffix:semicolon
)brace
)brace
multiline_comment|/* At this point, all methods of drive detection have completed */
id|ide_gendisk
(braket
l_int|0
)braket
dot
id|nr_real
op_assign
id|ide_dev
(braket
l_int|0
)braket
(braket
l_int|0
)braket
dot
id|present
op_plus
id|ide_dev
(braket
l_int|0
)braket
(braket
l_int|1
)braket
dot
id|present
suffix:semicolon
id|ide_gendisk
(braket
l_int|1
)braket
dot
id|nr_real
op_assign
id|ide_dev
(braket
l_int|1
)braket
(braket
l_int|0
)braket
dot
id|present
op_plus
id|ide_dev
(braket
l_int|1
)braket
(braket
l_int|1
)braket
dot
id|present
suffix:semicolon
r_if
c_cond
(paren
id|ide_gendisk
(braket
l_int|1
)braket
dot
id|nr_real
op_logical_and
(paren
id|ide_irq
(braket
l_int|0
)braket
op_eq
id|ide_irq
(braket
l_int|1
)braket
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|ide_gendisk
(braket
l_int|0
)braket
dot
id|nr_real
)paren
(brace
id|ide_irq
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* needed by ide_intr() */
)brace
r_else
(brace
macro_line|#if SUPPORT_SHARING_IRQ
id|sharing_single_irq
op_assign
l_int|1
suffix:semicolon
macro_line|#else /* SUPPORT_SHARING_IRQ */
id|printk
c_func
(paren
l_string|&quot;%s: ide irq-sharing%s&quot;
comma
id|ide_name
(braket
l_int|1
)braket
comma
id|unsupported
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
macro_line|#endif /* SUPPORT_SHARING_IRQ */
)brace
)brace
macro_line|#ifdef CONFIG_BLK_DEV_HD
macro_line|#if SUPPORT_SHARING_IRQ
r_if
c_cond
(paren
id|ide_irq
(braket
l_int|1
)braket
op_eq
l_int|14
op_logical_or
id|sharing_single_irq
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
id|ide_irq
(braket
l_int|1
)braket
op_eq
l_int|14
)paren
(brace
macro_line|#endif /* SUPPORT_SHARING_IRQ */
id|printk
c_func
(paren
l_string|&quot;%s: irq-sharing not possible with old harddisk driver (hd.c)&bslash;n&quot;
comma
id|ide_name
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_HD */
r_for
c_loop
(paren
id|hwif
op_assign
l_int|2
suffix:semicolon
id|hwif
op_decrement
OG
l_int|0
suffix:semicolon
)paren
(brace
r_if
c_cond
(paren
id|ide_gendisk
(braket
id|hwif
)braket
dot
id|nr_real
op_ne
l_int|0
op_logical_and
op_logical_neg
id|setup_irq
c_func
(paren
id|hwif
)paren
)paren
(brace
r_const
r_char
op_star
id|name
op_assign
id|ide_name
(braket
id|HWIF
)braket
suffix:semicolon
r_int
r_int
id|major
op_assign
id|ide_major
(braket
id|HWIF
)braket
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|major
comma
id|name
comma
op_amp
id|ide_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to get major number %d&bslash;n&quot;
comma
id|name
comma
id|major
)paren
suffix:semicolon
)brace
r_else
(brace
id|timer_table
(braket
id|ide_timer
(braket
id|HWIF
)braket
)braket
dot
id|fn
op_assign
id|HWIF
ques
c_cond
id|ide1_timer_expiry
suffix:colon
id|ide0_timer_expiry
suffix:semicolon
macro_line|#if SUPPORT_SHARING_IRQ
r_if
c_cond
(paren
id|sharing_single_irq
)paren
id|blk_dev
(braket
id|major
)braket
dot
id|request_fn
op_assign
op_amp
id|do_shared_request
suffix:semicolon
r_else
macro_line|#endif /* SUPPORT_SHARING_IRQ */
id|blk_dev
(braket
id|major
)braket
dot
id|request_fn
op_assign
id|HWIF
ques
c_cond
op_amp
id|do_ide1_request
suffix:colon
op_amp
id|do_ide0_request
suffix:semicolon
id|read_ahead
(braket
id|major
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* (4kB) */
id|ide_gendisk
(braket
id|HWIF
)braket
dot
id|next
op_assign
id|gendisk_head
suffix:semicolon
id|gendisk_head
op_assign
op_amp
id|ide_gendisk
(braket
id|HWIF
)braket
suffix:semicolon
)brace
)brace
)brace
r_return
id|mem_start
suffix:semicolon
)brace
eof
