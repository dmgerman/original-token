multiline_comment|/*&n; *  linux/drivers/block/ide.c&t;Version 5.52  Sep  24, 1996&n; *&n; *  Copyright (C) 1994-1996  Linus Torvalds &amp; authors (see below)&n; */
DECL|macro|_IDE_C
mdefine_line|#define _IDE_C&t;&t;/* needed by &lt;linux/blk.h&gt; */
multiline_comment|/*&n; *  Maintained by Mark Lord  &lt;mlord@pobox.com&gt;&n; *            and Gadi Oxman &lt;gadio@netvision.net.il&gt;&n; *&n; * This is the multiple IDE interface driver, as evolved from hd.c.&n; * It supports up to four IDE interfaces, on one or more IRQs (usually 14 &amp; 15).&n; * There can be up to two drives per interface, as per the ATA-2 spec.&n; *&n; * Primary:    ide0, port 0x1f0; major=3;  hda is minor=0; hdb is minor=64&n; * Secondary:  ide1, port 0x170; major=22; hdc is minor=0; hdd is minor=64&n; * Tertiary:   ide2, port 0x???; major=33; hde is minor=0; hdf is minor=64&n; * Quaternary: ide3, port 0x???; major=34; hdg is minor=0; hdh is minor=64&n; *&n; * It is easy to extend ide.c to handle more than four interfaces:&n; *&n; *&t;Change the MAX_HWIFS constant in ide.h.&n; *&n; *&t;Define some new major numbers (in major.h), and insert them into&n; *&t;the ide_hwif_to_major table in ide.c.&n; *&n; *&t;Fill in the extra values for the new interfaces into the two tables&n; *&t;inside ide.c:  default_io_base[]  and  default_irqs[].&n; *&n; *&t;Create the new request handlers by cloning &quot;do_ide3_request()&quot;&n; *&t;for each new interface, and add them to the switch statement&n; *&t;in the ide_init() function in ide.c.&n; *&n; *&t;Recompile, create the new /dev/ entries, and it will probably work.&n; *&n; *  From hd.c:&n; *  |&n; *  | It traverses the request-list, using interrupts to jump between functions.&n; *  | As nearly all functions can be called within interrupts, we may not sleep.&n; *  | Special care is recommended.  Have Fun!&n; *  |&n; *  | modified by Drew Eckhardt to check nr of hd&squot;s from the CMOS.&n; *  |&n; *  | Thanks to Branko Lankester, lankeste@fwi.uva.nl, who found a bug&n; *  | in the early extended-partition checks and added DM partitions.&n; *  |&n; *  | Early work on error handling by Mika Liljeberg (liljeber@cs.Helsinki.FI).&n; *  |&n; *  | IRQ-unmask, drive-id, multiple-mode, support for &quot;&gt;16 heads&quot;,&n; *  | and general streamlining by Mark Lord (mlord@pobox.com).&n; *&n; *  October, 1994 -- Complete line-by-line overhaul for linux 1.1.x, by:&n; *&n; *&t;Mark Lord&t;(mlord@pobox.com)&t;&t;(IDE Perf.Pkg)&n; *&t;Delman Lee&t;(delman@mipg.upenn.edu)&t;&t;(&quot;Mr. atdisk2&quot;)&n; *&t;Scott Snyder&t;(snyder@fnald0.fnal.gov)&t;(ATAPI IDE cd-rom)&n; *&n; *  This was a rewrite of just about everything from hd.c, though some original&n; *  code is still sprinkled about.  Think of it as a major evolution, with&n; *  inspiration from lots of linux users, esp.  hamish@zot.apana.org.au&n; *&n; *  Version 1.0 ALPHA&t;initial code, primary i/f working okay&n; *  Version 1.3 BETA&t;dual i/f on shared irq tested &amp; working!&n; *  Version 1.4 BETA&t;added auto probing for irq(s)&n; *  Version 1.5 BETA&t;added ALPHA (untested) support for IDE cd-roms,&n; *  ...&n; *  Version 3.5&t;&t;correct the bios_cyl field if it&squot;s too small&n; *  (linux 1.1.76)&t; (to help fdisk with brain-dead BIOSs)&n; *  Version 3.6&t;&t;cosmetic corrections to comments and stuff&n; *  (linux 1.1.77)&t;reorganise probing code to make it understandable&n; *&t;&t;&t;added halfway retry to probing for drive identification&n; *&t;&t;&t;added &quot;hdx=noprobe&quot; command line option&n; *&t;&t;&t;allow setting multmode even when identification fails&n; *  Version 3.7&t;&t;move set_geometry=1 from do_identify() to ide_init()&n; *&t;&t;&t;increase DRQ_WAIT to eliminate nuisance messages&n; *&t;&t;&t;wait for DRQ_STAT instead of DATA_READY during probing&n; *&t;&t;&t;  (courtesy of Gary Thomas gary@efland.UU.NET)&n; *  Version 3.8&t;&t;fixed byte-swapping for confused Mitsumi cdrom drives&n; *&t;&t;&t;update of ide-cd.c from Scott, allows blocksize=1024&n; *&t;&t;&t;cdrom probe fixes, inspired by jprang@uni-duisburg.de&n; *  Version 3.9&t;&t;don&squot;t use LBA if lba_capacity looks funny&n; *&t;&t;&t;correct the drive capacity calculations&n; *&t;&t;&t;fix probing for old Seagates without IDE_ALTSTATUS_REG&n; *&t;&t;&t;fix byte-ordering for some NEC cdrom drives&n; *  Version 3.10&t;disable multiple mode by default; was causing trouble&n; *  Version 3.11&t;fix mis-identification of old WD disks as cdroms&n; *  Version 3,12&t;simplify logic for selecting initial mult_count&n; *&t;&t;&t;  (fixes problems with buggy WD drives)&n; *  Version 3.13&t;remove excess &quot;multiple mode disabled&quot; messages&n; *  Version 3.14&t;fix ide_error() handling of BUSY_STAT&n; *&t;&t;&t;fix byte-swapped cdrom strings (again.. arghh!)&n; *&t;&t;&t;ignore INDEX bit when checking the ALTSTATUS reg&n; *  Version 3.15&t;add SINGLE_THREADED flag for use with dual-CMD i/f&n; *&t;&t;&t;ignore WRERR_STAT for non-write operations&n; *&t;&t;&t;added vlb_sync support for DC-2000A &amp; others,&n; *&t;&t;&t; (incl. some Promise chips), courtesy of Frank Gockel&n; *  Version 3.16&t;convert vlb_32bit and vlb_sync into runtime flags&n; *&t;&t;&t;add ioctls to get/set VLB flags (HDIO_[SG]ET_CHIPSET)&n; *&t;&t;&t;rename SINGLE_THREADED to SUPPORT_SERIALIZE,&n; *&t;&t;&t;add boot flag to &quot;serialize&quot; operation for CMD i/f&n; *&t;&t;&t;add optional support for DTC2278 interfaces,&n; *&t;&t;&t; courtesy of andy@cercle.cts.com (Dyan Wile).&n; *&t;&t;&t;add boot flag to enable &quot;dtc2278&quot; probe&n; *&t;&t;&t;add probe to avoid EATA (SCSI) interfaces,&n; *&t;&t;&t; courtesy of neuffer@goofy.zdv.uni-mainz.de.&n; *  Version 4.00&t;tidy up verify_area() calls - heiko@colossus.escape.de&n; *&t;&t;&t;add flag to ignore WRERR_STAT for some drives&n; *&t;&t;&t; courtesy of David.H.West@um.cc.umich.edu&n; *&t;&t;&t;assembly syntax tweak to vlb_sync&n; *&t;&t;&t;removable drive support from scuba@cs.tu-berlin.de&n; *&t;&t;&t;add transparent support for DiskManager-6.0x &quot;Dynamic&n; *&t;&t;&t; Disk Overlay&quot; (DDO), most of this is in genhd.c&n; *&t;&t;&t;eliminate &quot;multiple mode turned off&quot; message at boot&n; *  Version 4.10&t;fix bug in ioctl for &quot;hdparm -c3&quot;&n; *&t;&t;&t;fix DM6:DDO support -- now works with LILO, fdisk, ...&n; *&t;&t;&t;don&squot;t treat some naughty WD drives as removable&n; *  Version 4.11&t;updated DM6 support using info provided by OnTrack&n; *  Version 5.00&t;major overhaul, multmode setting fixed, vlb_sync fixed&n; *&t;&t;&t;added support for 3rd/4th/alternative IDE ports&n; *&t;&t;&t;created ide.h; ide-cd.c now compiles separate from ide.c&n; *&t;&t;&t;hopefully fixed infinite &quot;unexpected_intr&quot; from cdroms&n; *&t;&t;&t;zillions of other changes and restructuring&n; *&t;&t;&t;somehow reduced overall memory usage by several kB&n; *&t;&t;&t;probably slowed things down slightly, but worth it&n; *  Version 5.01&t;AT LAST!!  Finally understood why &quot;unexpected_intr&quot;&n; *&t;&t;&t; was happening at various times/places:  whenever the&n; *&t;&t;&t; ide-interface&squot;s ctl_port was used to &quot;mask&quot; the irq,&n; *&t;&t;&t; it also would trigger an edge in the process of masking&n; *&t;&t;&t; which would result in a self-inflicted interrupt!!&n; *&t;&t;&t; (such a stupid way to build a hardware interrupt mask).&n; *&t;&t;&t; This is now fixed (after a year of head-scratching).&n; *  Version 5.02&t;got rid of need for {enable,disable}_irq_list()&n; *  Version 5.03&t;tune-ups, comments, remove &quot;busy wait&quot; from drive resets&n; *&t;&t;&t;removed PROBE_FOR_IRQS option -- no longer needed&n; *&t;&t;&t;OOOPS!  fixed &quot;bad access&quot; bug for 2nd drive on an i/f&n; *  Version 5.04&t;changed &quot;ira %d&quot; to &quot;irq %d&quot; in DEBUG message&n; *&t;&t;&t;added more comments, cleaned up unexpected_intr()&n; *&t;&t;&t;OOOPS!  fixed null pointer problem in ide reset code&n; *&t;&t;&t;added autodetect for Triton chipset -- no effect yet&n; *  Version 5.05&t;OOOPS!  fixed bug in revalidate_disk()&n; *&t;&t;&t;OOOPS!  fixed bug in ide_do_request()&n; *&t;&t;&t;added ATAPI reset sequence for cdroms&n; *  Version 5.10&t;added Bus-Mastered DMA support for Triton Chipset&n; *&t;&t;&t;some (mostly) cosmetic changes&n; *  Version 5.11&t;added ht6560b support by malafoss@snakemail.hut.fi&n; *&t;&t;&t;reworked PCI scanning code&n; *&t;&t;&t;added automatic RZ1000 detection/support&n; *&t;&t;&t;added automatic PCI CMD640 detection/support&n; *&t;&t;&t;added option for VLB CMD640 support&n; *&t;&t;&t;tweaked probe to find cdrom on hdb with disks on hda,hdc&n; *  Version 5.12&t;some performance tuning&n; *&t;&t;&t;added message to alert user to bad /dev/hd[cd] entries&n; *&t;&t;&t;OOOPS!  fixed bug in atapi reset&n; *&t;&t;&t;driver now forces &quot;serialize&quot; again for all cmd640 chips&n; *&t;&t;&t;noticed REALLY_SLOW_IO had no effect, moved it to ide.c&n; *&t;&t;&t;made do_drive_cmd() into public ide_do_drive_cmd()&n; *  Version 5.13&t;fixed typo (&squot;B&squot;), thanks to houston@boyd.geog.mcgill.ca&n; *&t;&t;&t;fixed ht6560b support&n; *  Version 5.13b (sss)&t;fix problem in calling ide_cdrom_setup()&n; *&t;&t;&t;don&squot;t bother invalidating nonexistent partitions&n; *  Version 5.14&t;fixes to cmd640 support.. maybe it works now(?)&n; *&t;&t;&t;added &amp; tested full EZ-DRIVE support -- don&squot;t use LILO!&n; *&t;&t;&t;don&squot;t enable 2nd CMD640 PCI port during init - conflict&n; *  Version 5.15&t;bug fix in init_cmd640_vlb()&n; *&t;&t;&t;bug fix in interrupt sharing code&n; *  Version 5.16&t;ugh.. fix &quot;serialize&quot; support, broken in 5.15&n; *&t;&t;&t;remove &quot;Huh?&quot; from cmd640 code&n; *&t;&t;&t;added qd6580 interface speed select from Colten Edwards&n; *  Version 5.17&t;kludge around bug in BIOS32 on Intel triton motherboards&n; *  Version 5.18&t;new CMD640 code, moved to cmd640.c, #include&squot;d for now&n; *&t;&t;&t;new UMC8672 code, moved to umc8672.c, #include&squot;d for now&n; *&t;&t;&t;disallow turning on DMA when h/w not capable of DMA&n; *  Version 5.19&t;fix potential infinite timeout on resets&n; *&t;&t;&t;extend reset poll into a general purpose polling scheme&n; *&t;&t;&t;add atapi tape drive support from Gadi Oxman&n; *&t;&t;&t;simplify exit from _intr routines -- no IDE_DO_REQUEST&n; *  Version 5.20&t;leave current rq on blkdev request list during I/O&n; *&t;&t;&t;generalized ide_do_drive_cmd() for tape/cdrom driver use&n; *  Version 5.21&t;fix nasty cdrom/tape bug (ide_preempt was messed up)&n; *  Version 5.22&t;fix ide_xlate_1024() to work with/without drive-&gt;id&n; *  Version 5.23&t;miscellaneous touch-ups&n; *  Version 5.24&t;fix #if&squot;s for SUPPORT_CMD640&n; *  Version 5.25&t;more touch-ups, fix cdrom resets, ...&n; *&t;&t;&t;cmd640.c now configs/compiles separate from ide.c&n; *  Version 5.26&t;keep_settings now maintains the using_dma flag&n; *&t;&t;&t;fix [EZD] remap message to only output at boot time&n; *&t;&t;&t;fix &quot;bad /dev/ entry&quot; message to say hdc, not hdc0&n; *&t;&t;&t;fix ide_xlate_1024() to respect user specified CHS&n; *&t;&t;&t;use CHS from partn table if it looks translated&n; *&t;&t;&t;re-merged flags chipset,vlb_32bit,vlb_sync into io_32bit&n; *&t;&t;&t;keep track of interface chipset type, when known&n; *&t;&t;&t;add generic PIO mode &quot;tuneproc&quot; mechanism&n; *&t;&t;&t;fix cmd640_vlb option&n; *&t;&t;&t;fix ht6560b support (was completely broken)&n; *&t;&t;&t;umc8672.c now configures/compiles separate from ide.c&n; *&t;&t;&t;move dtc2278 support to dtc2278.c&n; *&t;&t;&t;move ht6560b support to ht6560b.c&n; *&t;&t;&t;move qd6580  support to qd6580.c&n; *&t;&t;&t;add  ali14xx support in ali14xx.c&n; * Version 5.27&t;&t;add [no]autotune parameters to help cmd640&n; *&t;&t;&t;move rz1000  support to rz1000.c&n; * Version 5.28&t;&t;#include &quot;ide_modes.h&quot;&n; *&t;&t;&t;fix disallow_unmask: now per-interface &quot;no_unmask&quot; bit&n; *&t;&t;&t;force io_32bit to be the same on drive pairs of dtc2278&n; *&t;&t;&t;improved IDE tape error handling, and tape DMA support&n; *&t;&t;&t;bugfix in ide_do_drive_cmd() for cdroms + serialize&n; * Version 5.29&t;&t;fixed non-IDE check for too many physical heads&n; *&t;&t;&t;don&squot;t use LBA if capacity is smaller than CHS&n; * Version 5.30&t;&t;remove real_devices kludge, formerly used by genhd.c&n; * Version 5.32&t;&t;change &quot;KB&quot; to &quot;kB&quot;&n; *&t;&t;&t;fix serialize (was broken in kernel 1.3.72)&n; *&t;&t;&t;add support for &quot;hdparm -I&quot;&n; *&t;&t;&t;use common code for disk/tape/cdrom IDE_DRIVE_CMDs&n; *&t;&t;&t;add support for Promise DC4030VL caching card&n; *&t;&t;&t;improved serialize support&n; *&t;&t;&t;put partition check back into alphabetical order&n; *&t;&t;&t;add config option for PCMCIA baggage&n; *&t;&t;&t;try to make PCMCIA support safer to use&n; *&t;&t;&t;improve security on ioctls(): all are suser() only&n; * Version 5.33&t;&t;improve handling of HDIO_DRIVE_CMDs that read data&n; * Version 5.34&t;&t;fix irq-sharing problem from 5.33&n; *&t;&t;&t;fix cdrom ioctl problem from 5.33&n; * Version 5.35&t;&t;cosmetic changes&n; *&t;&t;&t;fix cli() problem in try_to_identify()&n; * Version 5.36&t;&t;fixes to optional PCMCIA support&n; * Version 5.37&t;&t;don&squot;t use DMA when &quot;noautotune&quot; is specified&n; * Version 5.37a (go)&t;fix shared irq probing (was broken in kernel 1.3.72)&n; *&t;&t;&t;call unplug_device() from ide_do_drive_cmd()&n; * Version 5.38&t;&t;add &quot;hdx=none&quot; option, courtesy of Joel Maslak&n; *&t;&t;&t;mask drive irq after use, if sharing with another hwif&n; *&t;&t;&t;add code to help debug weird cmd640 problems&n; * Version 5.39&t;&t;fix horrible error in earlier irq sharing &quot;fix&quot;&n; * Version 5.40&t;&t;fix serialization -- was broken in 5.39&n; *&t;&t;&t;help sharing by masking device irq after probing&n; * Version 5.41&t;&t;more fixes to irq sharing/serialize detection&n; *&t;&t;&t;disable io_32bit by default on drive reset&n; * Version 5.42&t;&t;simplify irq-masking after probe&n; *&t;&t;&t;fix NULL pointer deref in save_match()&n; * Version 5.43&t;&t;Ugh.. unexpected_intr is back: try to exterminate it&n; * Version 5.44&t;&t;Fix for &quot;irq probe failed&quot; on cmd640&n; *&t;&t;&t;change path on message regarding MAKEDEV.ide&n; *&t;&t;&t;add a throttle to the unexpected_intr() messages&n; * Version 5.45&t;&t;fix ugly parameter parsing bugs (thanks Derek)&n; *&t;&t;&t;include Gadi&squot;s magic fix for cmd640 unexpected_intr&n; *&t;&t;&t;include mc68000 patches from Geert Uytterhoeven&n; *&t;&t;&t;add Gadi&squot;s fix for PCMCIA cdroms&n; * Version 5.46&t;&t;remove the mc68000 #ifdefs for 2.0.x&n; * Version 5.47&t;&t;fix set_tune race condition&n; *&t;&t;&t;fix bug in earlier PCMCIA cdrom update&n; * Version 5.48&t;&t;if def&squot;d, invoke CMD640_DUMP_REGS when irq probe fails&n; *&t;&t;&t;lengthen the do_reset1() pulse, for laptops&n; *&t;&t;&t;add idebus=xx parameter for cmd640 and ali chipsets&n; *&t;&t;&t;no_unmask flag now per-drive instead of per-hwif&n; *&t;&t;&t;fix tune_req so that it gets done immediately&n; *&t;&t;&t;fix missing restore_flags() in ide_ioctl&n; *&t;&t;&t;prevent use of io_32bit on cmd640 with no prefetch&n; * Version 5.49&t;&t;fix minor quirks in probing routines&n; * Version 5.50&t;&t;allow values as small as 20 for idebus=&n; * Version 5.51&t;&t;force non io_32bit in drive_cmd_intr()&n; *&t;&t;&t;change delay_10ms() to delay_50ms() to fix problems&n; * Version 5.52&t;&t;fix incorrect invalidation of removable devices&n; *&t;&t;&t;add &quot;hdx=slow&quot; command line option&n; *&n; *  Some additional driver compile-time options are in ide.h&n; *&n; *  To do, in likely order of completion:&n; *&t;- modify kernel to obtain BIOS geometry for drives on 2nd/3rd/4th i/f&n;*/
DECL|macro|REALLY_SLOW_IO
macro_line|#undef REALLY_SLOW_IO&t;&t;/* most systems can safely undef this */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#ifdef CONFIG_PCI
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#endif /* CONFIG_PCI */
macro_line|#include &quot;ide.h&quot;
macro_line|#include &quot;ide_modes.h&quot;
macro_line|#ifdef CONFIG_BLK_DEV_PROMISE
macro_line|#include &quot;promise.h&quot;
DECL|macro|IS_PROMISE_DRIVE
mdefine_line|#define IS_PROMISE_DRIVE (HWIF(drive)-&gt;chipset == ide_promise)
macro_line|#else
DECL|macro|IS_PROMISE_DRIVE
mdefine_line|#define IS_PROMISE_DRIVE (0)&t;/* auto-NULLs out Promise code */
macro_line|#endif /* CONFIG_BLK_DEV_PROMISE */
DECL|variable|ide_hwif_to_major
r_static
r_const
id|byte
id|ide_hwif_to_major
(braket
id|MAX_HWIFS
)braket
op_assign
(brace
id|IDE0_MAJOR
comma
id|IDE1_MAJOR
comma
id|IDE2_MAJOR
comma
id|IDE3_MAJOR
)brace
suffix:semicolon
DECL|variable|default_io_base
r_static
r_const
r_int
r_int
id|default_io_base
(braket
id|MAX_HWIFS
)braket
op_assign
(brace
l_int|0x1f0
comma
l_int|0x170
comma
l_int|0x1e8
comma
l_int|0x168
)brace
suffix:semicolon
DECL|variable|default_irqs
r_static
r_const
id|byte
id|default_irqs
(braket
id|MAX_HWIFS
)braket
op_assign
(brace
l_int|14
comma
l_int|15
comma
l_int|11
comma
l_int|10
)brace
suffix:semicolon
DECL|variable|idebus_parameter
r_static
r_int
id|idebus_parameter
suffix:semicolon
multiline_comment|/* holds the &quot;idebus=&quot; parameter */
DECL|variable|system_bus_speed
r_static
r_int
id|system_bus_speed
suffix:semicolon
multiline_comment|/* holds what we think is VESA/PCI bus speed */
multiline_comment|/*&n; * This is declared extern in ide.h, for access by other IDE modules:&n; */
DECL|variable|ide_hwifs
id|ide_hwif_t
id|ide_hwifs
(braket
id|MAX_HWIFS
)braket
suffix:semicolon
multiline_comment|/* master data repository */
macro_line|#if (DISK_RECOVERY_TIME &gt; 0)
multiline_comment|/*&n; * For really screwy hardware (hey, at least it *can* be used with Linux)&n; * we can enforce a minimum delay time between successive operations.&n; */
DECL|function|read_timer
r_static
r_int
r_int
id|read_timer
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|t
comma
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|t
op_assign
id|jiffies
op_star
l_int|11932
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
l_int|0x43
)paren
suffix:semicolon
id|i
op_assign
id|inb_p
c_func
(paren
l_int|0x40
)paren
suffix:semicolon
id|i
op_or_assign
id|inb
c_func
(paren
l_int|0x40
)paren
op_lshift
l_int|8
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|t
op_minus
id|i
)paren
suffix:semicolon
)brace
DECL|function|set_recovery_timer
r_static
r_void
id|set_recovery_timer
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
id|hwif-&gt;last_time
op_assign
id|read_timer
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|macro|SET_RECOVERY_TIMER
mdefine_line|#define SET_RECOVERY_TIMER(drive) set_recovery_timer (drive)
macro_line|#else
DECL|macro|SET_RECOVERY_TIMER
mdefine_line|#define SET_RECOVERY_TIMER(drive)
macro_line|#endif /* DISK_RECOVERY_TIME */
multiline_comment|/*&n; * Do not even *think* about calling this!&n; */
DECL|function|init_hwif_data
r_static
r_void
id|init_hwif_data
(paren
r_int
r_int
id|index
)paren
(brace
id|byte
op_star
id|p
suffix:semicolon
r_int
r_int
id|unit
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/* bulk initialize hwif &amp; drive info with zeros */
id|p
op_assign
(paren
(paren
id|byte
op_star
)paren
id|hwif
)paren
op_plus
r_sizeof
(paren
id|ide_hwif_t
)paren
suffix:semicolon
r_do
(brace
op_star
op_decrement
id|p
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|p
OG
(paren
id|byte
op_star
)paren
id|hwif
)paren
suffix:semicolon
multiline_comment|/* fill in any non-zero initial values */
id|hwif-&gt;index
op_assign
id|index
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
(paren
id|index
OG
l_int|1
)paren
suffix:semicolon
id|hwif-&gt;io_base
op_assign
id|default_io_base
(braket
id|index
)braket
suffix:semicolon
id|hwif-&gt;ctl_port
op_assign
id|hwif-&gt;io_base
ques
c_cond
id|hwif-&gt;io_base
op_plus
l_int|0x206
suffix:colon
l_int|0x000
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_HD
r_if
c_cond
(paren
id|hwif-&gt;io_base
op_eq
id|HD_DATA
)paren
id|hwif-&gt;noprobe
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* may be overridden by ide_setup() */
macro_line|#endif /* CONFIG_BLK_DEV_HD */
id|hwif-&gt;major
op_assign
id|ide_hwif_to_major
(braket
id|index
)braket
suffix:semicolon
id|hwif-&gt;name
(braket
l_int|0
)braket
op_assign
l_char|&squot;i&squot;
suffix:semicolon
id|hwif-&gt;name
(braket
l_int|1
)braket
op_assign
l_char|&squot;d&squot;
suffix:semicolon
id|hwif-&gt;name
(braket
l_int|2
)braket
op_assign
l_char|&squot;e&squot;
suffix:semicolon
id|hwif-&gt;name
(braket
l_int|3
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|index
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDETAPE
id|hwif-&gt;tape_drive
op_assign
l_int|NULL
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDETAPE */
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
id|drive-&gt;select.all
op_assign
(paren
id|unit
op_lshift
l_int|4
)paren
op_or
l_int|0xa0
suffix:semicolon
id|drive-&gt;hwif
op_assign
id|hwif
suffix:semicolon
id|drive-&gt;ctl
op_assign
l_int|0x08
suffix:semicolon
id|drive-&gt;ready_stat
op_assign
id|READY_STAT
suffix:semicolon
id|drive-&gt;bad_wstat
op_assign
id|BAD_W_STAT
suffix:semicolon
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;special.b.set_geometry
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;name
(braket
l_int|0
)braket
op_assign
l_char|&squot;h&squot;
suffix:semicolon
id|drive-&gt;name
(braket
l_int|1
)braket
op_assign
l_char|&squot;d&squot;
suffix:semicolon
id|drive-&gt;name
(braket
l_int|2
)braket
op_assign
l_char|&squot;a&squot;
op_plus
(paren
id|index
op_star
id|MAX_DRIVES
)paren
op_plus
id|unit
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * init_ide_data() sets reasonable default values into all fields&n; * of all instances of the hwifs and drives, but only on the first call.&n; * Subsequent calls have no effect (they don&squot;t wipe out anything).&n; *&n; * This routine is normally called at driver initialization time,&n; * but may also be called MUCH earlier during kernel &quot;command-line&quot;&n; * parameter processing.  As such, we cannot depend on any other parts&n; * of the kernel (such as memory allocation) to be functioning yet.&n; *&n; * This is too bad, as otherwise we could dynamically allocate the&n; * ide_drive_t structs as needed, rather than always consuming memory&n; * for the max possible number (MAX_HWIFS * MAX_DRIVES) of them.&n; */
DECL|macro|MAGIC_COOKIE
mdefine_line|#define MAGIC_COOKIE 0x12345678
DECL|function|init_ide_data
r_static
r_void
id|init_ide_data
(paren
r_void
)paren
(brace
r_int
r_int
id|index
suffix:semicolon
r_static
r_int
r_int
id|magic_cookie
op_assign
id|MAGIC_COOKIE
suffix:semicolon
r_if
c_cond
(paren
id|magic_cookie
op_ne
id|MAGIC_COOKIE
)paren
r_return
suffix:semicolon
multiline_comment|/* already initialized */
id|magic_cookie
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
id|init_hwif_data
c_func
(paren
id|index
)paren
suffix:semicolon
id|idebus_parameter
op_assign
l_int|0
suffix:semicolon
id|system_bus_speed
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_system_bus_speed() returns what we think is the system VESA/PCI&n; * bus speed (in Mhz).  This is used for calculating interface PIO timings.&n; * The default is 40 for known PCI systems, 50 otherwise.&n; * The &quot;idebus=xx&quot; parameter can be used to override this value.&n; * The actual value to be used is computed/displayed the first time through.&n; */
DECL|function|ide_system_bus_speed
r_int
id|ide_system_bus_speed
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|system_bus_speed
)paren
(brace
r_if
c_cond
(paren
id|idebus_parameter
)paren
id|system_bus_speed
op_assign
id|idebus_parameter
suffix:semicolon
multiline_comment|/* user supplied value */
macro_line|#ifdef CONFIG_PCI
r_else
r_if
c_cond
(paren
id|pcibios_present
c_func
(paren
)paren
)paren
id|system_bus_speed
op_assign
l_int|40
suffix:semicolon
multiline_comment|/* safe default value for PCI */
macro_line|#endif /* CONFIG_PCI */
r_else
id|system_bus_speed
op_assign
l_int|50
suffix:semicolon
multiline_comment|/* safe default value for VESA and PCI */
id|printk
c_func
(paren
l_string|&quot;ide: Assuming %dMhz system bus speed for PIO modes; override with idebus=xx&bslash;n&quot;
comma
id|system_bus_speed
)paren
suffix:semicolon
)brace
r_return
id|system_bus_speed
suffix:semicolon
)brace
macro_line|#if SUPPORT_VLB_SYNC
multiline_comment|/*&n; * Some localbus EIDE interfaces require a special access sequence&n; * when using 32-bit I/O instructions to transfer data.  We call this&n; * the &quot;vlb_sync&quot; sequence, which consists of three successive reads&n; * of the sector count register location, with interrupts disabled&n; * to ensure that the reads all happen together.&n; */
DECL|function|do_vlb_sync
r_static
r_inline
r_void
id|do_vlb_sync
(paren
r_int
r_int
id|port
)paren
(brace
(paren
r_void
)paren
id|inb
(paren
id|port
)paren
suffix:semicolon
(paren
r_void
)paren
id|inb
(paren
id|port
)paren
suffix:semicolon
(paren
r_void
)paren
id|inb
(paren
id|port
)paren
suffix:semicolon
)brace
macro_line|#endif /* SUPPORT_VLB_SYNC */
multiline_comment|/*&n; * This is used for most PIO data transfers *from* the IDE interface&n; */
DECL|function|ide_input_data
r_void
id|ide_input_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
r_int
r_int
id|io_base
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|io_base
suffix:semicolon
r_int
r_int
id|data_reg
op_assign
id|io_base
op_plus
id|IDE_DATA_OFFSET
suffix:semicolon
id|byte
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
r_if
c_cond
(paren
id|io_32bit
)paren
(brace
macro_line|#if SUPPORT_VLB_SYNC
r_if
c_cond
(paren
id|io_32bit
op_amp
l_int|2
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|do_vlb_sync
c_func
(paren
id|io_base
op_plus
id|IDE_NSECTOR_OFFSET
)paren
suffix:semicolon
id|insl
c_func
(paren
id|data_reg
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;unmask
)paren
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif /* SUPPORT_VLB_SYNC */
id|insl
c_func
(paren
id|data_reg
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if SUPPORT_SLOW_DATA_PORTS
r_if
c_cond
(paren
id|drive-&gt;slow
)paren
(brace
r_int
r_int
op_star
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|wcount
op_decrement
)paren
(brace
op_star
id|ptr
op_increment
op_assign
id|inw_p
c_func
(paren
id|data_reg
)paren
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
id|inw_p
c_func
(paren
id|data_reg
)paren
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif /* SUPPORT_SLOW_DATA_PORTS */
id|insw
c_func
(paren
id|data_reg
comma
id|buffer
comma
id|wcount
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This is used for most PIO data transfers *to* the IDE interface&n; */
DECL|function|ide_output_data
r_void
id|ide_output_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|wcount
)paren
(brace
r_int
r_int
id|io_base
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|io_base
suffix:semicolon
r_int
r_int
id|data_reg
op_assign
id|io_base
op_plus
id|IDE_DATA_OFFSET
suffix:semicolon
id|byte
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
r_if
c_cond
(paren
id|io_32bit
)paren
(brace
macro_line|#if SUPPORT_VLB_SYNC
r_if
c_cond
(paren
id|io_32bit
op_amp
l_int|2
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|do_vlb_sync
c_func
(paren
id|io_base
op_plus
id|IDE_NSECTOR_OFFSET
)paren
suffix:semicolon
id|outsl
c_func
(paren
id|data_reg
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;unmask
)paren
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif /* SUPPORT_VLB_SYNC */
id|outsl
c_func
(paren
id|data_reg
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if SUPPORT_SLOW_DATA_PORTS
r_if
c_cond
(paren
id|drive-&gt;slow
)paren
(brace
r_int
r_int
op_star
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|buffer
suffix:semicolon
r_while
c_loop
(paren
id|wcount
op_decrement
)paren
(brace
id|outw_p
c_func
(paren
op_star
id|ptr
op_increment
comma
id|data_reg
)paren
suffix:semicolon
id|outw_p
c_func
(paren
op_star
id|ptr
op_increment
comma
id|data_reg
)paren
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif /* SUPPORT_SLOW_DATA_PORTS */
id|outsw
c_func
(paren
id|data_reg
comma
id|buffer
comma
id|wcount
op_lshift
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This should get invoked any time we exit the driver to&n; * wait for an interrupt response from a drive.  handler() points&n; * at the appropriate code to handle the next interrupt, and a&n; * timer is started to prevent us from waiting forever in case&n; * something goes wrong (see the timer_expiry() handler later on).&n; */
DECL|function|ide_set_handler
r_void
id|ide_set_handler
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_handler_t
op_star
id|handler
comma
r_int
r_int
id|timeout
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ide_set_handler: handler not null; old=%p, new=%p&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|hwgroup-&gt;handler
comma
id|handler
)paren
suffix:semicolon
)brace
macro_line|#endif
id|hwgroup-&gt;handler
op_assign
id|handler
suffix:semicolon
id|hwgroup-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
(paren
id|hwgroup-&gt;timer
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * lba_capacity_is_ok() performs a sanity check on the claimed &quot;lba_capacity&quot;&n; * value for this drive (from its reported identification information).&n; *&n; * Returns:&t;1 if lba_capacity looks sensible&n; *&t;&t;0 otherwise&n; */
DECL|function|lba_capacity_is_ok
r_static
r_int
id|lba_capacity_is_ok
(paren
r_struct
id|hd_driveid
op_star
id|id
)paren
(brace
r_int
r_int
id|lba_sects
op_assign
id|id-&gt;lba_capacity
suffix:semicolon
r_int
r_int
id|chs_sects
op_assign
id|id-&gt;cyls
op_star
id|id-&gt;heads
op_star
id|id-&gt;sectors
suffix:semicolon
r_int
r_int
id|_10_percent
op_assign
id|chs_sects
op_div
l_int|10
suffix:semicolon
multiline_comment|/* perform a rough sanity check on lba_sects:  within 10% is &quot;okay&quot; */
r_if
c_cond
(paren
(paren
id|lba_sects
op_minus
id|chs_sects
)paren
OL
id|_10_percent
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* lba_capacity is good */
multiline_comment|/* some drives have the word order reversed */
id|lba_sects
op_assign
(paren
id|lba_sects
op_lshift
l_int|16
)paren
op_or
(paren
id|lba_sects
op_rshift
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|lba_sects
op_minus
id|chs_sects
)paren
OL
id|_10_percent
)paren
(brace
id|id-&gt;lba_capacity
op_assign
id|lba_sects
suffix:semicolon
multiline_comment|/* fix it */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* lba_capacity is (now) good */
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* lba_capacity value is bad */
)brace
multiline_comment|/*&n; * current_capacity() returns the capacity (in sectors) of a drive&n; * according to its current geometry/LBA settings.&n; */
DECL|function|current_capacity
r_static
r_int
r_int
id|current_capacity
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
r_int
r_int
id|capacity
op_assign
id|drive-&gt;cyl
op_star
id|drive-&gt;head
op_star
id|drive-&gt;sect
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_return
l_int|0x7fffffff
suffix:semicolon
multiline_comment|/* cdrom or tape */
id|drive-&gt;select.b.lba
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Determine capacity, and use LBA if the drive properly supports it */
r_if
c_cond
(paren
id|id
op_ne
l_int|NULL
op_logical_and
(paren
id|id-&gt;capability
op_amp
l_int|2
)paren
op_logical_and
id|lba_capacity_is_ok
c_func
(paren
id|id
)paren
)paren
(brace
r_if
c_cond
(paren
id|id-&gt;lba_capacity
op_ge
id|capacity
)paren
(brace
id|capacity
op_assign
id|id-&gt;lba_capacity
suffix:semicolon
id|drive-&gt;select.b.lba
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
(paren
id|capacity
op_minus
id|drive-&gt;sect0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_geninit() is called exactly *once* for each major, from genhd.c,&n; * at the beginning of the initial partition check for the drives.&n; */
DECL|function|ide_geninit
r_static
r_void
id|ide_geninit
(paren
r_struct
id|gendisk
op_star
id|gd
)paren
(brace
r_int
r_int
id|unit
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|gd-&gt;real_devices
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|gd-&gt;nr_real
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|drive-&gt;present
op_logical_and
id|drive-&gt;media
op_eq
id|ide_cdrom
)paren
id|ide_cdrom_setup
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDECD */
macro_line|#ifdef CONFIG_BLK_DEV_IDETAPE
r_if
c_cond
(paren
id|drive-&gt;present
op_logical_and
id|drive-&gt;media
op_eq
id|ide_tape
)paren
id|idetape_setup
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDETAPE */
id|drive-&gt;part
(braket
l_int|0
)braket
dot
id|nr_sects
op_assign
id|current_capacity
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
op_logical_or
id|drive-&gt;media
op_ne
id|ide_disk
)paren
(brace
id|drive-&gt;part
(braket
l_int|0
)braket
dot
id|start_sect
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* skip partition check */
)brace
)brace
)brace
multiline_comment|/*&n; * init_gendisk() (as opposed to ide_geninit) is called for each major device,&n; * after probing for drives, to allocate partition tables and other data&n; * structures needed for the routines in genhd.c.  ide_geninit() gets called&n; * somewhat later, during the partition check.&n; */
DECL|function|init_gendisk
r_static
r_void
id|init_gendisk
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_struct
id|gendisk
op_star
id|gd
comma
op_star
op_star
id|gdp
suffix:semicolon
r_int
r_int
id|unit
comma
id|units
comma
id|minors
suffix:semicolon
r_int
op_star
id|bs
suffix:semicolon
multiline_comment|/* figure out maximum drive number on the interface */
r_for
c_loop
(paren
id|units
op_assign
id|MAX_DRIVES
suffix:semicolon
id|units
OG
l_int|0
suffix:semicolon
op_decrement
id|units
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;drives
(braket
id|units
op_minus
l_int|1
)braket
dot
id|present
)paren
r_break
suffix:semicolon
)brace
id|minors
op_assign
id|units
op_star
(paren
l_int|1
op_lshift
id|PARTN_BITS
)paren
suffix:semicolon
id|gd
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|gendisk
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|gd-&gt;sizes
op_assign
id|kmalloc
(paren
id|minors
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|gd-&gt;part
op_assign
id|kmalloc
(paren
id|minors
op_star
r_sizeof
(paren
r_struct
id|hd_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|bs
op_assign
id|kmalloc
(paren
id|minors
op_star
r_sizeof
(paren
r_int
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|memset
c_func
(paren
id|gd-&gt;part
comma
l_int|0
comma
id|minors
op_star
r_sizeof
(paren
r_struct
id|hd_struct
)paren
)paren
suffix:semicolon
multiline_comment|/* cdroms and msdos f/s are examples of non-1024 blocksizes */
id|blksize_size
(braket
id|hwif-&gt;major
)braket
op_assign
id|bs
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|minors
suffix:semicolon
op_increment
id|unit
)paren
op_star
id|bs
op_increment
op_assign
id|BLOCK_SIZE
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|units
suffix:semicolon
op_increment
id|unit
)paren
id|hwif-&gt;drives
(braket
id|unit
)braket
dot
id|part
op_assign
op_amp
id|gd-&gt;part
(braket
id|unit
op_lshift
id|PARTN_BITS
)braket
suffix:semicolon
id|gd-&gt;major
op_assign
id|hwif-&gt;major
suffix:semicolon
multiline_comment|/* our major device number */
id|gd-&gt;major_name
op_assign
id|IDE_MAJOR_NAME
suffix:semicolon
multiline_comment|/* treated special in genhd.c */
id|gd-&gt;minor_shift
op_assign
id|PARTN_BITS
suffix:semicolon
multiline_comment|/* num bits for partitions */
id|gd-&gt;max_p
op_assign
l_int|1
op_lshift
id|PARTN_BITS
suffix:semicolon
multiline_comment|/* 1 + max partitions / drive */
id|gd-&gt;max_nr
op_assign
id|units
suffix:semicolon
multiline_comment|/* max num real drives */
id|gd-&gt;nr_real
op_assign
id|units
suffix:semicolon
multiline_comment|/* current num real drives */
id|gd-&gt;init
op_assign
id|ide_geninit
suffix:semicolon
multiline_comment|/* initialization function */
id|gd-&gt;real_devices
op_assign
id|hwif
suffix:semicolon
multiline_comment|/* ptr to internal data */
id|gd-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* linked list of major devs */
r_for
c_loop
(paren
id|gdp
op_assign
op_amp
id|gendisk_head
suffix:semicolon
op_star
id|gdp
suffix:semicolon
id|gdp
op_assign
op_amp
(paren
(paren
op_star
id|gdp
)paren
op_member_access_from_pointer
id|next
)paren
)paren
suffix:semicolon
id|hwif-&gt;gd
op_assign
op_star
id|gdp
op_assign
id|gd
suffix:semicolon
multiline_comment|/* link onto tail of list */
)brace
r_static
r_void
id|do_reset1
(paren
id|ide_drive_t
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* needed below */
macro_line|#ifdef CONFIG_BLK_DEV_IDEATAPI
multiline_comment|/*&n; * atapi_reset_pollfunc() gets invoked to poll the interface for completion every 50ms&n; * during an atapi drive reset operation. If the drive has not yet responded,&n; * and we have not yet hit our maximum waiting time, then the timer is restarted&n; * for another 50ms.&n; */
DECL|function|atapi_reset_pollfunc
r_static
r_void
id|atapi_reset_pollfunc
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
id|byte
id|stat
suffix:semicolon
id|OUT_BYTE
(paren
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|udelay
(paren
l_int|10
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
l_int|0
comma
id|BUSY_STAT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ATAPI reset complete&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|jiffies
OL
id|hwgroup-&gt;poll_timeout
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|atapi_reset_pollfunc
comma
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* continue polling */
)brace
id|hwgroup-&gt;poll_timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* end of polling */
id|printk
c_func
(paren
l_string|&quot;%s: ATAPI reset timed-out, status=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|stat
)paren
suffix:semicolon
id|do_reset1
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* do it the old fashioned way */
r_return
suffix:semicolon
)brace
id|hwgroup-&gt;poll_timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* done polling */
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEATAPI */
multiline_comment|/*&n; * reset_pollfunc() gets invoked to poll the interface for completion every 50ms&n; * during an ide reset operation. If the drives have not yet responded,&n; * and we have not yet hit our maximum waiting time, then the timer is restarted&n; * for another 50ms.&n; */
DECL|function|reset_pollfunc
r_static
r_void
id|reset_pollfunc
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|byte
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|tmp
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
l_int|0
comma
id|BUSY_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|jiffies
OL
id|hwgroup-&gt;poll_timeout
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|reset_pollfunc
comma
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* continue polling */
)brace
id|printk
c_func
(paren
l_string|&quot;%s: reset timed-out, status=0x%02x&bslash;n&quot;
comma
id|hwif-&gt;name
comma
id|tmp
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;%s: reset: &quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|tmp
op_assign
id|GET_ERR
c_func
(paren
)paren
)paren
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;success&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
macro_line|#if FANCY_STATUS_DUMPS
id|printk
c_func
(paren
l_string|&quot;master: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|tmp
op_amp
l_int|0x7f
)paren
(brace
r_case
l_int|1
suffix:colon
id|printk
c_func
(paren
l_string|&quot;passed&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
c_func
(paren
l_string|&quot;formatter device error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
l_string|&quot;sector buffer error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ECC circuitry error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printk
c_func
(paren
l_string|&quot;controlling MPU error&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;error (0x%02x?)&quot;
comma
id|tmp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp
op_amp
l_int|0x80
)paren
id|printk
c_func
(paren
l_string|&quot;; slave: failed&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
l_string|&quot;failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* FANCY_STATUS_DUMPS */
)brace
)brace
id|hwgroup-&gt;poll_timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* done polling */
)brace
multiline_comment|/*&n; * do_reset1() attempts to recover a confused drive by resetting it.&n; * Unfortunately, resetting a disk drive actually resets all devices on&n; * the same interface, so it can really be thought of as resetting the&n; * interface rather than resetting the drive.&n; *&n; * ATAPI devices have their own reset mechanism which allows them to be&n; * individually reset without clobbering other devices on the same interface.&n; *&n; * Unfortunately, the IDE interface does not generate an interrupt to let&n; * us know when the reset operation has finished, so we must poll for this.&n; * Equally poor, though, is the fact that this may a very long time to complete,&n; * (up to 30 seconds worstcase).  So, instead of busy-waiting here for it,&n; * we set a timer to poll at 50ms intervals.&n; */
DECL|function|do_reset1
r_static
r_void
id|do_reset1
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|do_not_try_atapi
)paren
(brace
r_int
r_int
id|unit
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Why ? */
macro_line|#ifdef CONFIG_BLK_DEV_IDEATAPI
multiline_comment|/* For an ATAPI device, first try an ATAPI SRST. */
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|do_not_try_atapi
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;keep_settings
)paren
(brace
id|drive-&gt;unmask
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
)brace
id|OUT_BYTE
(paren
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|udelay
(paren
l_int|20
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|WIN_SRST
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|hwgroup-&gt;poll_timeout
op_assign
id|jiffies
op_plus
id|WAIT_WORSTCASE
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|atapi_reset_pollfunc
comma
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEATAPI */
multiline_comment|/*&n;&t; * First, reset any device state data we were maintaining&n;&t; * for any of the drives on this interface.&n;&t; */
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|rdrive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
id|rdrive-&gt;special.all
op_assign
l_int|0
suffix:semicolon
id|rdrive-&gt;special.b.set_geometry
op_assign
l_int|1
suffix:semicolon
id|rdrive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|OK_TO_RESET_CONTROLLER
)paren
id|rdrive-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|rdrive-&gt;keep_settings
)paren
(brace
id|rdrive-&gt;mult_req
op_assign
l_int|0
suffix:semicolon
id|rdrive-&gt;unmask
op_assign
l_int|0
suffix:semicolon
id|rdrive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|rdrive-&gt;using_dma
)paren
(brace
id|rdrive-&gt;using_dma
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: disabled DMA&bslash;n&quot;
comma
id|rdrive-&gt;name
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|rdrive-&gt;mult_req
op_ne
id|rdrive-&gt;mult_count
)paren
id|rdrive-&gt;special.b.set_multmode
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#if OK_TO_RESET_CONTROLLER
multiline_comment|/*&n;&t; * Note that we also set nIEN while resetting the device,&n;&t; * to mask unwanted interrupts from the interface during the reset.&n;&t; * However, due to the design of PC hardware, this will cause an&n;&t; * immediate interrupt due to the edge transition it produces.&n;&t; * This single interrupt gives us a &quot;fast poll&quot; for drives that&n;&t; * recover from reset very quickly, saving us the first 50ms wait time.&n;&t; */
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|6
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* set SRST and nIEN */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* more than enough time */
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|2
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* clear SRST, leave nIEN */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* more than enough time */
id|hwgroup-&gt;poll_timeout
op_assign
id|jiffies
op_plus
id|WAIT_WORSTCASE
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|reset_pollfunc
comma
id|HZ
op_div
l_int|20
)paren
suffix:semicolon
macro_line|#endif&t;/* OK_TO_RESET_CONTROLLER */
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_do_reset() is the entry point to the drive/interface reset code.&n; */
DECL|function|ide_do_reset
r_void
id|ide_do_reset
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|do_reset1
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDETAPE
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_tape
)paren
id|drive-&gt;tape.reset_issued
op_assign
l_int|1
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDETAPE */
)brace
multiline_comment|/*&n; * Clean up after success/failure of an explicit drive cmd&n; */
DECL|function|ide_end_drive_cmd
r_void
id|ide_end_drive_cmd
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|stat
comma
id|byte
id|err
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|IDE_DRIVE_CMD
)paren
(brace
id|byte
op_star
id|args
op_assign
(paren
id|byte
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|rq-&gt;errors
op_assign
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
)paren
(brace
id|args
(braket
l_int|0
)braket
op_assign
id|stat
suffix:semicolon
id|args
(braket
l_int|1
)braket
op_assign
id|err
suffix:semicolon
id|args
(braket
l_int|2
)braket
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
)brace
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|blk_dev
(braket
id|MAJOR
c_func
(paren
id|rq-&gt;rq_dev
)paren
)braket
dot
id|current_request
op_assign
id|rq-&gt;next
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_assign
l_int|NULL
suffix:semicolon
id|rq-&gt;rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;sem
op_ne
l_int|NULL
)paren
id|up
c_func
(paren
id|rq-&gt;sem
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Error reporting, in human readable form (luxurious, but a memory hog).&n; */
DECL|function|ide_dump_status
id|byte
id|ide_dump_status
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|byte
id|stat
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|byte
id|err
op_assign
l_int|0
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s: status=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Busy &quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|READY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DriveReady &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DeviceFault &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|SEEK_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;SeekComplete &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DataRequest &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ECC_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;CorrectedError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|INDEX_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Index &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Error &quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
(paren
id|BUSY_STAT
op_or
id|ERR_STAT
)paren
)paren
op_eq
id|ERR_STAT
)paren
(brace
id|err
op_assign
id|GET_ERR
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s: error=0x%02x&quot;
comma
id|drive-&gt;name
comma
id|msg
comma
id|err
)paren
suffix:semicolon
macro_line|#if FANCY_STATUS_DUMPS
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; { &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|BBD_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;BadSector &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ECC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;UncorrectableError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ID_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;SectorIdNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|ABRT_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;DriveStatusError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;TrackZeroNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
id|MARK_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;AddrMarkNotFound &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ECC_ERR
op_or
id|ID_ERR
op_or
id|MARK_ERR
)paren
)paren
(brace
id|byte
id|cur
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cur
op_amp
l_int|0x40
)paren
(brace
multiline_comment|/* using LBA? */
id|printk
c_func
(paren
l_string|&quot;, LBAsect=%ld&quot;
comma
(paren
r_int
r_int
)paren
(paren
(paren
id|cur
op_amp
l_int|0xf
)paren
op_lshift
l_int|24
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|16
)paren
op_or
(paren
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
op_lshift
l_int|8
)paren
op_or
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, CHS=%d/%d/%d&quot;
comma
(paren
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
op_lshift
l_int|8
)paren
op_plus
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
comma
id|cur
op_amp
l_int|0xf
comma
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
id|printk
c_func
(paren
l_string|&quot;, sector=%ld&quot;
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq-&gt;sector
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif&t;/* FANCY_STATUS_DUMPS */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
multiline_comment|/*&n; * try_to_flush_leftover_data() is invoked in response to a drive&n; * unexpectedly having its DRQ_STAT bit set.  As an alternative to&n; * resetting the drive, this routine tries to clear the condition&n; * by read a sector&squot;s worth of data from the drive.  Of course,&n; * this may not help if the drive is *waiting* for data from *us*.&n; */
DECL|function|try_to_flush_leftover_data
r_static
r_void
id|try_to_flush_leftover_data
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|i
op_assign
(paren
id|drive-&gt;mult_count
ques
c_cond
id|drive-&gt;mult_count
suffix:colon
l_int|1
)paren
op_star
id|SECTOR_WORDS
suffix:semicolon
r_while
c_loop
(paren
id|i
OG
l_int|0
)paren
(brace
r_int
r_int
id|buffer
(braket
l_int|16
)braket
suffix:semicolon
r_int
r_int
id|wcount
op_assign
(paren
id|i
OG
l_int|16
)paren
ques
c_cond
l_int|16
suffix:colon
id|i
suffix:semicolon
id|i
op_sub_assign
id|wcount
suffix:semicolon
id|ide_input_data
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * ide_error() takes action based on the error returned by the controller.&n; */
DECL|function|ide_error
r_void
id|ide_error
(paren
id|ide_drive_t
op_star
id|drive
comma
r_const
r_char
op_star
id|msg
comma
id|byte
id|stat
)paren
(brace
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|byte
id|err
suffix:semicolon
id|err
op_assign
id|ide_dump_status
c_func
(paren
id|drive
comma
id|msg
comma
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
op_eq
l_int|NULL
op_logical_or
id|drive
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
multiline_comment|/* retry only &quot;normal&quot; I/O: */
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|IDE_DRIVE_CMD
)paren
(brace
id|rq-&gt;errors
op_assign
l_int|1
suffix:semicolon
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|stat
comma
id|err
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
(brace
multiline_comment|/* other bits are useless when BUSY */
id|rq-&gt;errors
op_or_assign
id|ERROR_RESET
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
op_logical_and
(paren
id|stat
op_amp
id|ERR_STAT
)paren
)paren
(brace
multiline_comment|/* err has different meaning on cdrom and tape */
r_if
c_cond
(paren
id|err
op_amp
(paren
id|BBD_ERR
op_or
id|ECC_ERR
)paren
)paren
multiline_comment|/* retries won&squot;t help these */
id|rq-&gt;errors
op_assign
id|ERROR_MAX
suffix:semicolon
r_else
r_if
c_cond
(paren
id|err
op_amp
id|TRK0_ERR
)paren
multiline_comment|/* help it find track zero */
id|rq-&gt;errors
op_or_assign
id|ERROR_RECAL
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_logical_and
id|rq-&gt;cmd
op_ne
id|WRITE
)paren
id|try_to_flush_leftover_data
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|GET_STAT
c_func
(paren
)paren
op_amp
(paren
id|BUSY_STAT
op_or
id|DRQ_STAT
)paren
)paren
id|rq-&gt;errors
op_or_assign
id|ERROR_RESET
suffix:semicolon
multiline_comment|/* Mmmm.. timing problem */
r_if
c_cond
(paren
id|rq-&gt;errors
op_ge
id|ERROR_MAX
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_IDETAPE
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_tape
)paren
(brace
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|idetape_end_request
c_func
(paren
l_int|0
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif /* CONFIG_BLK_DEV_IDETAPE */
id|ide_end_request
c_func
(paren
l_int|0
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RESET
)paren
op_eq
id|ERROR_RESET
)paren
(brace
op_increment
id|rq-&gt;errors
suffix:semicolon
id|ide_do_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|rq-&gt;errors
op_amp
id|ERROR_RECAL
)paren
op_eq
id|ERROR_RECAL
)paren
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
op_increment
id|rq-&gt;errors
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * read_intr() is the handler for disk read/multread interrupts&n; */
DECL|function|read_intr
r_static
r_void
id|read_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|msect
comma
id|nsect
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;read_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|msect
op_assign
id|drive-&gt;mult_count
suffix:semicolon
id|read_next
suffix:colon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_if
c_cond
(paren
id|msect
)paren
(brace
r_if
c_cond
(paren
(paren
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
)paren
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|msect
op_sub_assign
id|nsect
suffix:semicolon
)brace
r_else
id|nsect
op_assign
l_int|1
suffix:semicolon
id|ide_input_data
c_func
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s:  read: sectors(%ld-%ld), buffer=0x%08lx, remaining=%ld&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;sector
comma
id|rq-&gt;sector
op_plus
id|nsect
op_minus
l_int|1
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
op_plus
(paren
id|nsect
op_lshift
l_int|9
)paren
comma
id|rq-&gt;nr_sectors
op_minus
id|nsect
)paren
suffix:semicolon
macro_line|#endif
id|rq-&gt;sector
op_add_assign
id|nsect
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|nsect
op_lshift
l_int|9
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
(paren
id|rq-&gt;nr_sectors
op_sub_assign
id|nsect
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
)paren
op_le
l_int|0
)paren
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|msect
)paren
r_goto
id|read_next
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|read_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * write_intr() is the handler for disk write interrupts&n; */
DECL|function|write_intr
r_static
r_void
id|write_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|hwgroup-&gt;rq
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
)paren
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: write: sector %ld, buffer=0x%08lx, remaining=%ld&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;sector
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
comma
id|rq-&gt;nr_sectors
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|rq-&gt;nr_sectors
op_eq
l_int|1
)paren
op_xor
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_ne
l_int|0
)paren
)paren
(brace
id|rq-&gt;sector
op_increment
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
l_int|512
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
op_decrement
id|rq-&gt;nr_sectors
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_le
l_int|0
)paren
id|ide_end_request
c_func
(paren
l_int|1
comma
id|hwgroup
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
id|ide_output_data
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|write_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)brace
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;write_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_multwrite() transfers a block of up to mcount sectors of data&n; * to a drive as part of a disk multiple-sector write operation.&n; */
DECL|function|ide_multwrite
r_void
id|ide_multwrite
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|mcount
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
op_amp
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|wrq
suffix:semicolon
r_do
(brace
r_int
r_int
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|nsect
OG
id|mcount
)paren
id|nsect
op_assign
id|mcount
suffix:semicolon
id|mcount
op_sub_assign
id|nsect
suffix:semicolon
id|ide_output_data
c_func
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|nsect
op_lshift
l_int|7
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: multwrite: sector %ld, buffer=0x%08lx, count=%d, remaining=%ld&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;sector
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
comma
id|nsect
comma
id|rq-&gt;nr_sectors
op_minus
id|nsect
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|rq-&gt;nr_sectors
op_sub_assign
id|nsect
)paren
op_le
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|rq-&gt;bh
op_assign
id|rq-&gt;bh-&gt;b_reqnext
)paren
op_ne
l_int|NULL
)paren
(brace
id|rq-&gt;current_nr_sectors
op_assign
id|rq-&gt;bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|rq-&gt;buffer
op_assign
id|rq-&gt;bh-&gt;b_data
suffix:semicolon
)brace
r_else
(brace
id|panic
c_func
(paren
l_string|&quot;%s: buffer list corrupted&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|rq-&gt;buffer
op_add_assign
id|nsect
op_lshift
l_int|9
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|mcount
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * multwrite_intr() is the handler for disk multwrite interrupts&n; */
DECL|function|multwrite_intr
r_static
r_void
id|multwrite_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_int
id|i
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
op_amp
id|hwgroup-&gt;wrq
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
)paren
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;nr_sectors
)paren
(brace
id|ide_multwrite
c_func
(paren
id|drive
comma
id|drive-&gt;mult_count
)paren
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|multwrite_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;nr_sectors
)paren
(brace
multiline_comment|/* all done? */
id|rq
op_assign
id|hwgroup-&gt;rq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|i
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|1
comma
id|hwgroup
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
)brace
)brace
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;multwrite_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Issue a simple drive command&n; * The drive must be selected beforehand.&n; */
DECL|function|ide_cmd
r_static
r_void
id|ide_cmd
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|cmd
comma
id|byte
id|nsect
comma
id|ide_handler_t
op_star
id|handler
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|WAIT_CMD
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|nsect
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|cmd
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * set_multmode_intr() is invoked on completion of a WIN_SETMULT cmd.&n; */
DECL|function|set_multmode_intr
r_static
r_void
id|set_multmode_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
(brace
id|drive-&gt;mult_count
op_assign
id|drive-&gt;mult_req
suffix:semicolon
)brace
r_else
(brace
id|drive-&gt;mult_req
op_assign
id|drive-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;special.b.recalibrate
op_assign
l_int|1
suffix:semicolon
(paren
r_void
)paren
id|ide_dump_status
c_func
(paren
id|drive
comma
l_string|&quot;set_multmode&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * set_geometry_intr() is invoked on completion of a WIN_SPECIFY cmd.&n; */
DECL|function|set_geometry_intr
r_static
r_void
id|set_geometry_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;set_geometry_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * recal_intr() is invoked on completion of a WIN_RESTORE (recalibrate) cmd.&n; */
DECL|function|recal_intr
r_static
r_void
id|recal_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;recal_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * drive_cmd_intr() is invoked on completion of a special DRIVE_CMD.&n; */
DECL|function|drive_cmd_intr
r_static
r_void
id|drive_cmd_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|byte
op_star
id|args
op_assign
(paren
id|byte
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|byte
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_logical_and
id|args
op_logical_and
id|args
(braket
l_int|3
)braket
)paren
(brace
id|byte
id|io_32bit
op_assign
id|drive-&gt;io_32bit
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
id|ide_input_data
c_func
(paren
id|drive
comma
op_amp
id|args
(braket
l_int|4
)braket
comma
id|args
(braket
l_int|3
)braket
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
id|io_32bit
suffix:semicolon
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
comma
id|READY_STAT
comma
id|BAD_STAT
)paren
)paren
id|ide_end_drive_cmd
(paren
id|drive
comma
id|stat
comma
id|GET_ERR
c_func
(paren
)paren
)paren
suffix:semicolon
r_else
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;drive_cmd&quot;
comma
id|stat
)paren
suffix:semicolon
multiline_comment|/* calls ide_end_drive_cmd */
)brace
multiline_comment|/*&n; * do_special() is used to issue WIN_SPECIFY, WIN_RESTORE, and WIN_SETMULT&n; * commands to a drive.  It used to do much more, but has been scaled back.&n; */
DECL|function|do_special
r_static
r_inline
r_void
id|do_special
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|special_t
op_star
id|s
op_assign
op_amp
id|drive-&gt;special
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: do_special: 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|s-&gt;all
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|s-&gt;b.set_geometry
)paren
(brace
id|s-&gt;b.set_geometry
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|drive-&gt;sect
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|drive-&gt;cyl
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|drive-&gt;cyl
op_rshift
l_int|8
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
(paren
(paren
id|drive-&gt;head
op_minus
l_int|1
)paren
op_or
id|drive-&gt;select.all
)paren
op_amp
l_int|0xBF
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_PROMISE_DRIVE
)paren
id|ide_cmd
c_func
(paren
id|drive
comma
id|WIN_SPECIFY
comma
id|drive-&gt;sect
comma
op_amp
id|set_geometry_intr
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;b.recalibrate
)paren
(brace
id|s-&gt;b.recalibrate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
op_logical_and
op_logical_neg
id|IS_PROMISE_DRIVE
)paren
id|ide_cmd
c_func
(paren
id|drive
comma
id|WIN_RESTORE
comma
id|drive-&gt;sect
comma
op_amp
id|recal_intr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;b.set_tune
)paren
(brace
id|ide_tuneproc_t
op_star
id|tuneproc
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|tuneproc
suffix:semicolon
id|s-&gt;b.set_tune
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tuneproc
op_ne
l_int|NULL
)paren
id|tuneproc
c_func
(paren
id|drive
comma
id|drive-&gt;tune_req
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;b.set_multmode
)paren
(brace
id|s-&gt;b.set_multmode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;id
op_logical_and
id|drive-&gt;mult_req
OG
id|drive-&gt;id-&gt;max_multsect
)paren
id|drive-&gt;mult_req
op_assign
id|drive-&gt;id-&gt;max_multsect
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IS_PROMISE_DRIVE
)paren
id|ide_cmd
c_func
(paren
id|drive
comma
id|WIN_SETMULT
comma
id|drive-&gt;mult_req
comma
op_amp
id|set_multmode_intr
)paren
suffix:semicolon
)brace
r_else
id|drive-&gt;mult_req
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;all
)paren
(brace
r_int
id|special
op_assign
id|s-&gt;all
suffix:semicolon
id|s-&gt;all
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: bad special flag: 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|special
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This routine busy-waits for the drive status to be not &quot;busy&quot;.&n; * It then checks the status for all of the &quot;good&quot; bits and none&n; * of the &quot;bad&quot; bits, and if all is okay it returns 0.  All other&n; * cases return 1 after invoking ide_error() -- caller should just return.&n; *&n; * This routine should get fixed to not hog the cpu during extra long waits..&n; * That could be done by busy-waiting for the first jiffy or two, and then&n; * setting a timer to wake up at half second intervals thereafter,&n; * until timeout is achieved, before timing out.&n; */
DECL|function|ide_wait_stat
r_int
id|ide_wait_stat
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|good
comma
id|byte
id|bad
comma
r_int
r_int
id|timeout
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|test
suffix:colon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* spec allows drive 400ns to change &quot;BUSY&quot; */
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
comma
id|good
comma
id|bad
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* fast exit for most frequent case */
r_if
c_cond
(paren
op_logical_neg
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
)paren
(brace
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;status error&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|timeout
op_add_assign
id|jiffies
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
)paren
op_amp
id|BUSY_STAT
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_goto
id|test
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|jiffies
op_le
id|timeout
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;status timeout&quot;
comma
id|GET_STAT
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * do_rw_disk() issues READ and WRITE commands to a disk,&n; * using LBA if supported, or CHS otherwise, to address sectors.&n; * It also takes care of issuing special DRIVE_CMDs.&n; */
DECL|function|do_rw_disk
r_static
r_inline
r_void
id|do_rw_disk
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_int
r_int
id|block
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
id|io_base
op_assign
id|hwif-&gt;io_base
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_PROMISE
r_int
id|use_promise_io
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_PROMISE */
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|rq-&gt;nr_sectors
comma
id|io_base
op_plus
id|IDE_NSECTOR_OFFSET
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_PROMISE
r_if
c_cond
(paren
id|IS_PROMISE_DRIVE
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;is_promise2
op_logical_or
id|rq-&gt;cmd
op_eq
id|READ
)paren
(brace
id|use_promise_io
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|drive-&gt;select.b.lba
op_logical_or
id|use_promise_io
)paren
(brace
macro_line|#else /* !CONFIG_BLK_DEV_PROMISE */
r_if
c_cond
(paren
id|drive-&gt;select.b.lba
)paren
(brace
macro_line|#endif /* CONFIG_BLK_DEV_PROMISE */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: %sing: LBAsect=%ld, sectors=%ld, buffer=0x%08lx&bslash;n&quot;
comma
id|drive-&gt;name
comma
(paren
id|rq-&gt;cmd
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;writ&quot;
comma
id|block
comma
id|rq-&gt;nr_sectors
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
)paren
suffix:semicolon
macro_line|#endif
id|OUT_BYTE
c_func
(paren
id|block
comma
id|io_base
op_plus
id|IDE_SECTOR_OFFSET
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|block
op_rshift_assign
l_int|8
comma
id|io_base
op_plus
id|IDE_LCYL_OFFSET
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|block
op_rshift_assign
l_int|8
comma
id|io_base
op_plus
id|IDE_HCYL_OFFSET
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
(paren
(paren
id|block
op_rshift
l_int|8
)paren
op_amp
l_int|0x0f
)paren
op_or
id|drive-&gt;select.all
comma
id|io_base
op_plus
id|IDE_SELECT_OFFSET
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|sect
comma
id|head
comma
id|cyl
comma
id|track
suffix:semicolon
id|track
op_assign
id|block
op_div
id|drive-&gt;sect
suffix:semicolon
id|sect
op_assign
id|block
op_mod
id|drive-&gt;sect
op_plus
l_int|1
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|sect
comma
id|io_base
op_plus
id|IDE_SECTOR_OFFSET
)paren
suffix:semicolon
id|head
op_assign
id|track
op_mod
id|drive-&gt;head
suffix:semicolon
id|cyl
op_assign
id|track
op_div
id|drive-&gt;head
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|cyl
comma
id|io_base
op_plus
id|IDE_LCYL_OFFSET
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|cyl
op_rshift
l_int|8
comma
id|io_base
op_plus
id|IDE_HCYL_OFFSET
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|head
op_or
id|drive-&gt;select.all
comma
id|io_base
op_plus
id|IDE_SELECT_OFFSET
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: %sing: CHS=%d/%d/%d, sectors=%ld, buffer=0x%08lx&bslash;n&quot;
comma
id|drive-&gt;name
comma
(paren
id|rq-&gt;cmd
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;writ&quot;
comma
id|cyl
comma
id|head
comma
id|sect
comma
id|rq-&gt;nr_sectors
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef CONFIG_BLK_DEV_PROMISE
r_if
c_cond
(paren
id|use_promise_io
)paren
(brace
id|do_promise_io
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_PROMISE */
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|READ
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_TRITON
r_if
c_cond
(paren
id|drive-&gt;using_dma
op_logical_and
op_logical_neg
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_read
comma
id|drive
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_TRITON */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|read_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|drive-&gt;mult_count
ques
c_cond
id|WIN_MULTREAD
suffix:colon
id|WIN_READ
comma
id|io_base
op_plus
id|IDE_COMMAND_OFFSET
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|WRITE
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_TRITON
r_if
c_cond
(paren
id|drive-&gt;using_dma
op_logical_and
op_logical_neg
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_write
comma
id|drive
)paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_TRITON */
id|OUT_BYTE
c_func
(paren
id|drive-&gt;mult_count
ques
c_cond
id|WIN_MULTWRITE
suffix:colon
id|WIN_WRITE
comma
id|io_base
op_plus
id|IDE_COMMAND_OFFSET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: no DRQ after issuing %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;mult_count
ques
c_cond
l_string|&quot;MULTWRITE&quot;
suffix:colon
l_string|&quot;WRITE&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;unmask
)paren
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;mult_count
)paren
(brace
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|wrq
op_assign
op_star
id|rq
suffix:semicolon
multiline_comment|/* scratchpad */
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|multwrite_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
id|ide_multwrite
c_func
(paren
id|drive
comma
id|drive-&gt;mult_count
)paren
suffix:semicolon
)brace
r_else
(brace
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|write_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
id|ide_output_data
c_func
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: bad command: %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;cmd
)paren
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|0
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * execute_drive_cmd() issues a special drive command,&n; * usually initiated by ioctl() from the external hdparm program.&n; */
DECL|function|execute_drive_cmd
r_static
r_void
id|execute_drive_cmd
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|byte
op_star
id|args
op_assign
id|rq-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
id|args
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: DRIVE_CMD cmd=0x%02x sc=0x%02x fr=0x%02x xx=0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|args
(braket
l_int|0
)braket
comma
id|args
(braket
l_int|1
)braket
comma
id|args
(braket
l_int|2
)braket
comma
id|args
(braket
l_int|3
)braket
)paren
suffix:semicolon
macro_line|#endif
id|OUT_BYTE
c_func
(paren
id|args
(braket
l_int|2
)braket
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|ide_cmd
c_func
(paren
id|drive
comma
id|args
(braket
l_int|0
)braket
comma
id|args
(braket
l_int|1
)braket
comma
op_amp
id|drive_cmd_intr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * NULL is actually a valid way of waiting for&n;&t;&t; * all current requests to be flushed from the queue.&n;&t;&t; */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: DRIVE_CMD (null)&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|ide_end_drive_cmd
c_func
(paren
id|drive
comma
id|GET_STAT
c_func
(paren
)paren
comma
id|GET_ERR
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * do_request() initiates handling of a new I/O request&n; */
DECL|function|do_request
r_static
r_inline
r_void
id|do_request
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_int
r_int
id|minor
comma
id|unit
suffix:semicolon
r_int
r_int
id|block
comma
id|blockend
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s: do_request: current=0x%08lx&bslash;n&quot;
comma
id|hwif-&gt;name
comma
(paren
r_int
r_int
)paren
id|rq
)paren
suffix:semicolon
macro_line|#endif
id|minor
op_assign
id|MINOR
c_func
(paren
id|rq-&gt;rq_dev
)paren
suffix:semicolon
id|unit
op_assign
id|minor
op_rshift
id|PARTN_BITS
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|rq-&gt;rq_dev
)paren
op_ne
id|hwif-&gt;major
op_logical_or
id|unit
op_ge
id|MAX_DRIVES
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: bad device number: %s&bslash;n&quot;
comma
id|hwif-&gt;name
comma
id|kdevname
c_func
(paren
id|rq-&gt;rq_dev
)paren
)paren
suffix:semicolon
r_goto
id|kill_rq
suffix:semicolon
)brace
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|rq-&gt;bh
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|rq-&gt;bh
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: block not locked&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_goto
id|kill_rq
suffix:semicolon
)brace
macro_line|#endif
id|block
op_assign
id|rq-&gt;sector
suffix:semicolon
id|blockend
op_assign
id|block
op_plus
id|rq-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
(paren
id|blockend
OL
id|block
)paren
op_logical_or
(paren
id|blockend
OG
id|drive-&gt;part
(braket
id|minor
op_amp
id|PARTN_MASK
)braket
dot
id|nr_sects
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s%c: bad access: block=%ld, count=%ld&bslash;n&quot;
comma
id|drive-&gt;name
comma
(paren
id|minor
op_amp
id|PARTN_MASK
)paren
ques
c_cond
l_char|&squot;0&squot;
op_plus
(paren
id|minor
op_amp
id|PARTN_MASK
)paren
suffix:colon
l_char|&squot; &squot;
comma
id|block
comma
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
r_goto
id|kill_rq
suffix:semicolon
)brace
id|block
op_add_assign
id|drive-&gt;part
(braket
id|minor
op_amp
id|PARTN_MASK
)braket
dot
id|start_sect
op_plus
id|drive-&gt;sect0
suffix:semicolon
macro_line|#if FAKE_FDISK_FOR_EZDRIVE
r_if
c_cond
(paren
id|block
op_eq
l_int|0
op_logical_and
id|drive-&gt;remap_0_to_1
)paren
id|block
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* redirect MBR access to EZ-Drive partn table */
macro_line|#endif /* FAKE_FDISK_FOR_EZDRIVE */
(paren
(paren
id|ide_hwgroup_t
op_star
)paren
id|hwif-&gt;hwgroup
)paren
op_member_access_from_pointer
id|drive
op_assign
id|drive
suffix:semicolon
macro_line|#if (DISK_RECOVERY_TIME &gt; 0)
r_while
c_loop
(paren
(paren
id|read_timer
c_func
(paren
)paren
op_minus
id|hwif-&gt;last_time
)paren
OL
id|DISK_RECOVERY_TIME
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_IDETAPE
id|POLL_HWIF_TAPE_DRIVE
suffix:semicolon
multiline_comment|/* macro from ide-tape.h */
macro_line|#endif /* CONFIG_BLK_DEV_IDETAPE */
id|SELECT_DRIVE
c_func
(paren
id|hwif
comma
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
id|drive
comma
id|drive-&gt;ready_stat
comma
id|BUSY_STAT
op_or
id|DRQ_STAT
comma
id|WAIT_READY
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: drive not ready for command&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;special.all
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|IDE_DRIVE_CMD
)paren
(brace
id|execute_drive_cmd
c_func
(paren
id|drive
comma
id|rq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEATAPI
r_switch
c_cond
(paren
id|drive-&gt;media
)paren
(brace
r_case
id|ide_disk
suffix:colon
id|do_rw_disk
(paren
id|drive
comma
id|rq
comma
id|block
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_case
id|ide_cdrom
suffix:colon
id|ide_do_rw_cdrom
(paren
id|drive
comma
id|block
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDECD */
macro_line|#ifdef CONFIG_BLK_DEV_IDETAPE
r_case
id|ide_tape
suffix:colon
id|idetape_do_request
(paren
id|drive
comma
id|rq
comma
id|block
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDETAPE */
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: media type %d not supported&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;media
)paren
suffix:semicolon
r_goto
id|kill_rq
suffix:semicolon
)brace
macro_line|#else
id|do_rw_disk
(paren
id|drive
comma
id|rq
comma
id|block
)paren
suffix:semicolon
multiline_comment|/* simpler and faster */
r_return
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEATAPI */;
)brace
id|do_special
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
id|kill_rq
suffix:colon
id|ide_end_request
c_func
(paren
l_int|0
comma
id|hwif-&gt;hwgroup
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * The driver enables interrupts as much as possible.  In order to do this,&n; * (a) the device-interrupt is always masked before entry, and&n; * (b) the timeout-interrupt is always disabled before entry.&n; *&n; * If we enter here from, say irq14, and then start a new request for irq15,&n; * (possible with &quot;serialize&quot; option) then we cannot ensure that we exit&n; * before the irq15 hits us. So, we must be careful not to let this bother us.&n; *&n; * Interrupts are still masked (by default) whenever we are exchanging&n; * data/cmds with a drive, because some drives seem to have very poor&n; * tolerance for latency during I/O.  For devices which don&squot;t suffer from&n; * this problem (most don&squot;t), the unmask flag can be set using the &quot;hdparm&quot;&n; * utility, to permit other interrupts during data/cmd transfers.&n; */
DECL|function|ide_do_request
r_void
id|ide_do_request
(paren
id|ide_hwgroup_t
op_star
id|hwgroup
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* paranoia */
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_ne
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: EEeekk!! handler not NULL in ide_do_request()&bslash;n&quot;
comma
id|hwgroup-&gt;hwif-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_do
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|hwgroup-&gt;hwif
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq
op_assign
id|hwgroup-&gt;rq
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;sharing_irq
op_logical_and
id|hwgroup-&gt;drive
)paren
multiline_comment|/* set nIEN */
id|OUT_BYTE
c_func
(paren
id|hwgroup-&gt;drive-&gt;ctl
op_or
l_int|2
comma
id|hwif-&gt;ctl_port
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * hwgroup-&gt;next_hwif is different from hwgroup-&gt;hwif&n;&t;&t;&t; * only when a request is inserted using &quot;ide_next&quot;.&n;&t;&t;&t; * This saves wear and tear on IDE tapes.&n;&t;&t;&t; */
id|hwif
op_assign
id|hwgroup-&gt;next_hwif
suffix:semicolon
r_do
(brace
id|rq
op_assign
id|blk_dev
(braket
id|hwif-&gt;major
)braket
dot
id|current_request
suffix:semicolon
r_if
c_cond
(paren
id|rq
op_ne
l_int|NULL
op_logical_and
id|rq-&gt;rq_status
op_ne
id|RQ_INACTIVE
)paren
r_goto
id|got_rq
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|hwif
op_assign
id|hwif-&gt;next
)paren
op_ne
id|hwgroup-&gt;next_hwif
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* no work left for this hwgroup */
)brace
id|got_rq
suffix:colon
id|do_request
c_func
(paren
id|hwgroup-&gt;hwif
op_assign
id|hwgroup-&gt;next_hwif
op_assign
id|hwif
comma
id|hwgroup-&gt;rq
op_assign
id|rq
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|hwgroup-&gt;handler
op_eq
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * do_hwgroup_request() invokes ide_do_request() after first masking&n; * all possible interrupts for the current hwgroup.  This prevents race&n; * conditions in the event that an unexpected interrupt occurs while&n; * we are in the driver.&n; *&n; * Note that when an interrupt is used to reenter the driver, the first level&n; * handler will already have masked the irq that triggered, but any other ones&n; * for the hwgroup will still be unmasked.  The driver tries to be careful&n; * about such things.&n; */
DECL|function|do_hwgroup_request
r_static
r_void
id|do_hwgroup_request
(paren
id|ide_hwgroup_t
op_star
id|hwgroup
)paren
(brace
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_eq
l_int|NULL
)paren
(brace
id|ide_hwif_t
op_star
id|hgif
op_assign
id|hwgroup-&gt;hwif
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|hgif
suffix:semicolon
r_do
(brace
id|disable_irq
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|hwif
op_assign
id|hwif-&gt;next
)paren
op_ne
id|hgif
)paren
suffix:semicolon
id|ide_do_request
(paren
id|hwgroup
)paren
suffix:semicolon
r_do
(brace
id|enable_irq
c_func
(paren
id|hwif-&gt;irq
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|hwif
op_assign
id|hwif-&gt;next
)paren
op_ne
id|hgif
)paren
suffix:semicolon
)brace
)brace
DECL|function|do_ide0_request
r_static
r_void
id|do_ide0_request
(paren
r_void
)paren
multiline_comment|/* invoked with cli() */
(brace
id|do_hwgroup_request
(paren
id|ide_hwifs
(braket
l_int|0
)braket
dot
id|hwgroup
)paren
suffix:semicolon
)brace
macro_line|#if MAX_HWIFS &gt; 1
DECL|function|do_ide1_request
r_static
r_void
id|do_ide1_request
(paren
r_void
)paren
multiline_comment|/* invoked with cli() */
(brace
id|do_hwgroup_request
(paren
id|ide_hwifs
(braket
l_int|1
)braket
dot
id|hwgroup
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if MAX_HWIFS &gt; 2
DECL|function|do_ide2_request
r_static
r_void
id|do_ide2_request
(paren
r_void
)paren
multiline_comment|/* invoked with cli() */
(brace
id|do_hwgroup_request
(paren
id|ide_hwifs
(braket
l_int|2
)braket
dot
id|hwgroup
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#if MAX_HWIFS &gt; 3
DECL|function|do_ide3_request
r_static
r_void
id|do_ide3_request
(paren
r_void
)paren
multiline_comment|/* invoked with cli() */
(brace
id|do_hwgroup_request
(paren
id|ide_hwifs
(braket
l_int|3
)braket
dot
id|hwgroup
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|timer_expiry
r_static
r_void
id|timer_expiry
(paren
r_int
r_int
id|data
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
(paren
id|ide_hwgroup_t
op_star
)paren
id|data
suffix:semicolon
id|ide_drive_t
op_star
id|drive
op_assign
id|hwgroup-&gt;drive
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;poll_timeout
op_ne
l_int|0
)paren
(brace
multiline_comment|/* polling in progress? */
id|ide_handler_t
op_star
id|handler
op_assign
id|hwgroup-&gt;handler
suffix:semicolon
id|hwgroup-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
id|handler
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* not waiting for anything? */
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* drive must have responded just as the timer expired */
id|printk
c_func
(paren
l_string|&quot;%s: marginal timeout&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|hwgroup-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* abort the operation */
r_if
c_cond
(paren
id|hwgroup-&gt;hwif-&gt;dmaproc
)paren
(paren
r_void
)paren
id|hwgroup-&gt;hwif-&gt;dmaproc
(paren
id|ide_dma_abort
comma
id|drive
)paren
suffix:semicolon
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;irq timeout&quot;
comma
id|GET_STAT
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_eq
l_int|NULL
)paren
id|do_hwgroup_request
(paren
id|hwgroup
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * There&squot;s nothing really useful we can do with an unexpected interrupt,&n; * other than reading the status register (to clear it), and logging it.&n; * There should be no way that an irq can happen before we&squot;re ready for it,&n; * so we needn&squot;t worry much about losing an &quot;important&quot; interrupt here.&n; *&n; * On laptops (and &quot;green&quot; PCs), an unexpected interrupt occurs whenever the&n; * drive enters &quot;idle&quot;, &quot;standby&quot;, or &quot;sleep&quot; mode, so if the status looks&n; * &quot;good&quot;, we just ignore the interrupt completely.&n; *&n; * This routine assumes cli() is in effect when called.&n; *&n; * If an unexpected interrupt happens on irq15 while we are handling irq14&n; * and if the two interfaces are &quot;serialized&quot; (CMD640), then it looks like&n; * we could screw up by interfering with a new request being set up for irq15.&n; *&n; * In reality, this is a non-issue.  The new command is not sent unless the&n; * drive is ready to accept one, in which case we know the drive is not&n; * trying to interrupt us.  And ide_set_handler() is always invoked before&n; * completing the issuance of any new drive command, so we will not be&n; * accidently invoked as a result of any valid command completion interrupt.&n; *&n; */
DECL|function|unexpected_intr
r_static
r_void
id|unexpected_intr
(paren
r_int
id|irq
comma
id|ide_hwgroup_t
op_star
id|hwgroup
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_int
r_int
id|unit
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|hwgroup-&gt;hwif
suffix:semicolon
multiline_comment|/*&n;&t; * handle the unexpected interrupt&n;&t; */
r_do
(brace
r_if
c_cond
(paren
id|hwif-&gt;irq
op_eq
id|irq
)paren
(brace
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_continue
suffix:semicolon
id|SELECT_DRIVE
c_func
(paren
id|hwif
comma
id|drive
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Ugly, but wait_stat() may not be safe here */
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
id|drive-&gt;ready_stat
comma
id|BAD_STAT
)paren
)paren
(brace
multiline_comment|/* Try to not flood the console with msgs */
r_static
r_int
r_int
id|last_msgtime
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|last_msgtime
op_plus
(paren
id|HZ
op_div
l_int|2
)paren
)paren
OL
id|jiffies
)paren
(brace
id|last_msgtime
op_assign
id|jiffies
suffix:semicolon
(paren
r_void
)paren
id|ide_dump_status
c_func
(paren
id|drive
comma
l_string|&quot;unexpected_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
)paren
id|try_to_flush_leftover_data
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
(paren
id|hwif
op_assign
id|hwif-&gt;next
)paren
op_ne
id|hwgroup-&gt;hwif
)paren
suffix:semicolon
id|SELECT_DRIVE
c_func
(paren
id|hwif
comma
id|hwgroup-&gt;drive
)paren
suffix:semicolon
multiline_comment|/* Ugh.. probably interrupts current I/O */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
multiline_comment|/* Ugly, but wait_stat() may not be safe here */
)brace
multiline_comment|/*&n; * entry point for all interrupts, caller does cli() for us&n; */
DECL|function|ide_intr
r_void
id|ide_intr
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|dev_id
suffix:semicolon
id|ide_handler_t
op_star
id|handler
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_eq
id|hwgroup-&gt;hwif-&gt;irq
op_logical_and
(paren
id|handler
op_assign
id|hwgroup-&gt;handler
)paren
op_ne
l_int|NULL
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|hwgroup-&gt;drive
suffix:semicolon
id|hwgroup-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
(paren
id|hwgroup-&gt;timer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;unmask
)paren
id|sti
c_func
(paren
)paren
suffix:semicolon
id|handler
c_func
(paren
id|drive
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* this is necessary, as next rq may be different irq */
r_if
c_cond
(paren
id|hwgroup-&gt;handler
op_eq
l_int|NULL
)paren
(brace
id|SET_RECOVERY_TIMER
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
id|ide_do_request
c_func
(paren
id|hwgroup
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|unexpected_intr
c_func
(paren
id|irq
comma
id|hwgroup
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * get_info_ptr() returns the (ide_drive_t *) for a given device number.&n; * It returns NULL if the given device number does not match any present drives.&n; */
DECL|function|get_info_ptr
r_static
id|ide_drive_t
op_star
id|get_info_ptr
(paren
id|kdev_t
id|i_rdev
)paren
(brace
r_int
id|major
op_assign
id|MAJOR
c_func
(paren
id|i_rdev
)paren
suffix:semicolon
r_int
r_int
id|h
suffix:semicolon
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;present
op_logical_and
id|major
op_eq
id|hwif-&gt;major
)paren
(brace
r_int
id|unit
op_assign
id|DEVICE_NR
c_func
(paren
id|i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit
OL
id|MAX_DRIVES
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
)paren
r_return
id|drive
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|major
op_eq
id|IDE0_MAJOR
op_logical_and
id|unit
OL
l_int|4
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide: probable bad entry for /dev/hd%c&bslash;n&quot;
comma
l_char|&squot;a&squot;
op_plus
id|unit
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ide: to fix it, run:  /usr/src/linux/scripts/MAKEDEV.ide&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * This function is intended to be used prior to invoking ide_do_drive_cmd().&n; */
DECL|function|ide_init_drive_cmd
r_void
id|ide_init_drive_cmd
(paren
r_struct
id|request
op_star
id|rq
)paren
(brace
id|rq-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|rq-&gt;cmd
op_assign
id|IDE_DRIVE_CMD
suffix:semicolon
id|rq-&gt;sector
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;nr_sectors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;sem
op_assign
l_int|NULL
suffix:semicolon
id|rq-&gt;bh
op_assign
l_int|NULL
suffix:semicolon
id|rq-&gt;bhtail
op_assign
l_int|NULL
suffix:semicolon
id|rq-&gt;next
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if 0&t;/* these are done each time through ide_do_drive_cmd() */
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;rq_status
op_assign
id|RQ_ACTIVE
suffix:semicolon
id|rq-&gt;rq_dev
op_assign
ques
c_cond
ques
c_cond
ques
c_cond
ques
c_cond
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * This function issues a special IDE device request&n; * onto the request queue.&n; *&n; * If action is ide_wait, then then rq is queued at the end of&n; * the request queue, and the function sleeps until it has been&n; * processed.  This is for use when invoked from an ioctl handler.&n; *&n; * If action is ide_preempt, then the rq is queued at the head of&n; * the request queue, displacing the currently-being-processed&n; * request and this function returns immediately without waiting&n; * for the new rq to be completed.  This is VERY DANGEROUS, and is&n; * intended for careful use by the ATAPI tape/cdrom driver code.&n; *&n; * If action is ide_next, then the rq is queued immediately after&n; * the currently-being-processed-request (if any), and the function&n; * returns without waiting for the new rq to be completed.  As above,&n; * This is VERY DANGEROUS, and is intended for careful use by the&n; * ATAPI tape/cdrom driver code.&n; *&n; * If action is ide_end, then the rq is queued at the end of the&n; * request queue, and the function returns immediately without waiting&n; * for the new rq to be completed. This is again intended for careful&n; * use by the ATAPI tape/cdrom driver code. (Currently used by ide-tape.c,&n; * when operating in the pipelined operation mode).&n; */
DECL|function|ide_do_drive_cmd
r_int
id|ide_do_drive_cmd
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
id|ide_action_t
id|action
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|major
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
suffix:semicolon
r_struct
id|request
op_star
id|cur_rq
suffix:semicolon
r_struct
id|blk_dev_struct
op_star
id|bdev
op_assign
op_amp
id|blk_dev
(braket
id|major
)braket
suffix:semicolon
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
r_if
c_cond
(paren
id|IS_PROMISE_DRIVE
op_logical_and
id|rq-&gt;buffer
op_ne
l_int|NULL
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
multiline_comment|/* special drive cmds not supported */
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;rq_status
op_assign
id|RQ_ACTIVE
suffix:semicolon
id|rq-&gt;rq_dev
op_assign
id|MKDEV
c_func
(paren
id|major
comma
(paren
id|drive-&gt;select.b.unit
)paren
op_lshift
id|PARTN_BITS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|ide_wait
)paren
id|rq-&gt;sem
op_assign
op_amp
id|sem
suffix:semicolon
id|unplug_device
c_func
(paren
id|bdev
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|ide_next
)paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|next_hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|cur_rq
op_assign
id|bdev-&gt;current_request
suffix:semicolon
r_if
c_cond
(paren
id|cur_rq
op_eq
l_int|NULL
op_logical_or
id|action
op_eq
id|ide_preempt
)paren
(brace
id|rq-&gt;next
op_assign
id|cur_rq
suffix:semicolon
id|bdev-&gt;current_request
op_assign
id|rq
suffix:semicolon
r_if
c_cond
(paren
id|action
op_eq
id|ide_preempt
)paren
(brace
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* is this necessary (?) */
id|bdev
op_member_access_from_pointer
id|request_fn
c_func
(paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|action
op_eq
id|ide_wait
op_logical_or
id|action
op_eq
id|ide_end
)paren
(brace
r_while
c_loop
(paren
id|cur_rq-&gt;next
op_ne
l_int|NULL
)paren
multiline_comment|/* find end of list */
id|cur_rq
op_assign
id|cur_rq-&gt;next
suffix:semicolon
)brace
id|rq-&gt;next
op_assign
id|cur_rq-&gt;next
suffix:semicolon
id|cur_rq-&gt;next
op_assign
id|rq
suffix:semicolon
)brace
r_if
c_cond
(paren
id|action
op_eq
id|ide_wait
op_logical_and
id|rq-&gt;rq_status
op_ne
id|RQ_INACTIVE
)paren
id|down
c_func
(paren
op_amp
id|sem
)paren
suffix:semicolon
multiline_comment|/* wait for it to be serviced */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|rq-&gt;errors
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
multiline_comment|/* return -EIO if errors */
)brace
DECL|function|ide_open
r_static
r_int
id|ide_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|drive-&gt;busy
)paren
id|sleep_on
c_func
(paren
op_amp
id|drive-&gt;wqueue
)paren
suffix:semicolon
id|drive-&gt;usage
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_cdrom
)paren
r_return
id|ide_cdrom_open
(paren
id|inode
comma
id|filp
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
macro_line|#ifdef CONFIG_BLK_DEV_IDETAPE
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_tape
)paren
r_return
id|idetape_blkdev_open
(paren
id|inode
comma
id|filp
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDETAPE */
r_if
c_cond
(paren
id|drive-&gt;removable
op_logical_and
id|drive-&gt;usage
op_eq
l_int|1
)paren
(brace
id|byte
id|door_lock
(braket
)braket
op_assign
(brace
id|WIN_DOORLOCK
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_struct
id|request
id|rq
suffix:semicolon
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|ide_init_drive_cmd
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.buffer
op_assign
id|door_lock
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Ignore the return code from door_lock,&n;&t;&t; * since the open() has already succeeded,&n;&t;&t; * and the door_lock is irrelevant at this point.&n;&t;&t; */
(paren
r_void
)paren
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Releasing a block device means we sync() it, so that it can safely&n; * be forgotten about...&n; */
DECL|function|ide_release
r_static
r_void
id|ide_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|drive-&gt;usage
op_decrement
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_cdrom
)paren
(brace
id|ide_cdrom_release
(paren
id|inode
comma
id|file
comma
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
macro_line|#ifdef CONFIG_BLK_DEV_IDETAPE
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_tape
)paren
(brace
id|idetape_blkdev_release
(paren
id|inode
comma
id|file
comma
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDETAPE */
r_if
c_cond
(paren
id|drive-&gt;removable
op_logical_and
op_logical_neg
id|drive-&gt;usage
)paren
(brace
id|byte
id|door_unlock
(braket
)braket
op_assign
(brace
id|WIN_DOORUNLOCK
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_struct
id|request
id|rq
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|ide_init_drive_cmd
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.buffer
op_assign
id|door_unlock
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * This routine is called to flush all partitions and partition tables&n; * for a changed disk, and then re-read the new partition table.&n; * If we are revalidating a disk because of a media change, then we&n; * enter with usage == 0.  If we are using an ioctl, we automatically have&n; * usage == 1 (we need an open channel to use an ioctl :-), so this&n; * is our limit.&n; */
DECL|function|revalidate_disk
r_static
r_int
id|revalidate_disk
c_func
(paren
id|kdev_t
id|i_rdev
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_int
r_int
id|p
comma
id|major
comma
id|minor
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|i_rdev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|major
op_assign
id|MAJOR
c_func
(paren
id|i_rdev
)paren
suffix:semicolon
id|minor
op_assign
id|drive-&gt;select.b.unit
op_lshift
id|PARTN_BITS
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;busy
op_logical_or
(paren
id|drive-&gt;usage
OG
l_int|1
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
suffix:semicolon
id|drive-&gt;busy
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
l_int|0
suffix:semicolon
id|p
OL
(paren
l_int|1
op_lshift
id|PARTN_BITS
)paren
suffix:semicolon
op_increment
id|p
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;part
(braket
id|p
)braket
dot
id|nr_sects
OG
l_int|0
)paren
(brace
id|kdev_t
id|devp
op_assign
id|MKDEV
c_func
(paren
id|major
comma
id|minor
op_plus
id|p
)paren
suffix:semicolon
id|fsync_dev
(paren
id|devp
)paren
suffix:semicolon
id|invalidate_inodes
(paren
id|devp
)paren
suffix:semicolon
id|invalidate_buffers
(paren
id|devp
)paren
suffix:semicolon
)brace
id|drive-&gt;part
(braket
id|p
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;part
(braket
id|p
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
)brace
suffix:semicolon
id|drive-&gt;part
(braket
l_int|0
)braket
dot
id|nr_sects
op_assign
id|current_capacity
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
id|drive-&gt;part
(braket
l_int|0
)braket
dot
id|start_sect
op_assign
op_minus
l_int|1
suffix:semicolon
id|resetup_one_dev
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|gd
comma
id|drive-&gt;select.b.unit
)paren
suffix:semicolon
id|drive-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|drive-&gt;wqueue
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|write_fs_long
r_static
r_int
id|write_fs_long
(paren
r_int
r_int
id|useraddr
comma
r_int
id|value
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
r_int
op_star
)paren
id|useraddr
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|useraddr
comma
r_sizeof
(paren
r_int
)paren
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
id|put_user
c_func
(paren
(paren
r_int
)paren
id|value
comma
(paren
r_int
op_star
)paren
id|useraddr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_ioctl
r_static
r_int
id|ide_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
id|rq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_or
op_logical_neg
(paren
id|inode-&gt;i_rdev
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|ide_init_drive_cmd
(paren
op_amp
id|rq
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
(brace
r_struct
id|hd_geometry
op_star
id|loc
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|loc
op_logical_or
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|loc
comma
r_sizeof
(paren
op_star
id|loc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|put_user
c_func
(paren
id|drive-&gt;bios_head
comma
(paren
id|byte
op_star
)paren
op_amp
id|loc-&gt;heads
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|drive-&gt;bios_sect
comma
(paren
id|byte
op_star
)paren
op_amp
id|loc-&gt;sectors
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|drive-&gt;bios_cyl
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|loc-&gt;cylinders
)paren
suffix:semicolon
id|put_user
c_func
(paren
(paren
r_int
)paren
id|drive-&gt;part
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)braket
dot
id|start_sect
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|loc-&gt;start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|BLKFLSBUF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRASET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|arg
OG
l_int|0xff
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRAGET
suffix:colon
r_return
id|write_fs_long
c_func
(paren
id|arg
comma
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
)paren
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
multiline_comment|/* Return device size */
r_return
id|write_fs_long
c_func
(paren
id|arg
comma
id|drive-&gt;part
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)braket
dot
id|nr_sects
)paren
suffix:semicolon
r_case
id|BLKRRPART
suffix:colon
multiline_comment|/* Re-read partition tables */
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_return
id|revalidate_disk
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_case
id|HDIO_GET_KEEPSETTINGS
suffix:colon
r_return
id|write_fs_long
c_func
(paren
id|arg
comma
id|drive-&gt;keep_settings
)paren
suffix:semicolon
r_case
id|HDIO_GET_UNMASKINTR
suffix:colon
r_return
id|write_fs_long
c_func
(paren
id|arg
comma
id|drive-&gt;unmask
)paren
suffix:semicolon
r_case
id|HDIO_GET_DMA
suffix:colon
r_return
id|write_fs_long
c_func
(paren
id|arg
comma
id|drive-&gt;using_dma
)paren
suffix:semicolon
r_case
id|HDIO_GET_32BIT
suffix:colon
r_return
id|write_fs_long
c_func
(paren
id|arg
comma
id|drive-&gt;io_32bit
)paren
suffix:semicolon
r_case
id|HDIO_GET_MULTCOUNT
suffix:colon
r_return
id|write_fs_long
c_func
(paren
id|arg
comma
id|drive-&gt;mult_count
)paren
suffix:semicolon
r_case
id|HDIO_GET_IDENTITY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
op_logical_or
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMSG
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
op_star
id|drive-&gt;id
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|err
)paren
id|copy_to_user
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
(paren
r_char
op_star
)paren
id|drive-&gt;id
comma
r_sizeof
(paren
op_star
id|drive-&gt;id
)paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
r_case
id|HDIO_GET_NOWERR
suffix:colon
r_return
id|write_fs_long
c_func
(paren
id|arg
comma
id|drive-&gt;bad_wstat
op_eq
id|BAD_R_STAT
)paren
suffix:semicolon
r_case
id|HDIO_SET_DMA
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_cdrom
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDECD */
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;id
op_logical_or
op_logical_neg
(paren
id|drive-&gt;id-&gt;capability
op_amp
l_int|1
)paren
op_logical_or
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_case
id|HDIO_SET_KEEPSETTINGS
suffix:colon
r_case
id|HDIO_SET_UNMASKINTR
suffix:colon
r_case
id|HDIO_SET_NOWERR
suffix:colon
r_if
c_cond
(paren
id|arg
OG
l_int|1
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|HDIO_SET_32BIT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_SET_DMA
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|drive-&gt;using_dma
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDIO_SET_KEEPSETTINGS
suffix:colon
id|drive-&gt;keep_settings
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDIO_SET_UNMASKINTR
suffix:colon
r_if
c_cond
(paren
id|arg
op_logical_and
id|drive-&gt;no_unmask
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|drive-&gt;unmask
op_assign
id|arg
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDIO_SET_NOWERR
suffix:colon
id|drive-&gt;bad_wstat
op_assign
id|arg
ques
c_cond
id|BAD_R_STAT
suffix:colon
id|BAD_W_STAT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|HDIO_SET_32BIT
suffix:colon
r_if
c_cond
(paren
id|arg
OG
(paren
l_int|1
op_plus
(paren
id|SUPPORT_VLB_SYNC
op_lshift
l_int|1
)paren
)paren
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
op_logical_and
id|drive-&gt;no_io_32bit
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
id|drive-&gt;io_32bit
op_assign
id|arg
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_DTC2278
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|chipset
op_eq
id|ide_dtc2278
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|drives
(braket
op_logical_neg
id|drive-&gt;select.b.unit
)braket
dot
id|io_32bit
op_assign
id|arg
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_DTC2278 */
r_break
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|HDIO_SET_MULTCOUNT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
op_logical_and
id|arg
OG
id|drive-&gt;id-&gt;max_multsect
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;special.b.set_multmode
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|drive-&gt;mult_req
op_assign
id|arg
suffix:semicolon
id|drive-&gt;special.b.set_multmode
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
r_return
(paren
id|drive-&gt;mult_count
op_eq
id|arg
)paren
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
r_case
id|HDIO_DRIVE_CMD
suffix:colon
(brace
id|byte
id|args
(braket
l_int|4
)braket
comma
op_star
id|argbuf
op_assign
id|args
suffix:semicolon
r_int
id|argsize
op_assign
l_int|4
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
(paren
r_void
op_star
)paren
id|arg
)paren
(brace
id|err
op_assign
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
(paren
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|4
)paren
)paren
)paren
(brace
id|copy_from_user
c_func
(paren
id|args
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|args
(braket
l_int|3
)braket
)paren
(brace
id|argsize
op_assign
l_int|4
op_plus
(paren
id|SECTOR_WORDS
op_star
l_int|4
op_star
id|args
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|argbuf
op_assign
id|kmalloc
c_func
(paren
id|argsize
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|argbuf
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|argbuf
(braket
l_int|0
)braket
op_assign
id|args
(braket
l_int|0
)braket
suffix:semicolon
id|argbuf
(braket
l_int|1
)braket
op_assign
id|args
(braket
l_int|1
)braket
suffix:semicolon
id|argbuf
(braket
l_int|2
)braket
op_assign
id|args
(braket
l_int|2
)braket
suffix:semicolon
id|argbuf
(braket
l_int|3
)braket
op_assign
id|args
(braket
l_int|3
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|argsize
)paren
)paren
)paren
(brace
id|rq.buffer
op_assign
id|argbuf
suffix:semicolon
id|err
op_assign
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|argbuf
comma
id|argsize
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|argsize
OG
l_int|4
)paren
id|kfree
c_func
(paren
id|argbuf
)paren
suffix:semicolon
)brace
r_return
id|err
suffix:semicolon
)brace
r_case
id|HDIO_SET_PIO_MODE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
id|PARTN_MASK
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|tuneproc
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;special.b.set_tune
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|drive-&gt;tune_req
op_assign
(paren
id|byte
)paren
id|arg
suffix:semicolon
id|drive-&gt;special.b.set_tune
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|RO_IOCTLS
c_func
(paren
id|inode-&gt;i_rdev
comma
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
(brace
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_cdrom
)paren
r_return
id|ide_cdrom_ioctl
c_func
(paren
id|drive
comma
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDECD */
macro_line|#ifdef CONFIG_BLK_DEV_IDETAPE
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_tape
)paren
r_return
id|idetape_blkdev_ioctl
c_func
(paren
id|drive
comma
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDETAPE */
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
DECL|function|ide_check_media_change
r_static
r_int
id|ide_check_media_change
(paren
id|kdev_t
id|i_rdev
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|i_rdev
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_cdrom
)paren
r_return
id|ide_cdrom_check_media_change
(paren
id|drive
)paren
suffix:semicolon
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
r_if
c_cond
(paren
id|drive-&gt;removable
)paren
multiline_comment|/* for disks */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* always assume it was changed */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_fixstring
r_void
id|ide_fixstring
(paren
id|byte
op_star
id|s
comma
r_const
r_int
id|bytecount
comma
r_const
r_int
id|byteswap
)paren
(brace
id|byte
op_star
id|p
op_assign
id|s
comma
op_star
id|end
op_assign
op_amp
id|s
(braket
id|bytecount
op_amp
op_complement
l_int|1
)braket
suffix:semicolon
multiline_comment|/* bytecount must be even */
r_if
c_cond
(paren
id|byteswap
)paren
(brace
multiline_comment|/* convert from big-endian to host byte order */
r_for
c_loop
(paren
id|p
op_assign
id|end
suffix:semicolon
id|p
op_ne
id|s
suffix:semicolon
)paren
(brace
r_int
r_int
op_star
id|pp
op_assign
(paren
r_int
r_int
op_star
)paren
(paren
id|p
op_sub_assign
l_int|2
)paren
suffix:semicolon
op_star
id|pp
op_assign
id|ntohs
c_func
(paren
op_star
id|pp
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* strip leading blanks */
r_while
c_loop
(paren
id|s
op_ne
id|end
op_logical_and
op_star
id|s
op_eq
l_char|&squot; &squot;
)paren
op_increment
id|s
suffix:semicolon
multiline_comment|/* compress internal blanks and strip trailing blanks */
r_while
c_loop
(paren
id|s
op_ne
id|end
op_logical_and
op_star
id|s
)paren
(brace
r_if
c_cond
(paren
op_star
id|s
op_increment
op_ne
l_char|&squot; &squot;
op_logical_or
(paren
id|s
op_ne
id|end
op_logical_and
op_star
id|s
op_logical_and
op_star
id|s
op_ne
l_char|&squot; &squot;
)paren
)paren
op_star
id|p
op_increment
op_assign
op_star
(paren
id|s
op_minus
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* wipe out trailing garbage */
r_while
c_loop
(paren
id|p
op_ne
id|end
)paren
op_star
id|p
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
DECL|function|do_identify
r_static
r_inline
r_void
id|do_identify
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|cmd
)paren
(brace
r_int
id|bswap
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
suffix:semicolon
r_int
r_int
id|capacity
comma
id|check
suffix:semicolon
id|id
op_assign
id|drive-&gt;id
op_assign
id|kmalloc
(paren
id|SECTOR_WORDS
op_star
l_int|4
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|ide_input_data
c_func
(paren
id|drive
comma
id|id
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
multiline_comment|/* read 512 bytes of id info */
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * EATA SCSI controllers do a hardware ATA emulation:  ignore them&n;&t; */
r_if
c_cond
(paren
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;P&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;M&squot;
)paren
op_logical_or
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;S&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;K&squot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: EATA SCSI HBA %.10s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|id-&gt;model
)paren
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  WIN_IDENTIFY returns little-endian info,&n;&t; *  WIN_PIDENTIFY *usually* returns little-endian info.&n;&t; */
id|bswap
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|WIN_PIDENTIFY
)paren
(brace
r_if
c_cond
(paren
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;N&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;E&squot;
)paren
multiline_comment|/* NEC */
op_logical_or
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;F&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;X&squot;
)paren
multiline_comment|/* Mitsumi */
op_logical_or
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;P&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;i&squot;
)paren
)paren
multiline_comment|/* Pioneer */
id|bswap
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Vertos drives may still be weird */
)brace
id|ide_fixstring
(paren
id|id-&gt;model
comma
r_sizeof
(paren
id|id-&gt;model
)paren
comma
id|bswap
)paren
suffix:semicolon
id|ide_fixstring
(paren
id|id-&gt;fw_rev
comma
r_sizeof
(paren
id|id-&gt;fw_rev
)paren
comma
id|bswap
)paren
suffix:semicolon
id|ide_fixstring
(paren
id|id-&gt;serial_no
comma
r_sizeof
(paren
id|id-&gt;serial_no
)paren
comma
id|bswap
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEATAPI
multiline_comment|/*&n;&t; * Check for an ATAPI device&n;&t; */
r_if
c_cond
(paren
id|cmd
op_eq
id|WIN_PIDENTIFY
)paren
(brace
id|byte
id|type
op_assign
(paren
id|id-&gt;config
op_rshift
l_int|8
)paren
op_amp
l_int|0x1f
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s, ATAPI &quot;
comma
id|drive-&gt;name
comma
id|id-&gt;model
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_PROMISE
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|is_promise2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; -- not supported on 2nd Promise port&bslash;n&quot;
)paren
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_PROMISE */
r_switch
c_cond
(paren
id|type
)paren
(brace
r_case
l_int|0
suffix:colon
multiline_comment|/* Early cdrom models used zero */
r_case
l_int|5
suffix:colon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
id|printk
(paren
l_string|&quot;CDROM drive&bslash;n&quot;
)paren
suffix:semicolon
id|drive-&gt;media
op_assign
id|ide_cdrom
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;removable
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
macro_line|#else
id|printk
(paren
l_string|&quot;CDROM &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDECD */
r_case
l_int|1
suffix:colon
macro_line|#ifdef CONFIG_BLK_DEV_IDETAPE
id|printk
(paren
l_string|&quot;TAPE drive&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idetape_identify_device
(paren
id|drive
comma
id|id
)paren
)paren
(brace
id|drive-&gt;media
op_assign
id|ide_tape
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;removable
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;autotune
op_ne
l_int|2
op_logical_and
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_check
comma
id|drive
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;, DMA&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;nide-tape: the tape is not supported by this version of the driver&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
macro_line|#else
id|printk
(paren
l_string|&quot;TAPE &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDETAPE */
r_default
suffix:colon
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Type %d - Unknown device&bslash;n&quot;
comma
id|type
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;- not supported by this kernel&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEATAPI */
multiline_comment|/* check for removable disks (eg. SYQUEST), ignore &squot;WD&squot; drives */
r_if
c_cond
(paren
id|id-&gt;config
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
(brace
multiline_comment|/* removable disk ? */
r_if
c_cond
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_ne
l_char|&squot;W&squot;
op_logical_or
id|id-&gt;model
(braket
l_int|1
)braket
op_ne
l_char|&squot;D&squot;
)paren
id|drive-&gt;removable
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* SunDisk drives: treat as non-removable, force one unit */
r_if
c_cond
(paren
id|id-&gt;model
(braket
l_int|0
)braket
op_eq
l_char|&squot;S&squot;
op_logical_and
id|id-&gt;model
(braket
l_int|1
)braket
op_eq
l_char|&squot;u&squot;
)paren
(brace
id|drive-&gt;removable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;select.all
op_amp
(paren
l_int|1
op_lshift
l_int|4
)paren
)paren
(brace
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|drive-&gt;media
op_assign
id|ide_disk
suffix:semicolon
multiline_comment|/* Extract geometry if we did not already have one for the drive */
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
(brace
id|drive-&gt;present
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;cyl
op_assign
id|drive-&gt;bios_cyl
op_assign
id|id-&gt;cyls
suffix:semicolon
id|drive-&gt;head
op_assign
id|drive-&gt;bios_head
op_assign
id|id-&gt;heads
suffix:semicolon
id|drive-&gt;sect
op_assign
id|drive-&gt;bios_sect
op_assign
id|id-&gt;sectors
suffix:semicolon
)brace
multiline_comment|/* Handle logical geometry translation by the drive */
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|1
)paren
op_logical_and
id|id-&gt;cur_cyls
op_logical_and
id|id-&gt;cur_heads
op_logical_and
(paren
id|id-&gt;cur_heads
op_le
l_int|16
)paren
op_logical_and
id|id-&gt;cur_sectors
)paren
(brace
multiline_comment|/*&n;&t;&t; * Extract the physical drive geometry for our use.&n;&t;&t; * Note that we purposely do *not* update the bios info.&n;&t;&t; * This way, programs that use it (like fdisk) will&n;&t;&t; * still have the same logical view as the BIOS does,&n;&t;&t; * which keeps the partition table from being screwed.&n;&t;&t; *&n;&t;&t; * An exception to this is the cylinder count,&n;&t;&t; * which we reexamine later on to correct for 1024 limitations.&n;&t;&t; */
id|drive-&gt;cyl
op_assign
id|id-&gt;cur_cyls
suffix:semicolon
id|drive-&gt;head
op_assign
id|id-&gt;cur_heads
suffix:semicolon
id|drive-&gt;sect
op_assign
id|id-&gt;cur_sectors
suffix:semicolon
multiline_comment|/* check for word-swapped &quot;capacity&quot; field in id information */
id|capacity
op_assign
id|drive-&gt;cyl
op_star
id|drive-&gt;head
op_star
id|drive-&gt;sect
suffix:semicolon
id|check
op_assign
(paren
id|id-&gt;cur_capacity0
op_lshift
l_int|16
)paren
op_or
id|id-&gt;cur_capacity1
suffix:semicolon
r_if
c_cond
(paren
id|check
op_eq
id|capacity
)paren
(brace
multiline_comment|/* was it swapped? */
multiline_comment|/* yes, bring it into little-endian order: */
id|id-&gt;cur_capacity0
op_assign
(paren
id|capacity
op_rshift
l_int|0
)paren
op_amp
l_int|0xffff
suffix:semicolon
id|id-&gt;cur_capacity1
op_assign
(paren
id|capacity
op_rshift
l_int|16
)paren
op_amp
l_int|0xffff
suffix:semicolon
)brace
)brace
multiline_comment|/* Use physical geometry if what we have still makes no sense */
r_if
c_cond
(paren
(paren
op_logical_neg
id|drive-&gt;head
op_logical_or
id|drive-&gt;head
OG
l_int|16
)paren
op_logical_and
id|id-&gt;heads
op_logical_and
id|id-&gt;heads
op_le
l_int|16
)paren
(brace
id|drive-&gt;cyl
op_assign
id|id-&gt;cyls
suffix:semicolon
id|drive-&gt;head
op_assign
id|id-&gt;heads
suffix:semicolon
id|drive-&gt;sect
op_assign
id|id-&gt;sectors
suffix:semicolon
)brace
multiline_comment|/* Correct the number of cyls if the bios value is too small */
r_if
c_cond
(paren
id|drive-&gt;sect
op_eq
id|drive-&gt;bios_sect
op_logical_and
id|drive-&gt;head
op_eq
id|drive-&gt;bios_head
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;cyl
OG
id|drive-&gt;bios_cyl
)paren
id|drive-&gt;bios_cyl
op_assign
id|drive-&gt;cyl
suffix:semicolon
)brace
(paren
r_void
)paren
id|current_capacity
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* initialize LBA selection */
id|printk
(paren
l_string|&quot;%s: %.40s, %ldMB w/%dkB Cache, %sCHS=%d/%d/%d&quot;
comma
id|drive-&gt;name
comma
id|id-&gt;model
comma
id|current_capacity
c_func
(paren
id|drive
)paren
op_div
l_int|2048L
comma
id|id-&gt;buf_size
op_div
l_int|2
comma
id|drive-&gt;select.b.lba
ques
c_cond
l_string|&quot;LBA, &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|drive-&gt;bios_cyl
comma
id|drive-&gt;bios_head
comma
id|drive-&gt;bios_sect
)paren
suffix:semicolon
id|drive-&gt;mult_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;max_multsect
)paren
(brace
id|drive-&gt;mult_req
op_assign
id|INITIAL_MULT_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;mult_req
OG
id|id-&gt;max_multsect
)paren
id|drive-&gt;mult_req
op_assign
id|id-&gt;max_multsect
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;mult_req
op_logical_or
(paren
(paren
id|id-&gt;multsect_valid
op_amp
l_int|1
)paren
op_logical_and
id|id-&gt;multsect
)paren
)paren
id|drive-&gt;special.b.set_multmode
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive-&gt;autotune
op_ne
l_int|2
op_logical_and
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_check
comma
id|drive
)paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;, DMA&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Delay for *at least* 50ms.  As we don&squot;t know how much time is left&n; * until the next tick occurs, we wait an extra tick to be safe.&n; * This is used only during the probing/polling for drives at boot time.&n; */
DECL|function|delay_50ms
r_static
r_void
id|delay_50ms
(paren
r_void
)paren
(brace
r_int
r_int
id|timer
op_assign
id|jiffies
op_plus
(paren
(paren
id|HZ
op_plus
l_int|19
)paren
op_div
l_int|20
)paren
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|timer
OG
id|jiffies
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * try_to_identify() sends an ATA(PI) IDENTIFY request to a drive&n; * and waits for a response.  It also monitors irqs while this is&n; * happening, in hope of automatically determining which one is&n; * being used by the interface.&n; *&n; * Returns:&t;0  device was identified&n; *&t;&t;1  device timed-out (no response to identify request)&n; *&t;&t;2  device aborted the command (refused to identify itself)&n; */
DECL|function|try_to_identify
r_static
r_int
id|try_to_identify
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|cmd
)paren
(brace
r_int
id|hd_status
comma
id|rc
suffix:semicolon
r_int
r_int
id|timeout
suffix:semicolon
r_int
id|irqs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|irq
)paren
(brace
multiline_comment|/* already got an IRQ? */
id|probe_irq_off
c_func
(paren
id|probe_irq_on
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* clear dangling irqs */
id|irqs
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* start monitoring irqs */
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* enable device irq */
)brace
id|delay_50ms
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* take a deep breath */
r_if
c_cond
(paren
(paren
id|IN_BYTE
c_func
(paren
id|IDE_ALTSTATUS_REG
)paren
op_xor
id|IN_BYTE
c_func
(paren
id|IDE_STATUS_REG
)paren
)paren
op_amp
op_complement
id|INDEX_STAT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: probing with STATUS instead of ALTSTATUS&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|hd_status
op_assign
id|IDE_STATUS_REG
suffix:semicolon
multiline_comment|/* ancient Seagate drives */
)brace
r_else
id|hd_status
op_assign
id|IDE_ALTSTATUS_REG
suffix:semicolon
multiline_comment|/* use non-intrusive polling */
macro_line|#if CONFIG_BLK_DEV_PROMISE
r_if
c_cond
(paren
id|IS_PROMISE_DRIVE
)paren
(brace
r_if
c_cond
(paren
id|promise_cmd
c_func
(paren
id|drive
comma
id|PROMISE_IDENTIFY
)paren
)paren
(brace
r_if
c_cond
(paren
id|irqs
)paren
(paren
r_void
)paren
id|probe_irq_off
c_func
(paren
id|irqs
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
macro_line|#endif /* CONFIG_BLK_DEV_PROMISE */
id|OUT_BYTE
c_func
(paren
id|cmd
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* ask drive for ID */
id|timeout
op_assign
(paren
(paren
id|cmd
op_eq
id|WIN_IDENTIFY
)paren
ques
c_cond
id|WAIT_WORSTCASE
suffix:colon
id|WAIT_PIDENTIFY
)paren
op_div
l_int|2
suffix:semicolon
id|timeout
op_add_assign
id|jiffies
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|jiffies
OG
id|timeout
)paren
(brace
r_if
c_cond
(paren
id|irqs
)paren
(paren
r_void
)paren
id|probe_irq_off
c_func
(paren
id|irqs
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* drive timed-out */
)brace
id|delay_50ms
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* give drive a breather */
)brace
r_while
c_loop
(paren
id|IN_BYTE
c_func
(paren
id|hd_status
)paren
op_amp
id|BUSY_STAT
)paren
suffix:semicolon
id|delay_50ms
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for IRQ and DRQ_STAT */
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|GET_STAT
c_func
(paren
)paren
comma
id|DRQ_STAT
comma
id|BAD_R_STAT
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* some systems need this */
id|do_identify
c_func
(paren
id|drive
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* drive returned ID */
id|rc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* drive responded with ID */
(paren
r_void
)paren
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* clear drive IRQ */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_else
id|rc
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* drive refused ID */
r_if
c_cond
(paren
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|irq
)paren
(brace
id|irqs
op_assign
id|probe_irq_off
c_func
(paren
id|irqs
)paren
suffix:semicolon
multiline_comment|/* get our irq number */
r_if
c_cond
(paren
id|irqs
OG
l_int|0
)paren
(brace
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|irq
op_assign
id|irqs
suffix:semicolon
multiline_comment|/* save it for later */
id|irqs
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|drive-&gt;ctl
op_or
l_int|2
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
multiline_comment|/* mask device irq */
id|udelay
c_func
(paren
l_int|5
)paren
suffix:semicolon
(paren
r_void
)paren
id|probe_irq_off
c_func
(paren
id|irqs
)paren
suffix:semicolon
(paren
r_void
)paren
id|probe_irq_off
c_func
(paren
id|probe_irq_on
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* clear self-inflicted irq */
(paren
r_void
)paren
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* clear drive IRQ */
)brace
r_else
(brace
multiline_comment|/* Mmmm.. multiple IRQs.. don&squot;t know which was ours */
id|printk
c_func
(paren
l_string|&quot;%s: IRQ probe failed (%d)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|irqs
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_CMD640
macro_line|#ifdef CMD640_DUMP_REGS
r_if
c_cond
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|chipset
op_eq
id|ide_cmd640
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Hmmm.. probably a driver problem.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|CMD640_DUMP_REGS
suffix:semicolon
)brace
macro_line|#endif /* CMD640_DUMP_REGS */
macro_line|#endif /* CONFIG_BLK_DEV_CMD640 */
)brace
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * do_probe() has the difficult job of finding a drive if it exists,&n; * without getting hung up if it doesn&squot;t exist, without trampling on&n; * ethernet cards, and without leaving any IRQs dangling to haunt us later.&n; *&n; * If a drive is &quot;known&quot; to exist (from CMOS or kernel parameters),&n; * but does not respond right away, the probe will &quot;hang in there&quot;&n; * for the maximum wait time (about 30 seconds), otherwise it will&n; * exit much more quickly.&n; *&n; * Returns:&t;0  device was identified&n; *&t;&t;1  device timed-out (no response to identify request)&n; *&t;&t;2  device aborted the command (refused to identify itself)&n; *&t;&t;3  bad status from device (possible for ATAPI drives)&n; *&t;&t;4  probe was not attempted because failure was obvious&n; */
DECL|function|do_probe
r_static
r_int
id|do_probe
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|cmd
)paren
(brace
r_int
id|rc
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEATAPI
r_if
c_cond
(paren
id|drive-&gt;present
)paren
(brace
multiline_comment|/* avoid waiting for inappropriate probes */
r_if
c_cond
(paren
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
op_logical_and
(paren
id|cmd
op_eq
id|WIN_IDENTIFY
)paren
)paren
r_return
l_int|4
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDEATAPI */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;probing for %s: present=%d, media=%d, probetype=%s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;present
comma
id|drive-&gt;media
comma
(paren
id|cmd
op_eq
id|WIN_IDENTIFY
)paren
ques
c_cond
l_string|&quot;ATA&quot;
suffix:colon
l_string|&quot;ATAPI&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SELECT_DRIVE
c_func
(paren
id|hwif
comma
id|drive
)paren
suffix:semicolon
id|delay_50ms
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
op_ne
id|drive-&gt;select.all
op_logical_and
op_logical_neg
id|drive-&gt;present
)paren
(brace
id|OUT_BYTE
c_func
(paren
l_int|0xa0
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
multiline_comment|/* exit with drive0 selected */
id|delay_50ms
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* allow BUSY_STAT to assert &amp; clear */
r_return
l_int|3
suffix:semicolon
multiline_comment|/* no i/f present: avoid killing ethernet cards */
)brace
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|GET_STAT
c_func
(paren
)paren
comma
id|READY_STAT
comma
id|BUSY_STAT
)paren
op_logical_or
id|drive-&gt;present
op_logical_or
id|cmd
op_eq
id|WIN_PIDENTIFY
)paren
(brace
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|try_to_identify
c_func
(paren
id|drive
comma
id|cmd
)paren
)paren
)paren
multiline_comment|/* send cmd and wait */
id|rc
op_assign
id|try_to_identify
c_func
(paren
id|drive
comma
id|cmd
)paren
suffix:semicolon
multiline_comment|/* failed: try again */
r_if
c_cond
(paren
id|rc
op_eq
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;%s: no response (status = 0x%02x)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|GET_STAT
c_func
(paren
)paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ensure drive irq is clear */
)brace
r_else
(brace
id|rc
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* not present or maybe ATAPI */
)brace
r_if
c_cond
(paren
id|drive-&gt;select.b.unit
op_ne
l_int|0
)paren
(brace
id|OUT_BYTE
c_func
(paren
l_int|0xa0
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
multiline_comment|/* exit with drive0 selected */
id|delay_50ms
c_func
(paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* ensure drive irq is clear */
)brace
r_return
id|rc
suffix:semicolon
)brace
multiline_comment|/*&n; * probe_for_drive() tests for existence of a given drive using do_probe().&n; *&n; * Returns:&t;0  no device was found&n; *&t;&t;1  device was found (note: drive-&gt;present might still be 0)&n; */
DECL|function|probe_for_drive
r_static
r_inline
id|byte
id|probe_for_drive
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;noprobe
)paren
multiline_comment|/* skip probing? */
r_return
id|drive-&gt;present
suffix:semicolon
r_if
c_cond
(paren
id|do_probe
c_func
(paren
id|drive
comma
id|WIN_IDENTIFY
)paren
op_ge
l_int|2
)paren
(brace
multiline_comment|/* if !(success||timed-out) */
macro_line|#ifdef CONFIG_BLK_DEV_IDEATAPI
(paren
r_void
)paren
id|do_probe
c_func
(paren
id|drive
comma
id|WIN_PIDENTIFY
)paren
suffix:semicolon
multiline_comment|/* look for ATAPI device */
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDEATAPI */
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;present
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* drive not found */
r_if
c_cond
(paren
id|drive-&gt;id
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* identification failed? */
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
(brace
id|printk
(paren
l_string|&quot;%s: non-IDE drive, CHS=%d/%d/%d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;cyl
comma
id|drive-&gt;head
comma
id|drive-&gt;sect
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_else
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_cdrom
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: ATAPI cdrom (?)&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
macro_line|#endif&t;/* CONFIG_BLK_DEV_IDECD */
r_else
(brace
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* nuke it */
)brace
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* drive was found */
)brace
multiline_comment|/*&n; * We query CMOS about hard disks : it could be that we have a SCSI/ESDI/etc&n; * controller that is BIOS compatible with ST-506, and thus showing up in our&n; * BIOS table, but not register compatible, and therefore not present in CMOS.&n; *&n; * Furthermore, we will assume that our ST-506 drives &lt;if any&gt; are the primary&n; * drives in the system -- the ones reflected as drive 1 or 2.  The first&n; * drive is stored in the high nibble of CMOS byte 0x12, the second in the low&n; * nibble.  This will be either a 4 bit drive type or 0xf indicating use byte&n; * 0x19 for an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.  A non-zero value&n; * means we have an AT controller hard disk for that drive.&n; *&n; * Of course, there is no guarantee that either drive is actually on the&n; * &quot;primary&quot; IDE interface, but we don&squot;t bother trying to sort that out here.&n; * If a drive is not actually on the primary interface, then these parameters&n; * will be ignored.  This results in the user having to supply the logical&n; * drive geometry as a boot parameter for each drive not on the primary i/f.&n; *&n; * The only &quot;perfect&quot; way to handle this would be to modify the setup.[cS] code&n; * to do BIOS calls Int13h/Fn08h and Int13h/Fn48h to get all of the drive info&n; * for us during initialization.  I have the necessary docs -- any takers?  -ml&n; */
DECL|function|probe_cmos_for_drives
r_static
r_void
id|probe_cmos_for_drives
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
macro_line|#ifdef __i386__
r_extern
r_struct
id|drive_info_struct
id|drive_info
suffix:semicolon
id|byte
id|cmos_disks
comma
op_star
id|BIOS
op_assign
(paren
id|byte
op_star
)paren
op_amp
id|drive_info
suffix:semicolon
r_int
id|unit
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_PROMISE
r_if
c_cond
(paren
id|hwif-&gt;is_promise2
)paren
r_return
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_PROMISE */
id|outb_p
c_func
(paren
l_int|0x12
comma
l_int|0x70
)paren
suffix:semicolon
multiline_comment|/* specify CMOS address 0x12 */
id|cmos_disks
op_assign
id|inb_p
c_func
(paren
l_int|0x71
)paren
suffix:semicolon
multiline_comment|/* read the data from 0x12 */
multiline_comment|/* Extract drive geometry from CMOS+BIOS if not already setup */
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmos_disks
op_amp
(paren
l_int|0xf0
op_rshift
(paren
id|unit
op_star
l_int|4
)paren
)paren
)paren
op_logical_and
op_logical_neg
id|drive-&gt;present
op_logical_and
op_logical_neg
id|drive-&gt;nobios
)paren
(brace
id|drive-&gt;cyl
op_assign
id|drive-&gt;bios_cyl
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|BIOS
suffix:semicolon
id|drive-&gt;head
op_assign
id|drive-&gt;bios_head
op_assign
op_star
(paren
id|BIOS
op_plus
l_int|2
)paren
suffix:semicolon
id|drive-&gt;sect
op_assign
id|drive-&gt;bios_sect
op_assign
op_star
(paren
id|BIOS
op_plus
l_int|14
)paren
suffix:semicolon
id|drive-&gt;ctl
op_assign
op_star
(paren
id|BIOS
op_plus
l_int|8
)paren
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|1
suffix:semicolon
)brace
id|BIOS
op_add_assign
l_int|16
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * This routine only knows how to look for drive units 0 and 1&n; * on an interface, so any setting of MAX_DRIVES &gt; 2 won&squot;t work here.&n; */
DECL|function|probe_hwif
r_static
r_void
id|probe_hwif
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_int
r_int
id|unit
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;noprobe
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_base
op_eq
id|HD_DATA
)paren
id|probe_cmos_for_drives
(paren
id|hwif
)paren
suffix:semicolon
macro_line|#if CONFIG_BLK_DEV_PROMISE
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;is_promise2
op_logical_and
(paren
id|check_region
c_func
(paren
id|hwif-&gt;io_base
comma
l_int|8
)paren
op_logical_or
id|check_region
c_func
(paren
id|hwif-&gt;ctl_port
comma
l_int|1
)paren
)paren
)paren
(brace
macro_line|#else
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|hwif-&gt;io_base
comma
l_int|8
)paren
op_logical_or
id|check_region
c_func
(paren
id|hwif-&gt;ctl_port
comma
l_int|1
)paren
)paren
(brace
macro_line|#endif /* CONFIG_BLK_DEV_PROMISE */
r_int
id|msgout
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
)paren
(brace
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: ERROR, PORTS ALREADY IN USE&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|msgout
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|msgout
)paren
id|printk
c_func
(paren
l_string|&quot;%s: ports already in use, skipping probe&bslash;n&quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* needed for jiffies and irq probing */
multiline_comment|/*&n;&t;&t; * Second drive should only exist if first drive was found,&n;&t;&t; * but a lot of cdrom drives are configured as single slaves.&n;&t;&t; */
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
(paren
r_void
)paren
id|probe_for_drive
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
op_logical_and
id|drive-&gt;media
op_eq
id|ide_disk
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|drive-&gt;head
op_logical_or
id|drive-&gt;head
OG
l_int|16
)paren
op_logical_and
op_logical_neg
id|drive-&gt;select.b.lba
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: INVALID GEOMETRY: %d PHYSICAL HEADS?&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|drive-&gt;head
)paren
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|drive-&gt;present
op_logical_and
op_logical_neg
id|hwif-&gt;present
)paren
(brace
id|hwif-&gt;present
op_assign
l_int|1
suffix:semicolon
id|request_region
c_func
(paren
id|hwif-&gt;io_base
comma
l_int|8
comma
id|hwif-&gt;name
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|hwif-&gt;ctl_port
comma
l_int|1
comma
id|hwif-&gt;name
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|MAX_DRIVES
suffix:semicolon
op_increment
id|unit
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;present
op_logical_and
id|drive-&gt;media
op_ne
id|ide_tape
)paren
(brace
id|ide_tuneproc_t
op_star
id|tuneproc
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|tuneproc
suffix:semicolon
r_if
c_cond
(paren
id|tuneproc
op_ne
l_int|NULL
op_logical_and
id|drive-&gt;autotune
op_eq
l_int|1
)paren
id|tuneproc
c_func
(paren
id|drive
comma
l_int|255
)paren
suffix:semicolon
multiline_comment|/* auto-tune PIO mode */
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * stridx() returns the offset of c within s,&n; * or -1 if c is &squot;&bslash;0&squot; or not found within s.&n; */
DECL|function|stridx
r_static
r_int
id|stridx
(paren
r_const
r_char
op_star
id|s
comma
r_char
id|c
)paren
(brace
r_char
op_star
id|i
op_assign
id|strchr
c_func
(paren
id|s
comma
id|c
)paren
suffix:semicolon
r_return
(paren
id|i
op_logical_and
id|c
)paren
ques
c_cond
id|i
op_minus
id|s
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * match_parm() does parsing for ide_setup():&n; *&n; * 1. the first char of s must be &squot;=&squot;.&n; * 2. if the remainder matches one of the supplied keywords,&n; *     the index (1 based) of the keyword is negated and returned.&n; * 3. if the remainder is a series of no more than max_vals numbers&n; *     separated by commas, the numbers are saved in vals[] and a&n; *     count of how many were saved is returned.  Base10 is assumed,&n; *     and base16 is allowed when prefixed with &quot;0x&quot;.&n; * 4. otherwise, zero is returned.&n; */
DECL|function|match_parm
r_static
r_int
id|match_parm
(paren
r_char
op_star
id|s
comma
r_const
r_char
op_star
id|keywords
(braket
)braket
comma
r_int
id|vals
(braket
)braket
comma
r_int
id|max_vals
)paren
(brace
r_static
r_const
r_char
op_star
id|decimal
op_assign
l_string|&quot;0123456789&quot;
suffix:semicolon
r_static
r_const
r_char
op_star
id|hex
op_assign
l_string|&quot;0123456789abcdef&quot;
suffix:semicolon
r_int
id|i
comma
id|n
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_increment
op_eq
l_char|&squot;=&squot;
)paren
(brace
multiline_comment|/*&n;&t;&t; * Try matching against the supplied keywords,&n;&t;&t; * and return -(index+1) if we match one&n;&t;&t; */
r_if
c_cond
(paren
id|keywords
op_ne
l_int|NULL
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
op_star
id|keywords
op_ne
l_int|NULL
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
op_star
id|keywords
op_increment
)paren
)paren
r_return
op_minus
(paren
id|i
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Look for a series of no more than &quot;max_vals&quot;&n;&t;&t; * numeric values separated by commas, in base10,&n;&t;&t; * or base16 when prefixed with &quot;0x&quot;.&n;&t;&t; * Return a count of how many were found.&n;&t;&t; */
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
(paren
id|i
op_assign
id|stridx
c_func
(paren
id|decimal
comma
op_star
id|s
)paren
)paren
op_ge
l_int|0
suffix:semicolon
)paren
(brace
id|vals
(braket
id|n
)braket
op_assign
id|i
suffix:semicolon
r_while
c_loop
(paren
(paren
id|i
op_assign
id|stridx
c_func
(paren
id|decimal
comma
op_star
op_increment
id|s
)paren
)paren
op_ge
l_int|0
)paren
id|vals
(braket
id|n
)braket
op_assign
(paren
id|vals
(braket
id|n
)braket
op_star
l_int|10
)paren
op_plus
id|i
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;x&squot;
op_logical_and
op_logical_neg
id|vals
(braket
id|n
)braket
)paren
(brace
r_while
c_loop
(paren
(paren
id|i
op_assign
id|stridx
c_func
(paren
id|hex
comma
op_star
op_increment
id|s
)paren
)paren
op_ge
l_int|0
)paren
id|vals
(braket
id|n
)braket
op_assign
(paren
id|vals
(braket
id|n
)braket
op_star
l_int|0x10
)paren
op_plus
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|n
op_eq
id|max_vals
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot;,&squot;
)paren
op_increment
id|s
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|s
)paren
r_return
id|n
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* zero = nothing matched */
)brace
multiline_comment|/*&n; * ide_setup() gets called VERY EARLY during initialization,&n; * to handle kernel &quot;command line&quot; strings beginning with &quot;hdx=&quot;&n; * or &quot;ide&quot;.  Here is the complete set currently supported:&n; *&n; * &quot;hdx=&quot;  is recognized for all &quot;x&quot; from &quot;a&quot; to &quot;h&quot;, such as &quot;hdc&quot;.&n; * &quot;idex=&quot; is recognized for all &quot;x&quot; from &quot;0&quot; to &quot;3&quot;, such as &quot;ide1&quot;.&n; *&n; * &quot;hdx=noprobe&quot;&t;: drive may be present, but do not probe for it&n; * &quot;hdx=none&quot;&t;&t;: drive is NOT present, ignore cmos and do not probe&n; * &quot;hdx=nowerr&quot;&t;&t;: ignore the WRERR_STAT bit on this drive&n; * &quot;hdx=cdrom&quot;&t;&t;: drive is present, and is a cdrom drive&n; * &quot;hdx=cyl,head,sect&quot;&t;: disk drive is present, with specified geometry&n; * &quot;hdx=autotune&quot;&t;: driver will attempt to tune interface speed&n; *&t;&t;&t;&t;to the fastest PIO mode supported,&n; *&t;&t;&t;&t;if possible for this drive only.&n; *&t;&t;&t;&t;Not fully supported by all chipset types,&n; *&t;&t;&t;&t;and quite likely to cause trouble with&n; *&t;&t;&t;&t;older/odd IDE drives.&n; *&n; * &quot;idebus=xx&quot;&t;&t;: inform IDE driver of VESA/PCI bus speed in Mhz,&n; *&t;&t;&t;&t;where &quot;xx&quot; is between 20 and 66 inclusive,&n; *&t;&t;&t;&t;used when tuning chipset PIO modes.&n; *&t;&t;&t;&t;For PCI bus, 25 is correct for a P75 system,&n; *&t;&t;&t;&t;30 is correct for P90,P120,P180 systems,&n; *&t;&t;&t;&t;and 33 is used for P100,P133,P166 systems.&n; *&t;&t;&t;&t;If in doubt, use idebus=33 for PCI.&n; *&t;&t;&t;&t;As for VLB, it is safest to not specify it.&n; *&n; * &quot;idex=noprobe&quot;&t;: do not attempt to access/use this interface&n; * &quot;idex=base&quot;&t;&t;: probe for an interface at the addr specified,&n; *&t;&t;&t;&t;where &quot;base&quot; is usually 0x1f0 or 0x170&n; *&t;&t;&t;&t;and &quot;ctl&quot; is assumed to be &quot;base&quot;+0x206&n; * &quot;idex=base,ctl&quot;&t;: specify both base and ctl&n; * &quot;idex=base,ctl,irq&quot;&t;: specify base, ctl, and irq number&n; * &quot;idex=autotune&quot;&t;: driver will attempt to tune interface speed&n; *&t;&t;&t;&t;to the fastest PIO mode supported,&n; *&t;&t;&t;&t;for all drives on this interface.&n; *&t;&t;&t;&t;Not fully supported by all chipset types,&n; *&t;&t;&t;&t;and quite likely to cause trouble with&n; *&t;&t;&t;&t;older/odd IDE drives.&n; * &quot;idex=noautotune&quot;&t;: driver will NOT attempt to tune interface speed&n; *&t;&t;&t;&t;This is the default for most chipsets,&n; *&t;&t;&t;&t;except the cmd640.&n; * &quot;idex=serialize&quot;&t;: do not overlap operations on idex and ide(x^1)&n; *&n; * The following are valid ONLY on ide0,&n; * and the defaults for the base,ctl ports must not be altered.&n; *&n; * &quot;ide0=dtc2278&quot;&t;: probe/support DTC2278 interface&n; * &quot;ide0=ht6560b&quot;&t;: probe/support HT6560B interface&n; * &quot;ide0=cmd640_vlb&quot;&t;: *REQUIRED* for VLB cards with the CMD640 chip&n; *&t;&t;&t;  (not for PCI -- automatically detected)&n; * &quot;ide0=qd6580&quot;&t;: probe/support qd6580 interface&n; * &quot;ide0=ali14xx&quot;&t;: probe/support ali14xx chipsets (ALI M1439, M1443, M1445)&n; * &quot;ide0=umc8672&quot;&t;: probe/support umc8672 chipsets&n; */
DECL|function|ide_setup
r_void
id|ide_setup
(paren
r_char
op_star
id|s
)paren
(brace
r_int
id|i
comma
id|vals
(braket
l_int|3
)braket
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_int
r_int
id|hw
comma
id|unit
suffix:semicolon
r_const
r_char
id|max_drive
op_assign
l_char|&squot;a&squot;
op_plus
(paren
(paren
id|MAX_HWIFS
op_star
id|MAX_DRIVES
)paren
op_minus
l_int|1
)paren
suffix:semicolon
r_const
r_char
id|max_hwif
op_assign
l_char|&squot;0&squot;
op_plus
(paren
id|MAX_HWIFS
op_minus
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ide_setup: %s&quot;
comma
id|s
)paren
suffix:semicolon
id|init_ide_data
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Look for drive options:  &quot;hdx=&quot;&n;&t; */
r_if
c_cond
(paren
id|s
(braket
l_int|0
)braket
op_eq
l_char|&squot;h&squot;
op_logical_and
id|s
(braket
l_int|1
)braket
op_eq
l_char|&squot;d&squot;
op_logical_and
id|s
(braket
l_int|2
)braket
op_ge
l_char|&squot;a&squot;
op_logical_and
id|s
(braket
l_int|2
)braket
op_le
id|max_drive
)paren
(brace
r_const
r_char
op_star
id|hd_words
(braket
)braket
op_assign
(brace
l_string|&quot;none&quot;
comma
l_string|&quot;noprobe&quot;
comma
l_string|&quot;nowerr&quot;
comma
l_string|&quot;cdrom&quot;
comma
l_string|&quot;serialize&quot;
comma
l_string|&quot;autotune&quot;
comma
l_string|&quot;noautotune&quot;
comma
l_string|&quot;slow&quot;
comma
l_int|NULL
)brace
suffix:semicolon
id|unit
op_assign
id|s
(braket
l_int|2
)braket
op_minus
l_char|&squot;a&squot;
suffix:semicolon
id|hw
op_assign
id|unit
op_div
id|MAX_DRIVES
suffix:semicolon
id|unit
op_assign
id|unit
op_mod
id|MAX_DRIVES
suffix:semicolon
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|hw
)braket
suffix:semicolon
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|unit
)braket
suffix:semicolon
r_switch
c_cond
(paren
id|match_parm
c_func
(paren
op_amp
id|s
(braket
l_int|3
)braket
comma
id|hd_words
comma
id|vals
comma
l_int|3
)paren
)paren
(brace
r_case
op_minus
l_int|1
suffix:colon
multiline_comment|/* &quot;none&quot; */
id|drive-&gt;nobios
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* drop into &quot;noprobe&quot; */
r_case
op_minus
l_int|2
suffix:colon
multiline_comment|/* &quot;noprobe&quot; */
id|drive-&gt;noprobe
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|3
suffix:colon
multiline_comment|/* &quot;nowerr&quot; */
id|drive-&gt;bad_wstat
op_assign
id|BAD_R_STAT
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|4
suffix:colon
multiline_comment|/* &quot;cdrom&quot; */
id|drive-&gt;present
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;media
op_assign
id|ide_cdrom
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|5
suffix:colon
multiline_comment|/* &quot;serialize&quot; */
id|printk
c_func
(paren
l_string|&quot; -- USE &bslash;&quot;ide%d=serialize&bslash;&quot; INSTEAD&quot;
comma
id|hw
)paren
suffix:semicolon
r_goto
id|do_serialize
suffix:semicolon
r_case
op_minus
l_int|6
suffix:colon
multiline_comment|/* &quot;autotune&quot; */
id|drive-&gt;autotune
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|7
suffix:colon
multiline_comment|/* &quot;noautotune&quot; */
id|drive-&gt;autotune
op_assign
l_int|2
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|8
suffix:colon
multiline_comment|/* &quot;slow&quot; */
id|drive-&gt;slow
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* cyl,head,sect */
id|drive-&gt;media
op_assign
id|ide_disk
suffix:semicolon
id|drive-&gt;cyl
op_assign
id|drive-&gt;bios_cyl
op_assign
id|vals
(braket
l_int|0
)braket
suffix:semicolon
id|drive-&gt;head
op_assign
id|drive-&gt;bios_head
op_assign
id|vals
(braket
l_int|1
)braket
suffix:semicolon
id|drive-&gt;sect
op_assign
id|drive-&gt;bios_sect
op_assign
id|vals
(braket
l_int|2
)braket
suffix:semicolon
id|drive-&gt;present
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;forced_geom
op_assign
l_int|1
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_default
suffix:colon
r_goto
id|bad_option
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|s
(braket
l_int|0
)braket
op_ne
l_char|&squot;i&squot;
op_logical_or
id|s
(braket
l_int|1
)braket
op_ne
l_char|&squot;d&squot;
op_logical_or
id|s
(braket
l_int|2
)braket
op_ne
l_char|&squot;e&squot;
)paren
r_goto
id|bad_option
suffix:semicolon
multiline_comment|/*&n;&t; * Look for bus speed option:  &quot;idebus=&quot;&n;&t; */
r_if
c_cond
(paren
id|s
(braket
l_int|3
)braket
op_eq
l_char|&squot;b&squot;
op_logical_and
id|s
(braket
l_int|4
)braket
op_eq
l_char|&squot;u&squot;
op_logical_and
id|s
(braket
l_int|5
)braket
op_eq
l_char|&squot;s&squot;
)paren
(brace
r_if
c_cond
(paren
id|match_parm
c_func
(paren
op_amp
id|s
(braket
l_int|6
)braket
comma
l_int|NULL
comma
id|vals
comma
l_int|1
)paren
op_ne
l_int|1
)paren
r_goto
id|bad_option
suffix:semicolon
r_if
c_cond
(paren
id|vals
(braket
l_int|0
)braket
op_ge
l_int|20
op_logical_and
id|vals
(braket
l_int|0
)braket
op_le
l_int|66
)paren
id|idebus_parameter
op_assign
id|vals
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; -- BAD BUS SPEED! Expected value from 20 to 66&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Look for interface options:  &quot;idex=&quot;&n;&t; */
r_if
c_cond
(paren
id|s
(braket
l_int|3
)braket
op_ge
l_char|&squot;0&squot;
op_logical_and
id|s
(braket
l_int|3
)braket
op_le
id|max_hwif
)paren
(brace
multiline_comment|/*&n;&t;&t; * Be VERY CAREFUL changing this: note hardcoded indexes below&n;&t;&t; */
r_const
r_char
op_star
id|ide_words
(braket
)braket
op_assign
(brace
l_string|&quot;noprobe&quot;
comma
l_string|&quot;serialize&quot;
comma
l_string|&quot;autotune&quot;
comma
l_string|&quot;noautotune&quot;
comma
l_string|&quot;qd6580&quot;
comma
l_string|&quot;ht6560b&quot;
comma
l_string|&quot;cmd640_vlb&quot;
comma
l_string|&quot;dtc2278&quot;
comma
l_string|&quot;umc8672&quot;
comma
l_string|&quot;ali14xx&quot;
comma
l_string|&quot;dc4030&quot;
comma
l_int|NULL
)brace
suffix:semicolon
id|hw
op_assign
id|s
(braket
l_int|3
)braket
op_minus
l_char|&squot;0&squot;
suffix:semicolon
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|hw
)braket
suffix:semicolon
id|i
op_assign
id|match_parm
c_func
(paren
op_amp
id|s
(braket
l_int|4
)braket
comma
id|ide_words
comma
id|vals
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Cryptic check to ensure chipset not already set for hwif:&n;&t;&t; */
r_if
c_cond
(paren
id|i
OG
l_int|0
op_logical_or
id|i
op_le
op_minus
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_ne
id|ide_unknown
)paren
r_goto
id|bad_option
suffix:semicolon
r_if
c_cond
(paren
id|i
op_le
op_minus
l_int|5
)paren
(brace
r_if
c_cond
(paren
id|ide_hwifs
(braket
l_int|1
)braket
dot
id|chipset
op_ne
id|ide_unknown
)paren
r_goto
id|bad_option
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Interface keywords work only for ide0:&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
id|hw
op_ne
l_int|0
)paren
r_goto
id|bad_hwif
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|i
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_PROMISE
r_case
op_minus
l_int|11
suffix:colon
multiline_comment|/* &quot;dc4030&quot; */
(brace
id|setup_dc4030
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_PROMISE */
macro_line|#ifdef CONFIG_BLK_DEV_ALI14XX
r_case
op_minus
l_int|10
suffix:colon
multiline_comment|/* &quot;ali14xx&quot; */
(brace
r_extern
r_void
id|init_ali14xx
(paren
r_void
)paren
suffix:semicolon
id|init_ali14xx
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_ALI14XX */
macro_line|#ifdef CONFIG_BLK_DEV_UMC8672
r_case
op_minus
l_int|9
suffix:colon
multiline_comment|/* &quot;umc8672&quot; */
(brace
r_extern
r_void
id|init_umc8672
(paren
r_void
)paren
suffix:semicolon
id|init_umc8672
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_UMC8672 */
macro_line|#ifdef CONFIG_BLK_DEV_DTC2278
r_case
op_minus
l_int|8
suffix:colon
multiline_comment|/* &quot;dtc2278&quot; */
(brace
r_extern
r_void
id|init_dtc2278
(paren
r_void
)paren
suffix:semicolon
id|init_dtc2278
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_DTC2278 */
macro_line|#ifdef CONFIG_BLK_DEV_CMD640
r_case
op_minus
l_int|7
suffix:colon
multiline_comment|/* &quot;cmd640_vlb&quot; */
(brace
r_extern
r_int
id|cmd640_vlb
suffix:semicolon
multiline_comment|/* flag for cmd640.c */
id|cmd640_vlb
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_CMD640 */
macro_line|#ifdef CONFIG_BLK_DEV_HT6560B
r_case
op_minus
l_int|6
suffix:colon
multiline_comment|/* &quot;ht6560b&quot; */
(brace
r_extern
r_void
id|init_ht6560b
(paren
r_void
)paren
suffix:semicolon
id|init_ht6560b
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_HT6560B */
macro_line|#if CONFIG_BLK_DEV_QD6580
r_case
op_minus
l_int|5
suffix:colon
multiline_comment|/* &quot;qd6580&quot; (has secondary i/f) */
(brace
r_extern
r_void
id|init_qd6580
(paren
r_void
)paren
suffix:semicolon
id|init_qd6580
c_func
(paren
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_QD6580 */
r_case
op_minus
l_int|4
suffix:colon
multiline_comment|/* &quot;noautotune&quot; */
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|autotune
op_assign
l_int|2
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|autotune
op_assign
l_int|2
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|3
suffix:colon
multiline_comment|/* &quot;autotune&quot; */
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|autotune
op_assign
l_int|1
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|autotune
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|2
suffix:colon
multiline_comment|/* &quot;serialize&quot; */
id|do_serialize
suffix:colon
id|ide_hwifs
(braket
id|hw
)braket
dot
id|serialized
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* serialize */
id|ide_hwifs
(braket
id|hw
op_xor
l_int|1
)braket
dot
id|serialized
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* with mate */
r_goto
id|done
suffix:semicolon
r_case
op_minus
l_int|1
suffix:colon
multiline_comment|/* &quot;noprobe&quot; */
id|hwif-&gt;noprobe
op_assign
l_int|1
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
l_int|1
suffix:colon
multiline_comment|/* base */
id|vals
(braket
l_int|1
)braket
op_assign
id|vals
(braket
l_int|0
)braket
op_plus
l_int|0x206
suffix:semicolon
multiline_comment|/* default ctl */
r_case
l_int|2
suffix:colon
multiline_comment|/* base,ctl */
id|vals
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* default irq = probe for it */
r_case
l_int|3
suffix:colon
multiline_comment|/* base,ctl,irq */
id|hwif-&gt;io_base
op_assign
id|vals
(braket
l_int|0
)braket
suffix:semicolon
id|hwif-&gt;ctl_port
op_assign
id|vals
(braket
l_int|1
)braket
suffix:semicolon
id|hwif-&gt;irq
op_assign
id|vals
(braket
l_int|2
)braket
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|ide_generic
suffix:semicolon
r_goto
id|done
suffix:semicolon
r_case
l_int|0
suffix:colon
r_goto
id|bad_option
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot; -- SUPPORT NOT CONFIGURED IN THIS KERNEL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|bad_option
suffix:colon
id|printk
c_func
(paren
l_string|&quot; -- BAD OPTION&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
id|bad_hwif
suffix:colon
id|printk
c_func
(paren
l_string|&quot;-- NOT SUPPORTED ON ide%d&quot;
comma
id|hw
)paren
suffix:semicolon
id|done
suffix:colon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called from the partition-table code in genhd.c&n; * to &quot;convert&quot; a drive to a logical geometry with fewer than 1024 cyls.&n; *&n; * The second parameter, &quot;xparm&quot;, determines exactly how the translation &n; * will be handled:&n; *&t;&t; 0 = convert to CHS with fewer than 1024 cyls&n; *&t;&t;&t;using the same method as Ontrack DiskManager.&n; *&t;&t; 1 = same as &quot;0&quot;, plus offset everything by 63 sectors.&n; *&t;&t;-1 = similar to &quot;0&quot;, plus redirect sector 0 to sector 1.&n; *&t;&t;&gt;1 = convert to a CHS geometry with &quot;xparm&quot; heads.&n; *&n; * Returns 0 if the translation was not possible, if the device was not &n; * an IDE disk drive, or if a geometry was &quot;forced&quot; on the commandline.&n; * Returns 1 if the geometry translation was successful.&n; */
DECL|function|ide_xlate_1024
r_int
id|ide_xlate_1024
(paren
id|kdev_t
id|i_rdev
comma
r_int
id|xparm
comma
r_const
r_char
op_star
id|msg
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_static
r_const
id|byte
id|head_vals
(braket
)braket
op_assign
(brace
l_int|4
comma
l_int|8
comma
l_int|16
comma
l_int|32
comma
l_int|64
comma
l_int|128
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
r_const
id|byte
op_star
id|heads
op_assign
id|head_vals
suffix:semicolon
r_int
r_int
id|tracks
suffix:semicolon
r_if
c_cond
(paren
(paren
id|drive
op_assign
id|get_info_ptr
c_func
(paren
id|i_rdev
)paren
)paren
op_eq
l_int|NULL
op_logical_or
id|drive-&gt;forced_geom
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|xparm
OG
l_int|1
op_logical_and
id|xparm
op_le
id|drive-&gt;bios_head
op_logical_and
id|drive-&gt;bios_sect
op_eq
l_int|63
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* we already have a translation */
id|printk
c_func
(paren
l_string|&quot;%s &quot;
comma
id|msg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
)paren
(brace
id|drive-&gt;cyl
op_assign
id|drive-&gt;id-&gt;cyls
suffix:semicolon
id|drive-&gt;head
op_assign
id|drive-&gt;id-&gt;heads
suffix:semicolon
id|drive-&gt;sect
op_assign
id|drive-&gt;id-&gt;sectors
suffix:semicolon
)brace
id|drive-&gt;bios_cyl
op_assign
id|drive-&gt;cyl
suffix:semicolon
id|drive-&gt;bios_head
op_assign
id|drive-&gt;head
suffix:semicolon
id|drive-&gt;bios_sect
op_assign
id|drive-&gt;sect
suffix:semicolon
id|drive-&gt;special.b.set_geometry
op_assign
l_int|1
suffix:semicolon
id|tracks
op_assign
id|drive-&gt;bios_cyl
op_star
id|drive-&gt;bios_head
op_star
id|drive-&gt;bios_sect
op_div
l_int|63
suffix:semicolon
id|drive-&gt;bios_sect
op_assign
l_int|63
suffix:semicolon
r_if
c_cond
(paren
id|xparm
OG
l_int|1
)paren
(brace
id|drive-&gt;bios_head
op_assign
id|xparm
suffix:semicolon
id|drive-&gt;bios_cyl
op_assign
id|tracks
op_div
id|drive-&gt;bios_head
suffix:semicolon
)brace
r_else
(brace
r_while
c_loop
(paren
id|drive-&gt;bios_cyl
op_ge
l_int|1024
)paren
(brace
id|drive-&gt;bios_head
op_assign
op_star
id|heads
suffix:semicolon
id|drive-&gt;bios_cyl
op_assign
id|tracks
op_div
id|drive-&gt;bios_head
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
op_star
op_increment
id|heads
)paren
r_break
suffix:semicolon
)brace
macro_line|#if FAKE_FDISK_FOR_EZDRIVE
r_if
c_cond
(paren
id|xparm
op_eq
op_minus
l_int|1
)paren
(brace
id|drive-&gt;remap_0_to_1
op_assign
l_int|1
suffix:semicolon
id|msg
op_assign
l_string|&quot;0-&gt;1&quot;
suffix:semicolon
)brace
r_else
macro_line|#endif /* FAKE_FDISK_FOR_EZDRIVE */
r_if
c_cond
(paren
id|xparm
op_eq
l_int|1
)paren
(brace
id|drive-&gt;sect0
op_assign
l_int|63
suffix:semicolon
id|drive-&gt;bios_cyl
op_assign
(paren
id|tracks
op_minus
l_int|1
)paren
op_div
id|drive-&gt;bios_head
suffix:semicolon
id|msg
op_assign
l_string|&quot;+63&quot;
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;[remap %s] &quot;
comma
id|msg
)paren
suffix:semicolon
)brace
id|drive-&gt;part
(braket
l_int|0
)braket
dot
id|nr_sects
op_assign
id|current_capacity
c_func
(paren
id|drive
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;[%d/%d/%d]&quot;
comma
id|drive-&gt;bios_cyl
comma
id|drive-&gt;bios_head
comma
id|drive-&gt;bios_sect
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#if MAX_HWIFS &gt; 1
multiline_comment|/*&n; * save_match() is used to simplify logic in init_irq() below.&n; *&n; * A loophole here is that we may not know about a particular&n; * hwif&squot;s irq until after that hwif is actually probed/initialized..&n; * This could be a problem for the case where an hwif is on a&n; * dual interface that requires serialization (eg. cmd640) and another&n; * hwif using one of the same irqs is initialized beforehand.&n; *&n; * This routine detects and reports such situations, but does not fix them.&n; */
DECL|function|save_match
r_static
r_void
id|save_match
(paren
id|ide_hwif_t
op_star
id|hwif
comma
id|ide_hwif_t
op_star
r_new
comma
id|ide_hwif_t
op_star
op_star
id|match
)paren
(brace
id|ide_hwif_t
op_star
id|m
op_assign
op_star
id|match
suffix:semicolon
r_if
c_cond
(paren
id|m
op_logical_and
id|m-&gt;hwgroup
op_logical_and
id|m-&gt;hwgroup
op_ne
r_new
op_member_access_from_pointer
id|hwgroup
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
r_new
op_member_access_from_pointer
id|hwgroup
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: potential irq problem with %s and %s&bslash;n&quot;
comma
id|hwif-&gt;name
comma
r_new
op_member_access_from_pointer
id|name
comma
id|m-&gt;name
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|m
op_logical_or
id|m-&gt;irq
op_ne
id|hwif-&gt;irq
)paren
multiline_comment|/* don&squot;t undo a prior perfect match */
op_star
id|match
op_assign
r_new
suffix:semicolon
)brace
macro_line|#endif /* MAX_HWIFS &gt; 1 */
multiline_comment|/*&n; * This routine sets up the irq for an ide interface, and creates a new&n; * hwgroup for the irq/hwif if none was previously assigned.&n; *&n; * Much of the code is for correctly detecting/handling irq sharing&n; * and irq serialization situations.  This is somewhat complex because&n; * it handles static as well as dynamic (PCMCIA) IDE interfaces.&n; *&n; * The SA_INTERRUPT in sa_flags means ide_intr() is always entered with&n; * interrupts completely disabled.  This can be bad for interrupt latency,&n; * but anything else has led to problems on some machines.  We re-enable&n; * interrupts as much as we can safely do in most places.&n; */
DECL|function|init_irq
r_static
r_int
id|init_irq
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if MAX_HWIFS &gt; 1
r_int
r_int
id|index
suffix:semicolon
macro_line|#endif /* MAX_HWIFS &gt; 1 */
id|ide_hwgroup_t
op_star
id|hwgroup
suffix:semicolon
id|ide_hwif_t
op_star
id|match
op_assign
l_int|NULL
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|hwif-&gt;hwgroup
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if MAX_HWIFS &gt; 1
multiline_comment|/*&n;&t; * Group up with any other hwifs that share our irq(s).&n;&t; */
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
id|index
op_increment
)paren
(brace
id|ide_hwif_t
op_star
id|h
op_assign
op_amp
id|ide_hwifs
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|h-&gt;hwgroup
)paren
(brace
multiline_comment|/* scan only initialized hwif&squot;s */
r_if
c_cond
(paren
id|hwif-&gt;irq
op_eq
id|h-&gt;irq
)paren
(brace
id|hwif-&gt;sharing_irq
op_assign
id|h-&gt;sharing_irq
op_assign
l_int|1
suffix:semicolon
id|save_match
c_func
(paren
id|hwif
comma
id|h
comma
op_amp
id|match
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hwif-&gt;serialized
)paren
(brace
id|ide_hwif_t
op_star
id|mate
op_assign
op_amp
id|ide_hwifs
(braket
id|hwif-&gt;index
op_xor
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
id|mate-&gt;index
op_logical_or
id|h-&gt;irq
op_eq
id|mate-&gt;irq
)paren
id|save_match
c_func
(paren
id|hwif
comma
id|h
comma
op_amp
id|match
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|h-&gt;serialized
)paren
(brace
id|ide_hwif_t
op_star
id|mate
op_assign
op_amp
id|ide_hwifs
(braket
id|h-&gt;index
op_xor
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;irq
op_eq
id|mate-&gt;irq
)paren
id|save_match
c_func
(paren
id|hwif
comma
id|h
comma
op_amp
id|match
)paren
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* MAX_HWIFS &gt; 1 */
multiline_comment|/*&n;&t; * If we are still without a hwgroup, then form a new one&n;&t; */
r_if
c_cond
(paren
id|match
)paren
(brace
id|hwgroup
op_assign
id|match-&gt;hwgroup
suffix:semicolon
)brace
r_else
(brace
id|hwgroup
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ide_hwgroup_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|hwgroup-&gt;hwif
op_assign
id|hwgroup-&gt;next_hwif
op_assign
id|hwif-&gt;next
op_assign
id|hwif
suffix:semicolon
id|hwgroup-&gt;rq
op_assign
l_int|NULL
suffix:semicolon
id|hwgroup-&gt;handler
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|present
)paren
id|hwgroup-&gt;drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
l_int|0
)braket
suffix:semicolon
r_else
id|hwgroup-&gt;drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
l_int|1
)braket
suffix:semicolon
id|hwgroup-&gt;poll_timeout
op_assign
l_int|0
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|hwgroup-&gt;timer
)paren
suffix:semicolon
id|hwgroup-&gt;timer.function
op_assign
op_amp
id|timer_expiry
suffix:semicolon
id|hwgroup-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|hwgroup
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate the irq, if not already obtained for another hwif&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|match
op_logical_or
id|match-&gt;irq
op_ne
id|hwif-&gt;irq
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|hwif-&gt;irq
comma
id|ide_intr
comma
id|SA_INTERRUPT
comma
id|hwif-&gt;name
comma
id|hwgroup
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|match
)paren
id|kfree
c_func
(paren
id|hwgroup
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Everything is okay, so link us into the hwgroup&n;&t; */
id|hwif-&gt;hwgroup
op_assign
id|hwgroup
suffix:semicolon
id|hwif-&gt;next
op_assign
id|hwgroup-&gt;hwif-&gt;next
suffix:semicolon
id|hwgroup-&gt;hwif-&gt;next
op_assign
id|hwif
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* safe now that hwif-&gt;hwgroup is set up */
id|printk
c_func
(paren
l_string|&quot;%s at 0x%03x-0x%03x,0x%03x on irq %d&quot;
comma
id|hwif-&gt;name
comma
id|hwif-&gt;io_base
comma
id|hwif-&gt;io_base
op_plus
l_int|7
comma
id|hwif-&gt;ctl_port
comma
id|hwif-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|match
)paren
id|printk
c_func
(paren
l_string|&quot; (%sed with %s)&quot;
comma
id|hwif-&gt;sharing_irq
ques
c_cond
l_string|&quot;shar&quot;
suffix:colon
l_string|&quot;serializ&quot;
comma
id|match-&gt;name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ide_fops
r_static
r_struct
id|file_operations
id|ide_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|ide_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|ide_open
comma
multiline_comment|/* open */
id|ide_release
comma
multiline_comment|/* release */
id|block_fsync
multiline_comment|/* fsync */
comma
l_int|NULL
comma
multiline_comment|/* fasync */
id|ide_check_media_change
comma
multiline_comment|/* check_media_change */
id|revalidate_disk
multiline_comment|/* revalidate */
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_PCI
macro_line|#if defined(CONFIG_BLK_DEV_RZ1000) || defined(CONFIG_BLK_DEV_TRITON)
DECL|typedef|ide_pci_init_proc_t
r_typedef
r_void
(paren
id|ide_pci_init_proc_t
)paren
(paren
id|byte
comma
id|byte
)paren
suffix:semicolon
multiline_comment|/*&n; * ide_probe_pci() scans PCI for a specific vendor/device function,&n; * and invokes the supplied init routine for each instance detected.&n; */
DECL|function|ide_probe_pci
r_static
r_void
id|ide_probe_pci
(paren
r_int
r_int
id|vendor
comma
r_int
r_int
id|device
comma
id|ide_pci_init_proc_t
op_star
id|init
comma
r_int
id|func_adj
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|index
suffix:semicolon
id|byte
id|fn
comma
id|bus
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|pcibios_find_device
(paren
id|vendor
comma
id|device
comma
id|index
comma
op_amp
id|bus
comma
op_amp
id|fn
)paren
suffix:semicolon
op_increment
id|index
)paren
(brace
id|init
(paren
id|bus
comma
id|fn
op_plus
id|func_adj
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* defined(CONFIG_BLK_DEV_RZ1000) || defined(CONFIG_BLK_DEV_TRITON) */
macro_line|#endif /* CONFIG_PCI */
multiline_comment|/*&n; * ide_init_pci() finds/initializes &quot;known&quot; PCI IDE interfaces&n; *&n; * This routine should ideally be using pcibios_find_class() to find&n; * all IDE interfaces, but that function causes some systems to &quot;go weird&quot;.&n; */
DECL|function|probe_for_hwifs
r_static
r_void
id|probe_for_hwifs
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_PCI
multiline_comment|/*&n;&t; * Find/initialize PCI IDE interfaces&n;&t; */
r_if
c_cond
(paren
id|pcibios_present
c_func
(paren
)paren
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_RZ1000
id|ide_pci_init_proc_t
id|init_rz1000
suffix:semicolon
id|ide_probe_pci
(paren
id|PCI_VENDOR_ID_PCTECH
comma
id|PCI_DEVICE_ID_PCTECH_RZ1000
comma
op_amp
id|init_rz1000
comma
l_int|0
)paren
suffix:semicolon
id|ide_probe_pci
(paren
id|PCI_VENDOR_ID_PCTECH
comma
id|PCI_DEVICE_ID_PCTECH_RZ1001
comma
op_amp
id|init_rz1000
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_RZ1000 */
macro_line|#ifdef CONFIG_BLK_DEV_TRITON
multiline_comment|/*&n;&t;&t; * Apparently the BIOS32 services on Intel motherboards are&n;&t;&t; * buggy and won&squot;t find the PCI_DEVICE_ID_INTEL_82371_1 for us.&n;&t;&t; * So instead, we search for PCI_DEVICE_ID_INTEL_82371_0,&n;&t;&t; * and then add 1.&n;&t;&t; */
id|ide_probe_pci
(paren
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_82371_0
comma
op_amp
id|ide_init_triton
comma
l_int|1
)paren
suffix:semicolon
id|ide_probe_pci
(paren
id|PCI_VENDOR_ID_INTEL
comma
id|PCI_DEVICE_ID_INTEL_82371SB_1
comma
op_amp
id|ide_init_triton
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_TRITON */
)brace
macro_line|#endif /* CONFIG_PCI */
macro_line|#ifdef CONFIG_BLK_DEV_CMD640
(brace
r_extern
r_void
id|ide_probe_for_cmd640x
(paren
r_void
)paren
suffix:semicolon
id|ide_probe_for_cmd640x
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_PROMISE
id|init_dc4030
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|hwif_init
r_static
r_int
id|hwif_init
(paren
r_int
id|h
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_void
(paren
op_star
id|rfn
)paren
(paren
r_void
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;present
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;irq
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|hwif-&gt;irq
op_assign
id|default_irqs
(braket
id|h
)braket
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DISABLED, NO IRQ&bslash;n&quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_return
(paren
id|hwif-&gt;present
op_assign
l_int|0
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_BLK_DEV_HD
r_if
c_cond
(paren
id|hwif-&gt;irq
op_eq
id|HD_IRQ
op_logical_and
id|hwif-&gt;io_base
op_ne
id|HD_DATA
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: CANNOT SHARE IRQ WITH OLD HARDDISK DRIVER (hd.c)&bslash;n&quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_return
(paren
id|hwif-&gt;present
op_assign
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_HD */
id|hwif-&gt;present
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* we set it back to 1 if all is ok below */
r_switch
c_cond
(paren
id|hwif-&gt;major
)paren
(brace
r_case
id|IDE0_MAJOR
suffix:colon
id|rfn
op_assign
op_amp
id|do_ide0_request
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if MAX_HWIFS &gt; 1
r_case
id|IDE1_MAJOR
suffix:colon
id|rfn
op_assign
op_amp
id|do_ide1_request
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#if MAX_HWIFS &gt; 2
r_case
id|IDE2_MAJOR
suffix:colon
id|rfn
op_assign
op_amp
id|do_ide2_request
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
macro_line|#if MAX_HWIFS &gt; 3
r_case
id|IDE3_MAJOR
suffix:colon
id|rfn
op_assign
op_amp
id|do_ide3_request
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: request_fn NOT DEFINED&bslash;n&quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_return
(paren
id|hwif-&gt;present
op_assign
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|register_blkdev
(paren
id|hwif-&gt;major
comma
id|hwif-&gt;name
comma
op_amp
id|ide_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: UNABLE TO GET MAJOR NUMBER %d&bslash;n&quot;
comma
id|hwif-&gt;name
comma
id|hwif-&gt;major
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|init_irq
(paren
id|hwif
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: UNABLE TO GET IRQ %d&bslash;n&quot;
comma
id|hwif-&gt;name
comma
id|hwif-&gt;irq
)paren
suffix:semicolon
(paren
r_void
)paren
id|unregister_blkdev
(paren
id|hwif-&gt;major
comma
id|hwif-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
id|init_gendisk
c_func
(paren
id|hwif
)paren
suffix:semicolon
id|blk_dev
(braket
id|hwif-&gt;major
)braket
dot
id|request_fn
op_assign
id|rfn
suffix:semicolon
id|read_ahead
(braket
id|hwif-&gt;major
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* (4kB) */
id|hwif-&gt;present
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* success */
)brace
r_return
id|hwif-&gt;present
suffix:semicolon
)brace
multiline_comment|/*&n; * This is gets invoked once during initialization, to set *everything* up&n; */
DECL|function|ide_init
r_int
id|ide_init
(paren
r_void
)paren
(brace
r_int
id|index
suffix:semicolon
id|init_ide_data
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Probe for special &quot;known&quot; interface chipsets&n;&t; */
id|probe_for_hwifs
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Probe for drives in the usual way.. CMOS/BIOS, then poke at ports&n;&t; */
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
id|probe_hwif
(paren
op_amp
id|ide_hwifs
(braket
id|index
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
id|hwif_init
(paren
id|index
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDETAPE
id|idetape_register_chrdev
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Register character device interface to the ide tape */
macro_line|#endif /* CONFIG_BLK_DEV_IDETAPE */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDE_PCMCIA
DECL|function|ide_register
r_int
id|ide_register
c_func
(paren
r_int
id|io_base
comma
r_int
id|ctl_port
comma
r_int
id|irq
)paren
(brace
r_int
id|index
comma
id|i
comma
id|rc
op_assign
op_minus
l_int|1
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|index
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;present
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;io_base
op_eq
id|io_base
op_logical_or
id|hwif-&gt;ctl_port
op_eq
id|ctl_port
)paren
r_break
suffix:semicolon
multiline_comment|/* this ide port already exists */
)brace
r_else
(brace
id|hwif-&gt;io_base
op_assign
id|io_base
suffix:semicolon
id|hwif-&gt;ctl_port
op_assign
id|ctl_port
suffix:semicolon
id|hwif-&gt;irq
op_assign
id|irq
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
l_int|0
suffix:semicolon
id|probe_hwif
c_func
(paren
id|hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif_init
c_func
(paren
id|index
)paren
)paren
r_break
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hwif-&gt;gd-&gt;nr_real
suffix:semicolon
id|i
op_increment
)paren
(brace
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
id|i
)braket
suffix:semicolon
id|revalidate_disk
c_func
(paren
id|MKDEV
c_func
(paren
id|hwif-&gt;major
comma
id|i
op_lshift
id|PARTN_BITS
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDECD
r_if
c_cond
(paren
id|drive-&gt;present
op_logical_and
id|drive-&gt;media
op_eq
id|ide_cdrom
)paren
id|ide_cdrom_setup
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDECD */
)brace
id|rc
op_assign
id|index
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|rc
suffix:semicolon
)brace
DECL|function|ide_unregister
r_void
id|ide_unregister
(paren
r_int
r_int
id|index
)paren
(brace
r_struct
id|gendisk
op_star
id|gd
comma
op_star
op_star
id|gdp
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
comma
op_star
id|g
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
suffix:semicolon
r_int
id|irq_count
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|index
op_ge
id|MAX_HWIFS
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif-&gt;present
op_logical_or
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|busy
op_logical_or
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|busy
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|hwif-&gt;present
op_assign
l_int|0
suffix:semicolon
id|hwgroup
op_assign
id|hwif-&gt;hwgroup
suffix:semicolon
multiline_comment|/*&n;&t; * free the irq if we were the only hwif using it&n;&t; */
id|g
op_assign
id|hwgroup-&gt;hwif
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|g-&gt;irq
op_eq
id|hwif-&gt;irq
)paren
op_increment
id|irq_count
suffix:semicolon
id|g
op_assign
id|g-&gt;next
suffix:semicolon
)brace
r_while
c_loop
(paren
id|g
op_ne
id|hwgroup-&gt;hwif
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irq_count
op_eq
l_int|1
)paren
id|free_irq
c_func
(paren
id|hwif-&gt;irq
comma
id|hwgroup
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Note that we only release the standard ports,&n;&t; * and do not even try to handle any extra ports&n;&t; * allocated for weird IDE interface chipsets.&n;&t; */
id|release_region
c_func
(paren
id|hwif-&gt;io_base
comma
l_int|8
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|hwif-&gt;ctl_port
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove us from the hwgroup, and free&n;&t; * the hwgroup if we were the only member&n;&t; */
r_while
c_loop
(paren
id|hwgroup-&gt;hwif-&gt;next
op_ne
id|hwif
)paren
id|hwgroup-&gt;hwif
op_assign
id|hwgroup-&gt;hwif-&gt;next
suffix:semicolon
id|hwgroup-&gt;hwif-&gt;next
op_assign
id|hwif-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;hwif
op_eq
id|hwif
)paren
id|hwgroup-&gt;hwif
op_assign
id|hwif-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;next_hwif
op_eq
id|hwif
)paren
id|hwgroup-&gt;next_hwif
op_assign
id|hwif-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;hwif
op_eq
id|hwif
)paren
id|kfree
c_func
(paren
id|hwgroup
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove us from the kernel&squot;s knowledge&n;&t; */
id|unregister_blkdev
c_func
(paren
id|hwif-&gt;major
comma
id|hwif-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|blksize_size
(braket
id|hwif-&gt;major
)braket
)paren
suffix:semicolon
id|blk_dev
(braket
id|hwif-&gt;major
)braket
dot
id|request_fn
op_assign
l_int|NULL
suffix:semicolon
id|blksize_size
(braket
id|hwif-&gt;major
)braket
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|gdp
op_assign
op_amp
id|gendisk_head
suffix:semicolon
op_star
id|gdp
suffix:semicolon
id|gdp
op_assign
op_amp
(paren
(paren
op_star
id|gdp
)paren
op_member_access_from_pointer
id|next
)paren
)paren
r_if
c_cond
(paren
op_star
id|gdp
op_eq
id|hwif-&gt;gd
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|gdp
op_eq
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;gd not in disk chain!&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|gd
op_assign
op_star
id|gdp
suffix:semicolon
op_star
id|gdp
op_assign
id|gd-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|gd-&gt;sizes
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|gd-&gt;part
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|gd
)paren
suffix:semicolon
)brace
id|init_hwif_data
(paren
id|index
)paren
suffix:semicolon
multiline_comment|/* restore hwif data to pristine status */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDE_PCMCIA */
eof
