multiline_comment|/*&n; * ramdisk.c - Multiple ramdisk driver - gzip-loading version - v. 0.8 beta.&n; * &n; * (C) Chad Page, Theodore Ts&squot;o, et. al, 1995. &n; *&n; * This ramdisk is designed to have filesystems created on it and mounted&n; * just like a regular floppy disk.  &n; *  &n; * It also does something suggested by Linus: use the buffer cache as the&n; * ramdisk data.  This makes it possible to dynamically allocate the ramdisk&n; * buffer - with some consequences I have to deal with as I write this. &n; * &n; * This code is based on the original ramdisk.c, written mostly by&n; * Theodore Ts&squot;o (TYT) in 1991.  The code was largely rewritten by&n; * Chad Page to use the buffer cache to store the ramdisk data in&n; * 1995; Theodore then took over the driver again, and cleaned it up&n; * for inclusion in the mainline kernel.&n; *&n; * The original CRAMDISK code was written by Richard Lyons, and&n; * adapted by Chad Page to use the new ramdisk interface.  Theodore&n; * Ts&squot;o rewrote it so that both the compressed ramdisk loader and the&n; * kernel decompressor uses the same inflate.c codebase.  The ramdisk&n; * loader now also loads into a dynamic (buffer cache based) ramdisk,&n; * not the old static ramdisk.  Support for the old static ramdisk has&n; * been completely removed.&n; *&n; * Loadable module support added by Tom Dyas.&n; *&n; * Further cleanups by Chad Page (page0588@sundance.sjsu.edu):&n; *&t;Cosmetic changes in #ifdef MODULE, code movement, etc...&n; * &t;When the ramdisk is rmmod&squot;ed, free the protected buffers&n; * &t;Default ramdisk size changed to 2.88MB&n; *&n; *  Added initrd: Werner Almesberger &amp; Hans Lermen, Feb &squot;96&n; *&n; * 4/25/96 : Made ramdisk size a parameter (default is now 4MB) &n; *&t;&t;- Chad Page&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/minix_fs.h&gt;
macro_line|#include &lt;linux/ext2_fs.h&gt;
macro_line|#include &lt;linux/romfs_fs.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/fd.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
r_extern
r_void
id|wait_for_keypress
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * 35 has been officially registered as the RAMDISK major number, but&n; * so is the original MAJOR number of 1.  We&squot;re using 1 in&n; * include/linux/major.h for now&n; */
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR RAMDISK_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
multiline_comment|/* The ramdisk size is now a parameter */
DECL|macro|NUM_RAMDISKS
mdefine_line|#define NUM_RAMDISKS 16&t;&t;/* This cannot be overridden (yet) */ 
macro_line|#ifndef MODULE
multiline_comment|/* We don&squot;t have to load ramdisks or gunzip them in a module... */
DECL|macro|RD_LOADER
mdefine_line|#define RD_LOADER
DECL|macro|BUILD_CRAMDISK
mdefine_line|#define BUILD_CRAMDISK
r_void
id|rd_load
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|crd_load
c_func
(paren
r_struct
id|file
op_star
id|fp
comma
r_struct
id|file
op_star
id|outfp
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|variable|initrd_users
r_static
r_int
id|initrd_users
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/* Various static variables go here... mostly used within the ramdisk code only. */
DECL|variable|rd_length
r_static
r_int
id|rd_length
(braket
id|NUM_RAMDISKS
)braket
suffix:semicolon
DECL|variable|rd_blocksizes
r_static
r_int
id|rd_blocksizes
(braket
id|NUM_RAMDISKS
)braket
suffix:semicolon
multiline_comment|/*&n; * Parameters for the boot-loading of the ramdisk.  These are set by&n; * init/main.c (from arguments to the kernel command line) or from the&n; * architecture-specific setup routine (from the stored bootsector&n; * information). &n; */
DECL|variable|rd_size
r_int
id|rd_size
op_assign
l_int|4096
suffix:semicolon
multiline_comment|/* Size of the ramdisks */
macro_line|#ifndef MODULE
DECL|variable|rd_doload
r_int
id|rd_doload
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 1 = load ramdisk, 0 = don&squot;t load */
DECL|variable|rd_prompt
r_int
id|rd_prompt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 1 = prompt for ramdisk, 0 = don&squot;t prompt */
DECL|variable|rd_image_start
r_int
id|rd_image_start
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* starting block # of image */
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|variable|initrd_start
DECL|variable|initrd_end
r_int
r_int
id|initrd_start
comma
id|initrd_end
suffix:semicolon
DECL|variable|mount_initrd
r_int
id|mount_initrd
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* zero if initrd should not be mounted */
DECL|variable|initrd_below_start_ok
r_int
id|initrd_below_start_ok
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/*&n; *  Basically, my strategy here is to set up a buffer-head which can&squot;t be&n; *  deleted, and make that my Ramdisk.  If the request is outside of the&n; *  allocated size, we must get rid of it...&n; *&n; */
DECL|function|rd_request
r_static
r_void
id|rd_request
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|minor
suffix:semicolon
r_int
id|offset
comma
id|len
suffix:semicolon
id|repeat
suffix:colon
id|INIT_REQUEST
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|NUM_RAMDISKS
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|offset
op_assign
id|CURRENT-&gt;sector
op_lshift
l_int|9
suffix:semicolon
id|len
op_assign
id|CURRENT-&gt;current_nr_sectors
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_plus
id|len
)paren
OG
id|rd_length
(braket
id|minor
)braket
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If we&squot;re reading, fill the buffer with 0&squot;s.  This is okay since&n;         * we&squot;re using protected buffers which should never get freed...&n;&t; *&n;&t; * If we&squot;re writing, we protect the buffer.&n;  &t; */
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|READ
)paren
id|memset
c_func
(paren
id|CURRENT-&gt;buffer
comma
l_int|0
comma
id|len
)paren
suffix:semicolon
r_else
id|set_bit
c_func
(paren
id|BH_Protected
comma
op_amp
id|CURRENT-&gt;bh-&gt;b_state
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
DECL|function|rd_ioctl
r_static
r_int
id|rd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_or
op_logical_neg
id|inode-&gt;i_rdev
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|BLKFLSBUF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
multiline_comment|/* Return device size */
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|put_user
c_func
(paren
id|rd_length
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
op_div
l_int|512
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|function|initrd_read
r_static
r_int
id|initrd_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
r_int
id|count
)paren
(brace
r_int
id|left
suffix:semicolon
id|left
op_assign
id|initrd_end
op_minus
id|initrd_start
op_minus
id|file-&gt;f_pos
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|left
)paren
id|count
op_assign
id|left
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|copy_to_user
c_func
(paren
id|buf
comma
(paren
r_char
op_star
)paren
id|initrd_start
op_plus
id|file-&gt;f_pos
comma
id|count
)paren
suffix:semicolon
id|file-&gt;f_pos
op_add_assign
id|count
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|initrd_release
r_static
r_void
id|initrd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|initrd_users
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|initrd_start
suffix:semicolon
id|i
OL
id|initrd_end
suffix:semicolon
id|i
op_add_assign
id|PAGE_SIZE
)paren
id|free_page
c_func
(paren
id|i
)paren
suffix:semicolon
id|initrd_start
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|initrd_fops
r_static
r_struct
id|file_operations
id|initrd_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek */
id|initrd_read
comma
multiline_comment|/* read */
l_int|NULL
comma
multiline_comment|/* write */
l_int|NULL
comma
multiline_comment|/* readdir */
l_int|NULL
comma
multiline_comment|/* select */
l_int|NULL
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
l_int|NULL
comma
multiline_comment|/* open */
id|initrd_release
comma
multiline_comment|/* release */
l_int|NULL
multiline_comment|/* fsync */
)brace
suffix:semicolon
macro_line|#endif
DECL|function|rd_open
r_static
r_int
id|rd_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_eq
id|INITRD_MINOR
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|initrd_start
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|initrd_users
op_increment
suffix:semicolon
id|filp-&gt;f_op
op_assign
op_amp
id|initrd_fops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_ge
id|NUM_RAMDISKS
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|rd_release
r_static
r_void
id|rd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
macro_line|#endif
DECL|variable|fd_fops
r_static
r_struct
id|file_operations
id|fd_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - block dev read */
id|block_write
comma
multiline_comment|/* write - block dev write */
l_int|NULL
comma
multiline_comment|/* readdir - not here! */
l_int|NULL
comma
multiline_comment|/* select */
id|rd_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|rd_open
comma
multiline_comment|/* open */
macro_line|#ifndef MODULE
l_int|NULL
comma
multiline_comment|/* no special release code... */
macro_line|#else
id|rd_release
comma
multiline_comment|/* module needs to decrement use count */
macro_line|#endif
id|block_fsync
multiline_comment|/* fsync */
)brace
suffix:semicolon
multiline_comment|/* This is the registration and initialization section of the ramdisk driver */
DECL|function|rd_init
r_int
id|rd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;ramdisk&quot;
comma
op_amp
id|fd_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RAMDISK: Could not get major %d&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
op_amp
id|rd_request
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RAMDISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rd_length
(braket
id|i
)braket
op_assign
(paren
id|rd_size
op_star
l_int|1024
)paren
suffix:semicolon
id|rd_blocksizes
(braket
id|i
)braket
op_assign
l_int|1024
suffix:semicolon
)brace
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|rd_blocksizes
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Ramdisk driver initialized : %d ramdisks of %dK size&bslash;n&quot;
comma
id|NUM_RAMDISKS
comma
id|rd_size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* loadable module support */
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|error
op_assign
id|rd_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;RAMDISK: Loaded as module.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|error
suffix:semicolon
)brace
multiline_comment|/* Before freeing the module, invalidate all of the protected buffers! */
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RAMDISKS
suffix:semicolon
id|i
op_increment
)paren
id|invalidate_buffers
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|i
)paren
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;ramdisk&quot;
)paren
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif  /* MODULE */
multiline_comment|/* End of non-loading portions of the ramdisk driver */
macro_line|#ifdef RD_LOADER 
multiline_comment|/*&n; * This routine tries to a ramdisk image to load, and returns the&n; * number of blocks to read for a non-compressed image, 0 if the image&n; * is a compressed image, and -1 if an image with the right magic&n; * numbers could not be found.&n; *&n; * We currently check for the following magic numbers:&n; * &t;minix&n; * &t;ext2&n; *&t;romfs&n; * &t;gzip&n; */
r_int
DECL|function|identify_ramdisk_image
id|identify_ramdisk_image
c_func
(paren
id|kdev_t
id|device
comma
r_struct
id|file
op_star
id|fp
comma
r_int
id|start_block
)paren
(brace
r_const
r_int
id|size
op_assign
l_int|512
suffix:semicolon
r_struct
id|minix_super_block
op_star
id|minixsb
suffix:semicolon
r_struct
id|ext2_super_block
op_star
id|ext2sb
suffix:semicolon
r_struct
id|romfs_super_block
op_star
id|romfsb
suffix:semicolon
r_int
id|nblocks
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
id|max_blocks
suffix:semicolon
r_int
r_char
op_star
id|buf
suffix:semicolon
id|buf
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|minixsb
op_assign
(paren
r_struct
id|minix_super_block
op_star
)paren
id|buf
suffix:semicolon
id|ext2sb
op_assign
(paren
r_struct
id|ext2_super_block
op_star
)paren
id|buf
suffix:semicolon
id|romfsb
op_assign
(paren
r_struct
id|romfs_super_block
op_star
)paren
id|buf
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0xe5
comma
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read block 0 to test for gzipped kernel&n;&t; */
r_if
c_cond
(paren
id|fp-&gt;f_op-&gt;llseek
)paren
id|fp-&gt;f_op
op_member_access_from_pointer
id|llseek
c_func
(paren
id|fp-&gt;f_inode
comma
id|fp
comma
id|start_block
op_star
id|BLOCK_SIZE
comma
l_int|0
)paren
suffix:semicolon
id|fp-&gt;f_pos
op_assign
id|start_block
op_star
id|BLOCK_SIZE
suffix:semicolon
id|fp-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|fp-&gt;f_inode
comma
id|fp
comma
id|buf
comma
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If it matches the gzip magic numbers, return -1&n;&t; */
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_eq
l_int|037
op_logical_and
(paren
(paren
id|buf
(braket
l_int|1
)braket
op_eq
l_int|0213
)paren
op_logical_or
(paren
id|buf
(braket
l_int|1
)braket
op_eq
l_int|0236
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Compressed image found at block %d&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|nblocks
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* romfs is at block zero too */
r_if
c_cond
(paren
id|romfsb-&gt;word0
op_eq
id|ROMSB_WORD0
op_logical_and
id|romfsb-&gt;word1
op_eq
id|ROMSB_WORD1
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Romfs filesystem found at block %d&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|nblocks
op_assign
(paren
id|ntohl
c_func
(paren
id|romfsb-&gt;size
)paren
op_plus
id|BLOCK_SIZE
op_minus
l_int|1
)paren
op_rshift
id|BLOCK_SIZE_BITS
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read block 1 to test for minix and ext2 superblock&n;&t; */
r_if
c_cond
(paren
id|fp-&gt;f_op-&gt;llseek
)paren
id|fp-&gt;f_op
op_member_access_from_pointer
id|llseek
c_func
(paren
id|fp-&gt;f_inode
comma
id|fp
comma
(paren
id|start_block
op_plus
l_int|1
)paren
op_star
id|BLOCK_SIZE
comma
l_int|0
)paren
suffix:semicolon
id|fp-&gt;f_pos
op_assign
(paren
id|start_block
op_plus
l_int|1
)paren
op_star
id|BLOCK_SIZE
suffix:semicolon
id|fp-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|fp-&gt;f_inode
comma
id|fp
comma
id|buf
comma
id|size
)paren
suffix:semicolon
multiline_comment|/* Try minix */
r_if
c_cond
(paren
id|minixsb-&gt;s_magic
op_eq
id|MINIX_SUPER_MAGIC
op_logical_or
id|minixsb-&gt;s_magic
op_eq
id|MINIX_SUPER_MAGIC2
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Minix filesystem found at block %d&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|nblocks
op_assign
id|minixsb-&gt;s_nzones
op_lshift
id|minixsb-&gt;s_log_zone_size
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* Try ext2 */
r_if
c_cond
(paren
id|ext2sb-&gt;s_magic
op_eq
id|EXT2_SUPER_MAGIC
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Ext2 filesystem found at block %d&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|nblocks
op_assign
id|ext2sb-&gt;s_blocks_count
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Couldn&squot;t find valid ramdisk image starting at %d.&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|fp-&gt;f_op-&gt;llseek
)paren
id|fp-&gt;f_op
op_member_access_from_pointer
id|llseek
c_func
(paren
id|fp-&gt;f_inode
comma
id|fp
comma
id|start_block
op_star
id|BLOCK_SIZE
comma
l_int|0
)paren
suffix:semicolon
id|fp-&gt;f_pos
op_assign
id|start_block
op_star
id|BLOCK_SIZE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nblocks
OG
l_int|0
)paren
op_logical_and
id|blk_size
(braket
id|MAJOR
c_func
(paren
id|device
)paren
)braket
)paren
(brace
id|max_blocks
op_assign
id|blk_size
(braket
id|MAJOR
c_func
(paren
id|device
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|device
)paren
)braket
suffix:semicolon
id|max_blocks
op_sub_assign
id|start_block
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
OG
id|max_blocks
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Restricting filesystem size &quot;
l_string|&quot;from %d to %d blocks.&bslash;n&quot;
comma
id|nblocks
comma
id|max_blocks
)paren
suffix:semicolon
id|nblocks
op_assign
id|max_blocks
suffix:semicolon
)brace
)brace
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|nblocks
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine loads in the ramdisk image.&n; */
DECL|function|rd_load_image
r_static
r_void
id|rd_load_image
c_func
(paren
id|kdev_t
id|device
comma
r_int
id|offset
)paren
(brace
r_struct
id|inode
id|inode
comma
id|out_inode
suffix:semicolon
r_struct
id|file
id|infile
comma
id|outfile
suffix:semicolon
r_int
r_int
id|fs
suffix:semicolon
id|kdev_t
id|ram_device
suffix:semicolon
r_int
id|nblocks
comma
id|i
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_int
r_int
id|rotate
op_assign
l_int|0
suffix:semicolon
r_char
id|rotator
(braket
l_int|4
)braket
op_assign
(brace
l_char|&squot;|&squot;
comma
l_char|&squot;/&squot;
comma
l_char|&squot;-&squot;
comma
l_char|&squot;&bslash;&bslash;&squot;
)brace
suffix:semicolon
id|ram_device
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
l_int|0
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|infile
comma
l_int|0
comma
r_sizeof
(paren
id|infile
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|inode
comma
l_int|0
comma
r_sizeof
(paren
id|inode
)paren
)paren
suffix:semicolon
id|inode.i_rdev
op_assign
id|device
suffix:semicolon
id|infile.f_mode
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* read only */
id|infile.f_inode
op_assign
op_amp
id|inode
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|outfile
comma
l_int|0
comma
r_sizeof
(paren
id|outfile
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|out_inode
comma
l_int|0
comma
r_sizeof
(paren
id|out_inode
)paren
)paren
suffix:semicolon
id|out_inode.i_rdev
op_assign
id|ram_device
suffix:semicolon
id|outfile.f_mode
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* read/write */
id|outfile.f_inode
op_assign
op_amp
id|out_inode
suffix:semicolon
r_if
c_cond
(paren
id|blkdev_open
c_func
(paren
op_amp
id|inode
comma
op_amp
id|infile
)paren
op_ne
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|blkdev_open
c_func
(paren
op_amp
id|out_inode
comma
op_amp
id|outfile
)paren
op_ne
l_int|0
)paren
r_return
suffix:semicolon
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|nblocks
op_assign
id|identify_ramdisk_image
c_func
(paren
id|device
comma
op_amp
id|infile
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
OL
l_int|0
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef BUILD_CRAMDISK
r_if
c_cond
(paren
id|crd_load
c_func
(paren
op_amp
id|infile
comma
op_amp
id|outfile
)paren
op_eq
l_int|0
)paren
r_goto
id|successful_load
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Kernel does not support compressed &quot;
l_string|&quot;ramdisk images&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|nblocks
OG
(paren
id|rd_length
(braket
l_int|0
)braket
op_rshift
id|BLOCK_SIZE_BITS
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RAMDISK: image too big! (%d/%d blocks)&bslash;n&quot;
comma
id|nblocks
comma
id|rd_length
(braket
l_int|0
)braket
op_rshift
id|BLOCK_SIZE_BITS
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * OK, time to copy in the data&n;&t; */
id|buf
op_assign
id|kmalloc
c_func
(paren
id|BLOCK_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RAMDISK: could not allocate buffer&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Loading %d blocks into ram disk... &quot;
comma
id|nblocks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|infile.f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|infile.f_inode
comma
op_amp
id|infile
comma
id|buf
comma
id|BLOCK_SIZE
)paren
suffix:semicolon
id|outfile.f_op
op_member_access_from_pointer
id|write
c_func
(paren
id|outfile.f_inode
comma
op_amp
id|outfile
comma
id|buf
comma
id|BLOCK_SIZE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
l_int|16
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%c&bslash;b&quot;
comma
id|rotator
(braket
id|rotate
op_amp
l_int|0x3
)braket
)paren
suffix:semicolon
id|rotate
op_increment
suffix:semicolon
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;done.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
id|successful_load
suffix:colon
id|invalidate_buffers
c_func
(paren
id|device
)paren
suffix:semicolon
id|ROOT_DEV
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
l_int|0
)paren
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|infile.f_op-&gt;release
)paren
id|infile.f_op
op_member_access_from_pointer
id|release
c_func
(paren
op_amp
id|inode
comma
op_amp
id|infile
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
)brace
DECL|function|rd_load
r_void
id|rd_load
c_func
(paren
)paren
(brace
r_if
c_cond
(paren
id|rd_doload
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|ROOT_DEV
)paren
op_ne
id|FLOPPY_MAJOR
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|rd_prompt
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_FD
id|floppy_eject
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;VFS: Insert root floppy disk to be loaded into ramdisk and press ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|wait_for_keypress
c_func
(paren
)paren
suffix:semicolon
)brace
id|rd_load_image
c_func
(paren
id|ROOT_DEV
comma
id|rd_image_start
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|function|initrd_load
r_void
id|initrd_load
c_func
(paren
r_void
)paren
(brace
id|rd_load_image
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|INITRD_MINOR
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif /* RD_LOADER */
macro_line|#ifdef BUILD_CRAMDISK
multiline_comment|/*&n; * gzip declarations&n; */
DECL|macro|OF
mdefine_line|#define OF(args)  args
DECL|macro|memzero
mdefine_line|#define memzero(s, n)     memset ((s), 0, (n))
DECL|typedef|uch
r_typedef
r_int
r_char
id|uch
suffix:semicolon
DECL|typedef|ush
r_typedef
r_int
r_int
id|ush
suffix:semicolon
DECL|typedef|ulg
r_typedef
r_int
r_int
id|ulg
suffix:semicolon
DECL|macro|INBUFSIZ
mdefine_line|#define INBUFSIZ 4096
DECL|macro|WSIZE
mdefine_line|#define WSIZE 0x8000    /* window size--must be a power of two, and */
multiline_comment|/*  at least 32K for zip&squot;s deflate method */
DECL|variable|inbuf
r_static
id|uch
op_star
id|inbuf
suffix:semicolon
DECL|variable|window
r_static
id|uch
op_star
id|window
suffix:semicolon
DECL|variable|insize
r_static
r_int
id|insize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* valid bytes in inbuf */
DECL|variable|inptr
r_static
r_int
id|inptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* index of next byte to be processed in inbuf */
DECL|variable|outcnt
r_static
r_int
id|outcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bytes in output buffer */
DECL|variable|exit_code
r_static
r_int
id|exit_code
op_assign
l_int|0
suffix:semicolon
DECL|variable|bytes_out
r_static
r_int
id|bytes_out
op_assign
l_int|0
suffix:semicolon
DECL|variable|crd_infp
DECL|variable|crd_outfp
r_static
r_struct
id|file
op_star
id|crd_infp
comma
op_star
id|crd_outfp
suffix:semicolon
DECL|macro|get_byte
mdefine_line|#define get_byte()  (inptr &lt; insize ? inbuf[inptr++] : fill_inbuf())
multiline_comment|/* Diagnostic functions (stubbed out) */
DECL|macro|Assert
mdefine_line|#define Assert(cond,msg)
DECL|macro|Trace
mdefine_line|#define Trace(x)
DECL|macro|Tracev
mdefine_line|#define Tracev(x)
DECL|macro|Tracevv
mdefine_line|#define Tracevv(x)
DECL|macro|Tracec
mdefine_line|#define Tracec(c,x)
DECL|macro|Tracecv
mdefine_line|#define Tracecv(c,x)
DECL|macro|STATIC
mdefine_line|#define STATIC static
r_static
r_int
id|fill_inbuf
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|flush_window
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
op_star
id|malloc
c_func
(paren
r_int
id|size
)paren
suffix:semicolon
r_static
r_void
id|free
c_func
(paren
r_void
op_star
id|where
)paren
suffix:semicolon
r_static
r_void
id|error
c_func
(paren
r_char
op_star
id|m
)paren
suffix:semicolon
r_static
r_void
id|gzip_mark
c_func
(paren
r_void
op_star
op_star
)paren
suffix:semicolon
r_static
r_void
id|gzip_release
c_func
(paren
r_void
op_star
op_star
)paren
suffix:semicolon
macro_line|#include &quot;../../lib/inflate.c&quot;
DECL|function|malloc
r_static
r_void
op_star
id|malloc
c_func
(paren
r_int
id|size
)paren
(brace
r_return
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
DECL|function|free
r_static
r_void
id|free
c_func
(paren
r_void
op_star
id|where
)paren
(brace
id|kfree
c_func
(paren
id|where
)paren
suffix:semicolon
)brace
DECL|function|gzip_mark
r_static
r_void
id|gzip_mark
c_func
(paren
r_void
op_star
op_star
id|ptr
)paren
(brace
)brace
DECL|function|gzip_release
r_static
r_void
id|gzip_release
c_func
(paren
r_void
op_star
op_star
id|ptr
)paren
(brace
)brace
multiline_comment|/* ===========================================================================&n; * Fill the input buffer. This is called only when the buffer is empty&n; * and at least one byte is really needed.&n; */
DECL|function|fill_inbuf
r_static
r_int
id|fill_inbuf
c_func
(paren
)paren
(brace
r_if
c_cond
(paren
id|exit_code
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|insize
op_assign
id|crd_infp-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|crd_infp-&gt;f_inode
comma
id|crd_infp
comma
id|inbuf
comma
id|INBUFSIZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|insize
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|inptr
op_assign
l_int|1
suffix:semicolon
r_return
id|inbuf
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Write the output window window[0..outcnt-1] and update crc and bytes_out.&n; * (Used for the decompressed data only.)&n; */
DECL|function|flush_window
r_static
r_void
id|flush_window
c_func
(paren
)paren
(brace
id|ulg
id|c
op_assign
id|crc
suffix:semicolon
multiline_comment|/* temporary variable */
r_int
id|n
suffix:semicolon
id|uch
op_star
id|in
comma
id|ch
suffix:semicolon
id|crd_outfp-&gt;f_op
op_member_access_from_pointer
id|write
c_func
(paren
id|crd_outfp-&gt;f_inode
comma
id|crd_outfp
comma
id|window
comma
id|outcnt
)paren
suffix:semicolon
id|in
op_assign
id|window
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|outcnt
suffix:semicolon
id|n
op_increment
)paren
(brace
id|ch
op_assign
op_star
id|in
op_increment
suffix:semicolon
id|c
op_assign
id|crc_32_tab
(braket
(paren
(paren
r_int
)paren
id|c
op_xor
id|ch
)paren
op_amp
l_int|0xff
)braket
op_xor
(paren
id|c
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
id|crc
op_assign
id|c
suffix:semicolon
id|bytes_out
op_add_assign
(paren
id|ulg
)paren
id|outcnt
suffix:semicolon
id|outcnt
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|error
r_static
r_void
id|error
c_func
(paren
r_char
op_star
id|x
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s&quot;
comma
id|x
)paren
suffix:semicolon
id|exit_code
op_assign
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|crd_load
id|crd_load
c_func
(paren
r_struct
id|file
op_star
id|fp
comma
r_struct
id|file
op_star
id|outfp
)paren
(brace
r_int
id|result
suffix:semicolon
id|crd_infp
op_assign
id|fp
suffix:semicolon
id|crd_outfp
op_assign
id|outfp
suffix:semicolon
id|inbuf
op_assign
id|kmalloc
c_func
(paren
id|INBUFSIZ
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inbuf
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RAMDISK: Couldn&squot;t allocate gzip buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|window
op_assign
id|kmalloc
c_func
(paren
id|WSIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|window
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RAMDISK: Couldn&squot;t allocate gzip window&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|inbuf
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|makecrc
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
id|gunzip
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|inbuf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|window
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif  /* BUILD_CRAMDISK */
eof
