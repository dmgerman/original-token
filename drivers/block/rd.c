multiline_comment|/*&n; * ramdisk.c - Multiple RAM disk driver - gzip-loading version - v. 0.8 beta.&n; * &n; * (C) Chad Page, Theodore Ts&squot;o, et. al, 1995. &n; *&n; * This RAM disk is designed to have filesystems created on it and mounted&n; * just like a regular floppy disk.  &n; *  &n; * It also does something suggested by Linus: use the buffer cache as the&n; * RAM disk data.  This makes it possible to dynamically allocate the RAM disk&n; * buffer - with some consequences I have to deal with as I write this. &n; * &n; * This code is based on the original ramdisk.c, written mostly by&n; * Theodore Ts&squot;o (TYT) in 1991.  The code was largely rewritten by&n; * Chad Page to use the buffer cache to store the RAM disk data in&n; * 1995; Theodore then took over the driver again, and cleaned it up&n; * for inclusion in the mainline kernel.&n; *&n; * The original CRAMDISK code was written by Richard Lyons, and&n; * adapted by Chad Page to use the new RAM disk interface.  Theodore&n; * Ts&squot;o rewrote it so that both the compressed RAM disk loader and the&n; * kernel decompressor uses the same inflate.c codebase.  The RAM disk&n; * loader now also loads into a dynamic (buffer cache based) RAM disk,&n; * not the old static RAM disk.  Support for the old static RAM disk has&n; * been completely removed.&n; *&n; * Loadable module support added by Tom Dyas.&n; *&n; * Further cleanups by Chad Page (page0588@sundance.sjsu.edu):&n; *&t;Cosmetic changes in #ifdef MODULE, code movement, etc.&n; * &t;When the RAM disk module is removed, free the protected buffers&n; * &t;Default RAM disk size changed to 2.88 MB&n; *&n; *  Added initrd: Werner Almesberger &amp; Hans Lermen, Feb &squot;96&n; *&n; * 4/25/96 : Made RAM disk size a parameter (default is now 4 MB) &n; *&t;&t;- Chad Page&n; *&n; * Add support for fs images split across &gt;1 disk, Paul Gortmaker, Mar &squot;98&n; *&n; * Make block size and block size shift for RAM disks a global macro&n; * and set blk_size for -ENOSPC,     Werner Fink &lt;werner@suse.de&gt;, Apr &squot;99&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/minix_fs.h&gt;
macro_line|#include &lt;linux/ext2_fs.h&gt;
macro_line|#include &lt;linux/romfs_fs.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/mman.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/fd.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
r_extern
r_void
id|wait_for_keypress
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * 35 has been officially registered as the RAMDISK major number, but&n; * so is the original MAJOR number of 1.  We&squot;re using 1 in&n; * include/linux/major.h for now&n; */
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR RAMDISK_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
multiline_comment|/* The RAM disk size is now a parameter */
DECL|macro|NUM_RAMDISKS
mdefine_line|#define NUM_RAMDISKS 16&t;&t;/* This cannot be overridden (yet) */ 
macro_line|#ifndef MODULE
multiline_comment|/* We don&squot;t have to load RAM disks or gunzip them in a module. */
DECL|macro|RD_LOADER
mdefine_line|#define RD_LOADER
DECL|macro|BUILD_CRAMDISK
mdefine_line|#define BUILD_CRAMDISK
r_void
id|rd_load
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|crd_load
c_func
(paren
r_struct
id|file
op_star
id|fp
comma
r_struct
id|file
op_star
id|outfp
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|variable|initrd_users
r_static
r_int
id|initrd_users
suffix:semicolon
macro_line|#endif
macro_line|#endif
multiline_comment|/* Various static variables go here.  Most are used only in the RAM disk code.&n; */
DECL|variable|rd_length
r_static
r_int
r_int
id|rd_length
(braket
id|NUM_RAMDISKS
)braket
suffix:semicolon
multiline_comment|/* Size of RAM disks in bytes   */
DECL|variable|rd_hardsec
r_static
r_int
id|rd_hardsec
(braket
id|NUM_RAMDISKS
)braket
suffix:semicolon
multiline_comment|/* Size of real blocks in bytes */
DECL|variable|rd_blocksizes
r_static
r_int
id|rd_blocksizes
(braket
id|NUM_RAMDISKS
)braket
suffix:semicolon
multiline_comment|/* Size of 1024 byte blocks :)  */
DECL|variable|rd_kbsize
r_static
r_int
id|rd_kbsize
(braket
id|NUM_RAMDISKS
)braket
suffix:semicolon
multiline_comment|/* Size in blocks of 1024 bytes */
DECL|variable|devfs_handle
r_static
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
DECL|variable|rd_inode
r_static
r_struct
id|inode
op_star
id|rd_inode
(braket
id|NUM_RAMDISKS
)braket
suffix:semicolon
multiline_comment|/* Protected device inodes */
multiline_comment|/*&n; * Parameters for the boot-loading of the RAM disk.  These are set by&n; * init/main.c (from arguments to the kernel command line) or from the&n; * architecture-specific setup routine (from the stored boot sector&n; * information). &n; */
DECL|variable|rd_size
r_int
id|rd_size
op_assign
id|CONFIG_BLK_DEV_RAM_SIZE
suffix:semicolon
multiline_comment|/* Size of the RAM disks */
multiline_comment|/*&n; * It would be very desiderable to have a soft-blocksize (that in the case&n; * of the ramdisk driver is also the hardblocksize ;) of PAGE_SIZE because&n; * doing that we&squot;ll achieve a far better MM footprint. Using a rd_blocksize of&n; * BLOCK_SIZE in the worst case we&squot;ll make PAGE_SIZE/BLOCK_SIZE buffer-pages&n; * unfreeable. With a rd_blocksize of PAGE_SIZE instead we are sure that only&n; * 1 page will be protected. Depending on the size of the ramdisk you&n; * may want to change the ramdisk blocksize to achieve a better or worse MM&n; * behaviour. The default is still BLOCK_SIZE (needed by rd_load_image that&n; * supposes the filesystem in the image uses a BLOCK_SIZE blocksize).&n; */
DECL|variable|rd_blocksize
r_int
id|rd_blocksize
op_assign
id|BLOCK_SIZE
suffix:semicolon
multiline_comment|/* blocksize of the RAM disks */
macro_line|#ifndef MODULE
DECL|variable|rd_doload
r_int
id|rd_doload
suffix:semicolon
multiline_comment|/* 1 = load RAM disk, 0 = don&squot;t load */
DECL|variable|rd_prompt
r_int
id|rd_prompt
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 1 = prompt for RAM disk, 0 = don&squot;t prompt */
DECL|variable|rd_image_start
r_int
id|rd_image_start
suffix:semicolon
multiline_comment|/* starting block # of image */
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|variable|initrd_start
DECL|variable|initrd_end
r_int
r_int
id|initrd_start
comma
id|initrd_end
suffix:semicolon
DECL|variable|mount_initrd
r_int
id|mount_initrd
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* zero if initrd should not be mounted */
DECL|variable|initrd_below_start_ok
r_int
id|initrd_below_start_ok
suffix:semicolon
DECL|function|no_initrd
r_static
r_int
id|__init
id|no_initrd
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|mount_initrd
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;noinitrd&quot;
comma
id|no_initrd
)paren
suffix:semicolon
macro_line|#endif
DECL|function|ramdisk_start_setup
r_static
r_int
id|__init
id|ramdisk_start_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|rd_image_start
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|load_ramdisk
r_static
r_int
id|__init
id|load_ramdisk
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|rd_doload
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
op_amp
l_int|3
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|prompt_ramdisk
r_static
r_int
id|__init
id|prompt_ramdisk
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|rd_prompt
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
op_amp
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ramdisk_size
r_static
r_int
id|__init
id|ramdisk_size
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|rd_size
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|ramdisk_size2
r_static
r_int
id|__init
id|ramdisk_size2
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_return
id|ramdisk_size
c_func
(paren
id|str
)paren
suffix:semicolon
)brace
DECL|function|ramdisk_blocksize
r_static
r_int
id|__init
id|ramdisk_blocksize
c_func
(paren
r_char
op_star
id|str
)paren
(brace
id|rd_blocksize
op_assign
id|simple_strtol
c_func
(paren
id|str
comma
l_int|NULL
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;ramdisk_start=&quot;
comma
id|ramdisk_start_setup
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;load_ramdisk=&quot;
comma
id|load_ramdisk
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;prompt_ramdisk=&quot;
comma
id|prompt_ramdisk
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;ramdisk=&quot;
comma
id|ramdisk_size
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;ramdisk_size=&quot;
comma
id|ramdisk_size2
)paren
suffix:semicolon
id|__setup
c_func
(paren
l_string|&quot;ramdisk_blocksize=&quot;
comma
id|ramdisk_blocksize
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; *  Basically, my strategy here is to set up a buffer-head which can&squot;t be&n; *  deleted, and make that my Ramdisk.  If the request is outside of the&n; *  allocated size, we must get rid of it...&n; *&n; * 19-JAN-1998  Richard Gooch &lt;rgooch@atnf.csiro.au&gt;  Added devfs support&n; *&n; */
DECL|function|rd_make_request
r_static
r_int
id|rd_make_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|sbh
)paren
(brace
r_int
r_int
id|minor
suffix:semicolon
r_int
r_int
id|offset
comma
id|len
suffix:semicolon
r_struct
id|buffer_head
op_star
id|rbh
suffix:semicolon
r_char
op_star
id|bdata
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|sbh-&gt;b_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ge
id|NUM_RAMDISKS
)paren
r_goto
id|fail
suffix:semicolon
id|offset
op_assign
id|sbh-&gt;b_rsector
op_lshift
l_int|9
suffix:semicolon
id|len
op_assign
id|sbh-&gt;b_size
suffix:semicolon
r_if
c_cond
(paren
(paren
id|offset
op_plus
id|len
)paren
OG
id|rd_length
(braket
id|minor
)braket
)paren
r_goto
id|fail
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|READA
)paren
id|rw
op_assign
id|READ
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rw
op_ne
id|READ
)paren
op_logical_and
(paren
id|rw
op_ne
id|WRITE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;RAMDISK: bad command: %d&bslash;n&quot;
comma
id|rw
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
id|rbh
op_assign
id|getblk
c_func
(paren
id|sbh-&gt;b_rdev
comma
id|sbh-&gt;b_rsector
op_div
(paren
id|sbh-&gt;b_size
op_rshift
l_int|9
)paren
comma
id|sbh-&gt;b_size
)paren
suffix:semicolon
multiline_comment|/* I think that it is safe to assume that rbh is not in HighMem, though&n;&t; * sbh might be - NeilBrown&n;&t; */
id|bdata
op_assign
id|bh_kmap
c_func
(paren
id|sbh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
(brace
r_if
c_cond
(paren
id|sbh
op_ne
id|rbh
)paren
id|memcpy
c_func
(paren
id|bdata
comma
id|rbh-&gt;b_data
comma
id|rbh-&gt;b_size
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sbh
op_ne
id|rbh
)paren
id|memcpy
c_func
(paren
id|rbh-&gt;b_data
comma
id|bdata
comma
id|rbh-&gt;b_size
)paren
suffix:semicolon
id|bh_kunmap
c_func
(paren
id|sbh
)paren
suffix:semicolon
id|mark_buffer_protected
c_func
(paren
id|rbh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|rbh
)paren
suffix:semicolon
id|sbh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|sbh
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|fail
suffix:colon
id|sbh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|sbh
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rd_ioctl
r_static
r_int
id|rd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|minor
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_or
op_logical_neg
id|inode-&gt;i_rdev
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|BLKFLSBUF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
multiline_comment|/* special: we want to release the ramdisk memory,&n;&t;&t;&t;   it&squot;s not like with the other blockdevices where&n;&t;&t;&t;   this ioctl only flushes away the buffer cache. */
r_if
c_cond
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|inode-&gt;i_bdev-&gt;bd_openers
)paren
OG
l_int|2
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|destroy_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|rd_blocksizes
(braket
id|minor
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
multiline_comment|/* Return device size */
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|rd_kbsize
(braket
id|minor
)braket
op_lshift
l_int|1
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|BLKROSET
suffix:colon
r_case
id|BLKROGET
suffix:colon
r_case
id|BLKSSZGET
suffix:colon
r_return
id|blk_ioctl
c_func
(paren
id|inode-&gt;i_rdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|function|initrd_read
r_static
id|ssize_t
id|initrd_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_int
id|left
suffix:semicolon
id|left
op_assign
id|initrd_end
op_minus
id|initrd_start
op_minus
op_star
id|ppos
suffix:semicolon
r_if
c_cond
(paren
id|count
OG
id|left
)paren
id|count
op_assign
id|left
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|copy_to_user
c_func
(paren
id|buf
comma
(paren
r_char
op_star
)paren
id|initrd_start
op_plus
op_star
id|ppos
comma
id|count
)paren
suffix:semicolon
op_star
id|ppos
op_add_assign
id|count
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
DECL|function|initrd_release
r_static
r_int
id|initrd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_extern
r_void
id|free_initrd_mem
c_func
(paren
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|initrd_users
)paren
(brace
id|blkdev_put
c_func
(paren
id|inode-&gt;i_bdev
comma
id|BDEV_FILE
)paren
suffix:semicolon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
id|free_initrd_mem
c_func
(paren
id|initrd_start
comma
id|initrd_end
)paren
suffix:semicolon
id|initrd_start
op_assign
l_int|0
suffix:semicolon
)brace
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|initrd_fops
r_static
r_struct
id|file_operations
id|initrd_fops
op_assign
(brace
id|read
suffix:colon
id|initrd_read
comma
id|release
suffix:colon
id|initrd_release
comma
)brace
suffix:semicolon
macro_line|#endif
DECL|function|rd_open
r_static
r_int
id|rd_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_eq
id|INITRD_MINOR
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|initrd_start
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|initrd_users
op_increment
suffix:semicolon
id|filp-&gt;f_op
op_assign
op_amp
id|initrd_fops
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_ge
id|NUM_RAMDISKS
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/*&n;&t; * Immunize device against invalidate_buffers() and prune_icache().&n;&t; */
r_if
c_cond
(paren
id|rd_inode
(braket
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|inode-&gt;i_bdev
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rd_inode
(braket
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
op_assign
id|igrab
c_func
(paren
id|inode
)paren
)paren
op_ne
l_int|NULL
)paren
id|atomic_inc
c_func
(paren
op_amp
id|rd_inode
(braket
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
op_member_access_from_pointer
id|i_bdev-&gt;bd_openers
)paren
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|rd_release
r_static
r_int
id|rd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|fd_fops
r_static
r_struct
id|block_device_operations
id|fd_fops
op_assign
(brace
id|open
suffix:colon
id|rd_open
comma
id|release
suffix:colon
id|rd_release
comma
id|ioctl
suffix:colon
id|rd_ioctl
comma
)brace
suffix:semicolon
macro_line|#ifdef MODULE
multiline_comment|/* Before freeing the module, invalidate all of the protected buffers! */
DECL|function|rd_cleanup
r_static
r_void
id|__exit
id|rd_cleanup
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RAMDISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|rd_inode
(braket
id|i
)braket
)paren
(brace
multiline_comment|/* withdraw invalidate_buffers() and prune_icache() immunity */
id|atomic_dec
c_func
(paren
op_amp
id|rd_inode
(braket
id|i
)braket
op_member_access_from_pointer
id|i_bdev-&gt;bd_openers
)paren
suffix:semicolon
multiline_comment|/* remove stale pointer to module address space */
id|rd_inode
(braket
id|i
)braket
op_member_access_from_pointer
id|i_bdev-&gt;bd_op
op_assign
l_int|NULL
suffix:semicolon
id|iput
c_func
(paren
id|rd_inode
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|destroy_buffers
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|i
)paren
)paren
suffix:semicolon
)brace
id|devfs_unregister
(paren
id|devfs_handle
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;ramdisk&quot;
)paren
suffix:semicolon
id|hardsect_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* This is the registration and initialization section of the RAM disk driver */
DECL|function|rd_init
r_int
id|__init
id|rd_init
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|rd_blocksize
OG
id|PAGE_SIZE
op_logical_or
id|rd_blocksize
OL
l_int|512
op_logical_or
(paren
id|rd_blocksize
op_amp
(paren
id|rd_blocksize
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RAMDISK: wrong blocksize %d, reverting to defaults&bslash;n&quot;
comma
id|rd_blocksize
)paren
suffix:semicolon
id|rd_blocksize
op_assign
id|BLOCK_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;ramdisk&quot;
comma
op_amp
id|fd_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RAMDISK: Could not get major %d&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|blk_queue_make_request
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
op_amp
id|rd_make_request
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RAMDISKS
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* rd_size is given in kB */
id|rd_length
(braket
id|i
)braket
op_assign
id|rd_size
op_lshift
l_int|10
suffix:semicolon
id|rd_hardsec
(braket
id|i
)braket
op_assign
id|rd_blocksize
suffix:semicolon
id|rd_blocksizes
(braket
id|i
)braket
op_assign
id|rd_blocksize
suffix:semicolon
id|rd_kbsize
(braket
id|i
)braket
op_assign
id|rd_size
suffix:semicolon
)brace
id|devfs_handle
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;rd&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register_series
(paren
id|devfs_handle
comma
l_string|&quot;%u&quot;
comma
id|NUM_RAMDISKS
comma
id|DEVFS_FL_DEFAULT
comma
id|MAJOR_NR
comma
l_int|0
comma
id|S_IFBLK
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|fd_fops
comma
l_int|NULL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_RAMDISKS
suffix:semicolon
id|i
op_increment
)paren
id|register_disk
c_func
(paren
l_int|NULL
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|i
)paren
comma
l_int|1
comma
op_amp
id|fd_fops
comma
id|rd_size
op_lshift
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
multiline_comment|/* We ought to separate initrd operations here */
id|register_disk
c_func
(paren
l_int|NULL
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|INITRD_MINOR
)paren
comma
l_int|1
comma
op_amp
id|fd_fops
comma
id|rd_size
op_lshift
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|hardsect_size
(braket
id|MAJOR_NR
)braket
op_assign
id|rd_hardsec
suffix:semicolon
multiline_comment|/* Size of the RAM disk blocks */
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|rd_blocksizes
suffix:semicolon
multiline_comment|/* Avoid set_blocksize() check */
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|rd_kbsize
suffix:semicolon
multiline_comment|/* Size of the RAM disk in kB  */
multiline_comment|/* rd_size is given in kB */
id|printk
c_func
(paren
l_string|&quot;RAMDISK driver initialized: &quot;
l_string|&quot;%d RAM disks of %dK size %d blocksize&bslash;n&quot;
comma
id|NUM_RAMDISKS
comma
id|rd_size
comma
id|rd_blocksize
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|rd_init
id|module_init
c_func
(paren
id|rd_init
)paren
suffix:semicolon
DECL|variable|rd_cleanup
id|module_exit
c_func
(paren
id|rd_cleanup
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* loadable module support */
id|MODULE_PARM
(paren
id|rd_size
comma
l_string|&quot;1i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|rd_size
comma
l_string|&quot;Size of each RAM disk in kbytes.&quot;
)paren
suffix:semicolon
id|MODULE_PARM
(paren
id|rd_blocksize
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|rd_blocksize
comma
l_string|&quot;Blocksize of each RAM disk in bytes.&quot;
)paren
suffix:semicolon
multiline_comment|/* End of non-loading portions of the RAM disk driver */
macro_line|#ifdef RD_LOADER 
multiline_comment|/*&n; * This routine tries to find a RAM disk image to load, and returns the&n; * number of blocks to read for a non-compressed image, 0 if the image&n; * is a compressed image, and -1 if an image with the right magic&n; * numbers could not be found.&n; *&n; * We currently check for the following magic numbers:&n; * &t;minix&n; * &t;ext2&n; *&t;romfs&n; * &t;gzip&n; */
r_int
id|__init
DECL|function|identify_ramdisk_image
id|identify_ramdisk_image
c_func
(paren
id|kdev_t
id|device
comma
r_struct
id|file
op_star
id|fp
comma
r_int
id|start_block
)paren
(brace
r_const
r_int
id|size
op_assign
l_int|512
suffix:semicolon
r_struct
id|minix_super_block
op_star
id|minixsb
suffix:semicolon
r_struct
id|ext2_super_block
op_star
id|ext2sb
suffix:semicolon
r_struct
id|romfs_super_block
op_star
id|romfsb
suffix:semicolon
r_int
id|nblocks
op_assign
op_minus
l_int|1
suffix:semicolon
r_int
r_char
op_star
id|buf
suffix:semicolon
id|buf
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|minixsb
op_assign
(paren
r_struct
id|minix_super_block
op_star
)paren
id|buf
suffix:semicolon
id|ext2sb
op_assign
(paren
r_struct
id|ext2_super_block
op_star
)paren
id|buf
suffix:semicolon
id|romfsb
op_assign
(paren
r_struct
id|romfs_super_block
op_star
)paren
id|buf
suffix:semicolon
id|memset
c_func
(paren
id|buf
comma
l_int|0xe5
comma
id|size
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Read block 0 to test for gzipped kernel&n;&t; */
r_if
c_cond
(paren
id|fp-&gt;f_op-&gt;llseek
)paren
id|fp-&gt;f_op
op_member_access_from_pointer
id|llseek
c_func
(paren
id|fp
comma
id|start_block
op_star
id|BLOCK_SIZE
comma
l_int|0
)paren
suffix:semicolon
id|fp-&gt;f_pos
op_assign
id|start_block
op_star
id|BLOCK_SIZE
suffix:semicolon
id|fp-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|fp
comma
id|buf
comma
id|size
comma
op_amp
id|fp-&gt;f_pos
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * If it matches the gzip magic numbers, return -1&n;&t; */
r_if
c_cond
(paren
id|buf
(braket
l_int|0
)braket
op_eq
l_int|037
op_logical_and
(paren
(paren
id|buf
(braket
l_int|1
)braket
op_eq
l_int|0213
)paren
op_logical_or
(paren
id|buf
(braket
l_int|1
)braket
op_eq
l_int|0236
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Compressed image found at block %d&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|nblocks
op_assign
l_int|0
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* romfs is at block zero too */
r_if
c_cond
(paren
id|romfsb-&gt;word0
op_eq
id|ROMSB_WORD0
op_logical_and
id|romfsb-&gt;word1
op_eq
id|ROMSB_WORD1
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: romfs filesystem found at block %d&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|nblocks
op_assign
(paren
id|ntohl
c_func
(paren
id|romfsb-&gt;size
)paren
op_plus
id|BLOCK_SIZE
op_minus
l_int|1
)paren
op_rshift
id|BLOCK_SIZE_BITS
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Read block 1 to test for minix and ext2 superblock&n;&t; */
r_if
c_cond
(paren
id|fp-&gt;f_op-&gt;llseek
)paren
id|fp-&gt;f_op
op_member_access_from_pointer
id|llseek
c_func
(paren
id|fp
comma
(paren
id|start_block
op_plus
l_int|1
)paren
op_star
id|BLOCK_SIZE
comma
l_int|0
)paren
suffix:semicolon
id|fp-&gt;f_pos
op_assign
(paren
id|start_block
op_plus
l_int|1
)paren
op_star
id|BLOCK_SIZE
suffix:semicolon
id|fp-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|fp
comma
id|buf
comma
id|size
comma
op_amp
id|fp-&gt;f_pos
)paren
suffix:semicolon
multiline_comment|/* Try minix */
r_if
c_cond
(paren
id|minixsb-&gt;s_magic
op_eq
id|MINIX_SUPER_MAGIC
op_logical_or
id|minixsb-&gt;s_magic
op_eq
id|MINIX_SUPER_MAGIC2
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Minix filesystem found at block %d&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|nblocks
op_assign
id|minixsb-&gt;s_nzones
op_lshift
id|minixsb-&gt;s_log_zone_size
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/* Try ext2 */
r_if
c_cond
(paren
id|ext2sb-&gt;s_magic
op_eq
id|cpu_to_le16
c_func
(paren
id|EXT2_SUPER_MAGIC
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: ext2 filesystem found at block %d&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|nblocks
op_assign
id|le32_to_cpu
c_func
(paren
id|ext2sb-&gt;s_blocks_count
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Couldn&squot;t find valid RAM disk image starting at %d.&bslash;n&quot;
comma
id|start_block
)paren
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|fp-&gt;f_op-&gt;llseek
)paren
id|fp-&gt;f_op
op_member_access_from_pointer
id|llseek
c_func
(paren
id|fp
comma
id|start_block
op_star
id|BLOCK_SIZE
comma
l_int|0
)paren
suffix:semicolon
id|fp-&gt;f_pos
op_assign
id|start_block
op_star
id|BLOCK_SIZE
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
r_return
id|nblocks
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine loads in the RAM disk image.&n; */
DECL|function|rd_load_image
r_static
r_void
id|__init
id|rd_load_image
c_func
(paren
id|kdev_t
id|device
comma
r_int
id|offset
comma
r_int
id|unit
)paren
(brace
r_struct
id|inode
op_star
id|inode
comma
op_star
id|out_inode
suffix:semicolon
r_struct
id|file
id|infile
comma
id|outfile
suffix:semicolon
r_struct
id|dentry
id|in_dentry
comma
id|out_dentry
suffix:semicolon
id|mm_segment_t
id|fs
suffix:semicolon
id|kdev_t
id|ram_device
suffix:semicolon
r_int
id|nblocks
comma
id|i
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_int
r_int
id|rotate
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|devblocks
op_assign
l_int|0
suffix:semicolon
r_char
id|rotator
(braket
l_int|4
)braket
op_assign
(brace
l_char|&squot;|&squot;
comma
l_char|&squot;/&squot;
comma
l_char|&squot;-&squot;
comma
l_char|&squot;&bslash;&bslash;&squot;
)brace
suffix:semicolon
id|ram_device
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|unit
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inode
op_assign
id|get_empty_inode
c_func
(paren
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|infile
comma
l_int|0
comma
r_sizeof
(paren
id|infile
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|in_dentry
comma
l_int|0
comma
r_sizeof
(paren
id|in_dentry
)paren
)paren
suffix:semicolon
id|infile.f_mode
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* read only */
id|infile.f_dentry
op_assign
op_amp
id|in_dentry
suffix:semicolon
id|in_dentry.d_inode
op_assign
id|inode
suffix:semicolon
id|infile.f_op
op_assign
op_amp
id|def_blk_fops
suffix:semicolon
id|init_special_inode
c_func
(paren
id|inode
comma
id|S_IFBLK
op_or
id|S_IRUSR
comma
id|kdev_t_to_nr
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|out_inode
op_assign
id|get_empty_inode
c_func
(paren
)paren
)paren
op_eq
l_int|NULL
)paren
r_goto
id|free_inode
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|outfile
comma
l_int|0
comma
r_sizeof
(paren
id|outfile
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|out_dentry
comma
l_int|0
comma
r_sizeof
(paren
id|out_dentry
)paren
)paren
suffix:semicolon
id|outfile.f_mode
op_assign
l_int|3
suffix:semicolon
multiline_comment|/* read/write */
id|outfile.f_dentry
op_assign
op_amp
id|out_dentry
suffix:semicolon
id|out_dentry.d_inode
op_assign
id|out_inode
suffix:semicolon
id|outfile.f_op
op_assign
op_amp
id|def_blk_fops
suffix:semicolon
id|init_special_inode
c_func
(paren
id|out_inode
comma
id|S_IFBLK
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
id|kdev_t_to_nr
c_func
(paren
id|ram_device
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blkdev_open
c_func
(paren
id|inode
comma
op_amp
id|infile
)paren
op_ne
l_int|0
)paren
r_goto
id|free_inode
suffix:semicolon
r_if
c_cond
(paren
id|blkdev_open
c_func
(paren
id|out_inode
comma
op_amp
id|outfile
)paren
op_ne
l_int|0
)paren
r_goto
id|free_inodes
suffix:semicolon
id|fs
op_assign
id|get_fs
c_func
(paren
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|KERNEL_DS
)paren
suffix:semicolon
id|nblocks
op_assign
id|identify_ramdisk_image
c_func
(paren
id|device
comma
op_amp
id|infile
comma
id|offset
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
OL
l_int|0
)paren
r_goto
id|done
suffix:semicolon
r_if
c_cond
(paren
id|nblocks
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef BUILD_CRAMDISK
r_if
c_cond
(paren
id|crd_load
c_func
(paren
op_amp
id|infile
comma
op_amp
id|outfile
)paren
op_eq
l_int|0
)paren
r_goto
id|successful_load
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Kernel does not support compressed &quot;
l_string|&quot;RAM disk images&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * NOTE NOTE: nblocks suppose that the blocksize is BLOCK_SIZE, so&n;&t; * rd_load_image will work only with filesystem BLOCK_SIZE wide!&n;&t; * So make sure to use 1k blocksize while generating ext2fs&n;&t; * ramdisk-images.&n;&t; */
r_if
c_cond
(paren
id|nblocks
OG
(paren
id|rd_length
(braket
id|unit
)braket
op_rshift
id|BLOCK_SIZE_BITS
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;RAMDISK: image too big! (%d/%ld blocks)&bslash;n&quot;
comma
id|nblocks
comma
id|rd_length
(braket
id|unit
)braket
op_rshift
id|BLOCK_SIZE_BITS
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * OK, time to copy in the data&n;&t; */
id|buf
op_assign
id|kmalloc
c_func
(paren
id|BLOCK_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RAMDISK: could not allocate buffer&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
r_if
c_cond
(paren
id|blk_size
(braket
id|MAJOR
c_func
(paren
id|device
)paren
)braket
)paren
id|devblocks
op_assign
id|blk_size
(braket
id|MAJOR
c_func
(paren
id|device
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|device
)paren
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|device
)paren
op_eq
id|MAJOR_NR
op_logical_and
id|MINOR
c_func
(paren
id|device
)paren
op_eq
id|INITRD_MINOR
)paren
id|devblocks
op_assign
id|nblocks
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|devblocks
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RAMDISK: could not determine device size&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;RAMDISK: Loading %d blocks [%d disk%s] into ram disk... &quot;
comma
id|nblocks
comma
(paren
(paren
id|nblocks
op_minus
l_int|1
)paren
op_div
id|devblocks
)paren
op_plus
l_int|1
comma
id|nblocks
OG
id|devblocks
ques
c_cond
l_string|&quot;s&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
op_logical_and
(paren
id|i
op_mod
id|devblocks
op_eq
l_int|0
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;done disk #%d.&bslash;n&quot;
comma
id|i
op_div
id|devblocks
)paren
suffix:semicolon
id|rotate
op_assign
l_int|0
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|infile.f_op-&gt;release
)paren
id|infile.f_op
op_member_access_from_pointer
id|release
c_func
(paren
id|inode
comma
op_amp
id|infile
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Please insert disk #%d and press ENTER&bslash;n&quot;
comma
id|i
op_div
id|devblocks
op_plus
l_int|1
)paren
suffix:semicolon
id|wait_for_keypress
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blkdev_open
c_func
(paren
id|inode
comma
op_amp
id|infile
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error opening disk.&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|done
suffix:semicolon
)brace
id|infile.f_pos
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Loading disk #%d... &quot;
comma
id|i
op_div
id|devblocks
op_plus
l_int|1
)paren
suffix:semicolon
)brace
id|infile.f_op
op_member_access_from_pointer
id|read
c_func
(paren
op_amp
id|infile
comma
id|buf
comma
id|BLOCK_SIZE
comma
op_amp
id|infile.f_pos
)paren
suffix:semicolon
id|outfile.f_op
op_member_access_from_pointer
id|write
c_func
(paren
op_amp
id|outfile
comma
id|buf
comma
id|BLOCK_SIZE
comma
op_amp
id|outfile.f_pos
)paren
suffix:semicolon
macro_line|#if !defined(CONFIG_ARCH_S390)
r_if
c_cond
(paren
op_logical_neg
(paren
id|i
op_mod
l_int|16
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%c&bslash;b&quot;
comma
id|rotator
(braket
id|rotate
op_amp
l_int|0x3
)braket
)paren
suffix:semicolon
id|rotate
op_increment
suffix:semicolon
)brace
macro_line|#endif
)brace
id|printk
c_func
(paren
l_string|&quot;done.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buf
)paren
suffix:semicolon
id|successful_load
suffix:colon
id|invalidate_buffers
c_func
(paren
id|device
)paren
suffix:semicolon
id|ROOT_DEV
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ROOT_DEVICE_NAME
op_ne
l_int|NULL
)paren
id|strcpy
(paren
id|ROOT_DEVICE_NAME
comma
l_string|&quot;rd/0&quot;
)paren
suffix:semicolon
id|done
suffix:colon
r_if
c_cond
(paren
id|infile.f_op-&gt;release
)paren
id|infile.f_op
op_member_access_from_pointer
id|release
c_func
(paren
id|inode
comma
op_amp
id|infile
)paren
suffix:semicolon
id|set_fs
c_func
(paren
id|fs
)paren
suffix:semicolon
r_return
suffix:semicolon
id|free_inodes
suffix:colon
multiline_comment|/* free inodes on error */
id|iput
c_func
(paren
id|out_inode
)paren
suffix:semicolon
id|blkdev_put
c_func
(paren
id|inode-&gt;i_bdev
comma
id|BDEV_FILE
)paren
suffix:semicolon
id|free_inode
suffix:colon
id|iput
c_func
(paren
id|inode
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_MAC_FLOPPY
r_int
id|swim3_fd_eject
c_func
(paren
r_int
id|devnum
)paren
suffix:semicolon
macro_line|#endif
DECL|function|rd_load_disk
r_static
r_void
id|__init
id|rd_load_disk
c_func
(paren
r_int
id|n
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
r_extern
id|kdev_t
id|real_root_dev
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|rd_doload
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|ROOT_DEV
)paren
op_ne
id|FLOPPY_MAJOR
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
op_logical_and
id|MAJOR
c_func
(paren
id|real_root_dev
)paren
op_ne
id|FLOPPY_MAJOR
macro_line|#endif
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|rd_prompt
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_FD
id|floppy_eject
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_MAC_FLOPPY
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|ROOT_DEV
)paren
op_eq
id|FLOPPY_MAJOR
)paren
(brace
id|swim3_fd_eject
c_func
(paren
id|MINOR
c_func
(paren
id|ROOT_DEV
)paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|real_root_dev
)paren
op_eq
id|FLOPPY_MAJOR
)paren
(brace
id|swim3_fd_eject
c_func
(paren
id|MINOR
c_func
(paren
id|real_root_dev
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;VFS: Insert root floppy disk to be loaded into RAM disk and press ENTER&bslash;n&quot;
)paren
suffix:semicolon
id|wait_for_keypress
c_func
(paren
)paren
suffix:semicolon
)brace
id|rd_load_image
c_func
(paren
id|ROOT_DEV
comma
id|rd_image_start
comma
id|n
)paren
suffix:semicolon
)brace
DECL|function|rd_load
r_void
id|__init
id|rd_load
c_func
(paren
r_void
)paren
(brace
id|rd_load_disk
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|rd_load_secondary
r_void
id|__init
id|rd_load_secondary
c_func
(paren
r_void
)paren
(brace
id|rd_load_disk
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_INITRD
DECL|function|initrd_load
r_void
id|__init
id|initrd_load
c_func
(paren
r_void
)paren
(brace
id|rd_load_image
c_func
(paren
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|INITRD_MINOR
)paren
comma
id|rd_image_start
comma
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#endif /* RD_LOADER */
macro_line|#ifdef BUILD_CRAMDISK
multiline_comment|/*&n; * gzip declarations&n; */
DECL|macro|OF
mdefine_line|#define OF(args)  args
macro_line|#ifndef memzero
DECL|macro|memzero
mdefine_line|#define memzero(s, n)     memset ((s), 0, (n))
macro_line|#endif
DECL|typedef|uch
r_typedef
r_int
r_char
id|uch
suffix:semicolon
DECL|typedef|ush
r_typedef
r_int
r_int
id|ush
suffix:semicolon
DECL|typedef|ulg
r_typedef
r_int
r_int
id|ulg
suffix:semicolon
DECL|macro|INBUFSIZ
mdefine_line|#define INBUFSIZ 4096
DECL|macro|WSIZE
mdefine_line|#define WSIZE 0x8000    /* window size--must be a power of two, and */
multiline_comment|/*  at least 32K for zip&squot;s deflate method */
DECL|variable|inbuf
r_static
id|uch
op_star
id|inbuf
suffix:semicolon
DECL|variable|window
r_static
id|uch
op_star
id|window
suffix:semicolon
DECL|variable|insize
r_static
r_int
id|insize
suffix:semicolon
multiline_comment|/* valid bytes in inbuf */
DECL|variable|inptr
r_static
r_int
id|inptr
suffix:semicolon
multiline_comment|/* index of next byte to be processed in inbuf */
DECL|variable|outcnt
r_static
r_int
id|outcnt
suffix:semicolon
multiline_comment|/* bytes in output buffer */
DECL|variable|exit_code
r_static
r_int
id|exit_code
suffix:semicolon
DECL|variable|bytes_out
r_static
r_int
id|bytes_out
suffix:semicolon
DECL|variable|crd_infp
DECL|variable|crd_outfp
r_static
r_struct
id|file
op_star
id|crd_infp
comma
op_star
id|crd_outfp
suffix:semicolon
DECL|macro|get_byte
mdefine_line|#define get_byte()  (inptr &lt; insize ? inbuf[inptr++] : fill_inbuf())
multiline_comment|/* Diagnostic functions (stubbed out) */
DECL|macro|Assert
mdefine_line|#define Assert(cond,msg)
DECL|macro|Trace
mdefine_line|#define Trace(x)
DECL|macro|Tracev
mdefine_line|#define Tracev(x)
DECL|macro|Tracevv
mdefine_line|#define Tracevv(x)
DECL|macro|Tracec
mdefine_line|#define Tracec(c,x)
DECL|macro|Tracecv
mdefine_line|#define Tracecv(c,x)
DECL|macro|STATIC
mdefine_line|#define STATIC static
r_static
r_int
id|fill_inbuf
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|flush_window
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
op_star
id|malloc
c_func
(paren
r_int
id|size
)paren
suffix:semicolon
r_static
r_void
id|free
c_func
(paren
r_void
op_star
id|where
)paren
suffix:semicolon
r_static
r_void
id|error
c_func
(paren
r_char
op_star
id|m
)paren
suffix:semicolon
r_static
r_void
id|gzip_mark
c_func
(paren
r_void
op_star
op_star
)paren
suffix:semicolon
r_static
r_void
id|gzip_release
c_func
(paren
r_void
op_star
op_star
)paren
suffix:semicolon
macro_line|#include &quot;../../lib/inflate.c&quot;
DECL|function|malloc
r_static
r_void
id|__init
op_star
id|malloc
c_func
(paren
r_int
id|size
)paren
(brace
r_return
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
)brace
DECL|function|free
r_static
r_void
id|__init
id|free
c_func
(paren
r_void
op_star
id|where
)paren
(brace
id|kfree
c_func
(paren
id|where
)paren
suffix:semicolon
)brace
DECL|function|gzip_mark
r_static
r_void
id|__init
id|gzip_mark
c_func
(paren
r_void
op_star
op_star
id|ptr
)paren
(brace
)brace
DECL|function|gzip_release
r_static
r_void
id|__init
id|gzip_release
c_func
(paren
r_void
op_star
op_star
id|ptr
)paren
(brace
)brace
multiline_comment|/* ===========================================================================&n; * Fill the input buffer. This is called only when the buffer is empty&n; * and at least one byte is really needed.&n; */
DECL|function|fill_inbuf
r_static
r_int
id|__init
id|fill_inbuf
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|exit_code
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|insize
op_assign
id|crd_infp-&gt;f_op
op_member_access_from_pointer
id|read
c_func
(paren
id|crd_infp
comma
id|inbuf
comma
id|INBUFSIZ
comma
op_amp
id|crd_infp-&gt;f_pos
)paren
suffix:semicolon
r_if
c_cond
(paren
id|insize
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|inptr
op_assign
l_int|1
suffix:semicolon
r_return
id|inbuf
(braket
l_int|0
)braket
suffix:semicolon
)brace
multiline_comment|/* ===========================================================================&n; * Write the output window window[0..outcnt-1] and update crc and bytes_out.&n; * (Used for the decompressed data only.)&n; */
DECL|function|flush_window
r_static
r_void
id|__init
id|flush_window
c_func
(paren
r_void
)paren
(brace
id|ulg
id|c
op_assign
id|crc
suffix:semicolon
multiline_comment|/* temporary variable */
r_int
id|n
suffix:semicolon
id|uch
op_star
id|in
comma
id|ch
suffix:semicolon
id|crd_outfp-&gt;f_op
op_member_access_from_pointer
id|write
c_func
(paren
id|crd_outfp
comma
id|window
comma
id|outcnt
comma
op_amp
id|crd_outfp-&gt;f_pos
)paren
suffix:semicolon
id|in
op_assign
id|window
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
l_int|0
suffix:semicolon
id|n
OL
id|outcnt
suffix:semicolon
id|n
op_increment
)paren
(brace
id|ch
op_assign
op_star
id|in
op_increment
suffix:semicolon
id|c
op_assign
id|crc_32_tab
(braket
(paren
(paren
r_int
)paren
id|c
op_xor
id|ch
)paren
op_amp
l_int|0xff
)braket
op_xor
(paren
id|c
op_rshift
l_int|8
)paren
suffix:semicolon
)brace
id|crc
op_assign
id|c
suffix:semicolon
id|bytes_out
op_add_assign
(paren
id|ulg
)paren
id|outcnt
suffix:semicolon
id|outcnt
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|error
r_static
r_void
id|__init
id|error
c_func
(paren
r_char
op_star
id|x
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s&quot;
comma
id|x
)paren
suffix:semicolon
id|exit_code
op_assign
l_int|1
suffix:semicolon
)brace
r_static
r_int
id|__init
DECL|function|crd_load
id|crd_load
c_func
(paren
r_struct
id|file
op_star
id|fp
comma
r_struct
id|file
op_star
id|outfp
)paren
(brace
r_int
id|result
suffix:semicolon
id|insize
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* valid bytes in inbuf */
id|inptr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* index of next byte to be processed in inbuf */
id|outcnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* bytes in output buffer */
id|exit_code
op_assign
l_int|0
suffix:semicolon
id|bytes_out
op_assign
l_int|0
suffix:semicolon
id|crc
op_assign
(paren
id|ulg
)paren
l_int|0xffffffffL
suffix:semicolon
multiline_comment|/* shift register contents */
id|crd_infp
op_assign
id|fp
suffix:semicolon
id|crd_outfp
op_assign
id|outfp
suffix:semicolon
id|inbuf
op_assign
id|kmalloc
c_func
(paren
id|INBUFSIZ
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inbuf
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RAMDISK: Couldn&squot;t allocate gzip buffer&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|window
op_assign
id|kmalloc
c_func
(paren
id|WSIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|window
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;RAMDISK: Couldn&squot;t allocate gzip window&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|inbuf
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|makecrc
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
id|gunzip
c_func
(paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|inbuf
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|window
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
macro_line|#endif  /* BUILD_CRAMDISK */
eof
