multiline_comment|/*&n; * linux/drivers/block/ide-tape.c&t;Version 1.1 - ALPHA&t;Dec  14, 1995&n; *&n; * Copyright (C) 1995 Gadi Oxman &lt;tgud@tochnapc2.technion.ac.il&gt;&n; *&n; * This driver was constructed as a student project in the software laboratory&n; * of the faculty of electrical engineering in the Technion - Israel&squot;s&n; * Institute Of Technology, with the guide of Avner Lottem and Dr. Ilana David.&n; *&n; * It is hereby placed under the terms of the GNU general public license.&n; * (See linux/COPYING).&n; */
multiline_comment|/*&n; * IDE ATAPI streaming tape driver.&n; *&n; * This driver is a part of the Linux ide driver and works in co-operation&n; * with linux/drivers/block/ide.c.&n; *&n; * The driver, in co-operation with ide.c, basically traverses the &n; * request-list for the block device interface. The character device&n; * interface, on the other hand, creates new requests, adds them&n; * to the request-list of the block device, and waits for their completion.&n; *&n; * Pipelined operation mode is now supported on writes.&n; *&n; * The block device major and minor numbers are determined from the&n; * tape&squot;s relative position in the ide interfaces, as explained in ide.c.&n; *&n; * The character device interface consists of two devices:&n; *&n; * ht0&t;&t;major=37,minor=0&t;first IDE tape, rewind on close.&n; * nht0&t;&t;major=37,minor=128&t;first IDE tape, no rewind on close.&n; *&n; * Run /usr/src/linux/drivers/block/MAKEDEV.ide to create the above entries.&n; * We currently support only one ide tape drive.&n; *&n; * The general magnetic tape commands compatible interface, as defined by&n; * include/linux/mtio.h, is accessible through the character device.&n; *&n; * General ide driver configuration options, such as the interrupt-unmask&n; * flag, can be configured by issuing an ioctl to the block device interface,&n; * as any other ide device.&n; *&n; * Our own ide-tape ioctl&squot;s can can be issued to either the block device or&n; * the character device interface.&n; *&n; * Testing was done with a 2 GB CONNER CTMA 4000 IDE ATAPI Streaming Tape Drive.&n; *&n; * Ver 0.1   Nov  1 95   Pre-working code :-)&n; * Ver 0.2   Nov 23 95   A short backup (few megabytes) and restore procedure&n; *                        was successful ! (Using tar cvf ... on the block&n; *                        device interface).&n; *                       A longer backup resulted in major swapping, bad&n; *                        overall Linux performance and eventually failed as&n; *                        we received non serial read-ahead requests from the&n; *                        buffer cache.&n; * Ver 0.3   Nov 28 95   Long backups are now possible, thanks to the&n; *                        character device interface. Linux&squot;s responsiveness&n; *                        and performance doesn&squot;t seem to be much affected&n; *                        from the background backup procedure.&n; *                       Some general mtio.h magnetic tape operations are&n; *                        now supported by our character device. As a result,&n; *                        popular tape utilities are starting to work with&n; *                        ide tapes :-)&n; *                       The following configurations were tested:&n; *                       &t;1. An IDE ATAPI TAPE shares the same interface&n; *                       &t;   and irq with an IDE ATAPI CDROM.&n; *                        &t;2. An IDE ATAPI TAPE shares the same interface&n; *                          &t;   and irq with a normal IDE disk.&n; *                        Both configurations seemed to work just fine !&n; *                        However, to be on the safe side, it is meanwhile&n; *                        recommended to give the IDE TAPE its own interface&n; *                        and irq.&n; *                       The one thing which needs to be done here is to&n; *                        add a &quot;request postpone&quot; feature to ide.c,&n; *                        so that we won&squot;t have to wait for the tape to finish&n; *                        performing a long media access (DSC) request (such&n; *                        as a rewind) before we can access the other device&n; *                        on the same interface. This effect doesn&squot;t disturb&n; *                        normal operation most of the time because read/write&n; *                        requests are relatively fast, and once we are&n; *                        performing one tape r/w request, a lot of requests&n; *                        from the other device can be queued and ide.c will&n; *&t;&t;&t;  service all of them after this single tape request.&n; * Ver 1.0   Dec 11 95   Integrated into Linux 1.3.46 development tree.&n; *                       On each read / write request, we now ask the drive&n; *                        if we can transfer a constant number of bytes&n; *                        (a parameter of the drive) only to its buffers,&n; *                        without causing actual media access. If we can&squot;t,&n; *                        we just wait until we can by polling the DSC bit.&n; *                        This ensures that while we are not transferring&n; *                        more bytes than the constant referred to above, the&n; *                        interrupt latency will not become too high and&n; *                        we won&squot;t cause an interrupt timeout, as happened&n; *                        occasionally in the previous version.&n; *                       While polling for DSC, the current request is&n; *                        postponed and ide.c is free to handle requests from&n; *                        the other device. This is handled transparently to&n; *                        ide.c. The hwgroup locking method which was used&n; *                        in the previous version was removed.&n; *                       Use of new general features which are provided by&n; *                        ide.c for use with atapi devices.&n; *                        (Programming done by Mark Lord)&n; *                       Few potential bug fixes (Again, suggested by Mark)&n; *                       Single character device data transfers are now&n; *                        not limited in size, as they were before.&n; *                       We are asking the tape about its recommended&n; *                        transfer unit and send a larger data transfer&n; *                        as several transfers of the above size.&n; *                        For best results, use an integral number of this&n; *                        basic unit (which is shown during driver&n; *                        initialization). I will soon add an ioctl to get&n; *                        this important parameter.&n; *                       Our data transfer buffer is allocated on startup,&n; *                        rather than before each data transfer. This should&n; *                        ensure that we will indeed have a data buffer.&n; * Ver 1.1   Dec 14 95   Fixed random problems which occured when the tape&n; *                        shared an interface with another device.&n; *                        (poll_for_dsc was a complete mess).&n; *                       Removed some old (non-active) code which had&n; *                        to do with supporting buffer cache originated&n; *                        requests.&n; *                       The block device interface can now be opened, so&n; *                        that general ide driver features like the unmask&n; *                        interrupts flag can be selected with an ioctl.&n; *                        This is the only use of the block device interface.&n; *                       New fast pipelined operation mode (currently only on&n; *                        writes). When using the pipelined mode, the&n; *                        throughput can potentially reach the maximum&n; *                        tape supported throughput, regardless of the&n; *                        user backup program. On my tape drive, it sometimes&n; *                        boosted performance by a factor of 2. Pipelined&n; *                        mode is enabled by default, but since it has a few&n; *                        downfalls as well, you may want to disable it.&n; *                        A short explanation of the pipelined operation mode&n; *                        is available below.&n; *&n; * We are currently in an *alpha* stage. The driver is not complete and not&n; * much tested. I would strongly suggest to:&n; *&n; *&t;1. Connect the tape to a separate interface and irq.&n; *&t;2. Be truly prepared for a kernel crash and the resulting data loss.&n; *&t;3. Don&squot;t rely too much on the resulting backups.&n; *&n; * Other than that, enjoy !&n; *&n; * Here are some words from the first releases of hd.c, which are quoted&n; * in ide.c and apply here as well:&n; *&n; * | Special care is recommended.  Have Fun!&n; *&n; */
multiline_comment|/*&n; * A short explanation of the pipelined operation mode.&n; *&n; * Pipelined mode is currently only implemented on writes. Reads are still&n; * performed in the slow non-pipelined mode.&n; *&n; * The pipeline mode, when enough pipeline stages are available, manages to&n; * keep the tape constantly streaming with the maximum device supported&n; * throughput, regardless of the user backup program, since even when Linux&n; * is busy doing other tasks, we still have job to be done.&n; *&n; * On my tape drive, using pipelined mode and giving the tape its own&n; * interface and irq, I get a constant over 400 KBps throughput, which seems&n; * to be the maximum throughput supported by my tape. When sharing the&n; * interface between the tape and another ata-2 disk drive, I receive around&n; * 350 KBps.&n; *&n; * Using the non-pipelined mode, I get anything between 150 to 380 KBps,&n; * with the average being around 150 or 250 KBps, depending mainly on&n; * the double buffering capabilities of the user backup program, but also&n; * on some additional factors, such as the user block size and the ongoing&n; * disk activity.&n; *&n; * However, there are some downfalls:&n; *&n; *&t;1.&t;We use memory (for data buffers) in proportional to the number&n; *&t;&t;of pipeline stages (each stage is about 26 KB with my tape).&n; *&t;2.&t;We cheat and postpone error codes to the user task. Again,&n; *&t;&t;the postponing period is proportional to the number of stages.&n; *&n; * Concerning (1):&n; *&n; *&t;1.&t;We allocate stages dynamically only when we need them. When&n; *&t;&t;we don&squot;t need them, we don&squot;t consume additional memory. In&n; *&t;&t;case we can&squot;t allocate stages, we just manage without them&n; *&t;&t;(at the expense of decreased throughput) so when Linux is&n; *&t;&t;tight in memory, we will not pose additional difficulties.&n; *&n; *&t;2.&t;The maximum number of stages (which is, in fact, the maximum&n; *&t;&t;amount of memory) which we allocate is limited by the compile&n; *&t;&t;time parameter IDETAPE_MAX_PIPELINE_STAGES.&n; *&n; *&t;3.&t;The maximum number of stages is a controlled parameter - We&n; *&t;&t;don&squot;t start from the user defined maximum number of stages&n; *&t;&t;but from the lower IDETAPE_MIN_PIPELINE_STAGES (again, we&n; *&t;&t;will not even allocate this amount of stages if the user&n; *&t;&t;program can&squot;t handle the speed). We then implement a feedback&n; *&t;&t;loop which checks if the pipeline is empty, and if it is, we&n; *&t;&t;increase the maximum number of stages as necessary until we&n; *&t;&t;reach the optimum value which just manages to keep the tape&n; *&t;&t;busy with with minimum allocated memory or until we reach&n; *&t;&t;IDETAPE_MAX_PIPELINE_STAGES.&n; *&n; * Concerning (2):&n; *&n; *&t;In pipelined mode, ide-tape can not return accurate error codes to&n; *      the user program since we usually just add the request to the&n; *      pipeline without waiting for it to be serviced. In case an error&n; *      occurs, I will report it on the next user request.&n; *&n; *&t;For accurate error codes, you should disable pipelined mode.&n; *&n; * You can enable/disable/tune the pipelined operation mode by adjusting&n; * the compile time parameters in ide-tape.h.&n; */
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|macro|_IDE_TAPE_C
mdefine_line|#define _IDE_TAPE_C&t;&t;&t;/* For ide_end_request in blk.h */
multiline_comment|/*&n; *&t;Main Linux ide driver include file&n; *&n; *&t;Automatically includes our include file - ide-tape.h.&n; */
macro_line|#include &quot;ide.h&quot;&t;&t;
multiline_comment|/*&n; *&t;Supported ATAPI tape drives packet commands&n; */
DECL|macro|IDETAPE_TEST_UNIT_READY_CMD
mdefine_line|#define&t;IDETAPE_TEST_UNIT_READY_CMD&t;0x00
DECL|macro|IDETAPE_REWIND_CMD
mdefine_line|#define&t;IDETAPE_REWIND_CMD&t;&t;0x01
DECL|macro|IDETAPE_REQUEST_SENSE_CMD
mdefine_line|#define&t;IDETAPE_REQUEST_SENSE_CMD&t;0x03
DECL|macro|IDETAPE_READ_CMD
mdefine_line|#define&t;IDETAPE_READ_CMD&t;&t;0x08
DECL|macro|IDETAPE_WRITE_CMD
mdefine_line|#define&t;IDETAPE_WRITE_CMD&t;&t;0x0a
DECL|macro|IDETAPE_WRITE_FILEMARK_CMD
mdefine_line|#define&t;IDETAPE_WRITE_FILEMARK_CMD&t;0x10
DECL|macro|IDETAPE_SPACE_CMD
mdefine_line|#define&t;IDETAPE_SPACE_CMD&t;&t;0x11
DECL|macro|IDETAPE_INQUIRY_CMD
mdefine_line|#define&t;IDETAPE_INQUIRY_CMD&t;&t;0x12
DECL|macro|IDETAPE_ERASE_CMD
mdefine_line|#define&t;IDETAPE_ERASE_CMD&t;&t;0x19
DECL|macro|IDETAPE_MODE_SENSE_CMD
mdefine_line|#define&t;IDETAPE_MODE_SENSE_CMD&t;&t;0x1a
DECL|macro|IDETAPE_LOCATE_CMD
mdefine_line|#define&t;IDETAPE_LOCATE_CMD&t;&t;0x2b
DECL|macro|IDETAPE_READ_POSITION_CMD
mdefine_line|#define&t;IDETAPE_READ_POSITION_CMD&t;0x34
multiline_comment|/*&n; *&t;Some defines for the SPACE command&n; *&n; *&t;(The code field in the SPACE packet command).&n; */
DECL|macro|IDETAPE_SPACE_OVER_FILEMARK
mdefine_line|#define&t;IDETAPE_SPACE_OVER_FILEMARK&t;1
DECL|macro|IDETAPE_SPACE_TO_EOD
mdefine_line|#define&t;IDETAPE_SPACE_TO_EOD&t;&t;3
multiline_comment|/*&n; *&t;Our ioctls - We will use 0x034n and 0x035n&n; *&n; *&t;Nothing special meanwhile.&n; *&t;mtio.h MTIOCTOP compatible commands are supported on the character&n; *&t;device interface.&n; */
DECL|macro|IDETAPE_INQUIRY_IOCTL
mdefine_line|#define IDETAPE_INQUIRY_IOCTL&t;&t;0x0341
DECL|macro|IDETAPE_LOCATE_IOCTL
mdefine_line|#define&t;IDETAPE_LOCATE_IOCTL&t;&t;0x0342
DECL|macro|IDETAPE_RESET_IOCTL
mdefine_line|#define IDETAPE_RESET_IOCTL&t;&t;0x0350
multiline_comment|/*&n; *&t;Special requests for our block device strategy routine.&n; *&n; *&t;In order to service a character device command, we add special&n; *&t;requests to the tail of our block device request queue and wait&n; *&t;for their completion.&n; *&n; */
DECL|macro|IDETAPE_FIRST_REQUEST
mdefine_line|#define&t;IDETAPE_FIRST_REQUEST&t;&t;&t;90
multiline_comment|/*&n; * &t;IDETAPE_PACKET_COMMAND_REQUEST_TYPE1 is used to queue a packet command&n; *&t;in the request queue. We will wait for DSC before issuing the command&n; *&t;if it is still not set. In that case, we will temporary replace the&n; *&t;cmd field to type 2 and restore it back to type 1 when we receive DSC&n; *&t;and can start with sending the command.&n; */
DECL|macro|IDETAPE_PACKET_COMMAND_REQUEST_TYPE1
mdefine_line|#define&t;IDETAPE_PACKET_COMMAND_REQUEST_TYPE1&t;90
DECL|macro|IDETAPE_PACKET_COMMAND_REQUEST_TYPE2
mdefine_line|#define&t;IDETAPE_PACKET_COMMAND_REQUEST_TYPE2&t;91
multiline_comment|/*&n; *&t;IDETAPE_READ_REQUEST and IDETAPE_WRITE_REQUEST are used by our&n; *&t;character device interface to request read/write operations from&n; *&t;our block device interface.&n; *&n; *&t;In case a read or write request was requested by the buffer cache&n; *&t;and not by our character device interface, the cmd field in the&n; *&t;request will contain READ and WRITE instead.&n; *&n; *&t;We handle both cases in a similar way. The main difference is that&n; *&t;in our own requests, buffer head is NULL and idetape_end_request&n; *&t;will update the errors field if the request was not completed.&n; */
DECL|macro|IDETAPE_READ_REQUEST
mdefine_line|#define&t;IDETAPE_READ_REQUEST&t;&t;&t;92
DECL|macro|IDETAPE_WRITE_REQUEST
mdefine_line|#define&t;IDETAPE_WRITE_REQUEST&t;&t;&t;93
DECL|macro|IDETAPE_LAST_REQUEST
mdefine_line|#define IDETAPE_LAST_REQUEST&t;&t;&t;93
multiline_comment|/*&n; *&t;A macro which can be used to check if a we support a given&n; *&t;request command.&n; */
DECL|macro|IDETAPE_REQUEST_CMD
mdefine_line|#define IDETAPE_REQUEST_CMD(cmd) &t;((cmd &gt;= IDETAPE_FIRST_REQUEST) &amp;&amp; (cmd &lt;= IDETAPE_LAST_REQUEST))
multiline_comment|/*&n; *&t;We are now able to postpone an idetape request in the stage&n; *&t;where it is polling for DSC and service requests from the other&n; *&t;ide device meanwhile.&n; */
DECL|macro|IDETAPE_RQ_POSTPONED
mdefine_line|#define&t;IDETAPE_RQ_POSTPONED&t;&t;0x1234
multiline_comment|/*&n; *&t;ATAPI Task File Registers (Re-definition of the ATA Task File&n; *&t;Registers for an ATAPI packet command).&n; * &t;From Table 3-2 of QIC-157C.&n; */
multiline_comment|/* Read Access */
DECL|macro|IDETAPE_DATA_OFFSET
mdefine_line|#define&t;IDETAPE_DATA_OFFSET&t;&t;(0)
DECL|macro|IDETAPE_ERROR_OFFSET
mdefine_line|#define IDETAPE_ERROR_OFFSET&t;&t;(1)
DECL|macro|IDETAPE_IREASON_OFFSET
mdefine_line|#define&t;IDETAPE_IREASON_OFFSET&t;&t;(2)
DECL|macro|IDETAPE_RESERVED3_OFFSET
mdefine_line|#define IDETAPE_RESERVED3_OFFSET&t;(3)
DECL|macro|IDETAPE_BCOUNTL_OFFSET
mdefine_line|#define IDETAPE_BCOUNTL_OFFSET&t;&t;(4)
DECL|macro|IDETAPE_BCOUNTH_OFFSET
mdefine_line|#define&t;IDETAPE_BCOUNTH_OFFSET&t;&t;(5)
DECL|macro|IDETAPE_DRIVESEL_OFFSET
mdefine_line|#define IDETAPE_DRIVESEL_OFFSET&t;&t;(6)
DECL|macro|IDETAPE_STATUS_OFFSET
mdefine_line|#define&t;IDETAPE_STATUS_OFFSET&t;&t;(7)
DECL|macro|IDETAPE_DATA_REG
mdefine_line|#define&t;IDETAPE_DATA_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_DATA_OFFSET)
DECL|macro|IDETAPE_ERROR_REG
mdefine_line|#define IDETAPE_ERROR_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_ERROR_OFFSET)
DECL|macro|IDETAPE_IREASON_REG
mdefine_line|#define&t;IDETAPE_IREASON_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_IREASON_OFFSET)
DECL|macro|IDETAPE_RESERVED3_REG
mdefine_line|#define IDETAPE_RESERVED3_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_RESERVED3_OFFSET)
DECL|macro|IDETAPE_BCOUNTL_REG
mdefine_line|#define IDETAPE_BCOUNTL_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_BCOUNTL_OFFSET)
DECL|macro|IDETAPE_BCOUNTH_REG
mdefine_line|#define&t;IDETAPE_BCOUNTH_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_BCOUNTH_OFFSET)
DECL|macro|IDETAPE_DRIVESEL_REG
mdefine_line|#define IDETAPE_DRIVESEL_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_DRIVESEL_OFFSET)
DECL|macro|IDETAPE_STATUS_REG
mdefine_line|#define&t;IDETAPE_STATUS_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_STATUS_OFFSET)
multiline_comment|/* Write Access */
DECL|macro|IDETAPE_FEATURES_OFFSET
mdefine_line|#define&t;IDETAPE_FEATURES_OFFSET&t;&t;(1)
DECL|macro|IDETAPE_ATACOMMAND_OFFSET
mdefine_line|#define IDETAPE_ATACOMMAND_OFFSET&t;(7)
DECL|macro|IDETAPE_FEATURES_REG
mdefine_line|#define IDETAPE_FEATURES_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_FEATURES_OFFSET)
DECL|macro|IDETAPE_ATACOMMAND_REG
mdefine_line|#define IDETAPE_ATACOMMAND_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_ATACOMMAND_OFFSET)
DECL|macro|IDETAPE_CONTROL_REG
mdefine_line|#define IDETAPE_CONTROL_REG&t;&t;(HWIF(drive)-&gt;ctl_port)
multiline_comment|/*&n; *&t;Structure of the various task file registers&n; */
multiline_comment|/*&n; *&t;The ATAPI Status Register.&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
DECL|member|check
r_int
id|check
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Error occured */
DECL|member|idx
r_int
id|idx
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|corr
r_int
id|corr
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Correctable error occured */
DECL|member|drq
r_int
id|drq
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Data is request by the device */
DECL|member|dsc
r_int
id|dsc
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Set when a media access command is finished */
multiline_comment|/* Reads / Writes are NOT media access commands */
DECL|member|reserved5
r_int
id|reserved5
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|drdy
r_int
id|drdy
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Ignored for ATAPI commands */
multiline_comment|/* (The device is ready to accept ATA command) */
DECL|member|bsy
r_int
id|bsy
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The device has access to the command block */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|idetape_status_reg_t
)brace
id|idetape_status_reg_t
suffix:semicolon
multiline_comment|/*&n; *&t;The ATAPI error register.&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
DECL|member|ili
r_int
id|ili
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Illegal Length Indication */
DECL|member|eom
r_int
id|eom
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* End Of Media Detected */
DECL|member|abrt
r_int
id|abrt
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Aborted command - As defined by ATA */
DECL|member|mcr
r_int
id|mcr
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Media Change Requested - As defined by ATA */
DECL|member|sense_key
r_int
id|sense_key
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* Sense key of the last failed packet command */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|idetape_error_reg_t
)brace
id|idetape_error_reg_t
suffix:semicolon
multiline_comment|/*&n; *&t;ATAPI Feature Register&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
DECL|member|dma
r_int
id|dma
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Using DMA of PIO */
DECL|member|reserved321
r_int
id|reserved321
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved654
r_int
id|reserved654
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Reserved (Tag Type) */
DECL|member|reserved7
r_int
id|reserved7
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|idetape_feature_reg_t
)brace
id|idetape_feature_reg_t
suffix:semicolon
multiline_comment|/*&n; *&t;ATAPI Byte Count Register.&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|16
suffix:semicolon
r_struct
(brace
DECL|member|low
r_int
id|low
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* LSB */
DECL|member|high
r_int
id|high
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* MSB */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|idetape_bcount_reg_t
)brace
id|idetape_bcount_reg_t
suffix:semicolon
multiline_comment|/*&n; *&t;ATAPI Interrupt Reason Register.&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
DECL|member|cod
r_int
id|cod
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Information transferred is command (1) or data (0) */
DECL|member|io
r_int
id|io
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The device requests us to read (1) or write (0) */
DECL|member|reserved
r_int
id|reserved
suffix:colon
l_int|6
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|idetape_ireason_reg_t
)brace
id|idetape_ireason_reg_t
suffix:semicolon
multiline_comment|/*&n; *&t;ATAPI Drive Select Register&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
DECL|member|sam_lun
r_int
id|sam_lun
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* Should be zero with ATAPI (not used) */
DECL|member|drv
r_int
id|drv
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The responding drive will be drive 0 (0) or drive 1 (1) */
DECL|member|one5
r_int
id|one5
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Should be set to 1 */
DECL|member|reserved6
r_int
id|reserved6
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|one7
r_int
id|one7
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Should be set to 1 */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|idetape_drivesel_reg_t
)brace
id|idetape_drivesel_reg_t
suffix:semicolon
multiline_comment|/*&n; *&t;ATAPI Device Control Register&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
DECL|member|zero0
r_int
id|zero0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Should be set to zero */
DECL|member|nien
r_int
id|nien
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Device interrupt is disabled (1) or enabled (0) */
DECL|member|srst
r_int
id|srst
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* ATA software reset. ATAPI devices should use the new ATAPI srst. */
DECL|member|one3
r_int
id|one3
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Should be set to 1 */
DECL|member|reserved4567
r_int
id|reserved4567
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|idetape_control_reg_t
)brace
id|idetape_control_reg_t
suffix:semicolon
multiline_comment|/*&n; *&t;idetape_chrdev_t provides the link between out character device&n; *&t;interface and our block device interface and the corresponding&n; *&t;ide_drive_t structure.&n; *&n; *&t;We currently support only one tape drive.&n; * &n; */
r_typedef
r_struct
(brace
DECL|member|drive
id|ide_drive_t
op_star
id|drive
suffix:semicolon
DECL|member|major
DECL|member|minor
r_int
id|major
comma
id|minor
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|4
)braket
suffix:semicolon
DECL|typedef|idetape_chrdev_t
)brace
id|idetape_chrdev_t
suffix:semicolon
multiline_comment|/*&n; *&t;The following is used to format the general configuration word of&n; *&t;the ATAPI IDENTIFY DEVICE command.&n; */
DECL|struct|idetape_id_gcw
r_struct
id|idetape_id_gcw
(brace
DECL|member|packet_size
r_int
id|packet_size
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Packet Size */
DECL|member|reserved2
r_int
id|reserved2
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved3
r_int
id|reserved3
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved4
r_int
id|reserved4
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|drq_type
r_int
id|drq_type
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Command packet DRQ type */
DECL|member|removable
r_int
id|removable
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Removable media */
DECL|member|device_type
r_int
id|device_type
suffix:colon
l_int|5
suffix:semicolon
multiline_comment|/* Device type */
DECL|member|reserved13
r_int
id|reserved13
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|protocol
r_int
id|protocol
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Protocol type */
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;INQUIRY packet command - Data Format (From Table 6-8 of QIC-157C)&n; */
r_typedef
r_struct
(brace
DECL|member|device_type
r_int
id|device_type
suffix:colon
l_int|5
suffix:semicolon
multiline_comment|/* Peripheral Device Type */
DECL|member|reserved0_765
r_int
id|reserved0_765
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Peripheral Qualifier - Reserved */
DECL|member|reserved1_6t0
r_int
id|reserved1_6t0
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|rmb
r_int
id|rmb
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Removable Medium Bit */
DECL|member|ansi_version
r_int
id|ansi_version
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* ANSI Version */
DECL|member|ecma_version
r_int
id|ecma_version
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* ECMA Version */
DECL|member|iso_version
r_int
id|iso_version
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* ISO Version */
DECL|member|response_format
r_int
id|response_format
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* Response Data Format */
DECL|member|reserved3_45
r_int
id|reserved3_45
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved3_6
r_int
id|reserved3_6
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* TrmIOP - Reserved */
DECL|member|reserved3_7
r_int
id|reserved3_7
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* AENC - Reserved */
DECL|member|additional_length
id|byte
id|additional_length
suffix:semicolon
multiline_comment|/* Additional Length (total_length-4) */
DECL|member|reserved_5
id|byte
id|reserved_5
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved_6
id|byte
id|reserved_6
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved7_0
r_int
id|reserved7_0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* SftRe - Reserved */
DECL|member|reserved7_1
r_int
id|reserved7_1
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* CmdQue - Reserved */
DECL|member|reserved7_2
r_int
id|reserved7_2
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved7_3
r_int
id|reserved7_3
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Linked - Reserved */
DECL|member|reserved7_4
r_int
id|reserved7_4
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Sync - Reserved */
DECL|member|reserved7_5
r_int
id|reserved7_5
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* WBus16 - Reserved */
DECL|member|reserved7_6
r_int
id|reserved7_6
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* WBus32 - Reserved */
DECL|member|reserved7_7
r_int
id|reserved7_7
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* RelAdr - Reserved */
DECL|member|vendor_id
id|byte
id|vendor_id
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Vendor Identification */
DECL|member|product_id
id|byte
id|product_id
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Product Identification */
DECL|member|revision_level
id|byte
id|revision_level
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Revision Level */
DECL|member|vendor_specific
id|byte
id|vendor_specific
(braket
l_int|20
)braket
suffix:semicolon
multiline_comment|/* Vendor Specific - Optional */
DECL|member|reserved56t95
id|byte
id|reserved56t95
(braket
l_int|40
)braket
suffix:semicolon
multiline_comment|/* Reserved - Optional */
multiline_comment|/* Additional information may be returned */
DECL|typedef|idetape_inquiry_result_t
)brace
id|idetape_inquiry_result_t
suffix:semicolon
multiline_comment|/*&n; *&t;READ POSITION packet command - Data Format (From Table 6-57)&n; */
r_typedef
r_struct
(brace
DECL|member|reserved0_10
r_int
id|reserved0_10
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|bpu
r_int
id|bpu
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Block Position Unknown */
DECL|member|reserved0_543
r_int
id|reserved0_543
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|eop
r_int
id|eop
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* End Of Partition */
DECL|member|bop
r_int
id|bop
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Begining Of Partition */
DECL|member|partition_num
id|byte
id|partition_num
suffix:semicolon
multiline_comment|/* Partition Number */
DECL|member|reserved_2
id|byte
id|reserved_2
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved_3
id|byte
id|reserved_3
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|first_block
r_int
r_int
id|first_block
suffix:semicolon
multiline_comment|/* First Block Location */
DECL|member|last_block
r_int
r_int
id|last_block
suffix:semicolon
multiline_comment|/* Last Block Location (Optional) */
DECL|member|reserved_12
id|byte
id|reserved_12
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|blocks_in_buffer_2
id|byte
id|blocks_in_buffer_2
suffix:semicolon
multiline_comment|/* Blocks In Buffer - MSB (Optional) */
DECL|member|blocks_in_buffer_1
id|byte
id|blocks_in_buffer_1
suffix:semicolon
DECL|member|blocks_in_buffer_0
id|byte
id|blocks_in_buffer_0
suffix:semicolon
multiline_comment|/* Blocks In Buffer - LSB (Optional) */
DECL|member|bytes_in_buffer
r_int
r_int
id|bytes_in_buffer
suffix:semicolon
multiline_comment|/* Bytes In Buffer (Optional) */
DECL|typedef|idetape_read_position_result_t
)brace
id|idetape_read_position_result_t
suffix:semicolon
multiline_comment|/*&n; *&t;REQUEST SENSE packet command result - Data Format.&n; */
r_typedef
r_struct
(brace
DECL|member|error_code
r_int
id|error_code
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* Current of deferred errors */
DECL|member|valid
r_int
id|valid
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The information field conforms to QIC-157C */
DECL|member|reserved_1
id|byte
id|reserved_1
suffix:semicolon
multiline_comment|/* Segment Number - Reserved */
DECL|member|sense_key
r_int
id|sense_key
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* Sense Key */
DECL|member|reserved2_4
r_int
id|reserved2_4
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|ili
r_int
id|ili
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Incorrect Length Indicator */
DECL|member|eom
r_int
id|eom
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* End Of Medium */
DECL|member|filemark
r_int
id|filemark
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Filemark */
DECL|member|information
r_int
r_int
id|information
suffix:semicolon
multiline_comment|/* Information - Command specific */
DECL|member|asl
id|byte
id|asl
suffix:semicolon
multiline_comment|/* Additional sense length (n-7) */
DECL|member|command_specific
r_int
r_int
id|command_specific
suffix:semicolon
multiline_comment|/* Additional command specific information */
DECL|member|asc
id|byte
id|asc
suffix:semicolon
multiline_comment|/* Additional Sense Code */
DECL|member|ascq
id|byte
id|ascq
suffix:semicolon
multiline_comment|/* Additional Sense Code Qualifier */
DECL|member|replaceable_unit_code
id|byte
id|replaceable_unit_code
suffix:semicolon
multiline_comment|/* Field Replaceable Unit Code */
DECL|member|sk_specific1
r_int
id|sk_specific1
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* Sense Key Specific */
DECL|member|sksv
r_int
id|sksv
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Sense Key Specific informatio is valid */
DECL|member|sk_specific2
id|byte
id|sk_specific2
suffix:semicolon
multiline_comment|/* Sense Key Specific */
DECL|member|sk_specific3
id|byte
id|sk_specific3
suffix:semicolon
multiline_comment|/* Sense Key Specific */
DECL|typedef|idetape_request_sense_result_t
)brace
id|idetape_request_sense_result_t
suffix:semicolon
multiline_comment|/*&n; *&t;Follows structures which are realted to the SELECT SENSE / MODE SENSE&n; *&t;packet commands. Those packet commands are still not supported&n; *&t;by ide-tape.&n; */
DECL|macro|IDETAPE_CAPABILITIES_PAGE
mdefine_line|#define&t;IDETAPE_CAPABILITIES_PAGE&t;0x2a
multiline_comment|/*&n; *&t;Mode Parameter Header for the MODE SENSE packet command&n; */
r_typedef
r_struct
(brace
DECL|member|mode_data_length
id|byte
id|mode_data_length
suffix:semicolon
multiline_comment|/* The length of the following data that is */
multiline_comment|/* available to be transferred */
DECL|member|medium_type
id|byte
id|medium_type
suffix:semicolon
multiline_comment|/* Medium Type */
DECL|member|dsp
id|byte
id|dsp
suffix:semicolon
multiline_comment|/* Device Specific Parameter */
DECL|member|bdl
id|byte
id|bdl
suffix:semicolon
multiline_comment|/* Block Descriptor Length */
DECL|typedef|idetape_mode_parameter_header_t
)brace
id|idetape_mode_parameter_header_t
suffix:semicolon
multiline_comment|/*&n; *&t;Mode Parameter Block Descriptor the MODE SENSE packet command&n; *&n; *&t;Support for block descriptors is optional.&n; */
r_typedef
r_struct
(brace
DECL|member|density_code
id|byte
id|density_code
suffix:semicolon
multiline_comment|/* Medium density code */
DECL|member|blocks1
id|byte
id|blocks1
suffix:semicolon
multiline_comment|/* Number of blocks - MSB */
DECL|member|blocks2
id|byte
id|blocks2
suffix:semicolon
multiline_comment|/* Number of blocks - Middle byte */
DECL|member|blocks3
id|byte
id|blocks3
suffix:semicolon
multiline_comment|/* Number of blocks - LSB */
DECL|member|reserved4
id|byte
id|reserved4
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|length1
id|byte
id|length1
suffix:semicolon
multiline_comment|/* Block Length - MSB */
DECL|member|length2
id|byte
id|length2
suffix:semicolon
multiline_comment|/* Block Length - Middle byte */
DECL|member|length3
id|byte
id|length3
suffix:semicolon
multiline_comment|/* Block Length - LSB */
DECL|typedef|idetape_parameter_block_descriptor_t
)brace
id|idetape_parameter_block_descriptor_t
suffix:semicolon
multiline_comment|/*&n; *&t;The Data Compression Page, as returned by the MODE SENSE packet command.&n; */
r_typedef
r_struct
(brace
DECL|member|page_code
r_int
id|page_code
suffix:colon
l_int|6
suffix:semicolon
multiline_comment|/* Page Code - Should be 0xf */
DECL|member|reserved
r_int
id|reserved
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|ps
r_int
id|ps
suffix:colon
l_int|1
suffix:semicolon
DECL|member|page_length
id|byte
id|page_length
suffix:semicolon
multiline_comment|/* Page Length - Should be 14 */
DECL|member|reserved2
r_int
id|reserved2
suffix:colon
l_int|6
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|dcc
r_int
id|dcc
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Data Compression Capable */
DECL|member|dce
r_int
id|dce
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Data Compression Enable */
DECL|member|reserved3
r_int
id|reserved3
suffix:colon
l_int|5
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|red
r_int
id|red
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Report Exception on Decompression */
DECL|member|dde
r_int
id|dde
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Data Decompression Enable */
DECL|member|ca
r_int
r_int
id|ca
suffix:semicolon
multiline_comment|/* Compression Algorithm */
DECL|member|da
r_int
r_int
id|da
suffix:semicolon
multiline_comment|/* Decompression Algorithm */
DECL|member|reserved_12
id|byte
id|reserved_12
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved_13
id|byte
id|reserved_13
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved_14
id|byte
id|reserved_14
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved_15
id|byte
id|reserved_15
suffix:semicolon
multiline_comment|/* Reserved */
DECL|typedef|idetape_data_compression_page_t
)brace
id|idetape_data_compression_page_t
suffix:semicolon
multiline_comment|/*&n; *&t;The Medium Partition Page, as returned by the MODE SENSE packet command.&n; */
r_typedef
r_struct
(brace
DECL|member|page_code
r_int
id|page_code
suffix:colon
l_int|6
suffix:semicolon
multiline_comment|/* Page Code - Should be 0x11 */
DECL|member|reserved1_6
r_int
id|reserved1_6
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|ps
r_int
id|ps
suffix:colon
l_int|1
suffix:semicolon
DECL|member|page_length
id|byte
id|page_length
suffix:semicolon
multiline_comment|/* Page Length - Should be 6 */
DECL|member|map
id|byte
id|map
suffix:semicolon
multiline_comment|/* Maximum Additional Partitions - Should be 0 */
DECL|member|apd
id|byte
id|apd
suffix:semicolon
multiline_comment|/* Additional Partitions Defined - Should be 0 */
DECL|member|reserved4_012
r_int
id|reserved4_012
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|psum
r_int
id|psum
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Should be 0 */
DECL|member|idp
r_int
id|idp
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Should be 0 */
DECL|member|sdp
r_int
id|sdp
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Should be 0 */
DECL|member|fdp
r_int
id|fdp
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Fixed Data Partitions */
DECL|member|mfr
id|byte
id|mfr
suffix:semicolon
multiline_comment|/* Medium Format Recognition */
DECL|member|reserved6
id|byte
id|reserved6
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved7
id|byte
id|reserved7
suffix:semicolon
multiline_comment|/* Reserved */
DECL|typedef|idetape_medium_partition_page_t
)brace
id|idetape_medium_partition_page_t
suffix:semicolon
multiline_comment|/*&n; *&t;Prototypes of various functions in ide-tape.c&n; *&n; *&t;The following functions are called from ide.c, and their prototypes&n; *&t;are available in ide.h:&n; *&n; *&t;&t;idetape_identify_device&n; *&t;&t;idetape_setup&n; *&t;&t;idetape_blkdev_ioctl&n; *&t;&t;idetape_do_request&n; *&t;&t;idetape_blkdev_open&n; *&t;&t;idetape_blkdev_release&n; *&t;&t;idetape_register_chrdev (void);&n; */
multiline_comment|/*&n; *&t;The following functions are used to transfer data from / to the&n; *&t;tape&squot;s data register.&n; */
r_void
id|idetape_input_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bcount
)paren
suffix:semicolon
r_void
id|idetape_output_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bcount
)paren
suffix:semicolon
r_void
id|idetape_discard_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|bcount
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Packet command related functions.&n; */
r_void
id|idetape_issue_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_packet_command_t
op_star
id|pc
comma
id|ide_handler_t
op_star
id|handler
)paren
suffix:semicolon
r_void
id|idetape_pc_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;DSC handling functions.&n; */
r_void
id|idetape_postpone_request
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_poll_for_dsc
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_void
id|idetape_poll_for_dsc_direct
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_void
id|idetape_media_access_finished
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Some more packet command related functions.&n; */
r_void
id|idetape_pc_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_retry_pc
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_zero_packet_command
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_void
id|idetape_queue_pc_head
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_packet_command_t
op_star
id|pc
comma
r_struct
id|request
op_star
id|rq
)paren
suffix:semicolon
id|idetape_packet_command_t
op_star
id|idetape_next_pc_storage
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|idetape_next_rq_storage
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_end_request
(paren
id|byte
id|uptodate
comma
id|ide_hwgroup_t
op_star
id|hwgroup
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Various packet commands&n; */
r_void
id|idetape_create_inquiry_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_void
id|idetape_inquiry_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_create_locate_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
r_int
id|block
comma
id|byte
id|partition
)paren
suffix:semicolon
r_void
id|idetape_create_rewind_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_void
id|idetape_create_write_filemark_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
id|write_filemark
)paren
suffix:semicolon
r_void
id|idetape_create_space_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
id|count
comma
id|byte
id|cmd
)paren
suffix:semicolon
r_void
id|idetape_create_erase_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_void
id|idetape_create_test_unit_ready_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_void
id|idetape_create_read_position_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_void
id|idetape_read_position_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_create_read_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
r_int
id|length
)paren
suffix:semicolon
r_void
id|idetape_read_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_create_write_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
r_int
id|length
)paren
suffix:semicolon
r_void
id|idetape_write_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_create_request_sense_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_void
id|idetape_create_mode_sense_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
id|byte
id|page_code
)paren
suffix:semicolon
r_void
id|idetape_request_sense_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_display_inquiry_result
(paren
id|byte
op_star
id|buffer
)paren
suffix:semicolon
r_void
id|idetape_analyze_error
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_request_sense_result_t
op_star
id|result
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Character device callback functions.&n; *&n; *&t;We currently support:&n; *&n; *&t;&t;OPEN, RELEASE, READ, WRITE and IOCTL.&n; */
r_int
id|idetape_chrdev_read
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_int
id|idetape_chrdev_read_remainder
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_int
id|idetape_chrdev_write
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_int
id|idetape_chrdev_write_remainder
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_int
id|idetape_chrdev_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_int
id|idetape_chrdev_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_void
id|idetape_chrdev_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;idetape_mtioctop implements general magnetic tape io control&n; *&t;commands, as defined in include/linux/mtio.h. Those commands are&n; *&t;accessed through the character device interface, using the MTIOCTOP&n; *&t;ioctl.&n; */
r_int
id|idetape_mtioctop
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|mt_op
comma
r_int
id|mt_count
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;idetape_add_chrdev_write_request adds a character device write&n; *&t;request to the pipeline.&n; */
r_int
id|idetape_add_chrdev_write_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|cmd
comma
r_int
id|blocks
comma
r_char
op_star
id|buffer
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;idetape_queue_rw_tail will add a command to the tail of the device&n; *&t;request queue and wait for it to finish. This is used when we&n; *&t;can not allocate pipeline stages (or in non-pipelined mode).&n; */
r_int
id|idetape_queue_rw_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|cmd
comma
r_int
id|blocks
comma
r_char
op_star
id|buffer
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Adds a packet command request to the tail of the device request&n; *&t;queue and waits for it to be serviced.&n; */
r_int
id|idetape_queue_pc_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_int
id|idetape_position_tape
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|block
)paren
suffix:semicolon
r_int
id|idetape_rewind_tape
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Used to get device information&n; */
r_void
id|idetape_get_mode_sense_results
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;General utility functions&n; */
r_int
r_int
id|idetape_swap_long
(paren
r_int
r_int
id|temp
)paren
suffix:semicolon
r_int
r_int
id|idetape_swap_short
(paren
r_int
r_int
id|temp
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Pipeline related functions&n; */
id|idetape_pipeline_stage_t
op_star
id|idetape_kmalloc_stage
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_kfree_stage
(paren
id|idetape_pipeline_stage_t
op_star
id|stage
)paren
suffix:semicolon
r_void
id|idetape_copy_buffer_from_stage
(paren
id|idetape_pipeline_stage_t
op_star
id|stage
comma
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_void
id|idetape_copy_buffer_to_stage
(paren
id|idetape_pipeline_stage_t
op_star
id|stage
comma
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_void
id|idetape_increase_max_pipeline_stages
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_add_stage_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pipeline_stage_t
op_star
id|stage
)paren
suffix:semicolon
r_void
id|idetape_active_next_stage
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_empty_pipeline
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_insert_pipeline_into_queue
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;For general magnetic tape device compatibility.&n; */
macro_line|#include &lt;linux/mtio.h&gt;
multiline_comment|/*&n; *&t;Global variables&n; *&n; *&t;The variables below are used for the character device interface.&n; *&n; *&t;Additional state variables are defined in our ide_drive_t structure.&n; */
DECL|variable|idetape_chrdev
id|idetape_chrdev_t
id|idetape_chrdev
suffix:semicolon
multiline_comment|/* Character device interface information */
DECL|variable|idetape_drive_already_found
id|byte
id|idetape_drive_already_found
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 1 when the above data structure is initialized */
multiline_comment|/*&n; *&t;Our character device supporting functions, passed to register_chrdev.&n; */
DECL|variable|idetape_fops
r_static
r_struct
id|file_operations
id|idetape_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|idetape_chrdev_read
comma
multiline_comment|/* read  */
id|idetape_chrdev_write
comma
multiline_comment|/* write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|idetape_chrdev_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|idetape_chrdev_open
comma
multiline_comment|/* open */
id|idetape_chrdev_release
comma
multiline_comment|/* release */
l_int|NULL
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
l_int|NULL
comma
multiline_comment|/* check_media_change */
l_int|NULL
multiline_comment|/* revalidate */
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;idetape_identify_device is called by do_identify in ide.c during&n; *&t;the device probing stage to check the contents of the ATAPI IDENTIFY&n; *&t;command results, in case the device type is tape. We return:&n; *&n; *&t;1&t;If the tape can be supported by us, based on the information&n; *&t;&t;we have so far.&n; *&n; *&t;0 &t;If this tape driver is not currently supported by us.&n; *&n; *&t;In case we decide to support the tape, we store the current drive&n; *&t;pointer in our character device global variables, so that we can&n; *&t;pass between both interfaces.&n; */
DECL|function|idetape_identify_device
r_int
id|idetape_identify_device
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|hd_driveid
op_star
id|id
)paren
(brace
r_struct
id|idetape_id_gcw
id|gcw
suffix:semicolon
r_int
r_int
op_star
id|ptr
suffix:semicolon
r_int
id|support
op_assign
l_int|1
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
r_int
r_int
id|mask
comma
id|i
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|gcw
suffix:semicolon
op_star
id|ptr
op_assign
id|id-&gt;config
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Dumping ATAPI Identify Device tape parameters&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Protocol Type: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|gcw.protocol
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
l_int|1
suffix:colon
id|printk
(paren
l_string|&quot;ATA&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
(paren
l_string|&quot;ATAPI&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
(paren
l_string|&quot;Reserved (Unknown to ide-tape)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Device Type: %x - &quot;
comma
id|gcw.device_type
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|gcw.device_type
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
(paren
l_string|&quot;Direct-access Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
(paren
l_string|&quot;Streaming Tape Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
r_case
l_int|4
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printk
(paren
l_string|&quot;CD-ROM Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_case
l_int|7
suffix:colon
id|printk
(paren
l_string|&quot;Optical memory Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1f
suffix:colon
id|printk
(paren
l_string|&quot;Unknown or no Device type&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Removable: %s&quot;
comma
id|gcw.removable
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Command Packet DRQ Type: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|gcw.drq_type
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
(paren
l_string|&quot;Microprocessor DRQ&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
(paren
l_string|&quot;Interrupt DRQ&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
(paren
l_string|&quot;Accelerated DRQ&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Command Packet Size: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|gcw.packet_size
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
(paren
l_string|&quot;12 bytes&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
(paren
l_string|&quot;16 bytes&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Model: %s&bslash;n&quot;
comma
id|id-&gt;model
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Firmware Revision: %s&bslash;n&quot;
comma
id|id-&gt;fw_rev
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Serial Number: %s&bslash;n&quot;
comma
id|id-&gt;serial_no
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Write buffer size: %d bytes&bslash;n&quot;
comma
id|id-&gt;buf_size
op_star
l_int|512
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;DMA: %s&quot;
comma
id|id-&gt;capability
op_amp
l_int|0x01
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;LBA: %s&quot;
comma
id|id-&gt;capability
op_amp
l_int|0x02
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;IORDY can be disabled: %s&quot;
comma
id|id-&gt;capability
op_amp
l_int|0x04
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;IORDY supported: %s&quot;
comma
id|id-&gt;capability
op_amp
l_int|0x08
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;Unknown&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;PIO Cycle Timing Category: %d&bslash;n&quot;
comma
id|id-&gt;tPIO
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;DMA Cycle Timing Category: %d&bslash;n&quot;
comma
id|id-&gt;tDMA
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Single Word DMA supported modes: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
comma
id|mask
op_assign
id|mask
op_lshift
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|id-&gt;dma_1word
op_amp
id|mask
)paren
id|printk
(paren
l_string|&quot;%d &quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;dma_1word
op_amp
(paren
id|mask
op_lshift
l_int|8
)paren
)paren
id|printk
(paren
l_string|&quot;(active) &quot;
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Multi Word DMA supported modes: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
comma
id|mask
op_assign
id|mask
op_lshift
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|id-&gt;dma_mword
op_amp
id|mask
)paren
id|printk
(paren
l_string|&quot;%d &quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;dma_mword
op_amp
(paren
id|mask
op_lshift
l_int|8
)paren
)paren
id|printk
(paren
l_string|&quot;(active) &quot;
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|0x0002
)paren
(brace
id|printk
(paren
l_string|&quot;Enhanced PIO Modes: %s&bslash;n&quot;
comma
id|id-&gt;eide_pio_modes
op_amp
l_int|1
ques
c_cond
l_string|&quot;Mode 3&quot;
suffix:colon
l_string|&quot;None&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Minimum Multi-word DMA cycle per word: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;eide_dma_min
op_eq
l_int|0
)paren
id|printk
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;%d ns&bslash;n&quot;
comma
id|id-&gt;eide_dma_min
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Manafactuer&bslash;&squot;s Recommended Multi-word cycle: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;eide_dma_time
op_eq
l_int|0
)paren
id|printk
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;%d ns&bslash;n&quot;
comma
id|id-&gt;eide_dma_time
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Minimum PIO cycle without IORDY: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;eide_pio
op_eq
l_int|0
)paren
id|printk
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;%d ns&bslash;n&quot;
comma
id|id-&gt;eide_pio
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Minimum PIO cycle with IORDY: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;eide_pio_iordy
op_eq
l_int|0
)paren
id|printk
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;%d ns&bslash;n&quot;
comma
id|id-&gt;eide_pio_iordy
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;According to the device, fields 64-70 are not valid.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG */
multiline_comment|/* Check that we can support this device */
r_if
c_cond
(paren
id|gcw.protocol
op_ne
l_int|2
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Protocol is not ATAPI&bslash;n&quot;
)paren
suffix:semicolon
id|support
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gcw.device_type
op_ne
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Device type is not set to tape&bslash;n&quot;
)paren
suffix:semicolon
id|support
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|gcw.removable
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: The removable flag is not set&bslash;n&quot;
)paren
suffix:semicolon
id|support
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gcw.drq_type
op_ne
l_int|2
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Sorry, DRQ types other than Accelerated DRQ&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: are still not supproted by the driver&bslash;n&quot;
)paren
suffix:semicolon
id|support
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gcw.packet_size
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Packet size is not 12 bytes long&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gcw.packet_size
op_eq
l_int|1
)paren
id|printk
(paren
l_string|&quot;ide-tape: Sorry, padding to 16 bytes is still not supported&bslash;n&quot;
)paren
suffix:semicolon
id|support
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|idetape_drive_already_found
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Sorry, only one ide tape drive is supported by the driver&bslash;n&quot;
)paren
suffix:semicolon
id|support
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|idetape_drive_already_found
op_assign
l_int|1
suffix:semicolon
id|idetape_chrdev.drive
op_assign
id|drive
suffix:semicolon
id|idetape_chrdev.major
op_assign
id|IDETAPE_MAJOR
suffix:semicolon
id|idetape_chrdev.minor
op_assign
l_int|0
suffix:semicolon
id|idetape_chrdev.name
(braket
l_int|0
)braket
op_assign
l_char|&squot;h&squot;
suffix:semicolon
id|idetape_chrdev.name
(braket
l_int|1
)braket
op_assign
l_char|&squot;t&squot;
suffix:semicolon
id|idetape_chrdev.name
(braket
l_int|2
)braket
op_assign
l_char|&squot;0&squot;
suffix:semicolon
id|idetape_chrdev.name
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|support
)paren
suffix:semicolon
multiline_comment|/* In case support=0, we will not install the driver */
)brace
multiline_comment|/*&n; *&t;idetape_register_chrdev calls register_chrdev to register our character&n; *&t;device interface. The connection to the ide_drive_t structure, which&n; *&t;is used by the entire ide driver is provided by our global variable&n; *&t;idetape_chrdev.drive, which was initialized earlier, during the device&n; *&t;probing stage.&n; */
DECL|function|idetape_register_chrdev
r_void
id|idetape_register_chrdev
(paren
r_void
)paren
(brace
r_int
id|major
comma
id|minor
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|idetape_drive_already_found
)paren
r_return
suffix:semicolon
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
id|major
op_assign
id|idetape_chrdev.major
suffix:semicolon
id|minor
op_assign
id|idetape_chrdev.minor
suffix:semicolon
r_if
c_cond
(paren
id|register_chrdev
(paren
id|major
comma
id|idetape_chrdev.name
comma
op_amp
id|idetape_fops
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;Unable to register character device interface !&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* ??? */
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;ide-tape: %s &lt;-&gt; %s : Character device interface on major = %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|idetape_chrdev.name
comma
id|major
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;idetape_setup is called from the ide driver in the partition table&n; *&t;identification stage, to:&n; *&n; *&t;&t;1.&t;Initialize our various state variables.&n; *&t;&t;2.&t;Ask the tape for its capabilities.&n; *&t;&t;3.&t;Allocate a buffer which will be used for data&n; *&t;&t;&t;transfer. The buffer size is chosen based on&n; *&t;&t;&t;the recommendation which we received in step (2).&n; *&n; *&t;Note that at this point ide.c already assigned us an irq, so that&n; *&t;we can queue requests here and wait for their completion.&n; */
DECL|function|idetape_setup
r_void
id|idetape_setup
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_int
r_int
id|allocation_length
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_setup&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */&t;
id|drive-&gt;ready_stat
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* With an ATAPI device, we can issue packet commands */
multiline_comment|/* regardless of the state of DRDY */
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|tape_drive
op_assign
id|drive
suffix:semicolon
id|tape-&gt;block_address
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;block_address_valid
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;pc_stack_index
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;postponed_rq
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;active_data_request
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;current_number_of_stages
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;first_stage
op_assign
id|tape-&gt;last_stage
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;pipeline_was_full_once
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;error_in_pipeline_stage
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;pipeline_locked
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;request_status
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;request_dsc_callback
op_assign
l_int|0
suffix:semicolon
macro_line|#if IDETAPE_PIPELINE
id|tape-&gt;max_number_of_stages
op_assign
id|IDETAPE_MIN_PIPELINE_STAGES
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: Operating in pipelined (fast and tricky) write mode.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|tape-&gt;max_number_of_stages
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: Operating in non-pipelined (slow and safe) write mode.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_PIPELINE */
id|printk
(paren
l_string|&quot;ide-tape: Operating in non-pipelined (slow and safe) read mode.&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_get_mode_sense_results
(paren
id|drive
)paren
suffix:semicolon
id|tape-&gt;data_buffer_size
op_assign
id|tape-&gt;capabilities.ctl
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
id|allocation_length
op_assign
id|tape-&gt;data_buffer_size
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;data_buffer_size
op_mod
id|IDETAPE_ALLOCATION_BLOCK
)paren
id|allocation_length
op_add_assign
id|IDETAPE_ALLOCATION_BLOCK
suffix:semicolon
id|tape-&gt;data_buffer
op_assign
id|kmalloc
(paren
id|allocation_length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|tape-&gt;temp_data_buffer
op_assign
id|kmalloc
(paren
id|allocation_length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;data_buffer
op_eq
l_int|NULL
op_logical_or
id|tape-&gt;temp_data_buffer
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: FATAL - Can not allocate 2 buffers of %d bytes each&bslash;n&quot;
comma
id|allocation_length
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: Aborting character device installation&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_drive_already_found
op_assign
l_int|0
suffix:semicolon
id|unregister_chrdev
(paren
id|idetape_chrdev.major
comma
id|idetape_chrdev.name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;ide-tape: Tape speed - %d KBps. Recommended transfer unit - %d bytes.&bslash;n&quot;
comma
id|tape-&gt;capabilities.speed
comma
id|tape-&gt;data_buffer_size
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_get_mode_sense_results asks the tape about its various&n; *&t;parameters. In particular, we will adjust our data transfer buffer&n; *&t;size to the recommended value as returned by the tape.&n; */
DECL|function|idetape_get_mode_sense_results
r_void
id|idetape_get_mode_sense_results
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|retval
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_mode_parameter_header_t
op_star
id|header
suffix:semicolon
id|idetape_capabilities_page_t
op_star
id|capabilities
suffix:semicolon
id|idetape_packet_command_t
id|pc
suffix:semicolon
id|idetape_create_mode_sense_cmd
(paren
op_amp
id|pc
comma
id|IDETAPE_CAPABILITIES_PAGE
)paren
suffix:semicolon
id|pc.buffer
op_assign
id|pc.temp_buffer
suffix:semicolon
id|pc.buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc.current_position
op_assign
id|pc.temp_buffer
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
id|header
op_assign
(paren
id|idetape_mode_parameter_header_t
op_star
)paren
id|pc.buffer
suffix:semicolon
id|capabilities
op_assign
(paren
id|idetape_capabilities_page_t
op_star
)paren
(paren
id|pc.buffer
op_plus
r_sizeof
(paren
id|idetape_mode_parameter_header_t
)paren
)paren
suffix:semicolon
id|capabilities-&gt;max_speed
op_assign
id|idetape_swap_short
(paren
id|capabilities-&gt;max_speed
)paren
suffix:semicolon
id|capabilities-&gt;ctl
op_assign
id|idetape_swap_short
(paren
id|capabilities-&gt;ctl
)paren
suffix:semicolon
id|capabilities-&gt;speed
op_assign
id|idetape_swap_short
(paren
id|capabilities-&gt;speed
)paren
suffix:semicolon
id|capabilities-&gt;buffer_size
op_assign
id|idetape_swap_short
(paren
id|capabilities-&gt;buffer_size
)paren
suffix:semicolon
id|tape-&gt;capabilities
op_assign
op_star
id|capabilities
suffix:semicolon
multiline_comment|/* Save us a copy */
id|tape-&gt;tape_block_size
op_assign
id|capabilities-&gt;blk512
ques
c_cond
l_int|512
suffix:colon
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Can&squot;t get tape parameters&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: Assuming some default parameters&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;tape_block_size
op_assign
l_int|512
suffix:semicolon
id|tape-&gt;capabilities.ctl
op_assign
l_int|26
op_star
l_int|1024
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Dumping the results of the MODE SENSE packet command&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Mode Parameter Header:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Mode Data Length - %d&bslash;n&quot;
comma
id|header-&gt;mode_data_length
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Medium Type - %d&bslash;n&quot;
comma
id|header-&gt;medium_type
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Device Specific Parameter - %d&bslash;n&quot;
comma
id|header-&gt;dsp
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Block Descriptor Length - %d&bslash;n&quot;
comma
id|header-&gt;bdl
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Capabilities and Mechanical Status Page:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Page code - %d&bslash;n&quot;
comma
id|capabilities-&gt;page_code
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Page length - %d&bslash;n&quot;
comma
id|capabilities-&gt;page_length
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Read only - %s&bslash;n&quot;
comma
id|capabilities-&gt;ro
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports reverse space - %s&bslash;n&quot;
comma
id|capabilities-&gt;sprev
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports erase initiated formatting - %s&bslash;n&quot;
comma
id|capabilities-&gt;efmt
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports QFA two Partition format - %s&bslash;n&quot;
comma
id|capabilities-&gt;qfa
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports locking the medium - %s&bslash;n&quot;
comma
id|capabilities-&gt;lock
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;The volume is currently locked - %s&bslash;n&quot;
comma
id|capabilities-&gt;locked
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;The device defaults in the prevent state - %s&bslash;n&quot;
comma
id|capabilities-&gt;prevent
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports ejecting the medium - %s&bslash;n&quot;
comma
id|capabilities-&gt;eject
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports error correction - %s&bslash;n&quot;
comma
id|capabilities-&gt;ecc
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports data compression - %s&bslash;n&quot;
comma
id|capabilities-&gt;cmprs
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports 512 bytes block size - %s&bslash;n&quot;
comma
id|capabilities-&gt;blk512
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports 1024 bytes block size - %s&bslash;n&quot;
comma
id|capabilities-&gt;blk1024
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Restricted byte count for PIO transfers - %s&bslash;n&quot;
comma
id|capabilities-&gt;slowb
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Maximum supported speed in KBps - %d&bslash;n&quot;
comma
id|capabilities-&gt;max_speed
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Continuous transfer limits in blocks - %d&bslash;n&quot;
comma
id|capabilities-&gt;ctl
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Current speed in KBps - %d&bslash;n&quot;
comma
id|capabilities-&gt;speed
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Buffer size - %d&bslash;n&quot;
comma
id|capabilities-&gt;buffer_size
op_star
l_int|512
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
)brace
multiline_comment|/*&n; *&t;Packet Command Interface&n; *&n; *&t;The current Packet Command is available in tape-&gt;pc, and will not&n; *&t;change until we finish handling it. Each packet command is associated&n; *&t;with a callback function that will be called when the command is&n; *&t;finished.&n; *&n; *&t;The handling will be done in three stages:&n; *&n; *&t;1.&t;idetape_issue_packet_command will send the packet command to the&n; *&t;&t;drive, and will set the interrupt handler to idetape_pc_intr.&n; *&n; *&t;2.&t;On each interrupt, idetape_pc_intr will be called. This step&n; *&t;&t;will be repeated until the device signals us that no more&n; *&t;&t;interrupts will be issued.&n; *&n; *&t;3.&t;ATAPI Tape media access commands have immediate status with a&n; *&t;&t;delayed process. In case of a successfull initiation of a&n; *&t;&t;media access packet command, the DSC bit will be set when the&n; *&t;&t;actual execution of the command is finished. &n; *&t;&t;Since the tape drive will not issue an interrupt, we have to&n; *&t;&t;poll for this event. In this case, we define the request as&n; *&t;&t;&quot;low priority request&quot; by setting rq_status to&n; *&t;&t;IDETAPE_RQ_POSTPONED, &t;set a timer to poll for DSC and exit&n; *&t;&t;the driver.&n; *&n; *&t;&t;ide.c will then give higher priority to requests which&n; *&t;&t;originate from the other device, until will change rq_status&n; *&t;&t;to RQ_ACTIVE.&n; *&n; *&t;4.&t;When the packet command is finished, it will be checked for errors.&n; *&n; *&t;5.&t;In case an error was found, we queue a request sense packet command&n; *&t;&t;in front of the request queue and retry the operation up to&n; *&t;&t;IDETAPE_MAX_PC_RETRIES times.&n; *&n; *&t;6.&t;In case no error was found, or we decided to give up and not&n; *&t;&t;to retry again, the callback function will be called and then&n; *&t;&t;we will handle the next request.&n; *&n; */
DECL|function|idetape_issue_packet_command
r_void
id|idetape_issue_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_packet_command_t
op_star
id|pc
comma
id|ide_handler_t
op_star
id|handler
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
id|idetape_bcount_reg_t
id|bcount
suffix:semicolon
id|idetape_ireason_reg_t
id|ireason
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
r_if
c_cond
(paren
id|tape-&gt;pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_REQUEST_SENSE_CMD
op_logical_and
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_REQUEST_SENSE_CMD
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: ide-tape.c bug - Two request sense in serial were issued&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* ??? Need to rethink about that */
)brace
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
id|tape-&gt;failed_pc
op_eq
l_int|NULL
op_logical_and
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|IDETAPE_REQUEST_SENSE_CMD
)paren
id|tape-&gt;failed_pc
op_assign
id|pc
suffix:semicolon
id|tape-&gt;pc
op_assign
id|pc
suffix:semicolon
multiline_comment|/* Set the current packet command */
r_if
c_cond
(paren
id|pc-&gt;retries
OG
id|IDETAPE_MAX_PC_RETRIES
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: %s: I/O error, &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;pc = %x, key = %x, asc = %x, ascq = %x&bslash;n&quot;
comma
id|pc-&gt;c
(braket
l_int|0
)braket
comma
id|tape-&gt;sense_key
comma
id|tape-&gt;asc
comma
id|tape-&gt;ascq
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: Maximum retries reached - Giving up&bslash;n&quot;
)paren
suffix:semicolon
id|pc-&gt;error
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Giving up */
id|pc-&gt;active
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
r_if
c_cond
(paren
id|pc-&gt;callback
op_eq
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;ide-tape: ide-tape bug - Callback function not set !&bslash;n&quot;
)paren
suffix:semicolon
r_else
macro_line|#endif /* IDETAPE_DEBUG */
(paren
op_star
id|pc-&gt;callback
)paren
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Retry number - %d&bslash;n&quot;
comma
id|pc-&gt;retries
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|pc-&gt;retries
op_increment
suffix:semicolon
multiline_comment|/*&n; *&t;We no longer call ide_wait_stat to wait for the drive to be ready,&n; *&t;as ide.c already does this for us in do_request.&n; */
id|pc-&gt;actually_transferred
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We haven&squot;t transferred any data yet */
id|pc-&gt;active
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Packet command started */
id|bcount.all
op_assign
id|pc-&gt;request_transfer
suffix:semicolon
multiline_comment|/* Request to transfer the entire buffer at once */
multiline_comment|/* Initialize the task file registers */
id|OUT_BYTE
(paren
l_int|0
comma
id|IDETAPE_FEATURES_REG
)paren
suffix:semicolon
multiline_comment|/* Use PIO data transger, No DMA */
id|OUT_BYTE
(paren
id|bcount.b.high
comma
id|IDETAPE_BCOUNTH_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|bcount.b.low
comma
id|IDETAPE_BCOUNTL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|drive-&gt;select.all
comma
id|IDETAPE_DRIVESEL_REG
)paren
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|WAIT_CMD
)paren
suffix:semicolon
multiline_comment|/* Set the interrupt routine */
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|IDETAPE_ATACOMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* Issue the packet command */
r_if
c_cond
(paren
id|ide_wait_stat
(paren
id|drive
comma
id|DRQ_STAT
comma
id|BUSY_STAT
comma
id|WAIT_READY
)paren
)paren
(brace
multiline_comment|/* Wait for DRQ to be ready - Assuming Accelerated DRQ */
multiline_comment|/*&n;&t;&t; *&t;We currently only support tape drives which report&n;&t;&t; *&t;accelerated DRQ assertion. For this case, specs&n;&t;&t; *&t;allow up to 50us. We really shouldn&squot;t get here.&n;&t;&t; *&n;&t;&t; *&t;??? Still needs to think what to do if we reach&n;&t;&t; *&t;here anyway.&n;&t;&t; */
id|printk
(paren
l_string|&quot;ide-tape: Strange, packet command initiated yet DRQ isn&squot;t asserted&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ireason.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_IREASON_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ireason.b.cod
op_logical_or
id|ireason.b.io
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: (IO,CoD) != (0,1) while issuing a packet command&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* ??? */
)brace
id|ide_output_data
(paren
id|drive
comma
id|pc-&gt;c
comma
l_int|12
op_div
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Send the actual packet */
)brace
multiline_comment|/*&n; *&t;idetape_pc_intr is the usual interrupt handler which will be called&n; *&t;during a packet command. We will transfer some of the data (as&n; *&t;requested by the drive) and will re-point interrupt handler to us.&n; *&t;When data transfer is finished, we will act according to the&n; *&t;algorithm described before idetape_issue_packet_command.&n; *&n; */
DECL|function|idetape_pc_intr
r_void
id|idetape_pc_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
id|idetape_status_reg_t
id|status
suffix:semicolon
id|idetape_bcount_reg_t
id|bcount
suffix:semicolon
id|idetape_ireason_reg_t
id|ireason
suffix:semicolon
id|idetape_packet_command_t
op_star
id|pc
suffix:semicolon
r_int
r_int
id|temp
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|status.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* Clear the interrupt */
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_pc_intr interrupt handler&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */&t;
id|pc
op_assign
id|tape-&gt;pc
suffix:semicolon
multiline_comment|/* Current packet command */
r_if
c_cond
(paren
op_logical_neg
id|status.b.drq
)paren
(brace
multiline_comment|/* No more interrupts */
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Packet command completed&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Total bytes transferred: %lu&bslash;n&quot;
comma
id|pc-&gt;actually_transferred
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
id|status.b.check
)paren
(brace
multiline_comment|/* Error detected */
macro_line|#if IDETAPE_DEBUG
multiline_comment|/*&n;&t; *&t;Without debugging, we only log an error if we decided to&n;&t; *&t;give up retrying.&n;&t; */
id|printk
(paren
l_string|&quot;ide-tape: %s: I/O error, &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|idetape_retry_pc
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Retry operation */
r_return
suffix:semicolon
)brace
id|pc-&gt;error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pc-&gt;wait_for_dsc
op_logical_and
op_logical_neg
id|status.b.dsc
)paren
(brace
multiline_comment|/* Media access command */
id|tape-&gt;dsc_polling_frequency
op_assign
id|IDETAPE_DSC_FAST_MEDIA_ACCESS_FREQUENCY
suffix:semicolon
id|idetape_postpone_request
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Allow ide.c to handle other requests */
r_return
suffix:semicolon
)brace
id|pc-&gt;active
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;failed_pc
op_eq
id|pc
)paren
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
r_if
c_cond
(paren
id|pc-&gt;callback
op_eq
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;ide-tape: ide-tape bug - Callback function not set !&bslash;n&quot;
)paren
suffix:semicolon
r_else
macro_line|#endif /* IDETAPE_DEBUG */
(paren
op_star
id|pc-&gt;callback
)paren
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Command finished - Call the callback function */
r_return
suffix:semicolon
)brace
id|bcount.b.high
op_assign
id|IN_BYTE
(paren
id|IDETAPE_BCOUNTH_REG
)paren
suffix:semicolon
multiline_comment|/* Get the number of bytes to transfer */
id|bcount.b.low
op_assign
id|IN_BYTE
(paren
id|IDETAPE_BCOUNTL_REG
)paren
suffix:semicolon
multiline_comment|/* on this interrupt */
id|ireason.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_IREASON_REG
)paren
suffix:semicolon
multiline_comment|/* Read the interrupt reason register */
r_if
c_cond
(paren
id|ireason.b.cod
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: CoD != 0 in idetape_pc_intr&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* ??? */
)brace
r_if
c_cond
(paren
id|ireason.b.io
op_ne
op_logical_neg
(paren
id|pc-&gt;writing
)paren
)paren
(brace
multiline_comment|/* Hopefully, we will never get here */
id|printk
(paren
l_string|&quot;ide-tape: We wanted to %s, &quot;
comma
id|pc-&gt;writing
ques
c_cond
l_string|&quot;Write&quot;
suffix:colon
l_string|&quot;Read&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;but the tape wants us to %s !&bslash;n&quot;
comma
id|ireason.b.io
ques
c_cond
l_string|&quot;Read&quot;
suffix:colon
l_string|&quot;Write&quot;
)paren
suffix:semicolon
multiline_comment|/* ??? */
)brace
r_if
c_cond
(paren
op_logical_neg
id|pc-&gt;writing
)paren
(brace
multiline_comment|/* Reading - Check that we have enough space */
id|temp
op_assign
(paren
r_int
r_int
)paren
id|pc-&gt;actually_transferred
op_plus
id|bcount.all
suffix:semicolon
r_if
c_cond
(paren
id|temp
OG
id|pc-&gt;request_transfer
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: The tape wants to send us more data than requested - &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|temp
OG
id|pc-&gt;buffer_size
)paren
(brace
id|printk
(paren
l_string|&quot;Discarding data&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_discard_data
(paren
id|drive
comma
id|bcount.all
)paren
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|idetape_pc_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
id|printk
(paren
l_string|&quot;Allowing transfer&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#if IDETAPE_DEBUG&t;
r_if
c_cond
(paren
id|bcount.all
op_logical_and
op_logical_neg
id|pc-&gt;buffer
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: ide-tape.c bug - Buffer not set in idetape_pc_intr. Discarding data.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pc-&gt;writing
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Discarding data&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_discard_data
(paren
id|drive
comma
id|bcount.all
)paren
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|idetape_pc_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ??? */
)brace
)brace
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
id|pc-&gt;writing
)paren
id|idetape_output_data
(paren
id|drive
comma
id|pc-&gt;current_position
comma
id|bcount.all
)paren
suffix:semicolon
multiline_comment|/* Write the current buffer */
r_else
id|idetape_input_data
(paren
id|drive
comma
id|pc-&gt;current_position
comma
id|bcount.all
)paren
suffix:semicolon
multiline_comment|/* Read the current buffer */
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: %s %d bytes&bslash;n&quot;
comma
id|pc-&gt;writing
ques
c_cond
l_string|&quot;Wrote&quot;
suffix:colon
l_string|&quot;Received&quot;
comma
id|bcount.all
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|pc-&gt;actually_transferred
op_add_assign
id|bcount.all
suffix:semicolon
multiline_comment|/* Update the current position */
id|pc-&gt;current_position
op_add_assign
id|bcount.all
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|idetape_pc_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
multiline_comment|/* And set the interrupt handler again */
)brace
multiline_comment|/*&n; *&t;idetape_postpone_request postpones the current request so that&n; *&t;ide.c will be able to service requests from another device on&n; *&t;the same hwgroup while we are polling for DSC.&n; */
DECL|function|idetape_postpone_request
r_void
id|idetape_postpone_request
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|idetape_status_reg_t
id|status
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|status.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_STATUS_REG
)paren
suffix:semicolon
id|sti
(paren
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_postpone_request&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;postponed_rq
op_ne
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;ide-tape.c bug - postponed_rq not NULL in idetape_postpone_request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|tape-&gt;dsc_timer.expires
op_assign
id|jiffies
op_plus
id|tape-&gt;dsc_polling_frequency
suffix:semicolon
multiline_comment|/* Set timer to poll for */
id|tape-&gt;dsc_timeout
op_assign
id|jiffies
op_plus
id|IDETAPE_DSC_TIMEOUT
suffix:semicolon
multiline_comment|/* actual completion */
id|tape-&gt;dsc_timer.data
op_assign
(paren
r_int
r_int
)paren
id|drive
suffix:semicolon
id|tape-&gt;dsc_timer.function
op_assign
op_amp
id|idetape_poll_for_dsc
suffix:semicolon
id|init_timer
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove current request from the request queue:&n;&t; */
id|tape-&gt;postponed_rq
op_assign
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|rq-&gt;rq_status
op_assign
id|IDETAPE_RQ_POSTPONED
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
multiline_comment|/* Let ide.c handle another request */
id|blk_dev
(braket
id|MAJOR
c_func
(paren
id|rq-&gt;rq_dev
)paren
)braket
dot
id|current_request
op_assign
id|rq-&gt;next
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_assign
l_int|NULL
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|tape-&gt;request_status
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;request_dsc_callback
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;last_status
op_assign
id|status.all
suffix:semicolon
id|tape-&gt;dsc_polling_start
op_assign
id|jiffies
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
multiline_comment|/* Activate the polling timer */
)brace
multiline_comment|/*&n; *&t;idetape_poll_for_dsc_direct is called from idetape_poll_for_dsc&n; *&t;to handle the case in which we can safely communicate with the tape&n; *&t;(since no other request for this hwgroup is active).&n; */
DECL|function|idetape_poll_for_dsc_direct
r_void
id|idetape_poll_for_dsc_direct
(paren
r_int
r_int
id|data
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|data
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
(paren
id|drive
)paren
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_status_reg_t
id|status
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;%s: idetape_poll_for_dsc_direct called&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */&t;
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|status.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwgroup-&gt;drive
op_ne
l_int|NULL
)paren
id|OUT_BYTE
(paren
id|hwgroup-&gt;drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status.b.dsc
)paren
(brace
multiline_comment|/* DSC received */
id|tape-&gt;dsc_received
op_assign
l_int|1
suffix:semicolon
id|del_timer
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
multiline_comment|/* Stop polling and put back the postponed */
id|idetape_put_back_postponed_request
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* request in the request queue */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|jiffies
OG
id|tape-&gt;dsc_timeout
)paren
(brace
multiline_comment|/* Timeout */
id|tape-&gt;dsc_received
op_assign
l_int|0
suffix:semicolon
id|del_timer
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
multiline_comment|/* ??? */
id|idetape_put_back_postponed_request
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Poll again */
r_if
c_cond
(paren
id|jiffies
op_minus
id|tape-&gt;dsc_polling_start
OG
id|IDETAPE_FAST_SLOW_THRESHOLD
)paren
id|tape-&gt;dsc_timer.expires
op_assign
id|jiffies
op_plus
id|IDETAPE_DSC_SLOW_MEDIA_ACCESS_FREQUENCY
suffix:semicolon
r_else
id|tape-&gt;dsc_timer.expires
op_assign
id|jiffies
op_plus
id|tape-&gt;dsc_polling_frequency
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_poll_for_dsc gets invoked by a timer (which was set&n; *&t;by idetape_postpone_request) to poll for the DSC bit&n; *&t;in the status register.&n; *&n; *&t;We take care not to perform any tape access and not to touch the&n; *&t;device request queue if the driver is accessing the other device.&n; *&t;We will instead ask ide.c to perform those functions on the next&n; *&t;call to do_request, at the point in which the other device is idle.&n; *&n; *&t;However, in case the other device is already idle, we will read&n; *&t;the status register from our timer handler.&n; *&n; *&t;I am also a bit paranoid with the use of cli (), all through the&n; *&t;code. I still need to think harder about each one whether we can&n; *&t;avoid it and still be free of race conditions ...&n; */
DECL|function|idetape_poll_for_dsc
r_void
id|idetape_poll_for_dsc
(paren
r_int
r_int
id|data
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|data
suffix:semicolon
r_int
r_int
id|major
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_struct
id|blk_dev_struct
op_star
id|bdev
op_assign
op_amp
id|blk_dev
(braket
id|major
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|idetape_status_reg_t
id|status
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;%s: idetape_poll_for_dsc called&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */&t;
multiline_comment|/*&n;&t; *&t;Check if the other device is idle. If there are no requests,&n;&t; *&t;we can safely access the tape.&n;&t; */
r_if
c_cond
(paren
id|bdev-&gt;current_request
op_eq
l_int|NULL
)paren
(brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|idetape_poll_for_dsc_direct
(paren
id|data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bdev-&gt;current_request-&gt;next
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;There will not be another request after the currently&n;&t;&t; *&t;ongoing request, so ide.c won&squot;t be able to sample&n;&t;&t; *&t;the status register on our behalf in do_request. Just&n;&t;&t; *&t;give up and poll again (in a faster frequency), until&n;&t;&t; *&t;we are lucky.&n;&t;&t; */
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|tape-&gt;dsc_timer.expires
op_assign
id|jiffies
op_plus
id|tape-&gt;dsc_polling_frequency
op_div
l_int|2
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;We now know that:&n;&t; *&n;&t; *&t;&t;1.&t;The ide driver is potentially accessing&n;&t; *&t;&t;&t;the other device -- We can not touch it.&n;&t; *&t;&t;2.&t;do_request will be called after the current&n;&t; *&t;&t;&t;request is finished.&n;&t; *&n;&t; *&t;We will therefor ask ide.c to perform the tasks on our behalf.&n;&t; */
id|status.all
op_assign
id|tape-&gt;last_status
suffix:semicolon
r_if
c_cond
(paren
id|status.b.dsc
)paren
(brace
multiline_comment|/* DSC received */
id|tape-&gt;dsc_received
op_assign
l_int|1
suffix:semicolon
id|del_timer
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
multiline_comment|/* Stop polling and request ide.c to call */
id|tape-&gt;request_dsc_callback
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* our idetape_put_back_postponed_request later */
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|jiffies
OG
id|tape-&gt;dsc_timeout
)paren
(brace
multiline_comment|/* Timeout */
id|tape-&gt;dsc_received
op_assign
l_int|1
suffix:semicolon
id|del_timer
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
multiline_comment|/* ??? */
id|tape-&gt;request_dsc_callback
op_assign
l_int|1
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Request ide.c to sample for us the tape&squot;s status register on&n;&t; *&t;the next time in which it can be safely done.&n;&t; */
id|tape-&gt;request_status
op_assign
l_int|1
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Poll again */
r_if
c_cond
(paren
id|jiffies
op_minus
id|tape-&gt;dsc_polling_start
OG
id|IDETAPE_FAST_SLOW_THRESHOLD
)paren
id|tape-&gt;dsc_timer.expires
op_assign
id|jiffies
op_plus
id|IDETAPE_DSC_SLOW_MEDIA_ACCESS_FREQUENCY
suffix:semicolon
r_else
id|tape-&gt;dsc_timer.expires
op_assign
id|jiffies
op_plus
id|tape-&gt;dsc_polling_frequency
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_put_back_postponed_request gets called by do_request&n; *&t;in ide.c when we decided to stop polling for DSC and continue&n; *&t;servicing our postponed request.&n; */
DECL|function|idetape_put_back_postponed_request
r_void
id|idetape_put_back_postponed_request
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Putting back postponed request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
id|tape-&gt;postponed_rq
comma
id|ide_next
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * &t;Note that the procedure done here is differnet than the method&n;&t; *&t;we are using in idetape_queue_pc_head - There we are putting&n;&t; *&t;request(s) before our currently called request.&n;&t; *&n;&t; *&t;Here, on the other hand, HWGROUP(drive)-&gt;rq is not our&n;&t; *&t;request but rather a request to another device. Therefore,&n;&t; *&t;we will let it finish and only then service our postponed&n;&t; *&t;request --&gt; We don&squot;t touch HWGROUP(drive)-&gt;rq.&n;&t; */
)brace
DECL|function|idetape_media_access_finished
r_void
id|idetape_media_access_finished
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_status_reg_t
id|status
suffix:semicolon
id|idetape_packet_command_t
op_star
id|pc
suffix:semicolon
id|pc
op_assign
id|tape-&gt;pc
suffix:semicolon
id|status.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;dsc_received
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;DSC received&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|pc-&gt;active
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|status.b.check
)paren
(brace
multiline_comment|/* Error detected */
id|printk
(paren
l_string|&quot;ide-tape: %s: I/O error, &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|idetape_retry_pc
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Retry operation */
r_return
suffix:semicolon
)brace
id|pc-&gt;error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;failed_pc
op_eq
id|pc
)paren
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
r_if
c_cond
(paren
id|pc-&gt;callback
op_eq
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;ide-tape: ide-tape bug - Callback function not set !&bslash;n&quot;
)paren
suffix:semicolon
r_else
macro_line|#endif /* IDETAPE_DEBUG */
(paren
op_star
id|pc-&gt;callback
)paren
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|pc-&gt;active
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: %s: DSC timeout.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
multiline_comment|/* ??? */
id|pc-&gt;error
op_assign
l_int|1
suffix:semicolon
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
r_if
c_cond
(paren
id|pc-&gt;callback
op_eq
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;ide-tape: ide-tape bug - Callback function not set !&bslash;n&quot;
)paren
suffix:semicolon
r_else
macro_line|#endif /* IDETAPE_DEBUG */
(paren
op_star
id|pc-&gt;callback
)paren
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;idetape_retry_pc is called when an error was detected during the&n; *&t;last packet command. We queue a request sense packet command in&n; *&t;the head of the request list.&n; */
DECL|function|idetape_retry_pc
r_void
id|idetape_retry_pc
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_packet_command_t
op_star
id|pc
suffix:semicolon
r_struct
id|request
op_star
id|new_rq
suffix:semicolon
id|idetape_error_reg_t
id|error
suffix:semicolon
id|error.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_ERROR_REG
)paren
suffix:semicolon
id|pc
op_assign
id|idetape_next_pc_storage
(paren
id|drive
)paren
suffix:semicolon
id|new_rq
op_assign
id|idetape_next_rq_storage
(paren
id|drive
)paren
suffix:semicolon
id|idetape_create_request_sense_cmd
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;buffer
op_assign
id|pc-&gt;temp_buffer
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc-&gt;current_position
op_assign
id|pc-&gt;temp_buffer
suffix:semicolon
id|idetape_queue_pc_head
(paren
id|drive
comma
id|pc
comma
id|new_rq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;General packet command callback function.&n; */
DECL|function|idetape_pc_callback
r_void
id|idetape_pc_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_pc_callback&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;pc-&gt;error
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Request completed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|idetape_end_request
(paren
l_int|1
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;Aborting request&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|idetape_read_callback
r_void
id|idetape_read_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG&t;
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_read_callback&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|tape-&gt;block_address
op_add_assign
id|tape-&gt;pc-&gt;actually_transferred
op_div
id|tape-&gt;tape_block_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;pc-&gt;error
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Request completed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|rq-&gt;sector
op_add_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|rq-&gt;nr_sectors
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_assign
l_int|0
suffix:semicolon
id|idetape_end_request
(paren
l_int|1
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;Aborting request&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|idetape_write_callback
r_void
id|idetape_write_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG&t;
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_write_callback&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|tape-&gt;block_address
op_add_assign
id|tape-&gt;pc-&gt;actually_transferred
op_div
id|tape-&gt;tape_block_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;pc-&gt;error
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Request completed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|rq-&gt;sector
op_add_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|rq-&gt;nr_sectors
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_assign
l_int|0
suffix:semicolon
id|idetape_end_request
(paren
l_int|1
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;Aborting request&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|idetape_inquiry_callback
r_void
id|idetape_inquiry_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_display_inquiry_result
(paren
id|tape-&gt;pc-&gt;buffer
)paren
suffix:semicolon
id|idetape_pc_callback
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_input_data is called to read data from the tape&squot;s data&n; *&t;register. We basically let ide_input_data do the job, but we also&n; *&t;take care about the remaining bytes which can not be transferred&n; *&t;in 32-bit data transfers.&n; */
DECL|function|idetape_input_data
r_void
id|idetape_input_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bcount
)paren
(brace
r_int
r_int
id|wcount
suffix:semicolon
id|wcount
op_assign
id|bcount
op_rshift
l_int|2
suffix:semicolon
id|bcount
op_sub_assign
l_int|4
op_star
id|wcount
suffix:semicolon
r_if
c_cond
(paren
id|wcount
)paren
id|ide_input_data
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcount
)paren
(brace
(paren
(paren
id|byte
op_star
)paren
id|buffer
)paren
op_add_assign
l_int|4
op_star
id|wcount
suffix:semicolon
id|insb
(paren
id|IDETAPE_DATA_REG
comma
id|buffer
comma
id|bcount
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;idetape_output_data is used to write data to the tape.&n; */
DECL|function|idetape_output_data
r_void
id|idetape_output_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bcount
)paren
(brace
r_int
r_int
id|wcount
suffix:semicolon
id|wcount
op_assign
id|bcount
op_rshift
l_int|2
suffix:semicolon
id|bcount
op_sub_assign
l_int|4
op_star
id|wcount
suffix:semicolon
r_if
c_cond
(paren
id|wcount
)paren
id|ide_output_data
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcount
)paren
(brace
(paren
(paren
id|byte
op_star
)paren
id|buffer
)paren
op_add_assign
l_int|4
op_star
id|wcount
suffix:semicolon
id|outsb
(paren
id|IDETAPE_DATA_REG
comma
id|buffer
comma
id|bcount
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Too bad. The drive wants to send us data which we are not ready to accept.&n; *&t;Just throw it away.&n; */
DECL|function|idetape_discard_data
r_void
id|idetape_discard_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|bcount
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bcount
suffix:semicolon
id|i
op_increment
)paren
id|IN_BYTE
(paren
id|IDETAPE_DATA_REG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Issue an INQUIRY packet command.&n; */
DECL|function|idetape_create_inquiry_cmd
r_void
id|idetape_create_inquiry_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Creating INQUIRY packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */&t;
id|pc-&gt;request_transfer
op_assign
l_int|36
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_inquiry_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_INQUIRY_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Format the INQUIRY command results.&n; */
DECL|function|idetape_display_inquiry_result
r_void
id|idetape_display_inquiry_result
(paren
id|byte
op_star
id|buffer
)paren
(brace
id|idetape_inquiry_result_t
op_star
id|result
suffix:semicolon
id|result
op_assign
(paren
id|idetape_inquiry_result_t
op_star
)paren
id|buffer
suffix:semicolon
id|ide_fixstring
(paren
id|result-&gt;vendor_id
comma
l_int|8
comma
l_int|0
)paren
suffix:semicolon
id|ide_fixstring
(paren
id|result-&gt;product_id
comma
l_int|16
comma
l_int|0
)paren
suffix:semicolon
id|ide_fixstring
(paren
id|result-&gt;revision_level
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result-&gt;response_format
op_ne
l_int|2
)paren
(brace
id|printk
(paren
l_string|&quot;The INQUIRY Data Format is unknown to us !&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Assuming QIC-157C format.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Dumping INQUIRY command results:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Response Data Format: %d - &quot;
comma
id|result-&gt;response_format
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result-&gt;response_format
)paren
(brace
r_case
l_int|2
suffix:colon
id|printk
(paren
l_string|&quot;As specified in QIC-157 Revision C&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Unknown&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Device Type: %x - &quot;
comma
id|result-&gt;device_type
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result-&gt;device_type
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
(paren
l_string|&quot;Direct-access Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
(paren
l_string|&quot;Streaming Tape Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
r_case
l_int|4
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printk
(paren
l_string|&quot;CD-ROM Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_case
l_int|7
suffix:colon
id|printk
(paren
l_string|&quot;Optical memory Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1f
suffix:colon
id|printk
(paren
l_string|&quot;Unknown or no Device type&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Removable Medium: %s&quot;
comma
id|result-&gt;rmb
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ANSI Version: %d - &quot;
comma
id|result-&gt;ansi_version
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result-&gt;ansi_version
)paren
(brace
r_case
l_int|2
suffix:colon
id|printk
(paren
l_string|&quot;QIC-157 Revision C&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Unknown&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;ECMA Version: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result-&gt;ecma_version
)paren
id|printk
(paren
l_string|&quot;%d&bslash;n&quot;
comma
id|result-&gt;ecma_version
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ISO Version: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result-&gt;iso_version
)paren
id|printk
(paren
l_string|&quot;%d&bslash;n&quot;
comma
id|result-&gt;iso_version
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Additional Length: %d&bslash;n&quot;
comma
id|result-&gt;additional_length
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Vendor Identification: %s&bslash;n&quot;
comma
id|result-&gt;vendor_id
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Product Identification: %s&bslash;n&quot;
comma
id|result-&gt;product_id
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Product Revision Level: %s&bslash;n&quot;
comma
id|result-&gt;revision_level
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
id|result-&gt;device_type
op_ne
l_int|1
)paren
id|printk
(paren
l_string|&quot;Device type is not set to tape&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result-&gt;rmb
)paren
id|printk
(paren
l_string|&quot;The removable flag is not set&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result-&gt;ansi_version
op_ne
l_int|2
)paren
(brace
id|printk
(paren
l_string|&quot;The Ansi Version is unknown to us !&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Assuming compliance with QIC-157C specification.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|idetape_create_request_sense_cmd
r_void
id|idetape_create_request_sense_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Creating REQUEST SENSE packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */&t;
id|pc-&gt;request_transfer
op_assign
l_int|18
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_request_sense_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_REQUEST_SENSE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
)brace
DECL|function|idetape_request_sense_callback
r_void
id|idetape_request_sense_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_request_sense_callback&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;pc-&gt;error
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Request completed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|idetape_analyze_error
(paren
id|drive
comma
(paren
id|idetape_request_sense_result_t
op_star
)paren
id|tape-&gt;pc-&gt;buffer
)paren
suffix:semicolon
id|idetape_end_request
(paren
l_int|1
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;Error in REQUEST SENSE itself - Aborting request!&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_analyze_error is called on each failed packet command retry&n; *&t;to analyze the request sense. We currently do not utilize this&n; *&t;information.&n; */
DECL|function|idetape_analyze_error
r_void
id|idetape_analyze_error
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_request_sense_result_t
op_star
id|result
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|tape-&gt;sense_key
op_assign
id|result-&gt;sense_key
suffix:semicolon
id|tape-&gt;asc
op_assign
id|result-&gt;asc
suffix:semicolon
id|tape-&gt;ascq
op_assign
id|result-&gt;ascq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG&t;
multiline_comment|/*&n;&t; *&t;Without debugging, we only log an error if we decided to&n;&t; *&t;give up retrying.&n;&t; */
id|printk
(paren
l_string|&quot;ide-tape: sense key = %x, asc = %x, ascq = %x&bslash;n&quot;
comma
id|result-&gt;sense_key
comma
id|result-&gt;asc
comma
id|result-&gt;ascq
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */&t;
r_return
suffix:semicolon
)brace
DECL|function|idetape_create_test_unit_ready_cmd
r_void
id|idetape_create_test_unit_ready_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Creating TEST UNIT READY packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */&t;
id|pc-&gt;request_transfer
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;current_position
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_TEST_UNIT_READY_CMD
suffix:semicolon
)brace
DECL|function|idetape_create_locate_cmd
r_void
id|idetape_create_locate_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
r_int
id|block
comma
id|byte
id|partition
)paren
(brace
r_int
r_int
op_star
id|ptr
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Creating LOCATE packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|pc-&gt;request_transfer
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;current_position
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_LOCATE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|pc-&gt;c
(braket
l_int|3
)braket
)paren
suffix:semicolon
op_star
id|ptr
op_assign
id|idetape_swap_long
(paren
id|block
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|8
)braket
op_assign
id|partition
suffix:semicolon
)brace
DECL|function|idetape_create_rewind_cmd
r_void
id|idetape_create_rewind_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Creating REWIND packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|pc-&gt;request_transfer
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;current_position
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_REWIND_CMD
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A mode sense command is used to &quot;sense&quot; tape parameters.&n; */
DECL|function|idetape_create_mode_sense_cmd
r_void
id|idetape_create_mode_sense_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
id|byte
id|page_code
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Creating MODE SENSE packet command - Page %d&bslash;n&quot;
comma
id|page_code
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|pc-&gt;wait_for_dsc
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|page_code
)paren
(brace
r_case
id|IDETAPE_CAPABILITIES_PAGE
suffix:colon
id|pc-&gt;request_transfer
op_assign
l_int|24
suffix:semicolon
)brace
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_MODE_SENSE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* DBD = 1 - Don&squot;t return block descriptors for now */
id|pc-&gt;c
(braket
l_int|2
)braket
op_assign
id|page_code
suffix:semicolon
id|pc-&gt;c
(braket
l_int|3
)braket
op_assign
l_int|255
suffix:semicolon
multiline_comment|/* Don&squot;t limit the returned information */
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
multiline_comment|/* (We will just discard data in that case) */
)brace
multiline_comment|/*&n; *&t;idetape_create_write_filemark_cmd will:&n; *&n; *&t;&t;1.&t;Write a filemark if write_filemark=1.&n; *&t;&t;2.&t;Flush the device buffers without writing a filemark&n; *&t;&t;&t;if write_filemark=0.&n; *&n; */
DECL|function|idetape_create_write_filemark_cmd
r_void
id|idetape_create_write_filemark_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
id|write_filemark
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Creating WRITE FILEMARK packet command&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|write_filemark
)paren
id|printk
(paren
l_string|&quot;which will only flush buffered data&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|pc-&gt;request_transfer
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;current_position
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_WRITE_FILEMARK_CMD
suffix:semicolon
r_if
c_cond
(paren
id|write_filemark
)paren
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|idetape_create_erase_cmd
r_void
id|idetape_create_erase_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Creating ERASE command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|pc-&gt;request_transfer
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;current_position
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_ERASE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|idetape_create_read_cmd
r_void
id|idetape_create_read_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
r_int
id|length
)paren
(brace
r_union
id|convert
(brace
r_int
id|all
suffix:colon
l_int|32
suffix:semicolon
r_struct
(brace
r_int
id|b1
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b2
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b3
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b4
suffix:colon
l_int|8
suffix:semicolon
)brace
id|b
suffix:semicolon
)brace
id|original
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Creating READ packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|original.all
op_assign
id|length
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_read_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_READ_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|original.b.b1
suffix:semicolon
id|pc-&gt;c
(braket
l_int|3
)braket
op_assign
id|original.b.b2
suffix:semicolon
id|pc-&gt;c
(braket
l_int|2
)braket
op_assign
id|original.b.b3
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|idetape_create_space_cmd
r_void
id|idetape_create_space_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
id|count
comma
id|byte
id|cmd
)paren
(brace
r_union
id|convert
(brace
r_int
id|all
suffix:colon
l_int|32
suffix:semicolon
r_struct
(brace
r_int
id|b1
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b2
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b3
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b4
suffix:colon
l_int|8
suffix:semicolon
)brace
id|b
suffix:semicolon
)brace
id|original
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Creating SPACE packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|original.all
op_assign
id|count
suffix:semicolon
id|pc-&gt;request_transfer
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;current_position
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_SPACE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
id|cmd
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|original.b.b1
suffix:semicolon
id|pc-&gt;c
(braket
l_int|3
)braket
op_assign
id|original.b.b2
suffix:semicolon
id|pc-&gt;c
(braket
l_int|2
)braket
op_assign
id|original.b.b3
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|idetape_create_write_cmd
r_void
id|idetape_create_write_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
r_int
id|length
)paren
(brace
r_union
id|convert
(brace
r_int
id|all
suffix:colon
l_int|32
suffix:semicolon
r_struct
(brace
r_int
id|b1
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b2
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b3
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b4
suffix:colon
l_int|8
suffix:semicolon
)brace
id|b
suffix:semicolon
)brace
id|original
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Creating WRITE packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|original.all
op_assign
id|length
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_write_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|1
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_WRITE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|original.b.b1
suffix:semicolon
id|pc-&gt;c
(braket
l_int|3
)braket
op_assign
id|original.b.b2
suffix:semicolon
id|pc-&gt;c
(braket
l_int|2
)braket
op_assign
id|original.b.b3
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|idetape_create_read_position_cmd
r_void
id|idetape_create_read_position_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Creating READ POSITION packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|pc-&gt;request_transfer
op_assign
l_int|20
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_read_position_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_READ_POSITION_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|idetape_read_position_callback
r_void
id|idetape_read_position_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|idetape_read_position_result_t
op_star
id|result
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_read_position_callback&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;pc-&gt;error
)paren
(brace
id|result
op_assign
(paren
id|idetape_read_position_result_t
op_star
)paren
id|tape-&gt;pc-&gt;buffer
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Request completed&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Dumping the results of the READ POSITION command&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;BOP - %s&bslash;n&quot;
comma
id|result-&gt;bop
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;EOP - %s&bslash;n&quot;
comma
id|result-&gt;eop
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
id|result-&gt;bpu
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Block location is unknown to the tape&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Aborting request&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;block_address_valid
op_assign
l_int|0
suffix:semicolon
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Block Location - %lu&bslash;n&quot;
comma
id|idetape_swap_long
(paren
id|result-&gt;first_block
)paren
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|tape-&gt;block_address
op_assign
id|idetape_swap_long
(paren
id|result-&gt;first_block
)paren
suffix:semicolon
id|tape-&gt;block_address_valid
op_assign
l_int|1
suffix:semicolon
id|idetape_end_request
(paren
l_int|1
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;Aborting request&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Our special ide-tape ioctl&squot;s.&n; *&n; *&t;Currently there aren&squot;t any significant ioctl&squot;s.&n; *&t;mtio.h compatible commands should be issued to the character device&n; *&t;interface.&n; */
DECL|function|idetape_blkdev_ioctl
r_int
id|idetape_blkdev_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|idetape_packet_command_t
id|pc
suffix:semicolon
r_int
id|retval
suffix:semicolon
id|pc.buffer
op_assign
id|pc.temp_buffer
suffix:semicolon
id|pc.buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc.current_position
op_assign
id|pc.temp_buffer
suffix:semicolon
macro_line|#if IDETAPE_DEBUG&t;
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_blkdev_ioctl&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|IDETAPE_INQUIRY_IOCTL
suffix:colon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Adding INQUIRY packet command to the tail of the request queue&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|idetape_create_inquiry_cmd
(paren
op_amp
id|pc
)paren
suffix:semicolon
id|pc.buffer
op_assign
id|pc.temp_buffer
suffix:semicolon
id|pc.buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc.current_position
op_assign
id|pc.temp_buffer
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|IDETAPE_LOCATE_IOCTL
suffix:colon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Adding LOCATE packet command to the tail of the request queue&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|idetape_create_locate_cmd
(paren
op_amp
id|pc
comma
id|arg
comma
l_int|0
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|0
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|idetape_create_read_position_cmd
(paren
op_amp
id|pc
)paren
suffix:semicolon
id|pc.buffer
op_assign
id|pc.temp_buffer
suffix:semicolon
id|pc.buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc.current_position
op_assign
id|pc.temp_buffer
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;case IDETAPE_RESET_IOCTL:&n;&t;&t;&t;printk (&quot;Resetting drive&bslash;n&quot;);&n;&t;&t;&t;return (!ide_do_reset (drive));&n;*/
r_default
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Functions which handle requests.&n; */
multiline_comment|/*&n; *&t;idetape_end_request is used to end a request.&n; *&n; *&t;It is very similiar to ide_end_request, with a major difference - If&n; *&t;we are handling our own requests rather than requests which originate&n; *&t;in the buffer cache, we set rq-&gt;errors to 1 if the request failed.&n; */
DECL|function|idetape_end_request
r_void
id|idetape_end_request
(paren
id|byte
id|uptodate
comma
id|ide_hwgroup_t
op_star
id|hwgroup
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|hwgroup-&gt;drive
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|hwgroup-&gt;rq
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
multiline_comment|/* Our own originated request */
id|rq-&gt;errors
op_assign
op_logical_neg
id|uptodate
suffix:semicolon
multiline_comment|/* rq-&gt;errors will tell us if the request was successfull */
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_eq
id|rq
)paren
(brace
multiline_comment|/* The request was a data transfer request */
macro_line|#if IDETAPE_DEBUG
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;max_number_of_stages
)paren
id|printk
(paren
l_string|&quot;ide-tape: non pipelined mode bug&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Finished our active data request&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Requests in pipeline: %d&bslash;n&quot;
comma
id|tape-&gt;current_number_of_stages
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
id|rq-&gt;errors
)paren
id|tape-&gt;error_in_pipeline_stage
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Pass to the next stage, but avoid a possible&n;&t;&t; *&t;race condition which could occur since&n;&t;&t; *&t;active_data_request is set to NULL until&n;&t;&t; *&t;idetape_active_next_stage returns, and in that&n;&t;&t; *&t;time, the higher level of the driver can get&n;&t;&t; *&t;an inaccurate sampling of this variable.&n;&t;&t; */
id|tape-&gt;pipeline_locked
op_assign
l_int|1
suffix:semicolon
id|tape-&gt;active_data_request
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_eq
l_int|NULL
)paren
(brace
id|tape-&gt;pipeline_locked
op_assign
l_int|0
suffix:semicolon
id|idetape_increase_max_pipeline_stages
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|idetape_active_next_stage
(paren
id|drive
)paren
suffix:semicolon
id|tape-&gt;pipeline_locked
op_assign
l_int|0
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Using ide_end&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
multiline_comment|/*&n;&t;&t; *&t;Insert the next request into the request queue.&n;&t;&t; *&n;&t;&t; *&t;We currently give higher priority to the other devie&n;&t;&t; *&t;by using ide_end. ide_next can be used to give us&n;&t;&t; *&t;a higher priority.&n;&t;&t; */
id|ide_do_drive_cmd
(paren
id|drive
comma
id|tape-&gt;active_data_request
comma
id|ide_end
)paren
suffix:semicolon
)brace
id|ide_end_drive_cmd
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_do_request is our request handling function.&t;&n; */
DECL|function|idetape_do_request
r_void
id|idetape_do_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_int
r_int
id|block
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_packet_command_t
op_star
id|pc
suffix:semicolon
id|idetape_status_reg_t
id|status
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Current request:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;rq_status: %d, rq_dev: %u, cmd: %d, errors: %d&bslash;n&quot;
comma
id|rq-&gt;rq_status
comma
(paren
r_int
r_int
)paren
id|rq-&gt;rq_dev
comma
id|rq-&gt;cmd
comma
id|rq-&gt;errors
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;sector: %ld, nr_sectors: %ld, current_nr_sectors: %ld&bslash;n&quot;
comma
id|rq-&gt;sector
comma
id|rq-&gt;nr_sectors
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
op_logical_neg
id|IDETAPE_REQUEST_CMD
(paren
id|rq-&gt;cmd
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We do not support buffer cache originated requests.&n;&t;&t; */
id|printk
(paren
l_string|&quot;ide-tape: Unsupported command in request queue&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: The block device interface should not be used for data transfers.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: Use the character device interfaces&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: /dev/ht0 and /dev/nht0 instead.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: (Run linux/drivers/block/MAKEDEV.ide to create them)&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: Aborting request.&bslash;n&quot;
)paren
suffix:semicolon
id|ide_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
multiline_comment|/* Let the common code handle it */
r_return
suffix:semicolon
)brace
multiline_comment|/* Retry a failed packet command */
r_if
c_cond
(paren
id|tape-&gt;failed_pc
op_ne
l_int|NULL
op_logical_and
id|tape-&gt;pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_REQUEST_SENSE_CMD
)paren
(brace
id|idetape_issue_packet_command
(paren
id|drive
comma
id|tape-&gt;failed_pc
comma
op_amp
id|idetape_pc_intr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check if we have a postponed request */
r_if
c_cond
(paren
id|tape-&gt;postponed_rq
op_ne
l_int|NULL
)paren
(brace
macro_line|#if IDETAPE_DEBUG
r_if
c_cond
(paren
id|tape-&gt;postponed_rq-&gt;rq_status
op_ne
id|RQ_ACTIVE
op_logical_or
id|rq
op_ne
id|tape-&gt;postponed_rq
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: ide-tape.c bug - Two DSC requests were queued&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE1
)paren
(brace
multiline_comment|/* Media access command */
id|tape-&gt;postponed_rq
op_assign
l_int|NULL
suffix:semicolon
id|idetape_media_access_finished
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Read / Write command - DSC polling was done before the&n;&t;&t; * actual command - Continue normally so that the command&n;&t;&t; * will be performed below.&n;&t;&t; */
id|tape-&gt;postponed_rq
op_assign
l_int|NULL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|rq-&gt;cmd
)paren
(brace
r_case
id|IDETAPE_READ_REQUEST
suffix:colon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Handling our own (not buffer cache originated) READ request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */&t;&t;&t;
id|status.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status.b.dsc
)paren
(brace
multiline_comment|/* Tape buffer not ready to accept r/w command */
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: DSC != 1 - Postponing read request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */&t;
id|tape-&gt;dsc_polling_frequency
op_assign
id|IDETAPE_DSC_READ_WRITE_FREQUENCY
suffix:semicolon
id|idetape_postpone_request
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Allow ide.c to process requests from */
r_return
suffix:semicolon
)brace
id|pc
op_assign
id|idetape_next_pc_storage
(paren
id|drive
)paren
suffix:semicolon
id|idetape_create_read_cmd
(paren
id|pc
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|pc-&gt;buffer
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
id|rq-&gt;current_nr_sectors
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
id|pc-&gt;current_position
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|pc-&gt;request_transfer
op_assign
id|rq-&gt;current_nr_sectors
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
id|idetape_issue_packet_command
(paren
id|drive
comma
id|pc
comma
op_amp
id|idetape_pc_intr
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|IDETAPE_WRITE_REQUEST
suffix:colon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Handling our own (not buffer cache originated) WRITE request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */&t;&t;&t;
id|status.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status.b.dsc
)paren
(brace
multiline_comment|/* Tape buffer not ready to accept r/w command */
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: DSC != 1 - Postponing write request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */&t;
id|tape-&gt;dsc_polling_frequency
op_assign
id|IDETAPE_DSC_READ_WRITE_FREQUENCY
suffix:semicolon
id|idetape_postpone_request
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Allow ide.c to process requests from */
r_return
suffix:semicolon
)brace
id|pc
op_assign
id|idetape_next_pc_storage
(paren
id|drive
)paren
suffix:semicolon
id|idetape_create_write_cmd
(paren
id|pc
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|pc-&gt;buffer
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
id|rq-&gt;current_nr_sectors
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
id|pc-&gt;current_position
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|pc-&gt;request_transfer
op_assign
id|rq-&gt;current_nr_sectors
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
id|idetape_issue_packet_command
(paren
id|drive
comma
id|pc
comma
op_amp
id|idetape_pc_intr
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE1
suffix:colon
r_case
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE2
suffix:colon
multiline_comment|/*&n; *&t;This should be unnecessary (postponing of a general packet command),&n; *&t;but I have occasionally missed DSC on a media access command otherwise.&n; *&t;??? Still have to figure it out ...&n; */
id|status.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|status.b.dsc
)paren
(brace
multiline_comment|/* Tape buffers are still not ready */
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: DSC != 1 - Postponing packet command request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|rq-&gt;cmd
op_assign
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE2
suffix:semicolon
multiline_comment|/* Note that we are waiting for DSC *before* we */
multiline_comment|/* even issued the command */
id|tape-&gt;dsc_polling_frequency
op_assign
id|IDETAPE_DSC_READ_WRITE_FREQUENCY
suffix:semicolon
id|idetape_postpone_request
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Allow ide.c to process requests from */
r_return
suffix:semicolon
)brace
id|rq-&gt;cmd
op_assign
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE1
suffix:semicolon
id|pc
op_assign
(paren
id|idetape_packet_command_t
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|idetape_issue_packet_command
(paren
id|drive
comma
id|pc
comma
op_amp
id|idetape_pc_intr
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
r_default
suffix:colon
id|printk
(paren
l_string|&quot;ide-tape: bug in IDETAPE_REQUEST_CMD macro&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
)brace
)brace
multiline_comment|/*&n; *&t;idetape_queue_pc_tail is based on the following functions:&n; *&n; *&t;ide_do_drive_cmd from ide.c&n; *&t;cdrom_queue_request and cdrom_queue_packet_command from ide-cd.c&n; *&n; *&t;We add a special packet command request to the tail of the request queue,&n; *&t;and wait for it to be serviced.&n; *&n; *&t;This is not to be called from within the request handling part&n; *&t;of the driver ! We allocate here data in the stack, and it is valid&n; *&t;until the request is finished. This is not the case for the bottom&n; *&t;part of the driver, where we are always leaving the functions to wait&n; *&t;for an interrupt or a timer event.&n; *&n; *&t;From the bottom part of the driver, we should allocate safe memory&n; *&t;using idetape_next_pc_storage and idetape_next_rq_storage, and add&n; *&t;the request to the request list without waiting for it to be serviced !&n; *&t;In that case, we usually use idetape_queue_pc_head.&n; */
DECL|function|idetape_queue_pc_tail
r_int
id|idetape_queue_pc_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|ide_init_drive_cmd
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
id|rq.cmd
op_assign
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE1
suffix:semicolon
r_return
id|ide_do_drive_cmd
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_queue_pc_head generates a new packet command request in front&n; *&t;of the request queue, before the current request, so that it will be&n; *&t;processed immediately, on the next pass through the driver.&n; *&n; *&t;idetape_queue_pc_head is called from the request handling part of&n; *&t;the driver (the &quot;bottom&quot; part). Safe storage for the request should&n; *&t;be allocated with idetape_next_pc_storage and idetape_next_rq_storage&n; *&t;before calling idetape_queue_pc_head.&n; *&n; *&t;Memory for those requests is pre-allocated at initialization time, and&n; *&t;is limited to IDETAPE_PC_STACK requests. We assume that we have enough&n; *&t;space for the maximum possible number of inter-dependent packet commands.&n; *&n; *&t;The higher level of the driver - The ioctl handler and the character&n; *&t;device handling functions should queue request to the lower level part&n; *&t;and wait for their completion using idetape_queue_pc_tail or&n; *&t;idetape_queue_rw_tail.&n; */
DECL|function|idetape_queue_pc_head
r_void
id|idetape_queue_pc_head
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_packet_command_t
op_star
id|pc
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
id|ide_init_drive_cmd
(paren
id|rq
)paren
suffix:semicolon
id|rq-&gt;buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
id|rq-&gt;cmd
op_assign
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE1
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
id|rq
comma
id|ide_preempt
)paren
suffix:semicolon
)brace
DECL|function|idetape_wait_for_request
r_void
id|idetape_wait_for_request
(paren
r_struct
id|request
op_star
id|rq
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|rq-&gt;sem
op_assign
op_amp
id|sem
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|down
(paren
op_amp
id|sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_queue_rw_tail is typically called from the character device&n; *&t;interface to generate a read/write request for the block device interface&n; *&t;and wait for it to be serviced. Note that cmd will be different than&n; *&t;a buffer cache originated read/write request. This will be used&n; *&t;in idetape_end_request.&n; *&n; *&t;Returns 0 on success or -EIO if an error occured.&n; */
DECL|function|idetape_queue_rw_tail
r_int
id|idetape_queue_rw_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|cmd
comma
r_int
id|blocks
comma
r_char
op_star
id|buffer
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_struct
id|request
id|rq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;idetape_queue_rw_tail: cmd=%d&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
multiline_comment|/* build up a special read request, and add it to the queue */
id|ide_init_drive_cmd
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.buffer
op_assign
id|buffer
suffix:semicolon
id|rq.cmd
op_assign
id|cmd
suffix:semicolon
id|rq.sector
op_assign
id|tape-&gt;block_address
suffix:semicolon
id|rq.nr_sectors
op_assign
id|blocks
suffix:semicolon
id|rq.current_nr_sectors
op_assign
id|blocks
suffix:semicolon
id|tape-&gt;active_data_request
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Non-pipelined mode */
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Using ide_tail&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_return
id|ide_do_drive_cmd
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_add_chrdev_write_request tries to add a character device&n; *&t;originated write request to our pipeline. In case we don&squot;t succeed,&n; *&t;we revert to non-piplined operation mode for this request.&n; *&n; *&t;1.&t;Try to allocate a new pipeline stage.&n; *&t;2.&t;If we can&squot;t, wait for more and more requests to be serviced&n; *&t;&t;and try again each time.&n; *&t;3.&t;If we still can&squot;t allocate a stage, fallback to&n; *&t;&t;non-pipelined operation mode for this request.&n; */
DECL|function|idetape_add_chrdev_write_request
r_int
id|idetape_add_chrdev_write_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|cmd
comma
r_int
id|blocks
comma
r_char
op_star
id|buffer
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_pipeline_stage_t
op_star
id|new_stage
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_add_chrdev_write_request&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Trying to allocate stage - &quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
id|tape-&gt;error_in_pipeline_stage
)paren
multiline_comment|/* Return a deferred error */
r_return
(paren
op_minus
id|EIO
)paren
suffix:semicolon
id|new_stage
op_assign
id|idetape_kmalloc_stage
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we don&squot;t have a new stage, wait for more and more requests&n;&t; *&t;to finish, and try to allocate after each one.&n;&t; *&n;&t; *&t;Pay special attention to possible race conditions.&n;&t; */
r_while
c_loop
(paren
id|new_stage
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Wait for the time in which we can safely inspect&n;&t;&t; *&t;tape-&gt;first_stage.&n;&t;&t; */
r_while
c_loop
(paren
id|tape-&gt;pipeline_locked
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_ne
l_int|NULL
)paren
(brace
id|idetape_wait_for_request
(paren
op_amp
(paren
id|tape-&gt;first_stage-&gt;rq
)paren
)paren
suffix:semicolon
id|new_stage
op_assign
id|idetape_kmalloc_stage
(paren
id|drive
)paren
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
multiline_comment|/* Linux is short on memory */
)brace
multiline_comment|/*&n;&t; *&t;If we don&squot;t have a new_stage, fallback to non-pipelined&n;&t; *&t;operation mode for this request.&n;&t; */
r_if
c_cond
(paren
id|new_stage
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_ne
l_int|NULL
)paren
id|idetape_wait_for_request
(paren
id|tape-&gt;active_data_request
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_rw_tail
(paren
id|drive
comma
id|cmd
comma
id|blocks
comma
id|buffer
)paren
)paren
suffix:semicolon
)brace
id|rq
op_assign
op_amp
(paren
id|new_stage-&gt;rq
)paren
suffix:semicolon
id|ide_init_drive_cmd
(paren
id|rq
)paren
suffix:semicolon
id|rq-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* We will correct this when we will actually service the request */
id|rq-&gt;cmd
op_assign
id|cmd
suffix:semicolon
id|rq-&gt;sector
op_assign
id|tape-&gt;block_address
suffix:semicolon
multiline_comment|/* Doesn&squot;t actually matter - We always assume sequential access */
id|rq-&gt;nr_sectors
op_assign
id|blocks
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_assign
id|blocks
suffix:semicolon
id|idetape_copy_buffer_to_stage
(paren
id|new_stage
comma
id|buffer
)paren
suffix:semicolon
id|idetape_add_stage_tail
(paren
id|drive
comma
id|new_stage
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|idetape_empty_pipeline
r_void
id|idetape_empty_pipeline
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|tape-&gt;pipeline_was_full_once
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|tape-&gt;pipeline_locked
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_eq
l_int|NULL
)paren
id|idetape_insert_pipeline_into_queue
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;last_stage
op_ne
l_int|NULL
)paren
id|idetape_wait_for_request
(paren
op_amp
(paren
id|tape-&gt;last_stage-&gt;rq
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_ne
l_int|NULL
)paren
id|idetape_wait_for_request
(paren
id|tape-&gt;active_data_request
)paren
suffix:semicolon
id|tape-&gt;error_in_pipeline_stage
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *&t;On the next backup, perform the feedback loop again.&n;&t; *&t;(I don&squot;t want to keep sense information between backups,&n;&t; *&t; as some systems are constantly on, and the system load&n;&t; *&t; can be totally different on the next backup).&n;&t; */
macro_line|#if IDETAPE_PIPELINE
id|tape-&gt;max_number_of_stages
op_assign
id|IDETAPE_MIN_PIPELINE_STAGES
suffix:semicolon
macro_line|#else
id|tape-&gt;max_number_of_stages
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* IDETAPE_PIPELINE */
macro_line|#if IDETAPE_DEBUG
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_ne
l_int|NULL
op_logical_or
id|tape-&gt;last_stage
op_ne
l_int|NULL
op_logical_or
id|tape-&gt;current_number_of_stages
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: ide-tape pipeline bug&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG */
)brace
multiline_comment|/*&n; *&t;idetape_zero_packet_command just zeros a packet command and&n; *&t;sets the number of retries to 0, as we haven&squot;t retried it yet.&n; */
DECL|function|idetape_zero_packet_command
r_void
id|idetape_zero_packet_command
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|12
suffix:semicolon
id|i
op_increment
)paren
id|pc-&gt;c
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;retries
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_swap_shorts converts a 16 bit number from little endian&n; *&t;to big endian format.&n; */
DECL|function|idetape_swap_short
r_int
r_int
id|idetape_swap_short
(paren
r_int
r_int
id|temp
)paren
(brace
r_union
id|convert
(brace
r_int
id|all
suffix:colon
l_int|16
suffix:semicolon
r_struct
(brace
r_int
id|b1
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b2
suffix:colon
l_int|8
suffix:semicolon
)brace
id|b
suffix:semicolon
)brace
id|original
comma
id|converted
suffix:semicolon
id|original.all
op_assign
id|temp
suffix:semicolon
id|converted.b.b1
op_assign
id|original.b.b2
suffix:semicolon
id|converted.b.b2
op_assign
id|original.b.b1
suffix:semicolon
r_return
(paren
id|converted.all
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_swap_long converts from little endian to big endian format.&n; */
DECL|function|idetape_swap_long
r_int
r_int
id|idetape_swap_long
(paren
r_int
r_int
id|temp
)paren
(brace
r_union
id|convert
(brace
r_int
id|all
suffix:colon
l_int|32
suffix:semicolon
r_struct
(brace
r_int
id|b1
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b2
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b3
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b4
suffix:colon
l_int|8
suffix:semicolon
)brace
id|b
suffix:semicolon
)brace
id|original
comma
id|converted
suffix:semicolon
id|original.all
op_assign
id|temp
suffix:semicolon
id|converted.b.b1
op_assign
id|original.b.b4
suffix:semicolon
id|converted.b.b2
op_assign
id|original.b.b3
suffix:semicolon
id|converted.b.b3
op_assign
id|original.b.b2
suffix:semicolon
id|converted.b.b4
op_assign
id|original.b.b1
suffix:semicolon
r_return
(paren
id|converted.all
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_next_pc_storage returns a pointer to a place in which we can&n; *&t;safely store a packet command, even though we intend to leave the&n; *&t;driver. A storage space for a maximum of IDETAPE_PC_STACK packet&n; *&t;commands is allocated at initialization time.&n; */
DECL|function|idetape_next_pc_storage
id|idetape_packet_command_t
op_star
id|idetape_next_pc_storage
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: pc_stack_index=%d&bslash;n&quot;
comma
id|tape-&gt;pc_stack_index
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
id|tape-&gt;pc_stack_index
op_eq
id|IDETAPE_PC_STACK
)paren
id|tape-&gt;pc_stack_index
op_assign
l_int|0
suffix:semicolon
r_return
(paren
op_amp
(paren
id|tape-&gt;pc_stack
(braket
id|tape-&gt;pc_stack_index
op_increment
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_next_rq_storage is used along with idetape_next_pc_storage.&n; *&t;Since we queue packet commands in the request queue, we need to&n; *&t;allocate a request, along with the allocation of a packet command.&n; */
multiline_comment|/**************************************************************&n; *                                                            *&n; *  This should get fixed to use kmalloc(GFP_ATOMIC, ..)      *&n; *  followed later on by kfree().   -ml                       *&n; *                                                            *&n; **************************************************************/
DECL|function|idetape_next_rq_storage
r_struct
id|request
op_star
id|idetape_next_rq_storage
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: rq_stack_index=%d&bslash;n&quot;
comma
id|tape-&gt;rq_stack_index
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
id|tape-&gt;rq_stack_index
op_eq
id|IDETAPE_PC_STACK
)paren
id|tape-&gt;rq_stack_index
op_assign
l_int|0
suffix:semicolon
r_return
(paren
op_amp
(paren
id|tape-&gt;rq_stack
(braket
id|tape-&gt;rq_stack_index
op_increment
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Block device interface functions&n; *&n; *&t;The block device interface should not be used for data transfers.&n; *&t;However, we still allow opening it so that we can issue general&n; *&t;ide driver configuration ioctl&squot;s, such as the interrupt unmask feature.&n; */
DECL|function|idetape_blkdev_open
r_int
id|idetape_blkdev_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_blkdev_open&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
id|tape-&gt;busy
)paren
(brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Allowing access only through one */
r_return
(paren
op_minus
id|EBUSY
)paren
suffix:semicolon
multiline_comment|/* one file descriptor */
)brace
id|tape-&gt;busy
op_assign
l_int|1
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|idetape_blkdev_release
r_void
id|idetape_blkdev_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_blkdev_release&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tape-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Character device interface functions&n; */
multiline_comment|/*&n; *&t;lseek is currently not installed.&n; */
DECL|function|idetape_chrdev_lseek
r_int
id|idetape_chrdev_lseek
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|off_t
id|offset
comma
r_int
id|origin
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_chrdev_lseek&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
r_if
c_cond
(paren
id|idetape_position_tape
(paren
id|drive
comma
id|offset
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Rewinding tape failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Our character device read / write functions.&n; *&n; *&t;The tape is optimized to maximize throughput when it is transfering&n; *&t;an integral number of the &quot;continous transfer limit&quot;, which is&n; *&t;a parameter of the specific tape (26 KB on my particular tape). The&n; *&t;resulting increase in performance should be dramatical. In the&n; *&t;character device read/write functions, we split the current&n; *&t;request to units of the above size, and handle the remaining bytes&n; *&t;in some other sub-functions.&n; *&n; *&t;In case the count number is not even an integral number of the tape&n; *&t;block size (usually 512 or 1024 bytes), we will pad the transfer with&n; *&t;zeroes (write) or read the entire block and return only the requested&n; *&t;bytes (but the tape will be in the &quot;wrong&quot; position). Do not supply&n; *&t;such a count value unless you are going to close the device right&n; *&t;after this request.&n; *&n; *&t;Again, for best results use an integral number of the tape&squot;s parameter&n; *&t;(which is displayed in the driver installation stage). I will soon&n; *&t;add an ioctl to get this important parameter.&n; */
multiline_comment|/*&n; *&t;Our character device read function.&n; */
DECL|function|idetape_chrdev_read
r_int
id|idetape_chrdev_read
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_int
id|blocks
comma
id|remainder
comma
id|retval
comma
id|ctl_bytes
suffix:semicolon
r_char
op_star
id|buf_ptr
suffix:semicolon
r_int
r_int
id|previous_block_address
comma
id|actually_read
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_chrdev_read&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|tape-&gt;last_dt_was_write
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|actually_read
op_assign
l_int|0
suffix:semicolon
id|buf_ptr
op_assign
id|buf
suffix:semicolon
id|ctl_bytes
op_assign
id|tape-&gt;capabilities.ctl
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
id|blocks
op_assign
id|count
op_div
id|ctl_bytes
suffix:semicolon
id|remainder
op_assign
id|count
op_mod
id|ctl_bytes
suffix:semicolon
r_while
c_loop
(paren
id|blocks
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Adding a READ request to the block device request queue&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|previous_block_address
op_assign
id|tape-&gt;block_address
suffix:semicolon
id|retval
op_assign
id|idetape_queue_rw_tail
(paren
id|drive
comma
id|IDETAPE_READ_REQUEST
comma
id|tape-&gt;capabilities.ctl
comma
id|tape-&gt;data_buffer
)paren
suffix:semicolon
id|actually_read
op_add_assign
id|tape-&gt;tape_block_size
op_star
(paren
id|tape-&gt;block_address
op_minus
id|previous_block_address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Error occured while reading&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|actually_read
)paren
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Copying %d bytes to the user space memory&bslash;n&quot;
comma
id|ctl_bytes
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|memcpy_tofs
(paren
id|buf_ptr
comma
id|tape-&gt;data_buffer
comma
id|ctl_bytes
)paren
suffix:semicolon
id|buf_ptr
op_add_assign
id|ctl_bytes
suffix:semicolon
id|blocks
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|remainder
)paren
r_return
(paren
id|actually_read
op_plus
id|idetape_chrdev_read_remainder
(paren
id|inode
comma
id|file
comma
id|buf_ptr
comma
id|remainder
)paren
)paren
suffix:semicolon
r_else
r_return
(paren
id|actually_read
)paren
suffix:semicolon
)brace
DECL|function|idetape_chrdev_read_remainder
r_int
id|idetape_chrdev_read_remainder
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_int
id|blocks
comma
id|remainder
comma
id|retval
suffix:semicolon
r_int
r_int
id|previous_block_address
comma
id|actually_read
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_chrdev_read_remainder&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|tape-&gt;last_dt_was_write
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|blocks
op_assign
id|count
op_div
id|tape-&gt;tape_block_size
suffix:semicolon
id|remainder
op_assign
id|count
op_mod
id|tape-&gt;tape_block_size
suffix:semicolon
r_if
c_cond
(paren
id|remainder
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Padding read to block boundary&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|blocks
op_increment
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Adding a READ request to the block device request queue&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|previous_block_address
op_assign
id|tape-&gt;block_address
suffix:semicolon
id|retval
op_assign
id|idetape_queue_rw_tail
(paren
id|drive
comma
id|IDETAPE_READ_REQUEST
comma
id|blocks
comma
id|tape-&gt;data_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Error occured while reading&bslash;n&quot;
)paren
suffix:semicolon
id|actually_read
op_assign
id|tape-&gt;tape_block_size
op_star
(paren
id|tape-&gt;block_address
op_minus
id|previous_block_address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|actually_read
OG
id|count
)paren
id|actually_read
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|actually_read
op_ne
l_int|0
)paren
id|memcpy_tofs
(paren
id|buf
comma
id|tape-&gt;data_buffer
comma
id|actually_read
)paren
suffix:semicolon
r_return
(paren
id|actually_read
)paren
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Copying %d bytes to the user space memory&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|memcpy_tofs
(paren
id|buf
comma
id|tape-&gt;data_buffer
comma
id|count
)paren
suffix:semicolon
r_return
(paren
id|count
)paren
suffix:semicolon
)brace
DECL|function|idetape_chrdev_write
r_int
id|idetape_chrdev_write
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_int
id|blocks
comma
id|remainder
comma
id|retval
suffix:semicolon
r_const
r_char
op_star
id|buf_ptr
suffix:semicolon
r_int
r_int
id|previous_block_address
comma
id|actually_written
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_chrdev_write&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|tape-&gt;last_dt_was_write
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
id|actually_written
op_assign
l_int|0
suffix:semicolon
id|buf_ptr
op_assign
id|buf
suffix:semicolon
id|blocks
op_assign
id|count
op_div
id|tape-&gt;data_buffer_size
suffix:semicolon
id|remainder
op_assign
id|count
op_mod
id|tape-&gt;data_buffer_size
suffix:semicolon
r_while
c_loop
(paren
id|blocks
)paren
(brace
id|memcpy_fromfs
(paren
id|tape-&gt;temp_data_buffer
comma
id|buf_ptr
comma
id|tape-&gt;data_buffer_size
)paren
suffix:semicolon
id|buf_ptr
op_add_assign
id|tape-&gt;data_buffer_size
suffix:semicolon
id|previous_block_address
op_assign
id|tape-&gt;block_address
suffix:semicolon
id|retval
op_assign
id|idetape_add_chrdev_write_request
(paren
id|drive
comma
id|IDETAPE_WRITE_REQUEST
comma
id|tape-&gt;capabilities.ctl
comma
id|tape-&gt;temp_data_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;max_number_of_stages
)paren
id|actually_written
op_add_assign
id|tape-&gt;data_buffer_size
suffix:semicolon
multiline_comment|/* Pipelined mode - Cheat :-) */
r_else
id|actually_written
op_add_assign
id|tape-&gt;tape_block_size
op_star
(paren
id|tape-&gt;block_address
op_minus
id|previous_block_address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Error occured while writing&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;max_number_of_stages
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_else
r_return
(paren
id|actually_written
)paren
suffix:semicolon
)brace
id|blocks
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|remainder
)paren
r_return
(paren
id|actually_written
op_plus
id|idetape_chrdev_write_remainder
(paren
id|inode
comma
id|file
comma
id|buf_ptr
comma
id|remainder
)paren
)paren
suffix:semicolon
r_else
r_return
(paren
id|actually_written
)paren
suffix:semicolon
)brace
DECL|function|idetape_chrdev_write_remainder
r_int
id|idetape_chrdev_write_remainder
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_int
id|blocks
comma
id|remainder
comma
id|retval
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
r_int
r_int
id|previous_block_address
comma
id|actually_written
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_chrdev_write_remainder&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|blocks
op_assign
id|count
op_div
id|tape-&gt;tape_block_size
suffix:semicolon
id|remainder
op_assign
id|count
op_mod
id|tape-&gt;tape_block_size
suffix:semicolon
r_if
c_cond
(paren
id|remainder
)paren
id|blocks
op_increment
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Copying %d bytes from the user space memory&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|memcpy_fromfs
(paren
id|tape-&gt;temp_data_buffer
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|remainder
)paren
(brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;ide-tape: Padding written data to block boundary&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|ptr
op_assign
id|tape-&gt;temp_data_buffer
op_plus
(paren
id|blocks
op_minus
l_int|1
)paren
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
id|memset
(paren
id|ptr
comma
l_int|0
comma
id|remainder
)paren
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Adding a WRITE request to the block device request queue&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|previous_block_address
op_assign
id|tape-&gt;block_address
suffix:semicolon
id|retval
op_assign
id|idetape_add_chrdev_write_request
(paren
id|drive
comma
id|IDETAPE_WRITE_REQUEST
comma
id|blocks
comma
id|tape-&gt;temp_data_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Error occured while writing&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;max_number_of_stages
)paren
id|actually_written
op_assign
l_int|0
suffix:semicolon
r_else
id|actually_written
op_assign
id|tape-&gt;tape_block_size
op_star
(paren
id|tape-&gt;block_address
op_minus
id|previous_block_address
)paren
suffix:semicolon
r_if
c_cond
(paren
id|actually_written
OG
id|count
)paren
id|actually_written
op_assign
id|count
suffix:semicolon
r_return
(paren
id|actually_written
)paren
suffix:semicolon
)brace
r_return
(paren
id|count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Our character device ioctls.&n; *&n; *&t;General mtio.h magnetic io commands are supported here, and not in&n; *&t;the correspoding block interface.&n; *&n; *&t;Our own ide-tape ioctls are supported on both interfaces.&n; */
DECL|function|idetape_chrdev_ioctl
r_int
id|idetape_chrdev_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|mtop
id|mtop
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_int
id|retval
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_chrdev_ioctl, cmd=%u&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|MTIOCTOP
suffix:colon
id|retval
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|mtop
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|memcpy_fromfs
(paren
(paren
r_char
op_star
)paren
op_amp
id|mtop
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|mtop
)paren
)paren
suffix:semicolon
r_return
(paren
id|idetape_mtioctop
(paren
id|drive
comma
id|mtop.mt_op
comma
id|mtop.mt_count
)paren
)paren
suffix:semicolon
r_default
suffix:colon
r_return
(paren
id|idetape_blkdev_ioctl
(paren
id|drive
comma
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;idetape_mtioctop is called from idetape_chrdev_ioctl when&n; *&t;the general mtio MTIOCTOP ioctl is requested.&n; *&n; *&t;We currently support the following mtio.h operations:&n; *&n; *&t;MTFSF&t;-&t;Space over mt_count filemarks in the positive direction.&n; *&t;&t;&t;The tape is positioned after the last spaced filemark.&n; *&n; *&t;MTFSFM&t;-&t;Same as MTFSF, but the tape is positioned before the&n; *&t;&t;&t;last filemark.&n; *&n; *&t;MTBSF&t;-&t;Steps background over mt_count filemarks, tape is&n; *&t;&t;&t;positioned before the last filemark.&n; *&n; *&t;MTBSFM&t;-&t;Like MTBSF, only tape is positioned after the last filemark.&n; *&n; *&t;MTWEOF&t;-&t;Writes mt_count filemarks. Tape is positioned after&n; *&t;&t;&t;the last written filemark.&n; *&n; *&t;MTREW&t;-&t;Rewindes tape.&n; *&n; *&t;MTNOP&t;-&t;Flushes tape buffers.&n; *&n; *&t;MTEOM&t;-&t;Moves to the end of recorded data.&n; *&n; *&t;MTERASE&t;-&t;Erases tape.&n; *&n; *&t;The following commands are currently not supported:&n; *&n; *&t;MTFSR, MTBSR, MTFSS, MTBSS, MTWSM, MTOFFL, MTRETEN, MTSEEK, MTSETBLK,&n; *&t;MTSETDENSITY, MTSETDRVBUFFER, MT_ST_BOOLEANS, MT_ST_WRITE_THRESHOLD.&n; */
DECL|function|idetape_mtioctop
r_int
id|idetape_mtioctop
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|mt_op
comma
r_int
id|mt_count
)paren
(brace
r_int
id|i
comma
id|retval
suffix:semicolon
id|idetape_packet_command_t
id|pc
suffix:semicolon
id|pc.buffer
op_assign
id|pc.temp_buffer
suffix:semicolon
id|pc.buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc.current_position
op_assign
id|pc.temp_buffer
suffix:semicolon
id|idetape_create_write_filemark_cmd
(paren
op_amp
id|pc
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Flush buffers */
id|retval
op_assign
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mt_op
)paren
(brace
r_case
id|MTFSF
suffix:colon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Handling MTFSF command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|idetape_create_space_cmd
(paren
op_amp
id|pc
comma
id|mt_count
comma
id|IDETAPE_SPACE_OVER_FILEMARK
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTFSFM
suffix:colon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Handling MTFSFM command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|retval
op_assign
id|idetape_mtioctop
(paren
id|drive
comma
id|MTFSF
comma
id|mt_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
r_return
(paren
id|idetape_mtioctop
(paren
id|drive
comma
id|MTBSF
comma
l_int|1
)paren
)paren
suffix:semicolon
r_case
id|MTBSF
suffix:colon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Handling MTBSF command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|idetape_create_space_cmd
(paren
op_amp
id|pc
comma
op_minus
id|mt_count
comma
id|IDETAPE_SPACE_OVER_FILEMARK
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTBSFM
suffix:colon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Handling MTBSFM command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|retval
op_assign
id|idetape_mtioctop
(paren
id|drive
comma
id|MTBSF
comma
id|mt_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
r_return
(paren
id|idetape_mtioctop
(paren
id|drive
comma
id|MTFSF
comma
l_int|1
)paren
)paren
suffix:semicolon
r_case
id|MTWEOF
suffix:colon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Handling MTWEOF command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mt_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|idetape_create_write_filemark_cmd
(paren
op_amp
id|pc
comma
l_int|1
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|MTREW
suffix:colon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Handling MTREW command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_return
(paren
id|idetape_rewind_tape
(paren
id|drive
)paren
)paren
suffix:semicolon
r_case
id|MTNOP
suffix:colon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Handling MTNOP command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|idetape_create_write_filemark_cmd
(paren
op_amp
id|pc
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTEOM
suffix:colon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Handling MTEOM command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|idetape_create_space_cmd
(paren
op_amp
id|pc
comma
l_int|0
comma
id|IDETAPE_SPACE_TO_EOD
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTERASE
suffix:colon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Handling MTERASE command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|retval
op_assign
id|idetape_position_tape
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|idetape_create_erase_cmd
(paren
op_amp
id|pc
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;ide-tape: MTIO operation %d not supported&bslash;n&quot;
comma
id|mt_op
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Our character device open function.&n; */
DECL|function|idetape_chrdev_open
r_int
id|idetape_chrdev_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|minor
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_chrdev_open&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|minor
op_assign
id|MINOR
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_ne
l_int|0
op_logical_and
id|minor
op_ne
l_int|128
)paren
(brace
multiline_comment|/* Currently supporting only one */
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* tape drive */
r_return
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;busy
)paren
(brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Allowing access only through one */
r_return
(paren
op_minus
id|EBUSY
)paren
suffix:semicolon
multiline_comment|/* one file descriptor */
)brace
id|tape-&gt;busy
op_assign
l_int|1
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;block_address_valid
)paren
(brace
r_if
c_cond
(paren
id|idetape_rewind_tape
(paren
id|drive
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Rewinding tape failed&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;busy
op_assign
l_int|0
suffix:semicolon
r_return
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
)brace
id|tape-&gt;last_dt_was_write
op_assign
l_int|0
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Our character device release function.&n; */
DECL|function|idetape_chrdev_release
r_void
id|idetape_chrdev_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_int
r_int
id|minor
suffix:semicolon
id|idetape_packet_command_t
id|pc
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_chrdev_release&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|minor
op_assign
id|MINOR
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|idetape_empty_pipeline
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;last_dt_was_write
)paren
(brace
id|idetape_create_write_filemark_cmd
(paren
op_amp
id|pc
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Write a filemark */
r_if
c_cond
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Couldn&squot;t write a filemark&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* ??? */
)brace
)brace
r_else
(brace
id|idetape_create_write_filemark_cmd
(paren
op_amp
id|pc
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Flush buffers */
r_if
c_cond
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Couldn&squot;t flush buffers&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* ??? */
)brace
)brace
r_if
c_cond
(paren
id|minor
OL
l_int|128
)paren
(brace
r_if
c_cond
(paren
id|idetape_rewind_tape
(paren
id|drive
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Rewinding tape failed&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* ??? */
)brace
)brace
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|tape-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_position_tape positions the tape to the requested block&n; *&t;using the LOCATE packet command. A READ POSITION command is then&n; *&t;issued to check where we are positioned.&n; *&n; *&t;Like all higher level operations, we queue the commands at the tail&n; *&t;of the request queue and wait for their completion.&n; *&t;&n; */
DECL|function|idetape_position_tape
r_int
id|idetape_position_tape
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|block
)paren
(brace
r_int
id|retval
suffix:semicolon
id|idetape_packet_command_t
id|pc
suffix:semicolon
id|idetape_create_locate_cmd
(paren
op_amp
id|pc
comma
id|block
comma
l_int|0
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|0
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|idetape_create_read_position_cmd
(paren
op_amp
id|pc
)paren
suffix:semicolon
id|pc.buffer
op_assign
id|pc.temp_buffer
suffix:semicolon
id|pc.buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc.current_position
op_assign
id|pc.temp_buffer
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Rewinds the tape to the Begining Of the current Partition (BOP).&n; *&n; *&t;We currently support only one partition.&n; */
DECL|function|idetape_rewind_tape
r_int
id|idetape_rewind_tape
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|retval
suffix:semicolon
id|idetape_packet_command_t
id|pc
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_rewind_tape&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */&t;
id|idetape_create_write_filemark_cmd
(paren
op_amp
id|pc
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Flush buffers */
id|retval
op_assign
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|idetape_create_rewind_cmd
(paren
op_amp
id|pc
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|idetape_create_read_position_cmd
(paren
op_amp
id|pc
)paren
suffix:semicolon
id|pc.buffer
op_assign
id|pc.temp_buffer
suffix:semicolon
id|pc.buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc.current_position
op_assign
id|pc.temp_buffer
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Pipeline related functions&n; */
multiline_comment|/*&n; *&t;idetape_kmalloc_stage uses kmalloc to allocate a pipeline stage,&n; *&t;along with all the necessary small buffers which together make&n; *&t;a buffer of size tape-&gt;data_buffer_size or a bit more, in case&n; *&t;it is not a multiply of IDETAPE_ALLOCATION_BLOCK (it isn&squot;t ...).&n; *&n; *&t;Returns a pointer to the new allocated stage, or NULL if we&n; *&t;can&squot;t (or don&squot;t want to, in case we already have too many stages)&n; *&t;allocate a stage.&n; *&n; *&t;Pipeline stages are optional and are used to increase performance.&n; *&t;If we can&squot;t allocate them, we&squot;ll manage without them.&n; */
DECL|function|idetape_kmalloc_stage
id|idetape_pipeline_stage_t
op_star
id|idetape_kmalloc_stage
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_pipeline_stage_t
op_star
id|new_stage
suffix:semicolon
id|idetape_buffer_head_t
op_star
id|prev_bh
comma
op_star
id|bh
suffix:semicolon
r_int
id|buffers_num
comma
id|i
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_kmalloc_stage&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
id|tape-&gt;current_number_of_stages
op_eq
id|tape-&gt;max_number_of_stages
)paren
(brace
id|tape-&gt;pipeline_was_full_once
op_assign
l_int|1
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|new_stage
op_assign
(paren
id|idetape_pipeline_stage_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|idetape_pipeline_stage_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_stage
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
id|new_stage-&gt;next
op_assign
id|new_stage-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|buffers_num
op_assign
id|tape-&gt;data_buffer_size
op_div
id|IDETAPE_ALLOCATION_BLOCK
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;data_buffer_size
op_mod
id|IDETAPE_ALLOCATION_BLOCK
)paren
id|buffers_num
op_increment
suffix:semicolon
id|prev_bh
op_assign
id|new_stage-&gt;bh
op_assign
(paren
id|idetape_buffer_head_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|idetape_buffer_head_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_stage-&gt;bh
op_eq
l_int|NULL
)paren
(brace
id|idetape_kfree_stage
(paren
id|new_stage
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|new_stage-&gt;bh-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|new_stage-&gt;bh-&gt;data
op_assign
id|kmalloc
(paren
id|IDETAPE_ALLOCATION_BLOCK
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_stage-&gt;bh-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|idetape_kfree_stage
(paren
id|new_stage
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|buffers_num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
(paren
id|idetape_buffer_head_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|idetape_buffer_head_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
id|idetape_kfree_stage
(paren
id|new_stage
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|bh-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|prev_bh-&gt;next
op_assign
id|bh
suffix:semicolon
id|bh-&gt;data
op_assign
id|kmalloc
(paren
id|IDETAPE_ALLOCATION_BLOCK
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|idetape_kfree_stage
(paren
id|new_stage
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|prev_bh
op_assign
id|bh
suffix:semicolon
)brace
r_return
(paren
id|new_stage
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_kfree_stage calls kfree to completly free a stage, along with&n; *&t;its related buffers.&n; */
DECL|function|idetape_kfree_stage
r_void
id|idetape_kfree_stage
(paren
id|idetape_pipeline_stage_t
op_star
id|stage
)paren
(brace
id|idetape_buffer_head_t
op_star
id|prev_bh
comma
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|stage
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_kfree_stage&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|bh
op_assign
id|stage-&gt;bh
suffix:semicolon
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
(brace
id|prev_bh
op_assign
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;data
op_ne
l_int|NULL
)paren
id|kfree
(paren
id|bh-&gt;data
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;next
suffix:semicolon
id|kfree
(paren
id|prev_bh
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|stage
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_copy_buffer_from_stage and idetape_copy_buffer_to_stage&n; *&t;copy data from/to the small buffers into/from a continous buffer.&n; */
DECL|function|idetape_copy_buffer_from_stage
r_void
id|idetape_copy_buffer_from_stage
(paren
id|idetape_pipeline_stage_t
op_star
id|stage
comma
r_char
op_star
id|buffer
)paren
(brace
id|idetape_buffer_head_t
op_star
id|bh
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_copy_buffer_from_stage&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|ptr
op_assign
id|buffer
suffix:semicolon
id|bh
op_assign
id|stage-&gt;bh
suffix:semicolon
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
(brace
id|memcpy
(paren
id|ptr
comma
id|bh-&gt;data
comma
id|IDETAPE_ALLOCATION_BLOCK
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;next
suffix:semicolon
id|ptr
op_assign
id|ptr
op_plus
id|IDETAPE_ALLOCATION_BLOCK
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Here we copy a continuous data buffer to the various small buffers&n; *&t;in the pipeline stage.&n; */
DECL|function|idetape_copy_buffer_to_stage
r_void
id|idetape_copy_buffer_to_stage
(paren
id|idetape_pipeline_stage_t
op_star
id|stage
comma
r_char
op_star
id|buffer
)paren
(brace
id|idetape_buffer_head_t
op_star
id|bh
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_copy_buffer_to_stage&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|ptr
op_assign
id|buffer
suffix:semicolon
id|bh
op_assign
id|stage-&gt;bh
suffix:semicolon
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
(brace
id|memcpy
(paren
id|bh-&gt;data
comma
id|ptr
comma
id|IDETAPE_ALLOCATION_BLOCK
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;next
suffix:semicolon
id|ptr
op_assign
id|ptr
op_plus
id|IDETAPE_ALLOCATION_BLOCK
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_increase_max_pipeline_stages is a part of the feedback&n; *&t;loop which tries to find the optimum number of stages. In the&n; *&t;feedback loop, we are starting from a minimum maximum number of&n; *&t;stages, and if we sense that the pipeline is empty, we try to&n; *&t;increase it, until we reach the user compile time memory limit.&n; */
DECL|function|idetape_increase_max_pipeline_stages
r_void
id|idetape_increase_max_pipeline_stages
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_increase_max_pipeline_stages&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;pipeline_was_full_once
)paren
r_return
suffix:semicolon
id|tape-&gt;max_number_of_stages
op_add_assign
id|IDETAPE_INCREASE_STAGES_RATE
op_star
(paren
id|IDETAPE_MAX_PIPELINE_STAGES
op_minus
id|IDETAPE_MIN_PIPELINE_STAGES
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;max_number_of_stages
op_ge
id|IDETAPE_MAX_PIPELINE_STAGES
)paren
id|tape-&gt;max_number_of_stages
op_assign
id|IDETAPE_MAX_PIPELINE_STAGES
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Maximum number of stages: %d&bslash;n&quot;
comma
id|tape-&gt;max_number_of_stages
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_add_stage_tail adds a new stage at the end of the pipeline.&n; */
DECL|function|idetape_add_stage_tail
r_void
id|idetape_add_stage_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pipeline_stage_t
op_star
id|stage
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_add_stage_tail&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
id|stage-&gt;next
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Adding to the tail of the pipeline&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
multiline_comment|/*&n;&t; *&t;Avoid a race condition - pipeline_locked is set whenever&n;&t; *&t;we modify active_data_request from the lower level of&n;&t; *&t;the driver. We wait until active_data_request is valid.&n;&t; */
r_while
c_loop
(paren
id|tape-&gt;pipeline_locked
)paren
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|stage-&gt;prev
op_assign
id|tape-&gt;last_stage
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_ne
l_int|NULL
)paren
id|tape-&gt;last_stage-&gt;next
op_assign
id|stage
suffix:semicolon
r_else
id|tape-&gt;first_stage
op_assign
id|stage
suffix:semicolon
id|tape-&gt;last_stage
op_assign
id|stage
suffix:semicolon
id|tape-&gt;current_number_of_stages
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Check if we are currently servicing requests in the bottom&n;&t; *&t;part of the driver.&n;&t; *&n;&t; *&t;If not, wait for the pipeline to be full enough (75%) before&n;&t; *&t;starting to service requests, so that we will be able to&n;&t; *&t;keep up with the higher speeds of the tape.&n;&t; */
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_eq
l_int|NULL
op_logical_and
id|tape-&gt;current_number_of_stages
op_ge
l_float|0.75
op_star
id|tape-&gt;max_number_of_stages
)paren
(brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|idetape_insert_pipeline_into_queue
(paren
id|drive
)paren
suffix:semicolon
)brace
r_else
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_insert_pipeline_into_queue is used to start servicing the&n; *&t;pipeline stages.&n; */
DECL|function|idetape_insert_pipeline_into_queue
r_void
id|idetape_insert_pipeline_into_queue
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_eq
l_int|NULL
)paren
(brace
id|idetape_active_next_stage
(paren
id|drive
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Using ide_end&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG */
(paren
r_void
)paren
(paren
id|ide_do_drive_cmd
(paren
id|drive
comma
id|tape-&gt;active_data_request
comma
id|ide_end
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;idetape_active_next_stage will &quot;move the pipeline&quot; one stage -&n; *&t;Inserting the first stage into the &quot;active place&quot;, and using kfree&n; *&t;to free the stage.&n; */
DECL|function|idetape_active_next_stage
r_void
id|idetape_active_next_stage
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_pipeline_stage_t
op_star
id|stage
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if IDETAPE_DEBUG
id|printk
(paren
l_string|&quot;Reached idetape_active_next_stage&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: ide-tape.c bug - tape-&gt;first_stage is NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG */
id|stage
op_assign
id|tape-&gt;first_stage
suffix:semicolon
id|idetape_copy_buffer_from_stage
(paren
id|stage
comma
id|tape-&gt;data_buffer
)paren
suffix:semicolon
id|rq
op_assign
id|idetape_next_rq_storage
(paren
id|drive
)paren
suffix:semicolon
op_star
id|rq
op_assign
id|stage-&gt;rq
suffix:semicolon
id|rq-&gt;buffer
op_assign
id|tape-&gt;data_buffer
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|tape-&gt;first_stage
op_assign
id|stage-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_eq
l_int|NULL
)paren
id|tape-&gt;last_stage
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;current_number_of_stages
op_decrement
suffix:semicolon
id|tape-&gt;active_data_request
op_assign
id|rq
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|idetape_kfree_stage
(paren
id|stage
)paren
suffix:semicolon
)brace
eof
