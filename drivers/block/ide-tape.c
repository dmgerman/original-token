multiline_comment|/*&n; * linux/drivers/block/ide-tape.c&t;Version 1.7 - ALPHA&t;Sep  10, 1996&n; *&n; * Copyright (C) 1995, 1996 Gadi Oxman &lt;gadio@netvision.net.il&gt;&n; *&n; * This driver was constructed as a student project in the software laboratory&n; * of the faculty of electrical engineering in the Technion - Israel&squot;s&n; * Institute Of Technology, with the guide of Avner Lottem and Dr. Ilana David.&n; *&n; * It is hereby placed under the terms of the GNU general public license.&n; * (See linux/COPYING).&n; */
multiline_comment|/*&n; * IDE ATAPI streaming tape driver.&n; *&n; * This driver is a part of the Linux ide driver and works in co-operation&n; * with linux/drivers/block/ide.c.&n; *&n; * The driver, in co-operation with ide.c, basically traverses the &n; * request-list for the block device interface. The character device&n; * interface, on the other hand, creates new requests, adds them&n; * to the request-list of the block device, and waits for their completion.&n; *&n; * Pipelined operation mode is now supported on both reads and writes.&n; *&n; * The block device major and minor numbers are determined from the&n; * tape&squot;s relative position in the ide interfaces, as explained in ide.c.&n; *&n; * The character device interface consists of two devices:&n; *&n; * ht0&t;&t;major=37,minor=0&t;first IDE tape, rewind on close.&n; * nht0&t;&t;major=37,minor=128&t;first IDE tape, no rewind on close.&n; *&n; * Run /usr/src/linux/scripts/MAKEDEV.ide to create the above entries.&n; * We currently support only one ide tape drive.&n; *&n; * The general magnetic tape commands compatible interface, as defined by&n; * include/linux/mtio.h, is accessible through the character device.&n; *&n; * General ide driver configuration options, such as the interrupt-unmask&n; * flag, can be configured by issuing an ioctl to the block device interface,&n; * as any other ide device.&n; *&n; * Our own ide-tape ioctl&squot;s can can be issued to either the block device or&n; * the character device interface.&n; *&n; * Maximal throughput with minimal bus load will usually be achieved in the&n; * following scenario:&n; *&n; *&t;1.&t;ide-tape is operating in the pipelined operation mode.&n; *&t;2.&t;All character device read/write requests consist of an&n; *&t;&t;integral number of the tape&squot;s recommended data transfer unit&n; *&t;&t;(which is shown on initialization and can be received with&n; *&t;&t; an ioctl).&n; *&t;&t;As of version 1.3 of the driver, this is no longer as critical&n; *&t;&t;as it used to be.&n; *&t;3.&t;No buffering is performed by the user backup program.&n; *&n; * Testing was done with a 2 GB CONNER CTMA 4000 IDE ATAPI Streaming Tape Drive.&n; * &n; * Ver 0.1   Nov  1 95   Pre-working code :-)&n; * Ver 0.2   Nov 23 95   A short backup (few megabytes) and restore procedure&n; *                        was successful ! (Using tar cvf ... on the block&n; *                        device interface).&n; *                       A longer backup resulted in major swapping, bad&n; *                        overall Linux performance and eventually failed as&n; *                        we received non serial read-ahead requests from the&n; *                        buffer cache.&n; * Ver 0.3   Nov 28 95   Long backups are now possible, thanks to the&n; *                        character device interface. Linux&squot;s responsiveness&n; *                        and performance doesn&squot;t seem to be much affected&n; *                        from the background backup procedure.&n; *                       Some general mtio.h magnetic tape operations are&n; *                        now supported by our character device. As a result,&n; *                        popular tape utilities are starting to work with&n; *                        ide tapes :-)&n; *                       The following configurations were tested:&n; *                       &t;1. An IDE ATAPI TAPE shares the same interface&n; *                       &t;   and irq with an IDE ATAPI CDROM.&n; *                        &t;2. An IDE ATAPI TAPE shares the same interface&n; *                          &t;   and irq with a normal IDE disk.&n; *                        Both configurations seemed to work just fine !&n; *                        However, to be on the safe side, it is meanwhile&n; *                        recommended to give the IDE TAPE its own interface&n; *                        and irq.&n; *                       The one thing which needs to be done here is to&n; *                        add a &quot;request postpone&quot; feature to ide.c,&n; *                        so that we won&squot;t have to wait for the tape to finish&n; *                        performing a long media access (DSC) request (such&n; *                        as a rewind) before we can access the other device&n; *                        on the same interface. This effect doesn&squot;t disturb&n; *                        normal operation most of the time because read/write&n; *                        requests are relatively fast, and once we are&n; *                        performing one tape r/w request, a lot of requests&n; *                        from the other device can be queued and ide.c will&n; *&t;&t;&t;  service all of them after this single tape request.&n; * Ver 1.0   Dec 11 95   Integrated into Linux 1.3.46 development tree.&n; *                       On each read / write request, we now ask the drive&n; *                        if we can transfer a constant number of bytes&n; *                        (a parameter of the drive) only to its buffers,&n; *                        without causing actual media access. If we can&squot;t,&n; *                        we just wait until we can by polling the DSC bit.&n; *                        This ensures that while we are not transferring&n; *                        more bytes than the constant referred to above, the&n; *                        interrupt latency will not become too high and&n; *                        we won&squot;t cause an interrupt timeout, as happened&n; *                        occasionally in the previous version.&n; *                       While polling for DSC, the current request is&n; *                        postponed and ide.c is free to handle requests from&n; *                        the other device. This is handled transparently to&n; *                        ide.c. The hwgroup locking method which was used&n; *                        in the previous version was removed.&n; *                       Use of new general features which are provided by&n; *                        ide.c for use with atapi devices.&n; *                        (Programming done by Mark Lord)&n; *                       Few potential bug fixes (Again, suggested by Mark)&n; *                       Single character device data transfers are now&n; *                        not limited in size, as they were before.&n; *                       We are asking the tape about its recommended&n; *                        transfer unit and send a larger data transfer&n; *                        as several transfers of the above size.&n; *                        For best results, use an integral number of this&n; *                        basic unit (which is shown during driver&n; *                        initialization). I will soon add an ioctl to get&n; *                        this important parameter.&n; *                       Our data transfer buffer is allocated on startup,&n; *                        rather than before each data transfer. This should&n; *                        ensure that we will indeed have a data buffer.&n; * Ver 1.1   Dec 14 95   Fixed random problems which occurred when the tape&n; *                        shared an interface with another device.&n; *                        (poll_for_dsc was a complete mess).&n; *                       Removed some old (non-active) code which had&n; *                        to do with supporting buffer cache originated&n; *                        requests.&n; *                       The block device interface can now be opened, so&n; *                        that general ide driver features like the unmask&n; *                        interrupts flag can be selected with an ioctl.&n; *                        This is the only use of the block device interface.&n; *                       New fast pipelined operation mode (currently only on&n; *                        writes). When using the pipelined mode, the&n; *                        throughput can potentially reach the maximum&n; *                        tape supported throughput, regardless of the&n; *                        user backup program. On my tape drive, it sometimes&n; *                        boosted performance by a factor of 2. Pipelined&n; *                        mode is enabled by default, but since it has a few&n; *                        downfalls as well, you may want to disable it.&n; *                        A short explanation of the pipelined operation mode&n; *                        is available below.&n; * Ver 1.2   Jan  1 96   Eliminated pipelined mode race condition.&n; *                       Added pipeline read mode. As a result, restores&n; *                        are now as fast as backups.&n; *                       Optimized shared interface behavior. The new behavior&n; *                        typically results in better IDE bus efficiency and&n; *                        higher tape throughput.&n; *                       Pre-calculation of the expected read/write request&n; *                        service time, based on the tape&squot;s parameters. In&n; *                        the pipelined operation mode, this allows us to&n; *                        adjust our polling frequency to a much lower value,&n; *                        and thus to dramatically reduce our load on Linux,&n; *                        without any decrease in performance.&n; *                       Implemented additional mtio.h operations.&n; *                       The recommended user block size is returned by&n; *                        the MTIOCGET ioctl.&n; *                       Additional minor changes.&n; * Ver 1.3   Feb  9 96   Fixed pipelined read mode bug which prevented the&n; *                        use of some block sizes during a restore procedure.&n; *                       The character device interface will now present a&n; *                        continuous view of the media - any mix of block sizes&n; *                        during a backup/restore procedure is supported. The&n; *                        driver will buffer the requests internally and&n; *                        convert them to the tape&squot;s recommended transfer&n; *                        unit, making performance almost independent of the&n; *                        chosen user block size.&n; *                       Some improvements in error recovery.&n; *                       By cooperating with triton.c, bus mastering DMA can&n; *                        now sometimes be used with IDE tape drives as well.&n; *                        Bus mastering DMA has the potential to dramatically&n; *                        reduce the CPU&squot;s overhead when accessing the device,&n; *                        and can be enabled by using hdparm -d1 on the tape&squot;s&n; *                        block device interface. For more info, read the&n; *                        comments in triton.c.&n; * Ver 1.4   Mar 13 96   Fixed serialize support.&n; * Ver 1.5   Apr 12 96   Fixed shared interface operation, broken in 1.3.85.&n; *                       Fixed pipelined read mode inefficiency.&n; *                       Fixed nasty null dereferencing bug.&n; * Ver 1.6   Aug 16 96   Fixed FPU usage in the driver.&n; *                       Fixed end of media bug.&n; * Ver 1.7   Sep 10 96   Minor changes for the CONNER CTT8000-A model.&n; *&n; * We are currently in an *alpha* stage. The driver is not complete and not&n; * much tested. I would strongly suggest to:&n; *&n; *&t;1. Connect the tape to a separate interface and irq.&n; *&t;2. Be truly prepared for a kernel crash and the resulting data loss.&n; *&t;3. Don&squot;t rely too much on the resulting backups.&n; *&n; * Other than that, enjoy !&n; *&n; * Here are some words from the first releases of hd.c, which are quoted&n; * in ide.c and apply here as well:&n; *&n; * | Special care is recommended.  Have Fun!&n; *&n; */
multiline_comment|/*&n; * An overview of the pipelined operation mode.&n; *&n; * In the pipelined write mode, we will usually just add requests to our&n; * pipeline and return immediately, before we even start to service them. The&n; * user program will then have enough time to prepare the next request while&n; * we are still busy servicing previous requests. In the pipelined read mode,&n; * the situation is similar - we add read-ahead requests into the pipeline,&n; * before the user even requested them.&n; *&n; * The pipeline can be viewed as a &quot;safety net&quot; which will be activated when&n; * the system load is high and prevents the user backup program from keeping up&n; * with the current tape speed. At this point, the pipeline will get&n; * shorter and shorter but the tape will still be streaming at the same speed.&n; * Assuming we have enough pipeline stages, the system load will hopefully&n; * decrease before the pipeline is completely empty, and the backup program&n; * will be able to &quot;catch up&quot; and refill the pipeline again.&n; * &n; * When using the pipelined mode, it would be best to disable any type of&n; * buffering done by the user program, as ide-tape already provides all the&n; * benefits in the kernel, where it can be done in a more efficient way.&n; * As we will usually not block the user program on a request, the most&n; * efficient user code will then be a simple read-write-read-... cycle.&n; * Any additional logic will usually just slow down the backup process.&n; *&n; * Using the pipelined mode, I get a constant over 400 KBps throughput,&n; * which seems to be the maximum throughput supported by my tape.&n; *&n; * However, there are some downfalls:&n; *&n; *&t;1.&t;We use memory (for data buffers) in proportional to the number&n; *&t;&t;of pipeline stages (each stage is about 26 KB with my tape).&n; *&t;2.&t;In the pipelined write mode, we cheat and postpone error codes&n; *&t;&t;to the user task. In read mode, the actual tape position&n; *&t;&t;will be a bit further than the last requested block.&n; *&n; * Concerning (1):&n; *&n; *&t;1.&t;We allocate stages dynamically only when we need them. When&n; *&t;&t;we don&squot;t need them, we don&squot;t consume additional memory. In&n; *&t;&t;case we can&squot;t allocate stages, we just manage without them&n; *&t;&t;(at the expense of decreased throughput) so when Linux is&n; *&t;&t;tight in memory, we will not pose additional difficulties.&n; *&n; *&t;2.&t;The maximum number of stages (which is, in fact, the maximum&n; *&t;&t;amount of memory) which we allocate is limited by the compile&n; *&t;&t;time parameter IDETAPE_MAX_PIPELINE_STAGES.&n; *&n; *&t;3.&t;The maximum number of stages is a controlled parameter - We&n; *&t;&t;don&squot;t start from the user defined maximum number of stages&n; *&t;&t;but from the lower IDETAPE_MIN_PIPELINE_STAGES (again, we&n; *&t;&t;will not even allocate this amount of stages if the user&n; *&t;&t;program can&squot;t handle the speed). We then implement a feedback&n; *&t;&t;loop which checks if the pipeline is empty, and if it is, we&n; *&t;&t;increase the maximum number of stages as necessary until we&n; *&t;&t;reach the optimum value which just manages to keep the tape&n; *&t;&t;busy with with minimum allocated memory or until we reach&n; *&t;&t;IDETAPE_MAX_PIPELINE_STAGES.&n; *&n; * Concerning (2):&n; *&n; *&t;In pipelined write mode, ide-tape can not return accurate error codes&n; *&t;to the user program since we usually just add the request to the&n; *      pipeline without waiting for it to be serviced. In case an error&n; *      occurs, I will report it on the next user request.&n; *&n; *&t;In the pipelined read mode, subsequent read requests or forward&n; *&t;filemark spacing will perform correctly, as we preserve all blocks&n; *&t;and filemarks which we encountered during our excess read-ahead.&n; * &n; *&t;For accurate tape positioning and error reporting, disabling&n; *&t;pipelined mode might be the best option.&n; *&n; * You can enable/disable/tune the pipelined operation mode by adjusting&n; * the compile time parameters in ide-tape.h.&n; */
multiline_comment|/*&n; *&t;Possible improvements.&n; *&n; *&t;1.&t;Support for the ATAPI overlap protocol.&n; *&n; *&t;&t;In order to maximize bus throughput, we currently use the DSC&n; *&t;&t;overlap method which enables ide.c to service requests from the&n; *&t;&t;other device while the tape is busy executing a command. The&n; *&t;&t;DSC overlap method involves polling the tape&squot;s status register&n; *&t;&t;for the DSC bit, and servicing the other device while the tape&n; *&t;&t;isn&squot;t ready.&n; *&n; *&t;&t;In the current QIC development standard (December 1995),&n; *&t;&t;it is recommended that new tape drives will *in addition* &n; *&t;&t;implement the ATAPI overlap protocol, which is used for the&n; *&t;&t;same purpose - efficient use of the IDE bus, but is interrupt&n; *&t;&t;driven and thus has much less CPU overhead.&n; *&n; *&t;&t;ATAPI overlap is likely to be supported in most new ATAPI&n; *&t;&t;devices, including new ATAPI cdroms, and thus provides us&n; *&t;&t;a method by which we can achieve higher throughput when&n; *&t;&t;sharing a (fast) ATA-2 disk with any (slow) new ATAPI device.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/io.h&gt;
multiline_comment|/*&n; *&t;Main Linux ide driver include file&n; *&n; *&t;Automatically includes our include file - ide-tape.h.&n; */
macro_line|#include &quot;ide.h&quot;&t;&t;
multiline_comment|/*&n; *&t;Supported ATAPI tape drives packet commands&n; */
DECL|macro|IDETAPE_TEST_UNIT_READY_CMD
mdefine_line|#define&t;IDETAPE_TEST_UNIT_READY_CMD&t;0x00
DECL|macro|IDETAPE_REWIND_CMD
mdefine_line|#define&t;IDETAPE_REWIND_CMD&t;&t;0x01
DECL|macro|IDETAPE_REQUEST_SENSE_CMD
mdefine_line|#define&t;IDETAPE_REQUEST_SENSE_CMD&t;0x03
DECL|macro|IDETAPE_READ_CMD
mdefine_line|#define&t;IDETAPE_READ_CMD&t;&t;0x08
DECL|macro|IDETAPE_WRITE_CMD
mdefine_line|#define&t;IDETAPE_WRITE_CMD&t;&t;0x0a
DECL|macro|IDETAPE_WRITE_FILEMARK_CMD
mdefine_line|#define&t;IDETAPE_WRITE_FILEMARK_CMD&t;0x10
DECL|macro|IDETAPE_SPACE_CMD
mdefine_line|#define&t;IDETAPE_SPACE_CMD&t;&t;0x11
DECL|macro|IDETAPE_INQUIRY_CMD
mdefine_line|#define&t;IDETAPE_INQUIRY_CMD&t;&t;0x12
DECL|macro|IDETAPE_ERASE_CMD
mdefine_line|#define&t;IDETAPE_ERASE_CMD&t;&t;0x19
DECL|macro|IDETAPE_MODE_SENSE_CMD
mdefine_line|#define&t;IDETAPE_MODE_SENSE_CMD&t;&t;0x1a
DECL|macro|IDETAPE_LOAD_UNLOAD_CMD
mdefine_line|#define&t;IDETAPE_LOAD_UNLOAD_CMD&t;&t;0x1b
DECL|macro|IDETAPE_LOCATE_CMD
mdefine_line|#define&t;IDETAPE_LOCATE_CMD&t;&t;0x2b
DECL|macro|IDETAPE_READ_POSITION_CMD
mdefine_line|#define&t;IDETAPE_READ_POSITION_CMD&t;0x34
multiline_comment|/*&n; *&t;Some defines for the SPACE command&n; *&n; *&t;(The code field in the SPACE packet command).&n; */
DECL|macro|IDETAPE_SPACE_OVER_FILEMARK
mdefine_line|#define&t;IDETAPE_SPACE_OVER_FILEMARK&t;1
DECL|macro|IDETAPE_SPACE_TO_EOD
mdefine_line|#define&t;IDETAPE_SPACE_TO_EOD&t;&t;3
multiline_comment|/*&n; *&t;Some defines for the LOAD UNLOAD command&n; */
DECL|macro|IDETAPE_LU_LOAD_MASK
mdefine_line|#define&t;IDETAPE_LU_LOAD_MASK&t;&t;1
DECL|macro|IDETAPE_LU_RETENSION_MASK
mdefine_line|#define&t;IDETAPE_LU_RETENSION_MASK&t;2
DECL|macro|IDETAPE_LU_EOT_MASK
mdefine_line|#define&t;IDETAPE_LU_EOT_MASK&t;&t;4
multiline_comment|/*&n; *&t;Our ioctls - We will use 0x034n and 0x035n&n; *&n; *&t;Nothing special meanwhile.&n; *&t;mtio.h MTIOCTOP compatible commands are supported on the character&n; *&t;device interface.&n; */
multiline_comment|/*&n; *&t;Special requests for our block device strategy routine.&n; *&n; *&t;In order to service a character device command, we add special&n; *&t;requests to the tail of our block device request queue and wait&n; *&t;for their completion.&n; *&n; */
DECL|macro|IDETAPE_FIRST_REQUEST
mdefine_line|#define&t;IDETAPE_FIRST_REQUEST&t;&t;&t;90
multiline_comment|/*&n; * &t;IDETAPE_PACKET_COMMAND_REQUEST_TYPE1 is used to queue a packet command&n; *&t;in the request queue. We will wait for DSC before issuing the command&n; *&t;if it is still not set. In that case, we will temporary replace the&n; *&t;cmd field to type 2 and restore it back to type 1 when we receive DSC&n; *&t;and can start with sending the command.&n; */
DECL|macro|IDETAPE_PACKET_COMMAND_REQUEST_TYPE1
mdefine_line|#define&t;IDETAPE_PACKET_COMMAND_REQUEST_TYPE1&t;90
DECL|macro|IDETAPE_PACKET_COMMAND_REQUEST_TYPE2
mdefine_line|#define&t;IDETAPE_PACKET_COMMAND_REQUEST_TYPE2&t;91
multiline_comment|/*&n; *&t;IDETAPE_READ_REQUEST and IDETAPE_WRITE_REQUEST are used by our&n; *&t;character device interface to request read/write operations from&n; *&t;our block device interface.&n; *&n; *&t;In case a read or write request was requested by the buffer cache&n; *&t;and not by our character device interface, the cmd field in the&n; *&t;request will contain READ and WRITE instead.&n; *&n; *&t;We handle both cases in a similar way. The main difference is that&n; *&t;in our own requests, buffer head is NULL and idetape_end_request&n; *&t;will update the errors field if the request was not completed.&n; */
DECL|macro|IDETAPE_READ_REQUEST
mdefine_line|#define&t;IDETAPE_READ_REQUEST&t;&t;&t;92
DECL|macro|IDETAPE_WRITE_REQUEST
mdefine_line|#define&t;IDETAPE_WRITE_REQUEST&t;&t;&t;93
DECL|macro|IDETAPE_LAST_REQUEST
mdefine_line|#define IDETAPE_LAST_REQUEST&t;&t;&t;93
multiline_comment|/*&n; *&t;A macro which can be used to check if a we support a given&n; *&t;request command.&n; */
DECL|macro|IDETAPE_REQUEST_CMD
mdefine_line|#define IDETAPE_REQUEST_CMD(cmd) &t;((cmd &gt;= IDETAPE_FIRST_REQUEST) &amp;&amp; (cmd &lt;= IDETAPE_LAST_REQUEST))
multiline_comment|/*&n; *&t;We are now able to postpone an idetape request in the stage&n; *&t;where it is polling for DSC and service requests from the other&n; *&t;ide device meanwhile.&n; */
DECL|macro|IDETAPE_RQ_POSTPONED
mdefine_line|#define&t;IDETAPE_RQ_POSTPONED&t;&t;0x1234
multiline_comment|/*&n; *&t;Error codes which are returned in rq-&gt;errors to the higher part&n; *&t;of the driver.&n; */
DECL|macro|IDETAPE_RQ_ERROR_GENERAL
mdefine_line|#define&t;IDETAPE_RQ_ERROR_GENERAL&t;1 
DECL|macro|IDETAPE_RQ_ERROR_FILEMARK
mdefine_line|#define&t;IDETAPE_RQ_ERROR_FILEMARK&t;2
DECL|macro|IDETAPE_RQ_ERROR_EOD
mdefine_line|#define&t;IDETAPE_RQ_ERROR_EOD&t;&t;3
multiline_comment|/*&n; *&t;ATAPI Task File Registers (Re-definition of the ATA Task File&n; *&t;Registers for an ATAPI packet command).&n; * &t;From Table 3-2 of QIC-157C.&n; */
multiline_comment|/* Read Access */
DECL|macro|IDETAPE_DATA_OFFSET
mdefine_line|#define&t;IDETAPE_DATA_OFFSET&t;&t;(0)
DECL|macro|IDETAPE_ERROR_OFFSET
mdefine_line|#define IDETAPE_ERROR_OFFSET&t;&t;(1)
DECL|macro|IDETAPE_IREASON_OFFSET
mdefine_line|#define&t;IDETAPE_IREASON_OFFSET&t;&t;(2)
DECL|macro|IDETAPE_RESERVED3_OFFSET
mdefine_line|#define IDETAPE_RESERVED3_OFFSET&t;(3)
DECL|macro|IDETAPE_BCOUNTL_OFFSET
mdefine_line|#define IDETAPE_BCOUNTL_OFFSET&t;&t;(4)
DECL|macro|IDETAPE_BCOUNTH_OFFSET
mdefine_line|#define&t;IDETAPE_BCOUNTH_OFFSET&t;&t;(5)
DECL|macro|IDETAPE_DRIVESEL_OFFSET
mdefine_line|#define IDETAPE_DRIVESEL_OFFSET&t;&t;(6)
DECL|macro|IDETAPE_STATUS_OFFSET
mdefine_line|#define&t;IDETAPE_STATUS_OFFSET&t;&t;(7)
DECL|macro|IDETAPE_DATA_REG
mdefine_line|#define&t;IDETAPE_DATA_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_DATA_OFFSET)
DECL|macro|IDETAPE_ERROR_REG
mdefine_line|#define IDETAPE_ERROR_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_ERROR_OFFSET)
DECL|macro|IDETAPE_IREASON_REG
mdefine_line|#define&t;IDETAPE_IREASON_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_IREASON_OFFSET)
DECL|macro|IDETAPE_RESERVED3_REG
mdefine_line|#define IDETAPE_RESERVED3_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_RESERVED3_OFFSET)
DECL|macro|IDETAPE_BCOUNTL_REG
mdefine_line|#define IDETAPE_BCOUNTL_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_BCOUNTL_OFFSET)
DECL|macro|IDETAPE_BCOUNTH_REG
mdefine_line|#define&t;IDETAPE_BCOUNTH_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_BCOUNTH_OFFSET)
DECL|macro|IDETAPE_DRIVESEL_REG
mdefine_line|#define IDETAPE_DRIVESEL_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_DRIVESEL_OFFSET)
DECL|macro|IDETAPE_STATUS_REG
mdefine_line|#define&t;IDETAPE_STATUS_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_STATUS_OFFSET)
multiline_comment|/* Write Access */
DECL|macro|IDETAPE_FEATURES_OFFSET
mdefine_line|#define&t;IDETAPE_FEATURES_OFFSET&t;&t;(1)
DECL|macro|IDETAPE_ATACOMMAND_OFFSET
mdefine_line|#define IDETAPE_ATACOMMAND_OFFSET&t;(7)
DECL|macro|IDETAPE_FEATURES_REG
mdefine_line|#define IDETAPE_FEATURES_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_FEATURES_OFFSET)
DECL|macro|IDETAPE_ATACOMMAND_REG
mdefine_line|#define IDETAPE_ATACOMMAND_REG&t;&t;(HWIF(drive)-&gt;io_base+IDETAPE_ATACOMMAND_OFFSET)
DECL|macro|IDETAPE_CONTROL_REG
mdefine_line|#define IDETAPE_CONTROL_REG&t;&t;(HWIF(drive)-&gt;ctl_port)
multiline_comment|/*&n; *&t;Structure of the various task file registers&n; */
multiline_comment|/*&n; *&t;The ATAPI Status Register.&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
DECL|member|check
r_int
id|check
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Error occurred */
DECL|member|idx
r_int
id|idx
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|corr
r_int
id|corr
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Correctable error occurred */
DECL|member|drq
r_int
id|drq
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Data is request by the device */
DECL|member|dsc
r_int
id|dsc
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Set when a media access command is finished */
multiline_comment|/* Reads / Writes are NOT media access commands */
DECL|member|reserved5
r_int
id|reserved5
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|drdy
r_int
id|drdy
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Ignored for ATAPI commands */
multiline_comment|/* (The device is ready to accept ATA command) */
DECL|member|bsy
r_int
id|bsy
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The device has access to the command block */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|idetape_status_reg_t
)brace
id|idetape_status_reg_t
suffix:semicolon
multiline_comment|/*&n; *&t;The ATAPI error register.&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
DECL|member|ili
r_int
id|ili
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Illegal Length Indication */
DECL|member|eom
r_int
id|eom
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* End Of Media Detected */
DECL|member|abrt
r_int
id|abrt
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Aborted command - As defined by ATA */
DECL|member|mcr
r_int
id|mcr
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Media Change Requested - As defined by ATA */
DECL|member|sense_key
r_int
id|sense_key
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* Sense key of the last failed packet command */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|idetape_error_reg_t
)brace
id|idetape_error_reg_t
suffix:semicolon
multiline_comment|/*&n; *&t;ATAPI Feature Register&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
DECL|member|dma
r_int
id|dma
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Using DMA of PIO */
DECL|member|reserved321
r_int
id|reserved321
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved654
r_int
id|reserved654
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Reserved (Tag Type) */
DECL|member|reserved7
r_int
id|reserved7
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|idetape_feature_reg_t
)brace
id|idetape_feature_reg_t
suffix:semicolon
multiline_comment|/*&n; *&t;ATAPI Byte Count Register.&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|16
suffix:semicolon
r_struct
(brace
DECL|member|low
r_int
id|low
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* LSB */
DECL|member|high
r_int
id|high
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* MSB */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|idetape_bcount_reg_t
)brace
id|idetape_bcount_reg_t
suffix:semicolon
multiline_comment|/*&n; *&t;ATAPI Interrupt Reason Register.&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
DECL|member|cod
r_int
id|cod
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Information transferred is command (1) or data (0) */
DECL|member|io
r_int
id|io
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The device requests us to read (1) or write (0) */
DECL|member|reserved
r_int
id|reserved
suffix:colon
l_int|6
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|idetape_ireason_reg_t
)brace
id|idetape_ireason_reg_t
suffix:semicolon
multiline_comment|/*&n; *&t;ATAPI Drive Select Register&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
DECL|member|sam_lun
r_int
id|sam_lun
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* Should be zero with ATAPI (not used) */
DECL|member|drv
r_int
id|drv
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The responding drive will be drive 0 (0) or drive 1 (1) */
DECL|member|one5
r_int
id|one5
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Should be set to 1 */
DECL|member|reserved6
r_int
id|reserved6
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|one7
r_int
id|one7
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Should be set to 1 */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|idetape_drivesel_reg_t
)brace
id|idetape_drivesel_reg_t
suffix:semicolon
multiline_comment|/*&n; *&t;ATAPI Device Control Register&n; */
r_typedef
r_union
(brace
r_int
id|all
suffix:colon
l_int|8
suffix:semicolon
r_struct
(brace
DECL|member|zero0
r_int
id|zero0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Should be set to zero */
DECL|member|nien
r_int
id|nien
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Device interrupt is disabled (1) or enabled (0) */
DECL|member|srst
r_int
id|srst
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* ATA software reset. ATAPI devices should use the new ATAPI srst. */
DECL|member|one3
r_int
id|one3
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Should be set to 1 */
DECL|member|reserved4567
r_int
id|reserved4567
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|b
)brace
id|b
suffix:semicolon
DECL|typedef|idetape_control_reg_t
)brace
id|idetape_control_reg_t
suffix:semicolon
multiline_comment|/*&n; *&t;idetape_chrdev_t provides the link between out character device&n; *&t;interface and our block device interface and the corresponding&n; *&t;ide_drive_t structure.&n; *&n; *&t;We currently support only one tape drive.&n; * &n; */
r_typedef
r_struct
(brace
DECL|member|drive
id|ide_drive_t
op_star
id|drive
suffix:semicolon
DECL|member|major
DECL|member|minor
r_int
id|major
comma
id|minor
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
l_int|4
)braket
suffix:semicolon
DECL|typedef|idetape_chrdev_t
)brace
id|idetape_chrdev_t
suffix:semicolon
multiline_comment|/*&n; *&t;The following is used to format the general configuration word of&n; *&t;the ATAPI IDENTIFY DEVICE command.&n; */
DECL|struct|idetape_id_gcw
r_struct
id|idetape_id_gcw
(brace
DECL|member|packet_size
r_int
id|packet_size
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Packet Size */
DECL|member|reserved2
r_int
id|reserved2
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved3
r_int
id|reserved3
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved4
r_int
id|reserved4
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|drq_type
r_int
id|drq_type
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Command packet DRQ type */
DECL|member|removable
r_int
id|removable
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Removable media */
DECL|member|device_type
r_int
id|device_type
suffix:colon
l_int|5
suffix:semicolon
multiline_comment|/* Device type */
DECL|member|reserved13
r_int
id|reserved13
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|protocol
r_int
id|protocol
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Protocol type */
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;INQUIRY packet command - Data Format (From Table 6-8 of QIC-157C)&n; */
r_typedef
r_struct
(brace
DECL|member|device_type
r_int
id|device_type
suffix:colon
l_int|5
suffix:semicolon
multiline_comment|/* Peripheral Device Type */
DECL|member|reserved0_765
r_int
id|reserved0_765
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Peripheral Qualifier - Reserved */
DECL|member|reserved1_6t0
r_int
id|reserved1_6t0
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|rmb
r_int
id|rmb
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Removable Medium Bit */
DECL|member|ansi_version
r_int
id|ansi_version
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* ANSI Version */
DECL|member|ecma_version
r_int
id|ecma_version
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* ECMA Version */
DECL|member|iso_version
r_int
id|iso_version
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* ISO Version */
DECL|member|response_format
r_int
id|response_format
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* Response Data Format */
DECL|member|reserved3_45
r_int
id|reserved3_45
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved3_6
r_int
id|reserved3_6
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* TrmIOP - Reserved */
DECL|member|reserved3_7
r_int
id|reserved3_7
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* AENC - Reserved */
DECL|member|additional_length
id|byte
id|additional_length
suffix:semicolon
multiline_comment|/* Additional Length (total_length-4) */
DECL|member|reserved_5
id|byte
id|reserved_5
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved_6
id|byte
id|reserved_6
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved7_0
r_int
id|reserved7_0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* SftRe - Reserved */
DECL|member|reserved7_1
r_int
id|reserved7_1
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* CmdQue - Reserved */
DECL|member|reserved7_2
r_int
id|reserved7_2
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved7_3
r_int
id|reserved7_3
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Linked - Reserved */
DECL|member|reserved7_4
r_int
id|reserved7_4
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Sync - Reserved */
DECL|member|reserved7_5
r_int
id|reserved7_5
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* WBus16 - Reserved */
DECL|member|reserved7_6
r_int
id|reserved7_6
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* WBus32 - Reserved */
DECL|member|reserved7_7
r_int
id|reserved7_7
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* RelAdr - Reserved */
DECL|member|vendor_id
id|byte
id|vendor_id
(braket
l_int|8
)braket
suffix:semicolon
multiline_comment|/* Vendor Identification */
DECL|member|product_id
id|byte
id|product_id
(braket
l_int|16
)braket
suffix:semicolon
multiline_comment|/* Product Identification */
DECL|member|revision_level
id|byte
id|revision_level
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/* Revision Level */
DECL|member|vendor_specific
id|byte
id|vendor_specific
(braket
l_int|20
)braket
suffix:semicolon
multiline_comment|/* Vendor Specific - Optional */
DECL|member|reserved56t95
id|byte
id|reserved56t95
(braket
l_int|40
)braket
suffix:semicolon
multiline_comment|/* Reserved - Optional */
multiline_comment|/* Additional information may be returned */
DECL|typedef|idetape_inquiry_result_t
)brace
id|idetape_inquiry_result_t
suffix:semicolon
multiline_comment|/*&n; *&t;READ POSITION packet command - Data Format (From Table 6-57)&n; */
r_typedef
r_struct
(brace
DECL|member|reserved0_10
r_int
id|reserved0_10
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|bpu
r_int
id|bpu
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Block Position Unknown */
DECL|member|reserved0_543
r_int
id|reserved0_543
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|eop
r_int
id|eop
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* End Of Partition */
DECL|member|bop
r_int
id|bop
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Beginning Of Partition */
DECL|member|partition_num
id|byte
id|partition_num
suffix:semicolon
multiline_comment|/* Partition Number */
DECL|member|reserved_2
id|byte
id|reserved_2
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved_3
id|byte
id|reserved_3
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|first_block
r_int
r_int
id|first_block
suffix:semicolon
multiline_comment|/* First Block Location */
DECL|member|last_block
r_int
r_int
id|last_block
suffix:semicolon
multiline_comment|/* Last Block Location (Optional) */
DECL|member|reserved_12
id|byte
id|reserved_12
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|blocks_in_buffer_2
id|byte
id|blocks_in_buffer_2
suffix:semicolon
multiline_comment|/* Blocks In Buffer - MSB (Optional) */
DECL|member|blocks_in_buffer_1
id|byte
id|blocks_in_buffer_1
suffix:semicolon
DECL|member|blocks_in_buffer_0
id|byte
id|blocks_in_buffer_0
suffix:semicolon
multiline_comment|/* Blocks In Buffer - LSB (Optional) */
DECL|member|bytes_in_buffer
r_int
r_int
id|bytes_in_buffer
suffix:semicolon
multiline_comment|/* Bytes In Buffer (Optional) */
DECL|typedef|idetape_read_position_result_t
)brace
id|idetape_read_position_result_t
suffix:semicolon
multiline_comment|/*&n; *&t;REQUEST SENSE packet command result - Data Format.&n; */
r_typedef
r_struct
(brace
DECL|member|error_code
r_int
id|error_code
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* Current of deferred errors */
DECL|member|valid
r_int
id|valid
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The information field conforms to QIC-157C */
DECL|member|reserved_1
r_int
id|reserved_1
suffix:colon
l_int|8
suffix:semicolon
multiline_comment|/* Segment Number - Reserved */
DECL|member|sense_key
r_int
id|sense_key
suffix:colon
l_int|4
suffix:semicolon
multiline_comment|/* Sense Key */
DECL|member|reserved2_4
r_int
id|reserved2_4
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|ili
r_int
id|ili
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Incorrect Length Indicator */
DECL|member|eom
r_int
id|eom
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* End Of Medium */
DECL|member|filemark
r_int
id|filemark
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Filemark */
multiline_comment|/*&n;&t; *&t;We can&squot;t use a 32 bit variable, since it will be re-aligned&n;&t; *&t;by GCC, as we are not on a 32 bit boundary.&n;&t; */
DECL|member|information1
id|byte
id|information1
suffix:semicolon
multiline_comment|/* MSB - Information - Command specific */
DECL|member|information2
id|byte
id|information2
suffix:semicolon
DECL|member|information3
id|byte
id|information3
suffix:semicolon
DECL|member|information4
id|byte
id|information4
suffix:semicolon
multiline_comment|/* LSB */
DECL|member|asl
id|byte
id|asl
suffix:semicolon
multiline_comment|/* Additional sense length (n-7) */
DECL|member|command_specific
r_int
r_int
id|command_specific
suffix:semicolon
multiline_comment|/* Additional command specific information */
DECL|member|asc
id|byte
id|asc
suffix:semicolon
multiline_comment|/* Additional Sense Code */
DECL|member|ascq
id|byte
id|ascq
suffix:semicolon
multiline_comment|/* Additional Sense Code Qualifier */
DECL|member|replaceable_unit_code
id|byte
id|replaceable_unit_code
suffix:semicolon
multiline_comment|/* Field Replaceable Unit Code */
DECL|member|sk_specific1
r_int
id|sk_specific1
suffix:colon
l_int|7
suffix:semicolon
multiline_comment|/* Sense Key Specific */
DECL|member|sksv
r_int
id|sksv
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Sense Key Specific information is valid */
DECL|member|sk_specific2
id|byte
id|sk_specific2
suffix:semicolon
multiline_comment|/* Sense Key Specific */
DECL|member|sk_specific3
id|byte
id|sk_specific3
suffix:semicolon
multiline_comment|/* Sense Key Specific */
DECL|member|pad
id|byte
id|pad
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/* Padding to 20 bytes */
DECL|typedef|idetape_request_sense_result_t
)brace
id|idetape_request_sense_result_t
suffix:semicolon
multiline_comment|/*&n; *&t;Follows structures which are related to the SELECT SENSE / MODE SENSE&n; *&t;packet commands. Those packet commands are still not supported&n; *&t;by ide-tape.&n; */
DECL|macro|IDETAPE_CAPABILITIES_PAGE
mdefine_line|#define&t;IDETAPE_CAPABILITIES_PAGE&t;0x2a
multiline_comment|/*&n; *&t;Mode Parameter Header for the MODE SENSE packet command&n; */
r_typedef
r_struct
(brace
DECL|member|mode_data_length
id|byte
id|mode_data_length
suffix:semicolon
multiline_comment|/* The length of the following data that is */
multiline_comment|/* available to be transferred */
DECL|member|medium_type
id|byte
id|medium_type
suffix:semicolon
multiline_comment|/* Medium Type */
DECL|member|dsp
id|byte
id|dsp
suffix:semicolon
multiline_comment|/* Device Specific Parameter */
DECL|member|bdl
id|byte
id|bdl
suffix:semicolon
multiline_comment|/* Block Descriptor Length */
DECL|typedef|idetape_mode_parameter_header_t
)brace
id|idetape_mode_parameter_header_t
suffix:semicolon
multiline_comment|/*&n; *&t;Mode Parameter Block Descriptor the MODE SENSE packet command&n; *&n; *&t;Support for block descriptors is optional.&n; */
r_typedef
r_struct
(brace
DECL|member|density_code
id|byte
id|density_code
suffix:semicolon
multiline_comment|/* Medium density code */
DECL|member|blocks1
id|byte
id|blocks1
suffix:semicolon
multiline_comment|/* Number of blocks - MSB */
DECL|member|blocks2
id|byte
id|blocks2
suffix:semicolon
multiline_comment|/* Number of blocks - Middle byte */
DECL|member|blocks3
id|byte
id|blocks3
suffix:semicolon
multiline_comment|/* Number of blocks - LSB */
DECL|member|reserved4
id|byte
id|reserved4
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|length1
id|byte
id|length1
suffix:semicolon
multiline_comment|/* Block Length - MSB */
DECL|member|length2
id|byte
id|length2
suffix:semicolon
multiline_comment|/* Block Length - Middle byte */
DECL|member|length3
id|byte
id|length3
suffix:semicolon
multiline_comment|/* Block Length - LSB */
DECL|typedef|idetape_parameter_block_descriptor_t
)brace
id|idetape_parameter_block_descriptor_t
suffix:semicolon
multiline_comment|/*&n; *&t;The Data Compression Page, as returned by the MODE SENSE packet command.&n; */
r_typedef
r_struct
(brace
DECL|member|page_code
r_int
id|page_code
suffix:colon
l_int|6
suffix:semicolon
multiline_comment|/* Page Code - Should be 0xf */
DECL|member|reserved
r_int
id|reserved
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|ps
r_int
id|ps
suffix:colon
l_int|1
suffix:semicolon
DECL|member|page_length
id|byte
id|page_length
suffix:semicolon
multiline_comment|/* Page Length - Should be 14 */
DECL|member|reserved2
r_int
id|reserved2
suffix:colon
l_int|6
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|dcc
r_int
id|dcc
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Data Compression Capable */
DECL|member|dce
r_int
id|dce
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Data Compression Enable */
DECL|member|reserved3
r_int
id|reserved3
suffix:colon
l_int|5
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|red
r_int
id|red
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Report Exception on Decompression */
DECL|member|dde
r_int
id|dde
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Data Decompression Enable */
DECL|member|ca
r_int
r_int
id|ca
suffix:semicolon
multiline_comment|/* Compression Algorithm */
DECL|member|da
r_int
r_int
id|da
suffix:semicolon
multiline_comment|/* Decompression Algorithm */
DECL|member|reserved_12
id|byte
id|reserved_12
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved_13
id|byte
id|reserved_13
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved_14
id|byte
id|reserved_14
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved_15
id|byte
id|reserved_15
suffix:semicolon
multiline_comment|/* Reserved */
DECL|typedef|idetape_data_compression_page_t
)brace
id|idetape_data_compression_page_t
suffix:semicolon
multiline_comment|/*&n; *&t;The Medium Partition Page, as returned by the MODE SENSE packet command.&n; */
r_typedef
r_struct
(brace
DECL|member|page_code
r_int
id|page_code
suffix:colon
l_int|6
suffix:semicolon
multiline_comment|/* Page Code - Should be 0x11 */
DECL|member|reserved1_6
r_int
id|reserved1_6
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|ps
r_int
id|ps
suffix:colon
l_int|1
suffix:semicolon
DECL|member|page_length
id|byte
id|page_length
suffix:semicolon
multiline_comment|/* Page Length - Should be 6 */
DECL|member|map
id|byte
id|map
suffix:semicolon
multiline_comment|/* Maximum Additional Partitions - Should be 0 */
DECL|member|apd
id|byte
id|apd
suffix:semicolon
multiline_comment|/* Additional Partitions Defined - Should be 0 */
DECL|member|reserved4_012
r_int
id|reserved4_012
suffix:colon
l_int|3
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|psum
r_int
id|psum
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Should be 0 */
DECL|member|idp
r_int
id|idp
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Should be 0 */
DECL|member|sdp
r_int
id|sdp
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Should be 0 */
DECL|member|fdp
r_int
id|fdp
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Fixed Data Partitions */
DECL|member|mfr
id|byte
id|mfr
suffix:semicolon
multiline_comment|/* Medium Format Recognition */
DECL|member|reserved6
id|byte
id|reserved6
suffix:semicolon
multiline_comment|/* Reserved */
DECL|member|reserved7
id|byte
id|reserved7
suffix:semicolon
multiline_comment|/* Reserved */
DECL|typedef|idetape_medium_partition_page_t
)brace
id|idetape_medium_partition_page_t
suffix:semicolon
multiline_comment|/*&n; *&t;Prototypes of various functions in ide-tape.c&n; *&n; *&t;The following functions are called from ide.c, and their prototypes&n; *&t;are available in ide.h:&n; *&n; *&t;&t;idetape_identify_device&n; *&t;&t;idetape_setup&n; *&t;&t;idetape_blkdev_ioctl&n; *&t;&t;idetape_do_request&n; *&t;&t;idetape_blkdev_open&n; *&t;&t;idetape_blkdev_release&n; *&t;&t;idetape_register_chrdev (void);&n; */
multiline_comment|/*&n; *&t;The following functions are used to transfer data from / to the&n; *&t;tape&squot;s data register.&n; */
r_void
id|idetape_input_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bcount
)paren
suffix:semicolon
r_void
id|idetape_output_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bcount
)paren
suffix:semicolon
r_void
id|idetape_discard_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|bcount
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Packet command related functions.&n; */
r_void
id|idetape_issue_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_packet_command_t
op_star
id|pc
comma
id|ide_handler_t
op_star
id|handler
)paren
suffix:semicolon
r_void
id|idetape_pc_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;DSC handling functions.&n; */
r_void
id|idetape_postpone_request
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_poll_for_dsc
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_void
id|idetape_poll_for_dsc_direct
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_void
id|idetape_put_back_postponed_request
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_media_access_finished
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Some more packet command related functions.&n; */
r_void
id|idetape_pc_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_retry_pc
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_zero_packet_command
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_void
id|idetape_queue_pc_head
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_packet_command_t
op_star
id|pc
comma
r_struct
id|request
op_star
id|rq
)paren
suffix:semicolon
r_void
id|idetape_analyze_error
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_request_sense_result_t
op_star
id|result
)paren
suffix:semicolon
id|idetape_packet_command_t
op_star
id|idetape_next_pc_storage
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|idetape_next_rq_storage
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Various packet commands&n; */
r_void
id|idetape_create_inquiry_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_void
id|idetape_inquiry_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_create_locate_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
r_int
id|block
comma
id|byte
id|partition
)paren
suffix:semicolon
r_void
id|idetape_create_rewind_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_void
id|idetape_create_write_filemark_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
id|write_filemark
)paren
suffix:semicolon
r_void
id|idetape_create_load_unload_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
id|cmd
)paren
suffix:semicolon
r_void
id|idetape_create_space_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
id|count
comma
id|byte
id|cmd
)paren
suffix:semicolon
r_void
id|idetape_create_erase_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_void
id|idetape_create_test_unit_ready_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_void
id|idetape_create_read_position_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_void
id|idetape_read_position_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_create_read_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
r_int
id|length
)paren
suffix:semicolon
r_void
id|idetape_read_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_create_write_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
r_int
id|length
)paren
suffix:semicolon
r_void
id|idetape_write_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_create_request_sense_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_void
id|idetape_create_mode_sense_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
id|byte
id|page_code
)paren
suffix:semicolon
r_void
id|idetape_request_sense_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_display_inquiry_result
(paren
id|byte
op_star
id|buffer
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Character device callback functions.&n; *&n; *&t;We currently support:&n; *&n; *&t;&t;OPEN, RELEASE, READ, WRITE and IOCTL.&n; */
r_int
id|idetape_chrdev_read
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_int
id|idetape_chrdev_write
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
suffix:semicolon
r_int
id|idetape_chrdev_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_int
id|idetape_chrdev_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_void
id|idetape_chrdev_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;idetape_mtioctop implements general magnetic tape io control&n; *&t;commands, as defined in include/linux/mtio.h. Those commands are&n; *&t;accessed through the character device interface, using the MTIOCTOP&n; *&t;ioctl.&n; */
r_int
id|idetape_mtioctop
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|mt_op
comma
r_int
id|mt_count
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;idetape_space_over_filemarks handles the MTFSF, MTFSFM, ... mtio.h&n; *&t;commands.&n; */
r_int
id|idetape_space_over_filemarks
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|mt_op
comma
r_int
id|mt_count
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;idetape_add_chrdev_read_request is called from idetape_chrdev_read&n; *&t;to service a character device read request and add read-ahead&n; *&t;requests to our pipeline.&n; */
r_int
id|idetape_add_chrdev_read_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|blocks
comma
r_char
op_star
id|buffer
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;idetape_add_chrdev_write_request adds a character device write&n; *&t;request to the pipeline.&n; */
r_int
id|idetape_add_chrdev_write_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|blocks
comma
r_char
op_star
id|buffer
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;idetape_queue_rw_tail will add a command to the tail of the device&n; *&t;request queue and wait for it to finish. This is used when we&n; *&t;can not allocate pipeline stages (or in non-pipelined mode).&n; */
r_int
id|idetape_queue_rw_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|cmd
comma
r_int
id|blocks
comma
r_char
op_star
id|buffer
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Adds a packet command request to the tail of the device request&n; *&t;queue and waits for it to be serviced.&n; */
r_int
id|idetape_queue_pc_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_packet_command_t
op_star
id|pc
)paren
suffix:semicolon
r_int
id|idetape_position_tape
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|block
)paren
suffix:semicolon
r_int
id|idetape_rewind_tape
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_int
id|idetape_flush_tape_buffers
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;Used to get device information&n; */
r_void
id|idetape_get_mode_sense_results
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;General utility functions&n; */
r_int
r_int
id|idetape_swap_long
(paren
r_int
r_int
id|temp
)paren
suffix:semicolon
r_int
r_int
id|idetape_swap_short
(paren
r_int
r_int
id|temp
)paren
suffix:semicolon
DECL|macro|IDETAPE_MIN
mdefine_line|#define IDETAPE_MIN(a,b)&t;((a)&lt;(b) ? (a):(b))
multiline_comment|/*&n; *&t;Pipeline related functions&n; */
id|idetape_pipeline_stage_t
op_star
id|idetape_kmalloc_stage
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_kfree_stage
(paren
id|idetape_pipeline_stage_t
op_star
id|stage
)paren
suffix:semicolon
r_void
id|idetape_copy_buffer_from_stage
(paren
id|idetape_pipeline_stage_t
op_star
id|stage
comma
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_void
id|idetape_copy_buffer_to_stage
(paren
id|idetape_pipeline_stage_t
op_star
id|stage
comma
r_char
op_star
id|buffer
)paren
suffix:semicolon
r_void
id|idetape_increase_max_pipeline_stages
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_add_stage_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pipeline_stage_t
op_star
id|stage
)paren
suffix:semicolon
r_void
id|idetape_remove_stage_head
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_active_next_stage
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_wait_for_pipeline
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_discard_read_pipeline
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_empty_write_pipeline
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_void
id|idetape_insert_pipeline_into_queue
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n; *&t;For general magnetic tape device compatibility.&n; */
macro_line|#include &lt;linux/mtio.h&gt;
multiline_comment|/*&n; *&t;Global variables&n; *&n; *&t;The variables below are used for the character device interface.&n; *&n; *&t;Additional state variables are defined in our ide_drive_t structure.&n; */
DECL|variable|idetape_chrdev
id|idetape_chrdev_t
id|idetape_chrdev
suffix:semicolon
multiline_comment|/* Character device interface information */
DECL|variable|idetape_drive_already_found
id|byte
id|idetape_drive_already_found
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 1 when the above data structure is initialized */
multiline_comment|/*&n; *&t;Our character device supporting functions, passed to register_chrdev.&n; */
DECL|variable|idetape_fops
r_static
r_struct
id|file_operations
id|idetape_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|idetape_chrdev_read
comma
multiline_comment|/* read  */
id|idetape_chrdev_write
comma
multiline_comment|/* write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|idetape_chrdev_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|idetape_chrdev_open
comma
multiline_comment|/* open */
id|idetape_chrdev_release
comma
multiline_comment|/* release */
l_int|NULL
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
l_int|NULL
comma
multiline_comment|/* check_media_change */
l_int|NULL
multiline_comment|/* revalidate */
)brace
suffix:semicolon
multiline_comment|/*&n; *&t;idetape_identify_device is called by do_identify in ide.c during&n; *&t;the device probing stage to check the contents of the ATAPI IDENTIFY&n; *&t;command results, in case the device type is tape. We return:&n; *&n; *&t;1&t;If the tape can be supported by us, based on the information&n; *&t;&t;we have so far.&n; *&n; *&t;0 &t;If this tape driver is not currently supported by us.&n; *&n; *&t;In case we decide to support the tape, we store the current drive&n; *&t;pointer in our character device global variables, so that we can&n; *&t;pass between both interfaces.&n; */
DECL|function|idetape_identify_device
r_int
id|idetape_identify_device
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|hd_driveid
op_star
id|id
)paren
(brace
r_struct
id|idetape_id_gcw
id|gcw
suffix:semicolon
r_int
r_int
op_star
id|ptr
suffix:semicolon
r_int
id|support
op_assign
l_int|1
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
r_int
r_int
id|mask
comma
id|i
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
id|gcw
suffix:semicolon
op_star
id|ptr
op_assign
id|id-&gt;config
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Dumping ATAPI Identify Device tape parameters&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Protocol Type: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|gcw.protocol
)paren
(brace
r_case
l_int|0
suffix:colon
r_case
l_int|1
suffix:colon
id|printk
(paren
l_string|&quot;ATA&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
(paren
l_string|&quot;ATAPI&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
(paren
l_string|&quot;Reserved (Unknown to ide-tape)&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Device Type: %x - &quot;
comma
id|gcw.device_type
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|gcw.device_type
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
(paren
l_string|&quot;Direct-access Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
(paren
l_string|&quot;Streaming Tape Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
r_case
l_int|4
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printk
(paren
l_string|&quot;CD-ROM Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_case
l_int|7
suffix:colon
id|printk
(paren
l_string|&quot;Optical memory Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1f
suffix:colon
id|printk
(paren
l_string|&quot;Unknown or no Device type&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Removable: %s&quot;
comma
id|gcw.removable
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Command Packet DRQ Type: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|gcw.drq_type
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
(paren
l_string|&quot;Microprocessor DRQ&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
(paren
l_string|&quot;Interrupt DRQ&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|printk
(paren
l_string|&quot;Accelerated DRQ&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Command Packet Size: &quot;
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|gcw.packet_size
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
(paren
l_string|&quot;12 bytes&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
(paren
l_string|&quot;16 bytes&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Model: %s&bslash;n&quot;
comma
id|id-&gt;model
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Firmware Revision: %s&bslash;n&quot;
comma
id|id-&gt;fw_rev
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Serial Number: %s&bslash;n&quot;
comma
id|id-&gt;serial_no
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Write buffer size: %d bytes&bslash;n&quot;
comma
id|id-&gt;buf_size
op_star
l_int|512
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;DMA: %s&quot;
comma
id|id-&gt;capability
op_amp
l_int|0x01
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;LBA: %s&quot;
comma
id|id-&gt;capability
op_amp
l_int|0x02
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;IORDY can be disabled: %s&quot;
comma
id|id-&gt;capability
op_amp
l_int|0x04
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;IORDY supported: %s&quot;
comma
id|id-&gt;capability
op_amp
l_int|0x08
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;Unknown&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ATAPI overlap supported: %s&quot;
comma
id|id-&gt;capability
op_amp
l_int|0x20
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;PIO Cycle Timing Category: %d&bslash;n&quot;
comma
id|id-&gt;tPIO
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;DMA Cycle Timing Category: %d&bslash;n&quot;
comma
id|id-&gt;tDMA
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Single Word DMA supported modes: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
comma
id|mask
op_assign
id|mask
op_lshift
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|id-&gt;dma_1word
op_amp
id|mask
)paren
id|printk
(paren
l_string|&quot;%d &quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;dma_1word
op_amp
(paren
id|mask
op_lshift
l_int|8
)paren
)paren
id|printk
(paren
l_string|&quot;(active) &quot;
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Multi Word DMA supported modes: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mask
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
comma
id|mask
op_assign
id|mask
op_lshift
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|id-&gt;dma_mword
op_amp
id|mask
)paren
id|printk
(paren
l_string|&quot;%d &quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;dma_mword
op_amp
(paren
id|mask
op_lshift
l_int|8
)paren
)paren
id|printk
(paren
l_string|&quot;(active) &quot;
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|0x0002
)paren
(brace
id|printk
(paren
l_string|&quot;Enhanced PIO Modes: %s&bslash;n&quot;
comma
id|id-&gt;eide_pio_modes
op_amp
l_int|1
ques
c_cond
l_string|&quot;Mode 3&quot;
suffix:colon
l_string|&quot;None&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Minimum Multi-word DMA cycle per word: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;eide_dma_min
op_eq
l_int|0
)paren
id|printk
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;%d ns&bslash;n&quot;
comma
id|id-&gt;eide_dma_min
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Manufacturer&bslash;&squot;s Recommended Multi-word cycle: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;eide_dma_time
op_eq
l_int|0
)paren
id|printk
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;%d ns&bslash;n&quot;
comma
id|id-&gt;eide_dma_time
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Minimum PIO cycle without IORDY: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;eide_pio
op_eq
l_int|0
)paren
id|printk
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;%d ns&bslash;n&quot;
comma
id|id-&gt;eide_pio
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Minimum PIO cycle with IORDY: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id-&gt;eide_pio_iordy
op_eq
l_int|0
)paren
id|printk
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;%d ns&bslash;n&quot;
comma
id|id-&gt;eide_pio_iordy
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;According to the device, fields 64-70 are not valid.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_LOG */
multiline_comment|/* Check that we can support this device */
r_if
c_cond
(paren
id|gcw.protocol
op_ne
l_int|2
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Protocol is not ATAPI&bslash;n&quot;
)paren
suffix:semicolon
id|support
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gcw.device_type
op_ne
l_int|1
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Device type is not set to tape&bslash;n&quot;
)paren
suffix:semicolon
id|support
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|gcw.removable
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: The removable flag is not set&bslash;n&quot;
)paren
suffix:semicolon
id|support
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gcw.drq_type
op_ne
l_int|2
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Sorry, DRQ types other than Accelerated DRQ&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: are still not supported by the driver&bslash;n&quot;
)paren
suffix:semicolon
id|support
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|gcw.packet_size
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Packet size is not 12 bytes long&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gcw.packet_size
op_eq
l_int|1
)paren
id|printk
(paren
l_string|&quot;ide-tape: Sorry, padding to 16 bytes is still not supported&bslash;n&quot;
)paren
suffix:semicolon
id|support
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|idetape_drive_already_found
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Sorry, only one ide tape drive is supported by the driver&bslash;n&quot;
)paren
suffix:semicolon
id|support
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|idetape_drive_already_found
op_assign
l_int|1
suffix:semicolon
id|idetape_chrdev.drive
op_assign
id|drive
suffix:semicolon
id|idetape_chrdev.major
op_assign
id|IDETAPE_MAJOR
suffix:semicolon
id|idetape_chrdev.minor
op_assign
l_int|0
suffix:semicolon
id|idetape_chrdev.name
(braket
l_int|0
)braket
op_assign
l_char|&squot;h&squot;
suffix:semicolon
id|idetape_chrdev.name
(braket
l_int|1
)braket
op_assign
l_char|&squot;t&squot;
suffix:semicolon
id|idetape_chrdev.name
(braket
l_int|2
)braket
op_assign
l_char|&squot;0&squot;
suffix:semicolon
id|idetape_chrdev.name
(braket
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
)brace
r_return
(paren
id|support
)paren
suffix:semicolon
multiline_comment|/* In case support=0, we will not install the driver */
)brace
multiline_comment|/*&n; *&t;idetape_register_chrdev calls register_chrdev to register our character&n; *&t;device interface. The connection to the ide_drive_t structure, which&n; *&t;is used by the entire ide driver is provided by our global variable&n; *&t;idetape_chrdev.drive, which was initialized earlier, during the device&n; *&t;probing stage.&n; */
DECL|function|idetape_register_chrdev
r_void
id|idetape_register_chrdev
(paren
r_void
)paren
(brace
r_int
id|major
comma
id|minor
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|idetape_drive_already_found
)paren
r_return
suffix:semicolon
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
id|major
op_assign
id|idetape_chrdev.major
suffix:semicolon
id|minor
op_assign
id|idetape_chrdev.minor
suffix:semicolon
r_if
c_cond
(paren
id|register_chrdev
(paren
id|major
comma
id|idetape_chrdev.name
comma
op_amp
id|idetape_fops
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;Unable to register character device interface !&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* ??? */
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;ide-tape: %s &lt;-&gt; %s : Character device interface on major = %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|idetape_chrdev.name
comma
id|major
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;idetape_setup is called from the ide driver in the partition table&n; *&t;identification stage, to:&n; *&n; *&t;&t;1.&t;Initialize our various state variables.&n; *&t;&t;2.&t;Ask the tape for its capabilities.&n; *&t;&t;3.&t;Allocate a buffer which will be used for data&n; *&t;&t;&t;transfer. The buffer size is chosen based on&n; *&t;&t;&t;the recommendation which we received in step (2).&n; *&n; *&t;Note that at this point ide.c already assigned us an irq, so that&n; *&t;we can queue requests here and wait for their completion.&n; */
DECL|function|idetape_setup
r_void
id|idetape_setup
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_int
r_int
id|allocation_length
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_setup&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */&t;
id|drive-&gt;ready_stat
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* With an ATAPI device, we can issue packet commands */
multiline_comment|/* regardless of the state of DRDY */
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|tape_drive
op_assign
id|drive
suffix:semicolon
id|tape-&gt;block_address
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;block_address_valid
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;pc_stack_index
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;postponed_rq
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;active_data_request
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;current_number_of_stages
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;first_stage
op_assign
id|tape-&gt;next_stage
op_assign
id|tape-&gt;last_stage
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;error_in_pipeline_stage
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;request_status
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;chrdev_direction
op_assign
id|idetape_direction_none
suffix:semicolon
id|tape-&gt;reset_issued
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;pc
op_assign
op_amp
(paren
id|tape-&gt;pc_stack
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#if IDETAPE_PIPELINE
id|tape-&gt;max_number_of_stages
op_assign
id|IDETAPE_MIN_PIPELINE_STAGES
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: Operating in pipelined (fast and tricky) operation mode.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|tape-&gt;max_number_of_stages
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: Operating in non-pipelined (slow and safe) operation mode.&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_PIPELINE */
id|idetape_get_mode_sense_results
(paren
id|drive
)paren
suffix:semicolon
id|tape-&gt;data_buffer_size
op_assign
id|tape-&gt;capabilities.ctl
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
r_while
c_loop
(paren
id|tape-&gt;data_buffer_size
OG
l_int|0xffff
)paren
(brace
id|tape-&gt;capabilities.ctl
op_div_assign
l_int|2
suffix:semicolon
id|tape-&gt;data_buffer_size
op_assign
id|tape-&gt;capabilities.ctl
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
)brace
id|allocation_length
op_assign
id|tape-&gt;data_buffer_size
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;data_buffer_size
op_mod
id|IDETAPE_ALLOCATION_BLOCK
)paren
id|allocation_length
op_add_assign
id|IDETAPE_ALLOCATION_BLOCK
suffix:semicolon
macro_line|#if IDETAPE_MINIMIZE_IDLE_MEMORY_USAGE
id|tape-&gt;data_buffer
op_assign
id|tape-&gt;merge_buffer
op_assign
l_int|NULL
suffix:semicolon
macro_line|#else
id|tape-&gt;data_buffer
op_assign
id|kmalloc
(paren
id|allocation_length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|tape-&gt;merge_buffer
op_assign
id|kmalloc
(paren
id|allocation_length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;data_buffer
op_eq
l_int|NULL
op_logical_or
id|tape-&gt;merge_buffer
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: FATAL - Can not allocate 2 buffers of %d bytes each&bslash;n&quot;
comma
id|allocation_length
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: Aborting character device installation&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_drive_already_found
op_assign
l_int|0
suffix:semicolon
id|unregister_chrdev
(paren
id|idetape_chrdev.major
comma
id|idetape_chrdev.name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_MINIMIZE_IDLE_MEMORY_USAGE */
id|tape-&gt;merge_buffer_size
op_assign
id|tape-&gt;merge_buffer_offset
op_assign
l_int|0
suffix:semicolon
macro_line|#if IDETAPE_ANTICIPATE_READ_WRITE_DSC
multiline_comment|/*&n;&t; *&t;Cleverly select the DSC read/write polling frequency, based&n;&t; *&t;on the tape&squot;s speed, its recommended transfer unit, its&n;&t; *&t;internal buffer size and our operation mode.&n;&t; *&n;&t; *&t;In the pipelined operation mode we aim for &quot;catching&quot; the&n;&t; *&t;tape when its internal buffer is about 50% full. This will&n;&t; *&t;dramatically reduce our polling frequency and will also&n;&t; *&t;leave enough time for the ongoing request of the other device&n;&t; *&t;to complete before the buffer is completely empty. We will&n;&t; *&t;then completely refill the buffer with requests from our&n;&t; *&t;internal pipeline.&n;&t; *&n;&t; *&t;When operating in the non-pipelined operation mode, we&n;&t; *&t;can&squot;t allow ourself this luxury. Instead, we will try to take&n;&t; *&t;full advantage of the internal tape buffer by waiting only&n;&t; *&t;for one request to complete. This will increase our load&n;&t; *&t;on linux but will usually still fail to keep the tape&n;&t; *&t;constantly streaming.&n;&t; */
r_if
c_cond
(paren
id|tape-&gt;max_number_of_stages
)paren
id|tape-&gt;best_dsc_rw_frequency
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
id|tape-&gt;capabilities.buffer_size
op_star
l_int|32
op_star
id|HZ
)paren
op_div
(paren
id|tape-&gt;capabilities.speed
op_star
l_int|125
)paren
)paren
suffix:semicolon
r_else
id|tape-&gt;best_dsc_rw_frequency
op_assign
(paren
r_int
r_int
)paren
(paren
(paren
id|tape-&gt;data_buffer_size
op_star
id|HZ
)paren
op_div
(paren
id|tape-&gt;capabilities.speed
op_star
l_int|1000
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Ensure that the number we got makes sense.&n;&t; */
r_if
c_cond
(paren
id|tape-&gt;best_dsc_rw_frequency
OG
id|IDETAPE_DSC_READ_WRITE_LOWEST_FREQUENCY
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Although the recommended polling period is %lu jiffies, &bslash;n&quot;
comma
id|tape-&gt;best_dsc_rw_frequency
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: we will use %u jiffies&bslash;n&quot;
comma
id|IDETAPE_DSC_READ_WRITE_LOWEST_FREQUENCY
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: (It may well be that we are wrong here)&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;best_dsc_rw_frequency
op_assign
id|IDETAPE_DSC_READ_WRITE_LOWEST_FREQUENCY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;best_dsc_rw_frequency
OL
id|IDETAPE_DSC_READ_WRITE_FALLBACK_FREQUENCY
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Although the recommended polling period is %lu jiffies, &bslash;n&quot;
comma
id|tape-&gt;best_dsc_rw_frequency
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: we will use %u jiffies&bslash;n&quot;
comma
id|IDETAPE_DSC_READ_WRITE_FALLBACK_FREQUENCY
)paren
suffix:semicolon
id|tape-&gt;best_dsc_rw_frequency
op_assign
id|IDETAPE_DSC_READ_WRITE_FALLBACK_FREQUENCY
suffix:semicolon
)brace
macro_line|#else
id|tape-&gt;best_dsc_rw_frequency
op_assign
id|IDETAPE_DSC_READ_WRITE_FALLBACK_FREQUENCY
suffix:semicolon
macro_line|#endif /* IDETAPE_ANTICIPATE_READ_WRITE_DSC */
id|printk
(paren
l_string|&quot;ide-tape: Tape speed - %d KBps. Recommended transfer unit - %d bytes.&bslash;n&quot;
comma
id|tape-&gt;capabilities.speed
comma
id|tape-&gt;data_buffer_size
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_get_mode_sense_results asks the tape about its various&n; *&t;parameters. In particular, we will adjust our data transfer buffer&n; *&t;size to the recommended value as returned by the tape.&n; */
DECL|function|idetape_get_mode_sense_results
r_void
id|idetape_get_mode_sense_results
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|retval
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_mode_parameter_header_t
op_star
id|header
suffix:semicolon
id|idetape_capabilities_page_t
op_star
id|capabilities
suffix:semicolon
id|idetape_packet_command_t
id|pc
suffix:semicolon
id|idetape_create_mode_sense_cmd
(paren
op_amp
id|pc
comma
id|IDETAPE_CAPABILITIES_PAGE
)paren
suffix:semicolon
id|pc.buffer
op_assign
id|pc.temp_buffer
suffix:semicolon
id|pc.buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc.current_position
op_assign
id|pc.temp_buffer
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
id|header
op_assign
(paren
id|idetape_mode_parameter_header_t
op_star
)paren
id|pc.buffer
suffix:semicolon
id|capabilities
op_assign
(paren
id|idetape_capabilities_page_t
op_star
)paren
(paren
id|pc.buffer
op_plus
r_sizeof
(paren
id|idetape_mode_parameter_header_t
)paren
)paren
suffix:semicolon
id|capabilities-&gt;max_speed
op_assign
id|idetape_swap_short
(paren
id|capabilities-&gt;max_speed
)paren
suffix:semicolon
id|capabilities-&gt;ctl
op_assign
id|idetape_swap_short
(paren
id|capabilities-&gt;ctl
)paren
suffix:semicolon
id|capabilities-&gt;speed
op_assign
id|idetape_swap_short
(paren
id|capabilities-&gt;speed
)paren
suffix:semicolon
id|capabilities-&gt;buffer_size
op_assign
id|idetape_swap_short
(paren
id|capabilities-&gt;buffer_size
)paren
suffix:semicolon
id|tape-&gt;capabilities
op_assign
op_star
id|capabilities
suffix:semicolon
multiline_comment|/* Save us a copy */
id|tape-&gt;tape_block_size
op_assign
id|capabilities-&gt;blk512
ques
c_cond
l_int|512
suffix:colon
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Can&squot;t get tape parameters&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: Assuming some default parameters&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;tape_block_size
op_assign
l_int|512
suffix:semicolon
id|tape-&gt;capabilities.ctl
op_assign
l_int|52
suffix:semicolon
id|tape-&gt;capabilities.speed
op_assign
l_int|450
suffix:semicolon
id|tape-&gt;capabilities.buffer_size
op_assign
l_int|6
op_star
l_int|52
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Dumping the results of the MODE SENSE packet command&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Mode Parameter Header:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Mode Data Length - %d&bslash;n&quot;
comma
id|header-&gt;mode_data_length
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Medium Type - %d&bslash;n&quot;
comma
id|header-&gt;medium_type
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Device Specific Parameter - %d&bslash;n&quot;
comma
id|header-&gt;dsp
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Block Descriptor Length - %d&bslash;n&quot;
comma
id|header-&gt;bdl
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Capabilities and Mechanical Status Page:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Page code - %d&bslash;n&quot;
comma
id|capabilities-&gt;page_code
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Page length - %d&bslash;n&quot;
comma
id|capabilities-&gt;page_length
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Read only - %s&bslash;n&quot;
comma
id|capabilities-&gt;ro
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports reverse space - %s&bslash;n&quot;
comma
id|capabilities-&gt;sprev
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports erase initiated formatting - %s&bslash;n&quot;
comma
id|capabilities-&gt;efmt
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports QFA two Partition format - %s&bslash;n&quot;
comma
id|capabilities-&gt;qfa
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports locking the medium - %s&bslash;n&quot;
comma
id|capabilities-&gt;lock
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;The volume is currently locked - %s&bslash;n&quot;
comma
id|capabilities-&gt;locked
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;The device defaults in the prevent state - %s&bslash;n&quot;
comma
id|capabilities-&gt;prevent
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports ejecting the medium - %s&bslash;n&quot;
comma
id|capabilities-&gt;eject
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports error correction - %s&bslash;n&quot;
comma
id|capabilities-&gt;ecc
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports data compression - %s&bslash;n&quot;
comma
id|capabilities-&gt;cmprs
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports 512 bytes block size - %s&bslash;n&quot;
comma
id|capabilities-&gt;blk512
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Supports 1024 bytes block size - %s&bslash;n&quot;
comma
id|capabilities-&gt;blk1024
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Restricted byte count for PIO transfers - %s&bslash;n&quot;
comma
id|capabilities-&gt;slowb
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Maximum supported speed in KBps - %d&bslash;n&quot;
comma
id|capabilities-&gt;max_speed
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Continuous transfer limits in blocks - %d&bslash;n&quot;
comma
id|capabilities-&gt;ctl
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Current speed in KBps - %d&bslash;n&quot;
comma
id|capabilities-&gt;speed
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Buffer size - %d&bslash;n&quot;
comma
id|capabilities-&gt;buffer_size
op_star
l_int|512
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
)brace
multiline_comment|/*&n; *&t;Packet Command Interface&n; *&n; *&t;The current Packet Command is available in tape-&gt;pc, and will not&n; *&t;change until we finish handling it. Each packet command is associated&n; *&t;with a callback function that will be called when the command is&n; *&t;finished.&n; *&n; *&t;The handling will be done in three stages:&n; *&n; *&t;1.&t;idetape_issue_packet_command will send the packet command to the&n; *&t;&t;drive, and will set the interrupt handler to idetape_pc_intr.&n; *&n; *&t;2.&t;On each interrupt, idetape_pc_intr will be called. This step&n; *&t;&t;will be repeated until the device signals us that no more&n; *&t;&t;interrupts will be issued.&n; *&n; *&t;3.&t;ATAPI Tape media access commands have immediate status with a&n; *&t;&t;delayed process. In case of a successful initiation of a&n; *&t;&t;media access packet command, the DSC bit will be set when the&n; *&t;&t;actual execution of the command is finished. &n; *&t;&t;Since the tape drive will not issue an interrupt, we have to&n; *&t;&t;poll for this event. In this case, we define the request as&n; *&t;&t;&quot;low priority request&quot; by setting rq_status to&n; *&t;&t;IDETAPE_RQ_POSTPONED, &t;set a timer to poll for DSC and exit&n; *&t;&t;the driver.&n; *&n; *&t;&t;ide.c will then give higher priority to requests which&n; *&t;&t;originate from the other device, until will change rq_status&n; *&t;&t;to RQ_ACTIVE.&n; *&n; *&t;4.&t;When the packet command is finished, it will be checked for errors.&n; *&n; *&t;5.&t;In case an error was found, we queue a request sense packet command&n; *&t;&t;in front of the request queue and retry the operation up to&n; *&t;&t;IDETAPE_MAX_PC_RETRIES times.&n; *&n; *&t;6.&t;In case no error was found, or we decided to give up and not&n; *&t;&t;to retry again, the callback function will be called and then&n; *&t;&t;we will handle the next request.&n; *&n; */
DECL|function|idetape_issue_packet_command
r_void
id|idetape_issue_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_packet_command_t
op_star
id|pc
comma
id|ide_handler_t
op_star
id|handler
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
id|idetape_bcount_reg_t
id|bcount
suffix:semicolon
id|idetape_ireason_reg_t
id|ireason
suffix:semicolon
r_int
id|dma_ok
op_assign
l_int|0
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_REQUEST_SENSE_CMD
op_logical_and
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_REQUEST_SENSE_CMD
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: possible ide-tape.c bug - Two request sense in serial were issued&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
r_if
c_cond
(paren
id|tape-&gt;failed_pc
op_eq
l_int|NULL
op_logical_and
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|IDETAPE_REQUEST_SENSE_CMD
)paren
id|tape-&gt;failed_pc
op_assign
id|pc
suffix:semicolon
id|tape-&gt;pc
op_assign
id|pc
suffix:semicolon
multiline_comment|/* Set the current packet command */
r_if
c_cond
(paren
id|pc-&gt;retries
OG
id|IDETAPE_MAX_PC_RETRIES
op_logical_or
id|pc
op_member_access_from_pointer
m_abort
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We will &quot;abort&quot; retrying a packet command in case&n;&t;&t; *&t;a legitimate error code was received (crossing a&n;&t;&t; *&t;filemark, or DMA error in the end of media, for&n;&t;&t; *&t;example).&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|pc
op_member_access_from_pointer
m_abort
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: %s: I/O error, &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;pc = %x, key = %x, asc = %x, ascq = %x&bslash;n&quot;
comma
id|pc-&gt;c
(braket
l_int|0
)braket
comma
id|tape-&gt;sense_key
comma
id|tape-&gt;asc
comma
id|tape-&gt;ascq
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Maximum retries reached - Giving up&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|pc-&gt;error
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Giving up */
)brace
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|pc-&gt;callback
op_eq
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;ide-tape: ide-tape bug - Callback function not set !&bslash;n&quot;
)paren
suffix:semicolon
r_else
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
(paren
op_star
id|pc-&gt;callback
)paren
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Retry number - %d&bslash;n&quot;
comma
id|pc-&gt;retries
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|pc-&gt;retries
op_increment
suffix:semicolon
multiline_comment|/*&n; *&t;We no longer call ide_wait_stat to wait for the drive to be ready,&n; *&t;as ide.c already does this for us in do_request.&n; */
id|pc-&gt;actually_transferred
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We haven&squot;t transferred any data yet */
id|pc-&gt;current_position
op_assign
id|pc-&gt;buffer
suffix:semicolon
id|bcount.all
op_assign
id|pc-&gt;request_transfer
suffix:semicolon
multiline_comment|/* Request to transfer the entire buffer at once */
macro_line|#ifdef CONFIG_BLK_DEV_TRITON
r_if
c_cond
(paren
id|pc-&gt;dma_error
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: DMA disabled, reverting to PIO&bslash;n&quot;
)paren
suffix:semicolon
id|drive-&gt;using_dma
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;dma_error
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pc-&gt;request_transfer
op_logical_and
id|pc-&gt;dma_recommended
op_logical_and
id|drive-&gt;using_dma
)paren
(brace
id|dma_ok
op_assign
op_logical_neg
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|pc-&gt;writing
ques
c_cond
id|ide_dma_write
suffix:colon
id|ide_dma_read
comma
id|drive
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_TRITON */
id|OUT_BYTE
(paren
id|drive-&gt;ctl
comma
id|IDETAPE_CONTROL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|dma_ok
ques
c_cond
l_int|1
suffix:colon
l_int|0
comma
id|IDETAPE_FEATURES_REG
)paren
suffix:semicolon
multiline_comment|/* Use PIO/DMA */
id|OUT_BYTE
(paren
id|bcount.b.high
comma
id|IDETAPE_BCOUNTH_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|bcount.b.low
comma
id|IDETAPE_BCOUNTL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|drive-&gt;select.all
comma
id|IDETAPE_DRIVESEL_REG
)paren
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|WAIT_CMD
)paren
suffix:semicolon
multiline_comment|/* Set the interrupt routine */
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|IDETAPE_ATACOMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* Issue the packet command */
r_if
c_cond
(paren
id|ide_wait_stat
(paren
id|drive
comma
id|DRQ_STAT
comma
id|BUSY_STAT
comma
id|WAIT_READY
)paren
)paren
(brace
multiline_comment|/* Wait for DRQ to be ready - Assuming Accelerated DRQ */
multiline_comment|/*&n;&t;&t; *&t;We currently only support tape drives which report&n;&t;&t; *&t;accelerated DRQ assertion. For this case, specs&n;&t;&t; *&t;allow up to 50us. We really shouldn&squot;t get here.&n;&t;&t; *&n;&t;&t; *&t;??? Still needs to think what to do if we reach&n;&t;&t; *&t;here anyway.&n;&t;&t; */
id|printk
(paren
l_string|&quot;ide-tape: Strange, packet command initiated yet DRQ isn&squot;t asserted&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ireason.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_IREASON_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ireason.b.cod
op_logical_or
id|ireason.b.io
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: (IO,CoD) != (0,1) while issuing a packet command&bslash;n&quot;
)paren
suffix:semicolon
id|ide_do_reset
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ide_output_data
(paren
id|drive
comma
id|pc-&gt;c
comma
l_int|12
op_div
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Send the actual packet */
macro_line|#ifdef CONFIG_BLK_DEV_TRITON
r_if
c_cond
(paren
(paren
id|pc-&gt;dma_in_progress
op_assign
id|dma_ok
)paren
)paren
(brace
multiline_comment|/* Begin DMA, if necessary */
id|pc-&gt;dma_error
op_assign
l_int|0
suffix:semicolon
(paren
r_void
)paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_begin
comma
id|drive
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_TRITON */
)brace
multiline_comment|/*&n; *&t;idetape_pc_intr is the usual interrupt handler which will be called&n; *&t;during a packet command. We will transfer some of the data (as&n; *&t;requested by the drive) and will re-point interrupt handler to us.&n; *&t;When data transfer is finished, we will act according to the&n; *&t;algorithm described before idetape_issue_packet_command.&n; *&n; */
DECL|function|idetape_pc_intr
r_void
id|idetape_pc_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_status_reg_t
id|status
suffix:semicolon
id|idetape_bcount_reg_t
id|bcount
suffix:semicolon
id|idetape_ireason_reg_t
id|ireason
suffix:semicolon
id|idetape_packet_command_t
op_star
id|pc
op_assign
id|tape-&gt;pc
suffix:semicolon
r_int
r_int
id|temp
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_TRITON
r_if
c_cond
(paren
id|pc-&gt;dma_in_progress
)paren
(brace
r_if
c_cond
(paren
(paren
id|pc-&gt;dma_error
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_status_bad
comma
id|drive
)paren
)paren
)paren
multiline_comment|/*&n;&t;&t;&t; *&t;We will currently correct the following in&n;&t;&t;&t; *&t;idetape_analyze_error.&n;&t;&t;&t; */
id|pc-&gt;actually_transferred
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_transferred
comma
id|drive
)paren
suffix:semicolon
r_else
id|pc-&gt;actually_transferred
op_assign
id|pc-&gt;request_transfer
suffix:semicolon
(paren
r_void
)paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_abort
comma
id|drive
)paren
)paren
suffix:semicolon
multiline_comment|/* End DMA */
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: DMA finished&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
)brace
macro_line|#endif /* CONFIG_BLK_DEV_TRITON */
id|status.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_STATUS_REG
)paren
suffix:semicolon
multiline_comment|/* Clear the interrupt */
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_pc_intr interrupt handler&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */&t;
r_if
c_cond
(paren
op_logical_neg
id|status.b.drq
)paren
(brace
multiline_comment|/* No more interrupts */
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Packet command completed&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Total bytes transferred: %lu&bslash;n&quot;
comma
id|pc-&gt;actually_transferred
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|pc-&gt;dma_in_progress
op_assign
l_int|0
suffix:semicolon
id|sti
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status.b.check
op_logical_or
id|pc-&gt;dma_error
)paren
(brace
multiline_comment|/* Error detected */
macro_line|#if IDETAPE_DEBUG_LOG
multiline_comment|/*&n;&t; *&t;Without debugging, we only log an error if we decided to&n;&t; *&t;give up retrying.&n;&t; */
id|printk
(paren
l_string|&quot;ide-tape: %s: I/O error, &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_REQUEST_SENSE_CMD
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: I/O error in request sense command&bslash;n&quot;
)paren
suffix:semicolon
id|ide_do_reset
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|idetape_retry_pc
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Retry operation */
r_return
suffix:semicolon
)brace
id|pc-&gt;error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pc-&gt;wait_for_dsc
op_logical_and
op_logical_neg
id|status.b.dsc
)paren
(brace
multiline_comment|/* Media access command */
id|tape-&gt;dsc_polling_frequency
op_assign
id|IDETAPE_DSC_FAST_MEDIA_ACCESS_FREQUENCY
suffix:semicolon
id|idetape_postpone_request
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Allow ide.c to handle other requests */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;failed_pc
op_eq
id|pc
)paren
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|pc-&gt;callback
op_eq
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;ide-tape: ide-tape bug - Callback function not set !&bslash;n&quot;
)paren
suffix:semicolon
r_else
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
(paren
op_star
id|pc-&gt;callback
)paren
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Command finished - Call the callback function */
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_TRITON
r_if
c_cond
(paren
id|pc-&gt;dma_in_progress
)paren
(brace
id|pc-&gt;dma_in_progress
op_assign
l_int|0
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: The tape wants to issue more interrupts in DMA mode&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: DMA disabled, reverting to PIO&bslash;n&quot;
)paren
suffix:semicolon
id|drive-&gt;using_dma
op_assign
l_int|0
suffix:semicolon
id|ide_do_reset
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_TRITON */
id|bcount.b.high
op_assign
id|IN_BYTE
(paren
id|IDETAPE_BCOUNTH_REG
)paren
suffix:semicolon
multiline_comment|/* Get the number of bytes to transfer */
id|bcount.b.low
op_assign
id|IN_BYTE
(paren
id|IDETAPE_BCOUNTL_REG
)paren
suffix:semicolon
multiline_comment|/* on this interrupt */
id|ireason.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_IREASON_REG
)paren
suffix:semicolon
multiline_comment|/* Read the interrupt reason register */
r_if
c_cond
(paren
id|ireason.b.cod
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: CoD != 0 in idetape_pc_intr&bslash;n&quot;
)paren
suffix:semicolon
id|ide_do_reset
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ireason.b.io
op_ne
op_logical_neg
(paren
id|pc-&gt;writing
)paren
)paren
(brace
multiline_comment|/* Hopefully, we will never get here */
id|printk
(paren
l_string|&quot;ide-tape: We wanted to %s, &quot;
comma
id|pc-&gt;writing
ques
c_cond
l_string|&quot;Write&quot;
suffix:colon
l_string|&quot;Read&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;but the tape wants us to %s !&bslash;n&quot;
comma
id|ireason.b.io
ques
c_cond
l_string|&quot;Read&quot;
suffix:colon
l_string|&quot;Write&quot;
)paren
suffix:semicolon
id|ide_do_reset
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pc-&gt;writing
)paren
(brace
multiline_comment|/* Reading - Check that we have enough space */
id|temp
op_assign
(paren
r_int
r_int
)paren
id|pc-&gt;actually_transferred
op_plus
id|bcount.all
suffix:semicolon
r_if
c_cond
(paren
id|temp
OG
id|pc-&gt;request_transfer
)paren
(brace
r_if
c_cond
(paren
id|temp
OG
id|pc-&gt;buffer_size
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: The tape wants to send us more data than requested - discarding data&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_discard_data
(paren
id|drive
comma
id|bcount.all
)paren
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|idetape_pc_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: The tape wants to send us more data than requested - allowing transfer&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
)brace
)brace
macro_line|#if IDETAPE_DEBUG_BUGS&t;
r_if
c_cond
(paren
id|bcount.all
op_logical_and
op_logical_neg
id|pc-&gt;buffer
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: ide-tape.c bug - Buffer not set in idetape_pc_intr. Discarding data.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pc-&gt;writing
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Discarding data&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_discard_data
(paren
id|drive
comma
id|bcount.all
)paren
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|idetape_pc_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ??? */
)brace
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
r_if
c_cond
(paren
id|pc-&gt;writing
)paren
id|idetape_output_data
(paren
id|drive
comma
id|pc-&gt;current_position
comma
id|bcount.all
)paren
suffix:semicolon
multiline_comment|/* Write the current buffer */
r_else
id|idetape_input_data
(paren
id|drive
comma
id|pc-&gt;current_position
comma
id|bcount.all
)paren
suffix:semicolon
multiline_comment|/* Read the current buffer */
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: %s %d bytes&bslash;n&quot;
comma
id|pc-&gt;writing
ques
c_cond
l_string|&quot;Wrote&quot;
suffix:colon
l_string|&quot;Received&quot;
comma
id|bcount.all
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|pc-&gt;actually_transferred
op_add_assign
id|bcount.all
suffix:semicolon
multiline_comment|/* Update the current position */
id|pc-&gt;current_position
op_add_assign
id|bcount.all
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|idetape_pc_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
multiline_comment|/* And set the interrupt handler again */
)brace
multiline_comment|/*&n; *&t;idetape_postpone_request postpones the current request so that&n; *&t;ide.c will be able to service requests from another device on&n; *&t;the same hwgroup while we are polling for DSC.&n; */
DECL|function|idetape_postpone_request
r_void
id|idetape_postpone_request
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|idetape_status_reg_t
id|status
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_postpone_request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;postponed_rq
op_ne
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;ide-tape.c bug - postponed_rq not NULL in idetape_postpone_request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|tape-&gt;dsc_timer.expires
op_assign
id|jiffies
op_plus
id|tape-&gt;dsc_polling_frequency
suffix:semicolon
multiline_comment|/* Set timer to poll for */
id|tape-&gt;dsc_timeout
op_assign
id|jiffies
op_plus
id|IDETAPE_DSC_TIMEOUT
suffix:semicolon
multiline_comment|/* actual completion */
id|tape-&gt;dsc_timer.data
op_assign
(paren
r_int
r_int
)paren
id|drive
suffix:semicolon
id|tape-&gt;dsc_timer.function
op_assign
op_amp
id|idetape_poll_for_dsc
suffix:semicolon
id|init_timer
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Remove current request from the request queue:&n;&t; */
id|tape-&gt;postponed_rq
op_assign
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|rq-&gt;rq_status
op_assign
id|IDETAPE_RQ_POSTPONED
suffix:semicolon
id|blk_dev
(braket
id|MAJOR
c_func
(paren
id|rq-&gt;rq_dev
)paren
)braket
dot
id|current_request
op_assign
id|rq-&gt;next
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Check the status again - Maybe we can save one polling period.&n;&t; */
id|status.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_STATUS_REG
)paren
suffix:semicolon
id|tape-&gt;last_status
op_assign
id|status.all
suffix:semicolon
id|tape-&gt;request_status
op_assign
l_int|1
suffix:semicolon
id|tape-&gt;dsc_polling_start
op_assign
id|jiffies
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
multiline_comment|/* Activate the polling timer */
)brace
multiline_comment|/*&n; *&t;idetape_poll_for_dsc_direct is called from idetape_poll_for_dsc&n; *&t;to handle the case in which we can safely communicate with the tape&n; *&t;(since no other request for this hwgroup is active).&n; */
DECL|function|idetape_poll_for_dsc_direct
r_void
id|idetape_poll_for_dsc_direct
(paren
r_int
r_int
id|data
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|data
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_status_reg_t
id|status
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;%s: idetape_poll_for_dsc_direct called&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */&t;
id|OUT_BYTE
c_func
(paren
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|status.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status.b.dsc
)paren
(brace
multiline_comment|/* DSC received */
id|tape-&gt;dsc_received
op_assign
l_int|1
suffix:semicolon
id|del_timer
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
multiline_comment|/* Stop polling and put back the postponed */
id|idetape_put_back_postponed_request
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* request in the request queue */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|jiffies
OG
id|tape-&gt;dsc_timeout
)paren
(brace
multiline_comment|/* Timeout */
id|tape-&gt;dsc_received
op_assign
l_int|0
suffix:semicolon
id|del_timer
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
multiline_comment|/* ??? */
id|idetape_put_back_postponed_request
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Poll again */
r_if
c_cond
(paren
id|jiffies
op_minus
id|tape-&gt;dsc_polling_start
OG
id|IDETAPE_FAST_SLOW_THRESHOLD
)paren
id|tape-&gt;dsc_timer.expires
op_assign
id|jiffies
op_plus
id|IDETAPE_DSC_SLOW_MEDIA_ACCESS_FREQUENCY
suffix:semicolon
r_else
id|tape-&gt;dsc_timer.expires
op_assign
id|jiffies
op_plus
id|tape-&gt;dsc_polling_frequency
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_poll_for_dsc gets invoked by a timer (which was set&n; *&t;by idetape_postpone_request) to poll for the DSC bit&n; *&t;in the status register.&n; *&n; *&t;We take care not to perform any tape access if the driver is&n; *&t;accessing the other device. We will instead ask ide.c to sample&n; *&t;the tape status register on our behalf in the next call to do_request,&n; *&t;at the point in which the other device is idle, or assume that&n; *&t;DSC was received even though we won&squot;t verify it (but when we assume&n; *&t;that, it will usually have a solid basis).&n; *&n; *&t;The use of cli () below is a must, as we inspect and change&n; *&t;the device request list while another request is active.&n; */
DECL|function|idetape_poll_for_dsc
r_void
id|idetape_poll_for_dsc
(paren
r_int
r_int
id|data
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|data
suffix:semicolon
r_int
r_int
id|major
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_struct
id|blk_dev_struct
op_star
id|bdev
op_assign
op_amp
id|blk_dev
(braket
id|major
)braket
suffix:semicolon
r_struct
id|request
op_star
id|next_rq
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|idetape_status_reg_t
id|status
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;%s: idetape_poll_for_dsc called&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */&t;
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Check if the other device is idle. If there are no requests,&n;&t; *&t;we can safely access the tape.&n;&t; */
r_if
c_cond
(paren
id|HWGROUP
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
op_eq
l_int|NULL
)paren
(brace
id|sti
(paren
)paren
suffix:semicolon
id|idetape_poll_for_dsc_direct
(paren
id|data
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;If DSC was received, re-insert our postponed request into&n;&t; *&t;the request queue (using ide_next).&n;&t; */
id|status.all
op_assign
id|tape-&gt;last_status
suffix:semicolon
r_if
c_cond
(paren
id|status.b.dsc
)paren
(brace
multiline_comment|/* DSC received */
id|tape-&gt;dsc_received
op_assign
l_int|1
suffix:semicolon
id|idetape_put_back_postponed_request
(paren
id|drive
)paren
suffix:semicolon
id|del_timer
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;At this point, DSC may have been received, but we can&squot;t&n;&t; *&t;check it. We now have two options:&n;&t; *&n;&t; *&t;&t;1.&t;The &quot;simple&quot; method - We can continue polling&n;&t; *&t;&t;&t;until we know the value of DSC.&n;&t; *&n;&t; *&t;but we also have a more clever option :-)&n;&t; *&n;&t; *&t;&t;2.&t;We can sometimes more or less anticipate in&n;&t; *&t;&t;&t;advance how much time it will take for&n;&t; *&t;&t;&t;the tape to perform the request. This is the&n;&t; *&t;&t;&t;place to take advantage of this !&n;&t; *&n;&t; *&t;&t;&t;We can assume that DSC was received, put&n;&t; *&t;&t;&t;back our request, and hope that we will have&n;&t; *&t;&t;&t;a &quot;cache hit&quot;. This will only work when&n;&t; *&t;&t;&t;we haven&squot;t initiated the packet command yet,&n;&t; *&t;&t;&t;but this is the common read/write case. As&n;&t; *&t;&t;&t;for the slower media access commands, fallback&n;&t; *&t;&t;&t;to method 1 above.&n;&t; *&n;&t; *&t;When using method 2, we can also take advantage of the&n;&t; *&t;knowledge of the tape&squot;s internal buffer size - We can&n;&t; *&t;precalculate the time it will take for the tape to complete&n;&t; *&t;servicing not only one request, but rather, say, 50% of its&n;&t; *&t;internal buffer. The polling period will then be much larger,&n;&t; *&t;decreasing our load on Linux, and we will also call&n;&t; *&t;idetape_postpone_request less often, as there will usually&n;&t; *&t;be more room in the internal tape buffer while we are in&n;&t; *&t;idetape_do_request.&n;&t; *&n;&t; *&t;For this method to work well, the ongoing request of the&n;&t; *&t;other device should be serviced by the time the tape is&n;&t; *&t;still working on its remaining 50% internal buffer. This&n;&t; *&t;will usually happen when the other device is much faster&n;&t; *&t;than the tape.&n;&t; */
macro_line|#if IDETAPE_ANTICIPATE_READ_WRITE_DSC
multiline_comment|/*&n;&t; *&t;Method 2.&n;&t; *&n;&t; *&t;There is a high chance that DSC was received, even though&n;&t; *&t;we couldn&squot;t verify it. Let&squot;s hope that it&squot;s a &quot;cache hit&quot;&n;&t; *&t;rather than a &quot;cache miss&quot;. Someday I will probably add a&n;&t; *&t;feedback loop around the number of &quot;cache hits&quot; which will&n;&t; *&t;fine-tune the polling period.&n;&t; */
r_if
c_cond
(paren
id|tape-&gt;postponed_rq-&gt;cmd
op_ne
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE1
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We can use this method only when the packet command&n;&t;&t; *&t;was still not initiated.&n;&t;&t; */
id|idetape_put_back_postponed_request
(paren
id|drive
)paren
suffix:semicolon
id|del_timer
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_ANTICIPATE_READ_WRITE_DSC */
multiline_comment|/*&n;&t; *&t;Fallback to method 1.&n;&t; */
id|next_rq
op_assign
id|bdev-&gt;current_request
suffix:semicolon
r_if
c_cond
(paren
id|next_rq
op_eq
id|HWGROUP
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
)paren
id|next_rq
op_assign
id|next_rq-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|next_rq
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;There will not be another request after the currently&n;&t;&t; *&t;ongoing request, so ide.c won&squot;t be able to sample&n;&t;&t; *&t;the status register on our behalf in do_request.&n;&t;&t; *&n;&t;&t; *&t;In case we are waiting for DSC before the packet&n;&t;&t; *&t;command was initiated, we will put back our postponed&n;&t;&t; *&t;request and have another look at the status register&n;&t;&t; *&t;in idetape_do_request, as done in method 2 above.&n;&t;&t; *&n;&t;&t; *&t;In case we already initiated the command, we can&squot;t&n;&t;&t; *&t;put it back, but it is anyway a slow media access&n;&t;&t; *&t;command. We will just give up and poll again until&n;&t;&t; *&t;we are lucky.&n;&t;&t; */
r_if
c_cond
(paren
id|tape-&gt;postponed_rq-&gt;cmd
op_eq
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE1
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Media access command - Poll again.&n;&t;&t;&t; *&n;&t;&t;&t; *&t;We set tape-&gt;request_status to 1, just in case&n;&t;&t;&t; *&t;other requests are added while we are waiting.&n;&t;&t;&t; */
id|tape-&gt;request_status
op_assign
l_int|1
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|tape-&gt;dsc_timer.expires
op_assign
id|jiffies
op_plus
id|tape-&gt;dsc_polling_frequency
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;The packet command hasn&squot;t been sent to the tape yet -&n;&t;&t; *&t;We can safely put back the request and have another&n;&t;&t; *&t;look at the status register in idetape_do_request.&n;&t;&t; */
id|idetape_put_back_postponed_request
(paren
id|drive
)paren
suffix:semicolon
id|del_timer
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;There will be another request after the current request.&n;&t; *&n;&t; *&t;Request ide.c to sample for us the tape&squot;s status register&n;&t; *&t;before the next request.&n;&t; */
id|tape-&gt;request_status
op_assign
l_int|1
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|jiffies
OG
id|tape-&gt;dsc_timeout
)paren
(brace
multiline_comment|/* Timeout */
id|tape-&gt;dsc_received
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* ??? */
id|idetape_put_back_postponed_request
(paren
id|drive
)paren
suffix:semicolon
id|del_timer
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Poll again */
r_if
c_cond
(paren
id|jiffies
op_minus
id|tape-&gt;dsc_polling_start
OG
id|IDETAPE_FAST_SLOW_THRESHOLD
)paren
id|tape-&gt;dsc_timer.expires
op_assign
id|jiffies
op_plus
id|IDETAPE_DSC_SLOW_MEDIA_ACCESS_FREQUENCY
suffix:semicolon
r_else
id|tape-&gt;dsc_timer.expires
op_assign
id|jiffies
op_plus
id|tape-&gt;dsc_polling_frequency
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
(paren
id|tape-&gt;dsc_timer
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_put_back_postponed_request gets called when we decided to&n; *&t;stop polling for DSC and continue servicing our postponed request.&n; */
DECL|function|idetape_put_back_postponed_request
r_void
id|idetape_put_back_postponed_request
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Putting back postponed request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;postponed_rq
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;tape-&gt;postponed_rq is NULL in put_back_postponed_request&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
id|tape-&gt;postponed_rq
comma
id|ide_next
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * &t;Note that the procedure done here is different than the method&n;&t; *&t;we are using in idetape_queue_pc_head - There we are putting&n;&t; *&t;request(s) before our currently called request.&n;&t; *&n;&t; *&t;Here, on the other hand, HWGROUP(drive)-&gt;rq is not our&n;&t; *&t;request but rather a request to another device. Therefore,&n;&t; *&t;we will let it finish and only then service our postponed&n;&t; *&t;request --&gt; We don&squot;t touch HWGROUP(drive)-&gt;rq.&n;&t; */
)brace
DECL|function|idetape_media_access_finished
r_void
id|idetape_media_access_finished
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_status_reg_t
id|status
suffix:semicolon
id|idetape_packet_command_t
op_star
id|pc
suffix:semicolon
id|pc
op_assign
id|tape-&gt;pc
suffix:semicolon
id|status.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_STATUS_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;dsc_received
)paren
(brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;DSC received&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|status.b.check
)paren
(brace
multiline_comment|/* Error detected */
id|printk
(paren
l_string|&quot;ide-tape: %s: I/O error, &quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|idetape_retry_pc
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Retry operation */
r_return
suffix:semicolon
)brace
id|pc-&gt;error
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;failed_pc
op_eq
id|pc
)paren
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|pc-&gt;callback
op_eq
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;ide-tape: ide-tape bug - Callback function not set !&bslash;n&quot;
)paren
suffix:semicolon
r_else
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
(paren
op_star
id|pc-&gt;callback
)paren
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;ide-tape: %s: DSC timeout.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
multiline_comment|/* ??? */
id|pc-&gt;error
op_assign
l_int|1
suffix:semicolon
id|tape-&gt;failed_pc
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|pc-&gt;callback
op_eq
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;ide-tape: ide-tape bug - Callback function not set !&bslash;n&quot;
)paren
suffix:semicolon
r_else
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
(paren
op_star
id|pc-&gt;callback
)paren
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;idetape_retry_pc is called when an error was detected during the&n; *&t;last packet command. We queue a request sense packet command in&n; *&t;the head of the request list.&n; */
DECL|function|idetape_retry_pc
r_void
id|idetape_retry_pc
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
id|drive-&gt;tape
suffix:semicolon
id|idetape_packet_command_t
op_star
id|pc
suffix:semicolon
r_struct
id|request
op_star
id|new_rq
suffix:semicolon
id|idetape_error_reg_t
id|error
suffix:semicolon
id|error.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_ERROR_REG
)paren
suffix:semicolon
id|pc
op_assign
id|idetape_next_pc_storage
(paren
id|drive
)paren
suffix:semicolon
id|new_rq
op_assign
id|idetape_next_rq_storage
(paren
id|drive
)paren
suffix:semicolon
id|idetape_create_request_sense_cmd
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;buffer
op_assign
id|pc-&gt;temp_buffer
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc-&gt;current_position
op_assign
id|pc-&gt;temp_buffer
suffix:semicolon
id|tape-&gt;reset_issued
op_assign
l_int|1
suffix:semicolon
id|idetape_queue_pc_head
(paren
id|drive
comma
id|pc
comma
id|new_rq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;General packet command callback function.&n; */
DECL|function|idetape_pc_callback
r_void
id|idetape_pc_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_pc_callback&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;pc-&gt;error
)paren
(brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Request completed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|idetape_end_request
(paren
l_int|1
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|idetape_read_callback
r_void
id|idetape_read_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|blocks_read
op_assign
id|tape-&gt;pc-&gt;actually_transferred
op_div
id|tape-&gt;tape_block_size
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG&t;
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_read_callback&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|tape-&gt;block_address
op_add_assign
id|blocks_read
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|blocks_read
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;pc-&gt;error
)paren
id|idetape_end_request
(paren
l_int|1
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
r_else
(brace
id|rq-&gt;errors
op_assign
id|tape-&gt;pc-&gt;error
suffix:semicolon
r_switch
c_cond
(paren
id|rq-&gt;errors
)paren
(brace
r_case
id|IDETAPE_RQ_ERROR_FILEMARK
suffix:colon
r_case
id|IDETAPE_RQ_ERROR_EOD
suffix:colon
r_break
suffix:semicolon
)brace
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|idetape_write_callback
r_void
id|idetape_write_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|blocks_written
op_assign
id|tape-&gt;pc-&gt;actually_transferred
op_div
id|tape-&gt;tape_block_size
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG&t;
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_write_callback&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|tape-&gt;block_address
op_add_assign
id|blocks_written
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|blocks_written
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;pc-&gt;error
)paren
id|idetape_end_request
(paren
l_int|1
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
r_else
(brace
id|rq-&gt;errors
op_assign
id|tape-&gt;pc-&gt;error
suffix:semicolon
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|idetape_inquiry_callback
r_void
id|idetape_inquiry_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_display_inquiry_result
(paren
id|tape-&gt;pc-&gt;buffer
)paren
suffix:semicolon
id|idetape_pc_callback
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_input_data is called to read data from the tape&squot;s data&n; *&t;register. We basically let ide_input_data do the job, but we also&n; *&t;take care about the remaining bytes which can not be transferred&n; *&t;in 32-bit data transfers.&n; */
DECL|function|idetape_input_data
r_void
id|idetape_input_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bcount
)paren
(brace
r_int
r_int
id|wcount
suffix:semicolon
id|wcount
op_assign
id|bcount
op_rshift
l_int|2
suffix:semicolon
id|bcount
op_sub_assign
l_int|4
op_star
id|wcount
suffix:semicolon
r_if
c_cond
(paren
id|wcount
)paren
id|ide_input_data
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcount
)paren
(brace
(paren
(paren
id|byte
op_star
)paren
id|buffer
)paren
op_add_assign
l_int|4
op_star
id|wcount
suffix:semicolon
id|insb
(paren
id|IDETAPE_DATA_REG
comma
id|buffer
comma
id|bcount
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;idetape_output_data is used to write data to the tape.&n; */
DECL|function|idetape_output_data
r_void
id|idetape_output_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
r_int
r_int
id|bcount
)paren
(brace
r_int
r_int
id|wcount
suffix:semicolon
id|wcount
op_assign
id|bcount
op_rshift
l_int|2
suffix:semicolon
id|bcount
op_sub_assign
l_int|4
op_star
id|wcount
suffix:semicolon
r_if
c_cond
(paren
id|wcount
)paren
id|ide_output_data
(paren
id|drive
comma
id|buffer
comma
id|wcount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcount
)paren
(brace
(paren
(paren
id|byte
op_star
)paren
id|buffer
)paren
op_add_assign
l_int|4
op_star
id|wcount
suffix:semicolon
id|outsb
(paren
id|IDETAPE_DATA_REG
comma
id|buffer
comma
id|bcount
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Too bad. The drive wants to send us data which we are not ready to accept.&n; *&t;Just throw it away.&n; */
DECL|function|idetape_discard_data
r_void
id|idetape_discard_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|bcount
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bcount
suffix:semicolon
id|i
op_increment
)paren
id|IN_BYTE
(paren
id|IDETAPE_DATA_REG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Issue an INQUIRY packet command.&n; */
DECL|function|idetape_create_inquiry_cmd
r_void
id|idetape_create_inquiry_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Creating INQUIRY packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */&t;
id|pc-&gt;request_transfer
op_assign
l_int|36
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_inquiry_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_INQUIRY_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Format the INQUIRY command results.&n; */
DECL|function|idetape_display_inquiry_result
r_void
id|idetape_display_inquiry_result
(paren
id|byte
op_star
id|buffer
)paren
(brace
id|idetape_inquiry_result_t
op_star
id|result
suffix:semicolon
id|result
op_assign
(paren
id|idetape_inquiry_result_t
op_star
)paren
id|buffer
suffix:semicolon
id|ide_fixstring
(paren
id|result-&gt;vendor_id
comma
l_int|8
comma
l_int|0
)paren
suffix:semicolon
id|ide_fixstring
(paren
id|result-&gt;product_id
comma
l_int|16
comma
l_int|0
)paren
suffix:semicolon
id|ide_fixstring
(paren
id|result-&gt;revision_level
comma
l_int|4
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result-&gt;response_format
op_ne
l_int|2
)paren
(brace
id|printk
(paren
l_string|&quot;The INQUIRY Data Format is unknown to us !&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Assuming QIC-157C format.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Dumping INQUIRY command results:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Response Data Format: %d - &quot;
comma
id|result-&gt;response_format
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result-&gt;response_format
)paren
(brace
r_case
l_int|2
suffix:colon
id|printk
(paren
l_string|&quot;As specified in QIC-157 Revision C&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Unknown&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Device Type: %x - &quot;
comma
id|result-&gt;device_type
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result-&gt;device_type
)paren
(brace
r_case
l_int|0
suffix:colon
id|printk
(paren
l_string|&quot;Direct-access Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|printk
(paren
l_string|&quot;Streaming Tape Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|3
suffix:colon
r_case
l_int|4
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|5
suffix:colon
id|printk
(paren
l_string|&quot;CD-ROM Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
r_case
l_int|7
suffix:colon
id|printk
(paren
l_string|&quot;Optical memory Device&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x1f
suffix:colon
id|printk
(paren
l_string|&quot;Unknown or no Device type&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Reserved&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;Removable Medium: %s&quot;
comma
id|result-&gt;rmb
ques
c_cond
l_string|&quot;Yes&bslash;n&quot;
suffix:colon
l_string|&quot;No&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ANSI Version: %d - &quot;
comma
id|result-&gt;ansi_version
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|result-&gt;ansi_version
)paren
(brace
r_case
l_int|2
suffix:colon
id|printk
(paren
l_string|&quot;QIC-157 Revision C&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;Unknown&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;ECMA Version: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result-&gt;ecma_version
)paren
id|printk
(paren
l_string|&quot;%d&bslash;n&quot;
comma
id|result-&gt;ecma_version
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ISO Version: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result-&gt;iso_version
)paren
id|printk
(paren
l_string|&quot;%d&bslash;n&quot;
comma
id|result-&gt;iso_version
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;Not supported&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Additional Length: %d&bslash;n&quot;
comma
id|result-&gt;additional_length
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Vendor Identification: %s&bslash;n&quot;
comma
id|result-&gt;vendor_id
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Product Identification: %s&bslash;n&quot;
comma
id|result-&gt;product_id
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Product Revision Level: %s&bslash;n&quot;
comma
id|result-&gt;revision_level
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|result-&gt;device_type
op_ne
l_int|1
)paren
id|printk
(paren
l_string|&quot;Device type is not set to tape&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|result-&gt;rmb
)paren
id|printk
(paren
l_string|&quot;The removable flag is not set&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result-&gt;ansi_version
op_ne
l_int|2
)paren
(brace
id|printk
(paren
l_string|&quot;The Ansi Version is unknown to us !&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Assuming compliance with QIC-157C specification.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|idetape_create_request_sense_cmd
r_void
id|idetape_create_request_sense_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Creating REQUEST SENSE packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */&t;
id|pc-&gt;request_transfer
op_assign
l_int|18
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_request_sense_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_REQUEST_SENSE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
)brace
DECL|function|idetape_request_sense_callback
r_void
id|idetape_request_sense_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_request_sense_callback&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;pc-&gt;error
)paren
(brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Request completed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|idetape_analyze_error
(paren
id|drive
comma
(paren
id|idetape_request_sense_result_t
op_star
)paren
id|tape-&gt;pc-&gt;buffer
)paren
suffix:semicolon
id|idetape_end_request
(paren
l_int|1
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;Error in REQUEST SENSE itself - Aborting request!&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_analyze_error is called on each failed packet command retry&n; *&t;to analyze the request sense. We currently do not utilize this&n; *&t;information.&n; */
DECL|function|idetape_analyze_error
r_void
id|idetape_analyze_error
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_request_sense_result_t
op_star
id|result
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_packet_command_t
op_star
id|pc
op_assign
id|tape-&gt;failed_pc
suffix:semicolon
id|tape-&gt;sense_key
op_assign
id|result-&gt;sense_key
suffix:semicolon
id|tape-&gt;asc
op_assign
id|result-&gt;asc
suffix:semicolon
id|tape-&gt;ascq
op_assign
id|result-&gt;ascq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG&t;
multiline_comment|/*&n;&t; *&t;Without debugging, we only log an error if we decided to&n;&t; *&t;give up retrying.&n;&t; */
id|printk
(paren
l_string|&quot;ide-tape: pc = %x, sense key = %x, asc = %x, ascq = %x&bslash;n&quot;
comma
id|pc-&gt;c
(braket
l_int|0
)braket
comma
id|result-&gt;sense_key
comma
id|result-&gt;asc
comma
id|result-&gt;ascq
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_READ_CMD
)paren
(brace
r_if
c_cond
(paren
id|result-&gt;filemark
)paren
(brace
id|pc-&gt;error
op_assign
id|IDETAPE_RQ_ERROR_FILEMARK
suffix:semicolon
id|pc
op_member_access_from_pointer
m_abort
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_READ_CMD
op_logical_or
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_WRITE_CMD
)paren
(brace
r_if
c_cond
(paren
id|result-&gt;sense_key
op_eq
l_int|8
)paren
(brace
id|pc-&gt;error
op_assign
id|IDETAPE_RQ_ERROR_EOD
suffix:semicolon
id|pc
op_member_access_from_pointer
m_abort
op_assign
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#if 1
macro_line|#ifdef CONFIG_BLK_DEV_TRITON
multiline_comment|/*&n;&t; *&t;Correct pc-&gt;actually_transferred by asking the tape.&n;&t; */
r_if
c_cond
(paren
id|pc-&gt;dma_error
op_logical_and
id|pc
op_member_access_from_pointer
m_abort
)paren
(brace
r_int
r_int
op_star
id|long_ptr
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|result-&gt;information1
)paren
suffix:semicolon
id|pc-&gt;actually_transferred
op_assign
id|pc-&gt;request_transfer
op_minus
id|tape-&gt;tape_block_size
op_star
id|idetape_swap_long
(paren
op_star
id|long_ptr
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_TRITON */
macro_line|#endif
)brace
DECL|function|idetape_create_test_unit_ready_cmd
r_void
id|idetape_create_test_unit_ready_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Creating TEST UNIT READY packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */&t;
id|pc-&gt;request_transfer
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;current_position
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_TEST_UNIT_READY_CMD
suffix:semicolon
)brace
DECL|function|idetape_create_locate_cmd
r_void
id|idetape_create_locate_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
r_int
id|block
comma
id|byte
id|partition
)paren
(brace
r_int
r_int
op_star
id|ptr
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Creating LOCATE packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|pc-&gt;request_transfer
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;current_position
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_LOCATE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
op_amp
(paren
id|pc-&gt;c
(braket
l_int|3
)braket
)paren
suffix:semicolon
op_star
id|ptr
op_assign
id|idetape_swap_long
(paren
id|block
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|8
)braket
op_assign
id|partition
suffix:semicolon
)brace
DECL|function|idetape_create_rewind_cmd
r_void
id|idetape_create_rewind_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Creating REWIND packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|pc-&gt;request_transfer
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;current_position
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_REWIND_CMD
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;A mode sense command is used to &quot;sense&quot; tape parameters.&n; */
DECL|function|idetape_create_mode_sense_cmd
r_void
id|idetape_create_mode_sense_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
id|byte
id|page_code
)paren
(brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Creating MODE SENSE packet command - Page %d&bslash;n&quot;
comma
id|page_code
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|pc-&gt;wait_for_dsc
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|page_code
)paren
(brace
r_case
id|IDETAPE_CAPABILITIES_PAGE
suffix:colon
id|pc-&gt;request_transfer
op_assign
l_int|24
suffix:semicolon
)brace
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_MODE_SENSE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* DBD = 1 - Don&squot;t return block descriptors for now */
id|pc-&gt;c
(braket
l_int|2
)braket
op_assign
id|page_code
suffix:semicolon
id|pc-&gt;c
(braket
l_int|3
)braket
op_assign
l_int|255
suffix:semicolon
multiline_comment|/* Don&squot;t limit the returned information */
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
l_int|255
suffix:semicolon
multiline_comment|/* (We will just discard data in that case) */
)brace
multiline_comment|/*&n; *&t;idetape_create_write_filemark_cmd will:&n; *&n; *&t;&t;1.&t;Write a filemark if write_filemark=1.&n; *&t;&t;2.&t;Flush the device buffers without writing a filemark&n; *&t;&t;&t;if write_filemark=0.&n; *&n; */
DECL|function|idetape_create_write_filemark_cmd
r_void
id|idetape_create_write_filemark_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
id|write_filemark
)paren
(brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Creating WRITE FILEMARK packet command&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|write_filemark
)paren
id|printk
(paren
l_string|&quot;which will only flush buffered data&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|pc-&gt;request_transfer
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;current_position
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_WRITE_FILEMARK_CMD
suffix:semicolon
r_if
c_cond
(paren
id|write_filemark
)paren
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|idetape_create_load_unload_cmd
r_void
id|idetape_create_load_unload_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
id|cmd
)paren
(brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Creating LOAD UNLOAD packet command, cmd=%d&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|pc-&gt;request_transfer
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;current_position
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_LOAD_UNLOAD_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|cmd
suffix:semicolon
)brace
DECL|function|idetape_create_erase_cmd
r_void
id|idetape_create_erase_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Creating ERASE command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|pc-&gt;request_transfer
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;current_position
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_ERASE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|idetape_create_read_cmd
r_void
id|idetape_create_read_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
r_int
id|length
)paren
(brace
r_union
id|convert
(brace
r_int
id|all
suffix:colon
l_int|32
suffix:semicolon
r_struct
(brace
r_int
id|b1
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b2
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b3
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b4
suffix:colon
l_int|8
suffix:semicolon
)brace
id|b
suffix:semicolon
)brace
id|original
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Creating READ packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|original.all
op_assign
id|length
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_read_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_READ_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|original.b.b1
suffix:semicolon
id|pc-&gt;c
(braket
l_int|3
)braket
op_assign
id|original.b.b2
suffix:semicolon
id|pc-&gt;c
(braket
l_int|2
)braket
op_assign
id|original.b.b3
suffix:semicolon
r_if
c_cond
(paren
id|length
)paren
id|pc-&gt;dma_recommended
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|idetape_create_space_cmd
r_void
id|idetape_create_space_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
id|count
comma
id|byte
id|cmd
)paren
(brace
r_union
id|convert
(brace
r_int
id|all
suffix:colon
l_int|32
suffix:semicolon
r_struct
(brace
r_int
id|b1
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b2
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b3
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b4
suffix:colon
l_int|8
suffix:semicolon
)brace
id|b
suffix:semicolon
)brace
id|original
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Creating SPACE packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|original.all
op_assign
id|count
suffix:semicolon
id|pc-&gt;request_transfer
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;current_position
op_assign
l_int|NULL
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_pc_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_SPACE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
id|cmd
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|original.b.b1
suffix:semicolon
id|pc-&gt;c
(braket
l_int|3
)braket
op_assign
id|original.b.b2
suffix:semicolon
id|pc-&gt;c
(braket
l_int|2
)braket
op_assign
id|original.b.b3
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|idetape_create_write_cmd
r_void
id|idetape_create_write_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
comma
r_int
r_int
id|length
)paren
(brace
r_union
id|convert
(brace
r_int
id|all
suffix:colon
l_int|32
suffix:semicolon
r_struct
(brace
r_int
id|b1
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b2
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b3
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b4
suffix:colon
l_int|8
suffix:semicolon
)brace
id|b
suffix:semicolon
)brace
id|original
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Creating WRITE packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|original.all
op_assign
id|length
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_write_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|1
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_WRITE_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|original.b.b1
suffix:semicolon
id|pc-&gt;c
(braket
l_int|3
)braket
op_assign
id|original.b.b2
suffix:semicolon
id|pc-&gt;c
(braket
l_int|2
)braket
op_assign
id|original.b.b3
suffix:semicolon
r_if
c_cond
(paren
id|length
)paren
id|pc-&gt;dma_recommended
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|idetape_create_read_position_cmd
r_void
id|idetape_create_read_position_cmd
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Creating READ POSITION packet command&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|pc-&gt;request_transfer
op_assign
l_int|20
suffix:semicolon
id|pc-&gt;wait_for_dsc
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;callback
op_assign
op_amp
id|idetape_read_position_callback
suffix:semicolon
id|pc-&gt;writing
op_assign
l_int|0
suffix:semicolon
id|idetape_zero_packet_command
(paren
id|pc
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|IDETAPE_READ_POSITION_CMD
suffix:semicolon
id|pc-&gt;c
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|idetape_read_position_callback
r_void
id|idetape_read_position_callback
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|idetape_read_position_result_t
op_star
id|result
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_read_position_callback&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;pc-&gt;error
)paren
(brace
id|result
op_assign
(paren
id|idetape_read_position_result_t
op_star
)paren
id|tape-&gt;pc-&gt;buffer
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Request completed&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Dumping the results of the READ POSITION command&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;BOP - %s&bslash;n&quot;
comma
id|result-&gt;bop
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;EOP - %s&bslash;n&quot;
comma
id|result-&gt;eop
ques
c_cond
l_string|&quot;Yes&quot;
suffix:colon
l_string|&quot;No&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|result-&gt;bpu
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Block location is unknown to the tape&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;Aborting request&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;block_address_valid
op_assign
l_int|0
suffix:semicolon
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Block Location - %lu&bslash;n&quot;
comma
id|idetape_swap_long
(paren
id|result-&gt;first_block
)paren
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|tape-&gt;block_address
op_assign
id|idetape_swap_long
(paren
id|result-&gt;first_block
)paren
suffix:semicolon
id|tape-&gt;block_address_valid
op_assign
l_int|1
suffix:semicolon
id|idetape_end_request
(paren
l_int|1
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;Aborting request&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Our special ide-tape ioctl&squot;s.&n; *&n; *&t;Currently there aren&squot;t any significant ioctl&squot;s.&n; *&t;mtio.h compatible commands should be issued to the character device&n; *&t;interface.&n; */
DECL|function|idetape_blkdev_ioctl
r_int
id|idetape_blkdev_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|idetape_packet_command_t
id|pc
suffix:semicolon
id|pc.buffer
op_assign
id|pc.temp_buffer
suffix:semicolon
id|pc.buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc.current_position
op_assign
id|pc.temp_buffer
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG&t;
id|printk
(paren
l_string|&quot;ide-tape: Reached idetape_blkdev_ioctl&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_default
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Functions which handle requests.&n; */
multiline_comment|/*&n; *&t;idetape_end_request is used to end a request.&n; */
DECL|function|idetape_end_request
r_void
id|idetape_end_request
(paren
id|byte
id|uptodate
comma
id|ide_hwgroup_t
op_star
id|hwgroup
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|hwgroup-&gt;drive
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|hwgroup-&gt;rq
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_int
r_int
id|major
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
suffix:semicolon
r_struct
id|blk_dev_struct
op_star
id|bdev
op_assign
op_amp
id|blk_dev
(braket
id|major
)braket
suffix:semicolon
r_int
id|error
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_end_request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|bdev-&gt;current_request
op_assign
id|rq
suffix:semicolon
multiline_comment|/* Since we may have taken it out */
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;errors
)paren
multiline_comment|/* In case rq-&gt;errors is already set, */
id|rq-&gt;errors
op_assign
op_logical_neg
id|uptodate
suffix:semicolon
multiline_comment|/* we won&squot;t change it. */
id|error
op_assign
id|rq-&gt;errors
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_eq
id|rq
)paren
(brace
multiline_comment|/* The request was a pipelined data transfer request */
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|IDETAPE_READ_REQUEST
)paren
(brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;active_stage
op_eq
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;ide-tape: bug: active_stage is NULL in idetape_end_request&bslash;n&quot;
)paren
suffix:semicolon
r_else
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|idetape_copy_buffer_to_stage
(paren
id|tape-&gt;active_stage
comma
id|tape-&gt;data_buffer
)paren
suffix:semicolon
)brace
id|tape-&gt;active_stage
op_assign
l_int|NULL
suffix:semicolon
id|tape-&gt;active_data_request
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|IDETAPE_WRITE_REQUEST
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;errors
)paren
id|tape-&gt;error_in_pipeline_stage
op_assign
id|rq-&gt;errors
suffix:semicolon
id|idetape_remove_stage_head
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;next_stage
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|error
)paren
id|idetape_increase_max_pipeline_stages
(paren
id|drive
)paren
suffix:semicolon
id|ide_end_drive_cmd
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|idetape_active_next_stage
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Insert the next request into the request queue.&n;&t;&t; *&n;&t;&t; *&t;The choice of using ide_next or ide_end is now left&n;&t;&t; *&t;to the user.&n;&t;&t; */
macro_line|#if IDETAPE_LOW_TAPE_PRIORITY
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
id|tape-&gt;active_data_request
comma
id|ide_end
)paren
suffix:semicolon
macro_line|#else
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
id|tape-&gt;active_data_request
comma
id|ide_next
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_LOW_TAPE_PRIORITY */
)brace
id|ide_end_drive_cmd
(paren
id|drive
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_do_request is our request handling function.&t;&n; */
DECL|function|idetape_do_request
r_void
id|idetape_do_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_int
r_int
id|block
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_packet_command_t
op_star
id|pc
suffix:semicolon
r_int
r_int
id|major
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
suffix:semicolon
r_struct
id|blk_dev_struct
op_star
id|bdev
op_assign
op_amp
id|blk_dev
(braket
id|major
)braket
suffix:semicolon
id|idetape_status_reg_t
id|status
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Current request:&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;rq_status: %d, rq_dev: %u, cmd: %d, errors: %d&bslash;n&quot;
comma
id|rq-&gt;rq_status
comma
(paren
r_int
r_int
)paren
id|rq-&gt;rq_dev
comma
id|rq-&gt;cmd
comma
id|rq-&gt;errors
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;sector: %ld, nr_sectors: %ld, current_nr_sectors: %ld&bslash;n&quot;
comma
id|rq-&gt;sector
comma
id|rq-&gt;nr_sectors
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
op_logical_neg
id|IDETAPE_REQUEST_CMD
(paren
id|rq-&gt;cmd
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We do not support buffer cache originated requests.&n;&t;&t; */
id|printk
(paren
l_string|&quot;ide-tape: Unsupported command in request queue&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: The block device interface should not be used for data transfers.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: Use the character device interfaces&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: /dev/ht0 and /dev/nht0 instead.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: (Run linux/scripts/MAKEDEV.ide to create them)&bslash;n&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;ide-tape: Aborting request.&bslash;n&quot;
)paren
suffix:semicolon
id|ide_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
multiline_comment|/* Let the common code handle it */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;This is an important point. We will try to remove our request&n;&t; *&t;from the block device request queue while we service the&n;&t; *&t;request. Note that the request must be returned to&n;&t; *&t;bdev-&gt;current_request before the next call to&n;&t; *&t;ide_end_drive_cmd or ide_do_drive_cmd to conform with the&n;&t; *&t;normal behavior of the IDE driver, which leaves the active&n;&t; *&t;request in bdev-&gt;current_request during I/O.&n;&t; *&n;&t; *&t;This will eliminate fragmentation of disk/cdrom requests&n;&t; *&t;around a tape request, now that we are using ide_next to&n;&t; *&t;insert pending pipeline requests, since we have only one&n;&t; *&t;ide-tape.c data request in the device request queue, and&n;&t; *&t;thus once removed, ll_rw_blk.c will only see requests from&n;&t; *&t;the other device.&n;&t; *&n;&t; *&t;The potential fragmentation inefficiency was pointed to me&n;&t; *&t;by Mark Lord.&n;&t; */
r_if
c_cond
(paren
id|rq-&gt;next
op_ne
l_int|NULL
op_logical_and
id|rq-&gt;rq_dev
op_ne
id|rq-&gt;next-&gt;rq_dev
)paren
id|bdev-&gt;current_request
op_assign
id|rq-&gt;next
suffix:semicolon
multiline_comment|/* Retry a failed packet command */
r_if
c_cond
(paren
id|tape-&gt;failed_pc
op_ne
l_int|NULL
op_logical_and
id|tape-&gt;pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|IDETAPE_REQUEST_SENSE_CMD
)paren
(brace
id|idetape_issue_packet_command
(paren
id|drive
comma
id|tape-&gt;failed_pc
comma
op_amp
id|idetape_pc_intr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check if we have a postponed request */
r_if
c_cond
(paren
id|tape-&gt;postponed_rq
op_ne
l_int|NULL
)paren
(brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;postponed_rq-&gt;rq_status
op_ne
id|RQ_ACTIVE
op_logical_or
id|rq
op_ne
id|tape-&gt;postponed_rq
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: ide-tape.c bug - Two DSC requests were queued&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE1
)paren
(brace
multiline_comment|/* Media access command */
id|tape-&gt;postponed_rq
op_assign
l_int|NULL
suffix:semicolon
id|idetape_media_access_finished
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Read / Write command - DSC polling was done before the&n;&t;&t; * actual command - Continue normally so that the command&n;&t;&t; * will be performed below.&n;&t;&t; */
id|tape-&gt;postponed_rq
op_assign
l_int|NULL
suffix:semicolon
)brace
id|status.all
op_assign
id|IN_BYTE
(paren
id|IDETAPE_STATUS_REG
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;After a software reset, the status register is locked. We&n;&t; *&t;will ignore the DSC value for our very first packet command,&n;&t; *&t;which will restore DSC operation.&n;&t; */
r_if
c_cond
(paren
id|tape-&gt;reset_issued
)paren
(brace
id|status.b.dsc
op_assign
l_int|1
suffix:semicolon
id|tape-&gt;reset_issued
op_assign
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|rq-&gt;cmd
)paren
(brace
r_case
id|IDETAPE_READ_REQUEST
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|status.b.dsc
)paren
(brace
multiline_comment|/* Tape buffer not ready to accept r/w command */
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: DSC != 1 - Postponing read request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */&t;
id|tape-&gt;dsc_polling_frequency
op_assign
id|tape-&gt;best_dsc_rw_frequency
suffix:semicolon
id|idetape_postpone_request
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Allow ide.c to process requests from */
r_return
suffix:semicolon
)brace
id|pc
op_assign
id|idetape_next_pc_storage
(paren
id|drive
)paren
suffix:semicolon
id|idetape_create_read_cmd
(paren
id|pc
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|pc-&gt;buffer
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
id|rq-&gt;current_nr_sectors
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
id|pc-&gt;current_position
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|pc-&gt;request_transfer
op_assign
id|rq-&gt;current_nr_sectors
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
id|idetape_issue_packet_command
(paren
id|drive
comma
id|pc
comma
op_amp
id|idetape_pc_intr
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|IDETAPE_WRITE_REQUEST
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|status.b.dsc
)paren
(brace
multiline_comment|/* Tape buffer not ready to accept r/w command */
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: DSC != 1 - Postponing write request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */&t;
id|tape-&gt;dsc_polling_frequency
op_assign
id|tape-&gt;best_dsc_rw_frequency
suffix:semicolon
id|idetape_postpone_request
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Allow ide.c to process requests from */
r_return
suffix:semicolon
)brace
id|pc
op_assign
id|idetape_next_pc_storage
(paren
id|drive
)paren
suffix:semicolon
id|idetape_create_write_cmd
(paren
id|pc
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|pc-&gt;buffer
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|pc-&gt;buffer_size
op_assign
id|rq-&gt;current_nr_sectors
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
id|pc-&gt;current_position
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|pc-&gt;request_transfer
op_assign
id|rq-&gt;current_nr_sectors
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
id|idetape_issue_packet_command
(paren
id|drive
comma
id|pc
comma
op_amp
id|idetape_pc_intr
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE1
suffix:colon
r_case
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE2
suffix:colon
multiline_comment|/*&n; *&t;This should be unnecessary (postponing of a general packet command),&n; *&t;but I have occasionally missed DSC on a media access command otherwise.&n; *&t;??? Still have to figure it out ...&n; */
r_if
c_cond
(paren
op_logical_neg
id|status.b.dsc
)paren
(brace
multiline_comment|/* Tape buffers are still not ready */
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: DSC != 1 - Postponing packet command request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|rq-&gt;cmd
op_assign
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE2
suffix:semicolon
multiline_comment|/* Note that we are waiting for DSC *before* we */
multiline_comment|/* even issued the command */
id|tape-&gt;dsc_polling_frequency
op_assign
id|IDETAPE_DSC_READ_WRITE_FALLBACK_FREQUENCY
suffix:semicolon
id|idetape_postpone_request
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Allow ide.c to process requests from */
r_return
suffix:semicolon
)brace
id|rq-&gt;cmd
op_assign
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE1
suffix:semicolon
id|pc
op_assign
(paren
id|idetape_packet_command_t
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|idetape_issue_packet_command
(paren
id|drive
comma
id|pc
comma
op_amp
id|idetape_pc_intr
)paren
suffix:semicolon
r_return
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_default
suffix:colon
id|printk
(paren
l_string|&quot;ide-tape: bug in IDETAPE_REQUEST_CMD macro&bslash;n&quot;
)paren
suffix:semicolon
id|idetape_end_request
(paren
l_int|0
comma
id|HWGROUP
(paren
id|drive
)paren
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
)brace
)brace
multiline_comment|/*&n; *&t;idetape_queue_pc_tail is based on the following functions:&n; *&n; *&t;ide_do_drive_cmd from ide.c&n; *&t;cdrom_queue_request and cdrom_queue_packet_command from ide-cd.c&n; *&n; *&t;We add a special packet command request to the tail of the request queue,&n; *&t;and wait for it to be serviced.&n; *&n; *&t;This is not to be called from within the request handling part&n; *&t;of the driver ! We allocate here data in the stack, and it is valid&n; *&t;until the request is finished. This is not the case for the bottom&n; *&t;part of the driver, where we are always leaving the functions to wait&n; *&t;for an interrupt or a timer event.&n; *&n; *&t;From the bottom part of the driver, we should allocate safe memory&n; *&t;using idetape_next_pc_storage and idetape_next_rq_storage, and add&n; *&t;the request to the request list without waiting for it to be serviced !&n; *&t;In that case, we usually use idetape_queue_pc_head.&n; */
DECL|function|idetape_queue_pc_tail
r_int
id|idetape_queue_pc_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
r_struct
id|request
id|rq
suffix:semicolon
id|ide_init_drive_cmd
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
id|rq.cmd
op_assign
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE1
suffix:semicolon
r_return
id|ide_do_drive_cmd
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_queue_pc_head generates a new packet command request in front&n; *&t;of the request queue, before the current request, so that it will be&n; *&t;processed immediately, on the next pass through the driver.&n; *&n; *&t;idetape_queue_pc_head is called from the request handling part of&n; *&t;the driver (the &quot;bottom&quot; part). Safe storage for the request should&n; *&t;be allocated with idetape_next_pc_storage and idetape_next_rq_storage&n; *&t;before calling idetape_queue_pc_head.&n; *&n; *&t;Memory for those requests is pre-allocated at initialization time, and&n; *&t;is limited to IDETAPE_PC_STACK requests. We assume that we have enough&n; *&t;space for the maximum possible number of inter-dependent packet commands.&n; *&n; *&t;The higher level of the driver - The ioctl handler and the character&n; *&t;device handling functions should queue request to the lower level part&n; *&t;and wait for their completion using idetape_queue_pc_tail or&n; *&t;idetape_queue_rw_tail.&n; */
DECL|function|idetape_queue_pc_head
r_void
id|idetape_queue_pc_head
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_packet_command_t
op_star
id|pc
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_int
r_int
id|major
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
suffix:semicolon
r_struct
id|blk_dev_struct
op_star
id|bdev
op_assign
op_amp
id|blk_dev
(braket
id|major
)braket
suffix:semicolon
id|bdev-&gt;current_request
op_assign
id|HWGROUP
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
multiline_comment|/* Since we may have taken it out */
id|ide_init_drive_cmd
(paren
id|rq
)paren
suffix:semicolon
id|rq-&gt;buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
id|rq-&gt;cmd
op_assign
id|IDETAPE_PACKET_COMMAND_REQUEST_TYPE1
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
id|rq
comma
id|ide_preempt
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_wait_for_request installs a semaphore in a pending request&n; *&t;and sleeps until it is serviced.&n; *&n; *&t;The caller should ensure that the request will not be serviced&n; *&t;before we install the semaphore (usually by disabling interrupts).&n; */
DECL|function|idetape_wait_for_request
r_void
id|idetape_wait_for_request
(paren
r_struct
id|request
op_star
id|rq
)paren
(brace
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|rq
op_eq
l_int|NULL
op_logical_or
op_logical_neg
id|IDETAPE_REQUEST_CMD
(paren
id|rq-&gt;cmd
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: Trying to sleep on non-valid request&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|rq-&gt;sem
op_assign
op_amp
id|sem
suffix:semicolon
id|down
(paren
op_amp
id|sem
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_queue_rw_tail generates a read/write request for the block&n; *&t;device interface and wait for it to be serviced.&n; */
DECL|function|idetape_queue_rw_tail
r_int
id|idetape_queue_rw_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|cmd
comma
r_int
id|blocks
comma
r_char
op_star
id|buffer
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_struct
id|request
id|rq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;idetape_queue_rw_tail: cmd=%d&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_ne
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: the pipeline is active in idetape_queue_rw_tail&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */&t;
id|ide_init_drive_cmd
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.buffer
op_assign
id|buffer
suffix:semicolon
id|rq.cmd
op_assign
id|cmd
suffix:semicolon
id|rq.sector
op_assign
id|tape-&gt;block_address
suffix:semicolon
id|rq.nr_sectors
op_assign
id|rq.current_nr_sectors
op_assign
id|blocks
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
op_amp
id|rq
comma
id|ide_wait
)paren
suffix:semicolon
r_return
(paren
id|tape-&gt;tape_block_size
op_star
(paren
id|blocks
op_minus
id|rq.current_nr_sectors
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_add_chrdev_read_request handles character device read requests&n; *&t;when operating in the pipelined operation mode.&n; */
DECL|function|idetape_add_chrdev_read_request
r_int
id|idetape_add_chrdev_read_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|blocks
comma
r_char
op_star
id|buffer
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_pipeline_stage_t
op_star
id|new_stage
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
id|rq
comma
op_star
id|rq_ptr
suffix:semicolon
r_int
id|bytes_read
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_add_chrdev_read_request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|ide_init_drive_cmd
(paren
op_amp
id|rq
)paren
suffix:semicolon
id|rq.cmd
op_assign
id|IDETAPE_READ_REQUEST
suffix:semicolon
id|rq.sector
op_assign
id|tape-&gt;block_address
suffix:semicolon
id|rq.nr_sectors
op_assign
id|rq.current_nr_sectors
op_assign
id|blocks
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_ne
l_int|NULL
op_logical_or
id|tape-&gt;current_number_of_stages
op_le
id|tape-&gt;max_number_of_stages
op_div
l_int|4
)paren
(brace
id|new_stage
op_assign
id|idetape_kmalloc_stage
(paren
id|drive
)paren
suffix:semicolon
r_while
c_loop
(paren
id|new_stage
op_ne
l_int|NULL
)paren
(brace
id|new_stage-&gt;rq
op_assign
id|rq
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|idetape_add_stage_tail
(paren
id|drive
comma
id|new_stage
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|new_stage
op_assign
id|idetape_kmalloc_stage
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_eq
l_int|NULL
)paren
id|idetape_insert_pipeline_into_queue
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;Linux is short on memory. Revert to non-pipelined&n;&t;&t; *&t;operation mode for this request.&n;&t;&t; */
r_return
(paren
id|idetape_queue_rw_tail
(paren
id|drive
comma
id|IDETAPE_READ_REQUEST
comma
id|blocks
comma
id|buffer
)paren
)paren
suffix:semicolon
)brace
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_eq
op_amp
(paren
id|tape-&gt;first_stage-&gt;rq
)paren
)paren
id|idetape_wait_for_request
(paren
id|tape-&gt;active_data_request
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|rq_ptr
op_assign
op_amp
(paren
id|tape-&gt;first_stage-&gt;rq
)paren
suffix:semicolon
id|bytes_read
op_assign
id|tape-&gt;tape_block_size
op_star
(paren
id|rq_ptr-&gt;nr_sectors
op_minus
id|rq_ptr-&gt;current_nr_sectors
)paren
suffix:semicolon
id|rq_ptr-&gt;nr_sectors
op_assign
id|rq_ptr-&gt;current_nr_sectors
op_assign
l_int|0
suffix:semicolon
id|idetape_copy_buffer_from_stage
(paren
id|tape-&gt;first_stage
comma
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq_ptr-&gt;errors
op_ne
id|IDETAPE_RQ_ERROR_FILEMARK
)paren
id|idetape_remove_stage_head
(paren
id|drive
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|bytes_read
OG
id|blocks
op_star
id|tape-&gt;tape_block_size
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: trying to return more bytes than requested&bslash;n&quot;
)paren
suffix:semicolon
id|bytes_read
op_assign
id|blocks
op_star
id|tape-&gt;tape_block_size
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
r_return
(paren
id|bytes_read
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_add_chrdev_write_request tries to add a character device&n; *&t;originated write request to our pipeline. In case we don&squot;t succeed,&n; *&t;we revert to non-pipelined operation mode for this request.&n; *&n; *&t;1.&t;Try to allocate a new pipeline stage.&n; *&t;2.&t;If we can&squot;t, wait for more and more requests to be serviced&n; *&t;&t;and try again each time.&n; *&t;3.&t;If we still can&squot;t allocate a stage, fallback to&n; *&t;&t;non-pipelined operation mode for this request.&n; */
DECL|function|idetape_add_chrdev_write_request
r_int
id|idetape_add_chrdev_write_request
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|blocks
comma
r_char
op_star
id|buffer
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_pipeline_stage_t
op_star
id|new_stage
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_add_chrdev_write_request&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|new_stage
op_assign
id|idetape_kmalloc_stage
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;If we don&squot;t have a new stage, wait for more and more requests&n;&t; *&t;to finish, and try to allocate after each one.&n;&t; *&n;&t; *&t;Pay special attention to possible race conditions.&n;&t; */
r_while
c_loop
(paren
id|new_stage
op_eq
l_int|NULL
)paren
(brace
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_ne
l_int|NULL
)paren
(brace
id|idetape_wait_for_request
(paren
id|tape-&gt;active_data_request
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|new_stage
op_assign
id|idetape_kmalloc_stage
(paren
id|drive
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Linux is short on memory. Fallback to&n;&t;&t;&t; *&t;non-pipelined operation mode for this request.&n;&t;&t;&t; */
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_rw_tail
(paren
id|drive
comma
id|IDETAPE_WRITE_REQUEST
comma
id|blocks
comma
id|buffer
)paren
)paren
suffix:semicolon
)brace
)brace
id|rq
op_assign
op_amp
(paren
id|new_stage-&gt;rq
)paren
suffix:semicolon
id|ide_init_drive_cmd
(paren
id|rq
)paren
suffix:semicolon
id|rq-&gt;cmd
op_assign
id|IDETAPE_WRITE_REQUEST
suffix:semicolon
id|rq-&gt;sector
op_assign
id|tape-&gt;block_address
suffix:semicolon
multiline_comment|/* Doesn&squot;t actually matter - We always assume sequential access */
id|rq-&gt;nr_sectors
op_assign
id|blocks
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_assign
id|blocks
suffix:semicolon
id|idetape_copy_buffer_to_stage
(paren
id|new_stage
comma
id|buffer
)paren
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|idetape_add_stage_tail
(paren
id|drive
comma
id|new_stage
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;Check if we are currently servicing requests in the bottom&n;&t; *&t;part of the driver.&n;&t; *&n;&t; *&t;If not, wait for the pipeline to be full enough (75%) before&n;&t; *&t;starting to service requests, so that we will be able to&n;&t; *&t;keep up with the higher speeds of the tape.&n;&t; */
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_eq
l_int|NULL
op_logical_and
id|tape-&gt;current_number_of_stages
op_ge
(paren
l_int|3
op_star
id|tape-&gt;max_number_of_stages
)paren
op_div
l_int|4
)paren
id|idetape_insert_pipeline_into_queue
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;error_in_pipeline_stage
)paren
(brace
multiline_comment|/* Return a deferred error */
id|tape-&gt;error_in_pipeline_stage
op_assign
l_int|0
suffix:semicolon
r_return
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
r_return
(paren
id|blocks
)paren
suffix:semicolon
)brace
DECL|function|idetape_discard_read_pipeline
r_void
id|idetape_discard_read_pipeline
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_ne
id|idetape_direction_read
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: Trying to discard read pipeline, but we are not reading.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|tape-&gt;merge_buffer_size
op_assign
id|tape-&gt;merge_buffer_offset
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;chrdev_direction
op_assign
id|idetape_direction_none
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|tape-&gt;next_stage
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_ne
l_int|NULL
)paren
id|idetape_wait_for_request
(paren
id|tape-&gt;active_data_request
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|tape-&gt;first_stage
op_ne
l_int|NULL
)paren
id|idetape_remove_stage_head
(paren
id|drive
)paren
suffix:semicolon
macro_line|#if IDETAPE_PIPELINE
id|tape-&gt;max_number_of_stages
op_assign
id|IDETAPE_MIN_PIPELINE_STAGES
suffix:semicolon
macro_line|#else
id|tape-&gt;max_number_of_stages
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* IDETAPE_PIPELINE */
)brace
multiline_comment|/*&n; *&t;idetape_wait_for_pipeline will wait until all pending pipeline&n; *&t;requests are serviced. Typically called on device close.&n; */
DECL|function|idetape_wait_for_pipeline
r_void
id|idetape_wait_for_pipeline
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_eq
l_int|NULL
)paren
id|idetape_insert_pipeline_into_queue
(paren
id|drive
)paren
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_eq
l_int|NULL
)paren
(brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;last_stage
op_ne
l_int|NULL
)paren
id|idetape_wait_for_request
(paren
op_amp
(paren
id|tape-&gt;last_stage-&gt;rq
)paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_ne
l_int|NULL
)paren
id|idetape_wait_for_request
(paren
id|tape-&gt;active_data_request
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|idetape_empty_write_pipeline
r_void
id|idetape_empty_write_pipeline
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_int
id|blocks
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_ne
id|idetape_direction_write
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: Trying to empty write pipeline, but we are not writing.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;merge_buffer_size
OG
id|tape-&gt;data_buffer_size
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: merge_buffer too big&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;merge_buffer_size
op_assign
id|tape-&gt;data_buffer_size
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
r_if
c_cond
(paren
id|tape-&gt;merge_buffer_size
)paren
(brace
id|blocks
op_assign
id|tape-&gt;merge_buffer_size
op_div
id|tape-&gt;tape_block_size
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;merge_buffer_size
op_mod
id|tape-&gt;tape_block_size
)paren
(brace
id|blocks
op_increment
suffix:semicolon
id|memset
(paren
id|tape-&gt;merge_buffer
op_plus
id|tape-&gt;merge_buffer_size
comma
l_int|0
comma
id|tape-&gt;data_buffer_size
op_minus
id|tape-&gt;merge_buffer_size
)paren
suffix:semicolon
)brace
(paren
r_void
)paren
id|idetape_add_chrdev_write_request
(paren
id|drive
comma
id|blocks
comma
id|tape-&gt;merge_buffer
)paren
suffix:semicolon
id|tape-&gt;merge_buffer_size
op_assign
l_int|0
suffix:semicolon
)brace
id|idetape_wait_for_pipeline
(paren
id|drive
)paren
suffix:semicolon
id|tape-&gt;error_in_pipeline_stage
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;chrdev_direction
op_assign
id|idetape_direction_none
suffix:semicolon
multiline_comment|/*&n;&t; *&t;On the next backup, perform the feedback loop again.&n;&t; *&t;(I don&squot;t want to keep sense information between backups,&n;&t; *&t; as some systems are constantly on, and the system load&n;&t; *&t; can be totally different on the next backup).&n;&t; */
macro_line|#if IDETAPE_PIPELINE
id|tape-&gt;max_number_of_stages
op_assign
id|IDETAPE_MIN_PIPELINE_STAGES
suffix:semicolon
macro_line|#else
id|tape-&gt;max_number_of_stages
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* IDETAPE_PIPELINE */
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_ne
l_int|NULL
op_logical_or
id|tape-&gt;next_stage
op_ne
l_int|NULL
op_logical_or
id|tape-&gt;last_stage
op_ne
l_int|NULL
op_logical_or
id|tape-&gt;current_number_of_stages
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: ide-tape pipeline bug&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
)brace
multiline_comment|/*&n; *&t;idetape_zero_packet_command just zeros a packet command and&n; *&t;sets the number of retries to 0, as we haven&squot;t retried it yet.&n; */
DECL|function|idetape_zero_packet_command
r_void
id|idetape_zero_packet_command
(paren
id|idetape_packet_command_t
op_star
id|pc
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|12
suffix:semicolon
id|i
op_increment
)paren
id|pc-&gt;c
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;retries
op_assign
l_int|0
suffix:semicolon
id|pc
op_member_access_from_pointer
m_abort
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;dma_recommended
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;dma_error
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_swap_shorts converts a 16 bit number from little endian&n; *&t;to big endian format.&n; */
DECL|function|idetape_swap_short
r_int
r_int
id|idetape_swap_short
(paren
r_int
r_int
id|temp
)paren
(brace
r_union
id|convert
(brace
r_int
id|all
suffix:colon
l_int|16
suffix:semicolon
r_struct
(brace
r_int
id|b1
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b2
suffix:colon
l_int|8
suffix:semicolon
)brace
id|b
suffix:semicolon
)brace
id|original
comma
id|converted
suffix:semicolon
id|original.all
op_assign
id|temp
suffix:semicolon
id|converted.b.b1
op_assign
id|original.b.b2
suffix:semicolon
id|converted.b.b2
op_assign
id|original.b.b1
suffix:semicolon
r_return
(paren
id|converted.all
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_swap_long converts from little endian to big endian format.&n; */
DECL|function|idetape_swap_long
r_int
r_int
id|idetape_swap_long
(paren
r_int
r_int
id|temp
)paren
(brace
r_union
id|convert
(brace
r_int
id|all
suffix:colon
l_int|32
suffix:semicolon
r_struct
(brace
r_int
id|b1
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b2
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b3
suffix:colon
l_int|8
suffix:semicolon
r_int
id|b4
suffix:colon
l_int|8
suffix:semicolon
)brace
id|b
suffix:semicolon
)brace
id|original
comma
id|converted
suffix:semicolon
id|original.all
op_assign
id|temp
suffix:semicolon
id|converted.b.b1
op_assign
id|original.b.b4
suffix:semicolon
id|converted.b.b2
op_assign
id|original.b.b3
suffix:semicolon
id|converted.b.b3
op_assign
id|original.b.b2
suffix:semicolon
id|converted.b.b4
op_assign
id|original.b.b1
suffix:semicolon
r_return
(paren
id|converted.all
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_next_pc_storage returns a pointer to a place in which we can&n; *&t;safely store a packet command, even though we intend to leave the&n; *&t;driver. A storage space for a maximum of IDETAPE_PC_STACK packet&n; *&t;commands is allocated at initialization time.&n; */
DECL|function|idetape_next_pc_storage
id|idetape_packet_command_t
op_star
id|idetape_next_pc_storage
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: pc_stack_index=%d&bslash;n&quot;
comma
id|tape-&gt;pc_stack_index
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|tape-&gt;pc_stack_index
op_eq
id|IDETAPE_PC_STACK
)paren
id|tape-&gt;pc_stack_index
op_assign
l_int|0
suffix:semicolon
r_return
(paren
op_amp
(paren
id|tape-&gt;pc_stack
(braket
id|tape-&gt;pc_stack_index
op_increment
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_next_rq_storage is used along with idetape_next_pc_storage.&n; *&t;Since we queue packet commands in the request queue, we need to&n; *&t;allocate a request, along with the allocation of a packet command.&n; */
multiline_comment|/**************************************************************&n; *                                                            *&n; *  This should get fixed to use kmalloc(GFP_ATOMIC, ..)      *&n; *  followed later on by kfree().   -ml                       *&n; *                                                            *&n; **************************************************************/
DECL|function|idetape_next_rq_storage
r_struct
id|request
op_star
id|idetape_next_rq_storage
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
suffix:semicolon
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;ide-tape: rq_stack_index=%d&bslash;n&quot;
comma
id|tape-&gt;rq_stack_index
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|tape-&gt;rq_stack_index
op_eq
id|IDETAPE_PC_STACK
)paren
id|tape-&gt;rq_stack_index
op_assign
l_int|0
suffix:semicolon
r_return
(paren
op_amp
(paren
id|tape-&gt;rq_stack
(braket
id|tape-&gt;rq_stack_index
op_increment
)braket
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Block device interface functions&n; *&n; *&t;The block device interface should not be used for data transfers.&n; *&t;However, we still allow opening it so that we can issue general&n; *&t;ide driver configuration ioctl&squot;s, such as the interrupt unmask feature.&n; */
DECL|function|idetape_blkdev_open
r_int
id|idetape_blkdev_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_blkdev_open&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|tape-&gt;busy
)paren
(brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Allowing access only through one */
r_return
(paren
op_minus
id|EBUSY
)paren
suffix:semicolon
multiline_comment|/* one file descriptor */
)brace
id|tape-&gt;busy
op_assign
l_int|1
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|idetape_blkdev_release
r_void
id|idetape_blkdev_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_blkdev_release&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|tape-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Character device interface functions&n; */
multiline_comment|/*&n; *&t;Our character device read / write functions.&n; *&n; *&t;The tape is optimized to maximize throughput when it is transferring&n; *&t;an integral number of the &quot;continuous transfer limit&quot;, which is&n; *&t;a parameter of the specific tape (26 KB on my particular tape).&n; *&n; *&t;For best results use an integral number of the tape&squot;s parameter&n; *&t;(which is displayed in the driver installation stage and is returned&n; *&t; by the MTIOCGET ioctl).&n; *&n; *&t;As of version 1.3 of the driver, the character device provides an&n; *&t;abstract continuous view of the media - any mix of block sizes (even 1&n; *&t;byte) on the same backup/restore procedure is supported. The driver&n; *&t;will internally convert the requests to the recommended transfer unit,&n; *&t;so that an unmatch between the user&squot;s block size to the recommended&n; *&t;size will only result in a (slightly) increased driver overhead, but&n; *&t;will no longer hit performance.&n; */
DECL|function|idetape_chrdev_read
r_int
id|idetape_chrdev_read
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_char
op_star
id|buf_ptr
op_assign
id|buf
suffix:semicolon
r_int
id|bytes_read
comma
id|temp
comma
id|actually_read
op_assign
l_int|0
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_chrdev_read&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_ne
id|idetape_direction_read
)paren
(brace
multiline_comment|/* Initialize read operation */
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_write
)paren
(brace
id|idetape_empty_write_pipeline
(paren
id|drive
)paren
suffix:semicolon
id|idetape_flush_tape_buffers
(paren
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *&t;Issue a read 0 command to ensure that DSC handshake&n;&t;&t; *&t;is switched from completion mode to buffer available&n;&t;&t; *&t;mode.&n;&t;&t; */
id|bytes_read
op_assign
id|idetape_queue_rw_tail
(paren
id|drive
comma
id|IDETAPE_READ_REQUEST
comma
l_int|0
comma
id|tape-&gt;merge_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes_read
OL
l_int|0
)paren
r_return
(paren
id|bytes_read
)paren
suffix:semicolon
id|tape-&gt;chrdev_direction
op_assign
id|idetape_direction_read
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;merge_buffer_size
)paren
(brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;merge_buffer_offset
op_plus
id|tape-&gt;merge_buffer_size
OG
id|tape-&gt;data_buffer_size
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: merge buffer too big&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;merge_buffer_offset
op_assign
l_int|0
suffix:semicolon
id|tape-&gt;merge_buffer_size
op_assign
id|tape-&gt;data_buffer_size
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|actually_read
op_assign
id|IDETAPE_MIN
(paren
id|tape-&gt;merge_buffer_size
comma
id|count
)paren
suffix:semicolon
id|memcpy_tofs
(paren
id|buf_ptr
comma
id|tape-&gt;merge_buffer
op_plus
id|tape-&gt;merge_buffer_offset
comma
id|actually_read
)paren
suffix:semicolon
id|buf_ptr
op_add_assign
id|actually_read
suffix:semicolon
id|tape-&gt;merge_buffer_size
op_sub_assign
id|actually_read
suffix:semicolon
id|count
op_sub_assign
id|actually_read
suffix:semicolon
id|tape-&gt;merge_buffer_offset
op_add_assign
id|actually_read
suffix:semicolon
)brace
r_while
c_loop
(paren
id|count
op_ge
id|tape-&gt;data_buffer_size
)paren
(brace
id|bytes_read
op_assign
id|idetape_add_chrdev_read_request
(paren
id|drive
comma
id|tape-&gt;capabilities.ctl
comma
id|tape-&gt;merge_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes_read
op_le
l_int|0
)paren
r_return
(paren
id|actually_read
)paren
suffix:semicolon
id|memcpy_tofs
(paren
id|buf_ptr
comma
id|tape-&gt;merge_buffer
comma
id|bytes_read
)paren
suffix:semicolon
id|buf_ptr
op_add_assign
id|bytes_read
suffix:semicolon
id|count
op_sub_assign
id|bytes_read
suffix:semicolon
id|actually_read
op_add_assign
id|bytes_read
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
id|bytes_read
op_assign
id|idetape_add_chrdev_read_request
(paren
id|drive
comma
id|tape-&gt;capabilities.ctl
comma
id|tape-&gt;merge_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bytes_read
op_le
l_int|0
)paren
r_return
(paren
id|actually_read
)paren
suffix:semicolon
id|temp
op_assign
id|IDETAPE_MIN
(paren
id|count
comma
id|bytes_read
)paren
suffix:semicolon
id|memcpy_tofs
(paren
id|buf_ptr
comma
id|tape-&gt;merge_buffer
comma
id|temp
)paren
suffix:semicolon
id|actually_read
op_add_assign
id|temp
suffix:semicolon
id|tape-&gt;merge_buffer_offset
op_assign
id|temp
suffix:semicolon
id|tape-&gt;merge_buffer_size
op_assign
id|bytes_read
op_minus
id|temp
suffix:semicolon
)brace
r_return
(paren
id|actually_read
)paren
suffix:semicolon
)brace
DECL|function|idetape_chrdev_write
r_int
id|idetape_chrdev_write
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_const
r_char
op_star
id|buf_ptr
op_assign
id|buf
suffix:semicolon
r_int
id|retval
comma
id|actually_written
op_assign
l_int|0
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_chrdev_write&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_ne
id|idetape_direction_write
)paren
(brace
multiline_comment|/* Initialize write operation */
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_read
)paren
id|idetape_discard_read_pipeline
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *&t;Issue a write 0 command to ensure that DSC handshake&n;&t;&t; *&t;is switched from completion mode to buffer available&n;&t;&t; *&t;mode.&n;&t;&t; */
id|retval
op_assign
id|idetape_queue_rw_tail
(paren
id|drive
comma
id|IDETAPE_WRITE_REQUEST
comma
l_int|0
comma
id|tape-&gt;merge_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
OL
l_int|0
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|tape-&gt;chrdev_direction
op_assign
id|idetape_direction_write
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;merge_buffer_size
)paren
(brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;merge_buffer_size
op_ge
id|tape-&gt;data_buffer_size
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: merge buffer too big&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;merge_buffer_size
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|actually_written
op_assign
id|IDETAPE_MIN
(paren
id|tape-&gt;data_buffer_size
op_minus
id|tape-&gt;merge_buffer_size
comma
id|count
)paren
suffix:semicolon
id|memcpy_fromfs
(paren
id|tape-&gt;merge_buffer
op_plus
id|tape-&gt;merge_buffer_size
comma
id|buf_ptr
comma
id|actually_written
)paren
suffix:semicolon
id|buf_ptr
op_add_assign
id|actually_written
suffix:semicolon
id|tape-&gt;merge_buffer_size
op_add_assign
id|actually_written
suffix:semicolon
id|count
op_sub_assign
id|actually_written
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;merge_buffer_size
op_eq
id|tape-&gt;data_buffer_size
)paren
(brace
id|tape-&gt;merge_buffer_size
op_assign
l_int|0
suffix:semicolon
id|retval
op_assign
id|idetape_add_chrdev_write_request
(paren
id|drive
comma
id|tape-&gt;capabilities.ctl
comma
id|tape-&gt;merge_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_le
l_int|0
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|count
op_ge
id|tape-&gt;data_buffer_size
)paren
(brace
id|memcpy_fromfs
(paren
id|tape-&gt;merge_buffer
comma
id|buf_ptr
comma
id|tape-&gt;data_buffer_size
)paren
suffix:semicolon
id|buf_ptr
op_add_assign
id|tape-&gt;data_buffer_size
suffix:semicolon
id|count
op_sub_assign
id|tape-&gt;data_buffer_size
suffix:semicolon
id|retval
op_assign
id|idetape_add_chrdev_write_request
(paren
id|drive
comma
id|tape-&gt;capabilities.ctl
comma
id|tape-&gt;merge_buffer
)paren
suffix:semicolon
id|actually_written
op_add_assign
id|tape-&gt;data_buffer_size
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_le
l_int|0
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
)paren
(brace
id|actually_written
op_add_assign
id|count
suffix:semicolon
id|memcpy_fromfs
(paren
id|tape-&gt;merge_buffer
comma
id|buf_ptr
comma
id|count
)paren
suffix:semicolon
id|tape-&gt;merge_buffer_size
op_add_assign
id|count
suffix:semicolon
)brace
r_return
(paren
id|actually_written
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Our character device ioctls.&n; *&n; *&t;General mtio.h magnetic io commands are supported here, and not in&n; *&t;the corresponding block interface.&n; *&n; *&t;The following ioctls are supported:&n; *&n; *&t;MTIOCTOP -&t;Refer to idetape_mtioctop for detailed description.&n; *&n; *&t;MTIOCGET - &t;The mt_dsreg field in the returned mtget structure&n; *&t;&t;&t;will be set to (recommended block size &lt;&lt;&n; *&t;&t;&t;MT_ST_BLKSIZE_SHIFT) &amp; MT_ST_BLKSIZE_MASK, which&n; *&t;&t;&t;is currently equal to the size itself.&n; *&t;&t;&t;The other mtget fields are not supported.&n; *&n; *&t;&t;&t;Note that we do not actually return the tape&squot;s&n; *&t;&t;&t;block size. Rather, we provide the recommended&n; *&t;&t;&t;number of bytes which should be used as a &quot;user&n; *&t;&t;&t;block size&quot; with the character device read/write&n; *&t;&t;&t;functions to maximize throughput.&n; *&n; *&t;MTIOCPOS -&t;The current tape &quot;position&quot; is returned.&n; *&t;&t;&t;(A unique number which can be used with the MTSEEK&n; *&t;&t;&t; operation to return to this position in some&n; *&t;&t;&t; future time, provided this place was not overwritten&n; *&t;&t;&t; meanwhile).&n; *&n; *&t;Our own ide-tape ioctls are supported on both interfaces.&n; */
DECL|function|idetape_chrdev_ioctl
r_int
id|idetape_chrdev_ioctl
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_packet_command_t
id|pc
suffix:semicolon
r_struct
id|mtop
id|mtop
suffix:semicolon
r_struct
id|mtget
id|mtget
suffix:semicolon
r_struct
id|mtpos
id|mtpos
suffix:semicolon
r_int
id|retval
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_chrdev_ioctl, cmd=%u&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_write
)paren
(brace
id|idetape_empty_write_pipeline
(paren
id|drive
)paren
suffix:semicolon
id|idetape_flush_tape_buffers
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_read
op_logical_and
id|cmd
op_ne
id|MTIOCTOP
)paren
id|idetape_discard_read_pipeline
(paren
id|drive
)paren
suffix:semicolon
id|pc.buffer
op_assign
id|pc.temp_buffer
suffix:semicolon
id|pc.buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc.current_position
op_assign
id|pc.temp_buffer
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|MTIOCTOP
suffix:colon
id|retval
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|mtop
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|memcpy_fromfs
(paren
(paren
r_char
op_star
)paren
op_amp
id|mtop
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|mtop
)paren
)paren
suffix:semicolon
r_return
(paren
id|idetape_mtioctop
(paren
id|drive
comma
id|mtop.mt_op
comma
id|mtop.mt_count
)paren
)paren
suffix:semicolon
r_case
id|MTIOCGET
suffix:colon
id|mtget.mt_dsreg
op_assign
(paren
id|tape-&gt;data_buffer_size
op_lshift
id|MT_ST_BLKSIZE_SHIFT
)paren
op_amp
id|MT_ST_BLKSIZE_MASK
suffix:semicolon
id|retval
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|mtget
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|memcpy_tofs
(paren
(paren
r_char
op_star
)paren
id|arg
comma
(paren
r_char
op_star
)paren
op_amp
id|mtget
comma
r_sizeof
(paren
r_struct
id|mtget
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|MTIOCPOS
suffix:colon
id|idetape_create_read_position_cmd
(paren
op_amp
id|pc
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|mtpos.mt_blkno
op_assign
id|tape-&gt;block_address
suffix:semicolon
id|retval
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|mtpos
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|memcpy_tofs
(paren
(paren
r_char
op_star
)paren
id|arg
comma
(paren
r_char
op_star
)paren
op_amp
id|mtpos
comma
r_sizeof
(paren
r_struct
id|mtpos
)paren
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_default
suffix:colon
r_return
(paren
id|idetape_blkdev_ioctl
(paren
id|drive
comma
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;idetape_mtioctop is called from idetape_chrdev_ioctl when&n; *&t;the general mtio MTIOCTOP ioctl is requested.&n; *&n; *&t;We currently support the following mtio.h operations:&n; *&n; *&t;MTFSF&t;-&t;Space over mt_count filemarks in the positive direction.&n; *&t;&t;&t;The tape is positioned after the last spaced filemark.&n; *&n; *&t;MTFSFM&t;-&t;Same as MTFSF, but the tape is positioned before the&n; *&t;&t;&t;last filemark.&n; *&n; *&t;MTBSF&t;-&t;Steps background over mt_count filemarks, tape is&n; *&t;&t;&t;positioned before the last filemark.&n; *&n; *&t;MTBSFM&t;-&t;Like MTBSF, only tape is positioned after the last filemark.&n; *&n; *&n; *&t;Note:&n; *&n; *&t;&t;MTBSF and MTBSFM are not supported when the tape doesn&squot;t&n; *&t;&t;supports spacing over filemarks in the reverse direction.&n; *&t;&t;In this case, MTFSFM is also usually not supported (it is&n; *&t;&t;supported in the rare case in which we crossed the filemark&n; *&t;&t;during our read-ahead pipelined operation mode).&n; *&t;&t;&n; *&t;MTWEOF&t;-&t;Writes mt_count filemarks. Tape is positioned after&n; *&t;&t;&t;the last written filemark.&n; *&n; *&t;MTREW&t;-&t;Rewinds tape.&n; *&n; *&t;MTOFFL&t;-&t;Puts the tape drive &quot;Offline&quot;: Rewinds the tape and&n; *&t;&t;&t;prevents further access until the media is replaced.&n; *&n; *&t;MTNOP&t;-&t;Flushes tape buffers.&n; *&n; *&t;MTRETEN&t;-&t;Retension media. This typically consists of one end&n; *&t;&t;&t;to end pass on the media.&n; *&n; *&t;MTEOM&t;-&t;Moves to the end of recorded data.&n; *&n; *&t;MTERASE&t;-&t;Erases tape.&n; *&n; *&t;MTSEEK&t;-&t;Positions the tape in a specific block number, which&n; *&t;&t;&t;was previously received using the MTIOCPOS ioctl,&n; *&t;&t;&t;assuming this place was not overwritten meanwhile.&n; *&n; *&t;The following commands are currently not supported:&n; *&n; *&t;MTFSR, MTBSR, MTFSS, MTBSS, MTWSM, MTSETBLK, MTSETDENSITY,&n; *&t;MTSETDRVBUFFER, MT_ST_BOOLEANS, MT_ST_WRITE_THRESHOLD.&n; */
DECL|function|idetape_mtioctop
r_int
id|idetape_mtioctop
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|mt_op
comma
r_int
id|mt_count
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_packet_command_t
id|pc
suffix:semicolon
r_int
id|i
comma
id|retval
suffix:semicolon
id|pc.buffer
op_assign
id|pc.temp_buffer
suffix:semicolon
id|pc.buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc.current_position
op_assign
id|pc.temp_buffer
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Handling MTIOCTOP ioctl: mt_op=%d, mt_count=%d&bslash;n&quot;
comma
id|mt_op
comma
id|mt_count
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
multiline_comment|/*&n;&t; *&t;Commands which need our pipelined read-ahead stages.&n;&t; */
r_switch
c_cond
(paren
id|mt_op
)paren
(brace
r_case
id|MTFSF
suffix:colon
r_case
id|MTFSFM
suffix:colon
r_case
id|MTBSF
suffix:colon
r_case
id|MTBSFM
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|mt_count
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|idetape_space_over_filemarks
(paren
id|drive
comma
id|mt_op
comma
id|mt_count
)paren
)paren
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;Empty the pipeline.&n;&t; */
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_read
)paren
id|idetape_discard_read_pipeline
(paren
id|drive
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mt_op
)paren
(brace
r_case
id|MTWEOF
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mt_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|idetape_create_write_filemark_cmd
(paren
op_amp
id|pc
comma
l_int|1
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|MTREW
suffix:colon
r_return
(paren
id|idetape_rewind_tape
(paren
id|drive
)paren
)paren
suffix:semicolon
r_case
id|MTOFFL
suffix:colon
id|idetape_create_load_unload_cmd
(paren
op_amp
id|pc
comma
op_logical_neg
id|IDETAPE_LU_LOAD_MASK
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTNOP
suffix:colon
r_return
(paren
id|idetape_flush_tape_buffers
(paren
id|drive
)paren
)paren
suffix:semicolon
r_case
id|MTRETEN
suffix:colon
id|idetape_create_load_unload_cmd
(paren
op_amp
id|pc
comma
id|IDETAPE_LU_RETENSION_MASK
op_or
id|IDETAPE_LU_LOAD_MASK
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTEOM
suffix:colon
id|idetape_create_space_cmd
(paren
op_amp
id|pc
comma
l_int|0
comma
id|IDETAPE_SPACE_TO_EOD
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTERASE
suffix:colon
id|retval
op_assign
id|idetape_rewind_tape
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|idetape_create_erase_cmd
(paren
op_amp
id|pc
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTSEEK
suffix:colon
r_return
(paren
id|idetape_position_tape
(paren
id|drive
comma
id|mt_count
)paren
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;ide-tape: MTIO operation %d not supported&bslash;n&quot;
comma
id|mt_op
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;idetape_space_over_filemarks is now a bit more complicated than just&n; *&t;passing the command to the tape since we may have crossed some&n; *&t;filemarks during our pipelined read-ahead mode.&n; *&n; *&t;As a minor side effect, the pipeline enables us to support MTFSFM when&n; *&t;the filemark is in our internal pipeline even if the tape doesn&squot;t&n; *&t;support spacing over filemarks in the reverse direction.&n; */
DECL|function|idetape_space_over_filemarks
r_int
id|idetape_space_over_filemarks
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|mt_op
comma
r_int
id|mt_count
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_packet_command_t
id|pc
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|retval
comma
id|count
op_assign
l_int|0
comma
id|errors
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_read
)paren
(brace
multiline_comment|/*&n;&t;&t; *&t;We have a read-ahead buffer. Scan it for crossed&n;&t;&t; *&t;filemarks.&n;&t;&t; */
id|tape-&gt;merge_buffer_size
op_assign
id|tape-&gt;merge_buffer_offset
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|tape-&gt;first_stage
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *&t;Wait until the first read-ahead request&n;&t;&t;&t; *&t;is serviced.&n;&t;&t;&t; */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_eq
op_amp
(paren
id|tape-&gt;first_stage-&gt;rq
)paren
)paren
id|idetape_wait_for_request
(paren
id|tape-&gt;active_data_request
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|errors
op_assign
id|tape-&gt;first_stage-&gt;rq.errors
suffix:semicolon
r_if
c_cond
(paren
id|errors
op_eq
id|IDETAPE_RQ_ERROR_FILEMARK
)paren
id|count
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|count
op_eq
id|mt_count
)paren
(brace
r_switch
c_cond
(paren
id|mt_op
)paren
(brace
r_case
id|MTFSF
suffix:colon
id|idetape_remove_stage_head
(paren
id|drive
)paren
suffix:semicolon
r_case
id|MTFSFM
suffix:colon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|idetape_remove_stage_head
(paren
id|drive
)paren
suffix:semicolon
)brace
id|idetape_discard_read_pipeline
(paren
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *&t;The filemark was not found in our internal pipeline.&n;&t; *&t;Now we can issue the space command.&n;&t; */
id|pc.buffer
op_assign
id|pc.temp_buffer
suffix:semicolon
id|pc.buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc.current_position
op_assign
id|pc.temp_buffer
suffix:semicolon
r_switch
c_cond
(paren
id|mt_op
)paren
(brace
r_case
id|MTFSF
suffix:colon
id|idetape_create_space_cmd
(paren
op_amp
id|pc
comma
id|mt_count
op_minus
id|count
comma
id|IDETAPE_SPACE_OVER_FILEMARK
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTFSFM
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;capabilities.sprev
)paren
r_return
(paren
op_minus
id|EIO
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_mtioctop
(paren
id|drive
comma
id|MTFSF
comma
id|mt_count
op_minus
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
r_return
(paren
id|idetape_mtioctop
(paren
id|drive
comma
id|MTBSF
comma
l_int|1
)paren
)paren
suffix:semicolon
r_case
id|MTBSF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;capabilities.sprev
)paren
r_return
(paren
op_minus
id|EIO
)paren
suffix:semicolon
id|idetape_create_space_cmd
(paren
op_amp
id|pc
comma
op_minus
(paren
id|mt_count
op_plus
id|count
)paren
comma
id|IDETAPE_SPACE_OVER_FILEMARK
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
r_case
id|MTBSFM
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;capabilities.sprev
)paren
r_return
(paren
op_minus
id|EIO
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_mtioctop
(paren
id|drive
comma
id|MTBSF
comma
id|mt_count
op_plus
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
r_return
(paren
id|idetape_mtioctop
(paren
id|drive
comma
id|MTFSF
comma
l_int|1
)paren
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
(paren
l_string|&quot;ide-tape: MTIO operation %d not supported&bslash;n&quot;
comma
id|mt_op
)paren
suffix:semicolon
r_return
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;Our character device open function.&n; */
DECL|function|idetape_chrdev_open
r_int
id|idetape_chrdev_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_int
id|minor
op_assign
id|MINOR
(paren
id|inode-&gt;i_rdev
)paren
comma
id|allocation_length
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_chrdev_open&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|minor
op_ne
l_int|0
op_logical_and
id|minor
op_ne
l_int|128
)paren
(brace
multiline_comment|/* Currently supporting only one */
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* tape drive */
r_return
(paren
op_minus
id|ENXIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;busy
)paren
(brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Allowing access only through one */
r_return
(paren
op_minus
id|EBUSY
)paren
suffix:semicolon
multiline_comment|/* one file descriptor */
)brace
id|tape-&gt;busy
op_assign
l_int|1
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|allocation_length
op_assign
id|tape-&gt;data_buffer_size
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;data_buffer_size
op_mod
id|IDETAPE_ALLOCATION_BLOCK
)paren
id|allocation_length
op_add_assign
id|IDETAPE_ALLOCATION_BLOCK
suffix:semicolon
macro_line|#if IDETAPE_MINIMIZE_IDLE_MEMORY_USAGE
r_if
c_cond
(paren
id|tape-&gt;data_buffer
op_eq
l_int|NULL
)paren
id|tape-&gt;data_buffer
op_assign
id|kmalloc
(paren
id|allocation_length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;data_buffer
op_eq
l_int|NULL
)paren
r_goto
id|sorry
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;merge_buffer
op_eq
l_int|NULL
)paren
id|tape-&gt;merge_buffer
op_assign
id|kmalloc
(paren
id|allocation_length
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;merge_buffer
op_eq
l_int|NULL
)paren
(brace
id|kfree
(paren
id|tape-&gt;data_buffer
)paren
suffix:semicolon
id|sorry
suffix:colon
id|printk
(paren
l_string|&quot;ide-tape: FATAL - Can not allocate continuous buffer of %d bytes&bslash;n&quot;
comma
id|allocation_length
)paren
suffix:semicolon
id|tape-&gt;busy
op_assign
l_int|0
suffix:semicolon
r_return
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_MINIMIZE_IDLE_MEMORY_USAGE */
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;block_address_valid
)paren
(brace
r_if
c_cond
(paren
id|idetape_rewind_tape
(paren
id|drive
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: Rewinding tape failed&bslash;n&quot;
)paren
suffix:semicolon
id|tape-&gt;busy
op_assign
l_int|0
suffix:semicolon
r_return
(paren
op_minus
id|EIO
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Our character device release function.&n; */
DECL|function|idetape_chrdev_release
r_void
id|idetape_chrdev_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|idetape_chrdev.drive
suffix:semicolon
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_int
r_int
id|minor
op_assign
id|MINOR
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|idetape_packet_command_t
id|pc
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_chrdev_release&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_write
)paren
(brace
id|idetape_empty_write_pipeline
(paren
id|drive
)paren
suffix:semicolon
id|idetape_create_write_filemark_cmd
(paren
op_amp
id|pc
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Write a filemark */
r_if
c_cond
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
id|printk
(paren
l_string|&quot;ide-tape: Couldn&squot;t write a filemark&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;chrdev_direction
op_eq
id|idetape_direction_read
)paren
(brace
r_if
c_cond
(paren
id|minor
OL
l_int|128
)paren
id|idetape_discard_read_pipeline
(paren
id|drive
)paren
suffix:semicolon
r_else
id|idetape_wait_for_pipeline
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|minor
OL
l_int|128
)paren
r_if
c_cond
(paren
id|idetape_rewind_tape
(paren
id|drive
)paren
)paren
id|printk
(paren
l_string|&quot;ide-tape: Rewinding tape failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if IDETAPE_MINIMIZE_IDLE_MEMORY_USAGE
id|kfree
(paren
id|tape-&gt;data_buffer
)paren
suffix:semicolon
id|tape-&gt;data_buffer
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tape-&gt;merge_buffer_size
)paren
(brace
id|kfree
(paren
id|tape-&gt;merge_buffer
)paren
suffix:semicolon
id|tape-&gt;merge_buffer
op_assign
l_int|NULL
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_MINIMIZE_IDLE_MEMORY_USAGE */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|tape-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_position_tape positions the tape to the requested block&n; *&t;using the LOCATE packet command. A READ POSITION command is then&n; *&t;issued to check where we are positioned.&n; *&n; *&t;Like all higher level operations, we queue the commands at the tail&n; *&t;of the request queue and wait for their completion.&n; *&t;&n; */
DECL|function|idetape_position_tape
r_int
id|idetape_position_tape
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|block
)paren
(brace
r_int
id|retval
suffix:semicolon
id|idetape_packet_command_t
id|pc
suffix:semicolon
id|idetape_create_locate_cmd
(paren
op_amp
id|pc
comma
id|block
comma
l_int|0
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
op_ne
l_int|0
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|idetape_create_read_position_cmd
(paren
op_amp
id|pc
)paren
suffix:semicolon
id|pc.buffer
op_assign
id|pc.temp_buffer
suffix:semicolon
id|pc.buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc.current_position
op_assign
id|pc.temp_buffer
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Rewinds the tape to the Beginning Of the current Partition (BOP).&n; *&n; *&t;We currently support only one partition.&n; */
DECL|function|idetape_rewind_tape
r_int
id|idetape_rewind_tape
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|retval
suffix:semicolon
id|idetape_packet_command_t
id|pc
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_rewind_tape&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */&t;
id|idetape_create_rewind_cmd
(paren
op_amp
id|pc
)paren
suffix:semicolon
id|retval
op_assign
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retval
)paren
r_return
(paren
id|retval
)paren
suffix:semicolon
id|idetape_create_read_position_cmd
(paren
op_amp
id|pc
)paren
suffix:semicolon
id|pc.buffer
op_assign
id|pc.temp_buffer
suffix:semicolon
id|pc.buffer_size
op_assign
id|IDETAPE_TEMP_BUFFER_SIZE
suffix:semicolon
id|pc.current_position
op_assign
id|pc.temp_buffer
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
)brace
DECL|function|idetape_flush_tape_buffers
r_int
id|idetape_flush_tape_buffers
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_packet_command_t
id|pc
suffix:semicolon
id|idetape_create_write_filemark_cmd
(paren
op_amp
id|pc
comma
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|idetape_queue_pc_tail
(paren
id|drive
comma
op_amp
id|pc
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Pipeline related functions&n; */
multiline_comment|/*&n; *&t;idetape_kmalloc_stage uses kmalloc to allocate a pipeline stage,&n; *&t;along with all the necessary small buffers which together make&n; *&t;a buffer of size tape-&gt;data_buffer_size or a bit more, in case&n; *&t;it is not a multiply of IDETAPE_ALLOCATION_BLOCK (it isn&squot;t ...).&n; *&n; *&t;Returns a pointer to the new allocated stage, or NULL if we&n; *&t;can&squot;t (or don&squot;t want to, in case we already have too many stages)&n; *&t;allocate a stage.&n; *&n; *&t;Pipeline stages are optional and are used to increase performance.&n; *&t;If we can&squot;t allocate them, we&squot;ll manage without them.&n; */
DECL|function|idetape_kmalloc_stage
id|idetape_pipeline_stage_t
op_star
id|idetape_kmalloc_stage
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_pipeline_stage_t
op_star
id|new_stage
suffix:semicolon
id|idetape_buffer_head_t
op_star
id|prev_bh
comma
op_star
id|bh
suffix:semicolon
r_int
id|buffers_num
comma
id|i
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_kmalloc_stage&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_if
c_cond
(paren
id|tape-&gt;current_number_of_stages
op_ge
id|tape-&gt;max_number_of_stages
)paren
(brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|new_stage
op_assign
(paren
id|idetape_pipeline_stage_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|idetape_pipeline_stage_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_stage
op_eq
l_int|NULL
)paren
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
id|new_stage-&gt;next
op_assign
id|new_stage-&gt;prev
op_assign
l_int|NULL
suffix:semicolon
id|buffers_num
op_assign
id|tape-&gt;data_buffer_size
op_div
id|IDETAPE_ALLOCATION_BLOCK
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;data_buffer_size
op_mod
id|IDETAPE_ALLOCATION_BLOCK
)paren
id|buffers_num
op_increment
suffix:semicolon
id|prev_bh
op_assign
id|new_stage-&gt;bh
op_assign
(paren
id|idetape_buffer_head_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|idetape_buffer_head_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_stage-&gt;bh
op_eq
l_int|NULL
)paren
(brace
id|idetape_kfree_stage
(paren
id|new_stage
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|new_stage-&gt;bh-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|new_stage-&gt;bh-&gt;data
op_assign
id|kmalloc
(paren
id|IDETAPE_ALLOCATION_BLOCK
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|new_stage-&gt;bh-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|idetape_kfree_stage
(paren
id|new_stage
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|buffers_num
suffix:semicolon
id|i
op_increment
)paren
(brace
id|bh
op_assign
(paren
id|idetape_buffer_head_t
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
id|idetape_buffer_head_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
id|idetape_kfree_stage
(paren
id|new_stage
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|bh-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|prev_bh-&gt;next
op_assign
id|bh
suffix:semicolon
id|bh-&gt;data
op_assign
id|kmalloc
(paren
id|IDETAPE_ALLOCATION_BLOCK
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|idetape_kfree_stage
(paren
id|new_stage
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|prev_bh
op_assign
id|bh
suffix:semicolon
)brace
r_return
(paren
id|new_stage
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_kfree_stage calls kfree to completely free a stage, along with&n; *&t;its related buffers.&n; */
DECL|function|idetape_kfree_stage
r_void
id|idetape_kfree_stage
(paren
id|idetape_pipeline_stage_t
op_star
id|stage
)paren
(brace
id|idetape_buffer_head_t
op_star
id|prev_bh
comma
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|stage
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_kfree_stage&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|bh
op_assign
id|stage-&gt;bh
suffix:semicolon
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
(brace
id|prev_bh
op_assign
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;data
op_ne
l_int|NULL
)paren
id|kfree
(paren
id|bh-&gt;data
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;next
suffix:semicolon
id|kfree
(paren
id|prev_bh
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|stage
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_copy_buffer_from_stage and idetape_copy_buffer_to_stage&n; *&t;copy data from/to the small buffers into/from a continuous buffer.&n; */
DECL|function|idetape_copy_buffer_from_stage
r_void
id|idetape_copy_buffer_from_stage
(paren
id|idetape_pipeline_stage_t
op_star
id|stage
comma
r_char
op_star
id|buffer
)paren
(brace
id|idetape_buffer_head_t
op_star
id|bh
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_copy_buffer_from_stage&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: buffer is null in copy_buffer_from_stage&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|ptr
op_assign
id|buffer
suffix:semicolon
id|bh
op_assign
id|stage-&gt;bh
suffix:semicolon
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
(brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|bh-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: bh-&gt;data is null&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|memcpy
(paren
id|ptr
comma
id|bh-&gt;data
comma
id|IDETAPE_ALLOCATION_BLOCK
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;next
suffix:semicolon
id|ptr
op_assign
id|ptr
op_plus
id|IDETAPE_ALLOCATION_BLOCK
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;Here we copy a continuous data buffer to the various small buffers&n; *&t;in the pipeline stage.&n; */
DECL|function|idetape_copy_buffer_to_stage
r_void
id|idetape_copy_buffer_to_stage
(paren
id|idetape_pipeline_stage_t
op_star
id|stage
comma
r_char
op_star
id|buffer
)paren
(brace
id|idetape_buffer_head_t
op_star
id|bh
suffix:semicolon
r_char
op_star
id|ptr
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_copy_buffer_to_stage&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|buffer
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: buffer is null in copy_buffer_to_stage&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|ptr
op_assign
id|buffer
suffix:semicolon
id|bh
op_assign
id|stage-&gt;bh
suffix:semicolon
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
(brace
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|bh-&gt;data
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: bh-&gt;data is null&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|memcpy
(paren
id|bh-&gt;data
comma
id|ptr
comma
id|IDETAPE_ALLOCATION_BLOCK
)paren
suffix:semicolon
id|bh
op_assign
id|bh-&gt;next
suffix:semicolon
id|ptr
op_assign
id|ptr
op_plus
id|IDETAPE_ALLOCATION_BLOCK
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_increase_max_pipeline_stages is a part of the feedback&n; *&t;loop which tries to find the optimum number of stages. In the&n; *&t;feedback loop, we are starting from a minimum maximum number of&n; *&t;stages, and if we sense that the pipeline is empty, we try to&n; *&t;increase it, until we reach the user compile time memory limit.&n; */
DECL|function|idetape_increase_max_pipeline_stages
r_void
id|idetape_increase_max_pipeline_stages
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_increase_max_pipeline_stages&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|tape-&gt;max_number_of_stages
op_add_assign
id|IDETAPE_INCREASE_STAGES_RATE
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;max_number_of_stages
op_ge
id|IDETAPE_MAX_PIPELINE_STAGES
)paren
id|tape-&gt;max_number_of_stages
op_assign
id|IDETAPE_MAX_PIPELINE_STAGES
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Maximum number of stages: %d&bslash;n&quot;
comma
id|tape-&gt;max_number_of_stages
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_add_stage_tail adds a new stage at the end of the pipeline.&n; *&n; *&t;Caller should disable interrupts, if necessary.&n; */
DECL|function|idetape_add_stage_tail
r_void
id|idetape_add_stage_tail
(paren
id|ide_drive_t
op_star
id|drive
comma
id|idetape_pipeline_stage_t
op_star
id|stage
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_add_stage_tail&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
id|stage-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|stage-&gt;prev
op_assign
id|tape-&gt;last_stage
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;last_stage
op_ne
l_int|NULL
)paren
id|tape-&gt;last_stage-&gt;next
op_assign
id|stage
suffix:semicolon
r_else
id|tape-&gt;first_stage
op_assign
id|tape-&gt;next_stage
op_assign
id|stage
suffix:semicolon
id|tape-&gt;last_stage
op_assign
id|stage
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;next_stage
op_eq
l_int|NULL
)paren
id|tape-&gt;next_stage
op_assign
id|tape-&gt;last_stage
suffix:semicolon
id|tape-&gt;current_number_of_stages
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;idetape_remove_stage_head removes tape-&gt;first_stage from the pipeline.&n; *&n; *&t;Again, caller should avoid race conditions.&n; */
DECL|function|idetape_remove_stage_head
r_void
id|idetape_remove_stage_head
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_pipeline_stage_t
op_star
id|stage
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_remove_stage_head&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: tape-&gt;first_stage is NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tape-&gt;active_stage
op_eq
id|tape-&gt;first_stage
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: Trying to free our active pipeline stage&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
id|stage
op_assign
id|tape-&gt;first_stage
suffix:semicolon
id|tape-&gt;first_stage
op_assign
id|stage-&gt;next
suffix:semicolon
id|idetape_kfree_stage
(paren
id|stage
)paren
suffix:semicolon
id|tape-&gt;current_number_of_stages
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;first_stage
op_eq
l_int|NULL
)paren
(brace
id|tape-&gt;last_stage
op_assign
l_int|NULL
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|tape-&gt;next_stage
op_ne
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;ide-tape: bug: tape-&gt;next_stage != NULL&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;current_number_of_stages
)paren
id|printk
(paren
l_string|&quot;ide-tape: bug: current_number_of_stages should be 0 now&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_BUGS */
)brace
)brace
multiline_comment|/*&n; *&t;idetape_insert_pipeline_into_queue is used to start servicing the&n; *&t;pipeline stages, starting from tape-&gt;next_stage.&n; */
DECL|function|idetape_insert_pipeline_into_queue
r_void
id|idetape_insert_pipeline_into_queue
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;next_stage
op_eq
l_int|NULL
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|tape-&gt;active_data_request
op_eq
l_int|NULL
)paren
(brace
id|idetape_active_next_stage
(paren
id|drive
)paren
suffix:semicolon
(paren
r_void
)paren
(paren
id|ide_do_drive_cmd
(paren
id|drive
comma
id|tape-&gt;active_data_request
comma
id|ide_end
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; *&t;idetape_active_next_stage will declare the next stage as &quot;active&quot;.&n; */
DECL|function|idetape_active_next_stage
r_void
id|idetape_active_next_stage
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|idetape_tape_t
op_star
id|tape
op_assign
op_amp
(paren
id|drive-&gt;tape
)paren
suffix:semicolon
id|idetape_pipeline_stage_t
op_star
id|stage
op_assign
id|tape-&gt;next_stage
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
op_amp
(paren
id|stage-&gt;rq
)paren
suffix:semicolon
macro_line|#if IDETAPE_DEBUG_LOG
id|printk
(paren
l_string|&quot;Reached idetape_active_next_stage&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* IDETAPE_DEBUG_LOG */
macro_line|#if IDETAPE_DEBUG_BUGS
r_if
c_cond
(paren
id|stage
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;ide-tape: bug: Trying to activate a non existing stage&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* IDETAPE_DEBUG_BUGS */&t;
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|IDETAPE_WRITE_REQUEST
)paren
id|idetape_copy_buffer_from_stage
(paren
id|stage
comma
id|tape-&gt;data_buffer
)paren
suffix:semicolon
id|rq-&gt;buffer
op_assign
id|tape-&gt;data_buffer
suffix:semicolon
id|tape-&gt;active_data_request
op_assign
id|rq
suffix:semicolon
id|tape-&gt;active_stage
op_assign
id|stage
suffix:semicolon
id|tape-&gt;next_stage
op_assign
id|stage-&gt;next
suffix:semicolon
)brace
eof
