multiline_comment|/* cm206.c. A linux-driver for the cm206 cdrom player with cm260 adapter card.&n;   Copyright (c) 1995 David van Leeuwen.&n;   &n;     This program is free software; you can redistribute it and/or modify&n;     it under the terms of the GNU General Public License as published by&n;     the Free Software Foundation; either version 2 of the License, or&n;     (at your option) any later version.&n;     &n;     This program is distributed in the hope that it will be useful,&n;     but WITHOUT ANY WARRANTY; without even the implied warranty of&n;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;     GNU General Public License for more details.&n;     &n;     You should have received a copy of the GNU General Public License&n;     along with this program; if not, write to the Free Software&n;     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;History:&n; Started 25 jan 1994. Waiting for documentation...&n; 22 feb 1995: 0.1a first reasonably safe polling driver.&n;&t;      Two major bugs, one in read_sector and one in &n;&t;      do_cm206_request, happened to cancel!&n; 25 feb 1995: 0.2a first reasonable interrupt driven version of above.&n;              uart writes are still done in polling mode. &n; 25 feb 1995: 0.21a writes also in interrupt mode, still some&n;&t;      small bugs to be found... Larger buffer. &n;  2 mrt 1995: 0.22 Bug found (cd-&gt; nowhere, interrupt was called in&n;              initialization), read_ahead of 16. Timeouts implemented.&n;&t;      unclear if they do something...&n;  7 mrt 1995: 0.23 Start of background read-ahead.&n; 18 mrt 1995: 0.24 Working background read-ahead. (still problems)&n; 26 mrt 1995: 0.25 Multi-session ioctl added (kernel v1.2).&n;              Statistics implemented, though separate stats206.h.&n;&t;      Accessible trough ioctl 0x1000 (just a number).&n;&t;      Hard to choose between v1.2 development and 1.1.75.&n;&t;      Bottom-half doesn&squot;t work with 1.2...&n;&t;      0.25a: fixed... typo. Still problems...&n;  1 apr 1995: 0.26 Module support added. Most bugs found. Use kernel 1.2.n.&n;  5 apr 1995: 0.27 Auto-probe for the adapter card base address.&n;              Auto-probe for the adaptor card irq line.&n;  7 apr 1995: 0.28 Added lilo setup support for base address and irq.&n;              Use major number 32 (not in this source), officially&n;&t;      assigned to this driver.&n;  9 apr 1995: 0.29 Added very limited audio support. Toc_header, stop, pause,&n;              resume, eject. Play_track ignores track info, because we can&squot;t &n;&t;      read a table-of-contents entry. Toc_entry is implemented&n;&t;      as a `placebo&squot; function: always returns start of disc. &n;  3 may 1995: 0.30 Audio support completed. The get_toc_entry function&n;              is implemented as a binary search. &n; 15 may 1995: 0.31 More work on audio stuff. Workman is not easy to &n;              satisfy; changed binary search into linear search.&n;&t;      Auto-probe for base address somewhat relaxed.&n;  1 jun 1995: 0.32 Removed probe_irq_on/off for module version.&n; 10 jun 1995: 0.33 Workman still behaves funny, but you should be&n;              able to eject and substitute another disc.&n;&n; An adaption of 0.33 is included in linux-1.3.7 by Eberhard Moenkeberg&n;&n; 18 jul 1996: 0.34 Patch by Heiko Eissfeldt included, mainly considering &n;              verify_area&squot;s in the ioctls. Some bugs introduced by &n;&t;      EM considering the base port and irq fixed. &n; * &n; * Parts of the code are based upon lmscd.c written by Kai Petzke,&n; * sbpcd.c written by Eberhard Moenkeberg, and mcd.c by Martin&n; * Harriss, but any off-the-shelf dynamic programming algorithm won&squot;t&n; * be able to find them.&n; *&n; * The cm206 drive interface and the cm260 adapter card seem to be &n; * sufficiently different from their cm205/cm250 counterparts&n; * in order to write a complete new driver.&n; * &n; * I call all routines connected to the Linux kernel something&n; * with `cm206&squot; in it, as this stuff is too series-dependent. &n; * &n; * Currently, my limited knowledge is based on:&n; * - The Linux Kernel Hacker&squot;s guide, v. 0.5 , by Michael J. Johnson&n; * - Linux Kernel Programmierung, by Michael Beck and others&n; * - Philips/LMS cm206 and cm226 product specification&n; * - Philips/LMS cm260 product specification&n; *&n; *                       David van Leeuwen, david@tm.tno.nl.  */
DECL|macro|VERSION
mdefine_line|#define VERSION &quot;0.34&quot;
macro_line|#ifdef MODULE&t;&t;&t;/* OK, so some of this is stolen */
macro_line|#include &lt;linux/module.h&gt;&t;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#ifndef CONFIG_MODVERSIONS
DECL|variable|kernel_version
r_char
id|kernel_version
(braket
)braket
op_assign
id|UTS_RELEASE
suffix:semicolon
macro_line|#endif
macro_line|#else 
DECL|macro|MOD_INC_USE_COUNT
mdefine_line|#define MOD_INC_USE_COUNT
DECL|macro|MOD_DEC_USE_COUNT
mdefine_line|#define MOD_DEC_USE_COUNT
macro_line|#endif MODULE
macro_line|#include &lt;linux/errno.h&gt;&t;/* These include what we really need */
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR CM206_CDROM_MAJOR
macro_line|#include &quot;blk.h&quot;
macro_line|#include &lt;linux/cm206.h&gt;
multiline_comment|/* This variable defines whether or not to probe for adapter base port &n;   address and interrupt request. It can be overridden by the boot &n;   parameter `auto&squot;.&n;*/
DECL|variable|auto_probe
r_static
r_int
id|auto_probe
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Yes, why not? */
DECL|variable|cm206_base
r_static
r_int
id|cm206_base
op_assign
id|CM206_BASE
suffix:semicolon
DECL|variable|cm206_irq
r_static
r_int
id|cm206_irq
op_assign
id|CM206_IRQ
suffix:semicolon
DECL|macro|DEBUG
macro_line|#undef DEBUG
DECL|macro|DEBUG_SECTORS
macro_line|#undef DEBUG_SECTORS
DECL|macro|STATISTICS
mdefine_line|#define STATISTICS
DECL|macro|AUTO_PROBE_MODULE
macro_line|#undef AUTO_PROBE_MODULE
DECL|macro|POLLOOP
mdefine_line|#define POLLOOP 10000
DECL|macro|READ_AHEAD
mdefine_line|#define READ_AHEAD 1&t;&t;/* defines private buffer, waste! */
DECL|macro|BACK_AHEAD
mdefine_line|#define BACK_AHEAD 1&t;&t;/* defines adapter-read ahead */
DECL|macro|DATA_TIMEOUT
mdefine_line|#define DATA_TIMEOUT (3*HZ)&t;/* measured in jiffies (10 ms) */
DECL|macro|UART_TIMEOUT
mdefine_line|#define UART_TIMEOUT (5*HZ/100)
DECL|macro|DSB_TIMEOUT
mdefine_line|#define DSB_TIMEOUT (7*HZ)&t;/* time for the slowest command to finish */
DECL|macro|RAW_SECTOR_SIZE
mdefine_line|#define RAW_SECTOR_SIZE 2352&t;/* ok, is also defined in cdrom.h */
DECL|macro|ISO_SECTOR_SIZE
mdefine_line|#define ISO_SECTOR_SIZE 2048
macro_line|#ifdef STATISTICS&t;&t;/* keep track of errors in counters */
macro_line|#include &lt;linux/stats206.h&gt;
DECL|macro|stats
mdefine_line|#define stats(i) ++cd-&gt;stats[st_ ## i]; &bslash;&n;                 cd-&gt;last_stat[st_ ## i] = cd-&gt;stat_counter++;
macro_line|#else
DECL|macro|stats
mdefine_line|#define stats(i) (void) 0
macro_line|#endif
macro_line|#ifdef DEBUG&t;&t;&t;/* from lmscd.c */
DECL|macro|debug
mdefine_line|#define debug(a) printk a
macro_line|#else
DECL|macro|debug
mdefine_line|#define debug(a) (void) 0
macro_line|#endif
DECL|typedef|uch
r_typedef
r_int
r_char
id|uch
suffix:semicolon
multiline_comment|/* 8-bits */
DECL|typedef|ush
r_typedef
r_int
r_int
id|ush
suffix:semicolon
multiline_comment|/* 16-bits */
DECL|struct|toc_struct
r_struct
id|toc_struct
(brace
DECL|member|track
DECL|member|fsm
DECL|member|q0
id|uch
id|track
comma
id|fsm
(braket
l_int|3
)braket
comma
id|q0
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|cm206_struct
r_struct
id|cm206_struct
(brace
DECL|member|intr_ds
id|ush
id|intr_ds
suffix:semicolon
multiline_comment|/* data status read on last interrupt */
DECL|member|intr_ls
id|ush
id|intr_ls
suffix:semicolon
multiline_comment|/* uart line status read on last interrupt*/
DECL|member|intr_ur
id|uch
id|intr_ur
suffix:semicolon
multiline_comment|/* uart receive buffer */
DECL|member|dsb
DECL|member|cc
id|uch
id|dsb
comma
id|cc
suffix:semicolon
multiline_comment|/* drive status byte and condition (error) code */
DECL|member|fool
id|uch
id|fool
suffix:semicolon
DECL|member|command
r_int
id|command
suffix:semicolon
multiline_comment|/* command to be written to te uart */
DECL|member|openfiles
r_int
id|openfiles
suffix:semicolon
DECL|member|sector
id|ush
id|sector
(braket
id|READ_AHEAD
op_star
id|RAW_SECTOR_SIZE
op_div
l_int|2
)braket
suffix:semicolon
multiline_comment|/* buffered cd-sector */
DECL|member|sector_first
DECL|member|sector_last
r_int
id|sector_first
comma
id|sector_last
suffix:semicolon
multiline_comment|/* range of these sector */
DECL|member|uart
r_struct
id|wait_queue
op_star
id|uart
suffix:semicolon
multiline_comment|/* wait for interrupt */
DECL|member|data
r_struct
id|wait_queue
op_star
id|data
suffix:semicolon
DECL|member|timer
r_struct
id|timer_list
id|timer
suffix:semicolon
multiline_comment|/* time-out */
DECL|member|timed_out
r_char
id|timed_out
suffix:semicolon
DECL|member|max_sectors
r_int
r_char
id|max_sectors
suffix:semicolon
DECL|member|wait_back
r_char
id|wait_back
suffix:semicolon
multiline_comment|/* we&squot;re waiting for a background-read */
DECL|member|background
r_char
id|background
suffix:semicolon
multiline_comment|/* is a read going on in the background? */
DECL|member|adapter_first
r_int
id|adapter_first
suffix:semicolon
multiline_comment|/* if so, that&squot;s the starting sector */
DECL|member|adapter_last
r_int
id|adapter_last
suffix:semicolon
DECL|member|fifo_overflowed
r_char
id|fifo_overflowed
suffix:semicolon
DECL|member|disc_status
id|uch
id|disc_status
(braket
l_int|7
)braket
suffix:semicolon
multiline_comment|/* result of get_disc_status command */
macro_line|#ifdef STATISTICS
DECL|member|stats
r_int
id|stats
(braket
id|NR_STATS
)braket
suffix:semicolon
DECL|member|last_stat
r_int
id|last_stat
(braket
id|NR_STATS
)braket
suffix:semicolon
multiline_comment|/* `time&squot; at which stat was stat */
DECL|member|stat_counter
r_int
id|stat_counter
suffix:semicolon
macro_line|#endif  
DECL|member|toc
r_struct
id|toc_struct
id|toc
(braket
l_int|101
)braket
suffix:semicolon
multiline_comment|/* The whole table of contents + lead-out */
DECL|member|q
id|uch
id|q
(braket
l_int|10
)braket
suffix:semicolon
multiline_comment|/* Last read q-channel info */
DECL|member|audio_status
id|uch
id|audio_status
(braket
l_int|5
)braket
suffix:semicolon
multiline_comment|/* last read position on pause */
)brace
suffix:semicolon
DECL|macro|DISC_STATUS
mdefine_line|#define DISC_STATUS cd-&gt;disc_status[0]
DECL|macro|FIRST_TRACK
mdefine_line|#define FIRST_TRACK cd-&gt;disc_status[1]
DECL|macro|LAST_TRACK
mdefine_line|#define LAST_TRACK cd-&gt;disc_status[2]
DECL|macro|PAUSED
mdefine_line|#define PAUSED cd-&gt;audio_status[0] /* misuse this memory byte! */
DECL|macro|PLAY_TO
mdefine_line|#define PLAY_TO cd-&gt;toc[0]&t;/* toc[0] records end-time in play */
DECL|variable|cd
r_static
r_struct
id|cm206_struct
op_star
id|cd
suffix:semicolon
multiline_comment|/* First, we define some polling functions. These are actually&n;   only being used in the initialization. */
DECL|function|send_command_polled
r_void
id|send_command_polled
c_func
(paren
r_int
id|command
)paren
(brace
r_int
id|loop
op_assign
id|POLLOOP
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inw
c_func
(paren
id|r_line_status
)paren
op_amp
id|ls_transmitter_buffer_empty
)paren
op_logical_and
id|loop
OG
l_int|0
)paren
op_decrement
id|loop
suffix:semicolon
id|outw
c_func
(paren
id|command
comma
id|r_uart_transmit
)paren
suffix:semicolon
)brace
DECL|function|receive_echo_polled
id|uch
id|receive_echo_polled
c_func
(paren
r_void
)paren
(brace
r_int
id|loop
op_assign
id|POLLOOP
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
id|inw
c_func
(paren
id|r_line_status
)paren
op_amp
id|ls_receive_buffer_full
)paren
op_logical_and
id|loop
OG
l_int|0
)paren
op_decrement
id|loop
suffix:semicolon
r_return
(paren
(paren
id|uch
)paren
id|inw
c_func
(paren
id|r_uart_receive
)paren
)paren
suffix:semicolon
)brace
DECL|function|send_receive_polled
id|uch
id|send_receive_polled
c_func
(paren
r_int
id|command
)paren
(brace
id|send_command_polled
c_func
(paren
id|command
)paren
suffix:semicolon
r_return
id|receive_echo_polled
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* The interrupt handler. When the cm260 generates an interrupt, very&n;   much care has to be taken in reading out the registers in the right&n;   order; in case of a receive_buffer_full interrupt, first the&n;   uart_receive must be read, and then the line status again to&n;   de-assert the interrupt line. It took me a couple of hours to find&n;   this out:-( &n;&n;   The function reset_cm206 appears to cause an interrupt, because&n;   pulling up the INIT line clears both the uart-write-buffer /and/&n;   the uart-write-buffer-empty mask. We call this a `lost interrupt,&squot;&n;   as there seems so reason for this to happen.&n;*/
DECL|function|cm206_interrupt
r_static
r_void
id|cm206_interrupt
c_func
(paren
r_int
id|sig
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
multiline_comment|/* you rang? */
(brace
r_volatile
id|ush
id|fool
suffix:semicolon
id|cd-&gt;intr_ds
op_assign
id|inw
c_func
(paren
id|r_data_status
)paren
suffix:semicolon
multiline_comment|/* resets data_ready, data_error,&n;&t;&t;&t;&t;&t; crc_error, sync_error, toc_ready &n;&t;&t;&t;&t;&t; interrupts */
id|cd-&gt;intr_ls
op_assign
id|inw
c_func
(paren
id|r_line_status
)paren
suffix:semicolon
multiline_comment|/* resets overrun bit */
multiline_comment|/* receive buffer full? */
r_if
c_cond
(paren
id|cd-&gt;intr_ls
op_amp
id|ls_receive_buffer_full
)paren
(brace
id|cd-&gt;intr_ur
op_assign
id|inb
c_func
(paren
id|r_uart_receive
)paren
suffix:semicolon
multiline_comment|/* get order right! */
id|cd-&gt;intr_ls
op_assign
id|inw
c_func
(paren
id|r_line_status
)paren
suffix:semicolon
multiline_comment|/* resets rbf interrupt */
r_if
c_cond
(paren
op_logical_neg
id|cd-&gt;background
op_logical_and
id|cd-&gt;uart
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|cd-&gt;uart
)paren
suffix:semicolon
)brace
multiline_comment|/* data ready in fifo? */
r_else
r_if
c_cond
(paren
id|cd-&gt;intr_ds
op_amp
id|ds_data_ready
)paren
(brace
r_if
c_cond
(paren
id|cd-&gt;background
)paren
op_increment
id|cd-&gt;adapter_last
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cd-&gt;wait_back
op_logical_or
op_logical_neg
id|cd-&gt;background
)paren
op_logical_and
id|cd-&gt;data
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|cd-&gt;data
)paren
suffix:semicolon
id|stats
c_func
(paren
id|data_ready
)paren
suffix:semicolon
)brace
multiline_comment|/* ready to issue a write command? */
r_else
r_if
c_cond
(paren
id|cd-&gt;command
op_logical_and
id|cd-&gt;intr_ls
op_amp
id|ls_transmitter_buffer_empty
)paren
(brace
id|outw
c_func
(paren
id|dc_normal
op_or
(paren
id|inw
c_func
(paren
id|r_data_status
)paren
op_amp
l_int|0x7f
)paren
comma
id|r_data_control
)paren
suffix:semicolon
id|outw
c_func
(paren
id|cd-&gt;command
comma
id|r_uart_transmit
)paren
suffix:semicolon
id|cd-&gt;command
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cd-&gt;background
)paren
id|wake_up_interruptible
c_func
(paren
op_amp
id|cd-&gt;uart
)paren
suffix:semicolon
)brace
multiline_comment|/* now treat errors (at least, identify them for debugging) */
r_else
r_if
c_cond
(paren
id|cd-&gt;intr_ds
op_amp
id|ds_fifo_overflow
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Fifo overflow at sectors 0x%x&bslash;n&quot;
comma
id|cd-&gt;sector_first
)paren
)paren
suffix:semicolon
id|fool
op_assign
id|inw
c_func
(paren
id|r_fifo_output_buffer
)paren
suffix:semicolon
multiline_comment|/* de-assert the interrupt */
id|cd-&gt;fifo_overflowed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* signal one word less should be read */
id|stats
c_func
(paren
id|fifo_overflow
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cd-&gt;intr_ds
op_amp
id|ds_data_error
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Data error at sector 0x%x&bslash;n&quot;
comma
id|cd-&gt;sector_first
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|data_error
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cd-&gt;intr_ds
op_amp
id|ds_crc_error
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;CRC error at sector 0x%x&bslash;n&quot;
comma
id|cd-&gt;sector_first
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|crc_error
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cd-&gt;intr_ds
op_amp
id|ds_sync_error
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Sync at sector 0x%x&bslash;n&quot;
comma
id|cd-&gt;sector_first
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|sync_error
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cd-&gt;intr_ds
op_amp
id|ds_toc_ready
)paren
(brace
multiline_comment|/* do something appropiate */
)brace
multiline_comment|/* couldn&squot;t see why this interrupt, maybe due to init */
r_else
(brace
id|outw
c_func
(paren
id|dc_normal
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
id|stats
c_func
(paren
id|lost_intr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cd-&gt;background
op_logical_and
(paren
id|cd-&gt;adapter_last
op_minus
id|cd-&gt;adapter_first
op_eq
id|cd-&gt;max_sectors
op_logical_or
id|cd-&gt;fifo_overflowed
)paren
)paren
id|mark_bh
c_func
(paren
id|CM206_BH
)paren
suffix:semicolon
multiline_comment|/* issue a stop read command */
id|stats
c_func
(paren
id|interrupt
)paren
suffix:semicolon
)brace
multiline_comment|/* we have put the address of the wait queue in who */
DECL|function|cm206_timeout
r_void
id|cm206_timeout
c_func
(paren
r_int
r_int
id|who
)paren
(brace
id|cd-&gt;timed_out
op_assign
l_int|1
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
(paren
r_struct
id|wait_queue
op_star
op_star
)paren
id|who
)paren
suffix:semicolon
)brace
multiline_comment|/* This function returns 1 if a timeout occurred, 0 if an interrupt&n;   happened */
DECL|function|sleep_or_timeout
r_int
id|sleep_or_timeout
c_func
(paren
r_struct
id|wait_queue
op_star
op_star
id|wait
comma
r_int
id|timeout
)paren
(brace
id|cd-&gt;timer.data
op_assign
(paren
r_int
r_int
)paren
id|wait
suffix:semicolon
id|cd-&gt;timer.expires
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|cd-&gt;timer
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
id|wait
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|cd-&gt;timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;timed_out
)paren
(brace
id|cd-&gt;timed_out
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cm206_delay
r_void
id|cm206_delay
c_func
(paren
r_int
id|jiffies
)paren
(brace
r_struct
id|wait_queue
op_star
id|wait
op_assign
l_int|NULL
suffix:semicolon
id|sleep_or_timeout
c_func
(paren
op_amp
id|wait
comma
id|jiffies
)paren
suffix:semicolon
)brace
DECL|function|send_command
r_void
id|send_command
c_func
(paren
r_int
id|command
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inw
c_func
(paren
id|r_line_status
)paren
op_amp
id|ls_transmitter_buffer_empty
)paren
)paren
(brace
id|cd-&gt;command
op_assign
id|command
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* don&squot;t interrupt before sleep */
id|outw
c_func
(paren
id|dc_mask_sync_error
op_or
id|dc_no_stop_on_error
op_or
(paren
id|inw
c_func
(paren
id|r_data_status
)paren
op_amp
l_int|0x7f
)paren
comma
id|r_data_control
)paren
suffix:semicolon
multiline_comment|/* interrupt routine sends command */
r_if
c_cond
(paren
id|sleep_or_timeout
c_func
(paren
op_amp
id|cd-&gt;uart
comma
id|UART_TIMEOUT
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Time out on write-buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|write_timeout
)paren
suffix:semicolon
id|outw
c_func
(paren
id|command
comma
id|r_uart_transmit
)paren
suffix:semicolon
)brace
)brace
r_else
id|outw
c_func
(paren
id|command
comma
id|r_uart_transmit
)paren
suffix:semicolon
)brace
DECL|function|receive_echo
id|uch
id|receive_echo
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inw
c_func
(paren
id|r_line_status
)paren
op_amp
id|ls_receive_buffer_full
)paren
op_logical_and
id|sleep_or_timeout
c_func
(paren
op_amp
id|cd-&gt;uart
comma
id|UART_TIMEOUT
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Time out on receive-buffer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|receive_timeout
)paren
suffix:semicolon
r_return
(paren
(paren
id|uch
)paren
id|inw
c_func
(paren
id|r_uart_receive
)paren
)paren
suffix:semicolon
)brace
r_return
id|cd-&gt;intr_ur
suffix:semicolon
)brace
DECL|function|send_receive
r_inline
id|uch
id|send_receive
c_func
(paren
r_int
id|command
)paren
(brace
id|send_command
c_func
(paren
id|command
)paren
suffix:semicolon
r_return
id|receive_echo
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|wait_dsb
id|uch
id|wait_dsb
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inw
c_func
(paren
id|r_line_status
)paren
op_amp
id|ls_receive_buffer_full
)paren
op_logical_and
id|sleep_or_timeout
c_func
(paren
op_amp
id|cd-&gt;uart
comma
id|DSB_TIMEOUT
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Time out on Drive Status Byte&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|dsb_timeout
)paren
suffix:semicolon
r_return
(paren
(paren
id|uch
)paren
id|inw
c_func
(paren
id|r_uart_receive
)paren
)paren
suffix:semicolon
)brace
r_return
id|cd-&gt;intr_ur
suffix:semicolon
)brace
DECL|function|type_0_command
r_int
id|type_0_command
c_func
(paren
r_int
id|command
comma
r_int
id|expect_dsb
)paren
(brace
r_int
id|e
suffix:semicolon
r_if
c_cond
(paren
id|command
op_ne
(paren
id|e
op_assign
id|send_receive
c_func
(paren
id|command
)paren
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;command 0x%x echoed as 0x%x&bslash;n&quot;
comma
id|command
comma
id|e
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|echo
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|expect_dsb
)paren
(brace
id|cd-&gt;dsb
op_assign
id|wait_dsb
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for command to finish */
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|type_1_command
r_int
id|type_1_command
c_func
(paren
r_int
id|command
comma
r_int
id|bytes
comma
id|uch
op_star
id|status
)paren
multiline_comment|/* returns info */
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|type_0_command
c_func
(paren
id|command
comma
l_int|0
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bytes
suffix:semicolon
id|i
op_increment
)paren
(brace
id|status
(braket
id|i
)braket
op_assign
id|send_receive
c_func
(paren
id|c_gimme
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function resets the adapter card. We&squot;d better not do this too */
multiline_comment|/* often, because it tends to generate `lost interrupts.&squot; */
DECL|function|reset_cm260
r_void
id|reset_cm260
c_func
(paren
r_void
)paren
(brace
id|outw
c_func
(paren
id|dc_normal
op_or
id|dc_initialize
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* 3.3 mu sec minimum */
id|outw
c_func
(paren
id|dc_normal
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
)brace
multiline_comment|/* fsm: frame-sec-min from linear address */
DECL|function|fsm
r_void
id|fsm
c_func
(paren
r_int
id|lba
comma
id|uch
op_star
id|fsm
)paren
(brace
id|fsm
(braket
l_int|0
)braket
op_assign
id|lba
op_mod
l_int|75
suffix:semicolon
id|lba
op_div_assign
l_int|75
suffix:semicolon
id|lba
op_add_assign
l_int|2
suffix:semicolon
id|fsm
(braket
l_int|1
)braket
op_assign
id|lba
op_mod
l_int|60
suffix:semicolon
id|fsm
(braket
l_int|2
)braket
op_assign
id|lba
op_div
l_int|60
suffix:semicolon
)brace
DECL|function|fsm2lba
r_inline
r_int
id|fsm2lba
c_func
(paren
id|uch
op_star
id|fsm
)paren
(brace
r_return
id|fsm
(braket
l_int|0
)braket
op_plus
l_int|75
op_star
(paren
id|fsm
(braket
l_int|1
)braket
op_minus
l_int|2
op_plus
l_int|60
op_star
id|fsm
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
DECL|function|f_s_m2lba
r_inline
r_int
id|f_s_m2lba
c_func
(paren
id|uch
id|f
comma
id|uch
id|s
comma
id|uch
id|m
)paren
(brace
r_return
id|f
op_plus
l_int|75
op_star
(paren
id|s
op_minus
l_int|2
op_plus
l_int|60
op_star
id|m
)paren
suffix:semicolon
)brace
DECL|function|start_read
r_int
id|start_read
c_func
(paren
r_int
id|start
)paren
(brace
id|uch
id|read_sector
(braket
l_int|4
)braket
op_assign
(brace
id|c_read_data
comma
)brace
suffix:semicolon
r_int
id|i
comma
id|e
suffix:semicolon
id|fsm
c_func
(paren
id|start
comma
op_amp
id|read_sector
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|read_sector
(braket
id|i
)braket
op_ne
(paren
id|e
op_assign
id|send_receive
c_func
(paren
id|read_sector
(braket
id|i
)braket
)paren
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;read_sector: %x echoes %x&bslash;n&quot;
comma
id|read_sector
(braket
id|i
)braket
comma
id|e
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|echo
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|stop_read
r_int
id|stop_read
c_func
(paren
r_void
)paren
(brace
id|type_0_command
c_func
(paren
id|c_stop
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|receive_echo
c_func
(paren
)paren
op_ne
l_int|0xff
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;c_stop didn&squot;t send 0xff&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|stop_0xff
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This function starts to read sectors in adapter memory, the&n;   interrupt routine should stop the read. In fact, the bottom_half&n;   routine takes care of this. Set a flag `background&squot; in the cd&n;   struct to indicate the process. */
DECL|function|read_background
r_int
id|read_background
c_func
(paren
r_int
id|start
comma
r_int
id|reading
)paren
(brace
r_if
c_cond
(paren
id|cd-&gt;background
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* can&squot;t do twice */
id|outw
c_func
(paren
id|dc_normal
op_or
id|BACK_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|reading
op_logical_and
id|start_read
c_func
(paren
id|start
)paren
)paren
r_return
op_minus
l_int|2
suffix:semicolon
id|cd-&gt;adapter_first
op_assign
id|cd-&gt;adapter_last
op_assign
id|start
suffix:semicolon
id|cd-&gt;background
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* flag a read is going on */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|read_sector
r_int
id|read_sector
c_func
(paren
r_int
id|start
)paren
(brace
r_if
c_cond
(paren
id|cd-&gt;background
)paren
(brace
id|cd-&gt;background
op_assign
l_int|0
suffix:semicolon
id|cd-&gt;adapter_last
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* invalidate adapter memory */
id|stop_read
c_func
(paren
)paren
suffix:semicolon
)brace
id|cd-&gt;fifo_overflowed
op_assign
l_int|0
suffix:semicolon
id|reset_cm260
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* empty fifo etc. */
r_if
c_cond
(paren
id|start_read
c_func
(paren
id|start
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|sleep_or_timeout
c_func
(paren
op_amp
id|cd-&gt;data
comma
id|DATA_TIMEOUT
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Read timed out sector 0x%x&bslash;n&quot;
comma
id|start
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|read_timeout
)paren
suffix:semicolon
id|stop_read
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|3
suffix:semicolon
)brace
id|insw
c_func
(paren
id|r_fifo_output_buffer
comma
id|cd-&gt;sector
comma
id|READ_AHEAD
op_star
id|RAW_SECTOR_SIZE
op_div
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_background
c_func
(paren
id|start
op_plus
id|READ_AHEAD
comma
l_int|1
)paren
)paren
id|stats
c_func
(paren
id|read_background
)paren
suffix:semicolon
id|cd-&gt;sector_first
op_assign
id|start
suffix:semicolon
id|cd-&gt;sector_last
op_assign
id|start
op_plus
id|READ_AHEAD
suffix:semicolon
id|stats
c_func
(paren
id|read_restarted
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* The function of bottom-half is to send a stop command to the drive&n;   This isn&squot;t easy because the routine is not `owned&squot; by any process;&n;   we can&squot;t go to sleep! The variable cd-&gt;background gives the status:&n;   0 no read pending&n;   1 a read is pending&n;   2 c_stop waits for write_buffer_empty&n;   3 c_stop waits for receive_buffer_full: echo&n;   4 c_stop waits for receive_buffer_full: 0xff&n;*/
DECL|function|cm206_bh
r_void
id|cm206_bh
c_func
(paren
r_void
op_star
id|unused
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;bh: %d&bslash;n&quot;
comma
id|cd-&gt;background
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cd-&gt;background
)paren
(brace
r_case
l_int|1
suffix:colon
id|stats
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cd-&gt;intr_ls
op_amp
id|ls_transmitter_buffer_empty
)paren
)paren
(brace
id|cd-&gt;command
op_assign
id|c_stop
suffix:semicolon
id|outw
c_func
(paren
id|dc_mask_sync_error
op_or
id|dc_no_stop_on_error
op_or
(paren
id|inw
c_func
(paren
id|r_data_status
)paren
op_amp
l_int|0x7f
)paren
comma
id|r_data_control
)paren
suffix:semicolon
id|cd-&gt;background
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* we&squot;d better not time-out here! */
)brace
r_else
id|outw
c_func
(paren
id|c_stop
comma
id|r_uart_transmit
)paren
suffix:semicolon
multiline_comment|/* fall into case 2: */
r_case
l_int|2
suffix:colon
multiline_comment|/* the write has been satisfied by interrupt routine */
id|cd-&gt;background
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|cd-&gt;intr_ur
op_ne
id|c_stop
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;cm206_bh: c_stop echoed 0x%x&bslash;n&quot;
comma
id|cd-&gt;intr_ur
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|echo
)paren
suffix:semicolon
)brace
id|cd-&gt;background
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
id|cd-&gt;intr_ur
op_ne
l_int|0xff
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;cm206_bh: c_stop reacted with 0x%x&bslash;n&quot;
comma
id|cd-&gt;intr_ur
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|stop_0xff
)paren
suffix:semicolon
)brace
id|cd-&gt;background
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|get_drive_status
r_void
id|get_drive_status
c_func
(paren
r_void
)paren
(brace
id|uch
id|status
(braket
l_int|2
)braket
suffix:semicolon
id|type_1_command
c_func
(paren
id|c_drive_status
comma
l_int|2
comma
id|status
)paren
suffix:semicolon
multiline_comment|/* this might be done faster */
id|cd-&gt;dsb
op_assign
id|status
(braket
l_int|0
)braket
suffix:semicolon
id|cd-&gt;cc
op_assign
id|status
(braket
l_int|1
)braket
suffix:semicolon
)brace
DECL|function|get_disc_status
r_void
id|get_disc_status
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|type_1_command
c_func
(paren
id|c_disc_status
comma
l_int|7
comma
id|cd-&gt;disc_status
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;get_disc_status: error&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|cm206_open
r_static
r_int
id|cm206_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cd-&gt;openfiles
)paren
(brace
id|cd-&gt;background
op_assign
l_int|0
suffix:semicolon
id|reset_cm260
c_func
(paren
)paren
suffix:semicolon
id|cd-&gt;adapter_last
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* invalidate adapter memory */
id|cd-&gt;sector_last
op_assign
op_minus
l_int|1
suffix:semicolon
id|get_drive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;dsb
op_amp
id|dsb_tray_not_closed
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
id|type_0_command
c_func
(paren
id|c_close_tray
comma
l_int|1
)paren
suffix:semicolon
r_while
c_loop
(paren
id|i
op_increment
OL
l_int|10
op_logical_and
id|cd-&gt;dsb
op_amp
id|dsb_drive_not_ready
)paren
(brace
id|cm206_delay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|get_drive_status
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cd-&gt;dsb
op_amp
(paren
id|dsb_not_useful
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cd-&gt;dsb
op_amp
id|dsb_disc_present
)paren
)paren
r_return
op_minus
id|ENODATA
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;dsb
op_amp
id|dsb_possible_media_change
)paren
(brace
id|memset
c_func
(paren
id|cd-&gt;toc
comma
l_int|0
comma
r_sizeof
(paren
id|cd-&gt;toc
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cd-&gt;audio_status
comma
l_int|0
comma
r_sizeof
(paren
id|cd-&gt;audio_status
)paren
)paren
suffix:semicolon
)brace
id|get_disc_status
c_func
(paren
)paren
suffix:semicolon
id|type_0_command
c_func
(paren
id|c_lock_tray
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cd-&gt;dsb
op_amp
id|dsb_tray_locked
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Couldn&squot;t lock tray&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
(paren
id|DISC_STATUS
op_amp
id|cds_all_audio
)paren
)paren
id|read_background
c_func
(paren
l_int|16
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* do something useful */
macro_line|#endif
)brace
op_increment
id|cd-&gt;openfiles
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|stats
c_func
(paren
id|open
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cm206_release
r_static
r_void
id|cm206_release
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_if
c_cond
(paren
id|cd-&gt;openfiles
op_eq
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|cd-&gt;background
)paren
(brace
id|cd-&gt;background
op_assign
l_int|0
suffix:semicolon
id|stop_read
c_func
(paren
)paren
suffix:semicolon
)brace
id|type_0_command
c_func
(paren
id|c_unlock_tray
comma
l_int|1
)paren
suffix:semicolon
id|cd-&gt;sector_last
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Make our internal buffer invalid */
id|FIRST_TRACK
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* No valid disc status */
id|sync_dev
c_func
(paren
id|ip
op_member_access_from_pointer
id|i_rdev
)paren
suffix:semicolon
multiline_comment|/* These two lines are stolen */
id|invalidate_buffers
c_func
(paren
id|ip
op_member_access_from_pointer
id|i_rdev
)paren
suffix:semicolon
)brace
op_decrement
id|cd-&gt;openfiles
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/* Empty buffer empties $sectors$ sectors of the adapter card buffer,&n; * and then reads a sector in kernel memory.  */
DECL|function|empty_buffer
r_void
id|empty_buffer
c_func
(paren
r_int
id|sectors
)paren
(brace
r_while
c_loop
(paren
id|sectors
op_ge
l_int|0
)paren
(brace
id|insw
c_func
(paren
id|r_fifo_output_buffer
comma
id|cd-&gt;sector
op_plus
id|cd-&gt;fifo_overflowed
comma
id|RAW_SECTOR_SIZE
op_div
l_int|2
op_minus
id|cd-&gt;fifo_overflowed
)paren
suffix:semicolon
op_decrement
id|sectors
suffix:semicolon
op_increment
id|cd-&gt;adapter_first
suffix:semicolon
multiline_comment|/* update the current adapter sector */
id|cd-&gt;fifo_overflowed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset overflow bit */
id|stats
c_func
(paren
id|sector_transferred
)paren
suffix:semicolon
)brace
id|cd-&gt;sector_first
op_assign
id|cd-&gt;adapter_first
op_minus
l_int|1
suffix:semicolon
id|cd-&gt;sector_last
op_assign
id|cd-&gt;adapter_first
suffix:semicolon
multiline_comment|/* update the buffer sector */
)brace
multiline_comment|/* try_adapter. This function determines of the requested sector is is&n;   in adapter memory, or will appear there soon. Returns 0 upon&n;   success */
DECL|function|try_adapter
r_int
id|try_adapter
c_func
(paren
r_int
id|sector
)paren
(brace
r_if
c_cond
(paren
id|cd-&gt;adapter_first
op_le
id|sector
op_logical_and
id|sector
OL
id|cd-&gt;adapter_last
)paren
(brace
multiline_comment|/* sector is in adapter memory */
id|empty_buffer
c_func
(paren
id|sector
op_minus
id|cd-&gt;adapter_first
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cd-&gt;background
op_eq
l_int|1
op_logical_and
id|cd-&gt;adapter_first
op_le
id|sector
op_logical_and
id|sector
OL
id|cd-&gt;adapter_first
op_plus
id|cd-&gt;max_sectors
)paren
(brace
multiline_comment|/* a read is going on, we can wait for it */
id|cd-&gt;wait_back
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|sector
op_ge
id|cd-&gt;adapter_last
)paren
(brace
r_if
c_cond
(paren
id|sleep_or_timeout
c_func
(paren
op_amp
id|cd-&gt;data
comma
id|DATA_TIMEOUT
)paren
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Timed out during background wait: %d %d %d %d&bslash;n&quot;
comma
id|sector
comma
id|cd-&gt;adapter_last
comma
id|cd-&gt;adapter_first
comma
id|cd-&gt;background
)paren
)paren
suffix:semicolon
id|stats
c_func
(paren
id|back_read_timeout
)paren
suffix:semicolon
id|cd-&gt;wait_back
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
id|cd-&gt;wait_back
op_assign
l_int|0
suffix:semicolon
id|empty_buffer
c_func
(paren
id|sector
op_minus
id|cd-&gt;adapter_first
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
l_int|2
suffix:semicolon
)brace
multiline_comment|/* This is not a very smart implementation. We could optimize for &n;   consecutive block numbers. I&squot;m not convinced this would really&n;   bring down the processor load. */
DECL|function|do_cm206_request
r_static
r_void
id|do_cm206_request
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
comma
id|cd_sec_no
suffix:semicolon
r_int
id|quarter
comma
id|error
suffix:semicolon
id|uch
op_star
id|source
comma
op_star
id|dest
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
multiline_comment|/* repeat until all requests have been satisfied */
id|INIT_REQUEST
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_eq
l_int|NULL
op_logical_or
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_ne
id|READ
)paren
(brace
id|debug
c_func
(paren
(paren
l_string|&quot;Non-read command %d on cdrom&bslash;n&quot;
comma
id|CURRENT-&gt;cmd
)paren
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|error
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CURRENT-&gt;nr_sectors
suffix:semicolon
id|i
op_increment
)paren
(brace
id|cd_sec_no
op_assign
(paren
id|CURRENT-&gt;sector
op_plus
id|i
)paren
op_div
l_int|4
suffix:semicolon
multiline_comment|/* 4 times 512 bytes */
id|quarter
op_assign
(paren
id|CURRENT-&gt;sector
op_plus
id|i
)paren
op_mod
l_int|4
suffix:semicolon
id|dest
op_assign
id|CURRENT-&gt;buffer
op_plus
id|i
op_star
l_int|512
suffix:semicolon
multiline_comment|/* is already in buffer memory? */
r_if
c_cond
(paren
id|cd-&gt;sector_first
op_le
id|cd_sec_no
op_logical_and
id|cd_sec_no
OL
id|cd-&gt;sector_last
)paren
(brace
id|source
op_assign
(paren
(paren
id|uch
op_star
)paren
id|cd-&gt;sector
)paren
op_plus
l_int|16
op_plus
id|quarter
op_star
l_int|512
op_plus
(paren
id|cd_sec_no
op_minus
id|cd-&gt;sector_first
)paren
op_star
id|RAW_SECTOR_SIZE
suffix:semicolon
id|memcpy
c_func
(paren
id|dest
comma
id|source
comma
l_int|512
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|try_adapter
c_func
(paren
id|cd_sec_no
)paren
op_logical_or
op_logical_neg
id|read_sector
c_func
(paren
id|cd_sec_no
)paren
)paren
(brace
id|source
op_assign
(paren
(paren
id|uch
op_star
)paren
id|cd-&gt;sector
)paren
op_plus
l_int|16
op_plus
id|quarter
op_star
l_int|512
suffix:semicolon
id|memcpy
c_func
(paren
id|dest
comma
id|source
comma
l_int|512
)paren
suffix:semicolon
)brace
r_else
(brace
id|error
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|end_request
c_func
(paren
op_logical_neg
id|error
)paren
suffix:semicolon
)brace
)brace
DECL|function|get_multi_session_info
r_int
id|get_multi_session_info
c_func
(paren
r_struct
id|cdrom_multisession
op_star
id|mssp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|FIRST_TRACK
)paren
id|get_disc_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mssp
)paren
(brace
r_if
c_cond
(paren
id|DISC_STATUS
op_amp
id|cds_multi_session
)paren
(brace
multiline_comment|/* multi-session */
r_if
c_cond
(paren
id|mssp-&gt;addr_format
op_eq
id|CDROM_LBA
)paren
id|mssp-&gt;addr.lba
op_assign
id|fsm2lba
c_func
(paren
op_amp
id|cd-&gt;disc_status
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_else
(brace
id|mssp-&gt;addr.msf.frame
op_assign
id|cd-&gt;disc_status
(braket
l_int|3
)braket
suffix:semicolon
id|mssp-&gt;addr.msf.second
op_assign
id|cd-&gt;disc_status
(braket
l_int|4
)braket
suffix:semicolon
id|mssp-&gt;addr.msf.minute
op_assign
id|cd-&gt;disc_status
(braket
l_int|5
)braket
suffix:semicolon
)brace
id|mssp-&gt;xa_flag
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|mssp-&gt;xa_flag
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Audio support. I&squot;ve tried very hard, but the cm206 drive doesn&squot;t &n;   seem to have a get_toc (table-of-contents) function, while i&squot;m&n;   pretty sure it must read the toc upon disc insertion. Therefore&n;   this function has been implemented through a binary search &n;   strategy. All track starts that happen to be found are stored in&n;   cd-&gt;toc[], for future use. &n;&n;   I&squot;ve spent a whole day on a bug that only shows under Workman---&n;   I don&squot;t get it. Tried everything, nothing works. If workman asks&n;   for track# 0xaa, it&squot;ll get the wrong time back. Any other program&n;   receives the correct value. I&squot;m stymied.&n;*/
multiline_comment|/* seek seeks to address lba. It does wait to arrive there. */
DECL|function|seek
r_void
id|seek
c_func
(paren
r_int
id|lba
)paren
(brace
r_int
id|i
suffix:semicolon
id|uch
id|seek_command
(braket
l_int|4
)braket
op_assign
initialization_block
suffix:semicolon
id|fsm
c_func
(paren
id|lba
comma
op_amp
id|seek_command
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
id|type_0_command
c_func
(paren
id|seek_command
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
id|cd-&gt;dsb
op_assign
id|wait_dsb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|bcdbin
id|uch
id|bcdbin
c_func
(paren
r_int
r_char
id|bcd
)paren
multiline_comment|/* stolen from mcd.c! */
(brace
r_return
(paren
id|bcd
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|bcd
op_amp
l_int|0xf
)paren
suffix:semicolon
)brace
DECL|function|normalize_track
r_inline
id|uch
id|normalize_track
c_func
(paren
id|uch
id|track
)paren
(brace
r_if
c_cond
(paren
id|track
OL
l_int|1
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|track
OG
id|LAST_TRACK
)paren
r_return
id|LAST_TRACK
op_plus
l_int|1
suffix:semicolon
r_return
id|track
suffix:semicolon
)brace
multiline_comment|/* This function does a binary search for track start. It records all&n; * tracks seen in the process. Input $track$ must be between 1 and&n; * #-of-tracks+1 */
DECL|function|get_toc_lba
r_int
id|get_toc_lba
c_func
(paren
id|uch
id|track
)paren
(brace
r_int
id|max
op_assign
l_int|74
op_star
l_int|60
op_star
l_int|75
op_minus
l_int|150
comma
id|min
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|lba
comma
id|l
comma
id|old_lba
op_assign
l_int|0
suffix:semicolon
id|uch
op_star
id|q
op_assign
id|cd-&gt;q
suffix:semicolon
id|uch
id|ct
suffix:semicolon
multiline_comment|/* current track */
r_int
id|binary
op_assign
l_int|0
suffix:semicolon
r_const
id|skip
op_assign
l_int|3
op_star
l_int|60
op_star
l_int|75
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|track
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
r_if
c_cond
(paren
id|cd-&gt;toc
(braket
id|i
)braket
dot
id|track
)paren
(brace
id|min
op_assign
id|fsm2lba
c_func
(paren
id|cd-&gt;toc
(braket
id|i
)braket
dot
id|fsm
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|lba
op_assign
id|min
op_plus
id|skip
suffix:semicolon
multiline_comment|/* 3 minutes */
r_do
(brace
id|seek
c_func
(paren
id|lba
)paren
suffix:semicolon
id|type_1_command
c_func
(paren
id|c_read_current_q
comma
l_int|10
comma
id|q
)paren
suffix:semicolon
id|ct
op_assign
id|normalize_track
c_func
(paren
id|q
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cd-&gt;toc
(braket
id|ct
)braket
dot
id|track
)paren
(brace
id|l
op_assign
id|q
(braket
l_int|9
)braket
op_minus
id|bcdbin
c_func
(paren
id|q
(braket
l_int|5
)braket
)paren
op_plus
l_int|75
op_star
(paren
id|q
(braket
l_int|8
)braket
op_minus
id|bcdbin
c_func
(paren
id|q
(braket
l_int|4
)braket
)paren
op_minus
l_int|2
op_plus
l_int|60
op_star
(paren
id|q
(braket
l_int|7
)braket
op_minus
id|bcdbin
c_func
(paren
id|q
(braket
l_int|3
)braket
)paren
)paren
)paren
suffix:semicolon
id|cd-&gt;toc
(braket
id|ct
)braket
dot
id|track
op_assign
id|q
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* lead out still 0xaa */
id|fsm
c_func
(paren
id|l
comma
id|cd-&gt;toc
(braket
id|ct
)braket
dot
id|fsm
)paren
suffix:semicolon
id|cd-&gt;toc
(braket
id|ct
)braket
dot
id|q0
op_assign
id|q
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* contains adr and ctrl info */
multiline_comment|/*&n;      if (ct==LAST_TRACK+1) &n;&t;printk(&quot;Leadout %x %x %x %x %d %d %d &bslash;n&quot;, q[1], q[3], q[4], q[5],&n;&t;       q[7], q[8], q[9]);&n;*/
r_if
c_cond
(paren
id|ct
op_eq
id|track
)paren
r_return
id|l
suffix:semicolon
)brace
id|old_lba
op_assign
id|lba
suffix:semicolon
r_if
c_cond
(paren
id|binary
)paren
(brace
r_if
c_cond
(paren
id|ct
OL
id|track
)paren
id|min
op_assign
id|lba
suffix:semicolon
r_else
id|max
op_assign
id|lba
suffix:semicolon
id|lba
op_assign
(paren
id|min
op_plus
id|max
)paren
op_div
l_int|2
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ct
OL
id|track
)paren
(brace
id|lba
op_add_assign
id|skip
suffix:semicolon
)brace
r_else
(brace
id|binary
op_assign
l_int|1
suffix:semicolon
id|max
op_assign
id|lba
suffix:semicolon
id|min
op_assign
id|lba
op_minus
id|skip
suffix:semicolon
id|lba
op_assign
(paren
id|min
op_plus
id|max
)paren
op_div
l_int|2
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|lba
op_ne
id|old_lba
)paren
suffix:semicolon
r_return
id|lba
suffix:semicolon
)brace
DECL|function|update_toc_entry
r_void
id|update_toc_entry
c_func
(paren
id|uch
id|track
)paren
(brace
id|track
op_assign
id|normalize_track
c_func
(paren
id|track
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cd-&gt;toc
(braket
id|track
)braket
dot
id|track
)paren
id|get_toc_lba
c_func
(paren
id|track
)paren
suffix:semicolon
)brace
DECL|function|read_toc_header
r_int
id|read_toc_header
c_func
(paren
r_struct
id|cdrom_tochdr
op_star
id|hp
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|FIRST_TRACK
)paren
id|get_disc_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hp
op_logical_and
id|DISC_STATUS
op_amp
id|cds_all_audio
)paren
(brace
multiline_comment|/* all audio */
r_int
id|i
suffix:semicolon
id|hp-&gt;cdth_trk0
op_assign
id|FIRST_TRACK
suffix:semicolon
id|hp-&gt;cdth_trk1
op_assign
id|LAST_TRACK
suffix:semicolon
id|cd-&gt;toc
(braket
l_int|1
)braket
dot
id|track
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* fill in first track position */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|cd-&gt;toc
(braket
l_int|1
)braket
dot
id|fsm
(braket
id|i
)braket
op_assign
id|cd-&gt;disc_status
(braket
l_int|3
op_plus
id|i
)braket
suffix:semicolon
id|update_toc_entry
c_func
(paren
id|LAST_TRACK
op_plus
l_int|1
)paren
suffix:semicolon
multiline_comment|/* find most entries */
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|play_from_to_msf
r_void
id|play_from_to_msf
c_func
(paren
r_struct
id|cdrom_msf
op_star
id|msfp
)paren
(brace
id|uch
id|play_command
(braket
)braket
op_assign
(brace
id|c_play
comma
id|msfp-&gt;cdmsf_frame0
comma
id|msfp-&gt;cdmsf_sec0
comma
id|msfp-&gt;cdmsf_min0
comma
id|msfp-&gt;cdmsf_frame1
comma
id|msfp-&gt;cdmsf_sec1
comma
id|msfp-&gt;cdmsf_min1
comma
l_int|2
comma
l_int|2
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|9
suffix:semicolon
id|i
op_increment
)paren
id|type_0_command
c_func
(paren
id|play_command
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
id|PLAY_TO.fsm
(braket
id|i
)braket
op_assign
id|play_command
(braket
id|i
op_plus
l_int|4
)braket
suffix:semicolon
id|PLAY_TO.track
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* say no track end */
id|cd-&gt;dsb
op_assign
id|wait_dsb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|play_from_to_track
r_void
id|play_from_to_track
c_func
(paren
r_int
id|from
comma
r_int
id|to
)paren
(brace
id|uch
id|play_command
(braket
l_int|8
)braket
op_assign
(brace
id|c_play
comma
)brace
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|from
op_eq
l_int|0
)paren
(brace
multiline_comment|/* continue paused play */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|play_command
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|cd-&gt;audio_status
(braket
id|i
op_plus
l_int|2
)braket
suffix:semicolon
id|play_command
(braket
id|i
op_plus
l_int|4
)braket
op_assign
id|PLAY_TO.fsm
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
r_else
(brace
id|update_toc_entry
c_func
(paren
id|from
)paren
suffix:semicolon
id|update_toc_entry
c_func
(paren
id|to
op_plus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|3
suffix:semicolon
id|i
op_increment
)paren
(brace
id|play_command
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|cd-&gt;toc
(braket
id|from
)braket
dot
id|fsm
(braket
id|i
)braket
suffix:semicolon
id|PLAY_TO.fsm
(braket
id|i
)braket
op_assign
id|play_command
(braket
id|i
op_plus
l_int|4
)braket
op_assign
id|cd-&gt;toc
(braket
id|to
op_plus
l_int|1
)braket
dot
id|fsm
(braket
id|i
)braket
suffix:semicolon
)brace
id|PLAY_TO.track
op_assign
id|to
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
id|type_0_command
c_func
(paren
id|play_command
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
id|type_0_command
c_func
(paren
l_int|0x2
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* volume */
id|cd-&gt;dsb
op_assign
id|wait_dsb
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|get_current_q
r_int
id|get_current_q
c_func
(paren
r_struct
id|cdrom_subchnl
op_star
id|qp
)paren
(brace
r_int
id|i
suffix:semicolon
id|uch
op_star
id|q
op_assign
id|cd-&gt;q
suffix:semicolon
r_if
c_cond
(paren
id|type_1_command
c_func
(paren
id|c_read_current_q
comma
l_int|10
comma
id|q
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/*  q[0] = bcdbin(q[0]); Don&squot;t think so! */
r_for
c_loop
(paren
id|i
op_assign
l_int|2
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
id|q
(braket
id|i
)braket
op_assign
id|bcdbin
c_func
(paren
id|q
(braket
id|i
)braket
)paren
suffix:semicolon
id|qp-&gt;cdsc_adr
op_assign
id|q
(braket
l_int|0
)braket
op_amp
l_int|0xf
suffix:semicolon
id|qp-&gt;cdsc_ctrl
op_assign
id|q
(braket
l_int|0
)braket
op_rshift
l_int|4
suffix:semicolon
multiline_comment|/* from mcd.c */
id|qp-&gt;cdsc_trk
op_assign
id|q
(braket
l_int|1
)braket
suffix:semicolon
id|qp-&gt;cdsc_ind
op_assign
id|q
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|qp-&gt;cdsc_format
op_eq
id|CDROM_MSF
)paren
(brace
id|qp-&gt;cdsc_reladdr.msf.minute
op_assign
id|q
(braket
l_int|3
)braket
suffix:semicolon
id|qp-&gt;cdsc_reladdr.msf.second
op_assign
id|q
(braket
l_int|4
)braket
suffix:semicolon
id|qp-&gt;cdsc_reladdr.msf.frame
op_assign
id|q
(braket
l_int|5
)braket
suffix:semicolon
id|qp-&gt;cdsc_absaddr.msf.minute
op_assign
id|q
(braket
l_int|7
)braket
suffix:semicolon
id|qp-&gt;cdsc_absaddr.msf.second
op_assign
id|q
(braket
l_int|8
)braket
suffix:semicolon
id|qp-&gt;cdsc_absaddr.msf.frame
op_assign
id|q
(braket
l_int|9
)braket
suffix:semicolon
)brace
r_else
(brace
id|qp-&gt;cdsc_reladdr.lba
op_assign
id|f_s_m2lba
c_func
(paren
id|q
(braket
l_int|5
)braket
comma
id|q
(braket
l_int|4
)braket
comma
id|q
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|qp-&gt;cdsc_absaddr.lba
op_assign
id|f_s_m2lba
c_func
(paren
id|q
(braket
l_int|9
)braket
comma
id|q
(braket
l_int|8
)braket
comma
id|q
(braket
l_int|7
)braket
)paren
suffix:semicolon
)brace
id|get_drive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;dsb
op_amp
id|dsb_play_in_progress
)paren
id|qp-&gt;cdsc_audiostatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|PAUSED
)paren
id|qp-&gt;cdsc_audiostatus
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
r_else
id|qp-&gt;cdsc_audiostatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|get_toc_entry
r_void
id|get_toc_entry
c_func
(paren
r_struct
id|cdrom_tocentry
op_star
id|ep
)paren
(brace
id|uch
id|track
op_assign
id|normalize_track
c_func
(paren
id|ep-&gt;cdte_track
)paren
suffix:semicolon
id|update_toc_entry
c_func
(paren
id|track
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ep-&gt;cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
id|ep-&gt;cdte_addr.msf.frame
op_assign
id|cd-&gt;toc
(braket
id|track
)braket
dot
id|fsm
(braket
l_int|0
)braket
suffix:semicolon
id|ep-&gt;cdte_addr.msf.second
op_assign
id|cd-&gt;toc
(braket
id|track
)braket
dot
id|fsm
(braket
l_int|1
)braket
suffix:semicolon
id|ep-&gt;cdte_addr.msf.minute
op_assign
id|cd-&gt;toc
(braket
id|track
)braket
dot
id|fsm
(braket
l_int|2
)braket
suffix:semicolon
)brace
r_else
id|ep-&gt;cdte_addr.lba
op_assign
id|fsm2lba
c_func
(paren
id|cd-&gt;toc
(braket
id|track
)braket
dot
id|fsm
)paren
suffix:semicolon
id|ep-&gt;cdte_adr
op_assign
id|cd-&gt;toc
(braket
id|track
)braket
dot
id|q0
op_amp
l_int|0xf
suffix:semicolon
id|ep-&gt;cdte_ctrl
op_assign
id|cd-&gt;toc
(braket
id|track
)braket
dot
id|q0
op_rshift
l_int|4
suffix:semicolon
id|ep-&gt;cdte_datamode
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Ioctl. I have made the statistics accessible through an ioctl&n;   call. The constant is defined in cm206.h, it shouldn&squot;t clash with&n;   the standard Linux ioctls. Multisession info is gathered at&n;   run-time, this may turn out to be slow. */
DECL|function|cm206_ioctl
r_static
r_int
id|cm206_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
macro_line|#ifdef STATISTICS
r_case
id|CM206CTL_GET_STAT
suffix:colon
r_if
c_cond
(paren
id|arg
op_ge
id|NR_STATS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
r_return
id|cd-&gt;stats
(braket
id|arg
)braket
suffix:semicolon
r_case
id|CM206CTL_GET_LAST_STAT
suffix:colon
r_if
c_cond
(paren
id|arg
op_ge
id|NR_STATS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
r_return
id|cd-&gt;last_stat
(braket
id|arg
)braket
suffix:semicolon
macro_line|#endif    
r_case
id|CDROMMULTISESSION
suffix:colon
(brace
r_struct
id|cdrom_multisession
id|ms_info
suffix:semicolon
r_int
id|st
suffix:semicolon
id|stats
c_func
(paren
id|ioctl_multisession
)paren
suffix:semicolon
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
(paren
id|st
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|ms_info
comma
(paren
r_struct
id|cdrom_multisession
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
suffix:semicolon
id|get_multi_session_info
c_func
(paren
op_amp
id|ms_info
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_struct
id|cdrom_multisession
op_star
)paren
id|arg
comma
op_amp
id|ms_info
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMRESET
suffix:colon
multiline_comment|/* If needed, it&squot;s probably too late anyway */
id|stop_read
c_func
(paren
)paren
suffix:semicolon
id|reset_cm260
c_func
(paren
)paren
suffix:semicolon
id|outw
c_func
(paren
id|dc_normal
op_or
id|dc_break
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* 750 musec minimum */
id|outw
c_func
(paren
id|dc_normal
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
id|cd-&gt;sector_last
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* flag no data buffered */
id|cd-&gt;adapter_last
op_assign
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|get_drive_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;dsb
op_amp
(paren
id|dsb_drive_not_ready
op_or
id|dsb_tray_not_closed
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMREADTOCHDR
suffix:colon
(brace
r_struct
id|cdrom_tochdr
id|header
suffix:semicolon
r_int
id|st
suffix:semicolon
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|header
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
(paren
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_toc_header
c_func
(paren
op_amp
id|header
)paren
)paren
(brace
id|memcpy_tofs
c_func
(paren
(paren
r_struct
id|cdrom_tochdr
op_star
)paren
id|arg
comma
op_amp
id|header
comma
r_sizeof
(paren
id|header
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|ENODATA
suffix:semicolon
)brace
r_case
id|CDROMREADTOCENTRY
suffix:colon
(brace
r_struct
id|cdrom_tocentry
id|entry
suffix:semicolon
r_int
id|st
suffix:semicolon
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
(paren
id|st
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|entry
comma
(paren
r_struct
id|cdrom_tocentry
op_star
)paren
id|arg
comma
r_sizeof
id|entry
)paren
suffix:semicolon
id|get_toc_entry
c_func
(paren
op_amp
id|entry
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_struct
id|cdrom_tocentry
op_star
)paren
id|arg
comma
op_amp
id|entry
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMPLAYMSF
suffix:colon
(brace
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_int
id|st
suffix:semicolon
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|msf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
(paren
id|st
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|msf
comma
(paren
r_struct
id|cdrom_mdf
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
id|play_from_to_msf
c_func
(paren
op_amp
id|msf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMPLAYTRKIND
suffix:colon
(brace
r_struct
id|cdrom_ti
id|track_index
suffix:semicolon
r_int
id|st
suffix:semicolon
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|track_index
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
(paren
id|st
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|track_index
comma
(paren
r_struct
id|cdrom_ti
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|track_index
)paren
)paren
suffix:semicolon
id|play_from_to_track
c_func
(paren
id|track_index.cdti_trk0
comma
id|track_index.cdti_trk1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMSTOP
suffix:colon
id|PAUSED
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;dsb
op_amp
id|dsb_play_in_progress
)paren
r_return
id|type_0_command
c_func
(paren
id|c_stop
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMPAUSE
suffix:colon
r_if
c_cond
(paren
id|cd-&gt;dsb
op_amp
id|dsb_play_in_progress
)paren
(brace
id|type_0_command
c_func
(paren
id|c_stop
comma
l_int|1
)paren
suffix:semicolon
id|type_1_command
c_func
(paren
id|c_audio_status
comma
l_int|5
comma
id|cd-&gt;audio_status
)paren
suffix:semicolon
id|PAUSED
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* say we&squot;re paused */
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
r_if
c_cond
(paren
id|PAUSED
)paren
id|play_from_to_track
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|PAUSED
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMEJECT
suffix:colon
id|PAUSED
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cd-&gt;openfiles
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Must do an open before an eject! */
id|type_0_command
c_func
(paren
id|c_open_tray
comma
l_int|1
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cd-&gt;toc
comma
l_int|0
comma
r_sizeof
(paren
id|cd-&gt;toc
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cd-&gt;disc_status
comma
l_int|0
comma
r_sizeof
(paren
id|cd-&gt;disc_status
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EBUSY
suffix:semicolon
r_case
id|CDROMSTART
suffix:colon
r_case
id|CDROMVOLCTRL
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMSUBCHNL
suffix:colon
(brace
r_struct
id|cdrom_subchnl
id|q
suffix:semicolon
r_int
id|st
suffix:semicolon
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|q
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
(paren
id|st
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|q
comma
(paren
r_struct
id|cdrom_subchnl
op_star
)paren
id|arg
comma
r_sizeof
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_current_q
c_func
(paren
op_amp
id|q
)paren
)paren
(brace
id|memcpy_tofs
c_func
(paren
(paren
r_struct
id|cdrom_subchnl
op_star
)paren
id|arg
comma
op_amp
id|q
comma
r_sizeof
id|q
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|cmd
suffix:semicolon
)brace
r_case
id|CDROM_GET_UPC
suffix:colon
(brace
id|uch
id|upc
(braket
l_int|10
)braket
suffix:semicolon
r_int
id|st
suffix:semicolon
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
(paren
id|st
)paren
suffix:semicolon
r_if
c_cond
(paren
id|type_1_command
c_func
(paren
id|c_read_upc
comma
l_int|10
comma
id|upc
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
id|uch
op_star
)paren
id|arg
comma
op_amp
id|upc
(braket
l_int|1
)braket
comma
l_int|8
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
id|debug
c_func
(paren
(paren
l_string|&quot;Unknown ioctl call 0x%x&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/* from lmscd.c */
DECL|variable|cm206_fops
r_static
r_struct
id|file_operations
id|cm206_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir */
l_int|NULL
comma
multiline_comment|/* select */
id|cm206_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|cm206_open
comma
multiline_comment|/* open */
id|cm206_release
comma
multiline_comment|/* release */
l_int|NULL
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
l_int|NULL
comma
multiline_comment|/* media_change */
l_int|NULL
multiline_comment|/* revalidate */
)brace
suffix:semicolon
multiline_comment|/* This routine gets called during init if thing go wrong, can be used&n; * in cleanup_module as well. */
DECL|function|cleanup
r_void
id|cleanup
c_func
(paren
r_int
id|level
)paren
(brace
r_switch
c_cond
(paren
id|level
)paren
(brace
r_case
l_int|4
suffix:colon
r_if
c_cond
(paren
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;cm206&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Can&squot;t unregister cm206&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_case
l_int|3
suffix:colon
id|free_irq
c_func
(paren
id|cm206_irq
)paren
suffix:semicolon
r_case
l_int|2
suffix:colon
r_case
l_int|1
suffix:colon
macro_line|#ifdef MODULE
id|kfree
c_func
(paren
id|cd
)paren
suffix:semicolon
macro_line|#endif
id|release_region
c_func
(paren
id|cm206_base
comma
l_int|16
)paren
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
)brace
multiline_comment|/* This function probes for the adapter card. It returns the base&n;   address if it has found the adapter card. One can specify a base &n;   port to probe specifically, or 0 which means span all possible&n;   bases. &n;&n;   Linus says it is too dangerous to use writes for probing, so we&n;   stick with pure reads for a while. Hope that 8 possible ranges,&n;   check_region, 15 bits of one port and 6 of another make things&n;   likely enough to accept the region on the first hit...&n; */
DECL|function|probe_base_port
r_int
id|probe_base_port
c_func
(paren
r_int
id|base
)paren
(brace
r_int
id|b
op_assign
l_int|0x300
comma
id|e
op_assign
l_int|0x370
suffix:semicolon
multiline_comment|/* this is the range of start addresses */
r_volatile
r_int
id|fool
suffix:semicolon
macro_line|#if 0
r_const
id|pattern1
op_assign
l_int|0x65
comma
id|pattern2
op_assign
l_int|0x1a
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|base
)paren
id|b
op_assign
id|e
op_assign
id|base
suffix:semicolon
r_for
c_loop
(paren
id|base
op_assign
id|b
suffix:semicolon
id|base
op_le
id|e
suffix:semicolon
id|base
op_add_assign
l_int|0x10
)paren
(brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|base
comma
l_int|0x10
)paren
)paren
r_continue
suffix:semicolon
id|fool
op_assign
id|inw
c_func
(paren
id|base
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* empty possibly uart_receive_buffer */
r_if
c_cond
(paren
(paren
id|inw
c_func
(paren
id|base
op_plus
l_int|6
)paren
op_amp
l_int|0xffef
)paren
op_ne
l_int|0x0001
op_logical_or
multiline_comment|/* line_status */
(paren
id|inw
c_func
(paren
id|base
)paren
op_amp
l_int|0xad00
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* data status */
r_continue
suffix:semicolon
)brace
macro_line|#if 0&t;&t;&t;&t;/* writes... dangerous... */
id|outw
c_func
(paren
id|dc_normal
op_or
id|pattern1
comma
id|base
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inw
c_func
(paren
id|base
)paren
op_amp
l_int|0x7f
)paren
op_ne
id|pattern1
)paren
r_continue
suffix:semicolon
id|outw
c_func
(paren
id|dc_normal
op_or
id|pattern2
comma
id|base
op_plus
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inw
c_func
(paren
id|base
)paren
op_amp
l_int|0x7f
)paren
op_ne
id|pattern2
)paren
r_continue
suffix:semicolon
id|outw
c_func
(paren
id|dc_normal
op_or
id|READ_AHEAD
comma
id|base
op_plus
l_int|8
)paren
suffix:semicolon
macro_line|#endif
r_return
id|base
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if !defined(MODULE) || defined(AUTO_PROBE_MODULE)
multiline_comment|/* Probe for irq# nr. If nr==0, probe for all possible irq&squot;s. */
DECL|function|probe_irq
r_int
id|probe_irq
c_func
(paren
r_int
id|nr
)paren
(brace
r_int
id|irqs
comma
id|irq
suffix:semicolon
id|outw
c_func
(paren
id|dc_normal
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
multiline_comment|/* disable irq-generation */
id|sti
c_func
(paren
)paren
suffix:semicolon
id|irqs
op_assign
id|probe_irq_on
c_func
(paren
)paren
suffix:semicolon
id|reset_cm260
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* causes interrupt */
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* wait for it */
id|irq
op_assign
id|probe_irq_off
c_func
(paren
id|irqs
)paren
suffix:semicolon
id|outw
c_func
(paren
id|dc_normal
op_or
id|READ_AHEAD
comma
id|r_data_control
)paren
suffix:semicolon
multiline_comment|/* services interrupt */
r_if
c_cond
(paren
id|nr
op_logical_and
id|irq
op_ne
id|nr
op_logical_and
id|irq
OG
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* wrong interrupt happened */
r_else
r_return
id|irq
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef MODULE
DECL|macro|OK
mdefine_line|#define OK  0
DECL|macro|ERROR
mdefine_line|#define ERROR  -EIO
DECL|variable|cm206
r_static
r_int
id|cm206
(braket
l_int|2
)braket
op_assign
(brace
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* for compatible `insmod&squot; parameter passing */
DECL|function|parse_options
r_void
id|parse_options
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
l_int|0x300
op_le
id|cm206
(braket
id|i
)braket
op_logical_and
id|i
op_le
l_int|0x370
op_logical_and
id|cm206
(braket
id|i
)braket
op_mod
l_int|0x10
op_eq
l_int|0
)paren
(brace
id|cm206_base
op_assign
id|cm206
(braket
id|i
)braket
suffix:semicolon
id|auto_probe
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
l_int|3
op_le
id|cm206
(braket
id|i
)braket
op_logical_and
id|cm206
(braket
id|i
)braket
op_le
l_int|15
)paren
(brace
id|cm206_irq
op_assign
id|cm206
(braket
id|i
)braket
suffix:semicolon
id|auto_probe
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
macro_line|#else MODULE
DECL|macro|OK
mdefine_line|#define OK  mem_start+size
DECL|macro|ERROR
mdefine_line|#define ERROR  mem_start
macro_line|#endif MODULE
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
macro_line|#else 
r_int
r_int
id|cm206_init
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
macro_line|#endif
(brace
id|uch
id|e
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|size
op_assign
r_sizeof
(paren
r_struct
id|cm206_struct
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cm206: v&quot;
id|VERSION
)paren
suffix:semicolon
macro_line|#if defined(MODULE) 
id|parse_options
c_func
(paren
)paren
suffix:semicolon
macro_line|#if !defined(AUTO_PROBE_MODULE)
id|auto_probe
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
macro_line|#endif
id|cm206_base
op_assign
id|probe_base_port
c_func
(paren
id|auto_probe
ques
c_cond
l_int|0
suffix:colon
id|cm206_base
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cm206_base
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; can&squot;t find adapter!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ERROR
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot; adapter at 0x%x&quot;
comma
id|cm206_base
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|cm206_base
comma
l_int|16
comma
l_string|&quot;cm206&quot;
)paren
suffix:semicolon
macro_line|#ifdef MODULE
id|cd
op_assign
(paren
r_struct
id|cm206_struct
op_star
)paren
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cd
)paren
r_return
id|ERROR
suffix:semicolon
macro_line|#else 
id|cd
op_assign
(paren
r_struct
id|cm206_struct
op_star
)paren
id|mem_start
suffix:semicolon
macro_line|#endif
multiline_comment|/* Now we have found the adaptor card, try to reset it. As we have&n;   * found out earlier, this process generates an interrupt as well,&n;   * so we might just exploit that fact for irq probing! */
macro_line|#if !defined(MODULE) || defined(AUTO_PROBE_MODULE)
id|cm206_irq
op_assign
id|probe_irq
c_func
(paren
id|auto_probe
ques
c_cond
l_int|0
suffix:colon
id|cm206_irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cm206_irq
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;can&squot;t find IRQ!&bslash;n&quot;
)paren
suffix:semicolon
id|cleanup
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
id|ERROR
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot; IRQ %d found&bslash;n&quot;
comma
id|cm206_irq
)paren
suffix:semicolon
macro_line|#else
id|reset_cm260
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; using IRQ %d&bslash;n&quot;
comma
id|cm206_irq
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|send_receive_polled
c_func
(paren
id|c_drive_configuration
)paren
op_ne
id|c_drive_configuration
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; drive not there&bslash;n&quot;
)paren
suffix:semicolon
id|cleanup
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
id|ERROR
suffix:semicolon
)brace
id|e
op_assign
id|send_receive_polled
c_func
(paren
id|c_gimme
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Firmware revision %d&quot;
comma
id|e
op_amp
id|dcf_revision_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
op_amp
id|dcf_transfer_rate
)paren
id|printk
c_func
(paren
l_string|&quot; double&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot; single&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; speed drive&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e
op_amp
id|dcf_motorized_tray
)paren
id|printk
c_func
(paren
l_string|&quot;, motorized tray&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|cm206_irq
comma
id|cm206_interrupt
comma
l_int|0
comma
l_string|&quot;cm206&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;nUnable to reserve IRQ---aborted&bslash;n&quot;
)paren
suffix:semicolon
id|cleanup
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_return
id|ERROR
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;.&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;cm206&quot;
comma
op_amp
id|cm206_fops
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cannot register for major %d!&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
id|cleanup
c_func
(paren
l_int|3
)paren
suffix:semicolon
r_return
id|ERROR
suffix:semicolon
)brace
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* reads ahead what? */
id|bh_base
(braket
id|CM206_BH
)braket
dot
id|routine
op_assign
id|cm206_bh
suffix:semicolon
id|enable_bh
c_func
(paren
id|CM206_BH
)paren
suffix:semicolon
id|memset
c_func
(paren
id|cd
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|cd
)paren
)paren
suffix:semicolon
multiline_comment|/* give&squot;m some reasonable value */
id|cd-&gt;sector_last
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* flag no data buffered */
id|cd-&gt;adapter_last
op_assign
op_minus
l_int|1
suffix:semicolon
id|cd-&gt;timer.function
op_assign
id|cm206_timeout
suffix:semicolon
id|cd-&gt;max_sectors
op_assign
(paren
id|inw
c_func
(paren
id|r_data_status
)paren
op_amp
id|ds_ram_size
)paren
ques
c_cond
l_int|24
suffix:colon
l_int|97
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%d kB adapter memory available, &quot;
l_string|&quot; %ld bytes kernel memory used.&bslash;n&quot;
comma
id|cd-&gt;max_sectors
op_star
l_int|2
comma
id|size
)paren
suffix:semicolon
r_return
id|OK
suffix:semicolon
)brace
DECL|macro|OK
macro_line|#undef OK
DECL|macro|ERROR
macro_line|#undef ERROR
macro_line|#ifdef MODULE
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|cleanup
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cm206 removed&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#else MODULE
multiline_comment|/* This setup function accepts either `auto&squot; or numbers in the range&n; * 3--11 (for irq) or 0x300--0x370 (for base port) or both. */
DECL|function|cm206_setup
r_void
id|cm206_setup
c_func
(paren
r_char
op_star
id|s
comma
r_int
op_star
id|p
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|s
comma
l_string|&quot;auto&quot;
)paren
)paren
id|auto_probe
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|p
(braket
l_int|0
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
l_int|0x300
op_le
id|p
(braket
id|i
)braket
op_logical_and
id|i
op_le
l_int|0x370
op_logical_and
id|p
(braket
id|i
)braket
op_mod
l_int|0x10
op_eq
l_int|0
)paren
(brace
id|cm206_base
op_assign
id|p
(braket
id|i
)braket
suffix:semicolon
id|auto_probe
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
l_int|3
op_le
id|p
(braket
id|i
)braket
op_logical_and
id|p
(braket
id|i
)braket
op_le
l_int|15
)paren
(brace
id|cm206_irq
op_assign
id|p
(braket
id|i
)braket
suffix:semicolon
id|auto_probe
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif MODULE
eof
