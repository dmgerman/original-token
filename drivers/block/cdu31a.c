multiline_comment|/*&n; * Sony CDU-31A CDROM interface device driver.&n; *&n; * Corey Minyard (minyard@wf-rch.cirr.com)&n; *&n; * Colossians 3:17&n; *&n; * The Sony interface device driver handles Sony interface CDROM&n; * drives and provides a complete block-level interface as well as an&n; * ioctl() interface compatible with the Sun (as specified in&n; * include/linux/cdrom.h).  With this interface, CDROMs can be&n; * accessed and standard audio CDs can be played back normally.&n; *&n; * This interface is (unfortunatly) a polled interface.  This is&n; * because most Sony interfaces are set up with DMA and interrupts&n; * disables.  Some (like mine) do not even have the capability to&n; * handle interrupts or DMA.  For this reason you will see a lot of&n; * the following:&n; *&n; *   retry_count = jiffies+ SONY_JIFFIES_TIMEOUT;&n; *   while ((retry_count &gt; jiffies) &amp;&amp; (! &lt;some condition to wait for))&n; *   {&n; *      while (handle_sony_cd_attention())&n; *         ;&n; *&n; *      sony_sleep();&n; *   }&n; *   if (the condition not met)&n; *   {&n; *      return an error;&n; *   }&n; *&n; * This ugly hack waits for something to happen, sleeping a little&n; * between every try.  it also handles attentions, which are&n; * asyncronous events from the drive informing the driver that a disk&n; * has been inserted, removed, etc.&n; *&n; * NEWS FLASH - The driver now supports interrupts and DMA, but they are&n; * turned off by default.  Use of interrupts is highly encouraged, it&n; * cuts CPU usage down to a reasonable level.  For a single-speed drive,&n; * DMA is ok, but the 8-bit DMA cannot keep up with the double speed&n; * drives.&n; *&n; * One thing about these drives: They talk in MSF (Minute Second Frame) format.&n; * There are 75 frames a second, 60 seconds a minute, and up to 75 minutes on a&n; * disk.  The funny thing is that these are sent to the drive in BCD, but the&n; * interface wants to see them in decimal.  A lot of conversion goes on.&n; *&n; *  Copyright (C) 1993  Corey Minyard&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; */
multiline_comment|/*&n; *&n; * Setting up the Sony CDU31A/CDU33A drive interface card.  If&n; * You have another card, you are on your own.&n; * &n; *      +----------+-----------------+----------------------+&n; *      |  JP1     |  34 Pin Conn    |     &t;&t;    |&n; *      |  JP2     +-----------------+     &t;&t;    |&n; *      |  JP3     &t;        &t;&t;&t;    |&n; *      |  JP4     &t;        &t;&t;&t;    |&n; *      |&t;&t;&t;        &t;&t;    +--+&n; *      |&t;&t;&t;                            |  +-+&n; *      |&t;&t;&t;        &t;&t;    |  | |  External&n; *      |&t;&t;&t;        &t;&t;    |  | |  Connector&n; *      |&t;&t;&t;&t;&t;&t;    |  | |&n; *      |&t;&t;&t;&t;&t;&t;    |  +-+&n; *      |&t;&t;&t;&t;&t;&t;    +--+&n; *      |&t;&t;&t;&t;&t;&t;    |&n; *      |&t;&t;&t;&t;&t;   +--------+&n; *      |&t;&t;&t;&t;&t;   |&n; *      +------------------------------------------+&n; * &n; *    JP1 sets the Base Address, using the following settings:&n; * &n; * &t;Address&t;&t;Pin 1&t;&t;Pin 2&n; * &t;-------&t;&t;-----&t;&t;-----&n; * &t;0x320&t;&t;Short&t;&t;Short&n; * &t;0x330&t;&t;Short&t;&t;Open&n; * &t;0x340&t;&t;Open&t;&t;Short&n; * &t;0x360&t;&t;Open&t;&t;Open&n; * &n; *    JP2 and JP3 configure the DMA channel; they must be set the same.&n; * &n; * &t;DMA&t;&t;Pin 1&t;&t;Pin 2&t;&t;Pin 3&n; * &t;---&t;&t;-----&t;&t;-----&t;&t;-----&n; * &t;1&t;&t;On&t;&t;Off&t;&t;On&n; * &t;2&t;&t;Off&t;&t;On&t;&t;Off&n; * &t;3&t;&t;Off&t;&t;Off&t;&t;On&n; * &n; *    JP4 Configures the IRQ:&n; * &n; * &t;IRQ&t;Pin 1&t;&t;Pin 2&t;&t;Pin 3&t;&t;Pin 4&n; * &t;---&t;-----&t;&t;-----&t;&t;-----&t;&t;-----&n; * &t;3&t;Off&t;&t;Off&t;&t;On&t;&t;Off&n; * &t;4&t;Off&t;&t;Off*&t;&t;Off&t;&t;On&n; * &t;5&t;On&t;&t;Off&t;&t;Off&t;&t;Off&n; * &t;6&t;Off&t;&t;On&t;&t;Off&t;&t;Off&n; * &n; * &t;&t;* The documentation states to set this for interrupt&n; * &t;&t;  4, but I think that is a mistake.&n; */
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/cdu31a.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR CDU31A_CDROM_MAJOR
macro_line|#include &quot;blk.h&quot;
DECL|macro|CDU31A_MAX_CONSECUTIVE_ATTENTIONS
mdefine_line|#define CDU31A_MAX_CONSECUTIVE_ATTENTIONS 10
multiline_comment|/* Define the following if you have data corruption problems. */
DECL|macro|SONY_POLL_EACH_BYTE
macro_line|#undef SONY_POLL_EACH_BYTE
multiline_comment|/*&n;** Edit the following data to change interrupts, DMA channels, etc.&n;** Default is polled and no DMA.  DMA is not recommended for double-speed&n;** drives.&n;*/
r_static
r_struct
(brace
DECL|member|base
r_int
r_int
id|base
suffix:semicolon
multiline_comment|/* I/O Base Address */
DECL|member|dma_num
r_int
id|dma_num
suffix:semicolon
multiline_comment|/* DMA Number (-1 means no DMA) */
DECL|member|int_num
r_int
id|int_num
suffix:semicolon
multiline_comment|/* Interrupt Number (-1 means scan for it,&n;                                   0 means don&squot;t use) */
DECL|variable|cdu31a_addresses
)brace
id|cdu31a_addresses
(braket
)braket
op_assign
(brace
(brace
l_int|0x340
comma
op_minus
l_int|1
comma
l_int|0
)brace
comma
multiline_comment|/* Standard configuration Sony Interface */
(brace
l_int|0x1f88
comma
op_minus
l_int|1
comma
l_int|0
)brace
comma
multiline_comment|/* Fusion CD-16 */
(brace
l_int|0x230
comma
op_minus
l_int|1
comma
l_int|0
)brace
comma
multiline_comment|/* SoundBlaster 16 card */
(brace
l_int|0x360
comma
op_minus
l_int|1
comma
l_int|0
)brace
comma
multiline_comment|/* Secondary standard Sony Interface */
(brace
l_int|0x320
comma
op_minus
l_int|1
comma
l_int|0
)brace
comma
multiline_comment|/* Secondary standard Sony Interface */
(brace
l_int|0x330
comma
op_minus
l_int|1
comma
l_int|0
)brace
comma
multiline_comment|/* Secondary standard Sony Interface */
(brace
l_int|0x634
comma
op_minus
l_int|1
comma
l_int|0
)brace
comma
multiline_comment|/* Sound FX SC400 */
(brace
l_int|0x654
comma
op_minus
l_int|1
comma
l_int|0
)brace
comma
multiline_comment|/* Sound FX SC400 */
(brace
l_int|0
)brace
)brace
suffix:semicolon
r_static
r_int
id|handle_sony_cd_attention
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|read_subcode
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|sony_get_toc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|scd_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|do_sony_cd_cmd
c_func
(paren
r_int
r_char
id|cmd
comma
r_int
r_char
op_star
id|params
comma
r_int
r_int
id|num_params
comma
r_int
r_char
op_star
id|result_buffer
comma
r_int
r_int
op_star
id|result_size
)paren
suffix:semicolon
r_static
r_void
id|size_to_buf
c_func
(paren
r_int
r_int
id|size
comma
r_int
r_char
op_star
id|buf
)paren
suffix:semicolon
multiline_comment|/* The base I/O address of the Sony Interface.  This is a variable (not a&n;   #define) so it can be easily changed via some future ioctl() */
DECL|variable|sony_cd_base_io
r_static
r_int
r_int
id|sony_cd_base_io
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * The following are I/O addresses of the various registers for the drive.  The&n; * comment for the base address also applies here.&n; */
DECL|variable|sony_cd_cmd_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_cmd_reg
suffix:semicolon
DECL|variable|sony_cd_param_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_param_reg
suffix:semicolon
DECL|variable|sony_cd_write_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_write_reg
suffix:semicolon
DECL|variable|sony_cd_control_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_control_reg
suffix:semicolon
DECL|variable|sony_cd_status_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_status_reg
suffix:semicolon
DECL|variable|sony_cd_result_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_result_reg
suffix:semicolon
DECL|variable|sony_cd_read_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_read_reg
suffix:semicolon
DECL|variable|sony_cd_fifost_reg
r_static
r_volatile
r_int
r_int
id|sony_cd_fifost_reg
suffix:semicolon
DECL|variable|sony_disc_changed
r_static
r_int
id|sony_disc_changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Has the disk been changed&n;                                              since the last check? */
DECL|variable|sony_toc_read
r_static
r_int
id|sony_toc_read
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Has the table of contents been&n;                                              read? */
DECL|variable|sony_spun_up
r_static
r_int
id|sony_spun_up
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Has the drive been spun up? */
DECL|variable|sony_buffer_size
r_static
r_int
r_int
id|sony_buffer_size
suffix:semicolon
multiline_comment|/* Size in bytes of the read-ahead&n;                                              buffer. */
DECL|variable|sony_buffer_sectors
r_static
r_int
r_int
id|sony_buffer_sectors
suffix:semicolon
multiline_comment|/* Size (in 2048 byte records) of&n;                                              the read-ahead buffer. */
DECL|variable|sony_usage
r_static
r_int
r_int
id|sony_usage
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* How many processes have the&n;                                              drive open. */
DECL|variable|sony_first_block
r_static
r_volatile
r_int
id|sony_first_block
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* First OS block (512 byte) in&n;                                              the read-ahead buffer */
DECL|variable|sony_last_block
r_static
r_volatile
r_int
id|sony_last_block
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Last OS block (512 byte) in&n;                                              the read-ahead buffer */
DECL|variable|sony_toc
r_static
r_struct
id|s_sony_toc
op_star
id|sony_toc
suffix:semicolon
multiline_comment|/* Points to the table of&n;                                                    contents. */
DECL|variable|last_sony_subcode
r_static
r_struct
id|s_sony_subcode
op_star
r_volatile
id|last_sony_subcode
suffix:semicolon
multiline_comment|/* Points to the last&n;                                                    subcode address read */
DECL|variable|sony_buffer
r_static
r_int
r_char
op_star
r_volatile
id|sony_buffer
suffix:semicolon
multiline_comment|/* Points to the read-ahead&n;                                                    buffer */
DECL|variable|sony_inuse
r_static
r_volatile
r_int
id|sony_inuse
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is the drive in use?  Only one operation at a time&n;                                        allowed */
DECL|variable|sony_wait
r_static
r_struct
id|wait_queue
op_star
id|sony_wait
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|has_cd_task
r_static
r_struct
id|task_struct
op_star
id|has_cd_task
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* The task that is currently using the&n;                                                   CDROM drive, or NULL if none. */
DECL|variable|is_double_speed
r_static
r_int
id|is_double_speed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is the drive a CDU33A? */
multiline_comment|/*&n; * The audio status uses the values from read subchannel data as specified&n; * in include/linux/cdrom.h.&n; */
DECL|variable|sony_audio_status
r_static
r_volatile
r_int
id|sony_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
multiline_comment|/*&n; * The following are a hack for pausing and resuming audio play.  The drive&n; * does not work as I would expect it, if you stop it then start it again,&n; * the drive seeks back to the beginning and starts over.  This holds the&n; * position during a pause so a resume can restart it.  It uses the&n; * audio status variable above to tell if it is paused.&n; */
DECL|variable|cur_pos_msf
r_static
r_int
r_volatile
r_char
id|cur_pos_msf
(braket
l_int|3
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|final_pos_msf
r_static
r_int
r_volatile
r_char
id|final_pos_msf
(braket
l_int|3
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|irq_used
r_static
r_int
id|irq_used
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|dma_channel
r_static
r_int
id|dma_channel
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|cdu31a_irq_wait
r_static
r_struct
id|wait_queue
op_star
id|cdu31a_irq_wait
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|curr_control_reg
r_static
r_int
id|curr_control_reg
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Current value of the control register */
multiline_comment|/*&n; * This routine returns 1 if the disk has been changed since the last&n; * check or 0 if it hasn&squot;t.&n; */
r_static
r_int
DECL|function|scd_disk_change
id|scd_disk_change
c_func
(paren
id|dev_t
id|full_dev
)paren
(brace
r_int
id|retval
comma
id|target
suffix:semicolon
id|target
op_assign
id|MINOR
c_func
(paren
id|full_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CD-ROM request error: invalid device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|retval
op_assign
id|sony_disc_changed
suffix:semicolon
id|sony_disc_changed
op_assign
l_int|0
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|enable_interrupts
id|enable_interrupts
c_func
(paren
r_void
)paren
(brace
id|curr_control_reg
op_or_assign
(paren
id|SONY_ATTN_INT_EN_BIT
op_or
id|SONY_RES_RDY_INT_EN_BIT
op_or
id|SONY_DATA_RDY_INT_EN_BIT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|curr_control_reg
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|disable_interrupts
id|disable_interrupts
c_func
(paren
r_void
)paren
(brace
id|curr_control_reg
op_and_assign
op_complement
(paren
id|SONY_ATTN_INT_EN_BIT
op_or
id|SONY_RES_RDY_INT_EN_BIT
op_or
id|SONY_DATA_RDY_INT_EN_BIT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|curr_control_reg
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|cdu31a_interrupt
id|cdu31a_interrupt
c_func
(paren
r_int
id|unused
)paren
(brace
id|disable_interrupts
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|cdu31a_irq_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait a little while (used for polling the drive).  If in initialization,&n; * setting a timeout doesn&squot;t work, so just loop for a while.&n; */
r_static
r_inline
r_void
DECL|function|sony_sleep
id|sony_sleep
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|irq_used
op_le
l_int|0
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Interrupt driven */
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|enable_interrupts
c_func
(paren
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|cdu31a_irq_wait
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * The following are convenience routine to read various status and set&n; * various conditions in the drive.&n; */
r_static
r_inline
r_int
DECL|function|is_attention
id|is_attention
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_ATTN_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_busy
id|is_busy
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_BUSY_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_data_ready
id|is_data_ready
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_DATA_RDY_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_data_requested
id|is_data_requested
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_DATA_REQUEST_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_result_ready
id|is_result_ready
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
op_amp
id|SONY_RES_RDY_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_int
DECL|function|is_param_write_rdy
id|is_param_write_rdy
c_func
(paren
r_void
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|sony_cd_fifost_reg
)paren
op_amp
id|SONY_PARAM_WRITE_RDY_BIT
)paren
op_ne
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|reset_drive
id|reset_drive
c_func
(paren
r_void
)paren
(brace
id|curr_control_reg
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|SONY_DRIVE_RESET_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|clear_attention
id|clear_attention
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_ATTN_CLR_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|clear_result_ready
id|clear_result_ready
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_RES_RDY_CLR_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|clear_data_ready
id|clear_data_ready
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_DATA_RDY_CLR_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|clear_param_reg
id|clear_param_reg
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_PARAM_CLR_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_char
DECL|function|read_status_register
id|read_status_register
c_func
(paren
r_void
)paren
(brace
r_return
id|inb
c_func
(paren
id|sony_cd_status_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_char
DECL|function|read_result_register
id|read_result_register
c_func
(paren
r_void
)paren
(brace
r_return
id|inb
c_func
(paren
id|sony_cd_result_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_int
r_char
DECL|function|read_data_register
id|read_data_register
c_func
(paren
r_void
)paren
(brace
r_return
id|inb
c_func
(paren
id|sony_cd_read_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|write_param
id|write_param
c_func
(paren
r_int
r_char
id|param
)paren
(brace
id|outb
c_func
(paren
id|param
comma
id|sony_cd_param_reg
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|write_cmd
id|write_cmd
c_func
(paren
r_int
r_char
id|cmd
)paren
(brace
id|outb
c_func
(paren
id|curr_control_reg
op_or
id|SONY_RES_RDY_INT_EN_BIT
comma
id|sony_cd_control_reg
)paren
suffix:semicolon
id|outb
c_func
(paren
id|cmd
comma
id|sony_cd_cmd_reg
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set the drive parameters so the drive will auto-spin-up when a&n; * disk is inserted.&n; */
r_static
r_void
DECL|function|set_drive_params
id|set_drive_params
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
r_char
id|params
(braket
l_int|3
)braket
suffix:semicolon
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_MECH_CONTROL
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
l_int|0x03
suffix:semicolon
multiline_comment|/* Set auto spin up and auto eject */
r_if
c_cond
(paren
id|is_double_speed
)paren
(brace
id|params
(braket
l_int|1
)braket
op_or_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* Set the drive to double speed if possible */
)brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|2
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  Unable to set mechanical parameters: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This code will reset the drive and attempt to restore sane parameters.&n; */
r_static
r_void
DECL|function|restart_on_error
id|restart_on_error
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
r_int
id|retry_count
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cdu31a: Resetting drive on error&bslash;n&quot;
)paren
suffix:semicolon
id|reset_drive
c_func
(paren
)paren
suffix:semicolon
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_RESET_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
(paren
op_logical_neg
id|is_attention
c_func
(paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
id|set_drive_params
c_func
(paren
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cdu31a: Unable to spin up drive: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
l_int|200
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_READ_TOC_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cdu31a: Unable to read TOC: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cdu31a: Unable to get TOC data&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This routine writes data to the parameter register.  Since this should&n; * happen fairly fast, it is polled with no OS waits between.&n; */
r_static
r_int
DECL|function|write_params
id|write_params
c_func
(paren
r_int
r_char
op_star
id|params
comma
r_int
id|num_params
)paren
(brace
r_int
r_int
id|retry_count
suffix:semicolon
id|retry_count
op_assign
id|SONY_READY_RETRIES
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|is_param_write_rdy
c_func
(paren
)paren
)paren
)paren
(brace
id|retry_count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_param_write_rdy
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_while
c_loop
(paren
id|num_params
OG
l_int|0
)paren
(brace
id|write_param
c_func
(paren
op_star
id|params
)paren
suffix:semicolon
id|params
op_increment
suffix:semicolon
id|num_params
op_decrement
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The following reads data from the command result register.  It is a&n; * fairly complex routine, all status info flows back through this&n; * interface.  The algorithm is stolen directly from the flowcharts in&n; * the drive manual.&n; */
r_static
r_void
DECL|function|get_result
id|get_result
c_func
(paren
r_int
r_char
op_star
id|result_buffer
comma
r_int
r_int
op_star
id|result_size
)paren
(brace
r_int
r_char
id|a
comma
id|b
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|retry_count
suffix:semicolon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
multiline_comment|/* Wait for the result data to be ready */
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
(paren
id|is_busy
c_func
(paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_busy
c_func
(paren
)paren
op_logical_or
(paren
op_logical_neg
(paren
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
)paren
(brace
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;    * Get the first two bytes.  This determines what else needs&n;    * to be done.&n;    */
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
id|a
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
op_star
id|result_buffer
op_assign
id|a
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
id|b
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
op_star
id|result_buffer
op_assign
id|b
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
multiline_comment|/*&n;    * 0x20 means an error occured.  Byte 2 will have the error code.&n;    * Otherwise, the command succeded, byte 2 will have the count of&n;    * how many more status bytes are coming.&n;    *&n;    * The result register can be read 10 bytes at a time, a wait for&n;    * result ready to be asserted must be done between every 10 bytes.&n;    */
r_if
c_cond
(paren
(paren
id|a
op_amp
l_int|0xf0
)paren
op_ne
l_int|0x20
)paren
(brace
r_if
c_cond
(paren
id|b
OG
l_int|8
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|result_buffer
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
(paren
op_star
id|result_size
)paren
op_increment
suffix:semicolon
)brace
id|b
op_assign
id|b
op_minus
l_int|8
suffix:semicolon
r_while
c_loop
(paren
id|b
OG
l_int|10
)paren
(brace
id|retry_count
op_assign
id|SONY_READY_RETRIES
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
(brace
id|retry_count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
(brace
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|result_buffer
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
(paren
op_star
id|result_size
)paren
op_increment
suffix:semicolon
)brace
id|b
op_assign
id|b
op_minus
l_int|10
suffix:semicolon
)brace
r_if
c_cond
(paren
id|b
OG
l_int|0
)paren
(brace
id|retry_count
op_assign
id|SONY_READY_RETRIES
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
(brace
id|retry_count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
(brace
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|b
OG
l_int|0
)paren
(brace
op_star
id|result_buffer
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
id|result_buffer
op_increment
suffix:semicolon
(paren
op_star
id|result_size
)paren
op_increment
suffix:semicolon
id|b
op_decrement
suffix:semicolon
)brace
)brace
)brace
r_static
r_void
DECL|function|read_data_dma
id|read_data_dma
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|data_size
comma
r_int
r_char
op_star
id|result_buffer
comma
r_int
r_int
op_star
id|result_size
)paren
(brace
r_int
r_int
id|retry_count
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|dma_channel
comma
id|DMA_MODE_READ
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|dma_channel
comma
(paren
r_int
)paren
id|data
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|dma_channel
comma
id|data_size
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|dma_channel
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
(paren
op_logical_neg
id|is_data_ready
c_func
(paren
)paren
)paren
op_logical_and
(paren
op_logical_neg
id|is_result_ready
c_func
(paren
)paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_data_requested
c_func
(paren
)paren
)paren
(brace
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Read in a 2048 byte block of data.&n; */
r_static
r_void
DECL|function|read_data_block
id|read_data_block
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
r_int
id|data_size
comma
r_int
r_char
op_star
id|result_buffer
comma
r_int
r_int
op_star
id|result_size
)paren
(brace
macro_line|#ifdef SONY_POLL_EACH_BYTE
r_int
id|i
suffix:semicolon
r_int
r_int
id|retry_count
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|data_size
suffix:semicolon
id|i
op_increment
)paren
(brace
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
(paren
op_logical_neg
id|is_data_requested
c_func
(paren
)paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|is_data_requested
c_func
(paren
)paren
)paren
(brace
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
op_star
id|data
op_assign
id|read_data_register
c_func
(paren
)paren
suffix:semicolon
id|data
op_increment
suffix:semicolon
)brace
macro_line|#else
id|insb
c_func
(paren
id|sony_cd_read_reg
comma
id|data
comma
id|data_size
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * This routine issues a read data command and gets the data.  I don&squot;t&n; * really like the way this is done (I would prefer for do_sony_cmd() to&n; * handle it automatically) but I found that the drive returns status&n; * when it finishes reading (not when the host has read all the data)&n; * or after it gets an error.  This means that the status can be&n; * received at any time and should be handled immediately (at least&n; * between every 2048 byte block) to check for errors, we can&squot;t wait&n; * until all the data is read.&n; *&n; * This routine returns the total number of sectors read.  It will&n; * not return an error if it reads at least one sector successfully.&n; */
r_static
r_int
r_int
DECL|function|get_data
id|get_data
c_func
(paren
r_int
r_char
op_star
id|orig_data
comma
r_int
r_char
op_star
id|params
comma
multiline_comment|/* 6 bytes with the MSF start address&n;                                           and number of sectors to read. */
r_int
r_int
id|orig_data_size
comma
r_int
r_char
op_star
id|result_buffer
comma
r_int
r_int
op_star
id|result_size
)paren
(brace
r_int
r_int
id|cur_offset
suffix:semicolon
r_int
r_int
id|retry_count
suffix:semicolon
r_int
id|result_read
suffix:semicolon
r_int
id|num_retries
suffix:semicolon
r_int
r_int
id|num_sectors_read
op_assign
l_int|0
suffix:semicolon
r_int
r_char
op_star
id|data
op_assign
id|orig_data
suffix:semicolon
r_int
r_int
id|data_size
op_assign
id|orig_data_size
suffix:semicolon
id|num_retries
op_assign
l_int|0
suffix:semicolon
id|retry_data_operation
suffix:colon
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;    * Clear any outstanding attentions and wait for the drive to&n;    * complete any pending operations.&n;    */
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
(paren
id|is_busy
c_func
(paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_busy
c_func
(paren
)paren
)paren
(brace
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Issue the command */
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
id|clear_param_reg
c_func
(paren
)paren
suffix:semicolon
id|write_params
c_func
(paren
id|params
comma
l_int|6
)paren
suffix:semicolon
id|write_cmd
c_func
(paren
id|SONY_READ_CMD
)paren
suffix:semicolon
multiline_comment|/*&n;       * Read the data from the drive one 2048 byte sector at a time.  Handle&n;       * any results received between sectors, if an error result is returned&n;       * terminate the operation immediately.&n;       */
id|cur_offset
op_assign
l_int|0
suffix:semicolon
id|result_read
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|data_size
OG
l_int|0
)paren
op_logical_and
(paren
id|result_buffer
(braket
l_int|0
)braket
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* Wait for the drive to tell us we have something */
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
(paren
op_logical_neg
(paren
id|is_result_ready
c_func
(paren
)paren
op_logical_or
id|is_data_ready
c_func
(paren
)paren
)paren
)paren
)paren
(brace
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|is_result_ready
c_func
(paren
)paren
op_logical_or
id|is_data_ready
c_func
(paren
)paren
)paren
)paren
(brace
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Handle results first */
r_else
r_if
c_cond
(paren
id|is_result_ready
c_func
(paren
)paren
)paren
(brace
id|result_read
op_assign
l_int|1
suffix:semicolon
id|get_result
c_func
(paren
id|result_buffer
comma
id|result_size
)paren
suffix:semicolon
)brace
multiline_comment|/* Handle data next */
r_else
r_if
c_cond
(paren
id|dma_channel
OG
l_int|0
)paren
(brace
id|clear_data_ready
c_func
(paren
)paren
suffix:semicolon
id|read_data_dma
c_func
(paren
id|data
comma
l_int|2048
comma
id|result_buffer
comma
id|result_size
)paren
suffix:semicolon
id|data
op_add_assign
l_int|2048
suffix:semicolon
id|data_size
op_sub_assign
l_int|2048
suffix:semicolon
id|cur_offset
op_assign
id|cur_offset
op_plus
l_int|2048
suffix:semicolon
id|num_sectors_read
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;             * The drive has to be polled for status on a byte-by-byte basis&n;             * to know if the data is ready.  Yuck.  I really wish I could use&n;             * DMA all the time.&n;&t;     *&n;&t;     * NEWS FLASH - I am no longer polling on a byte-by-byte basis.&n;&t;     * It seems to work ok, but the spec says you shouldn&squot;t.&n;             */
id|clear_data_ready
c_func
(paren
)paren
suffix:semicolon
id|read_data_block
c_func
(paren
id|data
comma
l_int|2048
comma
id|result_buffer
comma
id|result_size
)paren
suffix:semicolon
id|data
op_add_assign
l_int|2048
suffix:semicolon
id|data_size
op_sub_assign
l_int|2048
suffix:semicolon
id|cur_offset
op_assign
id|cur_offset
op_plus
l_int|2048
suffix:semicolon
id|num_sectors_read
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Make sure the result has been read */
r_if
c_cond
(paren
op_logical_neg
id|result_read
)paren
(brace
id|get_result
c_func
(paren
id|result_buffer
comma
id|result_size
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
(paren
id|result_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
op_logical_and
(paren
id|result_buffer
(braket
l_int|1
)braket
op_ne
id|SONY_NOT_SPIN_ERR
)paren
multiline_comment|/* No retry when not spin */
op_logical_and
(paren
id|num_retries
OL
id|MAX_CDU31A_RETRIES
)paren
)paren
(brace
multiline_comment|/*&n;       * If an error occurs, go back and only read one sector at the&n;       * given location.  Hopefully the error occurred on an unused&n;       * sector after the first one.  It is hard to say which sector&n;       * the error occurred on because the drive returns status before&n;       * the data transfer is finished and doesn&squot;t say which sector.&n;       */
id|data_size
op_assign
l_int|2048
suffix:semicolon
id|data
op_assign
id|orig_data
suffix:semicolon
id|num_sectors_read
op_assign
l_int|0
suffix:semicolon
id|size_to_buf
c_func
(paren
l_int|1
comma
op_amp
id|params
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|num_retries
op_increment
suffix:semicolon
multiline_comment|/* Issue a reset on an error (the second time), othersize just delay */
r_if
c_cond
(paren
id|num_retries
op_eq
l_int|2
)paren
(brace
id|restart_on_error
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
l_int|10
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Restart the operation. */
r_goto
id|retry_data_operation
suffix:semicolon
)brace
r_return
id|num_sectors_read
suffix:semicolon
)brace
multiline_comment|/*&n; * Do a command that does not involve data transfer.  This routine must&n; * be re-entrant from the same task to support being called from the&n; * data operation code when an error occurs.&n; */
r_static
r_void
DECL|function|do_sony_cd_cmd
id|do_sony_cd_cmd
c_func
(paren
r_int
r_char
id|cmd
comma
r_int
r_char
op_star
id|params
comma
r_int
r_int
id|num_params
comma
r_int
r_char
op_star
id|result_buffer
comma
r_int
r_int
op_star
id|result_size
)paren
(brace
r_int
r_int
id|retry_count
suffix:semicolon
r_int
id|num_retries
suffix:semicolon
r_int
id|recursive_call
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current
op_ne
id|has_cd_task
)paren
multiline_comment|/* Allow recursive calls to this routine */
(brace
r_while
c_loop
(paren
id|sony_inuse
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_SIGNAL_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|sony_inuse
op_assign
l_int|1
suffix:semicolon
id|has_cd_task
op_assign
id|current
suffix:semicolon
id|recursive_call
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|recursive_call
op_assign
l_int|1
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|num_retries
op_assign
l_int|0
suffix:semicolon
id|retry_cd_operation
suffix:colon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_JIFFIES_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
(paren
id|is_busy
c_func
(paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_busy
c_func
(paren
)paren
)paren
(brace
id|result_buffer
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
id|result_buffer
(braket
l_int|1
)braket
op_assign
id|SONY_TIMEOUT_OP_ERR
suffix:semicolon
op_star
id|result_size
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|clear_result_ready
c_func
(paren
)paren
suffix:semicolon
id|clear_param_reg
c_func
(paren
)paren
suffix:semicolon
id|write_params
c_func
(paren
id|params
comma
id|num_params
)paren
suffix:semicolon
id|write_cmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|get_result
c_func
(paren
id|result_buffer
comma
id|result_size
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|result_buffer
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
op_logical_and
(paren
id|num_retries
OL
id|MAX_CDU31A_RETRIES
)paren
)paren
(brace
id|num_retries
op_increment
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
l_int|10
suffix:semicolon
multiline_comment|/* Wait .1 seconds on retries */
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_goto
id|retry_cd_operation
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|recursive_call
)paren
(brace
id|has_cd_task
op_assign
l_int|NULL
suffix:semicolon
id|sony_inuse
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Handle an attention from the drive.  This will return 1 if it found one&n; * or 0 if not (if one is found, the caller might want to call again).&n; *&n; * This routine counts the number of consecutive times it is called&n; * (since this is always called from a while loop until it returns&n; * a 0), and returns a 0 if it happens too many times.  This will help&n; * prevent a lockup.&n; */
r_static
r_int
DECL|function|handle_sony_cd_attention
id|handle_sony_cd_attention
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|atten_code
suffix:semicolon
r_static
r_int
id|num_consecutive_attentions
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|is_attention
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|num_consecutive_attentions
OG
id|CDU31A_MAX_CONSECUTIVE_ATTENTIONS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;cdu31a: Too many consecutive attentions: %d&bslash;n&quot;
comma
id|num_consecutive_attentions
)paren
suffix:semicolon
id|num_consecutive_attentions
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|clear_attention
c_func
(paren
)paren
suffix:semicolon
id|atten_code
op_assign
id|read_result_register
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|atten_code
)paren
(brace
multiline_comment|/* Someone changed the CD.  Mark it as changed */
r_case
id|SONY_MECH_LOADED_ATTN
suffix:colon
id|sony_disc_changed
op_assign
l_int|1
suffix:semicolon
id|sony_toc_read
op_assign
l_int|0
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
id|sony_first_block
op_assign
op_minus
l_int|1
suffix:semicolon
id|sony_last_block
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SONY_AUDIO_PLAY_DONE_ATTN
suffix:colon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_COMPLETED
suffix:semicolon
id|read_subcode
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SONY_EJECT_PUSHED_ATTN
suffix:colon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_INVALID
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SONY_LEAD_IN_ERR_ATTN
suffix:colon
r_case
id|SONY_LEAD_OUT_ERR_ATTN
suffix:colon
r_case
id|SONY_DATA_TRACK_ERR_ATTN
suffix:colon
r_case
id|SONY_AUDIO_PLAYBACK_ERR_ATTN
suffix:colon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_break
suffix:semicolon
)brace
id|num_consecutive_attentions
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|num_consecutive_attentions
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Convert from an integer 0-99 to BCD */
r_static
r_inline
r_int
r_int
DECL|function|int_to_bcd
id|int_to_bcd
c_func
(paren
r_int
r_int
id|val
)paren
(brace
r_int
id|retval
suffix:semicolon
id|retval
op_assign
(paren
id|val
op_div
l_int|10
)paren
op_lshift
l_int|4
suffix:semicolon
id|retval
op_assign
id|retval
op_or
id|val
op_mod
l_int|10
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/* Convert from BCD to an integer from 0-99 */
r_static
r_int
r_int
DECL|function|bcd_to_int
id|bcd_to_int
c_func
(paren
r_int
r_int
id|bcd
)paren
(brace
r_return
(paren
(paren
(paren
id|bcd
op_rshift
l_int|4
)paren
op_amp
l_int|0x0f
)paren
op_star
l_int|10
)paren
op_plus
(paren
id|bcd
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert a logical sector value (like the OS would want to use for&n; * a block device) to an MSF format.&n; */
r_static
r_void
DECL|function|log_to_msf
id|log_to_msf
c_func
(paren
r_int
r_int
id|log
comma
r_int
r_char
op_star
id|msf
)paren
(brace
id|log
op_assign
id|log
op_plus
id|LOG_START_OFFSET
suffix:semicolon
id|msf
(braket
l_int|0
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|log
op_div
l_int|4500
)paren
suffix:semicolon
id|log
op_assign
id|log
op_mod
l_int|4500
suffix:semicolon
id|msf
(braket
l_int|1
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|log
op_div
l_int|75
)paren
suffix:semicolon
id|msf
(braket
l_int|2
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|log
op_mod
l_int|75
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Convert an MSF format to a logical sector.&n; */
r_static
r_int
r_int
DECL|function|msf_to_log
id|msf_to_log
c_func
(paren
r_int
r_char
op_star
id|msf
)paren
(brace
r_int
r_int
id|log
suffix:semicolon
id|log
op_assign
id|bcd_to_int
c_func
(paren
id|msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|log
op_add_assign
id|bcd_to_int
c_func
(paren
id|msf
(braket
l_int|1
)braket
)paren
op_star
l_int|75
suffix:semicolon
id|log
op_add_assign
id|bcd_to_int
c_func
(paren
id|msf
(braket
l_int|0
)braket
)paren
op_star
l_int|4500
suffix:semicolon
id|log
op_assign
id|log
op_minus
id|LOG_START_OFFSET
suffix:semicolon
r_return
id|log
suffix:semicolon
)brace
multiline_comment|/*&n; * Take in integer size value and put it into a buffer like&n; * the drive would want to see a number-of-sector value.&n; */
r_static
r_void
DECL|function|size_to_buf
id|size_to_buf
c_func
(paren
r_int
r_int
id|size
comma
r_int
r_char
op_star
id|buf
)paren
(brace
id|buf
(braket
l_int|0
)braket
op_assign
id|size
op_div
l_int|65536
suffix:semicolon
id|size
op_assign
id|size
op_mod
l_int|65536
suffix:semicolon
id|buf
(braket
l_int|1
)braket
op_assign
id|size
op_div
l_int|256
suffix:semicolon
id|buf
(braket
l_int|2
)braket
op_assign
id|size
op_mod
l_int|256
suffix:semicolon
)brace
multiline_comment|/*&n; * The OS calls this to perform a read or write operation to the drive.&n; * Write obviously fail.  Reads to a read ahead of sony_buffer_size&n; * bytes to help speed operations.  This especially helps since the OS&n; * uses 1024 byte blocks and the drive uses 2048 byte blocks.  Since most&n; * data access on a CD is done sequentially, this saves a lot of operations.&n; */
r_static
r_void
DECL|function|do_cdu31a_request
id|do_cdu31a_request
c_func
(paren
r_void
)paren
(brace
r_int
id|block
suffix:semicolon
r_int
r_int
id|dev
suffix:semicolon
r_int
id|nsect
suffix:semicolon
r_int
r_char
id|params
(braket
l_int|10
)braket
suffix:semicolon
r_int
r_char
id|res_reg
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
id|copyoff
suffix:semicolon
r_int
id|spin_up_retry
suffix:semicolon
r_int
r_int
id|read_size
suffix:semicolon
multiline_comment|/* &n;    * Make sure no one else is using the driver; wait for them&n;    * to finish if it is so.&n;    */
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sony_inuse
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;signal
op_amp
op_complement
id|current-&gt;blocked
)paren
(brace
r_return
suffix:semicolon
)brace
)brace
id|sony_inuse
op_assign
l_int|1
suffix:semicolon
id|has_cd_task
op_assign
id|current
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_spun_up
)paren
(brace
id|scd_open
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|cdu31a_request_startover
suffix:colon
multiline_comment|/*&n;       * The beginning here is stolen from the hard disk driver.  I hope&n;       * its right.&n;       */
r_if
c_cond
(paren
op_logical_neg
(paren
id|CURRENT
)paren
op_logical_or
id|CURRENT-&gt;dev
OL
l_int|0
)paren
(brace
r_goto
id|end_do_cdu31a_request
suffix:semicolon
)brace
id|INIT_REQUEST
suffix:semicolon
id|dev
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
suffix:semicolon
id|block
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|nsect
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ne
l_int|0
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|CURRENT-&gt;cmd
)paren
(brace
r_case
id|READ
suffix:colon
multiline_comment|/*&n;          * If the block address is invalid or the request goes beyond the end of&n;          * the media, return an error.&n;          */
r_if
c_cond
(paren
(paren
id|block
op_div
l_int|4
)paren
op_ge
id|sony_toc-&gt;lead_out_start_lba
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|block
op_plus
id|nsect
)paren
op_div
l_int|4
)paren
op_ge
id|sony_toc-&gt;lead_out_start_lba
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
r_while
c_loop
(paren
id|nsect
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;             * If the requested sector is not currently in the read-ahead buffer,&n;             * it must be read in.&n;             */
r_if
c_cond
(paren
(paren
id|block
OL
id|sony_first_block
)paren
op_logical_or
(paren
id|block
OG
id|sony_last_block
)paren
)paren
(brace
id|sony_first_block
op_assign
(paren
id|block
op_div
l_int|4
)paren
op_star
l_int|4
suffix:semicolon
id|log_to_msf
c_func
(paren
id|block
op_div
l_int|4
comma
id|params
)paren
suffix:semicolon
multiline_comment|/*&n;                * If the full read-ahead would go beyond the end of the media, trim&n;                * it back to read just till the end of the media.&n;                */
r_if
c_cond
(paren
(paren
(paren
id|block
op_div
l_int|4
)paren
op_plus
id|sony_buffer_sectors
)paren
op_ge
id|sony_toc-&gt;lead_out_start_lba
)paren
(brace
id|read_size
op_assign
id|sony_toc-&gt;lead_out_start_lba
op_minus
(paren
id|block
op_div
l_int|4
)paren
suffix:semicolon
)brace
r_else
(brace
id|read_size
op_assign
id|sony_buffer_sectors
suffix:semicolon
)brace
id|size_to_buf
c_func
(paren
id|read_size
comma
op_amp
id|params
(braket
l_int|3
)braket
)paren
suffix:semicolon
multiline_comment|/*&n;                * Read the data.  If the drive was not spinning, spin it up and try&n;                * once more.  I know, the goto is ugly, but I am too lazy to fix it.&n;                */
id|spin_up_retry
op_assign
l_int|0
suffix:semicolon
id|try_read_again
suffix:colon
id|sony_last_block
op_assign
id|sony_first_block
op_plus
(paren
id|get_data
c_func
(paren
id|sony_buffer
comma
id|params
comma
(paren
id|read_size
op_star
l_int|2048
)paren
comma
id|res_reg
comma
op_amp
id|res_size
)paren
op_star
l_int|4
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_NOT_SPIN_ERR
)paren
op_logical_and
(paren
op_logical_neg
id|spin_up_retry
)paren
)paren
(brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|spin_up_retry
op_assign
l_int|1
suffix:semicolon
r_goto
id|try_read_again
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM Read error: 0x%2.2x&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|sony_first_block
op_assign
op_minus
l_int|1
suffix:semicolon
id|sony_last_block
op_assign
op_minus
l_int|1
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|cdu31a_request_startover
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;             * The data is in memory now, copy it to the buffer and advance to the&n;             * next block to read.&n;             */
id|copyoff
op_assign
(paren
id|block
op_minus
id|sony_first_block
)paren
op_star
l_int|512
suffix:semicolon
id|memcpy
c_func
(paren
id|CURRENT-&gt;buffer
comma
id|sony_buffer
op_plus
id|copyoff
comma
l_int|512
)paren
suffix:semicolon
id|block
op_add_assign
l_int|1
suffix:semicolon
id|nsect
op_sub_assign
l_int|1
suffix:semicolon
id|CURRENT-&gt;buffer
op_add_assign
l_int|512
suffix:semicolon
)brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE
suffix:colon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;Unkown SONY CD cmd&quot;
)paren
suffix:semicolon
)brace
)brace
id|end_do_cdu31a_request
suffix:colon
id|has_cd_task
op_assign
l_int|NULL
suffix:semicolon
id|sony_inuse
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|sony_wait
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the table of contents from the drive and set sony_toc_read if&n; * successful.&n; */
r_static
r_void
DECL|function|sony_get_toc
id|sony_get_toc
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|res_size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_REQ_TOC_DATA_CMD
comma
l_int|NULL
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
id|sony_toc
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|sony_toc-&gt;exec_status
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|sony_toc-&gt;lead_out_start_lba
op_assign
id|msf_to_log
c_func
(paren
id|sony_toc-&gt;lead_out_start_msf
)paren
suffix:semicolon
id|sony_toc_read
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Search for a specific track in the table of contents.&n; */
r_static
r_int
DECL|function|find_track
id|find_track
c_func
(paren
r_int
id|track
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|num_tracks
suffix:semicolon
id|num_tracks
op_assign
id|sony_toc-&gt;last_track_num
op_plus
id|sony_toc-&gt;first_track_num
op_plus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|num_tracks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|sony_toc-&gt;tracks
(braket
id|i
)braket
dot
id|track
op_eq
id|track
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the subcode and put it int last_sony_subcode for future use.&n; */
r_static
r_int
DECL|function|read_subcode
id|read_subcode
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|res_size
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_REQ_SUBCODE_ADDRESS_CMD
comma
l_int|NULL
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
id|last_sony_subcode
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|last_sony_subcode-&gt;exec_status
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (read_subcode)&bslash;n&quot;
comma
id|last_sony_subcode-&gt;exec_status
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the subchannel info like the CDROMSUBCHNL command wants to see it.  If&n; * the drive is playing, the subchannel needs to be read (since it would be&n; * changing).  If the drive is paused or completed, the subcode information has&n; * already been stored, just use that.  The ioctl call wants things in decimal&n; * (not BCD), so all the conversions are done.&n; */
r_static
r_int
DECL|function|sony_get_subchnl_info
id|sony_get_subchnl_info
c_func
(paren
r_int
id|arg
)paren
(brace
r_struct
id|cdrom_subchnl
id|schi
suffix:semicolon
multiline_comment|/* Get attention stuff */
r_while
c_loop
(paren
id|handle_sony_cd_attention
c_func
(paren
)paren
)paren
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|schi
)paren
)paren
suffix:semicolon
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|schi
)paren
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|schi
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|schi
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|sony_audio_status
)paren
(brace
r_case
id|CDROM_AUDIO_PLAY
suffix:colon
r_if
c_cond
(paren
id|read_subcode
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CDROM_AUDIO_PAUSED
suffix:colon
r_case
id|CDROM_AUDIO_COMPLETED
suffix:colon
r_break
suffix:semicolon
r_case
id|CDROM_AUDIO_NO_STATUS
suffix:colon
id|schi.cdsc_audiostatus
op_assign
id|sony_audio_status
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
op_amp
id|schi
comma
r_sizeof
(paren
id|schi
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROM_AUDIO_INVALID
suffix:colon
r_case
id|CDROM_AUDIO_ERROR
suffix:colon
r_default
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|schi.cdsc_audiostatus
op_assign
id|sony_audio_status
suffix:semicolon
id|schi.cdsc_adr
op_assign
id|last_sony_subcode-&gt;address
suffix:semicolon
id|schi.cdsc_ctrl
op_assign
id|last_sony_subcode-&gt;control
suffix:semicolon
id|schi.cdsc_trk
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;track_num
)paren
suffix:semicolon
id|schi.cdsc_ind
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;index_num
)paren
suffix:semicolon
r_if
c_cond
(paren
id|schi.cdsc_format
op_eq
id|CDROM_MSF
)paren
(brace
id|schi.cdsc_absaddr.msf.minute
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;abs_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|schi.cdsc_absaddr.msf.second
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;abs_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|schi.cdsc_absaddr.msf.frame
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;abs_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|schi.cdsc_reladdr.msf.minute
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;rel_msf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|schi.cdsc_reladdr.msf.second
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;rel_msf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|schi.cdsc_reladdr.msf.frame
op_assign
id|bcd_to_int
c_func
(paren
id|last_sony_subcode-&gt;rel_msf
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|schi.cdsc_format
op_eq
id|CDROM_LBA
)paren
(brace
id|schi.cdsc_absaddr.lba
op_assign
id|msf_to_log
c_func
(paren
id|last_sony_subcode-&gt;abs_msf
)paren
suffix:semicolon
id|schi.cdsc_reladdr.lba
op_assign
id|msf_to_log
c_func
(paren
id|last_sony_subcode-&gt;rel_msf
)paren
suffix:semicolon
)brace
id|memcpy_tofs
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
op_amp
id|schi
comma
r_sizeof
(paren
id|schi
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * The big ugly ioctl handler.&n; */
r_static
r_int
DECL|function|scd_ioctl
id|scd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
r_int
id|dev
suffix:semicolon
r_int
r_char
id|res_reg
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
r_char
id|params
(braket
l_int|7
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|dev
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
l_int|6
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSTART
suffix:colon
multiline_comment|/* Spin up the drive */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (CDROMSTART)&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
multiline_comment|/* Spin down the drive */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_AUDIO_STOP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/*&n;       * Spin the drive down, ignoring the error if the disk was&n;       * already not spinning.&n;       */
id|sony_audio_status
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
)paren
op_logical_and
(paren
id|res_reg
(braket
l_int|1
)braket
op_ne
id|SONY_NOT_SPIN_ERR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (CDROMSTOP)&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPAUSE
suffix:colon
multiline_comment|/* Pause the drive */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_AUDIO_STOP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (CDROMPAUSE)&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Get the current position and save it for resuming */
r_if
c_cond
(paren
id|read_subcode
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|cur_pos_msf
(braket
l_int|0
)braket
op_assign
id|last_sony_subcode-&gt;abs_msf
(braket
l_int|0
)braket
suffix:semicolon
id|cur_pos_msf
(braket
l_int|1
)braket
op_assign
id|last_sony_subcode-&gt;abs_msf
(braket
l_int|1
)braket
suffix:semicolon
id|cur_pos_msf
(braket
l_int|2
)braket
op_assign
id|last_sony_subcode-&gt;abs_msf
(braket
l_int|2
)braket
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
multiline_comment|/* Start the drive after being paused */
r_if
c_cond
(paren
id|sony_audio_status
op_ne
id|CDROM_AUDIO_PAUSED
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/* Start the drive at the saved position. */
id|params
(braket
l_int|1
)braket
op_assign
id|cur_pos_msf
(braket
l_int|0
)braket
suffix:semicolon
id|params
(braket
l_int|2
)braket
op_assign
id|cur_pos_msf
(braket
l_int|1
)braket
suffix:semicolon
id|params
(braket
l_int|3
)braket
op_assign
id|cur_pos_msf
(braket
l_int|2
)braket
suffix:semicolon
id|params
(braket
l_int|4
)braket
op_assign
id|final_pos_msf
(braket
l_int|0
)braket
suffix:semicolon
id|params
(braket
l_int|5
)braket
op_assign
id|final_pos_msf
(braket
l_int|1
)braket
suffix:semicolon
id|params
(braket
l_int|6
)braket
op_assign
id|final_pos_msf
(braket
l_int|2
)braket
suffix:semicolon
id|params
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_AUDIO_PLAYBACK_CMD
comma
id|params
comma
l_int|7
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (CDROMRESUME)&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPLAYMSF
suffix:colon
multiline_comment|/* Play starting at the given MSF address. */
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
l_int|6
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
(paren
id|params
(braket
l_int|1
)braket
)paren
comma
(paren
r_void
op_star
)paren
id|arg
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* The parameters are given in int, must be converted */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
l_int|7
suffix:semicolon
id|i
op_increment
)paren
(brace
id|params
(braket
id|i
)braket
op_assign
id|int_to_bcd
c_func
(paren
id|params
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|params
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_AUDIO_PLAYBACK_CMD
comma
id|params
comma
l_int|7
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (CDROMPLAYMSF)&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Save the final position for pauses and resumes */
id|final_pos_msf
(braket
l_int|0
)braket
op_assign
id|params
(braket
l_int|4
)braket
suffix:semicolon
id|final_pos_msf
(braket
l_int|1
)braket
op_assign
id|params
(braket
l_int|5
)braket
suffix:semicolon
id|final_pos_msf
(braket
l_int|2
)braket
op_assign
id|params
(braket
l_int|6
)braket
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADTOCHDR
suffix:colon
multiline_comment|/* Read the table of contents header */
(brace
r_struct
id|cdrom_tochdr
op_star
id|hdr
suffix:semicolon
r_struct
id|cdrom_tochdr
id|loc_hdr
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|hdr
op_assign
(paren
r_struct
id|cdrom_tochdr
op_star
)paren
id|arg
suffix:semicolon
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|hdr
comma
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
suffix:semicolon
id|loc_hdr.cdth_trk0
op_assign
id|bcd_to_int
c_func
(paren
id|sony_toc-&gt;first_track_num
)paren
suffix:semicolon
id|loc_hdr.cdth_trk1
op_assign
id|bcd_to_int
c_func
(paren
id|sony_toc-&gt;last_track_num
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|hdr
comma
op_amp
id|loc_hdr
comma
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADTOCENTRY
suffix:colon
multiline_comment|/* Read a given table of contents entry */
(brace
r_struct
id|cdrom_tocentry
op_star
id|entry
suffix:semicolon
r_struct
id|cdrom_tocentry
id|loc_entry
suffix:semicolon
r_int
id|track_idx
suffix:semicolon
r_int
r_char
op_star
id|msf_val
op_assign
l_int|NULL
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|entry
op_assign
(paren
r_struct
id|cdrom_tocentry
op_star
)paren
id|arg
suffix:semicolon
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|entry
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|entry
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|loc_entry
comma
id|entry
comma
r_sizeof
(paren
id|loc_entry
)paren
)paren
suffix:semicolon
multiline_comment|/* Lead out is handled separately since it is special. */
r_if
c_cond
(paren
id|loc_entry.cdte_track
op_eq
id|CDROM_LEADOUT
)paren
(brace
id|loc_entry.cdte_adr
op_assign
id|sony_toc-&gt;address2
suffix:semicolon
id|loc_entry.cdte_ctrl
op_assign
id|sony_toc-&gt;control2
suffix:semicolon
id|msf_val
op_assign
id|sony_toc-&gt;lead_out_start_msf
suffix:semicolon
)brace
r_else
(brace
id|track_idx
op_assign
id|find_track
c_func
(paren
id|int_to_bcd
c_func
(paren
id|loc_entry.cdte_track
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|track_idx
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|loc_entry.cdte_adr
op_assign
id|sony_toc-&gt;tracks
(braket
id|track_idx
)braket
dot
id|address
suffix:semicolon
id|loc_entry.cdte_ctrl
op_assign
id|sony_toc-&gt;tracks
(braket
id|track_idx
)braket
dot
id|control
suffix:semicolon
id|msf_val
op_assign
id|sony_toc-&gt;tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
suffix:semicolon
)brace
multiline_comment|/* Logical buffer address or MSF format requested? */
r_if
c_cond
(paren
id|loc_entry.cdte_format
op_eq
id|CDROM_LBA
)paren
(brace
id|loc_entry.cdte_addr.lba
op_assign
id|msf_to_log
c_func
(paren
id|msf_val
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|loc_entry.cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
id|loc_entry.cdte_addr.msf.minute
op_assign
id|bcd_to_int
c_func
(paren
op_star
id|msf_val
)paren
suffix:semicolon
id|loc_entry.cdte_addr.msf.second
op_assign
id|bcd_to_int
c_func
(paren
op_star
(paren
id|msf_val
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|loc_entry.cdte_addr.msf.frame
op_assign
id|bcd_to_int
c_func
(paren
op_star
(paren
id|msf_val
op_plus
l_int|2
)paren
)paren
suffix:semicolon
)brace
id|memcpy_tofs
c_func
(paren
id|entry
comma
op_amp
id|loc_entry
comma
r_sizeof
(paren
op_star
id|entry
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPLAYTRKIND
suffix:colon
multiline_comment|/* Play a track.  This currently ignores index. */
(brace
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_int
id|track_idx
suffix:semicolon
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|ti
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ti.cdti_trk0
OL
id|sony_toc-&gt;first_track_num
)paren
op_logical_or
(paren
id|ti.cdti_trk0
OG
id|sony_toc-&gt;last_track_num
)paren
op_logical_or
(paren
id|ti.cdti_trk1
OL
id|ti.cdti_trk0
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|track_idx
op_assign
id|find_track
c_func
(paren
id|int_to_bcd
c_func
(paren
id|ti.cdti_trk0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|track_idx
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|params
(braket
l_int|1
)braket
op_assign
id|sony_toc-&gt;tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|0
)braket
suffix:semicolon
id|params
(braket
l_int|2
)braket
op_assign
id|sony_toc-&gt;tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|1
)braket
suffix:semicolon
id|params
(braket
l_int|3
)braket
op_assign
id|sony_toc-&gt;tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
(braket
l_int|2
)braket
suffix:semicolon
multiline_comment|/*&n;          * If we want to stop after the last track, use the lead-out&n;          * MSF to do that.&n;          */
r_if
c_cond
(paren
id|ti.cdti_trk1
op_ge
id|bcd_to_int
c_func
(paren
id|sony_toc-&gt;last_track_num
)paren
)paren
(brace
id|log_to_msf
c_func
(paren
id|msf_to_log
c_func
(paren
id|sony_toc-&gt;lead_out_start_msf
)paren
op_minus
l_int|1
comma
op_amp
(paren
id|params
(braket
l_int|4
)braket
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|track_idx
op_assign
id|find_track
c_func
(paren
id|int_to_bcd
c_func
(paren
id|ti.cdti_trk1
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|track_idx
OL
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|log_to_msf
c_func
(paren
id|msf_to_log
c_func
(paren
id|sony_toc-&gt;tracks
(braket
id|track_idx
)braket
dot
id|track_start_msf
)paren
op_minus
l_int|1
comma
op_amp
(paren
id|params
(braket
l_int|4
)braket
)paren
)paren
suffix:semicolon
)brace
id|params
(braket
l_int|0
)braket
op_assign
l_int|0x03
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_AUDIO_PLAYBACK_CMD
comma
id|params
comma
l_int|7
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Params: %x %x %x %x %x %x %x&bslash;n&quot;
comma
id|params
(braket
l_int|0
)braket
comma
id|params
(braket
l_int|1
)braket
comma
id|params
(braket
l_int|2
)braket
comma
id|params
(braket
l_int|3
)braket
comma
id|params
(braket
l_int|4
)braket
comma
id|params
(braket
l_int|5
)braket
comma
id|params
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (CDROMPLAYTRKIND&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Save the final position for pauses and resumes */
id|final_pos_msf
(braket
l_int|0
)braket
op_assign
id|params
(braket
l_int|4
)braket
suffix:semicolon
id|final_pos_msf
(braket
l_int|1
)braket
op_assign
id|params
(braket
l_int|5
)braket
suffix:semicolon
id|final_pos_msf
(braket
l_int|2
)braket
op_assign
id|params
(braket
l_int|6
)braket
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMSUBCHNL
suffix:colon
multiline_comment|/* Get subchannel info */
r_return
id|sony_get_subchnl_info
c_func
(paren
id|arg
)paren
suffix:semicolon
r_case
id|CDROMVOLCTRL
suffix:colon
multiline_comment|/* Volume control.  What volume does this change, anyway? */
(brace
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|volctrl
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
id|params
(braket
l_int|0
)braket
op_assign
id|SONY_SD_AUDIO_VOLUME
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
id|volctrl.channel0
suffix:semicolon
id|params
(braket
l_int|2
)braket
op_assign
id|volctrl.channel1
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SET_DRIVE_PARAM_CMD
comma
id|params
comma
l_int|3
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (CDROMVOLCTRL)&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMEJECT
suffix:colon
multiline_comment|/* Eject the drive */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_AUDIO_STOP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|sony_audio_status
op_assign
id|CDROM_AUDIO_INVALID
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_EJECT_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (CDROMEJECT)&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Open the drive for operations.  Spin the drive up and read the table of&n; * contents if these have not already been done.&n; */
r_static
r_int
DECL|function|scd_open
id|scd_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
id|num_spin_ups
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_spun_up
)paren
(brace
id|num_spin_ups
op_assign
l_int|0
suffix:semicolon
id|respinup_on_open
suffix:colon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_UP_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/* The drive sometimes returns error 0.  I don&squot;t know why, but ignore&n;         it.  It seems to mean the drive has already done the operation. */
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|res_reg
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (scd_open, spin up)&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_READ_TOC_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
multiline_comment|/* The drive sometimes returns error 0.  I don&squot;t know why, but ignore&n;         it.  It seems to mean the drive has already done the operation. */
r_if
c_cond
(paren
(paren
id|res_size
OL
l_int|2
)paren
op_logical_or
(paren
(paren
id|res_reg
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|res_reg
(braket
l_int|1
)braket
op_ne
l_int|0
)paren
)paren
)paren
(brace
multiline_comment|/* If the drive is already playing, its ok.  */
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_AUDIO_PLAYING_ERR
)paren
op_logical_or
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
l_int|0
)paren
)paren
(brace
r_goto
id|drive_spinning
suffix:semicolon
)brace
multiline_comment|/* If the drive says it is not spun up (even though we just did it!)&n;            then retry the operation at least a few times. */
r_if
c_cond
(paren
(paren
id|res_reg
(braket
l_int|1
)braket
op_eq
id|SONY_NOT_SPIN_ERR
)paren
op_logical_and
(paren
id|num_spin_ups
OL
id|MAX_CDU31A_RETRIES
)paren
)paren
(brace
id|num_spin_ups
op_increment
suffix:semicolon
r_goto
id|respinup_on_open
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Sony CDROM error 0x%2.2x (scd_open, read toc)&bslash;n&quot;
comma
id|res_reg
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|sony_get_toc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|sony_toc_read
)paren
(brace
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|sony_spun_up
op_assign
l_int|1
suffix:semicolon
)brace
id|drive_spinning
suffix:colon
r_if
c_cond
(paren
id|inode
)paren
(brace
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
)brace
id|sony_usage
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close the drive.  Spin it down if no task is using it.  The spin&n; * down will fail if playing audio, so audio play is OK.&n; */
r_static
r_void
DECL|function|scd_release
id|scd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
r_char
id|res_reg
(braket
l_int|2
)braket
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_if
c_cond
(paren
id|sony_usage
OG
l_int|0
)paren
(brace
id|sony_usage
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sony_usage
op_eq
l_int|0
)paren
(brace
id|sync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|do_sony_cd_cmd
c_func
(paren
id|SONY_SPIN_DOWN_CMD
comma
l_int|NULL
comma
l_int|0
comma
id|res_reg
comma
op_amp
id|res_size
)paren
suffix:semicolon
id|sony_spun_up
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|variable|scd_fops
r_static
r_struct
id|file_operations
id|scd_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|scd_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|scd_open
comma
multiline_comment|/* open */
id|scd_release
comma
multiline_comment|/* release */
l_int|NULL
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
id|scd_disk_change
comma
multiline_comment|/* media_change */
l_int|NULL
multiline_comment|/* revalidate */
)brace
suffix:semicolon
multiline_comment|/* The different types of disc loading mechanisms supported */
DECL|variable|load_mech
r_static
r_char
op_star
id|load_mech
(braket
)braket
op_assign
(brace
l_string|&quot;caddy&quot;
comma
l_string|&quot;tray&quot;
comma
l_string|&quot;pop-up&quot;
comma
l_string|&quot;unknown&quot;
)brace
suffix:semicolon
multiline_comment|/* Read-ahead buffer sizes for different drives.  These are just arbitrary&n;   values, I don&squot;t know what is really optimum. */
DECL|variable|mem_size
r_static
r_int
r_int
id|mem_size
(braket
)braket
op_assign
(brace
l_int|16384
comma
l_int|16384
comma
l_int|16384
comma
l_int|2048
)brace
suffix:semicolon
r_void
DECL|function|get_drive_configuration
id|get_drive_configuration
c_func
(paren
r_int
r_int
id|base_io
comma
r_int
r_char
id|res_reg
(braket
)braket
comma
r_int
r_int
op_star
id|res_size
)paren
(brace
r_int
id|retry_count
suffix:semicolon
multiline_comment|/* Set the base address */
id|sony_cd_base_io
op_assign
id|base_io
suffix:semicolon
multiline_comment|/* Set up all the register locations */
id|sony_cd_cmd_reg
op_assign
id|sony_cd_base_io
op_plus
id|SONY_CMD_REG_OFFSET
suffix:semicolon
id|sony_cd_param_reg
op_assign
id|sony_cd_base_io
op_plus
id|SONY_PARAM_REG_OFFSET
suffix:semicolon
id|sony_cd_write_reg
op_assign
id|sony_cd_base_io
op_plus
id|SONY_WRITE_REG_OFFSET
suffix:semicolon
id|sony_cd_control_reg
op_assign
id|sony_cd_base_io
op_plus
id|SONY_CONTROL_REG_OFFSET
suffix:semicolon
id|sony_cd_status_reg
op_assign
id|sony_cd_base_io
op_plus
id|SONY_STATUS_REG_OFFSET
suffix:semicolon
id|sony_cd_result_reg
op_assign
id|sony_cd_base_io
op_plus
id|SONY_RESULT_REG_OFFSET
suffix:semicolon
id|sony_cd_read_reg
op_assign
id|sony_cd_base_io
op_plus
id|SONY_READ_REG_OFFSET
suffix:semicolon
id|sony_cd_fifost_reg
op_assign
id|sony_cd_base_io
op_plus
id|SONY_FIFOST_REG_OFFSET
suffix:semicolon
multiline_comment|/*&n;    * Check to see if anything exists at the status register location.&n;    * I don&squot;t know if this is a good way to check, but it seems to work&n;    * ok for me.&n;    */
r_if
c_cond
(paren
id|read_status_register
c_func
(paren
)paren
op_ne
l_int|0xff
)paren
(brace
multiline_comment|/*&n;       * Reset the drive and wait for attention from it (to say its reset).&n;       * If you don&squot;t wait, the next operation will probably fail.&n;       */
id|reset_drive
c_func
(paren
)paren
suffix:semicolon
id|retry_count
op_assign
id|jiffies
op_plus
id|SONY_RESET_TIMEOUT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|retry_count
OG
id|jiffies
)paren
op_logical_and
(paren
op_logical_neg
id|is_attention
c_func
(paren
)paren
)paren
)paren
(brace
id|sony_sleep
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* If attention is never seen probably not a CDU31a present */
r_if
c_cond
(paren
op_logical_neg
id|is_attention
c_func
(paren
)paren
)paren
(brace
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;       * Get the drive configuration.&n;       */
id|do_sony_cd_cmd
c_func
(paren
id|SONY_REQ_DRIVE_CONFIG_CMD
comma
l_int|NULL
comma
l_int|0
comma
(paren
r_int
r_char
op_star
)paren
id|res_reg
comma
id|res_size
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Return an error */
id|res_reg
(braket
l_int|0
)braket
op_assign
l_int|0x20
suffix:semicolon
)brace
DECL|variable|cdu31a_sigaction
r_static
r_struct
id|sigaction
id|cdu31a_sigaction
op_assign
(brace
id|cdu31a_interrupt
comma
l_int|0
comma
id|SA_INTERRUPT
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|cdu31a_block_size
r_static
r_int
id|cdu31a_block_size
suffix:semicolon
multiline_comment|/*&n; * Initialize the driver.&n; */
r_int
r_int
DECL|function|cdu31a_init
id|cdu31a_init
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
(brace
r_struct
id|s_sony_drive_config
id|drive_config
suffix:semicolon
r_int
r_int
id|res_size
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|drive_found
suffix:semicolon
r_int
id|tmp_irq
suffix:semicolon
multiline_comment|/*&n;    * According to Alex Freed (freed@europa.orion.adobe.com), this is&n;    * required for the Fusion CD-16 package.  If the sound driver is&n;    * loaded, it should work fine, but just in case...&n;    *&n;    * The following turn on the CD-ROM interface for a Fusion CD-16.&n;    */
id|outb
c_func
(paren
l_int|0xbc
comma
l_int|0x9a01
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xe2
comma
l_int|0x9a01
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
id|drive_found
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|cdu31a_addresses
(braket
id|i
)braket
dot
id|base
op_ne
l_int|0
)paren
op_logical_and
(paren
op_logical_neg
id|drive_found
)paren
)paren
(brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|cdu31a_addresses
(braket
id|i
)braket
dot
id|base
comma
l_int|4
)paren
)paren
(brace
id|i
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|get_drive_configuration
c_func
(paren
id|cdu31a_addresses
(braket
id|i
)braket
dot
id|base
comma
id|drive_config.exec_status
comma
op_amp
id|res_size
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|res_size
OG
l_int|2
)paren
op_logical_and
(paren
(paren
id|drive_config.exec_status
(braket
l_int|0
)braket
op_amp
l_int|0x20
)paren
op_eq
l_int|0x00
)paren
)paren
(brace
id|drive_found
op_assign
l_int|1
suffix:semicolon
id|snarf_region
c_func
(paren
id|cdu31a_addresses
(braket
id|i
)braket
dot
id|base
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;cdu31a&quot;
comma
op_amp
id|scd_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major %d for CDU-31a&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SONY_HWC_DOUBLE_SPEED
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|is_double_speed
op_assign
l_int|1
suffix:semicolon
)brace
id|tmp_irq
op_assign
id|cdu31a_addresses
(braket
id|i
)braket
dot
id|int_num
suffix:semicolon
r_if
c_cond
(paren
id|tmp_irq
OL
l_int|0
)paren
(brace
id|autoirq_setup
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|enable_interrupts
c_func
(paren
)paren
suffix:semicolon
id|reset_drive
c_func
(paren
)paren
suffix:semicolon
id|tmp_irq
op_assign
id|autoirq_report
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|disable_interrupts
c_func
(paren
)paren
suffix:semicolon
id|set_drive_params
c_func
(paren
)paren
suffix:semicolon
id|irq_used
op_assign
id|tmp_irq
suffix:semicolon
)brace
r_else
(brace
id|set_drive_params
c_func
(paren
)paren
suffix:semicolon
id|irq_used
op_assign
id|tmp_irq
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq_used
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|irqaction
c_func
(paren
id|irq_used
comma
op_amp
id|cdu31a_sigaction
)paren
)paren
(brace
id|irq_used
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unable to grab IRQ%d for the CDU31A driver&bslash;n&quot;
comma
id|irq_used
)paren
suffix:semicolon
)brace
)brace
id|dma_channel
op_assign
id|cdu31a_addresses
(braket
id|i
)braket
dot
id|dma_num
suffix:semicolon
r_if
c_cond
(paren
id|dma_channel
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|dma_channel
)paren
)paren
(brace
id|dma_channel
op_assign
op_minus
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unable to grab DMA%d for the CDU31A driver&bslash;n&quot;
comma
id|dma_channel
)paren
suffix:semicolon
)brace
)brace
id|sony_buffer_size
op_assign
id|mem_size
(braket
id|SONY_HWC_GET_BUF_MEM_SIZE
c_func
(paren
id|drive_config
)paren
)braket
suffix:semicolon
id|sony_buffer_sectors
op_assign
id|sony_buffer_size
op_div
l_int|2048
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Sony I/F CDROM : %8.8s %16.16s %8.8s with %s load mechanism&bslash;n&quot;
comma
id|drive_config.vendor_id
comma
id|drive_config.product_id
comma
id|drive_config.product_rev_level
comma
id|load_mech
(braket
id|SONY_HWC_GET_LOAD_MECH
c_func
(paren
id|drive_config
)paren
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  using %d byte buffer&quot;
comma
id|sony_buffer_size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SONY_HWC_AUDIO_PLAYBACK
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, audio&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SONY_HWC_EJECT
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, eject&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SONY_HWC_LED_SUPPORT
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, LED&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SONY_HWC_ELECTRIC_VOLUME
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, elec. Vol&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SONY_HWC_ELECTRIC_VOLUME_CTL
c_func
(paren
id|drive_config
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, sep. Vol&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_double_speed
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, double speed&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|irq_used
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, irq %d&quot;
comma
id|irq_used
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma_channel
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, drq %d&quot;
comma
id|dma_channel
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* 32 sector (16kB) read-ahead */
id|cdu31a_block_size
op_assign
l_int|2048
suffix:semicolon
multiline_comment|/* 2kB block size */
multiline_comment|/* use &squot;mount -o block=2048&squot; */
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
op_amp
id|cdu31a_block_size
suffix:semicolon
id|sony_toc
op_assign
(paren
r_struct
id|s_sony_toc
op_star
)paren
id|mem_start
suffix:semicolon
id|mem_start
op_add_assign
r_sizeof
(paren
op_star
id|sony_toc
)paren
suffix:semicolon
id|last_sony_subcode
op_assign
(paren
r_struct
id|s_sony_subcode
op_star
)paren
id|mem_start
suffix:semicolon
id|mem_start
op_add_assign
r_sizeof
(paren
op_star
id|last_sony_subcode
)paren
suffix:semicolon
multiline_comment|/* If memory will not fit into the current 64KB block, align it&n;            so the block will not cross a 64KB boundary.  This is&n;            because DMA cannot cross 64KB boundaries. */
r_if
c_cond
(paren
(paren
id|dma_channel
OG
l_int|0
)paren
op_logical_and
(paren
(paren
(paren
id|mem_start
)paren
op_amp
(paren
op_complement
l_int|0xffff
)paren
)paren
op_ne
(paren
(paren
(paren
id|mem_start
)paren
op_plus
id|sony_buffer_size
)paren
op_amp
(paren
op_complement
l_int|0xffff
)paren
)paren
)paren
)paren
(brace
id|mem_start
op_assign
(paren
(paren
(paren
r_int
)paren
id|mem_start
)paren
op_plus
l_int|0x10000
)paren
op_amp
(paren
op_complement
l_int|0xffff
)paren
suffix:semicolon
)brace
id|sony_buffer
op_assign
(paren
r_int
r_char
op_star
)paren
id|mem_start
suffix:semicolon
id|mem_start
op_add_assign
id|sony_buffer_size
suffix:semicolon
)brace
id|i
op_increment
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
eof
