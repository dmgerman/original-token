multiline_comment|/*&n; * acsi_slm.c -- Device driver for the Atari SLM laser printer&n; *&n; * Copyright 1995 Roman Hodek &lt;Roman.Hodek@informatik.uni-erlangen.de&gt;&n; *&n; * This file is subject to the terms and conditions of the GNU General Public&n; * License.  See the file COPYING in the main directory of this archive for&n; * more details.&n; * &n; */
multiline_comment|/*&n;&n;Notes:&n;&n;The major number for SLM printers is 28 (like ACSI), but as a character&n;device, not block device. The minor number is the number of the printer (if&n;you have more than one SLM; currently max. 2 (#define-constant) SLMs are&n;supported). The device can be opened for reading and writing. If reading it,&n;you get some status infos (MODE SENSE data). Writing mode is used for the data&n;to be printed. Some ioctls allow to get the printer status and to tune printer&n;modes and some internal variables.&n;&n;A special problem of the SLM driver is the timing and thus the buffering of&n;the print data. The problem is that all the data for one page must be present&n;in memory when printing starts, else --when swapping occurs-- the timing could&n;not be guaranteed. There are several ways to assure this:&n;&n; 1) Reserve a buffer of 1196k (maximum page size) statically by&n;    atari_stram_alloc(). The data are collected there until they&squot;re complete,&n;&t;and then printing starts. Since the buffer is reserved, no further&n;&t;considerations about memory and swapping are needed. So this is the&n;&t;simplest method, but it needs a lot of memory for just the SLM.&n;&n;    An striking advantage of this method is (supposed the SLM_CONT_CNT_REPROG&n;&t;method works, see there), that there are no timing problems with the DMA&n;&t;anymore.&n;&t;&n; 2) The other method would be to reserve the buffer dynamically each time&n;    printing is required. I could think of looking at mem_map where the&n;&t;largest unallocted ST-RAM area is, taking the area, and then extending it&n;&t;by swapping out the neighbored pages, until the needed size is reached.&n;&t;This requires some mm hacking, but seems possible. The only obstacle could&n;&t;be pages that cannot be swapped out (reserved pages)...&n;&n; 3) Another possibility would be to leave the real data in user space and to&n;    work with two dribble buffers of about 32k in the driver: While the one&n;&t;buffer is DMAed to the SLM, the other can be filled with new data. But&n;&t;to keep the timing, that requires that the user data remain in memory and&n;&t;are not swapped out. Requires mm hacking, too, but maybe not so bad as&n;&t;method 2).&n;&n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/time.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/atarihw.h&gt;
macro_line|#include &lt;asm/atariints.h&gt;
macro_line|#include &lt;asm/atari_acsi.h&gt;
macro_line|#include &lt;asm/atari_stdma.h&gt;
macro_line|#include &lt;asm/atari_stram.h&gt;
macro_line|#include &lt;asm/atari_SLM.h&gt;
DECL|macro|DEBUG
macro_line|#undef&t;DEBUG
multiline_comment|/* Define this if the page data are continuous in physical memory. That&n; * requires less reprogramming of the ST-DMA */
DECL|macro|SLM_CONTINUOUS_DMA
mdefine_line|#define&t;SLM_CONTINUOUS_DMA
multiline_comment|/* Use continuous reprogramming of the ST-DMA counter register. This is&n; * --strictly speaking-- not allowed, Atari recommends not to look at the&n; * counter register while a DMA is going on. But I don&squot;t know if that applies&n; * only for reading the register, or also writing to it. Writing only works&n; * fine for me... The advantage is that the timing becomes absolutely&n; * uncritical: Just update each, say 200ms, the counter reg to its maximum,&n; * and the DMA will work until the status byte interrupt occurs.&n; */
DECL|macro|SLM_CONT_CNT_REPROG
mdefine_line|#define&t;SLM_CONT_CNT_REPROG
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR ACSI_MAJOR
DECL|macro|CMDSET_TARG_LUN
mdefine_line|#define CMDSET_TARG_LUN(cmd,targ,lun)&t;&t;&t;&bslash;&n;    do {&t;&t;&t;&t;&t;&t;&t;&t;&t;&t;&bslash;&n;&t;&t;cmd[0] = (cmd[0] &amp; ~0xe0) | (targ)&lt;&lt;5;&t;&bslash;&n;&t;&t;cmd[1] = (cmd[1] &amp; ~0xe0) | (lun)&lt;&lt;5;&t;&bslash;&n;&t;} while(0)
DECL|macro|START_TIMER
mdefine_line|#define&t;START_TIMER(to)&t;mod_timer(&amp;slm_timer, jiffies + (to))
DECL|macro|STOP_TIMER
mdefine_line|#define&t;STOP_TIMER()&t;del_timer(&amp;slm_timer)
DECL|variable|slmreqsense_cmd
r_static
r_char
id|slmreqsense_cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x03
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|slmprint_cmd
r_static
r_char
id|slmprint_cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x0a
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|slminquiry_cmd
r_static
r_char
id|slminquiry_cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x12
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x80
)brace
suffix:semicolon
DECL|variable|slmmsense_cmd
r_static
r_char
id|slmmsense_cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x1a
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|255
comma
l_int|0
)brace
suffix:semicolon
macro_line|#if 0
r_static
r_char
id|slmmselect_cmd
(braket
l_int|6
)braket
op_assign
(brace
l_int|0x15
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
macro_line|#endif
DECL|macro|MAX_SLM
mdefine_line|#define&t;MAX_SLM&t;&t;2
DECL|struct|slm
r_static
r_struct
id|slm
(brace
DECL|member|target
r_int
id|target
suffix:semicolon
multiline_comment|/* target number */
DECL|member|lun
r_int
id|lun
suffix:semicolon
multiline_comment|/* LUN in target controller */
DECL|member|wbusy
r_int
id|wbusy
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* output part busy */
DECL|member|rbusy
r_int
id|rbusy
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* status part busy */
DECL|variable|slm_info
)brace
id|slm_info
(braket
id|MAX_SLM
)braket
suffix:semicolon
DECL|variable|N_SLM_Printers
r_int
id|N_SLM_Printers
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* printer buffer */
DECL|variable|SLMBuffer
r_static
r_int
r_char
op_star
id|SLMBuffer
suffix:semicolon
multiline_comment|/* start of buffer */
DECL|variable|BufferP
r_static
r_int
r_char
op_star
id|BufferP
suffix:semicolon
multiline_comment|/* current position in buffer */
DECL|variable|BufferSize
r_static
r_int
id|BufferSize
suffix:semicolon
multiline_comment|/* length of buffer for page size */
DECL|enumerator|IDLE
DECL|enumerator|FILLING
DECL|enumerator|PRINTING
DECL|typedef|SLMSTATE
r_typedef
r_enum
(brace
id|IDLE
comma
id|FILLING
comma
id|PRINTING
)brace
id|SLMSTATE
suffix:semicolon
DECL|variable|SLMState
r_static
id|SLMSTATE
id|SLMState
suffix:semicolon
DECL|variable|SLMBufOwner
r_static
r_int
id|SLMBufOwner
suffix:semicolon
multiline_comment|/* SLM# currently using the buffer */
multiline_comment|/* DMA variables */
macro_line|#ifndef SLM_CONT_CNT_REPROG
DECL|variable|SLMCurAddr
r_static
r_int
r_int
id|SLMCurAddr
suffix:semicolon
multiline_comment|/* current base addr of DMA chunk */
DECL|variable|SLMEndAddr
r_static
r_int
r_int
id|SLMEndAddr
suffix:semicolon
multiline_comment|/* expected end addr */
DECL|variable|SLMSliceSize
r_static
r_int
r_int
id|SLMSliceSize
suffix:semicolon
multiline_comment|/* size of one DMA chunk */
macro_line|#endif
DECL|variable|SLMError
r_static
r_int
id|SLMError
suffix:semicolon
multiline_comment|/* wait queues */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|slm_wait
)paren
suffix:semicolon
multiline_comment|/* waiting for buffer */
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|print_wait
)paren
suffix:semicolon
multiline_comment|/* waiting for printing finished */
multiline_comment|/* status codes */
DECL|macro|SLMSTAT_OK
mdefine_line|#define&t;SLMSTAT_OK&t;&t;0x00
DECL|macro|SLMSTAT_ORNERY
mdefine_line|#define&t;SLMSTAT_ORNERY&t;0x02
DECL|macro|SLMSTAT_TONER
mdefine_line|#define&t;SLMSTAT_TONER&t;0x03
DECL|macro|SLMSTAT_WARMUP
mdefine_line|#define&t;SLMSTAT_WARMUP&t;0x04
DECL|macro|SLMSTAT_PAPER
mdefine_line|#define&t;SLMSTAT_PAPER&t;0x05
DECL|macro|SLMSTAT_DRUM
mdefine_line|#define&t;SLMSTAT_DRUM&t;0x06
DECL|macro|SLMSTAT_INJAM
mdefine_line|#define&t;SLMSTAT_INJAM&t;0x07
DECL|macro|SLMSTAT_THRJAM
mdefine_line|#define&t;SLMSTAT_THRJAM&t;0x08
DECL|macro|SLMSTAT_OUTJAM
mdefine_line|#define&t;SLMSTAT_OUTJAM&t;0x09
DECL|macro|SLMSTAT_COVER
mdefine_line|#define&t;SLMSTAT_COVER&t;0x0a
DECL|macro|SLMSTAT_FUSER
mdefine_line|#define&t;SLMSTAT_FUSER&t;0x0b
DECL|macro|SLMSTAT_IMAGER
mdefine_line|#define&t;SLMSTAT_IMAGER&t;0x0c
DECL|macro|SLMSTAT_MOTOR
mdefine_line|#define&t;SLMSTAT_MOTOR&t;0x0d
DECL|macro|SLMSTAT_VIDEO
mdefine_line|#define&t;SLMSTAT_VIDEO&t;0x0e
DECL|macro|SLMSTAT_SYSTO
mdefine_line|#define&t;SLMSTAT_SYSTO&t;0x10
DECL|macro|SLMSTAT_OPCODE
mdefine_line|#define&t;SLMSTAT_OPCODE&t;0x12
DECL|macro|SLMSTAT_DEVNUM
mdefine_line|#define&t;SLMSTAT_DEVNUM&t;0x15
DECL|macro|SLMSTAT_PARAM
mdefine_line|#define&t;SLMSTAT_PARAM&t;0x1a
DECL|macro|SLMSTAT_ACSITO
mdefine_line|#define&t;SLMSTAT_ACSITO&t;0x1b&t;/* driver defined */
DECL|macro|SLMSTAT_NOTALL
mdefine_line|#define&t;SLMSTAT_NOTALL&t;0x1c&t;/* driver defined */
DECL|variable|SLMErrors
r_static
r_char
op_star
id|SLMErrors
(braket
)braket
op_assign
(brace
multiline_comment|/* 0x00 */
l_string|&quot;OK and ready&quot;
comma
multiline_comment|/* 0x01 */
l_int|NULL
comma
multiline_comment|/* 0x02 */
l_string|&quot;ornery printer&quot;
comma
multiline_comment|/* 0x03 */
l_string|&quot;toner empty&quot;
comma
multiline_comment|/* 0x04 */
l_string|&quot;warming up&quot;
comma
multiline_comment|/* 0x05 */
l_string|&quot;paper empty&quot;
comma
multiline_comment|/* 0x06 */
l_string|&quot;drum empty&quot;
comma
multiline_comment|/* 0x07 */
l_string|&quot;input jam&quot;
comma
multiline_comment|/* 0x08 */
l_string|&quot;through jam&quot;
comma
multiline_comment|/* 0x09 */
l_string|&quot;output jam&quot;
comma
multiline_comment|/* 0x0a */
l_string|&quot;cover open&quot;
comma
multiline_comment|/* 0x0b */
l_string|&quot;fuser malfunction&quot;
comma
multiline_comment|/* 0x0c */
l_string|&quot;imager malfunction&quot;
comma
multiline_comment|/* 0x0d */
l_string|&quot;motor malfunction&quot;
comma
multiline_comment|/* 0x0e */
l_string|&quot;video malfunction&quot;
comma
multiline_comment|/* 0x0f */
l_int|NULL
comma
multiline_comment|/* 0x10 */
l_string|&quot;printer system timeout&quot;
comma
multiline_comment|/* 0x11 */
l_int|NULL
comma
multiline_comment|/* 0x12 */
l_string|&quot;invalid operation code&quot;
comma
multiline_comment|/* 0x13 */
l_int|NULL
comma
multiline_comment|/* 0x14 */
l_int|NULL
comma
multiline_comment|/* 0x15 */
l_string|&quot;invalid device number&quot;
comma
multiline_comment|/* 0x16 */
l_int|NULL
comma
multiline_comment|/* 0x17 */
l_int|NULL
comma
multiline_comment|/* 0x18 */
l_int|NULL
comma
multiline_comment|/* 0x19 */
l_int|NULL
comma
multiline_comment|/* 0x1a */
l_string|&quot;invalid parameter list&quot;
comma
multiline_comment|/* 0x1b */
l_string|&quot;ACSI timeout&quot;
comma
multiline_comment|/* 0x1c */
l_string|&quot;not all printed&quot;
)brace
suffix:semicolon
DECL|macro|N_ERRORS
mdefine_line|#define&t;N_ERRORS&t;(sizeof(SLMErrors)/sizeof(*SLMErrors))
multiline_comment|/* real (driver caused) error? */
DECL|macro|IS_REAL_ERROR
mdefine_line|#define&t;IS_REAL_ERROR(x)&t;(x &gt; 0x10)
r_static
r_struct
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|w
DECL|member|h
r_int
id|w
comma
id|h
suffix:semicolon
DECL|variable|StdPageSize
)brace
id|StdPageSize
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;Letter&quot;
comma
l_int|2400
comma
l_int|3180
)brace
comma
(brace
l_string|&quot;Legal&quot;
comma
l_int|2400
comma
l_int|4080
)brace
comma
(brace
l_string|&quot;A4&quot;
comma
l_int|2336
comma
l_int|3386
)brace
comma
(brace
l_string|&quot;B5&quot;
comma
l_int|2016
comma
l_int|2914
)brace
)brace
suffix:semicolon
DECL|macro|N_STD_SIZES
mdefine_line|#define&t;N_STD_SIZES&t;&t;(sizeof(StdPageSize)/sizeof(*StdPageSize))
DECL|macro|SLM_BUFFER_SIZE
mdefine_line|#define&t;SLM_BUFFER_SIZE&t;(2336*3386/8)&t;/* A4 for now */
DECL|macro|SLM_DMA_AMOUNT
mdefine_line|#define&t;SLM_DMA_AMOUNT&t;255&t;&t;&t;&t;/* #sectors to program the DMA for */
macro_line|#ifdef&t;SLM_CONTINUOUS_DMA
DECL|macro|SLM_DMA_INT_OFFSET
macro_line|# define&t;SLM_DMA_INT_OFFSET&t;0&t;&t;/* DMA goes until seccnt 0, no offs */
DECL|macro|SLM_DMA_END_OFFSET
macro_line|# define&t;SLM_DMA_END_OFFSET&t;32&t;&t;/* 32 Byte ST-DMA FIFO */
DECL|macro|SLM_SLICE_SIZE
macro_line|# define&t;SLM_SLICE_SIZE(w) &t;(255*512)
macro_line|#else
DECL|macro|SLM_DMA_INT_OFFSET
macro_line|# define&t;SLM_DMA_INT_OFFSET&t;32&t;&t;/* 32 Byte ST-DMA FIFO */
DECL|macro|SLM_DMA_END_OFFSET
macro_line|# define&t;SLM_DMA_END_OFFSET&t;32&t;&t;/* 32 Byte ST-DMA FIFO */
DECL|macro|SLM_SLICE_SIZE
macro_line|# define&t;SLM_SLICE_SIZE(w)&t;((254*512)/(w/8)*(w/8))
macro_line|#endif
multiline_comment|/* calculate the number of jiffies to wait for &squot;n&squot; bytes */
macro_line|#ifdef SLM_CONT_CNT_REPROG
DECL|macro|DMA_TIME_FOR
mdefine_line|#define&t;DMA_TIME_FOR(n)&t;&t;50
DECL|macro|DMA_STARTUP_TIME
mdefine_line|#define&t;DMA_STARTUP_TIME&t;0
macro_line|#else
DECL|macro|DMA_TIME_FOR
mdefine_line|#define&t;DMA_TIME_FOR(n)&t;&t;(n/1400-1)
DECL|macro|DMA_STARTUP_TIME
mdefine_line|#define&t;DMA_STARTUP_TIME&t;650
macro_line|#endif
multiline_comment|/***************************** Prototypes *****************************/
r_static
r_char
op_star
id|slm_errstr
c_func
(paren
r_int
id|stat
)paren
suffix:semicolon
r_static
r_int
id|slm_getstats
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|device
)paren
suffix:semicolon
r_static
id|ssize_t
id|slm_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
r_void
id|start_print
c_func
(paren
r_int
id|device
)paren
suffix:semicolon
r_static
r_void
id|slm_interrupt
c_func
(paren
r_int
id|irc
comma
r_void
op_star
id|data
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
suffix:semicolon
r_static
r_void
id|slm_test_ready
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
r_static
r_void
id|set_dma_addr
c_func
(paren
r_int
r_int
id|paddr
)paren
suffix:semicolon
r_static
r_int
r_int
id|get_dma_addr
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
id|ssize_t
id|slm_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
r_int
id|slm_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|slm_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|slm_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|slm_req_sense
c_func
(paren
r_int
id|device
)paren
suffix:semicolon
r_static
r_int
id|slm_mode_sense
c_func
(paren
r_int
id|device
comma
r_char
op_star
id|buffer
comma
r_int
id|abs_flag
)paren
suffix:semicolon
macro_line|#if 0
r_static
r_int
id|slm_mode_select
c_func
(paren
r_int
id|device
comma
r_char
op_star
id|buffer
comma
r_int
id|len
comma
r_int
id|default_flag
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|slm_get_pagesize
c_func
(paren
r_int
id|device
comma
r_int
op_star
id|w
comma
r_int
op_star
id|h
)paren
suffix:semicolon
multiline_comment|/************************* End of Prototypes **************************/
DECL|variable|slm_timer
r_static
r_struct
id|timer_list
id|slm_timer
op_assign
(brace
id|function
suffix:colon
id|slm_test_ready
)brace
suffix:semicolon
DECL|variable|slm_fops
r_static
r_struct
id|file_operations
id|slm_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|read
suffix:colon
id|slm_read
comma
id|write
suffix:colon
id|slm_write
comma
id|ioctl
suffix:colon
id|slm_ioctl
comma
id|open
suffix:colon
id|slm_open
comma
id|release
suffix:colon
id|slm_release
comma
)brace
suffix:semicolon
multiline_comment|/* ---------------------------------------------------------------------- */
multiline_comment|/*&t;&t;&t;&t;&t;&t;&t;   Status Functions&t;&t;&t;&t;&t;&t;&t;  */
DECL|function|slm_errstr
r_static
r_char
op_star
id|slm_errstr
c_func
(paren
r_int
id|stat
)paren
(brace
r_char
op_star
id|p
suffix:semicolon
r_static
r_char
id|str
(braket
l_int|22
)braket
suffix:semicolon
id|stat
op_and_assign
l_int|0x1f
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_ge
l_int|0
op_logical_and
id|stat
OL
id|N_ERRORS
op_logical_and
(paren
id|p
op_assign
id|SLMErrors
(braket
id|stat
)braket
)paren
)paren
r_return
id|p
suffix:semicolon
id|sprintf
c_func
(paren
id|str
comma
l_string|&quot;unknown status 0x%02x&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
id|str
suffix:semicolon
)brace
DECL|function|slm_getstats
r_static
r_int
id|slm_getstats
c_func
(paren
r_char
op_star
id|buffer
comma
r_int
id|device
)paren
(brace
r_int
id|len
op_assign
l_int|0
comma
id|stat
comma
id|i
comma
id|w
comma
id|h
suffix:semicolon
r_int
r_char
id|buf
(braket
l_int|256
)braket
suffix:semicolon
id|stat
op_assign
id|slm_mode_sense
c_func
(paren
id|device
comma
id|buf
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IS_REAL_ERROR
c_func
(paren
id|stat
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
DECL|macro|SHORTDATA
mdefine_line|#define SHORTDATA(i)&t;&t;((buf[i] &lt;&lt; 8) | buf[i+1])
DECL|macro|BOOLDATA
mdefine_line|#define&t;BOOLDATA(i,mask)&t;((buf[i] &amp; mask) ? &quot;on&quot; : &quot;off&quot;)
id|w
op_assign
id|SHORTDATA
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|h
op_assign
id|SHORTDATA
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Status&bslash;t&bslash;t%s&bslash;n&quot;
comma
id|slm_errstr
c_func
(paren
id|stat
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Page Size&bslash;t%dx%d&quot;
comma
id|w
comma
id|h
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_STD_SIZES
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|w
op_eq
id|StdPageSize
(braket
id|i
)braket
dot
id|w
op_logical_and
id|h
op_eq
id|StdPageSize
(braket
id|i
)braket
dot
id|h
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
OL
id|N_STD_SIZES
)paren
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot; (%s)&quot;
comma
id|StdPageSize
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|buffer
(braket
id|len
op_increment
)braket
op_assign
l_char|&squot;&bslash;n&squot;
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Top/Left Margin&bslash;t%d/%d&bslash;n&quot;
comma
id|SHORTDATA
c_func
(paren
l_int|5
)paren
comma
id|SHORTDATA
c_func
(paren
l_int|7
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Manual Feed&bslash;t%s&bslash;n&quot;
comma
id|BOOLDATA
c_func
(paren
l_int|9
comma
l_int|0x01
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Input Select&bslash;t%d&bslash;n&quot;
comma
(paren
id|buf
(braket
l_int|9
)braket
op_rshift
l_int|1
)paren
op_amp
l_int|7
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Auto Select&bslash;t%s&bslash;n&quot;
comma
id|BOOLDATA
c_func
(paren
l_int|9
comma
l_int|0x10
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Prefeed Paper&bslash;t%s&bslash;n&quot;
comma
id|BOOLDATA
c_func
(paren
l_int|9
comma
l_int|0x20
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Thick Pixels&bslash;t%s&bslash;n&quot;
comma
id|BOOLDATA
c_func
(paren
l_int|9
comma
l_int|0x40
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;H/V Resol.&bslash;t%d/%d dpi&bslash;n&quot;
comma
id|SHORTDATA
c_func
(paren
l_int|12
)paren
comma
id|SHORTDATA
c_func
(paren
l_int|10
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;System Timeout&bslash;t%d&bslash;n&quot;
comma
id|buf
(braket
l_int|14
)braket
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Scan Time&bslash;t%d&bslash;n&quot;
comma
id|SHORTDATA
c_func
(paren
l_int|15
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Page Count&bslash;t%d&bslash;n&quot;
comma
id|SHORTDATA
c_func
(paren
l_int|17
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;In/Out Cap.&bslash;t%d/%d&bslash;n&quot;
comma
id|SHORTDATA
c_func
(paren
l_int|19
)paren
comma
id|SHORTDATA
c_func
(paren
l_int|21
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Stagger Output&bslash;t%s&bslash;n&quot;
comma
id|BOOLDATA
c_func
(paren
l_int|23
comma
l_int|0x01
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Output Select&bslash;t%d&bslash;n&quot;
comma
(paren
id|buf
(braket
l_int|23
)braket
op_rshift
l_int|1
)paren
op_amp
l_int|7
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Duplex Print&bslash;t%s&bslash;n&quot;
comma
id|BOOLDATA
c_func
(paren
l_int|23
comma
l_int|0x10
)paren
)paren
suffix:semicolon
id|len
op_add_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;Color Sep.&bslash;t%s&bslash;n&quot;
comma
id|BOOLDATA
c_func
(paren
l_int|23
comma
l_int|0x20
)paren
)paren
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
DECL|function|slm_read
r_static
id|ssize_t
id|slm_read
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|inode
op_star
id|node
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
r_int
id|page
suffix:semicolon
r_int
id|length
suffix:semicolon
r_int
id|end
suffix:semicolon
r_if
c_cond
(paren
id|count
OL
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|page
op_assign
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
)paren
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|length
op_assign
id|slm_getstats
c_func
(paren
(paren
r_char
op_star
)paren
id|page
comma
id|MINOR
c_func
(paren
id|node-&gt;i_rdev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|length
OL
l_int|0
)paren
(brace
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
id|length
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_pos
op_ge
id|length
)paren
(brace
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_plus
id|file-&gt;f_pos
OG
id|length
)paren
id|count
op_assign
id|length
op_minus
id|file-&gt;f_pos
suffix:semicolon
id|end
op_assign
id|count
op_plus
id|file-&gt;f_pos
suffix:semicolon
id|copy_to_user
c_func
(paren
id|buf
comma
(paren
r_char
op_star
)paren
id|page
op_plus
id|file-&gt;f_pos
comma
id|count
)paren
suffix:semicolon
id|free_page
c_func
(paren
id|page
)paren
suffix:semicolon
id|file-&gt;f_pos
op_assign
id|end
suffix:semicolon
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------------------- */
multiline_comment|/*&t;&t;&t;&t;&t;&t;&t;&t;   Printing&t;&t;&t;&t;&t;&t;&t;&t;  */
DECL|function|start_print
r_static
r_void
id|start_print
c_func
(paren
r_int
id|device
)paren
(brace
r_struct
id|slm
op_star
id|sip
op_assign
op_amp
id|slm_info
(braket
id|device
)braket
suffix:semicolon
r_int
r_char
op_star
id|cmd
suffix:semicolon
r_int
r_int
id|paddr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|stdma_lock
c_func
(paren
id|slm_interrupt
comma
l_int|NULL
)paren
suffix:semicolon
id|CMDSET_TARG_LUN
c_func
(paren
id|slmprint_cmd
comma
id|sip-&gt;target
comma
id|sip-&gt;lun
)paren
suffix:semicolon
id|cmd
op_assign
id|slmprint_cmd
suffix:semicolon
id|paddr
op_assign
id|virt_to_phys
c_func
(paren
id|SLMBuffer
)paren
suffix:semicolon
id|dma_cache_maintenance
c_func
(paren
id|paddr
comma
id|virt_to_phys
c_func
(paren
id|BufferP
)paren
op_minus
id|paddr
comma
l_int|1
)paren
suffix:semicolon
id|DISABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Low on A1 */
id|dma_wd.dma_mode_status
op_assign
l_int|0x88
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* send the command bytes except the last */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
op_increment
id|i
)paren
(brace
id|DMA_LONG_WRITE
c_func
(paren
op_star
id|cmd
op_increment
comma
l_int|0x8a
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsi_wait_for_IRQ
c_func
(paren
id|HZ
op_div
l_int|2
)paren
)paren
(brace
id|SLMError
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* timeout */
)brace
)brace
multiline_comment|/* last command byte */
id|DMA_LONG_WRITE
c_func
(paren
op_star
id|cmd
op_increment
comma
l_int|0x82
)paren
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set DMA address */
id|set_dma_addr
c_func
(paren
id|paddr
)paren
suffix:semicolon
multiline_comment|/* program DMA for write and select sector counter reg */
id|dma_wd.dma_mode_status
op_assign
l_int|0x192
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* program for 255*512 bytes and start DMA */
id|DMA_LONG_WRITE
c_func
(paren
id|SLM_DMA_AMOUNT
comma
l_int|0x112
)paren
suffix:semicolon
macro_line|#ifndef SLM_CONT_CNT_REPROG
id|SLMCurAddr
op_assign
id|paddr
suffix:semicolon
id|SLMEndAddr
op_assign
id|paddr
op_plus
id|SLMSliceSize
op_plus
id|SLM_DMA_INT_OFFSET
suffix:semicolon
macro_line|#endif
id|START_TIMER
c_func
(paren
id|DMA_STARTUP_TIME
op_plus
id|DMA_TIME_FOR
c_func
(paren
id|SLMSliceSize
)paren
)paren
suffix:semicolon
macro_line|#if !defined(SLM_CONT_CNT_REPROG) &amp;&amp; defined(DEBUG)
id|printk
c_func
(paren
l_string|&quot;SLM: CurAddr=%#lx EndAddr=%#lx timer=%ld&bslash;n&quot;
comma
id|SLMCurAddr
comma
id|SLMEndAddr
comma
id|DMA_TIME_FOR
c_func
(paren
id|SLMSliceSize
)paren
)paren
suffix:semicolon
macro_line|#endif
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Only called when an error happened or at the end of a page */
DECL|function|slm_interrupt
r_static
r_void
id|slm_interrupt
c_func
(paren
r_int
id|irc
comma
r_void
op_star
id|data
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|STOP_TIMER
c_func
(paren
)paren
suffix:semicolon
id|addr
op_assign
id|get_dma_addr
c_func
(paren
)paren
suffix:semicolon
id|stat
op_assign
id|acsi_getstatus
c_func
(paren
)paren
suffix:semicolon
id|SLMError
op_assign
(paren
id|stat
OL
l_int|0
)paren
ques
c_cond
id|SLMSTAT_ACSITO
suffix:colon
(paren
id|addr
OL
id|virt_to_phys
c_func
(paren
id|BufferP
)paren
)paren
ques
c_cond
id|SLMSTAT_NOTALL
suffix:colon
id|stat
suffix:semicolon
id|dma_wd.dma_mode_status
op_assign
l_int|0x80
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SLM: interrupt, addr=%#lx, error=%d&bslash;n&quot;
comma
id|addr
comma
id|SLMError
)paren
suffix:semicolon
macro_line|#endif
id|wake_up
c_func
(paren
op_amp
id|print_wait
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|slm_test_ready
r_static
r_void
id|slm_test_ready
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
macro_line|#ifdef SLM_CONT_CNT_REPROG
multiline_comment|/* program for 255*512 bytes again */
id|dma_wd.fdc_acces_seccount
op_assign
id|SLM_DMA_AMOUNT
suffix:semicolon
id|START_TIMER
c_func
(paren
id|DMA_TIME_FOR
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SLM: reprogramming timer for %d jiffies, addr=%#lx&bslash;n&quot;
comma
id|DMA_TIME_FOR
c_func
(paren
l_int|0
)paren
comma
id|get_dma_addr
c_func
(paren
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#else /* !SLM_CONT_CNT_REPROG */
r_int
r_int
id|flags
comma
id|addr
suffix:semicolon
r_int
id|d
comma
id|ti
suffix:semicolon
macro_line|#ifdef DEBUG
r_struct
id|timeval
id|start_tm
comma
id|end_tm
suffix:semicolon
r_int
id|did_wait
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|addr
op_assign
id|get_dma_addr
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|d
op_assign
id|SLMEndAddr
op_minus
id|addr
)paren
OG
l_int|0
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* slice not yet finished, decide whether to start another timer or to&n;&t;&t; * busy-wait */
id|ti
op_assign
id|DMA_TIME_FOR
c_func
(paren
id|d
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ti
OG
l_int|0
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SLM: reprogramming timer for %d jiffies, rest %d bytes&bslash;n&quot;
comma
id|ti
comma
id|d
)paren
suffix:semicolon
macro_line|#endif
id|START_TIMER
c_func
(paren
id|ti
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* wait for desired end address to be reached */
macro_line|#ifdef DEBUG
id|do_gettimeofday
c_func
(paren
op_amp
id|start_tm
)paren
suffix:semicolon
id|did_wait
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|get_dma_addr
c_func
(paren
)paren
OL
id|SLMEndAddr
)paren
(brace
id|barrier
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* slice finished, start next one */
id|SLMCurAddr
op_add_assign
id|SLMSliceSize
suffix:semicolon
macro_line|#ifdef SLM_CONTINUOUS_DMA
multiline_comment|/* program for 255*512 bytes again */
id|dma_wd.fdc_acces_seccount
op_assign
id|SLM_DMA_AMOUNT
suffix:semicolon
macro_line|#else
multiline_comment|/* set DMA address;&n;&t; * add 2 bytes for the ones in the SLM controller FIFO! */
id|set_dma_addr
c_func
(paren
id|SLMCurAddr
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* toggle DMA to write and select sector counter reg */
id|dma_wd.dma_mode_status
op_assign
l_int|0x92
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|dma_wd.dma_mode_status
op_assign
l_int|0x192
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* program for 255*512 bytes and start DMA */
id|DMA_LONG_WRITE
c_func
(paren
id|SLM_DMA_AMOUNT
comma
l_int|0x112
)paren
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|did_wait
)paren
(brace
r_int
id|ms
suffix:semicolon
id|do_gettimeofday
c_func
(paren
op_amp
id|end_tm
)paren
suffix:semicolon
id|ms
op_assign
(paren
id|end_tm.tv_sec
op_star
l_int|1000000
op_plus
id|end_tm.tv_usec
)paren
op_minus
(paren
id|start_tm.tv_sec
op_star
l_int|1000000
op_plus
id|start_tm.tv_usec
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;SLM: did %ld.%ld ms busy waiting for %d bytes&bslash;n&quot;
comma
id|ms
op_div
l_int|1000
comma
id|ms
op_mod
l_int|1000
comma
id|d
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;SLM: didn&squot;t wait (!)&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
r_int
r_char
op_star
)paren
id|PTOV
c_func
(paren
id|SLMCurAddr
op_plus
id|SLMSliceSize
)paren
op_ge
id|BufferP
)paren
(brace
multiline_comment|/* will be last slice, no timer necessary */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SLM: CurAddr=%#lx EndAddr=%#lx last slice -&gt; no timer&bslash;n&quot;
comma
id|SLMCurAddr
comma
id|SLMEndAddr
)paren
suffix:semicolon
macro_line|#endif
)brace
r_else
(brace
multiline_comment|/* not last slice */
id|SLMEndAddr
op_assign
id|SLMCurAddr
op_plus
id|SLMSliceSize
op_plus
id|SLM_DMA_INT_OFFSET
suffix:semicolon
id|START_TIMER
c_func
(paren
id|DMA_TIME_FOR
c_func
(paren
id|SLMSliceSize
)paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;SLM: CurAddr=%#lx EndAddr=%#lx timer=%ld&bslash;n&quot;
comma
id|SLMCurAddr
comma
id|SLMEndAddr
comma
id|DMA_TIME_FOR
c_func
(paren
id|SLMSliceSize
)paren
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#endif /* SLM_CONT_CNT_REPROG */
)brace
DECL|function|set_dma_addr
r_static
r_void
id|set_dma_addr
c_func
(paren
r_int
r_int
id|paddr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dma_wd.dma_lo
op_assign
(paren
r_int
r_char
)paren
id|paddr
suffix:semicolon
id|paddr
op_rshift_assign
l_int|8
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|dma_wd.dma_md
op_assign
(paren
r_int
r_char
)paren
id|paddr
suffix:semicolon
id|paddr
op_rshift_assign
l_int|8
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|EXTD_DMA
)paren
)paren
id|st_dma_ext_dmahi
op_assign
(paren
r_int
r_int
)paren
id|paddr
suffix:semicolon
r_else
id|dma_wd.dma_hi
op_assign
(paren
r_int
r_char
)paren
id|paddr
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|get_dma_addr
r_static
r_int
r_int
id|get_dma_addr
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|addr
suffix:semicolon
id|addr
op_assign
id|dma_wd.dma_lo
op_amp
l_int|0xff
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|addr
op_or_assign
(paren
id|dma_wd.dma_md
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|addr
op_or_assign
(paren
id|dma_wd.dma_hi
op_amp
l_int|0xff
)paren
op_lshift
l_int|16
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
r_return
id|addr
suffix:semicolon
)brace
DECL|function|slm_write
r_static
id|ssize_t
id|slm_write
c_func
(paren
r_struct
id|file
op_star
id|file
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|inode
op_star
id|node
op_assign
id|file-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
id|device
op_assign
id|MINOR
c_func
(paren
id|node-&gt;i_rdev
)paren
suffix:semicolon
r_int
id|n
comma
id|filled
comma
id|w
comma
id|h
suffix:semicolon
r_while
c_loop
(paren
id|SLMState
op_eq
id|PRINTING
op_logical_or
(paren
id|SLMState
op_eq
id|FILLING
op_logical_and
id|SLMBufOwner
op_ne
id|device
)paren
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|slm_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
r_return
op_minus
id|ERESTARTSYS
suffix:semicolon
)brace
r_if
c_cond
(paren
id|SLMState
op_eq
id|IDLE
)paren
(brace
multiline_comment|/* first data of page: get current page size  */
r_if
c_cond
(paren
id|slm_get_pagesize
c_func
(paren
id|device
comma
op_amp
id|w
comma
op_amp
id|h
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|BufferSize
op_assign
id|w
op_star
id|h
op_div
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|BufferSize
OG
id|SLM_BUFFER_SIZE
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|SLMState
op_assign
id|FILLING
suffix:semicolon
id|SLMBufOwner
op_assign
id|device
suffix:semicolon
)brace
id|n
op_assign
id|count
suffix:semicolon
id|filled
op_assign
id|BufferP
op_minus
id|SLMBuffer
suffix:semicolon
r_if
c_cond
(paren
id|filled
op_plus
id|n
OG
id|BufferSize
)paren
id|n
op_assign
id|BufferSize
op_minus
id|filled
suffix:semicolon
id|copy_from_user
c_func
(paren
id|BufferP
comma
id|buf
comma
id|n
)paren
suffix:semicolon
id|BufferP
op_add_assign
id|n
suffix:semicolon
id|filled
op_add_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|filled
op_eq
id|BufferSize
)paren
(brace
multiline_comment|/* Check the paper size again! The user may have switched it in the&n;&t;&t; * time between starting the data and finishing them. Would end up in&n;&t;&t; * a trashy page... */
r_if
c_cond
(paren
id|slm_get_pagesize
c_func
(paren
id|device
comma
op_amp
id|w
comma
op_amp
id|h
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|BufferSize
op_ne
id|w
op_star
id|h
op_div
l_int|8
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;slm%d: page size changed while printing&bslash;n&quot;
comma
id|device
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
id|SLMState
op_assign
id|PRINTING
suffix:semicolon
multiline_comment|/* choose a slice size that is a multiple of the line size */
macro_line|#ifndef SLM_CONT_CNT_REPROG
id|SLMSliceSize
op_assign
id|SLM_SLICE_SIZE
c_func
(paren
id|w
)paren
suffix:semicolon
macro_line|#endif
id|start_print
c_func
(paren
id|device
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|print_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SLMError
op_logical_and
id|IS_REAL_ERROR
c_func
(paren
id|SLMError
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;slm%d: %s&bslash;n&quot;
comma
id|device
comma
id|slm_errstr
c_func
(paren
id|SLMError
)paren
)paren
suffix:semicolon
id|n
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
id|SLMState
op_assign
id|IDLE
suffix:semicolon
id|BufferP
op_assign
id|SLMBuffer
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|slm_wait
)paren
suffix:semicolon
)brace
r_return
id|n
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------------------- */
multiline_comment|/*&t;&t;&t;&t;&t;&t;&t;   ioctl Functions&t;&t;&t;&t;&t;&t;&t;  */
DECL|function|slm_ioctl
r_static
r_int
id|slm_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|device
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
comma
id|err
suffix:semicolon
multiline_comment|/* I can think of setting:&n;&t; *  - manual feed&n;&t; *  - paper format&n;&t; *  - copy count&n;&t; *  - ...&n;&t; * but haven&squot;t implemented that yet :-)&n;&t; * BTW, has anybody better docs about the MODE SENSE/MODE SELECT data?&n;&t; */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|SLMIORESET
suffix:colon
multiline_comment|/* reset buffer, i.e. empty the buffer */
r_if
c_cond
(paren
op_logical_neg
(paren
id|file-&gt;f_mode
op_amp
l_int|2
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|SLMState
op_eq
id|PRINTING
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|SLMState
op_assign
id|IDLE
suffix:semicolon
id|BufferP
op_assign
id|SLMBuffer
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|slm_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|SLMIOGSTAT
suffix:colon
(brace
multiline_comment|/* get status */
r_int
id|stat
suffix:semicolon
r_char
op_star
id|str
suffix:semicolon
id|stat
op_assign
id|slm_req_sense
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
(brace
id|str
op_assign
id|slm_errstr
c_func
(paren
id|stat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|stat
comma
(paren
r_int
op_star
)paren
op_amp
(paren
(paren
r_struct
id|SLM_status
op_star
)paren
id|arg
)paren
op_member_access_from_pointer
id|stat
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|copy_to_user
c_func
(paren
(paren
(paren
r_struct
id|SLM_status
op_star
)paren
id|arg
)paren
op_member_access_from_pointer
id|str
comma
id|str
comma
id|strlen
c_func
(paren
id|str
)paren
op_plus
l_int|1
)paren
suffix:semicolon
)brace
r_return
id|stat
suffix:semicolon
)brace
r_case
id|SLMIOGPSIZE
suffix:colon
(brace
multiline_comment|/* get paper size */
r_int
id|w
comma
id|h
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|SLM_paper_size
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|slm_get_pagesize
c_func
(paren
id|device
comma
op_amp
id|w
comma
op_amp
id|h
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|w
comma
(paren
r_int
op_star
)paren
op_amp
(paren
(paren
r_struct
id|SLM_paper_size
op_star
)paren
id|arg
)paren
op_member_access_from_pointer
id|width
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
id|put_user
c_func
(paren
id|h
comma
(paren
r_int
op_star
)paren
op_amp
(paren
(paren
r_struct
id|SLM_paper_size
op_star
)paren
id|arg
)paren
op_member_access_from_pointer
id|height
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|SLMIOGMFEED
suffix:colon
multiline_comment|/* get manual feed */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|SLMIOSPSIZE
suffix:colon
multiline_comment|/* set paper size */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|SLMIOSMFEED
suffix:colon
multiline_comment|/* set manual feed */
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------------------- */
multiline_comment|/*&t;&t;&t;&t;&t;&t;&t; Opening and Closing&t;&t;&t;&t;&t;&t;  */
DECL|function|slm_open
r_static
r_int
id|slm_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|device
suffix:semicolon
r_struct
id|slm
op_star
id|sip
suffix:semicolon
id|device
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
op_ge
id|N_SLM_Printers
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|sip
op_assign
op_amp
id|slm_info
(braket
id|device
)braket
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
l_int|2
)paren
(brace
multiline_comment|/* open for writing is exclusive */
r_if
c_cond
(paren
id|sip-&gt;wbusy
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|sip-&gt;wbusy
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
l_int|1
)paren
(brace
multiline_comment|/* open for writing is exclusive */
r_if
c_cond
(paren
id|sip-&gt;rbusy
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|sip-&gt;rbusy
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|slm_release
r_static
r_int
id|slm_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|device
suffix:semicolon
r_struct
id|slm
op_star
id|sip
suffix:semicolon
id|device
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|sip
op_assign
op_amp
id|slm_info
(braket
id|device
)braket
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
l_int|2
)paren
id|sip-&gt;wbusy
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
l_int|1
)paren
id|sip-&gt;rbusy
op_assign
l_int|0
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------------------- */
multiline_comment|/*&t;&t;&t;&t;&t;&t; ACSI Primitives for the SLM&t;&t;&t;&t;&t;  */
DECL|function|slm_req_sense
r_static
r_int
id|slm_req_sense
c_func
(paren
r_int
id|device
)paren
(brace
r_int
id|stat
comma
id|rv
suffix:semicolon
r_struct
id|slm
op_star
id|sip
op_assign
op_amp
id|slm_info
(braket
id|device
)braket
suffix:semicolon
id|stdma_lock
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|CMDSET_TARG_LUN
c_func
(paren
id|slmreqsense_cmd
comma
id|sip-&gt;target
comma
id|sip-&gt;lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsicmd_nodma
c_func
(paren
id|slmreqsense_cmd
comma
l_int|0
)paren
op_logical_or
(paren
id|stat
op_assign
id|acsi_getstatus
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
id|rv
op_assign
id|SLMSTAT_ACSITO
suffix:semicolon
r_else
id|rv
op_assign
id|stat
op_amp
l_int|0x1f
suffix:semicolon
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
DECL|function|slm_mode_sense
r_static
r_int
id|slm_mode_sense
c_func
(paren
r_int
id|device
comma
r_char
op_star
id|buffer
comma
r_int
id|abs_flag
)paren
(brace
r_int
r_char
id|stat
comma
id|len
suffix:semicolon
r_int
id|rv
op_assign
l_int|0
suffix:semicolon
r_struct
id|slm
op_star
id|sip
op_assign
op_amp
id|slm_info
(braket
id|device
)braket
suffix:semicolon
id|stdma_lock
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|CMDSET_TARG_LUN
c_func
(paren
id|slmmsense_cmd
comma
id|sip-&gt;target
comma
id|sip-&gt;lun
)paren
suffix:semicolon
id|slmmsense_cmd
(braket
l_int|5
)braket
op_assign
id|abs_flag
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsicmd_nodma
c_func
(paren
id|slmmsense_cmd
comma
l_int|0
)paren
)paren
(brace
id|rv
op_assign
id|SLMSTAT_ACSITO
suffix:semicolon
r_goto
id|the_end
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|acsi_extstatus
c_func
(paren
op_amp
id|stat
comma
l_int|1
)paren
)paren
(brace
id|acsi_end_extstatus
c_func
(paren
)paren
suffix:semicolon
id|rv
op_assign
id|SLMSTAT_ACSITO
suffix:semicolon
r_goto
id|the_end
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|acsi_extstatus
c_func
(paren
op_amp
id|len
comma
l_int|1
)paren
)paren
(brace
id|acsi_end_extstatus
c_func
(paren
)paren
suffix:semicolon
id|rv
op_assign
id|SLMSTAT_ACSITO
suffix:semicolon
r_goto
id|the_end
suffix:semicolon
)brace
id|buffer
(braket
l_int|0
)braket
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsi_extstatus
c_func
(paren
id|buffer
op_plus
l_int|1
comma
id|len
)paren
)paren
(brace
id|acsi_end_extstatus
c_func
(paren
)paren
suffix:semicolon
id|rv
op_assign
id|SLMSTAT_ACSITO
suffix:semicolon
r_goto
id|the_end
suffix:semicolon
)brace
id|acsi_end_extstatus
c_func
(paren
)paren
suffix:semicolon
id|rv
op_assign
id|stat
op_amp
l_int|0x1f
suffix:semicolon
id|the_end
suffix:colon
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* currently unused */
r_static
r_int
id|slm_mode_select
c_func
(paren
r_int
id|device
comma
r_char
op_star
id|buffer
comma
r_int
id|len
comma
r_int
id|default_flag
)paren
(brace
r_int
id|stat
comma
id|rv
suffix:semicolon
r_struct
id|slm
op_star
id|sip
op_assign
op_amp
id|slm_info
(braket
id|device
)braket
suffix:semicolon
id|stdma_lock
c_func
(paren
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|CMDSET_TARG_LUN
c_func
(paren
id|slmmselect_cmd
comma
id|sip-&gt;target
comma
id|sip-&gt;lun
)paren
suffix:semicolon
id|slmmselect_cmd
(braket
l_int|5
)braket
op_assign
id|default_flag
ques
c_cond
l_int|0x80
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsicmd_nodma
c_func
(paren
id|slmmselect_cmd
comma
l_int|0
)paren
)paren
(brace
id|rv
op_assign
id|SLMSTAT_ACSITO
suffix:semicolon
r_goto
id|the_end
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|default_flag
)paren
(brace
r_int
r_char
id|c
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsi_extcmd
c_func
(paren
op_amp
id|c
comma
l_int|1
)paren
)paren
(brace
id|rv
op_assign
id|SLMSTAT_ACSITO
suffix:semicolon
r_goto
id|the_end
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|acsi_extcmd
c_func
(paren
id|buffer
comma
id|len
)paren
)paren
(brace
id|rv
op_assign
id|SLMSTAT_ACSITO
suffix:semicolon
r_goto
id|the_end
suffix:semicolon
)brace
)brace
id|stat
op_assign
id|acsi_getstatus
c_func
(paren
)paren
suffix:semicolon
id|rv
op_assign
(paren
id|stat
OL
l_int|0
ques
c_cond
id|SLMSTAT_ACSITO
suffix:colon
id|stat
)paren
suffix:semicolon
id|the_end
suffix:colon
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
r_return
id|rv
suffix:semicolon
)brace
macro_line|#endif
DECL|function|slm_get_pagesize
r_static
r_int
id|slm_get_pagesize
c_func
(paren
r_int
id|device
comma
r_int
op_star
id|w
comma
r_int
op_star
id|h
)paren
(brace
r_char
id|buf
(braket
l_int|256
)braket
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|slm_mode_sense
c_func
(paren
id|device
comma
id|buf
comma
l_int|0
)paren
suffix:semicolon
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_ne
id|SLMSTAT_OK
)paren
r_return
op_minus
id|EIO
suffix:semicolon
op_star
id|w
op_assign
(paren
id|buf
(braket
l_int|3
)braket
op_lshift
l_int|8
)paren
op_or
id|buf
(braket
l_int|4
)braket
suffix:semicolon
op_star
id|h
op_assign
(paren
id|buf
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_or
id|buf
(braket
l_int|2
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ---------------------------------------------------------------------- */
multiline_comment|/*&t;&t;&t;&t;&t;&t;&t;&t;Initialization&t;&t;&t;&t;&t;&t;&t;  */
DECL|function|attach_slm
r_int
id|attach_slm
c_func
(paren
r_int
id|target
comma
r_int
id|lun
)paren
(brace
r_static
r_int
id|did_register
suffix:semicolon
r_int
id|len
suffix:semicolon
r_if
c_cond
(paren
id|N_SLM_Printers
op_ge
id|MAX_SLM
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Too much SLMs&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* do an INQUIRY */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|CMDSET_TARG_LUN
c_func
(paren
id|slminquiry_cmd
comma
id|target
comma
id|lun
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acsicmd_nodma
c_func
(paren
id|slminquiry_cmd
comma
l_int|0
)paren
)paren
(brace
id|inq_timeout
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SLM inquiry command timed out.&bslash;n&quot;
)paren
suffix:semicolon
id|inq_fail
suffix:colon
id|acsi_end_extstatus
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* read status and header of return data */
r_if
c_cond
(paren
op_logical_neg
id|acsi_extstatus
c_func
(paren
id|SLMBuffer
comma
l_int|6
)paren
)paren
r_goto
id|inq_timeout
suffix:semicolon
r_if
c_cond
(paren
id|SLMBuffer
(braket
l_int|1
)braket
op_ne
l_int|2
)paren
(brace
multiline_comment|/* device type == printer? */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;SLM inquiry returned device type != printer&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|inq_fail
suffix:semicolon
)brace
id|len
op_assign
id|SLMBuffer
(braket
l_int|5
)braket
suffix:semicolon
multiline_comment|/* read id string */
r_if
c_cond
(paren
op_logical_neg
id|acsi_extstatus
c_func
(paren
id|SLMBuffer
comma
id|len
)paren
)paren
r_goto
id|inq_timeout
suffix:semicolon
id|acsi_end_extstatus
c_func
(paren
)paren
suffix:semicolon
id|SLMBuffer
(braket
id|len
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|did_register
)paren
(brace
id|did_register
op_assign
l_int|1
suffix:semicolon
)brace
id|slm_info
(braket
id|N_SLM_Printers
)braket
dot
id|target
op_assign
id|target
suffix:semicolon
id|slm_info
(braket
id|N_SLM_Printers
)braket
dot
id|lun
op_assign
id|lun
suffix:semicolon
id|slm_info
(braket
id|N_SLM_Printers
)braket
dot
id|wbusy
op_assign
l_int|0
suffix:semicolon
id|slm_info
(braket
id|N_SLM_Printers
)braket
dot
id|rbusy
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  Printer: %s&bslash;n&quot;
comma
id|SLMBuffer
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Detected slm%d at id %d lun %d&bslash;n&quot;
comma
id|N_SLM_Printers
comma
id|target
comma
id|lun
)paren
suffix:semicolon
id|N_SLM_Printers
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|variable|devfs_handle
r_static
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
DECL|function|slm_init
r_int
id|slm_init
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|devfs_register_chrdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;slm&quot;
comma
op_amp
id|slm_fops
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to get major %d for ACSI SLM&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|SLMBuffer
op_assign
id|atari_stram_alloc
c_func
(paren
id|SLM_BUFFER_SIZE
comma
l_int|NULL
comma
l_string|&quot;SLM&quot;
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to get SLM ST-Ram buffer.&bslash;n&quot;
)paren
suffix:semicolon
id|devfs_unregister_chrdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;slm&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|BufferP
op_assign
id|SLMBuffer
suffix:semicolon
id|SLMState
op_assign
id|IDLE
suffix:semicolon
id|devfs_handle
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;slm&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register_series
(paren
id|devfs_handle
comma
l_string|&quot;%u&quot;
comma
id|MAX_SLM
comma
id|DEVFS_FL_DEFAULT
comma
id|MAJOR_NR
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|slm_fops
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/* from acsi.c */
r_void
id|acsi_attach_SLMs
c_func
(paren
r_int
(paren
op_star
id|attach_func
)paren
(paren
r_int
comma
r_int
)paren
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
id|err
op_assign
id|slm_init
c_func
(paren
)paren
)paren
)paren
r_return
id|err
suffix:semicolon
multiline_comment|/* This calls attach_slm() for every target/lun where acsi.c detected a&n;&t; * printer */
id|acsi_attach_SLMs
c_func
(paren
id|attach_slm
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|devfs_unregister
(paren
id|devfs_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_unregister_chrdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;slm&quot;
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;acsi_slm: cleanup_module failed&bslash;n&quot;
)paren
suffix:semicolon
id|atari_stram_free
c_func
(paren
id|SLMBuffer
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
