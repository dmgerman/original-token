multiline_comment|/* #define VERBOSE_IDE_CD_ERRORS 1 */
multiline_comment|/*&n; * linux/drivers/block/ide-cd.c&n; * ATAPI cd-rom driver.  To be used with ide.c.&n; * See Documentation/cdrom/ide-cd for usage information.&n; *&n; * Copyright (C) 1994, 1995, 1996  scott snyder  &lt;snyder@fnald0.fnal.gov&gt;&n; * Copyright (C) 1996  Erik Andersen &lt;andersee@et.byu.edu&gt;&n; *&n; * May be copied or modified under the terms of the GNU General Public License&n; * see linux/COPYING for more information.&n; *&n; * 1.00  Oct 31, 1994 -- Initial version.&n; * 1.01  Nov  2, 1994 -- Fixed problem with starting request in&n; *                       cdrom_check_status.&n; * 1.03  Nov 25, 1994 -- leaving unmask_intr[] as a user-setting (as for disks)&n; * (from mlord)       -- minor changes to cdrom_setup()&n; *                    -- renamed ide_dev_s to ide_drive_t, enable irq on command&n; * 2.00  Nov 27, 1994 -- Generalize packet command interface;&n; *                       add audio ioctls.&n; * 2.01  Dec  3, 1994 -- Rework packet command interface to handle devices&n; *                       which send an interrupt when ready for a command.&n; * 2.02  Dec 11, 1994 -- Cache the TOC in the driver.&n; *                       Don&squot;t use SCMD_PLAYAUDIO_TI; it&squot;s not included&n; *                       in the current version of ATAPI.&n; *                       Try to use LBA instead of track or MSF addressing&n; *                       when possible.&n; *                       Don&squot;t wait for READY_STAT.&n; * 2.03  Jan 10, 1995 -- Rewrite block read routines to handle block sizes&n; *                       other than 2k and to move multiple sectors in a&n; *                       single transaction.&n; * 2.04  Apr 21, 1995 -- Add work-around for Creative Labs CD220E drives.&n; *                       Thanks to Nick Saw &lt;cwsaw@pts7.pts.mot.com&gt; for&n; *                       help in figuring this out.  Ditto for Acer and&n; *                       Aztech drives, which seem to have the same problem.&n; * 2.04b May 30, 1995 -- Fix to match changes in ide.c version 3.16 -ml&n; * 2.05  Jun  8, 1995 -- Don&squot;t attempt to retry after an illegal request&n; *                        or data protect error.&n; *                       Use HWIF and DEV_HWIF macros as in ide.c.&n; *                       Always try to do a request_sense after&n; *                        a failed command.&n; *                       Include an option to give textual descriptions&n; *                        of ATAPI errors.&n; *                       Fix a bug in handling the sector cache which&n; *                        showed up if the drive returned data in 512 byte&n; *                        blocks (like Pioneer drives).  Thanks to&n; *                        Richard Hirst &lt;srh@gpt.co.uk&gt; for diagnosing this.&n; *                       Properly supply the page number field in the&n; *                        MODE_SELECT command.&n; *                       PLAYAUDIO12 is broken on the Aztech; work around it.&n; * 2.05x Aug 11, 1995 -- lots of data structure renaming/restructuring in ide.c&n; *                       (my apologies to Scott, but now ide-cd.c is independent)&n; * 3.00  Aug 22, 1995 -- Implement CDROMMULTISESSION ioctl.&n; *                       Implement CDROMREADAUDIO ioctl (UNTESTED).&n; *                       Use input_ide_data() and output_ide_data().&n; *                       Add door locking.&n; *                       Fix usage count leak in cdrom_open, which happened&n; *                        when a read-write mount was attempted.&n; *                       Try to load the disk on open.&n; *                       Implement CDROMEJECT_SW ioctl (off by default).&n; *                       Read total cdrom capacity during open.&n; *                       Rearrange logic in cdrom_decode_status.  Issue&n; *                        request sense commands for failed packet commands&n; *                        from here instead of from cdrom_queue_packet_command.&n; *                        Fix a race condition in retrieving error information.&n; *                       Suppress printing normal unit attention errors and&n; *                        some drive not ready errors.&n; *                       Implement CDROMVOLREAD ioctl.&n; *                       Implement CDROMREADMODE1/2 ioctls.&n; *                       Fix race condition in setting up interrupt handlers&n; *                        when the `serialize&squot; option is used.&n; * 3.01  Sep  2, 1995 -- Fix ordering of reenabling interrupts in&n; *                        cdrom_queue_request.&n; *                       Another try at using ide_[input,output]_data.&n; * 3.02  Sep 16, 1995 -- Stick total disk capacity in partition table as well.&n; *                       Make VERBOSE_IDE_CD_ERRORS dump failed command again.&n; *                       Dump out more information for ILLEGAL REQUEST errs.&n; *                       Fix handling of errors occurring before the&n; *                        packet command is transferred.&n; *                       Fix transfers with odd bytelengths.&n; * 3.03  Oct 27, 1995 -- Some Creative drives have an id of just `CD&squot;.&n; *                       `DCI-2S10&squot; drives are broken too.&n; * 3.04  Nov 20, 1995 -- So are Vertos drives.&n; * 3.05  Dec  1, 1995 -- Changes to go with overhaul of ide.c and ide-tape.c&n; * 3.06  Dec 16, 1995 -- Add support needed for partitions.&n; *                       More workarounds for Vertos bugs (based on patches&n; *                        from Holger Dietze &lt;dietze@aix520.informatik.uni-leipzig.de&gt;).&n; *                       Try to eliminate byteorder assumptions.&n; *                       Use atapi_cdrom_subchnl struct definition.&n; *                       Add STANDARD_ATAPI compilation option.&n; * 3.07  Jan 29, 1996 -- More twiddling for broken drives: Sony 55D,&n; *                        Vertos 300.&n; *                       Add NO_DOOR_LOCKING configuration option.&n; *                       Handle drive_cmd requests w/NULL args (for hdparm -t).&n; *                       Work around sporadic Sony55e audio play problem.&n; * 3.07a Feb 11, 1996 -- check drive-&gt;id for NULL before dereferencing, to fix&n; *                        problem with &quot;hde=cdrom&quot; with no drive present.  -ml&n; * 3.08  Mar  6, 1996 -- More Vertos workarounds.&n; * 3.09  Apr  5, 1996 -- Add CDROMCLOSETRAY ioctl.&n; *                       Switch to using MSF addressing for audio commands.&n; *                       Reformat to match kernel tabbing style.&n; *                       Add CDROM_GET_UPC ioctl.&n; * 3.10  Apr 10, 1996 -- Fix compilation error with STANDARD_ATAPI.&n; * 3.11  Apr 29, 1996 -- Patch from Heiko Eissfeldt &lt;heiko@colossus.escape.de&gt;&n; *                       to remove redundant verify_area calls.&n; * 3.12  May  7, 1996 -- Rudimentary changer support.  Based on patches&n; *                        from Gerhard Zuber &lt;zuber@berlin.snafu.de&gt;.&n; *                       Let open succeed even if there&squot;s no loaded disc.&n; * 3.13  May 19, 1996 -- Fixes for changer code.&n; * 3.14  May 29, 1996 -- Add work-around for Vertos 600.&n; *                        (From Hennus Bergman &lt;hennus@sky.ow.nl&gt;.)&n; * 3.15  July 2, 1996 -- Added support for Sanyo 3 CD changers&n; *                        from Ben Galliart &lt;bgallia@luc.edu&gt; with &n; *                        special help from Jeff Lightfoot &n; *                        &lt;jeffml@netcom.com&gt;&n; * 3.15a July 9, 1996 -- Improved Sanyo 3 CD changer identification&n; * 3.16  Jul 28, 1996 -- Fix from Gadi to reduce kernel stack usage for ioctl.&n; * 3.17  Sep 17, 1996 -- Tweak audio reads for some drives.&n; *                       Start changing CDROMLOADFROMSLOT to CDROM_SELECT_DISC.&n; * 3.18  Oct 31, 1996 -- Added module and DMA support.&n; *                       &n; *                       &n; * 4.00  Nov 5, 1996   -- New ide-cd maintainer,&n; *                                 Erik B. Andersen &lt;andersee@et.byu.edu&gt;&n; *                     -- Newer Creative drives don&squot;t always set the error&n; *                          register correctly.  Make sure we see media changes&n; *                          regardless.&n; *                     -- Integrate with generic cdrom driver.&n; *                     -- CDROMGETSPINDOWN and CDROMSETSPINDOWN ioctls, based on&n; *                          a patch from Ciro Cattuto &lt;&gt;.&n; *                     -- Call set_device_ro.&n; *                     -- Implement CDROMMECHANISMSTATUS and CDROMSLOTTABLE&n; *                          ioctls, based on patch by Erik Andersen&n; *                     -- Add some probes of drive capability during setup.&n; *&n; * 4.01  Nov 11, 1996  -- Split into ide-cd.c and ide-cd.h&n; *                     -- Removed CDROMMECHANISMSTATUS and CDROMSLOTTABLE &n; *                          ioctls in favor of a generalized approach &n; *                          using the generic cdrom driver.&n; *                     -- Fully integrated with the 2.1.X kernel.&n; *                     -- Other stuff that I forgot (lots of changes)&n; *&n; * 4.02  Dec 01, 1996  -- Applied patch from Gadi Oxman &lt;gadio@netvision.net.il&gt;&n; *                          to fix the drive door locking problems.&n; *&n; * 4.03  Dec 04, 1996  -- Added DSC overlap support.&n; * 4.04  Dec 29, 1996  -- Added CDROMREADRAW ioclt based on patch &n; *                          by Ales Makarov (xmakarov@sun.felk.cvut.cz)&n; *&n; *&n; * MOSTLY DONE LIST:&n; *  Query the drive to find what features are available&n; *   before trying to use them.&n; *&n; * TO DO LIST:&n; *  Avoid printing error messages for expected errors from the drive.&n; *    (If you are using a cd changer, you may get errors in the kernel&n; *     logs that are completly expected.  Don&squot;t complain to me about this,&n; *     unless you have a patch to fix it.  I am working on it...)&n; *  Reset unlocks drive?&n; *  Implement ide_cdrom_disc_status using the generic cdrom interface&n; *  Implement ide_cdrom_select_speed using the generic cdrom interface&n; *  Fix ide_cdrom_reset so that it works (it does nothing right now)&n; *&n; *  -- Suggestions are welcome.  Patches that work are more welcome though.&n; *       For those wishing to work on this driver, please be sure you download&n; *       and comply with the latest ATAPI standard.  This document can be&n; *       obtained by anonymous ftp from fission.dt.wdc.com in directory:&n; *       /pub/standards/atapi/spec/SFF8020-r2.6/PDF/8020r26.pdf&n; *&n; */
multiline_comment|/***************************************************************************/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ucdrom.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &quot;ide.h&quot;
macro_line|#include &quot;ide-cd.h&quot;
multiline_comment|/****************************************************************************&n; * Generic packet command support and error handling routines.&n; */
multiline_comment|/* Mark that we&squot;ve seen a media change, and invalidate our internal&n;   buffers. */
DECL|function|cdrom_saw_media_change
r_static
r_void
id|cdrom_saw_media_change
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|1
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|0
suffix:semicolon
id|info-&gt;nsectors_buffered
op_assign
l_int|0
suffix:semicolon
)brace
r_static
DECL|function|cdrom_analyze_sense_data
r_void
id|cdrom_analyze_sense_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
comma
r_struct
id|packet_command
op_star
id|failed_command
)paren
(brace
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|NOT_READY
op_logical_or
id|reqbuf-&gt;sense_key
op_eq
id|UNIT_ATTENTION
)paren
(brace
multiline_comment|/* Make good and sure we&squot;ve seen this potential media change.&n;&t;&t;   Some drives (i.e. Creative) fail to present the correct&n;&t;&t;   sense key in the error register. */
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t print not ready or unit attention errors for&n;&t;&t;   READ_SUBCHANNEL.  Workman (and probably other programs)&n;&t;&t;   uses this command to poll the drive, and we don&squot;t want&n;&t;&t;   to fill the syslog with useless errors. */
r_if
c_cond
(paren
id|failed_command
op_logical_and
id|failed_command-&gt;c
(braket
l_int|0
)braket
op_eq
id|SCMD_READ_SUBCHANNEL
)paren
r_return
suffix:semicolon
)brace
macro_line|#if VERBOSE_IDE_CD_ERRORS
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|s
suffix:semicolon
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
id|printk
(paren
l_string|&quot;ATAPI device %s:&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;  Error code: 0x%02x&bslash;n&quot;
comma
id|reqbuf-&gt;error_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_ge
l_int|0
op_logical_and
id|reqbuf-&gt;sense_key
OL
id|ARY_LEN
(paren
id|sense_key_texts
)paren
)paren
id|s
op_assign
id|sense_key_texts
(braket
id|reqbuf-&gt;sense_key
)braket
suffix:semicolon
r_else
id|s
op_assign
l_string|&quot;(bad sense key)&quot;
suffix:semicolon
id|printk
(paren
l_string|&quot;  Sense key: 0x%02x - %s&bslash;n&quot;
comma
id|reqbuf-&gt;sense_key
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf-&gt;asc
op_eq
l_int|0x40
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;Diagnostic failure on component 0x%02x&quot;
comma
id|reqbuf-&gt;ascq
)paren
suffix:semicolon
id|s
op_assign
id|buf
suffix:semicolon
)brace
r_else
(brace
r_int
id|lo
comma
id|hi
suffix:semicolon
r_int
id|key
op_assign
(paren
id|reqbuf-&gt;asc
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|reqbuf-&gt;ascq
op_ge
l_int|0x80
op_logical_and
id|reqbuf-&gt;ascq
op_le
l_int|0xdd
)paren
)paren
id|key
op_or_assign
id|reqbuf-&gt;ascq
suffix:semicolon
id|lo
op_assign
l_int|0
suffix:semicolon
id|hi
op_assign
id|ARY_LEN
(paren
id|sense_data_texts
)paren
suffix:semicolon
id|s
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|hi
OG
id|lo
)paren
(brace
r_int
id|mid
op_assign
(paren
id|lo
op_plus
id|hi
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|sense_data_texts
(braket
id|mid
)braket
dot
id|asc_ascq
op_eq
id|key
)paren
(brace
id|s
op_assign
id|sense_data_texts
(braket
id|mid
)braket
dot
id|text
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense_data_texts
(braket
id|mid
)braket
dot
id|asc_ascq
OG
id|key
)paren
id|hi
op_assign
id|mid
suffix:semicolon
r_else
id|lo
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|s
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|reqbuf-&gt;asc
OG
l_int|0x80
)paren
id|s
op_assign
l_string|&quot;(vendor-specific error)&quot;
suffix:semicolon
r_else
id|s
op_assign
l_string|&quot;(reserved error code)&quot;
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;  Additional sense data: 0x%02x, 0x%02x  - %s&bslash;n&quot;
comma
id|reqbuf-&gt;asc
comma
id|reqbuf-&gt;ascq
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|failed_command
op_ne
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;  Failed packet command: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|failed_command-&gt;c
)paren
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot;%02x &quot;
comma
id|failed_command-&gt;c
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
(paren
id|reqbuf-&gt;sense_key_specific
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;  Error in %s byte %d&quot;
comma
(paren
id|reqbuf-&gt;sense_key_specific
(braket
l_int|0
)braket
op_amp
l_int|0x40
)paren
op_ne
l_int|0
ques
c_cond
l_string|&quot;command packet&quot;
suffix:colon
l_string|&quot;command data&quot;
comma
(paren
id|reqbuf-&gt;sense_key_specific
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_plus
id|reqbuf-&gt;sense_key_specific
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reqbuf-&gt;sense_key_specific
(braket
l_int|0
)braket
op_amp
l_int|0x40
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot; bit %d&quot;
comma
id|reqbuf-&gt;sense_key_specific
(braket
l_int|0
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#else /* not VERBOSE_IDE_CD_ERRORS */
multiline_comment|/* Suppress printing unit attention and `in progress of becoming ready&squot;&n;&t;   errors when we&squot;re not being verbose. */
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|UNIT_ATTENTION
op_logical_or
(paren
id|reqbuf-&gt;sense_key
op_eq
id|NOT_READY
op_logical_and
(paren
id|reqbuf-&gt;asc
op_eq
l_int|4
op_logical_or
id|reqbuf-&gt;asc
op_eq
l_int|0x3a
)paren
)paren
)paren
r_return
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: code: 0x%02x  key: 0x%02x  asc: 0x%02x  ascq: 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|reqbuf-&gt;error_code
comma
id|reqbuf-&gt;sense_key
comma
id|reqbuf-&gt;asc
comma
id|reqbuf-&gt;ascq
)paren
suffix:semicolon
macro_line|#endif /* not VERBOSE_IDE_CD_ERRORS */
)brace
multiline_comment|/* Fix up a possibly partially-processed request so that we can&n;   start it over entirely, or even put it back on the request queue. */
DECL|function|restore_request
r_static
r_void
id|restore_request
(paren
r_struct
id|request
op_star
id|rq
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;buffer
op_ne
id|rq-&gt;bh-&gt;b_data
)paren
(brace
r_int
id|n
op_assign
(paren
id|rq-&gt;buffer
op_minus
id|rq-&gt;bh-&gt;b_data
)paren
op_div
id|SECTOR_SIZE
suffix:semicolon
id|rq-&gt;buffer
op_assign
id|rq-&gt;bh-&gt;b_data
suffix:semicolon
id|rq-&gt;nr_sectors
op_add_assign
id|n
suffix:semicolon
id|rq-&gt;sector
op_sub_assign
id|n
suffix:semicolon
)brace
id|rq-&gt;current_nr_sectors
op_assign
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
suffix:semicolon
)brace
DECL|function|cdrom_queue_request_sense
r_static
r_void
id|cdrom_queue_request_sense
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|semaphore
op_star
id|sem
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
comma
r_struct
id|packet_command
op_star
id|failed_command
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* If the request didn&squot;t explicitly specify where&n;&t;   to put the sense data, use the statically allocated structure. */
r_if
c_cond
(paren
id|reqbuf
op_eq
l_int|NULL
)paren
id|reqbuf
op_assign
op_amp
id|info-&gt;sense_data
suffix:semicolon
multiline_comment|/* Make up a new request to retrieve sense information. */
id|pc
op_assign
op_amp
id|info-&gt;request_sense_pc
suffix:semicolon
id|memset
(paren
id|pc
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pc
)paren
)paren
suffix:semicolon
multiline_comment|/* The request_sense structure has an odd number of (16-bit) words,&n;&t;   which won&squot;t work well with 32-bit transfers.  However, we don&squot;t care&n;&t;   about the last two bytes, so just truncate the structure down&n;&t;   to an even length. */
id|len
op_assign
r_sizeof
(paren
op_star
id|reqbuf
)paren
op_div
l_int|4
suffix:semicolon
id|len
op_mul_assign
l_int|4
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|len
suffix:semicolon
id|pc-&gt;buffer
op_assign
(paren
r_char
op_star
)paren
id|reqbuf
suffix:semicolon
id|pc-&gt;buflen
op_assign
id|len
suffix:semicolon
id|pc-&gt;sense_data
op_assign
(paren
r_struct
id|atapi_request_sense
op_star
)paren
id|failed_command
suffix:semicolon
multiline_comment|/* stuff the sense request in front of our current request */
id|rq
op_assign
op_amp
id|info-&gt;request_sense_request
suffix:semicolon
id|ide_init_drive_cmd
(paren
id|rq
)paren
suffix:semicolon
id|rq-&gt;cmd
op_assign
id|REQUEST_SENSE_COMMAND
suffix:semicolon
id|rq-&gt;buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
id|rq-&gt;sem
op_assign
id|sem
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
id|rq
comma
id|ide_preempt
)paren
suffix:semicolon
)brace
DECL|function|cdrom_end_request
r_static
r_void
id|cdrom_end_request
(paren
r_int
id|uptodate
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|REQUEST_SENSE_COMMAND
op_logical_and
id|uptodate
)paren
(brace
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|cdrom_analyze_sense_data
(paren
id|drive
comma
(paren
r_struct
id|atapi_request_sense
op_star
)paren
(paren
id|pc-&gt;buffer
op_minus
id|pc-&gt;c
(braket
l_int|4
)braket
)paren
comma
(paren
r_struct
id|packet_command
op_star
)paren
id|pc-&gt;sense_data
)paren
suffix:semicolon
)brace
id|ide_end_request
(paren
id|uptodate
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Returns 0 if the request should be continued.&n;   Returns 1 if the request was ended. */
DECL|function|cdrom_decode_status
r_static
r_int
id|cdrom_decode_status
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|good_stat
comma
r_int
op_star
id|stat_ret
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|stat
comma
id|err
comma
id|sense_key
comma
id|cmd
suffix:semicolon
multiline_comment|/* Check for errors. */
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
op_star
id|stat_ret
op_assign
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
(paren
id|stat
comma
id|good_stat
comma
id|BAD_R_STAT
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Got an error. */
id|err
op_assign
id|IN_BYTE
(paren
id|IDE_ERROR_REG
)paren
suffix:semicolon
id|sense_key
op_assign
id|err
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|rq
op_eq
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;%s : missing request in cdrom_decode_status&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_else
(brace
id|cmd
op_assign
id|rq-&gt;cmd
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|REQUEST_SENSE_COMMAND
)paren
(brace
multiline_comment|/* We got an error trying to get sense info&n;&t;&t;&t;   from the drive (probably while trying&n;&t;&t;&t;   to recover from a former error).  Just give up. */
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
id|ide_error
(paren
id|drive
comma
l_string|&quot;request sense failure&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|PACKET_COMMAND
)paren
(brace
multiline_comment|/* All other functions, except for READ. */
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
r_struct
id|semaphore
op_star
id|sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Check for tray open. */
r_if
c_cond
(paren
id|sense_key
op_eq
id|NOT_READY
)paren
(brace
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Print an error message to the syslog.&n;&t;&t;&t;&t;   Exception: don&squot;t print anything if this&n;&t;&t;&t;&t;   is a read subchannel command.  This is&n;&t;&t;&t;&t;   because workman constantly polls the drive&n;&t;&t;&t;&t;   with this command, and we don&squot;t want&n;&t;&t;&t;&t;   to uselessly fill up the syslog. */
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|SCMD_READ_SUBCHANNEL
)paren
id|printk
(paren
l_string|&quot;%s: tray open or drive not ready&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense_key
op_eq
id|UNIT_ATTENTION
)paren
(brace
multiline_comment|/* Check for media change. */
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: media changed&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, print an error. */
id|ide_dump_status
(paren
id|drive
comma
l_string|&quot;packet command error&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the error flag and complete the request.&n;&t;&t;&t;   Then, if we have a CHECK CONDITION status,&n;&t;&t;&t;   queue a request sense command.  We must be careful,&n;&t;&t;&t;   though: we don&squot;t want the thread in&n;&t;&t;&t;   cdrom_queue_packet_command to wake up until&n;&t;&t;&t;   the request sense has completed.  We do this&n;&t;&t;&t;   by transferring the semaphore from the packet&n;&t;&t;&t;   command request to the request sense request. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_ne
l_int|0
)paren
(brace
id|sem
op_assign
id|rq-&gt;sem
suffix:semicolon
id|rq-&gt;sem
op_assign
l_int|NULL
suffix:semicolon
)brace
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_ne
l_int|0
)paren
id|cdrom_queue_request_sense
(paren
id|drive
comma
id|sem
comma
id|pc-&gt;sense_data
comma
id|pc
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Handle errors from READ requests. */
r_if
c_cond
(paren
id|sense_key
op_eq
id|NOT_READY
)paren
(brace
multiline_comment|/* Tray open. */
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Fail the request. */
id|printk
(paren
l_string|&quot;%s : tray open&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense_key
op_eq
id|UNIT_ATTENTION
)paren
(brace
multiline_comment|/* Media change. */
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Arrange to retry the request.&n;&t;&t;&t;&t;   But be sure to give up if we&squot;ve retried&n;&t;&t;&t;&t;   too many times. */
r_if
c_cond
(paren
op_increment
id|rq-&gt;errors
OG
id|ERROR_MAX
)paren
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_or
id|sense_key
op_eq
id|DATA_PROTECT
)paren
(brace
multiline_comment|/* No point in retrying after an illegal&n;&t;&t;&t;&t;   request or data protect error.*/
id|ide_dump_status
(paren
id|drive
comma
l_string|&quot;command error&quot;
comma
id|stat
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|err
op_amp
op_complement
id|ABRT_ERR
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Go to the default handler&n;&t;&t;&t;&t;   for other errors. */
id|ide_error
(paren
id|drive
comma
l_string|&quot;cdrom_decode_status&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_increment
id|rq-&gt;errors
OG
id|ERROR_MAX
)paren
)paren
(brace
multiline_comment|/* We&squot;ve racked up too many retries.  Abort. */
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/* If we got a CHECK_CONDITION status,&n;&t;&t;&t;   queue a request sense command. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_ne
l_int|0
)paren
id|cdrom_queue_request_sense
(paren
id|drive
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Retry, or handle the next request. */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Set up the device registers for transferring a packet command on DEV,&n;   expecting to later transfer XFERLEN bytes.  HANDLER is the routine&n;   which actually transfers the command to the drive.  If this is a&n;   drq_interrupt device, this routine will arrange for HANDLER to be&n;   called when the interrupt from the drive arrives.  Otherwise, HANDLER&n;   will be called immediately after the drive is prepared for the transfer. */
DECL|function|cdrom_start_packet_command
r_static
r_int
id|cdrom_start_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|xferlen
comma
id|ide_handler_t
op_star
id|handler
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
multiline_comment|/* Wait for the controller to be idle. */
r_if
c_cond
(paren
id|ide_wait_stat
(paren
id|drive
comma
l_int|0
comma
id|BUSY_STAT
comma
id|WAIT_READY
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;dma
)paren
id|info-&gt;dma
op_assign
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_read
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* Set up the controller registers. */
id|OUT_BYTE
(paren
id|info-&gt;dma
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
l_int|0
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
l_int|0
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|xferlen
op_amp
l_int|0xff
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|xferlen
op_rshift
l_int|8
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;dma
)paren
(paren
r_void
)paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_begin
comma
id|drive
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|WAIT_CMD
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* packet command */
)brace
r_else
(brace
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* packet command */
(paren
op_star
id|handler
)paren
(paren
id|drive
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Send a packet command to DRIVE described by CMD_BUF and CMD_LEN.&n;   The device registers must have already been prepared&n;   by cdrom_start_packet_command.&n;   HANDLER is the interrupt handler to call when the command completes&n;   or there&squot;s data ready. */
DECL|function|cdrom_transfer_packet_command
r_static
r_int
id|cdrom_transfer_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
r_char
op_star
id|cmd_buf
comma
r_int
id|cmd_len
comma
id|ide_handler_t
op_star
id|handler
)paren
(brace
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
)paren
(brace
multiline_comment|/* Here we should have been called after receiving an interrupt&n;&t;&t;   from the device.  DRQ should how be set. */
r_int
id|stat_dum
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
id|drive
comma
id|DRQ_STAT
comma
op_amp
id|stat_dum
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, we must wait for DRQ to get set. */
r_if
c_cond
(paren
id|ide_wait_stat
(paren
id|drive
comma
id|DRQ_STAT
comma
id|BUSY_STAT
comma
id|WAIT_READY
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Arm the interrupt handler. */
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|WAIT_CMD
)paren
suffix:semicolon
multiline_comment|/* Send the command to the device. */
id|atapi_output_bytes
(paren
id|drive
comma
id|cmd_buf
comma
id|cmd_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; * Block read functions.&n; */
multiline_comment|/*&n; * Buffer up to SECTORS_TO_TRANSFER sectors from the drive in our sector&n; * buffer.  Once the first sector is added, any subsequent sectors are&n; * assumed to be continuous (until the buffer is cleared).  For the first&n; * sector added, SECTOR is its sector number.  (SECTOR is then ignored until&n; * the buffer is cleared.)&n; */
DECL|function|cdrom_buffer_sectors
r_static
r_void
id|cdrom_buffer_sectors
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|sector
comma
r_int
id|sectors_to_transfer
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
multiline_comment|/* Number of sectors to read into the buffer. */
r_int
id|sectors_to_buffer
op_assign
id|MIN
(paren
id|sectors_to_transfer
comma
(paren
id|SECTOR_BUFFER_SIZE
op_rshift
id|SECTOR_BITS
)paren
op_minus
id|info-&gt;nsectors_buffered
)paren
suffix:semicolon
r_char
op_star
id|dest
suffix:semicolon
multiline_comment|/* If we don&squot;t yet have a sector buffer, try to allocate one.&n;&t;   If we can&squot;t get one atomically, it&squot;s not fatal -- we&squot;ll just throw&n;&t;   the data away rather than caching it. */
r_if
c_cond
(paren
id|info-&gt;sector_buffer
op_eq
l_int|NULL
)paren
(brace
id|info-&gt;sector_buffer
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
(paren
id|SECTOR_BUFFER_SIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/* If we couldn&squot;t get a buffer,&n;&t;&t;   don&squot;t try to buffer anything... */
r_if
c_cond
(paren
id|info-&gt;sector_buffer
op_eq
l_int|NULL
)paren
id|sectors_to_buffer
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If this is the first sector in the buffer, remember its number. */
r_if
c_cond
(paren
id|info-&gt;nsectors_buffered
op_eq
l_int|0
)paren
id|info-&gt;sector_buffered
op_assign
id|sector
suffix:semicolon
multiline_comment|/* Read the data into the buffer. */
id|dest
op_assign
id|info-&gt;sector_buffer
op_plus
id|info-&gt;nsectors_buffered
op_star
id|SECTOR_SIZE
suffix:semicolon
r_while
c_loop
(paren
id|sectors_to_buffer
OG
l_int|0
)paren
(brace
id|atapi_input_bytes
(paren
id|drive
comma
id|dest
comma
id|SECTOR_SIZE
)paren
suffix:semicolon
op_decrement
id|sectors_to_buffer
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
op_increment
id|info-&gt;nsectors_buffered
suffix:semicolon
id|dest
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
)brace
multiline_comment|/* Throw away any remaining data. */
r_while
c_loop
(paren
id|sectors_to_transfer
OG
l_int|0
)paren
(brace
r_char
id|dum
(braket
id|SECTOR_SIZE
)braket
suffix:semicolon
id|atapi_input_bytes
(paren
id|drive
comma
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Check the contents of the interrupt reason register from the cdrom&n; * and attempt to recover if there are problems.  Returns  0 if everything&squot;s&n; * ok; nonzero if the request has been terminated.&n; */
r_static
r_inline
DECL|function|cdrom_read_check_ireason
r_int
id|cdrom_read_check_ireason
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|len
comma
r_int
id|ireason
)paren
(brace
id|ireason
op_and_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|ireason
op_eq
l_int|2
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ireason
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Whoops... The drive is expecting to receive data from us! */
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: &quot;
l_string|&quot;Drive wants to transfer data the wrong way!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Throw some data at the drive so it doesn&squot;t hang&n;&t;&t;   and quit this request. */
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|atapi_output_bytes
(paren
id|drive
comma
op_amp
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
id|dum
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Drive wants a command packet, or invalid ireason... */
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: bad interrupt reason %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|ireason
)paren
suffix:semicolon
)brace
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Interrupt routine.  Called when a read request has completed.&n; */
DECL|function|cdrom_read_intr
r_static
r_void
id|cdrom_read_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|stat
suffix:semicolon
r_int
id|ireason
comma
id|len
comma
id|sectors_to_transfer
comma
id|nskip
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|i
comma
id|dma
op_assign
id|info-&gt;dma
comma
id|dma_error
op_assign
l_int|0
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|dma
)paren
(brace
id|info-&gt;dma
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dma_error
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_status_bad
comma
id|drive
)paren
)paren
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off
comma
id|drive
)paren
suffix:semicolon
(paren
r_void
)paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_abort
comma
id|drive
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
id|drive
comma
l_int|0
comma
op_amp
id|stat
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|dma
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dma_error
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|i
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
id|ide_error
(paren
id|drive
comma
l_string|&quot;dma error&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Read the interrupt reason and the transfer length. */
id|ireason
op_assign
id|IN_BYTE
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|len
op_assign
id|IN_BYTE
(paren
id|IDE_LCYL_REG
)paren
op_plus
l_int|256
op_star
id|IN_BYTE
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/* If DRQ is clear, the command has completed. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* If we&squot;re not done filling the current buffer, complain.&n;&t;&t;   Otherwise, complete the command normally. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
OG
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: data underrun (%ld blocks)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check that the drive is expecting to do the same thing we are. */
r_if
c_cond
(paren
id|cdrom_read_check_ireason
(paren
id|drive
comma
id|len
comma
id|ireason
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Assume that the drive will always provide data in multiples&n;&t;   of at least SECTOR_SIZE, as it gets hairy to keep track&n;&t;   of the transfers otherwise. */
r_if
c_cond
(paren
(paren
id|len
op_mod
id|SECTOR_SIZE
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: Bad transfer size %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|len
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;  This drive is not supported by this version of the driver&bslash;n&quot;
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The number of sectors we need to read from the drive. */
id|sectors_to_transfer
op_assign
id|len
op_div
id|SECTOR_SIZE
suffix:semicolon
multiline_comment|/* First, figure out if we need to bit-bucket&n;&t;   any of the leading sectors. */
id|nskip
op_assign
id|MIN
(paren
(paren
r_int
)paren
(paren
id|rq-&gt;current_nr_sectors
op_minus
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
)paren
comma
id|sectors_to_transfer
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nskip
OG
l_int|0
)paren
(brace
multiline_comment|/* We need to throw away a sector. */
r_char
id|dum
(braket
id|SECTOR_SIZE
)braket
suffix:semicolon
id|atapi_input_bytes
(paren
id|drive
comma
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_decrement
id|nskip
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
multiline_comment|/* Now loop while we still have data to read from the drive. */
r_while
c_loop
(paren
id|sectors_to_transfer
OG
l_int|0
)paren
(brace
r_int
id|this_transfer
suffix:semicolon
multiline_comment|/* If we&squot;ve filled the present buffer but there&squot;s another&n;&t;&t;   chained buffer after it, move on. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
op_logical_and
id|rq-&gt;nr_sectors
OG
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* If the buffers are full, cache the rest of the data in our&n;&t;&t;   internal buffer. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
(brace
id|cdrom_buffer_sectors
(paren
id|drive
comma
id|rq-&gt;sector
comma
id|sectors_to_transfer
)paren
suffix:semicolon
id|sectors_to_transfer
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Transfer data to the buffers.&n;&t;&t;&t;   Figure out how many sectors we can transfer&n;&t;&t;&t;   to the current buffer. */
id|this_transfer
op_assign
id|MIN
(paren
id|sectors_to_transfer
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
multiline_comment|/* Read this_transfer sectors&n;&t;&t;&t;   into the current buffer. */
r_while
c_loop
(paren
id|this_transfer
OG
l_int|0
)paren
(brace
id|atapi_input_bytes
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|SECTOR_SIZE
)paren
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
op_decrement
id|rq-&gt;nr_sectors
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_increment
id|rq-&gt;sector
suffix:semicolon
op_decrement
id|this_transfer
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Done moving data!&n;&t;   Wait for another interrupt. */
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|cdrom_read_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to satisfy some of the current read request from our cached data.&n; * Returns nonzero if the request has been completed, zero otherwise.&n; */
DECL|function|cdrom_read_from_buffer
r_static
r_int
id|cdrom_read_from_buffer
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
multiline_comment|/* Can&squot;t do anything if there&squot;s no buffer. */
r_if
c_cond
(paren
id|info-&gt;sector_buffer
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Loop while this request needs data and the next block is present&n;&t;   in our cache. */
r_while
c_loop
(paren
id|rq-&gt;nr_sectors
OG
l_int|0
op_logical_and
id|rq-&gt;sector
op_ge
id|info-&gt;sector_buffered
op_logical_and
id|rq-&gt;sector
OL
id|info-&gt;sector_buffered
op_plus
id|info-&gt;nsectors_buffered
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
id|memcpy
(paren
id|rq-&gt;buffer
comma
id|info-&gt;sector_buffer
op_plus
(paren
id|rq-&gt;sector
op_minus
id|info-&gt;sector_buffered
)paren
op_star
id|SECTOR_SIZE
comma
id|SECTOR_SIZE
)paren
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_decrement
id|rq-&gt;nr_sectors
suffix:semicolon
op_increment
id|rq-&gt;sector
suffix:semicolon
)brace
multiline_comment|/* If we&squot;ve satisfied the current request,&n;&t;   terminate it successfully. */
r_if
c_cond
(paren
id|rq-&gt;nr_sectors
op_eq
l_int|0
)paren
(brace
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Move on to the next buffer if needed. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* If this condition does not hold, then the kluge i use to&n;&t;   represent the number of sectors to skip at the start of a transfer&n;&t;   will fail.  I think that this will never happen, but let&squot;s be&n;&t;   paranoid and check. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
OL
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
op_logical_and
(paren
id|rq-&gt;sector
op_mod
id|SECTORS_PER_FRAME
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_from_buffer: buffer botch (%ld)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;sector
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Routine to send a read packet command to the drive.&n; * This is usually called directly from cdrom_start_read.&n; * However, for drq_interrupt devices, it is called from an interrupt&n; * when the drive is ready to accept the command.&n; */
DECL|function|cdrom_start_read_continuation
r_static
r_void
id|cdrom_start_read_continuation
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|nsect
comma
id|sector
comma
id|nframes
comma
id|frame
comma
id|nskip
suffix:semicolon
multiline_comment|/* Number of sectors to transfer. */
id|nsect
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
multiline_comment|/* Starting sector. */
id|sector
op_assign
id|rq-&gt;sector
suffix:semicolon
multiline_comment|/* If the requested sector doesn&squot;t start on a cdrom block boundary,&n;&t;   we must adjust the start of the transfer so that it does,&n;&t;   and remember to skip the first few sectors.&n;&t;   If the CURRENT_NR_SECTORS field is larger than the size&n;&t;   of the buffer, it will mean that we&squot;re to skip a number&n;&t;   of sectors equal to the amount by which CURRENT_NR_SECTORS&n;&t;   is larger than the buffer size. */
id|nskip
op_assign
(paren
id|sector
op_mod
id|SECTORS_PER_FRAME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nskip
OG
l_int|0
)paren
(brace
multiline_comment|/* Sanity check... */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_ne
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_start_read_continuation: buffer botch (%ld)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sector
op_sub_assign
id|nskip
suffix:semicolon
id|nsect
op_add_assign
id|nskip
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_add_assign
id|nskip
suffix:semicolon
)brace
multiline_comment|/* Convert from sectors to cdrom blocks, rounding up the transfer&n;&t;   length if needed. */
id|nframes
op_assign
(paren
id|nsect
op_plus
id|SECTORS_PER_FRAME
op_minus
l_int|1
)paren
op_div
id|SECTORS_PER_FRAME
suffix:semicolon
id|frame
op_assign
id|sector
op_div
id|SECTORS_PER_FRAME
suffix:semicolon
multiline_comment|/* Largest number of frames was can transfer at once is 64k-1. */
id|nframes
op_assign
id|MIN
(paren
id|nframes
comma
l_int|65535
)paren
suffix:semicolon
multiline_comment|/* Set up the command */
id|memset
(paren
op_amp
id|pc.c
comma
l_int|0
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|READ_10
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|nframes
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|nframes
op_amp
l_int|0xff
)paren
suffix:semicolon
id|put_unaligned
c_func
(paren
id|htonl
(paren
id|frame
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
suffix:semicolon
multiline_comment|/* Send the command to the drive and return. */
(paren
r_void
)paren
id|cdrom_transfer_packet_command
(paren
id|drive
comma
id|pc.c
comma
r_sizeof
(paren
id|pc.c
)paren
comma
op_amp
id|cdrom_read_intr
)paren
suffix:semicolon
)brace
DECL|macro|IDECD_SEEK_THRESHOLD
mdefine_line|#define IDECD_SEEK_THRESHOLD&t;(1000)&t;&t;&t;/* 1000 blocks */
DECL|macro|IDECD_SEEK_TIMER
mdefine_line|#define IDECD_SEEK_TIMER&t;(2 * WAIT_MIN_SLEEP)&t;/* 40 ms */
DECL|macro|IDECD_SEEK_TIMEOUT
mdefine_line|#define IDECD_SEEK_TIMEOUT&t;(20 * IDECD_SEEK_TIMER) /* 0.8 sec */
DECL|function|cdrom_seek_intr
r_static
r_void
id|cdrom_seek_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_static
r_int
id|retry
op_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
id|drive
comma
l_int|0
comma
op_amp
id|stat
)paren
)paren
r_return
suffix:semicolon
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|seeking
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|retry
op_logical_and
id|jiffies
op_minus
id|info-&gt;start_seek
OG
id|IDECD_SEEK_TIMER
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|retry
op_eq
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: disabled DSC seek overlap&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|drive-&gt;dsc_overlap
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
DECL|function|cdrom_start_seek_continuation
r_static
r_void
id|cdrom_start_seek_continuation
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|sector
comma
id|frame
comma
id|nskip
suffix:semicolon
id|sector
op_assign
id|rq-&gt;sector
suffix:semicolon
id|nskip
op_assign
(paren
id|sector
op_mod
id|SECTORS_PER_FRAME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nskip
OG
l_int|0
)paren
id|sector
op_sub_assign
id|nskip
suffix:semicolon
id|frame
op_assign
id|sector
op_div
id|SECTORS_PER_FRAME
suffix:semicolon
id|memset
(paren
op_amp
id|pc.c
comma
l_int|0
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SEEK
suffix:semicolon
id|put_unaligned
c_func
(paren
id|htonl
(paren
id|frame
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
suffix:semicolon
(paren
r_void
)paren
id|cdrom_transfer_packet_command
(paren
id|drive
comma
id|pc.c
comma
r_sizeof
(paren
id|pc.c
)paren
comma
op_amp
id|cdrom_seek_intr
)paren
suffix:semicolon
)brace
DECL|function|cdrom_start_seek
r_static
r_void
id|cdrom_start_seek
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|info-&gt;dma
op_assign
l_int|0
suffix:semicolon
id|info-&gt;start_seek
op_assign
id|jiffies
suffix:semicolon
id|cdrom_start_packet_command
(paren
id|drive
comma
l_int|0
comma
id|cdrom_start_seek_continuation
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Start a read request from the CD-ROM.&n; */
DECL|function|cdrom_start_read
r_static
r_void
id|cdrom_start_read
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|minor
op_assign
id|MINOR
(paren
id|rq-&gt;rq_dev
)paren
suffix:semicolon
multiline_comment|/* If the request is relative to a partition, fix it up to refer to the&n;&t;   absolute address.  */
r_if
c_cond
(paren
(paren
id|minor
op_amp
id|PARTN_MASK
)paren
op_ne
l_int|0
)paren
(brace
id|rq-&gt;sector
op_assign
id|block
suffix:semicolon
id|minor
op_and_assign
op_complement
id|PARTN_MASK
suffix:semicolon
id|rq-&gt;rq_dev
op_assign
id|MKDEV
(paren
id|MAJOR
c_func
(paren
id|rq-&gt;rq_dev
)paren
comma
id|minor
)paren
suffix:semicolon
)brace
multiline_comment|/* We may be retrying this request after an error.  Fix up&n;&t;   any weirdness which might be present in the request packet. */
id|restore_request
(paren
id|rq
)paren
suffix:semicolon
multiline_comment|/* Satisfy whatever we can of this request from our cached sector. */
r_if
c_cond
(paren
id|cdrom_read_from_buffer
(paren
id|drive
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Clear the local sector buffer. */
id|info-&gt;nsectors_buffered
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;using_dma
op_logical_and
(paren
id|rq-&gt;sector
op_mod
id|SECTORS_PER_FRAME
op_eq
l_int|0
)paren
op_logical_and
(paren
id|rq-&gt;nr_sectors
op_mod
id|SECTORS_PER_FRAME
op_eq
l_int|0
)paren
)paren
id|info-&gt;dma
op_assign
l_int|1
suffix:semicolon
r_else
id|info-&gt;dma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start sending the read request to the drive. */
id|cdrom_start_packet_command
(paren
id|drive
comma
l_int|32768
comma
id|cdrom_start_read_continuation
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; * Execute all other packet commands.&n; */
multiline_comment|/* Forward declarations. */
r_static
r_int
id|cdrom_lockdoor
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lockflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
suffix:semicolon
multiline_comment|/* Interrupt routine for packet command completion. */
DECL|function|cdrom_pc_intr
r_static
r_void
id|cdrom_pc_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|ireason
comma
id|len
comma
id|stat
comma
id|thislen
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
id|drive
comma
l_int|0
comma
op_amp
id|stat
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Read the interrupt reason and the transfer length. */
id|ireason
op_assign
id|IN_BYTE
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|len
op_assign
id|IN_BYTE
(paren
id|IDE_LCYL_REG
)paren
op_plus
l_int|256
op_star
id|IN_BYTE
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/* If DRQ is clear, the command has completed.&n;&t;   Complain if we still have data left to transfer. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Some of the trailing request sense fields are optional, and&n;&t;&t;   some drives don&squot;t send them.  Sigh. */
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|pc-&gt;buflen
OG
l_int|0
op_logical_and
id|pc-&gt;buflen
op_le
l_int|5
)paren
(brace
r_while
c_loop
(paren
id|pc-&gt;buflen
OG
l_int|0
)paren
(brace
op_star
id|pc-&gt;buffer
op_increment
op_assign
l_int|0
suffix:semicolon
op_decrement
id|pc-&gt;buflen
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pc-&gt;buflen
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_else
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: data underrun %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|pc-&gt;buflen
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Figure out how much data to transfer. */
id|thislen
op_assign
id|pc-&gt;buflen
suffix:semicolon
r_if
c_cond
(paren
id|thislen
OL
l_int|0
)paren
id|thislen
op_assign
op_minus
id|thislen
suffix:semicolon
r_if
c_cond
(paren
id|thislen
OG
id|len
)paren
id|thislen
op_assign
id|len
suffix:semicolon
multiline_comment|/* The drive wants to be written to. */
r_if
c_cond
(paren
(paren
id|ireason
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Check that we want to write. */
r_if
c_cond
(paren
id|pc-&gt;buflen
OG
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: Drive wants &quot;
l_string|&quot;to transfer data the wrong way!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|thislen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Transfer the data. */
id|atapi_output_bytes
(paren
id|drive
comma
id|pc-&gt;buffer
comma
id|thislen
)paren
suffix:semicolon
multiline_comment|/* If we haven&squot;t moved enough data to satisfy the drive,&n;&t;&t;   add some padding. */
r_while
c_loop
(paren
id|len
OG
id|thislen
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|atapi_output_bytes
(paren
id|drive
comma
op_amp
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
id|dum
)paren
suffix:semicolon
)brace
multiline_comment|/* Keep count of how much data we&squot;ve moved. */
id|pc-&gt;buffer
op_add_assign
id|thislen
suffix:semicolon
id|pc-&gt;buflen
op_add_assign
id|thislen
suffix:semicolon
)brace
multiline_comment|/* Same drill for reading. */
r_else
r_if
c_cond
(paren
(paren
id|ireason
op_amp
l_int|3
)paren
op_eq
l_int|2
)paren
(brace
multiline_comment|/* Check that we want to read. */
r_if
c_cond
(paren
id|pc-&gt;buflen
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: Drive wants to &quot;
l_string|&quot;transfer data the wrong way!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|thislen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Transfer the data. */
id|atapi_input_bytes
(paren
id|drive
comma
id|pc-&gt;buffer
comma
id|thislen
)paren
suffix:semicolon
multiline_comment|/* If we haven&squot;t moved enough data to satisfy the drive,&n;&t;&t;   add some padding. */
r_while
c_loop
(paren
id|len
OG
id|thislen
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|atapi_input_bytes
(paren
id|drive
comma
op_amp
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
id|dum
)paren
suffix:semicolon
)brace
multiline_comment|/* Keep count of how much data we&squot;ve moved. */
id|pc-&gt;buffer
op_add_assign
id|thislen
suffix:semicolon
id|pc-&gt;buflen
op_sub_assign
id|thislen
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: The drive &quot;
l_string|&quot;appears confused (ireason = 0x%2x)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|ireason
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now we wait for another interrupt. */
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|cdrom_pc_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
)brace
DECL|function|cdrom_do_pc_continuation
r_static
r_void
id|cdrom_do_pc_continuation
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
multiline_comment|/* Send the command to the drive and return. */
id|cdrom_transfer_packet_command
(paren
id|drive
comma
id|pc-&gt;c
comma
r_sizeof
(paren
id|pc-&gt;c
)paren
comma
op_amp
id|cdrom_pc_intr
)paren
suffix:semicolon
)brace
DECL|function|cdrom_do_packet_command
r_static
r_void
id|cdrom_do_packet_command
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|info-&gt;dma
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|pc-&gt;buflen
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
op_minus
id|len
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start sending the command to the drive. */
id|cdrom_start_packet_command
(paren
id|drive
comma
id|len
comma
id|cdrom_do_pc_continuation
)paren
suffix:semicolon
)brace
multiline_comment|/* Sleep for TIME jiffies.&n;   Not to be called from an interrupt handler. */
r_static
DECL|function|cdrom_sleep
r_void
id|cdrom_sleep
(paren
r_int
id|time
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|time
suffix:semicolon
id|schedule
(paren
)paren
suffix:semicolon
)brace
r_static
DECL|function|cdrom_queue_packet_command
r_int
id|cdrom_queue_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|packet_command
op_star
id|pc
)paren
(brace
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_int
id|retries
op_assign
l_int|10
suffix:semicolon
r_struct
id|request
id|req
suffix:semicolon
multiline_comment|/* If our caller has not provided a place to stick any sense data,&n;&t;   use our own area. */
r_if
c_cond
(paren
id|pc-&gt;sense_data
op_eq
l_int|NULL
)paren
id|pc-&gt;sense_data
op_assign
op_amp
id|my_reqbuf
suffix:semicolon
id|pc-&gt;sense_data-&gt;sense_key
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start of retry loop. */
r_do
(brace
id|ide_init_drive_cmd
(paren
op_amp
id|req
)paren
suffix:semicolon
id|req.cmd
op_assign
id|PACKET_COMMAND
suffix:semicolon
id|req.buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
op_amp
id|req
comma
id|ide_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pc-&gt;stat
op_ne
l_int|0
)paren
(brace
multiline_comment|/* The request failed.  Retry if it was due to a unit&n;&t;&t;&t;   attention status&n;&t;&t;&t;   (usually means media was changed). */
r_struct
id|atapi_request_sense
op_star
id|reqbuf
op_assign
id|pc-&gt;sense_data
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|UNIT_ATTENTION
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|NOT_READY
op_logical_and
id|reqbuf-&gt;asc
op_eq
l_int|4
)paren
(brace
multiline_comment|/* The drive is in the process of loading&n;&t;&t;&t;&t;   a disk.  Retry, but wait a little to give&n;&t;&t;&t;&t;   the drive time to complete the load. */
id|cdrom_sleep
(paren
id|HZ
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Otherwise, don&squot;t retry. */
id|retries
op_assign
l_int|0
suffix:semicolon
op_decrement
id|retries
suffix:semicolon
)brace
multiline_comment|/* End of retry loop. */
)brace
r_while
c_loop
(paren
id|pc-&gt;stat
op_ne
l_int|0
op_logical_and
id|retries
op_ge
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Return an error if the command failed. */
r_if
c_cond
(paren
id|pc-&gt;stat
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_else
(brace
multiline_comment|/* The command succeeded.  If it was anything other than&n;&t;&t;   a request sense, eject, or door lock command,&n;&t;&t;   and we think that the door is presently, lock it again.&n;&t;&t;   (The door was probably unlocked via an explicit&n;&t;&t;   CDROMEJECT ioctl.) */
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
op_eq
l_int|0
op_logical_and
id|drive-&gt;usage
op_logical_and
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
op_logical_and
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|ALLOW_MEDIUM_REMOVAL
op_logical_and
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|START_STOP
)paren
)paren
(brace
(paren
r_void
)paren
id|cdrom_lockdoor
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/****************************************************************************&n; * cdrom driver request routine.&n; */
DECL|function|ide_do_rw_cdrom
r_void
id|ide_do_rw_cdrom
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_int
r_int
id|block
)paren
(brace
r_if
c_cond
(paren
id|rq
op_member_access_from_pointer
id|cmd
op_eq
id|PACKET_COMMAND
op_logical_or
id|rq
op_member_access_from_pointer
id|cmd
op_eq
id|REQUEST_SENSE_COMMAND
)paren
id|cdrom_do_packet_command
(paren
id|drive
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rq
op_member_access_from_pointer
id|cmd
op_eq
id|RESET_DRIVE_COMMAND
)paren
(brace
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
id|ide_do_reset
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rq
op_member_access_from_pointer
id|cmd
op_ne
id|READ
)paren
(brace
id|printk
(paren
l_string|&quot;ide-cd: bad cmd %d&bslash;n&quot;
comma
id|rq
op_member_access_from_pointer
id|cmd
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|seeking
)paren
(brace
r_int
r_int
id|elpased
op_assign
id|jiffies
op_minus
id|info-&gt;start_seek
suffix:semicolon
r_int
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|SEEK_STAT
)paren
op_ne
id|SEEK_STAT
)paren
(brace
r_if
c_cond
(paren
id|elpased
OL
id|IDECD_SEEK_TIMEOUT
)paren
(brace
id|ide_stall_queue
(paren
id|drive
comma
id|IDECD_SEEK_TIMER
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;%s: DSC timeout&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|seeking
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IDE_LARGE_SEEK
c_func
(paren
id|info-&gt;last_block
comma
id|block
comma
id|IDECD_SEEK_THRESHOLD
)paren
op_logical_and
id|drive-&gt;dsc_overlap
)paren
id|cdrom_start_seek
(paren
id|drive
comma
id|block
)paren
suffix:semicolon
r_else
id|cdrom_start_read
(paren
id|drive
comma
id|block
)paren
suffix:semicolon
id|info-&gt;last_block
op_assign
id|block
suffix:semicolon
)brace
)brace
multiline_comment|/****************************************************************************&n; * Ioctl handling.&n; *&n; * Routines which queue packet commands take as a final argument a pointer&n; * to an atapi_request_sense struct.  If execution of the command results&n; * in an error with a CHECK CONDITION status, this structure will be filled&n; * with the results of the subsequent request sense command.  The pointer&n; * can also be NULL, in which case no sense information is returned.&n; */
macro_line|#if ! STANDARD_ATAPI
r_static
r_inline
DECL|function|bin2bcd
r_int
id|bin2bcd
(paren
r_int
id|x
)paren
(brace
r_return
(paren
id|x
op_mod
l_int|10
)paren
op_or
(paren
(paren
id|x
op_div
l_int|10
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
)brace
r_static
r_inline
DECL|function|bcd2bin
r_int
id|bcd2bin
(paren
r_int
id|x
)paren
(brace
r_return
(paren
id|x
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|x
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
r_static
DECL|function|msf_from_bcd
r_void
id|msf_from_bcd
(paren
r_struct
id|atapi_msf
op_star
id|msf
)paren
(brace
id|msf-&gt;minute
op_assign
id|bcd2bin
(paren
id|msf-&gt;minute
)paren
suffix:semicolon
id|msf-&gt;second
op_assign
id|bcd2bin
(paren
id|msf-&gt;second
)paren
suffix:semicolon
id|msf-&gt;frame
op_assign
id|bcd2bin
(paren
id|msf-&gt;frame
)paren
suffix:semicolon
)brace
macro_line|#endif /* not STANDARD_ATAPI */
r_static
r_inline
DECL|function|lba_to_msf
r_void
id|lba_to_msf
(paren
r_int
id|lba
comma
id|byte
op_star
id|m
comma
id|byte
op_star
id|s
comma
id|byte
op_star
id|f
)paren
(brace
id|lba
op_add_assign
id|CD_BLOCK_OFFSET
suffix:semicolon
id|lba
op_and_assign
l_int|0xffffff
suffix:semicolon
multiline_comment|/* negative lbas use only 24 bits */
op_star
id|m
op_assign
id|lba
op_div
(paren
id|CD_SECS
op_star
id|CD_FRAMES
)paren
suffix:semicolon
id|lba
op_mod_assign
(paren
id|CD_SECS
op_star
id|CD_FRAMES
)paren
suffix:semicolon
op_star
id|s
op_assign
id|lba
op_div
id|CD_FRAMES
suffix:semicolon
op_star
id|f
op_assign
id|lba
op_mod
id|CD_FRAMES
suffix:semicolon
)brace
r_static
r_inline
DECL|function|msf_to_lba
r_int
id|msf_to_lba
(paren
id|byte
id|m
comma
id|byte
id|s
comma
id|byte
id|f
)paren
(brace
r_return
(paren
(paren
(paren
id|m
op_star
id|CD_SECS
)paren
op_plus
id|s
)paren
op_star
id|CD_FRAMES
op_plus
id|f
)paren
op_minus
id|CD_BLOCK_OFFSET
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_check_status
id|cdrom_check_status
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|TEST_UNIT_READY
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
multiline_comment|/* the Sanyo 3 CD changer uses byte 7 of TEST_UNIT_READY to &n;           switch CDs instead of supporting the LOAD_UNLOAD opcode   */
id|pc.c
(braket
l_int|7
)braket
op_assign
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
op_mod
l_int|3
suffix:semicolon
macro_line|#endif /* not STANDARD_ATAPI */
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* Lock the door if LOCKFLAG is nonzero; unlock it otherwise. */
r_static
r_int
DECL|function|cdrom_lockdoor
id|cdrom_lockdoor
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lockflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_struct
id|packet_command
id|pc
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf
op_eq
l_int|NULL
)paren
id|reqbuf
op_assign
op_amp
id|my_reqbuf
suffix:semicolon
multiline_comment|/* If the drive cannot lock the door, just pretend. */
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
)paren
id|stat
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|ALLOW_MEDIUM_REMOVAL
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
(paren
id|lockflag
op_ne
l_int|0
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* If we got an illegal field error, the drive&n;&t;   probably cannot lock the door. */
r_if
c_cond
(paren
id|stat
op_ne
l_int|0
op_logical_and
id|reqbuf-&gt;sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
id|reqbuf-&gt;asc
op_eq
l_int|0x24
)paren
(brace
id|printk
(paren
l_string|&quot;%s: door locking not supported&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
op_assign
l_int|1
suffix:semicolon
id|stat
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
)paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
op_assign
id|lockflag
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
multiline_comment|/* Eject the disk if EJECTFLAG is 0.&n;   If EJECTFLAG is 1, try to reload the disk. */
r_static
r_int
DECL|function|cdrom_eject
id|cdrom_eject
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|ejectflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|START_STOP
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
l_int|2
op_plus
(paren
id|ejectflag
op_ne
l_int|0
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_pause
id|cdrom_pause
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|pauseflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_PAUSE_RESUME
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
op_logical_neg
id|pauseflag
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_startstop
id|cdrom_startstop
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|startflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|START_STOP
suffix:semicolon
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
id|startflag
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_read_capacity
id|cdrom_read_capacity
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
op_star
id|capacity
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
(brace
r_int
id|lba
suffix:semicolon
r_int
id|blocklen
suffix:semicolon
)brace
id|capbuf
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|READ_CAPACITY
suffix:semicolon
id|pc.buffer
op_assign
(paren
r_char
op_star
)paren
op_amp
id|capbuf
suffix:semicolon
id|pc.buflen
op_assign
r_sizeof
(paren
id|capbuf
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
)paren
op_star
id|capacity
op_assign
id|ntohl
(paren
id|capbuf.lba
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_read_tocentry
id|cdrom_read_tocentry
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|trackno
comma
r_int
id|msf_flag
comma
r_int
id|format
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_READ_TOC
suffix:semicolon
id|pc.c
(braket
l_int|6
)braket
op_assign
id|trackno
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
id|pc.c
(braket
l_int|9
)braket
op_assign
(paren
id|format
op_lshift
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msf_flag
)paren
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* Try to read the entire TOC for the disk into our internal buffer. */
r_static
r_int
DECL|function|cdrom_read_toc
id|cdrom_read_toc
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_int
id|stat
comma
id|ntracks
comma
id|i
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
r_struct
(brace
r_struct
id|atapi_toc_header
id|hdr
suffix:semicolon
r_struct
id|atapi_toc_entry
id|ent
suffix:semicolon
)brace
id|ms_tmp
suffix:semicolon
r_if
c_cond
(paren
id|toc
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Try to allocate space. */
id|toc
op_assign
(paren
r_struct
id|atapi_toc
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|atapi_toc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|info-&gt;toc
op_assign
id|toc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|toc
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: No cdrom TOC buffer!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Check to see if the existing data is still valid.&n;&t;   If it is, just return. */
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
)paren
(paren
r_void
)paren
id|cdrom_check_status
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* First read just the header, so we know how long the TOC is. */
id|stat
op_assign
id|cdrom_read_tocentry
(paren
id|drive
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
(paren
r_char
op_star
)paren
op_amp
id|toc-&gt;hdr
comma
r_sizeof
(paren
r_struct
id|atapi_toc_header
)paren
op_plus
r_sizeof
(paren
r_struct
id|atapi_toc_entry
)paren
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
)paren
(brace
id|toc-&gt;hdr.first_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.first_track
)paren
suffix:semicolon
id|toc-&gt;hdr.last_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.last_track
)paren
suffix:semicolon
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
id|ntracks
op_assign
id|toc-&gt;hdr.last_track
op_minus
id|toc-&gt;hdr.first_track
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ntracks
op_le
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|ntracks
OG
id|MAX_TRACKS
)paren
id|ntracks
op_assign
id|MAX_TRACKS
suffix:semicolon
multiline_comment|/* Now read the whole schmeer. */
id|stat
op_assign
id|cdrom_read_tocentry
(paren
id|drive
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
(paren
r_char
op_star
)paren
op_amp
id|toc-&gt;hdr
comma
r_sizeof
(paren
r_struct
id|atapi_toc_header
)paren
op_plus
(paren
id|ntracks
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|atapi_toc_entry
)paren
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc-&gt;hdr.toc_length
op_assign
id|ntohs
(paren
id|toc-&gt;hdr.toc_length
)paren
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
)paren
(brace
id|toc-&gt;hdr.first_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.first_track
)paren
suffix:semicolon
id|toc-&gt;hdr.last_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.last_track
)paren
suffix:semicolon
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|ntracks
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
)paren
(brace
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
)paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|track
op_assign
id|bcd2bin
(paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|track
)paren
suffix:semicolon
id|msf_from_bcd
(paren
op_amp
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf
)paren
suffix:semicolon
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.lba
op_assign
id|msf_to_lba
(paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.minute
comma
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.second
comma
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.frame
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the multisession information. */
id|stat
op_assign
id|cdrom_read_tocentry
(paren
id|drive
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
(paren
r_char
op_star
)paren
op_amp
id|ms_tmp
comma
r_sizeof
(paren
id|ms_tmp
)paren
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
)paren
id|msf_from_bcd
(paren
op_amp
id|ms_tmp.ent.addr.msf
)paren
suffix:semicolon
macro_line|#endif  /* not STANDARD_ATAPI */
id|toc-&gt;last_session_lba
op_assign
id|msf_to_lba
(paren
id|ms_tmp.ent.addr.msf.minute
comma
id|ms_tmp.ent.addr.msf.second
comma
id|ms_tmp.ent.addr.msf.frame
)paren
suffix:semicolon
id|toc-&gt;xa_flag
op_assign
(paren
id|ms_tmp.hdr.first_track
op_ne
id|ms_tmp.hdr.last_track
)paren
suffix:semicolon
multiline_comment|/* Now try to get the total cdrom capacity. */
id|stat
op_assign
id|cdrom_read_capacity
(paren
id|drive
comma
op_amp
id|toc-&gt;capacity
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
id|toc-&gt;capacity
op_assign
l_int|0x1fffff
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|gd-&gt;sizes
(braket
id|drive-&gt;select.b.unit
op_lshift
id|PARTN_BITS
)braket
op_assign
id|toc-&gt;capacity
op_star
id|SECTORS_PER_FRAME
suffix:semicolon
id|drive-&gt;part
(braket
l_int|0
)braket
dot
id|nr_sects
op_assign
id|toc-&gt;capacity
op_star
id|SECTORS_PER_FRAME
suffix:semicolon
multiline_comment|/* Remember that we&squot;ve read this stuff. */
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_read_subchannel
id|cdrom_read_subchannel
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|format
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_READ_SUBCHANNEL
suffix:semicolon
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* MSF addressing */
id|pc.c
(braket
l_int|2
)braket
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* request subQ data */
id|pc.c
(braket
l_int|3
)braket
op_assign
id|format
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* modeflag: 0 = current, 1 = changeable mask, 2 = default, 3 = saved */
r_static
r_int
DECL|function|cdrom_mode_sense
id|cdrom_mode_sense
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|pageno
comma
r_int
id|modeflag
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE_10
suffix:semicolon
id|pc.c
(braket
l_int|2
)braket
op_assign
id|pageno
op_or
(paren
id|modeflag
op_lshift
l_int|6
)paren
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_mode_select
id|cdrom_mode_select
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|pageno
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
op_minus
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|MODE_SELECT_10
suffix:semicolon
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|0x10
suffix:semicolon
id|pc.c
(braket
l_int|2
)braket
op_assign
id|pageno
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_play_lba_range_1
id|cdrom_play_lba_range_1
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lba_start
comma
r_int
id|lba_end
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_PLAYAUDIO_MSF
suffix:semicolon
id|lba_to_msf
(paren
id|lba_start
comma
op_amp
id|pc.c
(braket
l_int|3
)braket
comma
op_amp
id|pc.c
(braket
l_int|4
)braket
comma
op_amp
id|pc.c
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|lba_to_msf
(paren
id|lba_end
op_minus
l_int|1
comma
op_amp
id|pc.c
(braket
l_int|6
)braket
comma
op_amp
id|pc.c
(braket
l_int|7
)braket
comma
op_amp
id|pc.c
(braket
l_int|8
)braket
)paren
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_as_bcd
)paren
(brace
id|pc.c
(braket
l_int|3
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|5
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|6
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|8
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif /* not STANDARD_ATAPI */
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* Play audio starting at LBA LBA_START and finishing with the&n;   LBA before LBA_END. */
r_static
r_int
DECL|function|cdrom_play_lba_range
id|cdrom_play_lba_range
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lba_start
comma
r_int
id|lba_end
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_int
id|i
comma
id|stat
suffix:semicolon
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf
op_eq
l_int|NULL
)paren
id|reqbuf
op_assign
op_amp
id|my_reqbuf
suffix:semicolon
multiline_comment|/* Some drives, will, for certain audio cds,&n;&t;   give an error if you ask them to play the entire cd using the&n;&t;   values which are returned in the TOC.  The play will succeed,&n;&t;   however, if the ending address is adjusted downwards&n;&t;   by a few frames. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|75
suffix:semicolon
id|i
op_increment
)paren
(brace
id|stat
op_assign
id|cdrom_play_lba_range_1
(paren
id|drive
comma
id|lba_start
comma
id|lba_end
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
op_logical_or
op_logical_neg
(paren
id|reqbuf-&gt;sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
id|reqbuf-&gt;asc
op_eq
l_int|0x24
)paren
)paren
r_return
id|stat
suffix:semicolon
op_decrement
id|lba_end
suffix:semicolon
r_if
c_cond
(paren
id|lba_end
op_le
id|lba_start
)paren
r_break
suffix:semicolon
)brace
r_return
id|stat
suffix:semicolon
)brace
r_static
DECL|function|cdrom_get_toc_entry
r_int
id|cdrom_get_toc_entry
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|track
comma
r_struct
id|atapi_toc_entry
op_star
op_star
id|ent
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|stat
comma
id|ntracks
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
multiline_comment|/* Make sure our saved TOC is valid. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
multiline_comment|/* Check validity of requested track number. */
id|ntracks
op_assign
id|toc-&gt;hdr.last_track
op_minus
id|toc-&gt;hdr.first_track
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|track
op_eq
id|CDROM_LEADOUT
)paren
op_star
id|ent
op_assign
op_amp
id|toc-&gt;ent
(braket
id|ntracks
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|track
template_param
id|toc-&gt;hdr.last_track
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
op_star
id|ent
op_assign
op_amp
id|toc-&gt;ent
(braket
id|track
op_minus
id|toc-&gt;hdr.first_track
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_read_block
id|cdrom_read_block
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|format
comma
r_int
id|lba
comma
r_int
id|nblocks
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf
op_eq
l_int|NULL
)paren
id|reqbuf
op_assign
op_amp
id|my_reqbuf
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|nec260
)paren
id|pc.c
(braket
l_int|0
)braket
op_assign
l_int|0xd4
suffix:semicolon
r_else
macro_line|#endif  /* not STANDARD_ATAPI */
id|pc.c
(braket
l_int|0
)braket
op_assign
id|READ_CD
suffix:semicolon
id|pc.c
(braket
l_int|1
)braket
op_assign
(paren
id|format
op_lshift
l_int|2
)paren
suffix:semicolon
id|put_unaligned
c_func
(paren
id|htonl
c_func
(paren
id|lba
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|nblocks
op_amp
l_int|0xff
)paren
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
(paren
id|nblocks
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|pc.c
(braket
l_int|6
)braket
op_assign
(paren
(paren
id|nblocks
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|format
op_le
l_int|1
)paren
id|pc.c
(braket
l_int|9
)braket
op_assign
l_int|0xf8
suffix:semicolon
multiline_comment|/* returns 2352 for any format */
r_else
id|pc.c
(braket
l_int|9
)braket
op_assign
l_int|0x10
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* If SLOT&lt;0, unload the current slot.  Otherwise, try to load SLOT. */
r_static
r_int
DECL|function|cdrom_load_unload
id|cdrom_load_unload
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|slot
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
macro_line|#if ! STANDARD_ATAPI
multiline_comment|/* if the drive is a Sanyo 3 CD changer then TEST_UNIT_READY&n;           (used in the cdrom_check_status function) is used to &n;           switch CDs instead of LOAD_UNLOAD */
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|slot
op_eq
l_int|1
)paren
op_logical_or
(paren
id|slot
op_eq
l_int|2
)paren
)paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
op_assign
id|slot
suffix:semicolon
r_else
r_if
c_cond
(paren
id|slot
op_ge
l_int|0
)paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
op_assign
l_int|3
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
r_return
id|cdrom_check_status
(paren
id|drive
comma
id|reqbuf
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif /*not STANDARD_ATAPI */
(brace
multiline_comment|/* ATAPI Rev. 2.2+ standard for requesting switching of&n;                   CDs in a multiplatter device */
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|LOAD_UNLOAD
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
l_int|2
op_plus
(paren
id|slot
op_ge
l_int|0
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
id|slot
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This gets the mechanism status per ATAPI draft spec 2.6 */
r_static
r_int
DECL|function|cdrom_read_mech_status
id|cdrom_read_mech_status
(paren
id|ide_drive_t
op_star
id|drive
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|MECHANISM_STATUS
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|9
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the drive mechanism status and slot table into our internal buffer.&n;   If the buffer does not yet exist, allocate it. */
r_static
r_int
DECL|function|cdrom_read_changer_info
id|cdrom_read_changer_info
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|nslots
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;changer_info
)paren
id|nslots
op_assign
id|info-&gt;changer_info-&gt;hdr.nslots
suffix:semicolon
r_else
(brace
r_struct
id|atapi_mechstat_header
id|mechbuf
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_read_mech_status
(paren
id|drive
comma
(paren
r_char
op_star
)paren
op_amp
id|mechbuf
comma
r_sizeof
(paren
id|mechbuf
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|nslots
op_assign
id|mechbuf.nslots
suffix:semicolon
id|info-&gt;changer_info
op_assign
(paren
r_struct
id|atapi_changer_info
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|atapi_changer_info
)paren
op_plus
id|nslots
op_star
r_sizeof
(paren
r_struct
id|atapi_slot
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;changer_info
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
id|cdrom_read_mech_status
(paren
id|drive
comma
(paren
r_char
op_star
)paren
op_amp
id|info-&gt;changer_info-&gt;hdr
comma
r_sizeof
(paren
r_struct
id|atapi_mechstat_header
)paren
op_plus
id|nslots
op_star
r_sizeof
(paren
r_struct
id|atapi_slot
)paren
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_dev_ioctl
r_int
id|ide_cdrom_dev_ioctl
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMREADRAW
suffix:colon
r_case
id|CDROMREADMODE1
suffix:colon
r_case
id|CDROMREADMODE2
suffix:colon
(brace
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_int
id|blocksize
comma
id|format
comma
id|stat
comma
id|lba
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|CDROMREADMODE1
)paren
(brace
id|blocksize
op_assign
id|CD_FRAMESIZE
suffix:semicolon
id|format
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|CDROMREADMODE2
)paren
(brace
id|blocksize
op_assign
id|CD_FRAMESIZE_RAW0
suffix:semicolon
id|format
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|blocksize
op_assign
id|CD_FRAMESIZE_RAW
suffix:semicolon
id|format
op_assign
l_int|0
suffix:semicolon
)brace
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|arg
comma
id|blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|msf
)paren
)paren
suffix:semicolon
id|lba
op_assign
id|msf_to_lba
(paren
id|msf.cdmsf_min0
comma
id|msf.cdmsf_sec0
comma
id|msf.cdmsf_frame0
)paren
suffix:semicolon
multiline_comment|/* Make sure the TOC is up to date. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
r_if
c_cond
(paren
id|lba
OL
l_int|0
op_logical_or
id|lba
op_ge
id|toc-&gt;capacity
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|buf
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
(paren
id|CD_FRAMESIZE_RAW
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|stat
op_assign
id|cdrom_read_block
(paren
id|drive
comma
id|format
comma
id|lba
comma
l_int|1
comma
id|buf
comma
id|blocksize
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
)paren
id|copy_to_user
(paren
(paren
r_char
op_star
)paren
id|arg
comma
id|buf
comma
id|blocksize
)paren
suffix:semicolon
id|kfree
(paren
id|buf
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
multiline_comment|/* Read 2352 byte blocks from audio tracks. */
r_case
id|CDROMREADAUDIO
suffix:colon
(brace
r_int
id|stat
comma
id|lba
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
r_struct
id|cdrom_read_audio
id|ra
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
multiline_comment|/* Make sure the TOC is up to date. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ra
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|ra
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ra
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ra.nframes
template_param
id|toc-&gt;capacity
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ra.nframes
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|ra.buf
comma
id|ra.nframes
op_star
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|ra.addr_format
op_eq
id|CDROM_MSF
)paren
id|lba
op_assign
id|msf_to_lba
(paren
id|ra.addr.msf.minute
comma
id|ra.addr.msf.second
comma
id|ra.addr.msf.frame
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ra.addr_format
op_eq
id|CDROM_LBA
)paren
id|lba
op_assign
id|ra.addr.lba
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|lba
OL
l_int|0
op_logical_or
id|lba
op_ge
id|toc-&gt;capacity
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|buf
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
(paren
id|CDROM_NBLOCKS_BUFFER
op_star
id|CD_FRAMESIZE_RAW
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_while
c_loop
(paren
id|ra.nframes
OG
l_int|0
)paren
(brace
r_int
id|this_nblocks
op_assign
id|ra.nframes
suffix:semicolon
r_if
c_cond
(paren
id|this_nblocks
OG
id|CDROM_NBLOCKS_BUFFER
)paren
id|this_nblocks
op_assign
id|CDROM_NBLOCKS_BUFFER
suffix:semicolon
id|stat
op_assign
id|cdrom_read_block
(paren
id|drive
comma
l_int|1
comma
id|lba
comma
id|this_nblocks
comma
id|buf
comma
id|this_nblocks
op_star
id|CD_FRAMESIZE_RAW
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_break
suffix:semicolon
id|copy_to_user
(paren
id|ra.buf
comma
id|buf
comma
id|this_nblocks
op_star
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
id|ra.buf
op_add_assign
id|this_nblocks
op_star
id|CD_FRAMESIZE_RAW
suffix:semicolon
id|ra.nframes
op_sub_assign
id|this_nblocks
suffix:semicolon
id|lba
op_add_assign
id|this_nblocks
suffix:semicolon
)brace
id|kfree
(paren
id|buf
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_case
id|CDROMSETSPINDOWN
suffix:colon
(brace
r_char
id|spindown
suffix:semicolon
r_char
id|buffer
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_char
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|spindown
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_char
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_mode_sense
(paren
id|drive
comma
id|PAGE_CDROM
comma
l_int|0
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|buffer
(braket
l_int|11
)braket
op_assign
(paren
id|buffer
(braket
l_int|11
)braket
op_amp
l_int|0xf0
)paren
op_or
(paren
id|spindown
op_amp
l_int|0x0f
)paren
suffix:semicolon
r_return
id|cdrom_mode_select
(paren
id|drive
comma
id|PAGE_CDROM
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMGETSPINDOWN
suffix:colon
(brace
r_char
id|spindown
suffix:semicolon
r_char
id|buffer
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_char
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_mode_sense
(paren
id|drive
comma
id|PAGE_CDROM
comma
l_int|0
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|spindown
op_assign
id|buffer
(braket
l_int|11
)braket
op_amp
l_int|0x0f
suffix:semicolon
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|spindown
comma
r_sizeof
(paren
r_char
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef ALLOW_TEST_PACKETS
r_case
l_int|0x1234
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|packet_command
id|pc
suffix:semicolon
r_int
id|len
comma
id|lena
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|pc.c
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
id|arg
op_add_assign
r_sizeof
(paren
id|pc.c
)paren
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|len
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|len
)paren
)paren
suffix:semicolon
id|arg
op_add_assign
r_sizeof
(paren
id|len
)paren
suffix:semicolon
id|lena
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|lena
OL
l_int|0
)paren
id|lena
op_assign
op_minus
id|lena
suffix:semicolon
(brace
r_char
id|buf
(braket
id|lena
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
(brace
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
op_minus
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
id|buf
comma
(paren
r_void
op_star
)paren
id|arg
comma
op_minus
id|len
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|len
op_ne
l_int|0
)paren
(brace
id|pc.buflen
op_assign
id|len
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
)brace
id|stat
op_assign
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|buf
comma
id|len
)paren
suffix:semicolon
)brace
r_return
id|stat
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_static
DECL|function|ide_cdrom_audio_ioctl
r_int
id|ide_cdrom_audio_ioctl
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSUBCHNL
suffix:colon
(brace
r_struct
id|atapi_cdrom_subchnl
id|scbuf
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_struct
id|cdrom_subchnl
op_star
id|subchnl
op_assign
(paren
r_struct
id|cdrom_subchnl
op_star
)paren
id|arg
suffix:semicolon
id|stat
op_assign
id|cdrom_read_subchannel
(paren
id|drive
comma
l_int|1
comma
multiline_comment|/* current position */
(paren
r_char
op_star
)paren
op_amp
id|scbuf
comma
r_sizeof
(paren
id|scbuf
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|subchan_as_bcd
)paren
(brace
id|msf_from_bcd
(paren
op_amp
id|scbuf.acdsc_absaddr.msf
)paren
suffix:semicolon
id|msf_from_bcd
(paren
op_amp
id|scbuf.acdsc_reladdr.msf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
)paren
id|scbuf.acdsc_trk
op_assign
id|bcd2bin
(paren
id|scbuf.acdsc_trk
)paren
suffix:semicolon
macro_line|#endif /* not STANDARD_ATAPI */
id|subchnl-&gt;cdsc_absaddr.msf.minute
op_assign
id|scbuf.acdsc_absaddr.msf.minute
suffix:semicolon
id|subchnl-&gt;cdsc_absaddr.msf.second
op_assign
id|scbuf.acdsc_absaddr.msf.second
suffix:semicolon
id|subchnl-&gt;cdsc_absaddr.msf.frame
op_assign
id|scbuf.acdsc_absaddr.msf.frame
suffix:semicolon
id|subchnl-&gt;cdsc_reladdr.msf.minute
op_assign
id|scbuf.acdsc_reladdr.msf.minute
suffix:semicolon
id|subchnl-&gt;cdsc_reladdr.msf.second
op_assign
id|scbuf.acdsc_reladdr.msf.second
suffix:semicolon
id|subchnl-&gt;cdsc_reladdr.msf.frame
op_assign
id|scbuf.acdsc_reladdr.msf.frame
suffix:semicolon
id|subchnl-&gt;cdsc_audiostatus
op_assign
id|scbuf.acdsc_audiostatus
suffix:semicolon
id|subchnl-&gt;cdsc_ctrl
op_assign
id|scbuf.acdsc_ctrl
suffix:semicolon
id|subchnl-&gt;cdsc_trk
op_assign
id|scbuf.acdsc_trk
suffix:semicolon
id|subchnl-&gt;cdsc_ind
op_assign
id|scbuf.acdsc_ind
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMREADTOCHDR
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|cdrom_tochdr
op_star
id|tochdr
op_assign
(paren
r_struct
id|cdrom_tochdr
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
multiline_comment|/* Make sure our saved TOC is valid. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
id|tochdr-&gt;cdth_trk0
op_assign
id|toc-&gt;hdr.first_track
suffix:semicolon
id|tochdr-&gt;cdth_trk1
op_assign
id|toc-&gt;hdr.last_track
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMREADTOCENTRY
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|cdrom_tocentry
op_star
id|tocentry
op_assign
(paren
r_struct
id|cdrom_tocentry
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|atapi_toc_entry
op_star
id|toce
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
(paren
id|drive
comma
id|tocentry-&gt;cdte_track
comma
op_amp
id|toce
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|tocentry-&gt;cdte_ctrl
op_assign
id|toce-&gt;control
suffix:semicolon
id|tocentry-&gt;cdte_adr
op_assign
id|toce-&gt;adr
suffix:semicolon
id|tocentry-&gt;cdte_format
op_assign
id|CDROM_LBA
suffix:semicolon
id|tocentry-&gt;cdte_addr.lba
op_assign
id|toce-&gt;addr.lba
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMPLAYMSF
suffix:colon
(brace
r_struct
id|cdrom_msf
op_star
id|msf
op_assign
(paren
r_struct
id|cdrom_msf
op_star
)paren
id|arg
suffix:semicolon
r_int
id|lba_start
comma
id|lba_end
suffix:semicolon
id|lba_start
op_assign
id|msf_to_lba
(paren
id|msf-&gt;cdmsf_min0
comma
id|msf-&gt;cdmsf_sec0
comma
id|msf-&gt;cdmsf_frame0
)paren
suffix:semicolon
id|lba_end
op_assign
id|msf_to_lba
(paren
id|msf-&gt;cdmsf_min1
comma
id|msf-&gt;cdmsf_sec1
comma
id|msf-&gt;cdmsf_frame1
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lba_end
op_le
id|lba_start
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|cdrom_play_lba_range
(paren
id|drive
comma
id|lba_start
comma
id|lba_end
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Like just about every other Linux cdrom driver, we ignore the&n;&t;   index part of the request here. */
r_case
id|CDROMPLAYTRKIND
suffix:colon
(brace
r_int
id|stat
comma
id|lba_start
comma
id|lba_end
suffix:semicolon
r_struct
id|cdrom_ti
op_star
id|ti
op_assign
(paren
r_struct
id|cdrom_ti
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|atapi_toc_entry
op_star
id|first_toc
comma
op_star
id|last_toc
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
(paren
id|drive
comma
id|ti-&gt;cdti_trk0
comma
op_amp
id|first_toc
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
(paren
id|drive
comma
id|ti-&gt;cdti_trk1
comma
op_amp
id|last_toc
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|ti-&gt;cdti_trk1
op_ne
id|CDROM_LEADOUT
)paren
op_increment
id|last_toc
suffix:semicolon
id|lba_start
op_assign
id|first_toc-&gt;addr.lba
suffix:semicolon
id|lba_end
op_assign
id|last_toc-&gt;addr.lba
suffix:semicolon
r_if
c_cond
(paren
id|lba_end
op_le
id|lba_start
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|cdrom_play_lba_range
(paren
id|drive
comma
id|lba_start
comma
id|lba_end
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMVOLCTRL
suffix:colon
(brace
r_struct
id|cdrom_volctrl
op_star
id|volctrl
op_assign
(paren
r_struct
id|cdrom_volctrl
op_star
)paren
id|arg
suffix:semicolon
r_char
id|buffer
(braket
l_int|24
)braket
comma
id|mask
(braket
l_int|24
)braket
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_mode_sense
(paren
id|drive
comma
id|PAGE_AUDIO
comma
l_int|0
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_mode_sense
(paren
id|drive
comma
id|PAGE_AUDIO
comma
l_int|1
comma
id|mask
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|buffer
(braket
l_int|1
)braket
op_assign
id|buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|buffer
(braket
l_int|17
)braket
op_assign
id|volctrl-&gt;channel0
op_amp
id|mask
(braket
l_int|17
)braket
suffix:semicolon
id|buffer
(braket
l_int|19
)braket
op_assign
id|volctrl-&gt;channel1
op_amp
id|mask
(braket
l_int|19
)braket
suffix:semicolon
id|buffer
(braket
l_int|21
)braket
op_assign
id|volctrl-&gt;channel2
op_amp
id|mask
(braket
l_int|21
)braket
suffix:semicolon
id|buffer
(braket
l_int|23
)braket
op_assign
id|volctrl-&gt;channel3
op_amp
id|mask
(braket
l_int|23
)braket
suffix:semicolon
r_return
id|cdrom_mode_select
(paren
id|drive
comma
id|PAGE_AUDIO
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMVOLREAD
suffix:colon
(brace
r_struct
id|cdrom_volctrl
op_star
id|volctrl
op_assign
(paren
r_struct
id|cdrom_volctrl
op_star
)paren
id|arg
suffix:semicolon
r_char
id|buffer
(braket
l_int|24
)braket
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_mode_sense
(paren
id|drive
comma
id|PAGE_AUDIO
comma
l_int|0
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|volctrl-&gt;channel0
op_assign
id|buffer
(braket
l_int|17
)braket
suffix:semicolon
id|volctrl-&gt;channel1
op_assign
id|buffer
(braket
l_int|19
)braket
suffix:semicolon
id|volctrl-&gt;channel2
op_assign
id|buffer
(braket
l_int|21
)braket
suffix:semicolon
id|volctrl-&gt;channel3
op_assign
id|buffer
(braket
l_int|23
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMSTART
suffix:colon
r_return
id|cdrom_startstop
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_startstop
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
multiline_comment|/* pit says the Dolphin needs this. */
r_return
id|cdrom_eject
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMPAUSE
suffix:colon
r_return
id|cdrom_pause
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
r_return
id|cdrom_pause
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_static
DECL|function|ide_cdrom_reset
r_int
id|ide_cdrom_reset
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
multiline_comment|/* This doesn&squot;t work reliably yet, and so it is currently just a stub. */
macro_line|#if 0 
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_struct
id|request
id|req
suffix:semicolon
id|ide_init_drive_cmd
(paren
op_amp
id|req
)paren
suffix:semicolon
id|req.cmd
op_assign
id|RESET_DRIVE_COMMAND
suffix:semicolon
r_return
id|ide_do_drive_cmd
(paren
id|drive
comma
op_amp
id|req
comma
id|ide_wait
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* For now, just return 0, as if things worked...&t;*/
r_return
l_int|0
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_tray_move
r_int
id|ide_cdrom_tray_move
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|position
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_if
c_cond
(paren
id|position
)paren
(brace
r_int
id|stat
op_assign
id|cdrom_lockdoor
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
)brace
r_return
id|cdrom_eject
(paren
id|drive
comma
op_logical_neg
id|position
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_lock_door
r_int
id|ide_cdrom_lock_door
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|lock
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_return
id|cdrom_lockdoor
(paren
id|drive
comma
id|lock
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_select_disc
r_int
id|ide_cdrom_select_disc
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|slot
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_int
id|nslots
comma
id|curslot
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|is_changer
)paren
(brace
id|printk
(paren
l_string|&quot;%s: Not a changer.&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
OG
l_int|0
)paren
(brace
id|nslots
op_assign
l_int|3
suffix:semicolon
id|curslot
op_assign
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
suffix:semicolon
r_if
c_cond
(paren
id|curslot
op_eq
l_int|3
)paren
id|curslot
op_assign
l_int|0
suffix:semicolon
)brace
r_else
macro_line|#endif /* not STANDARD_ATAPI */
(brace
id|stat
op_assign
id|cdrom_read_changer_info
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|nslots
op_assign
id|info-&gt;changer_info-&gt;hdr.nslots
suffix:semicolon
id|curslot
op_assign
id|info-&gt;changer_info-&gt;hdr.curslot
suffix:semicolon
)brace
r_if
c_cond
(paren
id|slot
op_eq
id|curslot
)paren
r_return
id|curslot
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_eq
id|CDSL_CURRENT
)paren
r_return
id|curslot
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_ne
id|CDSL_NONE
op_logical_and
(paren
id|slot
OL
l_int|0
op_logical_or
id|slot
op_ge
id|nslots
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;usage
OG
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|stat
op_assign
id|cdrom_check_status
(paren
id|drive
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_logical_and
id|my_reqbuf.sense_key
op_eq
id|NOT_READY
)paren
r_return
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|slot
op_eq
id|CDSL_NONE
)paren
(brace
(paren
r_void
)paren
id|cdrom_load_unload
(paren
id|drive
comma
op_minus
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
(paren
r_void
)paren
id|cdrom_lockdoor
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
macro_line|#if ! STANDARD_ATAPI
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
op_eq
l_int|0
op_logical_and
macro_line|#endif
id|info-&gt;changer_info-&gt;slots
(braket
id|slot
)braket
dot
id|disc_present
op_eq
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: Requested slot does not contain a CD.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
(paren
op_minus
id|ENOENT
)paren
suffix:semicolon
)brace
id|stat
op_assign
id|cdrom_load_unload
(paren
id|drive
comma
id|slot
comma
l_int|NULL
)paren
suffix:semicolon
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_check_status
(paren
id|drive
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_logical_and
id|my_reqbuf.sense_key
op_eq
id|NOT_READY
)paren
r_return
op_minus
id|ENOENT
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
op_logical_or
id|my_reqbuf.sense_key
op_eq
id|UNIT_ATTENTION
)paren
(brace
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
r_return
id|slot
suffix:semicolon
)brace
r_else
r_return
id|stat
suffix:semicolon
)brace
)brace
r_static
DECL|function|ide_cdrom_drive_status
r_int
id|ide_cdrom_drive_status
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|slot_nr
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|slot_nr
op_eq
id|CDSL_CURRENT
)paren
(brace
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_int
id|stat
op_assign
id|cdrom_check_status
(paren
id|drive
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
op_logical_or
id|my_reqbuf.sense_key
op_eq
id|UNIT_ATTENTION
)paren
r_return
id|CDS_DISC_OK
suffix:semicolon
r_if
c_cond
(paren
id|my_reqbuf.sense_key
op_eq
id|NOT_READY
)paren
(brace
multiline_comment|/* With my NEC260, at least, we can&squot;t distinguish&n;&t;&t;&t;   between tray open and tray closed but no disc&n;&t;&t;&t;   inserted. */
r_return
id|CDS_TRAY_OPEN
suffix:semicolon
)brace
r_return
id|CDS_DRIVE_NOT_READY
suffix:semicolon
)brace
macro_line|#if ! STANDARD_ATAPI
r_else
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
OG
l_int|0
)paren
r_return
id|CDS_NO_INFO
suffix:semicolon
macro_line|#endif /* not STANDARD_ATAPI */
r_else
(brace
r_struct
id|atapi_changer_info
op_star
id|ci
suffix:semicolon
r_int
id|stat
op_assign
id|cdrom_read_changer_info
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
OL
l_int|0
)paren
r_return
id|stat
suffix:semicolon
id|ci
op_assign
id|info-&gt;changer_info
suffix:semicolon
r_if
c_cond
(paren
id|ci-&gt;slots
(braket
id|slot_nr
)braket
dot
id|disc_present
)paren
r_return
id|CDS_DISC_OK
suffix:semicolon
r_else
r_return
id|CDS_NO_DISC
suffix:semicolon
)brace
)brace
r_static
DECL|function|ide_cdrom_get_last_session
r_int
id|ide_cdrom_get_last_session
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_multisession
op_star
id|ms_info
)paren
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
multiline_comment|/* Make sure the TOC information is valid. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
id|ms_info-&gt;addr.lba
op_assign
id|toc-&gt;last_session_lba
suffix:semicolon
id|ms_info-&gt;xa_flag
op_assign
id|toc-&gt;xa_flag
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_get_mcn
r_int
id|ide_cdrom_get_mcn
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_mcn
op_star
id|mcn_info
)paren
(brace
r_int
id|stat
suffix:semicolon
r_char
id|mcnbuf
(braket
l_int|24
)braket
suffix:semicolon
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
id|stat
op_assign
id|cdrom_read_subchannel
(paren
id|drive
comma
l_int|2
comma
multiline_comment|/* get MCN */
id|mcnbuf
comma
r_sizeof
(paren
id|mcnbuf
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy
(paren
id|mcn_info-&gt;medium_catalog_number
comma
id|mcnbuf
op_plus
l_int|9
comma
r_sizeof
(paren
id|mcn_info-&gt;medium_catalog_number
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|mcn_info-&gt;medium_catalog_number
(braket
r_sizeof
(paren
id|mcn_info-&gt;medium_catalog_number
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; * Other driver requests (open, close, check media change).&n; */
r_static
DECL|function|ide_cdrom_check_media_change_real
r_int
id|ide_cdrom_check_media_change_real
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|slot_nr
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|slot_nr
op_eq
id|CDSL_CURRENT
)paren
(brace
(paren
r_void
)paren
id|cdrom_check_status
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
id|retval
op_assign
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if ! STANDARD_ATAPI
r_else
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
OG
l_int|0
)paren
(brace
id|retval
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* not STANDARD_ATAPI */
r_else
(brace
r_struct
id|atapi_changer_info
op_star
id|ci
suffix:semicolon
r_int
id|stat
op_assign
id|cdrom_read_changer_info
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
OL
l_int|0
)paren
r_return
id|stat
suffix:semicolon
id|ci
op_assign
id|info-&gt;changer_info
suffix:semicolon
multiline_comment|/* This test may be redundant with cdrom.c. */
r_if
c_cond
(paren
id|slot_nr
OL
l_int|0
op_logical_or
id|slot_nr
op_ge
id|ci-&gt;hdr.nslots
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|retval
op_assign
id|ci-&gt;slots
(braket
id|slot_nr
)braket
dot
id|change
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_open_real
r_int
id|ide_cdrom_open_real
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|purpose
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close down the device.  Invalidate all cached blocks.&n; */
r_static
DECL|function|ide_cdrom_release_real
r_void
id|ide_cdrom_release_real
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
)brace
multiline_comment|/****************************************************************************&n; * Device initialization.&n; */
r_static
DECL|variable|ide_cdrom_dops
r_struct
id|cdrom_device_ops
id|ide_cdrom_dops
op_assign
(brace
id|ide_cdrom_open_real
comma
multiline_comment|/* open */
id|ide_cdrom_release_real
comma
multiline_comment|/* release */
id|ide_cdrom_drive_status
comma
multiline_comment|/* drive_status */
l_int|0
comma
multiline_comment|/* disc_status */
id|ide_cdrom_check_media_change_real
comma
multiline_comment|/* media_changed */
id|ide_cdrom_tray_move
comma
multiline_comment|/* tray_move */
id|ide_cdrom_lock_door
comma
multiline_comment|/* lock_door */
l_int|0
comma
multiline_comment|/* select_speed */
id|ide_cdrom_select_disc
comma
multiline_comment|/* select_disc */
id|ide_cdrom_get_last_session
comma
multiline_comment|/* get_last_session */
id|ide_cdrom_get_mcn
comma
multiline_comment|/* get_mcn */
id|ide_cdrom_reset
comma
multiline_comment|/* reset */
id|ide_cdrom_audio_ioctl
comma
multiline_comment|/* audio_ioctl */
id|ide_cdrom_dev_ioctl
comma
multiline_comment|/* dev_ioctl */
id|CDC_CLOSE_TRAY
op_or
id|CDC_OPEN_TRAY
op_or
id|CDC_LOCK
op_or
id|CDC_SELECT_DISC
op_or
id|CDC_MULTI_SESSION
op_or
id|CDC_MCN
op_or
id|CDC_MEDIA_CHANGED
op_or
id|CDC_PLAY_AUDIO
comma
multiline_comment|/* capability */
l_int|0
multiline_comment|/* n_minors */
)brace
suffix:semicolon
DECL|function|ide_cdrom_register
r_static
r_int
id|ide_cdrom_register
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|nslots
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|devinfo
op_assign
op_amp
id|info-&gt;devinfo
suffix:semicolon
r_int
id|minor
op_assign
(paren
id|drive-&gt;select.b.unit
)paren
op_lshift
id|PARTN_BITS
suffix:semicolon
id|devinfo-&gt;dev
op_assign
id|MKDEV
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
comma
id|minor
)paren
suffix:semicolon
id|devinfo-&gt;ops
op_assign
op_amp
id|ide_cdrom_dops
suffix:semicolon
id|devinfo-&gt;mask
op_assign
l_int|0
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
op_amp
id|devinfo-&gt;speed
op_assign
l_int|0
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
op_amp
id|devinfo-&gt;capacity
op_assign
id|nslots
suffix:semicolon
id|devinfo-&gt;handle
op_assign
(paren
r_void
op_star
)paren
id|drive
suffix:semicolon
r_return
id|register_cdrom
(paren
id|devinfo
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_probe_capabilities
r_int
id|ide_cdrom_probe_capabilities
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|stat
comma
id|nslots
suffix:semicolon
r_struct
(brace
r_char
id|pad
(braket
l_int|8
)braket
suffix:semicolon
r_struct
id|atapi_capabilities_page
id|cap
suffix:semicolon
)brace
id|buf
suffix:semicolon
id|nslots
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|nec260
)paren
r_return
id|nslots
suffix:semicolon
id|stat
op_assign
id|cdrom_mode_sense
(paren
id|drive
comma
id|PAGE_CAPABILITIES
comma
l_int|0
comma
(paren
r_char
op_star
)paren
op_amp
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|nslots
suffix:semicolon
r_if
c_cond
(paren
id|buf.cap.lock
op_eq
l_int|0
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
op_assign
l_int|1
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
OG
l_int|0
)paren
(brace
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|is_changer
op_assign
l_int|1
suffix:semicolon
id|nslots
op_assign
l_int|3
suffix:semicolon
)brace
r_else
macro_line|#endif /* not STANDARD_ATAPI */
r_if
c_cond
(paren
id|buf.cap.mechtype
op_eq
id|mechtype_individual_changer
op_logical_or
id|buf.cap.mechtype
op_eq
id|mechtype_cartridge_changer
)paren
(brace
r_struct
id|atapi_mechstat_header
id|mechbuf
suffix:semicolon
id|stat
op_assign
id|cdrom_read_mech_status
(paren
id|drive
comma
(paren
r_char
op_star
)paren
op_amp
id|mechbuf
comma
r_sizeof
(paren
id|mechbuf
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat
)paren
(brace
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|is_changer
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|supp_disc_present
op_assign
l_int|1
suffix:semicolon
id|nslots
op_assign
id|mechbuf.nslots
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|is_changer
)paren
id|printk
(paren
l_string|&quot; %s: ATAPI CDROM changer with %d slots&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|nslots
)paren
suffix:semicolon
r_return
id|nslots
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_setup
r_int
id|ide_cdrom_setup
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|nslots
suffix:semicolon
id|kdev_t
id|dev
op_assign
id|MKDEV
(paren
id|HWIF
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
comma
id|drive-&gt;select.b.unit
op_lshift
id|PARTN_BITS
)paren
suffix:semicolon
id|set_device_ro
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
id|blksize_size
(braket
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
)braket
(braket
id|drive-&gt;select.b.unit
op_lshift
id|PARTN_BITS
)braket
op_assign
id|CD_FRAMESIZE
suffix:semicolon
id|drive-&gt;special.all
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;ready_stat
op_assign
l_int|0
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|0
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|0
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
op_assign
l_int|0
suffix:semicolon
macro_line|#if NO_DOOR_LOCKING
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
op_assign
l_int|1
suffix:semicolon
macro_line|#else
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|drive-&gt;id
op_ne
l_int|NULL
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
op_assign
(paren
(paren
id|drive-&gt;id-&gt;config
op_amp
l_int|0x0060
)paren
op_eq
l_int|0x20
)paren
suffix:semicolon
r_else
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|is_changer
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|supp_disc_present
op_assign
l_int|0
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
multiline_comment|/* by default Sanyo 3 CD changer support is turned off and&n;           ATAPI Rev 2.2+ standard support for CD changers is used */
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|nec260
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_as_bcd
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|subchan_as_bcd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;V003S0DS&quot;
)paren
op_eq
l_int|0
op_logical_and
id|drive-&gt;id-&gt;fw_rev
(braket
l_int|4
)braket
op_eq
l_char|&squot;1&squot;
op_logical_and
id|drive-&gt;id-&gt;fw_rev
(braket
l_int|6
)braket
op_le
l_char|&squot;2&squot;
)paren
(brace
multiline_comment|/* Vertos 300.&n;&t;&t;&t;   Some versions of this drive like to talk BCD. */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|subchan_as_bcd
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;V006E0DS&quot;
)paren
op_eq
l_int|0
op_logical_and
id|drive-&gt;id-&gt;fw_rev
(braket
l_int|4
)braket
op_eq
l_char|&squot;1&squot;
op_logical_and
id|drive-&gt;id-&gt;fw_rev
(braket
l_int|6
)braket
op_le
l_char|&squot;2&squot;
)paren
(brace
multiline_comment|/* Vertos 600 ESD. */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;NEC CD-ROM DRIVE:260&quot;
)paren
op_eq
l_int|0
op_logical_and
id|strcmp
(paren
id|drive-&gt;id-&gt;fw_rev
comma
l_string|&quot;1.01&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Old NEC260 (not R).&n;&t;&t;&t;   This drive was released before the 1.2 version&n;&t;&t;&t;   of the spec. */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|subchan_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|nec260
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;WEARNES CDD-120&quot;
)paren
op_eq
l_int|0
op_logical_and
id|strcmp
(paren
id|drive-&gt;id-&gt;fw_rev
comma
l_string|&quot;A1.1&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Wearnes */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|subchan_as_bcd
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Sanyo 3 CD changer uses a non-standard command &n;                   for CD changing. */
r_else
r_if
c_cond
(paren
(paren
id|strcmp
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;CD-ROM CDR-C3 G&quot;
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|strcmp
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;CD-ROM CDR-C3G&quot;
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* uses CD in slot 0 when value is set to 3 */
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
op_assign
l_int|3
suffix:semicolon
)brace
)brace
macro_line|#endif /* not STANDARD_ATAPI */
id|info-&gt;toc
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;sector_buffer
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;sector_buffered
op_assign
l_int|0
suffix:semicolon
id|info-&gt;nsectors_buffered
op_assign
l_int|0
suffix:semicolon
id|info-&gt;changer_info
op_assign
l_int|NULL
suffix:semicolon
id|nslots
op_assign
id|ide_cdrom_probe_capabilities
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_cdrom_register
(paren
id|drive
comma
id|nslots
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: ide_cdrom_setup failed to register device with the cdrom driver.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|info-&gt;devinfo.handle
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Forwarding functions to generic routines. */
DECL|function|ide_cdrom_ioctl
r_int
id|ide_cdrom_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_return
id|cdrom_fops.ioctl
(paren
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
DECL|function|ide_cdrom_open
r_int
id|ide_cdrom_open
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|rc
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|rc
op_assign
id|cdrom_fops.open
(paren
id|ip
comma
id|fp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rc
)paren
(brace
id|drive-&gt;usage
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|ide_cdrom_release
r_void
id|ide_cdrom_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|cdrom_fops.release
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|ide_cdrom_check_media_change
r_int
id|ide_cdrom_check_media_change
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
id|cdrom_fops.check_media_change
(paren
id|MKDEV
(paren
id|HWIF
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
comma
(paren
id|drive-&gt;select.b.unit
)paren
op_lshift
id|PARTN_BITS
)paren
)paren
suffix:semicolon
)brace
DECL|function|ide_cdrom_cleanup
r_int
id|ide_cdrom_cleanup
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|devinfo
op_assign
op_amp
id|info-&gt;devinfo
suffix:semicolon
r_if
c_cond
(paren
id|ide_unregister_subdriver
(paren
id|drive
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;sector_buffer
op_ne
l_int|NULL
)paren
id|kfree
(paren
id|info-&gt;sector_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;toc
op_ne
l_int|NULL
)paren
id|kfree
(paren
id|info-&gt;toc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devinfo-&gt;handle
op_eq
id|drive
op_logical_and
id|unregister_cdrom
(paren
id|devinfo
)paren
)paren
id|printk
(paren
l_string|&quot;%s: ide_cdrom_cleanup failed to unregister device from the cdrom driver.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|kfree
(paren
id|info
)paren
suffix:semicolon
id|drive-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
id|ide_cdrom_init
(paren
r_void
)paren
suffix:semicolon
DECL|variable|ide_cdrom_module
r_static
id|ide_module_t
id|ide_cdrom_module
op_assign
(brace
id|IDE_DRIVER_MODULE
comma
id|ide_cdrom_init
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|ide_cdrom_driver
r_static
id|ide_driver_t
id|ide_cdrom_driver
op_assign
(brace
id|ide_cdrom
comma
multiline_comment|/* media */
l_int|0
comma
multiline_comment|/* busy */
l_int|1
comma
multiline_comment|/* supports_dma */
l_int|1
comma
multiline_comment|/* supports_dsc_overlap */
id|ide_cdrom_cleanup
comma
multiline_comment|/* cleanup */
id|ide_do_rw_cdrom
comma
multiline_comment|/* do_request */
l_int|NULL
comma
multiline_comment|/* ??? or perhaps&n;&t;cdrom_end_request? */
id|ide_cdrom_ioctl
comma
multiline_comment|/* ioctl */
id|ide_cdrom_open
comma
multiline_comment|/* open */
id|ide_cdrom_release
comma
multiline_comment|/* release */
id|ide_cdrom_check_media_change
comma
multiline_comment|/* media_change */
l_int|NULL
comma
multiline_comment|/* pre_reset */
l_int|NULL
comma
multiline_comment|/* capacity */
l_int|NULL
multiline_comment|/* special */
)brace
suffix:semicolon
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
(brace
r_return
id|ide_cdrom_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_int
id|failed
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|drive
op_assign
id|ide_scan_devices
(paren
id|ide_cdrom
comma
op_amp
id|ide_cdrom_driver
comma
id|failed
)paren
)paren
op_ne
l_int|NULL
)paren
r_if
c_cond
(paren
id|ide_cdrom_cleanup
(paren
id|drive
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cleanup_module() called while still busy&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|failed
op_increment
suffix:semicolon
)brace
id|ide_unregister_module
(paren
op_amp
id|ide_cdrom_module
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
DECL|function|ide_cdrom_init
r_int
id|ide_cdrom_init
(paren
r_void
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
suffix:semicolon
r_int
id|failed
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|drive
op_assign
id|ide_scan_devices
(paren
id|ide_cdrom
comma
l_int|NULL
comma
id|failed
op_increment
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|info
op_assign
(paren
r_struct
id|cdrom_info
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|cdrom_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: Can&squot;t allocate a cdrom structure&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ide_register_subdriver
(paren
id|drive
comma
op_amp
id|ide_cdrom_driver
comma
id|IDE_SUBDRIVER_VERSION
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: Failed to register the driver with ide.c&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|kfree
(paren
id|info
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|memset
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cdrom_info
)paren
)paren
suffix:semicolon
id|drive-&gt;driver_data
op_assign
id|info
suffix:semicolon
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busy
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ide_cdrom_setup
(paren
id|drive
)paren
)paren
(brace
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busy
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ide_cdrom_cleanup
(paren
id|drive
)paren
)paren
id|printk
(paren
l_string|&quot;%s: ide_cdrom_cleanup failed in ide_cdrom_init&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busy
op_decrement
suffix:semicolon
id|failed
op_decrement
suffix:semicolon
)brace
id|ide_register_module
c_func
(paren
op_amp
id|ide_cdrom_module
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*==========================================================================*/
multiline_comment|/*&n; * Local variables:&n; * c-basic-offset: 8&n; * End:&n; */
eof
