multiline_comment|/*&n; * linux/drivers/block/ide-cd.c&n; *&n; * 1.00  Oct 31, 1994 -- Initial version.&n; * 1.01  Nov  2, 1994 -- Fixed problem with starting request in&n; *                       cdrom_check_status.&n; * 1.03  Nov 25, 1994 -- leaving unmask_intr[] as a user-setting (as for disks)&n; * (from mlord)       -- minor changes to cdrom_setup()&n; *                    -- renamed ide_dev_s to ide_drive_t, enable irq on command&n; * 2.00  Nov 27, 1994 -- Generalize packet command interface;&n; *                       add audio ioctls.&n; * 2.01  Dec  3, 1994 -- Rework packet command interface to handle devices&n; *                       which send an interrupt when ready for a command.&n; * 2.02  Dec 11, 1994 -- Cache the TOC in the driver.&n; *                       Don&squot;t use SCMD_PLAYAUDIO_TI; it&squot;s not included&n; *                       in the current version of ATAPI.&n; *                       Try to use LBA instead of track or MSF addressing&n; *                       when possible.&n; *                       Don&squot;t wait for READY_STAT.&n; * 2.03  Jan 10, 1995 -- Rewrite block read routines to handle block sizes&n; *                       other than 2k and to move multiple sectors in a&n; *                       single transaction.&n; * 2.04  Apr 21, 1995 -- Add work-around for Creative Labs CD220E drives.&n; *                       Thanks to Nick Saw &lt;cwsaw@pts7.pts.mot.com&gt; for&n; *                       help in figuring this out.  Ditto for Acer and&n; *                       Aztech drives, which seem to have the same problem.&n; * 2.04b May 30, 1995 -- Fix to match changes in ide.c version 3.16 -ml&n; * 2.05  Jun  8, 1995 -- Don&squot;t attempt to retry after an illegal request&n; *                        or data protect error.&n; *                       Use HWIF and DEV_HWIF macros as in ide.c.&n; *                       Always try to do a request_sense after&n; *                        a failed command.&n; *                       Include an option to give textual descriptions&n; *                        of ATAPI errors.&n; *                       Fix a bug in handling the sector cache which&n; *                        showed up if the drive returned data in 512 byte&n; *                        blocks (like Pioneer drives).  Thanks to&n; *                        Richard Hirst &lt;srh@gpt.co.uk&gt; for diagnosing this.&n; *                       Properly supply the page number field in the&n; *                        MODE_SELECT command.&n; *                       PLAYAUDIO12 is broken on the Aztech; work around it.&n; * 2.05x Aug 11, 1995 -- lots of data structure renaming/restructuring in ide.c&n; *                       (my apologies to Scott, but now ide-cd.c is independent)&n; * 3.00  Aug 22, 1995 -- Implement CDROMMULTISESSION ioctl.&n; *                       Implement CDROMREADAUDIO ioctl (UNTESTED).&n; *                       Use input_ide_data() and output_ide_data().&n; *                       Add door locking.&n; *                       Fix usage count leak in cdrom_open, which happened&n; *                        when a read-write mount was attempted.&n; *                       Try to load the disk on open.&n; *                       Implement CDROMEJECT_SW ioctl (off by default).&n; *                       Read total cdrom capacity during open.&n; *                       Rearrange logic in cdrom_decode_status.  Issue&n; *                        request sense commands for failed packet commands&n; *                        from here instead of from cdrom_queue_packet_command.&n; *                        Fix a race condition in retrieving error information.&n; *                       Suppress printing normal unit attention errors and&n; *                        some drive not ready errors.&n; *                       Implement CDROMVOLREAD ioctl.&n; *                       Implement CDROMREADMODE1/2 ioctls.&n; *                       Fix race condition in setting up interrupt handlers&n; *                        when the `serialize&squot; option is used.&n; * 3.01  Sep  2, 1995 -- Fix ordering of reenabling interrupts in&n; *                        cdrom_queue_request.&n; *                       Another try at using ide_[input,output]_data.&n; * 3.02  Sep 16, 1995 -- Stick total disk capacity in partition table as well.&n; *                       Make VERBOSE_IDE_CD_ERRORS dump failed command again.&n; *                       Dump out more information for ILLEGAL REQUEST errs.&n; *                       Fix handling of errors occurring before the&n; *                        packet command is transferred.&n; *                       Fix transfers with odd bytelengths.&n; * 3.03  Oct 27, 1995 -- Some Creative drives have an id of just `CD&squot;.&n; *                       `DCI-2S10&squot; drives are broken too.&n; * 3.04  Nov 20, 1995 -- So are Vertos drives.&n; * 3.05  Dec  1, 1995 -- Changes to go with overhaul of ide.c and ide-tape.c&n; * 3.06  Dec 16, 1995 -- Add support needed for partitions.&n; *                       More workarounds for Vertos bugs (based on patches&n; *                        from Holger Dietze &lt;dietze@aix520.informatik.uni-leipzig.de&gt;).&n; *                       Try to eliminate byteorder assumptions.&n; *                       Use atapi_cdrom_subchnl struct definition.&n; *                       Add STANDARD_ATAPI compilation option.&n; * 3.07  Jan 29, 1996 -- More twiddling for broken drives: Sony 55D,&n; *                        Vertos 300.&n; *                       Add NO_DOOR_LOCKING configuration option.&n; *                       Handle drive_cmd requests w/NULL args (for hdparm -t).&n; *                       Work around sporadic Sony55e audio play problem.&n; * 3.07a Feb 11, 1996 -- check drive-&gt;id for NULL before dereferencing, to fix&n; *                        problem with &quot;hde=cdrom&quot; with no drive present.  -ml&n; * 3.08  Mar  6, 1996 -- More Vertos workarounds.&n; * 3.09  Apr  5, 1996 -- Add CDROMCLOSETRAY ioctl.&n; *                       Switch to using MSF addressing for audio commands.&n; *                       Reformat to match kernel tabbing style.&n; *                       Add CDROM_GET_UPC ioctl.&n; * 3.10  Apr 10, 1996 -- Fix compilation error with STANDARD_ATAPI.&n; * 3.11  Apr 29, 1996 -- Patch from Heiko Eissfeldt &lt;heiko@colossus.escape.de&gt;&n; *                       to remove redundant verify_area calls.&n; * 3.12  May  7, 1996 -- Rudimentary changer support.  Based on patches&n; *                        from Gerhard Zuber &lt;zuber@berlin.snafu.de&gt;.&n; *                       Let open succeed even if there&squot;s no loaded disc.&n; * 3.13  May 19, 1996 -- Fixes for changer code.&n; * 3.14  May 29, 1996 -- Add work-around for Vertos 600.&n; *                        (From Hennus Bergman &lt;hennus@sky.ow.nl&gt;.)&n; * 3.15  July 2, 1996 -- Added support for Sanyo 3 CD changers&n; *                        from Ben Galliart &lt;bgallia@luc.edu&gt; with &n; *                        special help from Jeff Lightfoot &n; *                        &lt;jeffml@netcom.com&gt;&n; * 3.15a July 9, 1996 -- Improved Sanyo 3 CD changer identification&n; * 3.16  Jul 28, 1996 -- Fix from Gadi to reduce kernel stack usage for ioctl.&n; * 3.17  Sep 17, 1996 -- Tweak audio reads for some drives.&n; *                       Start changing CDROMLOADFROMSLOT to CDROM_SELECT_DISC.&n; * 3.17a Oct 31, 1996 -- Added module and DMA support.&n; *&n; * NOTE: Direct audio reads will only work on some types of drive.&n; * So far, i&squot;ve received reports of success for Sony and Toshiba drives.&n; *&n; * ATAPI cd-rom driver.  To be used with ide.c.&n; * See Documentation/cdrom/ide-cd for usage information.&n; *&n; * Copyright (C) 1994, 1995, 1996  scott snyder  &lt;snyder@fnald0.fnal.gov&gt;&n; * May be copied or modified under the terms of the GNU General Public License&n; * (../../COPYING).&n; */
multiline_comment|/***************************************************************************/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ucdrom.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &quot;ide.h&quot;
multiline_comment|/* Turn this on to have the driver print out the meanings of the&n;   ATAPI error codes.  This will use up additional kernel-space&n;   memory, though. */
macro_line|#ifndef VERBOSE_IDE_CD_ERRORS
DECL|macro|VERBOSE_IDE_CD_ERRORS
mdefine_line|#define VERBOSE_IDE_CD_ERRORS 0
macro_line|#endif
multiline_comment|/* Turning this on will remove code to work around various nonstandard&n;   ATAPI implementations.  If you know your drive follows the standard,&n;   this will give you a slightly smaller kernel. */
macro_line|#ifndef STANDARD_ATAPI
DECL|macro|STANDARD_ATAPI
mdefine_line|#define STANDARD_ATAPI 0
macro_line|#endif
multiline_comment|/* Turning this on will disable the door-locking functionality.&n;   This is apparently needed for supermount. */
macro_line|#ifndef NO_DOOR_LOCKING
DECL|macro|NO_DOOR_LOCKING
mdefine_line|#define NO_DOOR_LOCKING 0
macro_line|#endif
multiline_comment|/* Size of buffer to allocate, in blocks, for audio reads. */
macro_line|#ifndef CDROM_NBLOCKS_BUFFER
DECL|macro|CDROM_NBLOCKS_BUFFER
mdefine_line|#define CDROM_NBLOCKS_BUFFER 8
macro_line|#endif
multiline_comment|/************************************************************************/
DECL|macro|SECTOR_SIZE
mdefine_line|#define SECTOR_SIZE 512
DECL|macro|SECTOR_BITS
mdefine_line|#define SECTOR_BITS 9
DECL|macro|SECTORS_PER_FRAME
mdefine_line|#define SECTORS_PER_FRAME (CD_FRAMESIZE / SECTOR_SIZE)
DECL|macro|MIN
mdefine_line|#define MIN(a,b) ((a) &lt; (b) ? (a) : (b))
multiline_comment|/* special command codes for strategy routine. */
DECL|macro|PACKET_COMMAND
mdefine_line|#define PACKET_COMMAND        4315
DECL|macro|REQUEST_SENSE_COMMAND
mdefine_line|#define REQUEST_SENSE_COMMAND 4316
DECL|macro|RESET_DRIVE_COMMAND
mdefine_line|#define RESET_DRIVE_COMMAND   4317
multiline_comment|/* Some ATAPI command opcodes (just like SCSI).&n;   (Some other cdrom-specific codes are in cdrom.h.) */
DECL|macro|TEST_UNIT_READY
mdefine_line|#define TEST_UNIT_READY         0x00
DECL|macro|REQUEST_SENSE
mdefine_line|#define REQUEST_SENSE           0x03
DECL|macro|START_STOP
mdefine_line|#define START_STOP              0x1b
DECL|macro|ALLOW_MEDIUM_REMOVAL
mdefine_line|#define ALLOW_MEDIUM_REMOVAL    0x1e
DECL|macro|READ_CAPACITY
mdefine_line|#define READ_CAPACITY&t;&t;0x25
DECL|macro|READ_10
mdefine_line|#define READ_10                 0x28
DECL|macro|MODE_SENSE_10
mdefine_line|#define MODE_SENSE_10           0x5a
DECL|macro|MODE_SELECT_10
mdefine_line|#define MODE_SELECT_10          0x55
DECL|macro|READ_CD
mdefine_line|#define READ_CD                 0xbe
DECL|macro|LOAD_UNLOAD
mdefine_line|#define LOAD_UNLOAD             0xa6
multiline_comment|/* ATAPI sense keys (mostly copied from scsi.h). */
DECL|macro|NO_SENSE
mdefine_line|#define NO_SENSE                0x00
DECL|macro|RECOVERED_ERROR
mdefine_line|#define RECOVERED_ERROR         0x01
DECL|macro|NOT_READY
mdefine_line|#define NOT_READY               0x02
DECL|macro|MEDIUM_ERROR
mdefine_line|#define MEDIUM_ERROR            0x03
DECL|macro|HARDWARE_ERROR
mdefine_line|#define HARDWARE_ERROR          0x04
DECL|macro|ILLEGAL_REQUEST
mdefine_line|#define ILLEGAL_REQUEST         0x05
DECL|macro|UNIT_ATTENTION
mdefine_line|#define UNIT_ATTENTION          0x06
DECL|macro|DATA_PROTECT
mdefine_line|#define DATA_PROTECT            0x07
DECL|macro|ABORTED_COMMAND
mdefine_line|#define ABORTED_COMMAND         0x0b
DECL|macro|MISCOMPARE
mdefine_line|#define MISCOMPARE              0x0e
multiline_comment|/* We want some additional flags for cd-rom drives.&n;   To save space in the ide_drive_t struct, use some fields which&n;   doesn&squot;t make sense for cd-roms -- `bios_sect&squot; and `bios_head&squot;. */
multiline_comment|/* Configuration flags.  These describe the capabilities of the drive.&n;   They generally do not change after initialization, unless we learn&n;   more about the drive from stuff failing. */
DECL|struct|ide_cd_config_flags
r_struct
id|ide_cd_config_flags
(brace
DECL|member|drq_interrupt
id|__u8
id|drq_interrupt
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Device sends an interrupt when ready&n;&t;&t;&t;&t;      for a packet command. */
DECL|member|no_doorlock
id|__u8
id|no_doorlock
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Drive cannot lock the door. */
macro_line|#if ! STANDARD_ATAPI
DECL|member|old_readcd
id|__u8
id|old_readcd
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Drive uses old READ CD opcode. */
DECL|member|playmsf_as_bcd
id|__u8
id|playmsf_as_bcd
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* PLAYMSF command takes BCD args. */
DECL|member|tocaddr_as_bcd
id|__u8
id|tocaddr_as_bcd
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* TOC addresses are in BCD. */
DECL|member|toctracks_as_bcd
id|__u8
id|toctracks_as_bcd
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* TOC track numbers are in BCD. */
DECL|member|subchan_as_bcd
id|__u8
id|subchan_as_bcd
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Subchannel info is in BCD. */
macro_line|#endif  /* not STANDARD_ATAPI */
DECL|member|reserved
id|__u8
id|reserved
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|CDROM_CONFIG_FLAGS
mdefine_line|#define CDROM_CONFIG_FLAGS(drive) ((struct ide_cd_config_flags *)&amp;((drive)-&gt;bios_sect))
multiline_comment|/* State flags.  These give information about the current state of the&n;   drive, and will change during normal operation. */
DECL|struct|ide_cd_state_flags
r_struct
id|ide_cd_state_flags
(brace
DECL|member|media_changed
id|__u8
id|media_changed
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Driver has noticed a media change. */
DECL|member|toc_valid
id|__u8
id|toc_valid
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Saved TOC information is current. */
DECL|member|door_locked
id|__u8
id|door_locked
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* We think that the drive door is locked. */
DECL|member|eject_on_close
id|__u8
id|eject_on_close
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Drive should eject when device is closed. */
DECL|member|sanyo_slot
id|__u8
id|sanyo_slot
suffix:colon
l_int|2
suffix:semicolon
multiline_comment|/* Sanyo 3 CD changer support */
DECL|member|reserved
id|__u8
id|reserved
suffix:colon
l_int|2
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|CDROM_STATE_FLAGS
mdefine_line|#define CDROM_STATE_FLAGS(drive)  ((struct ide_cd_state_flags *)&amp;((drive)-&gt;bios_head))
DECL|struct|atapi_request_sense
r_struct
id|atapi_request_sense
(brace
DECL|member|error_code
r_int
r_char
id|error_code
suffix:colon
l_int|7
suffix:semicolon
DECL|member|valid
r_int
r_char
id|valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reserved1
id|byte
id|reserved1
suffix:semicolon
DECL|member|sense_key
r_int
r_char
id|sense_key
suffix:colon
l_int|4
suffix:semicolon
DECL|member|reserved2
r_int
r_char
id|reserved2
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ili
r_int
r_char
id|ili
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reserved3
r_int
r_char
id|reserved3
suffix:colon
l_int|2
suffix:semicolon
DECL|member|info
id|byte
id|info
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|sense_len
id|byte
id|sense_len
suffix:semicolon
DECL|member|command_info
id|byte
id|command_info
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|asc
id|byte
id|asc
suffix:semicolon
DECL|member|ascq
id|byte
id|ascq
suffix:semicolon
DECL|member|fru
id|byte
id|fru
suffix:semicolon
DECL|member|sense_key_specific
id|byte
id|sense_key_specific
(braket
l_int|3
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|packet_command
r_struct
id|packet_command
(brace
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
DECL|member|buflen
r_int
id|buflen
suffix:semicolon
DECL|member|stat
r_int
id|stat
suffix:semicolon
DECL|member|sense_data
r_struct
id|atapi_request_sense
op_star
id|sense_data
suffix:semicolon
DECL|member|c
r_int
r_char
id|c
(braket
l_int|12
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Structure of a MSF cdrom address. */
DECL|struct|atapi_msf
r_struct
id|atapi_msf
(brace
DECL|member|reserved
id|byte
id|reserved
suffix:semicolon
DECL|member|minute
id|byte
id|minute
suffix:semicolon
DECL|member|second
id|byte
id|second
suffix:semicolon
DECL|member|frame
id|byte
id|frame
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Space to hold the disk TOC. */
DECL|macro|MAX_TRACKS
mdefine_line|#define MAX_TRACKS 99
DECL|struct|atapi_toc_header
r_struct
id|atapi_toc_header
(brace
DECL|member|toc_length
r_int
r_int
id|toc_length
suffix:semicolon
DECL|member|first_track
id|byte
id|first_track
suffix:semicolon
DECL|member|last_track
id|byte
id|last_track
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|atapi_toc_entry
r_struct
id|atapi_toc_entry
(brace
DECL|member|reserved1
id|byte
id|reserved1
suffix:semicolon
DECL|member|control
r_int
id|control
suffix:colon
l_int|4
suffix:semicolon
DECL|member|adr
r_int
id|adr
suffix:colon
l_int|4
suffix:semicolon
DECL|member|track
id|byte
id|track
suffix:semicolon
DECL|member|reserved2
id|byte
id|reserved2
suffix:semicolon
r_union
(brace
DECL|member|lba
r_int
id|lba
suffix:semicolon
DECL|member|msf
r_struct
id|atapi_msf
id|msf
suffix:semicolon
DECL|member|addr
)brace
id|addr
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|atapi_toc
r_struct
id|atapi_toc
(brace
DECL|member|last_session_lba
r_int
id|last_session_lba
suffix:semicolon
DECL|member|xa_flag
r_int
id|xa_flag
suffix:semicolon
DECL|member|capacity
r_int
id|capacity
suffix:semicolon
DECL|member|hdr
r_struct
id|atapi_toc_header
id|hdr
suffix:semicolon
DECL|member|ent
r_struct
id|atapi_toc_entry
id|ent
(braket
id|MAX_TRACKS
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* One extra for the leadout. */
)brace
suffix:semicolon
multiline_comment|/* This structure is annoyingly close to, but not identical with,&n;   the cdrom_subchnl structure from cdrom.h. */
DECL|struct|atapi_cdrom_subchnl
r_struct
id|atapi_cdrom_subchnl
(brace
DECL|member|acdsc_reserved
id|u_char
id|acdsc_reserved
suffix:semicolon
DECL|member|acdsc_audiostatus
id|u_char
id|acdsc_audiostatus
suffix:semicolon
DECL|member|acdsc_length
id|u_short
id|acdsc_length
suffix:semicolon
DECL|member|acdsc_format
id|u_char
id|acdsc_format
suffix:semicolon
DECL|member|acdsc_adr
id|u_char
id|acdsc_adr
suffix:colon
l_int|4
suffix:semicolon
DECL|member|acdsc_ctrl
id|u_char
id|acdsc_ctrl
suffix:colon
l_int|4
suffix:semicolon
DECL|member|acdsc_trk
id|u_char
id|acdsc_trk
suffix:semicolon
DECL|member|acdsc_ind
id|u_char
id|acdsc_ind
suffix:semicolon
r_union
(brace
DECL|member|msf
r_struct
id|atapi_msf
id|msf
suffix:semicolon
DECL|member|lba
r_int
id|lba
suffix:semicolon
DECL|member|acdsc_absaddr
)brace
id|acdsc_absaddr
suffix:semicolon
r_union
(brace
DECL|member|msf
r_struct
id|atapi_msf
id|msf
suffix:semicolon
DECL|member|lba
r_int
id|lba
suffix:semicolon
DECL|member|acdsc_reladdr
)brace
id|acdsc_reladdr
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Extra per-device info for cdrom drives. */
DECL|struct|cdrom_info
r_struct
id|cdrom_info
(brace
multiline_comment|/* Buffer for table of contents.  NULL if we haven&squot;t allocated&n;&t;   a TOC buffer for this device yet. */
DECL|member|toc
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
multiline_comment|/* Sector buffer.  If a read request wants only the first part&n;&t;   of a cdrom block, we cache the rest of the block here,&n;&t;   in the expectation that that data is going to be wanted soon.&n;&t;   SECTOR_BUFFERED is the number of the first buffered sector,&n;&t;   and NSECTORS_BUFFERED is the number of sectors in the buffer.&n;&t;   Before the buffer is allocated, we should have&n;&t;   SECTOR_BUFFER == NULL and NSECTORS_BUFFERED == 0. */
DECL|member|sector_buffered
r_int
r_int
id|sector_buffered
suffix:semicolon
DECL|member|nsectors_buffered
r_int
r_int
id|nsectors_buffered
suffix:semicolon
DECL|member|sector_buffer
r_char
op_star
id|sector_buffer
suffix:semicolon
multiline_comment|/* The result of the last successful request sense command&n;&t;   on this device. */
DECL|member|sense_data
r_struct
id|atapi_request_sense
id|sense_data
suffix:semicolon
DECL|member|request_sense_request
r_struct
id|request
id|request_sense_request
suffix:semicolon
DECL|member|request_sense_pc
r_struct
id|packet_command
id|request_sense_pc
suffix:semicolon
DECL|member|dma
r_int
id|dma
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|SECTOR_BUFFER_SIZE
mdefine_line|#define SECTOR_BUFFER_SIZE CD_FRAMESIZE
"&f;"
multiline_comment|/****************************************************************************&n; * Descriptions of ATAPI error codes.&n; */
DECL|macro|ARY_LEN
mdefine_line|#define ARY_LEN(a) ((sizeof(a) / sizeof(a[0])))
macro_line|#if VERBOSE_IDE_CD_ERRORS
multiline_comment|/* From Table 124 of the ATAPI 1.2 spec. */
DECL|variable|sense_key_texts
r_char
op_star
id|sense_key_texts
(braket
l_int|16
)braket
op_assign
(brace
l_string|&quot;No sense data&quot;
comma
l_string|&quot;Recovered error&quot;
comma
l_string|&quot;Not ready&quot;
comma
l_string|&quot;Medium error&quot;
comma
l_string|&quot;Hardware error&quot;
comma
l_string|&quot;Illegal request&quot;
comma
l_string|&quot;Unit attention&quot;
comma
l_string|&quot;Data protect&quot;
comma
l_string|&quot;(reserved)&quot;
comma
l_string|&quot;(reserved)&quot;
comma
l_string|&quot;(reserved)&quot;
comma
l_string|&quot;Aborted command&quot;
comma
l_string|&quot;(reserved)&quot;
comma
l_string|&quot;(reserved)&quot;
comma
l_string|&quot;Miscompare&quot;
comma
l_string|&quot;(reserved)&quot;
comma
)brace
suffix:semicolon
multiline_comment|/* From Table 125 of the ATAPI 1.2 spec. */
r_struct
(brace
DECL|member|asc_ascq
r_int
id|asc_ascq
suffix:semicolon
DECL|member|text
r_char
op_star
id|text
suffix:semicolon
DECL|variable|sense_data_texts
)brace
id|sense_data_texts
(braket
)braket
op_assign
(brace
(brace
l_int|0x0000
comma
l_string|&quot;No additional sense information&quot;
)brace
comma
(brace
l_int|0x0011
comma
l_string|&quot;Audio play operation in progress&quot;
)brace
comma
(brace
l_int|0x0012
comma
l_string|&quot;Audio play operation paused&quot;
)brace
comma
(brace
l_int|0x0013
comma
l_string|&quot;Audio play operation successfully completed&quot;
)brace
comma
(brace
l_int|0x0014
comma
l_string|&quot;Audio play operation stopped due to error&quot;
)brace
comma
(brace
l_int|0x0015
comma
l_string|&quot;No current audio status to return&quot;
)brace
comma
(brace
l_int|0x0200
comma
l_string|&quot;No seek complete&quot;
)brace
comma
(brace
l_int|0x0400
comma
l_string|&quot;Logical unit not ready - cause not reportable&quot;
)brace
comma
(brace
l_int|0x0401
comma
l_string|&quot;Logical unit not ready - in progress (sic) of becoming ready&quot;
)brace
comma
(brace
l_int|0x0402
comma
l_string|&quot;Logical unit not ready - initializing command required&quot;
)brace
comma
(brace
l_int|0x0403
comma
l_string|&quot;Logical unit not ready - manual intervention required&quot;
)brace
comma
(brace
l_int|0x0600
comma
l_string|&quot;No reference position found&quot;
)brace
comma
(brace
l_int|0x0900
comma
l_string|&quot;Track following error&quot;
)brace
comma
(brace
l_int|0x0901
comma
l_string|&quot;Tracking servo failure&quot;
)brace
comma
(brace
l_int|0x0902
comma
l_string|&quot;Focus servo failure&quot;
)brace
comma
(brace
l_int|0x0903
comma
l_string|&quot;Spindle servo failure&quot;
)brace
comma
(brace
l_int|0x1100
comma
l_string|&quot;Unrecovered read error&quot;
)brace
comma
(brace
l_int|0x1106
comma
l_string|&quot;CIRC unrecovered error&quot;
)brace
comma
(brace
l_int|0x1500
comma
l_string|&quot;Random positioning error&quot;
)brace
comma
(brace
l_int|0x1501
comma
l_string|&quot;Mechanical positioning error&quot;
)brace
comma
(brace
l_int|0x1502
comma
l_string|&quot;Positioning error detected by read of medium&quot;
)brace
comma
(brace
l_int|0x1700
comma
l_string|&quot;Recovered data with no error correction applied&quot;
)brace
comma
(brace
l_int|0x1701
comma
l_string|&quot;Recovered data with retries&quot;
)brace
comma
(brace
l_int|0x1702
comma
l_string|&quot;Recovered data with positive head offset&quot;
)brace
comma
(brace
l_int|0x1703
comma
l_string|&quot;Recovered data with negative head offset&quot;
)brace
comma
(brace
l_int|0x1704
comma
l_string|&quot;Recovered data with retries and/or CIRC applied&quot;
)brace
comma
(brace
l_int|0x1705
comma
l_string|&quot;Recovered data using previous sector ID&quot;
)brace
comma
(brace
l_int|0x1800
comma
l_string|&quot;Recovered data with error correction applied&quot;
)brace
comma
(brace
l_int|0x1801
comma
l_string|&quot;Recovered data with error correction and retries applied&quot;
)brace
comma
(brace
l_int|0x1802
comma
l_string|&quot;Recovered data - the data was auto-reallocated&quot;
)brace
comma
(brace
l_int|0x1803
comma
l_string|&quot;Recovered data with CIRC&quot;
)brace
comma
(brace
l_int|0x1804
comma
l_string|&quot;Recovered data with L-EC&quot;
)brace
comma
(brace
l_int|0x1805
comma
l_string|&quot;Recovered data - recommend reassignment&quot;
)brace
comma
(brace
l_int|0x1806
comma
l_string|&quot;Recovered data - recommend rewrite&quot;
)brace
comma
(brace
l_int|0x1a00
comma
l_string|&quot;Parameter list length error&quot;
)brace
comma
(brace
l_int|0x2000
comma
l_string|&quot;Invalid command operation code&quot;
)brace
comma
(brace
l_int|0x2100
comma
l_string|&quot;Logical block address out of range&quot;
)brace
comma
(brace
l_int|0x2400
comma
l_string|&quot;Invalid field in command packet&quot;
)brace
comma
(brace
l_int|0x2600
comma
l_string|&quot;Invalid field in parameter list&quot;
)brace
comma
(brace
l_int|0x2601
comma
l_string|&quot;Parameter not supported&quot;
)brace
comma
(brace
l_int|0x2602
comma
l_string|&quot;Parameter value invalid&quot;
)brace
comma
(brace
l_int|0x2603
comma
l_string|&quot;Threshold parameters not supported&quot;
)brace
comma
(brace
l_int|0x2800
comma
l_string|&quot;Not ready to ready transition, medium may have changed&quot;
)brace
comma
(brace
l_int|0x2900
comma
l_string|&quot;Power on, reset or bus device reset occurred&quot;
)brace
comma
(brace
l_int|0x2a00
comma
l_string|&quot;Parameters changed&quot;
)brace
comma
(brace
l_int|0x2a01
comma
l_string|&quot;Mode parameters changed&quot;
)brace
comma
(brace
l_int|0x3000
comma
l_string|&quot;Incompatible medium installed&quot;
)brace
comma
(brace
l_int|0x3001
comma
l_string|&quot;Cannot read medium - unknown format&quot;
)brace
comma
(brace
l_int|0x3002
comma
l_string|&quot;Cannot read medium - incompatible format&quot;
)brace
comma
(brace
l_int|0x3700
comma
l_string|&quot;Rounded parameter&quot;
)brace
comma
(brace
l_int|0x3900
comma
l_string|&quot;Saving parameters not supported&quot;
)brace
comma
(brace
l_int|0x3a00
comma
l_string|&quot;Medium not present&quot;
)brace
comma
(brace
l_int|0x3f00
comma
l_string|&quot;ATAPI CD-ROM drive operating conditions have changed&quot;
)brace
comma
(brace
l_int|0x3f01
comma
l_string|&quot;Microcode has been changed&quot;
)brace
comma
(brace
l_int|0x3f02
comma
l_string|&quot;Changed operating definition&quot;
)brace
comma
(brace
l_int|0x3f03
comma
l_string|&quot;Inquiry data has changed&quot;
)brace
comma
(brace
l_int|0x4000
comma
l_string|&quot;Diagnostic failure on component (ASCQ)&quot;
)brace
comma
(brace
l_int|0x4400
comma
l_string|&quot;Internal ATAPI CD-ROM drive failure&quot;
)brace
comma
(brace
l_int|0x4e00
comma
l_string|&quot;Overlapped commands attempted&quot;
)brace
comma
(brace
l_int|0x5300
comma
l_string|&quot;Media load or eject failed&quot;
)brace
comma
(brace
l_int|0x5302
comma
l_string|&quot;Medium removal prevented&quot;
)brace
comma
(brace
l_int|0x5700
comma
l_string|&quot;Unable to recover table of contents&quot;
)brace
comma
(brace
l_int|0x5a00
comma
l_string|&quot;Operator request or state change input (unspecified)&quot;
)brace
comma
(brace
l_int|0x5a01
comma
l_string|&quot;Operator medium removal request&quot;
)brace
comma
(brace
l_int|0x5b00
comma
l_string|&quot;Threshold condition met&quot;
)brace
comma
(brace
l_int|0x5c00
comma
l_string|&quot;Status change&quot;
)brace
comma
(brace
l_int|0x6300
comma
l_string|&quot;End of user area encountered on this track&quot;
)brace
comma
(brace
l_int|0x6400
comma
l_string|&quot;Illegal mode for this track&quot;
)brace
comma
(brace
l_int|0xbf00
comma
l_string|&quot;Loss of streaming&quot;
)brace
comma
)brace
suffix:semicolon
macro_line|#endif
"&f;"
multiline_comment|/****************************************************************************&n; * Generic packet command support and error handling routines.&n; */
r_static
DECL|function|cdrom_analyze_sense_data
r_void
id|cdrom_analyze_sense_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
comma
r_struct
id|packet_command
op_star
id|failed_command
)paren
(brace
multiline_comment|/* Don&squot;t print not ready or unit attention errors for READ_SUBCHANNEL.&n;&t;   Workman (and probably other programs) uses this command to poll&n;&t;   the drive, and we don&squot;t want to fill the syslog&n;&t;   with useless errors. */
r_if
c_cond
(paren
id|failed_command
op_logical_and
id|failed_command-&gt;c
(braket
l_int|0
)braket
op_eq
id|SCMD_READ_SUBCHANNEL
op_logical_and
(paren
id|reqbuf-&gt;sense_key
op_eq
id|NOT_READY
op_logical_or
id|reqbuf-&gt;sense_key
op_eq
id|UNIT_ATTENTION
)paren
)paren
r_return
suffix:semicolon
macro_line|#if VERBOSE_IDE_CD_ERRORS
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|s
suffix:semicolon
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
id|printk
(paren
l_string|&quot;ATAPI device %s:&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;  Error code: 0x%02x&bslash;n&quot;
comma
id|reqbuf-&gt;error_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_ge
l_int|0
op_logical_and
id|reqbuf-&gt;sense_key
OL
id|ARY_LEN
(paren
id|sense_key_texts
)paren
)paren
id|s
op_assign
id|sense_key_texts
(braket
id|reqbuf-&gt;sense_key
)braket
suffix:semicolon
r_else
id|s
op_assign
l_string|&quot;(bad sense key)&quot;
suffix:semicolon
id|printk
(paren
l_string|&quot;  Sense key: 0x%02x - %s&bslash;n&quot;
comma
id|reqbuf-&gt;sense_key
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf-&gt;asc
op_eq
l_int|0x40
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;Diagnostic failure on component 0x%02x&quot;
comma
id|reqbuf-&gt;ascq
)paren
suffix:semicolon
id|s
op_assign
id|buf
suffix:semicolon
)brace
r_else
(brace
r_int
id|lo
comma
id|hi
suffix:semicolon
r_int
id|key
op_assign
(paren
id|reqbuf-&gt;asc
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|reqbuf-&gt;ascq
op_ge
l_int|0x80
op_logical_and
id|reqbuf-&gt;ascq
op_le
l_int|0xdd
)paren
)paren
id|key
op_or_assign
id|reqbuf-&gt;ascq
suffix:semicolon
id|lo
op_assign
l_int|0
suffix:semicolon
id|hi
op_assign
id|ARY_LEN
(paren
id|sense_data_texts
)paren
suffix:semicolon
id|s
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|hi
OG
id|lo
)paren
(brace
r_int
id|mid
op_assign
(paren
id|lo
op_plus
id|hi
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|sense_data_texts
(braket
id|mid
)braket
dot
id|asc_ascq
op_eq
id|key
)paren
(brace
id|s
op_assign
id|sense_data_texts
(braket
id|mid
)braket
dot
id|text
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense_data_texts
(braket
id|mid
)braket
dot
id|asc_ascq
OG
id|key
)paren
id|hi
op_assign
id|mid
suffix:semicolon
r_else
id|lo
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|s
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|reqbuf-&gt;asc
OG
l_int|0x80
)paren
id|s
op_assign
l_string|&quot;(vendor-specific error)&quot;
suffix:semicolon
r_else
id|s
op_assign
l_string|&quot;(reserved error code)&quot;
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;  Additional sense data: 0x%02x, 0x%02x  - %s&bslash;n&quot;
comma
id|reqbuf-&gt;asc
comma
id|reqbuf-&gt;ascq
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|failed_command
op_ne
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;  Failed packet command: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|failed_command-&gt;c
)paren
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot;%02x &quot;
comma
id|failed_command-&gt;c
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
(paren
id|reqbuf-&gt;sense_key_specific
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;  Error in %s byte %d&quot;
comma
(paren
id|reqbuf-&gt;sense_key_specific
(braket
l_int|0
)braket
op_amp
l_int|0x40
)paren
op_ne
l_int|0
ques
c_cond
l_string|&quot;command packet&quot;
suffix:colon
l_string|&quot;command data&quot;
comma
(paren
id|reqbuf-&gt;sense_key_specific
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_plus
id|reqbuf-&gt;sense_key_specific
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reqbuf-&gt;sense_key_specific
(braket
l_int|0
)braket
op_amp
l_int|0x40
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot; bit %d&quot;
comma
id|reqbuf-&gt;sense_key_specific
(braket
l_int|0
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#else /* not VERBOSE_IDE_CD_ERRORS */
multiline_comment|/* Suppress printing unit attention and `in progress of becoming ready&squot;&n;&t;   errors when we&squot;re not being verbose. */
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|UNIT_ATTENTION
op_logical_or
(paren
id|reqbuf-&gt;sense_key
op_eq
id|NOT_READY
op_logical_and
(paren
id|reqbuf-&gt;asc
op_eq
l_int|4
op_logical_or
id|reqbuf-&gt;asc
op_eq
l_int|0x3a
)paren
)paren
)paren
r_return
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: code: 0x%02x  key: 0x%02x  asc: 0x%02x  ascq: 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|reqbuf-&gt;error_code
comma
id|reqbuf-&gt;sense_key
comma
id|reqbuf-&gt;asc
comma
id|reqbuf-&gt;ascq
)paren
suffix:semicolon
macro_line|#endif /* not VERBOSE_IDE_CD_ERRORS */
)brace
multiline_comment|/* Fix up a possibly partially-processed request so that we can&n;   start it over entirely, or even put it back on the request queue. */
DECL|function|restore_request
r_static
r_void
id|restore_request
(paren
r_struct
id|request
op_star
id|rq
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;buffer
op_ne
id|rq-&gt;bh-&gt;b_data
)paren
(brace
r_int
id|n
op_assign
(paren
id|rq-&gt;buffer
op_minus
id|rq-&gt;bh-&gt;b_data
)paren
op_div
id|SECTOR_SIZE
suffix:semicolon
id|rq-&gt;buffer
op_assign
id|rq-&gt;bh-&gt;b_data
suffix:semicolon
id|rq-&gt;nr_sectors
op_add_assign
id|n
suffix:semicolon
id|rq-&gt;sector
op_sub_assign
id|n
suffix:semicolon
)brace
id|rq-&gt;current_nr_sectors
op_assign
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
suffix:semicolon
)brace
DECL|function|cdrom_queue_request_sense
r_static
r_void
id|cdrom_queue_request_sense
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|semaphore
op_star
id|sem
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
comma
r_struct
id|packet_command
op_star
id|failed_command
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* If the request didn&squot;t explicitly specify where&n;&t;   to put the sense data, use the statically allocated structure. */
r_if
c_cond
(paren
id|reqbuf
op_eq
l_int|NULL
)paren
id|reqbuf
op_assign
op_amp
id|info-&gt;sense_data
suffix:semicolon
multiline_comment|/* Make up a new request to retrieve sense information. */
id|pc
op_assign
op_amp
id|info-&gt;request_sense_pc
suffix:semicolon
id|memset
(paren
id|pc
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pc
)paren
)paren
suffix:semicolon
multiline_comment|/* The request_sense structure has an odd number of (16-bit) words,&n;&t;   which won&squot;t work well with 32-bit transfers.  However, we don&squot;t care&n;&t;   about the last two bytes, so just truncate the structure down&n;&t;   to an even length. */
id|len
op_assign
r_sizeof
(paren
op_star
id|reqbuf
)paren
op_div
l_int|4
suffix:semicolon
id|len
op_mul_assign
l_int|4
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|len
suffix:semicolon
id|pc-&gt;buffer
op_assign
(paren
r_char
op_star
)paren
id|reqbuf
suffix:semicolon
id|pc-&gt;buflen
op_assign
id|len
suffix:semicolon
id|pc-&gt;sense_data
op_assign
(paren
r_struct
id|atapi_request_sense
op_star
)paren
id|failed_command
suffix:semicolon
multiline_comment|/* stuff the sense request in front of our current request */
id|rq
op_assign
op_amp
id|info-&gt;request_sense_request
suffix:semicolon
id|ide_init_drive_cmd
(paren
id|rq
)paren
suffix:semicolon
id|rq-&gt;cmd
op_assign
id|REQUEST_SENSE_COMMAND
suffix:semicolon
id|rq-&gt;buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
id|rq-&gt;sem
op_assign
id|sem
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
id|rq
comma
id|ide_preempt
)paren
suffix:semicolon
)brace
DECL|function|cdrom_end_request
r_static
r_void
id|cdrom_end_request
(paren
r_int
id|uptodate
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
multiline_comment|/* The code in blk.h can screw us up on error recovery if the block&n;&t;   size is larger than 1k.  Fix that up here. */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
op_logical_and
id|rq-&gt;bh
op_ne
l_int|0
)paren
(brace
r_int
id|adj
op_assign
id|rq-&gt;current_nr_sectors
op_minus
l_int|1
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|adj
suffix:semicolon
id|rq-&gt;sector
op_add_assign
id|adj
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|REQUEST_SENSE_COMMAND
op_logical_and
id|uptodate
)paren
(brace
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|cdrom_analyze_sense_data
(paren
id|drive
comma
(paren
r_struct
id|atapi_request_sense
op_star
)paren
(paren
id|pc-&gt;buffer
op_minus
id|pc-&gt;c
(braket
l_int|4
)braket
)paren
comma
(paren
r_struct
id|packet_command
op_star
)paren
id|pc-&gt;sense_data
)paren
suffix:semicolon
)brace
id|ide_end_request
(paren
id|uptodate
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Mark that we&squot;ve seen a media change, and invalidate our internal&n;   buffers. */
DECL|function|cdrom_saw_media_change
r_static
r_void
id|cdrom_saw_media_change
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|1
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|0
suffix:semicolon
id|info-&gt;nsectors_buffered
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Returns 0 if the request should be continued.&n;   Returns 1 if the request was ended. */
DECL|function|cdrom_decode_status
r_static
r_int
id|cdrom_decode_status
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|good_stat
comma
r_int
op_star
id|stat_ret
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|stat
comma
id|err
comma
id|sense_key
comma
id|cmd
suffix:semicolon
multiline_comment|/* Check for errors. */
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
op_star
id|stat_ret
op_assign
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
(paren
id|stat
comma
id|good_stat
comma
id|BAD_R_STAT
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Got an error. */
id|err
op_assign
id|IN_BYTE
(paren
id|IDE_ERROR_REG
)paren
suffix:semicolon
id|sense_key
op_assign
id|err
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|rq
op_eq
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;%s : missing request in cdrom_decode_status&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_else
(brace
id|cmd
op_assign
id|rq-&gt;cmd
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|REQUEST_SENSE_COMMAND
)paren
(brace
multiline_comment|/* We got an error trying to get sense info&n;&t;&t;&t;   from the drive (probably while trying&n;&t;&t;&t;   to recover from a former error).  Just give up. */
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
id|ide_error
(paren
id|drive
comma
l_string|&quot;request sense failure&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|PACKET_COMMAND
)paren
(brace
multiline_comment|/* All other functions, except for READ. */
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
r_struct
id|semaphore
op_star
id|sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Check for tray open. */
r_if
c_cond
(paren
id|sense_key
op_eq
id|NOT_READY
)paren
(brace
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Print an error message to the syslog.&n;&t;&t;&t;&t;   Exception: don&squot;t print anything if this&n;&t;&t;&t;&t;   is a read subchannel command.  This is&n;&t;&t;&t;&t;   because workman constantly polls the drive&n;&t;&t;&t;&t;   with this command, and we don&squot;t want&n;&t;&t;&t;&t;   to uselessly fill up the syslog. */
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|SCMD_READ_SUBCHANNEL
)paren
id|printk
(paren
l_string|&quot;%s : tray open or drive not ready&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense_key
op_eq
id|UNIT_ATTENTION
)paren
(brace
multiline_comment|/* Check for media change. */
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: media changed&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, print an error. */
id|ide_dump_status
(paren
id|drive
comma
l_string|&quot;packet command error&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the error flag and complete the request.&n;&t;&t;&t;   Then, if we have a CHECK CONDITION status,&n;&t;&t;&t;   queue a request sense command.  We must be careful,&n;&t;&t;&t;   though: we don&squot;t want the thread in&n;&t;&t;&t;   cdrom_queue_packet_command to wake up until&n;&t;&t;&t;   the request sense has completed.  We do this&n;&t;&t;&t;   by transferring the semaphore from the packet&n;&t;&t;&t;   command request to the request sense request. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_ne
l_int|0
)paren
(brace
id|sem
op_assign
id|rq-&gt;sem
suffix:semicolon
id|rq-&gt;sem
op_assign
l_int|NULL
suffix:semicolon
)brace
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_ne
l_int|0
)paren
id|cdrom_queue_request_sense
(paren
id|drive
comma
id|sem
comma
id|pc-&gt;sense_data
comma
id|pc
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Handle errors from READ requests. */
r_if
c_cond
(paren
id|sense_key
op_eq
id|NOT_READY
)paren
(brace
multiline_comment|/* Tray open. */
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Fail the request. */
id|printk
(paren
l_string|&quot;%s : tray open&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense_key
op_eq
id|UNIT_ATTENTION
)paren
(brace
multiline_comment|/* Media change. */
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Arrange to retry the request.&n;&t;&t;&t;&t;   But be sure to give up if we&squot;ve retried&n;&t;&t;&t;&t;   too many times. */
r_if
c_cond
(paren
op_increment
id|rq-&gt;errors
OG
id|ERROR_MAX
)paren
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_or
id|sense_key
op_eq
id|DATA_PROTECT
)paren
(brace
multiline_comment|/* No point in retrying after an illegal&n;&t;&t;&t;&t;   request or data protect error.*/
id|ide_dump_status
(paren
id|drive
comma
l_string|&quot;command error&quot;
comma
id|stat
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|err
op_amp
op_complement
id|ABRT_ERR
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Go to the default handler&n;&t;&t;&t;&t;   for other errors. */
id|ide_error
(paren
id|drive
comma
l_string|&quot;cdrom_decode_status&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_increment
id|rq-&gt;errors
OG
id|ERROR_MAX
)paren
)paren
(brace
multiline_comment|/* We&squot;ve racked up too many retries.  Abort. */
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/* If we got a CHECK_CONDITION status,&n;&t;&t;&t;   queue a request sense command. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_ne
l_int|0
)paren
id|cdrom_queue_request_sense
(paren
id|drive
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Retry, or handle the next request. */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Set up the device registers for transferring a packet command on DEV,&n;   expecting to later transfer XFERLEN bytes.  HANDLER is the routine&n;   which actually transfers the command to the drive.  If this is a&n;   drq_interrupt device, this routine will arrange for HANDLER to be&n;   called when the interrupt from the drive arrives.  Otherwise, HANDLER&n;   will be called immediately after the drive is prepared for the transfer. */
DECL|function|cdrom_start_packet_command
r_static
r_int
id|cdrom_start_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|xferlen
comma
id|ide_handler_t
op_star
id|handler
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
multiline_comment|/* Wait for the controller to be idle. */
r_if
c_cond
(paren
id|ide_wait_stat
(paren
id|drive
comma
l_int|0
comma
id|BUSY_STAT
comma
id|WAIT_READY
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;dma
)paren
id|info-&gt;dma
op_assign
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_read
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* Set up the controller registers. */
id|OUT_BYTE
(paren
id|info-&gt;dma
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
l_int|0
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
l_int|0
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|xferlen
op_amp
l_int|0xff
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|xferlen
op_rshift
l_int|8
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;dma
)paren
(paren
r_void
)paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_begin
comma
id|drive
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|WAIT_CMD
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* packet command */
)brace
r_else
(brace
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* packet command */
(paren
op_star
id|handler
)paren
(paren
id|drive
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Send a packet command to DRIVE described by CMD_BUF and CMD_LEN.&n;   The device registers must have already been prepared&n;   by cdrom_start_packet_command.&n;   HANDLER is the interrupt handler to call when the command completes&n;   or there&squot;s data ready. */
DECL|function|cdrom_transfer_packet_command
r_static
r_int
id|cdrom_transfer_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
r_char
op_star
id|cmd_buf
comma
r_int
id|cmd_len
comma
id|ide_handler_t
op_star
id|handler
)paren
(brace
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
)paren
(brace
multiline_comment|/* Here we should have been called after receiving an interrupt&n;&t;&t;   from the device.  DRQ should how be set. */
r_int
id|stat_dum
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
id|drive
comma
id|DRQ_STAT
comma
op_amp
id|stat_dum
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, we must wait for DRQ to get set. */
r_if
c_cond
(paren
id|ide_wait_stat
(paren
id|drive
comma
id|DRQ_STAT
comma
id|BUSY_STAT
comma
id|WAIT_READY
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Arm the interrupt handler. */
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|WAIT_CMD
)paren
suffix:semicolon
multiline_comment|/* Send the command to the device. */
id|atapi_output_bytes
(paren
id|drive
comma
id|cmd_buf
comma
id|cmd_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Block read functions.&n; */
multiline_comment|/*&n; * Buffer up to SECTORS_TO_TRANSFER sectors from the drive in our sector&n; * buffer.  Once the first sector is added, any subsequent sectors are&n; * assumed to be continuous (until the buffer is cleared).  For the first&n; * sector added, SECTOR is its sector number.  (SECTOR is then ignored until&n; * the buffer is cleared.)&n; */
DECL|function|cdrom_buffer_sectors
r_static
r_void
id|cdrom_buffer_sectors
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|sector
comma
r_int
id|sectors_to_transfer
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
multiline_comment|/* Number of sectors to read into the buffer. */
r_int
id|sectors_to_buffer
op_assign
id|MIN
(paren
id|sectors_to_transfer
comma
(paren
id|SECTOR_BUFFER_SIZE
op_rshift
id|SECTOR_BITS
)paren
op_minus
id|info-&gt;nsectors_buffered
)paren
suffix:semicolon
r_char
op_star
id|dest
suffix:semicolon
multiline_comment|/* If we don&squot;t yet have a sector buffer, try to allocate one.&n;&t;   If we can&squot;t get one atomically, it&squot;s not fatal -- we&squot;ll just throw&n;&t;   the data away rather than caching it. */
r_if
c_cond
(paren
id|info-&gt;sector_buffer
op_eq
l_int|NULL
)paren
(brace
id|info-&gt;sector_buffer
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
(paren
id|SECTOR_BUFFER_SIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/* If we couldn&squot;t get a buffer,&n;&t;&t;   don&squot;t try to buffer anything... */
r_if
c_cond
(paren
id|info-&gt;sector_buffer
op_eq
l_int|NULL
)paren
id|sectors_to_buffer
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If this is the first sector in the buffer, remember its number. */
r_if
c_cond
(paren
id|info-&gt;nsectors_buffered
op_eq
l_int|0
)paren
id|info-&gt;sector_buffered
op_assign
id|sector
suffix:semicolon
multiline_comment|/* Read the data into the buffer. */
id|dest
op_assign
id|info-&gt;sector_buffer
op_plus
id|info-&gt;nsectors_buffered
op_star
id|SECTOR_SIZE
suffix:semicolon
r_while
c_loop
(paren
id|sectors_to_buffer
OG
l_int|0
)paren
(brace
id|atapi_input_bytes
(paren
id|drive
comma
id|dest
comma
id|SECTOR_SIZE
)paren
suffix:semicolon
op_decrement
id|sectors_to_buffer
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
op_increment
id|info-&gt;nsectors_buffered
suffix:semicolon
id|dest
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
)brace
multiline_comment|/* Throw away any remaining data. */
r_while
c_loop
(paren
id|sectors_to_transfer
OG
l_int|0
)paren
(brace
r_char
id|dum
(braket
id|SECTOR_SIZE
)braket
suffix:semicolon
id|atapi_input_bytes
(paren
id|drive
comma
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Check the contents of the interrupt reason register from the cdrom&n; * and attempt to recover if there are problems.  Returns  0 if everything&squot;s&n; * ok; nonzero if the request has been terminated.&n; */
r_static
r_inline
DECL|function|cdrom_read_check_ireason
r_int
id|cdrom_read_check_ireason
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|len
comma
r_int
id|ireason
)paren
(brace
id|ireason
op_and_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|ireason
op_eq
l_int|2
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ireason
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Whoops... The drive is expecting to receive data from us! */
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: &quot;
l_string|&quot;Drive wants to transfer data the wrong way!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Throw some data at the drive so it doesn&squot;t hang&n;&t;&t;   and quit this request. */
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|atapi_output_bytes
(paren
id|drive
comma
op_amp
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
id|dum
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Drive wants a command packet, or invalid ireason... */
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: bad interrupt reason %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|ireason
)paren
suffix:semicolon
)brace
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Interrupt routine.  Called when a read request has completed.&n; */
DECL|function|cdrom_read_intr
r_static
r_void
id|cdrom_read_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|stat
suffix:semicolon
r_int
id|ireason
comma
id|len
comma
id|sectors_to_transfer
comma
id|nskip
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|i
comma
id|dma
op_assign
id|info-&gt;dma
comma
id|dma_error
op_assign
l_int|0
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|dma
)paren
(brace
id|info-&gt;dma
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dma_error
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_status_bad
comma
id|drive
)paren
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: disabled DMA&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|drive-&gt;using_dma
op_assign
l_int|0
suffix:semicolon
)brace
(paren
r_void
)paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_abort
comma
id|drive
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
id|drive
comma
l_int|0
comma
op_amp
id|stat
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|dma
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dma_error
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|i
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
id|ide_error
(paren
id|drive
comma
l_string|&quot;dma error&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Read the interrupt reason and the transfer length. */
id|ireason
op_assign
id|IN_BYTE
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|len
op_assign
id|IN_BYTE
(paren
id|IDE_LCYL_REG
)paren
op_plus
l_int|256
op_star
id|IN_BYTE
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/* If DRQ is clear, the command has completed. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* If we&squot;re not done filling the current buffer, complain.&n;&t;&t;   Otherwise, complete the command normally. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
OG
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: data underrun (%ld blocks)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check that the drive is expecting to do the same thing we are. */
r_if
c_cond
(paren
id|cdrom_read_check_ireason
(paren
id|drive
comma
id|len
comma
id|ireason
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Assume that the drive will always provide data in multiples&n;&t;   of at least SECTOR_SIZE, as it gets hairy to keep track&n;&t;   of the transfers otherwise. */
r_if
c_cond
(paren
(paren
id|len
op_mod
id|SECTOR_SIZE
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: Bad transfer size %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|len
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;  This drive is not supported by this version of the driver&bslash;n&quot;
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The number of sectors we need to read from the drive. */
id|sectors_to_transfer
op_assign
id|len
op_div
id|SECTOR_SIZE
suffix:semicolon
multiline_comment|/* First, figure out if we need to bit-bucket&n;&t;   any of the leading sectors. */
id|nskip
op_assign
id|MIN
(paren
(paren
r_int
)paren
(paren
id|rq-&gt;current_nr_sectors
op_minus
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
)paren
comma
id|sectors_to_transfer
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nskip
OG
l_int|0
)paren
(brace
multiline_comment|/* We need to throw away a sector. */
r_char
id|dum
(braket
id|SECTOR_SIZE
)braket
suffix:semicolon
id|atapi_input_bytes
(paren
id|drive
comma
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_decrement
id|nskip
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
multiline_comment|/* Now loop while we still have data to read from the drive. */
r_while
c_loop
(paren
id|sectors_to_transfer
OG
l_int|0
)paren
(brace
r_int
id|this_transfer
suffix:semicolon
multiline_comment|/* If we&squot;ve filled the present buffer but there&squot;s another&n;&t;&t;   chained buffer after it, move on. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
op_logical_and
id|rq-&gt;nr_sectors
OG
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* If the buffers are full, cache the rest of the data in our&n;&t;&t;   internal buffer. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
(brace
id|cdrom_buffer_sectors
(paren
id|drive
comma
id|rq-&gt;sector
comma
id|sectors_to_transfer
)paren
suffix:semicolon
id|sectors_to_transfer
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Transfer data to the buffers.&n;&t;&t;&t;   Figure out how many sectors we can transfer&n;&t;&t;&t;   to the current buffer. */
id|this_transfer
op_assign
id|MIN
(paren
id|sectors_to_transfer
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
multiline_comment|/* Read this_transfer sectors&n;&t;&t;&t;   into the current buffer. */
r_while
c_loop
(paren
id|this_transfer
OG
l_int|0
)paren
(brace
id|atapi_input_bytes
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|SECTOR_SIZE
)paren
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
op_decrement
id|rq-&gt;nr_sectors
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_increment
id|rq-&gt;sector
suffix:semicolon
op_decrement
id|this_transfer
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Done moving data!&n;&t;   Wait for another interrupt. */
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|cdrom_read_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to satisfy some of the current read request from our cached data.&n; * Returns nonzero if the request has been completed, zero otherwise.&n; */
DECL|function|cdrom_read_from_buffer
r_static
r_int
id|cdrom_read_from_buffer
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
multiline_comment|/* Can&squot;t do anything if there&squot;s no buffer. */
r_if
c_cond
(paren
id|info-&gt;sector_buffer
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Loop while this request needs data and the next block is present&n;&t;   in our cache. */
r_while
c_loop
(paren
id|rq-&gt;nr_sectors
OG
l_int|0
op_logical_and
id|rq-&gt;sector
op_ge
id|info-&gt;sector_buffered
op_logical_and
id|rq-&gt;sector
OL
id|info-&gt;sector_buffered
op_plus
id|info-&gt;nsectors_buffered
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
id|memcpy
(paren
id|rq-&gt;buffer
comma
id|info-&gt;sector_buffer
op_plus
(paren
id|rq-&gt;sector
op_minus
id|info-&gt;sector_buffered
)paren
op_star
id|SECTOR_SIZE
comma
id|SECTOR_SIZE
)paren
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_decrement
id|rq-&gt;nr_sectors
suffix:semicolon
op_increment
id|rq-&gt;sector
suffix:semicolon
)brace
multiline_comment|/* If we&squot;ve satisfied the current request,&n;&t;   terminate it successfully. */
r_if
c_cond
(paren
id|rq-&gt;nr_sectors
op_eq
l_int|0
)paren
(brace
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Move on to the next buffer if needed. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* If this condition does not hold, then the kluge i use to&n;&t;   represent the number of sectors to skip at the start of a transfer&n;&t;   will fail.  I think that this will never happen, but let&squot;s be&n;&t;   paranoid and check. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
OL
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
op_logical_and
(paren
id|rq-&gt;sector
op_mod
id|SECTORS_PER_FRAME
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_from_buffer: buffer botch (%ld)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;sector
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Routine to send a read packet command to the drive.&n; * This is usually called directly from cdrom_start_read.&n; * However, for drq_interrupt devices, it is called from an interrupt&n; * when the drive is ready to accept the command.&n; */
DECL|function|cdrom_start_read_continuation
r_static
r_void
id|cdrom_start_read_continuation
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|nsect
comma
id|sector
comma
id|nframes
comma
id|frame
comma
id|nskip
suffix:semicolon
multiline_comment|/* Number of sectors to transfer. */
id|nsect
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
multiline_comment|/* Starting sector. */
id|sector
op_assign
id|rq-&gt;sector
suffix:semicolon
multiline_comment|/* If the requested sector doesn&squot;t start on a cdrom block boundary,&n;&t;   we must adjust the start of the transfer so that it does,&n;&t;   and remember to skip the first few sectors.&n;&t;   If the CURRENT_NR_SECTORS field is larger than the size&n;&t;   of the buffer, it will mean that we&squot;re to skip a number&n;&t;   of sectors equal to the amount by which CURRENT_NR_SECTORS&n;&t;   is larger than the buffer size. */
id|nskip
op_assign
(paren
id|sector
op_mod
id|SECTORS_PER_FRAME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nskip
OG
l_int|0
)paren
(brace
multiline_comment|/* Sanity check... */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_ne
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_start_read_continuation: buffer botch (%ld)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sector
op_sub_assign
id|nskip
suffix:semicolon
id|nsect
op_add_assign
id|nskip
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_add_assign
id|nskip
suffix:semicolon
)brace
multiline_comment|/* Convert from sectors to cdrom blocks, rounding up the transfer&n;&t;   length if needed. */
id|nframes
op_assign
(paren
id|nsect
op_plus
id|SECTORS_PER_FRAME
op_minus
l_int|1
)paren
op_div
id|SECTORS_PER_FRAME
suffix:semicolon
id|frame
op_assign
id|sector
op_div
id|SECTORS_PER_FRAME
suffix:semicolon
multiline_comment|/* Largest number of frames was can transfer at once is 64k-1. */
id|nframes
op_assign
id|MIN
(paren
id|nframes
comma
l_int|65535
)paren
suffix:semicolon
multiline_comment|/* Set up the command */
id|memset
(paren
op_amp
id|pc.c
comma
l_int|0
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|READ_10
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|nframes
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|nframes
op_amp
l_int|0xff
)paren
suffix:semicolon
id|put_unaligned
c_func
(paren
id|htonl
(paren
id|frame
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
suffix:semicolon
multiline_comment|/* Send the command to the drive and return. */
(paren
r_void
)paren
id|cdrom_transfer_packet_command
(paren
id|drive
comma
id|pc.c
comma
r_sizeof
(paren
id|pc.c
)paren
comma
op_amp
id|cdrom_read_intr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Start a read request from the CD-ROM.&n; */
DECL|function|cdrom_start_read
r_static
r_void
id|cdrom_start_read
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|minor
op_assign
id|MINOR
(paren
id|rq-&gt;rq_dev
)paren
suffix:semicolon
multiline_comment|/* If the request is relative to a partition, fix it up to refer to the&n;&t;   absolute address.  */
r_if
c_cond
(paren
(paren
id|minor
op_amp
id|PARTN_MASK
)paren
op_ne
l_int|0
)paren
(brace
id|rq-&gt;sector
op_assign
id|block
suffix:semicolon
id|minor
op_and_assign
op_complement
id|PARTN_MASK
suffix:semicolon
id|rq-&gt;rq_dev
op_assign
id|MKDEV
(paren
id|MAJOR
c_func
(paren
id|rq-&gt;rq_dev
)paren
comma
id|minor
)paren
suffix:semicolon
)brace
multiline_comment|/* We may be retrying this request after an error.  Fix up&n;&t;   any weirdness which might be present in the request packet. */
id|restore_request
(paren
id|rq
)paren
suffix:semicolon
multiline_comment|/* Satisfy whatever we can of this request from our cached sector. */
r_if
c_cond
(paren
id|cdrom_read_from_buffer
(paren
id|drive
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Clear the local sector buffer. */
id|info-&gt;nsectors_buffered
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;using_dma
op_logical_and
(paren
id|rq-&gt;sector
op_mod
id|SECTORS_PER_FRAME
op_eq
l_int|0
)paren
op_logical_and
(paren
id|rq-&gt;nr_sectors
op_mod
id|SECTORS_PER_FRAME
op_eq
l_int|0
)paren
)paren
id|info-&gt;dma
op_assign
l_int|1
suffix:semicolon
r_else
id|info-&gt;dma
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start sending the read request to the drive. */
id|cdrom_start_packet_command
(paren
id|drive
comma
l_int|32768
comma
id|cdrom_start_read_continuation
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Execute all other packet commands.&n; */
multiline_comment|/* Forward declarations. */
r_static
r_int
id|cdrom_lockdoor
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lockflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
suffix:semicolon
multiline_comment|/* Interrupt routine for packet command completion. */
DECL|function|cdrom_pc_intr
r_static
r_void
id|cdrom_pc_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|ireason
comma
id|len
comma
id|stat
comma
id|thislen
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
id|drive
comma
l_int|0
comma
op_amp
id|stat
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Read the interrupt reason and the transfer length. */
id|ireason
op_assign
id|IN_BYTE
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|len
op_assign
id|IN_BYTE
(paren
id|IDE_LCYL_REG
)paren
op_plus
l_int|256
op_star
id|IN_BYTE
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/* If DRQ is clear, the command has completed.&n;&t;   Complain if we still have data left to transfer. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Some of the trailing request sense fields are optional, and&n;&t;&t;   some drives don&squot;t send them.  Sigh. */
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|pc-&gt;buflen
OG
l_int|0
op_logical_and
id|pc-&gt;buflen
op_le
l_int|5
)paren
(brace
r_while
c_loop
(paren
id|pc-&gt;buflen
OG
l_int|0
)paren
(brace
op_star
id|pc-&gt;buffer
op_increment
op_assign
l_int|0
suffix:semicolon
op_decrement
id|pc-&gt;buflen
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pc-&gt;buflen
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_else
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: data underrun %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|pc-&gt;buflen
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Figure out how much data to transfer. */
id|thislen
op_assign
id|pc-&gt;buflen
suffix:semicolon
r_if
c_cond
(paren
id|thislen
OL
l_int|0
)paren
id|thislen
op_assign
op_minus
id|thislen
suffix:semicolon
r_if
c_cond
(paren
id|thislen
OG
id|len
)paren
id|thislen
op_assign
id|len
suffix:semicolon
multiline_comment|/* The drive wants to be written to. */
r_if
c_cond
(paren
(paren
id|ireason
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Check that we want to write. */
r_if
c_cond
(paren
id|pc-&gt;buflen
OG
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: Drive wants &quot;
l_string|&quot;to transfer data the wrong way!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|thislen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Transfer the data. */
id|atapi_output_bytes
(paren
id|drive
comma
id|pc-&gt;buffer
comma
id|thislen
)paren
suffix:semicolon
multiline_comment|/* If we haven&squot;t moved enough data to satisfy the drive,&n;&t;&t;   add some padding. */
r_while
c_loop
(paren
id|len
OG
id|thislen
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|atapi_output_bytes
(paren
id|drive
comma
op_amp
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
id|dum
)paren
suffix:semicolon
)brace
multiline_comment|/* Keep count of how much data we&squot;ve moved. */
id|pc-&gt;buffer
op_add_assign
id|thislen
suffix:semicolon
id|pc-&gt;buflen
op_add_assign
id|thislen
suffix:semicolon
)brace
multiline_comment|/* Same drill for reading. */
r_else
r_if
c_cond
(paren
(paren
id|ireason
op_amp
l_int|3
)paren
op_eq
l_int|2
)paren
(brace
multiline_comment|/* Check that we want to read. */
r_if
c_cond
(paren
id|pc-&gt;buflen
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: Drive wants to &quot;
l_string|&quot;transfer data the wrong way!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|thislen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Transfer the data. */
id|atapi_input_bytes
(paren
id|drive
comma
id|pc-&gt;buffer
comma
id|thislen
)paren
suffix:semicolon
multiline_comment|/* If we haven&squot;t moved enough data to satisfy the drive,&n;&t;&t;   add some padding. */
r_while
c_loop
(paren
id|len
OG
id|thislen
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|atapi_input_bytes
(paren
id|drive
comma
op_amp
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
id|dum
)paren
suffix:semicolon
)brace
multiline_comment|/* Keep count of how much data we&squot;ve moved. */
id|pc-&gt;buffer
op_add_assign
id|thislen
suffix:semicolon
id|pc-&gt;buflen
op_sub_assign
id|thislen
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: The drive &quot;
l_string|&quot;appears confused (ireason = 0x%2x)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|ireason
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now we wait for another interrupt. */
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|cdrom_pc_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
)brace
DECL|function|cdrom_do_pc_continuation
r_static
r_void
id|cdrom_do_pc_continuation
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
multiline_comment|/* Send the command to the drive and return. */
id|cdrom_transfer_packet_command
(paren
id|drive
comma
id|pc-&gt;c
comma
r_sizeof
(paren
id|pc-&gt;c
)paren
comma
op_amp
id|cdrom_pc_intr
)paren
suffix:semicolon
)brace
DECL|function|cdrom_do_packet_command
r_static
r_void
id|cdrom_do_packet_command
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|info-&gt;dma
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|pc-&gt;buflen
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
op_minus
id|len
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start sending the command to the drive. */
id|cdrom_start_packet_command
(paren
id|drive
comma
id|len
comma
id|cdrom_do_pc_continuation
)paren
suffix:semicolon
)brace
multiline_comment|/* Sleep for TIME jiffies.&n;   Not to be called from an interrupt handler. */
r_static
DECL|function|cdrom_sleep
r_void
id|cdrom_sleep
(paren
r_int
id|time
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|time
suffix:semicolon
id|schedule
(paren
)paren
suffix:semicolon
)brace
r_static
DECL|function|cdrom_queue_packet_command
r_int
id|cdrom_queue_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|packet_command
op_star
id|pc
)paren
(brace
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_int
id|retries
op_assign
l_int|10
suffix:semicolon
r_struct
id|request
id|req
suffix:semicolon
multiline_comment|/* If our caller has not provided a place to stick any sense data,&n;&t;   use our own area. */
r_if
c_cond
(paren
id|pc-&gt;sense_data
op_eq
l_int|NULL
)paren
id|pc-&gt;sense_data
op_assign
op_amp
id|my_reqbuf
suffix:semicolon
id|pc-&gt;sense_data-&gt;sense_key
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start of retry loop. */
r_do
(brace
id|ide_init_drive_cmd
(paren
op_amp
id|req
)paren
suffix:semicolon
id|req.cmd
op_assign
id|PACKET_COMMAND
suffix:semicolon
id|req.buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
op_amp
id|req
comma
id|ide_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pc-&gt;stat
op_ne
l_int|0
)paren
(brace
multiline_comment|/* The request failed.  Retry if it was due to a unit&n;&t;&t;&t;   attention status&n;&t;&t;&t;   (usually means media was changed). */
r_struct
id|atapi_request_sense
op_star
id|reqbuf
op_assign
id|pc-&gt;sense_data
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|UNIT_ATTENTION
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|NOT_READY
op_logical_and
id|reqbuf-&gt;asc
op_eq
l_int|4
)paren
(brace
multiline_comment|/* The drive is in the process of loading&n;&t;&t;&t;&t;   a disk.  Retry, but wait a little to give&n;&t;&t;&t;&t;   the drive time to complete the load. */
id|cdrom_sleep
(paren
id|HZ
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* Otherwise, don&squot;t retry. */
id|retries
op_assign
l_int|0
suffix:semicolon
op_decrement
id|retries
suffix:semicolon
)brace
multiline_comment|/* End of retry loop. */
)brace
r_while
c_loop
(paren
id|pc-&gt;stat
op_ne
l_int|0
op_logical_and
id|retries
op_ge
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Return an error if the command failed. */
r_if
c_cond
(paren
id|pc-&gt;stat
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_else
(brace
multiline_comment|/* The command succeeded.  If it was anything other than&n;&t;&t;   a request sense, eject, or door lock command,&n;&t;&t;   and we think that the door is presently, lock it again.&n;&t;&t;   (The door was probably unlocked via an explicit&n;&t;&t;   CDROMEJECT ioctl.) */
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
op_eq
l_int|0
op_logical_and
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
op_logical_and
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|ALLOW_MEDIUM_REMOVAL
op_logical_and
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|START_STOP
)paren
)paren
(brace
(paren
r_void
)paren
id|cdrom_lockdoor
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * cdrom driver request routine.&n; */
DECL|function|ide_do_rw_cdrom
r_void
id|ide_do_rw_cdrom
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_int
r_int
id|block
)paren
(brace
r_if
c_cond
(paren
id|rq
op_member_access_from_pointer
id|cmd
op_eq
id|PACKET_COMMAND
op_logical_or
id|rq
op_member_access_from_pointer
id|cmd
op_eq
id|REQUEST_SENSE_COMMAND
)paren
id|cdrom_do_packet_command
(paren
id|drive
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rq
op_member_access_from_pointer
id|cmd
op_eq
id|RESET_DRIVE_COMMAND
)paren
(brace
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
id|ide_do_reset
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rq
op_member_access_from_pointer
id|cmd
op_ne
id|READ
)paren
(brace
id|printk
(paren
l_string|&quot;ide-cd: bad cmd %d&bslash;n&quot;
comma
id|rq
op_member_access_from_pointer
id|cmd
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
id|cdrom_start_read
(paren
id|drive
comma
id|block
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Ioctl handling.&n; *&n; * Routines which queue packet commands take as a final argument a pointer&n; * to an atapi_request_sense struct.  If execution of the command results&n; * in an error with a CHECK CONDITION status, this structure will be filled&n; * with the results of the subsequent request sense command.  The pointer&n; * can also be NULL, in which case no sense information is returned.&n; */
macro_line|#if ! STANDARD_ATAPI
r_static
r_inline
DECL|function|bin2bcd
r_int
id|bin2bcd
(paren
r_int
id|x
)paren
(brace
r_return
(paren
id|x
op_mod
l_int|10
)paren
op_or
(paren
(paren
id|x
op_div
l_int|10
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
)brace
r_static
r_inline
DECL|function|bcd2bin
r_int
id|bcd2bin
(paren
r_int
id|x
)paren
(brace
r_return
(paren
id|x
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|x
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
r_static
DECL|function|msf_from_bcd
r_void
id|msf_from_bcd
(paren
r_struct
id|atapi_msf
op_star
id|msf
)paren
(brace
id|msf-&gt;minute
op_assign
id|bcd2bin
(paren
id|msf-&gt;minute
)paren
suffix:semicolon
id|msf-&gt;second
op_assign
id|bcd2bin
(paren
id|msf-&gt;second
)paren
suffix:semicolon
id|msf-&gt;frame
op_assign
id|bcd2bin
(paren
id|msf-&gt;frame
)paren
suffix:semicolon
)brace
macro_line|#endif /* not STANDARD_ATAPI */
r_static
r_inline
DECL|function|lba_to_msf
r_void
id|lba_to_msf
(paren
r_int
id|lba
comma
id|byte
op_star
id|m
comma
id|byte
op_star
id|s
comma
id|byte
op_star
id|f
)paren
(brace
id|lba
op_add_assign
id|CD_BLOCK_OFFSET
suffix:semicolon
id|lba
op_and_assign
l_int|0xffffff
suffix:semicolon
multiline_comment|/* negative lbas use only 24 bits */
op_star
id|m
op_assign
id|lba
op_div
(paren
id|CD_SECS
op_star
id|CD_FRAMES
)paren
suffix:semicolon
id|lba
op_mod_assign
(paren
id|CD_SECS
op_star
id|CD_FRAMES
)paren
suffix:semicolon
op_star
id|s
op_assign
id|lba
op_div
id|CD_FRAMES
suffix:semicolon
op_star
id|f
op_assign
id|lba
op_mod
id|CD_FRAMES
suffix:semicolon
)brace
r_static
r_inline
DECL|function|msf_to_lba
r_int
id|msf_to_lba
(paren
id|byte
id|m
comma
id|byte
id|s
comma
id|byte
id|f
)paren
(brace
r_return
(paren
(paren
(paren
id|m
op_star
id|CD_SECS
)paren
op_plus
id|s
)paren
op_star
id|CD_FRAMES
op_plus
id|f
)paren
op_minus
id|CD_BLOCK_OFFSET
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_check_status
id|cdrom_check_status
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|TEST_UNIT_READY
suffix:semicolon
multiline_comment|/* the Sanyo 3 CD changer uses byte 7 of TEST_UNIT_READY to &n;           switch CDs instead of supporting the LOAD_UNLOAD opcode   */
id|pc.c
(braket
l_int|7
)braket
op_assign
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
op_mod
l_int|3
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* Lock the door if LOCKFLAG is nonzero; unlock it otherwise. */
r_static
r_int
DECL|function|cdrom_lockdoor
id|cdrom_lockdoor
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lockflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_struct
id|packet_command
id|pc
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf
op_eq
l_int|NULL
)paren
id|reqbuf
op_assign
op_amp
id|my_reqbuf
suffix:semicolon
multiline_comment|/* If the drive cannot lock the door, just pretend. */
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
)paren
id|stat
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|ALLOW_MEDIUM_REMOVAL
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
(paren
id|lockflag
op_ne
l_int|0
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
)paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
op_assign
id|lockflag
suffix:semicolon
r_else
(brace
multiline_comment|/* If we got an illegal field error, the drive&n;&t;&t;   probably cannot lock the door. */
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
id|reqbuf-&gt;asc
op_eq
l_int|0x24
)paren
(brace
id|printk
(paren
l_string|&quot;%s: door locking not supported&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
op_assign
l_int|1
suffix:semicolon
id|stat
op_assign
l_int|0
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
op_assign
id|lockflag
suffix:semicolon
)brace
)brace
r_return
id|stat
suffix:semicolon
)brace
multiline_comment|/* Eject the disk if EJECTFLAG is 0.&n;   If EJECTFLAG is 1, try to reload the disk. */
r_static
r_int
DECL|function|cdrom_eject
id|cdrom_eject
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|ejectflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|START_STOP
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
l_int|2
op_plus
(paren
id|ejectflag
op_ne
l_int|0
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_pause
id|cdrom_pause
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|pauseflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_PAUSE_RESUME
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
op_logical_neg
id|pauseflag
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_startstop
id|cdrom_startstop
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|startflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|START_STOP
suffix:semicolon
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
id|startflag
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_read_capacity
id|cdrom_read_capacity
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
op_star
id|capacity
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
(brace
r_int
id|lba
suffix:semicolon
r_int
id|blocklen
suffix:semicolon
)brace
id|capbuf
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|READ_CAPACITY
suffix:semicolon
id|pc.buffer
op_assign
(paren
r_char
op_star
)paren
op_amp
id|capbuf
suffix:semicolon
id|pc.buflen
op_assign
r_sizeof
(paren
id|capbuf
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
)paren
op_star
id|capacity
op_assign
id|ntohl
(paren
id|capbuf.lba
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_read_tocentry
id|cdrom_read_tocentry
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|trackno
comma
r_int
id|msf_flag
comma
r_int
id|format
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_READ_TOC
suffix:semicolon
id|pc.c
(braket
l_int|6
)braket
op_assign
id|trackno
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
id|pc.c
(braket
l_int|9
)braket
op_assign
(paren
id|format
op_lshift
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msf_flag
)paren
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* Try to read the entire TOC for the disk into our internal buffer. */
r_static
r_int
DECL|function|cdrom_read_toc
id|cdrom_read_toc
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_int
id|stat
comma
id|ntracks
comma
id|i
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
r_struct
(brace
r_struct
id|atapi_toc_header
id|hdr
suffix:semicolon
r_struct
id|atapi_toc_entry
id|ent
suffix:semicolon
)brace
id|ms_tmp
suffix:semicolon
r_if
c_cond
(paren
id|toc
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Try to allocate space. */
id|toc
op_assign
(paren
r_struct
id|atapi_toc
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|atapi_toc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|info-&gt;toc
op_assign
id|toc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|toc
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: No cdrom TOC buffer!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Check to see if the existing data is still valid.&n;&t;   If it is, just return. */
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
)paren
(paren
r_void
)paren
id|cdrom_check_status
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* First read just the header, so we know how long the TOC is. */
id|stat
op_assign
id|cdrom_read_tocentry
(paren
id|drive
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
(paren
r_char
op_star
)paren
op_amp
id|toc-&gt;hdr
comma
r_sizeof
(paren
r_struct
id|atapi_toc_header
)paren
op_plus
r_sizeof
(paren
r_struct
id|atapi_toc_entry
)paren
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
)paren
(brace
id|toc-&gt;hdr.first_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.first_track
)paren
suffix:semicolon
id|toc-&gt;hdr.last_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.last_track
)paren
suffix:semicolon
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
id|ntracks
op_assign
id|toc-&gt;hdr.last_track
op_minus
id|toc-&gt;hdr.first_track
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ntracks
op_le
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|ntracks
OG
id|MAX_TRACKS
)paren
id|ntracks
op_assign
id|MAX_TRACKS
suffix:semicolon
multiline_comment|/* Now read the whole schmeer. */
id|stat
op_assign
id|cdrom_read_tocentry
(paren
id|drive
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
(paren
r_char
op_star
)paren
op_amp
id|toc-&gt;hdr
comma
r_sizeof
(paren
r_struct
id|atapi_toc_header
)paren
op_plus
(paren
id|ntracks
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|atapi_toc_entry
)paren
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc-&gt;hdr.toc_length
op_assign
id|ntohs
(paren
id|toc-&gt;hdr.toc_length
)paren
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
)paren
(brace
id|toc-&gt;hdr.first_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.first_track
)paren
suffix:semicolon
id|toc-&gt;hdr.last_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.last_track
)paren
suffix:semicolon
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|ntracks
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
)paren
(brace
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
)paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|track
op_assign
id|bcd2bin
(paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|track
)paren
suffix:semicolon
id|msf_from_bcd
(paren
op_amp
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf
)paren
suffix:semicolon
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.lba
op_assign
id|msf_to_lba
(paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.minute
comma
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.second
comma
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.frame
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the multisession information. */
id|stat
op_assign
id|cdrom_read_tocentry
(paren
id|drive
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
(paren
r_char
op_star
)paren
op_amp
id|ms_tmp
comma
r_sizeof
(paren
id|ms_tmp
)paren
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
)paren
id|msf_from_bcd
(paren
op_amp
id|ms_tmp.ent.addr.msf
)paren
suffix:semicolon
macro_line|#endif  /* not STANDARD_ATAPI */
id|toc-&gt;last_session_lba
op_assign
id|msf_to_lba
(paren
id|ms_tmp.ent.addr.msf.minute
comma
id|ms_tmp.ent.addr.msf.second
comma
id|ms_tmp.ent.addr.msf.frame
)paren
suffix:semicolon
id|toc-&gt;xa_flag
op_assign
(paren
id|ms_tmp.hdr.first_track
op_ne
id|ms_tmp.hdr.last_track
)paren
suffix:semicolon
multiline_comment|/* Now try to get the total cdrom capacity. */
id|stat
op_assign
id|cdrom_read_capacity
(paren
id|drive
comma
op_amp
id|toc-&gt;capacity
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
id|toc-&gt;capacity
op_assign
l_int|0x1fffff
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|gd-&gt;sizes
(braket
id|drive-&gt;select.b.unit
op_lshift
id|PARTN_BITS
)braket
op_assign
id|toc-&gt;capacity
op_star
id|SECTORS_PER_FRAME
suffix:semicolon
id|drive-&gt;part
(braket
l_int|0
)braket
dot
id|nr_sects
op_assign
id|toc-&gt;capacity
op_star
id|SECTORS_PER_FRAME
suffix:semicolon
multiline_comment|/* Remember that we&squot;ve read this stuff. */
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_read_subchannel
id|cdrom_read_subchannel
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|format
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_READ_SUBCHANNEL
suffix:semicolon
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* MSF addressing */
id|pc.c
(braket
l_int|2
)braket
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* request subQ data */
id|pc.c
(braket
l_int|3
)braket
op_assign
id|format
comma
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* modeflag: 0 = current, 1 = changeable mask, 2 = default, 3 = saved */
r_static
r_int
DECL|function|cdrom_mode_sense
id|cdrom_mode_sense
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|pageno
comma
r_int
id|modeflag
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE_10
suffix:semicolon
id|pc.c
(braket
l_int|2
)braket
op_assign
id|pageno
op_or
(paren
id|modeflag
op_lshift
l_int|6
)paren
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_mode_select
id|cdrom_mode_select
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|pageno
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
op_minus
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|MODE_SELECT_10
suffix:semicolon
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|0x10
suffix:semicolon
id|pc.c
(braket
l_int|2
)braket
op_assign
id|pageno
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_play_lba_range_1
id|cdrom_play_lba_range_1
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lba_start
comma
r_int
id|lba_end
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_PLAYAUDIO_MSF
suffix:semicolon
id|lba_to_msf
(paren
id|lba_start
comma
op_amp
id|pc.c
(braket
l_int|3
)braket
comma
op_amp
id|pc.c
(braket
l_int|4
)braket
comma
op_amp
id|pc.c
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|lba_to_msf
(paren
id|lba_end
op_minus
l_int|1
comma
op_amp
id|pc.c
(braket
l_int|6
)braket
comma
op_amp
id|pc.c
(braket
l_int|7
)braket
comma
op_amp
id|pc.c
(braket
l_int|8
)braket
)paren
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_as_bcd
)paren
(brace
id|pc.c
(braket
l_int|3
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|5
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|6
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|8
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif /* not STANDARD_ATAPI */
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* Play audio starting at LBA LBA_START and finishing with the&n;   LBA before LBA_END. */
r_static
r_int
DECL|function|cdrom_play_lba_range
id|cdrom_play_lba_range
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lba_start
comma
r_int
id|lba_end
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_int
id|i
comma
id|stat
suffix:semicolon
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf
op_eq
l_int|NULL
)paren
id|reqbuf
op_assign
op_amp
id|my_reqbuf
suffix:semicolon
multiline_comment|/* Some drives, will, for certain audio cds,&n;&t;   give an error if you ask them to play the entire cd using the&n;&t;   values which are returned in the TOC.  The play will succeed,&n;&t;   however, if the ending address is adjusted downwards&n;&t;   by a few frames. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|75
suffix:semicolon
id|i
op_increment
)paren
(brace
id|stat
op_assign
id|cdrom_play_lba_range_1
(paren
id|drive
comma
id|lba_start
comma
id|lba_end
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
op_logical_or
op_logical_neg
(paren
id|reqbuf-&gt;sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
id|reqbuf-&gt;asc
op_eq
l_int|0x24
)paren
)paren
r_return
id|stat
suffix:semicolon
op_decrement
id|lba_end
suffix:semicolon
r_if
c_cond
(paren
id|lba_end
op_le
id|lba_start
)paren
r_break
suffix:semicolon
)brace
r_return
id|stat
suffix:semicolon
)brace
r_static
DECL|function|cdrom_get_toc_entry
r_int
id|cdrom_get_toc_entry
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|track
comma
r_struct
id|atapi_toc_entry
op_star
op_star
id|ent
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|stat
comma
id|ntracks
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
multiline_comment|/* Make sure our saved TOC is valid. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
multiline_comment|/* Check validity of requested track number. */
id|ntracks
op_assign
id|toc-&gt;hdr.last_track
op_minus
id|toc-&gt;hdr.first_track
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|track
op_eq
id|CDROM_LEADOUT
)paren
op_star
id|ent
op_assign
op_amp
id|toc-&gt;ent
(braket
id|ntracks
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|track
template_param
id|toc-&gt;hdr.last_track
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
op_star
id|ent
op_assign
op_amp
id|toc-&gt;ent
(braket
id|track
op_minus
id|toc-&gt;hdr.first_track
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_read_block
id|cdrom_read_block
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|format
comma
r_int
id|lba
comma
r_int
id|nblocks
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf
op_eq
l_int|NULL
)paren
id|reqbuf
op_assign
op_amp
id|my_reqbuf
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|old_readcd
)paren
id|pc.c
(braket
l_int|0
)braket
op_assign
l_int|0xd4
suffix:semicolon
r_else
macro_line|#endif  /* not STANDARD_ATAPI */
id|pc.c
(braket
l_int|0
)braket
op_assign
id|READ_CD
suffix:semicolon
id|pc.c
(braket
l_int|1
)braket
op_assign
(paren
id|format
op_lshift
l_int|2
)paren
suffix:semicolon
id|put_unaligned
c_func
(paren
id|htonl
c_func
(paren
id|lba
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|nblocks
op_amp
l_int|0xff
)paren
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
(paren
id|nblocks
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
id|pc.c
(braket
l_int|6
)braket
op_assign
(paren
(paren
id|nblocks
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|format
op_le
l_int|1
)paren
id|pc.c
(braket
l_int|9
)braket
op_assign
l_int|0xf0
suffix:semicolon
r_else
id|pc.c
(braket
l_int|9
)braket
op_assign
l_int|0x10
suffix:semicolon
id|stat
op_assign
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
multiline_comment|/* If the drive doesn&squot;t recognize the READ CD opcode, retry the command&n;&t;   with an older opcode for that command. */
r_if
c_cond
(paren
id|stat
op_logical_and
id|reqbuf-&gt;sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
id|reqbuf-&gt;asc
op_eq
l_int|0x20
op_logical_and
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|old_readcd
op_eq
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: Drive does not recognize READ_CD;&quot;
l_string|&quot;trying opcode 0xd4&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|old_readcd
op_assign
l_int|1
suffix:semicolon
r_return
id|cdrom_read_block
(paren
id|drive
comma
id|format
comma
id|lba
comma
id|nblocks
comma
id|buf
comma
id|buflen
comma
id|reqbuf
)paren
suffix:semicolon
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
r_return
id|stat
suffix:semicolon
)brace
multiline_comment|/* If SLOT&lt;0, unload the current slot.  Otherwise, try to load SLOT. */
r_static
r_int
DECL|function|cdrom_load_unload
id|cdrom_load_unload
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|slot
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
multiline_comment|/* if the drive is a Sanyo 3 CD changer then TEST_UNIT_READY&n;           (used in the cdrom_check_status function) is used to &n;           switch CDs instead of LOAD_UNLOAD */
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|slot
op_eq
l_int|1
)paren
op_logical_or
(paren
id|slot
op_eq
l_int|2
)paren
)paren
(brace
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
op_assign
id|slot
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|slot
op_ge
l_int|0
)paren
(brace
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_return
id|cdrom_check_status
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* ATAPI Rev. 2.2+ standard for requesting switching of&n;                   CDs in a multiplatter device */
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|LOAD_UNLOAD
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
l_int|2
op_plus
(paren
id|slot
op_ge
l_int|0
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
id|slot
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
)brace
DECL|function|ide_cdrom_ioctl
r_int
id|ide_cdrom_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMEJECT
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;usage
OG
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|stat
op_assign
id|cdrom_lockdoor
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
r_return
id|cdrom_eject
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMCLOSETRAY
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;usage
OG
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|stat
op_assign
id|cdrom_eject
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
r_return
id|cdrom_lockdoor
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMEJECT_SW
suffix:colon
(brace
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|eject_on_close
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMPAUSE
suffix:colon
r_return
id|cdrom_pause
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
r_return
id|cdrom_pause
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_case
id|CDROMSTART
suffix:colon
r_return
id|cdrom_startstop
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_startstop
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
multiline_comment|/* pit says the Dolphin needs this. */
r_return
id|cdrom_eject
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMPLAYMSF
suffix:colon
(brace
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_int
id|stat
comma
id|lba_start
comma
id|lba_end
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|msf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|msf
)paren
)paren
suffix:semicolon
id|lba_start
op_assign
id|msf_to_lba
(paren
id|msf.cdmsf_min0
comma
id|msf.cdmsf_sec0
comma
id|msf.cdmsf_frame0
)paren
suffix:semicolon
id|lba_end
op_assign
id|msf_to_lba
(paren
id|msf.cdmsf_min1
comma
id|msf.cdmsf_sec1
comma
id|msf.cdmsf_frame1
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lba_end
op_le
id|lba_start
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|cdrom_play_lba_range
(paren
id|drive
comma
id|lba_start
comma
id|lba_end
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Like just about every other Linux cdrom driver, we ignore the&n;&t;   index part of the request here. */
r_case
id|CDROMPLAYTRKIND
suffix:colon
(brace
r_int
id|stat
comma
id|lba_start
comma
id|lba_end
suffix:semicolon
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_struct
id|atapi_toc_entry
op_star
id|first_toc
comma
op_star
id|last_toc
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|ti
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
(paren
id|drive
comma
id|ti.cdti_trk0
comma
op_amp
id|first_toc
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
(paren
id|drive
comma
id|ti.cdti_trk1
comma
op_amp
id|last_toc
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|ti.cdti_trk1
op_ne
id|CDROM_LEADOUT
)paren
op_increment
id|last_toc
suffix:semicolon
id|lba_start
op_assign
id|first_toc-&gt;addr.lba
suffix:semicolon
id|lba_end
op_assign
id|last_toc-&gt;addr.lba
suffix:semicolon
r_if
c_cond
(paren
id|lba_end
op_le
id|lba_start
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|cdrom_play_lba_range
(paren
id|drive
comma
id|lba_start
comma
id|lba_end
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMREADTOCHDR
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|cdrom_tochdr
id|tochdr
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|tochdr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
multiline_comment|/* Make sure our saved TOC is valid. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
id|tochdr.cdth_trk0
op_assign
id|toc-&gt;hdr.first_track
suffix:semicolon
id|tochdr.cdth_trk1
op_assign
id|toc-&gt;hdr.last_track
suffix:semicolon
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|tochdr
comma
r_sizeof
(paren
id|tochdr
)paren
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_case
id|CDROMREADTOCENTRY
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|cdrom_tocentry
id|tocentry
suffix:semicolon
r_struct
id|atapi_toc_entry
op_star
id|toce
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|tocentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|tocentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|tocentry
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
(paren
id|drive
comma
id|tocentry.cdte_track
comma
op_amp
id|toce
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|tocentry.cdte_ctrl
op_assign
id|toce-&gt;control
suffix:semicolon
id|tocentry.cdte_adr
op_assign
id|toce-&gt;adr
suffix:semicolon
r_if
c_cond
(paren
id|tocentry.cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
multiline_comment|/* convert to MSF */
id|lba_to_msf
(paren
id|toce-&gt;addr.lba
comma
op_amp
id|tocentry.cdte_addr.msf.minute
comma
op_amp
id|tocentry.cdte_addr.msf.second
comma
op_amp
id|tocentry.cdte_addr.msf.frame
)paren
suffix:semicolon
)brace
r_else
id|tocentry.cdte_addr.lba
op_assign
id|toce-&gt;addr.lba
suffix:semicolon
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|tocentry
comma
r_sizeof
(paren
id|tocentry
)paren
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_case
id|CDROMSUBCHNL
suffix:colon
(brace
r_struct
id|atapi_cdrom_subchnl
id|scbuf
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_struct
id|cdrom_subchnl
id|subchnl
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|subchnl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_read_subchannel
(paren
id|drive
comma
l_int|1
comma
multiline_comment|/* current position */
(paren
r_char
op_star
)paren
op_amp
id|scbuf
comma
r_sizeof
(paren
id|scbuf
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|subchan_as_bcd
)paren
(brace
id|msf_from_bcd
(paren
op_amp
id|scbuf.acdsc_absaddr.msf
)paren
suffix:semicolon
id|msf_from_bcd
(paren
op_amp
id|scbuf.acdsc_reladdr.msf
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
)paren
id|scbuf.acdsc_trk
op_assign
id|bcd2bin
(paren
id|scbuf.acdsc_trk
)paren
suffix:semicolon
macro_line|#endif /* not STANDARD_ATAPI */
r_if
c_cond
(paren
id|subchnl.cdsc_format
op_eq
id|CDROM_MSF
)paren
(brace
id|subchnl.cdsc_absaddr.msf.minute
op_assign
id|scbuf.acdsc_absaddr.msf.minute
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.second
op_assign
id|scbuf.acdsc_absaddr.msf.second
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.frame
op_assign
id|scbuf.acdsc_absaddr.msf.frame
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.minute
op_assign
id|scbuf.acdsc_reladdr.msf.minute
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.second
op_assign
id|scbuf.acdsc_reladdr.msf.second
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.frame
op_assign
id|scbuf.acdsc_reladdr.msf.frame
suffix:semicolon
)brace
r_else
(brace
id|subchnl.cdsc_absaddr.lba
op_assign
id|msf_to_lba
(paren
id|scbuf.acdsc_absaddr.msf.minute
comma
id|scbuf.acdsc_absaddr.msf.second
comma
id|scbuf.acdsc_absaddr.msf.frame
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.lba
op_assign
id|msf_to_lba
(paren
id|scbuf.acdsc_reladdr.msf.minute
comma
id|scbuf.acdsc_reladdr.msf.second
comma
id|scbuf.acdsc_reladdr.msf.frame
)paren
suffix:semicolon
)brace
id|subchnl.cdsc_audiostatus
op_assign
id|scbuf.acdsc_audiostatus
suffix:semicolon
id|subchnl.cdsc_ctrl
op_assign
id|scbuf.acdsc_ctrl
suffix:semicolon
id|subchnl.cdsc_trk
op_assign
id|scbuf.acdsc_trk
suffix:semicolon
id|subchnl.cdsc_ind
op_assign
id|scbuf.acdsc_ind
suffix:semicolon
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|subchnl
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_case
id|CDROMVOLCTRL
suffix:colon
(brace
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
r_char
id|buffer
(braket
l_int|24
)braket
comma
id|mask
(braket
l_int|24
)braket
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|volctrl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_mode_sense
(paren
id|drive
comma
l_int|0x0e
comma
l_int|0
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_mode_sense
(paren
id|drive
comma
l_int|0x0e
comma
l_int|1
comma
id|mask
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|buffer
(braket
l_int|1
)braket
op_assign
id|buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|buffer
(braket
l_int|17
)braket
op_assign
id|volctrl.channel0
op_amp
id|mask
(braket
l_int|17
)braket
suffix:semicolon
id|buffer
(braket
l_int|19
)braket
op_assign
id|volctrl.channel1
op_amp
id|mask
(braket
l_int|19
)braket
suffix:semicolon
id|buffer
(braket
l_int|21
)braket
op_assign
id|volctrl.channel2
op_amp
id|mask
(braket
l_int|21
)braket
suffix:semicolon
id|buffer
(braket
l_int|23
)braket
op_assign
id|volctrl.channel3
op_amp
id|mask
(braket
l_int|23
)braket
suffix:semicolon
r_return
id|cdrom_mode_select
(paren
id|drive
comma
l_int|0x0e
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMVOLREAD
suffix:colon
(brace
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
r_char
id|buffer
(braket
l_int|24
)braket
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_mode_sense
(paren
id|drive
comma
l_int|0x0e
comma
l_int|0
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|volctrl.channel0
op_assign
id|buffer
(braket
l_int|17
)braket
suffix:semicolon
id|volctrl.channel1
op_assign
id|buffer
(braket
l_int|19
)braket
suffix:semicolon
id|volctrl.channel2
op_assign
id|buffer
(braket
l_int|21
)braket
suffix:semicolon
id|volctrl.channel3
op_assign
id|buffer
(braket
l_int|23
)braket
suffix:semicolon
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|volctrl
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMMULTISESSION
suffix:colon
(brace
r_struct
id|cdrom_multisession
id|ms_info
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ms_info
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|ms_info
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ms_info
)paren
)paren
suffix:semicolon
multiline_comment|/* Make sure the TOC information is valid. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
r_if
c_cond
(paren
id|ms_info.addr_format
op_eq
id|CDROM_MSF
)paren
id|lba_to_msf
(paren
id|toc-&gt;last_session_lba
comma
op_amp
id|ms_info.addr.msf.minute
comma
op_amp
id|ms_info.addr.msf.second
comma
op_amp
id|ms_info.addr.msf.frame
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ms_info.addr_format
op_eq
id|CDROM_LBA
)paren
id|ms_info.addr.lba
op_assign
id|toc-&gt;last_session_lba
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ms_info.xa_flag
op_assign
id|toc-&gt;xa_flag
suffix:semicolon
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|ms_info
comma
r_sizeof
(paren
id|ms_info
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read 2352 byte blocks from audio tracks. */
r_case
id|CDROMREADAUDIO
suffix:colon
(brace
r_int
id|stat
comma
id|lba
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
r_struct
id|cdrom_read_audio
id|ra
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
multiline_comment|/* Make sure the TOC is up to date. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ra
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|ra
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ra
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ra.nframes
template_param
id|toc-&gt;capacity
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ra.nframes
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|ra.buf
comma
id|ra.nframes
op_star
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|ra.addr_format
op_eq
id|CDROM_MSF
)paren
id|lba
op_assign
id|msf_to_lba
(paren
id|ra.addr.msf.minute
comma
id|ra.addr.msf.second
comma
id|ra.addr.msf.frame
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ra.addr_format
op_eq
id|CDROM_LBA
)paren
id|lba
op_assign
id|ra.addr.lba
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|lba
OL
l_int|0
op_logical_or
id|lba
op_ge
id|toc-&gt;capacity
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|buf
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
(paren
id|CDROM_NBLOCKS_BUFFER
op_star
id|CD_FRAMESIZE_RAW
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_while
c_loop
(paren
id|ra.nframes
OG
l_int|0
)paren
(brace
r_int
id|this_nblocks
op_assign
id|ra.nframes
suffix:semicolon
r_if
c_cond
(paren
id|this_nblocks
OG
id|CDROM_NBLOCKS_BUFFER
)paren
id|this_nblocks
op_assign
id|CDROM_NBLOCKS_BUFFER
suffix:semicolon
id|stat
op_assign
id|cdrom_read_block
(paren
id|drive
comma
l_int|1
comma
id|lba
comma
id|this_nblocks
comma
id|buf
comma
id|this_nblocks
op_star
id|CD_FRAMESIZE_RAW
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_break
suffix:semicolon
id|copy_to_user
(paren
id|ra.buf
comma
id|buf
comma
id|this_nblocks
op_star
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
id|ra.buf
op_add_assign
id|this_nblocks
op_star
id|CD_FRAMESIZE_RAW
suffix:semicolon
id|ra.nframes
op_sub_assign
id|this_nblocks
suffix:semicolon
id|lba
op_add_assign
id|this_nblocks
suffix:semicolon
)brace
id|kfree
(paren
id|buf
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_case
id|CDROMREADMODE1
suffix:colon
r_case
id|CDROMREADMODE2
suffix:colon
(brace
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_int
id|blocksize
comma
id|format
comma
id|stat
comma
id|lba
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
r_char
op_star
id|buf
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|CDROMREADMODE1
)paren
(brace
id|blocksize
op_assign
id|CD_FRAMESIZE
suffix:semicolon
id|format
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|blocksize
op_assign
id|CD_FRAMESIZE_RAW0
suffix:semicolon
id|format
op_assign
l_int|3
suffix:semicolon
)brace
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|arg
comma
id|blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|msf
)paren
)paren
suffix:semicolon
id|lba
op_assign
id|msf_to_lba
(paren
id|msf.cdmsf_min0
comma
id|msf.cdmsf_sec0
comma
id|msf.cdmsf_frame0
)paren
suffix:semicolon
multiline_comment|/* Make sure the TOC is up to date. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
r_if
c_cond
(paren
id|lba
OL
l_int|0
op_logical_or
id|lba
op_ge
id|toc-&gt;capacity
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|buf
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
(paren
id|CD_FRAMESIZE_RAW0
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buf
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|stat
op_assign
id|cdrom_read_block
(paren
id|drive
comma
id|format
comma
id|lba
comma
l_int|1
comma
id|buf
comma
id|blocksize
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
)paren
id|copy_to_user
(paren
(paren
r_char
op_star
)paren
id|arg
comma
id|buf
comma
id|blocksize
)paren
suffix:semicolon
id|kfree
(paren
id|buf
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_case
id|CDROM_GET_UPC
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_char
id|mcnbuf
(braket
l_int|24
)braket
suffix:semicolon
r_struct
id|cdrom_mcn
id|mcn
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|mcn
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_read_subchannel
(paren
id|drive
comma
l_int|2
comma
multiline_comment|/* get MCN */
id|mcnbuf
comma
r_sizeof
(paren
id|mcnbuf
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy
(paren
id|mcn.medium_catalog_number
comma
id|mcnbuf
op_plus
l_int|9
comma
r_sizeof
(paren
id|mcn.medium_catalog_number
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|mcn.medium_catalog_number
(braket
r_sizeof
(paren
id|mcn.medium_catalog_number
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|mcn
comma
r_sizeof
(paren
id|mcn
)paren
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_case
id|CDROMLOADFROMSLOT
suffix:colon
id|printk
(paren
l_string|&quot;%s: Use CDROM_SELECT_DISC &quot;
l_string|&quot; instead of CDROMLOADFROMSLOT.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Fall through. */
r_case
id|CDROM_SELECT_DISC
suffix:colon
(brace
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;usage
OG
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
(paren
r_void
)paren
id|cdrom_load_unload
(paren
id|drive
comma
op_minus
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
op_minus
l_int|1
)paren
(brace
(paren
r_void
)paren
id|cdrom_lockdoor
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
(paren
r_void
)paren
id|cdrom_load_unload
(paren
id|drive
comma
(paren
r_int
)paren
id|arg
comma
l_int|NULL
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_check_status
(paren
id|drive
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_logical_and
id|my_reqbuf.sense_key
op_eq
id|NOT_READY
)paren
(brace
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
multiline_comment|/* And try to read the TOC information now. */
r_return
id|cdrom_read_toc
(paren
id|drive
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
)brace
macro_line|#if 0 /* Doesn&squot;t work reliably yet. */
r_case
id|CDROMRESET
suffix:colon
(brace
r_struct
id|request
id|req
suffix:semicolon
id|ide_init_drive_cmd
(paren
op_amp
id|req
)paren
suffix:semicolon
id|req.cmd
op_assign
id|RESET_DRIVE_COMMAND
suffix:semicolon
r_return
id|ide_do_drive_cmd
(paren
id|drive
comma
op_amp
id|req
comma
id|ide_wait
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef TEST
r_case
l_int|0x1234
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|packet_command
id|pc
suffix:semicolon
r_int
id|len
comma
id|lena
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|pc.c
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
id|arg
op_add_assign
r_sizeof
(paren
id|pc.c
)paren
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|copy_from_user
(paren
op_amp
id|len
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|len
)paren
)paren
suffix:semicolon
id|arg
op_add_assign
r_sizeof
(paren
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
)brace
id|lena
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|lena
OL
l_int|0
)paren
id|lena
op_assign
l_int|0
suffix:semicolon
(brace
r_char
id|buf
(braket
id|lena
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|pc.buflen
op_assign
id|len
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
)brace
id|stat
op_assign
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
id|copy_to_user
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|buf
comma
id|len
)paren
suffix:semicolon
)brace
r_return
id|stat
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Other driver requests (open, close, check media change).&n; */
DECL|function|ide_cdrom_check_media_change
r_int
id|ide_cdrom_check_media_change
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|retval
suffix:semicolon
(paren
r_void
)paren
id|cdrom_check_status
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
id|retval
op_assign
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|0
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|ide_cdrom_open
r_int
id|ide_cdrom_open
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
multiline_comment|/* no write access */
r_if
c_cond
(paren
id|fp-&gt;f_mode
op_amp
l_int|2
)paren
(brace
op_decrement
id|drive-&gt;usage
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* If this is the first open, check the drive status. */
r_if
c_cond
(paren
id|drive-&gt;usage
op_eq
l_int|1
)paren
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
id|my_reqbuf.sense_key
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get the drive status. */
id|stat
op_assign
id|cdrom_check_status
(paren
id|drive
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
multiline_comment|/* If the tray is open, try to close it. */
r_if
c_cond
(paren
id|stat
op_logical_and
id|my_reqbuf.sense_key
op_eq
id|NOT_READY
)paren
(brace
id|cdrom_eject
(paren
id|drive
comma
l_int|1
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_check_status
(paren
id|drive
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
)brace
multiline_comment|/* If things worked ok, lock the door and read the&n;&t;&t;   TOC information. */
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
op_logical_or
id|my_reqbuf.sense_key
op_eq
id|UNIT_ATTENTION
)paren
(brace
(paren
r_void
)paren
id|cdrom_lockdoor
(paren
id|drive
comma
l_int|1
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
(paren
r_void
)paren
id|cdrom_read_toc
(paren
id|drive
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close down the device.  Invalidate all cached blocks.&n; */
DECL|function|ide_cdrom_release
r_void
id|ide_cdrom_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;usage
op_eq
l_int|0
)paren
(brace
id|invalidate_buffers
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
multiline_comment|/* Unlock the door. */
(paren
r_void
)paren
id|cdrom_lockdoor
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Do an eject if we were requested to do so. */
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|eject_on_close
)paren
(paren
r_void
)paren
id|cdrom_eject
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Device initialization.&n; */
DECL|function|ide_cdrom_setup
r_void
id|ide_cdrom_setup
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|blksize_size
(braket
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
)braket
(braket
id|drive-&gt;select.b.unit
op_lshift
id|PARTN_BITS
)braket
op_assign
id|CD_FRAMESIZE
suffix:semicolon
id|drive-&gt;special.all
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;ready_stat
op_assign
l_int|0
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|0
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|0
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Turn this off by default, since many people don&squot;t like it. */
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|eject_on_close
op_assign
l_int|0
suffix:semicolon
macro_line|#if NO_DOOR_LOCKING
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
op_assign
l_int|1
suffix:semicolon
macro_line|#else
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* by default Sanyo 3 CD changer support is turned off and&n;           ATAPI Rev 2.2+ standard support for CD changers is used */
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
op_ne
l_int|NULL
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
op_assign
(paren
(paren
id|drive-&gt;id-&gt;config
op_amp
l_int|0x0060
)paren
op_eq
l_int|0x20
)paren
suffix:semicolon
r_else
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
op_assign
l_int|0
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|old_readcd
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_as_bcd
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|subchan_as_bcd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;V003S0DS&quot;
)paren
op_eq
l_int|0
op_logical_and
id|drive-&gt;id-&gt;fw_rev
(braket
l_int|4
)braket
op_eq
l_char|&squot;1&squot;
op_logical_and
id|drive-&gt;id-&gt;fw_rev
(braket
l_int|6
)braket
op_le
l_char|&squot;2&squot;
)paren
(brace
multiline_comment|/* Vertos 300.&n;&t;&t;&t;   Some versions of this drive like to talk BCD. */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|subchan_as_bcd
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;V006E0DS&quot;
)paren
op_eq
l_int|0
op_logical_and
id|drive-&gt;id-&gt;fw_rev
(braket
l_int|4
)braket
op_eq
l_char|&squot;1&squot;
op_logical_and
id|drive-&gt;id-&gt;fw_rev
(braket
l_int|6
)braket
op_le
l_char|&squot;2&squot;
)paren
(brace
multiline_comment|/* Vertos 600 ESD. */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;NEC CD-ROM DRIVE:260&quot;
)paren
op_eq
l_int|0
op_logical_and
id|strcmp
(paren
id|drive-&gt;id-&gt;fw_rev
comma
l_string|&quot;1.01&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Old NEC260 (not R). */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|subchan_as_bcd
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;WEARNES CDD-120&quot;
)paren
op_eq
l_int|0
op_logical_and
id|strcmp
(paren
id|drive-&gt;id-&gt;fw_rev
comma
l_string|&quot;A1.1&quot;
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Wearnes */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|subchan_as_bcd
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Sanyo 3 CD changer uses a non-standard command &n;                   for CD changing */
r_else
r_if
c_cond
(paren
(paren
id|strcmp
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;CD-ROM CDR-C3 G&quot;
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|strcmp
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;CD-ROM CDR-C3G&quot;
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* uses CD in slot 0 when value is set to 3 */
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|sanyo_slot
op_assign
l_int|3
suffix:semicolon
)brace
)brace
macro_line|#endif /* not STANDARD_ATAPI */
id|info-&gt;toc
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;sector_buffer
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;sector_buffered
op_assign
l_int|0
suffix:semicolon
id|info-&gt;nsectors_buffered
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|ide_cdrom_cleanup
r_int
id|ide_cdrom_cleanup
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_if
c_cond
(paren
id|ide_unregister_subdriver
(paren
id|drive
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;sector_buffer
op_ne
l_int|NULL
)paren
id|kfree
(paren
id|info-&gt;sector_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;toc
op_ne
l_int|NULL
)paren
id|kfree
(paren
id|info-&gt;toc
)paren
suffix:semicolon
id|kfree
(paren
id|info
)paren
suffix:semicolon
id|drive-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_int
id|ide_cdrom_init
(paren
r_void
)paren
suffix:semicolon
DECL|variable|ide_cdrom_module
r_static
id|ide_module_t
id|ide_cdrom_module
op_assign
(brace
id|IDE_DRIVER_MODULE
comma
id|ide_cdrom_init
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|ide_cdrom_driver
r_static
id|ide_driver_t
id|ide_cdrom_driver
op_assign
(brace
id|ide_cdrom
comma
multiline_comment|/* media */
l_int|0
comma
multiline_comment|/* busy */
l_int|1
comma
multiline_comment|/* supports_dma */
id|ide_cdrom_cleanup
comma
multiline_comment|/* cleanup */
id|ide_do_rw_cdrom
comma
multiline_comment|/* do_request */
l_int|NULL
comma
multiline_comment|/* ??? or perhaps cdrom_end_request? */
id|ide_cdrom_ioctl
comma
multiline_comment|/* ioctl */
id|ide_cdrom_open
comma
multiline_comment|/* open */
id|ide_cdrom_release
comma
multiline_comment|/* release */
id|ide_cdrom_check_media_change
comma
multiline_comment|/* media_change */
l_int|NULL
comma
multiline_comment|/* pre_reset */
l_int|NULL
comma
multiline_comment|/* capacity */
l_int|NULL
multiline_comment|/* special */
)brace
suffix:semicolon
DECL|function|ide_cdrom_init
r_int
id|ide_cdrom_init
(paren
r_void
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
suffix:semicolon
r_int
id|failed
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|drive
op_assign
id|ide_scan_devices
(paren
id|ide_cdrom
comma
l_int|NULL
comma
id|failed
op_increment
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
id|info
op_assign
(paren
r_struct
id|cdrom_info
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|cdrom_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: Can&squot;t allocate a cdrom structure&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ide_register_subdriver
(paren
id|drive
comma
op_amp
id|ide_cdrom_driver
comma
id|IDE_SUBDRIVER_VERSION
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: Failed to register the driver with ide.c&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|kfree
(paren
id|info
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|failed
op_decrement
suffix:semicolon
id|memset
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cdrom_info
)paren
)paren
suffix:semicolon
id|drive-&gt;driver_data
op_assign
id|info
suffix:semicolon
id|ide_cdrom_setup
(paren
id|drive
)paren
suffix:semicolon
)brace
id|ide_register_module
c_func
(paren
op_amp
id|ide_cdrom_module
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
(brace
r_return
id|ide_cdrom_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_int
id|failed
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|drive
op_assign
id|ide_scan_devices
(paren
id|ide_cdrom
comma
op_amp
id|ide_cdrom_driver
comma
id|failed
)paren
)paren
op_ne
l_int|NULL
)paren
r_if
c_cond
(paren
id|ide_cdrom_cleanup
(paren
id|drive
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cleanup_module() called while still busy&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|failed
op_increment
suffix:semicolon
)brace
id|ide_unregister_module
(paren
op_amp
id|ide_cdrom_module
)paren
suffix:semicolon
)brace
macro_line|#endif /* MODULE */
multiline_comment|/*&n; * TODO (for 2.1?):&n; *  Avoid printing error messages for expected errors from the drive.&n; *  Integrate with generic cdrom driver.&n; *  Query the drive to find what features are available&n; *   before trying to use them.&n; *  Integrate spindown time adjustment patch.&n; *  CDROMRESET ioctl.&n; *  Better support for changers.&n; */
multiline_comment|/*==========================================================================*/
multiline_comment|/*&n; * Local variables:&n; * c-basic-offset: 8&n; * End:&n; */
eof
