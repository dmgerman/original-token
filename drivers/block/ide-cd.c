multiline_comment|/*&n; * linux/drivers/block/ide-cd.c&n; *&n; * 1.00  Oct 31, 1994 -- Initial version.&n; * 1.01  Nov  2, 1994 -- Fixed problem with starting request in&n; *                       cdrom_check_status.&n; * 1.03  Nov 25, 1994 -- leaving unmask_intr[] as a user-setting (as for disks)&n; * (from mlord)       -- minor changes to cdrom_setup()&n; *                    -- renamed ide_dev_s to ide_drive_t, enable irq on command&n; * 2.00  Nov 27, 1994 -- Generalize packet command interface;&n; *                       add audio ioctls.&n; * 2.01  Dec  3, 1994 -- Rework packet command interface to handle devices&n; *                       which send an interrupt when ready for a command.&n; * 2.02  Dec 11, 1994 -- Cache the TOC in the driver.&n; *                       Don&squot;t use SCMD_PLAYAUDIO_TI; it&squot;s not included&n; *                       in the current version of ATAPI.&n; *                       Try to use LBA instead of track or MSF addressing&n; *                       when possible.&n; *                       Don&squot;t wait for READY_STAT.&n; * 2.03  Jan 10, 1995 -- Rewrite block read routines to handle block sizes&n; *                       other than 2k and to move multiple sectors in a&n; *                       single transaction.&n; * 2.04  Apr 21, 1995 -- Add work-around for Creative Labs CD220E drives.&n; *                       Thanks to Nick Saw &lt;cwsaw@pts7.pts.mot.com&gt; for&n; *                       help in figuring this out.  Ditto for Acer and&n; *                       Aztech drives, which seem to have the same problem.&n; * 2.04b May 30, 1995 -- Fix to match changes in ide.c version 3.16 -ml&n; * 2.05  Jun  8, 1995 -- Don&squot;t attempt to retry after an illegal request&n; *                        or data protect error.&n; *                       Use HWIF and DEV_HWIF macros as in ide.c.&n; *                       Always try to do a request_sense after&n; *                        a failed command.&n; *                       Include an option to give textual descriptions&n; *                        of ATAPI errors.&n; *                       Fix a bug in handling the sector cache which&n; *                        showed up if the drive returned data in 512 byte&n; *                        blocks (like Pioneer drives).  Thanks to&n; *                        Richard Hirst &lt;srh@gpt.co.uk&gt; for diagnosing this.&n; *                       Properly supply the page number field in the&n; *                        MODE_SELECT command.&n; *                       PLAYAUDIO12 is broken on the Aztech; work around it.&n; * 2.05x Aug 11, 1995 -- lots of data structure renaming/restructuring in ide.c&n; *                       (my apologies to Scott, but now ide-cd.c is independent)&n; * 3.00  Aug 22, 1995 -- Implement CDROMMULTISESSION ioctl.&n; *                       Implement CDROMREADAUDIO ioctl (UNTESTED).&n; *                       Use input_ide_data() and output_ide_data().&n; *                       Add door locking.&n; *                       Fix usage count leak in cdrom_open, which happened&n; *                        when a read-write mount was attempted.&n; *                       Try to load the disk on open.&n; *                       Implement CDROMEJECT_SW ioctl (off by default).&n; *                       Read total cdrom capacity during open.&n; *                       Rearrange logic in cdrom_decode_status.  Issue&n; *                        request sense commands for failed packet commands&n; *                        from here instead of from cdrom_queue_packet_command.&n; *                        Fix a race condition in retrieving error information.&n; *                       Suppress printing normal unit attention errors and&n; *                        some drive not ready errors.&n; *                       Implement CDROMVOLREAD ioctl.&n; *                       Implement CDROMREADMODE1/2 ioctls.&n; *                       Fix race condition in setting up interrupt handlers&n; *                        when the `serialize&squot; option is used.&n; * 3.01  Sep  2, 1995 -- Fix ordering of reenabling interrupts in&n; *                        cdrom_queue_request.&n; *                       Another try at using ide_[input,output]_data.&n; * 3.02  Sep 16, 1995 -- Stick total disk capacity in partition table as well.&n; *                       Make VERBOSE_IDE_CD_ERRORS dump failed command again.&n; *                       Dump out more information for ILLEGAL REQUEST errs.&n; *                       Fix handling of errors occuring before the&n; *                        packet command is transferred.&n; *                       Fix transfers with odd bytelengths.&n; * 3.03  Oct 27, 1995 -- Some Creative drives have an id of just `CD&squot;.&n; *                       `DCI-2S10&squot; drives are broken too.&n; * 3.04  Nov 20, 1995 -- So are Vertos drives.&n; * 3.05  Dec  1, 1995 -- Changes to go with overhaul of ide.c and ide-tape.c&n; * 3.06  Dec 16, 1995 -- Add support needed for partitions.&n; *                       More workarounds for Vertos bugs (based on patches&n; *                        from Holger Dietze &lt;dietze@aix520.informatik.uni-leipzig.de&gt;).&n; *                       Try to eliminate byteorder assumptions.&n; *                       Use atapi_cdrom_subchnl struct definition.&n; *                       Add STANDARD_ATAPI compilation option.&n; * 3.07  Jan 29, 1996 -- More twiddling for broken drives: Sony 55D,&n; *                        Vertos 300.&n; *                       Add NO_DOOR_LOCKING configuration option.&n; *                       Handle drive_cmd requests w/NULL args (for hdparm -t).&n; *                       Work around sporadic Sony55e audio play problem.&n; * 3.07a Feb 11, 1996 -- check drive-&gt;id for NULL before dereferencing, to fix&n; *                        problem with &quot;hde=cdrom&quot; with no drive present.  -ml&n; * 3.08  Mar  6, 1996 -- More Vertos workarounds.&n; *&n; * NOTE: Direct audio reads will only work on some types of drive.&n; * So far, i&squot;ve received reports of success for Sony and Toshiba drives.&n; *&n; * ATAPI cd-rom driver.  To be used with ide.c.&n; *&n; * Copyright (C) 1994, 1995, 1996  scott snyder  &lt;snyder@fnald0.fnal.gov&gt;&n; * May be copied or modified under the terms of the GNU General Public License&n; * (../../COPYING).&n; */
multiline_comment|/***************************************************************************/
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#ifdef __alpha__
macro_line|# include &lt;asm/unaligned.h&gt;
macro_line|#endif
macro_line|#include &quot;ide.h&quot;
multiline_comment|/* Turn this on to have the driver print out the meanings of the&n;   ATAPI error codes.  This will use up additional kernel-space&n;   memory, though. */
macro_line|#ifndef VERBOSE_IDE_CD_ERRORS
DECL|macro|VERBOSE_IDE_CD_ERRORS
mdefine_line|#define VERBOSE_IDE_CD_ERRORS 0
macro_line|#endif
multiline_comment|/* Turning this on will remove code to work around various nonstandard&n;   ATAPI implementations.  If you know your drive follows the standard,&n;   this will give you a slightly smaller kernel. */
macro_line|#ifndef STANDARD_ATAPI
DECL|macro|STANDARD_ATAPI
mdefine_line|#define STANDARD_ATAPI 0
macro_line|#endif
multiline_comment|/* Turning this on will disable the door-locking functionality.&n;   This is apparently needed for supermount. */
macro_line|#ifndef NO_DOOR_LOCKING
DECL|macro|NO_DOOR_LOCKING
mdefine_line|#define NO_DOOR_LOCKING 0
macro_line|#endif
multiline_comment|/************************************************************************/
DECL|macro|SECTOR_SIZE
mdefine_line|#define SECTOR_SIZE 512
DECL|macro|SECTOR_BITS
mdefine_line|#define SECTOR_BITS 9
DECL|macro|SECTORS_PER_FRAME
mdefine_line|#define SECTORS_PER_FRAME (CD_FRAMESIZE / SECTOR_SIZE)
DECL|macro|MIN
mdefine_line|#define MIN(a,b) ((a) &lt; (b) ? (a) : (b))
multiline_comment|/* special command codes for strategy routine. */
DECL|macro|PACKET_COMMAND
mdefine_line|#define PACKET_COMMAND        4315
DECL|macro|REQUEST_SENSE_COMMAND
mdefine_line|#define REQUEST_SENSE_COMMAND 4316
DECL|macro|RESET_DRIVE_COMMAND
mdefine_line|#define RESET_DRIVE_COMMAND   4317
multiline_comment|/* Some ATAPI command opcodes (just like SCSI).&n;   (Some other cdrom-specific codes are in cdrom.h.) */
DECL|macro|TEST_UNIT_READY
mdefine_line|#define TEST_UNIT_READY         0x00
DECL|macro|REQUEST_SENSE
mdefine_line|#define REQUEST_SENSE           0x03
DECL|macro|START_STOP
mdefine_line|#define START_STOP              0x1b
DECL|macro|ALLOW_MEDIUM_REMOVAL
mdefine_line|#define ALLOW_MEDIUM_REMOVAL    0x1e
DECL|macro|READ_CAPACITY
mdefine_line|#define READ_CAPACITY&t;&t;0x25
DECL|macro|READ_10
mdefine_line|#define READ_10                 0x28
DECL|macro|MODE_SENSE_10
mdefine_line|#define MODE_SENSE_10           0x5a
DECL|macro|MODE_SELECT_10
mdefine_line|#define MODE_SELECT_10          0x55
DECL|macro|READ_CD
mdefine_line|#define READ_CD                 0xbe
multiline_comment|/* ATAPI sense keys (mostly copied from scsi.h). */
DECL|macro|NO_SENSE
mdefine_line|#define NO_SENSE                0x00
DECL|macro|RECOVERED_ERROR
mdefine_line|#define RECOVERED_ERROR         0x01
DECL|macro|NOT_READY
mdefine_line|#define NOT_READY               0x02
DECL|macro|MEDIUM_ERROR
mdefine_line|#define MEDIUM_ERROR            0x03
DECL|macro|HARDWARE_ERROR
mdefine_line|#define HARDWARE_ERROR          0x04
DECL|macro|ILLEGAL_REQUEST
mdefine_line|#define ILLEGAL_REQUEST         0x05
DECL|macro|UNIT_ATTENTION
mdefine_line|#define UNIT_ATTENTION          0x06
DECL|macro|DATA_PROTECT
mdefine_line|#define DATA_PROTECT            0x07
DECL|macro|ABORTED_COMMAND
mdefine_line|#define ABORTED_COMMAND         0x0b
DECL|macro|MISCOMPARE
mdefine_line|#define MISCOMPARE              0x0e
multiline_comment|/* We want some additional flags for cd-rom drives.&n;   To save space in the ide_drive_t struct, use some fields which&n;   doesn&squot;t make sense for cd-roms -- `bios_sect&squot; and `bios_head&squot;. */
multiline_comment|/* Configuration flags.  These describe the capabilities of the drive.&n;   They generally do not change after initialization, unless we learn&n;   more about the drive from stuff failing. */
DECL|struct|ide_cd_config_flags
r_struct
id|ide_cd_config_flags
(brace
DECL|member|drq_interrupt
id|__u8
id|drq_interrupt
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Device sends an interrupt when ready&n;                                 for a packet command. */
DECL|member|no_doorlock
id|__u8
id|no_doorlock
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Drive cannot lock the door. */
macro_line|#if ! STANDARD_ATAPI
DECL|member|no_playaudio12
id|__u8
id|no_playaudio12
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The PLAYAUDIO12 command is not supported. */
DECL|member|no_lba_toc
id|__u8
id|no_lba_toc
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Drive cannot return TOC info in LBA format. */
DECL|member|playmsf_uses_bcd
id|__u8
id|playmsf_uses_bcd
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Drive uses BCD in PLAYAUDIO_MSF. */
DECL|member|old_readcd
id|__u8
id|old_readcd
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Drive uses old READ CD opcode. */
DECL|member|vertos_lossage
id|__u8
id|vertos_lossage
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Drive is a Vertos 300,&n;&t;&t;&t;&t; and likes to speak BCD. */
macro_line|#endif  /* not STANDARD_ATAPI */
DECL|member|reserved
id|__u8
id|reserved
suffix:colon
l_int|1
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|CDROM_CONFIG_FLAGS
mdefine_line|#define CDROM_CONFIG_FLAGS(drive) ((struct ide_cd_config_flags *)&amp;((drive)-&gt;bios_sect))
multiline_comment|/* State flags.  These give information about the current state of the&n;   drive, and will change during normal operation. */
DECL|struct|ide_cd_state_flags
r_struct
id|ide_cd_state_flags
(brace
DECL|member|media_changed
id|__u8
id|media_changed
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Driver has noticed a media change. */
DECL|member|toc_valid
id|__u8
id|toc_valid
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Saved TOC information is current. */
DECL|member|door_locked
id|__u8
id|door_locked
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* We think that the drive door is locked. */
DECL|member|eject_on_close
id|__u8
id|eject_on_close
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Drive should eject when device is closed. */
DECL|member|reserved
id|__u8
id|reserved
suffix:colon
l_int|4
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|CDROM_STATE_FLAGS
mdefine_line|#define CDROM_STATE_FLAGS(drive)  ((struct ide_cd_state_flags *)&amp;((drive)-&gt;bios_head))
DECL|macro|SECTOR_BUFFER_SIZE
mdefine_line|#define SECTOR_BUFFER_SIZE CD_FRAMESIZE
"&f;"
multiline_comment|/****************************************************************************&n; * Routines to read and write data from/to the drive, using&n; * the routines input_ide_data() and output_ide_data() from ide.c.&n; *&n; * These routines will round up any request for an odd number of bytes,&n; * so if an odd bytecount is specified, be sure that there&squot;s at least one&n; * extra byte allocated for the buffer.&n; */
r_static
r_inline
DECL|function|cdrom_in_bytes
r_void
id|cdrom_in_bytes
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
id|uint
id|bytecount
)paren
(brace
op_increment
id|bytecount
suffix:semicolon
id|ide_input_data
(paren
id|drive
comma
id|buffer
comma
id|bytecount
op_div
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bytecount
op_amp
l_int|0x03
)paren
op_ge
l_int|2
)paren
(brace
id|insw
(paren
id|IDE_DATA_REG
comma
(paren
(paren
id|byte
op_star
)paren
id|buffer
)paren
op_plus
(paren
id|bytecount
op_amp
op_complement
l_int|0x03
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_static
r_inline
DECL|function|cdrom_out_bytes
r_void
id|cdrom_out_bytes
(paren
id|ide_drive_t
op_star
id|drive
comma
r_void
op_star
id|buffer
comma
id|uint
id|bytecount
)paren
(brace
op_increment
id|bytecount
suffix:semicolon
id|ide_output_data
(paren
id|drive
comma
id|buffer
comma
id|bytecount
op_div
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bytecount
op_amp
l_int|0x03
)paren
op_ge
l_int|2
)paren
(brace
id|outsw
(paren
id|IDE_DATA_REG
comma
(paren
(paren
id|byte
op_star
)paren
id|buffer
)paren
op_plus
(paren
id|bytecount
op_amp
op_complement
l_int|0x03
)paren
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Descriptions of ATAPI error codes.&n; */
DECL|macro|ARY_LEN
mdefine_line|#define ARY_LEN(a) ((sizeof(a) / sizeof(a[0])))
macro_line|#if VERBOSE_IDE_CD_ERRORS
multiline_comment|/* From Table 124 of the ATAPI 1.2 spec. */
DECL|variable|sense_key_texts
r_char
op_star
id|sense_key_texts
(braket
l_int|16
)braket
op_assign
(brace
l_string|&quot;No sense data&quot;
comma
l_string|&quot;Recovered error&quot;
comma
l_string|&quot;Not ready&quot;
comma
l_string|&quot;Medium error&quot;
comma
l_string|&quot;Hardware error&quot;
comma
l_string|&quot;Illegal request&quot;
comma
l_string|&quot;Unit attention&quot;
comma
l_string|&quot;Data protect&quot;
comma
l_string|&quot;(reserved)&quot;
comma
l_string|&quot;(reserved)&quot;
comma
l_string|&quot;(reserved)&quot;
comma
l_string|&quot;Aborted command&quot;
comma
l_string|&quot;(reserved)&quot;
comma
l_string|&quot;(reserved)&quot;
comma
l_string|&quot;Miscompare&quot;
comma
l_string|&quot;(reserved)&quot;
comma
)brace
suffix:semicolon
multiline_comment|/* From Table 125 of the ATAPI 1.2 spec. */
r_struct
(brace
DECL|member|asc_ascq
r_int
id|asc_ascq
suffix:semicolon
DECL|member|text
r_char
op_star
id|text
suffix:semicolon
DECL|variable|sense_data_texts
)brace
id|sense_data_texts
(braket
)braket
op_assign
(brace
(brace
l_int|0x0000
comma
l_string|&quot;No additional sense information&quot;
)brace
comma
(brace
l_int|0x0011
comma
l_string|&quot;Audio play operation in progress&quot;
)brace
comma
(brace
l_int|0x0012
comma
l_string|&quot;Audio play operation paused&quot;
)brace
comma
(brace
l_int|0x0013
comma
l_string|&quot;Audio play operation successfully completed&quot;
)brace
comma
(brace
l_int|0x0014
comma
l_string|&quot;Audio play operation stopped due to error&quot;
)brace
comma
(brace
l_int|0x0015
comma
l_string|&quot;No current audio status to return&quot;
)brace
comma
(brace
l_int|0x0200
comma
l_string|&quot;No seek complete&quot;
)brace
comma
(brace
l_int|0x0400
comma
l_string|&quot;Logical unit not ready - cause not reportable&quot;
)brace
comma
(brace
l_int|0x0401
comma
l_string|&quot;Logical unit not ready - in progress (sic) of becoming ready&quot;
)brace
comma
(brace
l_int|0x0402
comma
l_string|&quot;Logical unit not ready - initializing command required&quot;
)brace
comma
(brace
l_int|0x0403
comma
l_string|&quot;Logical unit not ready - manual intervention required&quot;
)brace
comma
(brace
l_int|0x0600
comma
l_string|&quot;No reference position found&quot;
)brace
comma
(brace
l_int|0x0900
comma
l_string|&quot;Track following error&quot;
)brace
comma
(brace
l_int|0x0901
comma
l_string|&quot;Tracking servo failure&quot;
)brace
comma
(brace
l_int|0x0902
comma
l_string|&quot;Focus servo failure&quot;
)brace
comma
(brace
l_int|0x0903
comma
l_string|&quot;Spindle servo failure&quot;
)brace
comma
(brace
l_int|0x1100
comma
l_string|&quot;Unrecovered read error&quot;
)brace
comma
(brace
l_int|0x1106
comma
l_string|&quot;CIRC unrecovered error&quot;
)brace
comma
(brace
l_int|0x1500
comma
l_string|&quot;Random positioning error&quot;
)brace
comma
(brace
l_int|0x1501
comma
l_string|&quot;Mechanical positioning error&quot;
)brace
comma
(brace
l_int|0x1502
comma
l_string|&quot;Positioning error detected by read of medium&quot;
)brace
comma
(brace
l_int|0x1700
comma
l_string|&quot;Recovered data with no error correction applied&quot;
)brace
comma
(brace
l_int|0x1701
comma
l_string|&quot;Recovered data with retries&quot;
)brace
comma
(brace
l_int|0x1702
comma
l_string|&quot;Recovered data with positive head offset&quot;
)brace
comma
(brace
l_int|0x1703
comma
l_string|&quot;Recovered data with negative head offset&quot;
)brace
comma
(brace
l_int|0x1704
comma
l_string|&quot;Recovered data with retries and/or CIRC applied&quot;
)brace
comma
(brace
l_int|0x1705
comma
l_string|&quot;Recovered data using previous sector ID&quot;
)brace
comma
(brace
l_int|0x1800
comma
l_string|&quot;Recovered data with error correction applied&quot;
)brace
comma
(brace
l_int|0x1801
comma
l_string|&quot;Recovered data with error correction and retries applied&quot;
)brace
comma
(brace
l_int|0x1802
comma
l_string|&quot;Recovered data - the data was auto-reallocated&quot;
)brace
comma
(brace
l_int|0x1803
comma
l_string|&quot;Recovered data with CIRC&quot;
)brace
comma
(brace
l_int|0x1804
comma
l_string|&quot;Recovered data with L-EC&quot;
)brace
comma
(brace
l_int|0x1805
comma
l_string|&quot;Recovered data - recommend reassignment&quot;
)brace
comma
(brace
l_int|0x1806
comma
l_string|&quot;Recovered data - recommend rewrite&quot;
)brace
comma
(brace
l_int|0x1a00
comma
l_string|&quot;Parameter list length error&quot;
)brace
comma
(brace
l_int|0x2000
comma
l_string|&quot;Invalid command operation code&quot;
)brace
comma
(brace
l_int|0x2100
comma
l_string|&quot;Logical block address out of range&quot;
)brace
comma
(brace
l_int|0x2400
comma
l_string|&quot;Invalid field in command packet&quot;
)brace
comma
(brace
l_int|0x2600
comma
l_string|&quot;Invalid field in parameter list&quot;
)brace
comma
(brace
l_int|0x2601
comma
l_string|&quot;Parameter not supported&quot;
)brace
comma
(brace
l_int|0x2602
comma
l_string|&quot;Parameter value invalid&quot;
)brace
comma
(brace
l_int|0x2603
comma
l_string|&quot;Threshold parameters not supported&quot;
)brace
comma
(brace
l_int|0x2800
comma
l_string|&quot;Not ready to ready transition, medium may have changed&quot;
)brace
comma
(brace
l_int|0x2900
comma
l_string|&quot;Power on, reset or bus device reset occurred&quot;
)brace
comma
(brace
l_int|0x2a00
comma
l_string|&quot;Parameters changed&quot;
)brace
comma
(brace
l_int|0x2a01
comma
l_string|&quot;Mode parameters changed&quot;
)brace
comma
(brace
l_int|0x3000
comma
l_string|&quot;Incompatible medium installed&quot;
)brace
comma
(brace
l_int|0x3001
comma
l_string|&quot;Cannot read medium - unknown format&quot;
)brace
comma
(brace
l_int|0x3002
comma
l_string|&quot;Cannot read medium - incompatible format&quot;
)brace
comma
(brace
l_int|0x3700
comma
l_string|&quot;Rounded parameter&quot;
)brace
comma
(brace
l_int|0x3900
comma
l_string|&quot;Saving parameters not supported&quot;
)brace
comma
(brace
l_int|0x3a00
comma
l_string|&quot;Medium not present&quot;
)brace
comma
(brace
l_int|0x3f00
comma
l_string|&quot;ATAPI CD-ROM drive operating conditions have changed&quot;
)brace
comma
(brace
l_int|0x3f01
comma
l_string|&quot;Microcode has been changed&quot;
)brace
comma
(brace
l_int|0x3f02
comma
l_string|&quot;Changed operating definition&quot;
)brace
comma
(brace
l_int|0x3f03
comma
l_string|&quot;Inquiry data has changed&quot;
)brace
comma
(brace
l_int|0x4000
comma
l_string|&quot;Diagnostic failure on component (ASCQ)&quot;
)brace
comma
(brace
l_int|0x4400
comma
l_string|&quot;Internal ATAPI CD-ROM drive failure&quot;
)brace
comma
(brace
l_int|0x4e00
comma
l_string|&quot;Overlapped commands attempted&quot;
)brace
comma
(brace
l_int|0x5300
comma
l_string|&quot;Media load or eject failed&quot;
)brace
comma
(brace
l_int|0x5302
comma
l_string|&quot;Medium removal prevented&quot;
)brace
comma
(brace
l_int|0x5700
comma
l_string|&quot;Unable to recover table of contents&quot;
)brace
comma
(brace
l_int|0x5a00
comma
l_string|&quot;Operator request or state change input (unspecified)&quot;
)brace
comma
(brace
l_int|0x5a01
comma
l_string|&quot;Operator medium removal request&quot;
)brace
comma
(brace
l_int|0x5b00
comma
l_string|&quot;Threshold condition met&quot;
)brace
comma
(brace
l_int|0x5c00
comma
l_string|&quot;Status change&quot;
)brace
comma
(brace
l_int|0x6300
comma
l_string|&quot;End of user area encountered on this track&quot;
)brace
comma
(brace
l_int|0x6400
comma
l_string|&quot;Illegal mode for this track&quot;
)brace
comma
(brace
l_int|0xbf00
comma
l_string|&quot;Loss of streaming&quot;
)brace
comma
)brace
suffix:semicolon
macro_line|#endif
"&f;"
multiline_comment|/****************************************************************************&n; * Generic packet command support and error handling routines.&n; */
r_static
DECL|function|cdrom_analyze_sense_data
r_void
id|cdrom_analyze_sense_data
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
comma
r_struct
id|packet_command
op_star
id|failed_command
)paren
(brace
multiline_comment|/* Don&squot;t print not ready or unit attention errors for READ_SUBCHANNEL.&n;     Workman (and probably other programs) uses this command to poll&n;     the drive, and we don&squot;t want to fill the syslog with useless errors. */
r_if
c_cond
(paren
id|failed_command
op_logical_and
id|failed_command-&gt;c
(braket
l_int|0
)braket
op_eq
id|SCMD_READ_SUBCHANNEL
op_logical_and
(paren
id|reqbuf-&gt;sense_key
op_eq
id|NOT_READY
op_logical_or
id|reqbuf-&gt;sense_key
op_eq
id|UNIT_ATTENTION
)paren
)paren
r_return
suffix:semicolon
macro_line|#if VERBOSE_IDE_CD_ERRORS
(brace
r_int
id|i
suffix:semicolon
r_char
op_star
id|s
suffix:semicolon
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
id|printk
(paren
l_string|&quot;ATAPI device %s:&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;  Error code: 0x%02x&bslash;n&quot;
comma
id|reqbuf-&gt;error_code
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_ge
l_int|0
op_logical_and
id|reqbuf-&gt;sense_key
OL
id|ARY_LEN
(paren
id|sense_key_texts
)paren
)paren
id|s
op_assign
id|sense_key_texts
(braket
id|reqbuf-&gt;sense_key
)braket
suffix:semicolon
r_else
id|s
op_assign
l_string|&quot;(bad sense key)&quot;
suffix:semicolon
id|printk
(paren
l_string|&quot;  Sense key: 0x%02x - %s&bslash;n&quot;
comma
id|reqbuf-&gt;sense_key
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf-&gt;asc
op_eq
l_int|0x40
)paren
(brace
id|sprintf
(paren
id|buf
comma
l_string|&quot;Diagnostic failure on component 0x%02x&quot;
comma
id|reqbuf-&gt;ascq
)paren
suffix:semicolon
id|s
op_assign
id|buf
suffix:semicolon
)brace
r_else
(brace
r_int
id|lo
comma
id|hi
suffix:semicolon
r_int
id|key
op_assign
(paren
id|reqbuf-&gt;asc
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|reqbuf-&gt;ascq
op_ge
l_int|0x80
op_logical_and
id|reqbuf-&gt;ascq
op_le
l_int|0xdd
)paren
)paren
id|key
op_or_assign
id|reqbuf-&gt;ascq
suffix:semicolon
id|lo
op_assign
l_int|0
suffix:semicolon
id|hi
op_assign
id|ARY_LEN
(paren
id|sense_data_texts
)paren
suffix:semicolon
id|s
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|hi
OG
id|lo
)paren
(brace
r_int
id|mid
op_assign
(paren
id|lo
op_plus
id|hi
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|sense_data_texts
(braket
id|mid
)braket
dot
id|asc_ascq
op_eq
id|key
)paren
(brace
id|s
op_assign
id|sense_data_texts
(braket
id|mid
)braket
dot
id|text
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense_data_texts
(braket
id|mid
)braket
dot
id|asc_ascq
OG
id|key
)paren
id|hi
op_assign
id|mid
suffix:semicolon
r_else
id|lo
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|s
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|reqbuf-&gt;asc
OG
l_int|0x80
)paren
id|s
op_assign
l_string|&quot;(vendor-specific error)&quot;
suffix:semicolon
r_else
id|s
op_assign
l_string|&quot;(reserved error code)&quot;
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;  Additional sense data: 0x%02x, 0x%02x  - %s&bslash;n&quot;
comma
id|reqbuf-&gt;asc
comma
id|reqbuf-&gt;ascq
comma
id|s
)paren
suffix:semicolon
r_if
c_cond
(paren
id|failed_command
op_ne
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;  Failed packet command: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|failed_command-&gt;c
)paren
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot;%02x &quot;
comma
id|failed_command-&gt;c
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
(paren
id|reqbuf-&gt;sense_key_specific
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;  Error in %s byte %d&quot;
comma
(paren
id|reqbuf-&gt;sense_key_specific
(braket
l_int|0
)braket
op_amp
l_int|0x40
)paren
op_ne
l_int|0
ques
c_cond
l_string|&quot;command packet&quot;
suffix:colon
l_string|&quot;command data&quot;
comma
(paren
id|reqbuf-&gt;sense_key_specific
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_plus
id|reqbuf-&gt;sense_key_specific
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|reqbuf-&gt;sense_key_specific
(braket
l_int|0
)braket
op_amp
l_int|0x40
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot; bit %d&quot;
comma
id|reqbuf-&gt;sense_key_specific
(braket
l_int|0
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#else
multiline_comment|/* Suppress printing unit attention and `in progress of becoming ready&squot;&n;     errors when we&squot;re not being verbose. */
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|UNIT_ATTENTION
op_logical_or
(paren
id|reqbuf-&gt;sense_key
op_eq
id|NOT_READY
op_logical_and
(paren
id|reqbuf-&gt;asc
op_eq
l_int|4
op_logical_or
id|reqbuf-&gt;asc
op_eq
l_int|0x3a
)paren
)paren
)paren
r_return
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: code: 0x%02x  key: 0x%02x  asc: 0x%02x  ascq: 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|reqbuf-&gt;error_code
comma
id|reqbuf-&gt;sense_key
comma
id|reqbuf-&gt;asc
comma
id|reqbuf-&gt;ascq
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Fix up a possibly partially-processed request so that we can&n;   start it over entirely, or even put it back on the request queue. */
DECL|function|restore_request
r_static
r_void
id|restore_request
(paren
r_struct
id|request
op_star
id|rq
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;buffer
op_ne
id|rq-&gt;bh-&gt;b_data
)paren
(brace
r_int
id|n
op_assign
(paren
id|rq-&gt;buffer
op_minus
id|rq-&gt;bh-&gt;b_data
)paren
op_div
id|SECTOR_SIZE
suffix:semicolon
id|rq-&gt;buffer
op_assign
id|rq-&gt;bh-&gt;b_data
suffix:semicolon
id|rq-&gt;nr_sectors
op_add_assign
id|n
suffix:semicolon
id|rq-&gt;sector
op_sub_assign
id|n
suffix:semicolon
)brace
id|rq-&gt;current_nr_sectors
op_assign
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
suffix:semicolon
)brace
DECL|function|cdrom_queue_request_sense
r_static
r_void
id|cdrom_queue_request_sense
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|semaphore
op_star
id|sem
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
comma
r_struct
id|packet_command
op_star
id|failed_command
)paren
(brace
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
suffix:semicolon
r_int
id|len
suffix:semicolon
multiline_comment|/* If the request didn&squot;t explicitly specify where to put the sense data,&n;     use the statically allocated structure. */
r_if
c_cond
(paren
id|reqbuf
op_eq
l_int|NULL
)paren
id|reqbuf
op_assign
op_amp
id|drive-&gt;cdrom_info.sense_data
suffix:semicolon
multiline_comment|/* Make up a new request to retrieve sense information. */
id|pc
op_assign
op_amp
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|request_sense_pc
suffix:semicolon
id|memset
(paren
id|pc
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|pc
)paren
)paren
suffix:semicolon
multiline_comment|/* The request_sense structure has an odd number of (16-bit) words,&n;     which won&squot;t work well with 32-bit transfers.  However, we don&squot;t care&n;     about the last two bytes, so just truncate the structure down&n;     to an even length. */
id|len
op_assign
r_sizeof
(paren
op_star
id|reqbuf
)paren
op_div
l_int|4
suffix:semicolon
id|len
op_mul_assign
l_int|4
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|len
suffix:semicolon
id|pc-&gt;buffer
op_assign
(paren
r_char
op_star
)paren
id|reqbuf
suffix:semicolon
id|pc-&gt;buflen
op_assign
id|len
suffix:semicolon
id|pc-&gt;sense_data
op_assign
(paren
r_struct
id|atapi_request_sense
op_star
)paren
id|failed_command
suffix:semicolon
multiline_comment|/* stuff the sense request in front of our current request */
id|rq
op_assign
op_amp
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|request_sense_request
suffix:semicolon
id|ide_init_drive_cmd
(paren
id|rq
)paren
suffix:semicolon
id|rq-&gt;cmd
op_assign
id|REQUEST_SENSE_COMMAND
suffix:semicolon
id|rq-&gt;buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
id|rq-&gt;sem
op_assign
id|sem
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
id|rq
comma
id|ide_preempt
)paren
suffix:semicolon
)brace
DECL|function|cdrom_end_request
r_static
r_void
id|cdrom_end_request
(paren
r_int
id|uptodate
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
multiline_comment|/* The code in blk.h can screw us up on error recovery if the block&n;     size is larger than 1k.  Fix that up here. */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
op_logical_and
id|rq-&gt;bh
op_ne
l_int|0
)paren
(brace
r_int
id|adj
op_assign
id|rq-&gt;current_nr_sectors
op_minus
l_int|1
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|adj
suffix:semicolon
id|rq-&gt;sector
op_add_assign
id|adj
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|REQUEST_SENSE_COMMAND
op_logical_and
id|uptodate
)paren
(brace
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|cdrom_analyze_sense_data
(paren
id|drive
comma
(paren
r_struct
id|atapi_request_sense
op_star
)paren
(paren
id|pc-&gt;buffer
op_minus
id|pc-&gt;c
(braket
l_int|4
)braket
)paren
comma
(paren
r_struct
id|packet_command
op_star
)paren
id|pc-&gt;sense_data
)paren
suffix:semicolon
)brace
id|ide_end_request
(paren
id|uptodate
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Mark that we&squot;ve seen a media change, and invalidate our internal&n;   buffers. */
DECL|function|cdrom_saw_media_change
r_static
r_void
id|cdrom_saw_media_change
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|1
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;cdrom_info.nsectors_buffered
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Returns 0 if the request should be continued.&n;   Returns 1 if the request was ended. */
DECL|function|cdrom_decode_status
r_static
r_int
id|cdrom_decode_status
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|good_stat
comma
r_int
op_star
id|stat_ret
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|stat
comma
id|err
comma
id|sense_key
comma
id|cmd
suffix:semicolon
multiline_comment|/* Check for errors. */
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
op_star
id|stat_ret
op_assign
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
(paren
id|stat
comma
id|good_stat
comma
id|BAD_R_STAT
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Got an error. */
id|err
op_assign
id|IN_BYTE
(paren
id|IDE_ERROR_REG
)paren
suffix:semicolon
id|sense_key
op_assign
id|err
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|rq
op_eq
l_int|NULL
)paren
id|printk
(paren
l_string|&quot;%s : missing request in cdrom_decode_status&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_else
(brace
id|cmd
op_assign
id|rq-&gt;cmd
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|REQUEST_SENSE_COMMAND
)paren
(brace
multiline_comment|/* We got an error trying to get sense info from the drive&n;&t;     (probably while trying to recover from a former error).&n;&t;     Just give up. */
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
id|ide_error
(paren
id|drive
comma
l_string|&quot;request sense failure&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|PACKET_COMMAND
)paren
(brace
multiline_comment|/* All other functions, except for READ. */
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
r_struct
id|semaphore
op_star
id|sem
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Check for tray open. */
r_if
c_cond
(paren
id|sense_key
op_eq
id|NOT_READY
)paren
(brace
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Print an error message to the syslog.&n;&t;&t; Exception: don&squot;t print anything if this is a read subchannel&n;&t;&t; command.  This is because workman constantly polls the drive&n;&t;&t; with this command, and we don&squot;t want to uselessly fill up&n;&t;&t; the syslog. */
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|SCMD_READ_SUBCHANNEL
)paren
id|printk
(paren
l_string|&quot;%s : tray open or drive not ready&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for media change. */
r_else
r_if
c_cond
(paren
id|sense_key
op_eq
id|UNIT_ATTENTION
)paren
(brace
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: media changed&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/* Otherwise, print an error. */
r_else
(brace
id|ide_dump_status
(paren
id|drive
comma
l_string|&quot;packet command error&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the error flag and complete the request.&n;&t;     Then, if we have a CHECK CONDITION status, queue a request&n;&t;     sense command.  We must be careful, though: we don&squot;t want&n;&t;     the thread in cdrom_queue_packet_command to wake up until&n;&t;     the request sense has completed.  We do this by transferring&n;&t;     the semaphore from the packet command request to the&n;&t;     request sense request. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_ne
l_int|0
)paren
(brace
id|sem
op_assign
id|rq-&gt;sem
suffix:semicolon
id|rq-&gt;sem
op_assign
l_int|NULL
suffix:semicolon
)brace
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_ne
l_int|0
)paren
id|cdrom_queue_request_sense
(paren
id|drive
comma
id|sem
comma
id|pc-&gt;sense_data
comma
id|pc
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Handle errors from READ requests. */
multiline_comment|/* Check for tray open. */
r_if
c_cond
(paren
id|sense_key
op_eq
id|NOT_READY
)paren
(brace
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Fail the request. */
id|printk
(paren
l_string|&quot;%s : tray open&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for media change. */
r_else
r_if
c_cond
(paren
id|sense_key
op_eq
id|UNIT_ATTENTION
)paren
(brace
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Arrange to retry the request.&n;&t;         But be sure to give up if we&squot;ve retried too many times. */
r_if
c_cond
(paren
op_increment
id|rq-&gt;errors
OG
id|ERROR_MAX
)paren
(brace
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* No point in retrying after an illegal request or&n;&t;     data protect error.*/
r_else
r_if
c_cond
(paren
id|sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_or
id|sense_key
op_eq
id|DATA_PROTECT
)paren
(brace
id|ide_dump_status
(paren
id|drive
comma
l_string|&quot;command error&quot;
comma
id|stat
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/* If there were other errors, go to the default handler. */
r_else
r_if
c_cond
(paren
(paren
id|err
op_amp
op_complement
id|ABRT_ERR
)paren
op_ne
l_int|0
)paren
(brace
id|ide_error
(paren
id|drive
comma
l_string|&quot;cdrom_decode_status&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Else, abort if we&squot;ve racked up too many retries. */
r_else
r_if
c_cond
(paren
(paren
op_increment
id|rq-&gt;errors
OG
id|ERROR_MAX
)paren
)paren
(brace
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/* If we got a CHECK_CONDITION status, queue a request sense&n;&t;     command. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_ne
l_int|0
)paren
id|cdrom_queue_request_sense
(paren
id|drive
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Retry, or handle the next request. */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Set up the device registers for transferring a packet command on DEV,&n;   expecting to later transfer XFERLEN bytes.  HANDLER is the routine&n;   which actually transfers the command to the drive.  If this is a&n;   drq_interrupt device, this routine will arrange for HANDLER to be&n;   called when the interrupt from the drive arrives.  Otherwise, HANDLER&n;   will be called immediately after the drive is prepared for the transfer. */
DECL|function|cdrom_start_packet_command
r_static
r_int
id|cdrom_start_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|xferlen
comma
id|ide_handler_t
op_star
id|handler
)paren
(brace
multiline_comment|/* Wait for the controller to be idle. */
r_if
c_cond
(paren
id|ide_wait_stat
(paren
id|drive
comma
l_int|0
comma
id|BUSY_STAT
comma
id|WAIT_READY
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Set up the controller registers. */
id|OUT_BYTE
(paren
l_int|0
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
l_int|0
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
l_int|0
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|xferlen
op_amp
l_int|0xff
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|xferlen
op_rshift
l_int|8
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|WAIT_CMD
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* packet command */
)brace
r_else
(brace
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* packet command */
(paren
op_star
id|handler
)paren
(paren
id|drive
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Send a packet command to DRIVE described by CMD_BUF and CMD_LEN.&n;   The device registers must have already been prepared&n;   by cdrom_start_packet_command.&n;   HANDLER is the interrupt handler to call when the command completes&n;   or there&squot;s data ready. */
DECL|function|cdrom_transfer_packet_command
r_static
r_int
id|cdrom_transfer_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
r_char
op_star
id|cmd_buf
comma
r_int
id|cmd_len
comma
id|ide_handler_t
op_star
id|handler
)paren
(brace
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
)paren
(brace
multiline_comment|/* Here we should have been called after receiving an interrupt&n;         from the device.  DRQ should how be set. */
r_int
id|stat_dum
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
id|drive
comma
id|DRQ_STAT
comma
op_amp
id|stat_dum
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, we must wait for DRQ to get set. */
r_if
c_cond
(paren
id|ide_wait_stat
(paren
id|drive
comma
id|DRQ_STAT
comma
id|BUSY_STAT
comma
id|WAIT_READY
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Arm the interrupt handler. */
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|WAIT_CMD
)paren
suffix:semicolon
multiline_comment|/* Send the command to the device. */
id|cdrom_out_bytes
(paren
id|drive
comma
id|cmd_buf
comma
id|cmd_len
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Block read functions.&n; */
multiline_comment|/*&n; * Buffer up to SECTORS_TO_TRANSFER sectors from the drive in our sector&n; * buffer.  Once the first sector is added, any subsequent sectors are&n; * assumed to be continuous (until the buffer is cleared).  For the first&n; * sector added, SECTOR is its sector number.  (SECTOR is then ignored until&n; * the buffer is cleared.)&n; */
DECL|function|cdrom_buffer_sectors
r_static
r_void
id|cdrom_buffer_sectors
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|sector
comma
r_int
id|sectors_to_transfer
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
op_amp
id|drive-&gt;cdrom_info
suffix:semicolon
multiline_comment|/* Number of sectors to read into the buffer. */
r_int
id|sectors_to_buffer
op_assign
id|MIN
(paren
id|sectors_to_transfer
comma
(paren
id|SECTOR_BUFFER_SIZE
op_rshift
id|SECTOR_BITS
)paren
op_minus
id|info-&gt;nsectors_buffered
)paren
suffix:semicolon
r_char
op_star
id|dest
suffix:semicolon
multiline_comment|/* If we don&squot;t yet have a sector buffer, try to allocate one.&n;     If we can&squot;t get one atomically, it&squot;s not fatal -- we&squot;ll just throw&n;     the data away rather than caching it. */
r_if
c_cond
(paren
id|info-&gt;sector_buffer
op_eq
l_int|NULL
)paren
(brace
id|info-&gt;sector_buffer
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
(paren
id|SECTOR_BUFFER_SIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/* If we couldn&squot;t get a buffer, don&squot;t try to buffer anything... */
r_if
c_cond
(paren
id|info-&gt;sector_buffer
op_eq
l_int|NULL
)paren
id|sectors_to_buffer
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If this is the first sector in the buffer, remember its number. */
r_if
c_cond
(paren
id|info-&gt;nsectors_buffered
op_eq
l_int|0
)paren
id|info-&gt;sector_buffered
op_assign
id|sector
suffix:semicolon
multiline_comment|/* Read the data into the buffer. */
id|dest
op_assign
id|info-&gt;sector_buffer
op_plus
id|info-&gt;nsectors_buffered
op_star
id|SECTOR_SIZE
suffix:semicolon
r_while
c_loop
(paren
id|sectors_to_buffer
OG
l_int|0
)paren
(brace
id|cdrom_in_bytes
(paren
id|drive
comma
id|dest
comma
id|SECTOR_SIZE
)paren
suffix:semicolon
op_decrement
id|sectors_to_buffer
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
op_increment
id|info-&gt;nsectors_buffered
suffix:semicolon
id|dest
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
)brace
multiline_comment|/* Throw away any remaining data. */
r_while
c_loop
(paren
id|sectors_to_transfer
OG
l_int|0
)paren
(brace
r_char
id|dum
(braket
id|SECTOR_SIZE
)braket
suffix:semicolon
id|cdrom_in_bytes
(paren
id|drive
comma
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Check the contents of the interrupt reason register from the cdrom&n; * and attempt to recover if there are problems.  Returns  0 if everything&squot;s&n; * ok; nonzero if the request has been terminated.&n; */
r_static
r_inline
DECL|function|cdrom_read_check_ireason
r_int
id|cdrom_read_check_ireason
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|len
comma
r_int
id|ireason
)paren
(brace
id|ireason
op_and_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|ireason
op_eq
l_int|2
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ireason
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Whoops... The drive is expecting to receive data from us! */
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: &quot;
l_string|&quot;Drive wants to transfer data the wrong way!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Throw some data at the drive so it doesn&squot;t hang&n;         and quit this request. */
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|cdrom_out_bytes
(paren
id|drive
comma
op_amp
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
id|dum
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Drive wants a command packet, or invalid ireason... */
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: bad interrupt reason %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|ireason
)paren
suffix:semicolon
)brace
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Interrupt routine.  Called when a read request has completed.&n; */
DECL|function|cdrom_read_intr
r_static
r_void
id|cdrom_read_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|stat
suffix:semicolon
r_int
id|ireason
comma
id|len
comma
id|sectors_to_transfer
comma
id|nskip
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
id|drive
comma
l_int|0
comma
op_amp
id|stat
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Read the interrupt reason and the transfer length. */
id|ireason
op_assign
id|IN_BYTE
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|len
op_assign
id|IN_BYTE
(paren
id|IDE_LCYL_REG
)paren
op_plus
l_int|256
op_star
id|IN_BYTE
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/* If DRQ is clear, the command has completed. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* If we&squot;re not done filling the current buffer, complain.&n;         Otherwise, complete the command normally. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
OG
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: data underrun (%ld blocks)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check that the drive is expecting to do the same thing that we are. */
r_if
c_cond
(paren
id|cdrom_read_check_ireason
(paren
id|drive
comma
id|len
comma
id|ireason
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Assume that the drive will always provide data in multiples of at least&n;     SECTOR_SIZE, as it gets hairy to keep track of the transfers otherwise. */
r_if
c_cond
(paren
(paren
id|len
op_mod
id|SECTOR_SIZE
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: Bad transfer size %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|len
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;  This drive is not supported by this version of the driver&bslash;n&quot;
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The number of sectors we need to read from the drive. */
id|sectors_to_transfer
op_assign
id|len
op_div
id|SECTOR_SIZE
suffix:semicolon
multiline_comment|/* First, figure out if we need to bit-bucket any of the leading sectors. */
id|nskip
op_assign
id|MIN
(paren
(paren
r_int
)paren
(paren
id|rq-&gt;current_nr_sectors
op_minus
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
)paren
comma
id|sectors_to_transfer
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nskip
OG
l_int|0
)paren
(brace
multiline_comment|/* We need to throw away a sector. */
r_char
id|dum
(braket
id|SECTOR_SIZE
)braket
suffix:semicolon
id|cdrom_in_bytes
(paren
id|drive
comma
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_decrement
id|nskip
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
multiline_comment|/* Now loop while we still have data to read from the drive. */
r_while
c_loop
(paren
id|sectors_to_transfer
OG
l_int|0
)paren
(brace
r_int
id|this_transfer
suffix:semicolon
multiline_comment|/* If we&squot;ve filled the present buffer but there&squot;s another chained&n;         buffer after it, move on. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
op_logical_and
id|rq-&gt;nr_sectors
OG
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* If the buffers are full, cache the rest of the data in our&n;         internal buffer. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
(brace
id|cdrom_buffer_sectors
(paren
id|drive
comma
id|rq-&gt;sector
comma
id|sectors_to_transfer
)paren
suffix:semicolon
id|sectors_to_transfer
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Transfer data to the buffers.&n;             Figure out how many sectors we can transfer&n;             to the current buffer. */
id|this_transfer
op_assign
id|MIN
(paren
id|sectors_to_transfer
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
multiline_comment|/* Read this_transfer sectors into the current buffer. */
r_while
c_loop
(paren
id|this_transfer
OG
l_int|0
)paren
(brace
id|cdrom_in_bytes
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|SECTOR_SIZE
)paren
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
op_decrement
id|rq-&gt;nr_sectors
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_increment
id|rq-&gt;sector
suffix:semicolon
op_decrement
id|this_transfer
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Done moving data!&n;     Wait for another interrupt. */
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|cdrom_read_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to satisfy some of the current read request from our cached data.&n; * Returns nonzero if the request has been completed, zero otherwise.&n; */
DECL|function|cdrom_read_from_buffer
r_static
r_int
id|cdrom_read_from_buffer
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
op_amp
id|drive-&gt;cdrom_info
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
multiline_comment|/* Can&squot;t do anything if there&squot;s no buffer. */
r_if
c_cond
(paren
id|info-&gt;sector_buffer
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Loop while this request needs data and the next block is present&n;     in our cache. */
r_while
c_loop
(paren
id|rq-&gt;nr_sectors
OG
l_int|0
op_logical_and
id|rq-&gt;sector
op_ge
id|info-&gt;sector_buffered
op_logical_and
id|rq-&gt;sector
OL
id|info-&gt;sector_buffered
op_plus
id|info-&gt;nsectors_buffered
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
id|memcpy
(paren
id|rq-&gt;buffer
comma
id|info-&gt;sector_buffer
op_plus
(paren
id|rq-&gt;sector
op_minus
id|info-&gt;sector_buffered
)paren
op_star
id|SECTOR_SIZE
comma
id|SECTOR_SIZE
)paren
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_decrement
id|rq-&gt;nr_sectors
suffix:semicolon
op_increment
id|rq-&gt;sector
suffix:semicolon
)brace
multiline_comment|/* If we&squot;ve satisfied the current request, terminate it successfully. */
r_if
c_cond
(paren
id|rq-&gt;nr_sectors
op_eq
l_int|0
)paren
(brace
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Move on to the next buffer if needed. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* If this condition does not hold, then the kluge i use to&n;     represent the number of sectors to skip at the start of a transfer&n;     will fail.  I think that this will never happen, but let&squot;s be&n;     paranoid and check. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
OL
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
op_logical_and
(paren
id|rq-&gt;sector
op_mod
id|SECTORS_PER_FRAME
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_from_buffer: buffer botch (%ld)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;sector
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Routine to send a read packet command to the drive.&n; * This is usually called directly from cdrom_start_read.&n; * However, for drq_interrupt devices, it is called from an interrupt&n; * when the drive is ready to accept the command.&n; */
DECL|function|cdrom_start_read_continuation
r_static
r_void
id|cdrom_start_read_continuation
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|nsect
comma
id|sector
comma
id|nframes
comma
id|frame
comma
id|nskip
suffix:semicolon
multiline_comment|/* Number of sectors to transfer. */
id|nsect
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
multiline_comment|/* Starting sector. */
id|sector
op_assign
id|rq-&gt;sector
suffix:semicolon
multiline_comment|/* If the requested sector doesn&squot;t start on a cdrom block boundary,&n;     we must adjust the start of the transfer so that it does,&n;     and remember to skip the first few sectors.  If the CURRENT_NR_SECTORS&n;     field is larger than the size of the buffer, it will mean that&n;     we&squot;re to skip a number of sectors equal to the amount by which&n;     CURRENT_NR_SECTORS is larger than the buffer size. */
id|nskip
op_assign
(paren
id|sector
op_mod
id|SECTORS_PER_FRAME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nskip
OG
l_int|0
)paren
(brace
multiline_comment|/* Sanity check... */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_ne
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_start_read_continuation: buffer botch (%ld)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sector
op_sub_assign
id|nskip
suffix:semicolon
id|nsect
op_add_assign
id|nskip
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_add_assign
id|nskip
suffix:semicolon
)brace
multiline_comment|/* Convert from sectors to cdrom blocks, rounding up the transfer&n;     length if needed. */
id|nframes
op_assign
(paren
id|nsect
op_plus
id|SECTORS_PER_FRAME
op_minus
l_int|1
)paren
op_div
id|SECTORS_PER_FRAME
suffix:semicolon
id|frame
op_assign
id|sector
op_div
id|SECTORS_PER_FRAME
suffix:semicolon
multiline_comment|/* Largest number of frames was can transfer at once is 64k-1. */
id|nframes
op_assign
id|MIN
(paren
id|nframes
comma
l_int|65535
)paren
suffix:semicolon
multiline_comment|/* Set up the command */
id|memset
(paren
op_amp
id|pc.c
comma
l_int|0
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|READ_10
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|nframes
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|nframes
op_amp
l_int|0xff
)paren
suffix:semicolon
macro_line|#ifdef __alpha__
id|stl_u
(paren
id|htonl
(paren
id|frame
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
suffix:semicolon
macro_line|#else
op_star
(paren
r_int
op_star
)paren
(paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
op_assign
id|htonl
(paren
id|frame
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Send the command to the drive and return. */
(paren
r_void
)paren
id|cdrom_transfer_packet_command
(paren
id|drive
comma
id|pc.c
comma
r_sizeof
(paren
id|pc.c
)paren
comma
op_amp
id|cdrom_read_intr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Start a read request from the CD-ROM.&n; */
DECL|function|cdrom_start_read
r_static
r_void
id|cdrom_start_read
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|minor
op_assign
id|MINOR
(paren
id|rq-&gt;rq_dev
)paren
suffix:semicolon
multiline_comment|/* If the request is relative to a partition, fix it up to refer to the&n;     absolute address.  */
r_if
c_cond
(paren
(paren
id|minor
op_amp
id|PARTN_MASK
)paren
op_ne
l_int|0
)paren
(brace
id|rq-&gt;sector
op_assign
id|block
suffix:semicolon
id|minor
op_and_assign
op_complement
id|PARTN_MASK
suffix:semicolon
id|rq-&gt;rq_dev
op_assign
id|MKDEV
(paren
id|MAJOR
c_func
(paren
id|rq-&gt;rq_dev
)paren
comma
id|minor
)paren
suffix:semicolon
)brace
multiline_comment|/* We may be retrying this request after an error.&n;     Fix up any weirdness which might be present in the request packet. */
id|restore_request
(paren
id|rq
)paren
suffix:semicolon
multiline_comment|/* Satisfy whatever we can of this request from our cached sector. */
r_if
c_cond
(paren
id|cdrom_read_from_buffer
(paren
id|drive
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Clear the local sector buffer. */
id|drive-&gt;cdrom_info.nsectors_buffered
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start sending the read request to the drive. */
id|cdrom_start_packet_command
(paren
id|drive
comma
l_int|32768
comma
id|cdrom_start_read_continuation
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Execute all other packet commands.&n; */
multiline_comment|/* Forward declarations. */
r_static
r_int
id|cdrom_lockdoor
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lockflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
suffix:semicolon
multiline_comment|/* Interrupt routine for packet command completion. */
DECL|function|cdrom_pc_intr
r_static
r_void
id|cdrom_pc_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|ireason
comma
id|len
comma
id|stat
comma
id|thislen
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
id|drive
comma
l_int|0
comma
op_amp
id|stat
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Read the interrupt reason and the transfer length. */
id|ireason
op_assign
id|IN_BYTE
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|len
op_assign
id|IN_BYTE
(paren
id|IDE_LCYL_REG
)paren
op_plus
l_int|256
op_star
id|IN_BYTE
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/* If DRQ is clear, the command has completed.&n;     Complain if we still have data left to transfer. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Some of the trailing request sense fields are optional, and&n;&t; some drives don&squot;t send them.  Sigh. */
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|REQUEST_SENSE
op_logical_and
id|pc-&gt;buflen
OG
l_int|0
op_logical_and
id|pc-&gt;buflen
op_le
l_int|5
)paren
(brace
r_while
c_loop
(paren
id|pc-&gt;buflen
OG
l_int|0
)paren
(brace
op_star
id|pc-&gt;buffer
op_increment
op_assign
l_int|0
suffix:semicolon
op_decrement
id|pc-&gt;buflen
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pc-&gt;buflen
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_else
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: data underrun %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|pc-&gt;buflen
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/* Figure out how much data to transfer. */
id|thislen
op_assign
id|pc-&gt;buflen
suffix:semicolon
r_if
c_cond
(paren
id|thislen
OL
l_int|0
)paren
id|thislen
op_assign
op_minus
id|thislen
suffix:semicolon
r_if
c_cond
(paren
id|thislen
OG
id|len
)paren
id|thislen
op_assign
id|len
suffix:semicolon
multiline_comment|/* The drive wants to be written to. */
r_if
c_cond
(paren
(paren
id|ireason
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Check that we want to write. */
r_if
c_cond
(paren
id|pc-&gt;buflen
OG
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: Drive wants to transfer data the wrong way!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|thislen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Transfer the data. */
id|cdrom_out_bytes
(paren
id|drive
comma
id|pc-&gt;buffer
comma
id|thislen
)paren
suffix:semicolon
multiline_comment|/* If we haven&squot;t moved enough data to satisfy the drive,&n;         add some padding. */
r_while
c_loop
(paren
id|len
OG
id|thislen
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|cdrom_out_bytes
(paren
id|drive
comma
op_amp
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
id|dum
)paren
suffix:semicolon
)brace
multiline_comment|/* Keep count of how much data we&squot;ve moved. */
id|pc-&gt;buffer
op_add_assign
id|thislen
suffix:semicolon
id|pc-&gt;buflen
op_add_assign
id|thislen
suffix:semicolon
)brace
multiline_comment|/* Same drill for reading. */
r_else
r_if
c_cond
(paren
(paren
id|ireason
op_amp
l_int|3
)paren
op_eq
l_int|2
)paren
(brace
multiline_comment|/* Check that we want to read. */
r_if
c_cond
(paren
id|pc-&gt;buflen
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: Drive wants to transfer data the wrong way!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|thislen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Transfer the data. */
id|cdrom_in_bytes
(paren
id|drive
comma
id|pc-&gt;buffer
comma
id|thislen
)paren
suffix:semicolon
multiline_comment|/* If we haven&squot;t moved enough data to satisfy the drive,&n;         add some padding. */
r_while
c_loop
(paren
id|len
OG
id|thislen
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|cdrom_in_bytes
(paren
id|drive
comma
op_amp
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
id|dum
)paren
suffix:semicolon
)brace
multiline_comment|/* Keep count of how much data we&squot;ve moved. */
id|pc-&gt;buffer
op_add_assign
id|thislen
suffix:semicolon
id|pc-&gt;buflen
op_sub_assign
id|thislen
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: The drive appears confused (ireason = 0x%2x)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|ireason
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now we wait for another interrupt. */
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|cdrom_pc_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
)brace
DECL|function|cdrom_do_pc_continuation
r_static
r_void
id|cdrom_do_pc_continuation
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
multiline_comment|/* Send the command to the drive and return. */
id|cdrom_transfer_packet_command
(paren
id|drive
comma
id|pc-&gt;c
comma
r_sizeof
(paren
id|pc-&gt;c
)paren
comma
op_amp
id|cdrom_pc_intr
)paren
suffix:semicolon
)brace
DECL|function|cdrom_do_packet_command
r_static
r_void
id|cdrom_do_packet_command
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|len
op_assign
id|pc-&gt;buflen
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
op_minus
id|len
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start sending the command to the drive. */
id|cdrom_start_packet_command
(paren
id|drive
comma
id|len
comma
id|cdrom_do_pc_continuation
)paren
suffix:semicolon
)brace
multiline_comment|/* Sleep for TIME jiffies.&n;   Not to be called from an interrupt handler. */
r_static
DECL|function|cdrom_sleep
r_void
id|cdrom_sleep
(paren
r_int
id|time
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|time
suffix:semicolon
id|schedule
(paren
)paren
suffix:semicolon
)brace
r_static
DECL|function|cdrom_queue_packet_command
r_int
id|cdrom_queue_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|packet_command
op_star
id|pc
)paren
(brace
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_int
id|retries
op_assign
l_int|10
suffix:semicolon
r_struct
id|request
id|req
suffix:semicolon
multiline_comment|/* If our caller has not provided a place to stick any sense data,&n;     use our own area. */
r_if
c_cond
(paren
id|pc-&gt;sense_data
op_eq
l_int|NULL
)paren
id|pc-&gt;sense_data
op_assign
op_amp
id|my_reqbuf
suffix:semicolon
id|pc-&gt;sense_data-&gt;sense_key
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Start of retry loop. */
r_do
(brace
id|ide_init_drive_cmd
(paren
op_amp
id|req
)paren
suffix:semicolon
id|req.cmd
op_assign
id|PACKET_COMMAND
suffix:semicolon
id|req.buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
(paren
id|drive
comma
op_amp
id|req
comma
id|ide_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pc-&gt;stat
op_ne
l_int|0
)paren
(brace
multiline_comment|/* The request failed.  Retry if it was due to a unit attention status&n;&t;   (usually means media was changed). */
r_struct
id|atapi_request_sense
op_star
id|reqbuf
op_assign
id|pc-&gt;sense_data
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|UNIT_ATTENTION
)paren
suffix:semicolon
multiline_comment|/* Also retry if the drive is in the process of loading a disk.&n;&t;   This time, however, wait a little between retries to give&n;&t;   the drive time. */
r_else
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|NOT_READY
op_logical_and
id|reqbuf-&gt;asc
op_eq
l_int|4
)paren
(brace
id|cdrom_sleep
(paren
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/* Otherwise, don&squot;t retry. */
r_else
id|retries
op_assign
l_int|0
suffix:semicolon
op_decrement
id|retries
suffix:semicolon
)brace
multiline_comment|/* End of retry loop. */
)brace
r_while
c_loop
(paren
id|pc-&gt;stat
op_ne
l_int|0
op_logical_and
id|retries
op_ge
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Return an error if the command failed. */
r_if
c_cond
(paren
id|pc-&gt;stat
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_else
(brace
multiline_comment|/* The command succeeded.  If it was anything other than a request sense,&n;&t; eject, or door lock command, and we think that the door is presently&n;&t; unlocked, lock it again.  (The door was probably unlocked via&n;&t; an explicit CDROMEJECT ioctl.) */
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
op_eq
l_int|0
op_logical_and
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|REQUEST_SENSE
op_logical_and
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|ALLOW_MEDIUM_REMOVAL
op_logical_and
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|START_STOP
)paren
)paren
(brace
(paren
r_void
)paren
id|cdrom_lockdoor
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * cdrom driver request routine.&n; */
DECL|function|ide_do_rw_cdrom
r_void
id|ide_do_rw_cdrom
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_if
c_cond
(paren
id|rq
op_member_access_from_pointer
id|cmd
op_eq
id|PACKET_COMMAND
op_logical_or
id|rq
op_member_access_from_pointer
id|cmd
op_eq
id|REQUEST_SENSE_COMMAND
)paren
id|cdrom_do_packet_command
(paren
id|drive
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|rq
op_member_access_from_pointer
id|cmd
op_eq
id|RESET_DRIVE_COMMAND
)paren
(brace
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
id|ide_do_reset
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rq
op_member_access_from_pointer
id|cmd
op_ne
id|READ
)paren
(brace
id|printk
(paren
l_string|&quot;ide-cd: bad cmd %d&bslash;n&quot;
comma
id|rq
op_member_access_from_pointer
id|cmd
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
id|cdrom_start_read
(paren
id|drive
comma
id|block
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Ioctl handling.&n; *&n; * Routines which queue packet commands take as a final argument a pointer&n; * to an atapi_request_sense struct.  If execution of the command results&n; * in an error with a CHECK CONDITION status, this structure will be filled&n; * with the results of the subsequent request sense command.  The pointer&n; * can also be NULL, in which case no sense information is returned.&n; */
macro_line|#if ! STANDARD_ATAPI
r_static
DECL|function|bin2bcd
r_int
id|bin2bcd
(paren
r_int
id|x
)paren
(brace
r_return
(paren
id|x
op_mod
l_int|10
)paren
op_or
(paren
(paren
id|x
op_div
l_int|10
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
)brace
r_static
DECL|function|bcd2bin
r_int
id|bcd2bin
(paren
r_int
id|x
)paren
(brace
r_return
(paren
id|x
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|x
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
macro_line|#endif /* not STANDARD_ATAPI */
r_static
r_inline
DECL|function|lba_to_msf
r_void
id|lba_to_msf
(paren
r_int
id|lba
comma
id|byte
op_star
id|m
comma
id|byte
op_star
id|s
comma
id|byte
op_star
id|f
)paren
(brace
id|lba
op_add_assign
id|CD_BLOCK_OFFSET
suffix:semicolon
id|lba
op_and_assign
l_int|0xffffff
suffix:semicolon
multiline_comment|/* negative lbas use only 24 bits */
op_star
id|m
op_assign
id|lba
op_div
(paren
id|CD_SECS
op_star
id|CD_FRAMES
)paren
suffix:semicolon
id|lba
op_mod_assign
(paren
id|CD_SECS
op_star
id|CD_FRAMES
)paren
suffix:semicolon
op_star
id|s
op_assign
id|lba
op_div
id|CD_FRAMES
suffix:semicolon
op_star
id|f
op_assign
id|lba
op_mod
id|CD_FRAMES
suffix:semicolon
)brace
r_static
r_inline
DECL|function|msf_to_lba
r_int
id|msf_to_lba
(paren
id|byte
id|m
comma
id|byte
id|s
comma
id|byte
id|f
)paren
(brace
r_return
(paren
(paren
(paren
id|m
op_star
id|CD_SECS
)paren
op_plus
id|s
)paren
op_star
id|CD_FRAMES
op_plus
id|f
)paren
op_minus
id|CD_BLOCK_OFFSET
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_check_status
id|cdrom_check_status
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|TEST_UNIT_READY
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* Lock the door if LOCKFLAG is nonzero; unlock it otherwise. */
r_static
r_int
DECL|function|cdrom_lockdoor
id|cdrom_lockdoor
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lockflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_struct
id|packet_command
id|pc
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf
op_eq
l_int|NULL
)paren
id|reqbuf
op_assign
op_amp
id|my_reqbuf
suffix:semicolon
multiline_comment|/* If the drive cannot lock the door, just pretend. */
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
)paren
id|stat
op_assign
l_int|0
suffix:semicolon
r_else
(brace
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|ALLOW_MEDIUM_REMOVAL
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
(paren
id|lockflag
op_ne
l_int|0
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
)paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
op_assign
id|lockflag
suffix:semicolon
r_else
(brace
multiline_comment|/* If we got an illegal field error, the drive&n;&t; probably cannot lock the door. */
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
id|reqbuf-&gt;asc
op_eq
l_int|0x24
)paren
(brace
id|printk
(paren
l_string|&quot;%s: door locking not supported&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
op_assign
l_int|1
suffix:semicolon
id|stat
op_assign
l_int|0
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
op_assign
id|lockflag
suffix:semicolon
)brace
)brace
r_return
id|stat
suffix:semicolon
)brace
multiline_comment|/* Eject the disk if EJECTFLAG is 0.&n;   If EJECTFLAG is 1, try to reload the disk. */
r_static
r_int
DECL|function|cdrom_eject
id|cdrom_eject
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|ejectflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|START_STOP
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
l_int|2
op_plus
(paren
id|ejectflag
op_ne
l_int|0
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_pause
id|cdrom_pause
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|pauseflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_PAUSE_RESUME
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
op_logical_neg
id|pauseflag
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_startstop
id|cdrom_startstop
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|startflag
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|START_STOP
suffix:semicolon
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
id|startflag
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_read_capacity
id|cdrom_read_capacity
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
op_star
id|capacity
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
(brace
r_int
id|lba
suffix:semicolon
r_int
id|blocklen
suffix:semicolon
)brace
id|capbuf
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|READ_CAPACITY
suffix:semicolon
id|pc.buffer
op_assign
(paren
r_char
op_star
)paren
op_amp
id|capbuf
suffix:semicolon
id|pc.buflen
op_assign
r_sizeof
(paren
id|capbuf
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
)paren
(brace
op_star
id|capacity
op_assign
id|ntohl
(paren
id|capbuf.lba
)paren
suffix:semicolon
)brace
r_return
id|stat
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_read_tocentry
id|cdrom_read_tocentry
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|trackno
comma
r_int
id|msf_flag
comma
r_int
id|format
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_READ_TOC
suffix:semicolon
id|pc.c
(braket
l_int|6
)braket
op_assign
id|trackno
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
id|pc.c
(braket
l_int|9
)braket
op_assign
(paren
id|format
op_lshift
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msf_flag
)paren
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* Try to read the entire TOC for the disk into our internal buffer. */
r_static
r_int
DECL|function|cdrom_read_toc
id|cdrom_read_toc
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_int
id|msf_flag
suffix:semicolon
r_int
id|stat
comma
id|ntracks
comma
id|i
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
op_assign
id|drive-&gt;cdrom_info.toc
suffix:semicolon
r_struct
(brace
r_struct
id|atapi_toc_header
id|hdr
suffix:semicolon
r_struct
id|atapi_toc_entry
id|ent
suffix:semicolon
)brace
id|ms_tmp
suffix:semicolon
r_if
c_cond
(paren
id|toc
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Try to allocate space. */
id|toc
op_assign
(paren
r_struct
id|atapi_toc
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|atapi_toc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|drive-&gt;cdrom_info.toc
op_assign
id|toc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|toc
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: No cdrom TOC buffer!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Check to see if the existing data is still valid.&n;     If it is, just return. */
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
)paren
(paren
r_void
)paren
id|cdrom_check_status
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#if STANDARD_ATAPI
id|msf_flag
op_assign
l_int|0
suffix:semicolon
macro_line|#else  /* not STANDARD_ATAPI */
multiline_comment|/* Some drives can&squot;t return TOC data in LBA format. */
id|msf_flag
op_assign
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_lba_toc
)paren
suffix:semicolon
macro_line|#endif  /* not STANDARD_ATAPI */
multiline_comment|/* First read just the header, so we know how long the TOC is. */
id|stat
op_assign
id|cdrom_read_tocentry
(paren
id|drive
comma
l_int|0
comma
id|msf_flag
comma
l_int|0
comma
(paren
r_char
op_star
)paren
op_amp
id|toc-&gt;hdr
comma
r_sizeof
(paren
r_struct
id|atapi_toc_header
)paren
op_plus
r_sizeof
(paren
r_struct
id|atapi_toc_entry
)paren
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|vertos_lossage
)paren
(brace
id|toc-&gt;hdr.first_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.first_track
)paren
suffix:semicolon
id|toc-&gt;hdr.last_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.last_track
)paren
suffix:semicolon
multiline_comment|/* hopefully the length is not BCD, too ;-| */
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
id|ntracks
op_assign
id|toc-&gt;hdr.last_track
op_minus
id|toc-&gt;hdr.first_track
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ntracks
op_le
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|ntracks
OG
id|MAX_TRACKS
)paren
id|ntracks
op_assign
id|MAX_TRACKS
suffix:semicolon
multiline_comment|/* Now read the whole schmeer. */
id|stat
op_assign
id|cdrom_read_tocentry
(paren
id|drive
comma
l_int|0
comma
id|msf_flag
comma
l_int|0
comma
(paren
r_char
op_star
)paren
op_amp
id|toc-&gt;hdr
comma
r_sizeof
(paren
r_struct
id|atapi_toc_header
)paren
op_plus
(paren
id|ntracks
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|atapi_toc_entry
)paren
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc-&gt;hdr.toc_length
op_assign
id|ntohs
(paren
id|toc-&gt;hdr.toc_length
)paren
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|vertos_lossage
)paren
(brace
id|toc-&gt;hdr.first_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.first_track
)paren
suffix:semicolon
id|toc-&gt;hdr.last_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.last_track
)paren
suffix:semicolon
multiline_comment|/* hopefully the length is not BCD, too ;-| */
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|ntracks
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|msf_flag
)paren
(brace
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|vertos_lossage
)paren
(brace
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|track
op_assign
id|bcd2bin
(paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|track
)paren
suffix:semicolon
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.m
op_assign
id|bcd2bin
(paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.m
)paren
suffix:semicolon
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.s
op_assign
id|bcd2bin
(paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.s
)paren
suffix:semicolon
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.f
op_assign
id|bcd2bin
(paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.f
)paren
suffix:semicolon
)brace
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.lba
op_assign
id|msf_to_lba
(paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.m
comma
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.s
comma
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.f
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif  /* not STANDARD_ATAPI */
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.lba
op_assign
id|ntohl
(paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.lba
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the multisession information. */
id|stat
op_assign
id|cdrom_read_tocentry
(paren
id|drive
comma
l_int|0
comma
id|msf_flag
comma
l_int|1
comma
(paren
r_char
op_star
)paren
op_amp
id|ms_tmp
comma
r_sizeof
(paren
id|ms_tmp
)paren
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|msf_flag
)paren
id|toc-&gt;last_session_lba
op_assign
id|msf_to_lba
(paren
id|ms_tmp.ent.addr.msf.m
comma
id|ms_tmp.ent.addr.msf.s
comma
id|ms_tmp.ent.addr.msf.f
)paren
suffix:semicolon
r_else
macro_line|#endif  /* not STANDARD_ATAPI */
id|toc-&gt;last_session_lba
op_assign
id|ntohl
(paren
id|ms_tmp.ent.addr.lba
)paren
suffix:semicolon
id|toc-&gt;xa_flag
op_assign
(paren
id|ms_tmp.hdr.first_track
op_ne
id|ms_tmp.hdr.last_track
)paren
suffix:semicolon
multiline_comment|/* Now try to get the total cdrom capacity. */
id|stat
op_assign
id|cdrom_read_capacity
(paren
id|drive
comma
op_amp
id|toc-&gt;capacity
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
id|toc-&gt;capacity
op_assign
l_int|0x1fffff
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|gd-&gt;sizes
(braket
id|drive-&gt;select.b.unit
op_lshift
id|PARTN_BITS
)braket
op_assign
id|toc-&gt;capacity
op_star
id|SECTORS_PER_FRAME
suffix:semicolon
id|drive-&gt;part
(braket
l_int|0
)braket
dot
id|nr_sects
op_assign
id|toc-&gt;capacity
op_star
id|SECTORS_PER_FRAME
suffix:semicolon
multiline_comment|/* Remember that we&squot;ve read this stuff. */
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_read_subchannel
id|cdrom_read_subchannel
(paren
id|ide_drive_t
op_star
id|drive
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_READ_SUBCHANNEL
suffix:semicolon
id|pc.c
(braket
l_int|2
)braket
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* request subQ data */
id|pc.c
(braket
l_int|3
)braket
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* Format 1: current position */
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* modeflag: 0 = current, 1 = changeable mask, 2 = default, 3 = saved */
r_static
r_int
DECL|function|cdrom_mode_sense
id|cdrom_mode_sense
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|pageno
comma
r_int
id|modeflag
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE_10
suffix:semicolon
id|pc.c
(braket
l_int|2
)braket
op_assign
id|pageno
op_or
(paren
id|modeflag
op_lshift
l_int|6
)paren
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_mode_select
id|cdrom_mode_select
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|pageno
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
op_minus
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|MODE_SELECT_10
suffix:semicolon
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|0x10
suffix:semicolon
id|pc.c
(braket
l_int|2
)braket
op_assign
id|pageno
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_play_lba_range_play12
id|cdrom_play_lba_range_play12
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lba_start
comma
r_int
id|lba_end
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_PLAYAUDIO12
suffix:semicolon
macro_line|#ifdef __alpha__
id|stq_u
c_func
(paren
(paren
(paren
r_int
)paren
id|htonl
(paren
id|lba_end
op_minus
id|lba_start
)paren
op_lshift
l_int|32
)paren
op_or
id|htonl
c_func
(paren
id|lba_start
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
suffix:semicolon
macro_line|#else
op_star
(paren
r_int
op_star
)paren
(paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
op_assign
id|htonl
(paren
id|lba_start
)paren
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
(paren
op_amp
id|pc.c
(braket
l_int|6
)braket
)paren
op_assign
id|htonl
(paren
id|lba_end
op_minus
id|lba_start
)paren
suffix:semicolon
macro_line|#endif
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
macro_line|#if !  STANDARD_ATAPI
r_static
r_int
DECL|function|cdrom_play_lba_range_msf
id|cdrom_play_lba_range_msf
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lba_start
comma
r_int
id|lba_end
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_PLAYAUDIO_MSF
suffix:semicolon
id|lba_to_msf
(paren
id|lba_start
comma
op_amp
id|pc.c
(braket
l_int|3
)braket
comma
op_amp
id|pc.c
(braket
l_int|4
)braket
comma
op_amp
id|pc.c
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|lba_to_msf
(paren
id|lba_end
op_minus
l_int|1
comma
op_amp
id|pc.c
(braket
l_int|6
)braket
comma
op_amp
id|pc.c
(braket
l_int|7
)braket
comma
op_amp
id|pc.c
(braket
l_int|8
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_uses_bcd
)paren
(brace
id|pc.c
(braket
l_int|3
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|5
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|6
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|8
)braket
)paren
suffix:semicolon
)brace
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
r_static
r_int
DECL|function|cdrom_play_lba_range_1
id|cdrom_play_lba_range_1
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lba_start
comma
r_int
id|lba_end
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
multiline_comment|/* This is rather annoying.&n;     My NEC-260 won&squot;t recognize group 5 commands such as PLAYAUDIO12;&n;     the only way to get it to play more than 64k of blocks at once&n;     seems to be the PLAYAUDIO_MSF command.  However, the parameters&n;     the NEC 260 wants for the PLAYMSF command are incompatible with&n;     the new version of the spec.&n;&n;     So what i&squot;ll try is this.  First try for PLAYAUDIO12.  If it works,&n;     great.  Otherwise, if the drive reports an illegal command code,&n;     try PLAYAUDIO_MSF using the NEC 260-style bcd parameters. */
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_playaudio12
)paren
r_return
id|cdrom_play_lba_range_msf
(paren
id|drive
comma
id|lba_start
comma
id|lba_end
comma
id|reqbuf
)paren
suffix:semicolon
r_else
macro_line|#endif  /* not STANDARD_ATAPI */
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf
op_eq
l_int|NULL
)paren
id|reqbuf
op_assign
op_amp
id|my_reqbuf
suffix:semicolon
id|stat
op_assign
id|cdrom_play_lba_range_play12
(paren
id|drive
comma
id|lba_start
comma
id|lba_end
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
multiline_comment|/* It failed.  Try to find out why. */
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
id|reqbuf-&gt;asc
op_eq
l_int|0x20
)paren
(brace
multiline_comment|/* The drive didn&squot;t recognize the command.&n;             Retry with the MSF variant. */
id|printk
(paren
l_string|&quot;%s: Drive does not support PLAYAUDIO12; &quot;
l_string|&quot;trying PLAYAUDIO_MSF&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_playaudio12
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_uses_bcd
op_assign
l_int|1
suffix:semicolon
r_return
id|cdrom_play_lba_range_msf
(paren
id|drive
comma
id|lba_start
comma
id|lba_end
comma
id|reqbuf
)paren
suffix:semicolon
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
multiline_comment|/* Failed for some other reason.  Give up. */
r_return
id|stat
suffix:semicolon
)brace
)brace
multiline_comment|/* Play audio starting at LBA LBA_START and finishing with the&n;   LBA before LBA_END. */
r_static
r_int
DECL|function|cdrom_play_lba_range
id|cdrom_play_lba_range
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lba_start
comma
r_int
id|lba_end
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_int
id|i
comma
id|stat
suffix:semicolon
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf
op_eq
l_int|NULL
)paren
id|reqbuf
op_assign
op_amp
id|my_reqbuf
suffix:semicolon
multiline_comment|/* Some drives, will, for certain audio cds,&n;     give an error if you ask them to play the entire cd using the&n;     values which are returned in the TOC.  The play will succeed, however,&n;     if the ending address is adjusted downwards by a few frames. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|75
suffix:semicolon
id|i
op_increment
)paren
(brace
id|stat
op_assign
id|cdrom_play_lba_range_1
(paren
id|drive
comma
id|lba_start
comma
id|lba_end
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
op_logical_or
op_logical_neg
(paren
id|reqbuf-&gt;sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
id|reqbuf-&gt;asc
op_eq
l_int|0x24
)paren
)paren
r_return
id|stat
suffix:semicolon
op_decrement
id|lba_end
suffix:semicolon
r_if
c_cond
(paren
id|lba_end
op_le
id|lba_start
)paren
r_break
suffix:semicolon
)brace
r_return
id|stat
suffix:semicolon
)brace
r_static
DECL|function|cdrom_get_toc_entry
r_int
id|cdrom_get_toc_entry
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|track
comma
r_struct
id|atapi_toc_entry
op_star
op_star
id|ent
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_int
id|stat
comma
id|ntracks
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
multiline_comment|/* Make sure our saved TOC is valid. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|drive-&gt;cdrom_info.toc
suffix:semicolon
multiline_comment|/* Check validity of requested track number. */
id|ntracks
op_assign
id|toc-&gt;hdr.last_track
op_minus
id|toc-&gt;hdr.first_track
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|track
op_eq
id|CDROM_LEADOUT
)paren
op_star
id|ent
op_assign
op_amp
id|toc-&gt;ent
(braket
id|ntracks
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|track
template_param
id|toc-&gt;hdr.last_track
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
op_star
id|ent
op_assign
op_amp
id|toc-&gt;ent
(braket
id|track
op_minus
id|toc-&gt;hdr.first_track
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_read_block
id|cdrom_read_block
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|format
comma
r_int
id|lba
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf
op_eq
l_int|NULL
)paren
id|reqbuf
op_assign
op_amp
id|my_reqbuf
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense_data
op_assign
id|reqbuf
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|old_readcd
)paren
id|pc.c
(braket
l_int|0
)braket
op_assign
l_int|0xd4
suffix:semicolon
r_else
macro_line|#endif  /* not STANDARD_ATAPI */
id|pc.c
(braket
l_int|0
)braket
op_assign
id|READ_CD
suffix:semicolon
id|pc.c
(braket
l_int|1
)braket
op_assign
(paren
id|format
op_lshift
l_int|2
)paren
suffix:semicolon
macro_line|#ifdef __alpha__
id|stl_u
c_func
(paren
id|htonl
(paren
id|lba
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
suffix:semicolon
macro_line|#else
op_star
(paren
r_int
op_star
)paren
(paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
op_assign
id|htonl
(paren
id|lba
)paren
suffix:semicolon
macro_line|#endif
id|pc.c
(braket
l_int|8
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* one block */
id|pc.c
(braket
l_int|9
)braket
op_assign
l_int|0x10
suffix:semicolon
id|stat
op_assign
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
multiline_comment|/* If the drive doesn&squot;t recognize the READ CD opcode, retry the command&n;     with an older opcode for that command. */
r_if
c_cond
(paren
id|stat
op_logical_and
id|reqbuf-&gt;sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
id|reqbuf-&gt;asc
op_eq
l_int|0x20
op_logical_and
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|old_readcd
op_eq
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: Drive does not recognize READ_CD; trying opcode 0xd4&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|old_readcd
op_assign
l_int|1
suffix:semicolon
r_return
id|cdrom_read_block
(paren
id|drive
comma
id|format
comma
id|lba
comma
id|buf
comma
id|buflen
comma
id|reqbuf
)paren
suffix:semicolon
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
r_return
id|stat
suffix:semicolon
)brace
DECL|function|ide_cdrom_ioctl
r_int
id|ide_cdrom_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMEJECT
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;usage
OG
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|stat
op_assign
id|cdrom_lockdoor
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
r_return
id|cdrom_eject
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMEJECT_SW
suffix:colon
(brace
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|eject_on_close
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMCLOSETRAY
suffix:colon
(brace
r_if
c_cond
(paren
id|drive-&gt;usage
OG
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_return
id|cdrom_eject
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMPAUSE
suffix:colon
r_return
id|cdrom_pause
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
r_return
id|cdrom_pause
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_case
id|CDROMSTART
suffix:colon
r_return
id|cdrom_startstop
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_startstop
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
multiline_comment|/* pit says the Dolphin needs this. */
r_return
id|cdrom_eject
(paren
id|drive
comma
l_int|1
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMPLAYMSF
suffix:colon
(brace
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_int
id|stat
comma
id|lba_start
comma
id|lba_end
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|msf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|msf
)paren
)paren
suffix:semicolon
id|lba_start
op_assign
id|msf_to_lba
(paren
id|msf.cdmsf_min0
comma
id|msf.cdmsf_sec0
comma
id|msf.cdmsf_frame0
)paren
suffix:semicolon
id|lba_end
op_assign
id|msf_to_lba
(paren
id|msf.cdmsf_min1
comma
id|msf.cdmsf_sec1
comma
id|msf.cdmsf_frame1
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lba_end
op_le
id|lba_start
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|cdrom_play_lba_range
(paren
id|drive
comma
id|lba_start
comma
id|lba_end
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Like just about every other Linux cdrom driver, we ignore the&n;       index part of the request here. */
r_case
id|CDROMPLAYTRKIND
suffix:colon
(brace
r_int
id|stat
comma
id|lba_start
comma
id|lba_end
suffix:semicolon
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_struct
id|atapi_toc_entry
op_star
id|first_toc
comma
op_star
id|last_toc
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|ti
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
(paren
id|drive
comma
id|ti.cdti_trk0
comma
op_amp
id|first_toc
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
(paren
id|drive
comma
id|ti.cdti_trk1
comma
op_amp
id|last_toc
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|ti.cdti_trk1
op_ne
id|CDROM_LEADOUT
)paren
op_increment
id|last_toc
suffix:semicolon
id|lba_start
op_assign
id|first_toc-&gt;addr.lba
suffix:semicolon
id|lba_end
op_assign
id|last_toc-&gt;addr.lba
suffix:semicolon
r_if
c_cond
(paren
id|lba_end
op_le
id|lba_start
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|cdrom_play_lba_range
(paren
id|drive
comma
id|lba_start
comma
id|lba_end
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMREADTOCHDR
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|cdrom_tochdr
id|tochdr
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|tochdr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
multiline_comment|/* Make sure our saved TOC is valid. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|drive-&gt;cdrom_info.toc
suffix:semicolon
id|tochdr.cdth_trk0
op_assign
id|toc-&gt;hdr.first_track
suffix:semicolon
id|tochdr.cdth_trk1
op_assign
id|toc-&gt;hdr.last_track
suffix:semicolon
id|memcpy_tofs
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|tochdr
comma
r_sizeof
(paren
id|tochdr
)paren
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_case
id|CDROMREADTOCENTRY
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|cdrom_tocentry
id|tocentry
suffix:semicolon
r_struct
id|atapi_toc_entry
op_star
id|toce
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|tocentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|tocentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|tocentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|tocentry
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
(paren
id|drive
comma
id|tocentry.cdte_track
comma
op_amp
id|toce
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|tocentry.cdte_ctrl
op_assign
id|toce-&gt;control
suffix:semicolon
id|tocentry.cdte_adr
op_assign
id|toce-&gt;adr
suffix:semicolon
r_if
c_cond
(paren
id|tocentry.cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
multiline_comment|/* convert to MSF */
id|lba_to_msf
(paren
id|toce-&gt;addr.lba
comma
op_amp
id|tocentry.cdte_addr.msf.minute
comma
op_amp
id|tocentry.cdte_addr.msf.second
comma
op_amp
id|tocentry.cdte_addr.msf.frame
)paren
suffix:semicolon
)brace
r_else
id|tocentry.cdte_addr.lba
op_assign
id|toce-&gt;addr.lba
suffix:semicolon
id|memcpy_tofs
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|tocentry
comma
r_sizeof
(paren
id|tocentry
)paren
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_case
id|CDROMSUBCHNL
suffix:colon
(brace
r_struct
id|atapi_cdrom_subchnl
id|scbuf
suffix:semicolon
r_int
id|stat
comma
id|abs_lba
comma
id|rel_lba
suffix:semicolon
r_struct
id|cdrom_subchnl
id|subchnl
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|subchnl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_read_subchannel
(paren
id|drive
comma
(paren
r_char
op_star
)paren
op_amp
id|scbuf
comma
r_sizeof
(paren
id|scbuf
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|vertos_lossage
)paren
(brace
id|abs_lba
op_assign
id|msf_to_lba
(paren
id|bcd2bin
(paren
id|scbuf.acdsc_absaddr.msf.minute
)paren
comma
id|bcd2bin
(paren
id|scbuf.acdsc_absaddr.msf.second
)paren
comma
id|bcd2bin
(paren
id|scbuf.acdsc_absaddr.msf.frame
)paren
)paren
suffix:semicolon
id|rel_lba
op_assign
id|msf_to_lba
(paren
id|bcd2bin
(paren
id|scbuf.acdsc_reladdr.msf.minute
)paren
comma
id|bcd2bin
(paren
id|scbuf.acdsc_reladdr.msf.second
)paren
comma
id|bcd2bin
(paren
id|scbuf.acdsc_reladdr.msf.frame
)paren
)paren
suffix:semicolon
id|scbuf.acdsc_trk
op_assign
id|bcd2bin
(paren
id|scbuf.acdsc_trk
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif /* not STANDARD_ATAPI */
(brace
id|abs_lba
op_assign
id|ntohl
(paren
id|scbuf.acdsc_absaddr.lba
)paren
suffix:semicolon
id|rel_lba
op_assign
id|ntohl
(paren
id|scbuf.acdsc_reladdr.lba
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|subchnl.cdsc_format
op_eq
id|CDROM_MSF
)paren
(brace
id|lba_to_msf
(paren
id|abs_lba
comma
op_amp
id|subchnl.cdsc_absaddr.msf.minute
comma
op_amp
id|subchnl.cdsc_absaddr.msf.second
comma
op_amp
id|subchnl.cdsc_absaddr.msf.frame
)paren
suffix:semicolon
id|lba_to_msf
(paren
id|rel_lba
comma
op_amp
id|subchnl.cdsc_reladdr.msf.minute
comma
op_amp
id|subchnl.cdsc_reladdr.msf.second
comma
op_amp
id|subchnl.cdsc_reladdr.msf.frame
)paren
suffix:semicolon
)brace
r_else
(brace
id|subchnl.cdsc_absaddr.lba
op_assign
id|abs_lba
suffix:semicolon
id|subchnl.cdsc_reladdr.lba
op_assign
id|rel_lba
suffix:semicolon
)brace
id|subchnl.cdsc_audiostatus
op_assign
id|scbuf.acdsc_audiostatus
suffix:semicolon
id|subchnl.cdsc_ctrl
op_assign
id|scbuf.acdsc_ctrl
suffix:semicolon
id|subchnl.cdsc_trk
op_assign
id|scbuf.acdsc_trk
suffix:semicolon
id|subchnl.cdsc_ind
op_assign
id|scbuf.acdsc_ind
suffix:semicolon
id|memcpy_tofs
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|subchnl
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_case
id|CDROMVOLCTRL
suffix:colon
(brace
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
r_char
id|buffer
(braket
l_int|24
)braket
comma
id|mask
(braket
l_int|24
)braket
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|volctrl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_mode_sense
(paren
id|drive
comma
l_int|0x0e
comma
l_int|0
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_mode_sense
(paren
id|drive
comma
l_int|0x0e
comma
l_int|1
comma
id|mask
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|buffer
(braket
l_int|1
)braket
op_assign
id|buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|buffer
(braket
l_int|17
)braket
op_assign
id|volctrl.channel0
op_amp
id|mask
(braket
l_int|17
)braket
suffix:semicolon
id|buffer
(braket
l_int|19
)braket
op_assign
id|volctrl.channel1
op_amp
id|mask
(braket
l_int|19
)braket
suffix:semicolon
id|buffer
(braket
l_int|21
)braket
op_assign
id|volctrl.channel2
op_amp
id|mask
(braket
l_int|21
)braket
suffix:semicolon
id|buffer
(braket
l_int|23
)braket
op_assign
id|volctrl.channel3
op_amp
id|mask
(braket
l_int|23
)braket
suffix:semicolon
r_return
id|cdrom_mode_select
(paren
id|drive
comma
l_int|0x0e
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMVOLREAD
suffix:colon
(brace
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
r_char
id|buffer
(braket
l_int|24
)braket
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_mode_sense
(paren
id|drive
comma
l_int|0x0e
comma
l_int|0
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|volctrl.channel0
op_assign
id|buffer
(braket
l_int|17
)braket
suffix:semicolon
id|volctrl.channel1
op_assign
id|buffer
(braket
l_int|19
)braket
suffix:semicolon
id|volctrl.channel2
op_assign
id|buffer
(braket
l_int|21
)braket
suffix:semicolon
id|volctrl.channel3
op_assign
id|buffer
(braket
l_int|23
)braket
suffix:semicolon
id|memcpy_tofs
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|volctrl
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMMULTISESSION
suffix:colon
(brace
r_struct
id|cdrom_multisession
id|ms_info
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ms_info
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ms_info
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|ms_info
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ms_info
)paren
)paren
suffix:semicolon
multiline_comment|/* Make sure the TOC information is valid. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|drive-&gt;cdrom_info.toc
suffix:semicolon
r_if
c_cond
(paren
id|ms_info.addr_format
op_eq
id|CDROM_MSF
)paren
id|lba_to_msf
(paren
id|toc-&gt;last_session_lba
comma
op_amp
id|ms_info.addr.msf.minute
comma
op_amp
id|ms_info.addr.msf.second
comma
op_amp
id|ms_info.addr.msf.frame
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ms_info.addr_format
op_eq
id|CDROM_LBA
)paren
id|ms_info.addr.lba
op_assign
id|toc-&gt;last_session_lba
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ms_info.xa_flag
op_assign
id|toc-&gt;xa_flag
suffix:semicolon
id|memcpy_tofs
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|ms_info
comma
r_sizeof
(paren
id|ms_info
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read 2352 byte blocks from audio tracks. */
r_case
id|CDROMREADAUDIO
suffix:colon
(brace
r_int
id|stat
comma
id|lba
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
r_struct
id|cdrom_read_audio
id|ra
suffix:semicolon
r_char
id|buf
(braket
id|CD_FRAMESIZE_RAW
)braket
suffix:semicolon
multiline_comment|/* Make sure the TOC is up to date. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|drive-&gt;cdrom_info.toc
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ra
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|ra
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ra
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ra.nframes
template_param
id|toc-&gt;capacity
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ra.nframes
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|ra.buf
comma
id|ra.nframes
op_star
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|ra.addr_format
op_eq
id|CDROM_MSF
)paren
id|lba
op_assign
id|msf_to_lba
(paren
id|ra.addr.msf.minute
comma
id|ra.addr.msf.second
comma
id|ra.addr.msf.frame
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ra.addr_format
op_eq
id|CDROM_LBA
)paren
id|lba
op_assign
id|ra.addr.lba
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|lba
OL
l_int|0
op_logical_or
id|lba
op_ge
id|toc-&gt;capacity
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_while
c_loop
(paren
id|ra.nframes
OG
l_int|0
)paren
(brace
id|stat
op_assign
id|cdrom_read_block
(paren
id|drive
comma
l_int|1
comma
id|lba
comma
id|buf
comma
id|CD_FRAMESIZE_RAW
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_tofs
(paren
id|ra.buf
comma
id|buf
comma
id|CD_FRAMESIZE_RAW
)paren
suffix:semicolon
id|ra.buf
op_add_assign
id|CD_FRAMESIZE_RAW
suffix:semicolon
op_decrement
id|ra.nframes
suffix:semicolon
op_increment
id|lba
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMREADMODE1
suffix:colon
r_case
id|CDROMREADMODE2
suffix:colon
(brace
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_int
id|blocksize
comma
id|format
comma
id|stat
comma
id|lba
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
r_char
id|buf
(braket
id|CD_FRAMESIZE_RAW0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|CDROMREADMODE1
)paren
(brace
id|blocksize
op_assign
id|CD_FRAMESIZE
suffix:semicolon
id|format
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|blocksize
op_assign
id|CD_FRAMESIZE_RAW0
suffix:semicolon
id|format
op_assign
l_int|3
suffix:semicolon
)brace
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|msf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|arg
comma
id|blocksize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|msf
)paren
)paren
suffix:semicolon
id|lba
op_assign
id|msf_to_lba
(paren
id|msf.cdmsf_min0
comma
id|msf.cdmsf_sec0
comma
id|msf.cdmsf_frame0
)paren
suffix:semicolon
multiline_comment|/* Make sure the TOC is up to date. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|drive-&gt;cdrom_info.toc
suffix:semicolon
r_if
c_cond
(paren
id|lba
OL
l_int|0
op_logical_or
id|lba
op_ge
id|toc-&gt;capacity
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|stat
op_assign
id|cdrom_read_block
(paren
id|drive
comma
id|format
comma
id|lba
comma
id|buf
comma
id|blocksize
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_tofs
(paren
(paren
r_char
op_star
)paren
id|arg
comma
id|buf
comma
id|blocksize
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0 /* Doesn&squot;t work reliably yet. */
r_case
id|CDROMRESET
suffix:colon
(brace
r_struct
id|request
id|req
suffix:semicolon
id|ide_init_drive_cmd
(paren
op_amp
id|req
)paren
suffix:semicolon
id|req.cmd
op_assign
id|RESET_DRIVE_COMMAND
suffix:semicolon
r_return
id|ide_do_drive_cmd
(paren
id|drive
comma
op_amp
id|req
comma
id|ide_wait
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef TEST
r_case
l_int|0x1234
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|packet_command
id|pc
suffix:semicolon
r_int
id|len
comma
id|lena
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|pc.c
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
id|arg
op_add_assign
r_sizeof
(paren
id|pc.c
)paren
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|len
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|len
)paren
)paren
suffix:semicolon
id|arg
op_add_assign
r_sizeof
(paren
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
)brace
id|lena
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|lena
OL
l_int|0
)paren
id|lena
op_assign
l_int|0
suffix:semicolon
(brace
r_char
id|buf
(braket
id|lena
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
(brace
id|pc.buflen
op_assign
id|len
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
)brace
id|stat
op_assign
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
l_int|0
)paren
id|memcpy_tofs
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|buf
comma
id|len
)paren
suffix:semicolon
)brace
r_return
id|stat
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Other driver requests (open, close, check media change).&n; */
DECL|function|ide_cdrom_check_media_change
r_int
id|ide_cdrom_check_media_change
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|retval
suffix:semicolon
(paren
r_void
)paren
id|cdrom_check_status
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
id|retval
op_assign
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|0
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|ide_cdrom_open
r_int
id|ide_cdrom_open
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
multiline_comment|/* no write access */
r_if
c_cond
(paren
id|fp-&gt;f_mode
op_amp
l_int|2
)paren
(brace
op_decrement
id|drive-&gt;usage
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
multiline_comment|/* If this is the first open, check the drive status. */
r_if
c_cond
(paren
id|drive-&gt;usage
op_eq
l_int|1
)paren
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|atapi_request_sense
id|my_reqbuf
suffix:semicolon
id|my_reqbuf.sense_key
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get the drive status. */
id|stat
op_assign
id|cdrom_check_status
(paren
id|drive
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
multiline_comment|/* If the tray is open, try to close it. */
r_if
c_cond
(paren
id|stat
op_logical_and
id|my_reqbuf.sense_key
op_eq
id|NOT_READY
)paren
(brace
id|cdrom_eject
(paren
id|drive
comma
l_int|1
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_check_status
(paren
id|drive
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
)brace
multiline_comment|/* Return an error if there are still problems. */
r_if
c_cond
(paren
id|stat
op_logical_and
id|my_reqbuf.sense_key
op_ne
id|UNIT_ATTENTION
)paren
(brace
op_decrement
id|drive-&gt;usage
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* Now lock the door. */
(paren
r_void
)paren
id|cdrom_lockdoor
(paren
id|drive
comma
l_int|1
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
multiline_comment|/* And try to read the TOC information now. */
(paren
r_void
)paren
id|cdrom_read_toc
(paren
id|drive
comma
op_amp
id|my_reqbuf
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close down the device.  Invalidate all cached blocks.&n; */
DECL|function|ide_cdrom_release
r_void
id|ide_cdrom_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;usage
op_eq
l_int|0
)paren
(brace
id|invalidate_buffers
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
multiline_comment|/* Unlock the door. */
(paren
r_void
)paren
id|cdrom_lockdoor
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* Do an eject if we were requested to do so. */
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|eject_on_close
)paren
(paren
r_void
)paren
id|cdrom_eject
(paren
id|drive
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
)brace
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Device initialization.&n; */
DECL|function|ide_cdrom_setup
r_void
id|ide_cdrom_setup
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|blksize_size
(braket
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
)braket
(braket
id|drive-&gt;select.b.unit
op_lshift
id|PARTN_BITS
)braket
op_assign
id|CD_FRAMESIZE
suffix:semicolon
id|drive-&gt;special.all
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;ready_stat
op_assign
l_int|0
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|0
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|0
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Turn this off by default, since many people don&squot;t like it. */
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|eject_on_close
op_assign
l_int|0
suffix:semicolon
macro_line|#if NO_DOOR_LOCKING
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
op_assign
l_int|1
suffix:semicolon
macro_line|#else
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|drive-&gt;id
op_ne
l_int|NULL
)paren
(brace
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
op_assign
(paren
(paren
id|drive-&gt;id-&gt;config
op_amp
l_int|0x0060
)paren
op_eq
l_int|0x20
)paren
suffix:semicolon
)brace
r_else
(brace
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#if ! STANDARD_ATAPI
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_playaudio12
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|old_readcd
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_lba_toc
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_uses_bcd
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|vertos_lossage
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* Accommodate some broken drives... */
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;CD220E&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;CD&quot;
)paren
op_eq
l_int|0
)paren
multiline_comment|/* Creative Labs */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_lba_toc
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;TO-ICSLYAL&quot;
)paren
op_eq
l_int|0
op_logical_or
multiline_comment|/* Acer CD525E */
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;OTI-SCYLLA&quot;
)paren
op_eq
l_int|0
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_lba_toc
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* I don&squot;t know who makes this.&n;       Francesco Messineo &lt;sidera@ccii.unipi.it&gt; says this one&squot;s broken too. */
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;DCI-2S10&quot;
)paren
op_eq
l_int|0
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_lba_toc
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;CDA26803I SE&quot;
)paren
op_eq
l_int|0
)paren
multiline_comment|/* Aztech */
(brace
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_lba_toc
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* This drive _also_ does not implement PLAYAUDIO12 correctly. */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_playaudio12
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Vertos 300. */
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;V003S0DS&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_lba_toc
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Some versions of this drive like to talk BCD. */
r_if
c_cond
(paren
id|drive-&gt;id-&gt;fw_rev
(braket
l_int|4
)braket
op_eq
l_char|&squot;1&squot;
op_logical_and
id|drive-&gt;id-&gt;fw_rev
(braket
l_int|6
)braket
op_le
l_char|&squot;2&squot;
)paren
(brace
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|vertos_lossage
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_uses_bcd
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;0V300SSD&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;V003M0DP&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;0V300MPD&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;0V300HPD&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;V003H0DP&quot;
)paren
op_eq
l_int|0
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_lba_toc
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Vertos 400. */
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;V004E0DT&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;0V400ETD&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;V004H0DT&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;0V400HTD&quot;
)paren
op_eq
l_int|0
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_lba_toc
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;CD-ROM CDU55D&quot;
)paren
op_eq
l_int|0
)paren
multiline_comment|/*sony cdu55d */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_playaudio12
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;CD-ROM CDU55E&quot;
)paren
op_eq
l_int|0
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_playaudio12
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* drive-id != NULL */
macro_line|#endif  /* not STANDARD_ATAPI */
id|drive-&gt;cdrom_info.toc
op_assign
l_int|NULL
suffix:semicolon
id|drive-&gt;cdrom_info.sector_buffer
op_assign
l_int|NULL
suffix:semicolon
id|drive-&gt;cdrom_info.sector_buffered
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;cdrom_info.nsectors_buffered
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * TODO:&n; *  CDROM_GET_UPC&n; *  CDROMRESET&n; *  Lock the door when a read request completes successfully and the&n; *   door is not already locked.  Also try to reorganize to reduce&n; *   duplicated functionality between read and ioctl paths?&n; *  Establish interfaces for an IDE port driver, and break out the cdrom&n; *   code into a loadable module.&n; *  Support changers.&n; *  Write some real documentation.&n; */
eof
