multiline_comment|/*&n; * linux/drivers/block/ide-cd.c  (BETA)&n; *&n; * 1.00  Oct 31, 1994 -- Initial version.&n; * 1.01  Nov  2, 1994 -- Fixed problem with starting request in&n; *                       cdrom_check_status.&n; * 1.03  Nov 25, 1994 -- leaving unmask_intr[] as a user-setting (as for disks)&n; * (from mlord)       -- minor changes to cdrom_setup()&n; *                    -- renamed ide_dev_s to ide_dev_t, enable irq on command&n; * 2.00  Nov 27, 1994 -- Generalize packet command interface;&n; *                       add audio ioctls.&n; * 2.01  Dec  3, 1994 -- Rework packet command interface to handle devices&n; *                       which send an interrupt when ready for a command.&n; * 2.02  Dec 11, 1994 -- Cache the TOC in the driver.&n; *                       Don&squot;t use SCMD_PLAYAUDIO_TI; it&squot;s not included&n; *                       in the current version of ATAPI.&n; *                       Try to use LBA instead of track or MSF addressing&n; *                       when possible.&n; *                       Don&squot;t wait for READY_STAT.&n; * 2.03  Jan 10, 1995 -- Rewrite block read routines to handle block sizes&n; *                       other than 2k and to move multiple sectors in a&n; *                       single transaction.&n; *&n; * ATAPI cd-rom driver.  To be used with ide.c.&n; *&n; * Copyright (C) 1994, 1995  scott snyder  &lt;snyder@fnald0.fnal.gov&gt;&n; */
macro_line|#include &lt;linux/cdrom.h&gt;
DECL|macro|SECTOR_SIZE
mdefine_line|#define SECTOR_SIZE 512
DECL|macro|SECTOR_BITS
mdefine_line|#define SECTOR_BITS 9
DECL|macro|SECTORS_PER_FRAME
mdefine_line|#define SECTORS_PER_FRAME (CD_FRAMESIZE / SECTOR_SIZE)
DECL|macro|MIN
mdefine_line|#define MIN(a,b) ((a) &lt; (b) ? (a) : (b))
DECL|macro|OUT_WORDS
mdefine_line|#define OUT_WORDS(b,n)  outsw (IDE_PORT (HD_DATA, dev-&gt;hwif), (b), (n))
DECL|macro|IN_WORDS
mdefine_line|#define IN_WORDS(b,n)   insw  (IDE_PORT (HD_DATA, dev-&gt;hwif), (b), (n))
multiline_comment|/* special command codes for strategy routine. */
DECL|macro|PACKET_COMMAND
mdefine_line|#define PACKET_COMMAND 4315
DECL|macro|WIN_PACKETCMD
mdefine_line|#define WIN_PACKETCMD 0xa0  /* Send a packet command. */
multiline_comment|/* Some ATAPI command opcodes (just like SCSI).&n;   (Some other cdrom-specific codes are in cdrom.h.) */
DECL|macro|TEST_UNIT_READY
mdefine_line|#define TEST_UNIT_READY         0x00
DECL|macro|REQUEST_SENSE
mdefine_line|#define REQUEST_SENSE           0x03
DECL|macro|START_STOP
mdefine_line|#define START_STOP              0x1b
DECL|macro|ALLOW_MEDIUM_REMOVAL
mdefine_line|#define ALLOW_MEDIUM_REMOVAL    0x1e
DECL|macro|READ_10
mdefine_line|#define READ_10                 0x28
DECL|macro|MODE_SENSE_10
mdefine_line|#define MODE_SENSE_10           0x5a
DECL|macro|MODE_SELECT_10
mdefine_line|#define MODE_SELECT_10          0x55
DECL|struct|packet_command
r_struct
id|packet_command
(brace
DECL|member|buffer
r_char
op_star
id|buffer
suffix:semicolon
DECL|member|buflen
r_int
id|buflen
suffix:semicolon
DECL|member|stat
r_int
id|stat
suffix:semicolon
DECL|member|c
r_int
r_char
id|c
(braket
l_int|12
)braket
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|atapi_request_sense
r_struct
id|atapi_request_sense
(brace
DECL|member|error_code
r_int
r_char
id|error_code
suffix:colon
l_int|7
suffix:semicolon
DECL|member|valid
r_int
r_char
id|valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reserved1
id|byte
id|reserved1
suffix:semicolon
DECL|member|sense_key
r_int
r_char
id|sense_key
suffix:colon
l_int|4
suffix:semicolon
DECL|member|reserved2
r_int
r_char
id|reserved2
suffix:colon
l_int|1
suffix:semicolon
DECL|member|ili
r_int
r_char
id|ili
suffix:colon
l_int|1
suffix:semicolon
DECL|member|reserved3
r_int
r_char
id|reserved3
suffix:colon
l_int|2
suffix:semicolon
DECL|member|info
id|byte
id|info
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|sense_len
id|byte
id|sense_len
suffix:semicolon
DECL|member|command_info
id|byte
id|command_info
(braket
l_int|4
)braket
suffix:semicolon
DECL|member|asc
id|byte
id|asc
suffix:semicolon
DECL|member|ascq
id|byte
id|ascq
suffix:semicolon
DECL|member|fru
id|byte
id|fru
suffix:semicolon
DECL|member|sense_key_specific
id|byte
id|sense_key_specific
(braket
l_int|3
)braket
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* We want some additional flags for cd-rom drives.&n;   To save space in the ide_dev_t struct, use one of the fields which&n;   doesn&squot;t make sense for cd-roms -- `bios_sect&squot;. */
DECL|struct|ide_cd_flags
r_struct
id|ide_cd_flags
(brace
DECL|member|drq_interrupt
r_int
id|drq_interrupt
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Device sends an interrupt when ready&n;                                 for a packet command. */
DECL|member|no_playaudio12
r_int
id|no_playaudio12
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* The PLAYAUDIO12 command is not supported. */
DECL|member|media_changed
r_int
id|media_changed
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Driver has noticed a media change. */
DECL|member|toc_valid
r_int
id|toc_valid
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* Saved TOC information is current. */
DECL|member|reserved
r_int
id|reserved
suffix:colon
l_int|4
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|CDROM_FLAGS
mdefine_line|#define CDROM_FLAGS(dev) ((struct ide_cd_flags *)&amp;((dev)-&gt;bios_sect))
multiline_comment|/* Space to hold the disk TOC. */
DECL|macro|MAX_TRACKS
mdefine_line|#define MAX_TRACKS 99
DECL|struct|atapi_toc_header
r_struct
id|atapi_toc_header
(brace
DECL|member|toc_length
r_int
r_int
id|toc_length
suffix:semicolon
DECL|member|first_track
id|byte
id|first_track
suffix:semicolon
DECL|member|last_track
id|byte
id|last_track
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|atapi_toc_entry
r_struct
id|atapi_toc_entry
(brace
DECL|member|reserved1
id|byte
id|reserved1
suffix:semicolon
DECL|member|control
r_int
id|control
suffix:colon
l_int|4
suffix:semicolon
DECL|member|adr
r_int
id|adr
suffix:colon
l_int|4
suffix:semicolon
DECL|member|track
id|byte
id|track
suffix:semicolon
DECL|member|reserved2
id|byte
id|reserved2
suffix:semicolon
DECL|member|lba
r_int
id|lba
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|atapi_toc
r_struct
id|atapi_toc
(brace
DECL|member|hdr
r_struct
id|atapi_toc_header
id|hdr
suffix:semicolon
DECL|member|ent
r_struct
id|atapi_toc_entry
id|ent
(braket
id|MAX_TRACKS
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* One extra for the leadout. */
)brace
suffix:semicolon
DECL|macro|SECTOR_BUFFER_SIZE
mdefine_line|#define SECTOR_BUFFER_SIZE CD_FRAMESIZE
multiline_comment|/* Extra per-device info for cdrom drives. */
DECL|struct|cdrom_info
r_struct
id|cdrom_info
(brace
multiline_comment|/* Buffer for table of contents.  NULL if we haven&squot;t allocated&n;     a TOC buffer for this device yet. */
DECL|member|toc
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
multiline_comment|/* Sector buffer.  If a read request wants only the first part of a cdrom&n;     block, we cache the rest of the block here, in the expectation that that&n;     data is going to be wanted soon.  SECTOR_BUFFERED is the number of the&n;     first buffered sector, and NSECTORS_BUFFERED is the number of sectors&n;     in the buffer.  Before the buffer is allocated, we should have&n;     SECTOR_BUFFER == NULL and NSECTORS_BUFFERED == 0. */
DECL|member|sector_buffered
r_int
r_int
id|sector_buffered
suffix:semicolon
DECL|member|nsectors_buffered
r_int
r_int
id|nsectors_buffered
suffix:semicolon
DECL|member|sector_buffer
r_char
op_star
id|sector_buffer
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|cdrom_info
r_static
r_struct
id|cdrom_info
id|cdrom_info
(braket
l_int|2
)braket
(braket
id|MAX_DRIVES
)braket
suffix:semicolon
"&f;"
multiline_comment|/****************************************************************************&n; * Generic packet command support routines.&n; */
DECL|function|cdrom_end_request
r_static
r_void
id|cdrom_end_request
(paren
r_int
id|uptodate
comma
id|ide_dev_t
op_star
id|dev
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|ide_cur_rq
(braket
id|dev-&gt;hwif
)braket
suffix:semicolon
multiline_comment|/* The code in blk.h can screw us up on error recovery if the block&n;     size is larger than 1k.  Fix that up here. */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
op_logical_and
id|rq-&gt;bh
op_ne
l_int|0
)paren
(brace
r_int
id|adj
op_assign
id|rq-&gt;current_nr_sectors
op_minus
l_int|1
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_sub_assign
id|adj
suffix:semicolon
id|rq-&gt;sector
op_add_assign
id|adj
suffix:semicolon
)brace
id|end_request
(paren
id|uptodate
comma
id|dev-&gt;hwif
)paren
suffix:semicolon
)brace
multiline_comment|/* Mark that we&squot;ve seen a media change, and invalidate our internal&n;   buffers. */
DECL|function|cdrom_saw_media_change
r_static
r_void
id|cdrom_saw_media_change
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|1
suffix:semicolon
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|0
suffix:semicolon
id|cdrom_info
(braket
id|dev-&gt;hwif
)braket
(braket
id|dev-&gt;select.b.drive
)braket
dot
id|nsectors_buffered
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Returns 0 if the request should be continued.&n;   Returns 1 if the request was ended. */
DECL|function|cdrom_decode_status
r_static
r_int
id|cdrom_decode_status
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
id|good_stat
comma
r_int
op_star
id|stat_ret
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|ide_cur_rq
(braket
id|dev-&gt;hwif
)braket
suffix:semicolon
r_int
id|stat
comma
id|err
suffix:semicolon
multiline_comment|/* Check for errors. */
id|stat
op_assign
id|GET_STAT
(paren
id|dev-&gt;hwif
)paren
suffix:semicolon
op_star
id|stat_ret
op_assign
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
(paren
id|stat
comma
id|good_stat
comma
id|BAD_RW_STAT
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Got an error. */
id|err
op_assign
id|IN_BYTE
(paren
id|HD_ERROR
comma
id|dev-&gt;hwif
)paren
suffix:semicolon
multiline_comment|/* Check for tray open */
r_if
c_cond
(paren
(paren
id|err
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x20
)paren
(brace
r_struct
id|packet_command
op_star
id|pc
suffix:semicolon
id|cdrom_saw_media_change
(paren
id|dev
)paren
suffix:semicolon
multiline_comment|/* Fail the request if this is a read command. */
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|READ
)paren
(brace
id|printk
(paren
l_string|&quot;%s : tray open&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, it&squot;s some other packet command.&n;             Print an error message to the syslog.&n;             Exception: don&squot;t print anything if this is a read subchannel&n;             command.  This is because workman constantly polls the drive&n;             with this command, and we don&squot;t want to uselessly fill up&n;             the syslog. */
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_ne
id|SCMD_READ_SUBCHANNEL
)paren
id|printk
(paren
l_string|&quot;%s : tray open&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Set the error flag and complete the request. */
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|cdrom_end_request
(paren
l_int|1
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Check for media change. */
r_else
r_if
c_cond
(paren
(paren
id|err
op_amp
l_int|0xf0
)paren
op_eq
l_int|0x60
)paren
(brace
id|cdrom_saw_media_change
(paren
id|dev
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: media changed&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* We&squot;re going to retry this command.&n;         But be sure to give up if we&squot;ve retried too many times. */
r_if
c_cond
(paren
(paren
op_increment
id|rq-&gt;errors
OG
id|ERROR_MAX
)paren
)paren
(brace
id|cdrom_end_request
(paren
l_int|0
comma
id|dev
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Don&squot;t attempt to retry if this was a packet command. */
r_else
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|PACKET_COMMAND
)paren
(brace
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|dump_status
(paren
id|dev-&gt;hwif
comma
l_string|&quot;packet command error&quot;
comma
id|stat
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* signal error */
id|cdrom_end_request
(paren
l_int|1
comma
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* If there were other errors, go to the default handler. */
r_else
r_if
c_cond
(paren
(paren
id|err
op_amp
op_complement
id|ABRT_ERR
)paren
op_ne
l_int|0
)paren
(brace
id|ide_error
(paren
id|dev
comma
l_string|&quot;cdrom_decode_status&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* Else, abort if we&squot;ve racked up too many retries. */
r_else
r_if
c_cond
(paren
(paren
op_increment
id|rq-&gt;errors
OG
id|ERROR_MAX
)paren
)paren
(brace
id|cdrom_end_request
(paren
l_int|0
comma
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Retry, or handle the next request. */
id|DO_REQUEST
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Set up the device registers for transferring a packet command on DEV,&n;   expecting to later transfer XFERLEN bytes.  This should be followed&n;   by a call to cdrom_transfer_packet_command; however, if this is a&n;   drq_interrupt device, one must wait for an interrupt first. */
DECL|function|cdrom_start_packet_command
r_static
r_int
id|cdrom_start_packet_command
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
id|xferlen
)paren
(brace
multiline_comment|/* Wait for the controller to be idle. */
r_if
c_cond
(paren
id|wait_stat
(paren
id|dev
comma
l_int|0
comma
id|BUSY_STAT
comma
id|WAIT_READY
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Set up the controller registers. */
id|OUT_BYTE
(paren
l_int|0
comma
id|HD_FEATURE
)paren
suffix:semicolon
id|OUT_BYTE
(paren
l_int|0
comma
id|HD_NSECTOR
)paren
suffix:semicolon
id|OUT_BYTE
(paren
l_int|0
comma
id|HD_SECTOR
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|xferlen
op_amp
l_int|0xff
comma
id|HD_LCYL
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|xferlen
op_rshift
l_int|8
comma
id|HD_HCYL
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|dev-&gt;ctl
comma
id|HD_CMD
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|HD_COMMAND
)paren
suffix:semicolon
multiline_comment|/* packet command */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Send a packet command to DEV described by CMD_BUF and CMD_LEN.&n;   The device registers must have already been prepared&n;   by cdrom_start_packet_command. */
DECL|function|cdrom_transfer_packet_command
r_static
r_int
id|cdrom_transfer_packet_command
(paren
id|ide_dev_t
op_star
id|dev
comma
r_char
op_star
id|cmd_buf
comma
r_int
id|cmd_len
)paren
(brace
r_if
c_cond
(paren
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|drq_interrupt
)paren
(brace
multiline_comment|/* Here we should have been called after receiving an interrupt&n;         from the device.  DRQ should how be set. */
r_int
id|stat_dum
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
id|dev
comma
id|DRQ_STAT
comma
op_amp
id|stat_dum
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, we must wait for DRQ to get set. */
r_if
c_cond
(paren
id|wait_stat
(paren
id|dev
comma
id|DRQ_STAT
comma
id|BAD_STAT
comma
id|WAIT_READY
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Send the command to the device. */
id|OUT_WORDS
(paren
id|cmd_buf
comma
id|cmd_len
op_div
l_int|2
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Block read functions.&n; */
multiline_comment|/*&n; * Buffer up to SECTORS_TO_TRANSFER sectors from the drive in our sector&n; * buffer.  SECTOR is the number of the first sector to be buffered.&n; */
DECL|function|cdrom_buffer_sectors
r_static
r_void
id|cdrom_buffer_sectors
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
r_int
id|sector
comma
r_int
id|sectors_to_transfer
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
op_amp
id|cdrom_info
(braket
id|dev-&gt;hwif
)braket
(braket
id|dev-&gt;select.b.drive
)braket
suffix:semicolon
multiline_comment|/* Number of sectors to read into the buffer. */
r_int
id|sectors_to_buffer
op_assign
id|MIN
(paren
id|sectors_to_transfer
comma
(paren
id|SECTOR_BUFFER_SIZE
op_rshift
id|SECTOR_BITS
)paren
)paren
suffix:semicolon
r_char
op_star
id|dest
suffix:semicolon
multiline_comment|/* If we don&squot;t yet have a sector buffer, try to allocate one.&n;     If we can&squot;t get one atomically, it&squot;s not fatal -- we&squot;ll just throw&n;     the data away rather than caching it. */
r_if
c_cond
(paren
id|info-&gt;sector_buffer
op_eq
l_int|NULL
)paren
(brace
id|info-&gt;sector_buffer
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
(paren
id|SECTOR_BUFFER_SIZE
comma
id|GFP_ATOMIC
)paren
suffix:semicolon
multiline_comment|/* If we couldn&squot;t get a buffer, don&squot;t try to buffer anything... */
r_if
c_cond
(paren
id|info-&gt;sector_buffer
op_eq
l_int|NULL
)paren
id|sectors_to_buffer
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Remember the sector number and the number of sectors we&squot;re storing. */
id|info-&gt;sector_buffered
op_assign
id|sector
suffix:semicolon
id|info-&gt;nsectors_buffered
op_assign
id|sectors_to_buffer
suffix:semicolon
multiline_comment|/* Read the data into the buffer. */
id|dest
op_assign
id|info-&gt;sector_buffer
suffix:semicolon
r_while
c_loop
(paren
id|sectors_to_buffer
OG
l_int|0
)paren
(brace
id|IN_WORDS
(paren
id|dest
comma
id|SECTOR_SIZE
op_div
l_int|2
)paren
suffix:semicolon
op_decrement
id|sectors_to_buffer
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
id|dest
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
)brace
multiline_comment|/* Throw away any remaining data. */
r_while
c_loop
(paren
id|sectors_to_transfer
OG
l_int|0
)paren
(brace
r_char
id|dum
(braket
id|SECTOR_SIZE
)braket
suffix:semicolon
id|IN_WORDS
(paren
id|dest
comma
r_sizeof
(paren
id|dum
)paren
op_div
l_int|2
)paren
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Check the contents of the interrupt reason register from the cdrom&n; * and attempt to recover if there are problems.  Returns  0 if everything&squot;s&n; * ok; nonzero if the request has been terminated.&n; */
r_static
r_inline
DECL|function|cdrom_read_check_ireason
r_int
id|cdrom_read_check_ireason
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
id|len
comma
r_int
id|ireason
)paren
(brace
id|ireason
op_and_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|ireason
op_eq
l_int|2
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ireason
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Whoops... The drive is expecting to receive data from us! */
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: &quot;
l_string|&quot;Drive wants to transfer data the wrong way!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Throw some data at the drive so it doesn&squot;t hang&n;         and quit this request. */
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|OUT_WORDS
(paren
op_amp
id|dum
comma
l_int|1
)paren
suffix:semicolon
id|len
op_sub_assign
l_int|2
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Drive wants a command packet, or invalid ireason... */
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: bad interrupt reason %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ireason
)paren
suffix:semicolon
)brace
id|cdrom_end_request
(paren
l_int|0
comma
id|dev
)paren
suffix:semicolon
id|DO_REQUEST
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Interrupt routine.  Called when a read request has completed.&n; */
DECL|function|cdrom_read_intr
r_static
r_void
id|cdrom_read_intr
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
r_int
id|stat
suffix:semicolon
r_int
id|ireason
comma
id|len
comma
id|sectors_to_transfer
comma
id|nskip
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|ide_cur_rq
(braket
id|dev-&gt;hwif
)braket
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
id|dev
comma
l_int|0
comma
op_amp
id|stat
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Read the interrupt reason and the transfer length. */
id|ireason
op_assign
id|IN_BYTE
(paren
id|HD_NSECTOR
comma
id|dev-&gt;hwif
)paren
suffix:semicolon
id|len
op_assign
id|IN_BYTE
(paren
id|HD_LCYL
comma
id|dev-&gt;hwif
)paren
op_plus
l_int|256
op_star
id|IN_BYTE
(paren
id|HD_HCYL
comma
id|dev-&gt;hwif
)paren
suffix:semicolon
multiline_comment|/* If DRQ is clear, the command has completed. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* If we&squot;re not done filling the current buffer, complain.&n;         Otherwise, complete the command normally. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
OG
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: data underrun (%ld blocks)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|dev
)paren
suffix:semicolon
)brace
r_else
id|cdrom_end_request
(paren
l_int|1
comma
id|dev
)paren
suffix:semicolon
id|DO_REQUEST
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Check that the drive is expecting to do the same thing that we are. */
r_if
c_cond
(paren
id|cdrom_read_check_ireason
(paren
id|dev
comma
id|len
comma
id|ireason
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Assume that the drive will always provide data in multiples of at least&n;     SECTOR_SIZE, as it gets hairy to keep track of the transfers otherwise. */
r_if
c_cond
(paren
(paren
id|len
op_mod
id|SECTOR_SIZE
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: Bad transfer size %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|len
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;  This drive is not supported by this version of the driver&bslash;n&quot;
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|dev
)paren
suffix:semicolon
id|DO_REQUEST
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* The number of sectors we need to read from the drive. */
id|sectors_to_transfer
op_assign
id|len
op_div
id|SECTOR_SIZE
suffix:semicolon
multiline_comment|/* First, figure out if we need to bit-bucket any of the leading sectors. */
id|nskip
op_assign
id|MIN
(paren
(paren
r_int
)paren
(paren
id|rq-&gt;current_nr_sectors
op_minus
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
)paren
comma
id|sectors_to_transfer
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nskip
OG
l_int|0
)paren
(brace
multiline_comment|/* We need to throw away a sector. */
r_char
id|dum
(braket
id|SECTOR_SIZE
)braket
suffix:semicolon
id|IN_WORDS
(paren
id|dum
comma
r_sizeof
(paren
id|dum
)paren
op_div
l_int|2
)paren
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_decrement
id|nskip
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
multiline_comment|/* Now loop while we still have data to read from the drive. */
r_while
c_loop
(paren
id|sectors_to_transfer
OG
l_int|0
)paren
(brace
r_int
id|this_transfer
suffix:semicolon
multiline_comment|/* If we&squot;ve filled the present buffer but there&squot;s another chained&n;         buffer after it, move on. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
op_logical_and
id|rq-&gt;nr_sectors
OG
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* If the buffers are full, cache the rest of the data in our&n;         internal buffer. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
(brace
id|cdrom_buffer_sectors
(paren
id|dev
comma
id|rq-&gt;sector
comma
id|sectors_to_transfer
)paren
suffix:semicolon
id|sectors_to_transfer
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Transfer data to the buffers.&n;             Figure out how many sectors we can transfer&n;             to the current buffer. */
id|this_transfer
op_assign
id|MIN
(paren
id|sectors_to_transfer
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
multiline_comment|/* Read this_transfer sectors into the current buffer. */
r_while
c_loop
(paren
id|this_transfer
OG
l_int|0
)paren
(brace
id|IN_WORDS
(paren
id|rq-&gt;buffer
comma
id|SECTOR_SIZE
op_div
l_int|2
)paren
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
op_decrement
id|rq-&gt;nr_sectors
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_increment
id|rq-&gt;sector
suffix:semicolon
op_decrement
id|this_transfer
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Done moving data!&n;     Wait for another interrupt. */
id|ide_handler
(braket
id|dev-&gt;hwif
)braket
op_assign
id|cdrom_read_intr
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to satisfy some of the current read request from our cached data.&n; * Returns nonzero if the request has been completed, zero otherwise.&n; */
DECL|function|cdrom_read_from_buffer
r_static
r_int
id|cdrom_read_from_buffer
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
op_amp
id|cdrom_info
(braket
id|dev-&gt;hwif
)braket
(braket
id|dev-&gt;select.b.drive
)braket
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|ide_cur_rq
(braket
id|dev-&gt;hwif
)braket
suffix:semicolon
multiline_comment|/* Can&squot;t do anything if there&squot;s no buffer. */
r_if
c_cond
(paren
id|info-&gt;sector_buffer
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Loop while this request needs data and the next block is present&n;     in our cache. */
r_while
c_loop
(paren
id|rq-&gt;nr_sectors
OG
l_int|0
op_logical_and
id|rq-&gt;sector
op_ge
id|info-&gt;sector_buffered
op_logical_and
id|rq-&gt;sector
OL
id|info-&gt;sector_buffered
op_plus
id|info-&gt;nsectors_buffered
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|dev
)paren
suffix:semicolon
id|memcpy
(paren
id|rq-&gt;buffer
comma
id|info-&gt;sector_buffer
op_plus
(paren
id|rq-&gt;sector
op_minus
id|info-&gt;sector_buffered
)paren
op_star
id|SECTOR_SIZE
comma
id|SECTOR_SIZE
)paren
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_decrement
id|rq-&gt;nr_sectors
suffix:semicolon
op_increment
id|rq-&gt;sector
suffix:semicolon
)brace
multiline_comment|/* If we&squot;ve satisfied the current request, terminate it successfully. */
r_if
c_cond
(paren
id|rq-&gt;nr_sectors
op_eq
l_int|0
)paren
(brace
id|cdrom_end_request
(paren
l_int|1
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Move on to the next buffer if needed. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|dev
)paren
suffix:semicolon
multiline_comment|/* If this condition does not hold, then the kluge i use to&n;     represent the number of sectors to skip at the start of a transfer&n;     will fail.  I think that this will never happen, but let&squot;s be&n;     paranoid and check. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
OL
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
op_logical_and
(paren
id|rq-&gt;sector
op_mod
id|SECTORS_PER_FRAME
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_from_buffer: buffer botch (%ld)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rq-&gt;sector
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|dev
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Routine to send a read packet command to the drive.&n; * This is usually called directly from cdrom_start_read.&n; * However, for drq_interrupt devices, it is called from an interrupt&n; * when the drive is ready to accept the command.&n; */
DECL|function|cdrom_start_read_continuation
r_static
r_int
id|cdrom_start_read_continuation
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|ide_cur_rq
(braket
id|dev-&gt;hwif
)braket
suffix:semicolon
r_int
id|nsect
comma
id|sector
comma
id|nframes
comma
id|frame
comma
id|nskip
suffix:semicolon
multiline_comment|/* Number of sectors to transfer. */
id|nsect
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
multiline_comment|/* Starting sector. */
id|sector
op_assign
id|rq-&gt;sector
suffix:semicolon
multiline_comment|/* If the requested sector doesn&squot;t start on a cdrom block boundary,&n;     we must adjust the start of the transfer so that it does,&n;     and remember to skip the first few sectors.  If the CURRENT_NR_SECTORS&n;     field is larger than the size of the buffer, it will mean that&n;     we&squot;re to skip a number of sectors equal to the amount by which&n;     CURRENT_NR_SECTORS is larger than the buffer size. */
id|nskip
op_assign
(paren
id|sector
op_mod
id|SECTORS_PER_FRAME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nskip
OG
l_int|0
)paren
(brace
multiline_comment|/* Sanity check... */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_ne
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_start_read_continuation: buffer botch (%ld)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|dev
)paren
suffix:semicolon
id|DO_REQUEST
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|sector
op_sub_assign
id|nskip
suffix:semicolon
id|nsect
op_add_assign
id|nskip
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_add_assign
id|nskip
suffix:semicolon
)brace
multiline_comment|/* Convert from sectors to cdrom blocks, rounding up the transfer&n;     length if needed. */
id|nframes
op_assign
(paren
id|nsect
op_plus
id|SECTORS_PER_FRAME
op_minus
l_int|1
)paren
op_div
id|SECTORS_PER_FRAME
suffix:semicolon
id|frame
op_assign
id|sector
op_div
id|SECTORS_PER_FRAME
suffix:semicolon
multiline_comment|/* Largest number of frames was can transfer at once is 64k-1. */
id|nframes
op_assign
id|MIN
(paren
id|nframes
comma
l_int|65535
)paren
suffix:semicolon
multiline_comment|/* Set up the command */
id|memset
(paren
op_amp
id|pc.c
comma
l_int|0
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|READ_10
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|nframes
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|nframes
op_amp
l_int|0xff
)paren
suffix:semicolon
multiline_comment|/* Write the sector address into the command image. */
(brace
r_union
(brace
r_struct
(brace
r_int
r_char
id|b0
comma
id|b1
comma
id|b2
comma
id|b3
suffix:semicolon
)brace
id|b
suffix:semicolon
r_struct
(brace
r_int
r_int
id|l0
suffix:semicolon
)brace
id|l
suffix:semicolon
)brace
id|conv
suffix:semicolon
id|conv.l.l0
op_assign
id|frame
suffix:semicolon
id|pc.c
(braket
l_int|2
)braket
op_assign
id|conv.b.b3
suffix:semicolon
id|pc.c
(braket
l_int|3
)braket
op_assign
id|conv.b.b2
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
id|conv.b.b1
suffix:semicolon
id|pc.c
(braket
l_int|5
)braket
op_assign
id|conv.b.b0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cdrom_transfer_packet_command
(paren
id|dev
comma
id|pc.c
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Set up our interrupt handler and return. */
id|ide_handler
(braket
id|dev-&gt;hwif
)braket
op_assign
id|cdrom_read_intr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Start a read request from the CD-ROM.&n; * Returns 0 if the request was started successfully,&n; *  1 if there was an error and we should either retry or move on to the&n; *  next request.&n; */
DECL|function|cdrom_start_read
r_static
r_int
id|cdrom_start_read
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|ide_cur_rq
(braket
id|dev-&gt;hwif
)braket
suffix:semicolon
multiline_comment|/* We may be retrying this request after an error.&n;     Fix up any weirdness which might be present in the request packet. */
r_if
c_cond
(paren
id|rq-&gt;buffer
op_ne
id|rq-&gt;bh-&gt;b_data
)paren
(brace
r_int
id|n
op_assign
(paren
id|rq-&gt;buffer
op_minus
id|rq-&gt;bh-&gt;b_data
)paren
op_div
id|SECTOR_SIZE
suffix:semicolon
id|rq-&gt;buffer
op_assign
id|rq-&gt;bh-&gt;b_data
suffix:semicolon
id|rq-&gt;nr_sectors
op_add_assign
id|n
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_add_assign
id|n
suffix:semicolon
id|rq-&gt;sector
op_sub_assign
id|n
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
OG
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
)paren
id|rq-&gt;current_nr_sectors
op_assign
id|rq-&gt;bh-&gt;b_size
suffix:semicolon
multiline_comment|/* Satisfy whatever we can of this request from our cached sector. */
r_if
c_cond
(paren
id|cdrom_read_from_buffer
(paren
id|dev
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cdrom_start_packet_command
(paren
id|dev
comma
l_int|32768
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|drq_interrupt
)paren
id|ide_handler
(braket
id|dev-&gt;hwif
)braket
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|ide_dev_t
op_star
)paren
)paren
id|cdrom_start_read_continuation
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|cdrom_start_read_continuation
(paren
id|dev
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Execute all other packet commands.&n; */
DECL|function|cdrom_pc_intr
r_static
r_void
id|cdrom_pc_intr
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
r_int
id|ireason
comma
id|len
comma
id|stat
comma
id|thislen
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|ide_cur_rq
(braket
id|dev-&gt;hwif
)braket
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
id|dev
comma
l_int|0
comma
op_amp
id|stat
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Read the interrupt reason and the transfer length. */
id|ireason
op_assign
id|IN_BYTE
(paren
id|HD_NSECTOR
comma
id|dev-&gt;hwif
)paren
suffix:semicolon
id|len
op_assign
id|IN_BYTE
(paren
id|HD_LCYL
comma
id|dev-&gt;hwif
)paren
op_plus
l_int|256
op_star
id|IN_BYTE
(paren
id|HD_HCYL
comma
id|dev-&gt;hwif
)paren
suffix:semicolon
multiline_comment|/* If DRQ is clear, the command has completed.&n;     Complain if we still have data left to transfer. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|pc-&gt;buflen
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|dev
)paren
suffix:semicolon
r_else
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: data underrun %d&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|pc-&gt;buflen
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|cdrom_end_request
(paren
l_int|1
comma
id|dev
)paren
suffix:semicolon
)brace
id|DO_REQUEST
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Figure out how much data to transfer. */
id|thislen
op_assign
id|pc-&gt;buflen
suffix:semicolon
r_if
c_cond
(paren
id|thislen
OL
l_int|0
)paren
id|thislen
op_assign
op_minus
id|thislen
suffix:semicolon
r_if
c_cond
(paren
id|thislen
OG
id|len
)paren
id|thislen
op_assign
id|len
suffix:semicolon
multiline_comment|/* The drive wants to be written to. */
r_if
c_cond
(paren
(paren
id|ireason
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Check that we want to write. */
r_if
c_cond
(paren
id|pc-&gt;buflen
OG
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: Drive wants to transfer data the wrong way!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|thislen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Transfer the data. */
id|OUT_WORDS
(paren
id|pc-&gt;buffer
comma
id|thislen
op_div
l_int|2
)paren
suffix:semicolon
multiline_comment|/* If we haven&squot;t moved enough data to satisfy the drive,&n;         add some padding. */
r_while
c_loop
(paren
id|len
OG
id|thislen
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|OUT_WORDS
(paren
op_amp
id|dum
comma
l_int|1
)paren
suffix:semicolon
id|len
op_sub_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Keep count of how much data we&squot;ve moved. */
id|pc-&gt;buffer
op_add_assign
id|thislen
suffix:semicolon
id|pc-&gt;buflen
op_add_assign
id|thislen
suffix:semicolon
)brace
multiline_comment|/* Same drill for reading. */
r_else
r_if
c_cond
(paren
(paren
id|ireason
op_amp
l_int|3
)paren
op_eq
l_int|2
)paren
(brace
multiline_comment|/* Check that we want to read. */
r_if
c_cond
(paren
id|pc-&gt;buflen
OL
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: Drive wants to transfer data the wrong way!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|thislen
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Transfer the data. */
id|IN_WORDS
(paren
id|pc-&gt;buffer
comma
id|thislen
op_div
l_int|2
)paren
suffix:semicolon
multiline_comment|/* If we haven&squot;t moved enough data to satisfy the drive,&n;         add some padding. */
r_while
c_loop
(paren
id|len
OG
id|thislen
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|IN_WORDS
(paren
op_amp
id|dum
comma
l_int|1
)paren
suffix:semicolon
id|len
op_sub_assign
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Keep count of how much data we&squot;ve moved. */
id|pc-&gt;buffer
op_add_assign
id|thislen
suffix:semicolon
id|pc-&gt;buflen
op_sub_assign
id|thislen
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: The drive appears confused (ireason = 0x%2x)&bslash;n&quot;
comma
id|dev-&gt;name
comma
id|ireason
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now we wait for another interrupt. */
id|ide_handler
(braket
id|dev-&gt;hwif
)braket
op_assign
id|cdrom_pc_intr
suffix:semicolon
)brace
DECL|function|cdrom_do_pc_continuation
r_static
r_int
id|cdrom_do_pc_continuation
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|ide_cur_rq
(braket
id|dev-&gt;hwif
)braket
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
id|cdrom_transfer_packet_command
(paren
id|dev
comma
id|pc-&gt;c
comma
r_sizeof
(paren
id|pc-&gt;c
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Set up our interrupt handler and return. */
id|ide_handler
(braket
id|dev-&gt;hwif
)braket
op_assign
id|cdrom_pc_intr
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cdrom_do_packet_command
r_static
r_int
id|cdrom_do_packet_command
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|ide_cur_rq
(braket
id|dev-&gt;hwif
)braket
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|len
op_assign
id|pc-&gt;buflen
suffix:semicolon
r_if
c_cond
(paren
id|len
OL
l_int|0
)paren
id|len
op_assign
op_minus
id|len
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cdrom_start_packet_command
(paren
id|dev
comma
id|len
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|drq_interrupt
)paren
id|ide_handler
(braket
id|dev-&gt;hwif
)braket
op_assign
(paren
r_void
(paren
op_star
)paren
(paren
id|ide_dev_t
op_star
)paren
)paren
id|cdrom_do_pc_continuation
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|cdrom_do_pc_continuation
(paren
id|dev
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
DECL|function|cdrom_queue_packet_command
r_int
id|cdrom_queue_packet_command
(paren
id|ide_dev_t
op_star
id|dev
comma
r_struct
id|packet_command
op_star
id|pc
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|request
id|req
comma
op_star
op_star
id|p
comma
op_star
op_star
id|pfirst
suffix:semicolon
r_struct
id|semaphore
id|sem
op_assign
id|MUTEX_LOCKED
suffix:semicolon
r_int
id|major
op_assign
id|ide_major
(braket
id|dev-&gt;hwif
)braket
suffix:semicolon
id|req.dev
op_assign
id|MKDEV
(paren
id|major
comma
(paren
id|dev-&gt;select.b.drive
)paren
op_lshift
id|PARTN_BITS
)paren
suffix:semicolon
id|req.cmd
op_assign
id|PACKET_COMMAND
suffix:semicolon
id|req.errors
op_assign
l_int|0
suffix:semicolon
id|req.sector
op_assign
l_int|0
suffix:semicolon
id|req.nr_sectors
op_assign
l_int|0
suffix:semicolon
id|req.current_nr_sectors
op_assign
l_int|0
suffix:semicolon
id|req.buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
id|req.sem
op_assign
op_amp
id|sem
suffix:semicolon
id|req.bh
op_assign
l_int|NULL
suffix:semicolon
id|req.bhtail
op_assign
l_int|NULL
suffix:semicolon
id|req.next
op_assign
l_int|NULL
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
(paren
)paren
suffix:semicolon
id|p
op_assign
op_amp
id|blk_dev
(braket
id|major
)braket
dot
id|current_request
suffix:semicolon
id|pfirst
op_assign
id|p
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|p
)paren
op_ne
l_int|NULL
)paren
(brace
id|p
op_assign
op_amp
(paren
(paren
op_star
id|p
)paren
op_member_access_from_pointer
id|next
)paren
suffix:semicolon
)brace
op_star
id|p
op_assign
op_amp
id|req
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
id|pfirst
)paren
id|blk_dev
(braket
id|major
)braket
dot
id|request_fn
(paren
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|down
(paren
op_amp
id|sem
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pc-&gt;stat
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * cdrom driver request routine.&n; */
DECL|function|do_rw_cdrom
r_static
r_int
id|do_rw_cdrom
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|ide_cur_rq
(braket
id|dev-&gt;hwif
)braket
suffix:semicolon
r_if
c_cond
(paren
id|rq
op_member_access_from_pointer
id|cmd
op_eq
id|PACKET_COMMAND
)paren
r_return
id|cdrom_do_packet_command
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq
op_member_access_from_pointer
id|cmd
op_ne
id|READ
)paren
(brace
id|printk
(paren
l_string|&quot;ide-cd: bad cmd %d&bslash;n&quot;
comma
id|rq
op_member_access_from_pointer
id|cmd
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|dev
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
id|cdrom_start_read
(paren
id|dev
comma
id|block
)paren
suffix:semicolon
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * ioctl handling.&n; */
r_static
r_inline
DECL|function|byte_swap_word
r_void
id|byte_swap_word
(paren
r_int
r_int
op_star
id|x
)paren
(brace
r_char
op_star
id|c
op_assign
(paren
r_char
op_star
)paren
id|x
suffix:semicolon
r_char
id|d
op_assign
id|c
(braket
l_int|0
)braket
suffix:semicolon
id|c
(braket
l_int|0
)braket
op_assign
id|c
(braket
l_int|1
)braket
suffix:semicolon
id|c
(braket
l_int|1
)braket
op_assign
id|d
suffix:semicolon
)brace
r_static
r_inline
DECL|function|byte_swap_long
r_void
id|byte_swap_long
(paren
r_int
op_star
id|x
)paren
(brace
r_char
op_star
id|c
op_assign
(paren
r_char
op_star
)paren
id|x
suffix:semicolon
r_char
id|d
op_assign
id|c
(braket
l_int|0
)braket
suffix:semicolon
id|c
(braket
l_int|0
)braket
op_assign
id|c
(braket
l_int|3
)braket
suffix:semicolon
id|c
(braket
l_int|3
)braket
op_assign
id|d
suffix:semicolon
id|d
op_assign
id|c
(braket
l_int|1
)braket
suffix:semicolon
id|c
(braket
l_int|1
)braket
op_assign
id|c
(braket
l_int|2
)braket
suffix:semicolon
id|c
(braket
l_int|2
)braket
op_assign
id|d
suffix:semicolon
)brace
r_static
DECL|function|bin2bcd
r_int
id|bin2bcd
(paren
r_int
id|x
)paren
(brace
r_return
(paren
id|x
op_mod
l_int|10
)paren
op_or
(paren
(paren
id|x
op_div
l_int|10
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
)brace
r_static
r_inline
DECL|function|lba_to_msf
r_void
id|lba_to_msf
(paren
r_int
id|lba
comma
id|byte
op_star
id|m
comma
id|byte
op_star
id|s
comma
id|byte
op_star
id|f
)paren
(brace
id|lba
op_add_assign
id|CD_BLOCK_OFFSET
suffix:semicolon
id|lba
op_and_assign
l_int|0xffffff
suffix:semicolon
multiline_comment|/* negative lbas use only 24 bits */
op_star
id|m
op_assign
id|lba
op_div
(paren
id|CD_SECS
op_star
id|CD_FRAMES
)paren
suffix:semicolon
id|lba
op_mod_assign
(paren
id|CD_SECS
op_star
id|CD_FRAMES
)paren
suffix:semicolon
op_star
id|s
op_assign
id|lba
op_div
id|CD_FRAMES
suffix:semicolon
op_star
id|f
op_assign
id|lba
op_mod
id|CD_FRAMES
suffix:semicolon
)brace
r_static
r_inline
DECL|function|msf_to_lba
r_int
id|msf_to_lba
(paren
id|byte
id|m
comma
id|byte
id|s
comma
id|byte
id|f
)paren
(brace
r_return
(paren
(paren
(paren
id|m
op_star
id|CD_SECS
)paren
op_plus
id|s
)paren
op_star
id|CD_FRAMES
op_plus
id|f
)paren
op_minus
id|CD_BLOCK_OFFSET
suffix:semicolon
)brace
r_static
r_void
DECL|function|cdrom_check_status
id|cdrom_check_status
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|TEST_UNIT_READY
suffix:semicolon
(paren
r_void
)paren
id|cdrom_queue_packet_command
(paren
id|dev
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_request_sense
id|cdrom_request_sense
(paren
id|ide_dev_t
op_star
id|dev
comma
r_struct
id|atapi_request_sense
op_star
id|reqbuf
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|REQUEST_SENSE
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
r_sizeof
(paren
op_star
id|reqbuf
)paren
suffix:semicolon
id|pc.buffer
op_assign
(paren
r_char
op_star
)paren
id|reqbuf
suffix:semicolon
id|pc.buflen
op_assign
r_sizeof
(paren
op_star
id|reqbuf
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|dev
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
macro_line|#if 0
multiline_comment|/* Lock the door if LOCKFLAG is nonzero; unlock it otherwise. */
r_static
r_int
id|cdrom_lockdoor
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
id|lockflag
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|ALLOW_MEDIUM_REMOVAL
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
(paren
id|lockflag
op_ne
l_int|0
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|dev
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Eject the disk if EJECTFLAG is 0.&n;   If EJECTFLAG is 1, try to reload the disk. */
r_static
r_int
DECL|function|cdrom_eject
id|cdrom_eject
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
id|ejectflag
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|START_STOP
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
l_int|2
op_plus
(paren
id|ejectflag
op_ne
l_int|0
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|dev
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_pause
id|cdrom_pause
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
id|pauseflag
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_PAUSE_RESUME
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
op_logical_neg
id|pauseflag
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|dev
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_startstop
id|cdrom_startstop
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
id|startflag
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|START_STOP
suffix:semicolon
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|1
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
id|startflag
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|dev
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_read_tocentry
id|cdrom_read_tocentry
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
id|trackno
comma
r_int
id|msf_flag
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_READ_TOC
suffix:semicolon
id|pc.c
(braket
l_int|6
)braket
op_assign
id|trackno
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msf_flag
)paren
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|dev
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* Try to read the entire TOC for the disk into our internal buffer. */
r_static
r_int
DECL|function|cdrom_read_toc
id|cdrom_read_toc
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
r_int
id|stat
comma
id|ntracks
comma
id|i
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
op_assign
id|cdrom_info
(braket
id|dev-&gt;hwif
)braket
(braket
id|dev-&gt;select.b.drive
)braket
dot
id|toc
suffix:semicolon
r_if
c_cond
(paren
id|toc
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Try to allocate space. */
id|toc
op_assign
(paren
r_struct
id|atapi_toc
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|atapi_toc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|cdrom_info
(braket
id|dev-&gt;hwif
)braket
(braket
id|dev-&gt;select.b.drive
)braket
dot
id|toc
op_assign
id|toc
suffix:semicolon
)brace
r_if
c_cond
(paren
id|toc
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: No cdrom TOC buffer!&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Check to see if the existing data is still valid.&n;     If it is, just return. */
r_if
c_cond
(paren
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|toc_valid
)paren
id|cdrom_check_status
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|toc_valid
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* First read just the header, so we know how long the TOC is. */
id|stat
op_assign
id|cdrom_read_tocentry
(paren
id|dev
comma
l_int|0
comma
l_int|0
comma
(paren
r_char
op_star
)paren
id|toc
comma
r_sizeof
(paren
r_struct
id|atapi_toc_header
)paren
op_plus
r_sizeof
(paren
r_struct
id|atapi_toc_entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|ntracks
op_assign
id|toc-&gt;hdr.last_track
op_minus
id|toc-&gt;hdr.first_track
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ntracks
op_le
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|ntracks
OG
id|MAX_TRACKS
)paren
id|ntracks
op_assign
id|MAX_TRACKS
suffix:semicolon
multiline_comment|/* Now read the whole schmeer. */
id|stat
op_assign
id|cdrom_read_tocentry
(paren
id|dev
comma
l_int|0
comma
l_int|0
comma
(paren
r_char
op_star
)paren
id|toc
comma
r_sizeof
(paren
r_struct
id|atapi_toc_header
)paren
op_plus
(paren
id|ntracks
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|atapi_toc_entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|byte_swap_word
(paren
op_amp
id|toc-&gt;hdr.toc_length
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|ntracks
suffix:semicolon
id|i
op_increment
)paren
id|byte_swap_long
(paren
op_amp
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|lba
)paren
suffix:semicolon
multiline_comment|/* Remember that we&squot;ve read this stuff. */
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_read_subchannel
id|cdrom_read_subchannel
(paren
id|ide_dev_t
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_READ_SUBCHANNEL
suffix:semicolon
id|pc.c
(braket
l_int|2
)braket
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* request subQ data */
id|pc.c
(braket
l_int|3
)braket
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* Format 1: current position */
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|dev
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* modeflag: 0 = current, 1 = changeable mask, 2 = default, 3 = saved */
r_static
r_int
DECL|function|cdrom_mode_sense
id|cdrom_mode_sense
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
id|pageno
comma
r_int
id|modeflag
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|MODE_SENSE_10
suffix:semicolon
id|pc.c
(braket
l_int|2
)braket
op_assign
id|pageno
op_or
(paren
id|modeflag
op_lshift
l_int|6
)paren
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|dev
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_mode_select
id|cdrom_mode_select
(paren
id|ide_dev_t
op_star
id|dev
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
op_minus
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|MODE_SELECT_10
suffix:semicolon
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|0x10
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|dev
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_play_lba_range_play12
id|cdrom_play_lba_range_play12
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
id|lba_start
comma
r_int
id|lba_end
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_PLAYAUDIO12
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
(paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
op_assign
id|lba_start
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
(paren
op_amp
id|pc.c
(braket
l_int|6
)braket
)paren
op_assign
id|lba_end
op_minus
id|lba_start
suffix:semicolon
id|byte_swap_long
(paren
(paren
r_int
op_star
)paren
(paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
)paren
suffix:semicolon
id|byte_swap_long
(paren
(paren
r_int
op_star
)paren
(paren
op_amp
id|pc.c
(braket
l_int|6
)braket
)paren
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|dev
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_play_lba_range_msf
id|cdrom_play_lba_range_msf
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
id|lba_start
comma
r_int
id|lba_end
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|SCMD_PLAYAUDIO_MSF
suffix:semicolon
id|lba_to_msf
(paren
id|lba_start
comma
op_amp
id|pc.c
(braket
l_int|3
)braket
comma
op_amp
id|pc.c
(braket
l_int|4
)braket
comma
op_amp
id|pc.c
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|lba_to_msf
(paren
id|lba_end
op_minus
l_int|1
comma
op_amp
id|pc.c
(braket
l_int|6
)braket
comma
op_amp
id|pc.c
(braket
l_int|7
)braket
comma
op_amp
id|pc.c
(braket
l_int|8
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|3
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|3
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|4
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|5
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|6
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|7
)braket
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
id|bin2bcd
(paren
id|pc.c
(braket
l_int|8
)braket
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|dev
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* Play audio starting at LBA LBA_START and finishing with the&n;   LBA before LBA_END. */
r_static
r_int
DECL|function|cdrom_play_lba_range
id|cdrom_play_lba_range
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
id|lba_start
comma
r_int
id|lba_end
)paren
(brace
multiline_comment|/* This is rather annoying.&n;     My NEC-260 won&squot;t recognize group 5 commands such as PLAYAUDIO12;&n;     the only way to get it to play more than 64k of blocks at once&n;     seems to be the PLAYAUDIO_MSF command.  However, the parameters&n;     the NEC 260 wants for the PLAYMSF command are incompatible with&n;     the new version of the spec.&n;&n;     So what i&squot;ll try is this.  First try for PLAYAUDIO12.  If it works,&n;     great.  Otherwise, if the drive reports an illegal command code,&n;     try PLAYAUDIO_MSF using the NEC 260-style bcd parameters. */
r_if
c_cond
(paren
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|no_playaudio12
)paren
r_return
id|cdrom_play_lba_range_msf
(paren
id|dev
comma
id|lba_start
comma
id|lba_end
)paren
suffix:semicolon
r_else
(brace
r_int
id|stat
comma
id|stat2
suffix:semicolon
r_struct
id|atapi_request_sense
id|reqbuf
suffix:semicolon
id|stat
op_assign
id|cdrom_play_lba_range_play12
(paren
id|dev
comma
id|lba_start
comma
id|lba_end
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* It failed.  Try to find out why. */
id|stat2
op_assign
id|cdrom_request_sense
(paren
id|dev
comma
op_amp
id|reqbuf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat2
)paren
r_return
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf.sense_key
op_eq
l_int|0x05
op_logical_and
id|reqbuf.asc
op_eq
l_int|0x20
)paren
(brace
multiline_comment|/* The drive didn&squot;t recognize the command.&n;             Retry with the MSF variant. */
id|printk
(paren
l_string|&quot;%s: Drive does not support PLAYAUDIO12; &quot;
l_string|&quot;trying PLAYAUDIO_MSF&bslash;n&quot;
comma
id|dev-&gt;name
)paren
suffix:semicolon
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|no_playaudio12
op_assign
l_int|1
suffix:semicolon
r_return
id|cdrom_play_lba_range_msf
(paren
id|dev
comma
id|lba_start
comma
id|lba_end
)paren
suffix:semicolon
)brace
multiline_comment|/* Failed for some other reason.  Give up. */
r_return
id|stat
suffix:semicolon
)brace
)brace
r_static
DECL|function|cdrom_get_toc_entry
r_int
id|cdrom_get_toc_entry
(paren
id|ide_dev_t
op_star
id|dev
comma
r_int
id|track
comma
r_struct
id|atapi_toc_entry
op_star
op_star
id|ent
)paren
(brace
r_int
id|stat
comma
id|ntracks
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
multiline_comment|/* Make sure our saved TOC is valid. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|cdrom_info
(braket
id|dev-&gt;hwif
)braket
(braket
id|dev-&gt;select.b.drive
)braket
dot
id|toc
suffix:semicolon
multiline_comment|/* Check validity of requested track number. */
id|ntracks
op_assign
id|toc-&gt;hdr.last_track
op_minus
id|toc-&gt;hdr.first_track
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|track
op_eq
id|CDROM_LEADOUT
)paren
op_star
id|ent
op_assign
op_amp
id|toc-&gt;ent
(braket
id|ntracks
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|track
template_param
id|toc-&gt;hdr.last_track
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
op_star
id|ent
op_assign
op_amp
id|toc-&gt;ent
(braket
id|track
op_minus
id|toc-&gt;hdr.first_track
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ide_cdrom_ioctl
r_static
r_int
id|ide_cdrom_ioctl
(paren
id|ide_dev_t
op_star
id|dev
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMEJECT
suffix:colon
r_return
id|cdrom_eject
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_case
id|CDROMPAUSE
suffix:colon
r_return
id|cdrom_pause
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
r_return
id|cdrom_pause
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_case
id|CDROMSTART
suffix:colon
r_return
id|cdrom_startstop
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
r_return
id|cdrom_startstop
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
r_case
id|CDROMPLAYMSF
suffix:colon
(brace
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_int
id|stat
comma
id|lba_start
comma
id|lba_end
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|msf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|msf
)paren
)paren
suffix:semicolon
id|lba_start
op_assign
id|msf_to_lba
(paren
id|msf.cdmsf_min0
comma
id|msf.cdmsf_sec0
comma
id|msf.cdmsf_frame0
)paren
suffix:semicolon
id|lba_end
op_assign
id|msf_to_lba
(paren
id|msf.cdmsf_min1
comma
id|msf.cdmsf_sec1
comma
id|msf.cdmsf_frame1
)paren
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|lba_end
op_le
id|lba_start
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|cdrom_play_lba_range
(paren
id|dev
comma
id|lba_start
comma
id|lba_end
)paren
suffix:semicolon
)brace
multiline_comment|/* Like just about every other Linux cdrom driver, we ignore the&n;       index part of the request here. */
r_case
id|CDROMPLAYTRKIND
suffix:colon
(brace
r_int
id|stat
comma
id|lba_start
comma
id|lba_end
suffix:semicolon
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_struct
id|atapi_toc_entry
op_star
id|first_toc
comma
op_star
id|last_toc
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|ti
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
(paren
id|dev
comma
id|ti.cdti_trk0
comma
op_amp
id|first_toc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
(paren
id|dev
comma
id|ti.cdti_trk1
comma
op_amp
id|last_toc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|ti.cdti_trk1
op_ne
id|CDROM_LEADOUT
)paren
op_increment
id|last_toc
suffix:semicolon
id|lba_start
op_assign
id|first_toc-&gt;lba
suffix:semicolon
id|lba_end
op_assign
id|last_toc-&gt;lba
suffix:semicolon
r_if
c_cond
(paren
id|lba_end
op_le
id|lba_start
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|cdrom_play_lba_range
(paren
id|dev
comma
id|lba_start
comma
id|lba_end
)paren
suffix:semicolon
)brace
r_case
id|CDROMREADTOCHDR
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|cdrom_tochdr
id|tochdr
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|tochdr
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
multiline_comment|/* Make sure our saved TOC is valid. */
id|stat
op_assign
id|cdrom_read_toc
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|cdrom_info
(braket
id|dev-&gt;hwif
)braket
(braket
id|dev-&gt;select.b.drive
)braket
dot
id|toc
suffix:semicolon
id|tochdr.cdth_trk0
op_assign
id|toc-&gt;hdr.first_track
suffix:semicolon
id|tochdr.cdth_trk1
op_assign
id|toc-&gt;hdr.last_track
suffix:semicolon
id|memcpy_tofs
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|tochdr
comma
r_sizeof
(paren
id|tochdr
)paren
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_case
id|CDROMREADTOCENTRY
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|cdrom_tocentry
id|tocentry
suffix:semicolon
r_struct
id|atapi_toc_entry
op_star
id|toce
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|tocentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|tocentry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|tocentry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|tocentry
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
(paren
id|dev
comma
id|tocentry.cdte_track
comma
op_amp
id|toce
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|tocentry.cdte_ctrl
op_assign
id|toce-&gt;control
suffix:semicolon
id|tocentry.cdte_adr
op_assign
id|toce-&gt;adr
suffix:semicolon
r_if
c_cond
(paren
id|tocentry.cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
multiline_comment|/* convert to MSF */
id|lba_to_msf
(paren
id|toce-&gt;lba
comma
op_amp
id|tocentry.cdte_addr.msf.minute
comma
op_amp
id|tocentry.cdte_addr.msf.second
comma
op_amp
id|tocentry.cdte_addr.msf.frame
)paren
suffix:semicolon
)brace
r_else
id|tocentry.cdte_addr.lba
op_assign
id|toce-&gt;lba
suffix:semicolon
id|memcpy_tofs
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|tocentry
comma
r_sizeof
(paren
id|tocentry
)paren
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_case
id|CDROMSUBCHNL
suffix:colon
(brace
r_char
id|buffer
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|stat
comma
id|abs_lba
comma
id|rel_lba
suffix:semicolon
r_struct
id|cdrom_subchnl
id|subchnl
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|subchnl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_read_subchannel
(paren
id|dev
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|abs_lba
op_assign
op_star
(paren
r_int
op_star
)paren
op_amp
id|buffer
(braket
l_int|8
)braket
suffix:semicolon
id|rel_lba
op_assign
op_star
(paren
r_int
op_star
)paren
op_amp
id|buffer
(braket
l_int|12
)braket
suffix:semicolon
id|byte_swap_long
(paren
op_amp
id|abs_lba
)paren
suffix:semicolon
id|byte_swap_long
(paren
op_amp
id|rel_lba
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subchnl.cdsc_format
op_eq
id|CDROM_MSF
)paren
(brace
id|lba_to_msf
(paren
id|abs_lba
comma
op_amp
id|subchnl.cdsc_absaddr.msf.minute
comma
op_amp
id|subchnl.cdsc_absaddr.msf.second
comma
op_amp
id|subchnl.cdsc_absaddr.msf.frame
)paren
suffix:semicolon
id|lba_to_msf
(paren
id|rel_lba
comma
op_amp
id|subchnl.cdsc_reladdr.msf.minute
comma
op_amp
id|subchnl.cdsc_reladdr.msf.second
comma
op_amp
id|subchnl.cdsc_reladdr.msf.frame
)paren
suffix:semicolon
)brace
r_else
(brace
id|subchnl.cdsc_absaddr.lba
op_assign
id|abs_lba
suffix:semicolon
id|subchnl.cdsc_reladdr.lba
op_assign
id|rel_lba
suffix:semicolon
)brace
id|subchnl.cdsc_audiostatus
op_assign
id|buffer
(braket
l_int|1
)braket
suffix:semicolon
id|subchnl.cdsc_ctrl
op_assign
id|buffer
(braket
l_int|5
)braket
op_amp
l_int|0xf
suffix:semicolon
id|subchnl.cdsc_trk
op_assign
id|buffer
(braket
l_int|6
)braket
suffix:semicolon
id|subchnl.cdsc_ind
op_assign
id|buffer
(braket
l_int|7
)braket
suffix:semicolon
id|memcpy_tofs
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|subchnl
comma
r_sizeof
(paren
id|subchnl
)paren
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_case
id|CDROMVOLCTRL
suffix:colon
(brace
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
r_char
id|buffer
(braket
l_int|24
)braket
comma
id|mask
(braket
l_int|24
)braket
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|volctrl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_mode_sense
(paren
id|dev
comma
l_int|0x0e
comma
l_int|0
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_mode_sense
(paren
id|dev
comma
l_int|0x0e
comma
l_int|1
comma
id|mask
comma
r_sizeof
(paren
id|buffer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|buffer
(braket
l_int|1
)braket
op_assign
id|buffer
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|buffer
(braket
l_int|17
)braket
op_assign
id|volctrl.channel0
op_amp
id|mask
(braket
l_int|17
)braket
suffix:semicolon
id|buffer
(braket
l_int|19
)braket
op_assign
id|volctrl.channel1
op_amp
id|mask
(braket
l_int|19
)braket
suffix:semicolon
id|buffer
(braket
l_int|21
)braket
op_assign
id|volctrl.channel2
op_amp
id|mask
(braket
l_int|21
)braket
suffix:semicolon
id|buffer
(braket
l_int|23
)braket
op_assign
id|volctrl.channel3
op_amp
id|mask
(braket
l_int|23
)braket
suffix:semicolon
r_return
id|cdrom_mode_select
(paren
id|dev
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef TEST
r_case
l_int|0x1234
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|memcpy_fromfs
(paren
op_amp
id|pc.c
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|dev
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_case
l_int|0x1235
suffix:colon
(brace
r_int
id|stat
suffix:semicolon
r_struct
id|atapi_request_sense
id|reqbuf
suffix:semicolon
id|stat
op_assign
id|verify_area
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|reqbuf
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_request_sense
(paren
id|dev
comma
op_amp
id|reqbuf
)paren
suffix:semicolon
id|memcpy_tofs
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|reqbuf
comma
r_sizeof
(paren
id|reqbuf
)paren
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EPERM
suffix:semicolon
)brace
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Other driver requests (open, close, check media change).&n; */
DECL|function|cdrom_check_media_change
r_static
r_int
id|cdrom_check_media_change
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
r_int
id|retval
suffix:semicolon
id|cdrom_check_status
(paren
id|dev
)paren
suffix:semicolon
id|retval
op_assign
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|media_changed
suffix:semicolon
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|0
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_static
r_int
DECL|function|cdrom_open
id|cdrom_open
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
id|ide_dev_t
op_star
id|dev
)paren
(brace
multiline_comment|/* no write access */
r_if
c_cond
(paren
id|fp-&gt;f_mode
op_amp
l_int|2
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
macro_line|#if 0 /* With this, one cannot eject a disk with workman */
multiline_comment|/* If this is the first open, lock the door. */
r_if
c_cond
(paren
id|dev-&gt;usage
op_eq
l_int|1
)paren
(paren
r_void
)paren
id|cdrom_lockdoor
(paren
id|dev
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Should check that there&squot;s a disk in the drive? */
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close down the device.  Invalidate all cached blocks.&n; */
r_static
r_void
DECL|function|cdrom_release
id|cdrom_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|ide_dev_t
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;usage
op_eq
l_int|0
)paren
(brace
id|invalidate_buffers
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Unlock the door. */
(paren
r_void
)paren
id|cdrom_lockdoor
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
"&f;"
multiline_comment|/****************************************************************************&n; * Device initialization.&n; */
DECL|function|cdrom_setup
r_static
r_void
id|cdrom_setup
(paren
id|ide_dev_t
op_star
id|dev
)paren
(brace
multiline_comment|/* Just guess at capacity for now. */
id|ide_capacity
(braket
id|dev-&gt;hwif
)braket
(braket
id|dev-&gt;select.b.drive
)braket
op_assign
l_int|0x1fffff
suffix:semicolon
id|ide_blksizes
(braket
id|dev-&gt;hwif
)braket
(braket
id|dev-&gt;select.b.drive
op_lshift
id|PARTN_BITS
)braket
op_assign
id|CD_FRAMESIZE
suffix:semicolon
id|dev-&gt;special.all
op_assign
l_int|0
suffix:semicolon
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|0
suffix:semicolon
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|0
suffix:semicolon
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|no_playaudio12
op_assign
l_int|0
suffix:semicolon
id|CDROM_FLAGS
(paren
id|dev
)paren
op_member_access_from_pointer
id|drq_interrupt
op_assign
(paren
(paren
id|dev-&gt;id-&gt;config
op_amp
l_int|0x0060
)paren
op_eq
l_int|0x20
)paren
suffix:semicolon
id|cdrom_info
(braket
id|dev-&gt;hwif
)braket
(braket
id|dev-&gt;select.b.drive
)braket
dot
id|toc
op_assign
l_int|NULL
suffix:semicolon
id|cdrom_info
(braket
id|dev-&gt;hwif
)braket
(braket
id|dev-&gt;select.b.drive
)braket
dot
id|sector_buffer
op_assign
l_int|NULL
suffix:semicolon
id|cdrom_info
(braket
id|dev-&gt;hwif
)braket
(braket
id|dev-&gt;select.b.drive
)braket
dot
id|sector_buffered
op_assign
l_int|0
suffix:semicolon
id|cdrom_info
(braket
id|dev-&gt;hwif
)braket
(braket
id|dev-&gt;select.b.drive
)braket
dot
id|nsectors_buffered
op_assign
l_int|0
suffix:semicolon
)brace
DECL|macro|MIN
macro_line|#undef MIN
DECL|macro|SECTOR_SIZE
macro_line|#undef SECTOR_SIZE
DECL|macro|SECTOR_BITS
macro_line|#undef SECTOR_BITS
multiline_comment|/*&n; * TODO:&n; *  Retrieve and interpret extended ATAPI error codes.&n; *  Read actual disk capacity.&n; *  Multisession support.&n; *  Direct reading of audio data.&n; *  Eject-on-dismount.&n; *  Lock door while there&squot;s a mounted volume.&n; */
eof
