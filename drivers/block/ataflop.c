multiline_comment|/*&n; *  drivers/block/ataflop.c&n; *&n; *  Copyright (C) 1993  Greg Harp&n; *  Atari Support by Bjoern Brauel, Roman Hodek&n; *&n; *  Big cleanup Sep 11..14 1994 Roman Hodek:&n; *   - Driver now works interrupt driven&n; *   - Support for two drives; should work, but I cannot test that :-(&n; *   - Reading is done in whole tracks and buffered to speed up things&n; *   - Disk change detection and drive deselecting after motor-off&n; *     similar to TOS&n; *   - Autodetection of disk format (DD/HD); untested yet, because I&n; *     don&squot;t have an HD drive :-(&n; *&n; *  Fixes Nov 13 1994 Martin Schaller:&n; *   - Autodetection works now&n; *   - Support for 5 1/4&squot;&squot; disks&n; *   - Removed drive type (unknown on atari)&n; *   - Do seeks with 8 Mhz&n; *&n; *  Changes by Andreas Schwab:&n; *   - After errors in multiple read mode try again reading single sectors&n; *  (Feb 1995):&n; *   - Clean up error handling&n; *   - Set blk_size for proper size checking&n; *   - Initialize track register when testing presence of floppy&n; *   - Implement some ioctl&squot;s&n; *&n; *  Changes by Torsten Lang:&n; *   - When probing the floppies we should add the FDCCMDADD_H flag since&n; *     the FDC will otherwise wait forever when no disk is inserted...&n; *&n; * ++ Freddi Aschwanden (fa) 20.9.95 fixes for medusa:&n; *  - MFPDELAY() after each FDC access -&gt; atari &n; *  - more/other disk formats&n; *  - DMA to the block buffer directly if we have a 32bit DMA&n; *  - for medusa, the step rate is always 3ms&n; *  - on medusa, use only cache_push()&n; * Roman:&n; *  - Make disk format numbering independent from minors&n; *  - Let user set max. supported drive type (speeds up format&n; *    detection, saves buffer space)&n; *&n; * Roman 10/15/95:&n; *  - implement some more ioctls&n; *  - disk formatting&n; *  &n; * Andreas 95/12/12:&n; *  - increase gap size at start of track for HD/ED disks&n; *&n; * Michael (MSch) 11/07/96:&n; *  - implemented FDSETPRM and FDDEFPRM ioctl&n; *&n; * Andreas (97/03/19):&n; *  - implemented missing BLK* ioctls&n; *&n; *  Things left to do:&n; *   - Formatting&n; *   - Maybe a better strategy for disk change detection (does anyone&n; *     know one?)&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fd.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/atafd.h&gt;
macro_line|#include &lt;asm/atafdreg.h&gt;
macro_line|#include &lt;asm/atarihw.h&gt;
macro_line|#include &lt;asm/atariints.h&gt;
macro_line|#include &lt;asm/atari_stdma.h&gt;
macro_line|#include &lt;asm/atari_stram.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR FLOPPY_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
DECL|macro|FD_MAX_UNITS
mdefine_line|#define&t;FD_MAX_UNITS 2
DECL|macro|DEBUG
macro_line|#undef DEBUG
multiline_comment|/* Disk types: DD, HD, ED */
DECL|struct|atari_disk_type
r_static
r_struct
id|atari_disk_type
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|spt
r_int
id|spt
suffix:semicolon
multiline_comment|/* sectors per track */
DECL|member|blocks
r_int
id|blocks
suffix:semicolon
multiline_comment|/* total number of blocks */
DECL|member|fdc_speed
r_int
id|fdc_speed
suffix:semicolon
multiline_comment|/* fdc_speed setting */
DECL|member|stretch
r_int
id|stretch
suffix:semicolon
multiline_comment|/* track doubling ? */
DECL|variable|disk_type
)brace
id|disk_type
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;d360&quot;
comma
l_int|9
comma
l_int|720
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/*  0: 360kB diskette */
(brace
l_string|&quot;D360&quot;
comma
l_int|9
comma
l_int|720
comma
l_int|0
comma
l_int|1
)brace
comma
multiline_comment|/*  1: 360kb in 720k or 1.2MB drive */
(brace
l_string|&quot;D720&quot;
comma
l_int|9
comma
l_int|1440
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/*  2: 720kb in 720k or 1.2MB drive */
(brace
l_string|&quot;D820&quot;
comma
l_int|10
comma
l_int|1640
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/*  3: DD disk with 82 tracks/10 sectors */
multiline_comment|/* formats above are probed for type DD */
DECL|macro|MAX_TYPE_DD
mdefine_line|#define&t;MAX_TYPE_DD 3
(brace
l_string|&quot;h1200&quot;
comma
l_int|15
comma
l_int|2400
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/*  4: 1.2MB diskette */
(brace
l_string|&quot;H1440&quot;
comma
l_int|18
comma
l_int|2880
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/*  5: 1.4 MB diskette (HD) */
(brace
l_string|&quot;H1640&quot;
comma
l_int|20
comma
l_int|3280
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/*  6: 1.64MB diskette (fat HD) 82 tr 20 sec */
multiline_comment|/* formats above are probed for types DD and HD */
DECL|macro|MAX_TYPE_HD
mdefine_line|#define&t;MAX_TYPE_HD 6
(brace
l_string|&quot;E2880&quot;
comma
l_int|36
comma
l_int|5760
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/*  7: 2.8 MB diskette (ED) */
(brace
l_string|&quot;E3280&quot;
comma
l_int|40
comma
l_int|6560
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/*  8: 3.2 MB diskette (fat ED) 82 tr 40 sec */
multiline_comment|/* formats above are probed for types DD, HD and ED */
DECL|macro|MAX_TYPE_ED
mdefine_line|#define&t;MAX_TYPE_ED 8
multiline_comment|/* types below are never autoprobed */
(brace
l_string|&quot;H1680&quot;
comma
l_int|21
comma
l_int|3360
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/*  9: 1.68MB diskette (fat HD) 80 tr 21 sec */
(brace
l_string|&quot;h410&quot;
comma
l_int|10
comma
l_int|820
comma
l_int|0
comma
l_int|1
)brace
comma
multiline_comment|/* 10: 410k diskette 41 tr 10 sec, stretch */
(brace
l_string|&quot;h1476&quot;
comma
l_int|18
comma
l_int|2952
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/* 11: 1.48MB diskette 82 tr 18 sec */
(brace
l_string|&quot;H1722&quot;
comma
l_int|21
comma
l_int|3444
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/* 12: 1.72MB diskette 82 tr 21 sec */
(brace
l_string|&quot;h420&quot;
comma
l_int|10
comma
l_int|840
comma
l_int|0
comma
l_int|1
)brace
comma
multiline_comment|/* 13: 420k diskette 42 tr 10 sec, stretch */
(brace
l_string|&quot;H830&quot;
comma
l_int|10
comma
l_int|1660
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* 14: 820k diskette 83 tr 10 sec */
(brace
l_string|&quot;h1494&quot;
comma
l_int|18
comma
l_int|2952
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/* 15: 1.49MB diskette 83 tr 18 sec */
(brace
l_string|&quot;H1743&quot;
comma
l_int|21
comma
l_int|3486
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/* 16: 1.74MB diskette 83 tr 21 sec */
(brace
l_string|&quot;h880&quot;
comma
l_int|11
comma
l_int|1760
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* 17: 880k diskette 80 tr 11 sec */
(brace
l_string|&quot;D1040&quot;
comma
l_int|13
comma
l_int|2080
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* 18: 1.04MB diskette 80 tr 13 sec */
(brace
l_string|&quot;D1120&quot;
comma
l_int|14
comma
l_int|2240
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* 19: 1.12MB diskette 80 tr 14 sec */
(brace
l_string|&quot;h1600&quot;
comma
l_int|20
comma
l_int|3200
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/* 20: 1.60MB diskette 80 tr 20 sec */
(brace
l_string|&quot;H1760&quot;
comma
l_int|22
comma
l_int|3520
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/* 21: 1.76MB diskette 80 tr 22 sec */
(brace
l_string|&quot;H1920&quot;
comma
l_int|24
comma
l_int|3840
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/* 22: 1.92MB diskette 80 tr 24 sec */
(brace
l_string|&quot;E3200&quot;
comma
l_int|40
comma
l_int|6400
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/* 23: 3.2MB diskette 80 tr 40 sec */
(brace
l_string|&quot;E3520&quot;
comma
l_int|44
comma
l_int|7040
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/* 24: 3.52MB diskette 80 tr 44 sec */
(brace
l_string|&quot;E3840&quot;
comma
l_int|48
comma
l_int|7680
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/* 25: 3.84MB diskette 80 tr 48 sec */
(brace
l_string|&quot;H1840&quot;
comma
l_int|23
comma
l_int|3680
comma
l_int|3
comma
l_int|0
)brace
comma
multiline_comment|/* 26: 1.84MB diskette 80 tr 23 sec */
(brace
l_string|&quot;D800&quot;
comma
l_int|10
comma
l_int|1600
comma
l_int|0
comma
l_int|0
)brace
comma
multiline_comment|/* 27: 800k diskette 80 tr 10 sec */
)brace
suffix:semicolon
DECL|variable|StartDiskType
r_static
r_int
id|StartDiskType
(braket
)braket
op_assign
(brace
id|MAX_TYPE_DD
comma
id|MAX_TYPE_HD
comma
id|MAX_TYPE_ED
)brace
suffix:semicolon
DECL|macro|TYPE_DD
mdefine_line|#define&t;TYPE_DD&t;&t;0
DECL|macro|TYPE_HD
mdefine_line|#define&t;TYPE_HD&t;&t;1
DECL|macro|TYPE_ED
mdefine_line|#define&t;TYPE_ED&t;&t;2
DECL|variable|DriveType
r_static
r_int
id|DriveType
op_assign
id|TYPE_HD
suffix:semicolon
multiline_comment|/* Array for translating minors into disk formats */
r_static
r_struct
(brace
DECL|member|index
r_int
id|index
suffix:semicolon
DECL|member|drive_types
r_int
id|drive_types
suffix:semicolon
DECL|variable|minor2disktype
)brace
id|minor2disktype
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
id|TYPE_DD
)brace
comma
multiline_comment|/*  1: d360 */
(brace
l_int|4
comma
id|TYPE_HD
)brace
comma
multiline_comment|/*  2: h1200 */
(brace
l_int|1
comma
id|TYPE_DD
)brace
comma
multiline_comment|/*  3: D360 */
(brace
l_int|2
comma
id|TYPE_DD
)brace
comma
multiline_comment|/*  4: D720 */
(brace
l_int|1
comma
id|TYPE_DD
)brace
comma
multiline_comment|/*  5: h360 = D360 */
(brace
l_int|2
comma
id|TYPE_DD
)brace
comma
multiline_comment|/*  6: h720 = D720 */
(brace
l_int|5
comma
id|TYPE_HD
)brace
comma
multiline_comment|/*  7: H1440 */
(brace
l_int|7
comma
id|TYPE_ED
)brace
comma
multiline_comment|/*  8: E2880 */
multiline_comment|/* some PC formats :-) */
(brace
l_int|8
comma
id|TYPE_ED
)brace
comma
multiline_comment|/*  9: E3280    &lt;- was &quot;CompaQ&quot; == E2880 for PC */
(brace
l_int|5
comma
id|TYPE_HD
)brace
comma
multiline_comment|/* 10: h1440 = H1440 */
(brace
l_int|9
comma
id|TYPE_HD
)brace
comma
multiline_comment|/* 11: H1680 */
(brace
l_int|10
comma
id|TYPE_DD
)brace
comma
multiline_comment|/* 12: h410  */
(brace
l_int|3
comma
id|TYPE_DD
)brace
comma
multiline_comment|/* 13: H820     &lt;- == D820, 82x10 */
(brace
l_int|11
comma
id|TYPE_HD
)brace
comma
multiline_comment|/* 14: h1476 */
(brace
l_int|12
comma
id|TYPE_HD
)brace
comma
multiline_comment|/* 15: H1722 */
(brace
l_int|13
comma
id|TYPE_DD
)brace
comma
multiline_comment|/* 16: h420  */
(brace
l_int|14
comma
id|TYPE_DD
)brace
comma
multiline_comment|/* 17: H830  */
(brace
l_int|15
comma
id|TYPE_HD
)brace
comma
multiline_comment|/* 18: h1494 */
(brace
l_int|16
comma
id|TYPE_HD
)brace
comma
multiline_comment|/* 19: H1743 */
(brace
l_int|17
comma
id|TYPE_DD
)brace
comma
multiline_comment|/* 20: h880  */
(brace
l_int|18
comma
id|TYPE_DD
)brace
comma
multiline_comment|/* 21: D1040 */
(brace
l_int|19
comma
id|TYPE_DD
)brace
comma
multiline_comment|/* 22: D1120 */
(brace
l_int|20
comma
id|TYPE_HD
)brace
comma
multiline_comment|/* 23: h1600 */
(brace
l_int|21
comma
id|TYPE_HD
)brace
comma
multiline_comment|/* 24: H1760 */
(brace
l_int|22
comma
id|TYPE_HD
)brace
comma
multiline_comment|/* 25: H1920 */
(brace
l_int|23
comma
id|TYPE_ED
)brace
comma
multiline_comment|/* 26: E3200 */
(brace
l_int|24
comma
id|TYPE_ED
)brace
comma
multiline_comment|/* 27: E3520 */
(brace
l_int|25
comma
id|TYPE_ED
)brace
comma
multiline_comment|/* 28: E3840 */
(brace
l_int|26
comma
id|TYPE_HD
)brace
comma
multiline_comment|/* 29: H1840 */
(brace
l_int|27
comma
id|TYPE_DD
)brace
comma
multiline_comment|/* 30: D800  */
(brace
l_int|6
comma
id|TYPE_HD
)brace
comma
multiline_comment|/* 31: H1640    &lt;- was H1600 == h1600 for PC */
)brace
suffix:semicolon
DECL|macro|NUM_DISK_MINORS
mdefine_line|#define NUM_DISK_MINORS (sizeof(minor2disktype)/sizeof(*minor2disktype))
multiline_comment|/*&n; * Maximum disk size (in kilobytes). This default is used whenever the&n; * current disk size is unknown.&n; */
DECL|macro|MAX_DISK_SIZE
mdefine_line|#define MAX_DISK_SIZE 3280
multiline_comment|/*&n; * MSch: User-provided type information. &squot;drive&squot; points to&n; * the respective entry of this array. Set by FDSETPRM ioctls.&n; */
DECL|variable|user_params
r_static
r_struct
id|atari_disk_type
id|user_params
(braket
id|FD_MAX_UNITS
)braket
suffix:semicolon
multiline_comment|/*&n; * User-provided permanent type information. &squot;drive&squot; points to&n; * the respective entry of this array.  Set by FDDEFPRM ioctls, &n; * restored upon disk change by floppy_revalidate() if valid (as seen by&n; * default_params[].blocks &gt; 0 - a bit in unit[].flags might be used for this?)&n; */
DECL|variable|default_params
r_static
r_struct
id|atari_disk_type
id|default_params
(braket
id|FD_MAX_UNITS
)braket
suffix:semicolon
DECL|variable|floppy_sizes
r_static
r_int
id|floppy_sizes
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|floppy_blocksizes
r_static
r_int
id|floppy_blocksizes
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* current info on each unit */
DECL|struct|atari_floppy_struct
r_static
r_struct
id|atari_floppy_struct
(brace
DECL|member|connected
r_int
id|connected
suffix:semicolon
multiline_comment|/* !=0 : drive is connected */
DECL|member|autoprobe
r_int
id|autoprobe
suffix:semicolon
multiline_comment|/* !=0 : do autoprobe&t;    */
DECL|member|disktype
r_struct
id|atari_disk_type
op_star
id|disktype
suffix:semicolon
multiline_comment|/* current type of disk */
DECL|member|track
r_int
id|track
suffix:semicolon
multiline_comment|/* current head position or -1 if&n;&t;&t;&t;&t;   unknown */
DECL|member|steprate
r_int
r_int
id|steprate
suffix:semicolon
multiline_comment|/* steprate setting */
DECL|member|wpstat
r_int
r_int
id|wpstat
suffix:semicolon
multiline_comment|/* current state of WP signal (for&n;&t;&t;&t;&t;   disk change detection) */
DECL|member|flags
r_int
id|flags
suffix:semicolon
multiline_comment|/* flags */
DECL|variable|unit
)brace
id|unit
(braket
id|FD_MAX_UNITS
)braket
suffix:semicolon
DECL|macro|UD
mdefine_line|#define&t;UD&t;unit[drive]
DECL|macro|UDT
mdefine_line|#define&t;UDT&t;unit[drive].disktype
DECL|macro|SUD
mdefine_line|#define&t;SUD&t;unit[SelectedDrive]
DECL|macro|SUDT
mdefine_line|#define&t;SUDT&t;unit[SelectedDrive].disktype
DECL|macro|FDC_READ
mdefine_line|#define FDC_READ(reg) ({&t;&t;&t;&bslash;&n;    /* unsigned long __flags; */&t;&t;&bslash;&n;    unsigned short __val;&t;&t;&t;&bslash;&n;    /* save_flags(__flags); cli(); */&t;&t;&bslash;&n;    dma_wd.dma_mode_status = 0x80 | (reg);&t;&bslash;&n;    udelay(25);&t;&t;&t;&t;&t;&bslash;&n;    __val = dma_wd.fdc_acces_seccount;&t;&t;&bslash;&n;    MFPDELAY();&t;&t;&t;&t;&t;&bslash;&n;    /* restore_flags(__flags); */&t;&t;&bslash;&n;    __val &amp; 0xff;&t;&t;&t;&t;&bslash;&n;})
DECL|macro|FDC_WRITE
mdefine_line|#define FDC_WRITE(reg,val)&t;&t;&t;&bslash;&n;    do {&t;&t;&t;&t;&t;&bslash;&n;&t;/* unsigned long __flags; */&t;&t;&bslash;&n;&t;/* save_flags(__flags); cli(); */&t;&bslash;&n;&t;dma_wd.dma_mode_status = 0x80 | (reg);&t;&bslash;&n;&t;udelay(25);&t;&t;&t;&t;&bslash;&n;&t;dma_wd.fdc_acces_seccount = (val);&t;&bslash;&n;&t;MFPDELAY();&t;&t;&t;&t;&bslash;&n;        /* restore_flags(__flags); */&t;&t;&bslash;&n;    } while(0)
multiline_comment|/* Buffering variables:&n; * First, there is a DMA buffer in ST-RAM that is used for floppy DMA&n; * operations. Second, a track buffer is used to cache a whole track&n; * of the disk to save read operations. These are two separate buffers&n; * because that allows write operations without clearing the track buffer.&n; */
DECL|variable|MaxSectors
r_static
r_int
id|MaxSectors
(braket
)braket
op_assign
(brace
l_int|11
comma
l_int|22
comma
l_int|44
)brace
suffix:semicolon
DECL|variable|BufferSize
r_static
r_int
id|BufferSize
(braket
)braket
op_assign
(brace
l_int|15
op_star
l_int|512
comma
l_int|30
op_star
l_int|512
comma
l_int|60
op_star
l_int|512
)brace
suffix:semicolon
DECL|macro|BUFFER_SIZE
mdefine_line|#define&t;BUFFER_SIZE&t;(BufferSize[DriveType])
DECL|variable|DMABuffer
r_int
r_char
op_star
id|DMABuffer
suffix:semicolon
multiline_comment|/* buffer for writes */
DECL|variable|PhysDMABuffer
r_static
r_int
r_int
id|PhysDMABuffer
suffix:semicolon
multiline_comment|/* physical address */
DECL|variable|UseTrackbuffer
r_static
r_int
id|UseTrackbuffer
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Do track buffering? */
id|MODULE_PARM
c_func
(paren
id|UseTrackbuffer
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
DECL|variable|TrackBuffer
r_int
r_char
op_star
id|TrackBuffer
suffix:semicolon
multiline_comment|/* buffer for reads */
DECL|variable|PhysTrackBuffer
r_static
r_int
r_int
id|PhysTrackBuffer
suffix:semicolon
multiline_comment|/* physical address */
DECL|variable|BufferDrive
DECL|variable|BufferSide
DECL|variable|BufferTrack
r_static
r_int
id|BufferDrive
comma
id|BufferSide
comma
id|BufferTrack
suffix:semicolon
DECL|variable|read_track
r_static
r_int
id|read_track
suffix:semicolon
multiline_comment|/* non-zero if we are reading whole tracks */
DECL|macro|SECTOR_BUFFER
mdefine_line|#define&t;SECTOR_BUFFER(sec)&t;(TrackBuffer + ((sec)-1)*512)
DECL|macro|IS_BUFFERED
mdefine_line|#define&t;IS_BUFFERED(drive,side,track) &bslash;&n;    (BufferDrive == (drive) &amp;&amp; BufferSide == (side) &amp;&amp; BufferTrack == (track))
multiline_comment|/*&n; * These are global variables, as that&squot;s the easiest way to give&n; * information to interrupts. They are the data used for the current&n; * request.&n; */
DECL|variable|SelectedDrive
r_static
r_int
id|SelectedDrive
op_assign
l_int|0
suffix:semicolon
DECL|variable|ReqCmd
DECL|variable|ReqBlock
r_static
r_int
id|ReqCmd
comma
id|ReqBlock
suffix:semicolon
DECL|variable|ReqSide
DECL|variable|ReqTrack
DECL|variable|ReqSector
DECL|variable|ReqCnt
r_static
r_int
id|ReqSide
comma
id|ReqTrack
comma
id|ReqSector
comma
id|ReqCnt
suffix:semicolon
DECL|variable|HeadSettleFlag
r_static
r_int
id|HeadSettleFlag
op_assign
l_int|0
suffix:semicolon
DECL|variable|ReqData
DECL|variable|ReqBuffer
r_static
r_int
r_char
op_star
id|ReqData
comma
op_star
id|ReqBuffer
suffix:semicolon
DECL|variable|MotorOn
DECL|variable|MotorOffTrys
r_static
r_int
id|MotorOn
op_assign
l_int|0
comma
id|MotorOffTrys
suffix:semicolon
DECL|variable|IsFormatting
DECL|variable|FormatError
r_static
r_int
id|IsFormatting
op_assign
l_int|0
comma
id|FormatError
suffix:semicolon
DECL|variable|UserSteprate
r_static
r_int
id|UserSteprate
(braket
id|FD_MAX_UNITS
)braket
op_assign
(brace
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|UserSteprate
comma
l_string|&quot;1-&quot;
id|__MODULE_STRING
c_func
(paren
id|FD_MAX_UNITS
)paren
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/* Synchronization of FDC access. */
DECL|variable|fdc_busy
r_static
r_volatile
r_int
id|fdc_busy
op_assign
l_int|0
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|fdc_wait
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|format_wait
)paren
suffix:semicolon
DECL|variable|changed_floppies
DECL|variable|fake_change
r_static
r_int
r_int
id|changed_floppies
op_assign
l_int|0xff
comma
id|fake_change
op_assign
l_int|0
suffix:semicolon
DECL|macro|CHECK_CHANGE_DELAY
mdefine_line|#define&t;CHECK_CHANGE_DELAY&t;HZ/2
DECL|macro|FD_MOTOR_OFF_DELAY
mdefine_line|#define&t;FD_MOTOR_OFF_DELAY&t;(3*HZ)
DECL|macro|FD_MOTOR_OFF_MAXTRY
mdefine_line|#define&t;FD_MOTOR_OFF_MAXTRY&t;(10*20)
DECL|macro|FLOPPY_TIMEOUT
mdefine_line|#define FLOPPY_TIMEOUT&t;&t;(6*HZ)
DECL|macro|RECALIBRATE_ERRORS
mdefine_line|#define RECALIBRATE_ERRORS&t;4&t;/* After this many errors the drive&n;&t;&t;&t;&t;&t; * will be recalibrated. */
DECL|macro|MAX_ERRORS
mdefine_line|#define MAX_ERRORS&t;&t;8&t;/* After this many errors the driver&n;&t;&t;&t;&t;&t; * will give up. */
multiline_comment|/*&n; * The driver is trying to determine the correct media format&n; * while Probing is set. fd_rwsec_done() clears it after a&n; * successful access.&n; */
DECL|variable|Probing
r_static
r_int
id|Probing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This flag is set when a dummy seek is necessary to make the WP&n; * status bit accessible.&n; */
DECL|variable|NeedSeek
r_static
r_int
id|NeedSeek
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DEBUG
DECL|macro|DPRINT
mdefine_line|#define DPRINT(a)&t;printk a
macro_line|#else
DECL|macro|DPRINT
mdefine_line|#define DPRINT(a)
macro_line|#endif
multiline_comment|/***************************** Prototypes *****************************/
r_static
r_void
id|fd_select_side
c_func
(paren
r_int
id|side
)paren
suffix:semicolon
r_static
r_void
id|fd_select_drive
c_func
(paren
r_int
id|drive
)paren
suffix:semicolon
r_static
r_void
id|fd_deselect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|fd_motor_off_timer
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
r_static
r_void
id|check_change
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
id|__inline__
r_void
id|set_head_settle_flag
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
id|__inline__
r_int
id|get_head_settle_flag
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|floppy_irq
(paren
r_int
id|irq
comma
r_void
op_star
id|dummy
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
suffix:semicolon
r_static
r_void
id|fd_error
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|do_format
c_func
(paren
id|kdev_t
id|drive
comma
r_struct
id|atari_format_descr
op_star
id|desc
)paren
suffix:semicolon
r_static
r_void
id|do_fd_action
c_func
(paren
r_int
id|drive
)paren
suffix:semicolon
r_static
r_void
id|fd_calibrate
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|fd_calibrate_done
c_func
(paren
r_int
id|status
)paren
suffix:semicolon
r_static
r_void
id|fd_seek
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|fd_seek_done
c_func
(paren
r_int
id|status
)paren
suffix:semicolon
r_static
r_void
id|fd_rwsec
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|fd_readtrack_check
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
r_static
r_void
id|fd_rwsec_done
c_func
(paren
r_int
id|status
)paren
suffix:semicolon
r_static
r_void
id|fd_rwsec_done1
c_func
(paren
r_int
id|status
)paren
suffix:semicolon
r_static
r_void
id|fd_writetrack
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|fd_writetrack_done
c_func
(paren
r_int
id|status
)paren
suffix:semicolon
r_static
r_void
id|fd_times_out
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
r_static
r_void
id|finish_fdc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|finish_fdc_done
c_func
(paren
r_int
id|dummy
)paren
suffix:semicolon
r_static
r_void
id|floppy_off
c_func
(paren
r_int
r_int
id|nr
)paren
suffix:semicolon
r_static
id|__inline__
r_void
id|copy_buffer
c_func
(paren
r_void
op_star
id|from
comma
r_void
op_star
id|to
)paren
suffix:semicolon
r_static
r_void
id|setup_req_params
c_func
(paren
r_int
id|drive
)paren
suffix:semicolon
r_static
r_void
id|redo_fd_request
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|invalidate_drive
c_func
(paren
id|kdev_t
id|rdev
)paren
suffix:semicolon
r_static
r_int
id|fd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|param
)paren
suffix:semicolon
r_static
r_void
id|fd_probe
c_func
(paren
r_int
id|drive
)paren
suffix:semicolon
r_static
r_int
id|fd_test_drive_present
c_func
(paren
r_int
id|drive
)paren
suffix:semicolon
r_static
r_void
id|config_types
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|floppy_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_int
id|floppy_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
multiline_comment|/************************* End of Prototypes **************************/
DECL|variable|motor_off_timer
r_static
r_struct
id|timer_list
id|motor_off_timer
op_assign
(brace
id|function
suffix:colon
id|fd_motor_off_timer
)brace
suffix:semicolon
DECL|variable|readtrack_timer
r_static
r_struct
id|timer_list
id|readtrack_timer
op_assign
(brace
id|function
suffix:colon
id|fd_readtrack_check
)brace
suffix:semicolon
DECL|variable|timeout_timer
r_static
r_struct
id|timer_list
id|timeout_timer
op_assign
(brace
id|function
suffix:colon
id|fd_times_out
)brace
suffix:semicolon
DECL|variable|fd_timer
r_static
r_struct
id|timer_list
id|fd_timer
op_assign
(brace
id|function
suffix:colon
id|check_change
)brace
suffix:semicolon
r_static
r_inline
r_void
DECL|function|start_motor_off_timer
id|start_motor_off_timer
c_func
(paren
r_void
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|motor_off_timer
comma
id|jiffies
op_plus
id|FD_MOTOR_OFF_DELAY
)paren
suffix:semicolon
id|MotorOffTrys
op_assign
l_int|0
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|start_check_change_timer
id|start_check_change_timer
c_func
(paren
r_void
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|fd_timer
comma
id|jiffies
op_plus
id|CHECK_CHANGE_DELAY
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|start_timeout
id|start_timeout
c_func
(paren
r_void
)paren
(brace
id|mod_timer
c_func
(paren
op_amp
id|timeout_timer
comma
id|jiffies
op_plus
id|FLOPPY_TIMEOUT
)paren
suffix:semicolon
)brace
r_static
r_inline
r_void
DECL|function|stop_timeout
id|stop_timeout
c_func
(paren
r_void
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|timeout_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* Select the side to use. */
DECL|function|fd_select_side
r_static
r_void
id|fd_select_side
c_func
(paren
r_int
id|side
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* protect against various other ints mucking around with the PSG */
id|sound_ym.rd_data_reg_sel
op_assign
l_int|14
suffix:semicolon
multiline_comment|/* Select PSG Port A */
id|sound_ym.wd_data
op_assign
(paren
id|side
op_eq
l_int|0
)paren
ques
c_cond
id|sound_ym.rd_data_reg_sel
op_or
l_int|0x01
suffix:colon
id|sound_ym.rd_data_reg_sel
op_amp
l_int|0xfe
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Select a drive, update the FDC&squot;s track register and set the correct&n; * clock speed for this disk&squot;s type.&n; */
DECL|function|fd_select_drive
r_static
r_void
id|fd_select_drive
c_func
(paren
r_int
id|drive
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
id|SelectedDrive
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* protect against various other ints mucking around with the PSG */
id|sound_ym.rd_data_reg_sel
op_assign
l_int|14
suffix:semicolon
multiline_comment|/* Select PSG Port A */
id|tmp
op_assign
id|sound_ym.rd_data_reg_sel
suffix:semicolon
id|sound_ym.wd_data
op_assign
(paren
id|tmp
op_or
id|DSKDRVNONE
)paren
op_amp
op_complement
(paren
id|drive
op_eq
l_int|0
ques
c_cond
id|DSKDRV0
suffix:colon
id|DSKDRV1
)paren
suffix:semicolon
id|atari_dont_touch_floppy_select
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* restore track register to saved value */
id|FDC_WRITE
c_func
(paren
id|FDCREG_TRACK
comma
id|UD.track
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
multiline_comment|/* select 8/16 MHz */
r_if
c_cond
(paren
id|UDT
)paren
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|FDCSPEED
)paren
)paren
id|dma_wd.fdc_speed
op_assign
id|UDT-&gt;fdc_speed
suffix:semicolon
id|SelectedDrive
op_assign
id|drive
suffix:semicolon
)brace
multiline_comment|/* Deselect both drives. */
DECL|function|fd_deselect
r_static
r_void
id|fd_deselect
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* protect against various other ints mucking around with the PSG */
id|atari_dont_touch_floppy_select
op_assign
l_int|0
suffix:semicolon
id|sound_ym.rd_data_reg_sel
op_assign
l_int|14
suffix:semicolon
multiline_comment|/* Select PSG Port A */
id|sound_ym.wd_data
op_assign
(paren
id|sound_ym.rd_data_reg_sel
op_or
(paren
id|MACH_IS_FALCON
ques
c_cond
l_int|3
suffix:colon
l_int|7
)paren
)paren
suffix:semicolon
multiline_comment|/* no drives selected */
multiline_comment|/* On Falcon, the drive B select line is used on the printer port, so&n;&t; * leave it alone... */
id|SelectedDrive
op_assign
op_minus
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* This timer function deselects the drives when the FDC switched the&n; * motor off. The deselection cannot happen earlier because the FDC&n; * counts the index signals, which arrive only if one drive is selected.&n; */
DECL|function|fd_motor_off_timer
r_static
r_void
id|fd_motor_off_timer
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
r_if
c_cond
(paren
id|SelectedDrive
OL
l_int|0
)paren
multiline_comment|/* no drive selected, needn&squot;t deselect anyone */
r_return
suffix:semicolon
r_if
c_cond
(paren
id|stdma_islocked
c_func
(paren
)paren
)paren
r_goto
id|retry
suffix:semicolon
id|status
op_assign
id|FDC_READ
c_func
(paren
id|FDCREG_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x80
)paren
)paren
(brace
multiline_comment|/* motor already turned off by FDC -&gt; deselect drives */
id|MotorOn
op_assign
l_int|0
suffix:semicolon
id|fd_deselect
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* not yet off, try again */
id|retry
suffix:colon
multiline_comment|/* Test again later; if tested too often, it seems there is no disk&n;&t; * in the drive and the FDC will leave the motor on forever (or,&n;&t; * at least until a disk is inserted). So we&squot;ll test only twice&n;&t; * per second from then on...&n;&t; */
id|mod_timer
c_func
(paren
op_amp
id|motor_off_timer
comma
id|jiffies
op_plus
(paren
id|MotorOffTrys
op_increment
OL
id|FD_MOTOR_OFF_MAXTRY
ques
c_cond
id|HZ
op_div
l_int|20
suffix:colon
id|HZ
op_div
l_int|2
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This function is repeatedly called to detect disk changes (as good&n; * as possible) and keep track of the current state of the write protection.&n; */
DECL|function|check_change
r_static
r_void
id|check_change
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|drive
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|old_porta
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|drive
OG
l_int|1
op_logical_or
op_logical_neg
id|UD.connected
)paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* protect against various other ints mucking around with the PSG */
r_if
c_cond
(paren
op_logical_neg
id|stdma_islocked
c_func
(paren
)paren
)paren
(brace
id|sound_ym.rd_data_reg_sel
op_assign
l_int|14
suffix:semicolon
id|old_porta
op_assign
id|sound_ym.rd_data_reg_sel
suffix:semicolon
id|sound_ym.wd_data
op_assign
(paren
id|old_porta
op_or
id|DSKDRVNONE
)paren
op_amp
op_complement
(paren
id|drive
op_eq
l_int|0
ques
c_cond
id|DSKDRV0
suffix:colon
id|DSKDRV1
)paren
suffix:semicolon
id|stat
op_assign
op_logical_neg
op_logical_neg
(paren
id|FDC_READ
c_func
(paren
id|FDCREG_STATUS
)paren
op_amp
id|FDCSTAT_WPROT
)paren
suffix:semicolon
id|sound_ym.wd_data
op_assign
id|old_porta
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_ne
id|UD.wpstat
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;wpstat[%d] = %d&bslash;n&quot;
comma
id|drive
comma
id|stat
)paren
)paren
suffix:semicolon
id|UD.wpstat
op_assign
id|stat
suffix:semicolon
id|set_bit
(paren
id|drive
comma
op_amp
id|changed_floppies
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|start_check_change_timer
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Handling of the Head Settling Flag: This flag should be set after each&n; * seek operation, because we don&squot;t use seeks with verify.&n; */
DECL|function|set_head_settle_flag
r_static
id|__inline__
r_void
id|set_head_settle_flag
c_func
(paren
r_void
)paren
(brace
id|HeadSettleFlag
op_assign
id|FDCCMDADD_E
suffix:semicolon
)brace
DECL|function|get_head_settle_flag
r_static
id|__inline__
r_int
id|get_head_settle_flag
c_func
(paren
r_void
)paren
(brace
r_int
id|tmp
op_assign
id|HeadSettleFlag
suffix:semicolon
id|HeadSettleFlag
op_assign
l_int|0
suffix:semicolon
r_return
id|tmp
suffix:semicolon
)brace
multiline_comment|/* General Interrupt Handling */
DECL|variable|FloppyIRQHandler
r_static
r_void
(paren
op_star
id|FloppyIRQHandler
)paren
(paren
r_int
id|status
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|function|floppy_irq
r_static
r_void
id|floppy_irq
(paren
r_int
id|irq
comma
r_void
op_star
id|dummy
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
)paren
suffix:semicolon
id|handler
op_assign
id|xchg
c_func
(paren
op_amp
id|FloppyIRQHandler
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|handler
)paren
(brace
id|nop
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
id|FDC_READ
c_func
(paren
id|FDCREG_STATUS
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;FDC irq, status = %02x handler = %08lx&bslash;n&quot;
comma
id|status
comma
(paren
r_int
r_int
)paren
id|handler
)paren
)paren
suffix:semicolon
id|handler
c_func
(paren
id|status
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;FDC irq, no handler&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Error handling: If some error happened, retry some times, then&n; * recalibrate, then try again, and fail after MAX_ERRORS.&n; */
DECL|function|fd_error
r_static
r_void
id|fd_error
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|IsFormatting
)paren
(brace
id|IsFormatting
op_assign
l_int|0
suffix:semicolon
id|FormatError
op_assign
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|format_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|QUEUE_EMPTY
)paren
r_return
suffix:semicolon
id|CURRENT-&gt;errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;errors
op_ge
id|MAX_ERRORS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;fd%d: too many errors.&bslash;n&quot;
comma
id|SelectedDrive
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CURRENT-&gt;errors
op_eq
id|RECALIBRATE_ERRORS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;fd%d: recalibrating&bslash;n&quot;
comma
id|SelectedDrive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SelectedDrive
op_ne
op_minus
l_int|1
)paren
id|SUD.track
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|macro|SET_IRQ_HANDLER
mdefine_line|#define&t;SET_IRQ_HANDLER(proc) do { FloppyIRQHandler = (proc); } while(0)
multiline_comment|/* ---------- Formatting ---------- */
DECL|macro|FILL
mdefine_line|#define FILL(n,val)&t;&t;&bslash;&n;    do {&t;&t;&t;&bslash;&n;&t;memset( p, val, n );&t;&bslash;&n;&t;p += n;&t;&t;&t;&bslash;&n;    } while(0)
DECL|function|do_format
r_static
r_int
id|do_format
c_func
(paren
id|kdev_t
id|device
comma
r_struct
id|atari_format_descr
op_star
id|desc
)paren
(brace
r_int
r_char
op_star
id|p
suffix:semicolon
r_int
id|sect
comma
id|nsect
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|type
comma
id|drive
op_assign
id|MINOR
c_func
(paren
id|device
)paren
op_amp
l_int|3
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;do_format( dr=%d tr=%d he=%d offs=%d )&bslash;n&quot;
comma
id|drive
comma
id|desc-&gt;track
comma
id|desc-&gt;head
comma
id|desc-&gt;sect_offset
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fdc_busy
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
)brace
id|fdc_busy
op_assign
l_int|1
suffix:semicolon
id|stdma_lock
c_func
(paren
id|floppy_irq
comma
l_int|NULL
)paren
suffix:semicolon
id|atari_turnon_irq
c_func
(paren
id|IRQ_MFP_FDC
)paren
suffix:semicolon
multiline_comment|/* should be already, just to be sure */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|type
op_assign
id|MINOR
c_func
(paren
id|device
)paren
op_rshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|type
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|type
op_ge
id|NUM_DISK_MINORS
op_logical_or
id|minor2disktype
(braket
id|type
)braket
dot
id|drive_types
OG
id|DriveType
)paren
(brace
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|type
op_assign
id|minor2disktype
(braket
id|type
)braket
dot
id|index
suffix:semicolon
id|UDT
op_assign
op_amp
id|disk_type
(braket
id|type
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|UDT
op_logical_or
id|desc-&gt;track
op_ge
id|UDT-&gt;blocks
op_div
id|UDT-&gt;spt
op_div
l_int|2
op_logical_or
id|desc-&gt;head
op_ge
l_int|2
)paren
(brace
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|nsect
op_assign
id|UDT-&gt;spt
suffix:semicolon
id|p
op_assign
id|TrackBuffer
suffix:semicolon
multiline_comment|/* The track buffer is used for the raw track data, so its&n;&t;   contents become invalid! */
id|BufferDrive
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* stop deselect timer */
id|del_timer
c_func
(paren
op_amp
id|motor_off_timer
)paren
suffix:semicolon
id|FILL
c_func
(paren
l_int|60
op_star
(paren
id|nsect
op_div
l_int|9
)paren
comma
l_int|0x4e
)paren
suffix:semicolon
r_for
c_loop
(paren
id|sect
op_assign
l_int|0
suffix:semicolon
id|sect
OL
id|nsect
suffix:semicolon
op_increment
id|sect
)paren
(brace
id|FILL
c_func
(paren
l_int|12
comma
l_int|0
)paren
suffix:semicolon
id|FILL
c_func
(paren
l_int|3
comma
l_int|0xf5
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|0xfe
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|desc-&gt;track
suffix:semicolon
op_star
id|p
op_increment
op_assign
id|desc-&gt;head
suffix:semicolon
op_star
id|p
op_increment
op_assign
(paren
id|nsect
op_plus
id|sect
op_minus
id|desc-&gt;sect_offset
)paren
op_mod
id|nsect
op_plus
l_int|1
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|2
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|0xf7
suffix:semicolon
id|FILL
c_func
(paren
l_int|22
comma
l_int|0x4e
)paren
suffix:semicolon
id|FILL
c_func
(paren
l_int|12
comma
l_int|0
)paren
suffix:semicolon
id|FILL
c_func
(paren
l_int|3
comma
l_int|0xf5
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|0xfb
suffix:semicolon
id|FILL
c_func
(paren
l_int|512
comma
l_int|0xe5
)paren
suffix:semicolon
op_star
id|p
op_increment
op_assign
l_int|0xf7
suffix:semicolon
id|FILL
c_func
(paren
l_int|40
comma
l_int|0x4e
)paren
suffix:semicolon
)brace
id|FILL
c_func
(paren
id|TrackBuffer
op_plus
id|BUFFER_SIZE
op_minus
id|p
comma
l_int|0x4e
)paren
suffix:semicolon
id|IsFormatting
op_assign
l_int|1
suffix:semicolon
id|FormatError
op_assign
l_int|0
suffix:semicolon
id|ReqTrack
op_assign
id|desc-&gt;track
suffix:semicolon
id|ReqSide
op_assign
id|desc-&gt;head
suffix:semicolon
id|do_fd_action
c_func
(paren
id|drive
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|format_wait
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
id|FormatError
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/* do_fd_action() is the general procedure for a fd request: All&n; * required parameter settings (drive select, side select, track&n; * position) are checked and set if needed. For each of these&n; * parameters and the actual reading or writing exist two functions:&n; * one that starts the setting (or skips it if possible) and one&n; * callback for the &quot;done&quot; interrupt. Each done func calls the next&n; * set function to propagate the request down to fd_rwsec_done().&n; */
DECL|function|do_fd_action
r_static
r_void
id|do_fd_action
c_func
(paren
r_int
id|drive
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;do_fd_action&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UseTrackbuffer
op_logical_and
op_logical_neg
id|IsFormatting
)paren
(brace
id|repeat
suffix:colon
r_if
c_cond
(paren
id|IS_BUFFERED
c_func
(paren
id|drive
comma
id|ReqSide
comma
id|ReqTrack
)paren
)paren
(brace
r_if
c_cond
(paren
id|ReqCmd
op_eq
id|READ
)paren
(brace
id|copy_buffer
c_func
(paren
id|SECTOR_BUFFER
c_func
(paren
id|ReqSector
)paren
comma
id|ReqData
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|ReqCnt
OL
id|CURRENT-&gt;current_nr_sectors
)paren
(brace
multiline_comment|/* read next sector */
id|setup_req_params
c_func
(paren
id|drive
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* all sectors finished */
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* cmd == WRITE, pay attention to track buffer&n;&t;&t;     * consistency! */
id|copy_buffer
c_func
(paren
id|ReqData
comma
id|SECTOR_BUFFER
c_func
(paren
id|ReqSector
)paren
)paren
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|SelectedDrive
op_ne
id|drive
)paren
id|fd_select_drive
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UD.track
op_eq
op_minus
l_int|1
)paren
id|fd_calibrate
c_func
(paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|UD.track
op_ne
id|ReqTrack
op_lshift
id|UDT-&gt;stretch
)paren
id|fd_seek
c_func
(paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|IsFormatting
)paren
id|fd_writetrack
c_func
(paren
)paren
suffix:semicolon
r_else
id|fd_rwsec
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Seek to track 0 if the current track is unknown */
DECL|function|fd_calibrate
r_static
r_void
id|fd_calibrate
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|SUD.track
op_ge
l_int|0
)paren
(brace
id|fd_calibrate_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|FDCSPEED
)paren
)paren
id|dma_wd.fdc_speed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* always seek with 8 Mhz */
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_calibrate&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|SET_IRQ_HANDLER
c_func
(paren
id|fd_calibrate_done
)paren
suffix:semicolon
multiline_comment|/* we can&squot;t verify, since the speed may be incorrect */
id|FDC_WRITE
c_func
(paren
id|FDCREG_CMD
comma
id|FDCCMD_RESTORE
op_or
id|SUD.steprate
)paren
suffix:semicolon
id|NeedSeek
op_assign
l_int|1
suffix:semicolon
id|MotorOn
op_assign
l_int|1
suffix:semicolon
id|start_timeout
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for IRQ */
)brace
DECL|function|fd_calibrate_done
r_static
r_void
id|fd_calibrate_done
c_func
(paren
r_int
id|status
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_calibrate_done()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stop_timeout
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set the correct speed now */
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|FDCSPEED
)paren
)paren
id|dma_wd.fdc_speed
op_assign
id|SUDT-&gt;fdc_speed
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|FDCSTAT_RECNF
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;fd%d: restore failed&bslash;n&quot;
comma
id|SelectedDrive
)paren
suffix:semicolon
id|fd_error
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|SUD.track
op_assign
l_int|0
suffix:semicolon
id|fd_seek
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Seek the drive to the requested track. The drive must have been&n; * calibrated at some point before this.&n; */
DECL|function|fd_seek
r_static
r_void
id|fd_seek
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|SUD.track
op_eq
id|ReqTrack
op_lshift
id|SUDT-&gt;stretch
)paren
(brace
id|fd_seek_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|FDCSPEED
)paren
)paren
(brace
id|dma_wd.fdc_speed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* always seek witch 8 Mhz */
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_seek() to track %d&bslash;n&quot;
comma
id|ReqTrack
)paren
)paren
suffix:semicolon
id|FDC_WRITE
c_func
(paren
id|FDCREG_DATA
comma
id|ReqTrack
op_lshift
id|SUDT-&gt;stretch
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|SET_IRQ_HANDLER
c_func
(paren
id|fd_seek_done
)paren
suffix:semicolon
id|FDC_WRITE
c_func
(paren
id|FDCREG_CMD
comma
id|FDCCMD_SEEK
op_or
id|SUD.steprate
)paren
suffix:semicolon
id|MotorOn
op_assign
l_int|1
suffix:semicolon
id|set_head_settle_flag
c_func
(paren
)paren
suffix:semicolon
id|start_timeout
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for IRQ */
)brace
DECL|function|fd_seek_done
r_static
r_void
id|fd_seek_done
c_func
(paren
r_int
id|status
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_seek_done()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stop_timeout
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set the correct speed */
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|FDCSPEED
)paren
)paren
id|dma_wd.fdc_speed
op_assign
id|SUDT-&gt;fdc_speed
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|FDCSTAT_RECNF
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;fd%d: seek error (to track %d)&bslash;n&quot;
comma
id|SelectedDrive
comma
id|ReqTrack
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t know exactly which track we are on now! */
id|SUD.track
op_assign
op_minus
l_int|1
suffix:semicolon
id|fd_error
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|SUD.track
op_assign
id|ReqTrack
op_lshift
id|SUDT-&gt;stretch
suffix:semicolon
id|NeedSeek
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|IsFormatting
)paren
id|fd_writetrack
c_func
(paren
)paren
suffix:semicolon
r_else
id|fd_rwsec
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This does the actual reading/writing after positioning the head&n; * over the correct track.&n; */
DECL|variable|MultReadInProgress
r_static
r_int
id|MultReadInProgress
op_assign
l_int|0
suffix:semicolon
DECL|function|fd_rwsec
r_static
r_void
id|fd_rwsec
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|paddr
comma
id|flags
suffix:semicolon
r_int
r_int
id|rwflag
comma
id|old_motoron
suffix:semicolon
r_int
r_int
id|track
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_rwsec(), Sec=%d, Access=%c&bslash;n&quot;
comma
id|ReqSector
comma
id|ReqCmd
op_eq
id|WRITE
ques
c_cond
l_char|&squot;w&squot;
suffix:colon
l_char|&squot;r&squot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReqCmd
op_eq
id|WRITE
)paren
(brace
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|EXTD_DMA
)paren
)paren
(brace
id|paddr
op_assign
id|virt_to_phys
c_func
(paren
id|ReqData
)paren
suffix:semicolon
)brace
r_else
(brace
id|copy_buffer
c_func
(paren
id|ReqData
comma
id|DMABuffer
)paren
suffix:semicolon
id|paddr
op_assign
id|PhysDMABuffer
suffix:semicolon
)brace
id|dma_cache_maintenance
c_func
(paren
id|paddr
comma
l_int|512
comma
l_int|1
)paren
suffix:semicolon
id|rwflag
op_assign
l_int|0x100
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|read_track
)paren
id|paddr
op_assign
id|PhysTrackBuffer
suffix:semicolon
r_else
id|paddr
op_assign
id|ATARIHW_PRESENT
c_func
(paren
id|EXTD_DMA
)paren
ques
c_cond
id|virt_to_phys
c_func
(paren
id|ReqData
)paren
suffix:colon
id|PhysDMABuffer
suffix:semicolon
id|rwflag
op_assign
l_int|0
suffix:semicolon
)brace
id|fd_select_side
c_func
(paren
id|ReqSide
)paren
suffix:semicolon
multiline_comment|/* Start sector of this operation */
id|FDC_WRITE
c_func
(paren
id|FDCREG_SECTOR
comma
id|read_track
ques
c_cond
l_int|1
suffix:colon
id|ReqSector
)paren
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Cheat for track if stretch != 0 */
r_if
c_cond
(paren
id|SUDT-&gt;stretch
)paren
(brace
id|track
op_assign
id|FDC_READ
c_func
(paren
id|FDCREG_TRACK
)paren
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|FDC_WRITE
c_func
(paren
id|FDCREG_TRACK
comma
id|track
op_rshift
id|SUDT-&gt;stretch
)paren
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
multiline_comment|/* Setup DMA */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dma_wd.dma_lo
op_assign
(paren
r_int
r_char
)paren
id|paddr
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|paddr
op_rshift_assign
l_int|8
suffix:semicolon
id|dma_wd.dma_md
op_assign
(paren
r_int
r_char
)paren
id|paddr
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|paddr
op_rshift_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|EXTD_DMA
)paren
)paren
id|st_dma_ext_dmahi
op_assign
(paren
r_int
r_int
)paren
id|paddr
suffix:semicolon
r_else
id|dma_wd.dma_hi
op_assign
(paren
r_int
r_char
)paren
id|paddr
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Clear FIFO and switch DMA to correct mode */
id|dma_wd.dma_mode_status
op_assign
l_int|0x90
op_or
id|rwflag
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|dma_wd.dma_mode_status
op_assign
l_int|0x90
op_or
(paren
id|rwflag
op_xor
l_int|0x100
)paren
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|dma_wd.dma_mode_status
op_assign
l_int|0x90
op_or
id|rwflag
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* How many sectors for DMA */
id|dma_wd.fdc_acces_seccount
op_assign
id|read_track
ques
c_cond
id|SUDT-&gt;spt
suffix:colon
l_int|1
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
multiline_comment|/* Start operation */
id|dma_wd.dma_mode_status
op_assign
id|FDCSELREG_STP
op_or
id|rwflag
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|SET_IRQ_HANDLER
c_func
(paren
id|fd_rwsec_done
)paren
suffix:semicolon
id|dma_wd.fdc_acces_seccount
op_assign
(paren
id|get_head_settle_flag
c_func
(paren
)paren
op_or
(paren
id|rwflag
ques
c_cond
id|FDCCMD_WRSEC
suffix:colon
(paren
id|FDCCMD_RDSEC
op_or
(paren
id|read_track
ques
c_cond
id|FDCCMDADD_M
suffix:colon
l_int|0
)paren
)paren
)paren
)paren
suffix:semicolon
id|old_motoron
op_assign
id|MotorOn
suffix:semicolon
id|MotorOn
op_assign
l_int|1
suffix:semicolon
id|NeedSeek
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* wait for interrupt */
r_if
c_cond
(paren
id|read_track
)paren
(brace
multiline_comment|/* If reading a whole track, wait about one disk rotation and&n;&t;&t; * then check if all sectors are read. The FDC will even&n;&t;&t; * search for the first non-existent sector and need 1 sec to&n;&t;&t; * recognise that it isn&squot;t present :-(&n;&t;&t; */
id|MultReadInProgress
op_assign
l_int|1
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|readtrack_timer
comma
multiline_comment|/* 1 rot. + 5 rot.s if motor was off  */
id|jiffies
op_plus
id|HZ
op_div
l_int|5
op_plus
(paren
id|old_motoron
ques
c_cond
l_int|0
suffix:colon
id|HZ
)paren
)paren
suffix:semicolon
)brace
id|start_timeout
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fd_readtrack_check
r_static
r_void
id|fd_readtrack_check
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
r_int
id|flags
comma
id|addr
comma
id|addr2
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MultReadInProgress
)paren
(brace
multiline_comment|/* This prevents a race condition that could arise if the&n;&t;&t; * interrupt is triggered while the calling of this timer&n;&t;&t; * callback function takes place. The IRQ function then has&n;&t;&t; * already cleared &squot;MultReadInProgress&squot;  when flow of control&n;&t;&t; * gets here.&n;&t;&t; */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* get the current DMA address */
multiline_comment|/* ++ f.a. read twice to avoid being fooled by switcher */
id|addr
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|addr2
op_assign
id|addr
suffix:semicolon
id|addr
op_assign
id|dma_wd.dma_lo
op_amp
l_int|0xff
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|addr
op_or_assign
(paren
id|dma_wd.dma_md
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|EXTD_DMA
)paren
)paren
id|addr
op_or_assign
(paren
id|st_dma_ext_dmahi
op_amp
l_int|0xffff
)paren
op_lshift
l_int|16
suffix:semicolon
r_else
id|addr
op_or_assign
(paren
id|dma_wd.dma_hi
op_amp
l_int|0xff
)paren
op_lshift
l_int|16
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|addr
op_ne
id|addr2
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
id|addr
op_ge
id|PhysTrackBuffer
op_plus
id|SUDT-&gt;spt
op_star
l_int|512
)paren
(brace
multiline_comment|/* already read enough data, force an FDC interrupt to stop&n;&t;&t; * the read operation&n;&t;&t; */
id|SET_IRQ_HANDLER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|MultReadInProgress
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_readtrack_check(): done&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|FDC_WRITE
c_func
(paren
id|FDCREG_CMD
comma
id|FDCCMD_FORCI
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
multiline_comment|/* No error until now -- the FDC would have interrupted&n;&t;&t; * otherwise!&n;&t;&t; */
id|fd_rwsec_done1
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* not yet finished, wait another tenth rotation */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_readtrack_check(): not yet finished&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|mod_timer
c_func
(paren
op_amp
id|readtrack_timer
comma
id|jiffies
op_plus
id|HZ
op_div
l_int|5
op_div
l_int|10
)paren
suffix:semicolon
)brace
)brace
DECL|function|fd_rwsec_done
r_static
r_void
id|fd_rwsec_done
c_func
(paren
r_int
id|status
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_rwsec_done()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_track
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|readtrack_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MultReadInProgress
)paren
r_return
suffix:semicolon
id|MultReadInProgress
op_assign
l_int|0
suffix:semicolon
)brace
id|fd_rwsec_done1
c_func
(paren
id|status
)paren
suffix:semicolon
)brace
DECL|function|fd_rwsec_done1
r_static
r_void
id|fd_rwsec_done1
c_func
(paren
r_int
id|status
)paren
(brace
r_int
r_int
id|track
suffix:semicolon
id|stop_timeout
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Correct the track if stretch != 0 */
r_if
c_cond
(paren
id|SUDT-&gt;stretch
)paren
(brace
id|track
op_assign
id|FDC_READ
c_func
(paren
id|FDCREG_TRACK
)paren
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|FDC_WRITE
c_func
(paren
id|FDCREG_TRACK
comma
id|track
op_lshift
id|SUDT-&gt;stretch
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|UseTrackbuffer
)paren
(brace
id|dma_wd.dma_mode_status
op_assign
l_int|0x90
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dma_wd.dma_mode_status
op_amp
l_int|0x01
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;fd%d: DMA error&bslash;n&quot;
comma
id|SelectedDrive
)paren
suffix:semicolon
r_goto
id|err_end
suffix:semicolon
)brace
)brace
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReqCmd
op_eq
id|WRITE
op_logical_and
(paren
id|status
op_amp
id|FDCSTAT_WPROT
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;fd%d: is write protected&bslash;n&quot;
comma
id|SelectedDrive
)paren
suffix:semicolon
r_goto
id|err_end
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_amp
id|FDCSTAT_RECNF
)paren
op_logical_and
multiline_comment|/* RECNF is no error after a multiple read when the FDC&n;&t;       searched for a non-existent sector! */
op_logical_neg
(paren
id|read_track
op_logical_and
id|FDC_READ
c_func
(paren
id|FDCREG_SECTOR
)paren
OG
id|SUDT-&gt;spt
)paren
)paren
(brace
r_if
c_cond
(paren
id|Probing
)paren
(brace
r_if
c_cond
(paren
id|SUDT
OG
id|disk_type
)paren
(brace
r_if
c_cond
(paren
id|SUDT
(braket
op_minus
l_int|1
)braket
dot
id|blocks
OG
id|ReqBlock
)paren
(brace
multiline_comment|/* try another disk type */
id|SUDT
op_decrement
suffix:semicolon
id|floppy_sizes
(braket
id|SelectedDrive
)braket
op_assign
id|SUDT-&gt;blocks
op_rshift
l_int|1
suffix:semicolon
)brace
r_else
id|Probing
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|SUD.flags
op_amp
id|FTD_MSG
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;fd%d: Auto-detected floppy type %s&bslash;n&quot;
comma
id|SelectedDrive
comma
id|SUDT-&gt;name
)paren
suffix:semicolon
id|Probing
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* record not found, but not probing. Maybe stretch wrong ? Restart probing */
r_if
c_cond
(paren
id|SUD.autoprobe
)paren
(brace
id|SUDT
op_assign
id|disk_type
op_plus
id|StartDiskType
(braket
id|DriveType
)braket
suffix:semicolon
id|floppy_sizes
(braket
id|SelectedDrive
)braket
op_assign
id|SUDT-&gt;blocks
op_rshift
l_int|1
suffix:semicolon
id|Probing
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|Probing
)paren
(brace
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|FDCSPEED
)paren
)paren
(brace
id|dma_wd.fdc_speed
op_assign
id|SUDT-&gt;fdc_speed
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
)brace
id|setup_req_params
c_func
(paren
id|SelectedDrive
)paren
suffix:semicolon
id|BufferDrive
op_assign
op_minus
l_int|1
suffix:semicolon
id|do_fd_action
c_func
(paren
id|SelectedDrive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;fd%d: sector %d not found (side %d, track %d)&bslash;n&quot;
comma
id|SelectedDrive
comma
id|FDC_READ
(paren
id|FDCREG_SECTOR
)paren
comma
id|ReqSide
comma
id|ReqTrack
)paren
suffix:semicolon
r_goto
id|err_end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|FDCSTAT_CRC
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;fd%d: CRC error (side %d, track %d, sector %d)&bslash;n&quot;
comma
id|SelectedDrive
comma
id|ReqSide
comma
id|ReqTrack
comma
id|FDC_READ
(paren
id|FDCREG_SECTOR
)paren
)paren
suffix:semicolon
r_goto
id|err_end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|FDCSTAT_LOST
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;fd%d: lost data (side %d, track %d, sector %d)&bslash;n&quot;
comma
id|SelectedDrive
comma
id|ReqSide
comma
id|ReqTrack
comma
id|FDC_READ
(paren
id|FDCREG_SECTOR
)paren
)paren
suffix:semicolon
r_goto
id|err_end
suffix:semicolon
)brace
id|Probing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ReqCmd
op_eq
id|READ
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|read_track
)paren
(brace
r_void
op_star
id|addr
suffix:semicolon
id|addr
op_assign
id|ATARIHW_PRESENT
c_func
(paren
id|EXTD_DMA
)paren
ques
c_cond
id|ReqData
suffix:colon
id|DMABuffer
suffix:semicolon
id|dma_cache_maintenance
c_func
(paren
id|virt_to_phys
c_func
(paren
id|addr
)paren
comma
l_int|512
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ATARIHW_PRESENT
c_func
(paren
id|EXTD_DMA
)paren
)paren
id|copy_buffer
(paren
id|addr
comma
id|ReqData
)paren
suffix:semicolon
)brace
r_else
(brace
id|dma_cache_maintenance
c_func
(paren
id|PhysTrackBuffer
comma
id|MaxSectors
(braket
id|DriveType
)braket
op_star
l_int|512
comma
l_int|0
)paren
suffix:semicolon
id|BufferDrive
op_assign
id|SelectedDrive
suffix:semicolon
id|BufferSide
op_assign
id|ReqSide
suffix:semicolon
id|BufferTrack
op_assign
id|ReqTrack
suffix:semicolon
id|copy_buffer
(paren
id|SECTOR_BUFFER
(paren
id|ReqSector
)paren
comma
id|ReqData
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_increment
id|ReqCnt
OL
id|CURRENT-&gt;current_nr_sectors
)paren
(brace
multiline_comment|/* read next sector */
id|setup_req_params
c_func
(paren
id|SelectedDrive
)paren
suffix:semicolon
id|do_fd_action
c_func
(paren
id|SelectedDrive
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* all sectors finished */
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|err_end
suffix:colon
id|BufferDrive
op_assign
op_minus
l_int|1
suffix:semicolon
id|fd_error
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fd_writetrack
r_static
r_void
id|fd_writetrack
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|paddr
comma
id|flags
suffix:semicolon
r_int
r_int
id|track
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_writetrack() Tr=%d Si=%d&bslash;n&quot;
comma
id|ReqTrack
comma
id|ReqSide
)paren
)paren
suffix:semicolon
id|paddr
op_assign
id|PhysTrackBuffer
suffix:semicolon
id|dma_cache_maintenance
c_func
(paren
id|paddr
comma
id|BUFFER_SIZE
comma
l_int|1
)paren
suffix:semicolon
id|fd_select_side
c_func
(paren
id|ReqSide
)paren
suffix:semicolon
multiline_comment|/* Cheat for track if stretch != 0 */
r_if
c_cond
(paren
id|SUDT-&gt;stretch
)paren
(brace
id|track
op_assign
id|FDC_READ
c_func
(paren
id|FDCREG_TRACK
)paren
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|FDC_WRITE
c_func
(paren
id|FDCREG_TRACK
comma
id|track
op_rshift
id|SUDT-&gt;stretch
)paren
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|40
)paren
suffix:semicolon
multiline_comment|/* Setup DMA */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|dma_wd.dma_lo
op_assign
(paren
r_int
r_char
)paren
id|paddr
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|paddr
op_rshift_assign
l_int|8
suffix:semicolon
id|dma_wd.dma_md
op_assign
(paren
r_int
r_char
)paren
id|paddr
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|paddr
op_rshift_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|EXTD_DMA
)paren
)paren
id|st_dma_ext_dmahi
op_assign
(paren
r_int
r_int
)paren
id|paddr
suffix:semicolon
r_else
id|dma_wd.dma_hi
op_assign
(paren
r_int
r_char
)paren
id|paddr
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Clear FIFO and switch DMA to correct mode */
id|dma_wd.dma_mode_status
op_assign
l_int|0x190
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|dma_wd.dma_mode_status
op_assign
l_int|0x90
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
id|dma_wd.dma_mode_status
op_assign
l_int|0x190
suffix:semicolon
id|MFPDELAY
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* How many sectors for DMA */
id|dma_wd.fdc_acces_seccount
op_assign
id|BUFFER_SIZE
op_div
l_int|512
suffix:semicolon
id|udelay
c_func
(paren
l_int|40
)paren
suffix:semicolon
multiline_comment|/* Start operation */
id|dma_wd.dma_mode_status
op_assign
id|FDCSELREG_STP
op_or
l_int|0x100
suffix:semicolon
id|udelay
c_func
(paren
l_int|40
)paren
suffix:semicolon
id|SET_IRQ_HANDLER
c_func
(paren
id|fd_writetrack_done
)paren
suffix:semicolon
id|dma_wd.fdc_acces_seccount
op_assign
id|FDCCMD_WRTRA
op_or
id|get_head_settle_flag
c_func
(paren
)paren
suffix:semicolon
id|MotorOn
op_assign
l_int|1
suffix:semicolon
id|start_timeout
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for interrupt */
)brace
DECL|function|fd_writetrack_done
r_static
r_void
id|fd_writetrack_done
c_func
(paren
r_int
id|status
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_writetrack_done()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stop_timeout
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|FDCSTAT_WPROT
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;fd%d: is write protected&bslash;n&quot;
comma
id|SelectedDrive
)paren
suffix:semicolon
r_goto
id|err_end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|FDCSTAT_LOST
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;fd%d: lost data (side %d, track %d)&bslash;n&quot;
comma
id|SelectedDrive
comma
id|ReqSide
comma
id|ReqTrack
)paren
suffix:semicolon
r_goto
id|err_end
suffix:semicolon
)brace
id|wake_up
c_func
(paren
op_amp
id|format_wait
)paren
suffix:semicolon
r_return
suffix:semicolon
id|err_end
suffix:colon
id|fd_error
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fd_times_out
r_static
r_void
id|fd_times_out
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
id|atari_disable_irq
c_func
(paren
id|IRQ_MFP_FDC
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|FloppyIRQHandler
)paren
r_goto
id|end
suffix:semicolon
multiline_comment|/* int occurred after timer was fired, but&n;&t;&t;&t;&t;&t;  * before we came here... */
id|SET_IRQ_HANDLER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* If the timeout occurred while the readtrack_check timer was&n;&t; * active, we need to cancel it, else bad things will happen */
r_if
c_cond
(paren
id|UseTrackbuffer
)paren
id|del_timer
c_func
(paren
op_amp
id|readtrack_timer
)paren
suffix:semicolon
id|FDC_WRITE
c_func
(paren
id|FDCREG_CMD
comma
id|FDCCMD_FORCI
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;floppy timeout&bslash;n&quot;
)paren
suffix:semicolon
id|fd_error
c_func
(paren
)paren
suffix:semicolon
id|end
suffix:colon
id|atari_enable_irq
c_func
(paren
id|IRQ_MFP_FDC
)paren
suffix:semicolon
)brace
multiline_comment|/* The (noop) seek operation here is needed to make the WP bit in the&n; * FDC status register accessible for check_change. If the last disk&n; * operation would have been a RDSEC, this bit would always read as 0&n; * no matter what :-( To save time, the seek goes to the track we&squot;re&n; * already on.&n; */
DECL|function|finish_fdc
r_static
r_void
id|finish_fdc
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|NeedSeek
)paren
(brace
id|finish_fdc_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;finish_fdc: dummy seek started&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|FDC_WRITE
(paren
id|FDCREG_DATA
comma
id|SUD.track
)paren
suffix:semicolon
id|SET_IRQ_HANDLER
c_func
(paren
id|finish_fdc_done
)paren
suffix:semicolon
id|FDC_WRITE
(paren
id|FDCREG_CMD
comma
id|FDCCMD_SEEK
)paren
suffix:semicolon
id|MotorOn
op_assign
l_int|1
suffix:semicolon
id|start_timeout
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* we must wait for the IRQ here, because the ST-DMA&n;&t;&t;   is released immediately afterwards and the interrupt&n;&t;&t;   may be delivered to the wrong driver. */
)brace
)brace
DECL|function|finish_fdc_done
r_static
r_void
id|finish_fdc_done
c_func
(paren
r_int
id|dummy
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;finish_fdc_done entered&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stop_timeout
c_func
(paren
)paren
suffix:semicolon
id|NeedSeek
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|fd_timer
)paren
op_logical_and
id|time_before
c_func
(paren
id|fd_timer.expires
comma
id|jiffies
op_plus
l_int|5
)paren
)paren
multiline_comment|/* If the check for a disk change is done too early after this&n;&t;&t; * last seek command, the WP bit still reads wrong :-((&n;&t;&t; */
id|mod_timer
c_func
(paren
op_amp
id|fd_timer
comma
id|jiffies
op_plus
l_int|5
)paren
suffix:semicolon
r_else
id|start_check_change_timer
c_func
(paren
)paren
suffix:semicolon
id|start_motor_off_timer
c_func
(paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|stdma_release
c_func
(paren
)paren
suffix:semicolon
id|fdc_busy
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;finish_fdc() finished&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Prevent &quot;aliased&quot; accesses. */
DECL|variable|fd_ref
r_static
r_int
id|fd_ref
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|fd_device
r_static
r_int
id|fd_device
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * Current device number. Taken either from the block header or from the&n; * format request descriptor.&n; */
DECL|macro|CURRENT_DEVICE
mdefine_line|#define CURRENT_DEVICE (CURRENT-&gt;rq_dev)
multiline_comment|/* Current error count. */
DECL|macro|CURRENT_ERRORS
mdefine_line|#define CURRENT_ERRORS (CURRENT-&gt;errors)
multiline_comment|/* dummy for blk.h */
DECL|function|floppy_off
r_static
r_void
id|floppy_off
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
)brace
multiline_comment|/* The detection of disk changes is a dark chapter in Atari history :-(&n; * Because the &quot;Drive ready&quot; signal isn&squot;t present in the Atari&n; * hardware, one has to rely on the &quot;Write Protect&quot;. This works fine,&n; * as long as no write protected disks are used. TOS solves this&n; * problem by introducing tri-state logic (&quot;maybe changed&quot;) and&n; * looking at the serial number in block 0. This isn&squot;t possible for&n; * Linux, since the floppy driver can&squot;t make assumptions about the&n; * filesystem used on the disk and thus the contents of block 0. I&squot;ve&n; * chosen the method to always say &quot;The disk was changed&quot; if it is&n; * unsure whether it was. This implies that every open or mount&n; * invalidates the disk buffers if you work with write protected&n; * disks. But at least this is better than working with incorrect data&n; * due to unrecognised disk changes.&n; */
DECL|function|check_floppy_change
r_static
r_int
id|check_floppy_change
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
r_int
id|drive
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
op_amp
l_int|0x03
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
op_ne
id|MAJOR_NR
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;floppy_changed: not a floppy&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
(paren
id|drive
comma
op_amp
id|fake_change
)paren
)paren
(brace
multiline_comment|/* simulated change (e.g. after formatting) */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
(paren
id|drive
comma
op_amp
id|changed_floppies
)paren
)paren
(brace
multiline_comment|/* surely changed (the WP signal changed at least once) */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|UD.wpstat
)paren
(brace
multiline_comment|/* WP is on -&gt; could be changed: to be sure, buffers should be&n;&t;&t; * invalidated...&n;&t;&t; */
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|floppy_revalidate
r_static
r_int
id|floppy_revalidate
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|drive
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|drive
comma
op_amp
id|changed_floppies
)paren
op_logical_or
id|test_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
op_logical_or
id|unit
(braket
id|drive
)braket
dot
id|disktype
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|UD.flags
op_amp
id|FTD_MSG
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;floppy: clear format %p!&bslash;n&quot;
comma
id|UDT
)paren
suffix:semicolon
id|BufferDrive
op_assign
op_minus
l_int|1
suffix:semicolon
id|clear_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|drive
comma
op_amp
id|changed_floppies
)paren
suffix:semicolon
multiline_comment|/* MSch: clearing geometry makes sense only for autoprobe&n;&t;&t;   formats, for &squot;permanent user-defined&squot; parameter:&n;&t;&t;   restore default_params[] here if flagged valid! */
r_if
c_cond
(paren
id|default_params
(braket
id|drive
)braket
dot
id|blocks
op_eq
l_int|0
)paren
id|UDT
op_assign
l_int|0
suffix:semicolon
r_else
id|UDT
op_assign
op_amp
id|default_params
(braket
id|drive
)braket
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|copy_buffer
r_static
id|__inline__
r_void
id|copy_buffer
c_func
(paren
r_void
op_star
id|from
comma
r_void
op_star
id|to
)paren
(brace
id|ulong
op_star
id|p1
op_assign
(paren
id|ulong
op_star
)paren
id|from
comma
op_star
id|p2
op_assign
(paren
id|ulong
op_star
)paren
id|to
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|512
op_div
l_int|4
suffix:semicolon
id|cnt
suffix:semicolon
id|cnt
op_decrement
)paren
(brace
op_star
id|p2
op_increment
op_assign
op_star
id|p1
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* This sets up the global variables describing the current request. */
DECL|function|setup_req_params
r_static
r_void
id|setup_req_params
c_func
(paren
r_int
id|drive
)paren
(brace
r_int
id|block
op_assign
id|ReqBlock
op_plus
id|ReqCnt
suffix:semicolon
id|ReqTrack
op_assign
id|block
op_div
id|UDT-&gt;spt
suffix:semicolon
id|ReqSector
op_assign
id|block
op_minus
id|ReqTrack
op_star
id|UDT-&gt;spt
op_plus
l_int|1
suffix:semicolon
id|ReqSide
op_assign
id|ReqTrack
op_amp
l_int|1
suffix:semicolon
id|ReqTrack
op_rshift_assign
l_int|1
suffix:semicolon
id|ReqData
op_assign
id|ReqBuffer
op_plus
l_int|512
op_star
id|ReqCnt
suffix:semicolon
r_if
c_cond
(paren
id|UseTrackbuffer
)paren
id|read_track
op_assign
(paren
id|ReqCmd
op_eq
id|READ
op_logical_and
id|CURRENT_ERRORS
op_eq
l_int|0
)paren
suffix:semicolon
r_else
id|read_track
op_assign
l_int|0
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;Request params: Si=%d Tr=%d Se=%d Data=%08lx&bslash;n&quot;
comma
id|ReqSide
comma
id|ReqTrack
comma
id|ReqSector
comma
(paren
r_int
r_int
)paren
id|ReqData
)paren
)paren
suffix:semicolon
)brace
DECL|function|redo_fd_request
r_static
r_void
id|redo_fd_request
c_func
(paren
r_void
)paren
(brace
r_int
id|device
comma
id|drive
comma
id|type
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;redo_fd_request: CURRENT=%08lx CURRENT-&gt;dev=%04x CURRENT-&gt;sector=%ld&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|CURRENT
comma
op_logical_neg
id|QUEUE_EMPTY
ques
c_cond
id|CURRENT-&gt;rq_dev
suffix:colon
l_int|0
comma
op_logical_neg
id|QUEUE_EMPTY
ques
c_cond
id|CURRENT-&gt;sector
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|IsFormatting
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|QUEUE_EMPTY
op_logical_and
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_return
suffix:semicolon
)brace
id|repeat
suffix:colon
r_if
c_cond
(paren
id|QUEUE_EMPTY
)paren
r_goto
id|the_end
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
op_ne
id|MAJOR_NR
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: request list destroyed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;bh
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|CURRENT-&gt;bh
)paren
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
id|device
op_assign
id|MINOR
c_func
(paren
id|CURRENT_DEVICE
)paren
suffix:semicolon
id|drive
op_assign
id|device
op_amp
l_int|3
suffix:semicolon
id|type
op_assign
id|device
op_rshift
l_int|2
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|UD.connected
)paren
(brace
multiline_comment|/* drive not connected */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unknown Device: fd%d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|UDT
)paren
(brace
id|Probing
op_assign
l_int|1
suffix:semicolon
id|UDT
op_assign
id|disk_type
op_plus
id|StartDiskType
(braket
id|DriveType
)braket
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|UDT-&gt;blocks
op_rshift
l_int|1
suffix:semicolon
id|UD.autoprobe
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* user supplied disk type */
r_if
c_cond
(paren
op_decrement
id|type
op_ge
id|NUM_DISK_MINORS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;fd%d: invalid disk format&quot;
comma
id|drive
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|minor2disktype
(braket
id|type
)braket
dot
id|drive_types
OG
id|DriveType
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;fd%d: unsupported disk format&quot;
comma
id|drive
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|type
op_assign
id|minor2disktype
(braket
id|type
)braket
dot
id|index
suffix:semicolon
id|UDT
op_assign
op_amp
id|disk_type
(braket
id|type
)braket
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|UDT-&gt;blocks
op_rshift
l_int|1
suffix:semicolon
id|UD.autoprobe
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT-&gt;sector
op_plus
l_int|1
OG
id|UDT-&gt;blocks
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* stop deselect timer */
id|del_timer
c_func
(paren
op_amp
id|motor_off_timer
)paren
suffix:semicolon
id|ReqCnt
op_assign
l_int|0
suffix:semicolon
id|ReqCmd
op_assign
id|CURRENT-&gt;cmd
suffix:semicolon
id|ReqBlock
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|ReqBuffer
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|setup_req_params
c_func
(paren
id|drive
)paren
suffix:semicolon
id|do_fd_action
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
id|the_end
suffix:colon
id|finish_fdc
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|do_fd_request
r_void
id|do_fd_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;do_fd_request for pid %d&bslash;n&quot;
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fdc_busy
)paren
(brace
id|sleep_on
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
)brace
id|fdc_busy
op_assign
l_int|1
suffix:semicolon
id|stdma_lock
c_func
(paren
id|floppy_irq
comma
l_int|NULL
)paren
suffix:semicolon
id|atari_disable_irq
c_func
(paren
id|IRQ_MFP_FDC
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* The request function is called with ints&n;&t;sti();&t;&t;&t;&t; * disabled... so must save the IPL for later */
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|atari_enable_irq
c_func
(paren
id|IRQ_MFP_FDC
)paren
suffix:semicolon
)brace
DECL|function|invalidate_drive
r_static
r_int
id|invalidate_drive
c_func
(paren
id|kdev_t
id|rdev
)paren
(brace
multiline_comment|/* invalidate the buffer track to force a reread */
id|BufferDrive
op_assign
op_minus
l_int|1
suffix:semicolon
id|set_bit
c_func
(paren
id|MINOR
c_func
(paren
id|rdev
)paren
op_amp
l_int|3
comma
op_amp
id|fake_change
)paren
suffix:semicolon
id|check_disk_change
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fd_ioctl
r_static
r_int
id|fd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|param
)paren
(brace
r_int
id|drive
comma
id|type
suffix:semicolon
id|kdev_t
id|device
suffix:semicolon
r_struct
id|atari_format_descr
id|fmt_desc
suffix:semicolon
r_struct
id|atari_disk_type
op_star
id|dtp
suffix:semicolon
r_struct
id|floppy_struct
id|getprm
suffix:semicolon
r_int
id|settype
suffix:semicolon
r_struct
id|floppy_struct
id|setprm
suffix:semicolon
id|device
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|BLKROSET
suffix:colon
r_case
id|BLKROGET
suffix:colon
r_case
id|BLKRASET
suffix:colon
r_case
id|BLKRAGET
suffix:colon
r_case
id|BLKFLSBUF
suffix:colon
r_return
id|blk_ioctl
c_func
(paren
id|device
comma
id|cmd
comma
id|param
)paren
suffix:semicolon
)brace
id|drive
op_assign
id|MINOR
(paren
id|device
)paren
suffix:semicolon
id|type
op_assign
id|drive
op_rshift
l_int|2
suffix:semicolon
id|drive
op_and_assign
l_int|3
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FDGETPRM
suffix:colon
r_case
id|BLKGETSIZE
suffix:colon
r_if
c_cond
(paren
id|type
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|type
op_ge
id|NUM_DISK_MINORS
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|minor2disktype
(braket
id|type
)braket
dot
id|drive_types
OG
id|DriveType
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|type
op_assign
id|minor2disktype
(braket
id|type
)braket
dot
id|index
suffix:semicolon
id|dtp
op_assign
op_amp
id|disk_type
(braket
id|type
)braket
suffix:semicolon
r_if
c_cond
(paren
id|UD.flags
op_amp
id|FTD_MSG
)paren
id|printk
(paren
id|KERN_ERR
l_string|&quot;floppy%d: found dtp %p name %s!&bslash;n&quot;
comma
id|drive
comma
id|dtp
comma
id|dtp-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|UDT
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_else
id|dtp
op_assign
id|UDT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cmd
op_eq
id|BLKGETSIZE
)paren
r_return
id|put_user
c_func
(paren
id|dtp-&gt;blocks
comma
(paren
r_int
op_star
)paren
id|param
)paren
suffix:semicolon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|getprm
comma
l_int|0
comma
r_sizeof
(paren
id|getprm
)paren
)paren
suffix:semicolon
id|getprm.size
op_assign
id|dtp-&gt;blocks
suffix:semicolon
id|getprm.sect
op_assign
id|dtp-&gt;spt
suffix:semicolon
id|getprm.head
op_assign
l_int|2
suffix:semicolon
id|getprm.track
op_assign
id|dtp-&gt;blocks
op_div
id|dtp-&gt;spt
op_div
l_int|2
suffix:semicolon
id|getprm.stretch
op_assign
id|dtp-&gt;stretch
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|param
comma
op_amp
id|getprm
comma
r_sizeof
(paren
id|getprm
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FDSETPRM
suffix:colon
r_case
id|FDDEFPRM
suffix:colon
multiline_comment|/* &n;&t;&t; * MSch 7/96: simple &squot;set geometry&squot; case: just set the&n;&t;&t; * &squot;default&squot; device params (minor == 0).&n;&t;&t; * Currently, the drive geometry is cleared after each&n;&t;&t; * disk change and subsequent revalidate()! simple&n;&t;&t; * implementation of FDDEFPRM: save geometry from a&n;&t;&t; * FDDEFPRM call and restore it in floppy_revalidate() !&n;&t;&t; */
multiline_comment|/* get the parameters from user space */
r_if
c_cond
(paren
id|fd_ref
(braket
id|drive
)braket
op_ne
l_int|1
op_logical_and
id|fd_ref
(braket
id|drive
)braket
op_ne
op_minus
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|setprm
comma
(paren
r_void
op_star
)paren
id|param
comma
r_sizeof
(paren
id|setprm
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
multiline_comment|/* &n;&t;&t; * first of all: check for floppy change and revalidate, &n;&t;&t; * or the next access will revalidate - and clear UDT :-(&n;&t;&t; */
r_if
c_cond
(paren
id|check_floppy_change
c_func
(paren
id|device
)paren
)paren
id|floppy_revalidate
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UD.flags
op_amp
id|FTD_MSG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;floppy%d: setting size %d spt %d str %d!&bslash;n&quot;
comma
id|drive
comma
id|setprm.size
comma
id|setprm.sect
comma
id|setprm.stretch
)paren
suffix:semicolon
multiline_comment|/* what if type &gt; 0 here? Overwrite specified entry ? */
r_if
c_cond
(paren
id|type
)paren
(brace
multiline_comment|/* refuse to re-set a predefined type for now */
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* &n;&t;&t; * type == 0: first look for a matching entry in the type list,&n;&t;&t; * and set the UD.disktype field to use the perdefined entry.&n;&t;&t; * TODO: add user-defined format to head of autoprobe list ? &n;&t;&t; * Useful to include the user-type for future autodetection!&n;&t;&t; */
r_for
c_loop
(paren
id|settype
op_assign
l_int|0
suffix:semicolon
id|settype
OL
id|NUM_DISK_MINORS
suffix:semicolon
id|settype
op_increment
)paren
(brace
r_int
id|setidx
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|minor2disktype
(braket
id|settype
)braket
dot
id|drive_types
OG
id|DriveType
)paren
(brace
multiline_comment|/* skip this one, invalid for drive ... */
r_continue
suffix:semicolon
)brace
id|setidx
op_assign
id|minor2disktype
(braket
id|settype
)braket
dot
id|index
suffix:semicolon
id|dtp
op_assign
op_amp
id|disk_type
(braket
id|setidx
)braket
suffix:semicolon
multiline_comment|/* found matching entry ?? */
r_if
c_cond
(paren
id|dtp-&gt;blocks
op_eq
id|setprm.size
op_logical_and
id|dtp-&gt;spt
op_eq
id|setprm.sect
op_logical_and
id|dtp-&gt;stretch
op_eq
id|setprm.stretch
)paren
(brace
r_if
c_cond
(paren
id|UD.flags
op_amp
id|FTD_MSG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;floppy%d: setting %s %p!&bslash;n&quot;
comma
id|drive
comma
id|dtp-&gt;name
comma
id|dtp
)paren
suffix:semicolon
id|UDT
op_assign
id|dtp
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|UDT-&gt;blocks
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|FDDEFPRM
)paren
(brace
multiline_comment|/* save settings as permanent default type */
id|default_params
(braket
id|drive
)braket
dot
id|name
op_assign
id|dtp-&gt;name
suffix:semicolon
id|default_params
(braket
id|drive
)braket
dot
id|spt
op_assign
id|dtp-&gt;spt
suffix:semicolon
id|default_params
(braket
id|drive
)braket
dot
id|blocks
op_assign
id|dtp-&gt;blocks
suffix:semicolon
id|default_params
(braket
id|drive
)braket
dot
id|fdc_speed
op_assign
id|dtp-&gt;fdc_speed
suffix:semicolon
id|default_params
(braket
id|drive
)braket
dot
id|stretch
op_assign
id|dtp-&gt;stretch
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* no matching disk type found above - setting user_params */
r_if
c_cond
(paren
id|cmd
op_eq
id|FDDEFPRM
)paren
(brace
multiline_comment|/* set permanent type */
id|dtp
op_assign
op_amp
id|default_params
(braket
id|drive
)braket
suffix:semicolon
)brace
r_else
multiline_comment|/* set user type (reset by disk change!) */
id|dtp
op_assign
op_amp
id|user_params
(braket
id|drive
)braket
suffix:semicolon
id|dtp-&gt;name
op_assign
l_string|&quot;user format&quot;
suffix:semicolon
id|dtp-&gt;blocks
op_assign
id|setprm.size
suffix:semicolon
id|dtp-&gt;spt
op_assign
id|setprm.sect
suffix:semicolon
r_if
c_cond
(paren
id|setprm.sect
OG
l_int|14
)paren
id|dtp-&gt;fdc_speed
op_assign
l_int|3
suffix:semicolon
r_else
id|dtp-&gt;fdc_speed
op_assign
l_int|0
suffix:semicolon
id|dtp-&gt;stretch
op_assign
id|setprm.stretch
suffix:semicolon
r_if
c_cond
(paren
id|UD.flags
op_amp
id|FTD_MSG
)paren
id|printk
(paren
id|KERN_INFO
l_string|&quot;floppy%d: blk %d spt %d str %d!&bslash;n&quot;
comma
id|drive
comma
id|dtp-&gt;blocks
comma
id|dtp-&gt;spt
comma
id|dtp-&gt;stretch
)paren
suffix:semicolon
multiline_comment|/* sanity check */
r_if
c_cond
(paren
op_logical_neg
id|dtp
op_logical_or
id|setprm.track
op_ne
id|dtp-&gt;blocks
op_div
id|dtp-&gt;spt
op_div
l_int|2
op_logical_or
id|setprm.head
op_ne
l_int|2
)paren
(brace
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|UDT
op_assign
id|dtp
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|UDT-&gt;blocks
op_rshift
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDMSGON
suffix:colon
id|UD.flags
op_or_assign
id|FTD_MSG
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDMSGOFF
suffix:colon
id|UD.flags
op_and_assign
op_complement
id|FTD_MSG
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDSETEMSGTRESH
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|FDFMTBEG
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|FDFMTTRK
suffix:colon
r_if
c_cond
(paren
id|fd_ref
(braket
id|drive
)braket
op_ne
l_int|1
op_logical_and
id|fd_ref
(braket
id|drive
)braket
op_ne
op_minus
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|fmt_desc
comma
(paren
r_void
op_star
)paren
id|param
comma
r_sizeof
(paren
id|fmt_desc
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
id|do_format
c_func
(paren
id|device
comma
op_amp
id|fmt_desc
)paren
suffix:semicolon
r_case
id|FDCLRPRM
suffix:colon
id|UDT
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* MSch: invalidate default_params */
id|default_params
(braket
id|drive
)braket
dot
id|blocks
op_assign
l_int|0
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
r_return
id|invalidate_drive
(paren
id|device
)paren
suffix:semicolon
r_case
id|FDFMTEND
suffix:colon
r_case
id|FDFLUSH
suffix:colon
r_return
id|invalidate_drive
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Initialize the &squot;unit&squot; variable for drive &squot;drive&squot; */
DECL|function|fd_probe
r_static
r_void
id|__init
id|fd_probe
c_func
(paren
r_int
id|drive
)paren
(brace
id|UD.connected
op_assign
l_int|0
suffix:semicolon
id|UDT
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd_test_drive_present
c_func
(paren
id|drive
)paren
)paren
r_return
suffix:semicolon
id|UD.connected
op_assign
l_int|1
suffix:semicolon
id|UD.track
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|UserSteprate
(braket
id|drive
)braket
)paren
(brace
r_case
l_int|2
suffix:colon
id|UD.steprate
op_assign
id|FDCSTEP_2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|UD.steprate
op_assign
id|FDCSTEP_3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|6
suffix:colon
id|UD.steprate
op_assign
id|FDCSTEP_6
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|12
suffix:colon
id|UD.steprate
op_assign
id|FDCSTEP_12
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* should be -1 for &quot;not set by user&quot; */
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|FDCSPEED
)paren
op_logical_or
id|MACH_IS_MEDUSA
)paren
id|UD.steprate
op_assign
id|FDCSTEP_3
suffix:semicolon
r_else
id|UD.steprate
op_assign
id|FDCSTEP_6
suffix:semicolon
r_break
suffix:semicolon
)brace
id|MotorOn
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* from probe restore operation! */
)brace
multiline_comment|/* This function tests the physical presence of a floppy drive (not&n; * whether a disk is inserted). This is done by issuing a restore&n; * command, waiting max. 2 seconds (that should be enough to move the&n; * head across the whole disk) and looking at the state of the &quot;TR00&quot;&n; * signal. This should now be raised if there is a drive connected&n; * (and there is no hardware failure :-) Otherwise, the drive is&n; * declared absent.&n; */
DECL|function|fd_test_drive_present
r_static
r_int
id|__init
id|fd_test_drive_present
c_func
(paren
r_int
id|drive
)paren
(brace
r_int
r_int
id|timeout
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
id|ok
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_ge
(paren
id|MACH_IS_FALCON
ques
c_cond
l_int|1
suffix:colon
l_int|2
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|fd_select_drive
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* disable interrupt temporarily */
id|atari_turnoff_irq
c_func
(paren
id|IRQ_MFP_FDC
)paren
suffix:semicolon
id|FDC_WRITE
(paren
id|FDCREG_TRACK
comma
l_int|0xff00
)paren
suffix:semicolon
id|FDC_WRITE
c_func
(paren
id|FDCREG_CMD
comma
id|FDCCMD_RESTORE
op_or
id|FDCCMDADD_H
op_or
id|FDCSTEP_6
)paren
suffix:semicolon
id|timeout
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
op_plus
id|HZ
op_div
l_int|2
suffix:semicolon
r_while
c_loop
(paren
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|mfp.par_dt_reg
op_amp
l_int|0x20
)paren
)paren
r_break
suffix:semicolon
id|status
op_assign
id|FDC_READ
c_func
(paren
id|FDCREG_STATUS
)paren
suffix:semicolon
id|ok
op_assign
(paren
id|status
op_amp
id|FDCSTAT_TR00
)paren
op_ne
l_int|0
suffix:semicolon
multiline_comment|/* force interrupt to abort restore operation (FDC would try&n;&t; * about 50 seconds!) */
id|FDC_WRITE
c_func
(paren
id|FDCREG_CMD
comma
id|FDCCMD_FORCI
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
id|status
op_assign
id|FDC_READ
c_func
(paren
id|FDCREG_STATUS
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ok
)paren
(brace
multiline_comment|/* dummy seek command to make WP bit accessible */
id|FDC_WRITE
c_func
(paren
id|FDCREG_DATA
comma
l_int|0
)paren
suffix:semicolon
id|FDC_WRITE
c_func
(paren
id|FDCREG_CMD
comma
id|FDCCMD_SEEK
)paren
suffix:semicolon
r_while
c_loop
(paren
id|mfp.par_dt_reg
op_amp
l_int|0x20
)paren
(brace
suffix:semicolon
)brace
id|status
op_assign
id|FDC_READ
c_func
(paren
id|FDCREG_STATUS
)paren
suffix:semicolon
)brace
id|atari_turnon_irq
c_func
(paren
id|IRQ_MFP_FDC
)paren
suffix:semicolon
r_return
id|ok
suffix:semicolon
)brace
multiline_comment|/* Look how many and which kind of drives are connected. If there are&n; * floppies, additionally start the disk-change and motor-off timers.&n; */
DECL|function|config_types
r_static
r_void
id|__init
id|config_types
c_func
(paren
r_void
)paren
(brace
r_int
id|drive
comma
id|cnt
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* for probing drives, set the FDC speed to 8 MHz */
r_if
c_cond
(paren
id|ATARIHW_PRESENT
c_func
(paren
id|FDCSPEED
)paren
)paren
id|dma_wd.fdc_speed
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Probing floppy drive(s):&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|FD_MAX_UNITS
suffix:semicolon
id|drive
op_increment
)paren
(brace
id|fd_probe
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UD.connected
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;fd%d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
op_increment
id|cnt
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|FDC_READ
c_func
(paren
id|FDCREG_STATUS
)paren
op_amp
id|FDCSTAT_BUSY
)paren
(brace
multiline_comment|/* If FDC is still busy from probing, give it another FORCI&n;&t;&t; * command to abort the operation. If this isn&squot;t done, the FDC&n;&t;&t; * will interrupt later and its IRQ line stays low, because&n;&t;&t; * the status register isn&squot;t read. And this will block any&n;&t;&t; * interrupts on this IRQ line :-(&n;&t;&t; */
id|FDC_WRITE
c_func
(paren
id|FDCREG_CMD
comma
id|FDCCMD_FORCI
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
id|FDC_READ
c_func
(paren
id|FDCREG_STATUS
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cnt
OG
l_int|0
)paren
(brace
id|start_motor_off_timer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_eq
l_int|1
)paren
id|fd_select_drive
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|start_check_change_timer
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * floppy_open check for aliasing (/dev/fd0 can be the same as&n; * /dev/PS0 etc), and disallows simultaneous access to the same&n; * drive with different device numbers.&n; */
DECL|function|floppy_open
r_static
r_int
id|floppy_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|drive
comma
id|type
suffix:semicolon
r_int
id|old_dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
(brace
id|DPRINT
(paren
(paren
l_string|&quot;Weird, open called with filp=0&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|drive
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
l_int|3
suffix:semicolon
id|type
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
l_int|2
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_open: type=%d&bslash;n&quot;
comma
id|type
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_ge
id|FD_MAX_UNITS
op_logical_or
id|type
OG
id|NUM_DISK_MINORS
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|old_dev
op_assign
id|fd_device
(braket
id|drive
)braket
suffix:semicolon
r_if
c_cond
(paren
id|fd_ref
(braket
id|drive
)braket
op_logical_and
id|old_dev
op_ne
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|fd_ref
(braket
id|drive
)braket
op_eq
op_minus
l_int|1
op_logical_or
(paren
id|fd_ref
(braket
id|drive
)braket
op_logical_and
id|filp-&gt;f_flags
op_amp
id|O_EXCL
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_EXCL
)paren
id|fd_ref
(braket
id|drive
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|fd_ref
(braket
id|drive
)braket
op_increment
suffix:semicolon
id|fd_device
(braket
id|drive
)braket
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_dev
op_logical_and
id|old_dev
op_ne
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
id|invalidate_buffers
c_func
(paren
id|MKDEV
c_func
(paren
id|FLOPPY_MAJOR
comma
id|old_dev
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NDELAY
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
(brace
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|UD.wpstat
)paren
(brace
id|floppy_release
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|floppy_release
r_static
r_int
id|floppy_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|drive
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|fd_ref
(braket
id|drive
)braket
OL
l_int|0
)paren
id|fd_ref
(braket
id|drive
)braket
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|fd_ref
(braket
id|drive
)braket
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;floppy_release with fd_ref == 0&quot;
)paren
suffix:semicolon
id|fd_ref
(braket
id|drive
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|floppy_fops
r_static
r_struct
id|block_device_operations
id|floppy_fops
op_assign
(brace
id|open
suffix:colon
id|floppy_open
comma
id|release
suffix:colon
id|floppy_release
comma
id|ioctl
suffix:colon
id|fd_ioctl
comma
id|check_media_change
suffix:colon
id|check_floppy_change
comma
id|revalidate
suffix:colon
id|floppy_revalidate
comma
)brace
suffix:semicolon
DECL|function|atari_floppy_init
r_int
id|__init
id|atari_floppy_init
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MACH_IS_ATARI
)paren
multiline_comment|/* Amiga, Mac, ... don&squot;t have Atari-compatible floppy :-) */
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|MACH_IS_HADES
)paren
multiline_comment|/* Hades doesn&squot;t have Atari-compatible floppy */
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
comma
op_amp
id|floppy_fops
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to get major %d for floppy&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|UseTrackbuffer
OL
l_int|0
)paren
multiline_comment|/* not set by user -&gt; use default: for now, we turn&n;&t;&t;   track buffering off for all Medusas, though it&n;&t;&t;   could be used with ones that have a counter&n;&t;&t;   card. But the test is too hard :-( */
id|UseTrackbuffer
op_assign
op_logical_neg
id|MACH_IS_MEDUSA
suffix:semicolon
multiline_comment|/* initialize variables */
id|SelectedDrive
op_assign
op_minus
l_int|1
suffix:semicolon
id|BufferDrive
op_assign
op_minus
l_int|1
suffix:semicolon
id|DMABuffer
op_assign
id|atari_stram_alloc
c_func
(paren
id|BUFFER_SIZE
op_plus
l_int|512
comma
l_string|&quot;ataflop&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DMABuffer
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;atari_floppy_init: cannot get dma buffer&bslash;n&quot;
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
id|TrackBuffer
op_assign
id|DMABuffer
op_plus
l_int|512
suffix:semicolon
id|PhysDMABuffer
op_assign
id|virt_to_phys
c_func
(paren
id|DMABuffer
)paren
suffix:semicolon
id|PhysTrackBuffer
op_assign
id|virt_to_phys
c_func
(paren
id|TrackBuffer
)paren
suffix:semicolon
id|BufferDrive
op_assign
id|BufferSide
op_assign
id|BufferTrack
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FD_MAX_UNITS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|unit
(braket
id|i
)braket
dot
id|track
op_assign
op_minus
l_int|1
suffix:semicolon
id|unit
(braket
id|i
)braket
dot
id|flags
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|i
op_rshift
l_int|2
)paren
OG
l_int|0
op_logical_and
(paren
id|i
op_rshift
l_int|2
)paren
op_le
id|NUM_DISK_MINORS
)paren
(brace
r_int
id|type
op_assign
id|minor2disktype
(braket
(paren
id|i
op_rshift
l_int|2
)paren
op_minus
l_int|1
)braket
dot
id|index
suffix:semicolon
id|floppy_sizes
(braket
id|i
)braket
op_assign
id|disk_type
(braket
id|type
)braket
dot
id|blocks
op_rshift
l_int|1
suffix:semicolon
)brace
r_else
id|floppy_sizes
(braket
id|i
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|floppy_sizes
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|floppy_blocksizes
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|DEVICE_REQUEST
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Atari floppy driver: max. %cD, %strack buffering&bslash;n&quot;
comma
id|DriveType
op_eq
l_int|0
ques
c_cond
l_char|&squot;D&squot;
suffix:colon
id|DriveType
op_eq
l_int|1
ques
c_cond
l_char|&squot;H&squot;
suffix:colon
l_char|&squot;E&squot;
comma
id|UseTrackbuffer
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;no &quot;
)paren
suffix:semicolon
id|config_types
c_func
(paren
)paren
suffix:semicolon
(paren
r_void
)paren
id|do_floppy
suffix:semicolon
multiline_comment|/* avoid warning about unused variable */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|atari_floppy_setup
r_void
id|__init
id|atari_floppy_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OL
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ataflop_setup: no arguments!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|2
op_plus
id|FD_MAX_UNITS
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ataflop_setup: too many arguments&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|1
)braket
template_param
l_int|2
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ataflop_setup: bad drive type&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|DriveType
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ge
l_int|2
)paren
id|UseTrackbuffer
op_assign
(paren
id|ints
(braket
l_int|2
)braket
OG
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|3
suffix:semicolon
id|i
op_le
id|ints
(braket
l_int|0
)braket
op_logical_and
id|i
op_minus
l_int|3
OL
id|FD_MAX_UNITS
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
id|i
)braket
op_ne
l_int|2
op_logical_and
id|ints
(braket
id|i
)braket
op_ne
l_int|3
op_logical_and
id|ints
(braket
id|i
)braket
op_ne
l_int|6
op_logical_and
id|ints
(braket
id|i
)braket
op_ne
l_int|12
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ataflop_setup: bad steprate&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|UserSteprate
(braket
id|i
op_minus
l_int|3
)braket
op_assign
id|ints
(braket
id|i
)braket
suffix:semicolon
)brace
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|MACH_IS_ATARI
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_return
id|atari_floppy_init
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
(paren
r_void
)paren
(brace
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
id|atari_stram_free
c_func
(paren
id|DMABuffer
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
