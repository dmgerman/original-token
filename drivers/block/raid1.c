multiline_comment|/************************************************************************&n; * raid1.c : Multiple Devices driver for Linux&n; *           Copyright (C) 1996 Ingo Molnar, Miguel de Icaza, Gadi Oxman&n; *&n; * RAID-1 management functions.&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * You should have received a copy of the GNU General Public License&n; * (for example /usr/src/linux/COPYING); if not, write to the Free&n; * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/md.h&gt;
macro_line|#include &lt;linux/raid1.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/atomic.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR MD_MAJOR
DECL|macro|MD_DRIVER
mdefine_line|#define MD_DRIVER
DECL|macro|MD_PERSONALITY
mdefine_line|#define MD_PERSONALITY
multiline_comment|/*&n; * The following can be used to debug the driver&n; */
multiline_comment|/*#define RAID1_DEBUG*/
macro_line|#ifdef RAID1_DEBUG
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x)   do { printk x; } while (0);
macro_line|#else
DECL|macro|PRINTK
mdefine_line|#define PRINTK(x)   do { ; } while (0);
macro_line|#endif
DECL|macro|MAX
mdefine_line|#define MAX(a,b)&t;((a) &gt; (b) ? (a) : (b))
DECL|macro|MIN
mdefine_line|#define MIN(a,b)&t;((a) &lt; (b) ? (a) : (b))
DECL|variable|raid1_personality
r_static
r_struct
id|md_personality
id|raid1_personality
suffix:semicolon
DECL|variable|raid1_thread
r_static
r_struct
id|md_thread
op_star
id|raid1_thread
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|raid1_retry_list
r_struct
id|buffer_head
op_star
id|raid1_retry_list
op_assign
l_int|NULL
suffix:semicolon
DECL|function|__raid1_map
r_static
r_int
id|__raid1_map
(paren
r_struct
id|md_dev
op_star
id|mddev
comma
id|kdev_t
op_star
id|rdev
comma
r_int
r_int
op_star
id|rsector
comma
r_int
r_int
id|size
)paren
(brace
r_struct
id|raid1_data
op_star
id|raid_conf
op_assign
(paren
r_struct
id|raid1_data
op_star
)paren
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|i
comma
id|n
op_assign
id|raid_conf-&gt;raid_disks
suffix:semicolon
multiline_comment|/*&n;&t; * Later we do read balancing on the read side &n;&t; * now we use the first available disk.&n;&t; */
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1_map().&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|raid_conf-&gt;mirrors
(braket
id|i
)braket
dot
id|operational
)paren
(brace
op_star
id|rdev
op_assign
id|raid_conf-&gt;mirrors
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;raid1_map(): huh, no more operational devices?&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
op_minus
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|raid1_map
r_static
r_int
id|raid1_map
(paren
r_struct
id|md_dev
op_star
id|mddev
comma
id|kdev_t
op_star
id|rdev
comma
r_int
r_int
op_star
id|rsector
comma
r_int
r_int
id|size
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|raid1_reschedule_retry
r_void
id|raid1_reschedule_retry
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|raid1_bh
op_star
id|r1_bh
op_assign
(paren
r_struct
id|raid1_bh
op_star
)paren
(paren
id|bh-&gt;b_dev_id
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1_reschedule_retry().&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|r1_bh-&gt;next_retry
op_assign
id|raid1_retry_list
suffix:semicolon
id|raid1_retry_list
op_assign
id|bh
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|raid1_thread
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * raid1_end_buffer_io() is called when we have finished servicing a mirrored&n; * operation and are ready to return a success/failure code to the buffer&n; * cache layer.&n; */
DECL|function|raid1_end_buffer_io
r_static
r_inline
r_void
id|raid1_end_buffer_io
c_func
(paren
r_struct
id|raid1_bh
op_star
id|r1_bh
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|r1_bh-&gt;master_bh
suffix:semicolon
id|bh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|r1_bh
)paren
suffix:semicolon
)brace
DECL|variable|raid1_one_error
r_int
id|raid1_one_error
op_assign
l_int|0
suffix:semicolon
DECL|function|raid1_end_request
r_void
id|raid1_end_request
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
r_struct
id|raid1_bh
op_star
id|r1_bh
op_assign
(paren
r_struct
id|raid1_bh
op_star
)paren
(paren
id|bh-&gt;b_dev_id
)paren
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1_end_request().&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raid1_one_error
)paren
(brace
id|raid1_one_error
op_assign
l_int|0
suffix:semicolon
id|uptodate
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * this branch is our &squot;one mirror IO has finished&squot; event handler:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|md_error
(paren
id|bh-&gt;b_dev
comma
id|bh-&gt;b_rdev
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/*&n;&t;&t; * Set BH_Uptodate in our master buffer_head, so that&n;&t;&t; * we will return a good error code for to the higher&n;&t;&t; * levels even if IO on some other mirrored buffer fails.&n;&t;&t; *&n;&t;&t; * The &squot;master&squot; represents the complex operation to &n;&t;&t; * user-side. So if something waits for IO, then it will&n;&t;&t; * wait for the &squot;master&squot; buffer_head.&n;&t;&t; */
id|set_bit
(paren
id|BH_Uptodate
comma
op_amp
id|r1_bh-&gt;state
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We split up the read and write side, imho they are &n;&t; * conceptually different.&n;&t; */
r_if
c_cond
(paren
(paren
id|r1_bh-&gt;cmd
op_eq
id|READ
)paren
op_logical_or
(paren
id|r1_bh-&gt;cmd
op_eq
id|READA
)paren
)paren
(brace
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1_end_request(), read branch.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * we have only one buffer_head on the read side&n;&t;&t; */
r_if
c_cond
(paren
id|uptodate
)paren
(brace
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1_end_request(), read branch, uptodate.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|raid1_end_buffer_io
c_func
(paren
id|r1_bh
comma
id|uptodate
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * oops, read error:&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: %s: rescheduling block %lu&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|bh-&gt;b_dev
)paren
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|raid1_reschedule_retry
(paren
id|bh
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * WRITE or WRITEA.&n;&t; */
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1_end_request(), write branch.&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Let&squot;s see if all mirrored write operations have finished &n;&t; * already [we have irqs off, so we can decrease]:&n;&t; */
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|r1_bh-&gt;remaining
)paren
(brace
r_struct
id|md_dev
op_star
id|mddev
op_assign
id|r1_bh-&gt;mddev
suffix:semicolon
r_struct
id|raid1_data
op_star
id|raid_conf
op_assign
(paren
r_struct
id|raid1_data
op_star
)paren
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|i
comma
id|n
op_assign
id|raid_conf-&gt;raid_disks
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1_end_request(), remaining == 0.&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|r1_bh-&gt;mirror_bh
(braket
id|i
)braket
)paren
id|kfree
c_func
(paren
id|r1_bh-&gt;mirror_bh
(braket
id|i
)braket
)paren
suffix:semicolon
id|raid1_end_buffer_io
c_func
(paren
id|r1_bh
comma
id|test_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|r1_bh-&gt;state
)paren
)paren
suffix:semicolon
)brace
r_else
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1_end_request(), remaining == %u.&bslash;n&quot;
comma
id|r1_bh-&gt;remaining
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* This routine checks if the undelying device is an md device and in that&n; * case it maps the blocks before putting the request on the queue&n; */
r_static
r_inline
r_void
DECL|function|map_and_make_request
id|map_and_make_request
(paren
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
id|MAJOR
(paren
id|bh-&gt;b_rdev
)paren
op_eq
id|MD_MAJOR
)paren
id|md_map
(paren
id|MINOR
(paren
id|bh-&gt;b_rdev
)paren
comma
op_amp
id|bh-&gt;b_rdev
comma
op_amp
id|bh-&gt;b_rsector
comma
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Lock
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
id|make_request
(paren
id|MAJOR
(paren
id|bh-&gt;b_rdev
)paren
comma
id|rw
comma
id|bh
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|raid1_make_request
id|raid1_make_request
(paren
r_struct
id|md_dev
op_star
id|mddev
comma
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_struct
id|raid1_data
op_star
id|raid_conf
op_assign
(paren
r_struct
id|raid1_data
op_star
)paren
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|buffer_head
op_star
id|mirror_bh
(braket
id|MD_SB_DISKS
)braket
comma
op_star
id|bh_req
suffix:semicolon
r_struct
id|raid1_bh
op_star
id|r1_bh
suffix:semicolon
r_int
id|n
op_assign
id|raid_conf-&gt;raid_disks
comma
id|i
comma
id|sum_bhs
op_assign
l_int|0
comma
id|switch_disks
op_assign
l_int|0
comma
id|sectors
suffix:semicolon
r_struct
id|mirror_info
op_star
id|mirror
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1_make_request().&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
(paren
multiline_comment|/* FIXME: now we are rather fault tolerant than nice */
id|r1_bh
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|raid1_bh
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
id|printk
(paren
l_string|&quot;raid1_make_request(#1): out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|memset
(paren
id|r1_bh
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|raid1_bh
)paren
)paren
suffix:semicolon
multiline_comment|/*&n; * make_request() can abort the operation when READA or WRITEA are being&n; * used and no empty request is available.&n; *&n; * Currently, just replace the command with READ/WRITE.&n; */
r_if
c_cond
(paren
id|rw
op_eq
id|READA
)paren
id|rw
op_assign
id|READ
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|WRITEA
)paren
id|rw
op_assign
id|WRITE
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
op_logical_or
id|rw
op_eq
id|WRITEA
)paren
id|mark_buffer_clean
c_func
(paren
id|bh
)paren
suffix:semicolon
multiline_comment|/* Too early ? */
multiline_comment|/*&n; * i think the read and write branch should be separated completely, since we want&n; * to do read balancing on the read side for example. Comments? :) --mingo&n; */
id|r1_bh-&gt;master_bh
op_assign
id|bh
suffix:semicolon
id|r1_bh-&gt;mddev
op_assign
id|mddev
suffix:semicolon
id|r1_bh-&gt;cmd
op_assign
id|rw
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|READ
op_logical_or
id|rw
op_eq
id|READA
)paren
(brace
r_int
id|last_used
op_assign
id|raid_conf-&gt;last_used
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1_make_request(), read branch.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|mirror
op_assign
id|raid_conf-&gt;mirrors
op_plus
id|last_used
suffix:semicolon
id|bh-&gt;b_rdev
op_assign
id|mirror-&gt;dev
suffix:semicolon
id|sectors
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_blocknr
op_star
id|sectors
op_eq
id|raid_conf-&gt;next_sect
)paren
(brace
id|raid_conf-&gt;sect_count
op_add_assign
id|sectors
suffix:semicolon
r_if
c_cond
(paren
id|raid_conf-&gt;sect_count
op_ge
id|mirror-&gt;sect_limit
)paren
id|switch_disks
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|switch_disks
op_assign
l_int|1
suffix:semicolon
id|raid_conf-&gt;next_sect
op_assign
(paren
id|bh-&gt;b_blocknr
op_plus
l_int|1
)paren
op_star
id|sectors
suffix:semicolon
r_if
c_cond
(paren
id|switch_disks
)paren
(brace
id|PRINTK
c_func
(paren
(paren
l_string|&quot;read-balancing: switching %d -&gt; %d (%d sectors)&bslash;n&quot;
comma
id|last_used
comma
id|mirror-&gt;next
comma
id|raid_conf-&gt;sect_count
)paren
)paren
suffix:semicolon
id|raid_conf-&gt;sect_count
op_assign
l_int|0
suffix:semicolon
id|last_used
op_assign
id|raid_conf-&gt;last_used
op_assign
id|mirror-&gt;next
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Do not switch to write-only disks ... resyncing&n;&t;&t;&t; * is in progress&n;&t;&t;&t; */
r_while
c_loop
(paren
id|raid_conf-&gt;mirrors
(braket
id|last_used
)braket
dot
id|write_only
)paren
id|raid_conf-&gt;last_used
op_assign
id|raid_conf-&gt;mirrors
(braket
id|last_used
)braket
dot
id|next
suffix:semicolon
)brace
id|PRINTK
(paren
(paren
l_string|&quot;raid1 read queue: %d %d&bslash;n&quot;
comma
id|MAJOR
(paren
id|bh-&gt;b_rdev
)paren
comma
id|MINOR
(paren
id|bh-&gt;b_rdev
)paren
)paren
)paren
suffix:semicolon
id|bh_req
op_assign
op_amp
id|r1_bh-&gt;bh_req
suffix:semicolon
id|memcpy
c_func
(paren
id|bh_req
comma
id|bh
comma
r_sizeof
(paren
op_star
id|bh
)paren
)paren
suffix:semicolon
id|bh_req-&gt;b_end_io
op_assign
id|raid1_end_request
suffix:semicolon
id|bh_req-&gt;b_dev_id
op_assign
id|r1_bh
suffix:semicolon
id|map_and_make_request
(paren
id|rw
comma
id|bh_req
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * WRITE or WRITEA.&n;&t; */
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1_make_request(n=%d), write branch.&bslash;n&quot;
comma
id|n
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|raid_conf-&gt;mirrors
(braket
id|i
)braket
dot
id|operational
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * the r1_bh-&gt;mirror_bh[i] pointer remains NULL&n;&t;&t;&t; */
id|mirror_bh
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We should use a private pool (size depending on NR_REQUEST),&n;&t; * to avoid writes filling up the memory with bhs&n;&t; *&n;&t; * Such pools are much faster than kmalloc anyways (so we waste almost &n;&t; * nothing by not using the master bh when writing and win alot of cleanness)&n;&t; *&n;&t; * but for now we are cool enough. --mingo&n;&t; *&n;&t; * It&squot;s safe to sleep here, buffer heads cannot be used in a shared&n;&t; * manner in the write branch. Look how we lock the buffer at the beginning&n;&t; * of this function to grok the difference ;)&n;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
multiline_comment|/* FIXME: now we are rather fault tolerant than nice */
id|mirror_bh
(braket
id|i
)braket
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|buffer_head
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
id|printk
(paren
l_string|&quot;raid1_make_request(#2): out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|memset
(paren
id|mirror_bh
(braket
id|i
)braket
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|buffer_head
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * prepare mirrored bh (fields ordered for max mem throughput):&n;&t; */
id|mirror_bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_blocknr
op_assign
id|bh-&gt;b_blocknr
suffix:semicolon
id|mirror_bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_dev
op_assign
id|bh-&gt;b_dev
suffix:semicolon
id|mirror_bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_rdev
op_assign
id|raid_conf-&gt;mirrors
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
id|mirror_bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_rsector
op_assign
id|bh-&gt;b_rsector
suffix:semicolon
id|mirror_bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_state
op_assign
(paren
l_int|1
op_lshift
id|BH_Req
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Touched
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Dirty
)paren
suffix:semicolon
id|mirror_bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_count
op_assign
l_int|1
suffix:semicolon
id|mirror_bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_size
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|mirror_bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_data
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|mirror_bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_list
op_assign
id|BUF_LOCKED
suffix:semicolon
id|mirror_bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_end_io
op_assign
id|raid1_end_request
suffix:semicolon
id|mirror_bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_dev_id
op_assign
id|r1_bh
suffix:semicolon
id|r1_bh-&gt;mirror_bh
(braket
id|i
)braket
op_assign
id|mirror_bh
(braket
id|i
)braket
suffix:semicolon
id|sum_bhs
op_increment
suffix:semicolon
)brace
id|r1_bh-&gt;remaining
op_assign
id|sum_bhs
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1_make_request(), write branch, sum_bhs=%d.&bslash;n&quot;
comma
id|sum_bhs
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * We have to be a bit careful about the semaphore above, thats why we&n;&t; * start the requests separately. Since kmalloc() could fail, sleep and&n;&t; * make_request() can sleep too, this is the safer solution. Imagine,&n;&t; * end_request decreasing the semaphore before we could have set it up ...&n;&t; * We could play tricks with the semaphore (presetting it and correcting&n;&t; * at the end if sum_bhs is not &squot;n&squot; but we have to do end_request by hand&n;&t; * if all requests finish until we had a chance to set up the semaphore&n;&t; * correctly ... lots of races).&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|mirror_bh
(braket
id|i
)braket
op_ne
l_int|NULL
)paren
id|map_and_make_request
(paren
id|rw
comma
id|mirror_bh
(braket
id|i
)braket
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|raid1_status
r_static
r_int
id|raid1_status
(paren
r_char
op_star
id|page
comma
r_int
id|minor
comma
r_struct
id|md_dev
op_star
id|mddev
)paren
(brace
r_struct
id|raid1_data
op_star
id|raid_conf
op_assign
(paren
r_struct
id|raid1_data
op_star
)paren
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_int
id|sz
op_assign
l_int|0
comma
id|i
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot; [%d/%d] [&quot;
comma
id|raid_conf-&gt;raid_disks
comma
id|raid_conf-&gt;working_disks
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|raid_conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;%s&quot;
comma
id|raid_conf-&gt;mirrors
(braket
id|i
)braket
dot
id|operational
ques
c_cond
l_string|&quot;U&quot;
suffix:colon
l_string|&quot;_&quot;
)paren
suffix:semicolon
id|sz
op_add_assign
id|sprintf
(paren
id|page
op_plus
id|sz
comma
l_string|&quot;]&quot;
)paren
suffix:semicolon
r_return
id|sz
suffix:semicolon
)brace
DECL|function|raid1_fix_links
r_static
r_void
id|raid1_fix_links
(paren
r_struct
id|raid1_data
op_star
id|raid_conf
comma
r_int
id|failed_index
)paren
(brace
r_int
id|disks
op_assign
id|raid_conf-&gt;raid_disks
suffix:semicolon
r_int
id|j
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|disks
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|raid_conf-&gt;mirrors
(braket
id|j
)braket
dot
id|next
op_eq
id|failed_index
)paren
id|raid_conf-&gt;mirrors
(braket
id|j
)braket
dot
id|next
op_assign
id|raid_conf-&gt;mirrors
(braket
id|failed_index
)braket
dot
id|next
suffix:semicolon
)brace
DECL|macro|LAST_DISK
mdefine_line|#define LAST_DISK KERN_ALERT &bslash;&n;&quot;raid1: only one disk left and IO error.&bslash;n&quot;
DECL|macro|NO_SPARE_DISK
mdefine_line|#define NO_SPARE_DISK KERN_ALERT &bslash;&n;&quot;raid1: no spare disk left, degrading mirror level by one.&bslash;n&quot;
DECL|macro|DISK_FAILED
mdefine_line|#define DISK_FAILED KERN_ALERT &bslash;&n;&quot;raid1: Disk failure on %s, disabling device. &bslash;n&quot; &bslash;&n;&quot;       Operation continuing on %d devices&bslash;n&quot;
DECL|macro|START_SYNCING
mdefine_line|#define START_SYNCING KERN_ALERT &bslash;&n;&quot;raid1: start syncing spare disk.&bslash;n&quot;
DECL|macro|ALREADY_SYNCING
mdefine_line|#define ALREADY_SYNCING KERN_INFO &bslash;&n;&quot;raid1: syncing already in progress.&bslash;n&quot;
DECL|function|raid1_error
r_static
r_int
id|raid1_error
(paren
r_struct
id|md_dev
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
r_struct
id|raid1_data
op_star
id|raid_conf
op_assign
(paren
r_struct
id|raid1_data
op_star
)paren
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|mirror_info
op_star
id|mirror
suffix:semicolon
id|md_superblock_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
r_int
id|disks
op_assign
id|raid_conf-&gt;raid_disks
suffix:semicolon
r_int
id|i
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1_error called&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raid_conf-&gt;working_disks
op_eq
l_int|1
)paren
(brace
multiline_comment|/*&n;&t;&t; * Uh oh, we can do nothing if this is our last disk, but&n;&t;&t; * first check if this is a queued request for a device&n;&t;&t; * which has just failed.&n;&t;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mirror
op_assign
id|raid_conf-&gt;mirrors
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
comma
id|mirror
op_increment
)paren
r_if
c_cond
(paren
id|mirror-&gt;dev
op_eq
id|dev
op_logical_and
op_logical_neg
id|mirror-&gt;operational
)paren
r_return
l_int|0
suffix:semicolon
id|printk
(paren
id|LAST_DISK
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Mark disk as unusable */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mirror
op_assign
id|raid_conf-&gt;mirrors
suffix:semicolon
id|i
OL
id|disks
suffix:semicolon
id|i
op_increment
comma
id|mirror
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mirror-&gt;dev
op_eq
id|dev
op_logical_and
id|mirror-&gt;operational
)paren
(brace
id|mirror-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|raid1_fix_links
(paren
id|raid_conf
comma
id|i
)paren
suffix:semicolon
id|sb-&gt;disks
(braket
id|mirror-&gt;number
)braket
dot
id|state
op_or_assign
(paren
l_int|1
op_lshift
id|MD_FAULTY_DEVICE
)paren
suffix:semicolon
id|sb-&gt;disks
(braket
id|mirror-&gt;number
)braket
dot
id|state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|MD_SYNC_DEVICE
)paren
suffix:semicolon
id|sb-&gt;disks
(braket
id|mirror-&gt;number
)braket
dot
id|state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|MD_ACTIVE_DEVICE
)paren
suffix:semicolon
id|sb-&gt;active_disks
op_decrement
suffix:semicolon
id|sb-&gt;working_disks
op_decrement
suffix:semicolon
id|sb-&gt;failed_disks
op_increment
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|1
suffix:semicolon
id|md_wakeup_thread
c_func
(paren
id|raid1_thread
)paren
suffix:semicolon
id|raid_conf-&gt;working_disks
op_decrement
suffix:semicolon
id|printk
(paren
id|DISK_FAILED
comma
id|kdevname
(paren
id|dev
)paren
comma
id|raid_conf-&gt;working_disks
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|LAST_DISK
macro_line|#undef LAST_DISK
DECL|macro|NO_SPARE_DISK
macro_line|#undef NO_SPARE_DISK
DECL|macro|DISK_FAILED
macro_line|#undef DISK_FAILED
DECL|macro|START_SYNCING
macro_line|#undef START_SYNCING
multiline_comment|/*&n; * This is the personality-specific hot-addition routine&n; */
DECL|macro|NO_SUPERBLOCK
mdefine_line|#define NO_SUPERBLOCK KERN_ERR &bslash;&n;&quot;raid1: cannot hot-add disk to the array with no RAID superblock&bslash;n&quot;
DECL|macro|WRONG_LEVEL
mdefine_line|#define WRONG_LEVEL KERN_ERR &bslash;&n;&quot;raid1: hot-add: level of disk is not RAID-1&bslash;n&quot;
DECL|macro|HOT_ADD_SUCCEEDED
mdefine_line|#define HOT_ADD_SUCCEEDED KERN_INFO &bslash;&n;&quot;raid1: device %s hot-added&bslash;n&quot;
DECL|function|raid1_hot_add_disk
r_static
r_int
id|raid1_hot_add_disk
(paren
r_struct
id|md_dev
op_star
id|mddev
comma
id|kdev_t
id|dev
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|raid1_data
op_star
id|raid_conf
op_assign
(paren
r_struct
id|raid1_data
op_star
)paren
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|mirror_info
op_star
id|mirror
suffix:semicolon
id|md_superblock_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
r_struct
id|real_dev
op_star
id|realdev
suffix:semicolon
r_int
id|n
suffix:semicolon
multiline_comment|/*&n;&t; * The device has its superblock already read and it was found&n;&t; * to be consistent for generic RAID usage.  Now we check whether&n;&t; * it&squot;s usable for RAID-1 hot addition.&n;&t; */
id|n
op_assign
id|mddev-&gt;nb_dev
op_increment
suffix:semicolon
id|realdev
op_assign
op_amp
id|mddev-&gt;devices
(braket
id|n
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|realdev-&gt;sb
)paren
(brace
id|printk
(paren
id|NO_SUPERBLOCK
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|realdev-&gt;sb-&gt;level
op_ne
l_int|1
)paren
(brace
id|printk
(paren
id|WRONG_LEVEL
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* FIXME: are there other things left we could sanity-check? */
multiline_comment|/*&n;&t; * We have to disable interrupts, as our RAID-1 state is used&n;&t; * from irq handlers as well.&n;&t; */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|raid_conf-&gt;raid_disks
op_increment
suffix:semicolon
id|mirror
op_assign
id|raid_conf-&gt;mirrors
op_plus
id|n
suffix:semicolon
id|mirror-&gt;number
op_assign
id|n
suffix:semicolon
id|mirror-&gt;raid_disk
op_assign
id|n
suffix:semicolon
id|mirror-&gt;dev
op_assign
id|dev
suffix:semicolon
id|mirror-&gt;next
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FIXME */
id|mirror-&gt;sect_limit
op_assign
l_int|128
suffix:semicolon
id|mirror-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|mirror-&gt;spare
op_assign
l_int|1
suffix:semicolon
id|mirror-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|sb-&gt;disks
(braket
id|n
)braket
dot
id|state
op_or_assign
(paren
l_int|1
op_lshift
id|MD_FAULTY_DEVICE
)paren
suffix:semicolon
id|sb-&gt;disks
(braket
id|n
)braket
dot
id|state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|MD_SYNC_DEVICE
)paren
suffix:semicolon
id|sb-&gt;disks
(braket
id|n
)braket
dot
id|state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|MD_ACTIVE_DEVICE
)paren
suffix:semicolon
id|sb-&gt;nr_disks
op_increment
suffix:semicolon
id|sb-&gt;spare_disks
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|md_update_sb
c_func
(paren
id|MINOR
c_func
(paren
id|dev
)paren
)paren
suffix:semicolon
id|printk
(paren
id|HOT_ADD_SUCCEEDED
comma
id|kdevname
c_func
(paren
id|realdev-&gt;dev
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|NO_SUPERBLOCK
macro_line|#undef NO_SUPERBLOCK
DECL|macro|WRONG_LEVEL
macro_line|#undef WRONG_LEVEL
DECL|macro|HOT_ADD_SUCCEEDED
macro_line|#undef HOT_ADD_SUCCEEDED
multiline_comment|/*&n; * Insert the spare disk into the drive-ring&n; */
DECL|function|add_ring
r_static
r_void
id|add_ring
c_func
(paren
r_struct
id|raid1_data
op_star
id|raid_conf
comma
r_struct
id|mirror_info
op_star
id|mirror
)paren
(brace
r_int
id|j
comma
id|next
suffix:semicolon
r_struct
id|mirror_info
op_star
id|p
op_assign
id|raid_conf-&gt;mirrors
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|raid_conf-&gt;raid_disks
suffix:semicolon
id|j
op_increment
comma
id|p
op_increment
)paren
r_if
c_cond
(paren
id|p-&gt;operational
op_logical_and
op_logical_neg
id|p-&gt;write_only
)paren
(brace
id|next
op_assign
id|p-&gt;next
suffix:semicolon
id|p-&gt;next
op_assign
id|mirror-&gt;raid_disk
suffix:semicolon
id|mirror-&gt;next
op_assign
id|next
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;raid1: bug: no read-operational devices&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|raid1_mark_spare
r_static
r_int
id|raid1_mark_spare
c_func
(paren
r_struct
id|md_dev
op_star
id|mddev
comma
id|md_descriptor_t
op_star
id|spare
comma
r_int
id|state
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|failed_disk
op_assign
op_minus
l_int|1
suffix:semicolon
r_struct
id|raid1_data
op_star
id|raid_conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
r_struct
id|mirror_info
op_star
id|mirror
op_assign
id|raid_conf-&gt;mirrors
suffix:semicolon
id|md_descriptor_t
op_star
id|descriptor
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MD_SB_DISKS
suffix:semicolon
id|i
op_increment
comma
id|mirror
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mirror-&gt;spare
op_logical_and
id|mirror-&gt;number
op_eq
id|spare-&gt;number
)paren
r_goto
id|found
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
id|found
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|mirror
op_assign
id|raid_conf-&gt;mirrors
suffix:semicolon
id|i
OL
id|raid_conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
comma
id|mirror
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|mirror-&gt;operational
)paren
id|failed_disk
op_assign
id|i
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|state
)paren
(brace
r_case
id|SPARE_WRITE
suffix:colon
id|mirror-&gt;operational
op_assign
l_int|1
suffix:semicolon
id|mirror-&gt;write_only
op_assign
l_int|1
suffix:semicolon
id|raid_conf-&gt;raid_disks
op_assign
id|MAX
c_func
(paren
id|raid_conf-&gt;raid_disks
comma
id|mirror-&gt;raid_disk
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPARE_INACTIVE
suffix:colon
id|mirror-&gt;operational
op_assign
l_int|0
suffix:semicolon
id|mirror-&gt;write_only
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SPARE_ACTIVE
suffix:colon
id|mirror-&gt;spare
op_assign
l_int|0
suffix:semicolon
id|mirror-&gt;write_only
op_assign
l_int|0
suffix:semicolon
id|raid_conf-&gt;working_disks
op_increment
suffix:semicolon
id|add_ring
c_func
(paren
id|raid_conf
comma
id|mirror
)paren
suffix:semicolon
r_if
c_cond
(paren
id|failed_disk
op_ne
op_minus
l_int|1
)paren
(brace
id|descriptor
op_assign
op_amp
id|mddev-&gt;sb-&gt;disks
(braket
id|raid_conf-&gt;mirrors
(braket
id|failed_disk
)braket
dot
id|number
)braket
suffix:semicolon
id|i
op_assign
id|spare-&gt;raid_disk
suffix:semicolon
id|spare-&gt;raid_disk
op_assign
id|descriptor-&gt;raid_disk
suffix:semicolon
id|descriptor-&gt;raid_disk
op_assign
id|i
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;raid1_mark_spare: bug: state == %d&bslash;n&quot;
comma
id|state
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * This is a kernel thread which:&n; *&n; *&t;1.&t;Retries failed read operations on working mirrors.&n; *&t;2.&t;Updates the raid superblock when problems encounter.&n; */
DECL|function|raid1d
r_void
id|raid1d
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_struct
id|raid1_bh
op_star
id|r1_bh
suffix:semicolon
r_struct
id|md_dev
op_star
id|mddev
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1d() active&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|raid1_retry_list
)paren
(brace
id|bh
op_assign
id|raid1_retry_list
suffix:semicolon
id|r1_bh
op_assign
(paren
r_struct
id|raid1_bh
op_star
)paren
(paren
id|bh-&gt;b_dev_id
)paren
suffix:semicolon
id|raid1_retry_list
op_assign
id|r1_bh-&gt;next_retry
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|mddev
op_assign
id|md_dev
op_plus
id|MINOR
c_func
(paren
id|bh-&gt;b_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mddev-&gt;sb_dirty
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dirty sb detected, updating.&bslash;n&quot;
)paren
suffix:semicolon
id|mddev-&gt;sb_dirty
op_assign
l_int|0
suffix:semicolon
id|md_update_sb
c_func
(paren
id|MINOR
c_func
(paren
id|bh-&gt;b_dev
)paren
)paren
suffix:semicolon
)brace
id|dev
op_assign
id|bh-&gt;b_rdev
suffix:semicolon
id|__raid1_map
(paren
id|md_dev
op_plus
id|MINOR
c_func
(paren
id|bh-&gt;b_dev
)paren
comma
op_amp
id|bh-&gt;b_rdev
comma
op_amp
id|bh-&gt;b_rsector
comma
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_rdev
op_eq
id|dev
)paren
(brace
id|printk
(paren
id|KERN_ALERT
l_string|&quot;raid1: %s: unrecoverable I/O read error for block %lu&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|bh-&gt;b_dev
)paren
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|raid1_end_buffer_io
c_func
(paren
id|r1_bh
comma
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;raid1: %s: redirecting sector %lu to another mirror&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|bh-&gt;b_dev
)paren
comma
id|bh-&gt;b_blocknr
)paren
suffix:semicolon
id|map_and_make_request
(paren
id|r1_bh-&gt;cmd
comma
id|bh
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This will catch the scenario in which one of the mirrors was&n; * mounted as a normal device rather than as a part of a raid set.&n; */
DECL|function|__check_consistency
r_static
r_int
id|__check_consistency
(paren
r_struct
id|md_dev
op_star
id|mddev
comma
r_int
id|row
)paren
(brace
r_struct
id|raid1_data
op_star
id|raid_conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
l_int|NULL
suffix:semicolon
r_int
id|i
comma
id|rc
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|buffer
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|raid_conf-&gt;raid_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|raid_conf-&gt;mirrors
(braket
id|i
)braket
dot
id|operational
)paren
r_continue
suffix:semicolon
id|dev
op_assign
id|raid_conf-&gt;mirrors
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
id|set_blocksize
c_func
(paren
id|dev
comma
l_int|4096
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|bread
c_func
(paren
id|dev
comma
id|row
op_div
l_int|4
comma
l_int|4096
)paren
)paren
op_eq
l_int|NULL
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
(brace
id|buffer
op_assign
(paren
r_char
op_star
)paren
id|__get_free_page
c_func
(paren
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
)paren
r_break
suffix:semicolon
id|memcpy
c_func
(paren
id|buffer
comma
id|bh-&gt;b_data
comma
l_int|4096
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|buffer
comma
id|bh-&gt;b_data
comma
l_int|4096
)paren
)paren
(brace
id|rc
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|bforget
c_func
(paren
id|bh
)paren
suffix:semicolon
id|fsync_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
id|bh
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|buffer
)paren
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|dev
op_assign
id|bh-&gt;b_dev
suffix:semicolon
id|bforget
c_func
(paren
id|bh
)paren
suffix:semicolon
id|fsync_dev
c_func
(paren
id|dev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
DECL|function|check_consistency
r_static
r_int
id|check_consistency
(paren
r_struct
id|md_dev
op_star
id|mddev
)paren
(brace
r_int
id|size
op_assign
id|mddev-&gt;sb-&gt;size
suffix:semicolon
r_int
id|row
suffix:semicolon
r_for
c_loop
(paren
id|row
op_assign
l_int|0
suffix:semicolon
id|row
OL
id|size
suffix:semicolon
id|row
op_add_assign
id|size
op_div
l_int|8
)paren
r_if
c_cond
(paren
id|__check_consistency
c_func
(paren
id|mddev
comma
id|row
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|raid1_run
r_static
r_int
id|raid1_run
(paren
r_int
id|minor
comma
r_struct
id|md_dev
op_star
id|mddev
)paren
(brace
r_struct
id|raid1_data
op_star
id|raid_conf
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|raid_disk
suffix:semicolon
id|md_superblock_t
op_star
id|sb
op_assign
id|mddev-&gt;sb
suffix:semicolon
id|md_descriptor_t
op_star
id|descriptor
suffix:semicolon
r_struct
id|real_dev
op_star
id|realdev
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;level
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;raid1: %s: raid level not set to mirroring (%d)&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|MKDEV
c_func
(paren
id|MD_MAJOR
comma
id|minor
)paren
)paren
comma
id|sb-&gt;level
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/****&n;&t; * copy the now verified devices into our private RAID1 bookkeeping&n;&t; * area. [whatever we allocate in raid1_run(), should be freed in&n;&t; * raid1_stop()]&n;&t; */
r_while
c_loop
(paren
op_logical_neg
(paren
multiline_comment|/* FIXME: now we are rather fault tolerant than nice */
id|mddev
op_member_access_from_pointer
r_private
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|raid1_data
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
id|printk
(paren
l_string|&quot;raid1_run(): out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|raid_conf
op_assign
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
id|memset
c_func
(paren
id|raid_conf
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|raid_conf
)paren
)paren
suffix:semicolon
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid1_run(%d) called.&bslash;n&quot;
comma
id|minor
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|mddev-&gt;nb_dev
suffix:semicolon
id|i
op_increment
)paren
(brace
id|realdev
op_assign
op_amp
id|mddev-&gt;devices
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|realdev-&gt;sb
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: disabled mirror %s (couldn&squot;t access raid superblock)&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|realdev-&gt;dev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * This is important -- we are using the descriptor on&n;&t;&t; * the disk only to get a pointer to the descriptor on&n;&t;&t; * the main superblock, which might be more recent.&n;&t;&t; */
id|descriptor
op_assign
op_amp
id|sb-&gt;disks
(braket
id|realdev-&gt;sb-&gt;descriptor.number
)braket
suffix:semicolon
r_if
c_cond
(paren
id|descriptor-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_FAULTY_DEVICE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: disabled mirror %s (errors detected)&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|realdev-&gt;dev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|descriptor-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_ACTIVE_DEVICE
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|descriptor-&gt;state
op_amp
(paren
l_int|1
op_lshift
id|MD_SYNC_DEVICE
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: disabled mirror %s (not in sync)&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|realdev-&gt;dev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|raid_disk
op_assign
id|descriptor-&gt;raid_disk
suffix:semicolon
r_if
c_cond
(paren
id|descriptor-&gt;number
OG
id|sb-&gt;nr_disks
op_logical_or
id|raid_disk
OG
id|sb-&gt;raid_disks
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: disabled mirror %s (inconsistent descriptor)&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|realdev-&gt;dev
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raid_conf-&gt;mirrors
(braket
id|raid_disk
)braket
dot
id|operational
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: disabled mirror %s (mirror %d already operational)&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|realdev-&gt;dev
)paren
comma
id|raid_disk
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;raid1: device %s operational as mirror %d&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|realdev-&gt;dev
)paren
comma
id|raid_disk
)paren
suffix:semicolon
id|raid_conf-&gt;mirrors
(braket
id|raid_disk
)braket
dot
id|number
op_assign
id|descriptor-&gt;number
suffix:semicolon
id|raid_conf-&gt;mirrors
(braket
id|raid_disk
)braket
dot
id|raid_disk
op_assign
id|raid_disk
suffix:semicolon
id|raid_conf-&gt;mirrors
(braket
id|raid_disk
)braket
dot
id|dev
op_assign
id|mddev-&gt;devices
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
id|raid_conf-&gt;mirrors
(braket
id|raid_disk
)braket
dot
id|operational
op_assign
l_int|1
suffix:semicolon
id|raid_conf-&gt;mirrors
(braket
id|raid_disk
)braket
dot
id|sect_limit
op_assign
l_int|128
suffix:semicolon
id|raid_conf-&gt;working_disks
op_increment
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * Must be a spare disk ..&n;&t;&t; */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;raid1: spare disk %s&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|realdev-&gt;dev
)paren
)paren
suffix:semicolon
id|raid_disk
op_assign
id|descriptor-&gt;raid_disk
suffix:semicolon
id|raid_conf-&gt;mirrors
(braket
id|raid_disk
)braket
dot
id|number
op_assign
id|descriptor-&gt;number
suffix:semicolon
id|raid_conf-&gt;mirrors
(braket
id|raid_disk
)braket
dot
id|raid_disk
op_assign
id|raid_disk
suffix:semicolon
id|raid_conf-&gt;mirrors
(braket
id|raid_disk
)braket
dot
id|dev
op_assign
id|mddev-&gt;devices
(braket
id|i
)braket
dot
id|dev
suffix:semicolon
id|raid_conf-&gt;mirrors
(braket
id|raid_disk
)braket
dot
id|sect_limit
op_assign
l_int|128
suffix:semicolon
id|raid_conf-&gt;mirrors
(braket
id|raid_disk
)braket
dot
id|operational
op_assign
l_int|0
suffix:semicolon
id|raid_conf-&gt;mirrors
(braket
id|raid_disk
)braket
dot
id|write_only
op_assign
l_int|0
suffix:semicolon
id|raid_conf-&gt;mirrors
(braket
id|raid_disk
)braket
dot
id|spare
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|raid_conf-&gt;working_disks
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: no operational mirrors for %s&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|MKDEV
c_func
(paren
id|MD_MAJOR
comma
id|minor
)paren
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|raid_conf
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|raid_conf-&gt;raid_disks
op_assign
id|sb-&gt;raid_disks
suffix:semicolon
id|raid_conf-&gt;mddev
op_assign
id|mddev
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
op_logical_neg
id|raid_conf-&gt;mirrors
(braket
id|j
)braket
dot
id|operational
suffix:semicolon
id|j
op_increment
)paren
suffix:semicolon
id|raid_conf-&gt;last_used
op_assign
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|raid_conf-&gt;raid_disks
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|raid_conf-&gt;mirrors
(braket
id|i
)braket
dot
id|operational
)paren
(brace
id|PRINTK
c_func
(paren
(paren
l_string|&quot;raid_conf-&gt;mirrors[%d].next == %d&bslash;n&quot;
comma
id|i
comma
id|j
)paren
)paren
suffix:semicolon
id|raid_conf-&gt;mirrors
(braket
id|i
)braket
dot
id|next
op_assign
id|j
suffix:semicolon
id|j
op_assign
id|i
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|check_consistency
c_func
(paren
id|mddev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;raid1: detected mirror differences -- run ckraid&bslash;n&quot;
)paren
suffix:semicolon
id|sb-&gt;state
op_or_assign
l_int|1
op_lshift
id|MD_SB_ERRORS
suffix:semicolon
id|kfree
c_func
(paren
id|raid_conf
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Regenerate the &quot;device is in sync with the raid set&quot; bit for&n;&t; * each device.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sb-&gt;nr_disks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|sb-&gt;disks
(braket
id|i
)braket
dot
id|state
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|MD_SYNC_DEVICE
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|sb-&gt;raid_disks
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|raid_conf-&gt;mirrors
(braket
id|j
)braket
dot
id|operational
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|sb-&gt;disks
(braket
id|i
)braket
dot
id|number
op_eq
id|raid_conf-&gt;mirrors
(braket
id|j
)braket
dot
id|number
)paren
id|sb-&gt;disks
(braket
id|i
)braket
dot
id|state
op_or_assign
l_int|1
op_lshift
id|MD_SYNC_DEVICE
suffix:semicolon
)brace
)brace
id|sb-&gt;active_disks
op_assign
id|raid_conf-&gt;working_disks
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;raid1: raid set %s active with %d out of %d mirrors&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|MKDEV
c_func
(paren
id|MD_MAJOR
comma
id|minor
)paren
)paren
comma
id|sb-&gt;active_disks
comma
id|sb-&gt;raid_disks
)paren
suffix:semicolon
multiline_comment|/* Ok, everything is just fine now */
r_return
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|raid1_stop
r_static
r_int
id|raid1_stop
(paren
r_int
id|minor
comma
r_struct
id|md_dev
op_star
id|mddev
)paren
(brace
r_struct
id|raid1_data
op_star
id|raid_conf
op_assign
(paren
r_struct
id|raid1_data
op_star
)paren
id|mddev
op_member_access_from_pointer
r_private
suffix:semicolon
id|kfree
(paren
id|raid_conf
)paren
suffix:semicolon
id|mddev
op_member_access_from_pointer
r_private
op_assign
l_int|NULL
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|raid1_personality
r_static
r_struct
id|md_personality
id|raid1_personality
op_assign
(brace
l_string|&quot;raid1&quot;
comma
id|raid1_map
comma
id|raid1_make_request
comma
id|raid1_end_request
comma
id|raid1_run
comma
id|raid1_stop
comma
id|raid1_status
comma
l_int|NULL
comma
multiline_comment|/* no ioctls */
l_int|0
comma
id|raid1_error
comma
id|raid1_hot_add_disk
comma
multiline_comment|/* raid1_hot_remove_drive */
l_int|NULL
comma
id|raid1_mark_spare
)brace
suffix:semicolon
DECL|function|raid1_init
r_int
id|raid1_init
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
(paren
id|raid1_thread
op_assign
id|md_register_thread
c_func
(paren
id|raid1d
comma
l_int|NULL
)paren
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_return
id|register_md_personality
(paren
id|RAID1
comma
op_amp
id|raid1_personality
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
(paren
r_void
)paren
(brace
r_return
id|raid1_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
(paren
r_void
)paren
(brace
id|md_unregister_thread
(paren
id|raid1_thread
)paren
suffix:semicolon
id|unregister_md_personality
(paren
id|RAID1
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
