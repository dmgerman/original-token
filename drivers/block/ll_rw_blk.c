multiline_comment|/*&n; *  linux/drivers/block/ll_rw_blk.c&n; *&n; * Copyright (C) 1991, 1992 Linus Torvalds&n; * Copyright (C) 1994,      Karl Keyte: Added support for disk statistics&n; */
multiline_comment|/*&n; * This handles all read/write requests to block devices&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/module.h&gt;
multiline_comment|/*&n; * The request-struct contains all necessary data&n; * to load a nr of sectors into memory&n; */
DECL|variable|all_requests
r_static
r_struct
id|request
id|all_requests
(braket
id|NR_REQUEST
)braket
suffix:semicolon
multiline_comment|/*&n; * The &quot;disk&quot; task queue is used to start the actual requests&n; * after a plug&n; */
DECL|variable|tq_disk
id|DECLARE_TASK_QUEUE
c_func
(paren
id|tq_disk
)paren
suffix:semicolon
multiline_comment|/*&n; * Protect the request list against multiple users..&n; *&n; * With this spinlock the Linux block IO subsystem is 100% SMP threaded&n; * from the IRQ event side, and almost 100% SMP threaded from the syscall&n; * side (we still have protect against block device array operations, and&n; * the do_request() side is casually still unsafe. The kernel lock protects&n; * this part currently.).&n; *&n; * there is a fair chance that things will work just OK if these functions&n; * are called with no global kernel lock held ...&n; */
DECL|variable|io_request_lock
id|spinlock_t
id|io_request_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/*&n; * used to wait on when there are no free requests&n; */
DECL|variable|wait_for_request
r_struct
id|wait_queue
op_star
id|wait_for_request
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* This specifies how many sectors to read ahead on the disk.  */
DECL|variable|read_ahead
r_int
id|read_ahead
(braket
id|MAX_BLKDEV
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* blk_dev_struct is:&n; *&t;*request_fn&n; *&t;*current_request&n; */
DECL|variable|blk_dev
r_struct
id|blk_dev_struct
id|blk_dev
(braket
id|MAX_BLKDEV
)braket
suffix:semicolon
multiline_comment|/* initialized by blk_dev_init() */
multiline_comment|/*&n; * blk_size contains the size of all block-devices in units of 1024 byte&n; * sectors:&n; *&n; * blk_size[MAJOR][MINOR]&n; *&n; * if (!blk_size[MAJOR]) then no minor size checking is done.&n; */
DECL|variable|blk_size
r_int
op_star
id|blk_size
(braket
id|MAX_BLKDEV
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * blksize_size contains the size of all block-devices:&n; *&n; * blksize_size[MAJOR][MINOR]&n; *&n; * if (!blksize_size[MAJOR]) then 1024 bytes is assumed.&n; */
DECL|variable|blksize_size
r_int
op_star
id|blksize_size
(braket
id|MAX_BLKDEV
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * hardsect_size contains the size of the hardware sector of a device.&n; *&n; * hardsect_size[MAJOR][MINOR]&n; *&n; * if (!hardsect_size[MAJOR])&n; *&t;&t;then 512 bytes is assumed.&n; * else&n; *&t;&t;sector_size is hardsect_size[MAJOR][MINOR]&n; * This is currently set by some scsi devices and read by the msdos fs driver.&n; * Other uses may appear later.&n; */
DECL|variable|hardsect_size
r_int
op_star
id|hardsect_size
(braket
id|MAX_BLKDEV
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * The following tunes the read-ahead algorithm in mm/filemap.c&n; */
DECL|variable|max_readahead
r_int
op_star
id|max_readahead
(braket
id|MAX_BLKDEV
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Max number of sectors per request&n; */
DECL|variable|max_sectors
r_int
op_star
id|max_sectors
(braket
id|MAX_BLKDEV
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
)brace
suffix:semicolon
DECL|function|get_max_sectors
r_static
r_inline
r_int
id|get_max_sectors
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|max_sectors
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
)paren
r_return
id|MAX_SECTORS
suffix:semicolon
r_return
id|max_sectors
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * Is called with the request spinlock aquired.&n; * NOTE: the device-specific queue() functions&n; * have to be atomic!&n; */
DECL|function|get_queue
r_static
r_inline
r_struct
id|request
op_star
op_star
id|get_queue
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_struct
id|blk_dev_struct
op_star
id|bdev
op_assign
id|blk_dev
op_plus
id|major
suffix:semicolon
r_if
c_cond
(paren
id|bdev-&gt;queue
)paren
r_return
id|bdev
op_member_access_from_pointer
id|queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_return
op_amp
id|blk_dev
(braket
id|major
)braket
dot
id|current_request
suffix:semicolon
)brace
multiline_comment|/*&n; * remove the plug and let it rip..&n; */
DECL|function|unplug_device
r_void
id|unplug_device
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_struct
id|blk_dev_struct
op_star
id|dev
op_assign
(paren
r_struct
id|blk_dev_struct
op_star
)paren
id|data
suffix:semicolon
r_int
id|queue_new_request
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;current_request
op_eq
op_amp
id|dev-&gt;plug
)paren
(brace
r_struct
id|request
op_star
id|next
op_assign
id|dev-&gt;plug.next
suffix:semicolon
id|dev-&gt;current_request
op_assign
id|next
suffix:semicolon
r_if
c_cond
(paren
id|next
op_logical_or
id|dev-&gt;queue
)paren
(brace
id|dev-&gt;plug.next
op_assign
l_int|NULL
suffix:semicolon
id|queue_new_request
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|queue_new_request
)paren
(paren
id|dev-&gt;request_fn
)paren
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;plug&quot; the device if there are no outstanding requests: this will&n; * force the transfer to start only after we have put all the requests&n; * on the list.&n; *&n; * This is called with interrupts off and no requests on the queue.&n; * (and with the request spinlock aquired)&n; */
DECL|function|plug_device
r_static
r_inline
r_void
id|plug_device
c_func
(paren
r_struct
id|blk_dev_struct
op_star
id|dev
)paren
(brace
r_if
c_cond
(paren
id|dev-&gt;current_request
)paren
r_return
suffix:semicolon
id|dev-&gt;current_request
op_assign
op_amp
id|dev-&gt;plug
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|dev-&gt;plug_tq
comma
op_amp
id|tq_disk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * look for a free request in the first N entries.&n; * NOTE: interrupts must be disabled on the way in (on SMP the request queue&n; * spinlock has to be aquired), and will still be disabled on the way out.&n; */
DECL|function|get_request
r_static
r_inline
r_struct
id|request
op_star
id|get_request
c_func
(paren
r_int
id|n
comma
id|kdev_t
id|dev
)paren
(brace
r_static
r_struct
id|request
op_star
id|prev_found
op_assign
l_int|NULL
comma
op_star
id|prev_limit
op_assign
l_int|NULL
suffix:semicolon
r_register
r_struct
id|request
op_star
id|req
comma
op_star
id|limit
suffix:semicolon
r_if
c_cond
(paren
id|n
op_le
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;get_request(%d): impossible!&bslash;n&quot;
comma
id|n
)paren
suffix:semicolon
id|limit
op_assign
id|all_requests
op_plus
id|n
suffix:semicolon
r_if
c_cond
(paren
id|limit
op_ne
id|prev_limit
)paren
(brace
id|prev_limit
op_assign
id|limit
suffix:semicolon
id|prev_found
op_assign
id|all_requests
suffix:semicolon
)brace
id|req
op_assign
id|prev_found
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|req
op_assign
(paren
(paren
id|req
OG
id|all_requests
)paren
ques
c_cond
id|req
suffix:colon
id|limit
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|req
op_eq
id|prev_found
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
id|prev_found
op_assign
id|req
suffix:semicolon
id|req-&gt;rq_status
op_assign
id|RQ_ACTIVE
suffix:semicolon
id|req-&gt;rq_dev
op_assign
id|dev
suffix:semicolon
r_return
id|req
suffix:semicolon
)brace
multiline_comment|/*&n; * wait until a free request in the first N entries is available.&n; */
DECL|function|__get_request_wait
r_static
r_struct
id|request
op_star
id|__get_request_wait
c_func
(paren
r_int
id|n
comma
id|kdev_t
id|dev
)paren
(brace
r_register
r_struct
id|request
op_star
id|req
suffix:semicolon
r_struct
id|wait_queue
id|wait
op_assign
(brace
id|current
comma
l_int|NULL
)brace
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|wait_for_request
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_UNINTERRUPTIBLE
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|req
op_assign
id|get_request
c_func
(paren
id|n
comma
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
r_break
suffix:semicolon
id|run_task_queue
c_func
(paren
op_amp
id|tq_disk
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|wait_for_request
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
id|req
suffix:semicolon
)brace
DECL|function|get_request_wait
r_static
r_inline
r_struct
id|request
op_star
id|get_request_wait
c_func
(paren
r_int
id|n
comma
id|kdev_t
id|dev
)paren
(brace
r_register
r_struct
id|request
op_star
id|req
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|req
op_assign
id|get_request
c_func
(paren
id|n
comma
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req
)paren
r_return
id|req
suffix:semicolon
r_return
id|__get_request_wait
c_func
(paren
id|n
comma
id|dev
)paren
suffix:semicolon
)brace
multiline_comment|/* RO fail safe mechanism */
DECL|variable|ro_bits
r_static
r_int
id|ro_bits
(braket
id|MAX_BLKDEV
)braket
(braket
l_int|8
)braket
suffix:semicolon
DECL|function|is_read_only
r_int
id|is_read_only
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|minor
comma
id|major
suffix:semicolon
id|major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
OL
l_int|0
op_logical_or
id|major
op_ge
id|MAX_BLKDEV
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|ro_bits
(braket
id|major
)braket
(braket
id|minor
op_rshift
l_int|5
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|minor
op_amp
l_int|31
)paren
)paren
suffix:semicolon
)brace
DECL|function|set_device_ro
r_void
id|set_device_ro
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|flag
)paren
(brace
r_int
id|minor
comma
id|major
suffix:semicolon
id|major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
OL
l_int|0
op_logical_or
id|major
op_ge
id|MAX_BLKDEV
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
id|ro_bits
(braket
id|major
)braket
(braket
id|minor
op_rshift
l_int|5
)braket
op_or_assign
l_int|1
op_lshift
(paren
id|minor
op_amp
l_int|31
)paren
suffix:semicolon
r_else
id|ro_bits
(braket
id|major
)braket
(braket
id|minor
op_rshift
l_int|5
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
(paren
id|minor
op_amp
l_int|31
)paren
)paren
suffix:semicolon
)brace
DECL|function|drive_stat_acct
r_static
r_inline
r_void
id|drive_stat_acct
c_func
(paren
r_int
id|cmd
comma
r_int
r_int
id|nr_sectors
comma
r_int
id|disk_index
)paren
(brace
id|kstat.dk_drive
(braket
id|disk_index
)braket
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|READ
)paren
(brace
id|kstat.dk_drive_rio
(braket
id|disk_index
)braket
op_increment
suffix:semicolon
id|kstat.dk_drive_rblk
(braket
id|disk_index
)braket
op_add_assign
id|nr_sectors
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd
op_eq
id|WRITE
)paren
(brace
id|kstat.dk_drive_wio
(braket
id|disk_index
)braket
op_increment
suffix:semicolon
id|kstat.dk_drive_wblk
(braket
id|disk_index
)braket
op_add_assign
id|nr_sectors
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;drive_stat_acct: cmd not R/W?&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * add-request adds a request to the linked list.&n; * It disables interrupts (aquires the request spinlock) so that it can muck&n; * with the request-lists in peace. Thus it should be called with no spinlocks&n; * held.&n; *&n; * By this point, req-&gt;cmd is always either READ/WRITE, never READA/WRITEA,&n; * which is important for drive_stat_acct() above.&n; */
DECL|function|add_request
r_void
id|add_request
c_func
(paren
r_struct
id|blk_dev_struct
op_star
id|dev
comma
r_struct
id|request
op_star
id|req
)paren
(brace
r_struct
id|request
op_star
id|tmp
comma
op_star
op_star
id|current_request
suffix:semicolon
r_int
id|disk_index
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|queue_new_request
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|MAJOR
c_func
(paren
id|req-&gt;rq_dev
)paren
)paren
(brace
r_case
id|SCSI_DISK0_MAJOR
suffix:colon
id|disk_index
op_assign
(paren
id|MINOR
c_func
(paren
id|req-&gt;rq_dev
)paren
op_amp
l_int|0x00f0
)paren
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|disk_index
OL
l_int|4
)paren
id|drive_stat_acct
c_func
(paren
id|req-&gt;cmd
comma
id|req-&gt;nr_sectors
comma
id|disk_index
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IDE0_MAJOR
suffix:colon
multiline_comment|/* same as HD_MAJOR */
r_case
id|XT_DISK_MAJOR
suffix:colon
id|disk_index
op_assign
(paren
id|MINOR
c_func
(paren
id|req-&gt;rq_dev
)paren
op_amp
l_int|0x0040
)paren
op_rshift
l_int|6
suffix:semicolon
id|drive_stat_acct
c_func
(paren
id|req-&gt;cmd
comma
id|req-&gt;nr_sectors
comma
id|disk_index
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IDE1_MAJOR
suffix:colon
id|disk_index
op_assign
(paren
(paren
id|MINOR
c_func
(paren
id|req-&gt;rq_dev
)paren
op_amp
l_int|0x0040
)paren
op_rshift
l_int|6
)paren
op_plus
l_int|2
suffix:semicolon
id|drive_stat_acct
c_func
(paren
id|req-&gt;cmd
comma
id|req-&gt;nr_sectors
comma
id|disk_index
)paren
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|req-&gt;next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * We use the goto to reduce locking complexity&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|current_request
op_assign
id|get_queue
c_func
(paren
id|req-&gt;rq_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;bh
)paren
id|mark_buffer_clean
c_func
(paren
id|req-&gt;bh
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|tmp
op_assign
op_star
id|current_request
)paren
)paren
(brace
op_star
id|current_request
op_assign
id|req
suffix:semicolon
r_if
c_cond
(paren
id|dev-&gt;current_request
op_ne
op_amp
id|dev-&gt;plug
)paren
id|queue_new_request
op_assign
l_int|1
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_for
c_loop
(paren
suffix:semicolon
id|tmp-&gt;next
suffix:semicolon
id|tmp
op_assign
id|tmp-&gt;next
)paren
(brace
r_const
r_int
id|after_current
op_assign
id|IN_ORDER
c_func
(paren
id|tmp
comma
id|req
)paren
suffix:semicolon
r_const
r_int
id|before_next
op_assign
id|IN_ORDER
c_func
(paren
id|req
comma
id|tmp-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|IN_ORDER
c_func
(paren
id|tmp
comma
id|tmp-&gt;next
)paren
)paren
(brace
r_if
c_cond
(paren
id|after_current
op_logical_or
id|before_next
)paren
r_break
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|after_current
op_logical_and
id|before_next
)paren
r_break
suffix:semicolon
)brace
)brace
id|req-&gt;next
op_assign
id|tmp-&gt;next
suffix:semicolon
id|tmp-&gt;next
op_assign
id|req
suffix:semicolon
multiline_comment|/* for SCSI devices, call request_fn unconditionally */
r_if
c_cond
(paren
id|scsi_blk_major
c_func
(paren
id|MAJOR
c_func
(paren
id|req-&gt;rq_dev
)paren
)paren
)paren
id|queue_new_request
op_assign
l_int|1
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
id|queue_new_request
)paren
(paren
id|dev-&gt;request_fn
)paren
(paren
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Has to be called with the request spinlock aquired&n; */
DECL|function|attempt_merge
r_static
r_inline
r_void
id|attempt_merge
(paren
r_struct
id|request
op_star
id|req
comma
r_int
id|max_sectors
)paren
(brace
r_struct
id|request
op_star
id|next
op_assign
id|req-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|next
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;sector
op_plus
id|req-&gt;nr_sectors
op_ne
id|next-&gt;sector
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|next-&gt;sem
op_logical_or
id|req-&gt;cmd
op_ne
id|next-&gt;cmd
op_logical_or
id|req-&gt;rq_dev
op_ne
id|next-&gt;rq_dev
op_logical_or
id|req-&gt;nr_sectors
op_plus
id|next-&gt;nr_sectors
OG
id|max_sectors
)paren
r_return
suffix:semicolon
id|req-&gt;bhtail-&gt;b_reqnext
op_assign
id|next-&gt;bh
suffix:semicolon
id|req-&gt;bhtail
op_assign
id|next-&gt;bhtail
suffix:semicolon
id|req-&gt;nr_sectors
op_add_assign
id|next-&gt;nr_sectors
suffix:semicolon
id|next-&gt;rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
id|req-&gt;next
op_assign
id|next-&gt;next
suffix:semicolon
id|wake_up
(paren
op_amp
id|wait_for_request
)paren
suffix:semicolon
)brace
DECL|function|make_request
r_void
id|make_request
c_func
(paren
r_int
id|major
comma
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
r_int
id|sector
comma
id|count
suffix:semicolon
r_struct
id|request
op_star
id|req
suffix:semicolon
r_int
id|rw_ahead
comma
id|max_req
comma
id|max_sectors
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|count
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|sector
op_assign
id|bh-&gt;b_rsector
suffix:semicolon
multiline_comment|/* Uhhuh.. Nasty dead-lock possible here.. */
r_if
c_cond
(paren
id|buffer_locked
c_func
(paren
id|bh
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/* Maybe the above fixes it, and maybe it doesn&squot;t boot. Life is interesting */
id|lock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_size
(braket
id|major
)braket
)paren
r_if
c_cond
(paren
id|blk_size
(braket
id|major
)braket
(braket
id|MINOR
c_func
(paren
id|bh-&gt;b_rdev
)paren
)braket
OL
(paren
id|sector
op_plus
id|count
)paren
op_rshift
l_int|1
)paren
(brace
id|bh-&gt;b_state
op_and_assign
(paren
l_int|1
op_lshift
id|BH_Lock
)paren
suffix:semicolon
multiline_comment|/* This may well happen - the kernel calls bread()&n;                           without checking the size of the device, e.g.,&n;                           when mounting a device. */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;attempt to access beyond end of device&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: rw=%d, want=%d, limit=%d&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|bh-&gt;b_rdev
)paren
comma
id|rw
comma
(paren
id|sector
op_plus
id|count
)paren
op_rshift
l_int|1
comma
id|blk_size
(braket
id|major
)braket
(braket
id|MINOR
c_func
(paren
id|bh-&gt;b_rdev
)paren
)braket
)paren
suffix:semicolon
r_goto
id|end_io
suffix:semicolon
)brace
id|rw_ahead
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* normal case; gets changed below for READA/WRITEA */
r_switch
c_cond
(paren
id|rw
)paren
(brace
r_case
id|READA
suffix:colon
id|rw_ahead
op_assign
l_int|1
suffix:semicolon
id|rw
op_assign
id|READ
suffix:semicolon
multiline_comment|/* drop into READ */
r_case
id|READ
suffix:colon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
multiline_comment|/* Hmmph! Already have it */
r_goto
id|end_io
suffix:semicolon
id|kstat.pgpgin
op_increment
suffix:semicolon
id|max_req
op_assign
id|NR_REQUEST
suffix:semicolon
multiline_comment|/* reads take precedence */
r_break
suffix:semicolon
r_case
id|WRITEA
suffix:colon
id|rw_ahead
op_assign
l_int|1
suffix:semicolon
id|rw
op_assign
id|WRITE
suffix:semicolon
multiline_comment|/* drop into WRITE */
r_case
id|WRITE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|buffer_dirty
c_func
(paren
id|bh
)paren
)paren
multiline_comment|/* Hmmph! Nothing to write */
r_goto
id|end_io
suffix:semicolon
multiline_comment|/* We don&squot;t allow the write-requests to fill up the&n;&t;&t;&t; * queue completely:  we want some room for reads,&n;&t;&t;&t; * as they take precedence. The last third of the&n;&t;&t;&t; * requests are only for reads.&n;&t;&t;&t; */
id|kstat.pgpgout
op_increment
suffix:semicolon
id|max_req
op_assign
(paren
id|NR_REQUEST
op_star
l_int|2
)paren
op_div
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;make_request: bad block dev cmd,&quot;
l_string|&quot; must be R/W/RA/WA&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|end_io
suffix:semicolon
)brace
multiline_comment|/* look for a free request. */
multiline_comment|/* Loop uses two requests, 1 for loop and 1 for the real device.&n;        * Cut max_req in half to avoid running out and deadlocking. */
r_if
c_cond
(paren
(paren
id|major
op_eq
id|LOOP_MAJOR
)paren
op_logical_or
(paren
id|major
op_eq
id|NBD_MAJOR
)paren
)paren
id|max_req
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Try to coalesce the new request with old requests&n;&t; */
id|max_sectors
op_assign
id|get_max_sectors
c_func
(paren
id|bh-&gt;b_rdev
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now we acquire the request spinlock, we have to be mega careful&n;&t; * not to schedule or do something nonatomic&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|req
op_assign
op_star
id|get_queue
c_func
(paren
id|bh-&gt;b_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
(brace
multiline_comment|/* MD and loop can&squot;t handle plugging without deadlocking */
r_if
c_cond
(paren
id|major
op_ne
id|MD_MAJOR
op_logical_and
id|major
op_ne
id|LOOP_MAJOR
op_logical_and
id|major
op_ne
id|DDV_MAJOR
op_logical_and
id|major
op_ne
id|NBD_MAJOR
)paren
id|plug_device
c_func
(paren
id|blk_dev
op_plus
id|major
)paren
suffix:semicolon
multiline_comment|/* is atomic */
)brace
r_else
r_switch
c_cond
(paren
id|major
)paren
(brace
r_case
id|IDE0_MAJOR
suffix:colon
multiline_comment|/* same as HD_MAJOR */
r_case
id|IDE1_MAJOR
suffix:colon
r_case
id|FLOPPY_MAJOR
suffix:colon
r_case
id|IDE2_MAJOR
suffix:colon
r_case
id|IDE3_MAJOR
suffix:colon
r_case
id|IDE4_MAJOR
suffix:colon
r_case
id|IDE5_MAJOR
suffix:colon
r_case
id|ACSI_MAJOR
suffix:colon
r_case
id|MFM_ACORN_MAJOR
suffix:colon
multiline_comment|/*&n;&t;&t; * The scsi disk and cdrom drivers completely remove the request&n;&t;&t; * from the queue when they start processing an entry.  For this&n;&t;&t; * reason it is safe to continue to add links to the top entry for&n;&t;&t; * those devices.&n;&t;&t; *&n;&t;&t; * All other drivers need to jump over the first entry, as that&n;&t;&t; * entry may be busy being processed and we thus can&squot;t change it.&n;&t;&t; */
r_if
c_cond
(paren
id|req
op_eq
id|blk_dev
(braket
id|major
)braket
dot
id|current_request
)paren
id|req
op_assign
id|req-&gt;next
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
r_break
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|SCSI_DISK0_MAJOR
suffix:colon
r_case
id|SCSI_DISK1_MAJOR
suffix:colon
r_case
id|SCSI_DISK2_MAJOR
suffix:colon
r_case
id|SCSI_DISK3_MAJOR
suffix:colon
r_case
id|SCSI_DISK4_MAJOR
suffix:colon
r_case
id|SCSI_DISK5_MAJOR
suffix:colon
r_case
id|SCSI_DISK6_MAJOR
suffix:colon
r_case
id|SCSI_DISK7_MAJOR
suffix:colon
r_case
id|SCSI_CDROM_MAJOR
suffix:colon
r_do
(brace
r_if
c_cond
(paren
id|req-&gt;sem
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;cmd
op_ne
id|rw
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;nr_sectors
op_plus
id|count
OG
id|max_sectors
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;rq_dev
op_ne
id|bh-&gt;b_rdev
)paren
r_continue
suffix:semicolon
multiline_comment|/* Can we add it to the end of this request? */
r_if
c_cond
(paren
id|req-&gt;sector
op_plus
id|req-&gt;nr_sectors
op_eq
id|sector
)paren
(brace
id|req-&gt;bhtail-&gt;b_reqnext
op_assign
id|bh
suffix:semicolon
id|req-&gt;bhtail
op_assign
id|bh
suffix:semicolon
id|req-&gt;nr_sectors
op_add_assign
id|count
suffix:semicolon
multiline_comment|/* Can we now merge this req with the next? */
id|attempt_merge
c_func
(paren
id|req
comma
id|max_sectors
)paren
suffix:semicolon
multiline_comment|/* or to the beginning? */
)brace
r_else
r_if
c_cond
(paren
id|req-&gt;sector
op_minus
id|count
op_eq
id|sector
)paren
(brace
id|bh-&gt;b_reqnext
op_assign
id|req-&gt;bh
suffix:semicolon
id|req-&gt;bh
op_assign
id|bh
suffix:semicolon
id|req-&gt;buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|req-&gt;current_nr_sectors
op_assign
id|count
suffix:semicolon
id|req-&gt;sector
op_assign
id|sector
suffix:semicolon
id|req-&gt;nr_sectors
op_add_assign
id|count
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
id|mark_buffer_clean
c_func
(paren
id|bh
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|req
op_assign
id|req-&gt;next
)paren
op_ne
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* find an unused request. */
id|req
op_assign
id|get_request
c_func
(paren
id|max_req
comma
id|bh-&gt;b_rdev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* if no request available: if rw_ahead, forget it; otherwise try again blocking.. */
r_if
c_cond
(paren
op_logical_neg
id|req
)paren
(brace
r_if
c_cond
(paren
id|rw_ahead
)paren
r_goto
id|end_io
suffix:semicolon
id|req
op_assign
id|__get_request_wait
c_func
(paren
id|max_req
comma
id|bh-&gt;b_rdev
)paren
suffix:semicolon
)brace
multiline_comment|/* fill up the request-info, and add it to the queue */
id|req-&gt;cmd
op_assign
id|rw
suffix:semicolon
id|req-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|req-&gt;sector
op_assign
id|sector
suffix:semicolon
id|req-&gt;nr_sectors
op_assign
id|count
suffix:semicolon
id|req-&gt;current_nr_sectors
op_assign
id|count
suffix:semicolon
id|req-&gt;buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|req-&gt;sem
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;bh
op_assign
id|bh
suffix:semicolon
id|req-&gt;bhtail
op_assign
id|bh
suffix:semicolon
id|req-&gt;next
op_assign
l_int|NULL
suffix:semicolon
id|add_request
c_func
(paren
id|major
op_plus
id|blk_dev
comma
id|req
)paren
suffix:semicolon
r_return
suffix:semicolon
id|end_io
suffix:colon
id|bh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|bh
comma
id|test_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* This function can be used to request a number of buffers from a block&n;   device. Currently the only restriction is that all buffers must belong to&n;   the same device */
DECL|function|ll_rw_block
r_void
id|ll_rw_block
c_func
(paren
r_int
id|rw
comma
r_int
id|nr
comma
r_struct
id|buffer_head
op_star
id|bh
(braket
)braket
)paren
(brace
r_int
r_int
id|major
suffix:semicolon
r_int
id|correct_size
suffix:semicolon
r_struct
id|blk_dev_struct
op_star
id|dev
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Make sure that the first block contains something reasonable */
r_while
c_loop
(paren
op_logical_neg
op_star
id|bh
)paren
(brace
id|bh
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|nr
op_le
l_int|0
)paren
r_return
suffix:semicolon
)brace
id|dev
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|major
op_assign
id|MAJOR
c_func
(paren
id|bh
(braket
l_int|0
)braket
op_member_access_from_pointer
id|b_dev
)paren
)paren
OL
id|MAX_BLKDEV
)paren
id|dev
op_assign
id|blk_dev
op_plus
id|major
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dev
op_logical_or
op_logical_neg
id|dev-&gt;request_fn
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ll_rw_block: Trying to read nonexistent block-device %s (%ld)&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|bh
(braket
l_int|0
)braket
op_member_access_from_pointer
id|b_dev
)paren
comma
id|bh
(braket
l_int|0
)braket
op_member_access_from_pointer
id|b_blocknr
)paren
suffix:semicolon
r_goto
id|sorry
suffix:semicolon
)brace
multiline_comment|/* Determine correct block size for this device.  */
id|correct_size
op_assign
id|BLOCK_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|blksize_size
(braket
id|major
)braket
)paren
(brace
id|i
op_assign
id|blksize_size
(braket
id|major
)braket
(braket
id|MINOR
c_func
(paren
id|bh
(braket
l_int|0
)braket
op_member_access_from_pointer
id|b_dev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
id|correct_size
op_assign
id|i
suffix:semicolon
)brace
multiline_comment|/* Verify requested block sizes.  */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bh
(braket
id|i
)braket
op_logical_and
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_size
op_ne
id|correct_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ll_rw_block: device %s: &quot;
l_string|&quot;only %d-char blocks implemented (%lu)&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|bh
(braket
l_int|0
)braket
op_member_access_from_pointer
id|b_dev
)paren
comma
id|correct_size
comma
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_size
)paren
suffix:semicolon
r_goto
id|sorry
suffix:semicolon
)brace
multiline_comment|/* Md remaps blocks now */
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_rdev
op_assign
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_dev
suffix:semicolon
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_rsector
op_assign
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_blocknr
op_star
(paren
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_size
op_rshift
l_int|9
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_MD
r_if
c_cond
(paren
id|major
op_eq
id|MD_MAJOR
op_logical_and
id|md_map
(paren
id|MINOR
c_func
(paren
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_dev
)paren
comma
op_amp
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_rdev
comma
op_amp
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_rsector
comma
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_size
op_rshift
l_int|9
)paren
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;Bad md_map in ll_rw_block&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|sorry
suffix:semicolon
)brace
macro_line|#endif
)brace
r_if
c_cond
(paren
(paren
id|rw
op_eq
id|WRITE
op_logical_or
id|rw
op_eq
id|WRITEA
)paren
op_logical_and
id|is_read_only
c_func
(paren
id|bh
(braket
l_int|0
)braket
op_member_access_from_pointer
id|b_dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Can&squot;t write to read-only device %s&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|bh
(braket
l_int|0
)braket
op_member_access_from_pointer
id|b_dev
)paren
)paren
suffix:semicolon
r_goto
id|sorry
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bh
(braket
id|i
)braket
)paren
(brace
id|set_bit
c_func
(paren
id|BH_Req
comma
op_amp
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_state
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_MD
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_dev
)paren
op_eq
id|MD_MAJOR
)paren
(brace
id|md_make_request
c_func
(paren
id|MINOR
(paren
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_dev
)paren
comma
id|rw
comma
id|bh
(braket
id|i
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
macro_line|#endif
id|make_request
c_func
(paren
id|MAJOR
c_func
(paren
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_rdev
)paren
comma
id|rw
comma
id|bh
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
id|sorry
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bh
(braket
id|i
)braket
)paren
(brace
id|clear_bit
c_func
(paren
id|BH_Dirty
comma
op_amp
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_state
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh
(braket
id|i
)braket
op_member_access_from_pointer
id|b_state
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_STRAM_SWAP
r_extern
r_int
id|stram_device_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * First step of what used to be end_request&n; *&n; * 0 means continue with end_that_request_last,&n; * 1 means we are done&n; */
r_int
DECL|function|end_that_request_first
id|end_that_request_first
c_func
(paren
r_struct
id|request
op_star
id|req
comma
r_int
id|uptodate
comma
r_char
op_star
id|name
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|nsect
suffix:semicolon
id|req-&gt;errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;end_request: I/O error, dev %s (%s), sector %lu&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|req-&gt;rq_dev
)paren
comma
id|name
comma
id|req-&gt;sector
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|req-&gt;bh
)paren
op_ne
l_int|NULL
)paren
(brace
id|nsect
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|req-&gt;nr_sectors
op_decrement
suffix:semicolon
id|req-&gt;nr_sectors
op_and_assign
op_complement
(paren
id|nsect
op_minus
l_int|1
)paren
suffix:semicolon
id|req-&gt;sector
op_add_assign
id|nsect
suffix:semicolon
id|req-&gt;sector
op_and_assign
op_complement
(paren
id|nsect
op_minus
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|req-&gt;bh
)paren
op_ne
l_int|NULL
)paren
(brace
id|req-&gt;bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|req-&gt;bh
)paren
op_ne
l_int|NULL
)paren
(brace
id|req-&gt;current_nr_sectors
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;nr_sectors
OL
id|req-&gt;current_nr_sectors
)paren
(brace
id|req-&gt;nr_sectors
op_assign
id|req-&gt;current_nr_sectors
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;end_request: buffer-list destroyed&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|req-&gt;buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
DECL|function|end_that_request_last
id|end_that_request_last
c_func
(paren
r_struct
id|request
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;sem
op_ne
l_int|NULL
)paren
id|up
c_func
(paren
id|req-&gt;sem
)paren
suffix:semicolon
id|req-&gt;rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|wait_for_request
)paren
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|blk_dev_init
c_func
(paren
r_void
)paren
)paren
(brace
r_struct
id|request
op_star
id|req
suffix:semicolon
r_struct
id|blk_dev_struct
op_star
id|dev
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|blk_dev
op_plus
id|MAX_BLKDEV
suffix:semicolon
id|dev
op_decrement
op_ne
id|blk_dev
suffix:semicolon
)paren
(brace
id|dev-&gt;request_fn
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;queue
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;current_request
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;plug.rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
id|dev-&gt;plug.cmd
op_assign
op_minus
l_int|1
suffix:semicolon
id|dev-&gt;plug.next
op_assign
l_int|NULL
suffix:semicolon
id|dev-&gt;plug_tq.sync
op_assign
l_int|0
suffix:semicolon
id|dev-&gt;plug_tq.routine
op_assign
op_amp
id|unplug_device
suffix:semicolon
id|dev-&gt;plug_tq.data
op_assign
id|dev
suffix:semicolon
)brace
id|req
op_assign
id|all_requests
op_plus
id|NR_REQUEST
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|req
op_ge
id|all_requests
)paren
(brace
id|req-&gt;rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
id|req-&gt;next
op_assign
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ro_bits
comma
l_int|0
comma
r_sizeof
(paren
id|ro_bits
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|max_readahead
comma
l_int|0
comma
r_sizeof
(paren
id|max_readahead
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|max_sectors
comma
l_int|0
comma
r_sizeof
(paren
id|max_sectors
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_AMIGA_Z2RAM
id|z2_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_STRAM_SWAP
id|stram_device_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_RAM
id|rd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_LOOP
id|loop_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ISP16_CDI
id|isp16_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif CONFIG_ISP16_CDI
macro_line|#ifdef CONFIG_BLK_DEV_IDE
id|ide_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* this MUST precede hd_init */
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_HD
id|hd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_PS2
id|ps2esdi_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_XD
id|xd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_MFM
id|mfm_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PARIDE
(brace
r_extern
r_void
id|paride_init
c_func
(paren
r_void
)paren
suffix:semicolon
id|paride_init
c_func
(paren
)paren
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_MAC_FLOPPY
id|swim3_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_AMIGA_FLOPPY
id|amiga_floppy_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ATARI_FLOPPY
id|atari_floppy_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_FD
id|floppy_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
macro_line|#if !defined (__mc68000__) &amp;&amp; !defined(CONFIG_PMAC) &amp;&amp; !defined(__sparc__)&bslash;&n;    &amp;&amp; !defined(CONFIG_APUS)
id|outb_p
c_func
(paren
l_int|0xc
comma
l_int|0x3f2
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
macro_line|#ifdef CONFIG_CDU31A
id|cdu31a_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif CONFIG_CDU31A
macro_line|#ifdef CONFIG_ATARI_ACSI
id|acsi_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif CONFIG_ATARI_ACSI
macro_line|#ifdef CONFIG_MCD
id|mcd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif CONFIG_MCD
macro_line|#ifdef CONFIG_MCDX
id|mcdx_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif CONFIG_MCDX
macro_line|#ifdef CONFIG_SBPCD
id|sbpcd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif CONFIG_SBPCD
macro_line|#ifdef CONFIG_AZTCD
id|aztcd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif CONFIG_AZTCD
macro_line|#ifdef CONFIG_CDU535
id|sony535_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif CONFIG_CDU535
macro_line|#ifdef CONFIG_GSCD
id|gscd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif CONFIG_GSCD
macro_line|#ifdef CONFIG_CM206
id|cm206_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_OPTCD
id|optcd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif CONFIG_OPTCD
macro_line|#ifdef CONFIG_SJCD
id|sjcd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif CONFIG_SJCD
macro_line|#ifdef CONFIG_BLK_DEV_MD
id|md_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif CONFIG_BLK_DEV_MD
macro_line|#ifdef CONFIG_APBLOCK
id|ap_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_DDV
id|ddv_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_NBD
id|nbd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|io_request_lock
id|EXPORT_SYMBOL
c_func
(paren
id|io_request_lock
)paren
suffix:semicolon
DECL|variable|end_that_request_first
id|EXPORT_SYMBOL
c_func
(paren
id|end_that_request_first
)paren
suffix:semicolon
DECL|variable|end_that_request_last
id|EXPORT_SYMBOL
c_func
(paren
id|end_that_request_last
)paren
suffix:semicolon
eof
