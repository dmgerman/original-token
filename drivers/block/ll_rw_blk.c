multiline_comment|/*&n; *  linux/drivers/block/ll_rw_blk.c&n; *&n; * Copyright (C) 1991, 1992 Linus Torvalds&n; * Copyright (C) 1994,      Karl Keyte: Added support for disk statistics&n; * Elevator latency, (C) 2000  Andrea Arcangeli &lt;andrea@suse.de&gt; SuSE&n; * Queue request tables / lock, selectable elevator, Jens Axboe &lt;axboe@suse.de&gt;&n; * kernel-doc documentation started by NeilBrown &lt;neilb@cse.unsw.edu.au&gt; -  July2000&n; */
multiline_comment|/*&n; * This handles all read/write requests to block devices&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/kernel_stat.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/locks.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/highmem.h&gt;
macro_line|#include &lt;linux/raid/md.h&gt;
macro_line|#include &lt;linux/module.h&gt;
multiline_comment|/*&n; * MAC Floppy IWM hooks&n; */
macro_line|#ifdef CONFIG_MAC_FLOPPY_IWM
r_extern
r_int
id|mac_floppy_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_extern
r_int
id|lvm_init
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * For the allocated request tables&n; */
DECL|variable|request_cachep
r_static
id|kmem_cache_t
op_star
id|request_cachep
suffix:semicolon
multiline_comment|/*&n; * The &quot;disk&quot; task queue is used to start the actual requests&n; * after a plug&n; */
DECL|variable|tq_disk
id|DECLARE_TASK_QUEUE
c_func
(paren
id|tq_disk
)paren
suffix:semicolon
multiline_comment|/*&n; * Protect the request list against multiple users..&n; *&n; * With this spinlock the Linux block IO subsystem is 100% SMP threaded&n; * from the IRQ event side, and almost 100% SMP threaded from the syscall&n; * side (we still have protect against block device array operations, and&n; * the do_request() side is casually still unsafe. The kernel lock protects&n; * this part currently.).&n; *&n; * there is a fair chance that things will work just OK if these functions&n; * are called with no global kernel lock held ...&n; */
DECL|variable|io_request_lock
id|spinlock_t
id|io_request_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
multiline_comment|/* This specifies how many sectors to read ahead on the disk. */
DECL|variable|read_ahead
r_int
id|read_ahead
(braket
id|MAX_BLKDEV
)braket
suffix:semicolon
multiline_comment|/* blk_dev_struct is:&n; *&t;*request_fn&n; *&t;*current_request&n; */
DECL|variable|blk_dev
r_struct
id|blk_dev_struct
id|blk_dev
(braket
id|MAX_BLKDEV
)braket
suffix:semicolon
multiline_comment|/* initialized by blk_dev_init() */
multiline_comment|/*&n; * blk_size contains the size of all block-devices in units of 1024 byte&n; * sectors:&n; *&n; * blk_size[MAJOR][MINOR]&n; *&n; * if (!blk_size[MAJOR]) then no minor size checking is done.&n; */
DECL|variable|blk_size
r_int
op_star
id|blk_size
(braket
id|MAX_BLKDEV
)braket
suffix:semicolon
multiline_comment|/*&n; * blksize_size contains the size of all block-devices:&n; *&n; * blksize_size[MAJOR][MINOR]&n; *&n; * if (!blksize_size[MAJOR]) then 1024 bytes is assumed.&n; */
DECL|variable|blksize_size
r_int
op_star
id|blksize_size
(braket
id|MAX_BLKDEV
)braket
suffix:semicolon
multiline_comment|/*&n; * hardsect_size contains the size of the hardware sector of a device.&n; *&n; * hardsect_size[MAJOR][MINOR]&n; *&n; * if (!hardsect_size[MAJOR])&n; *&t;&t;then 512 bytes is assumed.&n; * else&n; *&t;&t;sector_size is hardsect_size[MAJOR][MINOR]&n; * This is currently set by some scsi devices and read by the msdos fs driver.&n; * Other uses may appear later.&n; */
DECL|variable|hardsect_size
r_int
op_star
id|hardsect_size
(braket
id|MAX_BLKDEV
)braket
suffix:semicolon
multiline_comment|/*&n; * The following tunes the read-ahead algorithm in mm/filemap.c&n; */
DECL|variable|max_readahead
r_int
op_star
id|max_readahead
(braket
id|MAX_BLKDEV
)braket
suffix:semicolon
multiline_comment|/*&n; * Max number of sectors per request&n; */
DECL|variable|max_sectors
r_int
op_star
id|max_sectors
(braket
id|MAX_BLKDEV
)braket
suffix:semicolon
DECL|function|get_max_sectors
r_static
r_inline
r_int
id|get_max_sectors
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|max_sectors
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
)paren
r_return
id|MAX_SECTORS
suffix:semicolon
r_return
id|max_sectors
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
suffix:semicolon
)brace
DECL|function|__blk_get_queue
r_static
r_inline
id|request_queue_t
op_star
id|__blk_get_queue
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_struct
id|blk_dev_struct
op_star
id|bdev
op_assign
id|blk_dev
op_plus
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bdev-&gt;queue
)paren
r_return
id|bdev
op_member_access_from_pointer
id|queue
c_func
(paren
id|dev
)paren
suffix:semicolon
r_else
r_return
op_amp
id|blk_dev
(braket
id|MAJOR
c_func
(paren
id|dev
)paren
)braket
dot
id|request_queue
suffix:semicolon
)brace
multiline_comment|/*&n; * NOTE: the device-specific queue() functions&n; * have to be atomic!&n; */
DECL|function|blk_get_queue
id|request_queue_t
op_star
id|blk_get_queue
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
id|request_queue_t
op_star
id|ret
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|ret
op_assign
id|__blk_get_queue
c_func
(paren
id|dev
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|__blk_cleanup_queue
r_static
r_int
id|__blk_cleanup_queue
c_func
(paren
r_struct
id|list_head
op_star
id|head
)paren
(brace
r_struct
id|list_head
op_star
id|entry
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_int
id|i
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|head
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|entry
op_assign
id|head-&gt;next
suffix:semicolon
r_do
(brace
id|rq
op_assign
id|list_entry
c_func
(paren
id|entry
comma
r_struct
id|request
comma
id|table
)paren
suffix:semicolon
id|entry
op_assign
id|entry-&gt;next
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|rq-&gt;table
)paren
suffix:semicolon
id|kmem_cache_free
c_func
(paren
id|request_cachep
comma
id|rq
)paren
suffix:semicolon
id|i
op_increment
suffix:semicolon
)brace
r_while
c_loop
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|head
)paren
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
multiline_comment|/**&n; * blk_cleanup_queue: - release a &amp;request_queue_t when it is no longer needed&n; * @q:    the request queue to be released&n; *&n; * Description:&n; *     blk_cleanup_queue is the pair to blk_init_queue().  It should&n; *     be called when a request queue is being released; typically&n; *     when a block device is being de-registered.  Currently, its&n; *     primary task it to free all the &amp;struct request structures that&n; *     were allocated to the queue.&n; * Caveat: &n; *     Hopefully the low level driver will have finished any&n; *     outstanding requests first...&n; **/
DECL|function|blk_cleanup_queue
r_void
id|blk_cleanup_queue
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_int
id|count
op_assign
id|QUEUE_NR_REQUESTS
suffix:semicolon
id|count
op_sub_assign
id|__blk_cleanup_queue
c_func
(paren
op_amp
id|q-&gt;request_freelist
(braket
id|READ
)braket
)paren
suffix:semicolon
id|count
op_sub_assign
id|__blk_cleanup_queue
c_func
(paren
op_amp
id|q-&gt;request_freelist
(braket
id|WRITE
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
id|printk
c_func
(paren
l_string|&quot;blk_cleanup_queue: leaked requests (%d)&bslash;n&quot;
comma
id|count
)paren
suffix:semicolon
id|memset
c_func
(paren
id|q
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|q
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * blk_queue_headactive - indicate whether head of request queue may be active&n; * @q:       The queue which this applies to.&n; * @active:  A flag indication where the head of the queue is active.&n; *&n; * Description:&n; *    The driver for a block device may choose to leave the currently active&n; *    request on the request queue, removing it only when it has completed.&n; *    The queue handling routines assume this by default for safety reasons&n; *    and will not involve the head of the request queue in any merging or&n; *    reordering of requests when the queue is unplugged (and thus may be&n; *    working on this particular request).&n; *&n; *    If a driver removes requests from the queue before processing them, then&n; *    it may indicate that it does so, there by allowing the head of the queue&n; *    to be involved in merging and reordering.  This is done be calling&n; *    blk_queue_headactive() with an @active flag of %0.&n; *&n; *    If a driver processes several requests at once, it must remove them (or&n; *    at least all but one of them) from the request queue.&n; *&n; *    When a queue is plugged (see blk_queue_pluggable()) the head will be&n; *    assumed to be inactive.&n; **/
DECL|function|blk_queue_headactive
r_void
id|blk_queue_headactive
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|active
)paren
(brace
id|q-&gt;head_active
op_assign
id|active
suffix:semicolon
)brace
multiline_comment|/**&n; * blk_queue_pluggable - define a plugging function for a request queue&n; * @q:   the request queue to which the function will apply&n; * @plug: the function to be called to plug a queue&n; *&n; * Description:&n; *   A request queue will be &quot;plugged&quot; if a request is added to it&n; *   while it is empty.  This allows a number of requests to be added&n; *   before any are processed, thus providing an opportunity for these&n; *   requests to be merged or re-ordered.&n; *   The default plugging function (generic_plug_device()) sets the&n; *   &quot;plugged&quot; flag for the queue and adds a task to the $tq_disk task&n; *   queue to unplug the queue and call the request function at a&n; *   later time.&n; *&n; *   A device driver may provide an alternate plugging function by&n; *   passing it to blk_queue_pluggable().  This function should set&n; *   the &quot;plugged&quot; flag if it want calls to the request_function to be&n; *   blocked, and should place a task on $tq_disk which will unplug&n; *   the queue.  Alternately it can simply do nothing and there-by&n; *   disable plugging of the device.&n; **/
DECL|function|blk_queue_pluggable
r_void
id|blk_queue_pluggable
(paren
id|request_queue_t
op_star
id|q
comma
id|plug_device_fn
op_star
id|plug
)paren
(brace
id|q-&gt;plug_device_fn
op_assign
id|plug
suffix:semicolon
)brace
multiline_comment|/**&n; * blk_queue_make_request - define an alternate make_request function for a device&n; * @q:  the request queue for the device to be affected&n; * @mfn: the alternate make_request function&n; *&n; * Description:&n; *    The normal way for &amp;struct buffer_heads to be passed to a device&n; *    driver is for them to be collected into requests on a request&n; *    queue, and then to allow the device driver to select requests&n; *    off that queue when it is ready.  This works well for many block&n; *    devices. However some block devices (typically virtual devices&n; *    such as md or lvm) do not benefit from the processing on the&n; *    request queue, and are served best by having the requests passed&n; *    directly to them.  This can be achieved by providing a function&n; *    to blk_queue_make_request().&n; *&n; * Caveat:&n; *    The driver that does this *must* be able to deal appropriately&n; *    with buffers in &quot;highmemory&quot;, either by calling bh_kmap() to get&n; *    a kernel mapping, to by calling create_bounce() to create a&n; *    buffer in normal memory.&n; **/
DECL|function|blk_queue_make_request
r_void
id|blk_queue_make_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
id|make_request_fn
op_star
id|mfn
)paren
(brace
id|q-&gt;make_request_fn
op_assign
id|mfn
suffix:semicolon
)brace
DECL|function|ll_new_segment
r_static
r_inline
r_int
id|ll_new_segment
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_int
id|max_segments
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;nr_segments
OL
id|max_segments
)paren
(brace
id|req-&gt;nr_segments
op_increment
suffix:semicolon
id|q-&gt;elevator.nr_segments
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|ll_back_merge_fn
r_static
r_int
id|ll_back_merge_fn
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|max_segments
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;bhtail-&gt;b_data
op_plus
id|req-&gt;bhtail-&gt;b_size
op_eq
id|bh-&gt;b_data
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|ll_new_segment
c_func
(paren
id|q
comma
id|req
comma
id|max_segments
)paren
suffix:semicolon
)brace
DECL|function|ll_front_merge_fn
r_static
r_int
id|ll_front_merge_fn
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|max_segments
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_data
op_plus
id|bh-&gt;b_size
op_eq
id|req-&gt;bh-&gt;b_data
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|ll_new_segment
c_func
(paren
id|q
comma
id|req
comma
id|max_segments
)paren
suffix:semicolon
)brace
DECL|function|ll_merge_requests_fn
r_static
r_int
id|ll_merge_requests_fn
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_struct
id|request
op_star
id|next
comma
r_int
id|max_segments
)paren
(brace
r_int
id|total_segments
op_assign
id|req-&gt;nr_segments
op_plus
id|next-&gt;nr_segments
suffix:semicolon
r_int
id|same_segment
suffix:semicolon
id|same_segment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;bhtail-&gt;b_data
op_plus
id|req-&gt;bhtail-&gt;b_size
op_eq
id|next-&gt;bh-&gt;b_data
)paren
(brace
id|total_segments
op_decrement
suffix:semicolon
id|same_segment
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|total_segments
OG
id|max_segments
)paren
r_return
l_int|0
suffix:semicolon
id|q-&gt;elevator.nr_segments
op_sub_assign
id|same_segment
suffix:semicolon
id|req-&gt;nr_segments
op_assign
id|total_segments
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * &quot;plug&quot; the device if there are no outstanding requests: this will&n; * force the transfer to start only after we have put all the requests&n; * on the list.&n; *&n; * This is called with interrupts off and no requests on the queue.&n; * (and with the request spinlock acquired)&n; */
DECL|function|generic_plug_device
r_static
r_void
id|generic_plug_device
c_func
(paren
id|request_queue_t
op_star
id|q
comma
id|kdev_t
id|dev
)paren
(brace
multiline_comment|/*&n;&t; * no need to replug device&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|q-&gt;queue_head
)paren
op_logical_or
id|q-&gt;plugged
)paren
r_return
suffix:semicolon
id|q-&gt;plugged
op_assign
l_int|1
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|q-&gt;plug_tq
comma
op_amp
id|tq_disk
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * remove the plug and let it rip..&n; */
DECL|function|__generic_unplug_device
r_static
r_inline
r_void
id|__generic_unplug_device
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_if
c_cond
(paren
id|q-&gt;plugged
)paren
(brace
id|q-&gt;plugged
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|q-&gt;queue_head
)paren
)paren
id|q
op_member_access_from_pointer
id|request_fn
c_func
(paren
id|q
)paren
suffix:semicolon
)brace
)brace
DECL|function|generic_unplug_device
r_static
r_void
id|generic_unplug_device
c_func
(paren
r_void
op_star
id|data
)paren
(brace
id|request_queue_t
op_star
id|q
op_assign
(paren
id|request_queue_t
op_star
)paren
id|data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|__generic_unplug_device
c_func
(paren
id|q
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|blk_init_free_list
r_static
r_void
id|blk_init_free_list
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Divide requests in half between read and write. This used to&n;&t; * be a 2/3 advantage for reads, but now reads can steal from&n;&t; * the write free list.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|QUEUE_NR_REQUESTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rq
op_assign
id|kmem_cache_alloc
c_func
(paren
id|request_cachep
comma
id|SLAB_KERNEL
)paren
suffix:semicolon
id|rq-&gt;rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
id|list_add
c_func
(paren
op_amp
id|rq-&gt;table
comma
op_amp
id|q-&gt;request_freelist
(braket
id|i
op_amp
l_int|1
)braket
)paren
suffix:semicolon
)brace
id|init_waitqueue_head
c_func
(paren
op_amp
id|q-&gt;wait_for_request
)paren
suffix:semicolon
id|spin_lock_init
c_func
(paren
op_amp
id|q-&gt;request_lock
)paren
suffix:semicolon
)brace
r_static
r_int
id|__make_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
suffix:semicolon
multiline_comment|/**&n; * blk_init_queue  - prepare a request queue for use with a block device&n; * @q:    The &amp;request_queue_t to be initialised&n; * @rfn:  The function to be called to process requests that have been&n; *        placed on the queue.&n; *&n; * Description:&n; *    If a block device wishes to use the standard request handling procedures,&n; *    which sorts requests and coalesces adjacent requests, then it must&n; *    call blk_init_queue().  The function @rfn will be called when there&n; *    are requests on the queue that need to be processed.  If the device&n; *    supports plugging, then @rfn may not be called immediately when requests&n; *    are available on the queue, but may be called at some time later instead.&n; *    Plugged queues are generally unplugged when a buffer belonging to one&n; *    of the requests on the queue is needed, or due to memory pressure.&n; *&n; *    @rfn is not required, or even expected, to remove all requests off the&n; *    queue, but only as many as it can handle at a time.  If it does leave&n; *    requests on the queue, it is responsible for arranging that the requests&n; *    get dealt with eventually.&n; *&n; *    A global spin lock $io_request_lock must be held while manipulating the&n; *    requests on the request queue.&n; *&n; *    The request on the head of the queue is by default assumed to be&n; *    potentially active, and it is not considered for re-ordering or merging&n; *    whenever the given queue is unplugged. This behaviour can be changed with&n; *    blk_queue_headactive().&n; *&n; * Note:&n; *    blk_init_queue() must be paired with a blk_cleanup-queue() call&n; *    when the block device is deactivated (such as at module unload).&n; **/
DECL|function|blk_init_queue
r_void
id|blk_init_queue
c_func
(paren
id|request_queue_t
op_star
id|q
comma
id|request_fn_proc
op_star
id|rfn
)paren
(brace
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;queue_head
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;request_freelist
(braket
id|READ
)braket
)paren
suffix:semicolon
id|INIT_LIST_HEAD
c_func
(paren
op_amp
id|q-&gt;request_freelist
(braket
id|WRITE
)braket
)paren
suffix:semicolon
id|elevator_init
c_func
(paren
op_amp
id|q-&gt;elevator
comma
id|ELEVATOR_LINUS
)paren
suffix:semicolon
id|blk_init_free_list
c_func
(paren
id|q
)paren
suffix:semicolon
id|q-&gt;request_fn
op_assign
id|rfn
suffix:semicolon
id|q-&gt;back_merge_fn
op_assign
id|ll_back_merge_fn
suffix:semicolon
id|q-&gt;front_merge_fn
op_assign
id|ll_front_merge_fn
suffix:semicolon
id|q-&gt;merge_requests_fn
op_assign
id|ll_merge_requests_fn
suffix:semicolon
id|q-&gt;make_request_fn
op_assign
id|__make_request
suffix:semicolon
id|q-&gt;plug_tq.sync
op_assign
l_int|0
suffix:semicolon
id|q-&gt;plug_tq.routine
op_assign
op_amp
id|generic_unplug_device
suffix:semicolon
id|q-&gt;plug_tq.data
op_assign
id|q
suffix:semicolon
id|q-&gt;plugged
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * These booleans describe the queue properties.  We set the&n;&t; * default (and most common) values here.  Other drivers can&n;&t; * use the appropriate functions to alter the queue properties.&n;&t; * as appropriate.&n;&t; */
id|q-&gt;plug_device_fn
op_assign
id|generic_plug_device
suffix:semicolon
id|q-&gt;head_active
op_assign
l_int|1
suffix:semicolon
)brace
DECL|macro|blkdev_free_rq
mdefine_line|#define blkdev_free_rq(list) list_entry((list)-&gt;next, struct request, table);
multiline_comment|/*&n; * Get a free request. io_request_lock must be held and interrupts&n; * disabled on the way in.&n; */
DECL|function|get_request
r_static
r_inline
r_struct
id|request
op_star
id|get_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|rw
)paren
(brace
r_struct
id|list_head
op_star
id|list
op_assign
op_amp
id|q-&gt;request_freelist
(braket
id|rw
)braket
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
multiline_comment|/*&n;&t; * Reads get preferential treatment and are allowed to steal&n;&t; * from the write free list if necessary.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
id|list
)paren
)paren
(brace
id|rq
op_assign
id|blkdev_free_rq
c_func
(paren
id|list
)paren
suffix:semicolon
r_goto
id|got_rq
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * if the WRITE list is non-empty, we know that rw is READ&n;&t; * and that the READ list is empty. allow reads to &squot;steal&squot;&n;&t; * from the WRITE list.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|list_empty
c_func
(paren
op_amp
id|q-&gt;request_freelist
(braket
id|WRITE
)braket
)paren
)paren
(brace
id|list
op_assign
op_amp
id|q-&gt;request_freelist
(braket
id|WRITE
)braket
suffix:semicolon
id|rq
op_assign
id|blkdev_free_rq
c_func
(paren
id|list
)paren
suffix:semicolon
r_goto
id|got_rq
suffix:semicolon
)brace
r_return
l_int|NULL
suffix:semicolon
id|got_rq
suffix:colon
id|list_del
c_func
(paren
op_amp
id|rq-&gt;table
)paren
suffix:semicolon
id|rq-&gt;free_list
op_assign
id|list
suffix:semicolon
id|rq-&gt;rq_status
op_assign
id|RQ_ACTIVE
suffix:semicolon
id|rq-&gt;special
op_assign
l_int|NULL
suffix:semicolon
id|rq-&gt;q
op_assign
id|q
suffix:semicolon
r_return
id|rq
suffix:semicolon
)brace
multiline_comment|/*&n; * No available requests for this queue, unplug the device.&n; */
DECL|function|__get_request_wait
r_static
r_struct
id|request
op_star
id|__get_request_wait
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|rw
)paren
(brace
r_register
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue_exclusive
c_func
(paren
op_amp
id|q-&gt;wait_for_request
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|__set_current_state
c_func
(paren
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|rq
op_assign
id|get_request
c_func
(paren
id|q
comma
id|rw
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq
)paren
r_break
suffix:semicolon
id|generic_unplug_device
c_func
(paren
id|q
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|remove_wait_queue
c_func
(paren
op_amp
id|q-&gt;wait_for_request
comma
op_amp
id|wait
)paren
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_RUNNING
suffix:semicolon
r_return
id|rq
suffix:semicolon
)brace
DECL|function|get_request_wait
r_static
r_inline
r_struct
id|request
op_star
id|get_request_wait
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|rw
)paren
(brace
r_register
r_struct
id|request
op_star
id|rq
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|rq
op_assign
id|get_request
c_func
(paren
id|q
comma
id|rw
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rq
)paren
r_return
id|rq
suffix:semicolon
r_return
id|__get_request_wait
c_func
(paren
id|q
comma
id|rw
)paren
suffix:semicolon
)brace
multiline_comment|/* RO fail safe mechanism */
DECL|variable|ro_bits
r_static
r_int
id|ro_bits
(braket
id|MAX_BLKDEV
)braket
(braket
l_int|8
)braket
suffix:semicolon
DECL|function|is_read_only
r_int
id|is_read_only
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|minor
comma
id|major
suffix:semicolon
id|major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
OL
l_int|0
op_logical_or
id|major
op_ge
id|MAX_BLKDEV
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|ro_bits
(braket
id|major
)braket
(braket
id|minor
op_rshift
l_int|5
)braket
op_amp
(paren
l_int|1
op_lshift
(paren
id|minor
op_amp
l_int|31
)paren
)paren
suffix:semicolon
)brace
DECL|function|set_device_ro
r_void
id|set_device_ro
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|flag
)paren
(brace
r_int
id|minor
comma
id|major
suffix:semicolon
id|major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
OL
l_int|0
op_logical_or
id|major
op_ge
id|MAX_BLKDEV
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|flag
)paren
id|ro_bits
(braket
id|major
)braket
(braket
id|minor
op_rshift
l_int|5
)braket
op_or_assign
l_int|1
op_lshift
(paren
id|minor
op_amp
l_int|31
)paren
suffix:semicolon
r_else
id|ro_bits
(braket
id|major
)braket
(braket
id|minor
op_rshift
l_int|5
)braket
op_and_assign
op_complement
(paren
l_int|1
op_lshift
(paren
id|minor
op_amp
l_int|31
)paren
)paren
suffix:semicolon
)brace
DECL|function|drive_stat_acct
r_inline
r_void
id|drive_stat_acct
(paren
id|kdev_t
id|dev
comma
r_int
id|rw
comma
r_int
r_int
id|nr_sectors
comma
r_int
id|new_io
)paren
(brace
r_int
r_int
id|major
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|index
suffix:semicolon
id|index
op_assign
id|disk_index
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|index
op_ge
id|DK_MAX_DISK
)paren
op_logical_or
(paren
id|major
op_ge
id|DK_MAX_MAJOR
)paren
)paren
r_return
suffix:semicolon
id|kstat.dk_drive
(braket
id|major
)braket
(braket
id|index
)braket
op_add_assign
id|new_io
suffix:semicolon
r_if
c_cond
(paren
id|rw
op_eq
id|READ
)paren
(brace
id|kstat.dk_drive_rio
(braket
id|major
)braket
(braket
id|index
)braket
op_add_assign
id|new_io
suffix:semicolon
id|kstat.dk_drive_rblk
(braket
id|major
)braket
(braket
id|index
)braket
op_add_assign
id|nr_sectors
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rw
op_eq
id|WRITE
)paren
(brace
id|kstat.dk_drive_wio
(braket
id|major
)braket
(braket
id|index
)braket
op_add_assign
id|new_io
suffix:semicolon
id|kstat.dk_drive_wblk
(braket
id|major
)braket
(braket
id|index
)braket
op_add_assign
id|nr_sectors
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;drive_stat_acct: cmd not R/W?&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * add-request adds a request to the linked list.&n; * It disables interrupts (acquires the request spinlock) so that it can muck&n; * with the request-lists in peace. Thus it should be called with no spinlocks&n; * held.&n; *&n; * By this point, req-&gt;cmd is always either READ/WRITE, never READA,&n; * which is important for drive_stat_acct() above.&n; */
DECL|function|add_request
r_static
r_inline
r_void
id|add_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_struct
id|list_head
op_star
id|head
comma
r_int
id|lat
)paren
(brace
r_int
id|major
suffix:semicolon
id|drive_stat_acct
c_func
(paren
id|req-&gt;rq_dev
comma
id|req-&gt;cmd
comma
id|req-&gt;nr_sectors
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * let selected elevator insert the request&n;&t; */
id|q-&gt;elevator
dot
id|elevator_fn
c_func
(paren
id|req
comma
op_amp
id|q-&gt;elevator
comma
op_amp
id|q-&gt;queue_head
comma
id|head
comma
id|lat
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME(eric) I don&squot;t understand why there is a need for this&n;&t; * special case code.  It clearly doesn&squot;t fit any more with&n;&t; * the new queueing architecture, and it got added in 2.3.10.&n;&t; * I am leaving this in here until I hear back from the COMPAQ&n;&t; * people.&n;         */
id|major
op_assign
id|MAJOR
c_func
(paren
id|req-&gt;rq_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
op_ge
id|COMPAQ_SMART2_MAJOR
op_plus
l_int|0
op_logical_and
id|major
op_le
id|COMPAQ_SMART2_MAJOR
op_plus
l_int|7
)paren
(paren
id|q-&gt;request_fn
)paren
(paren
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
op_ge
id|COMPAQ_CISS_MAJOR
op_plus
l_int|0
op_logical_and
id|major
op_le
id|COMPAQ_CISS_MAJOR
op_plus
l_int|7
)paren
(paren
id|q-&gt;request_fn
)paren
(paren
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|major
op_ge
id|DAC960_MAJOR
op_plus
l_int|0
op_logical_and
id|major
op_le
id|DAC960_MAJOR
op_plus
l_int|7
)paren
(paren
id|q-&gt;request_fn
)paren
(paren
id|q
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Must be called with io_request_lock held and interrupts disabled&n; */
DECL|function|blkdev_release_request
r_void
r_inline
id|blkdev_release_request
c_func
(paren
r_struct
id|request
op_star
id|req
)paren
(brace
id|req-&gt;rq_status
op_assign
id|RQ_INACTIVE
suffix:semicolon
multiline_comment|/*&n;&t; * Request may not have originated from ll_rw_blk&n;&t; */
r_if
c_cond
(paren
id|req-&gt;free_list
)paren
(brace
id|list_add
c_func
(paren
op_amp
id|req-&gt;table
comma
id|req-&gt;free_list
)paren
suffix:semicolon
id|req-&gt;free_list
op_assign
l_int|NULL
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|req-&gt;q-&gt;wait_for_request
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Has to be called with the request spinlock acquired&n; */
DECL|function|attempt_merge
r_static
r_void
id|attempt_merge
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_int
id|max_sectors
comma
r_int
id|max_segments
)paren
(brace
r_struct
id|request
op_star
id|next
suffix:semicolon
id|next
op_assign
id|blkdev_next_request
c_func
(paren
id|req
)paren
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;sector
op_plus
id|req-&gt;nr_sectors
op_ne
id|next-&gt;sector
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;cmd
op_ne
id|next-&gt;cmd
op_logical_or
id|req-&gt;rq_dev
op_ne
id|next-&gt;rq_dev
op_logical_or
id|req-&gt;nr_sectors
op_plus
id|next-&gt;nr_sectors
OG
id|max_sectors
op_logical_or
id|next-&gt;sem
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If we are not allowed to merge these requests, then&n;&t; * return.  If we are allowed to merge, then the count&n;&t; * will have been updated to the appropriate number,&n;&t; * and we shouldn&squot;t do it here too.&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|q-&gt;merge_requests_fn
)paren
(paren
id|q
comma
id|req
comma
id|next
comma
id|max_segments
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|req-&gt;bhtail-&gt;b_reqnext
op_assign
id|next-&gt;bh
suffix:semicolon
id|req-&gt;bhtail
op_assign
id|next-&gt;bhtail
suffix:semicolon
id|req-&gt;nr_sectors
op_assign
id|req-&gt;hard_nr_sectors
op_add_assign
id|next-&gt;hard_nr_sectors
suffix:semicolon
id|list_del
c_func
(paren
op_amp
id|next-&gt;queue
)paren
suffix:semicolon
id|blkdev_release_request
c_func
(paren
id|next
)paren
suffix:semicolon
)brace
DECL|function|attempt_back_merge
r_static
r_inline
r_void
id|attempt_back_merge
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_int
id|max_sectors
comma
r_int
id|max_segments
)paren
(brace
r_if
c_cond
(paren
op_amp
id|req-&gt;queue
op_eq
id|q-&gt;queue_head.prev
)paren
r_return
suffix:semicolon
id|attempt_merge
c_func
(paren
id|q
comma
id|req
comma
id|max_sectors
comma
id|max_segments
)paren
suffix:semicolon
)brace
DECL|function|attempt_front_merge
r_static
r_inline
r_void
id|attempt_front_merge
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|list_head
op_star
id|head
comma
r_struct
id|request
op_star
id|req
comma
r_int
id|max_sectors
comma
r_int
id|max_segments
)paren
(brace
r_struct
id|list_head
op_star
id|prev
suffix:semicolon
id|prev
op_assign
id|req-&gt;queue.prev
suffix:semicolon
r_if
c_cond
(paren
id|head
op_eq
id|prev
)paren
r_return
suffix:semicolon
id|attempt_merge
c_func
(paren
id|q
comma
id|blkdev_entry_to_request
c_func
(paren
id|prev
)paren
comma
id|max_sectors
comma
id|max_segments
)paren
suffix:semicolon
)brace
DECL|function|__make_request
r_static
r_int
id|__make_request
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
r_int
id|sector
comma
id|count
suffix:semicolon
r_int
id|max_segments
op_assign
id|MAX_SEGMENTS
suffix:semicolon
r_struct
id|request
op_star
id|req
op_assign
l_int|NULL
comma
op_star
id|freereq
op_assign
l_int|NULL
suffix:semicolon
r_int
id|rw_ahead
comma
id|max_sectors
comma
id|el_ret
suffix:semicolon
r_struct
id|list_head
op_star
id|head
suffix:semicolon
r_int
id|latency
suffix:semicolon
id|elevator_t
op_star
id|elevator
op_assign
op_amp
id|q-&gt;elevator
suffix:semicolon
id|count
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|sector
op_assign
id|bh-&gt;b_rsector
suffix:semicolon
id|rw_ahead
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* normal case; gets changed below for READA */
r_switch
c_cond
(paren
id|rw
)paren
(brace
r_case
id|READA
suffix:colon
id|rw_ahead
op_assign
l_int|1
suffix:semicolon
id|rw
op_assign
id|READ
suffix:semicolon
multiline_comment|/* drop into READ */
r_case
id|READ
suffix:colon
r_case
id|WRITE
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_goto
id|end_io
suffix:semicolon
)brace
multiline_comment|/* We&squot;d better have a real physical mapping!&n;&t;   Check this bit only if the buffer was dirty and just locked&n;&t;   down by us so at this point flushpage will block and&n;&t;   won&squot;t clear the mapped bit under us. */
r_if
c_cond
(paren
op_logical_neg
id|buffer_mapped
c_func
(paren
id|bh
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Temporary solution - in 2.5 this will be done by the lowlevel&n;&t; * driver. Create a bounce buffer if the buffer data points into&n;&t; * high memory - keep the original buffer otherwise.&n;&t; */
macro_line|#if CONFIG_HIGHMEM
id|bh
op_assign
id|create_bounce
c_func
(paren
id|rw
comma
id|bh
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* look for a free request. */
multiline_comment|/*&n;&t; * Try to coalesce the new request with old requests&n;&t; */
id|max_sectors
op_assign
id|get_max_sectors
c_func
(paren
id|bh-&gt;b_rdev
)paren
suffix:semicolon
id|latency
op_assign
id|elevator_request_latency
c_func
(paren
id|elevator
comma
id|rw
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now we acquire the request spinlock, we have to be mega careful&n;&t; * not to schedule or do something nonatomic&n;&t; */
id|again
suffix:colon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * skip first entry, for devices with active queue head&n;&t; */
id|head
op_assign
op_amp
id|q-&gt;queue_head
suffix:semicolon
r_if
c_cond
(paren
id|q-&gt;head_active
op_logical_and
op_logical_neg
id|q-&gt;plugged
)paren
id|head
op_assign
id|head-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|head
)paren
)paren
(brace
id|q
op_member_access_from_pointer
id|plug_device_fn
c_func
(paren
id|q
comma
id|bh-&gt;b_rdev
)paren
suffix:semicolon
multiline_comment|/* is atomic */
r_goto
id|get_rq
suffix:semicolon
)brace
id|el_ret
op_assign
id|elevator
op_member_access_from_pointer
id|elevator_merge_fn
c_func
(paren
id|q
comma
op_amp
id|req
comma
id|bh
comma
id|rw
comma
op_amp
id|max_sectors
comma
op_amp
id|max_segments
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|el_ret
)paren
(brace
r_case
id|ELEVATOR_BACK_MERGE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|q
op_member_access_from_pointer
id|back_merge_fn
c_func
(paren
id|q
comma
id|req
comma
id|bh
comma
id|max_segments
)paren
)paren
r_break
suffix:semicolon
id|req-&gt;bhtail-&gt;b_reqnext
op_assign
id|bh
suffix:semicolon
id|req-&gt;bhtail
op_assign
id|bh
suffix:semicolon
id|req-&gt;nr_sectors
op_assign
id|req-&gt;hard_nr_sectors
op_add_assign
id|count
suffix:semicolon
id|req-&gt;e
op_assign
id|elevator
suffix:semicolon
id|drive_stat_acct
c_func
(paren
id|req-&gt;rq_dev
comma
id|req-&gt;cmd
comma
id|count
comma
l_int|0
)paren
suffix:semicolon
id|attempt_back_merge
c_func
(paren
id|q
comma
id|req
comma
id|max_sectors
comma
id|max_segments
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
r_case
id|ELEVATOR_FRONT_MERGE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|q
op_member_access_from_pointer
id|front_merge_fn
c_func
(paren
id|q
comma
id|req
comma
id|bh
comma
id|max_segments
)paren
)paren
r_break
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
id|req-&gt;bh
suffix:semicolon
id|req-&gt;bh
op_assign
id|bh
suffix:semicolon
id|req-&gt;buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|req-&gt;current_nr_sectors
op_assign
id|count
suffix:semicolon
id|req-&gt;sector
op_assign
id|req-&gt;hard_sector
op_assign
id|sector
suffix:semicolon
id|req-&gt;nr_sectors
op_assign
id|req-&gt;hard_nr_sectors
op_add_assign
id|count
suffix:semicolon
id|req-&gt;e
op_assign
id|elevator
suffix:semicolon
id|drive_stat_acct
c_func
(paren
id|req-&gt;rq_dev
comma
id|req-&gt;cmd
comma
id|count
comma
l_int|0
)paren
suffix:semicolon
id|attempt_front_merge
c_func
(paren
id|q
comma
id|head
comma
id|req
comma
id|max_sectors
comma
id|max_segments
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
multiline_comment|/*&n;&t;&t; * elevator says don&squot;t/can&squot;t merge. get new request&n;&t;&t; */
r_case
id|ELEVATOR_NO_MERGE
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;elevator returned crap (%d)&bslash;n&quot;
comma
id|el_ret
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Grab a free request from the freelist. Read first try their&n;&t; * own queue - if that is empty, we steal from the write list.&n;&t; * Writes must block if the write list is empty, and read aheads&n;&t; * are not crucial.&n;&t; */
id|get_rq
suffix:colon
r_if
c_cond
(paren
id|freereq
)paren
(brace
id|req
op_assign
id|freereq
suffix:semicolon
id|freereq
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|req
op_assign
id|get_request
c_func
(paren
id|q
comma
id|rw
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rw_ahead
)paren
r_goto
id|end_io
suffix:semicolon
id|freereq
op_assign
id|__get_request_wait
c_func
(paren
id|q
comma
id|rw
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
multiline_comment|/* fill up the request-info, and add it to the queue */
id|req-&gt;cmd
op_assign
id|rw
suffix:semicolon
id|req-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|req-&gt;hard_sector
op_assign
id|req-&gt;sector
op_assign
id|sector
suffix:semicolon
id|req-&gt;hard_nr_sectors
op_assign
id|req-&gt;nr_sectors
op_assign
id|count
suffix:semicolon
id|req-&gt;current_nr_sectors
op_assign
id|count
suffix:semicolon
id|req-&gt;nr_segments
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Always 1 for a new request. */
id|req-&gt;nr_hw_segments
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Always 1 for a new request. */
id|req-&gt;buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|req-&gt;sem
op_assign
l_int|NULL
suffix:semicolon
id|req-&gt;bh
op_assign
id|bh
suffix:semicolon
id|req-&gt;bhtail
op_assign
id|bh
suffix:semicolon
id|req-&gt;rq_dev
op_assign
id|bh-&gt;b_rdev
suffix:semicolon
id|req-&gt;e
op_assign
id|elevator
suffix:semicolon
id|add_request
c_func
(paren
id|q
comma
id|req
comma
id|head
comma
id|latency
)paren
suffix:semicolon
id|out
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|q-&gt;plugged
)paren
(paren
id|q-&gt;request_fn
)paren
(paren
id|q
)paren
suffix:semicolon
r_if
c_cond
(paren
id|freereq
)paren
id|blkdev_release_request
c_func
(paren
id|freereq
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|end_io
suffix:colon
id|bh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|bh
comma
id|test_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/**&n; * generic_make_request: hand a buffer head to it&squot;s device driver for I/O&n; * @rw:  READ, WRITE, or READA - what sort of I/O is desired.&n; * @bh:  The buffer head describing the location in memory and on the device.&n; *&n; * generic_make_request() is used to make I/O requests of block&n; * devices. It is passed a &amp;struct buffer_head and a &amp;rw value.  The&n; * %READ and %WRITE options are (hopefully) obvious in meaning.  The&n; * %READA value means that a read is required, but that the driver is&n; * free to fail the request if, for example, it cannot get needed&n; * resources immediately.&n; *&n; * generic_make_request() does not return any status.  The&n; * success/failure status of the request, along with notification of&n; * completion, is delivered asynchronously through the bh-&gt;b_end_io&n; * function described (one day) else where.&n; *&n; * The caller of generic_make_request must make sure that b_page,&n; * b_addr, b_size are set to describe the memory buffer, that b_rdev&n; * and b_rsector are set to describe the device address, and the&n; * b_end_io and optionally b_private are set to describe how&n; * completion notification should be signaled.  BH_Mapped should also&n; * be set (to confirm that b_dev and b_blocknr are valid).&n; *&n; * generic_make_request and the drivers it calls may use b_reqnext,&n; * and may change b_rdev and b_rsector.  So the values of these fields&n; * should NOT be depended on after the call to generic_make_request.&n; * Because of this, the caller should record the device address&n; * information in b_dev and b_blocknr.&n; *&n; * Apart from those fields mentioned above, no other fields, and in&n; * particular, no other flags, are changed by generic_make_request or&n; * any lower level drivers.&n; * */
DECL|function|generic_make_request
r_void
id|generic_make_request
(paren
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
id|major
op_assign
id|MAJOR
c_func
(paren
id|bh-&gt;b_rdev
)paren
suffix:semicolon
id|request_queue_t
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bh-&gt;b_end_io
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_size
(braket
id|major
)braket
)paren
(brace
r_int
r_int
id|maxsector
op_assign
(paren
id|blk_size
(braket
id|major
)braket
(braket
id|MINOR
c_func
(paren
id|bh-&gt;b_rdev
)paren
)braket
op_lshift
l_int|1
)paren
op_plus
l_int|1
suffix:semicolon
r_int
r_int
id|sector
comma
id|count
suffix:semicolon
id|count
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|sector
op_assign
id|bh-&gt;b_rsector
suffix:semicolon
r_if
c_cond
(paren
id|maxsector
OL
id|count
op_logical_or
id|maxsector
op_minus
id|count
OL
id|sector
)paren
(brace
id|bh-&gt;b_state
op_and_assign
(paren
l_int|1
op_lshift
id|BH_Lock
)paren
op_or
(paren
l_int|1
op_lshift
id|BH_Mapped
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk_size
(braket
id|major
)braket
(braket
id|MINOR
c_func
(paren
id|bh-&gt;b_rdev
)paren
)braket
)paren
(brace
multiline_comment|/* This may well happen - the kernel calls bread()&n;&t;&t;&t;&t;   without checking the size of the device, e.g.,&n;&t;&t;&t;&t;   when mounting a device. */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;attempt to access beyond end of device&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%s: rw=%d, want=%d, limit=%d&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|bh-&gt;b_rdev
)paren
comma
id|rw
comma
(paren
id|sector
op_plus
id|count
)paren
op_rshift
l_int|1
comma
id|blk_size
(braket
id|major
)braket
(braket
id|MINOR
c_func
(paren
id|bh-&gt;b_rdev
)paren
)braket
)paren
suffix:semicolon
)brace
id|bh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|bh
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Resolve the mapping until finished. (drivers are&n;&t; * still free to implement/resolve their own stacking&n;&t; * by explicitly returning 0)&n;&t; */
multiline_comment|/* NOTE: we don&squot;t repeat the blk_size check for each new device.&n;&t; * Stacking drivers are expected to know what they are doing.&n;&t; */
r_do
(brace
id|q
op_assign
id|blk_get_queue
c_func
(paren
id|bh-&gt;b_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|q
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;generic_make_request: Trying to access nonexistent block-device %s (%ld)&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|bh-&gt;b_rdev
)paren
comma
id|bh-&gt;b_rsector
)paren
suffix:semicolon
id|buffer_IO_error
c_func
(paren
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|q
op_member_access_from_pointer
id|make_request_fn
c_func
(paren
id|q
comma
id|rw
comma
id|bh
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * submit_bh: submit a buffer_head to the block device later for I/O&n; * @rw: whether to %READ or %WRITE, or mayve to %READA (read ahead)&n; * @bh: The &amp;struct buffer_head which describes the I/O&n; *&n; * submit_bh() is very similar in purpose to generic_make_request(), and&n; * uses that function to do most of the work.&n; *&n; * The extra functionality provided by submit_bh is to determine&n; * b_rsector from b_blocknr and b_size, and to set b_rdev from b_dev.&n; * This is is appropriate for IO requests that come from the buffer&n; * cache and page cache which (currently) always use aligned blocks.&n; */
DECL|function|submit_bh
r_void
id|submit_bh
c_func
(paren
r_int
id|rw
comma
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|test_bit
c_func
(paren
id|BH_Lock
comma
op_amp
id|bh-&gt;b_state
)paren
)paren
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|set_bit
c_func
(paren
id|BH_Req
comma
op_amp
id|bh-&gt;b_state
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * First step, &squot;identity mapping&squot; - RAID or LVM might&n;&t; * further remap this.&n;&t; */
id|bh-&gt;b_rdev
op_assign
id|bh-&gt;b_dev
suffix:semicolon
id|bh-&gt;b_rsector
op_assign
id|bh-&gt;b_blocknr
op_star
(paren
id|bh-&gt;b_size
op_rshift
l_int|9
)paren
suffix:semicolon
id|generic_make_request
c_func
(paren
id|rw
comma
id|bh
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|rw
)paren
(brace
r_case
id|WRITE
suffix:colon
id|kstat.pgpgout
op_increment
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|kstat.pgpgin
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Default IO end handler, used by &quot;ll_rw_block()&quot;.&n; */
DECL|function|end_buffer_io_sync
r_static
r_void
id|end_buffer_io_sync
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|uptodate
)paren
(brace
id|mark_buffer_uptodate
c_func
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
id|unlock_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
)brace
multiline_comment|/**&n; * ll_rw_block: low-level access to block devices&n; * @rw: whether to %READ or %WRITE or maybe %READA (readahead)&n; * @nr: number of &amp;struct buffer_heads in the array&n; * @bhs: array of pointers to &amp;struct buffer_head&n; *&n; * ll_rw_block() takes an array of pointers to &amp;struct buffer_heads,&n; * and requests an I/O operation on them, either a %READ or a %WRITE.&n; * The third %READA option is described in the documentation for&n; * generic_make_request() which ll_rw_block() calls.&n; *&n; * This function provides extra functionality that is not in&n; * generic_make_request() that is relevant to buffers in the buffer&n; * cache or page cache.  In particular it drops any buffer that it&n; * cannot get a lock on (with the BH_Lock state bit), any buffer that&n; * appears to be clean when doing a write request, and any buffer that&n; * appears to be up-to-date when doing read request.  Further it marks&n; * as clean buffers that are processed for writing (the buffer cache&n; * wont assume that they are actually clean until the buffer gets&n; * unlocked).&n; *&n; * ll_rw_block sets b_end_io to simple completion handler that marks&n; * the buffer up-to-date (if approriate), unlocks the buffer and wakes&n; * any waiters.  As client that needs a more interesting completion&n; * routine should call submit_bh() (or generic_make_request())&n; * directly.&n; *&n; * Caveat:&n; *  All of the buffers must be for the same device, and must also be&n; *  of the current approved size for the device.  */
DECL|function|ll_rw_block
r_void
id|ll_rw_block
c_func
(paren
r_int
id|rw
comma
r_int
id|nr
comma
r_struct
id|buffer_head
op_star
id|bhs
(braket
)braket
)paren
(brace
r_int
r_int
id|major
suffix:semicolon
r_int
id|correct_size
suffix:semicolon
r_int
id|i
suffix:semicolon
id|major
op_assign
id|MAJOR
c_func
(paren
id|bhs
(braket
l_int|0
)braket
op_member_access_from_pointer
id|b_dev
)paren
suffix:semicolon
multiline_comment|/* Determine correct block size for this device. */
id|correct_size
op_assign
id|BLOCK_SIZE
suffix:semicolon
r_if
c_cond
(paren
id|blksize_size
(braket
id|major
)braket
)paren
(brace
id|i
op_assign
id|blksize_size
(braket
id|major
)braket
(braket
id|MINOR
c_func
(paren
id|bhs
(braket
l_int|0
)braket
op_member_access_from_pointer
id|b_dev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
id|correct_size
op_assign
id|i
suffix:semicolon
)brace
multiline_comment|/* Verify requested block sizes. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|bh
op_assign
id|bhs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_size
op_ne
id|correct_size
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ll_rw_block: device %s: &quot;
l_string|&quot;only %d-char blocks implemented (%u)&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|bhs
(braket
l_int|0
)braket
op_member_access_from_pointer
id|b_dev
)paren
comma
id|correct_size
comma
id|bh-&gt;b_size
)paren
suffix:semicolon
r_goto
id|sorry
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|rw
op_amp
id|WRITE
)paren
op_logical_and
id|is_read_only
c_func
(paren
id|bhs
(braket
l_int|0
)braket
op_member_access_from_pointer
id|b_dev
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Can&squot;t write to read-only device %s&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|bhs
(braket
l_int|0
)braket
op_member_access_from_pointer
id|b_dev
)paren
)paren
suffix:semicolon
r_goto
id|sorry
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
id|bh
op_assign
id|bhs
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* Only one thread can actually submit the I/O. */
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
id|BH_Lock
comma
op_amp
id|bh-&gt;b_state
)paren
)paren
r_continue
suffix:semicolon
multiline_comment|/* We have the buffer lock */
id|bh-&gt;b_end_io
op_assign
id|end_buffer_io_sync
suffix:semicolon
r_switch
c_cond
(paren
id|rw
)paren
(brace
r_case
id|WRITE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|atomic_set_buffer_clean
c_func
(paren
id|bh
)paren
)paren
multiline_comment|/* Hmmph! Nothing to write */
r_goto
id|end_io
suffix:semicolon
id|__mark_buffer_clean
c_func
(paren
id|bh
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READA
suffix:colon
r_case
id|READ
suffix:colon
r_if
c_cond
(paren
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
multiline_comment|/* Hmmph! Already have it */
r_goto
id|end_io
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|BUG
c_func
(paren
)paren
suffix:semicolon
id|end_io
suffix:colon
id|bh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|bh
comma
id|test_bit
c_func
(paren
id|BH_Uptodate
comma
op_amp
id|bh-&gt;b_state
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|submit_bh
c_func
(paren
id|rw
comma
id|bh
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|sorry
suffix:colon
multiline_comment|/* Make sure we don&squot;t get infinite dirty retries.. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr
suffix:semicolon
id|i
op_increment
)paren
id|mark_buffer_clean
c_func
(paren
id|bhs
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_STRAM_SWAP
r_extern
r_int
id|stram_device_init
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * First step of what used to be end_request&n; *&n; * 0 means continue with end_that_request_last,&n; * 1 means we are done&n; */
DECL|function|end_that_request_first
r_int
id|end_that_request_first
(paren
r_struct
id|request
op_star
id|req
comma
r_int
id|uptodate
comma
r_char
op_star
id|name
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|nsect
suffix:semicolon
id|req-&gt;errors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|uptodate
)paren
id|printk
c_func
(paren
l_string|&quot;end_request: I/O error, dev %s (%s), sector %lu&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|req-&gt;rq_dev
)paren
comma
id|name
comma
id|req-&gt;sector
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|req-&gt;bh
)paren
op_ne
l_int|NULL
)paren
(brace
id|nsect
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|req-&gt;bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|bh
comma
id|uptodate
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|bh
op_assign
id|req-&gt;bh
)paren
op_ne
l_int|NULL
)paren
(brace
id|req-&gt;hard_sector
op_add_assign
id|nsect
suffix:semicolon
id|req-&gt;hard_nr_sectors
op_sub_assign
id|nsect
suffix:semicolon
id|req-&gt;sector
op_assign
id|req-&gt;hard_sector
suffix:semicolon
id|req-&gt;nr_sectors
op_assign
id|req-&gt;hard_nr_sectors
suffix:semicolon
id|req-&gt;current_nr_sectors
op_assign
id|bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;nr_sectors
OL
id|req-&gt;current_nr_sectors
)paren
(brace
id|req-&gt;nr_sectors
op_assign
id|req-&gt;current_nr_sectors
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;end_request: buffer-list destroyed&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|req-&gt;buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|end_that_request_last
r_void
id|end_that_request_last
c_func
(paren
r_struct
id|request
op_star
id|req
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;e
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;end_that_request_last called with non-dequeued req&bslash;n&quot;
)paren
suffix:semicolon
id|BUG
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|req-&gt;sem
op_ne
l_int|NULL
)paren
id|up
c_func
(paren
id|req-&gt;sem
)paren
suffix:semicolon
id|blkdev_release_request
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
DECL|function|blk_dev_init
r_int
id|__init
id|blk_dev_init
c_func
(paren
r_void
)paren
(brace
r_struct
id|blk_dev_struct
op_star
id|dev
suffix:semicolon
id|request_cachep
op_assign
id|kmem_cache_create
c_func
(paren
l_string|&quot;blkdev_requests&quot;
comma
r_sizeof
(paren
r_struct
id|request
)paren
comma
l_int|0
comma
id|SLAB_HWCACHE_ALIGN
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|request_cachep
)paren
id|panic
c_func
(paren
l_string|&quot;Can&squot;t create request pool slab cache&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|dev
op_assign
id|blk_dev
op_plus
id|MAX_BLKDEV
suffix:semicolon
id|dev
op_decrement
op_ne
id|blk_dev
suffix:semicolon
)paren
id|dev-&gt;queue
op_assign
l_int|NULL
suffix:semicolon
id|memset
c_func
(paren
id|ro_bits
comma
l_int|0
comma
r_sizeof
(paren
id|ro_bits
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|max_readahead
comma
l_int|0
comma
r_sizeof
(paren
id|max_readahead
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|max_sectors
comma
l_int|0
comma
r_sizeof
(paren
id|max_sectors
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_AMIGA_Z2RAM
id|z2_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_STRAM_SWAP
id|stram_device_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_RAM
id|rd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_LOOP
id|loop_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ISP16_CDI
id|isp16_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if defined(CONFIG_IDE) &amp;&amp; defined(CONFIG_BLK_DEV_IDE)
id|ide_init
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* this MUST precede hd_init */
macro_line|#endif
macro_line|#if defined(CONFIG_IDE) &amp;&amp; defined(CONFIG_BLK_DEV_HD)
id|hd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_PS2
id|ps2esdi_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_XD
id|xd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_MFM
id|mfm_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_PARIDE
(brace
r_extern
r_void
id|paride_init
c_func
(paren
r_void
)paren
suffix:semicolon
id|paride_init
c_func
(paren
)paren
suffix:semicolon
)brace
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_MAC_FLOPPY
id|swim3_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_SWIM_IOP
id|swimiop_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_AMIGA_FLOPPY
id|amiga_floppy_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ATARI_FLOPPY
id|atari_floppy_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_FD
id|floppy_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#else
macro_line|#if defined(__i386__)&t;/* Do we even need this? */
id|outb_p
c_func
(paren
l_int|0xc
comma
l_int|0x3f2
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
macro_line|#ifdef CONFIG_CDU31A
id|cdu31a_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_ATARI_ACSI
id|acsi_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_MCD
id|mcd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_MCDX
id|mcdx_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SBPCD
id|sbpcd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_AZTCD
id|aztcd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_CDU535
id|sony535_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_GSCD
id|gscd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_CM206
id|cm206_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_OPTCD
id|optcd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SJCD
id|sjcd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_APBLOCK
id|ap_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_DDV
id|ddv_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_NBD
id|nbd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_MDISK
id|mdisk_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_DASD
id|dasd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_SUN_JSFLASH
id|jsfd_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef CONFIG_BLK_DEV_LVM
id|lvm_init
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|io_request_lock
id|EXPORT_SYMBOL
c_func
(paren
id|io_request_lock
)paren
suffix:semicolon
DECL|variable|end_that_request_first
id|EXPORT_SYMBOL
c_func
(paren
id|end_that_request_first
)paren
suffix:semicolon
DECL|variable|end_that_request_last
id|EXPORT_SYMBOL
c_func
(paren
id|end_that_request_last
)paren
suffix:semicolon
DECL|variable|blk_init_queue
id|EXPORT_SYMBOL
c_func
(paren
id|blk_init_queue
)paren
suffix:semicolon
DECL|variable|blk_get_queue
id|EXPORT_SYMBOL
c_func
(paren
id|blk_get_queue
)paren
suffix:semicolon
DECL|variable|blk_cleanup_queue
id|EXPORT_SYMBOL
c_func
(paren
id|blk_cleanup_queue
)paren
suffix:semicolon
DECL|variable|blk_queue_headactive
id|EXPORT_SYMBOL
c_func
(paren
id|blk_queue_headactive
)paren
suffix:semicolon
DECL|variable|blk_queue_pluggable
id|EXPORT_SYMBOL
c_func
(paren
id|blk_queue_pluggable
)paren
suffix:semicolon
DECL|variable|blk_queue_make_request
id|EXPORT_SYMBOL
c_func
(paren
id|blk_queue_make_request
)paren
suffix:semicolon
DECL|variable|generic_make_request
id|EXPORT_SYMBOL
c_func
(paren
id|generic_make_request
)paren
suffix:semicolon
DECL|variable|blkdev_release_request
id|EXPORT_SYMBOL
c_func
(paren
id|blkdev_release_request
)paren
suffix:semicolon
eof
