multiline_comment|/*&n; * The Mitsumi CDROM interface&n; * Copyright (C) 1995 Heiko Schlittermann&n; * VERSION: @VERSION@&n; * &n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; * &n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with this program; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Thanks to&n; *  The Linux Community at all and ...&n; *  Martin Harriss (he wrote the first Mitsumi Driver)&n; *  Eberhard Moenkeberg (he gave me much support and the initial kick)&n; *  Bernd Huebner, Ruediger Helsch (Unifix-Software GmbH, they&n; *      improved the original driver)&n; *  John Tombs, Bjorn Ekwall (module support)&n; *  Daniel v. Mosnenck (he sent me the Technical and Programming Reference)&n; *  Gerd Knorr (he lent me his PhotoCD)&n; *  Nils Faerber and Roger E. Wolff (extensivly tested the LU portion)&n; *  ... somebody forgotten?&n; *  &n; */
macro_line|#if RCS
DECL|variable|mcdx_c_version
r_static
r_const
r_char
op_star
id|mcdx_c_version
op_assign
l_string|&quot;$Id: mcdx.c,v 1.2 1995/06/18 18:00:53 heiko Exp $&quot;
suffix:semicolon
macro_line|#endif
macro_line|#include &lt;linux/config.h&gt;
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#ifndef CONFIG_MODVERSIONS
DECL|variable|kernel_version
r_char
id|kernel_version
(braket
)braket
op_assign
id|UTS_RELEASE
suffix:semicolon
macro_line|#endif
macro_line|#else
DECL|macro|MOD_INC_USE_COUNT
mdefine_line|#define MOD_INC_USE_COUNT
DECL|macro|MOD_DEC_USE_COUNT
mdefine_line|#define MOD_DEC_USE_COUNT
DECL|macro|MOD_IN_USE
mdefine_line|#define MOD_IN_USE 1
macro_line|#endif MODULE
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR MITSUMI_X_CDROM_MAJOR
macro_line|#include &quot;blk.h&quot;
DECL|macro|mcdx_drive_map
mdefine_line|#define&t;mcdx_drive_map mcdx /* for compatible parameter passing with &quot;insmod&quot; */
macro_line|#include &lt;linux/mcdx.h&gt;
multiline_comment|/* CONSTANTS *******************************************************/
DECL|variable|REQUEST_SIZE
r_const
r_int
id|REQUEST_SIZE
op_assign
l_int|200
suffix:semicolon
DECL|variable|DIRECT_SIZE
r_const
r_int
id|DIRECT_SIZE
op_assign
l_int|200
suffix:semicolon
DECL|enum|drivemodes
DECL|enumerator|TOC
DECL|enumerator|DATA
DECL|enumerator|RAW
DECL|enumerator|COOKED
r_enum
id|drivemodes
(brace
id|TOC
comma
id|DATA
comma
id|RAW
comma
id|COOKED
)brace
suffix:semicolon
DECL|enum|datamodes
DECL|enumerator|MODE0
DECL|enumerator|MODE1
DECL|enumerator|MODE2
r_enum
id|datamodes
(brace
id|MODE0
comma
id|MODE1
comma
id|MODE2
)brace
suffix:semicolon
DECL|enum|resetmodes
DECL|enumerator|SOFT
DECL|enumerator|HARD
r_enum
id|resetmodes
(brace
id|SOFT
comma
id|HARD
)brace
suffix:semicolon
DECL|variable|SINGLE
r_const
r_int
id|SINGLE
op_assign
l_int|0x01
suffix:semicolon
DECL|variable|DOUBLE
r_const
r_int
id|DOUBLE
op_assign
l_int|0x02
suffix:semicolon
DECL|variable|DOOR
r_const
r_int
id|DOOR
op_assign
l_int|0x04
suffix:semicolon
DECL|variable|MULTI
r_const
r_int
id|MULTI
op_assign
l_int|0x08
suffix:semicolon
DECL|variable|READSSPEED
r_const
r_int
r_char
id|READSSPEED
op_assign
l_int|0xc0
suffix:semicolon
DECL|variable|READDSPEED
r_const
r_int
r_char
id|READDSPEED
op_assign
l_int|0xc1
suffix:semicolon
multiline_comment|/* DECLARATIONS ****************************************************/
DECL|struct|s_msf
r_struct
id|s_msf
(brace
DECL|member|minute
r_int
r_char
id|minute
suffix:semicolon
DECL|member|second
r_int
r_char
id|second
suffix:semicolon
DECL|member|frame
r_int
r_char
id|frame
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|s_subqcode
r_struct
id|s_subqcode
(brace
DECL|member|control
r_int
r_char
id|control
suffix:semicolon
DECL|member|tno
r_int
r_char
id|tno
suffix:semicolon
DECL|member|index
r_int
r_char
id|index
suffix:semicolon
DECL|member|tt
r_struct
id|s_msf
id|tt
suffix:semicolon
DECL|member|dt
r_struct
id|s_msf
id|dt
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|s_diskinfo
r_struct
id|s_diskinfo
(brace
DECL|member|n_first
r_int
r_int
id|n_first
suffix:semicolon
DECL|member|n_last
r_int
r_int
id|n_last
suffix:semicolon
DECL|member|msf_leadout
r_struct
id|s_msf
id|msf_leadout
suffix:semicolon
DECL|member|msf_first
r_struct
id|s_msf
id|msf_first
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|s_multi
r_struct
id|s_multi
(brace
DECL|member|multi
r_int
r_char
id|multi
suffix:semicolon
DECL|member|msf_last
r_struct
id|s_msf
id|msf_last
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|s_version
r_struct
id|s_version
(brace
DECL|member|code
r_int
r_char
id|code
suffix:semicolon
DECL|member|ver
r_int
r_char
id|ver
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Per drive/controller stuff **************************************/
DECL|struct|s_drive_stuff
r_struct
id|s_drive_stuff
(brace
multiline_comment|/* waitquenes */
DECL|member|busyq
r_struct
id|wait_queue
op_star
id|busyq
suffix:semicolon
DECL|member|lockq
r_struct
id|wait_queue
op_star
id|lockq
suffix:semicolon
DECL|member|sleepq
r_struct
id|wait_queue
op_star
id|sleepq
suffix:semicolon
multiline_comment|/* flags */
DECL|member|introk
r_volatile
r_int
id|introk
suffix:semicolon
multiline_comment|/* status of last irq operation */
DECL|member|busy
r_volatile
r_int
id|busy
suffix:semicolon
multiline_comment|/* drive performs an operation */
DECL|member|lock
r_volatile
r_int
id|lock
suffix:semicolon
multiline_comment|/* exclusive usage */
multiline_comment|/* cd infos */
DECL|member|di
r_struct
id|s_diskinfo
id|di
suffix:semicolon
DECL|member|multi
r_struct
id|s_multi
id|multi
suffix:semicolon
DECL|member|toc
r_struct
id|s_subqcode
op_star
id|toc
suffix:semicolon
multiline_comment|/* first enty of the toc array */
DECL|member|start
r_struct
id|s_subqcode
id|start
suffix:semicolon
DECL|member|stop
r_struct
id|s_subqcode
id|stop
suffix:semicolon
DECL|member|xa
r_int
id|xa
suffix:semicolon
multiline_comment|/* 1 if xa disk */
DECL|member|audio
r_int
id|audio
suffix:semicolon
multiline_comment|/* 1 if audio disk */
DECL|member|audiostatus
r_int
id|audiostatus
suffix:semicolon
multiline_comment|/* `buffer&squot; control */
DECL|member|valid
r_volatile
r_int
id|valid
suffix:semicolon
DECL|member|pending
r_volatile
r_int
id|pending
suffix:semicolon
DECL|member|off_direct
r_volatile
r_int
id|off_direct
suffix:semicolon
DECL|member|off_requested
r_volatile
r_int
id|off_requested
suffix:semicolon
multiline_comment|/* adds and odds */
DECL|member|wreg_data
r_void
op_star
id|wreg_data
suffix:semicolon
multiline_comment|/* w data */
DECL|member|wreg_reset
r_void
op_star
id|wreg_reset
suffix:semicolon
multiline_comment|/* w hardware reset */
DECL|member|wreg_hcon
r_void
op_star
id|wreg_hcon
suffix:semicolon
multiline_comment|/* w hardware conf */
DECL|member|wreg_chn
r_void
op_star
id|wreg_chn
suffix:semicolon
multiline_comment|/* w channel */
DECL|member|rreg_data
r_void
op_star
id|rreg_data
suffix:semicolon
multiline_comment|/* r data */
DECL|member|rreg_status
r_void
op_star
id|rreg_status
suffix:semicolon
multiline_comment|/* r status */
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* irq used by this drive */
DECL|member|minor
r_int
id|minor
suffix:semicolon
multiline_comment|/* minor number of this drive */
DECL|member|present
r_int
id|present
suffix:semicolon
multiline_comment|/* drive present and its capabilities */
DECL|member|readcmd
r_char
id|readcmd
suffix:semicolon
multiline_comment|/* read cmd depends on single/double speed */
DECL|member|changed
r_int
r_int
id|changed
suffix:semicolon
multiline_comment|/* last jiff the media was changed */
DECL|member|users
r_int
id|users
suffix:semicolon
multiline_comment|/* keeps track of open/close */
DECL|member|lastsector
r_int
id|lastsector
suffix:semicolon
multiline_comment|/* last block accessible */
DECL|member|errno
r_int
id|errno
suffix:semicolon
multiline_comment|/* last operation&squot;s error */
)brace
suffix:semicolon
multiline_comment|/* Prototypes ******************************************************/
multiline_comment|/*&t;The following prototypes are already declared elsewhere.  They are&n; &t;repeated here to show what&squot;s going on.  And to sense, if they&squot;re&n;&t;changed elsewhere. */
multiline_comment|/* declared in blk.h */
r_int
r_int
id|mcdx_init
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
suffix:semicolon
r_void
id|do_mcdx_request
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|check_mcdx_media_change
c_func
(paren
id|dev_t
)paren
suffix:semicolon
multiline_comment|/* already declared in init/main */
r_void
id|mcdx_setup
c_func
(paren
r_char
op_star
comma
r_int
op_star
)paren
suffix:semicolon
multiline_comment|/*&t;Indirect exported functions. These functions are exported by their&n;&t;addresses, such as mcdx_open and mcdx_close in the &n;&t;structure fops. */
multiline_comment|/* ???  exported by the mcdx_sigaction struct */
r_static
r_void
id|mcdx_intr
c_func
(paren
r_int
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
multiline_comment|/* exported by file_ops */
r_static
r_int
id|mcdx_open
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_void
id|mcdx_close
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|mcdx_ioctl
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
multiline_comment|/* misc internal support functions */
r_static
r_void
id|log2msf
c_func
(paren
r_int
r_int
comma
r_struct
id|s_msf
op_star
)paren
suffix:semicolon
r_static
r_int
r_int
id|msf2log
c_func
(paren
r_const
r_struct
id|s_msf
op_star
)paren
suffix:semicolon
r_static
r_int
r_int
id|uint2bcd
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
r_int
id|bcd2uint
c_func
(paren
r_int
r_char
)paren
suffix:semicolon
macro_line|#if MCDX_DEBUG
r_static
r_void
id|TRACE
c_func
(paren
(paren
r_int
id|level
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifndef NOWARN
r_static
r_void
id|WARN
c_func
(paren
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
)paren
suffix:semicolon
macro_line|#endif
r_static
r_char
op_star
id|port
c_func
(paren
r_int
op_star
)paren
suffix:semicolon
r_static
r_int
id|irq
c_func
(paren
r_int
op_star
)paren
suffix:semicolon
r_static
r_void
id|mcdx_delay
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_int
id|jifs
)paren
suffix:semicolon
r_static
r_int
id|mcdx_transfer
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_char
op_star
id|buf
comma
r_int
id|sector
comma
r_int
id|nr_sectors
)paren
suffix:semicolon
r_static
r_int
id|mcdx_config
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_closedoor
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_requestversion
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_struct
id|s_version
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_lockdoor
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_int
comma
r_int
)paren
suffix:semicolon
macro_line|#if 0
r_static
r_int
id|mcdx_getstatus
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_int
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|mcdx_stop
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_reset
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_enum
id|resetmodes
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_eject
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_setdrivemode
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_enum
id|drivemodes
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_setdatamode
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_enum
id|datamodes
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_requestsubqcode
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_struct
id|s_subqcode
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_requestmultidiskinfo
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_struct
id|s_multi
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_requesttocdata
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_struct
id|s_diskinfo
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_talk
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_const
r_int
r_char
op_star
id|cmd
comma
r_int
comma
r_void
op_star
id|buffer
comma
r_int
id|size
comma
r_int
r_int
id|timeout
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_readtoc
c_func
(paren
r_struct
id|s_drive_stuff
op_star
)paren
suffix:semicolon
multiline_comment|/* static variables ************************************************/
DECL|variable|dummy0
r_static
r_int
id|dummy0
suffix:semicolon
DECL|variable|mcdx_drive_map
r_static
r_int
id|mcdx_drive_map
(braket
)braket
(braket
l_int|2
)braket
op_assign
id|MCDX_DRIVEMAP
suffix:semicolon
DECL|variable|mcdx_stuffp
r_static
r_struct
id|s_drive_stuff
op_star
id|mcdx_stuffp
(braket
id|MCDX_NDRIVES
)braket
suffix:semicolon
DECL|variable|mcdx_irq_map
r_static
r_struct
id|s_drive_stuff
op_star
id|mcdx_irq_map
(braket
l_int|16
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|mcdx_fops
r_static
r_struct
id|file_operations
id|mcdx_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - use kernel default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* no readdir */
l_int|NULL
comma
multiline_comment|/* no select */
id|mcdx_ioctl
comma
multiline_comment|/* ioctl() */
l_int|NULL
comma
multiline_comment|/* no mmap */
id|mcdx_open
comma
multiline_comment|/* open() */
id|mcdx_close
comma
multiline_comment|/* close() */
l_int|NULL
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
id|check_mcdx_media_change
comma
multiline_comment|/* media_change */
l_int|NULL
multiline_comment|/* revalidate */
)brace
suffix:semicolon
multiline_comment|/* KERNEL INTERFACE FUNCTIONS **************************************/
r_static
r_int
DECL|function|mcdx_ioctl
id|mcdx_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|ip-&gt;i_rdev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;present
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSTART
suffix:colon
(brace
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() START&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMSTOP
suffix:colon
(brace
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() STOP&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_stop
c_func
(paren
id|stuffp
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMPLAYTRKIND
suffix:colon
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;int ans;&n;&t;&t;&t;struct cdrom_ti ti;&n;&t;&t;&t;TRACE((IOCTL, &quot;ioctl() PLAYTRKIND&bslash;n&quot;));&n;&t;&t;&t;if (ans = verify_area(VERIFY_READ, (void*) arg, sizeof(ti));&n;&t;&t;&t;&t;return ans;&n;&t;&t;&t;memcpy_fromfs(&amp;ti, (void*) arg, sizeof(ti));&n;&t;&t;&t;if ((ti.cdti_trk0 &lt; stuffp-&gt;di.n_first)&n;&t;&t;&t;&t;&t;|| (ti.cdti_trk0 &gt; stuffp-&gt;di.n_last)&n;&t;&t;&t;&t;&t;|| (ti.cdti_trk1 &lt; stuffp-&gt;di.n_first))&n;&t;&t;&t;&t;return -EINVAL;&n;&t;&t;&t;if (ti.cdti_trk1 &gt; stuffp-&gt;di.n_last) ti.cdti_trk1 = stuffp-&gt;di.n_last;&n;&t;&t;&t;*/
)brace
r_case
id|CDROMREADTOCENTRY
suffix:colon
(brace
r_struct
id|cdrom_tocentry
id|entry
suffix:semicolon
r_struct
id|s_subqcode
op_star
id|tp
op_assign
l_int|NULL
suffix:semicolon
r_int
id|ans
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() READTOCENTRY&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stuffp-&gt;toc
op_eq
l_int|NULL
)paren
op_logical_and
(paren
l_int|0
op_ne
(paren
id|ans
op_assign
id|mcdx_readtoc
c_func
(paren
id|stuffp
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|entry
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|entry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry.cdte_track
op_eq
id|CDROM_LEADOUT
)paren
id|tp
op_assign
op_amp
id|stuffp-&gt;toc
(braket
id|stuffp-&gt;di.n_last
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|1
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry.cdte_track
OG
id|stuffp-&gt;di.n_last
op_logical_or
id|entry.cdte_track
OL
id|stuffp-&gt;di.n_first
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
id|tp
op_assign
op_amp
id|stuffp-&gt;toc
(braket
id|entry.cdte_track
op_minus
id|stuffp-&gt;di.n_first
)braket
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|tp
)paren
id|WARN
c_func
(paren
(paren
l_string|&quot;FATAL.&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|entry.cdte_adr
op_assign
id|tp-&gt;control
suffix:semicolon
id|entry.cdte_ctrl
op_assign
id|tp-&gt;control
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
id|entry.cdte_addr.msf.minute
op_assign
id|bcd2uint
c_func
(paren
id|tp-&gt;dt.minute
)paren
suffix:semicolon
id|entry.cdte_addr.msf.second
op_assign
id|bcd2uint
c_func
(paren
id|tp-&gt;dt.second
)paren
suffix:semicolon
id|entry.cdte_addr.msf.frame
op_assign
id|bcd2uint
c_func
(paren
id|tp-&gt;dt.frame
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
id|CDROM_LBA
)paren
id|entry.cdte_addr.lba
op_assign
id|msf2log
c_func
(paren
op_amp
id|tp-&gt;dt
)paren
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|entry
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|entry
comma
r_sizeof
(paren
id|entry
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMSUBCHNL
suffix:colon
(brace
r_int
id|ans
suffix:semicolon
r_struct
id|cdrom_subchnl
id|sub
suffix:semicolon
r_struct
id|s_subqcode
id|q
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() SUBCHNL&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|sub
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|sub
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|sub
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_requestsubqcode
c_func
(paren
id|stuffp
comma
op_amp
id|q
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;audiostatus: %x&bslash;n&quot;
comma
id|stuffp-&gt;audiostatus
)paren
)paren
suffix:semicolon
id|sub.cdsc_audiostatus
op_assign
id|stuffp-&gt;audiostatus
suffix:semicolon
id|sub.cdsc_adr
op_assign
id|q.control
suffix:semicolon
id|sub.cdsc_ctrl
op_assign
id|q.control
op_rshift
l_int|4
suffix:semicolon
id|sub.cdsc_trk
op_assign
id|bcd2uint
c_func
(paren
id|q.tno
)paren
suffix:semicolon
id|sub.cdsc_ind
op_assign
id|bcd2uint
c_func
(paren
id|q.index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sub.cdsc_format
op_eq
id|CDROM_LBA
)paren
(brace
id|sub.cdsc_absaddr.lba
op_assign
id|msf2log
c_func
(paren
op_amp
id|q.dt
)paren
suffix:semicolon
id|sub.cdsc_reladdr.lba
op_assign
id|msf2log
c_func
(paren
op_amp
id|q.tt
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sub.cdsc_format
op_eq
id|CDROM_MSF
)paren
(brace
id|sub.cdsc_absaddr.msf.minute
op_assign
id|bcd2uint
c_func
(paren
id|q.dt.minute
)paren
suffix:semicolon
id|sub.cdsc_absaddr.msf.second
op_assign
id|bcd2uint
c_func
(paren
id|q.dt.second
)paren
suffix:semicolon
id|sub.cdsc_absaddr.msf.frame
op_assign
id|bcd2uint
c_func
(paren
id|q.dt.frame
)paren
suffix:semicolon
id|sub.cdsc_reladdr.msf.minute
op_assign
id|bcd2uint
c_func
(paren
id|q.tt.minute
)paren
suffix:semicolon
id|sub.cdsc_reladdr.msf.second
op_assign
id|bcd2uint
c_func
(paren
id|q.tt.second
)paren
suffix:semicolon
id|sub.cdsc_reladdr.msf.frame
op_assign
id|bcd2uint
c_func
(paren
id|q.tt.frame
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|sub
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|sub
comma
r_sizeof
(paren
id|sub
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMREADTOCHDR
suffix:colon
(brace
r_struct
id|cdrom_tochdr
id|toc
suffix:semicolon
r_int
id|ans
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() READTOCHDR&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|toc
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|toc.cdth_trk0
op_assign
id|stuffp-&gt;di.n_first
suffix:semicolon
id|toc.cdth_trk1
op_assign
id|stuffp-&gt;di.n_last
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|toc
comma
r_sizeof
id|toc
)paren
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() track0 = %d, track1 = %d&bslash;n&quot;
comma
id|stuffp-&gt;di.n_first
comma
id|stuffp-&gt;di.n_last
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMPAUSE
suffix:colon
(brace
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() PAUSE&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;audiostatus
op_ne
id|CDROM_AUDIO_PLAY
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_stop
c_func
(paren
id|stuffp
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_requestsubqcode
c_func
(paren
id|stuffp
comma
op_amp
id|stuffp-&gt;start
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMMULTISESSION
suffix:colon
(brace
r_int
id|ans
suffix:semicolon
r_struct
id|cdrom_multisession
id|ms
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() MULTISESSION&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|ms
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ms.addr_format
op_eq
id|CDROM_MSF
)paren
(brace
id|ms.addr.msf.minute
op_assign
id|bcd2uint
c_func
(paren
id|stuffp-&gt;multi.msf_last.minute
)paren
suffix:semicolon
id|ms.addr.msf.second
op_assign
id|bcd2uint
c_func
(paren
id|stuffp-&gt;multi.msf_last.second
)paren
suffix:semicolon
id|ms.addr.msf.frame
op_assign
id|bcd2uint
c_func
(paren
id|stuffp-&gt;multi.msf_last.frame
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ms.addr_format
op_eq
id|CDROM_LBA
)paren
id|ms.addr.lba
op_assign
id|msf2log
c_func
(paren
op_amp
id|stuffp-&gt;multi.msf_last
)paren
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ms.xa_flag
op_assign
id|stuffp-&gt;xa
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_ne
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|ms
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ms.addr_format
op_eq
id|CDROM_MSF
)paren
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() (%d, %02x:%02x.%02x [%02x:%02x.%02x])&bslash;n&quot;
comma
id|ms.xa_flag
comma
id|ms.addr.msf.minute
comma
id|ms.addr.msf.second
comma
id|ms.addr.msf.frame
comma
id|stuffp-&gt;multi.msf_last.minute
comma
id|stuffp-&gt;multi.msf_last.second
comma
id|stuffp-&gt;multi.msf_last.frame
)paren
)paren
suffix:semicolon
r_else
(brace
id|dummy0
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() (%d, 0x%08x [%02x:%02x.%02x])&bslash;n&quot;
comma
id|ms.xa_flag
comma
id|ms.addr.lba
comma
id|stuffp-&gt;multi.msf_last.minute
comma
id|stuffp-&gt;multi.msf_last.second
comma
id|stuffp-&gt;multi.msf_last.frame
)paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMEJECT
suffix:colon
(brace
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() EJECT&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;users
OG
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_eject
c_func
(paren
id|stuffp
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
id|WARN
c_func
(paren
(paren
l_string|&quot;ioctl(): unknown request 0x%04x&bslash;n&quot;
comma
id|cmd
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|do_mcdx_request
r_void
id|do_mcdx_request
c_func
(paren
)paren
(brace
r_int
id|dev
suffix:semicolon
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
id|again
suffix:colon
id|TRACE
c_func
(paren
(paren
id|REQUEST
comma
l_string|&quot;do_request()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|CURRENT
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|CURRENT-&gt;dev
OL
l_int|0
)paren
)paren
(brace
id|TRACE
c_func
(paren
(paren
id|REQUEST
comma
l_string|&quot;do_request() done&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
)braket
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|REQUEST
comma
l_string|&quot;do_request() stuffp = %p&bslash;n&quot;
comma
id|stuffp
)paren
)paren
suffix:semicolon
id|INIT_REQUEST
suffix:semicolon
id|dev
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
OL
l_int|0
)paren
op_logical_or
(paren
id|dev
op_ge
id|MCDX_NDRIVES
)paren
op_logical_or
(paren
op_logical_neg
id|stuffp-&gt;present
)paren
)paren
(brace
id|printk
c_func
(paren
id|MCD
l_string|&quot;do_request(): bad device: 0x%04x&bslash;n&quot;
comma
id|CURRENT-&gt;dev
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stuffp-&gt;audio
)paren
(brace
id|WARN
c_func
(paren
(paren
l_string|&quot;do_request() attempt to read from audio cd&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|CURRENT-&gt;cmd
)paren
(brace
r_case
id|WRITE
suffix:colon
id|printk
c_func
(paren
id|MCD
l_string|&quot;: do_request(): attempt to write to cd!!&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ
suffix:colon
id|stuffp-&gt;errno
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT-&gt;nr_sectors
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
id|i
op_assign
id|mcdx_transfer
c_func
(paren
id|stuffp
comma
id|CURRENT-&gt;buffer
comma
id|CURRENT-&gt;sector
comma
id|CURRENT-&gt;nr_sectors
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|MCD
l_string|&quot; read error&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;errno
op_eq
id|MCDX_EOM
)paren
(brace
id|CURRENT-&gt;sector
op_add_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_assign
l_int|0
suffix:semicolon
)brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
id|CURRENT-&gt;sector
op_add_assign
id|i
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|i
suffix:semicolon
id|CURRENT-&gt;buffer
op_add_assign
(paren
id|i
op_star
l_int|512
)paren
suffix:semicolon
)brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
id|MCD
l_string|&quot;do_request: unknown command.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_goto
id|again
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_open
id|mcdx_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
r_static
r_int
r_int
id|changed
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|OPENCLOSE
comma
l_string|&quot;open()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|ip-&gt;i_rdev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;present
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* close the door, if necessary (get the door information&n;    from the hardware status register) */
r_if
c_cond
(paren
id|inb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_status
)paren
op_amp
id|MCDX_RBIT_DOOR
)paren
id|mcdx_closedoor
c_func
(paren
id|stuffp
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* if the media changed we will have to little more */
r_if
c_cond
(paren
id|changed
OL
id|stuffp-&gt;changed
)paren
(brace
id|TRACE
c_func
(paren
(paren
id|OPENCLOSE
comma
l_string|&quot;open() media changed&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* but wait - the time of media change will be set at the &n;        very last of this block - it seems, some of the following&n;        talk() will detect a media change ... (I think, config()&n;        is the reason. */
multiline_comment|/* get the multisession information */
(brace
id|TRACE
c_func
(paren
(paren
id|OPENCLOSE
comma
l_string|&quot;open() Request multisession info&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_requestmultidiskinfo
c_func
(paren
id|stuffp
comma
op_amp
id|stuffp-&gt;multi
comma
l_int|6
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;multi.multi
OG
l_int|2
)paren
id|WARN
c_func
(paren
(paren
l_string|&quot;open() unknown multisession value (%d)&bslash;n&quot;
comma
id|stuffp-&gt;multi.multi
)paren
)paren
suffix:semicolon
multiline_comment|/* multisession ? */
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;multi.multi
)paren
id|stuffp-&gt;multi.msf_last.second
op_assign
l_int|2
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|OPENCLOSE
comma
l_string|&quot;open() MS: %d, last @ %02x:%02x.%02x&bslash;n&quot;
comma
id|stuffp-&gt;multi.multi
comma
id|stuffp-&gt;multi.msf_last.minute
comma
id|stuffp-&gt;multi.msf_last.second
comma
id|stuffp-&gt;multi.msf_last.frame
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* got multisession information */
multiline_comment|/* request the disks table of contents (aka diskinfo) */
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_requesttocdata
c_func
(paren
id|stuffp
comma
op_amp
id|stuffp-&gt;di
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|stuffp-&gt;lastsector
op_assign
(paren
id|CD_FRAMESIZE
op_div
l_int|512
)paren
op_star
id|msf2log
c_func
(paren
op_amp
id|stuffp-&gt;di.msf_leadout
)paren
op_minus
l_int|1
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|OPENCLOSE
comma
l_string|&quot;open() start %d (%02x:%02x.%02x) %d&bslash;n&quot;
comma
id|stuffp-&gt;di.n_first
comma
id|stuffp-&gt;di.msf_first.minute
comma
id|stuffp-&gt;di.msf_first.second
comma
id|stuffp-&gt;di.msf_first.frame
comma
id|msf2log
c_func
(paren
op_amp
id|stuffp-&gt;di.msf_first
)paren
)paren
)paren
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|OPENCLOSE
comma
l_string|&quot;open() last %d (%02x:%02x.%02x) %d&bslash;n&quot;
comma
id|stuffp-&gt;di.n_last
comma
id|stuffp-&gt;di.msf_leadout.minute
comma
id|stuffp-&gt;di.msf_leadout.second
comma
id|stuffp-&gt;di.msf_leadout.frame
comma
id|msf2log
c_func
(paren
op_amp
id|stuffp-&gt;di.msf_leadout
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;toc
)paren
(brace
id|TRACE
c_func
(paren
(paren
id|MALLOC
comma
l_string|&quot;open() free toc @ %p&bslash;n&quot;
comma
id|stuffp-&gt;toc
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp-&gt;toc
)paren
suffix:semicolon
)brace
id|stuffp-&gt;toc
op_assign
l_int|NULL
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|OPENCLOSE
comma
l_string|&quot;open() init irq generation&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_config
c_func
(paren
id|stuffp
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* try to get the first sector ... */
(brace
r_char
id|buf
(braket
l_int|512
)braket
suffix:semicolon
r_int
id|ans
suffix:semicolon
r_int
id|tries
suffix:semicolon
id|stuffp-&gt;xa
op_assign
l_int|0
suffix:semicolon
id|stuffp-&gt;audio
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|tries
op_assign
l_int|6
suffix:semicolon
id|tries
suffix:semicolon
id|tries
op_decrement
)paren
(brace
id|TRACE
c_func
(paren
(paren
id|OPENCLOSE
comma
l_string|&quot;open() try as %s&bslash;n&quot;
comma
id|stuffp-&gt;xa
ques
c_cond
l_string|&quot;XA&quot;
suffix:colon
l_string|&quot;normal&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* set data mode */
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
id|ans
op_assign
id|mcdx_setdatamode
c_func
(paren
id|stuffp
comma
id|stuffp-&gt;xa
ques
c_cond
id|MODE2
suffix:colon
id|MODE1
comma
l_int|1
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stuffp-&gt;audio
op_assign
id|e_audio
c_func
(paren
id|ans
)paren
)paren
)paren
r_break
suffix:semicolon
r_while
c_loop
(paren
l_int|0
op_eq
(paren
id|ans
op_assign
id|mcdx_transfer
c_func
(paren
id|stuffp
comma
id|buf
comma
l_int|0
comma
l_int|1
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ans
op_eq
l_int|1
)paren
r_break
suffix:semicolon
id|stuffp-&gt;xa
op_assign
op_logical_neg
id|stuffp-&gt;xa
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tries
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* xa disks will be read in raw mode, others not */
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_setdrivemode
c_func
(paren
id|stuffp
comma
id|stuffp-&gt;xa
ques
c_cond
id|RAW
suffix:colon
id|COOKED
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;audio
)paren
(brace
id|WARN
c_func
(paren
(paren
l_string|&quot;open() audio disk found&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|WARN
c_func
(paren
(paren
l_string|&quot;open() %s%s disk found&bslash;n&quot;
comma
id|stuffp-&gt;xa
ques
c_cond
l_string|&quot;XA / &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|stuffp-&gt;multi.multi
ques
c_cond
l_string|&quot;Multi Session&quot;
suffix:colon
l_string|&quot;Single Session&quot;
)paren
)paren
suffix:semicolon
)brace
id|changed
op_assign
id|stuffp-&gt;changed
suffix:semicolon
)brace
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_lockdoor
c_func
(paren
id|stuffp
comma
l_int|1
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|stuffp-&gt;users
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|mcdx_close
id|mcdx_close
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|OPENCLOSE
comma
l_string|&quot;close()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|ip-&gt;i_rdev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
op_decrement
id|stuffp-&gt;users
)paren
(brace
id|sync_dev
c_func
(paren
id|ip-&gt;i_rdev
)paren
suffix:semicolon
multiline_comment|/* needed for r/o device? */
multiline_comment|/* invalidate_inodes(ip-&gt;i_rdev); */
id|invalidate_buffers
c_func
(paren
id|ip-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_lockdoor
c_func
(paren
id|stuffp
comma
l_int|0
comma
l_int|1
)paren
)paren
id|printk
c_func
(paren
id|MCD
l_string|&quot;: Cannot unlock the door&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|check_mcdx_media_change
r_int
id|check_mcdx_media_change
c_func
(paren
id|dev_t
id|full_dev
)paren
multiline_comment|/*&t;Return: 1 if media changed since last call to &n;&t;&t;&t;  this function&n;&t;&t;&t;0 else&n;&t;Setting flag to 0 resets the changed state. */
(brace
id|printk
c_func
(paren
id|MCD
l_string|&quot;:: check_mcdx_media_change(0x%x) called&bslash;n&quot;
comma
id|full_dev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mcdx_setup
r_void
id|mcdx_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|pi
)paren
(brace
macro_line|#if MCDX_DEBUG
id|printk
c_func
(paren
id|MCD
l_string|&quot;:: setup(%s, %d) called&bslash;n&quot;
comma
id|str
comma
id|pi
(braket
l_int|0
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* DIRTY PART ******************************************************/
DECL|function|mcdx_delay
r_static
r_void
id|mcdx_delay
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuff
comma
r_int
id|jifs
)paren
multiline_comment|/*&t;This routine is used for sleeping while initialisation - it seems that&n; &t;there are no other means available. May be we could use a simple count&n; &t;loop w/ jumps to itself, but I wanna make this independend of cpu&n; &t;speed.  */
(brace
r_int
r_int
id|tout
op_assign
id|jiffies
op_plus
id|jifs
suffix:semicolon
r_if
c_cond
(paren
id|jifs
OL
l_int|0
)paren
r_return
suffix:semicolon
macro_line|#ifdef MODULE
multiline_comment|/*&t;timer are available */
id|current-&gt;timeout
op_assign
id|tout
suffix:semicolon
r_while
c_loop
(paren
id|current-&gt;timeout
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
id|stuff-&gt;sleepq
)paren
suffix:semicolon
macro_line|#else
multiline_comment|/* timer are _not_ available at initialisation time */
r_if
c_cond
(paren
id|stuff-&gt;present
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|tout
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|stuff-&gt;sleepq
)paren
suffix:semicolon
)brace
r_else
r_while
c_loop
(paren
id|jiffies
OL
id|tout
)paren
(brace
id|current-&gt;timeout
op_assign
id|jiffies
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif MODULE
)brace
r_static
r_void
DECL|function|mcdx_intr
id|mcdx_intr
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
r_int
r_char
id|x
suffix:semicolon
id|stuffp
op_assign
id|mcdx_irq_map
(braket
id|irq
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;busy
)paren
(brace
id|WARN
c_func
(paren
(paren
l_string|&quot;intr() unexpected interrupt @ irq %d&bslash;n&quot;
comma
id|irq
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* if not ok read the next byte as the drives status */
r_if
c_cond
(paren
l_int|0
op_eq
(paren
id|stuffp-&gt;introk
op_assign
(paren
op_complement
(paren
id|x
op_assign
id|inb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_status
)paren
)paren
op_amp
id|MCDX_RBIT_DTEN
)paren
)paren
)paren
id|TRACE
c_func
(paren
(paren
id|IRQ
comma
l_string|&quot;intr() irq %d failed, status %02x %02x&bslash;n&quot;
comma
id|irq
comma
id|x
comma
id|inb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_data
)paren
)paren
)paren
suffix:semicolon
r_else
(brace
id|dummy0
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|IRQ
comma
l_string|&quot;irq() irq %d ok, status %02x&bslash;n&quot;
comma
id|irq
comma
id|x
)paren
)paren
suffix:semicolon
)brace
id|stuffp-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|stuffp-&gt;busyq
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_talk
id|mcdx_talk
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_const
r_int
r_char
op_star
id|cmd
comma
r_int
id|cmdlen
comma
r_void
op_star
id|buffer
comma
r_int
id|size
comma
r_int
r_int
id|timeout
comma
r_int
id|tries
)paren
multiline_comment|/* Send a command to the drive, wait for the result.&n; * returns -1 on timeout, drive status otherwise&n; */
(brace
r_const
id|DELAY
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* minimum delay */
r_char
id|c
suffix:semicolon
r_int
id|st
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer
op_logical_or
id|size
op_eq
l_int|0
)paren
id|buffer
op_assign
op_amp
id|c
comma
id|size
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|stuffp-&gt;lock
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
id|stuffp-&gt;lockq
)paren
suffix:semicolon
id|stuffp-&gt;lock
op_assign
l_int|1
suffix:semicolon
id|stuffp-&gt;valid
op_assign
l_int|0
suffix:semicolon
macro_line|#if MCDX_DEBUG &amp; TALK
(brace
r_int
r_char
id|i
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|TALK
comma
l_string|&quot;talk() res.size %d, command 0x%02x&quot;
comma
id|size
comma
(paren
r_int
r_char
)paren
id|cmd
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|cmdlen
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; 0x%02x&quot;
comma
id|cmd
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_for
c_loop
(paren
id|st
op_assign
op_minus
l_int|1
suffix:semicolon
id|st
op_eq
op_minus
l_int|1
op_logical_and
id|tries
suffix:semicolon
id|tries
op_decrement
)paren
(brace
r_int
id|sz
op_assign
id|size
suffix:semicolon
r_int
r_char
op_star
id|bp
op_assign
id|buffer
suffix:semicolon
id|outsb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_data
comma
id|cmd
comma
id|cmdlen
)paren
suffix:semicolon
r_while
c_loop
(paren
id|sz
op_decrement
)paren
(brace
r_int
id|to
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* wait for the status bit */
(brace
r_int
r_int
id|limit
op_assign
id|jiffies
op_plus
id|timeout
suffix:semicolon
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_status
)paren
)paren
op_amp
id|MCDX_RBIT_STEN
)paren
(brace
r_if
c_cond
(paren
(paren
id|to
op_assign
(paren
id|jiffies
OG
id|limit
)paren
)paren
)paren
r_break
suffix:semicolon
id|mcdx_delay
c_func
(paren
id|stuffp
comma
id|DELAY
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|to
)paren
(brace
multiline_comment|/* status read? */
r_if
c_cond
(paren
id|st
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* read the status byte */
op_star
id|bp
op_increment
op_assign
id|st
op_assign
(paren
r_int
r_char
)paren
id|inb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_data
)paren
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|TALK
comma
l_string|&quot;talk() got status 0x%02x&bslash;n&quot;
comma
id|st
)paren
)paren
suffix:semicolon
multiline_comment|/* audio status is handled here */
id|stuffp-&gt;audiostatus
op_assign
id|e_audiobusy
c_func
(paren
id|st
)paren
ques
c_cond
id|CDROM_AUDIO_PLAY
suffix:colon
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
multiline_comment|/* media change is handled here ... */
r_if
c_cond
(paren
id|e_changed
c_func
(paren
id|st
)paren
)paren
(brace
id|WARN
c_func
(paren
(paren
l_string|&quot;talk() media changed&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stuffp-&gt;changed
op_assign
id|jiffies
suffix:semicolon
)brace
multiline_comment|/* command error is handled here ... */
r_if
c_cond
(paren
id|e_cmderr
c_func
(paren
id|st
)paren
)paren
(brace
id|WARN
c_func
(paren
(paren
l_string|&quot;command error&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|st
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* read the answer */
op_star
id|bp
op_increment
op_assign
(paren
r_int
r_char
)paren
id|inb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_data
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|WARN
c_func
(paren
(paren
l_string|&quot;talk() timed out, %1d %s left&bslash;n&quot;
comma
id|tries
op_minus
l_int|1
comma
(paren
id|tries
op_minus
l_int|1
)paren
OG
l_int|1
ques
c_cond
l_string|&quot;tries&quot;
suffix:colon
l_string|&quot;try&quot;
)paren
)paren
suffix:semicolon
id|st
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|tries
)paren
id|WARN
c_func
(paren
(paren
l_string|&quot;talk() giving up&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stuffp-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|stuffp-&gt;lockq
)paren
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|TALK
comma
l_string|&quot;talk() done with 0x%02x&bslash;n&quot;
comma
id|st
)paren
)paren
suffix:semicolon
r_return
id|st
suffix:semicolon
)brace
multiline_comment|/* MODULE STUFF ***********************************************************/
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|drives
op_assign
l_int|0
suffix:semicolon
id|mcdx_init
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MCDX_NDRIVES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mcdx_stuffp
(braket
id|i
)braket
)paren
(brace
id|TRACE
c_func
(paren
(paren
id|INIT
comma
l_string|&quot;init_module() drive %d stuff @ %p&bslash;n&quot;
comma
id|i
comma
id|mcdx_stuffp
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
id|drives
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|drives
)paren
(brace
id|WARN
c_func
(paren
(paren
l_string|&quot;init_module() cannot init any drive&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|WARN
c_func
(paren
(paren
l_string|&quot;cleanup_module called&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MCDX_NDRIVES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp
)paren
r_continue
suffix:semicolon
id|release_region
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_data
comma
id|MCDX_IO_SIZE
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|stuffp-&gt;irq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;toc
)paren
(brace
id|TRACE
c_func
(paren
(paren
id|MALLOC
comma
l_string|&quot;cleanup_module() free toc @ %p&bslash;n&quot;
comma
id|stuffp-&gt;toc
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp-&gt;toc
)paren
suffix:semicolon
)brace
id|TRACE
c_func
(paren
(paren
id|MALLOC
comma
l_string|&quot;cleanup_module() free stuffp @ %p&bslash;n&quot;
comma
id|stuffp
)paren
)paren
suffix:semicolon
id|mcdx_stuffp
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
id|MCD
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
id|MCD
l_string|&quot;: cleanup_module failed.&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|MCD
l_string|&quot;: cleanup_module succeeded.&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif MODULE
multiline_comment|/* Support functions ************************************************/
macro_line|#if MCDX_DEBUG
DECL|function|trace
r_void
id|trace
c_func
(paren
r_int
id|level
comma
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
r_char
id|s
(braket
l_int|255
)braket
suffix:semicolon
id|va_list
id|args
suffix:semicolon
r_if
c_cond
(paren
id|level
OL
l_int|1
)paren
r_return
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
id|s
)paren
OL
id|vsprintf
c_func
(paren
id|s
comma
id|fmt
comma
id|args
)paren
)paren
id|printk
c_func
(paren
id|MCD
l_string|&quot;:: dprintf exeeds limit!!&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|MCD
l_string|&quot;:: %s&quot;
comma
id|s
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifndef NOWARN
DECL|function|warn
r_void
id|warn
c_func
(paren
r_const
r_char
op_star
id|fmt
comma
dot
dot
dot
)paren
(brace
r_char
id|s
(braket
l_int|255
)braket
suffix:semicolon
id|va_list
id|args
suffix:semicolon
id|va_start
c_func
(paren
id|args
comma
id|fmt
)paren
suffix:semicolon
r_if
c_cond
(paren
r_sizeof
(paren
id|s
)paren
OL
id|vsprintf
c_func
(paren
id|s
comma
id|fmt
comma
id|args
)paren
)paren
id|printk
c_func
(paren
id|MCD
l_string|&quot;:: dprintf exeeds limit!!&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|MCD
l_string|&quot;: %s&quot;
comma
id|s
)paren
suffix:semicolon
id|va_end
c_func
(paren
id|args
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|mcdx_init
r_int
r_int
id|mcdx_init
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
(brace
r_int
id|drive
suffix:semicolon
id|printk
c_func
(paren
id|MCD
l_string|&quot;: Version @VERSION@ &quot;
l_string|&quot;$Id: mcdx.c,v 1.2 1995/06/18 18:00:53 heiko Exp $ &bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* zero the pointer array */
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|MCDX_NDRIVES
suffix:semicolon
id|drive
op_increment
)paren
id|mcdx_stuffp
(braket
id|drive
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* do the initialisation */
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|MCDX_NDRIVES
suffix:semicolon
id|drive
op_increment
)paren
(brace
r_struct
id|s_version
id|version
suffix:semicolon
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|INIT
comma
l_string|&quot;init() try drive %d&bslash;n&quot;
comma
id|drive
)paren
)paren
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|MALLOC
comma
l_string|&quot;init() malloc %d bytes&bslash;n&quot;
comma
r_sizeof
(paren
op_star
id|stuffp
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|stuffp
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|stuffp
)paren
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|WARN
c_func
(paren
(paren
l_string|&quot;init() malloc failed&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|TRACE
c_func
(paren
(paren
id|INIT
comma
l_string|&quot;init() got %d bytes for drive stuff @ %p&bslash;n&quot;
comma
r_sizeof
(paren
op_star
id|stuffp
)paren
comma
id|stuffp
)paren
)paren
suffix:semicolon
multiline_comment|/* zero the stuff */
id|memset
c_func
(paren
id|stuffp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|stuffp
)paren
)paren
suffix:semicolon
id|stuffp-&gt;present
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* this should be 0 already */
id|stuffp-&gt;toc
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* this should be NULL already */
id|stuffp-&gt;changed
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* setup our irq and i/o addresses */
id|stuffp-&gt;irq
op_assign
id|irq
c_func
(paren
id|mcdx_drive_map
(braket
id|drive
)braket
)paren
suffix:semicolon
id|stuffp-&gt;wreg_data
op_assign
id|stuffp-&gt;rreg_data
op_assign
id|port
c_func
(paren
id|mcdx_drive_map
(braket
id|drive
)braket
)paren
suffix:semicolon
id|stuffp-&gt;wreg_reset
op_assign
id|stuffp-&gt;rreg_status
op_assign
id|stuffp-&gt;wreg_data
op_plus
l_int|1
suffix:semicolon
id|stuffp-&gt;wreg_hcon
op_assign
id|stuffp-&gt;wreg_reset
op_plus
l_int|1
suffix:semicolon
id|stuffp-&gt;wreg_chn
op_assign
id|stuffp-&gt;wreg_hcon
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* check if i/o addresses are available */
r_if
c_cond
(paren
l_int|0
op_ne
id|check_region
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_data
comma
id|MCDX_IO_SIZE
)paren
)paren
(brace
id|WARN
c_func
(paren
(paren
l_string|&quot;init() i/o ports at 0x%3p .. 0x%3p not available&bslash;n&quot;
comma
id|stuffp-&gt;wreg_data
comma
id|stuffp-&gt;wreg_data
op_plus
id|MCDX_IO_SIZE
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|stuffp-&gt;wreg_data
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|MALLOC
comma
l_string|&quot;init() free stuffp @ %p&bslash;n&quot;
comma
id|stuffp
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|INIT
comma
l_string|&quot;init() continue at next drive&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* next drive */
)brace
id|TRACE
c_func
(paren
(paren
id|INIT
comma
l_string|&quot;init() i/o port is available at 0x%3p&bslash;n&quot;
comma
id|stuffp-&gt;wreg_data
)paren
)paren
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|INIT
comma
l_string|&quot;init() hardware reset&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|mcdx_reset
c_func
(paren
id|stuffp
comma
id|HARD
comma
l_int|1
)paren
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|INIT
comma
l_string|&quot;init() get version&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_requestversion
c_func
(paren
id|stuffp
comma
op_amp
id|version
comma
l_int|2
)paren
)paren
(brace
multiline_comment|/* failed, next drive */
id|TRACE
c_func
(paren
(paren
id|MALLOC
comma
l_string|&quot;init() free stuffp @ %p&bslash;n&quot;
comma
id|stuffp
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|INIT
comma
l_string|&quot;init() continue at next drive&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|version.code
)paren
(brace
r_case
l_char|&squot;D&squot;
suffix:colon
id|stuffp-&gt;readcmd
op_assign
id|READDSPEED
suffix:semicolon
id|stuffp-&gt;present
op_assign
id|DOUBLE
op_or
id|DOOR
op_or
id|MULTI
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;F&squot;
suffix:colon
id|stuffp-&gt;readcmd
op_assign
id|READSSPEED
suffix:semicolon
id|stuffp-&gt;present
op_assign
id|SINGLE
op_or
id|DOOR
op_or
id|MULTI
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;M&squot;
suffix:colon
id|stuffp-&gt;readcmd
op_assign
id|READSSPEED
suffix:semicolon
id|stuffp-&gt;present
op_assign
id|SINGLE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|stuffp-&gt;present
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;present
)paren
(brace
id|printk
c_func
(paren
id|MCD
l_string|&quot;: no drive found. continue at next drive&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* next drive */
)brace
id|TRACE
c_func
(paren
(paren
id|INIT
comma
l_string|&quot;init() register blkdev&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
id|MCD
comma
op_amp
id|mcdx_fops
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|MCD
l_string|&quot;: unable to get major %d for &quot;
id|DEVICE_NAME
l_string|&quot;&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* next drive */
)brace
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
id|READ_AHEAD
suffix:semicolon
macro_line|#if WE_KNOW_WHY
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|BLKSIZES
suffix:semicolon
macro_line|#endif
id|TRACE
c_func
(paren
(paren
id|INIT
comma
l_string|&quot;init() subscribe irq and i/o&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|mcdx_irq_map
(braket
id|stuffp-&gt;irq
)braket
op_assign
id|stuffp
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|stuffp-&gt;irq
comma
id|mcdx_intr
comma
id|SA_INTERRUPT
comma
id|MCD
)paren
)paren
(brace
id|printk
c_func
(paren
id|MCD
l_string|&quot;: init() unable to get IRQ %d for &quot;
id|DEVICE_NAME
l_string|&quot;&bslash;n&quot;
comma
id|stuffp-&gt;irq
)paren
suffix:semicolon
id|stuffp-&gt;irq
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|request_region
c_func
(paren
(paren
r_int
r_int
)paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_data
comma
id|MCDX_IO_SIZE
comma
id|MCD
)paren
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|INIT
comma
l_string|&quot;init() get garbage&bslash;n&quot;
)paren
)paren
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
id|mcdx_delay
c_func
(paren
id|stuffp
comma
l_int|50
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|100
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(paren
r_void
)paren
id|inb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_status
)paren
suffix:semicolon
)brace
macro_line|#if WE_KNOW_WHY
id|outb
c_func
(paren
l_int|0x50
comma
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_chn
)paren
suffix:semicolon
multiline_comment|/* irq 11 -&gt; channel register */
macro_line|#endif
id|TRACE
c_func
(paren
(paren
id|INIT
comma
l_string|&quot;init() set non dma but irq mode&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|mcdx_config
c_func
(paren
id|stuffp
comma
l_int|1
)paren
suffix:semicolon
id|stuffp-&gt;minor
op_assign
id|drive
suffix:semicolon
id|printk
c_func
(paren
id|MCD
l_string|&quot;: &quot;
id|DEVICE_NAME
l_string|&quot; installed at 0x%3p, irq %d.&bslash;n&quot;
id|MCD
l_string|&quot;: Firmware version %c %x&bslash;n&quot;
comma
id|stuffp-&gt;wreg_data
comma
id|stuffp-&gt;irq
comma
id|version.code
comma
id|version.ver
)paren
suffix:semicolon
id|mcdx_stuffp
(braket
id|drive
)braket
op_assign
id|stuffp
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|INIT
comma
l_string|&quot;init() mcdx_stuffp[%d] = %p&bslash;n&quot;
comma
id|drive
comma
id|stuffp
)paren
)paren
suffix:semicolon
)brace
r_return
id|mem_start
suffix:semicolon
)brace
DECL|function|mcdx_transfer
r_static
r_int
id|mcdx_transfer
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_char
op_star
id|p
comma
r_int
id|sector
comma
r_int
id|nr_sectors
)paren
multiline_comment|/*&t;This does actually the transfer from the drive.&n;&t;Return:&t;-1 on timeout or other error&n;&t;&t;&t;else status byte (as in stuff-&gt;st) */
(brace
r_int
id|off
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|TRANSFER
comma
l_string|&quot;transfer() %d sectors at sector %d&bslash;n&quot;
comma
id|nr_sectors
comma
id|sector
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;audio
)paren
(brace
id|printk
c_func
(paren
id|MCD
l_string|&quot;: attempt to read from audio disk&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|stuffp-&gt;lock
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
id|stuffp-&gt;lockq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;valid
op_logical_and
(paren
id|sector
op_ge
id|stuffp-&gt;pending
)paren
op_logical_and
(paren
id|sector
OL
id|stuffp-&gt;off_direct
)paren
)paren
(brace
id|off
op_assign
id|stuffp-&gt;off_requested
OL
(paren
id|off
op_assign
id|sector
op_plus
id|nr_sectors
)paren
ques
c_cond
id|stuffp-&gt;off_requested
suffix:colon
id|off
suffix:semicolon
id|stuffp-&gt;lock
op_assign
id|current-&gt;pid
suffix:semicolon
r_do
(brace
r_int
id|sig
op_assign
l_int|0
suffix:semicolon
r_int
id|to
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* wait for the drive become idle */
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
l_int|500
suffix:semicolon
r_while
c_loop
(paren
id|stuffp-&gt;busy
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|stuffp-&gt;busyq
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sig
op_assign
(paren
id|current-&gt;signal
op_logical_and
op_complement
id|current-&gt;blocked
)paren
)paren
op_logical_or
(paren
id|to
op_assign
(paren
id|current-&gt;timeout
op_eq
l_int|0
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|current-&gt;timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* test for possible errors */
r_if
c_cond
(paren
(paren
(paren
id|stuffp-&gt;busy
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
id|stuffp-&gt;introk
)paren
op_logical_or
id|sig
op_logical_or
id|to
)paren
(brace
r_if
c_cond
(paren
(paren
id|stuffp-&gt;busy
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
id|stuffp-&gt;introk
)paren
id|printk
c_func
(paren
id|MCD
l_string|&quot;: failure in data request&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|to
)paren
id|printk
c_func
(paren
id|MCD
l_string|&quot;: timeout&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sig
)paren
id|printk
c_func
(paren
id|MCD
l_string|&quot;: got signal 0x%lx&bslash;n&quot;
comma
id|current-&gt;signal
)paren
suffix:semicolon
id|stuffp-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|stuffp-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|stuffp-&gt;lockq
)paren
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|stuffp-&gt;busyq
)paren
suffix:semicolon
id|stuffp-&gt;errno
op_assign
id|MCDX_E
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|TRANSFER
comma
l_string|&quot;transfer() done (-1)&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* test if it&squot;s the first sector of a block,&n;&t;&t; * there we have to skip some bytes as we read raw data */
r_if
c_cond
(paren
id|stuffp-&gt;xa
op_logical_and
(paren
l_int|0
op_eq
(paren
id|stuffp-&gt;pending
op_amp
l_int|3
)paren
)paren
)paren
(brace
r_const
r_int
id|HEAD
op_assign
id|CD_FRAMESIZE_RAW
op_minus
id|CD_XA_TAIL
op_minus
id|CD_FRAMESIZE
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|TRANSFER
comma
l_string|&quot;transfer() sector %d, skip %d header bytes&bslash;n&quot;
comma
id|stuffp-&gt;pending
comma
id|HEAD
)paren
)paren
suffix:semicolon
id|insb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_data
comma
id|p
comma
id|HEAD
)paren
suffix:semicolon
)brace
multiline_comment|/* now actually read the data */
id|TRACE
c_func
(paren
(paren
id|TRANSFER
comma
l_string|&quot;transfer() read sector %d&bslash;n&quot;
comma
id|stuffp-&gt;pending
)paren
)paren
suffix:semicolon
id|insb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_data
comma
id|p
comma
l_int|512
)paren
suffix:semicolon
multiline_comment|/* test if it&squot;s the last sector of a block,&n;&t;&t; * if so, we have to expect an interrupt and to skip some&n;&t;&t; * data too */
r_if
c_cond
(paren
(paren
id|stuffp-&gt;busy
op_assign
(paren
l_int|3
op_eq
(paren
id|stuffp-&gt;pending
op_amp
l_int|3
)paren
)paren
)paren
op_logical_and
id|stuffp-&gt;xa
)paren
(brace
r_char
id|dummy
(braket
id|CD_XA_TAIL
)braket
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|TRANSFER
comma
l_string|&quot;transfer() sector %d, skip %d trailer bytes&bslash;n&quot;
comma
id|stuffp-&gt;pending
comma
id|CD_XA_TAIL
)paren
)paren
suffix:semicolon
id|insb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_data
comma
op_amp
id|dummy
(braket
l_int|0
)braket
comma
id|CD_XA_TAIL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stuffp-&gt;pending
op_eq
id|sector
)paren
(brace
id|p
op_add_assign
l_int|512
suffix:semicolon
id|done
op_increment
suffix:semicolon
id|sector
op_increment
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_increment
(paren
id|stuffp-&gt;pending
)paren
OL
id|off
)paren
suffix:semicolon
id|stuffp-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|stuffp-&gt;lockq
)paren
suffix:semicolon
)brace
r_else
(brace
r_static
r_int
r_char
id|cmd
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|stuffp-&gt;readcmd
suffix:semicolon
id|stuffp-&gt;valid
op_assign
l_int|1
suffix:semicolon
id|stuffp-&gt;pending
op_assign
id|sector
op_amp
op_complement
l_int|3
suffix:semicolon
multiline_comment|/* do some sanity checks */
id|TRACE
c_func
(paren
(paren
id|TRANSFER
comma
l_string|&quot;transfer() request sector %d&bslash;n&quot;
comma
id|stuffp-&gt;pending
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;pending
OG
id|stuffp-&gt;lastsector
)paren
(brace
id|printk
c_func
(paren
id|MCD
l_string|&quot;: transfer() sector %d from nirvana requested.&bslash;n&quot;
comma
id|stuffp-&gt;pending
)paren
suffix:semicolon
id|stuffp-&gt;errno
op_assign
id|MCDX_EOM
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|TRANSFER
comma
l_string|&quot;transfer() done (-1)&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stuffp-&gt;off_direct
op_assign
id|stuffp-&gt;pending
op_plus
id|DIRECT_SIZE
)paren
OG
id|stuffp-&gt;lastsector
op_plus
l_int|1
)paren
id|stuffp-&gt;off_direct
op_assign
id|stuffp-&gt;lastsector
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stuffp-&gt;off_requested
op_assign
id|stuffp-&gt;pending
op_plus
id|REQUEST_SIZE
)paren
OG
id|stuffp-&gt;lastsector
op_plus
l_int|1
)paren
id|stuffp-&gt;off_requested
op_assign
id|stuffp-&gt;lastsector
op_plus
l_int|1
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|TRANSFER
comma
l_string|&quot;transfer() pending %d&bslash;n&quot;
comma
id|stuffp-&gt;pending
)paren
)paren
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|TRANSFER
comma
l_string|&quot;transfer() off_dir %d&bslash;n&quot;
comma
id|stuffp-&gt;off_direct
)paren
)paren
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|TRANSFER
comma
l_string|&quot;transfer() off_req %d&bslash;n&quot;
comma
id|stuffp-&gt;off_requested
)paren
)paren
suffix:semicolon
(brace
r_struct
id|s_msf
id|pending
suffix:semicolon
id|log2msf
c_func
(paren
id|stuffp-&gt;pending
op_div
l_int|4
comma
op_amp
id|pending
)paren
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
id|pending.minute
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
id|pending.second
suffix:semicolon
id|cmd
(braket
l_int|3
)braket
op_assign
id|pending.frame
suffix:semicolon
)brace
id|stuffp-&gt;busy
op_assign
l_int|1
suffix:semicolon
id|cmd
(braket
l_int|6
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
id|stuffp-&gt;off_requested
op_minus
id|stuffp-&gt;pending
)paren
op_div
l_int|4
suffix:semicolon
id|outsb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_data
comma
id|cmd
comma
r_sizeof
id|cmd
)paren
suffix:semicolon
)brace
id|stuffp-&gt;off_direct
op_assign
(paren
id|stuffp-&gt;off_direct
op_add_assign
id|done
)paren
OL
id|stuffp-&gt;off_requested
ques
c_cond
id|stuffp-&gt;off_direct
suffix:colon
id|stuffp-&gt;off_requested
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|TRANSFER
comma
l_string|&quot;transfer() done (%d)&bslash;n&quot;
comma
id|done
)paren
)paren
suffix:semicolon
r_return
id|done
suffix:semicolon
)brace
multiline_comment|/*&t;Access to elements of the mcdx_drive_map members */
DECL|function|port
r_static
r_char
op_star
id|port
c_func
(paren
r_int
op_star
id|ip
)paren
(brace
r_return
(paren
r_char
op_star
)paren
id|ip
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|irq
r_static
r_int
id|irq
c_func
(paren
r_int
op_star
id|ip
)paren
(brace
r_return
id|ip
(braket
l_int|1
)braket
suffix:semicolon
)brace
multiline_comment|/*&t;Misc number converters */
DECL|function|bcd2uint
r_static
r_int
r_int
id|bcd2uint
c_func
(paren
r_int
r_char
id|c
)paren
(brace
r_return
(paren
id|c
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|c
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
DECL|function|uint2bcd
r_static
r_int
r_int
id|uint2bcd
c_func
(paren
r_int
r_int
id|ival
)paren
(brace
r_return
(paren
(paren
id|ival
op_div
l_int|10
)paren
op_lshift
l_int|4
)paren
op_or
(paren
id|ival
op_mod
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|log2msf
r_static
r_void
id|log2msf
c_func
(paren
r_int
r_int
id|l
comma
r_struct
id|s_msf
op_star
id|pmsf
)paren
(brace
id|l
op_add_assign
id|CD_BLOCK_OFFSET
suffix:semicolon
id|pmsf-&gt;minute
op_assign
id|uint2bcd
c_func
(paren
id|l
op_div
l_int|4500
)paren
comma
id|l
op_mod_assign
l_int|4500
suffix:semicolon
id|pmsf-&gt;second
op_assign
id|uint2bcd
c_func
(paren
id|l
op_div
l_int|75
)paren
suffix:semicolon
id|pmsf-&gt;frame
op_assign
id|uint2bcd
c_func
(paren
id|l
op_mod
l_int|75
)paren
suffix:semicolon
)brace
DECL|function|msf2log
r_static
r_int
r_int
id|msf2log
c_func
(paren
r_const
r_struct
id|s_msf
op_star
id|pmsf
)paren
(brace
r_return
id|bcd2uint
c_func
(paren
id|pmsf-&gt;frame
)paren
op_plus
id|bcd2uint
c_func
(paren
id|pmsf-&gt;second
)paren
op_star
l_int|75
op_plus
id|bcd2uint
c_func
(paren
id|pmsf-&gt;minute
)paren
op_star
l_int|4500
op_minus
id|CD_BLOCK_OFFSET
suffix:semicolon
)brace
DECL|function|mcdx_readtoc
r_int
id|mcdx_readtoc
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
)paren
(brace
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() readtoc for %d tracks&bslash;n&quot;
comma
id|stuffp-&gt;di.n_last
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|1
)paren
)paren
suffix:semicolon
macro_line|#if MCDX_DEBUG &amp;&amp; IOCTL
r_if
c_cond
(paren
id|stuffp-&gt;toc
)paren
(brace
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() toc already read&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() tocmode&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_setdrivemode
c_func
(paren
id|stuffp
comma
id|TOC
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* all seems to be ok so far ... malloc */
(brace
r_int
id|size
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
r_struct
id|s_subqcode
)paren
op_star
(paren
id|stuffp-&gt;di.n_last
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|2
)paren
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|MALLOC
comma
l_string|&quot;ioctl() malloc %d bytes&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
id|stuffp-&gt;toc
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;toc
)paren
(brace
id|WARN
c_func
(paren
(paren
l_string|&quot;Cannot malloc %s bytes for toc&bslash;n&quot;
comma
id|size
)paren
)paren
suffix:semicolon
id|mcdx_setdrivemode
c_func
(paren
id|stuffp
comma
id|DATA
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
multiline_comment|/* now read actually the index */
(brace
r_int
id|trk
suffix:semicolon
r_int
id|retries
suffix:semicolon
r_for
c_loop
(paren
id|trk
op_assign
l_int|0
suffix:semicolon
id|trk
OL
(paren
id|stuffp-&gt;di.n_last
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|1
)paren
suffix:semicolon
id|trk
op_increment
)paren
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|index
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|retries
op_assign
l_int|300
suffix:semicolon
id|retries
suffix:semicolon
id|retries
op_decrement
)paren
(brace
multiline_comment|/* why 300? */
r_struct
id|s_subqcode
id|q
suffix:semicolon
r_int
r_int
id|idx
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_requestsubqcode
c_func
(paren
id|stuffp
comma
op_amp
id|q
comma
l_int|1
)paren
)paren
(brace
id|mcdx_setdrivemode
c_func
(paren
id|stuffp
comma
id|DATA
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|idx
op_assign
id|bcd2uint
c_func
(paren
id|q.index
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|idx
OG
l_int|0
)paren
op_logical_and
(paren
id|idx
op_le
id|stuffp-&gt;di.n_last
)paren
op_logical_and
(paren
id|q.tno
op_eq
l_int|0
)paren
op_logical_and
(paren
id|stuffp-&gt;toc
(braket
id|idx
op_minus
id|stuffp-&gt;di.n_first
)braket
dot
id|index
op_eq
l_int|0
)paren
)paren
(brace
id|stuffp-&gt;toc
(braket
id|idx
op_minus
id|stuffp-&gt;di.n_first
)braket
op_assign
id|q
suffix:semicolon
id|trk
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|trk
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|stuffp-&gt;toc
(braket
id|stuffp-&gt;di.n_last
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|1
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|stuffp-&gt;toc
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|stuffp-&gt;toc
(braket
id|stuffp-&gt;di.n_last
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|1
)braket
dot
id|dt
op_assign
id|stuffp-&gt;di.msf_leadout
suffix:semicolon
)brace
multiline_comment|/* unset toc mode */
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() undo toc mode&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_setdrivemode
c_func
(paren
id|stuffp
comma
id|DATA
comma
l_int|2
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
macro_line|#if MCDX_DEBUG &amp;&amp; IOCTL
(brace
r_int
id|trk
suffix:semicolon
r_for
c_loop
(paren
id|trk
op_assign
l_int|0
suffix:semicolon
id|trk
OL
(paren
id|stuffp-&gt;di.n_last
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|2
)paren
suffix:semicolon
id|trk
op_increment
)paren
id|TRACE
c_func
(paren
(paren
id|IOCTL
comma
l_string|&quot;ioctl() %d readtoc %02x %02x %02x&quot;
l_string|&quot;  %02x:%02x.%02x  %02x:%02x.%02x&bslash;n&quot;
comma
id|trk
op_plus
id|stuffp-&gt;di.n_first
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|control
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|tno
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|index
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|tt.minute
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|tt.second
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|tt.frame
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|dt.minute
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|dt.second
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|dt.frame
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Drive functions ************************************************/
r_static
r_int
DECL|function|mcdx_closedoor
id|mcdx_closedoor
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_int
id|tries
)paren
(brace
r_if
c_cond
(paren
id|stuffp-&gt;present
op_amp
id|DOOR
)paren
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;xf8&quot;
comma
l_int|1
comma
l_int|NULL
comma
l_int|0
comma
l_int|500
comma
id|tries
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_stop
id|mcdx_stop
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_int
id|tries
)paren
(brace
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;xf0&quot;
comma
l_int|1
comma
l_int|NULL
comma
l_int|0
comma
l_int|200
comma
id|tries
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_eject
id|mcdx_eject
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_int
id|tries
)paren
(brace
r_if
c_cond
(paren
id|stuffp-&gt;present
op_amp
id|DOOR
)paren
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;xf6&quot;
comma
l_int|1
comma
l_int|NULL
comma
l_int|0
comma
l_int|500
comma
id|tries
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_requestsubqcode
id|mcdx_requestsubqcode
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_struct
id|s_subqcode
op_star
id|sub
comma
r_int
id|tries
)paren
(brace
r_char
id|buf
(braket
l_int|11
)braket
suffix:semicolon
r_int
id|ans
suffix:semicolon
id|ans
op_assign
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;x20&quot;
comma
l_int|1
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_int|200
comma
id|tries
)paren
suffix:semicolon
id|sub-&gt;control
op_assign
id|buf
(braket
l_int|1
)braket
suffix:semicolon
id|sub-&gt;tno
op_assign
id|buf
(braket
l_int|2
)braket
suffix:semicolon
id|sub-&gt;index
op_assign
id|buf
(braket
l_int|3
)braket
suffix:semicolon
id|sub-&gt;tt.minute
op_assign
id|buf
(braket
l_int|4
)braket
suffix:semicolon
id|sub-&gt;tt.second
op_assign
id|buf
(braket
l_int|5
)braket
suffix:semicolon
id|sub-&gt;tt.frame
op_assign
id|buf
(braket
l_int|6
)braket
suffix:semicolon
id|sub-&gt;dt.minute
op_assign
id|buf
(braket
l_int|8
)braket
suffix:semicolon
id|sub-&gt;dt.second
op_assign
id|buf
(braket
l_int|9
)braket
suffix:semicolon
id|sub-&gt;dt.frame
op_assign
id|buf
(braket
l_int|10
)braket
suffix:semicolon
r_return
id|ans
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_requestmultidiskinfo
id|mcdx_requestmultidiskinfo
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_struct
id|s_multi
op_star
id|multi
comma
r_int
id|tries
)paren
(brace
r_char
id|buf
(braket
l_int|5
)braket
suffix:semicolon
r_int
id|ans
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;present
op_amp
id|MULTI
)paren
(brace
id|ans
op_assign
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;x11&quot;
comma
l_int|1
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_int|200
comma
id|tries
)paren
suffix:semicolon
id|multi-&gt;multi
op_assign
id|buf
(braket
l_int|1
)braket
suffix:semicolon
id|multi-&gt;msf_last.minute
op_assign
id|buf
(braket
l_int|2
)braket
suffix:semicolon
id|multi-&gt;msf_last.second
op_assign
id|buf
(braket
l_int|3
)braket
suffix:semicolon
id|multi-&gt;msf_last.frame
op_assign
id|buf
(braket
l_int|4
)braket
suffix:semicolon
r_return
id|ans
suffix:semicolon
)brace
r_else
(brace
id|multi-&gt;multi
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|mcdx_requesttocdata
id|mcdx_requesttocdata
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_struct
id|s_diskinfo
op_star
id|info
comma
r_int
id|tries
)paren
(brace
r_char
id|buf
(braket
l_int|9
)braket
suffix:semicolon
r_int
id|ans
suffix:semicolon
id|ans
op_assign
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;x10&quot;
comma
l_int|1
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_int|200
comma
id|tries
)paren
suffix:semicolon
id|info-&gt;n_first
op_assign
id|bcd2uint
c_func
(paren
id|buf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|info-&gt;n_last
op_assign
id|bcd2uint
c_func
(paren
id|buf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|info-&gt;msf_leadout.minute
op_assign
id|buf
(braket
l_int|3
)braket
suffix:semicolon
id|info-&gt;msf_leadout.second
op_assign
id|buf
(braket
l_int|4
)braket
suffix:semicolon
id|info-&gt;msf_leadout.frame
op_assign
id|buf
(braket
l_int|5
)braket
suffix:semicolon
id|info-&gt;msf_first.minute
op_assign
id|buf
(braket
l_int|6
)braket
suffix:semicolon
id|info-&gt;msf_first.second
op_assign
id|buf
(braket
l_int|7
)braket
suffix:semicolon
id|info-&gt;msf_first.frame
op_assign
id|buf
(braket
l_int|8
)braket
suffix:semicolon
r_return
id|ans
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_setdrivemode
id|mcdx_setdrivemode
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_enum
id|drivemodes
id|mode
comma
r_int
id|tries
)paren
(brace
r_char
id|cmd
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|ans
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|HW
comma
l_string|&quot;setdrivemode() %d&bslash;n&quot;
comma
id|mode
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
id|ans
op_assign
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;xc2&quot;
comma
l_int|1
comma
id|cmd
comma
r_sizeof
(paren
id|cmd
)paren
comma
l_int|500
comma
id|tries
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|TOC
suffix:colon
id|cmd
(braket
l_int|1
)braket
op_or_assign
l_int|0x04
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DATA
suffix:colon
id|cmd
(braket
l_int|1
)braket
op_and_assign
op_complement
l_int|0x04
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RAW
suffix:colon
id|cmd
(braket
l_int|1
)braket
op_or_assign
l_int|0x40
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COOKED
suffix:colon
id|cmd
(braket
l_int|1
)braket
op_and_assign
op_complement
l_int|0x40
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|cmd
(braket
l_int|0
)braket
op_assign
l_int|0x50
suffix:semicolon
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
id|cmd
comma
l_int|2
comma
l_int|NULL
comma
l_int|0
comma
l_int|500
comma
id|tries
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_setdatamode
id|mcdx_setdatamode
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_enum
id|datamodes
id|mode
comma
r_int
id|tries
)paren
(brace
r_int
r_char
id|cmd
(braket
l_int|2
)braket
op_assign
(brace
l_int|0xa0
)brace
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|HW
comma
l_string|&quot;setdatamode() %d&bslash;n&quot;
comma
id|mode
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|MODE0
suffix:colon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODE1
suffix:colon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODE2
suffix:colon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|0x02
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
id|cmd
comma
l_int|2
comma
l_int|NULL
comma
l_int|0
comma
l_int|500
comma
id|tries
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_config
id|mcdx_config
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_int
id|tries
)paren
(brace
r_char
id|cmd
(braket
l_int|4
)braket
suffix:semicolon
id|TRACE
c_func
(paren
(paren
id|HW
comma
l_string|&quot;config()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
l_int|0x90
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* irq enable */
id|cmd
(braket
l_int|2
)braket
op_assign
l_int|0x05
suffix:semicolon
multiline_comment|/* pre, err irq enable */
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_talk
c_func
(paren
id|stuffp
comma
id|cmd
comma
l_int|3
comma
l_int|NULL
comma
l_int|0
comma
l_int|100
comma
id|tries
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* dma select */
id|cmd
(braket
l_int|2
)braket
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* no dma */
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
id|cmd
comma
l_int|3
comma
l_int|NULL
comma
l_int|0
comma
l_int|100
comma
id|tries
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_requestversion
id|mcdx_requestversion
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_struct
id|s_version
op_star
id|ver
comma
r_int
id|tries
)paren
(brace
r_char
id|buf
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|ans
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
id|ans
op_assign
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;xdc&quot;
comma
l_int|1
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_int|200
comma
id|tries
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|ver-&gt;code
op_assign
id|buf
(braket
l_int|1
)braket
suffix:semicolon
id|ver-&gt;ver
op_assign
id|buf
(braket
l_int|2
)braket
suffix:semicolon
r_return
id|ans
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_reset
id|mcdx_reset
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_enum
id|resetmodes
id|mode
comma
r_int
id|tries
)paren
(brace
r_if
c_cond
(paren
id|mode
op_eq
id|HARD
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_chn
)paren
suffix:semicolon
multiline_comment|/* no dma, no irq -&gt; hardware */
id|outb
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_reset
)paren
suffix:semicolon
multiline_comment|/* hw reset */
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;x60&quot;
comma
l_int|1
comma
l_int|NULL
comma
l_int|0
comma
l_int|500
comma
id|tries
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_lockdoor
id|mcdx_lockdoor
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_int
id|lock
comma
r_int
id|tries
)paren
(brace
r_char
id|cmd
(braket
l_int|2
)braket
op_assign
(brace
l_int|0xfe
)brace
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;present
op_amp
id|DOOR
)paren
(brace
id|cmd
(braket
l_int|1
)braket
op_assign
id|lock
ques
c_cond
l_int|0x01
suffix:colon
l_int|0x00
suffix:semicolon
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
id|cmd
comma
r_sizeof
(paren
id|cmd
)paren
comma
l_int|NULL
comma
l_int|0
comma
l_int|500
comma
id|tries
)paren
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 0
r_static
r_int
id|mcdx_getstatus
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_int
id|tries
)paren
(brace
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;x40&quot;
comma
l_int|1
comma
l_int|NULL
comma
l_int|0
comma
l_int|500
comma
id|tries
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
