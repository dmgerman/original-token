multiline_comment|/*&n; *  linux/amiga/amiflop.c&n; *&n; *  Copyright (C) 1993  Greg Harp&n; *  Portions of this driver are based on code contributed by Brad Pepers&n; *  &n; *  revised 28.5.95 by Joerg Dorchain&n; *  - now no bugs(?) any more for both HD &amp; DD&n; *  - added support for 40 Track 5.25&quot; drives, 80-track hopefully behaves&n; *    like 3.5&quot; dd (no way to test - are there any 5.25&quot; drives out there&n; *    that work on an A4000?)&n; *  - wrote formatting routine (maybe dirty, but works)&n; *&n; *  june/july 1995 added ms-dos support by Joerg Dorchain&n; *  (portions based on messydos.device and various contributors)&n; *  - currently only 9 and 18 sector disks&n; *&n; *  - fixed a bug with the internal trackbuffer when using multiple &n; *    disks the same time&n; *  - made formatting a bit safer&n; *  - added command line and machine based default for &quot;silent&quot; df0&n; *&n; *  december 1995 adapted for 1.2.13pl4 by Joerg Dorchain&n; *  - works but I think it&squot;s inefficient. (look in redo_fd_request)&n; *    But the changes were very efficient. (only three and a half lines)&n; *&n; *  january 1996 added special ioctl for tracking down read/write problems&n; *  - usage ioctl(d, RAW_TRACK, ptr); the raw track buffer (MFM-encoded data&n; *    is copied to area. (area should be large enough since no checking is&n; *    done - 30K is currently sufficient). return the actual size of the&n; *    trackbuffer&n; *  - replaced udelays() by a timer (CIAA timer B) for the waits &n; *    needed for the disk mechanic.&n; *&n; *  february 1996 fixed error recovery and multiple disk access&n; *  - both got broken the first time I tampered with the driver :-(&n; *  - still not safe, but better than before&n; *&n; *  revised Marts 3rd, 1996 by Jes Sorensen for use in the 1.3.28 kernel.&n; *  - Minor changes to accept the kdev_t.&n; *  - Replaced some more udelays with ms_delays. Udelay is just a loop,&n; *    and so the delay will be different depending on the given&n; *    processor :-(&n; *  - The driver could use a major cleanup because of the new&n; *    major/minor handling that came with kdev_t. It seems to work for&n; *    the time being, but I can&squot;t guarantee that it will stay like&n; *    that when we start using 16 (24?) bit minors.&n; *&n; * restructured jan 1997 by Joerg Dorchain&n; * - Fixed Bug accessing multiple disks&n; * - some code cleanup&n; * - added trackbuffer for each drive to speed things up&n; * - fixed some race conditions (who finds the next may send it to me ;-)&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fd.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/slab.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/amifdreg.h&gt;
macro_line|#include &lt;linux/amifd.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/setup.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/amigahw.h&gt;
macro_line|#include &lt;asm/amigaints.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR FLOPPY_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
DECL|macro|DEBUG
macro_line|#undef DEBUG /* print _LOTS_ of infos */
DECL|macro|RAW_IOCTL
mdefine_line|#define RAW_IOCTL
macro_line|#ifdef RAW_IOCTL
DECL|macro|IOCTL_RAW_TRACK
mdefine_line|#define IOCTL_RAW_TRACK 0x5254524B  /* &squot;RTRK&squot; */
macro_line|#endif
multiline_comment|/*&n; *  Defines&n; */
multiline_comment|/*&n; *  Error codes&n; */
DECL|macro|FD_OK
mdefine_line|#define FD_OK&t;&t;0&t;/* operation succeeded */
DECL|macro|FD_ERROR
mdefine_line|#define FD_ERROR&t;-1&t;/* general error (seek, read, write, etc) */
DECL|macro|FD_NOUNIT
mdefine_line|#define FD_NOUNIT&t;1&t;/* unit does not exist */
DECL|macro|FD_UNITBUSY
mdefine_line|#define FD_UNITBUSY&t;2&t;/* unit already active */
DECL|macro|FD_NOTACTIVE
mdefine_line|#define FD_NOTACTIVE&t;3&t;/* unit is not active */
DECL|macro|FD_NOTREADY
mdefine_line|#define FD_NOTREADY&t;4&t;/* unit is not ready (motor not on/no disk) */
DECL|macro|MFM_NOSYNC
mdefine_line|#define MFM_NOSYNC&t;1
DECL|macro|MFM_HEADER
mdefine_line|#define MFM_HEADER&t;2
DECL|macro|MFM_DATA
mdefine_line|#define MFM_DATA&t;3
DECL|macro|MFM_TRACK
mdefine_line|#define MFM_TRACK&t;4
multiline_comment|/*&n; *  Floppy ID values&n; */
DECL|macro|FD_NODRIVE
mdefine_line|#define FD_NODRIVE&t;0x00000000  /* response when no unit is present */
DECL|macro|FD_DD_3
mdefine_line|#define FD_DD_3 &t;0xffffffff  /* double-density 3.5&quot; (880K) drive */
DECL|macro|FD_HD_3
mdefine_line|#define FD_HD_3 &t;0x55555555  /* high-density 3.5&quot; (1760K) drive */
DECL|macro|FD_DD_5
mdefine_line|#define FD_DD_5 &t;0xaaaaaaaa  /* double-density 5.25&quot; (440K) drive */
DECL|variable|fd_def_df0
r_static
r_int
r_int
id|fd_def_df0
op_assign
id|FD_DD_3
suffix:semicolon
multiline_comment|/* default for df0 if it doesn&squot;t identify */
id|MODULE_PARM
c_func
(paren
id|fd_def_df0
comma
l_string|&quot;l&quot;
)paren
suffix:semicolon
multiline_comment|/*&n; *  Macros&n; */
DECL|macro|MOTOR_ON
mdefine_line|#define MOTOR_ON&t;(ciab.prb &amp;= ~DSKMOTOR)
DECL|macro|MOTOR_OFF
mdefine_line|#define MOTOR_OFF&t;(ciab.prb |= DSKMOTOR)
DECL|macro|SELECT
mdefine_line|#define SELECT(mask)    (ciab.prb &amp;= ~mask)
DECL|macro|DESELECT
mdefine_line|#define DESELECT(mask)  (ciab.prb |= mask)
DECL|macro|SELMASK
mdefine_line|#define SELMASK(drive)  (1 &lt;&lt; (3 + (drive &amp; 3)))
DECL|variable|drive_types
r_static
r_struct
id|fd_drive_type
id|drive_types
(braket
)braket
op_assign
(brace
multiline_comment|/*  code&t;name&t;   tr he   rdsz   wrsz sm pc1 pc2 sd  st st*/
multiline_comment|/*  warning: times are now in milliseconds (ms)                    */
(brace
id|FD_DD_3
comma
l_string|&quot;DD 3.5&quot;
comma
l_int|80
comma
l_int|2
comma
l_int|14716
comma
l_int|13630
comma
l_int|1
comma
l_int|80
comma
l_int|161
comma
l_int|3
comma
l_int|18
comma
l_int|1
)brace
comma
(brace
id|FD_HD_3
comma
l_string|&quot;HD 3.5&quot;
comma
l_int|80
comma
l_int|2
comma
l_int|28344
comma
l_int|27258
comma
l_int|2
comma
l_int|80
comma
l_int|161
comma
l_int|3
comma
l_int|18
comma
l_int|1
)brace
comma
(brace
id|FD_DD_5
comma
l_string|&quot;DD 5.25&quot;
comma
l_int|40
comma
l_int|2
comma
l_int|14716
comma
l_int|13630
comma
l_int|1
comma
l_int|40
comma
l_int|81
comma
l_int|6
comma
l_int|30
comma
l_int|2
)brace
comma
(brace
id|FD_NODRIVE
comma
l_string|&quot;No Drive&quot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|num_dr_types
r_static
r_int
id|num_dr_types
op_assign
r_sizeof
(paren
id|drive_types
)paren
op_div
r_sizeof
(paren
id|drive_types
(braket
l_int|0
)braket
)paren
suffix:semicolon
multiline_comment|/* defaults for 3 1/2&quot; HD-Disks */
DECL|variable|floppy_sizes
r_static
r_int
id|floppy_sizes
(braket
l_int|256
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|floppy_blocksizes
r_static
r_int
id|floppy_blocksizes
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* hardsector size assumed to be 512 */
r_static
r_int
id|amiga_read
c_func
(paren
r_int
)paren
comma
id|dos_read
c_func
(paren
r_int
)paren
suffix:semicolon
r_static
r_void
id|amiga_write
c_func
(paren
r_int
)paren
comma
id|dos_write
c_func
(paren
r_int
)paren
suffix:semicolon
DECL|variable|data_types
r_static
r_struct
id|fd_data_type
id|data_types
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;Amiga&quot;
comma
l_int|11
comma
id|amiga_read
comma
id|amiga_write
)brace
comma
(brace
l_string|&quot;MS-Dos&quot;
comma
l_int|9
comma
id|dos_read
comma
id|dos_write
)brace
)brace
suffix:semicolon
multiline_comment|/* current info on each unit */
DECL|variable|unit
r_static
r_struct
id|amiga_floppy_struct
id|unit
(braket
id|FD_MAX_UNITS
)braket
suffix:semicolon
DECL|variable|flush_track_timer
r_static
r_struct
id|timer_list
id|flush_track_timer
(braket
id|FD_MAX_UNITS
)braket
suffix:semicolon
DECL|variable|post_write_timer
r_static
r_struct
id|timer_list
id|post_write_timer
suffix:semicolon
DECL|variable|motor_on_timer
r_static
r_struct
id|timer_list
id|motor_on_timer
suffix:semicolon
DECL|variable|motor_off_timer
r_static
r_struct
id|timer_list
id|motor_off_timer
(braket
id|FD_MAX_UNITS
)braket
suffix:semicolon
DECL|variable|on_attempts
r_static
r_int
id|on_attempts
suffix:semicolon
multiline_comment|/* Synchronization of FDC access */
multiline_comment|/* request loop (trackbuffer) */
DECL|variable|fdc_busy
r_static
r_volatile
r_int
id|fdc_busy
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|fdc_nested
r_static
r_volatile
r_int
id|fdc_nested
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|fdc_wait
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|motor_wait
)paren
suffix:semicolon
DECL|variable|selected
r_static
r_volatile
r_int
id|selected
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* currently selected drive */
DECL|variable|writepending
r_static
r_int
id|writepending
suffix:semicolon
DECL|variable|writefromint
r_static
r_int
id|writefromint
suffix:semicolon
DECL|variable|raw_buf
r_static
r_char
op_star
id|raw_buf
suffix:semicolon
DECL|macro|RAW_BUF_SIZE
mdefine_line|#define RAW_BUF_SIZE 30000  /* size of raw disk data */
multiline_comment|/*&n; * These are global variables, as that&squot;s the easiest way to give&n; * information to interrupts. They are the data used for the current&n; * request.&n; */
DECL|variable|block_flag
r_static
r_volatile
r_char
id|block_flag
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|wait_fd_block
)paren
suffix:semicolon
multiline_comment|/* MS-Dos MFM Coding tables (should go quick and easy) */
DECL|variable|mfmencode
r_static
r_int
r_char
id|mfmencode
(braket
l_int|16
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|mfmdecode
r_static
r_int
r_char
id|mfmdecode
(braket
l_int|128
)braket
suffix:semicolon
multiline_comment|/* floppy internal millisecond timer stuff */
DECL|variable|ms_busy
r_static
r_volatile
r_int
id|ms_busy
op_assign
op_minus
l_int|1
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|ms_wait
)paren
suffix:semicolon
DECL|macro|MS_TICKS
mdefine_line|#define MS_TICKS ((amiga_eclock+50)/1000)
multiline_comment|/*&n; * Note that MAX_ERRORS=X doesn&squot;t imply that we retry every bad read&n; * max X times - some types of errors increase the errorcount by 2 or&n; * even 3, so we might actually retry only X/2 times before giving up.&n; */
DECL|macro|MAX_ERRORS
mdefine_line|#define MAX_ERRORS 12
multiline_comment|/* Prevent &quot;aliased&quot; accesses. */
DECL|variable|fd_ref
r_static
r_int
id|fd_ref
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|fd_device
r_static
r_int
id|fd_device
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * Current device number. Taken either from the block header or from the&n; * format request descriptor.&n; */
DECL|macro|CURRENT_DEVICE
mdefine_line|#define CURRENT_DEVICE (CURRENT-&gt;rq_dev)
multiline_comment|/* Current error count. */
DECL|macro|CURRENT_ERRORS
mdefine_line|#define CURRENT_ERRORS (CURRENT-&gt;errors)
multiline_comment|/*&n; * Here come the actual hardware access and helper functions.&n; * They are not reentrant and single threaded because all drives&n; * share the same hardware and the same trackbuffer.&n; */
multiline_comment|/* Milliseconds timer */
DECL|function|ms_isr
r_static
r_void
id|ms_isr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dummy
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
id|ms_busy
op_assign
op_minus
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|ms_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* all waits are queued up &n;   A more generic routine would do a schedule a la timer.device */
DECL|function|ms_delay
r_static
r_void
id|ms_delay
c_func
(paren
r_int
id|ms
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
id|ticks
suffix:semicolon
r_if
c_cond
(paren
id|ms
OG
l_int|0
)paren
(brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|ms_busy
op_eq
l_int|0
)paren
id|sleep_on
c_func
(paren
op_amp
id|ms_wait
)paren
suffix:semicolon
id|ms_busy
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ticks
op_assign
id|MS_TICKS
op_star
id|ms
op_minus
l_int|1
suffix:semicolon
id|ciaa.tblo
op_assign
id|ticks
op_mod
l_int|256
suffix:semicolon
id|ciaa.tbhi
op_assign
id|ticks
op_div
l_int|256
suffix:semicolon
id|ciaa.crb
op_assign
l_int|0x19
suffix:semicolon
multiline_comment|/*count eclock, force load, one-shoot, start */
id|sleep_on
c_func
(paren
op_amp
id|ms_wait
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Hardware semaphore */
multiline_comment|/* returns true when we would get the semaphore */
DECL|function|try_fdc
r_static
r_inline
r_int
id|try_fdc
c_func
(paren
r_int
id|drive
)paren
(brace
id|drive
op_and_assign
l_int|3
suffix:semicolon
r_return
(paren
(paren
id|fdc_busy
OL
l_int|0
)paren
op_logical_or
(paren
id|fdc_busy
op_eq
id|drive
)paren
)paren
suffix:semicolon
)brace
DECL|function|get_fdc
r_static
r_void
id|get_fdc
c_func
(paren
r_int
id|drive
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|drive
op_and_assign
l_int|3
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;get_fdc: drive %d  fdc_busy %d  fdc_nested %d&bslash;n&quot;
comma
id|drive
comma
id|fdc_busy
comma
id|fdc_nested
)paren
suffix:semicolon
macro_line|#endif
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|try_fdc
c_func
(paren
id|drive
)paren
)paren
id|sleep_on
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
id|fdc_busy
op_assign
id|drive
suffix:semicolon
id|fdc_nested
op_increment
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|rel_fdc
r_static
r_inline
r_void
id|rel_fdc
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|fdc_nested
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;fd: unmatched rel_fdc&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rel_fdc: fdc_busy %d fdc_nested %d&bslash;n&quot;
comma
id|fdc_busy
comma
id|fdc_nested
)paren
suffix:semicolon
macro_line|#endif
id|fdc_nested
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|fdc_nested
op_eq
l_int|0
)paren
(brace
id|fdc_busy
op_assign
op_minus
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
)brace
)brace
DECL|function|fd_select
r_static
r_void
id|fd_select
(paren
r_int
id|drive
)paren
(brace
r_int
r_char
id|prb
op_assign
op_complement
l_int|0
suffix:semicolon
id|drive
op_and_assign
l_int|3
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;selecting %d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|drive
op_eq
id|selected
)paren
r_return
suffix:semicolon
id|get_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
id|selected
op_assign
id|drive
suffix:semicolon
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|track
op_mod
l_int|2
op_ne
l_int|0
)paren
id|prb
op_and_assign
op_complement
id|DSKSIDE
suffix:semicolon
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|motor
op_eq
l_int|1
)paren
id|prb
op_and_assign
op_complement
id|DSKMOTOR
suffix:semicolon
id|ciab.prb
op_or_assign
(paren
id|SELMASK
c_func
(paren
l_int|0
)paren
op_or
id|SELMASK
c_func
(paren
l_int|1
)paren
op_or
id|SELMASK
c_func
(paren
l_int|2
)paren
op_or
id|SELMASK
c_func
(paren
l_int|3
)paren
)paren
suffix:semicolon
id|ciab.prb
op_assign
id|prb
suffix:semicolon
id|prb
op_and_assign
op_complement
id|SELMASK
c_func
(paren
id|drive
)paren
suffix:semicolon
id|ciab.prb
op_assign
id|prb
suffix:semicolon
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fd_deselect
r_static
r_void
id|fd_deselect
(paren
r_int
id|drive
)paren
(brace
r_int
r_char
id|prb
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|drive
op_and_assign
l_int|3
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;deselecting %d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|drive
op_ne
id|selected
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Deselecting drive %d while %d was selected!&bslash;n&quot;
comma
id|drive
comma
id|selected
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|get_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|selected
op_assign
op_minus
l_int|1
suffix:semicolon
id|prb
op_assign
id|ciab.prb
suffix:semicolon
id|prb
op_or_assign
(paren
id|SELMASK
c_func
(paren
l_int|0
)paren
op_or
id|SELMASK
c_func
(paren
l_int|1
)paren
op_or
id|SELMASK
c_func
(paren
l_int|2
)paren
op_or
id|SELMASK
c_func
(paren
l_int|3
)paren
)paren
suffix:semicolon
id|ciab.prb
op_assign
id|prb
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|motor_on_callback
r_static
r_void
id|motor_on_callback
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ciaa.pra
op_amp
id|DSKRDY
)paren
op_logical_or
op_decrement
id|on_attempts
op_eq
l_int|0
)paren
(brace
id|wake_up
(paren
op_amp
id|motor_wait
)paren
suffix:semicolon
)brace
r_else
(brace
id|motor_on_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|10
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|motor_on_timer
)paren
suffix:semicolon
)brace
)brace
DECL|function|fd_motor_on
r_static
r_int
id|fd_motor_on
c_func
(paren
r_int
id|nr
)paren
(brace
id|nr
op_and_assign
l_int|3
suffix:semicolon
id|del_timer
c_func
(paren
id|motor_off_timer
op_plus
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|unit
(braket
id|nr
)braket
dot
id|motor
)paren
(brace
id|unit
(braket
id|nr
)braket
dot
id|motor
op_assign
l_int|1
suffix:semicolon
id|fd_select
c_func
(paren
id|nr
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|motor_on_timer
)paren
suffix:semicolon
id|motor_on_timer.data
op_assign
id|nr
suffix:semicolon
id|motor_on_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|2
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|motor_on_timer
)paren
suffix:semicolon
id|on_attempts
op_assign
l_int|10
suffix:semicolon
id|sleep_on
(paren
op_amp
id|motor_wait
)paren
suffix:semicolon
id|fd_deselect
c_func
(paren
id|nr
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|on_attempts
op_eq
l_int|0
)paren
(brace
id|on_attempts
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#if 0
id|printk
(paren
id|KERN_ERR
l_string|&quot;motor_on failed, turning motor off&bslash;n&quot;
)paren
suffix:semicolon
id|fd_motor_off
(paren
id|nr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
macro_line|#else
id|printk
(paren
id|KERN_WARNING
l_string|&quot;DSKRDY not set after 1.5 seconds - assuming drive is spinning notwithstanding&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fd_motor_off
r_static
r_void
id|fd_motor_off
c_func
(paren
r_int
r_int
id|drive
)paren
(brace
r_int
id|calledfromint
suffix:semicolon
macro_line|#ifdef MODULE
r_int
id|decusecount
suffix:semicolon
id|decusecount
op_assign
id|drive
op_amp
l_int|0x40000000
suffix:semicolon
macro_line|#endif
id|calledfromint
op_assign
id|drive
op_amp
l_int|0x80000000
suffix:semicolon
id|drive
op_and_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|calledfromint
op_logical_and
op_logical_neg
id|try_fdc
c_func
(paren
id|drive
)paren
)paren
(brace
multiline_comment|/* We would be blocked in an interrupt, so try again later */
id|motor_off_timer
(braket
id|drive
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|add_timer
c_func
(paren
id|motor_off_timer
op_plus
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|unit
(braket
id|drive
)braket
dot
id|motor
op_assign
l_int|0
suffix:semicolon
id|fd_select
c_func
(paren
id|drive
)paren
suffix:semicolon
id|udelay
(paren
l_int|1
)paren
suffix:semicolon
id|fd_deselect
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#ifdef MODULE
multiline_comment|/*&n;  this is the last interrupt for any drive access, happens after&n;  release (from floppy_off). So we have to wait until now to decrease&n;  the use count.&n;*/
r_if
c_cond
(paren
id|decusecount
)paren
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
)brace
DECL|function|floppy_off
r_static
r_void
id|floppy_off
(paren
r_int
r_int
id|nr
)paren
(brace
r_int
id|drive
suffix:semicolon
id|drive
op_assign
id|nr
op_amp
l_int|3
suffix:semicolon
id|del_timer
c_func
(paren
id|motor_off_timer
op_plus
id|drive
)paren
suffix:semicolon
id|motor_off_timer
(braket
id|drive
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
l_int|3
op_star
id|HZ
suffix:semicolon
multiline_comment|/* called this way it is always from interrupt */
id|motor_off_timer
(braket
id|drive
)braket
dot
id|data
op_assign
id|nr
op_or
l_int|0x80000000
suffix:semicolon
id|add_timer
c_func
(paren
id|motor_off_timer
op_plus
id|nr
)paren
suffix:semicolon
)brace
DECL|function|fd_calibrate
r_static
r_int
id|fd_calibrate
c_func
(paren
r_int
id|drive
)paren
(brace
r_int
r_char
id|prb
suffix:semicolon
r_int
id|n
suffix:semicolon
id|drive
op_and_assign
l_int|3
suffix:semicolon
id|get_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd_motor_on
(paren
id|drive
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|fd_select
(paren
id|drive
)paren
suffix:semicolon
id|prb
op_assign
id|ciab.prb
suffix:semicolon
id|prb
op_or_assign
id|DSKSIDE
suffix:semicolon
id|prb
op_and_assign
op_complement
id|DSKDIREC
suffix:semicolon
id|ciab.prb
op_assign
id|prb
suffix:semicolon
r_for
c_loop
(paren
id|n
op_assign
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;tracks
op_div
l_int|2
suffix:semicolon
id|n
op_ne
l_int|0
suffix:semicolon
op_decrement
id|n
)paren
(brace
r_if
c_cond
(paren
id|ciaa.pra
op_amp
id|DSKTRACK0
)paren
r_break
suffix:semicolon
id|prb
op_and_assign
op_complement
id|DSKSTEP
suffix:semicolon
id|ciab.prb
op_assign
id|prb
suffix:semicolon
id|prb
op_or_assign
id|DSKSTEP
suffix:semicolon
id|udelay
(paren
l_int|2
)paren
suffix:semicolon
id|ciab.prb
op_assign
id|prb
suffix:semicolon
id|ms_delay
c_func
(paren
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;step_delay
)paren
suffix:semicolon
)brace
id|ms_delay
(paren
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;settle_time
)paren
suffix:semicolon
id|prb
op_or_assign
id|DSKDIREC
suffix:semicolon
id|n
op_assign
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;tracks
op_plus
l_int|20
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|prb
op_and_assign
op_complement
id|DSKSTEP
suffix:semicolon
id|ciab.prb
op_assign
id|prb
suffix:semicolon
id|prb
op_or_assign
id|DSKSTEP
suffix:semicolon
id|udelay
(paren
l_int|2
)paren
suffix:semicolon
id|ciab.prb
op_assign
id|prb
suffix:semicolon
id|ms_delay
c_func
(paren
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;step_delay
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ciaa.pra
op_amp
id|DSKTRACK0
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|n
op_eq
l_int|0
)paren
(brace
id|printk
(paren
id|KERN_ERR
l_string|&quot;fd%d: calibrate failed, turning motor off&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
id|fd_motor_off
(paren
id|drive
)paren
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|track
op_assign
op_minus
l_int|1
suffix:semicolon
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
id|unit
(braket
id|drive
)braket
dot
id|track
op_assign
l_int|0
suffix:semicolon
id|ms_delay
c_func
(paren
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;settle_time
)paren
suffix:semicolon
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
id|fd_deselect
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fd_seek
r_static
r_int
id|fd_seek
c_func
(paren
r_int
id|drive
comma
r_int
id|track
)paren
(brace
r_int
r_char
id|prb
suffix:semicolon
r_int
id|cnt
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;seeking drive %d to track %d&bslash;n&quot;
comma
id|drive
comma
id|track
)paren
suffix:semicolon
macro_line|#endif
id|drive
op_and_assign
l_int|3
suffix:semicolon
id|get_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|track
op_eq
id|track
)paren
(brace
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|fd_motor_on
c_func
(paren
id|drive
)paren
)paren
(brace
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|track
OL
l_int|0
op_logical_and
op_logical_neg
id|fd_calibrate
c_func
(paren
id|drive
)paren
)paren
(brace
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|fd_select
(paren
id|drive
)paren
suffix:semicolon
id|cnt
op_assign
id|unit
(braket
id|drive
)braket
dot
id|track
op_div
l_int|2
op_minus
id|track
op_div
l_int|2
suffix:semicolon
id|prb
op_assign
id|ciab.prb
suffix:semicolon
id|prb
op_or_assign
id|DSKSIDE
op_or
id|DSKDIREC
suffix:semicolon
r_if
c_cond
(paren
id|track
op_mod
l_int|2
op_ne
l_int|0
)paren
id|prb
op_and_assign
op_complement
id|DSKSIDE
suffix:semicolon
r_if
c_cond
(paren
id|cnt
OL
l_int|0
)paren
(brace
id|cnt
op_assign
op_minus
id|cnt
suffix:semicolon
id|prb
op_and_assign
op_complement
id|DSKDIREC
suffix:semicolon
)brace
id|ciab.prb
op_assign
id|prb
suffix:semicolon
r_if
c_cond
(paren
id|track
op_mod
l_int|2
op_ne
id|unit
(braket
id|drive
)braket
dot
id|track
op_mod
l_int|2
)paren
id|ms_delay
(paren
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;side_time
)paren
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|track
op_assign
id|track
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_eq
l_int|0
)paren
(brace
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
id|fd_deselect
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_do
(brace
id|prb
op_and_assign
op_complement
id|DSKSTEP
suffix:semicolon
id|ciab.prb
op_assign
id|prb
suffix:semicolon
id|prb
op_or_assign
id|DSKSTEP
suffix:semicolon
id|udelay
(paren
l_int|1
)paren
suffix:semicolon
id|ciab.prb
op_assign
id|prb
suffix:semicolon
id|ms_delay
(paren
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;step_delay
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|cnt
op_ne
l_int|0
)paren
suffix:semicolon
id|ms_delay
(paren
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;settle_time
)paren
suffix:semicolon
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
id|fd_deselect
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|fd_get_drive_id
r_static
r_int
r_int
id|fd_get_drive_id
c_func
(paren
r_int
id|drive
)paren
(brace
r_int
id|i
suffix:semicolon
id|ulong
id|id
op_assign
l_int|0
suffix:semicolon
id|drive
op_and_assign
l_int|3
suffix:semicolon
id|get_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* set up for ID */
id|MOTOR_ON
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|SELECT
c_func
(paren
id|SELMASK
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|DESELECT
c_func
(paren
id|SELMASK
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|MOTOR_OFF
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|SELECT
c_func
(paren
id|SELMASK
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|DESELECT
c_func
(paren
id|SELMASK
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* loop and read disk ID */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|32
suffix:semicolon
id|i
op_increment
)paren
(brace
id|SELECT
c_func
(paren
id|SELMASK
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* read and store value of DSKRDY */
id|id
op_lshift_assign
l_int|1
suffix:semicolon
id|id
op_or_assign
(paren
id|ciaa.pra
op_amp
id|DSKRDY
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* cia regs are low-active! */
id|DESELECT
c_func
(paren
id|SELMASK
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;         * RB: At least A500/A2000&squot;s df0: don&squot;t identify themselves.&n;         * As every (real) Amiga has at least a 3.5&quot; DD drive as df0:&n;         * we default to that if df0: doesn&squot;t identify as a certain&n;         * type.&n;         */
r_if
c_cond
(paren
id|drive
op_eq
l_int|0
op_logical_and
id|id
op_eq
id|FD_NODRIVE
)paren
(brace
id|id
op_assign
id|fd_def_df0
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;fd: drive 0 didn&squot;t identify, setting default %08lx&bslash;n&quot;
comma
(paren
id|ulong
)paren
id|fd_def_df0
)paren
suffix:semicolon
)brace
multiline_comment|/* return the ID value */
r_return
(paren
id|id
)paren
suffix:semicolon
)brace
DECL|function|fd_block_done
r_static
r_void
id|fd_block_done
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dummy
comma
r_struct
id|pt_regs
op_star
id|fp
)paren
(brace
r_if
c_cond
(paren
id|block_flag
)paren
id|custom.dsklen
op_assign
l_int|0x4000
suffix:semicolon
r_if
c_cond
(paren
id|block_flag
op_eq
l_int|2
)paren
(brace
multiline_comment|/* writing */
id|writepending
op_assign
l_int|2
suffix:semicolon
id|post_write_timer.expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* at least 2 ms */
id|post_write_timer.data
op_assign
id|selected
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|post_write_timer
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* reading */
id|block_flag
op_assign
l_int|0
suffix:semicolon
id|wake_up
(paren
op_amp
id|wait_fd_block
)paren
suffix:semicolon
)brace
)brace
DECL|function|raw_read
r_static
r_void
id|raw_read
c_func
(paren
r_int
id|drive
)paren
(brace
id|drive
op_and_assign
l_int|3
suffix:semicolon
id|get_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_while
c_loop
(paren
id|block_flag
)paren
id|sleep_on
c_func
(paren
op_amp
id|wait_fd_block
)paren
suffix:semicolon
id|fd_select
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* setup adkcon bits correctly */
id|custom.adkcon
op_assign
id|ADK_MSBSYNC
suffix:semicolon
id|custom.adkcon
op_assign
id|ADK_SETCLR
op_or
id|ADK_WORDSYNC
op_or
id|ADK_FAST
suffix:semicolon
id|custom.dsksync
op_assign
id|MFM_SYNC
suffix:semicolon
id|custom.dsklen
op_assign
l_int|0
suffix:semicolon
id|custom.dskptr
op_assign
(paren
id|u_char
op_star
)paren
id|ZTWO_PADDR
c_func
(paren
(paren
id|u_char
op_star
)paren
id|raw_buf
)paren
suffix:semicolon
id|custom.dsklen
op_assign
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;read_size
op_div
r_sizeof
(paren
r_int
)paren
op_or
id|DSKLEN_DMAEN
suffix:semicolon
id|custom.dsklen
op_assign
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;read_size
op_div
r_sizeof
(paren
r_int
)paren
op_or
id|DSKLEN_DMAEN
suffix:semicolon
id|block_flag
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|block_flag
)paren
id|sleep_on
(paren
op_amp
id|wait_fd_block
)paren
suffix:semicolon
id|custom.dsklen
op_assign
l_int|0
suffix:semicolon
id|fd_deselect
c_func
(paren
id|drive
)paren
suffix:semicolon
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|raw_write
r_static
r_int
id|raw_write
c_func
(paren
r_int
id|drive
)paren
(brace
id|ushort
id|adk
suffix:semicolon
id|drive
op_and_assign
l_int|3
suffix:semicolon
id|get_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* corresponds to rel_fdc() in post_write() */
r_if
c_cond
(paren
(paren
id|ciaa.pra
op_amp
id|DSKPROT
)paren
op_eq
l_int|0
)paren
(brace
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|block_flag
)paren
id|sleep_on
c_func
(paren
op_amp
id|wait_fd_block
)paren
suffix:semicolon
id|fd_select
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* clear adkcon bits */
id|custom.adkcon
op_assign
id|ADK_PRECOMP1
op_or
id|ADK_PRECOMP0
op_or
id|ADK_WORDSYNC
op_or
id|ADK_MSBSYNC
suffix:semicolon
multiline_comment|/* set appropriate adkcon bits */
id|adk
op_assign
id|ADK_SETCLR
op_or
id|ADK_FAST
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ulong
)paren
id|unit
(braket
id|drive
)braket
dot
id|track
op_ge
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;precomp2
)paren
id|adk
op_or_assign
id|ADK_PRECOMP1
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|ulong
)paren
id|unit
(braket
id|drive
)braket
dot
id|track
op_ge
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;precomp1
)paren
id|adk
op_or_assign
id|ADK_PRECOMP0
suffix:semicolon
id|custom.adkcon
op_assign
id|adk
suffix:semicolon
id|custom.dsklen
op_assign
id|DSKLEN_WRITE
suffix:semicolon
id|custom.dskptr
op_assign
(paren
id|u_char
op_star
)paren
id|ZTWO_PADDR
c_func
(paren
(paren
id|u_char
op_star
)paren
id|raw_buf
)paren
suffix:semicolon
id|custom.dsklen
op_assign
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;write_size
op_div
r_sizeof
(paren
r_int
)paren
op_or
id|DSKLEN_DMAEN
op_or
id|DSKLEN_WRITE
suffix:semicolon
id|custom.dsklen
op_assign
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;write_size
op_div
r_sizeof
(paren
r_int
)paren
op_or
id|DSKLEN_DMAEN
op_or
id|DSKLEN_WRITE
suffix:semicolon
id|block_flag
op_assign
l_int|2
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * to be called at least 2ms after the write has finished but before any&n; * other access to the hardware.&n; */
DECL|function|post_write
r_static
r_void
id|post_write
(paren
r_int
r_int
id|drive
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;post_write for drive %ld&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif
id|drive
op_and_assign
l_int|3
suffix:semicolon
id|custom.dsklen
op_assign
l_int|0
suffix:semicolon
id|block_flag
op_assign
l_int|0
suffix:semicolon
id|writepending
op_assign
l_int|0
suffix:semicolon
id|writefromint
op_assign
l_int|0
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|dirty
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|wait_fd_block
)paren
suffix:semicolon
id|fd_deselect
c_func
(paren
id|drive
)paren
suffix:semicolon
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* corresponds to get_fdc() in raw_write */
)brace
multiline_comment|/*&n; * The following functions are to convert the block contents into raw data&n; * written to disk and vice versa.&n; * (Add other formats here ;-))&n; */
DECL|function|scan_sync
r_static
r_int
r_int
id|scan_sync
c_func
(paren
r_int
r_int
id|raw
comma
r_int
r_int
id|end
)paren
(brace
id|ushort
op_star
id|ptr
op_assign
(paren
id|ushort
op_star
)paren
id|raw
comma
op_star
id|endp
op_assign
(paren
id|ushort
op_star
)paren
id|end
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|endp
op_logical_and
op_star
id|ptr
op_increment
op_ne
l_int|0x4489
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr
OL
id|endp
)paren
(brace
r_while
c_loop
(paren
op_star
id|ptr
op_eq
l_int|0x4489
op_logical_and
id|ptr
OL
id|endp
)paren
id|ptr
op_increment
suffix:semicolon
r_return
(paren
id|ulong
)paren
id|ptr
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|checksum
r_static
r_inline
r_int
r_int
id|checksum
c_func
(paren
r_int
r_int
op_star
id|addr
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|csum
op_assign
l_int|0
suffix:semicolon
id|len
op_div_assign
r_sizeof
(paren
op_star
id|addr
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
op_decrement
OG
l_int|0
)paren
id|csum
op_xor_assign
op_star
id|addr
op_increment
suffix:semicolon
id|csum
op_assign
(paren
(paren
id|csum
op_rshift
l_int|1
)paren
op_amp
l_int|0x55555555
)paren
op_xor
(paren
id|csum
op_amp
l_int|0x55555555
)paren
suffix:semicolon
r_return
id|csum
suffix:semicolon
)brace
DECL|function|decode
r_static
r_int
r_int
id|decode
(paren
r_int
r_int
op_star
id|data
comma
r_int
r_int
op_star
id|raw
comma
r_int
id|len
)paren
(brace
id|ulong
op_star
id|odd
comma
op_star
id|even
suffix:semicolon
multiline_comment|/* convert length from bytes to longwords */
id|len
op_rshift_assign
l_int|2
suffix:semicolon
id|odd
op_assign
id|raw
suffix:semicolon
id|even
op_assign
id|odd
op_plus
id|len
suffix:semicolon
multiline_comment|/* prepare return pointer */
id|raw
op_add_assign
id|len
op_star
l_int|2
suffix:semicolon
r_do
(brace
op_star
id|data
op_increment
op_assign
(paren
(paren
op_star
id|odd
op_increment
op_amp
l_int|0x55555555
)paren
op_lshift
l_int|1
)paren
op_or
(paren
op_star
id|even
op_increment
op_amp
l_int|0x55555555
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|len
op_ne
l_int|0
)paren
suffix:semicolon
r_return
(paren
id|ulong
)paren
id|raw
suffix:semicolon
)brace
DECL|struct|header
r_struct
id|header
(brace
DECL|member|magic
r_int
r_char
id|magic
suffix:semicolon
DECL|member|track
r_int
r_char
id|track
suffix:semicolon
DECL|member|sect
r_int
r_char
id|sect
suffix:semicolon
DECL|member|ord
r_int
r_char
id|ord
suffix:semicolon
DECL|member|labels
r_int
r_char
id|labels
(braket
l_int|16
)braket
suffix:semicolon
DECL|member|hdrchk
r_int
r_int
id|hdrchk
suffix:semicolon
DECL|member|datachk
r_int
r_int
id|datachk
suffix:semicolon
)brace
suffix:semicolon
DECL|function|amiga_read
r_static
r_int
id|amiga_read
c_func
(paren
r_int
id|drive
)paren
(brace
r_int
r_int
id|raw
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_int
id|scnt
suffix:semicolon
r_int
r_int
id|csum
suffix:semicolon
r_struct
id|header
id|hdr
suffix:semicolon
id|drive
op_and_assign
l_int|3
suffix:semicolon
id|raw
op_assign
(paren
r_int
)paren
id|raw_buf
suffix:semicolon
id|end
op_assign
id|raw
op_plus
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;read_size
suffix:semicolon
r_for
c_loop
(paren
id|scnt
op_assign
l_int|0
suffix:semicolon
id|scnt
OL
id|unit
(braket
id|drive
)braket
dot
id|dtype-&gt;sects
op_star
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;sect_mult
suffix:semicolon
id|scnt
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|raw
op_assign
id|scan_sync
c_func
(paren
id|raw
comma
id|end
)paren
)paren
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;can&squot;t find sync for sector %d&bslash;n&quot;
comma
id|scnt
)paren
suffix:semicolon
r_return
id|MFM_NOSYNC
suffix:semicolon
)brace
id|raw
op_assign
id|decode
(paren
(paren
id|ulong
op_star
)paren
op_amp
id|hdr.magic
comma
(paren
id|ulong
op_star
)paren
id|raw
comma
l_int|4
)paren
suffix:semicolon
id|raw
op_assign
id|decode
(paren
(paren
id|ulong
op_star
)paren
op_amp
id|hdr.labels
comma
(paren
id|ulong
op_star
)paren
id|raw
comma
l_int|16
)paren
suffix:semicolon
id|raw
op_assign
id|decode
(paren
(paren
id|ulong
op_star
)paren
op_amp
id|hdr.hdrchk
comma
(paren
id|ulong
op_star
)paren
id|raw
comma
l_int|4
)paren
suffix:semicolon
id|raw
op_assign
id|decode
(paren
(paren
id|ulong
op_star
)paren
op_amp
id|hdr.datachk
comma
(paren
id|ulong
op_star
)paren
id|raw
comma
l_int|4
)paren
suffix:semicolon
id|csum
op_assign
id|checksum
c_func
(paren
(paren
id|ulong
op_star
)paren
op_amp
id|hdr
comma
(paren
r_char
op_star
)paren
op_amp
id|hdr.hdrchk
op_minus
(paren
r_char
op_star
)paren
op_amp
id|hdr
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
(paren
l_string|&quot;(%x,%d,%d,%d) (%lx,%lx,%lx,%lx) %lx %lx&bslash;n&quot;
comma
id|hdr.magic
comma
id|hdr.track
comma
id|hdr.sect
comma
id|hdr.ord
comma
op_star
(paren
id|ulong
op_star
)paren
op_amp
id|hdr.labels
(braket
l_int|0
)braket
comma
op_star
(paren
id|ulong
op_star
)paren
op_amp
id|hdr.labels
(braket
l_int|4
)braket
comma
op_star
(paren
id|ulong
op_star
)paren
op_amp
id|hdr.labels
(braket
l_int|8
)braket
comma
op_star
(paren
id|ulong
op_star
)paren
op_amp
id|hdr.labels
(braket
l_int|12
)braket
comma
id|hdr.hdrchk
comma
id|hdr.datachk
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hdr.hdrchk
op_ne
id|csum
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;MFM_HEADER: %08lx,%08lx&bslash;n&quot;
comma
id|hdr.hdrchk
comma
id|csum
)paren
suffix:semicolon
r_return
id|MFM_HEADER
suffix:semicolon
)brace
multiline_comment|/* verify track */
r_if
c_cond
(paren
id|hdr.track
op_ne
id|unit
(braket
id|drive
)braket
dot
id|track
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;MFM_TRACK: %d, %d&bslash;n&quot;
comma
id|hdr.track
comma
id|unit
(braket
id|drive
)braket
dot
id|track
)paren
suffix:semicolon
r_return
id|MFM_TRACK
suffix:semicolon
)brace
id|raw
op_assign
id|decode
(paren
(paren
id|ulong
op_star
)paren
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
id|hdr.sect
op_star
l_int|512
)paren
comma
(paren
id|ulong
op_star
)paren
id|raw
comma
l_int|512
)paren
suffix:semicolon
id|csum
op_assign
id|checksum
c_func
(paren
(paren
id|ulong
op_star
)paren
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
id|hdr.sect
op_star
l_int|512
)paren
comma
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hdr.datachk
op_ne
id|csum
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;MFM_DATA: (%x:%d:%d:%d) sc=%d %lx, %lx&bslash;n&quot;
comma
id|hdr.magic
comma
id|hdr.track
comma
id|hdr.sect
comma
id|hdr.ord
comma
id|scnt
comma
id|hdr.datachk
comma
id|csum
)paren
suffix:semicolon
id|printk
(paren
id|KERN_INFO
l_string|&quot;data=(%lx,%lx,%lx,%lx)&bslash;n&quot;
comma
(paren
(paren
id|ulong
op_star
)paren
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
id|hdr.sect
op_star
l_int|512
)paren
)paren
(braket
l_int|0
)braket
comma
(paren
(paren
id|ulong
op_star
)paren
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
id|hdr.sect
op_star
l_int|512
)paren
)paren
(braket
l_int|1
)braket
comma
(paren
(paren
id|ulong
op_star
)paren
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
id|hdr.sect
op_star
l_int|512
)paren
)paren
(braket
l_int|2
)braket
comma
(paren
(paren
id|ulong
op_star
)paren
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
id|hdr.sect
op_star
l_int|512
)paren
)paren
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_return
id|MFM_DATA
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|encode
r_static
r_void
id|encode
c_func
(paren
r_int
r_int
id|data
comma
r_int
r_int
op_star
id|dest
)paren
(brace
r_int
r_int
id|data2
suffix:semicolon
id|data
op_and_assign
l_int|0x55555555
suffix:semicolon
id|data2
op_assign
id|data
op_xor
l_int|0x55555555
suffix:semicolon
id|data
op_or_assign
(paren
(paren
id|data2
op_rshift
l_int|1
)paren
op_or
l_int|0x80000000
)paren
op_amp
(paren
id|data2
op_lshift
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
(paren
id|dest
op_minus
l_int|1
)paren
op_amp
l_int|0x00000001
)paren
id|data
op_and_assign
l_int|0x7FFFFFFF
suffix:semicolon
op_star
id|dest
op_assign
id|data
suffix:semicolon
)brace
DECL|function|encode_block
r_static
r_void
id|encode_block
c_func
(paren
r_int
r_int
op_star
id|dest
comma
r_int
r_int
op_star
id|src
comma
r_int
id|len
)paren
(brace
r_int
id|cnt
comma
id|to_cnt
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|data
suffix:semicolon
multiline_comment|/* odd bits */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|len
op_div
l_int|4
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|data
op_assign
id|src
(braket
id|cnt
)braket
op_rshift
l_int|1
suffix:semicolon
id|encode
c_func
(paren
id|data
comma
id|dest
op_plus
id|to_cnt
op_increment
)paren
suffix:semicolon
)brace
multiline_comment|/* even bits */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|len
op_div
l_int|4
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|data
op_assign
id|src
(braket
id|cnt
)braket
suffix:semicolon
id|encode
c_func
(paren
id|data
comma
id|dest
op_plus
id|to_cnt
op_increment
)paren
suffix:semicolon
)brace
)brace
DECL|function|putsec
r_static
r_int
r_int
op_star
id|putsec
c_func
(paren
r_int
id|disk
comma
r_int
r_int
op_star
id|raw
comma
r_int
id|cnt
)paren
(brace
r_struct
id|header
id|hdr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|disk
op_and_assign
l_int|3
suffix:semicolon
op_star
id|raw
op_assign
(paren
id|raw
(braket
op_minus
l_int|1
)braket
op_amp
l_int|1
)paren
ques
c_cond
l_int|0x2AAAAAAA
suffix:colon
l_int|0xAAAAAAAA
suffix:semicolon
id|raw
op_increment
suffix:semicolon
op_star
id|raw
op_increment
op_assign
l_int|0x44894489
suffix:semicolon
id|hdr.magic
op_assign
l_int|0xFF
suffix:semicolon
id|hdr.track
op_assign
id|unit
(braket
id|disk
)braket
dot
id|track
suffix:semicolon
id|hdr.sect
op_assign
id|cnt
suffix:semicolon
id|hdr.ord
op_assign
id|unit
(braket
id|disk
)braket
dot
id|dtype-&gt;sects
op_star
id|unit
(braket
id|disk
)braket
dot
id|type-&gt;sect_mult
op_minus
id|cnt
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|hdr.labels
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|hdr.hdrchk
op_assign
id|checksum
c_func
(paren
(paren
id|ulong
op_star
)paren
op_amp
id|hdr
comma
(paren
r_char
op_star
)paren
op_amp
id|hdr.hdrchk
op_minus
(paren
r_char
op_star
)paren
op_amp
id|hdr
)paren
suffix:semicolon
id|hdr.datachk
op_assign
id|checksum
c_func
(paren
(paren
id|ulong
op_star
)paren
(paren
id|unit
(braket
id|disk
)braket
dot
id|trackbuf
op_plus
id|cnt
op_star
l_int|512
)paren
comma
l_int|512
)paren
suffix:semicolon
id|encode_block
c_func
(paren
id|raw
comma
(paren
id|ulong
op_star
)paren
op_amp
id|hdr.magic
comma
l_int|4
)paren
suffix:semicolon
id|raw
op_add_assign
l_int|2
suffix:semicolon
id|encode_block
c_func
(paren
id|raw
comma
(paren
id|ulong
op_star
)paren
op_amp
id|hdr.labels
comma
l_int|16
)paren
suffix:semicolon
id|raw
op_add_assign
l_int|8
suffix:semicolon
id|encode_block
c_func
(paren
id|raw
comma
(paren
id|ulong
op_star
)paren
op_amp
id|hdr.hdrchk
comma
l_int|4
)paren
suffix:semicolon
id|raw
op_add_assign
l_int|2
suffix:semicolon
id|encode_block
c_func
(paren
id|raw
comma
(paren
id|ulong
op_star
)paren
op_amp
id|hdr.datachk
comma
l_int|4
)paren
suffix:semicolon
id|raw
op_add_assign
l_int|2
suffix:semicolon
id|encode_block
c_func
(paren
id|raw
comma
(paren
id|ulong
op_star
)paren
(paren
id|unit
(braket
id|disk
)braket
dot
id|trackbuf
op_plus
id|cnt
op_star
l_int|512
)paren
comma
l_int|512
)paren
suffix:semicolon
id|raw
op_add_assign
l_int|256
suffix:semicolon
r_return
id|raw
suffix:semicolon
)brace
DECL|function|amiga_write
r_static
r_void
id|amiga_write
c_func
(paren
r_int
id|disk
)paren
(brace
r_int
r_int
id|cnt
suffix:semicolon
r_int
r_int
op_star
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|raw_buf
suffix:semicolon
id|disk
op_and_assign
l_int|3
suffix:semicolon
multiline_comment|/* gap space */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
l_int|415
op_star
id|unit
(braket
id|disk
)braket
dot
id|type-&gt;sect_mult
suffix:semicolon
id|cnt
op_increment
)paren
op_star
id|ptr
op_increment
op_assign
l_int|0xaaaaaaaa
suffix:semicolon
multiline_comment|/* sectors */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|unit
(braket
id|disk
)braket
dot
id|dtype-&gt;sects
op_star
id|unit
(braket
id|disk
)braket
dot
id|type-&gt;sect_mult
suffix:semicolon
id|cnt
op_increment
)paren
id|ptr
op_assign
id|putsec
(paren
id|disk
comma
id|ptr
comma
id|cnt
)paren
suffix:semicolon
op_star
(paren
id|ushort
op_star
)paren
id|ptr
op_assign
(paren
id|ptr
(braket
op_minus
l_int|1
)braket
op_amp
l_int|1
)paren
ques
c_cond
l_int|0x2AA8
suffix:colon
l_int|0xAAA8
suffix:semicolon
)brace
DECL|struct|dos_header
r_struct
id|dos_header
(brace
DECL|member|track
r_int
r_char
id|track
comma
multiline_comment|/* 0-80 */
DECL|member|side
id|side
comma
multiline_comment|/* 0-1 */
DECL|member|sec
id|sec
comma
multiline_comment|/* 0-...*/
DECL|member|len_desc
id|len_desc
suffix:semicolon
multiline_comment|/* 2 */
DECL|member|crc
r_int
r_int
id|crc
suffix:semicolon
multiline_comment|/* on 68000 we got an alignment problem, &n;&t;&t;&t;&t;   but this compiler solves it  by adding silently &n;&t;&t;&t;&t;   adding a pad byte so data won&squot;t fit&n;&t;&t;&t;&t;   and this took about 3h to discover.... */
DECL|member|gap1
r_int
r_char
id|gap1
(braket
l_int|22
)braket
suffix:semicolon
multiline_comment|/* for longword-alignedness (0x4e) */
)brace
suffix:semicolon
multiline_comment|/* crc routines are borrowed from the messydos-handler  */
multiline_comment|/* excerpt from the messydos-device           &n;; The CRC is computed not only over the actual data, but including&n;; the SYNC mark (3 * $a1) and the &squot;ID/DATA - Address Mark&squot; ($fe/$fb).&n;; As we don&squot;t read or encode these fields into our buffers, we have to&n;; preload the registers containing the CRC with the values they would have&n;; after stepping over these fields.&n;;&n;; How CRCs &quot;really&quot; work:&n;;&n;; First, you should regard a bitstring as a series of coefficients of&n;; polynomials. We calculate with these polynomials in modulo-2&n;; arithmetic, in which both add and subtract are done the same as&n;; exclusive-or. Now, we modify our data (a very long polynomial) in&n;; such a way that it becomes divisible by the CCITT-standard 16-bit&n;;&t;&t; 16   12   5&n;; polynomial:&t;x  + x&t;+ x + 1, represented by $11021. The easiest&n;; way to do this would be to multiply (using proper arithmetic) our&n;; datablock with $11021. So we have:&n;;   data * $11021&t;&t; =&n;;   data * ($10000 + $1021)      =&n;;   data * $10000 + data * $1021&n;; The left part of this is simple: Just add two 0 bytes. But then&n;; the right part (data $1021) remains difficult and even could have&n;; a carry into the left part. The solution is to use a modified&n;; multiplication, which has a result that is not correct, but with&n;; a difference of any multiple of $11021. We then only need to keep&n;; the 16 least significant bits of the result.&n;;&n;; The following algorithm does this for us:&n;;&n;;   unsigned char *data, c, crclo, crchi;&n;;   while (not done) {&n;;&t;c = *data++ + crchi;&n;;&t;crchi = (@ c) &gt;&gt; 8 + crclo;&n;;&t;crclo = @ c;&n;;   }&n;;&n;; Remember, + is done with EOR, the @ operator is in two tables (high&n;; and low byte separately), which is calculated as&n;;&n;;      $1021 * (c &amp; $F0)&n;;  xor $1021 * (c &amp; $0F)&n;;  xor $1021 * (c &gt;&gt; 4)         (* is regular multiplication)&n;;&n;;&n;; Anyway, the end result is the same as the remainder of the division of&n;; the data by $11021. I am afraid I need to study theory a bit more...&n;&n;&n;my only works was to code this from manx to C....&n;&n;*/
DECL|function|dos_crc
r_static
id|ushort
id|dos_crc
c_func
(paren
r_void
op_star
id|data_a3
comma
r_int
id|data_d0
comma
r_int
id|data_d1
comma
r_int
id|data_d3
)paren
(brace
r_static
r_int
r_char
id|CRCTable1
(braket
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x10
comma
l_int|0x20
comma
l_int|0x30
comma
l_int|0x40
comma
l_int|0x50
comma
l_int|0x60
comma
l_int|0x70
comma
l_int|0x81
comma
l_int|0x91
comma
l_int|0xa1
comma
l_int|0xb1
comma
l_int|0xc1
comma
l_int|0xd1
comma
l_int|0xe1
comma
l_int|0xf1
comma
l_int|0x12
comma
l_int|0x02
comma
l_int|0x32
comma
l_int|0x22
comma
l_int|0x52
comma
l_int|0x42
comma
l_int|0x72
comma
l_int|0x62
comma
l_int|0x93
comma
l_int|0x83
comma
l_int|0xb3
comma
l_int|0xa3
comma
l_int|0xd3
comma
l_int|0xc3
comma
l_int|0xf3
comma
l_int|0xe3
comma
l_int|0x24
comma
l_int|0x34
comma
l_int|0x04
comma
l_int|0x14
comma
l_int|0x64
comma
l_int|0x74
comma
l_int|0x44
comma
l_int|0x54
comma
l_int|0xa5
comma
l_int|0xb5
comma
l_int|0x85
comma
l_int|0x95
comma
l_int|0xe5
comma
l_int|0xf5
comma
l_int|0xc5
comma
l_int|0xd5
comma
l_int|0x36
comma
l_int|0x26
comma
l_int|0x16
comma
l_int|0x06
comma
l_int|0x76
comma
l_int|0x66
comma
l_int|0x56
comma
l_int|0x46
comma
l_int|0xb7
comma
l_int|0xa7
comma
l_int|0x97
comma
l_int|0x87
comma
l_int|0xf7
comma
l_int|0xe7
comma
l_int|0xd7
comma
l_int|0xc7
comma
l_int|0x48
comma
l_int|0x58
comma
l_int|0x68
comma
l_int|0x78
comma
l_int|0x08
comma
l_int|0x18
comma
l_int|0x28
comma
l_int|0x38
comma
l_int|0xc9
comma
l_int|0xd9
comma
l_int|0xe9
comma
l_int|0xf9
comma
l_int|0x89
comma
l_int|0x99
comma
l_int|0xa9
comma
l_int|0xb9
comma
l_int|0x5a
comma
l_int|0x4a
comma
l_int|0x7a
comma
l_int|0x6a
comma
l_int|0x1a
comma
l_int|0x0a
comma
l_int|0x3a
comma
l_int|0x2a
comma
l_int|0xdb
comma
l_int|0xcb
comma
l_int|0xfb
comma
l_int|0xeb
comma
l_int|0x9b
comma
l_int|0x8b
comma
l_int|0xbb
comma
l_int|0xab
comma
l_int|0x6c
comma
l_int|0x7c
comma
l_int|0x4c
comma
l_int|0x5c
comma
l_int|0x2c
comma
l_int|0x3c
comma
l_int|0x0c
comma
l_int|0x1c
comma
l_int|0xed
comma
l_int|0xfd
comma
l_int|0xcd
comma
l_int|0xdd
comma
l_int|0xad
comma
l_int|0xbd
comma
l_int|0x8d
comma
l_int|0x9d
comma
l_int|0x7e
comma
l_int|0x6e
comma
l_int|0x5e
comma
l_int|0x4e
comma
l_int|0x3e
comma
l_int|0x2e
comma
l_int|0x1e
comma
l_int|0x0e
comma
l_int|0xff
comma
l_int|0xef
comma
l_int|0xdf
comma
l_int|0xcf
comma
l_int|0xbf
comma
l_int|0xaf
comma
l_int|0x9f
comma
l_int|0x8f
comma
l_int|0x91
comma
l_int|0x81
comma
l_int|0xb1
comma
l_int|0xa1
comma
l_int|0xd1
comma
l_int|0xc1
comma
l_int|0xf1
comma
l_int|0xe1
comma
l_int|0x10
comma
l_int|0x00
comma
l_int|0x30
comma
l_int|0x20
comma
l_int|0x50
comma
l_int|0x40
comma
l_int|0x70
comma
l_int|0x60
comma
l_int|0x83
comma
l_int|0x93
comma
l_int|0xa3
comma
l_int|0xb3
comma
l_int|0xc3
comma
l_int|0xd3
comma
l_int|0xe3
comma
l_int|0xf3
comma
l_int|0x02
comma
l_int|0x12
comma
l_int|0x22
comma
l_int|0x32
comma
l_int|0x42
comma
l_int|0x52
comma
l_int|0x62
comma
l_int|0x72
comma
l_int|0xb5
comma
l_int|0xa5
comma
l_int|0x95
comma
l_int|0x85
comma
l_int|0xf5
comma
l_int|0xe5
comma
l_int|0xd5
comma
l_int|0xc5
comma
l_int|0x34
comma
l_int|0x24
comma
l_int|0x14
comma
l_int|0x04
comma
l_int|0x74
comma
l_int|0x64
comma
l_int|0x54
comma
l_int|0x44
comma
l_int|0xa7
comma
l_int|0xb7
comma
l_int|0x87
comma
l_int|0x97
comma
l_int|0xe7
comma
l_int|0xf7
comma
l_int|0xc7
comma
l_int|0xd7
comma
l_int|0x26
comma
l_int|0x36
comma
l_int|0x06
comma
l_int|0x16
comma
l_int|0x66
comma
l_int|0x76
comma
l_int|0x46
comma
l_int|0x56
comma
l_int|0xd9
comma
l_int|0xc9
comma
l_int|0xf9
comma
l_int|0xe9
comma
l_int|0x99
comma
l_int|0x89
comma
l_int|0xb9
comma
l_int|0xa9
comma
l_int|0x58
comma
l_int|0x48
comma
l_int|0x78
comma
l_int|0x68
comma
l_int|0x18
comma
l_int|0x08
comma
l_int|0x38
comma
l_int|0x28
comma
l_int|0xcb
comma
l_int|0xdb
comma
l_int|0xeb
comma
l_int|0xfb
comma
l_int|0x8b
comma
l_int|0x9b
comma
l_int|0xab
comma
l_int|0xbb
comma
l_int|0x4a
comma
l_int|0x5a
comma
l_int|0x6a
comma
l_int|0x7a
comma
l_int|0x0a
comma
l_int|0x1a
comma
l_int|0x2a
comma
l_int|0x3a
comma
l_int|0xfd
comma
l_int|0xed
comma
l_int|0xdd
comma
l_int|0xcd
comma
l_int|0xbd
comma
l_int|0xad
comma
l_int|0x9d
comma
l_int|0x8d
comma
l_int|0x7c
comma
l_int|0x6c
comma
l_int|0x5c
comma
l_int|0x4c
comma
l_int|0x3c
comma
l_int|0x2c
comma
l_int|0x1c
comma
l_int|0x0c
comma
l_int|0xef
comma
l_int|0xff
comma
l_int|0xcf
comma
l_int|0xdf
comma
l_int|0xaf
comma
l_int|0xbf
comma
l_int|0x8f
comma
l_int|0x9f
comma
l_int|0x6e
comma
l_int|0x7e
comma
l_int|0x4e
comma
l_int|0x5e
comma
l_int|0x2e
comma
l_int|0x3e
comma
l_int|0x0e
comma
l_int|0x1e
)brace
suffix:semicolon
r_static
r_int
r_char
id|CRCTable2
(braket
)braket
op_assign
(brace
l_int|0x00
comma
l_int|0x21
comma
l_int|0x42
comma
l_int|0x63
comma
l_int|0x84
comma
l_int|0xa5
comma
l_int|0xc6
comma
l_int|0xe7
comma
l_int|0x08
comma
l_int|0x29
comma
l_int|0x4a
comma
l_int|0x6b
comma
l_int|0x8c
comma
l_int|0xad
comma
l_int|0xce
comma
l_int|0xef
comma
l_int|0x31
comma
l_int|0x10
comma
l_int|0x73
comma
l_int|0x52
comma
l_int|0xb5
comma
l_int|0x94
comma
l_int|0xf7
comma
l_int|0xd6
comma
l_int|0x39
comma
l_int|0x18
comma
l_int|0x7b
comma
l_int|0x5a
comma
l_int|0xbd
comma
l_int|0x9c
comma
l_int|0xff
comma
l_int|0xde
comma
l_int|0x62
comma
l_int|0x43
comma
l_int|0x20
comma
l_int|0x01
comma
l_int|0xe6
comma
l_int|0xc7
comma
l_int|0xa4
comma
l_int|0x85
comma
l_int|0x6a
comma
l_int|0x4b
comma
l_int|0x28
comma
l_int|0x09
comma
l_int|0xee
comma
l_int|0xcf
comma
l_int|0xac
comma
l_int|0x8d
comma
l_int|0x53
comma
l_int|0x72
comma
l_int|0x11
comma
l_int|0x30
comma
l_int|0xd7
comma
l_int|0xf6
comma
l_int|0x95
comma
l_int|0xb4
comma
l_int|0x5b
comma
l_int|0x7a
comma
l_int|0x19
comma
l_int|0x38
comma
l_int|0xdf
comma
l_int|0xfe
comma
l_int|0x9d
comma
l_int|0xbc
comma
l_int|0xc4
comma
l_int|0xe5
comma
l_int|0x86
comma
l_int|0xa7
comma
l_int|0x40
comma
l_int|0x61
comma
l_int|0x02
comma
l_int|0x23
comma
l_int|0xcc
comma
l_int|0xed
comma
l_int|0x8e
comma
l_int|0xaf
comma
l_int|0x48
comma
l_int|0x69
comma
l_int|0x0a
comma
l_int|0x2b
comma
l_int|0xf5
comma
l_int|0xd4
comma
l_int|0xb7
comma
l_int|0x96
comma
l_int|0x71
comma
l_int|0x50
comma
l_int|0x33
comma
l_int|0x12
comma
l_int|0xfd
comma
l_int|0xdc
comma
l_int|0xbf
comma
l_int|0x9e
comma
l_int|0x79
comma
l_int|0x58
comma
l_int|0x3b
comma
l_int|0x1a
comma
l_int|0xa6
comma
l_int|0x87
comma
l_int|0xe4
comma
l_int|0xc5
comma
l_int|0x22
comma
l_int|0x03
comma
l_int|0x60
comma
l_int|0x41
comma
l_int|0xae
comma
l_int|0x8f
comma
l_int|0xec
comma
l_int|0xcd
comma
l_int|0x2a
comma
l_int|0x0b
comma
l_int|0x68
comma
l_int|0x49
comma
l_int|0x97
comma
l_int|0xb6
comma
l_int|0xd5
comma
l_int|0xf4
comma
l_int|0x13
comma
l_int|0x32
comma
l_int|0x51
comma
l_int|0x70
comma
l_int|0x9f
comma
l_int|0xbe
comma
l_int|0xdd
comma
l_int|0xfc
comma
l_int|0x1b
comma
l_int|0x3a
comma
l_int|0x59
comma
l_int|0x78
comma
l_int|0x88
comma
l_int|0xa9
comma
l_int|0xca
comma
l_int|0xeb
comma
l_int|0x0c
comma
l_int|0x2d
comma
l_int|0x4e
comma
l_int|0x6f
comma
l_int|0x80
comma
l_int|0xa1
comma
l_int|0xc2
comma
l_int|0xe3
comma
l_int|0x04
comma
l_int|0x25
comma
l_int|0x46
comma
l_int|0x67
comma
l_int|0xb9
comma
l_int|0x98
comma
l_int|0xfb
comma
l_int|0xda
comma
l_int|0x3d
comma
l_int|0x1c
comma
l_int|0x7f
comma
l_int|0x5e
comma
l_int|0xb1
comma
l_int|0x90
comma
l_int|0xf3
comma
l_int|0xd2
comma
l_int|0x35
comma
l_int|0x14
comma
l_int|0x77
comma
l_int|0x56
comma
l_int|0xea
comma
l_int|0xcb
comma
l_int|0xa8
comma
l_int|0x89
comma
l_int|0x6e
comma
l_int|0x4f
comma
l_int|0x2c
comma
l_int|0x0d
comma
l_int|0xe2
comma
l_int|0xc3
comma
l_int|0xa0
comma
l_int|0x81
comma
l_int|0x66
comma
l_int|0x47
comma
l_int|0x24
comma
l_int|0x05
comma
l_int|0xdb
comma
l_int|0xfa
comma
l_int|0x99
comma
l_int|0xb8
comma
l_int|0x5f
comma
l_int|0x7e
comma
l_int|0x1d
comma
l_int|0x3c
comma
l_int|0xd3
comma
l_int|0xf2
comma
l_int|0x91
comma
l_int|0xb0
comma
l_int|0x57
comma
l_int|0x76
comma
l_int|0x15
comma
l_int|0x34
comma
l_int|0x4c
comma
l_int|0x6d
comma
l_int|0x0e
comma
l_int|0x2f
comma
l_int|0xc8
comma
l_int|0xe9
comma
l_int|0x8a
comma
l_int|0xab
comma
l_int|0x44
comma
l_int|0x65
comma
l_int|0x06
comma
l_int|0x27
comma
l_int|0xc0
comma
l_int|0xe1
comma
l_int|0x82
comma
l_int|0xa3
comma
l_int|0x7d
comma
l_int|0x5c
comma
l_int|0x3f
comma
l_int|0x1e
comma
l_int|0xf9
comma
l_int|0xd8
comma
l_int|0xbb
comma
l_int|0x9a
comma
l_int|0x75
comma
l_int|0x54
comma
l_int|0x37
comma
l_int|0x16
comma
l_int|0xf1
comma
l_int|0xd0
comma
l_int|0xb3
comma
l_int|0x92
comma
l_int|0x2e
comma
l_int|0x0f
comma
l_int|0x6c
comma
l_int|0x4d
comma
l_int|0xaa
comma
l_int|0x8b
comma
l_int|0xe8
comma
l_int|0xc9
comma
l_int|0x26
comma
l_int|0x07
comma
l_int|0x64
comma
l_int|0x45
comma
l_int|0xa2
comma
l_int|0x83
comma
l_int|0xe0
comma
l_int|0xc1
comma
l_int|0x1f
comma
l_int|0x3e
comma
l_int|0x5d
comma
l_int|0x7c
comma
l_int|0x9b
comma
l_int|0xba
comma
l_int|0xd9
comma
l_int|0xf8
comma
l_int|0x17
comma
l_int|0x36
comma
l_int|0x55
comma
l_int|0x74
comma
l_int|0x93
comma
l_int|0xb2
comma
l_int|0xd1
comma
l_int|0xf0
)brace
suffix:semicolon
multiline_comment|/* look at the asm-code - what looks in C a bit strange is almost as good as handmade */
r_register
r_int
id|i
suffix:semicolon
r_register
r_int
r_char
op_star
id|CRCT1
comma
op_star
id|CRCT2
comma
op_star
id|data
comma
id|c
comma
id|crch
comma
id|crcl
suffix:semicolon
id|CRCT1
op_assign
id|CRCTable1
suffix:semicolon
id|CRCT2
op_assign
id|CRCTable2
suffix:semicolon
id|data
op_assign
id|data_a3
suffix:semicolon
id|crcl
op_assign
id|data_d1
suffix:semicolon
id|crch
op_assign
id|data_d0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|data_d3
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|c
op_assign
(paren
op_star
id|data
op_increment
)paren
op_xor
id|crch
suffix:semicolon
id|crch
op_assign
id|CRCT1
(braket
id|c
)braket
op_xor
id|crcl
suffix:semicolon
id|crcl
op_assign
id|CRCT2
(braket
id|c
)braket
suffix:semicolon
)brace
r_return
(paren
id|crch
op_lshift
l_int|8
)paren
op_or
id|crcl
suffix:semicolon
)brace
DECL|function|dos_hdr_crc
r_static
r_inline
id|ushort
id|dos_hdr_crc
(paren
r_struct
id|dos_header
op_star
id|hdr
)paren
(brace
r_return
id|dos_crc
c_func
(paren
op_amp
(paren
id|hdr-&gt;track
)paren
comma
l_int|0xb2
comma
l_int|0x30
comma
l_int|3
)paren
suffix:semicolon
multiline_comment|/* precomputed magic */
)brace
DECL|function|dos_data_crc
r_static
r_inline
id|ushort
id|dos_data_crc
c_func
(paren
r_int
r_char
op_star
id|data
)paren
(brace
r_return
id|dos_crc
c_func
(paren
id|data
comma
l_int|0xe2
comma
l_int|0x95
comma
l_int|511
)paren
suffix:semicolon
multiline_comment|/* precomputed magic */
)brace
DECL|function|dos_decode_byte
r_static
r_inline
r_int
r_char
id|dos_decode_byte
c_func
(paren
id|ushort
id|word
)paren
(brace
r_register
id|ushort
id|w2
suffix:semicolon
r_register
r_int
r_char
id|byte
suffix:semicolon
r_register
r_int
r_char
op_star
id|dec
op_assign
id|mfmdecode
suffix:semicolon
id|w2
op_assign
id|word
suffix:semicolon
id|w2
op_rshift_assign
l_int|8
suffix:semicolon
id|w2
op_and_assign
l_int|127
suffix:semicolon
id|byte
op_assign
id|dec
(braket
id|w2
)braket
suffix:semicolon
id|byte
op_lshift_assign
l_int|4
suffix:semicolon
id|w2
op_assign
id|word
op_amp
l_int|127
suffix:semicolon
id|byte
op_or_assign
id|dec
(braket
id|w2
)braket
suffix:semicolon
r_return
id|byte
suffix:semicolon
)brace
DECL|function|dos_decode
r_static
r_int
r_int
id|dos_decode
c_func
(paren
r_int
r_char
op_star
id|data
comma
r_int
r_int
op_star
id|raw
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
op_star
id|data
op_increment
op_assign
id|dos_decode_byte
c_func
(paren
op_star
id|raw
op_increment
)paren
suffix:semicolon
r_return
(paren
(paren
id|ulong
)paren
id|raw
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
DECL|function|dbg
r_static
r_void
id|dbg
c_func
(paren
r_int
r_int
id|ptr
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;raw data @%08lx: %08lx, %08lx ,%08lx, %08lx&bslash;n&quot;
comma
id|ptr
comma
(paren
(paren
id|ulong
op_star
)paren
id|ptr
)paren
(braket
l_int|0
)braket
comma
(paren
(paren
id|ulong
op_star
)paren
id|ptr
)paren
(braket
l_int|1
)braket
comma
(paren
(paren
id|ulong
op_star
)paren
id|ptr
)paren
(braket
l_int|2
)braket
comma
(paren
(paren
id|ulong
op_star
)paren
id|ptr
)paren
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|dos_read
r_static
r_int
id|dos_read
c_func
(paren
r_int
id|drive
)paren
(brace
r_int
r_int
id|end
suffix:semicolon
r_int
r_int
id|raw
suffix:semicolon
r_int
id|scnt
suffix:semicolon
r_int
r_int
id|crc
comma
id|data_crc
(braket
l_int|2
)braket
suffix:semicolon
r_struct
id|dos_header
id|hdr
suffix:semicolon
id|drive
op_and_assign
l_int|3
suffix:semicolon
id|raw
op_assign
(paren
r_int
)paren
id|raw_buf
suffix:semicolon
id|end
op_assign
id|raw
op_plus
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;read_size
suffix:semicolon
r_for
c_loop
(paren
id|scnt
op_assign
l_int|0
suffix:semicolon
id|scnt
OL
id|unit
(braket
id|drive
)braket
dot
id|dtype-&gt;sects
op_star
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;sect_mult
suffix:semicolon
id|scnt
op_increment
)paren
(brace
r_do
(brace
multiline_comment|/* search for the right sync of each sec-hdr */
r_if
c_cond
(paren
op_logical_neg
(paren
id|raw
op_assign
id|scan_sync
(paren
id|raw
comma
id|end
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;dos_read: no hdr sync on &quot;
l_string|&quot;track %d, unit %d for sector %d&bslash;n&quot;
comma
id|unit
(braket
id|drive
)braket
dot
id|track
comma
id|drive
comma
id|scnt
)paren
suffix:semicolon
r_return
id|MFM_NOSYNC
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|dbg
c_func
(paren
id|raw
)paren
suffix:semicolon
macro_line|#endif
)brace
r_while
c_loop
(paren
op_star
(paren
(paren
id|ushort
op_star
)paren
id|raw
)paren
op_ne
l_int|0x5554
)paren
suffix:semicolon
multiline_comment|/* loop usually only once done */
id|raw
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* skip over headermark */
id|raw
op_assign
id|dos_decode
c_func
(paren
(paren
r_int
r_char
op_star
)paren
op_amp
id|hdr
comma
(paren
id|ushort
op_star
)paren
id|raw
comma
l_int|8
)paren
suffix:semicolon
id|crc
op_assign
id|dos_hdr_crc
c_func
(paren
op_amp
id|hdr
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;(%3d,%d,%2d,%d) %x&bslash;n&quot;
comma
id|hdr.track
comma
id|hdr.side
comma
id|hdr.sec
comma
id|hdr.len_desc
comma
id|hdr.crc
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|crc
op_ne
id|hdr.crc
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;dos_read: MFM_HEADER %04x,%04x&bslash;n&quot;
comma
id|hdr.crc
comma
id|crc
)paren
suffix:semicolon
r_return
id|MFM_HEADER
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hdr.track
op_ne
id|unit
(braket
id|drive
)braket
dot
id|track
op_div
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;heads
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;dos_read: MFM_TRACK %d, %d&bslash;n&quot;
comma
id|hdr.track
comma
id|unit
(braket
id|drive
)braket
dot
id|track
op_div
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;heads
)paren
suffix:semicolon
r_return
id|MFM_TRACK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hdr.side
op_ne
id|unit
(braket
id|drive
)braket
dot
id|track
op_mod
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;heads
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;dos_read: MFM_SIDE %d, %d&bslash;n&quot;
comma
id|hdr.side
comma
id|unit
(braket
id|drive
)braket
dot
id|track
op_mod
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;heads
)paren
suffix:semicolon
r_return
id|MFM_TRACK
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hdr.len_desc
op_ne
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;dos_read: unknown sector len &quot;
l_string|&quot;descriptor %d&bslash;n&quot;
comma
id|hdr.len_desc
)paren
suffix:semicolon
r_return
id|MFM_DATA
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;hdr accepted&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|raw
op_assign
id|scan_sync
(paren
id|raw
comma
id|end
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;dos_read: no data sync on track &quot;
l_string|&quot;%d, unit %d for sector%d, disk sector %d&bslash;n&quot;
comma
id|unit
(braket
id|drive
)braket
dot
id|track
comma
id|drive
comma
id|scnt
comma
id|hdr.sec
)paren
suffix:semicolon
r_return
id|MFM_NOSYNC
suffix:semicolon
)brace
macro_line|#ifdef DEBUG
id|dbg
c_func
(paren
id|raw
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_star
(paren
(paren
id|ushort
op_star
)paren
id|raw
)paren
op_ne
l_int|0x5545
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;dos_read: no data mark after &quot;
l_string|&quot;sync (%d,%d,%d,%d) sc=%d&bslash;n&quot;
comma
id|hdr.track
comma
id|hdr.side
comma
id|hdr.sec
comma
id|hdr.len_desc
comma
id|scnt
)paren
suffix:semicolon
r_return
id|MFM_NOSYNC
suffix:semicolon
)brace
id|raw
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* skip data mark (included in checksum) */
id|raw
op_assign
id|dos_decode
c_func
(paren
(paren
r_int
r_char
op_star
)paren
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
(paren
id|hdr.sec
op_minus
l_int|1
)paren
op_star
l_int|512
)paren
comma
(paren
id|ushort
op_star
)paren
id|raw
comma
l_int|512
)paren
suffix:semicolon
id|raw
op_assign
id|dos_decode
c_func
(paren
(paren
r_int
r_char
op_star
)paren
id|data_crc
comma
(paren
id|ushort
op_star
)paren
id|raw
comma
l_int|4
)paren
suffix:semicolon
id|crc
op_assign
id|dos_data_crc
c_func
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
(paren
id|hdr.sec
op_minus
l_int|1
)paren
op_star
l_int|512
)paren
suffix:semicolon
r_if
c_cond
(paren
id|crc
op_ne
id|data_crc
(braket
l_int|0
)braket
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;dos_read: MFM_DATA (%d,%d,%d,%d) &quot;
l_string|&quot;sc=%d, %x %x&bslash;n&quot;
comma
id|hdr.track
comma
id|hdr.side
comma
id|hdr.sec
comma
id|hdr.len_desc
comma
id|scnt
comma
id|data_crc
(braket
l_int|0
)braket
comma
id|crc
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;data=(%lx,%lx,%lx,%lx,...)&bslash;n&quot;
comma
(paren
(paren
id|ulong
op_star
)paren
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
(paren
id|hdr.sec
op_minus
l_int|1
)paren
op_star
l_int|512
)paren
)paren
(braket
l_int|0
)braket
comma
(paren
(paren
id|ulong
op_star
)paren
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
(paren
id|hdr.sec
op_minus
l_int|1
)paren
op_star
l_int|512
)paren
)paren
(braket
l_int|1
)braket
comma
(paren
(paren
id|ulong
op_star
)paren
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
(paren
id|hdr.sec
op_minus
l_int|1
)paren
op_star
l_int|512
)paren
)paren
(braket
l_int|2
)braket
comma
(paren
(paren
id|ulong
op_star
)paren
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
(paren
id|hdr.sec
op_minus
l_int|1
)paren
op_star
l_int|512
)paren
)paren
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_return
id|MFM_DATA
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|dos_encode_byte
r_static
r_inline
id|ushort
id|dos_encode_byte
c_func
(paren
r_int
r_char
id|byte
)paren
(brace
r_register
r_int
r_char
op_star
id|enc
comma
id|b2
comma
id|b1
suffix:semicolon
r_register
id|ushort
id|word
suffix:semicolon
id|enc
op_assign
id|mfmencode
suffix:semicolon
id|b1
op_assign
id|byte
suffix:semicolon
id|b2
op_assign
id|b1
op_rshift
l_int|4
suffix:semicolon
id|b1
op_and_assign
l_int|15
suffix:semicolon
id|word
op_assign
id|enc
(braket
id|b2
)braket
op_lshift
l_int|8
op_or
id|enc
(braket
id|b1
)braket
suffix:semicolon
r_return
(paren
id|word
op_or
(paren
(paren
id|word
op_amp
(paren
l_int|256
op_or
l_int|64
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|128
)paren
)paren
suffix:semicolon
)brace
DECL|function|dos_encode_block
r_static
r_void
id|dos_encode_block
c_func
(paren
id|ushort
op_star
id|dest
comma
r_int
r_char
op_star
id|src
comma
r_int
id|len
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|dest
op_assign
id|dos_encode_byte
c_func
(paren
op_star
id|src
op_increment
)paren
suffix:semicolon
op_star
id|dest
op_or_assign
(paren
(paren
id|dest
(braket
op_minus
l_int|1
)braket
op_amp
l_int|1
)paren
op_logical_or
(paren
op_star
id|dest
op_amp
l_int|0x4000
)paren
)paren
ques
c_cond
l_int|0
suffix:colon
l_int|0x8000
suffix:semicolon
id|dest
op_increment
suffix:semicolon
)brace
)brace
DECL|function|ms_putsec
r_static
r_int
r_int
op_star
id|ms_putsec
c_func
(paren
r_int
id|drive
comma
r_int
r_int
op_star
id|raw
comma
r_int
id|cnt
)paren
(brace
r_static
r_struct
id|dos_header
id|hdr
op_assign
initialization_block
suffix:semicolon
r_int
id|i
suffix:semicolon
r_static
id|ushort
id|crc
(braket
l_int|2
)braket
op_assign
initialization_block
suffix:semicolon
id|drive
op_and_assign
l_int|3
suffix:semicolon
multiline_comment|/* id gap 1 */
multiline_comment|/* the MFM word before is always 9254 */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|raw
op_increment
op_assign
l_int|0xaaaaaaaa
suffix:semicolon
)brace
multiline_comment|/* 3 sync + 1 headermark */
op_star
id|raw
op_increment
op_assign
l_int|0x44894489
suffix:semicolon
op_star
id|raw
op_increment
op_assign
l_int|0x44895554
suffix:semicolon
multiline_comment|/* fill in the variable parts of the header */
id|hdr.track
op_assign
id|unit
(braket
id|drive
)braket
dot
id|track
op_div
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;heads
suffix:semicolon
id|hdr.side
op_assign
id|unit
(braket
id|drive
)braket
dot
id|track
op_mod
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;heads
suffix:semicolon
id|hdr.sec
op_assign
id|cnt
op_plus
l_int|1
suffix:semicolon
id|hdr.crc
op_assign
id|dos_hdr_crc
c_func
(paren
op_amp
id|hdr
)paren
suffix:semicolon
multiline_comment|/* header (without &quot;magic&quot;) and id gap 2*/
id|dos_encode_block
c_func
(paren
(paren
id|ushort
op_star
)paren
id|raw
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|hdr.track
comma
l_int|28
)paren
suffix:semicolon
id|raw
op_add_assign
l_int|14
suffix:semicolon
multiline_comment|/*id gap 3 */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|raw
op_increment
op_assign
l_int|0xaaaaaaaa
suffix:semicolon
)brace
multiline_comment|/* 3 syncs and 1 datamark */
op_star
id|raw
op_increment
op_assign
l_int|0x44894489
suffix:semicolon
op_star
id|raw
op_increment
op_assign
l_int|0x44895545
suffix:semicolon
multiline_comment|/* data */
id|dos_encode_block
c_func
(paren
(paren
id|ushort
op_star
)paren
id|raw
comma
(paren
r_int
r_char
op_star
)paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
id|cnt
op_star
l_int|512
comma
l_int|512
)paren
suffix:semicolon
id|raw
op_add_assign
l_int|256
suffix:semicolon
multiline_comment|/*data crc + jd&squot;s special gap (long words :-/) */
id|crc
(braket
l_int|0
)braket
op_assign
id|dos_data_crc
c_func
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
id|cnt
op_star
l_int|512
)paren
suffix:semicolon
id|dos_encode_block
c_func
(paren
(paren
id|ushort
op_star
)paren
id|raw
comma
(paren
r_int
r_char
op_star
)paren
id|crc
comma
l_int|4
)paren
suffix:semicolon
id|raw
op_add_assign
l_int|2
suffix:semicolon
multiline_comment|/* data gap */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|38
suffix:semicolon
id|i
op_increment
)paren
(brace
op_star
id|raw
op_increment
op_assign
l_int|0x92549254
suffix:semicolon
)brace
r_return
id|raw
suffix:semicolon
multiline_comment|/* wrote 652 MFM words */
)brace
DECL|function|dos_write
r_static
r_void
id|dos_write
c_func
(paren
r_int
id|disk
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_int
r_int
id|raw
op_assign
(paren
r_int
r_int
)paren
id|raw_buf
suffix:semicolon
r_int
r_int
op_star
id|ptr
op_assign
(paren
r_int
r_int
op_star
)paren
id|raw
suffix:semicolon
id|disk
op_and_assign
l_int|3
suffix:semicolon
multiline_comment|/* really gap4 + indexgap , but we write it first and round it up */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
l_int|425
suffix:semicolon
id|cnt
op_increment
)paren
op_star
id|ptr
op_increment
op_assign
l_int|0x92549254
suffix:semicolon
multiline_comment|/* the following is just guessed */
r_if
c_cond
(paren
id|unit
(braket
id|disk
)braket
dot
id|type-&gt;sect_mult
op_eq
l_int|2
)paren
multiline_comment|/* check for HD-Disks */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
l_int|473
suffix:semicolon
id|cnt
op_increment
)paren
(brace
op_star
id|ptr
op_increment
op_assign
l_int|0x92549254
suffix:semicolon
)brace
multiline_comment|/* now the index marks...*/
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
l_int|20
suffix:semicolon
id|cnt
op_increment
)paren
op_star
id|ptr
op_increment
op_assign
l_int|0x92549254
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
l_int|6
suffix:semicolon
id|cnt
op_increment
)paren
op_star
id|ptr
op_increment
op_assign
l_int|0xaaaaaaaa
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_int|0x52245224
suffix:semicolon
op_star
id|ptr
op_increment
op_assign
l_int|0x52245552
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
l_int|20
suffix:semicolon
id|cnt
op_increment
)paren
op_star
id|ptr
op_increment
op_assign
l_int|0x92549254
suffix:semicolon
multiline_comment|/* sectors */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|unit
(braket
id|disk
)braket
dot
id|dtype-&gt;sects
op_star
id|unit
(braket
id|disk
)braket
dot
id|type-&gt;sect_mult
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|ptr
op_assign
id|ms_putsec
c_func
(paren
id|disk
comma
id|ptr
comma
id|cnt
)paren
suffix:semicolon
)brace
op_star
(paren
id|ushort
op_star
)paren
id|ptr
op_assign
l_int|0xaaa8
suffix:semicolon
multiline_comment|/* MFM word before is always 0x9254 */
)brace
multiline_comment|/*&n; * Here comes the high level stuff (i.e. the filesystem interface)&n; * and helper functions.&n; * Normally this should be the only part that has to be adapted to&n; * different kernel versions.&n; */
multiline_comment|/* FIXME: this assumes the drive is still spinning -&n; * which is only true if we complete writing a track within three seconds&n; */
DECL|function|flush_track_callback
r_static
r_void
id|flush_track_callback
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
id|nr
op_and_assign
l_int|3
suffix:semicolon
id|writefromint
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|try_fdc
c_func
(paren
id|nr
)paren
)paren
(brace
multiline_comment|/* we might block in an interrupt, so try again later */
id|flush_track_timer
(braket
id|nr
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|add_timer
c_func
(paren
id|flush_track_timer
op_plus
id|nr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|get_fdc
c_func
(paren
id|nr
)paren
suffix:semicolon
(paren
op_star
id|unit
(braket
id|nr
)braket
dot
id|dtype-&gt;write_fkt
)paren
(paren
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|raw_write
c_func
(paren
id|nr
)paren
)paren
(brace
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;floppy disk write protected&bslash;n&quot;
)paren
suffix:semicolon
id|writefromint
op_assign
l_int|0
suffix:semicolon
id|writepending
op_assign
l_int|0
suffix:semicolon
)brace
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|non_int_flush_track
r_static
r_int
id|non_int_flush_track
(paren
r_int
r_int
id|nr
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|nr
op_and_assign
l_int|3
suffix:semicolon
id|writefromint
op_assign
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|post_write_timer
)paren
suffix:semicolon
id|get_fdc
c_func
(paren
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd_motor_on
c_func
(paren
id|nr
)paren
)paren
(brace
id|writepending
op_assign
l_int|0
suffix:semicolon
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|writepending
op_ne
l_int|2
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
(paren
op_star
id|unit
(braket
id|nr
)braket
dot
id|dtype-&gt;write_fkt
)paren
(paren
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|raw_write
c_func
(paren
id|nr
)paren
)paren
(brace
id|printk
(paren
id|KERN_NOTICE
l_string|&quot;floppy disk write protected &quot;
l_string|&quot;in write!&bslash;n&quot;
)paren
suffix:semicolon
id|writepending
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|block_flag
op_eq
l_int|2
)paren
id|sleep_on
(paren
op_amp
id|wait_fd_block
)paren
suffix:semicolon
)brace
r_else
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|ms_delay
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* 2 ms post_write delay */
id|post_write
c_func
(paren
id|nr
)paren
suffix:semicolon
)brace
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|get_track
r_static
r_int
id|get_track
c_func
(paren
r_int
id|drive
comma
r_int
id|track
)paren
(brace
r_int
id|error
comma
id|errcnt
suffix:semicolon
id|drive
op_and_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|track
op_eq
id|track
)paren
r_return
l_int|0
suffix:semicolon
id|get_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd_motor_on
c_func
(paren
id|drive
)paren
)paren
(brace
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|dirty
op_eq
l_int|1
)paren
(brace
id|del_timer
(paren
id|flush_track_timer
op_plus
id|drive
)paren
suffix:semicolon
id|non_int_flush_track
(paren
id|drive
)paren
suffix:semicolon
)brace
id|errcnt
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|errcnt
OL
id|MAX_ERRORS
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fd_seek
c_func
(paren
id|drive
comma
id|track
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|raw_read
c_func
(paren
id|drive
)paren
suffix:semicolon
id|error
op_assign
(paren
op_star
id|unit
(braket
id|drive
)braket
dot
id|dtype-&gt;read_fkt
)paren
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|error
op_eq
l_int|0
)paren
(brace
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read Error Handling: recalibrate and try again */
id|unit
(braket
id|drive
)braket
dot
id|track
op_assign
op_minus
l_int|1
suffix:semicolon
id|errcnt
op_increment
suffix:semicolon
)brace
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|redo_fd_request
r_static
r_void
id|redo_fd_request
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|cnt
comma
id|block
comma
id|track
comma
id|sector
suffix:semicolon
r_int
id|device
comma
id|drive
suffix:semicolon
r_struct
id|amiga_floppy_struct
op_star
id|floppy
suffix:semicolon
r_char
op_star
id|data
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|QUEUE_EMPTY
op_logical_and
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
r_return
suffix:semicolon
)brace
id|repeat
suffix:colon
r_if
c_cond
(paren
id|QUEUE_EMPTY
)paren
(brace
multiline_comment|/* Nothing left to do */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
op_ne
id|MAJOR_NR
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: request list destroyed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;bh
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|CURRENT-&gt;bh
)paren
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
id|device
op_assign
id|MINOR
c_func
(paren
id|CURRENT_DEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
OL
l_int|8
)paren
(brace
multiline_comment|/* manual selection */
id|drive
op_assign
id|device
op_amp
l_int|3
suffix:semicolon
id|floppy
op_assign
id|unit
op_plus
id|drive
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Auto-detection */
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;redo_fd_request: can&squot;t handle auto detect&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;redo_fd_request: default to normal&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|drive
op_assign
id|device
op_amp
l_int|3
suffix:semicolon
id|floppy
op_assign
id|unit
op_plus
id|drive
suffix:semicolon
)brace
multiline_comment|/* Here someone could investigate to be more efficient */
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|cnt
op_increment
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;fd: sector %ld + %d requested for %s&bslash;n&quot;
comma
id|CURRENT-&gt;sector
comma
id|cnt
comma
(paren
id|CURRENT-&gt;cmd
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;write&quot;
)paren
suffix:semicolon
macro_line|#endif
id|block
op_assign
id|CURRENT-&gt;sector
op_plus
id|cnt
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
)paren
id|block
OG
id|floppy-&gt;blocks
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|track
op_assign
id|block
op_div
(paren
id|floppy-&gt;dtype-&gt;sects
op_star
id|floppy-&gt;type-&gt;sect_mult
)paren
suffix:semicolon
id|sector
op_assign
id|block
op_mod
(paren
id|floppy-&gt;dtype-&gt;sects
op_star
id|floppy-&gt;type-&gt;sect_mult
)paren
suffix:semicolon
id|data
op_assign
id|CURRENT-&gt;buffer
op_plus
l_int|512
op_star
id|cnt
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;access to track %d, sector %d, with buffer at &quot;
l_string|&quot;0x%08lx&bslash;n&quot;
comma
id|track
comma
id|sector
comma
id|data
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|CURRENT-&gt;cmd
op_ne
id|READ
)paren
op_logical_and
(paren
id|CURRENT-&gt;cmd
op_ne
id|WRITE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;do_fd_request: unknown command&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|get_track
c_func
(paren
id|drive
comma
id|track
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|CURRENT-&gt;cmd
)paren
(brace
r_case
id|READ
suffix:colon
id|memcpy
c_func
(paren
id|data
comma
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
id|sector
op_star
l_int|512
comma
l_int|512
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE
suffix:colon
id|memcpy
c_func
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_plus
id|sector
op_star
l_int|512
comma
id|data
comma
l_int|512
)paren
suffix:semicolon
multiline_comment|/* keep the drive spinning while writes are scheduled */
r_if
c_cond
(paren
op_logical_neg
id|fd_motor_on
c_func
(paren
id|drive
)paren
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * setup a callback to write the track buffer&n;&t;&t;&t; * after a short (1 tick) delay.&n;&t;&t;&t; */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|dirty
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* reset the timer */
id|del_timer
(paren
id|flush_track_timer
op_plus
id|drive
)paren
suffix:semicolon
id|flush_track_timer
(braket
id|drive
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
l_int|1
suffix:semicolon
id|add_timer
(paren
id|flush_track_timer
op_plus
id|drive
)paren
suffix:semicolon
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
DECL|function|do_fd_request
r_static
r_void
id|do_fd_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fd_ioctl
r_static
r_int
id|fd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|param
)paren
(brace
r_int
id|drive
op_assign
id|inode-&gt;i_rdev
op_amp
l_int|3
suffix:semicolon
r_static
r_struct
id|floppy_struct
id|getprm
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
(brace
r_struct
id|hd_geometry
id|loc
suffix:semicolon
id|loc.heads
op_assign
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;heads
suffix:semicolon
id|loc.sectors
op_assign
id|unit
(braket
id|drive
)braket
dot
id|dtype-&gt;sects
op_star
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;sect_mult
suffix:semicolon
id|loc.cylinders
op_assign
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;tracks
suffix:semicolon
id|loc.start
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|param
comma
(paren
r_void
op_star
)paren
op_amp
id|loc
comma
r_sizeof
(paren
r_struct
id|hd_geometry
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
)brace
r_case
id|FDFMTBEG
suffix:colon
id|get_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd_ref
(braket
id|drive
)braket
OG
l_int|1
)paren
(brace
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd_motor_on
c_func
(paren
id|drive
)paren
op_eq
l_int|0
)paren
(brace
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fd_calibrate
c_func
(paren
id|drive
)paren
op_eq
l_int|0
)paren
(brace
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|floppy_off
c_func
(paren
id|drive
)paren
suffix:semicolon
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDFMTTRK
suffix:colon
r_if
c_cond
(paren
id|param
OL
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;tracks
op_star
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;heads
)paren
(brace
id|get_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd_seek
c_func
(paren
id|drive
comma
id|param
)paren
op_ne
l_int|0
)paren
(brace
id|memset
c_func
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
comma
id|FD_FILL_BYTE
comma
id|unit
(braket
id|drive
)braket
dot
id|dtype-&gt;sects
op_star
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;sect_mult
op_star
l_int|512
)paren
suffix:semicolon
id|non_int_flush_track
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
id|floppy_off
c_func
(paren
id|drive
)paren
suffix:semicolon
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDFMTEND
suffix:colon
id|floppy_off
c_func
(paren
id|drive
)paren
suffix:semicolon
id|sb
op_assign
id|get_super
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
)paren
id|invalidate_inodes
c_func
(paren
id|sb
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDGETPRM
suffix:colon
id|memset
c_func
(paren
(paren
r_void
op_star
)paren
op_amp
id|getprm
comma
l_int|0
comma
r_sizeof
(paren
id|getprm
)paren
)paren
suffix:semicolon
id|getprm.track
op_assign
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;tracks
suffix:semicolon
id|getprm.head
op_assign
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;heads
suffix:semicolon
id|getprm.sect
op_assign
id|unit
(braket
id|drive
)braket
dot
id|dtype-&gt;sects
op_star
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;sect_mult
suffix:semicolon
id|getprm.size
op_assign
id|unit
(braket
id|drive
)braket
dot
id|blocks
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|param
comma
(paren
r_void
op_star
)paren
op_amp
id|getprm
comma
r_sizeof
(paren
r_struct
id|floppy_struct
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
r_return
id|put_user
c_func
(paren
id|unit
(braket
id|drive
)braket
dot
id|blocks
comma
(paren
r_int
op_star
)paren
id|param
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDSETPRM
suffix:colon
r_case
id|FDDEFPRM
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
r_case
id|FDFLUSH
suffix:colon
multiline_comment|/* unconditionally, even if not needed */
id|del_timer
(paren
id|flush_track_timer
op_plus
id|drive
)paren
suffix:semicolon
id|non_int_flush_track
c_func
(paren
id|drive
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#ifdef RAW_IOCTL
r_case
id|IOCTL_RAW_TRACK
suffix:colon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|param
comma
id|raw_buf
comma
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;read_size
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_else
r_return
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;read_size
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;fd_ioctl: unknown cmd %d for drive %d.&quot;
comma
id|cmd
comma
id|drive
)paren
suffix:semicolon
r_return
op_minus
id|ENOSYS
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fd_probe
r_static
r_void
id|fd_probe
c_func
(paren
r_int
id|dev
)paren
(brace
r_int
r_int
id|code
suffix:semicolon
r_int
id|type
suffix:semicolon
r_int
id|drive
suffix:semicolon
id|drive
op_assign
id|dev
op_amp
l_int|3
suffix:semicolon
id|code
op_assign
id|fd_get_drive_id
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* get drive type */
r_for
c_loop
(paren
id|type
op_assign
l_int|0
suffix:semicolon
id|type
OL
id|num_dr_types
suffix:semicolon
id|type
op_increment
)paren
r_if
c_cond
(paren
id|drive_types
(braket
id|type
)braket
dot
id|code
op_eq
id|code
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|num_dr_types
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;fd_probe: unsupported drive type &quot;
l_string|&quot;%08lx found&bslash;n&quot;
comma
id|code
)paren
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|type
op_assign
op_amp
id|drive_types
(braket
id|num_dr_types
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* FD_NODRIVE */
r_return
suffix:semicolon
)brace
id|unit
(braket
id|drive
)braket
dot
id|type
op_assign
id|drive_types
op_plus
id|type
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|track
op_assign
op_minus
l_int|1
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|disk
op_assign
op_minus
l_int|1
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|motor
op_assign
l_int|0
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|busy
op_assign
l_int|0
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|status
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * floppy_open check for aliasing (/dev/fd0 can be the same as&n; * /dev/PS0 etc), and disallows simultaneous access to the same&n; * drive with different device numbers.&n; */
DECL|function|floppy_open
r_static
r_int
id|floppy_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|drive
suffix:semicolon
r_int
id|old_dev
suffix:semicolon
r_int
id|system
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|drive
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
l_int|3
suffix:semicolon
id|old_dev
op_assign
id|fd_device
(braket
id|drive
)braket
suffix:semicolon
r_if
c_cond
(paren
id|fd_ref
(braket
id|drive
)braket
)paren
r_if
c_cond
(paren
id|old_dev
op_ne
id|inode-&gt;i_rdev
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;code
op_eq
id|FD_NODRIVE
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|filp
op_logical_and
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
(brace
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
(brace
r_int
id|wrprot
suffix:semicolon
id|get_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
id|fd_select
(paren
id|drive
)paren
suffix:semicolon
id|wrprot
op_assign
op_logical_neg
(paren
id|ciaa.pra
op_amp
id|DSKPROT
)paren
suffix:semicolon
id|fd_deselect
(paren
id|drive
)paren
suffix:semicolon
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wrprot
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
)brace
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|fd_ref
(braket
id|drive
)braket
op_increment
suffix:semicolon
id|fd_device
(braket
id|drive
)braket
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
macro_line|#ifdef MODULE
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|motor
op_eq
l_int|0
)paren
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_dev
op_logical_and
id|old_dev
op_ne
id|inode-&gt;i_rdev
)paren
id|invalidate_buffers
c_func
(paren
id|old_dev
)paren
suffix:semicolon
id|system
op_assign
(paren
id|inode-&gt;i_rdev
op_amp
l_int|4
)paren
op_rshift
l_int|2
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|dtype
op_assign
op_amp
id|data_types
(braket
id|system
)braket
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|blocks
op_assign
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;heads
op_star
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;tracks
op_star
id|data_types
(braket
id|system
)braket
dot
id|sects
op_star
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;sect_mult
suffix:semicolon
id|floppy_sizes
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
op_assign
id|unit
(braket
id|drive
)braket
dot
id|blocks
op_rshift
l_int|1
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;fd%d: accessing %s-disk with %s-layout&bslash;n&quot;
comma
id|drive
comma
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;name
comma
id|data_types
(braket
id|system
)braket
dot
id|name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|floppy_release
r_static
r_int
id|floppy_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
macro_line|#ifdef DEBUG
r_struct
id|super_block
op_star
id|sb
suffix:semicolon
macro_line|#endif
r_int
id|drive
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|dirty
op_eq
l_int|1
)paren
(brace
id|del_timer
(paren
id|flush_track_timer
op_plus
id|drive
)paren
suffix:semicolon
id|non_int_flush_track
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|fd_ref
(braket
id|drive
)braket
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;floppy_release with fd_ref == 0&quot;
)paren
suffix:semicolon
id|fd_ref
(braket
id|drive
)braket
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/* the mod_use counter is handled this way */
id|floppy_off
(paren
id|drive
op_or
l_int|0x40000000
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * floppy-change is never called from an interrupt, so we can relax a bit&n; * here, sleep etc. Note that floppy-on tries to set current_DOR to point&n; * to the desired drive, but it will probably not survive the sleep if&n; * several floppies are used at the same time: thus the loop.&n; */
DECL|function|amiga_floppy_change
r_static
r_int
id|amiga_floppy_change
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|drive
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
op_amp
l_int|3
suffix:semicolon
r_int
id|changed
suffix:semicolon
r_static
r_int
id|first_time
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
op_ne
id|MAJOR_NR
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;floppy_change: not a floppy&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|first_time
)paren
id|changed
op_assign
id|first_time
op_decrement
suffix:semicolon
r_else
(brace
id|get_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
id|fd_select
(paren
id|drive
)paren
suffix:semicolon
id|changed
op_assign
op_logical_neg
(paren
id|ciaa.pra
op_amp
id|DSKCHANGE
)paren
suffix:semicolon
id|fd_deselect
(paren
id|drive
)paren
suffix:semicolon
id|rel_fdc
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|changed
)paren
(brace
id|fd_probe
c_func
(paren
id|drive
)paren
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|track
op_assign
op_minus
l_int|1
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|dirty
op_assign
l_int|0
suffix:semicolon
id|writepending
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* if this was true before, too bad! */
id|writefromint
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|floppy_fops
r_static
r_struct
id|block_device_operations
id|floppy_fops
op_assign
(brace
id|open
suffix:colon
id|floppy_open
comma
id|release
suffix:colon
id|floppy_release
comma
id|ioctl
suffix:colon
id|fd_ioctl
comma
id|check_media_change
suffix:colon
id|amiga_floppy_change
comma
)brace
suffix:semicolon
DECL|function|amiga_floppy_setup
r_void
id|__init
id|amiga_floppy_setup
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|printk
(paren
id|KERN_INFO
l_string|&quot;amiflop: Setting default df0 to %x&bslash;n&quot;
comma
id|ints
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|fd_def_df0
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
)brace
DECL|function|fd_probe_drives
r_static
r_int
id|__init
id|fd_probe_drives
c_func
(paren
r_void
)paren
(brace
r_int
id|drive
comma
id|drives
comma
id|nomem
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FD: probing units&bslash;n&quot;
id|KERN_INFO
l_string|&quot;found &quot;
)paren
suffix:semicolon
id|drives
op_assign
l_int|0
suffix:semicolon
id|nomem
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|FD_MAX_UNITS
suffix:semicolon
id|drive
op_increment
)paren
(brace
id|fd_probe
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|type-&gt;code
op_ne
id|FD_NODRIVE
)paren
(brace
id|drives
op_increment
suffix:semicolon
r_if
c_cond
(paren
(paren
id|unit
(braket
id|drive
)braket
dot
id|trackbuf
op_assign
id|kmalloc
c_func
(paren
id|FLOPPY_MAX_SECTORS
op_star
l_int|512
comma
id|GFP_KERNEL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;no mem for &quot;
)paren
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|type
op_assign
op_amp
id|drive_types
(braket
id|num_dr_types
op_minus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* FD_NODRIVE */
id|drives
op_decrement
suffix:semicolon
id|nomem
op_assign
l_int|1
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;fd%d &quot;
comma
id|drive
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
(paren
id|drives
OG
l_int|0
)paren
op_logical_or
(paren
id|nomem
op_eq
l_int|0
)paren
)paren
(brace
r_if
c_cond
(paren
id|drives
op_eq
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;no drives&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|drives
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
DECL|function|amiga_floppy_init
r_int
id|__init
id|amiga_floppy_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|AMIGAHW_PRESENT
c_func
(paren
id|AMI_FLOPPY
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
comma
op_amp
id|floppy_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd: Unable to get major %d for floppy&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  We request DSKPTR, DSKLEN and DSKDATA only, because the other&n;&t; *  floppy registers are too spreaded over the custom register space&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|request_mem_region
c_func
(paren
id|CUSTOM_PHYSADDR
op_plus
l_int|0x20
comma
l_int|8
comma
l_string|&quot;amiflop [Paula]&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd: cannot get floppy registers&bslash;n&quot;
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|raw_buf
op_assign
(paren
r_char
op_star
)paren
id|amiga_chip_alloc
(paren
id|RAW_BUF_SIZE
comma
l_string|&quot;Floppy&quot;
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd: cannot get chip mem buffer&bslash;n&quot;
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|CUSTOM_PHYSADDR
op_plus
l_int|0x20
comma
l_int|8
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|IRQ_AMIGA_DSKBLK
comma
id|fd_block_done
comma
l_int|0
comma
l_string|&quot;floppy_dma&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd: cannot get irq for dma&bslash;n&quot;
)paren
suffix:semicolon
id|amiga_chip_free
c_func
(paren
id|raw_buf
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|CUSTOM_PHYSADDR
op_plus
l_int|0x20
comma
l_int|8
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|IRQ_AMIGA_CIAA_TB
comma
id|ms_isr
comma
l_int|0
comma
l_string|&quot;floppy_timer&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd: cannot get irq for timer&bslash;n&quot;
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|IRQ_AMIGA_DSKBLK
comma
l_int|NULL
)paren
suffix:semicolon
id|amiga_chip_free
c_func
(paren
id|raw_buf
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|CUSTOM_PHYSADDR
op_plus
l_int|0x20
comma
l_int|8
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fd_probe_drives
c_func
(paren
)paren
OL
l_int|1
)paren
(brace
multiline_comment|/* No usable drives */
id|free_irq
c_func
(paren
id|IRQ_AMIGA_CIAA_TB
comma
l_int|NULL
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|IRQ_AMIGA_DSKBLK
comma
l_int|NULL
)paren
suffix:semicolon
id|amiga_chip_free
c_func
(paren
id|raw_buf
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|CUSTOM_PHYSADDR
op_plus
l_int|0x20
comma
l_int|8
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
multiline_comment|/* initialize variables */
id|init_timer
c_func
(paren
op_amp
id|motor_on_timer
)paren
suffix:semicolon
id|motor_on_timer.expires
op_assign
l_int|0
suffix:semicolon
id|motor_on_timer.data
op_assign
l_int|0
suffix:semicolon
id|motor_on_timer.function
op_assign
id|motor_on_callback
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FD_MAX_UNITS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|init_timer
c_func
(paren
op_amp
id|motor_off_timer
(braket
id|i
)braket
)paren
suffix:semicolon
id|motor_off_timer
(braket
id|i
)braket
dot
id|expires
op_assign
l_int|0
suffix:semicolon
id|motor_off_timer
(braket
id|i
)braket
dot
id|data
op_assign
id|i
op_or
l_int|0x80000000
suffix:semicolon
id|motor_off_timer
(braket
id|i
)braket
dot
id|function
op_assign
id|fd_motor_off
suffix:semicolon
id|init_timer
c_func
(paren
op_amp
id|flush_track_timer
(braket
id|i
)braket
)paren
suffix:semicolon
id|flush_track_timer
(braket
id|i
)braket
dot
id|expires
op_assign
l_int|0
suffix:semicolon
id|flush_track_timer
(braket
id|i
)braket
dot
id|data
op_assign
id|i
suffix:semicolon
id|flush_track_timer
(braket
id|i
)braket
dot
id|function
op_assign
id|flush_track_callback
suffix:semicolon
id|unit
(braket
id|i
)braket
dot
id|track
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|init_timer
c_func
(paren
op_amp
id|post_write_timer
)paren
suffix:semicolon
id|post_write_timer.expires
op_assign
l_int|0
suffix:semicolon
id|post_write_timer.data
op_assign
l_int|0
suffix:semicolon
id|post_write_timer.function
op_assign
id|post_write
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|DEVICE_REQUEST
)paren
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|floppy_blocksizes
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|floppy_sizes
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|128
suffix:semicolon
id|i
op_increment
)paren
id|mfmdecode
(braket
id|i
)braket
op_assign
l_int|255
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|mfmdecode
(braket
id|mfmencode
(braket
id|i
)braket
)braket
op_assign
id|i
suffix:semicolon
multiline_comment|/* make sure that disk DMA is enabled */
id|custom.dmacon
op_assign
id|DMAF_SETCLR
op_or
id|DMAF_DISK
suffix:semicolon
multiline_comment|/* init ms timer */
id|ciaa.crb
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* one-shot, stop */
(paren
r_void
)paren
id|do_floppy
suffix:semicolon
multiline_comment|/* avoid warning about unused variable */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
macro_line|#include &lt;linux/version.h&gt;
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|MACH_IS_AMIGA
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_return
id|amiga_floppy_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FD_MAX_UNITS
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|unit
(braket
id|i
)braket
dot
id|type-&gt;code
op_ne
id|FD_NODRIVE
)paren
id|kfree
c_func
(paren
id|unit
(braket
id|i
)braket
dot
id|trackbuf
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|IRQ_AMIGA_CIAA_TB
comma
l_int|NULL
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|IRQ_AMIGA_DSKBLK
comma
l_int|NULL
)paren
suffix:semicolon
id|custom.dmacon
op_assign
id|DMAF_DISK
suffix:semicolon
multiline_comment|/* disable DMA */
id|amiga_chip_free
c_func
(paren
id|raw_buf
)paren
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
l_int|NULL
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
id|release_mem_region
c_func
(paren
id|CUSTOM_PHYSADDR
op_plus
l_int|0x20
comma
l_int|8
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
eof
