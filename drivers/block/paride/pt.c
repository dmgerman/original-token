multiline_comment|/* &n;        pt.c    (c) 1998  Grant R. Guenther &lt;grant@torque.net&gt;&n;                          Under the terms of the GNU public license.&n;&n;        This is the high-level driver for parallel port ATAPI tape&n;        drives based on chips supported by the paride module.&n;&n;&t;The driver implements both rewinding and non-rewinding&n;&t;devices, filemarks, and the rewind ioctl.  It allocates&n;&t;a small internal &quot;bounce buffer&quot; for each open device, but&n;        otherwise expects buffering and blocking to be done at the&n;        user level.  As with most block-structured tapes, short&n;&t;writes are padded to full tape blocks, so reading back a file&n;        may return more data than was actually written.&n;&n;        By default, the driver will autoprobe for a single parallel&n;        port ATAPI tape drive, but if their individual parameters are&n;        specified, the driver can handle up to 4 drives.&n;&n;&t;The rewinding devices are named /dev/pt0, /dev/pt1, ...&n;&t;while the non-rewinding devices are /dev/npt0, /dev/npt1, etc.&n;&n;        The behaviour of the pt driver can be altered by setting&n;        some parameters from the insmod command line.  The following&n;        parameters are adjustable:&n;&n;            drive0      These four arguments can be arrays of       &n;            drive1      1-6 integers as follows:&n;            drive2&n;            drive3      &lt;prt&gt;,&lt;pro&gt;,&lt;uni&gt;,&lt;mod&gt;,&lt;slv&gt;,&lt;dly&gt;&n;&n;                        Where,&n;&n;                &lt;prt&gt;   is the base of the parallel port address for&n;                        the corresponding drive.  (required)&n;&n;                &lt;pro&gt;   is the protocol number for the adapter that&n;                        supports this drive.  These numbers are&n;                        logged by &squot;paride&squot; when the protocol modules&n;                        are initialised.  (0 if not given)&n;&n;                &lt;uni&gt;   for those adapters that support chained&n;                        devices, this is the unit selector for the&n;                        chain of devices on the given port.  It should&n;                        be zero for devices that don&squot;t support chaining.&n;                        (0 if not given)&n;&n;                &lt;mod&gt;   this can be -1 to choose the best mode, or one&n;                        of the mode numbers supported by the adapter.&n;                        (-1 if not given)&n;&n;                &lt;slv&gt;   ATAPI devices can be jumpered to master or slave.&n;                        Set this to 0 to choose the master drive, 1 to&n;                        choose the slave, -1 (the default) to choose the&n;                        first drive found.&n;&n;                &lt;dly&gt;   some parallel ports require the driver to &n;                        go more slowly.  -1 sets a default value that&n;                        should work with the chosen protocol.  Otherwise,&n;                        set this to a small integer, the larger it is&n;                        the slower the port i/o.  In some cases, setting&n;                        this to zero will speed up the device. (default -1)&n;&n;&t;    major&t;You may use this parameter to overide the&n;&t;&t;&t;default major number (96) that this driver&n;&t;&t;&t;will use.  Be sure to change the device&n;&t;&t;&t;name as well.&n;&n;&t;    name&t;This parameter is a character string that&n;&t;&t;&t;contains the name the kernel will use for this&n;&t;&t;&t;device (in /proc output, for instance).&n;&t;&t;&t;(default &quot;pt&quot;).&n;&n;            verbose     This parameter controls the amount of logging&n;                        that the driver will do.  Set it to 0 for&n;                        normal operation, 1 to see autoprobe progress&n;                        messages, or 2 to see additional debugging&n;                        output.  (default 0)&n; &n;        If this driver is built into the kernel, you can use &n;        the following command line parameters, with the same values&n;        as the corresponding module parameters listed above:&n;&n;            pt.drive0&n;            pt.drive1&n;            pt.drive2&n;            pt.drive3&n;&n;        In addition, you can use the parameter pt.disable to disable&n;        the driver entirely.&n;&n;*/
multiline_comment|/*   Changes:&n;&n;&t;1.01&t;GRG 1998.05.06&t;Round up transfer size, fix ready_wait,&n;&t;&t;&t;        loosed interpretation of ATAPI standard&n;&t;&t;&t;&t;for clearing error status.&n;&t;&t;&t;&t;Eliminate sti();&n;&t;1.02    GRG 1998.06.16  Eliminate an Ugh.&n;&t;1.03    GRG 1998.08.15  Adjusted PT_TMO, use HZ in loop timing,&n;&t;&t;&t;&t;extra debugging&n;&t;1.04    GRG 1998.09.24  Repair minor coding error, added jumbo support&n;&t;&n;*/
DECL|macro|PT_VERSION
mdefine_line|#define PT_VERSION      &quot;1.04&quot;
DECL|macro|PT_MAJOR
mdefine_line|#define PT_MAJOR&t;96
DECL|macro|PT_NAME
mdefine_line|#define PT_NAME&t;&t;&quot;pt&quot;
DECL|macro|PT_UNITS
mdefine_line|#define PT_UNITS&t;4
multiline_comment|/* Here are things one can override from the insmod command.&n;   Most are autoprobed by paride unless set here.  Verbose is on&n;   by default.&n;&n;*/
DECL|variable|verbose
r_static
r_int
id|verbose
op_assign
l_int|0
suffix:semicolon
DECL|variable|major
r_static
r_int
id|major
op_assign
id|PT_MAJOR
suffix:semicolon
DECL|variable|name
r_static
r_char
op_star
id|name
op_assign
id|PT_NAME
suffix:semicolon
DECL|variable|disable
r_static
r_int
id|disable
op_assign
l_int|0
suffix:semicolon
DECL|variable|drive0
r_static
r_int
id|drive0
(braket
l_int|6
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|drive1
r_static
r_int
id|drive1
(braket
l_int|6
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|drive2
r_static
r_int
id|drive2
(braket
l_int|6
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|drive3
r_static
r_int
id|drive3
(braket
l_int|6
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|drives
r_static
r_int
(paren
op_star
id|drives
(braket
l_int|4
)braket
)paren
(braket
l_int|6
)braket
op_assign
(brace
op_amp
id|drive0
comma
op_amp
id|drive1
comma
op_amp
id|drive2
comma
op_amp
id|drive3
)brace
suffix:semicolon
DECL|variable|pt_drive_count
r_static
r_int
id|pt_drive_count
suffix:semicolon
DECL|macro|D_PRT
mdefine_line|#define D_PRT   0
DECL|macro|D_PRO
mdefine_line|#define D_PRO   1
DECL|macro|D_UNI
mdefine_line|#define D_UNI   2
DECL|macro|D_MOD
mdefine_line|#define D_MOD   3
DECL|macro|D_SLV
mdefine_line|#define D_SLV   4
DECL|macro|D_DLY
mdefine_line|#define D_DLY   5
DECL|macro|DU
mdefine_line|#define DU              (*drives[unit])
multiline_comment|/* end of parameters */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mtio.h&gt;
macro_line|#include &lt;linux/wait.h&gt;
macro_line|#include &lt;linux/smp_lock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifndef MODULE
macro_line|#include &quot;setup.h&quot;
DECL|variable|pt_stt
r_static
id|STT
id|pt_stt
(braket
l_int|5
)braket
op_assign
(brace
(brace
l_string|&quot;drive0&quot;
comma
l_int|6
comma
id|drive0
)brace
comma
(brace
l_string|&quot;drive1&quot;
comma
l_int|6
comma
id|drive1
)brace
comma
(brace
l_string|&quot;drive2&quot;
comma
l_int|6
comma
id|drive2
)brace
comma
(brace
l_string|&quot;drive3&quot;
comma
l_int|6
comma
id|drive3
)brace
comma
(brace
l_string|&quot;disable&quot;
comma
l_int|1
comma
op_amp
id|disable
)brace
)brace
suffix:semicolon
DECL|function|pt_setup
r_void
id|pt_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|generic_setup
c_func
(paren
id|pt_stt
comma
l_int|5
comma
id|str
)paren
suffix:semicolon
)brace
macro_line|#endif
id|MODULE_PARM
c_func
(paren
id|verbose
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|major
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|name
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|drive0
comma
l_string|&quot;1-6i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|drive1
comma
l_string|&quot;1-6i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|drive2
comma
l_string|&quot;1-6i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|drive3
comma
l_string|&quot;1-6i&quot;
)paren
suffix:semicolon
macro_line|#include &quot;paride.h&quot;
DECL|macro|PT_MAX_RETRIES
mdefine_line|#define PT_MAX_RETRIES  5
DECL|macro|PT_TMO
mdefine_line|#define PT_TMO          3000            /* interrupt timeout in jiffies */
DECL|macro|PT_SPIN_DEL
mdefine_line|#define PT_SPIN_DEL     50              /* spin delay in micro-seconds  */
DECL|macro|PT_RESET_TMO
mdefine_line|#define PT_RESET_TMO    30&t;&t;/* 30 seconds */
DECL|macro|PT_READY_TMO
mdefine_line|#define PT_READY_TMO&t;60&t;&t;/* 60 seconds */
DECL|macro|PT_REWIND_TMO
mdefine_line|#define PT_REWIND_TMO&t;1200&t;&t;/* 20 minutes */
DECL|macro|PT_SPIN
mdefine_line|#define PT_SPIN         ((1000000/(HZ*PT_SPIN_DEL))*PT_TMO)  
DECL|macro|STAT_ERR
mdefine_line|#define STAT_ERR        0x00001
DECL|macro|STAT_INDEX
mdefine_line|#define STAT_INDEX      0x00002
DECL|macro|STAT_ECC
mdefine_line|#define STAT_ECC        0x00004
DECL|macro|STAT_DRQ
mdefine_line|#define STAT_DRQ        0x00008
DECL|macro|STAT_SEEK
mdefine_line|#define STAT_SEEK       0x00010
DECL|macro|STAT_WRERR
mdefine_line|#define STAT_WRERR      0x00020
DECL|macro|STAT_READY
mdefine_line|#define STAT_READY      0x00040
DECL|macro|STAT_BUSY
mdefine_line|#define STAT_BUSY       0x00080
DECL|macro|STAT_SENSE
mdefine_line|#define STAT_SENSE&t;0x1f000
DECL|macro|ATAPI_TEST_READY
mdefine_line|#define ATAPI_TEST_READY&t;0x00
DECL|macro|ATAPI_REWIND
mdefine_line|#define ATAPI_REWIND&t;&t;0x01
DECL|macro|ATAPI_REQ_SENSE
mdefine_line|#define ATAPI_REQ_SENSE&t;&t;0x03
DECL|macro|ATAPI_READ_6
mdefine_line|#define ATAPI_READ_6&t;&t;0x08
DECL|macro|ATAPI_WRITE_6
mdefine_line|#define ATAPI_WRITE_6&t;&t;0x0a
DECL|macro|ATAPI_WFM
mdefine_line|#define ATAPI_WFM&t;&t;0x10
DECL|macro|ATAPI_IDENTIFY
mdefine_line|#define ATAPI_IDENTIFY&t;&t;0x12
DECL|macro|ATAPI_MODE_SENSE
mdefine_line|#define ATAPI_MODE_SENSE&t;0x1a
DECL|macro|ATAPI_LOG_SENSE
mdefine_line|#define ATAPI_LOG_SENSE&t;&t;0x4d
r_int
id|pt_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|pt_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|pt_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|pt_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
id|ssize_t
id|pt_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
id|ssize_t
id|pt_write
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
suffix:semicolon
r_static
r_int
id|pt_detect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|pt_identify
(paren
r_int
id|unit
)paren
suffix:semicolon
multiline_comment|/* bits in PT.flags */
DECL|macro|PT_MEDIA
mdefine_line|#define PT_MEDIA&t;1
DECL|macro|PT_WRITE_OK
mdefine_line|#define PT_WRITE_OK&t;2
DECL|macro|PT_REWIND
mdefine_line|#define PT_REWIND&t;4
DECL|macro|PT_WRITING
mdefine_line|#define PT_WRITING      8
DECL|macro|PT_READING
mdefine_line|#define PT_READING     16
DECL|macro|PT_EOF
mdefine_line|#define PT_EOF&t;       32
DECL|macro|PT_NAMELEN
mdefine_line|#define PT_NAMELEN      8
DECL|macro|PT_BUFSIZE
mdefine_line|#define PT_BUFSIZE  16384
DECL|struct|pt_unit
r_struct
id|pt_unit
(brace
DECL|member|pia
r_struct
id|pi_adapter
id|pia
suffix:semicolon
multiline_comment|/* interface to paride layer */
DECL|member|pi
r_struct
id|pi_adapter
op_star
id|pi
suffix:semicolon
DECL|member|flags
r_int
id|flags
suffix:semicolon
multiline_comment|/* various state flags */
DECL|member|last_sense
r_int
id|last_sense
suffix:semicolon
multiline_comment|/* result of last request sense */
DECL|member|drive
r_int
id|drive
suffix:semicolon
multiline_comment|/* drive */
DECL|member|access
r_int
id|access
suffix:semicolon
multiline_comment|/* count of active opens ... */
DECL|member|bs
r_int
id|bs
suffix:semicolon
multiline_comment|/* block size */
DECL|member|capacity
r_int
id|capacity
suffix:semicolon
multiline_comment|/* Size of tape in KB */
DECL|member|present
r_int
id|present
suffix:semicolon
multiline_comment|/* device present ? */
DECL|member|bufptr
r_char
op_star
id|bufptr
suffix:semicolon
DECL|member|name
r_char
id|name
(braket
id|PT_NAMELEN
)braket
suffix:semicolon
multiline_comment|/* pf0, pf1, ... */
)brace
suffix:semicolon
DECL|variable|pt
r_struct
id|pt_unit
id|pt
(braket
id|PT_UNITS
)braket
suffix:semicolon
multiline_comment|/*  &squot;unit&squot; must be defined in all functions - either as a local or a param */
DECL|macro|PT
mdefine_line|#define PT pt[unit]
DECL|macro|PI
mdefine_line|#define PI PT.pi
DECL|variable|pt_scratch
r_static
r_char
id|pt_scratch
(braket
l_int|512
)braket
suffix:semicolon
multiline_comment|/* scratch block buffer */
multiline_comment|/* kernel glue structures */
DECL|variable|pt_fops
r_static
r_struct
id|file_operations
id|pt_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|read
suffix:colon
id|pt_read
comma
id|write
suffix:colon
id|pt_write
comma
id|ioctl
suffix:colon
id|pt_ioctl
comma
id|open
suffix:colon
id|pt_open
comma
id|release
suffix:colon
id|pt_release
comma
)brace
suffix:semicolon
DECL|function|pt_init_units
r_void
id|pt_init_units
c_func
(paren
r_void
)paren
(brace
r_int
id|unit
comma
id|j
suffix:semicolon
id|pt_drive_count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|PT_UNITS
suffix:semicolon
id|unit
op_increment
)paren
(brace
id|PT.pi
op_assign
op_amp
id|PT.pia
suffix:semicolon
id|PT.access
op_assign
l_int|0
suffix:semicolon
id|PT.flags
op_assign
l_int|0
suffix:semicolon
id|PT.last_sense
op_assign
l_int|0
suffix:semicolon
id|PT.present
op_assign
l_int|0
suffix:semicolon
id|PT.bufptr
op_assign
l_int|NULL
suffix:semicolon
id|PT.drive
op_assign
id|DU
(braket
id|D_SLV
)braket
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|j
OL
id|PT_NAMELEN
op_minus
l_int|2
)paren
op_logical_and
(paren
id|PT.name
(braket
id|j
)braket
op_assign
id|name
(braket
id|j
)braket
)paren
)paren
id|j
op_increment
suffix:semicolon
id|PT.name
(braket
id|j
op_increment
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|unit
suffix:semicolon
id|PT.name
(braket
id|j
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|DU
(braket
id|D_PRT
)braket
)paren
id|pt_drive_count
op_increment
suffix:semicolon
)brace
)brace
DECL|variable|devfs_handle
r_static
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
DECL|function|pt_init
r_int
id|pt_init
(paren
r_void
)paren
multiline_comment|/* preliminary initialisation */
(brace
r_int
id|unit
suffix:semicolon
r_if
c_cond
(paren
id|disable
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|pt_init_units
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pt_detect
c_func
(paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|devfs_register_chrdev
c_func
(paren
id|major
comma
id|name
comma
op_amp
id|pt_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pt_init: unable to get major number %d&bslash;n&quot;
comma
id|major
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|PT_UNITS
suffix:semicolon
id|unit
op_increment
)paren
r_if
c_cond
(paren
id|PT.present
)paren
id|pi_release
c_func
(paren
id|PI
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|devfs_handle
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;pt&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register_series
(paren
id|devfs_handle
comma
l_string|&quot;%u&quot;
comma
l_int|4
comma
id|DEVFS_FL_DEFAULT
comma
id|major
comma
l_int|0
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|pt_fops
comma
l_int|NULL
)paren
suffix:semicolon
id|devfs_register_series
(paren
id|devfs_handle
comma
l_string|&quot;%un&quot;
comma
l_int|4
comma
id|DEVFS_FL_DEFAULT
comma
id|major
comma
l_int|128
comma
id|S_IFCHR
op_or
id|S_IRUSR
op_or
id|S_IWUSR
comma
op_amp
id|pt_fops
comma
l_int|NULL
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/* Glue for modules ... */
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
macro_line|#ifdef PARIDE_JUMBO
(brace
r_extern
id|paride_init
c_func
(paren
)paren
suffix:semicolon
id|paride_init
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|err
op_assign
id|pt_init
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|unit
suffix:semicolon
id|devfs_unregister
(paren
id|devfs_handle
)paren
suffix:semicolon
id|devfs_unregister_chrdev
c_func
(paren
id|major
comma
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|PT_UNITS
suffix:semicolon
id|unit
op_increment
)paren
r_if
c_cond
(paren
id|PT.present
)paren
id|pi_release
c_func
(paren
id|PI
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|WR
mdefine_line|#define&t;WR(c,r,v)&t;pi_write_regr(PI,c,r,v)
DECL|macro|RR
mdefine_line|#define&t;RR(c,r)&t;&t;(pi_read_regr(PI,c,r))
DECL|macro|DRIVE
mdefine_line|#define DRIVE           (0xa0+0x10*PT.drive)
DECL|function|pt_wait
r_static
r_int
id|pt_wait
c_func
(paren
r_int
id|unit
comma
r_int
id|go
comma
r_int
id|stop
comma
r_char
op_star
id|fun
comma
r_char
op_star
id|msg
)paren
(brace
r_int
id|j
comma
id|r
comma
id|e
comma
id|s
comma
id|p
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
(paren
id|r
op_assign
id|RR
c_func
(paren
l_int|1
comma
l_int|6
)paren
)paren
op_amp
id|go
)paren
op_logical_or
(paren
id|stop
op_logical_and
(paren
op_logical_neg
(paren
id|r
op_amp
id|stop
)paren
)paren
)paren
)paren
op_logical_and
(paren
id|j
op_increment
OL
id|PT_SPIN
)paren
)paren
id|udelay
c_func
(paren
id|PT_SPIN_DEL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
(paren
id|STAT_ERR
op_amp
id|stop
)paren
)paren
op_logical_or
(paren
id|j
op_ge
id|PT_SPIN
)paren
)paren
(brace
id|s
op_assign
id|RR
c_func
(paren
l_int|0
comma
l_int|7
)paren
suffix:semicolon
id|e
op_assign
id|RR
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|p
op_assign
id|RR
c_func
(paren
l_int|0
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
op_ge
id|PT_SPIN
)paren
id|e
op_or_assign
l_int|0x100
suffix:semicolon
r_if
c_cond
(paren
id|fun
)paren
id|printk
c_func
(paren
l_string|&quot;%s: %s %s: alt=0x%x stat=0x%x err=0x%x&quot;
l_string|&quot; loop=%d phase=%d&bslash;n&quot;
comma
id|PT.name
comma
id|fun
comma
id|msg
comma
id|r
comma
id|s
comma
id|e
comma
id|j
comma
id|p
)paren
suffix:semicolon
r_return
(paren
id|e
op_lshift
l_int|8
)paren
op_plus
id|s
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pt_command
r_static
r_int
id|pt_command
c_func
(paren
r_int
id|unit
comma
r_char
op_star
id|cmd
comma
r_int
id|dlen
comma
r_char
op_star
id|fun
)paren
(brace
id|pi_connect
c_func
(paren
id|PI
)paren
suffix:semicolon
id|WR
c_func
(paren
l_int|0
comma
l_int|6
comma
id|DRIVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pt_wait
c_func
(paren
id|unit
comma
id|STAT_BUSY
op_or
id|STAT_DRQ
comma
l_int|0
comma
id|fun
comma
l_string|&quot;before command&quot;
)paren
)paren
(brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|WR
c_func
(paren
l_int|0
comma
l_int|4
comma
id|dlen
op_mod
l_int|256
)paren
suffix:semicolon
id|WR
c_func
(paren
l_int|0
comma
l_int|5
comma
id|dlen
op_div
l_int|256
)paren
suffix:semicolon
id|WR
c_func
(paren
l_int|0
comma
l_int|7
comma
l_int|0xa0
)paren
suffix:semicolon
multiline_comment|/* ATAPI packet command */
r_if
c_cond
(paren
id|pt_wait
c_func
(paren
id|unit
comma
id|STAT_BUSY
comma
id|STAT_DRQ
comma
id|fun
comma
l_string|&quot;command DRQ&quot;
)paren
)paren
(brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|RR
c_func
(paren
l_int|0
comma
l_int|2
)paren
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s: command phase error&bslash;n&quot;
comma
id|PT.name
comma
id|fun
)paren
suffix:semicolon
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|pi_write_block
c_func
(paren
id|PI
comma
id|cmd
comma
l_int|12
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pt_completion
r_static
r_int
id|pt_completion
c_func
(paren
r_int
id|unit
comma
r_char
op_star
id|buf
comma
r_char
op_star
id|fun
)paren
(brace
r_int
id|r
comma
id|s
comma
id|n
comma
id|p
suffix:semicolon
id|r
op_assign
id|pt_wait
c_func
(paren
id|unit
comma
id|STAT_BUSY
comma
id|STAT_DRQ
op_or
id|STAT_READY
op_or
id|STAT_ERR
comma
id|fun
comma
l_string|&quot;completion&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|RR
c_func
(paren
l_int|0
comma
l_int|7
)paren
op_amp
id|STAT_DRQ
)paren
(brace
id|n
op_assign
(paren
(paren
(paren
id|RR
c_func
(paren
l_int|0
comma
l_int|4
)paren
op_plus
l_int|256
op_star
id|RR
c_func
(paren
l_int|0
comma
l_int|5
)paren
)paren
op_plus
l_int|3
)paren
op_amp
l_int|0xfffc
)paren
suffix:semicolon
id|p
op_assign
id|RR
c_func
(paren
l_int|0
comma
l_int|2
)paren
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|0
)paren
id|pi_write_block
c_func
(paren
id|PI
comma
id|buf
comma
id|n
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|2
)paren
id|pi_read_block
c_func
(paren
id|PI
comma
id|buf
comma
id|n
)paren
suffix:semicolon
)brace
id|s
op_assign
id|pt_wait
c_func
(paren
id|unit
comma
id|STAT_BUSY
comma
id|STAT_READY
op_or
id|STAT_ERR
comma
id|fun
comma
l_string|&quot;data done&quot;
)paren
suffix:semicolon
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_return
(paren
id|r
ques
c_cond
id|r
suffix:colon
id|s
)paren
suffix:semicolon
)brace
DECL|function|pt_req_sense
r_static
r_void
id|pt_req_sense
c_func
(paren
r_int
id|unit
comma
r_int
id|quiet
)paren
(brace
r_char
id|rs_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_REQ_SENSE
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|16
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_char
id|buf
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|r
suffix:semicolon
id|r
op_assign
id|pt_command
c_func
(paren
id|unit
comma
id|rs_cmd
comma
l_int|16
comma
l_string|&quot;Request sense&quot;
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
id|pt_completion
c_func
(paren
id|unit
comma
id|buf
comma
l_string|&quot;Request sense&quot;
)paren
suffix:semicolon
id|PT.last_sense
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|quiet
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Sense key: %x, ASC: %x, ASQ: %x&bslash;n&quot;
comma
id|PT.name
comma
id|buf
(braket
l_int|2
)braket
op_amp
l_int|0xf
comma
id|buf
(braket
l_int|12
)braket
comma
id|buf
(braket
l_int|13
)braket
)paren
suffix:semicolon
id|PT.last_sense
op_assign
(paren
id|buf
(braket
l_int|2
)braket
op_amp
l_int|0xf
)paren
op_or
(paren
(paren
id|buf
(braket
l_int|12
)braket
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
)paren
op_or
(paren
(paren
id|buf
(braket
l_int|13
)braket
op_amp
l_int|0xff
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
)brace
)brace
DECL|function|pt_atapi
r_static
r_int
id|pt_atapi
c_func
(paren
r_int
id|unit
comma
r_char
op_star
id|cmd
comma
r_int
id|dlen
comma
r_char
op_star
id|buf
comma
r_char
op_star
id|fun
)paren
(brace
r_int
id|r
suffix:semicolon
id|r
op_assign
id|pt_command
c_func
(paren
id|unit
comma
id|cmd
comma
id|dlen
comma
id|fun
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
id|r
op_assign
id|pt_completion
c_func
(paren
id|unit
comma
id|buf
comma
id|fun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|pt_req_sense
c_func
(paren
id|unit
comma
op_logical_neg
id|fun
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|pt_sleep
r_static
r_void
id|pt_sleep
c_func
(paren
r_int
id|cs
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|cs
)paren
suffix:semicolon
)brace
DECL|function|pt_poll_dsc
r_static
r_int
id|pt_poll_dsc
c_func
(paren
r_int
id|unit
comma
r_int
id|pause
comma
r_int
id|tmo
comma
r_char
op_star
id|msg
)paren
(brace
r_int
id|k
comma
id|e
comma
id|s
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
id|e
op_assign
l_int|0
suffix:semicolon
id|s
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|k
OL
id|tmo
)paren
(brace
id|pt_sleep
c_func
(paren
id|pause
)paren
suffix:semicolon
id|k
op_increment
suffix:semicolon
id|pi_connect
c_func
(paren
id|PI
)paren
suffix:semicolon
id|WR
c_func
(paren
l_int|0
comma
l_int|6
comma
id|DRIVE
)paren
suffix:semicolon
id|s
op_assign
id|RR
c_func
(paren
l_int|0
comma
l_int|7
)paren
suffix:semicolon
id|e
op_assign
id|RR
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
op_amp
(paren
id|STAT_ERR
op_or
id|STAT_SEEK
)paren
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|k
op_ge
id|tmo
)paren
op_logical_or
(paren
id|s
op_amp
id|STAT_ERR
)paren
)paren
(brace
r_if
c_cond
(paren
id|k
op_ge
id|tmo
)paren
id|printk
c_func
(paren
l_string|&quot;%s: %s DSC timeout&bslash;n&quot;
comma
id|PT.name
comma
id|msg
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%s: %s stat=0x%x err=0x%x&bslash;n&quot;
comma
id|PT.name
comma
id|msg
comma
id|s
comma
id|e
)paren
suffix:semicolon
id|pt_req_sense
c_func
(paren
id|unit
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|pt_media_access_cmd
r_static
r_void
id|pt_media_access_cmd
c_func
(paren
r_int
id|unit
comma
r_int
id|tmo
comma
r_char
op_star
id|cmd
comma
r_char
op_star
id|fun
)paren
(brace
r_if
c_cond
(paren
id|pt_command
c_func
(paren
id|unit
comma
id|cmd
comma
l_int|0
comma
id|fun
)paren
)paren
(brace
id|pt_req_sense
c_func
(paren
id|unit
comma
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
id|pt_poll_dsc
c_func
(paren
id|unit
comma
id|HZ
comma
id|tmo
comma
id|fun
)paren
suffix:semicolon
)brace
DECL|function|pt_rewind
r_static
r_void
id|pt_rewind
c_func
(paren
r_int
id|unit
)paren
(brace
r_char
id|rw_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_REWIND
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|pt_media_access_cmd
c_func
(paren
id|unit
comma
id|PT_REWIND_TMO
comma
id|rw_cmd
comma
l_string|&quot;rewind&quot;
)paren
suffix:semicolon
)brace
DECL|function|pt_write_fm
r_static
r_void
id|pt_write_fm
c_func
(paren
r_int
id|unit
)paren
(brace
r_char
id|wm_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_WFM
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|pt_media_access_cmd
c_func
(paren
id|unit
comma
id|PT_TMO
comma
id|wm_cmd
comma
l_string|&quot;write filemark&quot;
)paren
suffix:semicolon
)brace
DECL|macro|DBMSG
mdefine_line|#define DBMSG(msg)      ((verbose&gt;1)?(msg):NULL)
DECL|function|pt_reset
r_static
r_int
id|pt_reset
c_func
(paren
r_int
id|unit
)paren
(brace
r_int
id|i
comma
id|k
comma
id|flg
suffix:semicolon
r_int
id|expect
(braket
l_int|5
)braket
op_assign
(brace
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0x14
comma
l_int|0xeb
)brace
suffix:semicolon
id|pi_connect
c_func
(paren
id|PI
)paren
suffix:semicolon
id|WR
c_func
(paren
l_int|0
comma
l_int|6
comma
id|DRIVE
)paren
suffix:semicolon
id|WR
c_func
(paren
l_int|0
comma
l_int|7
comma
l_int|8
)paren
suffix:semicolon
id|pt_sleep
c_func
(paren
l_int|20
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|k
op_increment
OL
id|PT_RESET_TMO
)paren
op_logical_and
(paren
id|RR
c_func
(paren
l_int|1
comma
l_int|6
)paren
op_amp
id|STAT_BUSY
)paren
)paren
id|pt_sleep
c_func
(paren
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
id|flg
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|flg
op_and_assign
(paren
id|RR
c_func
(paren
l_int|0
comma
id|i
op_plus
l_int|1
)paren
op_eq
id|expect
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verbose
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Reset (%d) signature = &quot;
comma
id|PT.name
comma
id|k
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%3x&quot;
comma
id|RR
c_func
(paren
l_int|0
comma
id|i
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flg
)paren
id|printk
c_func
(paren
l_string|&quot; (incorrect)&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_return
id|flg
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|pt_ready_wait
r_static
r_int
id|pt_ready_wait
c_func
(paren
r_int
id|unit
comma
r_int
id|tmo
)paren
(brace
r_char
id|tr_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_TEST_READY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|k
comma
id|p
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|k
OL
id|tmo
)paren
(brace
id|PT.last_sense
op_assign
l_int|0
suffix:semicolon
id|pt_atapi
c_func
(paren
id|unit
comma
id|tr_cmd
comma
l_int|0
comma
l_int|NULL
comma
id|DBMSG
c_func
(paren
l_string|&quot;test unit ready&quot;
)paren
)paren
suffix:semicolon
id|p
op_assign
id|PT.last_sense
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|p
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
(paren
(paren
id|p
op_amp
l_int|0xffff
)paren
op_eq
l_int|0x0402
)paren
op_logical_or
(paren
(paren
id|p
op_amp
l_int|0xff
)paren
op_eq
l_int|6
)paren
)paren
)paren
r_return
id|p
suffix:semicolon
id|k
op_increment
suffix:semicolon
id|pt_sleep
c_func
(paren
id|HZ
)paren
suffix:semicolon
)brace
r_return
l_int|0x000020
suffix:semicolon
multiline_comment|/* timeout */
)brace
DECL|function|xs
r_static
r_void
id|xs
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
id|targ
comma
r_int
id|offs
comma
r_int
id|len
)paren
(brace
r_int
id|j
comma
id|k
comma
id|l
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
id|l
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|len
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
(paren
id|buf
(braket
id|k
op_plus
id|offs
)braket
op_ne
l_int|0x20
)paren
op_logical_or
(paren
id|buf
(braket
id|k
op_plus
id|offs
)braket
op_ne
id|l
)paren
)paren
(brace
id|l
op_assign
id|targ
(braket
id|j
op_increment
)braket
op_assign
id|buf
(braket
id|k
op_plus
id|offs
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|l
op_eq
l_int|0x20
)paren
id|j
op_decrement
suffix:semicolon
id|targ
(braket
id|j
)braket
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|xn
r_static
r_int
id|xn
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|offs
comma
r_int
id|size
)paren
(brace
r_int
id|v
comma
id|k
suffix:semicolon
id|v
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|size
suffix:semicolon
id|k
op_increment
)paren
(brace
id|v
op_assign
id|v
op_star
l_int|256
op_plus
(paren
id|buf
(braket
id|k
op_plus
id|offs
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
r_return
id|v
suffix:semicolon
)brace
DECL|function|pt_identify
r_static
r_int
id|pt_identify
c_func
(paren
r_int
id|unit
)paren
(brace
r_int
id|dt
comma
id|s
suffix:semicolon
r_char
op_star
id|ms
(braket
l_int|2
)braket
op_assign
(brace
l_string|&quot;master&quot;
comma
l_string|&quot;slave&quot;
)brace
suffix:semicolon
r_char
id|mf
(braket
l_int|10
)braket
comma
id|id
(braket
l_int|18
)braket
suffix:semicolon
r_char
id|id_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_IDENTIFY
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|36
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_char
id|ms_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_MODE_SENSE
comma
l_int|0
comma
l_int|0x2a
comma
l_int|0
comma
l_int|36
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_char
id|ls_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_LOG_SENSE
comma
l_int|0
comma
l_int|0x71
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|36
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_char
id|buf
(braket
l_int|36
)braket
suffix:semicolon
id|s
op_assign
id|pt_atapi
c_func
(paren
id|unit
comma
id|id_cmd
comma
l_int|36
comma
id|buf
comma
l_string|&quot;identify&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|dt
op_assign
id|buf
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
r_if
c_cond
(paren
id|dt
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|verbose
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Drive %d, unsupported type %d&bslash;n&quot;
comma
id|PT.name
comma
id|PT.drive
comma
id|dt
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|xs
c_func
(paren
id|buf
comma
id|mf
comma
l_int|8
comma
l_int|8
)paren
suffix:semicolon
id|xs
c_func
(paren
id|buf
comma
id|id
comma
l_int|16
comma
l_int|16
)paren
suffix:semicolon
id|PT.flags
op_assign
l_int|0
suffix:semicolon
id|PT.capacity
op_assign
l_int|0
suffix:semicolon
id|PT.bs
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pt_ready_wait
c_func
(paren
id|unit
comma
id|PT_READY_TMO
)paren
)paren
id|PT.flags
op_or_assign
id|PT_MEDIA
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pt_atapi
c_func
(paren
id|unit
comma
id|ms_cmd
comma
l_int|36
comma
id|buf
comma
l_string|&quot;mode sense&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|buf
(braket
l_int|2
)braket
op_amp
l_int|0x80
)paren
)paren
id|PT.flags
op_or_assign
id|PT_WRITE_OK
suffix:semicolon
id|PT.bs
op_assign
id|xn
c_func
(paren
id|buf
comma
l_int|10
comma
l_int|2
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pt_atapi
c_func
(paren
id|unit
comma
id|ls_cmd
comma
l_int|36
comma
id|buf
comma
l_string|&quot;log sense&quot;
)paren
)paren
id|PT.capacity
op_assign
id|xn
c_func
(paren
id|buf
comma
l_int|24
comma
l_int|4
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s %s, %s&quot;
comma
id|PT.name
comma
id|mf
comma
id|id
comma
id|ms
(braket
id|PT.drive
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|PT.flags
op_amp
id|PT_MEDIA
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;, no media&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|PT.flags
op_amp
id|PT_WRITE_OK
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;, RO&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, blocksize %d, %d MB&bslash;n&quot;
comma
id|PT.bs
comma
id|PT.capacity
op_div
l_int|1024
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pt_probe
r_static
r_int
id|pt_probe
c_func
(paren
r_int
id|unit
)paren
multiline_comment|/*&t;returns  0, with id set if drive is detected&n;&t;        -1, if drive detection failed&n;*/
(brace
r_if
c_cond
(paren
id|PT.drive
op_eq
op_minus
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|PT.drive
op_assign
l_int|0
suffix:semicolon
id|PT.drive
op_le
l_int|1
suffix:semicolon
id|PT.drive
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|pt_reset
c_func
(paren
id|unit
)paren
)paren
r_return
id|pt_identify
c_func
(paren
id|unit
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|pt_reset
c_func
(paren
id|unit
)paren
)paren
r_return
id|pt_identify
c_func
(paren
id|unit
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|pt_detect
r_static
r_int
id|pt_detect
c_func
(paren
r_void
)paren
(brace
r_int
id|k
comma
id|unit
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s version %s, major %d&bslash;n&quot;
comma
id|name
comma
id|name
comma
id|PT_VERSION
comma
id|major
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pt_drive_count
op_eq
l_int|0
)paren
(brace
id|unit
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pi_init
c_func
(paren
id|PI
comma
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|pt_scratch
comma
id|PI_PT
comma
id|verbose
comma
id|PT.name
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pt_probe
c_func
(paren
id|unit
)paren
)paren
(brace
id|PT.present
op_assign
l_int|1
suffix:semicolon
id|k
op_increment
suffix:semicolon
)brace
r_else
id|pi_release
c_func
(paren
id|PI
)paren
suffix:semicolon
)brace
)brace
r_else
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|PT_UNITS
suffix:semicolon
id|unit
op_increment
)paren
r_if
c_cond
(paren
id|DU
(braket
id|D_PRT
)braket
)paren
r_if
c_cond
(paren
id|pi_init
c_func
(paren
id|PI
comma
l_int|0
comma
id|DU
(braket
id|D_PRT
)braket
comma
id|DU
(braket
id|D_MOD
)braket
comma
id|DU
(braket
id|D_UNI
)braket
comma
id|DU
(braket
id|D_PRO
)braket
comma
id|DU
(braket
id|D_DLY
)braket
comma
id|pt_scratch
comma
id|PI_PT
comma
id|verbose
comma
id|PT.name
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pt_probe
c_func
(paren
id|unit
)paren
)paren
(brace
id|PT.present
op_assign
l_int|1
suffix:semicolon
id|k
op_increment
suffix:semicolon
)brace
r_else
id|pi_release
c_func
(paren
id|PI
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: No ATAPI tape drive detected&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|macro|DEVICE_NR
mdefine_line|#define DEVICE_NR(dev)&t;(MINOR(dev) % 128)
DECL|function|pt_open
r_static
r_int
id|pt_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|unit
op_assign
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|unit
op_ge
id|PT_UNITS
)paren
op_logical_or
(paren
op_logical_neg
id|PT.present
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|PT.access
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PT.access
OG
l_int|1
)paren
(brace
id|PT.access
op_decrement
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|pt_identify
c_func
(paren
id|unit
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PT.flags
op_amp
id|PT_MEDIA
)paren
(brace
id|PT.access
op_decrement
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|PT.flags
op_amp
id|PT_WRITE_OK
)paren
op_logical_and
(paren
id|file
op_member_access_from_pointer
id|f_mode
op_amp
l_int|2
)paren
)paren
(brace
id|PT.access
op_decrement
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
l_int|128
)paren
)paren
id|PT.flags
op_or_assign
id|PT_REWIND
suffix:semicolon
id|PT.bufptr
op_assign
id|kmalloc
c_func
(paren
id|PT_BUFSIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PT.bufptr
op_eq
l_int|NULL
)paren
(brace
id|PT.access
op_decrement
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: buffer allocation failed&bslash;n&quot;
comma
id|PT.name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pt_ioctl
r_static
r_int
id|pt_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|unit
suffix:semicolon
r_struct
id|mtop
id|mtop
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|inode
op_logical_or
op_logical_neg
id|inode-&gt;i_rdev
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|unit
op_assign
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit
op_ge
id|PT_UNITS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PT.present
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|MTIOCTOP
suffix:colon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
(paren
r_char
op_star
)paren
op_amp
id|mtop
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|mtop
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_switch
c_cond
(paren
id|mtop.mt_op
)paren
(brace
r_case
id|MTREW
suffix:colon
id|pt_rewind
c_func
(paren
id|unit
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: Unimplemented mt_op %d&bslash;n&quot;
comma
id|PT.name
comma
id|mtop.mt_op
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: Unimplemented ioctl 0x%x&bslash;n&quot;
comma
id|PT.name
comma
id|cmd
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|pt_release
r_static
r_int
id|pt_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|unit
op_assign
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|unit
op_ge
id|PT_UNITS
)paren
op_logical_or
(paren
id|PT.access
op_le
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|lock_kernel
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PT.flags
op_amp
id|PT_WRITING
)paren
id|pt_write_fm
c_func
(paren
id|unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PT.flags
op_amp
id|PT_REWIND
)paren
id|pt_rewind
c_func
(paren
id|unit
)paren
suffix:semicolon
id|PT.access
op_decrement
suffix:semicolon
id|kfree
c_func
(paren
id|PT.bufptr
)paren
suffix:semicolon
id|PT.bufptr
op_assign
l_int|NULL
suffix:semicolon
id|unlock_kernel
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pt_read
r_static
id|ssize_t
id|pt_read
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|inode
op_star
id|ino
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
id|unit
op_assign
id|DEVICE_NR
c_func
(paren
id|ino-&gt;i_rdev
)paren
suffix:semicolon
r_char
id|rd_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_READ_6
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|k
comma
id|n
comma
id|r
comma
id|p
comma
id|s
comma
id|t
comma
id|b
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|PT.flags
op_amp
(paren
id|PT_READING
op_or
id|PT_WRITING
)paren
)paren
)paren
(brace
id|PT.flags
op_or_assign
id|PT_READING
suffix:semicolon
r_if
c_cond
(paren
id|pt_atapi
c_func
(paren
id|unit
comma
id|rd_cmd
comma
l_int|0
comma
l_int|NULL
comma
l_string|&quot;start read-ahead&quot;
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PT.flags
op_amp
id|PT_WRITING
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|PT.flags
op_amp
id|PT_EOF
)paren
r_return
l_int|0
suffix:semicolon
id|t
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pt_poll_dsc
c_func
(paren
id|unit
comma
id|HZ
op_div
l_int|100
comma
id|PT_TMO
comma
l_string|&quot;read&quot;
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|n
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|32768
)paren
id|n
op_assign
l_int|32768
suffix:semicolon
multiline_comment|/* max per command */
id|b
op_assign
(paren
id|n
op_minus
l_int|1
op_plus
id|PT.bs
)paren
op_div
id|PT.bs
suffix:semicolon
id|n
op_assign
id|b
op_star
id|PT.bs
suffix:semicolon
multiline_comment|/* rounded up to even block */
id|rd_cmd
(braket
l_int|4
)braket
op_assign
id|b
suffix:semicolon
id|r
op_assign
id|pt_command
c_func
(paren
id|unit
comma
id|rd_cmd
comma
id|n
comma
l_string|&quot;read&quot;
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
id|pt_req_sense
c_func
(paren
id|unit
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|r
op_assign
id|pt_wait
c_func
(paren
id|unit
comma
id|STAT_BUSY
comma
id|STAT_DRQ
op_or
id|STAT_ERR
op_or
id|STAT_READY
comma
id|DBMSG
c_func
(paren
l_string|&quot;read DRQ&quot;
)paren
comma
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_amp
id|STAT_SENSE
)paren
(brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
id|pt_req_sense
c_func
(paren
id|unit
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r
)paren
id|PT.flags
op_or_assign
id|PT_EOF
suffix:semicolon
id|s
op_assign
id|RR
c_func
(paren
l_int|0
comma
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|s
op_amp
id|STAT_DRQ
)paren
)paren
r_break
suffix:semicolon
id|n
op_assign
(paren
id|RR
c_func
(paren
l_int|0
comma
l_int|4
)paren
op_plus
l_int|256
op_star
id|RR
c_func
(paren
l_int|0
comma
l_int|5
)paren
)paren
suffix:semicolon
id|p
op_assign
(paren
id|RR
c_func
(paren
l_int|0
comma
l_int|2
)paren
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ne
l_int|2
)paren
(brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Phase error on read: %d&bslash;n&quot;
comma
id|PT.name
comma
id|p
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_while
c_loop
(paren
id|n
OG
l_int|0
)paren
(brace
id|k
op_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
id|PT_BUFSIZE
)paren
id|k
op_assign
id|PT_BUFSIZE
suffix:semicolon
id|pi_read_block
c_func
(paren
id|PI
comma
id|PT.bufptr
comma
id|k
)paren
suffix:semicolon
id|n
op_sub_assign
id|k
suffix:semicolon
id|b
op_assign
id|k
suffix:semicolon
r_if
c_cond
(paren
id|b
OG
id|count
)paren
id|b
op_assign
id|count
suffix:semicolon
id|copy_to_user
c_func
(paren
id|buf
op_plus
id|t
comma
id|PT.bufptr
comma
id|b
)paren
suffix:semicolon
id|t
op_add_assign
id|b
suffix:semicolon
id|count
op_sub_assign
id|b
suffix:semicolon
)brace
)brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PT.flags
op_amp
id|PT_EOF
)paren
r_break
suffix:semicolon
)brace
r_return
id|t
suffix:semicolon
)brace
DECL|function|pt_write
r_static
id|ssize_t
id|pt_write
c_func
(paren
r_struct
id|file
op_star
id|filp
comma
r_const
r_char
op_star
id|buf
comma
r_int
id|count
comma
id|loff_t
op_star
id|ppos
)paren
(brace
r_struct
id|inode
op_star
id|ino
op_assign
id|filp-&gt;f_dentry-&gt;d_inode
suffix:semicolon
r_int
id|unit
op_assign
id|DEVICE_NR
c_func
(paren
id|ino-&gt;i_rdev
)paren
suffix:semicolon
r_char
id|wr_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_WRITE_6
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|k
comma
id|n
comma
id|r
comma
id|p
comma
id|s
comma
id|t
comma
id|b
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|PT.flags
op_amp
id|PT_WRITE_OK
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|PT.flags
op_amp
(paren
id|PT_READING
op_or
id|PT_WRITING
)paren
)paren
)paren
(brace
id|PT.flags
op_or_assign
id|PT_WRITING
suffix:semicolon
r_if
c_cond
(paren
id|pt_atapi
c_func
(paren
id|unit
comma
id|wr_cmd
comma
l_int|0
comma
l_int|NULL
comma
l_string|&quot;start buffer-available mode&quot;
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|PT.flags
op_amp
id|PT_READING
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|PT.flags
op_amp
id|PT_EOF
)paren
r_return
op_minus
id|ENOSPC
suffix:semicolon
id|t
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|count
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pt_poll_dsc
c_func
(paren
id|unit
comma
id|HZ
op_div
l_int|100
comma
id|PT_TMO
comma
l_string|&quot;write&quot;
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|n
op_assign
id|count
suffix:semicolon
r_if
c_cond
(paren
id|n
OG
l_int|32768
)paren
id|n
op_assign
l_int|32768
suffix:semicolon
multiline_comment|/* max per command */
id|b
op_assign
(paren
id|n
op_minus
l_int|1
op_plus
id|PT.bs
)paren
op_div
id|PT.bs
suffix:semicolon
id|n
op_assign
id|b
op_star
id|PT.bs
suffix:semicolon
multiline_comment|/* rounded up to even block */
id|wr_cmd
(braket
l_int|4
)braket
op_assign
id|b
suffix:semicolon
id|r
op_assign
id|pt_command
c_func
(paren
id|unit
comma
id|wr_cmd
comma
id|n
comma
l_string|&quot;write&quot;
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
(brace
multiline_comment|/* error delivering command only */
id|pt_req_sense
c_func
(paren
id|unit
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|r
op_assign
id|pt_wait
c_func
(paren
id|unit
comma
id|STAT_BUSY
comma
id|STAT_DRQ
op_or
id|STAT_ERR
op_or
id|STAT_READY
comma
id|DBMSG
c_func
(paren
l_string|&quot;write DRQ&quot;
)paren
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_amp
id|STAT_SENSE
)paren
(brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
id|pt_req_sense
c_func
(paren
id|unit
comma
l_int|0
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|r
)paren
id|PT.flags
op_or_assign
id|PT_EOF
suffix:semicolon
id|s
op_assign
id|RR
c_func
(paren
l_int|0
comma
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|s
op_amp
id|STAT_DRQ
)paren
)paren
r_break
suffix:semicolon
id|n
op_assign
(paren
id|RR
c_func
(paren
l_int|0
comma
l_int|4
)paren
op_plus
l_int|256
op_star
id|RR
c_func
(paren
l_int|0
comma
l_int|5
)paren
)paren
suffix:semicolon
id|p
op_assign
(paren
id|RR
c_func
(paren
l_int|0
comma
l_int|2
)paren
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_ne
l_int|0
)paren
(brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: Phase error on write: %d &bslash;n&quot;
comma
id|PT.name
comma
id|p
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_while
c_loop
(paren
id|n
OG
l_int|0
)paren
(brace
id|k
op_assign
id|n
suffix:semicolon
r_if
c_cond
(paren
id|k
OG
id|PT_BUFSIZE
)paren
id|k
op_assign
id|PT_BUFSIZE
suffix:semicolon
id|b
op_assign
id|k
suffix:semicolon
r_if
c_cond
(paren
id|b
OG
id|count
)paren
id|b
op_assign
id|count
suffix:semicolon
id|copy_from_user
c_func
(paren
id|PT.bufptr
comma
id|buf
op_plus
id|t
comma
id|b
)paren
suffix:semicolon
id|pi_write_block
c_func
(paren
id|PI
comma
id|PT.bufptr
comma
id|k
)paren
suffix:semicolon
id|t
op_add_assign
id|b
suffix:semicolon
id|count
op_sub_assign
id|b
suffix:semicolon
id|n
op_sub_assign
id|k
suffix:semicolon
)brace
)brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PT.flags
op_amp
id|PT_EOF
)paren
r_break
suffix:semicolon
)brace
r_return
id|t
suffix:semicolon
)brace
multiline_comment|/* end of pt.c */
eof
