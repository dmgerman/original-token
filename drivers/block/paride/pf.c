multiline_comment|/* &n;        pf.c    (c) 1997-8  Grant R. Guenther &lt;grant@torque.net&gt;&n;                            Under the terms of the GNU public license.&n;&n;        This is the high-level driver for parallel port ATAPI disk&n;        drives based on chips supported by the paride module.&n;&n;        By default, the driver will autoprobe for a single parallel&n;        port ATAPI disk drive, but if their individual parameters are&n;        specified, the driver can handle up to 4 drives.&n;&n;        The behaviour of the pf driver can be altered by setting&n;        some parameters from the insmod command line.  The following&n;        parameters are adjustable:&n;&n;            drive0      These four arguments can be arrays of       &n;            drive1      1-7 integers as follows:&n;            drive2&n;            drive3      &lt;prt&gt;,&lt;pro&gt;,&lt;uni&gt;,&lt;mod&gt;,&lt;slv&gt;,&lt;lun&gt;,&lt;dly&gt;&n;&n;                        Where,&n;&n;                &lt;prt&gt;   is the base of the parallel port address for&n;                        the corresponding drive.  (required)&n;&n;                &lt;pro&gt;   is the protocol number for the adapter that&n;                        supports this drive.  These numbers are&n;                        logged by &squot;paride&squot; when the protocol modules&n;                        are initialised.  (0 if not given)&n;&n;                &lt;uni&gt;   for those adapters that support chained&n;                        devices, this is the unit selector for the&n;                        chain of devices on the given port.  It should&n;                        be zero for devices that don&squot;t support chaining.&n;                        (0 if not given)&n;&n;                &lt;mod&gt;   this can be -1 to choose the best mode, or one&n;                        of the mode numbers supported by the adapter.&n;                        (-1 if not given)&n;&n;                &lt;slv&gt;   ATAPI CDroms can be jumpered to master or slave.&n;                        Set this to 0 to choose the master drive, 1 to&n;                        choose the slave, -1 (the default) to choose the&n;                        first drive found.&n;&n;&t;&t;&lt;lun&gt;   Some ATAPI devices support multiple LUNs.&n;                        One example is the ATAPI PD/CD drive from&n;                        Matshita/Panasonic.  This device has a &n;                        CD drive on LUN 0 and a PD drive on LUN 1.&n;                        By default, the driver will search for the&n;                        first LUN with a supported device.  Set &n;                        this parameter to force it to use a specific&n;                        LUN.  (default -1)&n;&n;                &lt;dly&gt;   some parallel ports require the driver to &n;                        go more slowly.  -1 sets a default value that&n;                        should work with the chosen protocol.  Otherwise,&n;                        set this to a small integer, the larger it is&n;                        the slower the port i/o.  In some cases, setting&n;                        this to zero will speed up the device. (default -1)&n;&n;&t;    major&t;You may use this parameter to overide the&n;&t;&t;&t;default major number (47) that this driver&n;&t;&t;&t;will use.  Be sure to change the device&n;&t;&t;&t;name as well.&n;&n;&t;    name&t;This parameter is a character string that&n;&t;&t;&t;contains the name the kernel will use for this&n;&t;&t;&t;device (in /proc output, for instance).&n;&t;&t;&t;(default &quot;pf&quot;).&n;&n;            cluster     The driver will attempt to aggregate requests&n;                        for adjacent blocks into larger multi-block&n;                        clusters.  The maximum cluster size (in 512&n;                        byte sectors) is set with this parameter.&n;                        (default 64)&n;&n;            verbose     This parameter controls the amount of logging&n;                        that the driver will do.  Set it to 0 for&n;                        normal operation, 1 to see autoprobe progress&n;                        messages, or 2 to see additional debugging&n;                        output.  (default 0)&n; &n;&t;    nice        This parameter controls the driver&squot;s use of&n;&t;&t;&t;idle CPU time, at the expense of some speed.&n;&n;        If this driver is built into the kernel, you can use the&n;        following command line parameters, with the same values&n;        as the corresponding module parameters listed above:&n;&n;            pf.drive0&n;            pf.drive1&n;            pf.drive2&n;            pf.drive3&n;&t;    pf.cluster&n;            pf.nice&n;&n;        In addition, you can use the parameter pf.disable to disable&n;        the driver entirely.&n;&n;*/
multiline_comment|/* Changes:&n;&n;&t;1.01&t;GRG 1998.05.03  Changes for SMP.  Eliminate sti().&n;&t;&t;&t;&t;Fix for drives that don&squot;t clear STAT_ERR&n;&t;&t;&t;        until after next CDB delivered.&n;&t;&t;&t;&t;Small change in pf_completion to round&n;&t;&t;&t;&t;up transfer size.&n;&t;1.02    GRG 1998.06.16  Eliminated an Ugh&n;&t;1.03    GRG 1998.08.16  Use HZ in loop timings, extra debugging&n;&t;1.04    GRG 1998.09.24  Added jumbo support&n;&n;*/
DECL|macro|PF_VERSION
mdefine_line|#define PF_VERSION      &quot;1.04&quot;
DECL|macro|PF_MAJOR
mdefine_line|#define PF_MAJOR&t;47
DECL|macro|PF_NAME
mdefine_line|#define PF_NAME&t;&t;&quot;pf&quot;
DECL|macro|PF_UNITS
mdefine_line|#define PF_UNITS&t;4
multiline_comment|/* Here are things one can override from the insmod command.&n;   Most are autoprobed by paride unless set here.  Verbose is off&n;   by default.&n;&n;*/
DECL|variable|verbose
r_static
r_int
id|verbose
op_assign
l_int|0
suffix:semicolon
DECL|variable|major
r_static
r_int
id|major
op_assign
id|PF_MAJOR
suffix:semicolon
DECL|variable|name
r_static
r_char
op_star
id|name
op_assign
id|PF_NAME
suffix:semicolon
DECL|variable|cluster
r_static
r_int
id|cluster
op_assign
l_int|64
suffix:semicolon
DECL|variable|nice
r_static
r_int
id|nice
op_assign
l_int|0
suffix:semicolon
DECL|variable|disable
r_static
r_int
id|disable
op_assign
l_int|0
suffix:semicolon
DECL|variable|drive0
r_static
r_int
id|drive0
(braket
l_int|7
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|drive1
r_static
r_int
id|drive1
(braket
l_int|7
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|drive2
r_static
r_int
id|drive2
(braket
l_int|7
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|drive3
r_static
r_int
id|drive3
(braket
l_int|7
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
)brace
suffix:semicolon
DECL|variable|drives
r_static
r_int
(paren
op_star
id|drives
(braket
l_int|4
)braket
)paren
(braket
l_int|7
)braket
op_assign
(brace
op_amp
id|drive0
comma
op_amp
id|drive1
comma
op_amp
id|drive2
comma
op_amp
id|drive3
)brace
suffix:semicolon
DECL|variable|pf_drive_count
r_static
r_int
id|pf_drive_count
suffix:semicolon
DECL|macro|D_PRT
mdefine_line|#define D_PRT   0
DECL|macro|D_PRO
mdefine_line|#define D_PRO   1
DECL|macro|D_UNI
mdefine_line|#define D_UNI   2
DECL|macro|D_MOD
mdefine_line|#define D_MOD   3
DECL|macro|D_SLV
mdefine_line|#define D_SLV   4
DECL|macro|D_LUN
mdefine_line|#define D_LUN   5
DECL|macro|D_DLY
mdefine_line|#define D_DLY   6
DECL|macro|DU
mdefine_line|#define DU              (*drives[unit])
multiline_comment|/* end of parameters */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifndef MODULE
macro_line|#include &quot;setup.h&quot;
DECL|variable|pf_stt
r_static
id|STT
id|pf_stt
(braket
l_int|7
)braket
op_assign
(brace
(brace
l_string|&quot;drive0&quot;
comma
l_int|7
comma
id|drive0
)brace
comma
(brace
l_string|&quot;drive1&quot;
comma
l_int|7
comma
id|drive1
)brace
comma
(brace
l_string|&quot;drive2&quot;
comma
l_int|7
comma
id|drive2
)brace
comma
(brace
l_string|&quot;drive3&quot;
comma
l_int|7
comma
id|drive3
)brace
comma
(brace
l_string|&quot;disable&quot;
comma
l_int|1
comma
op_amp
id|disable
)brace
comma
(brace
l_string|&quot;cluster&quot;
comma
l_int|1
comma
op_amp
id|cluster
)brace
comma
(brace
l_string|&quot;nice&quot;
comma
l_int|1
comma
op_amp
id|nice
)brace
)brace
suffix:semicolon
DECL|function|pf_setup
r_void
id|pf_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
id|generic_setup
c_func
(paren
id|pf_stt
comma
l_int|7
comma
id|str
)paren
suffix:semicolon
)brace
macro_line|#endif
id|MODULE_PARM
c_func
(paren
id|verbose
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|major
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|name
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|cluster
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|nice
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|drive0
comma
l_string|&quot;1-7i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|drive1
comma
l_string|&quot;1-7i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|drive2
comma
l_string|&quot;1-7i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|drive3
comma
l_string|&quot;1-7i&quot;
)paren
suffix:semicolon
macro_line|#include &quot;paride.h&quot;
multiline_comment|/* set up defines for blk.h,  why don&squot;t all drivers do it this way ? */
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR   major
DECL|macro|DEVICE_NAME
mdefine_line|#define DEVICE_NAME &quot;PF&quot;
DECL|macro|DEVICE_REQUEST
mdefine_line|#define DEVICE_REQUEST do_pf_request
DECL|macro|DEVICE_NR
mdefine_line|#define DEVICE_NR(device) MINOR(device)
DECL|macro|DEVICE_ON
mdefine_line|#define DEVICE_ON(device)
DECL|macro|DEVICE_OFF
mdefine_line|#define DEVICE_OFF(device)
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &quot;pseudo.h&quot;
multiline_comment|/* constants for faking geometry numbers */
DECL|macro|PF_FD_MAX
mdefine_line|#define PF_FD_MAX&t;8192&t;&t;/* use FD geometry under this size */
DECL|macro|PF_FD_HDS
mdefine_line|#define PF_FD_HDS&t;2
DECL|macro|PF_FD_SPT
mdefine_line|#define PF_FD_SPT&t;18
DECL|macro|PF_HD_HDS
mdefine_line|#define PF_HD_HDS&t;64
DECL|macro|PF_HD_SPT
mdefine_line|#define PF_HD_SPT&t;32
DECL|macro|PF_MAX_RETRIES
mdefine_line|#define PF_MAX_RETRIES  5
DECL|macro|PF_TMO
mdefine_line|#define PF_TMO          800             /* interrupt timeout in jiffies */
DECL|macro|PF_SPIN_DEL
mdefine_line|#define PF_SPIN_DEL     50              /* spin delay in micro-seconds  */
DECL|macro|PF_SPIN
mdefine_line|#define PF_SPIN         (1000000*PF_TMO)/(HZ*PF_SPIN_DEL)
DECL|macro|STAT_ERR
mdefine_line|#define STAT_ERR        0x00001
DECL|macro|STAT_INDEX
mdefine_line|#define STAT_INDEX      0x00002
DECL|macro|STAT_ECC
mdefine_line|#define STAT_ECC        0x00004
DECL|macro|STAT_DRQ
mdefine_line|#define STAT_DRQ        0x00008
DECL|macro|STAT_SEEK
mdefine_line|#define STAT_SEEK       0x00010
DECL|macro|STAT_WRERR
mdefine_line|#define STAT_WRERR      0x00020
DECL|macro|STAT_READY
mdefine_line|#define STAT_READY      0x00040
DECL|macro|STAT_BUSY
mdefine_line|#define STAT_BUSY       0x00080
DECL|macro|ATAPI_REQ_SENSE
mdefine_line|#define ATAPI_REQ_SENSE&t;&t;0x03
DECL|macro|ATAPI_LOCK
mdefine_line|#define ATAPI_LOCK&t;&t;0x1e
DECL|macro|ATAPI_DOOR
mdefine_line|#define ATAPI_DOOR&t;&t;0x1b
DECL|macro|ATAPI_MODE_SENSE
mdefine_line|#define ATAPI_MODE_SENSE&t;0x5a
DECL|macro|ATAPI_CAPACITY
mdefine_line|#define ATAPI_CAPACITY&t;&t;0x25
DECL|macro|ATAPI_IDENTIFY
mdefine_line|#define ATAPI_IDENTIFY&t;&t;0x12
DECL|macro|ATAPI_READ_10
mdefine_line|#define ATAPI_READ_10&t;&t;0x28
DECL|macro|ATAPI_WRITE_10
mdefine_line|#define ATAPI_WRITE_10&t;&t;0x2a
r_int
id|pf_init
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_static
r_int
id|pf_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_void
id|do_pf_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
suffix:semicolon
r_static
r_int
id|pf_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|pf_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|pf_detect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_pf_read
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_pf_read_start
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_pf_write
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_pf_write_start
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_pf_read_drq
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_pf_write_done
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|pf_identify
(paren
r_int
id|unit
)paren
suffix:semicolon
r_static
r_void
id|pf_lock
c_func
(paren
r_int
id|unit
comma
r_int
id|func
)paren
suffix:semicolon
r_static
r_void
id|pf_eject
c_func
(paren
r_int
id|unit
)paren
suffix:semicolon
r_static
r_int
id|pf_check_media
c_func
(paren
id|kdev_t
id|dev
)paren
suffix:semicolon
DECL|variable|pf_blocksizes
r_static
r_int
id|pf_blocksizes
(braket
id|PF_UNITS
)braket
suffix:semicolon
DECL|macro|PF_NM
mdefine_line|#define PF_NM           0
DECL|macro|PF_RO
mdefine_line|#define PF_RO           1
DECL|macro|PF_RW
mdefine_line|#define PF_RW           2
DECL|macro|PF_NAMELEN
mdefine_line|#define PF_NAMELEN      8
DECL|struct|pf_unit
r_struct
id|pf_unit
(brace
DECL|member|pia
r_struct
id|pi_adapter
id|pia
suffix:semicolon
multiline_comment|/* interface to paride layer */
DECL|member|pi
r_struct
id|pi_adapter
op_star
id|pi
suffix:semicolon
DECL|member|removable
r_int
id|removable
suffix:semicolon
multiline_comment|/* removable media device  ?  */
DECL|member|media_status
r_int
id|media_status
suffix:semicolon
multiline_comment|/* media present ?  WP ? */
DECL|member|drive
r_int
id|drive
suffix:semicolon
multiline_comment|/* drive */
DECL|member|lun
r_int
id|lun
suffix:semicolon
DECL|member|access
r_int
id|access
suffix:semicolon
multiline_comment|/* count of active opens ... */
DECL|member|capacity
r_int
id|capacity
suffix:semicolon
multiline_comment|/* Size of this volume in sectors */
DECL|member|present
r_int
id|present
suffix:semicolon
multiline_comment|/* device present ? */
DECL|member|name
r_char
id|name
(braket
id|PF_NAMELEN
)braket
suffix:semicolon
multiline_comment|/* pf0, pf1, ... */
)brace
suffix:semicolon
DECL|variable|pf
r_struct
id|pf_unit
id|pf
(braket
id|PF_UNITS
)braket
suffix:semicolon
multiline_comment|/*  &squot;unit&squot; must be defined in all functions - either as a local or a param */
DECL|macro|PF
mdefine_line|#define PF pf[unit]
DECL|macro|PI
mdefine_line|#define PI PF.pi
DECL|variable|pf_scratch
r_static
r_char
id|pf_scratch
(braket
l_int|512
)braket
suffix:semicolon
multiline_comment|/* scratch block buffer */
multiline_comment|/* the variables below are used mainly in the I/O request engine, which&n;   processes only one request at a time.&n;*/
DECL|variable|pf_retries
r_static
r_int
id|pf_retries
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* i/o error retry count */
DECL|variable|pf_busy
r_static
r_int
id|pf_busy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* request being processed ? */
DECL|variable|pf_block
r_static
r_int
id|pf_block
suffix:semicolon
multiline_comment|/* address of next requested block */
DECL|variable|pf_count
r_static
r_int
id|pf_count
suffix:semicolon
multiline_comment|/* number of blocks still to do */
DECL|variable|pf_run
r_static
r_int
id|pf_run
suffix:semicolon
multiline_comment|/* sectors in current cluster */
DECL|variable|pf_cmd
r_static
r_int
id|pf_cmd
suffix:semicolon
multiline_comment|/* current command READ/WRITE */
DECL|variable|pf_unit
r_static
r_int
id|pf_unit
suffix:semicolon
multiline_comment|/* unit of current request */
DECL|variable|pf_mask
r_static
r_int
id|pf_mask
suffix:semicolon
multiline_comment|/* stopper for pseudo-int */
DECL|variable|pf_buf
r_static
r_char
op_star
id|pf_buf
suffix:semicolon
multiline_comment|/* buffer for request in progress */
multiline_comment|/* kernel glue structures */
DECL|variable|pf_fops
r_static
r_struct
id|block_device_operations
id|pf_fops
op_assign
(brace
id|open
suffix:colon
id|pf_open
comma
id|release
suffix:colon
id|pf_release
comma
id|ioctl
suffix:colon
id|pf_ioctl
comma
id|check_media_change
suffix:colon
id|pf_check_media
comma
)brace
suffix:semicolon
DECL|function|pf_init_units
r_void
id|pf_init_units
c_func
(paren
r_void
)paren
(brace
r_int
id|unit
comma
id|j
suffix:semicolon
id|pf_drive_count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|PF_UNITS
suffix:semicolon
id|unit
op_increment
)paren
(brace
id|PF.pi
op_assign
op_amp
id|PF.pia
suffix:semicolon
id|PF.access
op_assign
l_int|0
suffix:semicolon
id|PF.media_status
op_assign
id|PF_NM
suffix:semicolon
id|PF.capacity
op_assign
l_int|0
suffix:semicolon
id|PF.present
op_assign
l_int|0
suffix:semicolon
id|PF.drive
op_assign
id|DU
(braket
id|D_SLV
)braket
suffix:semicolon
id|PF.lun
op_assign
id|DU
(braket
id|D_LUN
)braket
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|j
OL
id|PF_NAMELEN
op_minus
l_int|2
)paren
op_logical_and
(paren
id|PF.name
(braket
id|j
)braket
op_assign
id|name
(braket
id|j
)braket
)paren
)paren
id|j
op_increment
suffix:semicolon
id|PF.name
(braket
id|j
op_increment
)braket
op_assign
l_char|&squot;0&squot;
op_plus
id|unit
suffix:semicolon
id|PF.name
(braket
id|j
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|DU
(braket
id|D_PRT
)braket
)paren
id|pf_drive_count
op_increment
suffix:semicolon
)brace
)brace
DECL|function|pf_new_segment
r_static
r_inline
r_int
id|pf_new_segment
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_int
id|max_segments
)paren
(brace
r_if
c_cond
(paren
id|max_segments
OG
id|cluster
)paren
id|max_segments
op_assign
id|cluster
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;nr_segments
OL
id|max_segments
)paren
(brace
id|req-&gt;nr_segments
op_increment
suffix:semicolon
id|q-&gt;elevator.nr_segments
op_increment
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pf_back_merge_fn
r_static
r_int
id|pf_back_merge_fn
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|max_segments
)paren
(brace
r_if
c_cond
(paren
id|req-&gt;bhtail-&gt;b_data
op_plus
id|req-&gt;bhtail-&gt;b_size
op_eq
id|bh-&gt;b_data
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|pf_new_segment
c_func
(paren
id|q
comma
id|req
comma
id|max_segments
)paren
suffix:semicolon
)brace
DECL|function|pf_front_merge_fn
r_static
r_int
id|pf_front_merge_fn
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|max_segments
)paren
(brace
r_if
c_cond
(paren
id|bh-&gt;b_data
op_plus
id|bh-&gt;b_size
op_eq
id|req-&gt;bh-&gt;b_data
)paren
r_return
l_int|1
suffix:semicolon
r_return
id|pf_new_segment
c_func
(paren
id|q
comma
id|req
comma
id|max_segments
)paren
suffix:semicolon
)brace
DECL|function|pf_merge_requests_fn
r_static
r_int
id|pf_merge_requests_fn
c_func
(paren
id|request_queue_t
op_star
id|q
comma
r_struct
id|request
op_star
id|req
comma
r_struct
id|request
op_star
id|next
comma
r_int
id|max_segments
)paren
(brace
r_int
id|total_segments
op_assign
id|req-&gt;nr_segments
op_plus
id|next-&gt;nr_segments
suffix:semicolon
r_int
id|same_segment
suffix:semicolon
r_if
c_cond
(paren
id|max_segments
OG
id|cluster
)paren
id|max_segments
op_assign
id|cluster
suffix:semicolon
id|same_segment
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;bhtail-&gt;b_data
op_plus
id|req-&gt;bhtail-&gt;b_size
op_eq
id|next-&gt;bh-&gt;b_data
)paren
(brace
id|total_segments
op_decrement
suffix:semicolon
id|same_segment
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|total_segments
OG
id|max_segments
)paren
r_return
l_int|0
suffix:semicolon
id|q-&gt;elevator.nr_segments
op_sub_assign
id|same_segment
suffix:semicolon
id|req-&gt;nr_segments
op_assign
id|total_segments
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|pf_init
r_int
id|pf_init
(paren
r_void
)paren
multiline_comment|/* preliminary initialisation */
(brace
r_int
id|i
suffix:semicolon
id|request_queue_t
op_star
id|q
suffix:semicolon
r_if
c_cond
(paren
id|disable
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|pf_init_units
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_detect
c_func
(paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|pf_busy
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
id|name
comma
op_amp
id|pf_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pf_init: unable to get major number %d&bslash;n&quot;
comma
id|major
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|q
op_assign
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|q
comma
id|DEVICE_REQUEST
)paren
suffix:semicolon
id|q-&gt;back_merge_fn
op_assign
id|pf_back_merge_fn
suffix:semicolon
id|q-&gt;front_merge_fn
op_assign
id|pf_front_merge_fn
suffix:semicolon
id|q-&gt;merge_requests_fn
op_assign
id|pf_merge_requests_fn
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* 8 sector (4kB) read ahead */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PF_UNITS
suffix:semicolon
id|i
op_increment
)paren
id|pf_blocksizes
(braket
id|i
)braket
op_assign
l_int|1024
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|pf_blocksizes
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|PF_UNITS
suffix:semicolon
id|i
op_increment
)paren
id|register_disk
c_func
(paren
l_int|NULL
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|i
)paren
comma
l_int|1
comma
op_amp
id|pf_fops
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pf_open
r_static
r_int
id|pf_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|unit
op_assign
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|unit
op_ge
id|PF_UNITS
)paren
op_logical_or
(paren
op_logical_neg
id|PF.present
)paren
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
id|pf_identify
c_func
(paren
id|unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PF.media_status
op_eq
id|PF_NM
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|PF.media_status
op_eq
id|PF_RO
)paren
op_logical_and
(paren
id|file
op_member_access_from_pointer
id|f_mode
op_amp
l_int|2
)paren
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
id|PF.access
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|PF.removable
)paren
id|pf_lock
c_func
(paren
id|unit
comma
l_int|1
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pf_ioctl
r_static
r_int
id|pf_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|err
comma
id|unit
suffix:semicolon
r_struct
id|hd_geometry
op_star
id|geo
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|inode
)paren
op_logical_or
(paren
op_logical_neg
id|inode-&gt;i_rdev
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|unit
op_assign
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit
op_ge
id|PF_UNITS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PF.present
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMEJECT
suffix:colon
r_if
c_cond
(paren
id|PF.access
op_eq
l_int|1
)paren
(brace
id|pf_eject
c_func
(paren
id|unit
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|HDIO_GETGEO
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|geo
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|geo
comma
r_sizeof
(paren
op_star
id|geo
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
r_if
c_cond
(paren
id|PF.capacity
OL
id|PF_FD_MAX
)paren
(brace
id|put_user
c_func
(paren
id|PF.capacity
op_div
(paren
id|PF_FD_HDS
op_star
id|PF_FD_SPT
)paren
comma
(paren
r_int
op_star
)paren
op_amp
id|geo-&gt;cylinders
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|PF_FD_HDS
comma
(paren
r_char
op_star
)paren
op_amp
id|geo-&gt;heads
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|PF_FD_SPT
comma
(paren
r_char
op_star
)paren
op_amp
id|geo-&gt;sectors
)paren
suffix:semicolon
)brace
r_else
(brace
id|put_user
c_func
(paren
id|PF.capacity
op_div
(paren
id|PF_HD_HDS
op_star
id|PF_HD_SPT
)paren
comma
(paren
r_int
op_star
)paren
op_amp
id|geo-&gt;cylinders
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|PF_HD_HDS
comma
(paren
r_char
op_star
)paren
op_amp
id|geo-&gt;heads
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|PF_HD_SPT
comma
(paren
r_char
op_star
)paren
op_amp
id|geo-&gt;sectors
)paren
suffix:semicolon
)brace
id|put_user
c_func
(paren
l_int|0
comma
(paren
r_int
op_star
)paren
op_amp
id|geo-&gt;start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
(paren
id|err
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|PF.capacity
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|BLKROSET
suffix:colon
r_case
id|BLKROGET
suffix:colon
r_case
id|BLKRASET
suffix:colon
r_case
id|BLKRAGET
suffix:colon
r_case
id|BLKFLSBUF
suffix:colon
r_return
id|blk_ioctl
c_func
(paren
id|inode-&gt;i_rdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|pf_release
r_static
r_int
id|pf_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|kdev_t
id|devp
suffix:semicolon
r_int
id|unit
suffix:semicolon
id|devp
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
id|unit
op_assign
id|DEVICE_NR
c_func
(paren
id|devp
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|unit
op_ge
id|PF_UNITS
)paren
op_logical_or
(paren
id|PF.access
op_le
l_int|0
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|PF.access
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|PF.access
op_logical_and
id|PF.removable
)paren
id|pf_lock
c_func
(paren
id|unit
comma
l_int|0
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pf_check_media
r_static
r_int
id|pf_check_media
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/* Glue for modules ... */
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
macro_line|#ifdef PARIDE_JUMBO
(brace
r_extern
id|paride_init
c_func
(paren
)paren
suffix:semicolon
id|paride_init
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#endif
id|err
op_assign
id|pf_init
c_func
(paren
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|unit
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
id|name
)paren
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|PF_UNITS
suffix:semicolon
id|unit
op_increment
)paren
r_if
c_cond
(paren
id|PF.present
)paren
id|pi_release
c_func
(paren
id|PI
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|macro|WR
mdefine_line|#define&t;WR(c,r,v)&t;pi_write_regr(PI,c,r,v)
DECL|macro|RR
mdefine_line|#define&t;RR(c,r)&t;&t;(pi_read_regr(PI,c,r))
DECL|macro|LUN
mdefine_line|#define LUN             (0x20*PF.lun)
DECL|macro|DRIVE
mdefine_line|#define DRIVE           (0xa0+0x10*PF.drive)
DECL|function|pf_wait
r_static
r_int
id|pf_wait
c_func
(paren
r_int
id|unit
comma
r_int
id|go
comma
r_int
id|stop
comma
r_char
op_star
id|fun
comma
r_char
op_star
id|msg
)paren
(brace
r_int
id|j
comma
id|r
comma
id|e
comma
id|s
comma
id|p
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
(paren
(paren
id|r
op_assign
id|RR
c_func
(paren
l_int|1
comma
l_int|6
)paren
)paren
op_amp
id|go
)paren
op_logical_or
(paren
id|stop
op_logical_and
(paren
op_logical_neg
(paren
id|r
op_amp
id|stop
)paren
)paren
)paren
)paren
op_logical_and
(paren
id|j
op_increment
OL
id|PF_SPIN
)paren
)paren
id|udelay
c_func
(paren
id|PF_SPIN_DEL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
(paren
id|STAT_ERR
op_amp
id|stop
)paren
)paren
op_logical_or
(paren
id|j
op_ge
id|PF_SPIN
)paren
)paren
(brace
id|s
op_assign
id|RR
c_func
(paren
l_int|0
comma
l_int|7
)paren
suffix:semicolon
id|e
op_assign
id|RR
c_func
(paren
l_int|0
comma
l_int|1
)paren
suffix:semicolon
id|p
op_assign
id|RR
c_func
(paren
l_int|0
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|j
op_ge
id|PF_SPIN
)paren
id|e
op_or_assign
l_int|0x100
suffix:semicolon
r_if
c_cond
(paren
id|fun
)paren
id|printk
c_func
(paren
l_string|&quot;%s: %s %s: alt=0x%x stat=0x%x err=0x%x&quot;
l_string|&quot; loop=%d phase=%d&bslash;n&quot;
comma
id|PF.name
comma
id|fun
comma
id|msg
comma
id|r
comma
id|s
comma
id|e
comma
id|j
comma
id|p
)paren
suffix:semicolon
r_return
(paren
id|e
op_lshift
l_int|8
)paren
op_plus
id|s
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pf_command
r_static
r_int
id|pf_command
c_func
(paren
r_int
id|unit
comma
r_char
op_star
id|cmd
comma
r_int
id|dlen
comma
r_char
op_star
id|fun
)paren
(brace
id|pi_connect
c_func
(paren
id|PI
)paren
suffix:semicolon
id|WR
c_func
(paren
l_int|0
comma
l_int|6
comma
id|DRIVE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_wait
c_func
(paren
id|unit
comma
id|STAT_BUSY
op_or
id|STAT_DRQ
comma
l_int|0
comma
id|fun
comma
l_string|&quot;before command&quot;
)paren
)paren
(brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|WR
c_func
(paren
l_int|0
comma
l_int|4
comma
id|dlen
op_mod
l_int|256
)paren
suffix:semicolon
id|WR
c_func
(paren
l_int|0
comma
l_int|5
comma
id|dlen
op_div
l_int|256
)paren
suffix:semicolon
id|WR
c_func
(paren
l_int|0
comma
l_int|7
comma
l_int|0xa0
)paren
suffix:semicolon
multiline_comment|/* ATAPI packet command */
r_if
c_cond
(paren
id|pf_wait
c_func
(paren
id|unit
comma
id|STAT_BUSY
comma
id|STAT_DRQ
comma
id|fun
comma
l_string|&quot;command DRQ&quot;
)paren
)paren
(brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|RR
c_func
(paren
l_int|0
comma
l_int|2
)paren
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: %s: command phase error&bslash;n&quot;
comma
id|PF.name
comma
id|fun
)paren
suffix:semicolon
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|pi_write_block
c_func
(paren
id|PI
comma
id|cmd
comma
l_int|12
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pf_completion
r_static
r_int
id|pf_completion
c_func
(paren
r_int
id|unit
comma
r_char
op_star
id|buf
comma
r_char
op_star
id|fun
)paren
(brace
r_int
id|r
comma
id|s
comma
id|n
suffix:semicolon
id|r
op_assign
id|pf_wait
c_func
(paren
id|unit
comma
id|STAT_BUSY
comma
id|STAT_DRQ
op_or
id|STAT_READY
op_or
id|STAT_ERR
comma
id|fun
comma
l_string|&quot;completion&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|RR
c_func
(paren
l_int|0
comma
l_int|2
)paren
op_amp
l_int|2
)paren
op_logical_and
(paren
id|RR
c_func
(paren
l_int|0
comma
l_int|7
)paren
op_amp
id|STAT_DRQ
)paren
)paren
(brace
id|n
op_assign
(paren
(paren
(paren
id|RR
c_func
(paren
l_int|0
comma
l_int|4
)paren
op_plus
l_int|256
op_star
id|RR
c_func
(paren
l_int|0
comma
l_int|5
)paren
)paren
op_plus
l_int|3
)paren
op_amp
l_int|0xfffc
)paren
suffix:semicolon
id|pi_read_block
c_func
(paren
id|PI
comma
id|buf
comma
id|n
)paren
suffix:semicolon
)brace
id|s
op_assign
id|pf_wait
c_func
(paren
id|unit
comma
id|STAT_BUSY
comma
id|STAT_READY
op_or
id|STAT_ERR
comma
id|fun
comma
l_string|&quot;data done&quot;
)paren
suffix:semicolon
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_return
(paren
id|r
ques
c_cond
id|r
suffix:colon
id|s
)paren
suffix:semicolon
)brace
DECL|function|pf_req_sense
r_static
r_void
id|pf_req_sense
c_func
(paren
r_int
id|unit
comma
r_int
id|quiet
)paren
(brace
r_char
id|rs_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_REQ_SENSE
comma
id|LUN
comma
l_int|0
comma
l_int|0
comma
l_int|16
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_char
id|buf
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|r
suffix:semicolon
id|r
op_assign
id|pf_command
c_func
(paren
id|unit
comma
id|rs_cmd
comma
l_int|16
comma
l_string|&quot;Request sense&quot;
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
id|pf_completion
c_func
(paren
id|unit
comma
id|buf
comma
l_string|&quot;Request sense&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|r
)paren
op_logical_and
(paren
op_logical_neg
id|quiet
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Sense key: %x, ASC: %x, ASQ: %x&bslash;n&quot;
comma
id|PF.name
comma
id|buf
(braket
l_int|2
)braket
op_amp
l_int|0xf
comma
id|buf
(braket
l_int|12
)braket
comma
id|buf
(braket
l_int|13
)braket
)paren
suffix:semicolon
)brace
DECL|function|pf_atapi
r_static
r_int
id|pf_atapi
c_func
(paren
r_int
id|unit
comma
r_char
op_star
id|cmd
comma
r_int
id|dlen
comma
r_char
op_star
id|buf
comma
r_char
op_star
id|fun
)paren
(brace
r_int
id|r
suffix:semicolon
id|r
op_assign
id|pf_command
c_func
(paren
id|unit
comma
id|cmd
comma
id|dlen
comma
id|fun
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|r
)paren
id|r
op_assign
id|pf_completion
c_func
(paren
id|unit
comma
id|buf
comma
id|fun
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
)paren
id|pf_req_sense
c_func
(paren
id|unit
comma
op_logical_neg
id|fun
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|macro|DBMSG
mdefine_line|#define DBMSG(msg)      ((verbose&gt;1)?(msg):NULL)
DECL|function|pf_lock
r_static
r_void
id|pf_lock
c_func
(paren
r_int
id|unit
comma
r_int
id|func
)paren
(brace
r_char
id|lo_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_LOCK
comma
id|LUN
comma
l_int|0
comma
l_int|0
comma
id|func
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|pf_atapi
c_func
(paren
id|unit
comma
id|lo_cmd
comma
l_int|0
comma
id|pf_scratch
comma
id|func
ques
c_cond
l_string|&quot;unlock&quot;
suffix:colon
l_string|&quot;lock&quot;
)paren
suffix:semicolon
)brace
DECL|function|pf_eject
r_static
r_void
id|pf_eject
c_func
(paren
r_int
id|unit
)paren
(brace
r_char
id|ej_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_DOOR
comma
id|LUN
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|pf_lock
c_func
(paren
id|unit
comma
l_int|0
)paren
suffix:semicolon
id|pf_atapi
c_func
(paren
id|unit
comma
id|ej_cmd
comma
l_int|0
comma
id|pf_scratch
comma
l_string|&quot;eject&quot;
)paren
suffix:semicolon
)brace
DECL|macro|PF_RESET_TMO
mdefine_line|#define PF_RESET_TMO   30              /* in tenths of a second */
DECL|function|pf_sleep
r_static
r_void
id|pf_sleep
c_func
(paren
r_int
id|cs
)paren
(brace
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|cs
)paren
suffix:semicolon
)brace
DECL|function|pf_reset
r_static
r_int
id|pf_reset
c_func
(paren
r_int
id|unit
)paren
multiline_comment|/* the ATAPI standard actually specifies the contents of all 7 registers&n;   after a reset, but the specification is ambiguous concerning the last&n;   two bytes, and different drives interpret the standard differently.&n;*/
(brace
r_int
id|i
comma
id|k
comma
id|flg
suffix:semicolon
r_int
id|expect
(braket
l_int|5
)braket
op_assign
(brace
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0x14
comma
l_int|0xeb
)brace
suffix:semicolon
id|pi_connect
c_func
(paren
id|PI
)paren
suffix:semicolon
id|WR
c_func
(paren
l_int|0
comma
l_int|6
comma
id|DRIVE
)paren
suffix:semicolon
id|WR
c_func
(paren
l_int|0
comma
l_int|7
comma
l_int|8
)paren
suffix:semicolon
id|pf_sleep
c_func
(paren
l_int|20
op_star
id|HZ
op_div
l_int|1000
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|k
op_increment
OL
id|PF_RESET_TMO
)paren
op_logical_and
(paren
id|RR
c_func
(paren
l_int|1
comma
l_int|6
)paren
op_amp
id|STAT_BUSY
)paren
)paren
id|pf_sleep
c_func
(paren
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
id|flg
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|flg
op_and_assign
(paren
id|RR
c_func
(paren
l_int|0
comma
id|i
op_plus
l_int|1
)paren
op_eq
id|expect
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|verbose
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Reset (%d) signature = &quot;
comma
id|PF.name
comma
id|k
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%3x&quot;
comma
id|RR
c_func
(paren
l_int|0
comma
id|i
op_plus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flg
)paren
id|printk
c_func
(paren
l_string|&quot; (incorrect)&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_return
id|flg
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|pf_mode_sense
r_static
r_void
id|pf_mode_sense
c_func
(paren
r_int
id|unit
)paren
(brace
r_char
id|ms_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_MODE_SENSE
comma
id|LUN
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|8
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_char
id|buf
(braket
l_int|8
)braket
suffix:semicolon
id|pf_atapi
c_func
(paren
id|unit
comma
id|ms_cmd
comma
l_int|8
comma
id|buf
comma
id|DBMSG
c_func
(paren
l_string|&quot;mode sense&quot;
)paren
)paren
suffix:semicolon
id|PF.media_status
op_assign
id|PF_RW
suffix:semicolon
r_if
c_cond
(paren
id|buf
(braket
l_int|3
)braket
op_amp
l_int|0x80
)paren
id|PF.media_status
op_assign
id|PF_RO
suffix:semicolon
)brace
DECL|function|xs
r_static
r_void
id|xs
c_func
(paren
r_char
op_star
id|buf
comma
r_char
op_star
id|targ
comma
r_int
id|offs
comma
r_int
id|len
)paren
(brace
r_int
id|j
comma
id|k
comma
id|l
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
id|l
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
id|len
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
(paren
id|buf
(braket
id|k
op_plus
id|offs
)braket
op_ne
l_int|0x20
)paren
op_logical_or
(paren
id|buf
(braket
id|k
op_plus
id|offs
)braket
op_ne
id|l
)paren
)paren
(brace
id|l
op_assign
id|targ
(braket
id|j
op_increment
)braket
op_assign
id|buf
(braket
id|k
op_plus
id|offs
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|l
op_eq
l_int|0x20
)paren
id|j
op_decrement
suffix:semicolon
id|targ
(braket
id|j
)braket
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|xl
r_static
r_int
id|xl
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|offs
)paren
(brace
r_int
id|v
comma
id|k
suffix:semicolon
id|v
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|4
suffix:semicolon
id|k
op_increment
)paren
(brace
id|v
op_assign
id|v
op_star
l_int|256
op_plus
(paren
id|buf
(braket
id|k
op_plus
id|offs
)braket
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
r_return
id|v
suffix:semicolon
)brace
DECL|function|pf_get_capacity
r_static
r_void
id|pf_get_capacity
c_func
(paren
r_int
id|unit
)paren
(brace
r_char
id|rc_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_CAPACITY
comma
id|LUN
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_char
id|buf
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|bs
suffix:semicolon
r_if
c_cond
(paren
id|pf_atapi
c_func
(paren
id|unit
comma
id|rc_cmd
comma
l_int|8
comma
id|buf
comma
id|DBMSG
c_func
(paren
l_string|&quot;get capacity&quot;
)paren
)paren
)paren
(brace
id|PF.media_status
op_assign
id|PF_NM
suffix:semicolon
r_return
suffix:semicolon
)brace
id|PF.capacity
op_assign
id|xl
c_func
(paren
id|buf
comma
l_int|0
)paren
op_plus
l_int|1
suffix:semicolon
id|bs
op_assign
id|xl
c_func
(paren
id|buf
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bs
op_ne
l_int|512
)paren
(brace
id|PF.capacity
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|verbose
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Drive %d, LUN %d,&quot;
l_string|&quot; unsupported block size %d&bslash;n&quot;
comma
id|PF.name
comma
id|PF.drive
comma
id|PF.lun
comma
id|bs
)paren
suffix:semicolon
)brace
)brace
DECL|function|pf_identify
r_static
r_int
id|pf_identify
c_func
(paren
r_int
id|unit
)paren
(brace
r_int
id|dt
comma
id|s
suffix:semicolon
r_char
op_star
id|ms
(braket
l_int|2
)braket
op_assign
(brace
l_string|&quot;master&quot;
comma
l_string|&quot;slave&quot;
)brace
suffix:semicolon
r_char
id|mf
(braket
l_int|10
)braket
comma
id|id
(braket
l_int|18
)braket
suffix:semicolon
r_char
id|id_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|ATAPI_IDENTIFY
comma
id|LUN
comma
l_int|0
comma
l_int|0
comma
l_int|36
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_char
id|buf
(braket
l_int|36
)braket
suffix:semicolon
id|s
op_assign
id|pf_atapi
c_func
(paren
id|unit
comma
id|id_cmd
comma
l_int|36
comma
id|buf
comma
l_string|&quot;identify&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|dt
op_assign
id|buf
(braket
l_int|0
)braket
op_amp
l_int|0x1f
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dt
op_ne
l_int|0
)paren
op_logical_and
(paren
id|dt
op_ne
l_int|7
)paren
)paren
(brace
r_if
c_cond
(paren
id|verbose
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Drive %d, LUN %d, unsupported type %d&bslash;n&quot;
comma
id|PF.name
comma
id|PF.drive
comma
id|PF.lun
comma
id|dt
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|xs
c_func
(paren
id|buf
comma
id|mf
comma
l_int|8
comma
l_int|8
)paren
suffix:semicolon
id|xs
c_func
(paren
id|buf
comma
id|id
comma
l_int|16
comma
l_int|16
)paren
suffix:semicolon
id|PF.removable
op_assign
(paren
id|buf
(braket
l_int|1
)braket
op_amp
l_int|0x80
)paren
suffix:semicolon
id|pf_mode_sense
c_func
(paren
id|unit
)paren
suffix:semicolon
id|pf_mode_sense
c_func
(paren
id|unit
)paren
suffix:semicolon
id|pf_mode_sense
c_func
(paren
id|unit
)paren
suffix:semicolon
id|pf_get_capacity
c_func
(paren
id|unit
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s %s, %s LUN %d, type %d&quot;
comma
id|PF.name
comma
id|mf
comma
id|id
comma
id|ms
(braket
id|PF.drive
)braket
comma
id|PF.lun
comma
id|dt
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PF.removable
)paren
id|printk
c_func
(paren
l_string|&quot;, removable&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|PF.media_status
op_eq
id|PF_NM
)paren
id|printk
c_func
(paren
l_string|&quot;, no media&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|PF.media_status
op_eq
id|PF_RO
)paren
id|printk
c_func
(paren
l_string|&quot;, RO&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, %d blocks&bslash;n&quot;
comma
id|PF.capacity
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pf_probe
r_static
r_int
id|pf_probe
c_func
(paren
r_int
id|unit
)paren
multiline_comment|/*&t;returns  0, with id set if drive is detected&n;&t;        -1, if drive detection failed&n;*/
(brace
r_if
c_cond
(paren
id|PF.drive
op_eq
op_minus
l_int|1
)paren
(brace
r_for
c_loop
(paren
id|PF.drive
op_assign
l_int|0
suffix:semicolon
id|PF.drive
op_le
l_int|1
suffix:semicolon
id|PF.drive
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|pf_reset
c_func
(paren
id|unit
)paren
)paren
(brace
r_if
c_cond
(paren
id|PF.lun
op_ne
op_minus
l_int|1
)paren
r_return
id|pf_identify
c_func
(paren
id|unit
)paren
suffix:semicolon
r_else
r_for
c_loop
(paren
id|PF.lun
op_assign
l_int|0
suffix:semicolon
id|PF.lun
OL
l_int|8
suffix:semicolon
id|PF.lun
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|pf_identify
c_func
(paren
id|unit
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|pf_reset
c_func
(paren
id|unit
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|PF.lun
op_ne
op_minus
l_int|1
)paren
r_return
id|pf_identify
c_func
(paren
id|unit
)paren
suffix:semicolon
r_for
c_loop
(paren
id|PF.lun
op_assign
l_int|0
suffix:semicolon
id|PF.lun
OL
l_int|8
suffix:semicolon
id|PF.lun
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|pf_identify
c_func
(paren
id|unit
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|pf_detect
r_static
r_int
id|pf_detect
c_func
(paren
r_void
)paren
(brace
r_int
id|k
comma
id|unit
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %s version %s, major %d, cluster %d, nice %d&bslash;n&quot;
comma
id|name
comma
id|name
comma
id|PF_VERSION
comma
id|major
comma
id|cluster
comma
id|nice
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pf_drive_count
op_eq
l_int|0
)paren
(brace
id|unit
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|pi_init
c_func
(paren
id|PI
comma
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|pf_scratch
comma
id|PI_PF
comma
id|verbose
comma
id|PF.name
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pf_probe
c_func
(paren
id|unit
)paren
)paren
(brace
id|PF.present
op_assign
l_int|1
suffix:semicolon
id|k
op_increment
suffix:semicolon
)brace
r_else
id|pi_release
c_func
(paren
id|PI
)paren
suffix:semicolon
)brace
)brace
r_else
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
id|PF_UNITS
suffix:semicolon
id|unit
op_increment
)paren
r_if
c_cond
(paren
id|DU
(braket
id|D_PRT
)braket
)paren
r_if
c_cond
(paren
id|pi_init
c_func
(paren
id|PI
comma
l_int|0
comma
id|DU
(braket
id|D_PRT
)braket
comma
id|DU
(braket
id|D_MOD
)braket
comma
id|DU
(braket
id|D_UNI
)braket
comma
id|DU
(braket
id|D_PRO
)braket
comma
id|DU
(braket
id|D_DLY
)braket
comma
id|pf_scratch
comma
id|PI_PF
comma
id|verbose
comma
id|PF.name
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|pf_probe
c_func
(paren
id|unit
)paren
)paren
(brace
id|PF.present
op_assign
l_int|1
suffix:semicolon
id|k
op_increment
suffix:semicolon
)brace
r_else
id|pi_release
c_func
(paren
id|PI
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|k
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: No ATAPI disk detected&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* The i/o request engine */
DECL|function|pf_start
r_static
r_int
id|pf_start
c_func
(paren
r_int
id|unit
comma
r_int
id|cmd
comma
r_int
id|b
comma
r_int
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
id|io_cmd
(braket
l_int|12
)braket
op_assign
(brace
id|cmd
comma
id|LUN
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|io_cmd
(braket
l_int|5
op_minus
id|i
)braket
op_assign
id|b
op_amp
l_int|0xff
suffix:semicolon
id|b
op_assign
id|b
op_rshift
l_int|8
suffix:semicolon
)brace
id|io_cmd
(braket
l_int|8
)braket
op_assign
id|c
op_amp
l_int|0xff
suffix:semicolon
id|io_cmd
(braket
l_int|7
)braket
op_assign
(paren
id|c
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|i
op_assign
id|pf_command
c_func
(paren
id|unit
comma
id|io_cmd
comma
id|c
op_star
l_int|512
comma
l_string|&quot;start i/o&quot;
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|function|pf_ready
r_static
r_int
id|pf_ready
c_func
(paren
r_void
)paren
(brace
r_int
id|unit
op_assign
id|pf_unit
suffix:semicolon
r_return
(paren
(paren
(paren
id|RR
c_func
(paren
l_int|1
comma
l_int|6
)paren
op_amp
(paren
id|STAT_BUSY
op_or
id|pf_mask
)paren
)paren
op_eq
id|pf_mask
)paren
)paren
suffix:semicolon
)brace
DECL|function|do_pf_request
r_static
r_void
id|do_pf_request
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|unit
suffix:semicolon
r_if
c_cond
(paren
id|pf_busy
)paren
r_return
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
id|QUEUE_EMPTY
op_logical_or
(paren
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
)paren
r_return
suffix:semicolon
id|INIT_REQUEST
suffix:semicolon
id|pf_unit
op_assign
id|unit
op_assign
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
suffix:semicolon
id|pf_block
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|pf_run
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
id|pf_count
op_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|bh
op_assign
id|CURRENT-&gt;bh
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pf_unit
op_ge
id|PF_UNITS
)paren
op_logical_or
(paren
id|pf_block
op_plus
id|pf_count
OG
id|PF.capacity
)paren
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|pf_cmd
op_assign
id|CURRENT-&gt;cmd
suffix:semicolon
id|pf_buf
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|pf_retries
op_assign
l_int|0
suffix:semicolon
id|pf_busy
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pf_cmd
op_eq
id|READ
)paren
id|pi_do_claimed
c_func
(paren
id|PI
comma
id|do_pf_read
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|pf_cmd
op_eq
id|WRITE
)paren
id|pi_do_claimed
c_func
(paren
id|PI
comma
id|do_pf_write
)paren
suffix:semicolon
r_else
(brace
id|pf_busy
op_assign
l_int|0
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
DECL|function|pf_next_buf
r_static
r_void
id|pf_next_buf
c_func
(paren
r_int
id|unit
)paren
(brace
r_int
id|saved_flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pf_run
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* paranoia */
r_if
c_cond
(paren
id|QUEUE_EMPTY
op_logical_or
(paren
id|CURRENT-&gt;cmd
op_ne
id|pf_cmd
)paren
op_logical_or
(paren
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
op_ne
id|pf_unit
)paren
op_logical_or
(paren
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
op_logical_or
(paren
id|CURRENT-&gt;sector
op_ne
id|pf_block
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;%s: OUCH: request list changed unexpectedly&bslash;n&quot;
comma
id|PF.name
)paren
suffix:semicolon
id|pf_count
op_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|pf_buf
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
)brace
DECL|function|do_pf_read
r_static
r_void
id|do_pf_read
c_func
(paren
r_void
)paren
multiline_comment|/* detach from the calling context - in case the spinlock is held */
(brace
id|ps_set_intr
c_func
(paren
id|do_pf_read_start
comma
l_int|0
comma
l_int|0
comma
id|nice
)paren
suffix:semicolon
)brace
DECL|function|do_pf_read_start
r_static
r_void
id|do_pf_read_start
c_func
(paren
r_void
)paren
(brace
r_int
id|unit
op_assign
id|pf_unit
suffix:semicolon
r_int
id|saved_flags
suffix:semicolon
id|pf_busy
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pf_start
c_func
(paren
id|unit
comma
id|ATAPI_READ_10
comma
id|pf_block
comma
id|pf_run
)paren
)paren
(brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_retries
OL
id|PF_MAX_RETRIES
)paren
(brace
id|pf_retries
op_increment
suffix:semicolon
id|pi_do_claimed
c_func
(paren
id|PI
comma
id|do_pf_read_start
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|pf_busy
op_assign
l_int|0
suffix:semicolon
id|do_pf_request
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pf_mask
op_assign
id|STAT_DRQ
suffix:semicolon
id|ps_set_intr
c_func
(paren
id|do_pf_read_drq
comma
id|pf_ready
comma
id|PF_TMO
comma
id|nice
)paren
suffix:semicolon
)brace
DECL|function|do_pf_read_drq
r_static
r_void
id|do_pf_read_drq
c_func
(paren
r_void
)paren
(brace
r_int
id|unit
op_assign
id|pf_unit
suffix:semicolon
r_int
id|saved_flags
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|pf_wait
c_func
(paren
id|unit
comma
id|STAT_BUSY
comma
id|STAT_DRQ
op_or
id|STAT_ERR
comma
l_string|&quot;read block&quot;
comma
l_string|&quot;completion&quot;
)paren
op_amp
id|STAT_ERR
)paren
(brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_retries
OL
id|PF_MAX_RETRIES
)paren
(brace
id|pf_req_sense
c_func
(paren
id|unit
comma
l_int|0
)paren
suffix:semicolon
id|pf_retries
op_increment
suffix:semicolon
id|pi_do_claimed
c_func
(paren
id|PI
comma
id|do_pf_read_start
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|pf_busy
op_assign
l_int|0
suffix:semicolon
id|do_pf_request
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pi_read_block
c_func
(paren
id|PI
comma
id|pf_buf
comma
l_int|512
)paren
suffix:semicolon
id|pf_count
op_decrement
suffix:semicolon
id|pf_run
op_decrement
suffix:semicolon
id|pf_buf
op_add_assign
l_int|512
suffix:semicolon
id|pf_block
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pf_run
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pf_count
)paren
id|pf_next_buf
c_func
(paren
id|unit
)paren
suffix:semicolon
)brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|pf_busy
op_assign
l_int|0
suffix:semicolon
id|do_pf_request
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
)brace
DECL|function|do_pf_write
r_static
r_void
id|do_pf_write
c_func
(paren
r_void
)paren
(brace
id|ps_set_intr
c_func
(paren
id|do_pf_write_start
comma
l_int|0
comma
l_int|0
comma
id|nice
)paren
suffix:semicolon
)brace
DECL|function|do_pf_write_start
r_static
r_void
id|do_pf_write_start
c_func
(paren
r_void
)paren
(brace
r_int
id|unit
op_assign
id|pf_unit
suffix:semicolon
r_int
id|saved_flags
suffix:semicolon
id|pf_busy
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|pf_start
c_func
(paren
id|unit
comma
id|ATAPI_WRITE_10
comma
id|pf_block
comma
id|pf_run
)paren
)paren
(brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_retries
OL
id|PF_MAX_RETRIES
)paren
(brace
id|pf_retries
op_increment
suffix:semicolon
id|pi_do_claimed
c_func
(paren
id|PI
comma
id|do_pf_write_start
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|pf_busy
op_assign
l_int|0
suffix:semicolon
id|do_pf_request
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|pf_wait
c_func
(paren
id|unit
comma
id|STAT_BUSY
comma
id|STAT_DRQ
op_or
id|STAT_ERR
comma
l_string|&quot;write block&quot;
comma
l_string|&quot;data wait&quot;
)paren
op_amp
id|STAT_ERR
)paren
(brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_retries
OL
id|PF_MAX_RETRIES
)paren
(brace
id|pf_retries
op_increment
suffix:semicolon
id|pi_do_claimed
c_func
(paren
id|PI
comma
id|do_pf_write_start
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|pf_busy
op_assign
l_int|0
suffix:semicolon
id|do_pf_request
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pi_write_block
c_func
(paren
id|PI
comma
id|pf_buf
comma
l_int|512
)paren
suffix:semicolon
id|pf_count
op_decrement
suffix:semicolon
id|pf_run
op_decrement
suffix:semicolon
id|pf_buf
op_add_assign
l_int|512
suffix:semicolon
id|pf_block
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pf_run
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pf_count
)paren
id|pf_next_buf
c_func
(paren
id|unit
)paren
suffix:semicolon
)brace
id|pf_mask
op_assign
l_int|0
suffix:semicolon
id|ps_set_intr
c_func
(paren
id|do_pf_write_done
comma
id|pf_ready
comma
id|PF_TMO
comma
id|nice
)paren
suffix:semicolon
)brace
DECL|function|do_pf_write_done
r_static
r_void
id|do_pf_write_done
c_func
(paren
r_void
)paren
(brace
r_int
id|unit
op_assign
id|pf_unit
suffix:semicolon
r_int
id|saved_flags
suffix:semicolon
r_if
c_cond
(paren
id|pf_wait
c_func
(paren
id|unit
comma
id|STAT_BUSY
comma
l_int|0
comma
l_string|&quot;write block&quot;
comma
l_string|&quot;done&quot;
)paren
op_amp
id|STAT_ERR
)paren
(brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pf_retries
OL
id|PF_MAX_RETRIES
)paren
(brace
id|pf_retries
op_increment
suffix:semicolon
id|pi_do_claimed
c_func
(paren
id|PI
comma
id|do_pf_write_start
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|pf_busy
op_assign
l_int|0
suffix:semicolon
id|do_pf_request
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|pi_disconnect
c_func
(paren
id|PI
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|pf_busy
op_assign
l_int|0
suffix:semicolon
id|do_pf_request
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|saved_flags
)paren
suffix:semicolon
)brace
multiline_comment|/* end of pf.c */
eof
