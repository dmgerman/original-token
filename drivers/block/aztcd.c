DECL|macro|AZT_VERSION
mdefine_line|#define AZT_VERSION &quot;V0.9&quot;
multiline_comment|/*      $Id: aztcd.c,v 0.90 1995/02/02 18:14:17 root Exp $&n;&t;linux/drivers/block/aztcd.c - AztechCD268 CDROM driver&n;&n;&t;Copyright (C) 1994,1995 Werner Zimmermann (zimmerma@rz.fht-esslingen.de)&n;&n;&t;based on Mitsumi CDROM driver by  Martin Hariss and preworks by&n;&t;Eberhard Moenkeberg; contains contributions by Joe Nardone and Robby &n;&t;Schirmer.&n;&n;&t;This program is free software; you can redistribute it and/or modify&n;&t;it under the terms of the GNU General Public License as published by&n;&t;the Free Software Foundation; either version 2, or (at your option)&n;&t;any later version.&n;&n;&t;This program is distributed in the hope that it will be useful,&n;&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n;&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;&t;GNU General Public License for more details.&n;&n;&t;You should have received a copy of the GNU General Public License&n;&t;along with this program; if not, write to the Free Software&n;&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;&t;HISTORY&n;&t;V0.0    Adaption to Adaptec CD268-01A Version 1.3&n;&t;&t;Version is PRE_ALPHA, unresolved points:&n;&t;&t;1. I use busy wait instead of timer wait in STEN_LOW,DTEN_LOW&n;&t;&t;   thus driver causes CPU overhead and is very slow &n;&t;&t;2. could not find a way to stop the drive, when it is&n;&t;&t;   in data read mode, therefore I had to set&n;&t;&t;   msf.end.min/sec/frame to 0:0:1 (in azt_poll); so only one&n;&t;&t;   frame can be read in sequence, this is also the reason for&n;&t;&t;3. getting &squot;timeout in state 4&squot; messages, but nevertheless&n;&t;&t;   it works&n;&t;&t;W.Zimmermann, Oct. 31, 1994&n;&t;V0.1    Version is ALPHA, problems #2 and #3 resolved.  &n;&t;&t;W.Zimmermann, Nov. 3, 1994&n;&t;V0.2    Modification to some comments, debugging aids for partial test&n;&t;&t;with Borland C under DOS eliminated. Timer interrupt wait &n;&t;&t;STEN_LOW_WAIT additionally to busy wait for STEN_LOW implemented; &n;&t;&t;use it only for the &squot;slow&squot; commands (ACMD_GET_Q_CHANNEL, ACMD_&n;&t;&t;SEEK_TO_LEAD_IN), all other commands are so &squot;fast&squot;, that busy &n;&t;&t;waiting seems better to me than interrupt rescheduling.&n;&t;&t;Besides that, when used in the wrong place, STEN_LOW_WAIT causes&n;&t;&t;kernel panic.&n;&t;&t;In function aztPlay command ACMD_PLAY_AUDIO added, should make&n;&t;&t;audio functions work. The Aztech drive needs different commands&n;&t;&t;to read data tracks and play audio tracks.&n;&t;&t;W.Zimmermann, Nov. 8, 1994&n;&t;V0.3    Recognition of missing drive during boot up improved (speeded up).&n;&t;&t;W.Zimmermann, Nov. 13, 1994&n;&t;V0.35   Rewrote the control mechanism in azt_poll (formerly mcd_poll) &n;&t;&t;including removal of all &squot;goto&squot; commands. :-); &n;&t;&t;J. Nardone, Nov. 14, 1994&n;&t;V0.4    Renamed variables and constants to &squot;azt&squot; instead of &squot;mcd&squot;; had&n;&t;&t;to make some &quot;compatibility&quot; defines in azt.h; please note,&n;&t;&t;that the source file was renamed to azt.c, the include file to&n;&t;&t;azt.h                &n;&t;&t;Speeded up drive recognition during init (will be a little bit &n;&t;&t;slower than before if no drive is installed!); suggested by&n;&t;&t;Robby Schirmer.&n;&t;&t;read_count declared volatile and set to AZT_BUF_SIZ to make&n;&t;&t;drive faster (now 300kB/sec, was 60kB/sec before, measured&n;&t;&t;by &squot;time dd if=/dev/cdrom of=/dev/null bs=2048 count=4096&squot;;&n;&t;&t;different AZT_BUF_SIZes were test, above 16 no further im-&n;&t;&t;provement seems to be possible; suggested by E.Moenkeberg.&n;&t;&t;W.Zimmermann, Nov. 18, 1994&n;&t;V0.42   Included getAztStatus command in GetQChannelInfo() to allow&n;&t;&t;reading Q-channel info on audio disks, if drive is stopped, &n;&t;&t;and some other bug fixes in the audio stuff, suggested by &n;&t;&t;Robby Schirmer.&n;&t;&t;Added more ioctls (reading data in mode 1 and mode 2).&n;&t;&t;Completely removed the old azt_poll() routine.&n;&t;&t;Detection of ORCHID CDS-3110 in aztcd_init implemented.&n;&t;&t;Additional debugging aids (see the readme file).&n;&t;&t;W.Zimmermann, Dec. 9, 1994  &n;&t;V0.50   Autodetection of drives implemented.&n;&t;&t;W.Zimmermann, Dec. 12, 1994&n;&t;V0.52   Prepared for including in the standard kernel, renamed most&n;&t;&t;variables to contain &squot;azt&squot;, included autoconf.h&n;&t;&t;W.Zimmermann, Dec. 16, 1994        &n;&t;V0.6    Version for being included in the standard Linux kernel.&n;&t;&t;Renamed source and header file to aztcd.c and aztcd.h&n;&t;&t;W.Zimmermann, Dec. 24, 1994&n;&t;V0.7    Changed VERIFY_READ to VERIFY_WRITE in aztcd_ioctl, case&n;&t;&t;CDROMREADMODE1 and CDROMREADMODE2; bug fix in the ioctl,&n;&t;&t;which causes kernel crashes when playing audio, changed &n;&t;&t;include-files (config.h instead of autoconf.h, removed&n;&t;&t;delay.h)&n;&t;&t;W.Zimmermann, Jan. 8, 1995&n;&t;V0.72   Some more modifications for adaption to the standard kernel.&n;&t;&t;W.Zimmermann, Jan. 16, 1995&n;        V0.80   aztcd is now part of the standard kernel since version 1.1.83.&n;                Modified the SET_TIMER and CLEAR_TIMER macros to comply with&n;                the new timer scheme.&n;                W.Zimmermann, Jan. 21, 1995&n;        V0.90   Included CDROMVOLCTRL, but with my Aztech drive I can only turn&n;                the channels on and off. If it works better with your drive, &n;                please mail me. Also implemented ACMD_CLOSE for CDROMSTART.&n;                W.Zimmermann, Jan. 24, 1995&n;&t;NOTE: &n;&t;Points marked with ??? are questionable !&n;*/
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR AZTECH_CDROM_MAJOR 
macro_line|#include &quot;blk.h&quot;
macro_line|#include &lt;linux/aztcd.h&gt;
DECL|variable|aztPresent
r_static
r_int
id|aztPresent
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
mdefine_line|#define AZT_TEST1 /* &lt;int-..&gt; */
mdefine_line|#define AZT_TEST2 /* do_aztcd_request */
mdefine_line|#define AZT_TEST3 /* AZT_S_state */
mdefine_line|#define AZT_TEST4 /* QUICK_LOOP-counter */
mdefine_line|#define AZT_TEST5 /* port(1) state */
mdefine_line|#define AZT_DEBUG
macro_line|#endif
DECL|macro|CURRENT_VALID
mdefine_line|#define CURRENT_VALID &bslash;&n;  (CURRENT &amp;&amp; MAJOR(CURRENT -&gt; dev) == MAJOR_NR &amp;&amp; CURRENT -&gt; cmd == READ &bslash;&n;   &amp;&amp; CURRENT -&gt; sector != -1)
DECL|macro|AFL_STATUSorDATA
mdefine_line|#define AFL_STATUSorDATA (AFL_STATUS | AFL_DATA)
DECL|macro|AZT_BUF_SIZ
mdefine_line|#define AZT_BUF_SIZ 16
DECL|variable|azt_transfer_is_active
r_static
r_volatile
r_int
id|azt_transfer_is_active
op_assign
l_int|0
suffix:semicolon
DECL|variable|azt_buf
r_static
r_char
id|azt_buf
(braket
l_int|2048
op_star
id|AZT_BUF_SIZ
)braket
suffix:semicolon
multiline_comment|/*buffer for block size conversion*/
macro_line|#ifdef AZT_PRIVATE_IOCTLS
DECL|variable|buf
r_static
r_char
id|buf
(braket
l_int|2336
)braket
suffix:semicolon
multiline_comment|/*separate buffer for the ioctls*/
macro_line|#endif
DECL|variable|azt_buf_bn
DECL|variable|azt_next_bn
r_static
r_volatile
r_int
id|azt_buf_bn
(braket
id|AZT_BUF_SIZ
)braket
comma
id|azt_next_bn
suffix:semicolon
DECL|variable|azt_buf_in
DECL|variable|azt_buf_out
r_static
r_volatile
r_int
id|azt_buf_in
comma
id|azt_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|azt_error
r_static
r_volatile
r_int
id|azt_error
op_assign
l_int|0
suffix:semicolon
DECL|variable|azt_open_count
r_static
r_int
id|azt_open_count
op_assign
l_int|0
suffix:semicolon
DECL|enum|azt_state_e
r_enum
id|azt_state_e
(brace
DECL|enumerator|AZT_S_IDLE
id|AZT_S_IDLE
comma
multiline_comment|/* 0 */
DECL|enumerator|AZT_S_START
id|AZT_S_START
comma
multiline_comment|/* 1 */
DECL|enumerator|AZT_S_MODE
id|AZT_S_MODE
comma
multiline_comment|/* 2 */
DECL|enumerator|AZT_S_READ
id|AZT_S_READ
comma
multiline_comment|/* 3 */
DECL|enumerator|AZT_S_DATA
id|AZT_S_DATA
comma
multiline_comment|/* 4 */
DECL|enumerator|AZT_S_STOP
id|AZT_S_STOP
comma
multiline_comment|/* 5 */
DECL|enumerator|AZT_S_STOPPING
id|AZT_S_STOPPING
multiline_comment|/* 6 */
)brace
suffix:semicolon
DECL|variable|azt_state
r_static
r_volatile
r_enum
id|azt_state_e
id|azt_state
op_assign
id|AZT_S_IDLE
suffix:semicolon
macro_line|#ifdef AZT_TEST3
DECL|variable|azt_state_old
r_static
r_volatile
r_enum
id|azt_state_e
id|azt_state_old
op_assign
id|AZT_S_STOP
suffix:semicolon
DECL|variable|azt_st_old
r_static
r_volatile
r_int
id|azt_st_old
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|azt_mode
r_static
r_int
id|azt_mode
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|ACMD_DATA_READ
r_static
r_int
id|ACMD_DATA_READ
op_assign
id|ACMD_PLAY_READ
suffix:semicolon
DECL|variable|azt_read_count
r_static
r_volatile
r_int
id|azt_read_count
op_assign
l_int|1
suffix:semicolon
DECL|macro|READ_TIMEOUT
mdefine_line|#define READ_TIMEOUT 3000
DECL|variable|azt_port
r_static
r_int
id|azt_port
op_assign
id|AZT_BASE_ADDR
suffix:semicolon
DECL|variable|azt_cont
r_static
r_char
id|azt_cont
op_assign
l_int|0
suffix:semicolon
DECL|variable|azt_init_end
r_static
r_char
id|azt_init_end
op_assign
l_int|0
suffix:semicolon
DECL|variable|AztTimeout
DECL|variable|AztTries
r_static
r_int
id|AztTimeout
comma
id|AztTries
suffix:semicolon
DECL|variable|azt_waitq
r_static
r_struct
id|wait_queue
op_star
id|azt_waitq
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|delay_timer
r_static
r_struct
id|timer_list
id|delay_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|DiskInfo
r_static
r_struct
id|azt_DiskInfo
id|DiskInfo
suffix:semicolon
DECL|variable|Toc
r_static
r_struct
id|azt_Toc
id|Toc
(braket
id|MAX_TRACKS
)braket
suffix:semicolon
DECL|variable|azt_Play
r_static
r_struct
id|azt_Play_msf
id|azt_Play
suffix:semicolon
DECL|variable|aztAudioStatus
r_static
r_int
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
DECL|variable|aztDiskChanged
r_static
r_char
id|aztDiskChanged
op_assign
l_int|1
suffix:semicolon
DECL|variable|aztTocUpToDate
r_static
r_char
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
r_static
r_void
id|azt_transfer
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|azt_poll
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|azt_invalidate_buffers
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_aztcd_request
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|azt_hsg2msf
c_func
(paren
r_int
id|hsg
comma
r_struct
id|msf
op_star
id|msf
)paren
suffix:semicolon
r_static
r_void
id|azt_bin2bcd
c_func
(paren
r_int
r_char
op_star
id|p
)paren
suffix:semicolon
r_static
r_int
id|azt_bcd2bin
c_func
(paren
r_int
r_char
id|bcd
)paren
suffix:semicolon
r_static
r_int
id|aztStatus
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|getAztStatus
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|aztSendCmd
c_func
(paren
r_int
id|cmd
)paren
suffix:semicolon
r_static
r_int
id|sendAztCmd
c_func
(paren
r_int
id|cmd
comma
r_struct
id|azt_Play_msf
op_star
id|params
)paren
suffix:semicolon
r_static
r_int
id|aztGetQChannelInfo
c_func
(paren
r_struct
id|azt_Toc
op_star
id|qp
)paren
suffix:semicolon
r_static
r_int
id|aztUpdateToc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|aztGetDiskInfo
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|aztGetToc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|aztGetValue
c_func
(paren
r_int
r_char
op_star
id|result
)paren
suffix:semicolon
r_static
r_void
id|aztStatTimer
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|aztIndatum
r_static
r_int
r_char
id|aztIndatum
suffix:semicolon
DECL|variable|aztTimeOutCount
r_static
r_int
r_int
id|aztTimeOutCount
suffix:semicolon
multiline_comment|/* Macros for the drive hardware interface handshake, these macros use&n;   busy waiting */
multiline_comment|/* Wait for OP_OK = drive answers with AFL_OP_OK after receiving a command*/
DECL|macro|OP_OK
macro_line|# define OP_OK op_ok()
DECL|function|op_ok
r_void
id|op_ok
c_func
(paren
r_void
)paren
(brace
id|aztTimeOutCount
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|aztIndatum
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|aztTimeOutCount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_TIMEOUT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: Error Wait OP_OK&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|aztIndatum
op_ne
id|AFL_OP_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for PA_OK = drive answers with AFL_PA_OK after receiving parameters*/
DECL|macro|PA_OK
macro_line|# define PA_OK pa_ok()
DECL|function|pa_ok
r_void
id|pa_ok
c_func
(paren
r_void
)paren
(brace
id|aztTimeOutCount
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|aztIndatum
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|aztTimeOutCount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_TIMEOUT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: Error Wait PA_OK&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|aztIndatum
op_ne
id|AFL_PA_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for STEN=Low = handshake signal &squot;AFL_.._OK available or command executed*/
DECL|macro|STEN_LOW
macro_line|# define STEN_LOW  sten_low()
DECL|function|sten_low
r_void
id|sten_low
c_func
(paren
r_void
)paren
(brace
id|aztTimeOutCount
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|aztIndatum
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
suffix:semicolon
id|aztTimeOutCount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_TIMEOUT
)paren
(brace
r_if
c_cond
(paren
id|azt_init_end
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: Error Wait STEN_LOW&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|aztIndatum
op_amp
id|AFL_STATUS
)paren
suffix:semicolon
)brace
multiline_comment|/* Wait for DTEN=Low = handshake signal &squot;Data available&squot;*/
DECL|macro|DTEN_LOW
macro_line|# define DTEN_LOW dten_low()
DECL|function|dten_low
r_void
id|dten_low
c_func
(paren
r_void
)paren
(brace
id|aztTimeOutCount
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|aztIndatum
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
suffix:semicolon
id|aztTimeOutCount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_TIMEOUT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: Error Wait DTEN_OK&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|aztIndatum
op_amp
id|AFL_DATA
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Macro for timer wait on STEN=Low, should only be used for &squot;slow&squot; commands;&n; * may cause kernel panic when used in the wrong place&n;*/
DECL|macro|STEN_LOW_WAIT
mdefine_line|#define STEN_LOW_WAIT   statusAzt()
DECL|function|statusAzt
r_void
id|statusAzt
c_func
(paren
r_void
)paren
(brace
id|AztTimeout
op_assign
id|AZT_STATUS_DELAY
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|aztStatTimer
comma
l_int|1
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|azt_waitq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|AztTimeout
op_le
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: Error Wait STEN_LOW_WAIT&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|aztStatTimer
r_static
r_void
id|aztStatTimer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|AFL_STATUS
)paren
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|azt_waitq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|AztTimeout
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|AztTimeout
op_le
l_int|0
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|azt_waitq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SET_TIMER
c_func
(paren
id|aztStatTimer
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|aztcd_setup
r_void
id|aztcd_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|azt_port
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|1
)paren
id|azt_cont
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
)brace
multiline_comment|/* &n; * Send a single command, return -1 on error, else 0&n;*/
DECL|function|aztSendCmd
r_static
r_int
id|aztSendCmd
c_func
(paren
r_int
id|cmd
)paren
(brace
r_int
r_char
id|data
suffix:semicolon
r_int
id|retry
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: Executing command %x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|POLLED
comma
id|MODE_PORT
)paren
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|AFL_STATUS
)paren
r_break
suffix:semicolon
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
multiline_comment|/* if status left from last command, read and */
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* discard it */
r_do
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|AFL_DATA
)paren
r_break
suffix:semicolon
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
multiline_comment|/* if data left from last command, read and */
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* discard it */
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|AZT_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|outb
c_func
(paren
(paren
r_int
r_char
)paren
id|cmd
comma
id|CMD_PORT
)paren
suffix:semicolon
id|STEN_LOW
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
id|AFL_OP_OK
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*OP_OK?*/
r_if
c_cond
(paren
id|data
op_eq
id|AFL_OP_ERR
)paren
(brace
id|STEN_LOW
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;### Error 1 aztcd: aztSendCmd %x  Error Code %x&bslash;n&quot;
comma
id|cmd
comma
id|data
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|retry
op_ge
id|AZT_RETRY_ATTEMPTS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;### Error 2 aztcd: aztSendCmd %x &bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|azt_error
op_assign
l_int|0xA5
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a play or read command to the drive, return -1 on error, else 0&n;*/
DECL|function|sendAztCmd
r_static
r_int
id|sendAztCmd
c_func
(paren
r_int
id|cmd
comma
r_struct
id|azt_Play_msf
op_star
id|params
)paren
(brace
r_int
r_char
id|data
suffix:semicolon
r_int
id|retry
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;start=%02x:%02x:%02x  end=%02x:%02x:%02x&bslash;n&quot;
comma
"&bslash;"
id|params-&gt;start.min
comma
id|params-&gt;start.sec
comma
id|params-&gt;start.frame
comma
"&bslash;"
id|params-&gt;end.min
comma
id|params-&gt;end.sec
comma
id|params-&gt;end.frame
)paren
suffix:semicolon
macro_line|#endif   
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|AZT_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|aztSendCmd
c_func
(paren
id|cmd
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.min
comma
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.sec
comma
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.frame
comma
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.min
comma
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.sec
comma
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.frame
comma
id|CMD_PORT
)paren
suffix:semicolon
id|STEN_LOW
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|data
op_eq
id|AFL_PA_OK
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*PA_OK ?*/
r_if
c_cond
(paren
id|data
op_eq
id|AFL_PA_ERR
)paren
(brace
id|STEN_LOW
suffix:semicolon
id|data
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;### Error 1 aztcd: sendAztCmd %x  Error Code %x&bslash;n&quot;
comma
id|cmd
comma
id|data
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|retry
op_ge
id|AZT_RETRY_ATTEMPTS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;### Error 2 aztcd: sendAztCmd %x&bslash;n &quot;
comma
id|cmd
)paren
suffix:semicolon
id|azt_error
op_assign
l_int|0xA5
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* &n; * Checking if the media has been changed not yet implemented&n;*/
DECL|function|check_aztcd_media_change
r_static
r_int
id|check_aztcd_media_change
c_func
(paren
id|dev_t
id|full_dev
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* used in azt_poll to poll the status, expects another program to issue a &n; * ACMD_GET_STATUS directly before &n; */
DECL|function|aztStatus
r_static
r_int
id|aztStatus
c_func
(paren
r_void
)paren
(brace
r_int
id|st
suffix:semicolon
r_int
id|i
suffix:semicolon
id|i
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|AFL_STATUS
suffix:semicolon
multiline_comment|/* is STEN=0?    ???*/
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|st
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_return
id|st
suffix:semicolon
)brace
r_else
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Get the drive status&n; */
DECL|function|getAztStatus
r_static
r_int
id|getAztStatus
c_func
(paren
r_void
)paren
(brace
r_int
id|st
suffix:semicolon
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_GET_STATUS
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|STEN_LOW
suffix:semicolon
id|st
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
op_amp
l_int|0xFF
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: Status = %x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|st
op_eq
l_int|0xFF
)paren
op_logical_or
(paren
id|st
op_amp
id|AST_CMD_CHECK
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: AST_CMD_CHECK error or no status available&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
id|st
op_amp
id|AST_MODE_BITS
)paren
op_ne
id|AST_BUSY
)paren
op_logical_and
(paren
id|aztAudioStatus
op_eq
id|CDROM_AUDIO_PLAY
)paren
)paren
multiline_comment|/* XXX might be an error? look at q-channel? */
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_COMPLETED
suffix:semicolon
r_if
c_cond
(paren
id|st
op_amp
id|AST_DSK_CHG
)paren
(brace
id|aztDiskChanged
op_assign
l_int|1
suffix:semicolon
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
)brace
r_return
id|st
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a &squot;Play&squot; command and get the status.  Use only from the top half.&n; */
DECL|function|aztPlay
r_static
r_int
id|aztPlay
c_func
(paren
r_struct
id|azt_Play_msf
op_star
id|arg
)paren
(brace
r_if
c_cond
(paren
id|sendAztCmd
c_func
(paren
id|ACMD_PLAY_AUDIO
comma
id|arg
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|azt_msf2hsg
r_int
id|azt_msf2hsg
c_func
(paren
r_struct
id|msf
op_star
id|mp
)paren
(brace
macro_line|#ifdef AZT_DEBUG
r_if
c_cond
(paren
id|mp-&gt;min
op_ge
l_int|70
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: Error msf2hsg address Minutes&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;sec
op_ge
l_int|60
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: Error msf2hsg address Seconds&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mp-&gt;frame
op_ge
l_int|75
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: Error msf2hsg address Frames&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|azt_bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|frame
)paren
op_plus
id|azt_bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|sec
)paren
op_star
l_int|75
op_plus
id|azt_bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|min
)paren
op_star
l_int|4500
op_minus
l_int|150
suffix:semicolon
)brace
DECL|function|aztcd_ioctl
r_static
r_int
id|aztcd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|i
comma
id|st
suffix:semicolon
r_struct
id|azt_Toc
id|qInfo
suffix:semicolon
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_struct
id|cdrom_tochdr
id|tocHdr
suffix:semicolon
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_struct
id|cdrom_tocentry
id|entry
suffix:semicolon
r_struct
id|azt_Toc
op_star
id|tocPtr
suffix:semicolon
r_struct
id|cdrom_subchnl
id|subchnl
suffix:semicolon
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: starting aztcd_ioctl - Command:%x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ip
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|getAztStatus
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aztTocUpToDate
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_assign
id|aztUpdateToc
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
r_return
id|i
suffix:semicolon
multiline_comment|/* error reading TOC */
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSTART
suffix:colon
multiline_comment|/* Spin up the drive. Don&squot;t know, what to do,&n;&t;                        at least close the tray */
macro_line|#ifdef AZT_PRIVATE_IOCTLS 
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_CLOSE
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
macro_line|#endif
r_break
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
multiline_comment|/* Spin down the drive */
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_STOP
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
multiline_comment|/* should we do anything if it fails? */
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPAUSE
suffix:colon
multiline_comment|/* Pause the drive */
r_if
c_cond
(paren
id|aztAudioStatus
op_ne
id|CDROM_AUDIO_PLAY
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|aztGetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* didn&squot;t get q channel info */
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|azt_Play.start
op_assign
id|qInfo.diskTime
suffix:semicolon
multiline_comment|/* remember restart point */
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_PAUSE
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
multiline_comment|/* Play it again, Sam */
r_if
c_cond
(paren
id|aztAudioStatus
op_ne
id|CDROM_AUDIO_PAUSED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* restart the drive at the saved position. */
id|i
op_assign
id|aztPlay
c_func
(paren
op_amp
id|azt_Play
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPLAYTRKIND
suffix:colon
multiline_comment|/* Play a track.  This currently ignores index. */
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|ti
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ti.cdti_trk0
template_param
id|DiskInfo.last
op_logical_or
id|ti.cdti_trk1
OL
id|ti.cdti_trk0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ti.cdti_trk1
OG
id|DiskInfo.last
)paren
id|ti
dot
id|cdti_trk1
op_assign
id|DiskInfo.last
suffix:semicolon
id|azt_Play.start
op_assign
id|Toc
(braket
id|ti.cdti_trk0
)braket
dot
id|diskTime
suffix:semicolon
id|azt_Play.end
op_assign
id|Toc
(braket
id|ti.cdti_trk1
op_plus
l_int|1
)braket
dot
id|diskTime
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd play: %02x:%02x.%02x to %02x:%02x.%02x&bslash;n&quot;
comma
id|azt_Play.start.min
comma
id|azt_Play.start.sec
comma
id|azt_Play.start.frame
comma
id|azt_Play.end.min
comma
id|azt_Play.end.sec
comma
id|azt_Play.end.frame
)paren
suffix:semicolon
macro_line|#endif
id|i
op_assign
id|aztPlay
c_func
(paren
op_amp
id|azt_Play
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMPLAYMSF
suffix:colon
multiline_comment|/* Play starting at the given MSF address. */
multiline_comment|/*              if (aztAudioStatus == CDROM_AUDIO_PLAY) &n;&t;&t;{ if (aztSendCmd(ACMD_STOP)) return -1;&n;&t;&t;  STEN_LOW;&n;&t;&t;  aztAudioStatus = CDROM_AUDIO_NO_STATUS;&n;&t;&t;}&n;*/
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
multiline_comment|/* convert to bcd */
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_min0
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_sec0
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_frame0
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_min1
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_sec1
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_frame1
)paren
suffix:semicolon
id|azt_Play.start.min
op_assign
id|msf.cdmsf_min0
suffix:semicolon
id|azt_Play.start.sec
op_assign
id|msf.cdmsf_sec0
suffix:semicolon
id|azt_Play.start.frame
op_assign
id|msf.cdmsf_frame0
suffix:semicolon
id|azt_Play.end.min
op_assign
id|msf.cdmsf_min1
suffix:semicolon
id|azt_Play.end.sec
op_assign
id|msf.cdmsf_sec1
suffix:semicolon
id|azt_Play.end.frame
op_assign
id|msf.cdmsf_frame1
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd play: %02x:%02x.%02x to %02x:%02x.%02x&bslash;n&quot;
comma
id|azt_Play.start.min
comma
id|azt_Play.start.sec
comma
id|azt_Play.start.frame
comma
id|azt_Play.end.min
comma
id|azt_Play.end.sec
comma
id|azt_Play.end.frame
)paren
suffix:semicolon
macro_line|#endif
id|i
op_assign
id|aztPlay
c_func
(paren
op_amp
id|azt_Play
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADTOCHDR
suffix:colon
multiline_comment|/* Read the table of contents header */
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|tocHdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|tocHdr.cdth_trk0
op_assign
id|DiskInfo.first
suffix:semicolon
id|tocHdr.cdth_trk1
op_assign
id|DiskInfo.last
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|tocHdr
comma
r_sizeof
id|tocHdr
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADTOCENTRY
suffix:colon
multiline_comment|/* Read an entry in the table of contents */
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|entry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|aztTocUpToDate
)paren
id|aztGetDiskInfo
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry.cdte_track
op_eq
id|CDROM_LEADOUT
)paren
id|tocPtr
op_assign
op_amp
id|Toc
(braket
id|DiskInfo.last
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* ??? */
r_else
r_if
c_cond
(paren
id|entry.cdte_track
OG
id|DiskInfo.last
op_logical_or
id|entry.cdte_track
OL
id|DiskInfo.first
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_else
id|tocPtr
op_assign
op_amp
id|Toc
(braket
id|entry.cdte_track
)braket
suffix:semicolon
id|entry.cdte_adr
op_assign
id|tocPtr
op_member_access_from_pointer
id|ctrl_addr
suffix:semicolon
id|entry.cdte_ctrl
op_assign
id|tocPtr
op_member_access_from_pointer
id|ctrl_addr
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
id|CDROM_LBA
)paren
id|entry.cdte_addr.lba
op_assign
id|azt_msf2hsg
c_func
(paren
op_amp
id|tocPtr
op_member_access_from_pointer
id|diskTime
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
id|entry.cdte_addr.msf.minute
op_assign
id|azt_bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.min
)paren
suffix:semicolon
id|entry.cdte_addr.msf.second
op_assign
id|azt_bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.sec
)paren
suffix:semicolon
id|entry.cdte_addr.msf.frame
op_assign
id|azt_bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.frame
)paren
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|entry
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMSUBCHNL
suffix:colon
multiline_comment|/* Get subchannel info */
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|subchnl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|subchnl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|subchnl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|subchnl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztGetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|subchnl.cdsc_audiostatus
op_assign
id|aztAudioStatus
suffix:semicolon
id|subchnl.cdsc_adr
op_assign
id|qInfo.ctrl_addr
suffix:semicolon
id|subchnl.cdsc_ctrl
op_assign
id|qInfo.ctrl_addr
op_rshift
l_int|4
suffix:semicolon
id|subchnl.cdsc_trk
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.track
)paren
suffix:semicolon
id|subchnl.cdsc_ind
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.pointIndex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subchnl.cdsc_format
op_eq
id|CDROM_LBA
)paren
(brace
id|subchnl.cdsc_absaddr.lba
op_assign
id|azt_msf2hsg
c_func
(paren
op_amp
id|qInfo.diskTime
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.lba
op_assign
id|azt_msf2hsg
c_func
(paren
op_amp
id|qInfo.trackTime
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|subchnl.cdsc_format
op_eq
id|CDROM_MSF
)paren
(brace
id|subchnl.cdsc_absaddr.msf.minute
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.diskTime.min
)paren
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.second
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.diskTime.sec
)paren
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.frame
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.diskTime.frame
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.minute
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.trackTime.min
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.second
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.trackTime.sec
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.frame
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.trackTime.frame
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|subchnl
comma
r_sizeof
id|subchnl
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMVOLCTRL
suffix:colon
multiline_comment|/* Volume control &n;&t; * With my Aztech CD268-01A volume control does not work, I can only&n;&t;   turn the cannels on (any value !=0) or off (value==0). Maybe it&n;           works better with your drive */
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
(paren
id|st
)paren
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|volctrl
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
id|azt_Play.start.min
op_assign
l_int|0x21
suffix:semicolon
id|azt_Play.start.sec
op_assign
l_int|0x84
suffix:semicolon
id|azt_Play.start.frame
op_assign
id|volctrl.channel0
suffix:semicolon
id|azt_Play.end.min
op_assign
id|volctrl.channel1
suffix:semicolon
id|azt_Play.end.sec
op_assign
id|volctrl.channel2
suffix:semicolon
id|azt_Play.end.frame
op_assign
id|volctrl.channel3
suffix:semicolon
id|sendAztCmd
c_func
(paren
id|ACMD_SET_VOLUME
comma
op_amp
id|azt_Play
)paren
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMEJECT
suffix:colon
multiline_comment|/* all drives can at least stop! */
r_if
c_cond
(paren
id|aztAudioStatus
op_eq
id|CDROM_AUDIO_PLAY
)paren
(brace
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_STOP
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_EJECT
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|aztAudioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CDROMREADMODE1
suffix:colon
multiline_comment|/*read data in mode 1 (2048 Bytes)*/
r_case
id|CDROMREADMODE2
suffix:colon
multiline_comment|/*read data in mode 2 (2336 Bytes)*/
multiline_comment|/*Take care, the following code is not compatible with other CD-ROM drivers,&n;  use it at your own risk with cdplay.c. Normally it is not activated, as &n;  AZT_PRIVATE_IOCTLS is not defined&n;*/
macro_line|#ifdef AZT_PRIVATE_IOCTLS 
(brace
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
multiline_comment|/* convert to bcd */
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_min0
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_sec0
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_frame0
)paren
suffix:semicolon
id|msf.cdmsf_min1
op_assign
l_int|0
suffix:semicolon
id|msf.cdmsf_sec1
op_assign
l_int|0
suffix:semicolon
id|msf.cdmsf_frame1
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*read only one frame*/
id|azt_Play.start.min
op_assign
id|msf.cdmsf_min0
suffix:semicolon
id|azt_Play.start.sec
op_assign
id|msf.cdmsf_sec0
suffix:semicolon
id|azt_Play.start.frame
op_assign
id|msf.cdmsf_frame0
suffix:semicolon
id|azt_Play.end.min
op_assign
id|msf.cdmsf_min1
suffix:semicolon
id|azt_Play.end.sec
op_assign
id|msf.cdmsf_sec1
suffix:semicolon
id|azt_Play.end.frame
op_assign
id|msf.cdmsf_frame1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|CDROMREADMODE1
)paren
(brace
id|sendAztCmd
c_func
(paren
id|ACMD_DATA_READ
comma
op_amp
id|azt_Play
)paren
suffix:semicolon
id|DTEN_LOW
suffix:semicolon
id|insb
c_func
(paren
id|DATA_PORT
comma
id|buf
comma
l_int|2048
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|buf
comma
l_int|2048
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/*CDROMREADMODE2*/
(brace
id|sendAztCmd
c_func
(paren
id|ACMD_DATA_READ_RAW
comma
op_amp
id|azt_Play
)paren
suffix:semicolon
id|DTEN_LOW
suffix:semicolon
id|insb
c_func
(paren
id|DATA_PORT
comma
id|buf
comma
l_int|2336
)paren
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|buf
comma
l_int|2336
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif  /*end of incompatible code*/               
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: exiting aztcd_ioctl&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Take care of the different block sizes between cdrom and Linux.&n; * When Linux gets variable block sizes this will probably go away.&n; */
DECL|function|azt_transfer
r_static
r_void
id|azt_transfer
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef AZT_TEST
id|printk
c_func
(paren
l_string|&quot;aztcd: executing azt_transfer&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
(brace
r_while
c_loop
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
)paren
(brace
r_int
id|bn
op_assign
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AZT_BUF_SIZ
op_logical_and
id|azt_buf_bn
(braket
id|i
)braket
op_ne
id|bn
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|AZT_BUF_SIZ
)paren
(brace
r_int
id|offs
op_assign
(paren
id|i
op_star
l_int|4
op_plus
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_amp
l_int|3
)paren
)paren
op_star
l_int|512
suffix:semicolon
r_int
id|nr_sectors
op_assign
l_int|4
op_minus
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|azt_buf_out
op_ne
id|i
)paren
(brace
id|azt_buf_out
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|azt_buf_bn
(braket
id|i
)braket
op_ne
id|bn
)paren
(brace
id|azt_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nr_sectors
OG
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
)paren
id|nr_sectors
op_assign
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
suffix:semicolon
id|memcpy
c_func
(paren
id|CURRENT
op_member_access_from_pointer
id|buffer
comma
id|azt_buf
op_plus
id|offs
comma
id|nr_sectors
op_star
l_int|512
)paren
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_sub_assign
id|nr_sectors
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|sector
op_add_assign
id|nr_sectors
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|buffer
op_add_assign
id|nr_sectors
op_star
l_int|512
suffix:semicolon
)brace
r_else
(brace
id|azt_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|do_aztcd_request
r_static
r_void
id|do_aztcd_request
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef AZT_TEST
id|printk
c_func
(paren
l_string|&quot; do_aztcd_request(%ld+%ld)&bslash;n&quot;
comma
id|CURRENT
op_member_access_from_pointer
id|sector
comma
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
)paren
suffix:semicolon
macro_line|#endif
id|azt_transfer_is_active
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
(brace
r_if
c_cond
(paren
id|CURRENT-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|CURRENT-&gt;bh-&gt;b_lock
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
)brace
id|azt_transfer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_eq
l_int|0
)paren
(brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|azt_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Want to read a block not in buffer */
r_if
c_cond
(paren
id|azt_state
op_eq
id|AZT_S_IDLE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|aztTocUpToDate
)paren
(brace
r_if
c_cond
(paren
id|aztUpdateToc
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|azt_state
op_assign
id|AZT_S_START
suffix:semicolon
id|AztTries
op_assign
l_int|5
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|azt_poll
comma
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|azt_transfer_is_active
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef AZT_TEST2
id|printk
c_func
(paren
l_string|&quot;azt_next_bn:%x  azt_buf_in:%x azt_buf_out:%x  azt_buf_bn:%x&bslash;n&quot;
comma
"&bslash;"
id|azt_next_bn
comma
id|azt_buf_in
comma
id|azt_buf_out
comma
id|azt_buf_bn
(braket
id|azt_buf_in
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; do_aztcd_request ends&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|azt_poll
r_static
r_void
id|azt_poll
c_func
(paren
r_void
)paren
(brace
r_int
id|st
op_assign
l_int|0
suffix:semicolon
r_int
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_int
id|skip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|azt_error
)paren
(brace
multiline_comment|/* ???*/
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_GET_ERROR
)paren
)paren
r_return
suffix:semicolon
id|STEN_LOW
suffix:semicolon
id|azt_error
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;aztcd: I/O error 0x%02x&bslash;n&quot;
comma
id|azt_error
)paren
suffix:semicolon
id|azt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef WARN_IF_READ_FAILURE
r_if
c_cond
(paren
id|AztTries
op_eq
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: read of block %d failed - maybe audio disk?&bslash;n&quot;
comma
id|azt_next_bn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|AztTries
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: read of block %d failed, maybe audio disk? Giving up&bslash;n&quot;
comma
id|azt_next_bn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|azt_transfer_is_active
)paren
(brace
id|AztTries
op_assign
l_int|0
suffix:semicolon
id|loop_ctl
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|AztTries
op_assign
l_int|5
suffix:semicolon
)brace
id|azt_error
op_assign
l_int|0
suffix:semicolon
id|azt_state
op_assign
id|AZT_S_STOP
suffix:semicolon
)brace
r_while
c_loop
(paren
id|loop_ctl
)paren
(brace
id|loop_ctl
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* each case must flip this back to 1 if we want&n;&t;&t;&t; to come back up here */
r_switch
c_cond
(paren
id|azt_state
)paren
(brace
r_case
id|AZT_S_IDLE
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|azt_state
op_ne
id|azt_state_old
)paren
(brace
id|azt_state_old
op_assign
id|azt_state
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AZT_S_IDLE&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
suffix:semicolon
r_case
id|AZT_S_START
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|azt_state
op_ne
id|azt_state_old
)paren
(brace
id|azt_state_old
op_assign
id|azt_state
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AZT_S_START&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_GET_STATUS
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
multiline_comment|/*result will be checked by aztStatus() */
id|azt_state
op_assign
id|azt_mode
op_eq
l_int|1
ques
c_cond
id|AZT_S_READ
suffix:colon
id|AZT_S_MODE
suffix:semicolon
id|AztTimeout
op_assign
l_int|3000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AZT_S_MODE
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|azt_state
op_ne
id|azt_state_old
)paren
(brace
id|azt_state_old
op_assign
id|azt_state
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AZT_S_MODE&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|skip
)paren
(brace
r_if
c_cond
(paren
(paren
id|st
op_assign
id|aztStatus
c_func
(paren
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|st
op_amp
id|AST_DSK_CHG
)paren
(brace
id|aztDiskChanged
op_assign
l_int|1
suffix:semicolon
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|azt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_break
suffix:semicolon
)brace
id|skip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_amp
id|AST_DOOR_OPEN
)paren
op_logical_or
(paren
id|st
op_amp
id|AST_NOT_READY
)paren
)paren
(brace
id|aztDiskChanged
op_assign
l_int|1
suffix:semicolon
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
(paren
id|st
op_amp
id|AST_DOOR_OPEN
)paren
ques
c_cond
l_string|&quot;aztcd: door open&bslash;n&quot;
suffix:colon
l_string|&quot;aztcd: disk removed&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|azt_transfer_is_active
)paren
(brace
id|azt_state
op_assign
id|AZT_S_START
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* goto immediately */
r_break
suffix:semicolon
)brace
id|azt_state
op_assign
id|AZT_S_IDLE
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*???*/
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_SET_MODE
)paren
)paren
r_return
suffix:semicolon
id|outb
c_func
(paren
l_int|0x01
comma
id|DATA_PORT
)paren
suffix:semicolon
multiline_comment|/*Mode 1*/
id|PA_OK
suffix:semicolon
id|STEN_LOW
suffix:semicolon
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_GET_STATUS
)paren
)paren
r_return
suffix:semicolon
id|azt_mode
op_assign
l_int|1
suffix:semicolon
id|azt_state
op_assign
id|AZT_S_READ
suffix:semicolon
id|AztTimeout
op_assign
l_int|3000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AZT_S_READ
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|azt_state
op_ne
id|azt_state_old
)paren
(brace
id|azt_state_old
op_assign
id|azt_state
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AZT_S_READ&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|skip
)paren
(brace
r_if
c_cond
(paren
(paren
id|st
op_assign
id|aztStatus
c_func
(paren
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|st
op_amp
id|AST_DSK_CHG
)paren
(brace
id|aztDiskChanged
op_assign
l_int|1
suffix:semicolon
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|azt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_break
suffix:semicolon
)brace
id|skip
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_amp
id|AST_DOOR_OPEN
)paren
op_logical_or
(paren
id|st
op_amp
id|AST_NOT_READY
)paren
)paren
(brace
id|aztDiskChanged
op_assign
l_int|1
suffix:semicolon
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
(paren
id|st
op_amp
id|AST_DOOR_OPEN
)paren
ques
c_cond
l_string|&quot;aztcd: door open&bslash;n&quot;
suffix:colon
l_string|&quot;aztcd: disk removed&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|azt_transfer_is_active
)paren
(brace
id|azt_state
op_assign
id|AZT_S_START
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|azt_state
op_assign
id|AZT_S_IDLE
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
(brace
r_struct
id|azt_Play_msf
id|msf
suffix:semicolon
id|azt_next_bn
op_assign
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
suffix:semicolon
id|azt_hsg2msf
c_func
(paren
id|azt_next_bn
comma
op_amp
id|msf.start
)paren
suffix:semicolon
id|azt_read_count
op_assign
id|AZT_BUF_SIZ
suffix:semicolon
multiline_comment|/*??? fast, because we read ahead*/
multiline_comment|/*          azt_read_count= CURRENT-&gt;nr_sectors;      slow&n;*/
id|msf.end.min
op_assign
l_int|0
suffix:semicolon
id|msf.end.sec
op_assign
l_int|0
suffix:semicolon
id|msf.end.frame
op_assign
id|azt_read_count
suffix:semicolon
multiline_comment|/*Mitsumi here reads 0xffffff sectors*/
macro_line|#ifdef AZT_TEST3
id|printk
c_func
(paren
l_string|&quot;---reading msf-address %x:%x:%x  %x:%x:%x&bslash;n&quot;
comma
id|msf.start.min
comma
id|msf.start.sec
comma
id|msf.start.frame
comma
id|msf.end.min
comma
id|msf.end.sec
comma
id|msf.end.frame
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;azt_next_bn:%x  azt_buf_in:%x azt_buf_out:%x  azt_buf_bn:%x&bslash;n&quot;
comma
"&bslash;"
id|azt_next_bn
comma
id|azt_buf_in
comma
id|azt_buf_out
comma
id|azt_buf_bn
(braket
id|azt_buf_in
)braket
)paren
suffix:semicolon
macro_line|#endif 
id|sendAztCmd
c_func
(paren
id|ACMD_DATA_READ
comma
op_amp
id|msf
)paren
suffix:semicolon
id|azt_state
op_assign
id|AZT_S_DATA
suffix:semicolon
id|AztTimeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
)brace
r_else
(brace
id|azt_state
op_assign
id|AZT_S_STOP
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AZT_S_DATA
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|azt_state
op_ne
id|azt_state_old
)paren
(brace
id|azt_state_old
op_assign
id|azt_state
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AZT_S_DATA&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|st
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|AFL_STATUSorDATA
suffix:semicolon
multiline_comment|/*???*/
r_switch
c_cond
(paren
id|st
)paren
(brace
r_case
id|AFL_DATA
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|st
op_ne
id|azt_st_old
)paren
(brace
id|azt_st_old
op_assign
id|st
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---AFL_DATA st:%x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef WARN_IF_READ_FAILURE
r_if
c_cond
(paren
id|AztTries
op_eq
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: read of block %d failed - maybe audio disk?&bslash;n&quot;
comma
id|azt_next_bn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|AztTries
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: read of block %d failed, maybe audio disk ? Giving up&bslash;n&quot;
comma
id|azt_next_bn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|azt_transfer_is_active
)paren
(brace
id|AztTries
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|AztTries
op_assign
l_int|5
suffix:semicolon
)brace
id|azt_state
op_assign
id|AZT_S_START
suffix:semicolon
id|AztTimeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AFL_STATUSorDATA
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|st
op_ne
id|azt_st_old
)paren
(brace
id|azt_st_old
op_assign
id|st
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---AFL_STATUSorDATA st:%x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
)brace
macro_line|#endif
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|st
op_ne
id|azt_st_old
)paren
(brace
id|azt_st_old
op_assign
id|st
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;---default: st:%x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
)brace
macro_line|#endif
id|AztTries
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CURRENT_VALID
op_logical_and
id|azt_buf_in
op_eq
id|azt_buf_out
)paren
(brace
id|azt_state
op_assign
id|AZT_S_STOP
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|azt_read_count
op_le
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: warning - try to read 0 frames&bslash;n&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|azt_read_count
)paren
multiline_comment|/*??? fast read ahead loop*/
(brace
id|azt_buf_bn
(braket
id|azt_buf_in
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|DTEN_LOW
suffix:semicolon
multiline_comment|/*??? unsolved problem, very&n;&t;&t;&t;&t;&t;&t;      seldom we get timeouts&n;&t;&t;&t;&t;&t;&t;      here, don&squot;t now the real&n;&t;&t;&t;&t;&t;&t;      reason. With my drive this&n;&t;&t;&t;&t;&t;&t;      sometimes also happens with&n;&t;&t;&t;&t;&t;&t;      Aztech&squot;s original driver under&n;&t;&t;&t;&t;&t;&t;      DOS. Is it a hardware bug? &n;&t;&t;&t;&t;&t;&t;      I tried to recover from such&n;&t;&t;&t;&t;&t;&t;      situations here. Zimmermann*/
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_TIMEOUT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;read_count:%d CURRENT-&gt;nr_sectors:%ld azt_buf_in:%d&bslash;n&quot;
comma
id|azt_read_count
comma
id|CURRENT-&gt;nr_sectors
comma
id|azt_buf_in
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;azt_transfer_is_active:%x&bslash;n&quot;
comma
id|azt_transfer_is_active
)paren
suffix:semicolon
id|azt_read_count
op_assign
l_int|0
suffix:semicolon
id|azt_state
op_assign
id|AZT_S_STOP
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/*should we have here (1) or (0)? */
)brace
r_else
(brace
id|insb
c_func
(paren
id|DATA_PORT
comma
id|azt_buf
op_plus
l_int|2048
op_star
id|azt_buf_in
comma
l_int|2048
)paren
suffix:semicolon
id|azt_read_count
op_decrement
suffix:semicolon
macro_line|#ifdef AZT_TEST3
id|printk
c_func
(paren
l_string|&quot;AZT_S_DATA; ---I&squot;ve read data- read_count: %d&bslash;n&quot;
comma
id|azt_read_count
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;azt_next_bn:%d  azt_buf_in:%d azt_buf_out:%d  azt_buf_bn:%d&bslash;n&quot;
comma
"&bslash;"
id|azt_next_bn
comma
id|azt_buf_in
comma
id|azt_buf_out
comma
id|azt_buf_bn
(braket
id|azt_buf_in
)braket
)paren
suffix:semicolon
macro_line|#endif
id|azt_buf_bn
(braket
id|azt_buf_in
)braket
op_assign
id|azt_next_bn
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|azt_buf_out
op_eq
op_minus
l_int|1
)paren
id|azt_buf_out
op_assign
id|azt_buf_in
suffix:semicolon
id|azt_buf_in
op_assign
id|azt_buf_in
op_plus
l_int|1
op_eq
id|AZT_BUF_SIZ
ques
c_cond
l_int|0
suffix:colon
id|azt_buf_in
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|azt_transfer_is_active
)paren
(brace
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
(brace
id|azt_transfer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_eq
l_int|0
)paren
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
op_logical_and
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
template_param
id|azt_next_bn
op_plus
id|AZT_BUF_SIZ
)paren
)paren
(brace
id|azt_state
op_assign
id|AZT_S_STOP
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|AztTimeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
r_if
c_cond
(paren
id|azt_read_count
op_eq
l_int|0
)paren
(brace
id|azt_state
op_assign
id|AZT_S_STOP
suffix:semicolon
multiline_comment|/*???*/
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AZT_S_STOP
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|azt_state
op_ne
id|azt_state_old
)paren
(brace
id|azt_state_old
op_assign
id|azt_state
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AZT_S_STOP&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|azt_read_count
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: discard data=%x frames&bslash;n&quot;
comma
id|azt_read_count
)paren
suffix:semicolon
multiline_comment|/*???*/
r_while
c_loop
(paren
id|azt_read_count
op_ne
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|STATUS_PORT
)paren
op_amp
id|AFL_DATA
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2048
suffix:semicolon
id|i
op_increment
)paren
(brace
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
)brace
)brace
id|azt_read_count
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_GET_STATUS
)paren
)paren
r_return
suffix:semicolon
id|azt_state
op_assign
id|AZT_S_STOPPING
suffix:semicolon
id|AztTimeout
op_assign
l_int|1000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AZT_S_STOPPING
suffix:colon
macro_line|#ifdef AZT_TEST3
r_if
c_cond
(paren
id|azt_state
op_ne
id|azt_state_old
)paren
(brace
id|azt_state_old
op_assign
id|azt_state
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;AZT_S_STOPPING&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
(paren
id|st
op_assign
id|aztStatus
c_func
(paren
)paren
)paren
op_eq
op_minus
l_int|1
op_logical_and
id|AztTimeout
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_ne
op_minus
l_int|1
)paren
op_logical_and
(paren
id|st
op_amp
id|AST_DSK_CHG
)paren
)paren
(brace
id|aztDiskChanged
op_assign
l_int|1
suffix:semicolon
id|aztTocUpToDate
op_assign
l_int|0
suffix:semicolon
id|azt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef AZT_TEST3
id|printk
c_func
(paren
l_string|&quot;CURRENT_VALID %d azt_mode %d&bslash;n&quot;
comma
id|CURRENT_VALID
comma
id|azt_mode
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
(brace
r_if
c_cond
(paren
id|st
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|azt_mode
op_eq
l_int|1
)paren
(brace
id|azt_state
op_assign
id|AZT_S_READ
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
id|skip
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
(brace
id|azt_state
op_assign
id|AZT_S_MODE
suffix:semicolon
id|loop_ctl
op_assign
l_int|1
suffix:semicolon
id|skip
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
id|azt_state
op_assign
id|AZT_S_START
suffix:semicolon
id|AztTimeout
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|azt_state
op_assign
id|AZT_S_IDLE
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;aztcd: invalid state %d&bslash;n&quot;
comma
id|azt_state
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* case */
)brace
multiline_comment|/* while */
r_if
c_cond
(paren
op_logical_neg
id|AztTimeout
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: timeout in state %d&bslash;n&quot;
comma
id|azt_state
)paren
suffix:semicolon
id|azt_state
op_assign
id|AZT_S_STOP
suffix:semicolon
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_STOP
)paren
)paren
r_return
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
)brace
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|azt_poll
comma
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|azt_invalidate_buffers
r_static
r_void
id|azt_invalidate_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: executing azt_invalidate_buffers&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|AZT_BUF_SIZ
suffix:semicolon
op_increment
id|i
)paren
id|azt_buf_bn
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|azt_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Open the device special file.  Check that a disk is in.&n; */
DECL|function|aztcd_open
r_int
id|aztcd_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_int
id|st
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: starting aztcd_open&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|aztPresent
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* no hardware */
r_if
c_cond
(paren
op_logical_neg
id|azt_open_count
op_logical_and
id|azt_state
op_eq
id|AZT_S_IDLE
)paren
(brace
id|azt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|st
op_assign
id|getAztStatus
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* check drive status */
r_if
c_cond
(paren
id|st
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* drive doesn&squot;t respond */
r_if
c_cond
(paren
(paren
id|st
op_amp
id|AST_DOOR_OPEN
)paren
op_logical_or
(paren
id|st
op_amp
id|AST_NOT_READY
)paren
)paren
multiline_comment|/* no disk in drive or door open*/
(brace
multiline_comment|/*???*/
id|printk
c_func
(paren
l_string|&quot;aztcd: no disk in drive or door open&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|aztUpdateToc
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
op_increment
id|azt_open_count
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: exiting aztcd_open&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * On close, we flush all azt blocks from the buffer cache.&n; */
DECL|function|aztcd_release
r_static
r_void
id|aztcd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: executing aztcd_release&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;inode: %p, inode-&gt;i_rdev: %x    file: %p&bslash;n&quot;
comma
id|inode
comma
id|inode-&gt;i_rdev
comma
id|file
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|azt_open_count
)paren
(brace
id|azt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|sync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
multiline_comment|/*??? isn&squot;t it a read only dev?*/
id|invalidate_buffers
c_func
(paren
id|inode
op_member_access_from_pointer
id|i_rdev
)paren
suffix:semicolon
id|CLEAR_TIMER
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|variable|azt_fops
r_static
r_struct
id|file_operations
id|azt_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|aztcd_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|aztcd_open
comma
multiline_comment|/* open */
id|aztcd_release
comma
multiline_comment|/* release */
l_int|NULL
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync*/
id|check_aztcd_media_change
comma
multiline_comment|/*media change*/
l_int|NULL
multiline_comment|/* revalidate*/
)brace
suffix:semicolon
multiline_comment|/*&n; * Test for presence of drive and initialize it.  Called at boot time.&n; */
DECL|function|aztcd_init
r_int
r_int
id|aztcd_init
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
(brace
r_int
r_int
id|count
comma
id|max_count
suffix:semicolon
r_int
r_char
id|result
(braket
l_int|50
)braket
suffix:semicolon
r_int
id|st
suffix:semicolon
r_if
c_cond
(paren
id|azt_port
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: no Aztech CD-ROM Initialization&quot;
)paren
suffix:semicolon
r_return
(paren
id|mem_start
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Aztech CD-ROM Init: Aztech, Orchid, Okano, Wearnes CD-ROM Driver&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Aztech CD-ROM Init: (C) 1994,1995 Werner Zimmermann&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Aztech CD-ROM Init: DriverVersion=%s  BaseAddress=0x%x &bslash;n&quot;
comma
id|AZT_VERSION
comma
id|azt_port
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|azt_port
comma
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: conflict, I/O port (%X) already used&bslash;n&quot;
comma
id|azt_port
)paren
suffix:semicolon
r_return
(paren
id|mem_start
)paren
suffix:semicolon
)brace
multiline_comment|/* check for card */
id|outb
c_func
(paren
id|POLLED
comma
id|MODE_PORT
)paren
suffix:semicolon
multiline_comment|/*???*/
id|inb
c_func
(paren
id|CMD_PORT
)paren
suffix:semicolon
id|inb
c_func
(paren
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ACMD_GET_VERSION
comma
id|CMD_PORT
)paren
suffix:semicolon
multiline_comment|/*Try to get version info*/
id|STEN_LOW
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|DATA_PORT
)paren
op_ne
id|AFL_OP_OK
)paren
multiline_comment|/*OP_OK? If not, reset and try again*/
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: drive reset - please wait&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|50
suffix:semicolon
id|count
op_increment
)paren
(brace
id|inb
c_func
(paren
id|STATUS_PORT
)paren
suffix:semicolon
multiline_comment|/*removing all data from earlier tries*/
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
id|POLLED
comma
id|MODE_PORT
)paren
suffix:semicolon
multiline_comment|/*???*/
id|inb
c_func
(paren
id|CMD_PORT
)paren
suffix:semicolon
id|inb
c_func
(paren
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ACMD_SOFT_RESET
comma
id|CMD_PORT
)paren
suffix:semicolon
multiline_comment|/*send reset*/
id|STEN_LOW
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|DATA_PORT
)paren
op_ne
id|AFL_OP_OK
)paren
multiline_comment|/*OP_OK?*/
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: no AZTECH CD-ROM drive found&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|mem_start
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|AZT_TIMEOUT
suffix:semicolon
id|count
op_increment
)paren
suffix:semicolon
multiline_comment|/* delay a bit */
r_if
c_cond
(paren
(paren
id|st
op_assign
id|getAztStatus
c_func
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: Drive Status Error Status=%x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
r_return
(paren
id|mem_start
)paren
suffix:semicolon
)brace
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: Status = %x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|POLLED
comma
id|MODE_PORT
)paren
suffix:semicolon
multiline_comment|/*???*/
id|inb
c_func
(paren
id|CMD_PORT
)paren
suffix:semicolon
id|inb
c_func
(paren
id|CMD_PORT
)paren
suffix:semicolon
id|outb
c_func
(paren
id|ACMD_GET_VERSION
comma
id|CMD_PORT
)paren
suffix:semicolon
multiline_comment|/*GetVersion*/
id|STEN_LOW
suffix:semicolon
id|OP_OK
suffix:semicolon
)brace
id|azt_init_end
op_assign
l_int|1
suffix:semicolon
id|STEN_LOW
suffix:semicolon
id|result
(braket
l_int|0
)braket
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
multiline_comment|/*reading in a null byte???*/
r_for
c_loop
(paren
id|count
op_assign
l_int|1
suffix:semicolon
id|count
OL
l_int|50
suffix:semicolon
id|count
op_increment
)paren
multiline_comment|/*Reading version string*/
(brace
id|aztTimeOutCount
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*here we must implement STEN_LOW differently*/
r_do
(brace
id|aztIndatum
op_assign
id|inb
c_func
(paren
id|STATUS_PORT
)paren
suffix:semicolon
multiline_comment|/*because we want to exit by timeout*/
id|aztTimeOutCount
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_FAST_TIMEOUT
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
id|aztIndatum
op_amp
id|AFL_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_FAST_TIMEOUT
)paren
r_break
suffix:semicolon
multiline_comment|/*all chars read?*/
id|result
(braket
id|count
)braket
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
OG
l_int|30
)paren
id|max_count
op_assign
l_int|30
suffix:semicolon
multiline_comment|/*print max.30 chars of the version string*/
r_else
id|max_count
op_assign
id|count
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Aztech CD-ROM Init: FirmwareVersion=&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|1
suffix:semicolon
id|count
OL
id|max_count
suffix:semicolon
id|count
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|result
(braket
id|count
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&lt;&lt;&lt;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|result
(braket
l_int|1
)braket
op_eq
l_char|&squot;A&squot;
)paren
op_logical_and
(paren
id|result
(braket
l_int|2
)braket
op_eq
l_char|&squot;Z&squot;
)paren
op_logical_and
(paren
id|result
(braket
l_int|3
)braket
op_eq
l_char|&squot;T&squot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Aztech CD-ROM Init: AZTECH drive detected&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*AZTECH*/
)brace
r_else
r_if
c_cond
(paren
(paren
id|result
(braket
l_int|2
)braket
op_eq
l_char|&squot;C&squot;
)paren
op_logical_and
(paren
id|result
(braket
l_int|3
)braket
op_eq
l_char|&squot;D&squot;
)paren
op_logical_and
(paren
id|result
(braket
l_int|4
)braket
op_eq
l_char|&squot;D&squot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Aztech CD-ROM Init: ORCHID or WEARNES drive detected&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*ORCHID or WEARNES*/
)brace
r_else
multiline_comment|/*OTHERS or none*/
(brace
id|printk
c_func
(paren
l_string|&quot;Aztech CD-ROM Init: : unknown drive or firmware version detected&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                      azt may not run stable, if you want to try anyhow,&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;                      boot with: aztcd=base_address,0x79&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|azt_cont
op_ne
l_int|0x79
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Aztech CD-ROM Init: FirmwareVersion=&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|1
suffix:semicolon
id|count
OL
l_int|5
suffix:semicolon
id|count
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%c&quot;
comma
id|result
(braket
id|count
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Aztech CD-ROM Init: Aborted&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|mem_start
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;aztcd&quot;
comma
op_amp
id|azt_fops
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: Unable to get major %d for Aztech CD-ROM&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
(paren
id|mem_start
)paren
suffix:semicolon
)brace
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|4
suffix:semicolon
id|request_region
c_func
(paren
id|azt_port
comma
l_int|4
comma
l_string|&quot;aztcd&quot;
)paren
suffix:semicolon
id|azt_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|aztPresent
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Aztech CD-ROM Init: End&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|mem_start
)paren
suffix:semicolon
)brace
DECL|function|azt_hsg2msf
r_static
r_void
id|azt_hsg2msf
c_func
(paren
r_int
id|hsg
comma
r_struct
id|msf
op_star
id|msf
)paren
(brace
id|hsg
op_add_assign
l_int|150
suffix:semicolon
id|msf
op_member_access_from_pointer
id|min
op_assign
id|hsg
op_div
l_int|4500
suffix:semicolon
id|hsg
op_mod_assign
l_int|4500
suffix:semicolon
id|msf
op_member_access_from_pointer
id|sec
op_assign
id|hsg
op_div
l_int|75
suffix:semicolon
id|msf
op_member_access_from_pointer
id|frame
op_assign
id|hsg
op_mod
l_int|75
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
r_if
c_cond
(paren
id|msf-&gt;min
op_ge
l_int|70
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: Error hsg2msf address Minutes&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msf-&gt;sec
op_ge
l_int|60
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: Error hsg2msf address Seconds&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msf-&gt;frame
op_ge
l_int|75
)paren
id|printk
c_func
(paren
l_string|&quot;aztcd: Error hsg2msf address Frames&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf
op_member_access_from_pointer
id|min
)paren
suffix:semicolon
multiline_comment|/* convert to BCD */
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf
op_member_access_from_pointer
id|sec
)paren
suffix:semicolon
id|azt_bin2bcd
c_func
(paren
op_amp
id|msf
op_member_access_from_pointer
id|frame
)paren
suffix:semicolon
)brace
DECL|function|azt_bin2bcd
r_static
r_void
id|azt_bin2bcd
c_func
(paren
r_int
r_char
op_star
id|p
)paren
(brace
r_int
id|u
comma
id|t
suffix:semicolon
id|u
op_assign
op_star
id|p
op_mod
l_int|10
suffix:semicolon
id|t
op_assign
op_star
id|p
op_div
l_int|10
suffix:semicolon
op_star
id|p
op_assign
id|u
op_or
(paren
id|t
op_lshift
l_int|4
)paren
suffix:semicolon
)brace
DECL|function|azt_bcd2bin
r_static
r_int
id|azt_bcd2bin
c_func
(paren
r_int
r_char
id|bcd
)paren
(brace
r_return
(paren
id|bcd
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|bcd
op_amp
l_int|0xF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a value from the drive.  Should return quickly, so a busy wait&n; * is used to avoid excessive rescheduling. The read command itself must&n; * be issued with aztSendCmd() directly before&n; */
DECL|function|aztGetValue
r_static
r_int
id|aztGetValue
c_func
(paren
r_int
r_char
op_star
id|result
)paren
(brace
r_int
id|s
suffix:semicolon
id|STEN_LOW
suffix:semicolon
r_if
c_cond
(paren
id|aztTimeOutCount
op_ge
id|AZT_TIMEOUT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;aztcd: aztGetValue timeout&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|s
op_assign
id|inb
c_func
(paren
id|DATA_PORT
)paren
op_amp
l_int|0xFF
suffix:semicolon
op_star
id|result
op_assign
(paren
r_int
r_char
)paren
id|s
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the current Q-channel info.  Also used for reading the&n; * table of contents.&n; */
DECL|function|aztGetQChannelInfo
r_int
id|aztGetQChannelInfo
c_func
(paren
r_struct
id|azt_Toc
op_star
id|qp
)paren
(brace
r_int
r_char
id|notUsed
suffix:semicolon
r_int
id|st
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: starting aztGetQChannelInfo&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|st
op_assign
id|getAztStatus
c_func
(paren
)paren
)paren
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_GET_Q_CHANNEL
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|notUsed
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*Nullbyte ein-*/
multiline_comment|/*lesen ???*/
r_if
c_cond
(paren
(paren
id|st
op_amp
id|AST_MODE_BITS
)paren
op_eq
id|AST_INITIAL
)paren
(brace
id|qp-&gt;ctrl_addr
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* when audio stop ACMD_GET_Q_CHANNEL returns */
id|qp-&gt;track
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* only one byte with Aztech drives */
id|qp-&gt;pointIndex
op_assign
l_int|0
suffix:semicolon
id|qp-&gt;trackTime.min
op_assign
l_int|0
suffix:semicolon
id|qp-&gt;trackTime.sec
op_assign
l_int|0
suffix:semicolon
id|qp-&gt;trackTime.frame
op_assign
l_int|0
suffix:semicolon
id|qp-&gt;diskTime.min
op_assign
l_int|0
suffix:semicolon
id|qp-&gt;diskTime.sec
op_assign
l_int|0
suffix:semicolon
id|qp-&gt;diskTime.frame
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|ctrl_addr
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|track
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|pointIndex
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|trackTime.min
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|trackTime.sec
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|trackTime.frame
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|notUsed
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|diskTime.min
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|diskTime.sec
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|aztGetValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|diskTime.frame
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: exiting aztGetQChannelInfo&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the table of contents (TOC) and TOC header if necessary&n; */
DECL|function|aztUpdateToc
r_static
r_int
id|aztUpdateToc
c_func
(paren
)paren
(brace
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: starting aztUpdateToc&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif  
r_if
c_cond
(paren
id|aztTocUpToDate
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|aztGetDiskInfo
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|aztGetToc
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|aztTocUpToDate
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: exiting aztUpdateToc&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the table of contents header&n; */
DECL|function|aztGetDiskInfo
r_static
r_int
id|aztGetDiskInfo
c_func
(paren
)paren
(brace
r_int
id|limit
suffix:semicolon
r_int
r_char
id|test
suffix:semicolon
r_struct
id|azt_Toc
id|qInfo
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: starting aztGetDiskInfo&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_SEEK_TO_LEADIN
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
id|test
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|limit
op_assign
l_int|300
suffix:semicolon
id|limit
OG
l_int|0
suffix:semicolon
id|limit
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|aztGetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|qInfo.pointIndex
op_eq
l_int|0xA0
)paren
multiline_comment|/*Number of FirstTrack*/
(brace
id|DiskInfo.first
op_assign
id|qInfo.diskTime.min
suffix:semicolon
id|DiskInfo.first
op_assign
id|azt_bcd2bin
c_func
(paren
id|DiskInfo.first
)paren
suffix:semicolon
id|test
op_assign
id|test
op_or
l_int|0x01
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qInfo.pointIndex
op_eq
l_int|0xA1
)paren
multiline_comment|/*Number of LastTrack*/
(brace
id|DiskInfo.last
op_assign
id|qInfo.diskTime.min
suffix:semicolon
id|DiskInfo.last
op_assign
id|azt_bcd2bin
c_func
(paren
id|DiskInfo.last
)paren
suffix:semicolon
id|test
op_assign
id|test
op_or
l_int|0x02
suffix:semicolon
)brace
r_if
c_cond
(paren
id|qInfo.pointIndex
op_eq
l_int|0xA2
)paren
multiline_comment|/*DiskLength*/
(brace
id|DiskInfo.diskLength.min
op_assign
id|qInfo.diskTime.min
suffix:semicolon
id|DiskInfo.diskLength.sec
op_assign
id|qInfo.diskTime.sec
op_minus
l_int|2
suffix:semicolon
id|DiskInfo.diskLength.frame
op_assign
id|qInfo.diskTime.frame
suffix:semicolon
id|test
op_assign
id|test
op_or
l_int|0x04
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|qInfo.pointIndex
op_eq
id|DiskInfo.first
)paren
op_logical_and
(paren
id|test
op_amp
l_int|0x01
)paren
)paren
multiline_comment|/*StartTime of First Track*/
(brace
id|DiskInfo.firstTrack.min
op_assign
id|qInfo.diskTime.min
suffix:semicolon
id|DiskInfo.firstTrack.sec
op_assign
id|qInfo.diskTime.sec
suffix:semicolon
id|DiskInfo.firstTrack.frame
op_assign
id|qInfo.diskTime.frame
suffix:semicolon
id|test
op_assign
id|test
op_or
l_int|0x08
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test
op_eq
l_int|0x0F
)paren
r_break
suffix:semicolon
)brace
macro_line|#ifdef AZT_DEBUG
id|printk
(paren
l_string|&quot;aztcd: exiting aztGetDiskInfo&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Disk Info: first %d last %d length %02x:%02x.%02x first %02x:%02x.%02x&bslash;n&quot;
comma
id|DiskInfo.first
comma
id|DiskInfo.last
comma
id|DiskInfo.diskLength.min
comma
id|DiskInfo.diskLength.sec
comma
id|DiskInfo.diskLength.frame
comma
id|DiskInfo.firstTrack.min
comma
id|DiskInfo.firstTrack.sec
comma
id|DiskInfo.firstTrack.frame
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|test
op_ne
l_int|0x0F
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the table of contents (TOC)&n; */
DECL|function|aztGetToc
r_static
r_int
id|aztGetToc
c_func
(paren
)paren
(brace
r_int
id|i
comma
id|px
suffix:semicolon
r_int
id|limit
suffix:semicolon
r_struct
id|azt_Toc
id|qInfo
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: starting aztGetToc&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TRACKS
suffix:semicolon
id|i
op_increment
)paren
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|DiskInfo.last
op_plus
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_STOP
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|STEN_LOW_WAIT
suffix:semicolon
id|azt_mode
op_assign
l_int|0x05
suffix:semicolon
r_if
c_cond
(paren
id|aztSendCmd
c_func
(paren
id|ACMD_SEEK_TO_LEADIN
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*???*/
id|STEN_LOW_WAIT
suffix:semicolon
r_for
c_loop
(paren
id|limit
op_assign
l_int|300
suffix:semicolon
id|limit
OG
l_int|0
suffix:semicolon
id|limit
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|aztGetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|px
op_assign
id|azt_bcd2bin
c_func
(paren
id|qInfo.pointIndex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|px
OG
l_int|0
op_logical_and
id|px
OL
id|MAX_TRACKS
op_logical_and
id|qInfo.track
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|Toc
(braket
id|px
)braket
dot
id|pointIndex
op_eq
l_int|0
)paren
(brace
id|Toc
(braket
id|px
)braket
op_assign
id|qInfo
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_le
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|Toc
(braket
id|DiskInfo.last
op_plus
l_int|1
)braket
dot
id|diskTime
op_assign
id|DiskInfo.diskLength
suffix:semicolon
macro_line|#ifdef AZT_DEBUG
id|printk
c_func
(paren
l_string|&quot;aztcd: exiting aztGetToc&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|DiskInfo.last
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;i = %2d ctl-adr = %02X track %2d px %02X %02X:%02X.%02X    %02X:%02X.%02X&bslash;n&quot;
comma
id|i
comma
id|Toc
(braket
id|i
)braket
dot
id|ctrl_addr
comma
id|Toc
(braket
id|i
)braket
dot
id|track
comma
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.frame
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.frame
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|100
suffix:semicolon
id|i
OL
l_int|103
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;i = %2d ctl-adr = %02X track %2d px %02X %02X:%02X.%02X    %02X:%02X.%02X&bslash;n&quot;
comma
id|i
comma
id|Toc
(braket
id|i
)braket
dot
id|ctrl_addr
comma
id|Toc
(braket
id|i
)braket
dot
id|track
comma
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.frame
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.frame
)paren
suffix:semicolon
macro_line|#endif
r_return
id|limit
OG
l_int|0
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
eof
