multiline_comment|/*&n; *  linux/drivers/block/ide-dma.c&t;Version 4.06  December 3, 1997&n; *&n; *  Copyright (c) 1995-1998  Mark Lord&n; *  May be copied or modified under the terms of the GNU General Public License&n; */
multiline_comment|/*&n; * This module provides support for the bus-master IDE DMA functions&n; * of various PCI chipsets, including the Intel PIIX (i82371FB for&n; * the 430 FX chipset), the PIIX3 (i82371SB for the 430 HX/VX and &n; * 440 chipsets), and the PIIX4 (i82371AB for the 430 TX chipset)&n; * (&quot;PIIX&quot; stands for &quot;PCI ISA IDE Xcellerator&quot;).&n; *&n; * Pretty much the same code works for other IDE PCI bus-mastering chipsets.&n; *&n; * DMA is supported for all IDE devices (disk drives, cdroms, tapes, floppies).&n; *&n; * By default, DMA support is prepared for use, but is currently enabled only&n; * for drives which already have DMA enabled (UltraDMA or mode 2 multi/single),&n; * or which are recognized as &quot;good&quot; (see table below).  Drives with only mode0&n; * or mode1 (multi/single) DMA should also work with this chipset/driver&n; * (eg. MC2112A) but are not enabled by default.&n; *&n; * Use &quot;hdparm -i&quot; to view modes supported by a given drive.&n; *&n; * The hdparm-2.4 (or later) utility can be used for manually enabling/disabling&n; * DMA support, but must be (re-)compiled against this kernel version or later.&n; *&n; * To enable DMA, use &quot;hdparm -d1 /dev/hd?&quot; on a per-drive basis after booting.&n; * If problems arise, ide.c will disable DMA operation after a few retries.&n; * This error recovery mechanism works and has been extremely well exercised.&n; *&n; * IDE drives, depending on their vintage, may support several different modes&n; * of DMA operation.  The boot-time modes are indicated with a &quot;*&quot; in&n; * the &quot;hdparm -i&quot; listing, and can be changed with *knowledgeable* use of&n; * the &quot;hdparm -X&quot; feature.  There is seldom a need to do this, as drives&n; * normally power-up with their &quot;best&quot; PIO/DMA modes enabled.&n; *&n; * Testing has been done with a rather extensive number of drives,&n; * with Quantum &amp; Western Digital models generally outperforming the pack,&n; * and Fujitsu &amp; Conner (and some Seagate which are really Conner) drives&n; * showing more lackluster throughput.&n; *&n; * Keep an eye on /var/adm/messages for &quot;DMA disabled&quot; messages.&n; *&n; * Some people have reported trouble with Intel Zappa motherboards.&n; * This can be fixed by upgrading the AMI BIOS to version 1.00.04.BS0,&n; * available from ftp://ftp.intel.com/pub/bios/10004bs0.exe&n; * (thanks to Glen Morrell &lt;glen@spin.Stanford.edu&gt; for researching this).&n; *&n; * Thanks to &quot;Christopher J. Reimer&quot; &lt;reimer@doe.carleton.ca&gt; for fixing the&n; * problem with some (all?) ACER motherboards/BIOSs.  Hopefully the fix&n; * still works here (?).&n; *&n; * Thanks to &quot;Benoit Poulot-Cazajous&quot; &lt;poulot@chorus.fr&gt; for testing&n; * &quot;TX&quot; chipset compatibility and for providing patches for the &quot;TX&quot; chipset.&n; *&n; * Thanks to Christian Brunner &lt;chb@muc.de&gt; for taking a good first crack&n; * at generic DMA -- his patches were referred to when preparing this code.&n; *&n; * Most importantly, thanks to Robert Bringman &lt;rob@mars.trion.com&gt;&n; * for supplying a Promise UDMA board &amp; WD UDMA drive for this work!&n; *&n; * And, yes, Intel Zappa boards really *do* use both PIIX IDE ports.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/bios32.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &quot;ide.h&quot;
multiline_comment|/*&n; * good_dma_drives() lists the model names (from &quot;hdparm -i&quot;)&n; * of drives which do not support mode2 DMA but which are&n; * known to work fine with this interface under Linux.&n; */
DECL|variable|good_dma_drives
r_const
r_char
op_star
id|good_dma_drives
(braket
)braket
op_assign
(brace
l_string|&quot;Micropolis 2112A&quot;
comma
l_string|&quot;CONNER CTMA 4000&quot;
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; * Our Physical Region Descriptor (PRD) table should be large enough&n; * to handle the biggest I/O request we are likely to see.  Since requests&n; * can have no more than 256 sectors, and since the typical blocksize is&n; * two or more sectors, we could get by with a limit of 128 entries here for&n; * the usual worst case.  Most requests seem to include some contiguous blocks,&n; * further reducing the number of table entries required.&n; *&n; * The driver reverts to PIO mode for individual requests that exceed&n; * this limit (possible with 512 byte blocksizes, eg. MSDOS f/s), so handling&n; * 100% of all crazy scenarios here is not necessary.&n; *&n; * As it turns out though, we must allocate a full 4KB page for this,&n; * so the two PRD tables (ide0 &amp; ide1) will each get half of that,&n; * allowing each to have about 256 entries (8 bytes each) from this.&n; */
DECL|macro|PRD_BYTES
mdefine_line|#define PRD_BYTES&t;8
DECL|macro|PRD_ENTRIES
mdefine_line|#define PRD_ENTRIES&t;(PAGE_SIZE / (2 * PRD_BYTES))
r_static
r_int
id|config_drive_for_dma
(paren
id|ide_drive_t
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * dma_intr() is the handler for disk read/write DMA interrupts&n; */
DECL|function|dma_intr
r_static
r_void
id|dma_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
comma
id|dma_stat
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
r_int
id|dma_base
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dma_base
suffix:semicolon
id|dma_stat
op_assign
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* get DMA status */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_amp
op_complement
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* stop DMA operation */
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* get drive status */
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|dma_stat
op_amp
l_int|7
)paren
op_eq
l_int|4
)paren
(brace
multiline_comment|/* verify good DMA status */
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|i
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: bad DMA status: 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|dma_stat
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;dma_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_build_dmatable() prepares a dma request.&n; * Returns 0 if all went okay, returns 1 otherwise.&n; * May also be invoked from trm290.c&n; */
DECL|function|ide_build_dmatable
r_int
id|ide_build_dmatable
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|rq-&gt;bh
suffix:semicolon
r_int
r_int
id|size
comma
id|addr
comma
op_star
id|table
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmatable
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_TRM290
r_int
r_int
id|is_trm290_chipset
op_assign
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|chipset
op_eq
id|ide_trm290
)paren
suffix:semicolon
macro_line|#else
r_const
r_int
id|is_trm290_chipset
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * Determine addr and size of next buffer area.  We assume that&n;&t;&t; * individual virtual buffers are always composed linearly in&n;&t;&t; * physical memory.  For example, we assume that any 8kB buffer&n;&t;&t; * is always composed of two adjacent physical 4kB pages rather&n;&t;&t; * than two possibly non-adjacent physical 4kB pages.&n;&t;&t; */
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* paging requests have (rq-&gt;bh == NULL) */
id|addr
op_assign
id|virt_to_bus
(paren
id|rq-&gt;buffer
)paren
suffix:semicolon
id|size
op_assign
id|rq-&gt;nr_sectors
op_lshift
l_int|9
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* group sequential buffers into one large buffer */
id|addr
op_assign
id|virt_to_bus
(paren
id|bh-&gt;b_data
)paren
suffix:semicolon
id|size
op_assign
id|bh-&gt;b_size
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_reqnext
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_plus
id|size
)paren
op_ne
id|virt_to_bus
(paren
id|bh-&gt;b_data
)paren
)paren
r_break
suffix:semicolon
id|size
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Fill in the dma table, without crossing any 64kB boundaries.&n;&t;&t; * The hardware requires 16-bit alignment of all blocks&n;&t;&t; * (trm290 requires 32-bit alignment).&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|addr
op_amp
l_int|3
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: misaligned DMA buffer&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|size
)paren
(brace
r_if
c_cond
(paren
op_increment
id|count
op_ge
id|PRD_ENTRIES
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DMA table too small&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* revert to PIO for this request */
)brace
r_else
(brace
r_int
r_int
id|xcount
comma
id|bcount
op_assign
l_int|0x10000
op_minus
(paren
id|addr
op_amp
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcount
OG
id|size
)paren
id|bcount
op_assign
id|size
suffix:semicolon
op_star
id|table
op_increment
op_assign
id|addr
suffix:semicolon
id|xcount
op_assign
id|bcount
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|is_trm290_chipset
)paren
id|xcount
op_assign
(paren
(paren
id|xcount
op_rshift
l_int|2
)paren
op_minus
l_int|1
)paren
op_lshift
l_int|16
suffix:semicolon
op_star
id|table
op_increment
op_assign
id|xcount
suffix:semicolon
id|addr
op_add_assign
id|bcount
suffix:semicolon
id|size
op_sub_assign
id|bcount
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_trm290_chipset
)paren
op_star
op_decrement
id|table
op_or_assign
l_int|0x80000000
suffix:semicolon
multiline_comment|/* set End-Of-Table (EOT) bit */
r_return
id|count
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: empty DMA table?&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_dmaproc() initiates/aborts DMA read/write operations on a drive.&n; *&n; * The caller is assumed to have selected the drive and programmed the drive&squot;s&n; * sector address using CHS or LBA.  All that remains is to prepare for DMA&n; * and then issue the actual read/write DMA/PIO command to the drive.&n; *&n; * For ATAPI devices, we just prepare for DMA and return. The caller should&n; * then issue the packet command to the drive and call us again with&n; * ide_dma_begin afterwards.&n; *&n; * Returns 0 if all went well.&n; * Returns 1 if DMA read/write could not be started, in which case&n; * the caller should revert to PIO for the current request.&n; * May also be invoked from trm290.c&n; */
DECL|function|ide_dmaproc
r_int
id|ide_dmaproc
(paren
id|ide_dma_action_t
id|func
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
id|dma_base
op_assign
id|hwif-&gt;dma_base
suffix:semicolon
r_int
r_int
id|count
comma
id|reading
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|func
)paren
(brace
r_case
id|ide_dma_off
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: DMA disabled&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_case
id|ide_dma_off_quietly
suffix:colon
r_case
id|ide_dma_on
suffix:colon
id|drive-&gt;using_dma
op_assign
(paren
id|func
op_eq
id|ide_dma_on
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|ide_dma_abort
suffix:colon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_amp
op_complement
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* stop DMA */
r_return
l_int|0
suffix:semicolon
r_case
id|ide_dma_check
suffix:colon
r_return
id|config_drive_for_dma
(paren
id|drive
)paren
suffix:semicolon
r_case
id|ide_dma_status_bad
suffix:colon
r_return
(paren
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_amp
l_int|7
)paren
op_ne
l_int|4
)paren
suffix:semicolon
multiline_comment|/* verify good DMA status */
r_case
id|ide_dma_transferred
suffix:colon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* NOT IMPLEMENTED: number of bytes actually transferred */
r_case
id|ide_dma_begin
suffix:colon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_or
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* begin DMA */
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ide_dmaproc: unsupported func: %d&bslash;n&quot;
comma
id|func
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_case
id|ide_dma_read
suffix:colon
id|reading
op_assign
l_int|1
op_lshift
l_int|3
suffix:semicolon
r_case
id|ide_dma_write
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|count
op_assign
id|ide_build_dmatable
c_func
(paren
id|drive
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* try PIO instead of DMA */
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hwif-&gt;dmatable
)paren
comma
id|dma_base
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* PRD table */
id|outb
c_func
(paren
id|reading
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* specify r/w */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_or
l_int|0x06
comma
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* clear status bits */
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_return
l_int|0
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|dma_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
multiline_comment|/* issue cmd to drive */
id|OUT_BYTE
c_func
(paren
id|reading
ques
c_cond
id|WIN_READDMA
suffix:colon
id|WIN_WRITEDMA
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_or
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* begin DMA */
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|config_drive_for_dma
r_static
r_int
id|config_drive_for_dma
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_const
r_char
op_star
op_star
id|list
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_logical_and
(paren
id|id-&gt;capability
op_amp
l_int|1
)paren
)paren
(brace
multiline_comment|/* Enable DMA on any drive that has UltraDMA (mode 0/1/2) enabled */
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|4
)paren
multiline_comment|/* UltraDMA */
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_amp
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|8
)paren
op_amp
l_int|7
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* Enable DMA on any drive that has mode2 DMA (multi or single) enabled */
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
multiline_comment|/* regular DMA */
r_if
c_cond
(paren
(paren
id|id-&gt;dma_mword
op_amp
l_int|0x404
)paren
op_eq
l_int|0x404
op_logical_or
(paren
id|id-&gt;dma_1word
op_amp
l_int|0x404
)paren
op_eq
l_int|0x404
)paren
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* Consult the list of known &quot;good&quot; drives */
id|list
op_assign
id|good_dma_drives
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|list
op_increment
comma
id|id-&gt;model
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
)brace
)brace
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off_quietly
comma
id|drive
)paren
suffix:semicolon
)brace
DECL|function|ide_setup_dma
r_void
id|ide_setup_dma
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_int
r_int
id|dmabase
comma
r_int
r_int
id|num_ports
)paren
(brace
r_static
r_int
r_int
id|dmatable
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|leftover
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    %s: BM-DMA at 0x%04x-0x%04x&quot;
comma
id|hwif-&gt;name
comma
id|dmabase
comma
id|dmabase
op_plus
id|num_ports
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|dmabase
comma
id|num_ports
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; -- ERROR, PORT ADDRESSES ALREADY IN USE&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|request_region
c_func
(paren
id|dmabase
comma
id|num_ports
comma
id|hwif-&gt;name
)paren
suffix:semicolon
id|hwif-&gt;dma_base
op_assign
id|dmabase
suffix:semicolon
r_if
c_cond
(paren
id|leftover
OL
(paren
id|PRD_ENTRIES
op_star
id|PRD_BYTES
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The BM-DMA uses full 32bit addr, so we can&n;&t;&t; * safely use __get_free_page() here instead&n;&t;&t; * of __get_dma_pages() -- no ISA limitations.&n;&t;&t; */
id|dmatable
op_assign
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
l_int|1
comma
l_int|0
)paren
suffix:semicolon
id|leftover
op_assign
id|dmatable
ques
c_cond
id|PAGE_SIZE
suffix:colon
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dmatable
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; -- ERROR, UNABLE TO ALLOCATE PRD TABLE&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|hwif-&gt;dmatable
op_assign
(paren
r_int
r_int
op_star
)paren
id|dmatable
suffix:semicolon
id|dmatable
op_add_assign
(paren
id|PRD_ENTRIES
op_star
id|PRD_BYTES
)paren
suffix:semicolon
id|leftover
op_sub_assign
(paren
id|PRD_ENTRIES
op_star
id|PRD_BYTES
)paren
suffix:semicolon
id|hwif-&gt;dmaproc
op_assign
op_amp
id|ide_dmaproc
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_ne
id|ide_trm290
)paren
(brace
id|byte
id|dma_stat
op_assign
id|inb
c_func
(paren
id|dmabase
op_plus
l_int|2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, BIOS DMA settings: %s:%s %s:%s&quot;
comma
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|name
comma
(paren
id|dma_stat
op_amp
l_int|0x20
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no &quot;
comma
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|name
comma
(paren
id|dma_stat
op_amp
l_int|0x40
)paren
ques
c_cond
l_string|&quot;yes&quot;
suffix:colon
l_string|&quot;no&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_BLK_DEV_TRM290
r_extern
r_void
id|ide_init_trm290
c_func
(paren
id|byte
comma
id|byte
comma
id|ide_hwif_t
op_star
)paren
suffix:semicolon
DECL|macro|INIT_TRM290
mdefine_line|#define INIT_TRM290 (&amp;ide_init_trm290)
macro_line|#else
DECL|macro|INIT_TRM290
mdefine_line|#define INIT_TRM290 (NULL)
macro_line|#endif&t;/* CONFIG_BLK_DEV_TRM290 */
macro_line|#ifdef CONFIG_BLK_DEV_OPTI621
r_extern
r_void
id|ide_init_opti621
c_func
(paren
id|byte
comma
id|byte
comma
id|ide_hwif_t
op_star
)paren
suffix:semicolon
DECL|macro|INIT_OPTI
mdefine_line|#define INIT_OPTI (&amp;ide_init_opti621)
macro_line|#else
DECL|macro|INIT_OPTI
mdefine_line|#define INIT_OPTI (NULL)
macro_line|#endif&t;/* CONFIG_BLK_DEV_OPTI621 */
DECL|macro|DEVID_PIIX
mdefine_line|#define DEVID_PIIX&t;(PCI_VENDOR_ID_INTEL  |(PCI_DEVICE_ID_INTEL_82371_1   &lt;&lt;16))
DECL|macro|DEVID_PIIX3
mdefine_line|#define DEVID_PIIX3&t;(PCI_VENDOR_ID_INTEL  |(PCI_DEVICE_ID_INTEL_82371SB_1 &lt;&lt;16))
DECL|macro|DEVID_PIIX4
mdefine_line|#define DEVID_PIIX4&t;(PCI_VENDOR_ID_INTEL  |(PCI_DEVICE_ID_INTEL_82371AB   &lt;&lt;16))
DECL|macro|DEVID_VP_IDE
mdefine_line|#define DEVID_VP_IDE &t;(PCI_VENDOR_ID_VIA    |(PCI_DEVICE_ID_VIA_82C586_1    &lt;&lt;16))
DECL|macro|DEVID_PDC20246
mdefine_line|#define DEVID_PDC20246&t;(PCI_VENDOR_ID_PROMISE|(PCI_DEVICE_ID_PROMISE_20246   &lt;&lt;16))
DECL|macro|DEVID_RZ1000
mdefine_line|#define DEVID_RZ1000&t;(PCI_VENDOR_ID_PCTECH |(PCI_DEVICE_ID_PCTECH_RZ1000   &lt;&lt;16))
DECL|macro|DEVID_RZ1001
mdefine_line|#define DEVID_RZ1001&t;(PCI_VENDOR_ID_PCTECH |(PCI_DEVICE_ID_PCTECH_RZ1001   &lt;&lt;16))
DECL|macro|DEVID_CMD640
mdefine_line|#define DEVID_CMD640&t;(PCI_VENDOR_ID_CMD    |(PCI_DEVICE_ID_CMD_640         &lt;&lt;16))
DECL|macro|DEVID_CMD646
mdefine_line|#define DEVID_CMD646&t;(PCI_VENDOR_ID_CMD    |(PCI_DEVICE_ID_CMD_646         &lt;&lt;16))
DECL|macro|DEVID_SIS5513
mdefine_line|#define DEVID_SIS5513&t;(PCI_VENDOR_ID_SI     |(PCI_DEVICE_ID_SI_5513         &lt;&lt;16))
DECL|macro|DEVID_OPTI
mdefine_line|#define DEVID_OPTI&t;(PCI_VENDOR_ID_OPTI   |(PCI_DEVICE_ID_OPTI_82C621     &lt;&lt;16))
DECL|macro|DEVID_OPTI2
mdefine_line|#define DEVID_OPTI2&t;(PCI_VENDOR_ID_OPTI   |(0xd568 /* from datasheets */  &lt;&lt;16))
DECL|macro|DEVID_TRM290
mdefine_line|#define DEVID_TRM290&t;(PCI_VENDOR_ID_TEKRAM |(PCI_DEVICE_ID_TEKRAM_DC290    &lt;&lt;16))
DECL|macro|DEVID_NS87410
mdefine_line|#define DEVID_NS87410&t;(PCI_VENDOR_ID_NS     |(PCI_DEVICE_ID_NS_87410        &lt;&lt;16))
DECL|macro|DEVID_HT6565
mdefine_line|#define DEVID_HT6565&t;(PCI_VENDOR_ID_HOLTEK |(PCI_DEVICE_ID_HOLTEK_6565     &lt;&lt;16))
DECL|struct|ide_pci_enablebit_s
r_typedef
r_struct
id|ide_pci_enablebit_s
(brace
DECL|member|reg
id|byte
id|reg
suffix:semicolon
multiline_comment|/* byte pci reg holding the enable-bit */
DECL|member|mask
id|byte
id|mask
suffix:semicolon
multiline_comment|/* mask to isolate the enable-bit */
DECL|member|val
id|byte
id|val
suffix:semicolon
multiline_comment|/* value of masked reg when &quot;enabled&quot; */
DECL|typedef|ide_pci_enablebit_t
)brace
id|ide_pci_enablebit_t
suffix:semicolon
DECL|struct|ide_pci_device_s
r_typedef
r_struct
id|ide_pci_device_s
(brace
DECL|member|id
r_int
r_int
id|id
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|init_hwif
r_void
(paren
op_star
id|init_hwif
)paren
(paren
id|byte
id|bus
comma
id|byte
id|fn
comma
id|ide_hwif_t
op_star
id|hwif
)paren
suffix:semicolon
DECL|member|enablebits
id|ide_pci_enablebit_t
id|enablebits
(braket
l_int|2
)braket
suffix:semicolon
DECL|typedef|ide_pci_device_t
)brace
id|ide_pci_device_t
suffix:semicolon
DECL|variable|ide_pci_chipsets
r_static
id|ide_pci_device_t
id|ide_pci_chipsets
(braket
)braket
op_assign
(brace
(brace
id|DEVID_PIIX
comma
l_string|&quot;PIIX&quot;
comma
l_int|NULL
comma
(brace
(brace
l_int|0x41
comma
l_int|0x80
comma
l_int|0x80
)brace
comma
(brace
l_int|0x43
comma
l_int|0x80
comma
l_int|0x80
)brace
)brace
)brace
comma
(brace
id|DEVID_PIIX3
comma
l_string|&quot;PIIX3&quot;
comma
l_int|NULL
comma
(brace
(brace
l_int|0x41
comma
l_int|0x80
comma
l_int|0x80
)brace
comma
(brace
l_int|0x43
comma
l_int|0x80
comma
l_int|0x80
)brace
)brace
)brace
comma
(brace
id|DEVID_PIIX4
comma
l_string|&quot;PIIX4&quot;
comma
l_int|NULL
comma
(brace
(brace
l_int|0x41
comma
l_int|0x80
comma
l_int|0x80
)brace
comma
(brace
l_int|0x43
comma
l_int|0x80
comma
l_int|0x80
)brace
)brace
)brace
comma
(brace
id|DEVID_VP_IDE
comma
l_string|&quot;VP_IDE&quot;
comma
l_int|NULL
comma
(brace
(brace
l_int|0x40
comma
l_int|0x02
comma
l_int|0x02
)brace
comma
(brace
l_int|0x40
comma
l_int|0x01
comma
l_int|0x01
)brace
)brace
)brace
comma
(brace
id|DEVID_PDC20246
comma
l_string|&quot;PDC20246&quot;
comma
l_int|NULL
comma
(brace
(brace
l_int|0x50
comma
l_int|0x02
comma
l_int|0x02
)brace
comma
(brace
l_int|0x50
comma
l_int|0x04
comma
l_int|0x04
)brace
)brace
)brace
comma
(brace
id|DEVID_RZ1000
comma
l_int|NULL
comma
l_int|NULL
comma
(brace
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
comma
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
)brace
)brace
comma
(brace
id|DEVID_RZ1001
comma
l_int|NULL
comma
l_int|NULL
comma
(brace
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
comma
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
)brace
)brace
comma
(brace
id|DEVID_CMD640
comma
l_int|NULL
comma
l_int|NULL
comma
(brace
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
comma
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
)brace
)brace
comma
(brace
id|DEVID_OPTI
comma
l_string|&quot;OPTI&quot;
comma
id|INIT_OPTI
comma
(brace
(brace
l_int|0x45
comma
l_int|0x80
comma
l_int|0x00
)brace
comma
(brace
l_int|0x40
comma
l_int|0x08
comma
l_int|0x00
)brace
)brace
)brace
comma
(brace
id|DEVID_OPTI2
comma
l_string|&quot;OPTI2&quot;
comma
id|INIT_OPTI
comma
(brace
(brace
l_int|0x45
comma
l_int|0x80
comma
l_int|0x00
)brace
comma
(brace
l_int|0x40
comma
l_int|0x08
comma
l_int|0x00
)brace
)brace
)brace
comma
(brace
id|DEVID_SIS5513
comma
l_string|&quot;SIS5513&quot;
comma
l_int|NULL
comma
(brace
(brace
l_int|0x4a
comma
l_int|0x02
comma
l_int|0x02
)brace
comma
(brace
l_int|0x4a
comma
l_int|0x04
comma
l_int|0x04
)brace
)brace
)brace
comma
(brace
id|DEVID_CMD646
comma
l_string|&quot;CMD646&quot;
comma
l_int|NULL
comma
(brace
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
comma
(brace
l_int|0x51
comma
l_int|0x80
comma
l_int|0x80
)brace
)brace
)brace
comma
(brace
id|DEVID_TRM290
comma
l_string|&quot;TRM290&quot;
comma
id|INIT_TRM290
comma
(brace
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
comma
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
)brace
)brace
comma
(brace
id|DEVID_NS87410
comma
l_string|&quot;NS87410&quot;
comma
l_int|NULL
comma
(brace
(brace
l_int|0x43
comma
l_int|0x08
comma
l_int|0x08
)brace
comma
(brace
l_int|0x47
comma
l_int|0x08
comma
l_int|0x08
)brace
)brace
)brace
comma
(brace
id|DEVID_HT6565
comma
l_string|&quot;HT6565&quot;
comma
l_int|NULL
comma
(brace
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
comma
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
)brace
)brace
comma
(brace
l_int|0
comma
l_string|&quot;PCI_IDE&quot;
comma
l_int|NULL
comma
(brace
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
comma
(brace
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
)brace
)brace
)brace
)brace
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
id|ide_pci_device_t
op_star
id|lookup_devid
c_func
(paren
r_int
r_int
id|devid
)paren
)paren
(brace
id|ide_pci_device_t
op_star
id|d
op_assign
id|ide_pci_chipsets
suffix:semicolon
r_while
c_loop
(paren
id|d-&gt;id
op_logical_and
id|d-&gt;id
op_ne
id|devid
)paren
op_increment
id|d
suffix:semicolon
r_return
id|d
suffix:semicolon
)brace
multiline_comment|/* The next two functions were stolen from cmd640.c, with&n;   a few modifications  */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|write_pcicfg_dword
(paren
id|byte
id|fn
comma
r_int
r_int
id|reg
comma
r_int
id|val
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outl_p
c_func
(paren
(paren
id|reg
op_amp
l_int|0xfc
)paren
op_or
(paren
(paren
id|fn
op_star
l_int|0x100
)paren
op_plus
l_int|0x80000000
)paren
comma
l_int|0xcf8
)paren
suffix:semicolon
id|outl_p
c_func
(paren
id|val
comma
(paren
id|reg
op_amp
l_int|3
)paren
op_or
l_int|0xcfc
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|read_pcicfg_dword
(paren
id|byte
id|fn
comma
r_int
r_int
id|reg
)paren
)paren
(brace
r_int
id|b
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outl_p
c_func
(paren
(paren
id|reg
op_amp
l_int|0xfc
)paren
op_or
(paren
(paren
id|fn
op_star
l_int|0x100
)paren
op_plus
l_int|0x80000000
)paren
comma
l_int|0xcf8
)paren
suffix:semicolon
id|b
op_assign
id|inl_p
c_func
(paren
(paren
id|reg
op_amp
l_int|3
)paren
op_or
l_int|0xcfc
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
multiline_comment|/*&n; * Search for an (apparently) unused block of I/O space&n; * of &quot;size&quot; bytes in length.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|find_free_region
(paren
r_int
r_int
id|size
)paren
)paren
(brace
r_int
r_int
id|i
comma
id|base
op_assign
l_int|0xe800
suffix:semicolon
r_for
c_loop
(paren
id|base
op_assign
l_int|0xe800
suffix:semicolon
id|base
OG
l_int|0
suffix:semicolon
id|base
op_sub_assign
l_int|0x800
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|check_region
c_func
(paren
id|base
comma
id|size
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|size
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|base
op_plus
id|i
)paren
op_ne
l_int|0xff
)paren
r_goto
id|next
suffix:semicolon
)brace
r_return
id|base
suffix:semicolon
multiline_comment|/* success */
)brace
id|next
suffix:colon
)brace
r_return
l_int|0
suffix:semicolon
multiline_comment|/* failure */
)brace
multiline_comment|/*&n; * Fetch the Bus-Master I/O Base-Address (BMIBA) from PCI space:&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
r_int
id|ide_get_or_set_bmiba
(paren
id|byte
id|bus
comma
id|byte
id|fn
comma
r_const
r_char
op_star
id|name
)paren
)paren
(brace
r_int
r_int
id|bmiba
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
id|rc
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x20
comma
op_amp
id|bmiba
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: failed to read BMIBA&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|bmiba
op_and_assign
l_int|0xfff0
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: BMIBA is invalid (0x%04x, BIOS problem)&bslash;n&quot;
comma
id|name
comma
id|bmiba
)paren
suffix:semicolon
id|base
op_assign
id|find_free_region
c_func
(paren
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: setting BMIBA to 0x%04x&bslash;n&quot;
comma
id|name
comma
id|base
)paren
suffix:semicolon
id|pcibios_write_config_dword
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x20
comma
id|base
op_or
l_int|1
)paren
suffix:semicolon
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x20
comma
op_amp
id|bmiba
)paren
suffix:semicolon
id|bmiba
op_and_assign
l_int|0xfff0
suffix:semicolon
r_if
c_cond
(paren
id|bmiba
op_ne
id|base
)paren
(brace
r_if
c_cond
(paren
id|bus
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: operation failed, bypassing BIOS to try again&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|write_pcicfg_dword
c_func
(paren
id|fn
comma
l_int|0x20
comma
id|base
op_or
l_int|1
)paren
suffix:semicolon
id|bmiba
op_assign
id|read_pcicfg_dword
c_func
(paren
id|fn
comma
l_int|0x20
)paren
op_amp
l_int|0xfff0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bmiba
op_ne
id|base
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: operation failed, DMA disabled&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|bmiba
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
id|bmiba
suffix:semicolon
)brace
multiline_comment|/*&n; * Match a PCI IDE port against an entry in ide_hwifs[],&n; * based on io_base port if possible.&n; */
DECL|function|ide_match_hwif
id|__initfunc
c_func
(paren
id|ide_hwif_t
op_star
id|ide_match_hwif
(paren
r_int
r_int
id|io_base
)paren
)paren
(brace
r_int
id|h
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
multiline_comment|/*&n;&t; * Look for a hwif with matching io_base specified using&n;&t; * parameters to ide_setup().&n;&t; */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
id|io_base
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_generic
)paren
r_return
id|hwif
suffix:semicolon
multiline_comment|/* a perfect match */
)brace
)brace
multiline_comment|/*&n;&t; * Look for a hwif with matching io_base default value.&n;&t; * If chipset is &quot;ide_unknown&quot;, then claim that hwif slot.&n;&t; * Otherwise, some other chipset has already claimed it..  :(&n;&t; */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|h
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
id|io_base
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_unknown
)paren
r_return
id|hwif
suffix:semicolon
multiline_comment|/* match */
r_return
l_int|NULL
suffix:semicolon
multiline_comment|/* already claimed */
)brace
)brace
multiline_comment|/*&n;&t; * Okay, there is no hwif matching our io_base,&n;&t; * so we&squot;ll just claim an unassigned slot.&n;&t; * Give preference to claiming ide2/ide3 before ide0/ide1,&n;&t; * just in case there&squot;s another interface yet-to-be-scanned&n;&t; * which uses ports 1f0/170 (the ide0/ide1 defaults).&n;&t; */
r_for
c_loop
(paren
id|h
op_assign
l_int|0
suffix:semicolon
id|h
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|h
)paren
(brace
r_int
id|hwifs
(braket
)braket
op_assign
(brace
l_int|2
comma
l_int|3
comma
l_int|1
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* assign 3rd/4th before 1st/2nd */
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|hwifs
(braket
id|h
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_unknown
)paren
r_return
id|hwif
suffix:semicolon
multiline_comment|/* pick an unused entry */
)brace
r_return
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_setup_pci_device() looks at the primary/secondary interfaces&n; * on a PCI IDE device and, if they are enabled, prepares the IDE driver&n; * for use with them.  This generic code works for most PCI chipsets.&n; *&n; * One thing that is not standardized is the location of the&n; * primary/secondary interface &quot;enable/disable&quot; bits.  For chipsets that&n; * we &quot;know&quot; about, this information is in the ide_pci_device_t struct;&n; * for all other chipsets, we just assume both interfaces are enabled.&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|ide_setup_pci_device
(paren
id|byte
id|bus
comma
id|byte
id|fn
comma
r_int
r_int
id|bmiba
comma
id|ide_pci_device_t
op_star
id|d
)paren
)paren
(brace
r_int
r_int
id|port
comma
id|at_least_one_hwif_enabled
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|base
op_assign
l_int|0
comma
id|ctl
op_assign
l_int|0
suffix:semicolon
id|byte
id|tmp
op_assign
l_int|0
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
comma
op_star
id|mate
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|port
op_assign
l_int|0
suffix:semicolon
id|port
op_le
l_int|1
suffix:semicolon
op_increment
id|port
)paren
(brace
id|ide_pci_enablebit_t
op_star
id|e
op_assign
op_amp
(paren
id|d-&gt;enablebits
(braket
id|port
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|e-&gt;reg
)paren
(brace
r_if
c_cond
(paren
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|fn
comma
id|e-&gt;reg
comma
op_amp
id|tmp
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: unable to read pci reg 0x%x&bslash;n&quot;
comma
id|d-&gt;name
comma
id|e-&gt;reg
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|tmp
op_amp
id|e-&gt;mask
)paren
op_ne
id|e-&gt;val
)paren
r_continue
suffix:semicolon
multiline_comment|/* port not enabled */
)brace
r_if
c_cond
(paren
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x14
op_plus
(paren
id|port
op_star
l_int|8
)paren
comma
op_amp
id|ctl
)paren
)paren
id|ctl
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ctl
op_and_assign
l_int|0xfffc
)paren
op_eq
l_int|0
)paren
id|ctl
op_assign
l_int|0x3f4
op_xor
(paren
id|port
op_lshift
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x10
op_plus
(paren
id|port
op_star
l_int|8
)paren
comma
op_amp
id|base
)paren
)paren
id|base
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_and_assign
l_int|0xfff8
)paren
op_eq
l_int|0
)paren
id|base
op_assign
l_int|0x1F0
op_xor
(paren
id|port
op_lshift
l_int|7
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hwif
op_assign
id|ide_match_hwif
c_func
(paren
id|base
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: no room in hwif table for port %d&bslash;n&quot;
comma
id|d-&gt;name
comma
id|port
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|hwif-&gt;chipset
op_assign
id|ide_pci
suffix:semicolon
id|hwif-&gt;pci_port
op_assign
id|port
suffix:semicolon
r_if
c_cond
(paren
id|mate
)paren
(brace
id|hwif-&gt;mate
op_assign
id|mate
suffix:semicolon
id|mate-&gt;mate
op_assign
id|hwif
suffix:semicolon
)brace
id|mate
op_assign
id|hwif
suffix:semicolon
multiline_comment|/* for next iteration */
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_ne
id|base
)paren
(brace
id|ide_init_hwif_ports
c_func
(paren
id|hwif-&gt;io_ports
comma
id|base
comma
l_int|NULL
)paren
suffix:semicolon
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
op_assign
id|ctl
op_plus
l_int|2
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bmiba
)paren
(brace
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|bmiba
op_plus
l_int|2
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
multiline_comment|/* simplex DMA only? */
id|printk
c_func
(paren
l_string|&quot;%s: simplex device:  DMA disabled&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* supports simultaneous DMA on both channels */
id|ide_setup_dma
c_func
(paren
id|hwif
comma
id|bmiba
op_plus
(paren
l_int|8
op_star
id|port
)paren
comma
l_int|8
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|d-&gt;id
)paren
(brace
multiline_comment|/* For &quot;known&quot; chipsets, allow other irqs during i/o */
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|unmask
op_assign
l_int|1
suffix:semicolon
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|unmask
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|d-&gt;init_hwif
)paren
multiline_comment|/* Call chipset-specific routine for each enabled hwif */
id|d
op_member_access_from_pointer
id|init_hwif
c_func
(paren
id|bus
comma
id|fn
comma
id|hwif
)paren
suffix:semicolon
id|at_least_one_hwif_enabled
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|at_least_one_hwif_enabled
)paren
id|printk
c_func
(paren
l_string|&quot;%s: neither IDE port enabled (BIOS)&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_scan_pci_device() examines all functions of a PCI device,&n; * looking for IDE interfaces and/or devices in ide_pci_chipsets[].&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_inline
r_void
id|ide_scan_pci_device
(paren
r_int
r_int
id|bus
comma
r_int
r_int
id|fn
)paren
)paren
(brace
r_int
r_int
id|devid
comma
id|ccode
suffix:semicolon
r_int
r_int
id|pcicmd
comma
r_class
suffix:semicolon
id|ide_pci_device_t
op_star
id|d
suffix:semicolon
id|byte
id|hedt
comma
id|progif
suffix:semicolon
r_if
c_cond
(paren
id|pcibios_read_config_byte
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x0e
comma
op_amp
id|hedt
)paren
)paren
id|hedt
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x00
comma
op_amp
id|devid
)paren
op_logical_or
id|devid
op_eq
l_int|0xffffffff
op_logical_or
id|pcibios_read_config_dword
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x08
comma
op_amp
id|ccode
)paren
)paren
r_return
suffix:semicolon
id|d
op_assign
id|lookup_devid
c_func
(paren
id|devid
)paren
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;name
op_eq
l_int|NULL
)paren
multiline_comment|/* some chips (cmd640, rz1000) are handled elsewhere */
r_continue
suffix:semicolon
id|progif
op_assign
(paren
id|ccode
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
r_class
op_assign
id|ccode
op_rshift
l_int|16
suffix:semicolon
r_if
c_cond
(paren
id|d-&gt;id
op_logical_or
r_class
op_eq
id|PCI_CLASS_STORAGE_IDE
)paren
(brace
r_if
c_cond
(paren
id|d-&gt;id
)paren
id|printk
c_func
(paren
l_string|&quot;%s: IDE device on PCI bus %d function %d&bslash;n&quot;
comma
id|d-&gt;name
comma
id|bus
comma
id|fn
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;%s: unknown IDE device on PCI bus %d function %d, VID=%04x, DID=%04x&bslash;n&quot;
comma
id|d-&gt;name
comma
id|bus
comma
id|fn
comma
id|devid
op_amp
l_int|0xffff
comma
id|devid
op_rshift
l_int|16
)paren
suffix:semicolon
multiline_comment|/*&n;&t; &t;&t; * See if IDE ports are enabled&n;&t; &t;&t; */
r_if
c_cond
(paren
id|pcibios_read_config_word
c_func
(paren
id|bus
comma
id|fn
comma
l_int|0x04
comma
op_amp
id|pcicmd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: error accessing PCICMD&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|pcicmd
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: device disabled (BIOS)&bslash;n&quot;
comma
id|d-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|bmiba
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; &t; * Check for Bus-Master DMA capability&n;&t;&t;&t; &t; */
r_if
c_cond
(paren
id|d-&gt;id
op_eq
id|DEVID_PDC20246
op_logical_or
(paren
r_class
op_eq
id|PCI_CLASS_STORAGE_IDE
op_logical_and
(paren
id|progif
op_amp
l_int|0x80
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
(paren
id|pcicmd
op_amp
l_int|4
)paren
op_logical_or
op_logical_neg
(paren
id|bmiba
op_assign
id|ide_get_or_set_bmiba
c_func
(paren
id|bus
comma
id|fn
comma
id|d-&gt;name
)paren
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Bus-Master DMA disabled (BIOS), pcicmd=0x%04x, progif=0x%02x, bmiba=0x%04x&bslash;n&quot;
comma
id|d-&gt;name
comma
id|pcicmd
comma
id|progif
comma
id|bmiba
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Setup the IDE ports&n;&t;&t;&t;&t; */
id|ide_setup_pci_device
c_func
(paren
id|bus
comma
id|fn
comma
id|bmiba
comma
id|d
)paren
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|hedt
op_eq
l_int|0x80
op_logical_and
(paren
op_increment
id|fn
op_amp
l_int|7
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_scan_pcibus() gets invoked at boot time from ide.c&n; */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|ide_scan_pcibus
(paren
r_void
)paren
)paren
(brace
r_int
r_int
id|bus
comma
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pcibios_present
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|bus
op_assign
l_int|0
suffix:semicolon
id|bus
op_le
l_int|255
suffix:semicolon
op_increment
id|bus
)paren
(brace
r_for
c_loop
(paren
id|dev
op_assign
l_int|0
suffix:semicolon
id|dev
op_le
l_int|31
suffix:semicolon
op_increment
id|dev
)paren
(brace
id|ide_scan_pci_device
c_func
(paren
id|bus
comma
id|dev
op_lshift
l_int|3
)paren
suffix:semicolon
)brace
)brace
)brace
eof
