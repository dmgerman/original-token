multiline_comment|/*&n; *  linux/drivers/block/ide-dma.c&t;Version 4.09&t;April 23, 1999&n; *&n; *  Copyright (c) 1999  Andre Hedrick&n; *  May be copied or modified under the terms of the GNU General Public License&n; */
multiline_comment|/*&n; *  Special Thanks to Mark for his Six years of work.&n; *&n; *  Copyright (c) 1995-1998  Mark Lord&n; *  May be copied or modified under the terms of the GNU General Public License&n; */
multiline_comment|/*&n; * This module provides support for the bus-master IDE DMA functions&n; * of various PCI chipsets, including the Intel PIIX (i82371FB for&n; * the 430 FX chipset), the PIIX3 (i82371SB for the 430 HX/VX and &n; * 440 chipsets), and the PIIX4 (i82371AB for the 430 TX chipset)&n; * (&quot;PIIX&quot; stands for &quot;PCI ISA IDE Xcellerator&quot;).&n; *&n; * Pretty much the same code works for other IDE PCI bus-mastering chipsets.&n; *&n; * DMA is supported for all IDE devices (disk drives, cdroms, tapes, floppies).&n; *&n; * By default, DMA support is prepared for use, but is currently enabled only&n; * for drives which already have DMA enabled (UltraDMA or mode 2 multi/single),&n; * or which are recognized as &quot;good&quot; (see table below).  Drives with only mode0&n; * or mode1 (multi/single) DMA should also work with this chipset/driver&n; * (eg. MC2112A) but are not enabled by default.&n; *&n; * Use &quot;hdparm -i&quot; to view modes supported by a given drive.&n; *&n; * The hdparm-3.5 (or later) utility can be used for manually enabling/disabling&n; * DMA support, but must be (re-)compiled against this kernel version or later.&n; *&n; * To enable DMA, use &quot;hdparm -d1 /dev/hd?&quot; on a per-drive basis after booting.&n; * If problems arise, ide.c will disable DMA operation after a few retries.&n; * This error recovery mechanism works and has been extremely well exercised.&n; *&n; * IDE drives, depending on their vintage, may support several different modes&n; * of DMA operation.  The boot-time modes are indicated with a &quot;*&quot; in&n; * the &quot;hdparm -i&quot; listing, and can be changed with *knowledgeable* use of&n; * the &quot;hdparm -X&quot; feature.  There is seldom a need to do this, as drives&n; * normally power-up with their &quot;best&quot; PIO/DMA modes enabled.&n; *&n; * Testing has been done with a rather extensive number of drives,&n; * with Quantum &amp; Western Digital models generally outperforming the pack,&n; * and Fujitsu &amp; Conner (and some Seagate which are really Conner) drives&n; * showing more lackluster throughput.&n; *&n; * Keep an eye on /var/adm/messages for &quot;DMA disabled&quot; messages.&n; *&n; * Some people have reported trouble with Intel Zappa motherboards.&n; * This can be fixed by upgrading the AMI BIOS to version 1.00.04.BS0,&n; * available from ftp://ftp.intel.com/pub/bios/10004bs0.exe&n; * (thanks to Glen Morrell &lt;glen@spin.Stanford.edu&gt; for researching this).&n; *&n; * Thanks to &quot;Christopher J. Reimer&quot; &lt;reimer@doe.carleton.ca&gt; for&n; * fixing the problem with the BIOS on some Acer motherboards.&n; *&n; * Thanks to &quot;Benoit Poulot-Cazajous&quot; &lt;poulot@chorus.fr&gt; for testing&n; * &quot;TX&quot; chipset compatibility and for providing patches for the &quot;TX&quot; chipset.&n; *&n; * Thanks to Christian Brunner &lt;chb@muc.de&gt; for taking a good first crack&n; * at generic DMA -- his patches were referred to when preparing this code.&n; *&n; * Most importantly, thanks to Robert Bringman &lt;rob@mars.trion.com&gt;&n; * for supplying a Promise UDMA board &amp; WD UDMA drive for this work!&n; *&n; * And, yes, Intel Zappa boards really *do* use both PIIX IDE ports.&n; *&n; * ACARD ATP850UF Chipset &quot;Modified SCSI Class&quot; with other names&n; *       AEC6210 U/UF&n; *       SIIG&squot;s UltraIDE Pro CN-2449&n; * TTI   HPT343 Chipset &quot;Modified SCSI Class&quot; but reports as an&n; *       unknown storage device.&n; * NEW&t; check_drive_lists(ide_drive_t *drive, int good_bad)&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#ifdef CONFIG_IDEDMA_NEW_DRIVE_LISTINGS
DECL|struct|drive_list_entry
r_struct
id|drive_list_entry
(brace
DECL|member|id_model
r_char
op_star
id|id_model
suffix:semicolon
DECL|member|id_firmware
r_char
op_star
id|id_firmware
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|drive_whitelist
r_struct
id|drive_list_entry
id|drive_whitelist
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;Micropolis 2112A&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;CONNER CTMA 4000&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;CONNER CTT8000-A&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;ST34342A&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|drive_blacklist
r_struct
id|drive_list_entry
id|drive_blacklist
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;WDC AC11000H&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;WDC AC22100H&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;WDC AC32500H&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;WDC AC33100H&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;WDC AC31600H&quot;
comma
l_string|&quot;ALL&quot;
)brace
comma
(brace
l_string|&quot;WDC AC32100H&quot;
comma
l_string|&quot;24.09P07&quot;
)brace
comma
(brace
l_string|&quot;WDC AC23200L&quot;
comma
l_string|&quot;21.10N21&quot;
)brace
comma
(brace
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|function|in_drive_list
r_int
id|in_drive_list
c_func
(paren
r_struct
id|hd_driveid
op_star
id|id
comma
r_struct
id|drive_list_entry
op_star
id|drive_table
)paren
(brace
r_for
c_loop
(paren
suffix:semicolon
id|drive_table-&gt;id_model
suffix:semicolon
id|drive_table
op_increment
)paren
r_if
c_cond
(paren
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|drive_table-&gt;id_model
comma
id|id-&gt;model
)paren
)paren
op_logical_and
(paren
(paren
op_logical_neg
id|strstr
c_func
(paren
id|drive_table-&gt;id_firmware
comma
id|id-&gt;fw_rev
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|drive_table-&gt;id_firmware
comma
l_string|&quot;ALL&quot;
)paren
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_IDEDMA_NEW_DRIVE_LISTINGS */
multiline_comment|/*&n; * good_dma_drives() lists the model names (from &quot;hdparm -i&quot;)&n; * of drives which do not support mode2 DMA but which are&n; * known to work fine with this interface under Linux.&n; */
DECL|variable|good_dma_drives
r_const
r_char
op_star
id|good_dma_drives
(braket
)braket
op_assign
(brace
l_string|&quot;Micropolis 2112A&quot;
comma
l_string|&quot;CONNER CTMA 4000&quot;
comma
l_string|&quot;CONNER CTT8000-A&quot;
comma
l_string|&quot;ST34342A&quot;
comma
multiline_comment|/* for Sun Ultra */
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; * bad_dma_drives() lists the model names (from &quot;hdparm -i&quot;)&n; * of drives which supposedly support (U)DMA but which are&n; * known to corrupt data with this interface under Linux.&n; *&n; * This is an empirical list. Its generated from bug reports. That means&n; * while it reflects actual problem distributions it doesn&squot;t answer whether&n; * the drive or the controller, or cabling, or software, or some combination&n; * thereof is the fault. If you don&squot;t happen to agree with the kernel&squot;s &n; * opinion of your drive - use hdparm to turn DMA on.&n; */
DECL|variable|bad_dma_drives
r_const
r_char
op_star
id|bad_dma_drives
(braket
)braket
op_assign
(brace
l_string|&quot;WDC AC11000H&quot;
comma
l_string|&quot;WDC AC22100H&quot;
comma
l_string|&quot;WDC AC32100H&quot;
comma
l_string|&quot;WDC AC32500H&quot;
comma
l_string|&quot;WDC AC33100H&quot;
comma
l_string|&quot;WDC AC31600H&quot;
comma
l_int|NULL
)brace
suffix:semicolon
macro_line|#endif /* CONFIG_IDEDMA_NEW_DRIVE_LISTINGS */
multiline_comment|/*&n; * Our Physical Region Descriptor (PRD) table should be large enough&n; * to handle the biggest I/O request we are likely to see.  Since requests&n; * can have no more than 256 sectors, and since the typical blocksize is&n; * two or more sectors, we could get by with a limit of 128 entries here for&n; * the usual worst case.  Most requests seem to include some contiguous blocks,&n; * further reducing the number of table entries required.&n; *&n; * The driver reverts to PIO mode for individual requests that exceed&n; * this limit (possible with 512 byte blocksizes, eg. MSDOS f/s), so handling&n; * 100% of all crazy scenarios here is not necessary.&n; *&n; * As it turns out though, we must allocate a full 4KB page for this,&n; * so the two PRD tables (ide0 &amp; ide1) will each get half of that,&n; * allowing each to have about 256 entries (8 bytes each) from this.&n; */
DECL|macro|PRD_BYTES
mdefine_line|#define PRD_BYTES&t;8
DECL|macro|PRD_ENTRIES
mdefine_line|#define PRD_ENTRIES&t;(PAGE_SIZE / (2 * PRD_BYTES))
multiline_comment|/*&n; * dma_intr() is the handler for disk read/write DMA interrupts&n; */
DECL|function|ide_dma_intr
r_void
id|ide_dma_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|i
suffix:semicolon
id|byte
id|stat
comma
id|dma_stat
suffix:semicolon
id|dma_stat
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_end
comma
id|drive
)paren
suffix:semicolon
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* get drive status */
r_if
c_cond
(paren
id|OK_STAT
c_func
(paren
id|stat
comma
id|DRIVE_READY
comma
id|drive-&gt;bad_wstat
op_or
id|DRQ_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dma_stat
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|i
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: dma_intr: bad DMA status&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
id|ide__sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* local CPU only */
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;dma_intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_build_dmatable() prepares a dma request.&n; * Returns 0 if all went okay, returns 1 otherwise.&n; * May also be invoked from trm290.c&n; */
DECL|function|ide_build_dmatable
r_int
id|ide_build_dmatable
(paren
id|ide_drive_t
op_star
id|drive
comma
id|ide_dma_action_t
id|func
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|rq-&gt;bh
suffix:semicolon
r_int
r_int
id|size
comma
id|addr
comma
op_star
id|table
op_assign
(paren
r_int
r_int
op_star
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmatable
suffix:semicolon
r_int
r_char
op_star
id|virt_addr
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_TRM290
r_int
r_int
id|is_trm290_chipset
op_assign
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|chipset
op_eq
id|ide_trm290
)paren
suffix:semicolon
macro_line|#else
r_const
r_int
id|is_trm290_chipset
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_int
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * Determine addr and size of next buffer area.  We assume that&n;&t;&t; * individual virtual buffers are always composed linearly in&n;&t;&t; * physical memory.  For example, we assume that any 8kB buffer&n;&t;&t; * is always composed of two adjacent physical 4kB pages rather&n;&t;&t; * than two possibly non-adjacent physical 4kB pages.&n;&t;&t; */
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* paging requests have (rq-&gt;bh == NULL) */
id|virt_addr
op_assign
id|rq-&gt;buffer
suffix:semicolon
id|addr
op_assign
id|virt_to_bus
(paren
id|virt_addr
)paren
suffix:semicolon
id|size
op_assign
id|rq-&gt;nr_sectors
op_lshift
l_int|9
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* group sequential buffers into one large buffer */
id|virt_addr
op_assign
id|bh-&gt;b_data
suffix:semicolon
id|addr
op_assign
id|virt_to_bus
(paren
id|virt_addr
)paren
suffix:semicolon
id|size
op_assign
id|bh-&gt;b_size
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_reqnext
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_plus
id|size
)paren
op_ne
id|virt_to_bus
(paren
id|bh-&gt;b_data
)paren
)paren
r_break
suffix:semicolon
id|size
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Fill in the dma table, without crossing any 64kB boundaries.&n;&t;&t; * Most hardware requires 16-bit alignment of all blocks,&n;&t;&t; * but the trm290 requires 32-bit alignment.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|addr
op_amp
l_int|3
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: misaligned DMA buffer&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Some CPUs without cache snooping need to invalidate/write&n;&t;&t; * back their caches before DMA transfers to guarantee correct&n;&t;&t; * data.        -- rmk&n;&t;&t; */
r_if
c_cond
(paren
id|size
)paren
(brace
r_if
c_cond
(paren
id|func
op_eq
id|ide_dma_read
)paren
(brace
id|dma_cache_inv
c_func
(paren
(paren
r_int
r_int
)paren
id|virt_addr
comma
id|size
)paren
suffix:semicolon
)brace
r_else
(brace
id|dma_cache_wback
c_func
(paren
(paren
r_int
r_int
)paren
id|virt_addr
comma
id|size
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|size
)paren
(brace
r_if
c_cond
(paren
op_increment
id|count
op_ge
id|PRD_ENTRIES
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DMA table too small&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* revert to PIO for this request */
)brace
r_else
(brace
r_int
r_int
id|xcount
comma
id|bcount
op_assign
l_int|0x10000
op_minus
(paren
id|addr
op_amp
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bcount
OG
id|size
)paren
id|bcount
op_assign
id|size
suffix:semicolon
op_star
id|table
op_increment
op_assign
id|cpu_to_le32
c_func
(paren
id|addr
)paren
suffix:semicolon
id|xcount
op_assign
id|bcount
op_amp
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|is_trm290_chipset
)paren
id|xcount
op_assign
(paren
(paren
id|xcount
op_rshift
l_int|2
)paren
op_minus
l_int|1
)paren
op_lshift
l_int|16
suffix:semicolon
op_star
id|table
op_increment
op_assign
id|cpu_to_le32
c_func
(paren
id|xcount
)paren
suffix:semicolon
id|addr
op_add_assign
id|bcount
suffix:semicolon
id|size
op_sub_assign
id|bcount
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|count
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: empty DMA table?&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|is_trm290_chipset
)paren
op_star
op_decrement
id|table
op_or_assign
id|cpu_to_le32
c_func
(paren
l_int|0x80000000
)paren
suffix:semicolon
multiline_comment|/* set End-Of-Table (EOT) bit */
multiline_comment|/*&n;&t;&t; * Some CPUs need to flush the DMA table to physical RAM&n;&t;&t; * before DMA can start.        -- rmk&n;&t;&t; */
id|dma_cache_wback
c_func
(paren
(paren
r_int
r_int
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmatable
comma
id|count
op_star
r_sizeof
(paren
r_int
r_int
)paren
op_star
l_int|2
)paren
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/*&n; *  For both Blacklisted and Whitelisted drives.&n; *  This is setup to be called as an extern for future support&n; *  to other special driver code.&n; */
DECL|function|check_drive_lists
r_int
id|check_drive_lists
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|good_bad
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
macro_line|#ifdef CONFIG_IDEDMA_NEW_DRIVE_LISTINGS
r_if
c_cond
(paren
id|good_bad
)paren
(brace
r_return
id|in_drive_list
c_func
(paren
id|id
comma
id|drive_whitelist
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
id|blacklist
op_assign
id|in_drive_list
c_func
(paren
id|id
comma
id|drive_blacklist
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blacklist
)paren
id|printk
c_func
(paren
l_string|&quot;%s: Disabling (U)DMA for %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|id-&gt;model
)paren
suffix:semicolon
r_return
id|blacklist
suffix:semicolon
)brace
macro_line|#else /* !CONFIG_IDEDMA_NEW_DRIVE_LISTINGS */
r_const
r_char
op_star
op_star
id|list
suffix:semicolon
r_if
c_cond
(paren
id|good_bad
)paren
(brace
multiline_comment|/* Consult the list of known &quot;good&quot; drives */
id|list
op_assign
id|good_dma_drives
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|list
op_increment
comma
id|id-&gt;model
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Consult the list of known &quot;bad&quot; drives */
id|list
op_assign
id|bad_dma_drives
suffix:semicolon
r_while
c_loop
(paren
op_star
id|list
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
op_star
id|list
op_increment
comma
id|id-&gt;model
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Disabling (U)DMA for %s&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|id-&gt;model
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
macro_line|#endif /* CONFIG_IDEDMA_NEW_DRIVE_LISTINGS */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|config_drive_for_dma
r_static
r_int
id|config_drive_for_dma
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_logical_and
(paren
id|id-&gt;capability
op_amp
l_int|1
)paren
op_logical_and
id|hwif-&gt;autodma
)paren
(brace
multiline_comment|/* Consult the list of known &quot;bad&quot; drives */
r_if
c_cond
(paren
id|ide_dmaproc
c_func
(paren
id|ide_dma_bad_drive
comma
id|drive
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* Enable DMA on any drive that has UltraDMA (mode 3/4) enabled */
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|4
)paren
op_logical_and
(paren
id|hwif-&gt;udma_four
)paren
op_logical_and
(paren
id|id-&gt;word93
op_amp
l_int|0x2000
)paren
)paren
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_amp
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|11
)paren
op_amp
l_int|3
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* Enable DMA on any drive that has UltraDMA (mode 0/1/2) enabled */
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|4
)paren
multiline_comment|/* UltraDMA */
r_if
c_cond
(paren
(paren
id|id-&gt;dma_ultra
op_amp
(paren
id|id-&gt;dma_ultra
op_rshift
l_int|8
)paren
op_amp
l_int|7
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* Enable DMA on any drive that has mode2 DMA (multi or single) enabled */
r_if
c_cond
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
multiline_comment|/* regular DMA */
r_if
c_cond
(paren
(paren
id|id-&gt;dma_mword
op_amp
l_int|0x404
)paren
op_eq
l_int|0x404
op_logical_or
(paren
id|id-&gt;dma_1word
op_amp
l_int|0x404
)paren
op_eq
l_int|0x404
)paren
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* Consult the list of known &quot;good&quot; drives */
r_if
c_cond
(paren
id|ide_dmaproc
c_func
(paren
id|ide_dma_good_drive
comma
id|drive
)paren
)paren
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_on
comma
id|drive
)paren
suffix:semicolon
)brace
r_return
id|hwif
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off_quietly
comma
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ide_dmaproc() initiates/aborts DMA read/write operations on a drive.&n; *&n; * The caller is assumed to have selected the drive and programmed the drive&squot;s&n; * sector address using CHS or LBA.  All that remains is to prepare for DMA&n; * and then issue the actual read/write DMA/PIO command to the drive.&n; *&n; * For ATAPI devices, we just prepare for DMA and return. The caller should&n; * then issue the packet command to the drive and call us again with&n; * ide_dma_begin afterwards.&n; *&n; * Returns 0 if all went well.&n; * Returns 1 if DMA read/write could not be started, in which case&n; * the caller should revert to PIO for the current request.&n; * May also be invoked from trm290.c&n; */
DECL|function|ide_dmaproc
r_int
id|ide_dmaproc
(paren
id|ide_dma_action_t
id|func
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
r_int
id|dma_base
op_assign
id|hwif-&gt;dma_base
suffix:semicolon
r_int
r_int
id|count
comma
id|reading
op_assign
l_int|0
suffix:semicolon
id|byte
id|dma_stat
suffix:semicolon
r_switch
c_cond
(paren
id|func
)paren
(brace
r_case
id|ide_dma_off
suffix:colon
id|printk
c_func
(paren
l_string|&quot;%s: DMA disabled&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_case
id|ide_dma_off_quietly
suffix:colon
r_case
id|ide_dma_on
suffix:colon
id|drive-&gt;using_dma
op_assign
(paren
id|func
op_eq
id|ide_dma_on
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|ide_dma_check
suffix:colon
r_return
id|config_drive_for_dma
(paren
id|drive
)paren
suffix:semicolon
r_case
id|ide_dma_read
suffix:colon
id|reading
op_assign
l_int|1
op_lshift
l_int|3
suffix:semicolon
r_case
id|ide_dma_write
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|count
op_assign
id|ide_build_dmatable
c_func
(paren
id|drive
comma
id|func
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* try PIO instead of DMA */
id|outl
c_func
(paren
id|virt_to_bus
c_func
(paren
id|hwif-&gt;dmatable
)paren
comma
id|dma_base
op_plus
l_int|4
)paren
suffix:semicolon
multiline_comment|/* PRD table */
id|outb
c_func
(paren
id|reading
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* specify r/w */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_or
l_int|6
comma
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* clear INTR &amp; ERROR flags */
id|drive-&gt;waiting_for_dma
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_return
l_int|0
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|ide_dma_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* issue cmd to drive */
id|OUT_BYTE
c_func
(paren
id|reading
ques
c_cond
id|WIN_READDMA
suffix:colon
id|WIN_WRITEDMA
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_case
id|ide_dma_begin
suffix:colon
multiline_comment|/* Note that this is done *after* the cmd has&n;&t;&t;&t; * been issued to the drive, as per the BM-IDE spec.&n;&t;&t;&t; * The Promise Ultra33 doesn&squot;t work correctly when&n;&t;&t;&t; * we do this part before issuing the drive cmd.&n;&t;&t;&t; */
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_or
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* start DMA */
r_return
l_int|0
suffix:semicolon
r_case
id|ide_dma_end
suffix:colon
multiline_comment|/* returns 1 on error, 0 otherwise */
id|drive-&gt;waiting_for_dma
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
)paren
op_amp
op_complement
l_int|1
comma
id|dma_base
)paren
suffix:semicolon
multiline_comment|/* stop DMA */
id|dma_stat
op_assign
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* get DMA status */
id|outb
c_func
(paren
id|dma_stat
op_or
l_int|6
comma
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
multiline_comment|/* clear the INTR &amp; ERROR bits */
r_return
(paren
id|dma_stat
op_amp
l_int|7
)paren
op_ne
l_int|4
suffix:semicolon
multiline_comment|/* verify good DMA status */
r_case
id|ide_dma_test_irq
suffix:colon
multiline_comment|/* returns 1 if dma irq issued, 0 otherwise */
id|dma_stat
op_assign
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
r_return
(paren
id|dma_stat
op_amp
l_int|4
)paren
op_eq
l_int|4
suffix:semicolon
multiline_comment|/* return 1 if INTR asserted */
r_case
id|ide_dma_bad_drive
suffix:colon
r_case
id|ide_dma_good_drive
suffix:colon
r_return
id|check_drive_lists
c_func
(paren
id|drive
comma
(paren
id|func
op_eq
id|ide_dma_good_drive
)paren
)paren
suffix:semicolon
r_case
id|ide_dma_lostirq
suffix:colon
r_case
id|ide_dma_timeout
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * printk(&quot;ide_dmaproc: chipset supported func only: %d&bslash;n&quot;, func);&n;&t;&t;&t; */
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ide_dmaproc: unsupported func: %d&bslash;n&quot;
comma
id|func
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Needed for allowing full modular support of ide-driver&n; */
DECL|function|ide_release_dma
r_int
id|ide_release_dma
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;dmatable
)paren
(brace
id|clear_page
c_func
(paren
(paren
r_void
op_star
)paren
id|hwif-&gt;dmatable
)paren
suffix:semicolon
multiline_comment|/* clear PRD 1st */
id|free_page
c_func
(paren
(paren
r_int
r_int
)paren
id|hwif-&gt;dmatable
)paren
suffix:semicolon
multiline_comment|/* free PRD 2nd */
)brace
r_if
c_cond
(paren
(paren
id|hwif-&gt;dma_extra
)paren
op_logical_and
(paren
id|hwif-&gt;channel
op_eq
l_int|0
)paren
)paren
id|release_region
c_func
(paren
(paren
id|hwif-&gt;dma_base
op_plus
l_int|16
)paren
comma
id|hwif-&gt;dma_extra
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|hwif-&gt;dma_base
comma
l_int|8
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; *&t;This can be called for a dynamically installed interface. Don&squot;t __init it&n; */
DECL|function|ide_setup_dma
r_void
id|ide_setup_dma
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_int
r_int
id|dma_base
comma
r_int
r_int
id|num_ports
)paren
(brace
r_static
r_int
r_int
id|dmatable
op_assign
l_int|0
suffix:semicolon
r_static
r_int
id|leftover
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;    %s: BM-DMA at 0x%04lx-0x%04lx&quot;
comma
id|hwif-&gt;name
comma
id|dma_base
comma
id|dma_base
op_plus
id|num_ports
op_minus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|dma_base
comma
id|num_ports
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; -- ERROR, PORT ADDRESSES ALREADY IN USE&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|request_region
c_func
(paren
id|dma_base
comma
id|num_ports
comma
id|hwif-&gt;name
)paren
suffix:semicolon
id|hwif-&gt;dma_base
op_assign
id|dma_base
suffix:semicolon
r_if
c_cond
(paren
id|leftover
OL
(paren
id|PRD_ENTRIES
op_star
id|PRD_BYTES
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * The BM-DMA uses full 32bit addr, so we can&n;&t;&t; * safely use __get_free_page() here instead&n;&t;&t; * of __get_dma_pages() -- no ISA limitations.&n;&t;&t; */
id|dmatable
op_assign
id|__get_free_pages
c_func
(paren
id|GFP_KERNEL
comma
l_int|1
)paren
suffix:semicolon
id|leftover
op_assign
id|dmatable
ques
c_cond
id|PAGE_SIZE
suffix:colon
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|dmatable
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; -- ERROR, UNABLE TO ALLOCATE PRD TABLE&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|hwif-&gt;dmatable
op_assign
(paren
r_int
r_int
op_star
)paren
id|dmatable
suffix:semicolon
id|dmatable
op_add_assign
(paren
id|PRD_ENTRIES
op_star
id|PRD_BYTES
)paren
suffix:semicolon
id|leftover
op_sub_assign
(paren
id|PRD_ENTRIES
op_star
id|PRD_BYTES
)paren
suffix:semicolon
id|hwif-&gt;dmaproc
op_assign
op_amp
id|ide_dmaproc
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_ne
id|ide_trm290
)paren
(brace
id|byte
id|dma_stat
op_assign
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;, BIOS settings: %s:%s, %s:%s&quot;
comma
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|name
comma
(paren
id|dma_stat
op_amp
l_int|0x20
)paren
ques
c_cond
l_string|&quot;DMA&quot;
suffix:colon
l_string|&quot;pio&quot;
comma
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|name
comma
(paren
id|dma_stat
op_amp
l_int|0x40
)paren
ques
c_cond
l_string|&quot;DMA&quot;
suffix:colon
l_string|&quot;pio&quot;
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Fetch the DMA Bus-Master-I/O-Base-Address (BMIBA) from PCI space:&n; */
DECL|function|ide_get_or_set_dma_base
r_int
r_int
id|__init
id|ide_get_or_set_dma_base
(paren
id|ide_hwif_t
op_star
id|hwif
comma
r_int
id|extra
comma
r_const
r_char
op_star
id|name
)paren
(brace
r_int
r_int
id|dma_base
op_assign
l_int|0
suffix:semicolon
r_struct
id|pci_dev
op_star
id|dev
op_assign
id|hwif-&gt;pci_dev
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;mate
op_logical_and
id|hwif-&gt;mate-&gt;dma_base
)paren
(brace
id|dma_base
op_assign
id|hwif-&gt;mate-&gt;dma_base
op_minus
(paren
id|hwif-&gt;channel
ques
c_cond
l_int|0
suffix:colon
l_int|8
)paren
suffix:semicolon
)brace
r_else
(brace
id|dma_base
op_assign
id|dev-&gt;resource
(braket
l_int|4
)braket
dot
id|start
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|dma_base
op_logical_or
id|dma_base
op_eq
id|PCI_BASE_ADDRESS_IO_MASK
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: dma_base is invalid (0x%04lx)&bslash;n&quot;
comma
id|name
comma
id|dma_base
)paren
suffix:semicolon
id|dma_base
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dma_base
)paren
(brace
r_if
c_cond
(paren
id|extra
)paren
multiline_comment|/* PDC20246, PDC20262, &amp; HPT343 */
id|request_region
c_func
(paren
id|dma_base
op_plus
l_int|16
comma
id|extra
comma
id|name
)paren
suffix:semicolon
id|dma_base
op_add_assign
id|hwif-&gt;channel
ques
c_cond
l_int|8
suffix:colon
l_int|0
suffix:semicolon
id|hwif-&gt;dma_extra
op_assign
id|extra
suffix:semicolon
r_switch
c_cond
(paren
id|dev-&gt;device
)paren
(brace
r_case
id|PCI_DEVICE_ID_CMD_643
suffix:colon
r_case
id|PCI_DEVICE_ID_AL_M5219
suffix:colon
id|outb
c_func
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_amp
l_int|0x60
comma
id|dma_base
op_plus
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_amp
l_int|0x80
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: simplex device: DMA forced&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * If the device claims &quot;simplex&quot; DMA,&n;&t;&t;&t;&t; * this means only one of the two interfaces&n;&t;&t;&t;&t; * can be trusted with DMA at any point in time.&n;&t;&t;&t;&t; * So we should enable DMA only on one of the&n;&t;&t;&t;&t; * two interfaces.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|dma_base
op_plus
l_int|2
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
multiline_comment|/* simplex device? */
r_if
c_cond
(paren
(paren
op_logical_neg
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|present
op_logical_and
op_logical_neg
id|hwif-&gt;drives
(braket
l_int|1
)braket
dot
id|present
)paren
op_logical_or
(paren
id|hwif-&gt;mate
op_logical_and
id|hwif-&gt;mate-&gt;dma_base
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: simplex device:  DMA disabled&bslash;n&quot;
comma
id|name
)paren
suffix:semicolon
id|dma_base
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
id|dma_base
suffix:semicolon
)brace
eof
