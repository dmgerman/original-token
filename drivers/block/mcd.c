multiline_comment|/*&n;&t;linux/kernel/blk_drv/mcd.c - Mitsumi CDROM driver&n;&n;&t;Copyright (C) 1992  Martin Harriss&n;&n;&t;martin@bdsi.com&n;&n;&t;This program is free software; you can redistribute it and/or modify&n;&t;it under the terms of the GNU General Public License as published by&n;&t;the Free Software Foundation; either version 2, or (at your option)&n;&t;any later version.&n;&n;&t;This program is distributed in the hope that it will be useful,&n;&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n;&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;&t;GNU General Public License for more details.&n;&n;&t;You should have received a copy of the GNU General Public License&n;&t;along with this program; if not, write to the Free Software&n;&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;&t;HISTORY&n;&n;&t;0.1&t;First attempt - internal use only&n;&t;0.2&t;Cleaned up delays and use of timer - alpha release&n;&t;0.3&t;Audio support added&n;&t;0.3.1 Changes for mitsumi CRMC LU005S march version&n;&t;&t;   (stud11@cc4.kuleuven.ac.be)&n;        0.3.2 bug fixes to the ioclts and merged with ALPHA0.99-pl12&n;&t;&t;   (Jon Tombs &lt;jon@robots.ox.ac.uk&gt;)&n;        0.3.3 Added more #defines and mcd_setup()&n;   &t;&t;   (Jon Tombs &lt;jon@gtex02.us.es&gt;)&n;*/
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
multiline_comment|/* #define REALLY_SLOW_IO  */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR MITSUMI_CDROM_MAJOR
macro_line|#include &quot;blk.h&quot;
macro_line|#include &lt;linux/mcd.h&gt;
macro_line|#if 0
r_static
r_int
id|mcd_sizes
(braket
)braket
op_assign
(brace
l_int|0
)brace
suffix:semicolon
macro_line|#endif
DECL|variable|mcdPresent
r_static
r_int
id|mcdPresent
op_assign
l_int|0
suffix:semicolon
DECL|variable|mcd_buf
r_static
r_char
id|mcd_buf
(braket
l_int|2048
)braket
suffix:semicolon
multiline_comment|/* buffer for block size conversion */
DECL|variable|mcd_bn
r_static
r_int
id|mcd_bn
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|mcd_port
r_static
r_int
id|mcd_port
op_assign
id|MCD_BASE_ADDR
suffix:semicolon
DECL|variable|mcd_irq
r_static
r_int
id|mcd_irq
op_assign
id|MCD_INTR_NR
suffix:semicolon
DECL|variable|McdTimeout
DECL|variable|McdTries
r_static
r_int
id|McdTimeout
comma
id|McdTries
suffix:semicolon
DECL|variable|mcd_waitq
r_static
r_struct
id|wait_queue
op_star
id|mcd_waitq
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|DiskInfo
r_static
r_struct
id|mcd_DiskInfo
id|DiskInfo
suffix:semicolon
DECL|variable|Toc
r_static
r_struct
id|mcd_Toc
id|Toc
(braket
id|MAX_TRACKS
)braket
suffix:semicolon
DECL|variable|mcd_Play
r_static
r_struct
id|mcd_Play_msf
id|mcd_Play
suffix:semicolon
DECL|variable|audioStatus
r_static
r_int
id|audioStatus
suffix:semicolon
DECL|variable|mcdDiskChanged
r_static
r_char
id|mcdDiskChanged
suffix:semicolon
DECL|variable|tocUpToDate
r_static
r_char
id|tocUpToDate
suffix:semicolon
DECL|variable|mcdVersion
r_static
r_char
id|mcdVersion
suffix:semicolon
r_static
r_void
id|mcd_transfer
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|mcd_start
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|mcd_status
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|mcd_read_cmd
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|mcd_data
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_mcd_request
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|hsg2msf
c_func
(paren
r_int
id|hsg
comma
r_struct
id|msf
op_star
id|msf
)paren
suffix:semicolon
r_static
r_void
id|bin2bcd
c_func
(paren
r_int
r_char
op_star
id|p
)paren
suffix:semicolon
r_static
r_int
id|bcd2bin
c_func
(paren
r_int
r_char
id|bcd
)paren
suffix:semicolon
r_static
r_int
id|mcdStatus
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|sendMcdCmd
c_func
(paren
r_int
id|cmd
comma
r_struct
id|mcd_Play_msf
op_star
id|params
)paren
suffix:semicolon
r_static
r_int
id|getMcdStatus
c_func
(paren
r_int
id|timeout
)paren
suffix:semicolon
r_static
r_int
id|GetQChannelInfo
c_func
(paren
r_struct
id|mcd_Toc
op_star
id|qp
)paren
suffix:semicolon
r_static
r_int
id|updateToc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|GetDiskInfo
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|GetToc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|getValue
c_func
(paren
r_int
r_char
op_star
id|result
)paren
suffix:semicolon
DECL|function|mcd_setup
r_void
id|mcd_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|mcd_port
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|1
)paren
id|mcd_irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
)brace
r_int
DECL|function|check_mcd_media_change
id|check_mcd_media_change
c_func
(paren
r_int
id|full_dev
comma
r_int
id|flag
)paren
(brace
r_int
id|retval
comma
id|target
suffix:semicolon
macro_line|#if 1&t; /* the below is not reliable */
r_return
l_int|0
suffix:semicolon
macro_line|#endif  
id|target
op_assign
id|MINOR
c_func
(paren
id|full_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|target
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: Mitsumi CD-ROM request error: invalid device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|retval
op_assign
id|mcdDiskChanged
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
id|mcdDiskChanged
op_assign
l_int|0
suffix:semicolon
)brace
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Do a &squot;get status&squot; command and get the result.  Only use from the top half&n; * because it calls &squot;getMcdStatus&squot; which sleeps.&n; */
r_static
r_int
DECL|function|statusCmd
id|statusCmd
c_func
(paren
r_void
)paren
(brace
r_int
id|st
comma
id|retry
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|outb
c_func
(paren
id|MCMD_GET_STATUS
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* send get-status cmd */
id|st
op_assign
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
r_return
id|st
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a &squot;Play&squot; command and get the status.  Use only from the top half.&n; */
r_static
r_int
DECL|function|mcdPlay
id|mcdPlay
c_func
(paren
r_struct
id|mcd_Play_msf
op_star
id|arg
)paren
(brace
r_int
id|retry
comma
id|st
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|sendMcdCmd
c_func
(paren
id|MCMD_PLAY_READ
comma
id|arg
)paren
suffix:semicolon
id|st
op_assign
id|getMcdStatus
c_func
(paren
l_int|2
op_star
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
r_return
id|st
suffix:semicolon
)brace
r_int
DECL|function|msf2hsg
id|msf2hsg
c_func
(paren
r_struct
id|msf
op_star
id|mp
)paren
(brace
r_return
id|bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|frame
)paren
op_plus
id|bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|sec
)paren
op_star
l_int|75
op_plus
id|bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|min
)paren
op_star
l_int|4500
op_minus
l_int|150
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcd_ioctl
id|mcd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|i
comma
id|st
suffix:semicolon
r_struct
id|mcd_Toc
id|qInfo
suffix:semicolon
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_struct
id|cdrom_tochdr
id|tocHdr
suffix:semicolon
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_struct
id|cdrom_tocentry
id|entry
suffix:semicolon
r_struct
id|mcd_Toc
op_star
id|tocPtr
suffix:semicolon
r_struct
id|cdrom_subchnl
id|subchnl
suffix:semicolon
macro_line|#if 0
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|ip
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|st
op_assign
id|statusCmd
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tocUpToDate
)paren
(brace
id|i
op_assign
id|updateToc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
r_return
id|i
suffix:semicolon
multiline_comment|/* error reading TOC */
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSTART
suffix:colon
multiline_comment|/* Spin up the drive */
multiline_comment|/* Don&squot;t think we can do this.  Even if we could,&n; &t;&t; * I think the drive times out and stops after a while&n;&t;&t; * anyway.  For now, ignore it.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
multiline_comment|/* Spin down the drive */
id|outb
c_func
(paren
id|MCMD_STOP
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_assign
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
multiline_comment|/* should we do anything if it fails? */
id|audioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMPAUSE
suffix:colon
multiline_comment|/* Pause the drive */
r_if
c_cond
(paren
id|audioStatus
op_ne
id|CDROM_AUDIO_PLAY
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|outb
c_func
(paren
id|MCMD_STOP
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_assign
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* didn&squot;t get q channel info */
id|audioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mcd_Play.start
op_assign
id|qInfo.diskTime
suffix:semicolon
multiline_comment|/* remember restart point */
id|audioStatus
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
multiline_comment|/* Play it again, Sam */
r_if
c_cond
(paren
id|audioStatus
op_ne
id|CDROM_AUDIO_PAUSED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* restart the drive at the saved position. */
id|i
op_assign
id|mcdPlay
c_func
(paren
op_amp
id|mcd_Play
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|audioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|audioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMPLAYTRKIND
suffix:colon
multiline_comment|/* Play a track.  This currently ignores index. */
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|ti
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|ti
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ti.cdti_trk0
template_param
id|DiskInfo.last
op_logical_or
id|ti.cdti_trk1
OL
id|ti.cdti_trk0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ti.cdti_trk1
OG
id|DiskInfo.last
)paren
id|ti
dot
id|cdti_trk1
op_assign
id|DiskInfo.last
suffix:semicolon
id|mcd_Play.start
op_assign
id|Toc
(braket
id|ti.cdti_trk0
)braket
dot
id|diskTime
suffix:semicolon
id|mcd_Play.end
op_assign
id|Toc
(braket
id|ti.cdti_trk1
op_plus
l_int|1
)braket
dot
id|diskTime
suffix:semicolon
macro_line|#ifdef MCD_DEBUG
id|printk
c_func
(paren
l_string|&quot;play: %02x:%02x.%02x to %02x:%02x.%02x&bslash;n&quot;
comma
id|mcd_Play.start.min
comma
id|mcd_Play.start.sec
comma
id|mcd_Play.start.frame
comma
id|mcd_Play.end.min
comma
id|mcd_Play.end.sec
comma
id|mcd_Play.end.frame
)paren
suffix:semicolon
macro_line|#endif
id|i
op_assign
id|mcdPlay
c_func
(paren
op_amp
id|mcd_Play
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|audioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|audioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMPLAYMSF
suffix:colon
multiline_comment|/* Play starting at the given MSF address. */
r_if
c_cond
(paren
id|audioStatus
op_eq
id|CDROM_AUDIO_PLAY
)paren
(brace
id|outb
c_func
(paren
id|MCMD_STOP
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_assign
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
id|audioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
)brace
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
multiline_comment|/* convert to bcd */
id|bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_min0
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_sec0
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_frame0
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_min1
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_sec1
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf.cdmsf_frame1
)paren
suffix:semicolon
id|mcd_Play.start.min
op_assign
id|msf.cdmsf_min0
suffix:semicolon
id|mcd_Play.start.sec
op_assign
id|msf.cdmsf_sec0
suffix:semicolon
id|mcd_Play.start.frame
op_assign
id|msf.cdmsf_frame0
suffix:semicolon
id|mcd_Play.end.min
op_assign
id|msf.cdmsf_min1
suffix:semicolon
id|mcd_Play.end.sec
op_assign
id|msf.cdmsf_sec1
suffix:semicolon
id|mcd_Play.end.frame
op_assign
id|msf.cdmsf_frame1
suffix:semicolon
macro_line|#ifdef MCD_DEBUG
id|printk
c_func
(paren
l_string|&quot;play: %02x:%02x.%02x to %02x:%02x.%02x&bslash;n&quot;
comma
id|mcd_Play.start.min
comma
id|mcd_Play.start.sec
comma
id|mcd_Play.start.frame
comma
id|mcd_Play.end.min
comma
id|mcd_Play.end.sec
comma
id|mcd_Play.end.frame
)paren
suffix:semicolon
macro_line|#endif
id|i
op_assign
id|mcdPlay
c_func
(paren
op_amp
id|mcd_Play
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|audioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|audioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMREADTOCHDR
suffix:colon
multiline_comment|/* Read the table of contents header */
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|tocHdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|tocHdr.cdth_trk0
op_assign
id|DiskInfo.first
suffix:semicolon
id|tocHdr.cdth_trk1
op_assign
id|DiskInfo.last
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|tocHdr
comma
r_sizeof
id|tocHdr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMREADTOCENTRY
suffix:colon
multiline_comment|/* Read an entry in the table of contents */
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|entry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry.cdte_track
op_eq
id|CDROM_LEADOUT
)paren
multiline_comment|/* XXX */
id|tocPtr
op_assign
op_amp
id|Toc
(braket
id|DiskInfo.last
op_plus
l_int|1
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry.cdte_track
OG
id|DiskInfo.last
op_logical_or
id|entry.cdte_track
OL
id|DiskInfo.first
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
id|tocPtr
op_assign
op_amp
id|Toc
(braket
id|entry.cdte_track
)braket
suffix:semicolon
id|entry.cdte_adr
op_assign
id|tocPtr
op_member_access_from_pointer
id|ctrl_addr
suffix:semicolon
id|entry.cdte_ctrl
op_assign
id|tocPtr
op_member_access_from_pointer
id|ctrl_addr
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
id|CDROM_LBA
)paren
id|entry.cdte_addr.lba
op_assign
id|msf2hsg
c_func
(paren
op_amp
id|tocPtr
op_member_access_from_pointer
id|diskTime
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
id|entry.cdte_addr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.min
)paren
suffix:semicolon
id|entry.cdte_addr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.sec
)paren
suffix:semicolon
id|entry.cdte_addr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.frame
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|entry
comma
r_sizeof
id|entry
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMSUBCHNL
suffix:colon
multiline_comment|/* Get subchannel info */
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|subchnl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|subchnl
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|subchnl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|subchnl.cdsc_audiostatus
op_assign
id|audioStatus
suffix:semicolon
id|subchnl.cdsc_adr
op_assign
id|qInfo.ctrl_addr
suffix:semicolon
id|subchnl.cdsc_ctrl
op_assign
id|qInfo.ctrl_addr
op_rshift
l_int|4
suffix:semicolon
id|subchnl.cdsc_trk
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.track
)paren
suffix:semicolon
id|subchnl.cdsc_ind
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.pointIndex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|subchnl.cdsc_format
op_eq
id|CDROM_LBA
)paren
(brace
id|subchnl.cdsc_absaddr.lba
op_assign
id|msf2hsg
c_func
(paren
op_amp
id|qInfo.diskTime
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.lba
op_assign
id|msf2hsg
c_func
(paren
op_amp
id|qInfo.trackTime
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|subchnl.cdsc_format
op_eq
id|CDROM_MSF
)paren
(brace
id|subchnl.cdsc_absaddr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.diskTime.min
)paren
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.diskTime.sec
)paren
suffix:semicolon
id|subchnl.cdsc_absaddr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.diskTime.frame
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.trackTime.min
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.trackTime.sec
)paren
suffix:semicolon
id|subchnl.cdsc_reladdr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.trackTime.frame
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|subchnl
comma
r_sizeof
id|subchnl
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMVOLCTRL
suffix:colon
multiline_comment|/* Volume control */
multiline_comment|/*&n;&t; * This is not working yet.  Setting the volume by itself does&n;&t; * nothing.  Following the &squot;set&squot; by a &squot;play&squot; results in zero&n;&t; * volume.  Something to work on for the next release.&n;&t; */
macro_line|#if 0
id|st
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
)paren
r_return
id|st
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|volctrl
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;VOL %d %d&bslash;n&quot;
comma
id|volctrl.channel0
op_amp
l_int|0xFF
comma
id|volctrl.channel1
op_amp
l_int|0xFF
)paren
suffix:semicolon
id|outb
c_func
(paren
id|MCMD_SET_VOLUME
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|volctrl.channel0
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|volctrl.channel1
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_assign
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
(brace
r_int
id|a
comma
id|b
comma
id|c
comma
id|d
suffix:semicolon
id|getValue
c_func
(paren
op_amp
id|a
)paren
suffix:semicolon
id|getValue
c_func
(paren
op_amp
id|b
)paren
suffix:semicolon
id|getValue
c_func
(paren
op_amp
id|c
)paren
suffix:semicolon
id|getValue
c_func
(paren
op_amp
id|d
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%02X %02X %02X %02X&bslash;n&quot;
comma
id|a
comma
id|b
comma
id|c
comma
id|d
)paren
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0xF8
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_assign
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;F8 -&gt; %02X&bslash;n&quot;
comma
id|i
op_amp
l_int|0xFF
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMEJECT
suffix:colon
multiline_comment|/* Eject the drive - N/A */
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Take care of the different block sizes between cdrom and Linux.&n; * When Linux gets variable block sizes this will probably go away.&n; */
r_static
r_void
DECL|function|mcd_transfer
id|mcd_transfer
c_func
(paren
r_void
)paren
(brace
r_int
id|offs
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
OG
l_int|0
op_logical_and
id|mcd_bn
op_eq
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
)paren
(brace
id|offs
op_assign
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_amp
l_int|3
)paren
op_star
l_int|512
suffix:semicolon
id|memcpy
c_func
(paren
id|CURRENT
op_member_access_from_pointer
id|buffer
comma
id|mcd_buf
op_plus
id|offs
comma
l_int|512
)paren
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_decrement
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|sector
op_increment
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|buffer
op_add_assign
l_int|512
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * We only seem to get interrupts after an error.&n; * Just take the interrupt and clear out the status reg.&n; */
r_static
r_void
DECL|function|mcd_interrupt
id|mcd_interrupt
c_func
(paren
r_int
id|unused
)paren
(brace
r_int
id|st
suffix:semicolon
id|st
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|st
op_ne
l_int|0xFF
)paren
(brace
id|st
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
op_amp
l_int|0xFF
suffix:semicolon
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;&lt;int-%02X&gt;&quot;
comma
id|st
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
multiline_comment|/*&n; * I/O request routine called from Linux kernel.&n; */
r_static
r_void
DECL|function|do_mcd_request
id|do_mcd_request
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|block
comma
id|dev
suffix:semicolon
r_int
r_int
id|nsect
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
op_logical_neg
(paren
id|CURRENT
)paren
op_logical_or
id|CURRENT-&gt;dev
OL
l_int|0
)paren
r_return
suffix:semicolon
id|INIT_REQUEST
suffix:semicolon
id|dev
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
suffix:semicolon
id|block
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|nsect
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_eq
l_int|NULL
op_logical_or
id|CURRENT
op_member_access_from_pointer
id|sector
op_eq
op_minus
l_int|1
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_member_access_from_pointer
id|cmd
op_ne
id|READ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: bad cmd %d&bslash;n&quot;
comma
id|CURRENT
op_member_access_from_pointer
id|cmd
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|mcd_transfer
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* if we satisfied the request from the buffer, we&squot;re done. */
r_if
c_cond
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_eq
l_int|0
)paren
(brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|McdTries
op_assign
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|mcd_start
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Start the I/O for the cdrom. Handle retry count.&n; */
r_static
r_void
DECL|function|mcd_start
id|mcd_start
c_func
(paren
)paren
(brace
r_if
c_cond
(paren
id|McdTries
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: read failed after %d tries&bslash;n&quot;
comma
id|MCD_RETRY_ATTEMPTS
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|do_mcd_request
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* wait a bit, try again */
r_return
suffix:semicolon
)brace
id|McdTries
op_decrement
suffix:semicolon
id|outb
c_func
(paren
l_int|0x40
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* get status */
id|McdTimeout
op_assign
id|MCD_STATUS_DELAY
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|mcd_status
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Called from the timer to check the results of the get-status cmd.&n; * On success, send the set-mode command.&n; */
r_static
r_void
DECL|function|mcd_status
id|mcd_status
c_func
(paren
)paren
(brace
r_int
id|st
suffix:semicolon
id|McdTimeout
op_decrement
suffix:semicolon
id|st
op_assign
id|mcdStatus
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|McdTimeout
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: status timed out&bslash;n&quot;
)paren
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|mcd_start
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* wait a bit, try again */
r_return
suffix:semicolon
)brace
id|SET_TIMER
c_func
(paren
id|mcd_status
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st
op_amp
id|MST_DSK_CHG
)paren
(brace
id|mcdDiskChanged
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|st
op_amp
id|MST_READY
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: disk removed&bslash;n&quot;
)paren
suffix:semicolon
id|mcdDiskChanged
op_assign
l_int|1
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|do_mcd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|outb
c_func
(paren
l_int|0x50
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* set mode */
id|outb
c_func
(paren
l_int|0x01
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* mode = cooked data */
id|McdTimeout
op_assign
l_int|100
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|mcd_read_cmd
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check the result of the set-mode command.  On success, send the&n; * read-data command.&n; */
r_static
r_void
DECL|function|mcd_read_cmd
id|mcd_read_cmd
c_func
(paren
)paren
(brace
r_int
id|st
suffix:semicolon
r_int
id|block
suffix:semicolon
r_struct
id|mcd_Play_msf
id|mcdcmd
suffix:semicolon
id|McdTimeout
op_decrement
suffix:semicolon
id|st
op_assign
id|mcdStatus
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_amp
id|MST_DSK_CHG
)paren
(brace
id|mcdDiskChanged
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|McdTimeout
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: set mode timed out&bslash;n&quot;
)paren
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|mcd_start
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* wait a bit, try again */
r_return
suffix:semicolon
)brace
id|SET_TIMER
c_func
(paren
id|mcd_read_cmd
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|mcd_bn
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* purge our buffer */
id|block
op_assign
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
suffix:semicolon
id|hsg2msf
c_func
(paren
id|block
comma
op_amp
id|mcdcmd.start
)paren
suffix:semicolon
multiline_comment|/* cvt to msf format */
id|mcdcmd.end.min
op_assign
l_int|0
suffix:semicolon
id|mcdcmd.end.sec
op_assign
l_int|0
suffix:semicolon
id|mcdcmd.end.frame
op_assign
l_int|1
suffix:semicolon
id|sendMcdCmd
c_func
(paren
id|MCMD_PLAY_READ
comma
op_amp
id|mcdcmd
)paren
suffix:semicolon
multiline_comment|/* read command */
id|McdTimeout
op_assign
l_int|200
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|mcd_data
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Check the completion of the read-data command.  On success, read&n; * the 2048 bytes of data from the disk into our buffer.&n; */
r_static
r_void
DECL|function|mcd_data
id|mcd_data
c_func
(paren
)paren
(brace
r_int
id|i
suffix:semicolon
id|McdTimeout
op_decrement
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|i
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
(paren
id|MFL_STATUS
op_or
id|MFL_DATA
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|MFL_DATA
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: read failed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef MCD_DEBUG
id|printk
c_func
(paren
l_string|&quot;got 0xB %02X&bslash;n&quot;
comma
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
op_amp
l_int|0xFF
)paren
suffix:semicolon
macro_line|#endif
id|SET_TIMER
c_func
(paren
id|mcd_start
comma
l_int|1
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_eq
(paren
id|MFL_STATUS
op_or
id|MFL_DATA
)paren
)paren
(brace
r_if
c_cond
(paren
id|McdTimeout
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: data timeout, retrying&bslash;n&quot;
)paren
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|mcd_start
comma
l_int|1
)paren
suffix:semicolon
)brace
r_else
id|SET_TIMER
c_func
(paren
id|mcd_data
comma
l_int|1
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|CLEAR_TIMER
suffix:semicolon
id|READ_DATA
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
comma
op_amp
id|mcd_buf
(braket
l_int|0
)braket
comma
l_int|2048
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|mcd_bn
op_assign
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
suffix:semicolon
id|mcd_transfer
c_func
(paren
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|do_mcd_request
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Open the device special file.  Check that a disk is in.&n; */
r_int
DECL|function|mcd_open
id|mcd_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_int
id|st
suffix:semicolon
r_if
c_cond
(paren
id|mcdPresent
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* no hardware */
id|st
op_assign
id|statusCmd
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* check drive status */
r_if
c_cond
(paren
id|st
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* drive doesn&squot;t respond */
r_if
c_cond
(paren
(paren
id|st
op_amp
id|MST_READY
)paren
op_eq
l_int|0
)paren
multiline_comment|/* no disk in drive */
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: no disk in drive&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|updateToc
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * On close, we flush all mcd blocks from the buffer cache.&n; */
r_static
r_void
DECL|function|mcd_release
id|mcd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|mcd_bn
op_assign
op_minus
l_int|1
suffix:semicolon
id|sync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode
op_member_access_from_pointer
id|i_rdev
)paren
suffix:semicolon
)brace
DECL|variable|mcd_fops
r_static
r_struct
id|file_operations
id|mcd_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|mcd_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|mcd_open
comma
multiline_comment|/* open */
id|mcd_release
multiline_comment|/* release */
)brace
suffix:semicolon
multiline_comment|/*&n; * MCD interrupt descriptor&n; */
DECL|variable|mcd_sigaction
r_static
r_struct
id|sigaction
id|mcd_sigaction
op_assign
(brace
id|mcd_interrupt
comma
l_int|0
comma
id|SA_INTERRUPT
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; * Test for presence of drive and initialize it.  Called at boot time.&n; */
r_int
r_int
DECL|function|mcd_init
id|mcd_init
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
(brace
r_int
id|count
suffix:semicolon
r_int
r_char
id|result
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;mcd&quot;
comma
op_amp
id|mcd_fops
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: Unable to get major %d for Mitsumi CD-ROM&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|mcd_port
comma
l_int|4
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: Init failed, I/O port (%X) already in use&bslash;n&quot;
comma
id|mcd_port
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* check for card */
id|outb
c_func
(paren
l_int|0
comma
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* send reset */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|1000000
suffix:semicolon
id|count
op_increment
)paren
(paren
r_void
)paren
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* delay a bit */
id|outb
c_func
(paren
l_int|0x40
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* send get-stat cmd */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|1000000
suffix:semicolon
id|count
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
id|MFL_STATUS
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
l_int|1000000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: Init failed. No mcd device at 0x%x irq %d&bslash;n&quot;
comma
id|mcd_port
comma
id|mcd_irq
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
id|count
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* pick up the status */
id|outb
c_func
(paren
id|MCMD_GET_VERSION
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|3
suffix:semicolon
id|count
op_increment
)paren
r_if
c_cond
(paren
id|getValue
c_func
(paren
id|result
op_plus
id|count
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: mitsumi get version failed at 0x%d&bslash;n&quot;
comma
id|mcd_port
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;mcd: Mitsumi version : %02X %c %x&bslash;n&quot;
comma
id|result
(braket
l_int|0
)braket
comma
id|result
(braket
l_int|1
)braket
comma
id|result
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|mcdVersion
op_assign
id|result
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|mcdVersion
op_ge
l_int|4
)paren
id|outb
c_func
(paren
l_int|4
comma
id|MCDPORT
c_func
(paren
l_int|2
)paren
)paren
suffix:semicolon
multiline_comment|/* magic happens */
multiline_comment|/* don&squot;t get the IRQ until we know for sure the drive is there */
r_if
c_cond
(paren
id|irqaction
c_func
(paren
id|MCD_INTR_NR
comma
op_amp
id|mcd_sigaction
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: Unable to get IRQ%d for Mitsumi CD-ROM&bslash;n&quot;
comma
id|MCD_INTR_NR
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
id|snarf_region
c_func
(paren
id|mcd_port
comma
l_int|4
)paren
suffix:semicolon
id|mcdPresent
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;mcd: Mitsumi CD-ROM Drive present at addr %x, irq %d&bslash;n&quot;
comma
id|mcd_port
comma
id|mcd_irq
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
r_static
r_void
DECL|function|hsg2msf
id|hsg2msf
c_func
(paren
r_int
id|hsg
comma
r_struct
id|msf
op_star
id|msf
)paren
(brace
id|hsg
op_add_assign
l_int|150
suffix:semicolon
id|msf
op_member_access_from_pointer
id|min
op_assign
id|hsg
op_div
l_int|4500
suffix:semicolon
id|hsg
op_mod_assign
l_int|4500
suffix:semicolon
id|msf
op_member_access_from_pointer
id|sec
op_assign
id|hsg
op_div
l_int|75
suffix:semicolon
id|msf
op_member_access_from_pointer
id|frame
op_assign
id|hsg
op_mod
l_int|75
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf
op_member_access_from_pointer
id|min
)paren
suffix:semicolon
multiline_comment|/* convert to BCD */
id|bin2bcd
c_func
(paren
op_amp
id|msf
op_member_access_from_pointer
id|sec
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf
op_member_access_from_pointer
id|frame
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|bin2bcd
id|bin2bcd
c_func
(paren
r_int
r_char
op_star
id|p
)paren
(brace
r_int
id|u
comma
id|t
suffix:semicolon
id|u
op_assign
op_star
id|p
op_mod
l_int|10
suffix:semicolon
id|t
op_assign
op_star
id|p
op_div
l_int|10
suffix:semicolon
op_star
id|p
op_assign
id|u
op_or
(paren
id|t
op_lshift
l_int|4
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|bcd2bin
id|bcd2bin
c_func
(paren
r_int
r_char
id|bcd
)paren
(brace
r_return
(paren
id|bcd
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|bcd
op_amp
l_int|0xF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * See if a status is ready from the drive and return it&n; * if it is ready.&n; */
r_static
r_int
DECL|function|mcdStatus
id|mcdStatus
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|st
suffix:semicolon
id|st
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
id|MFL_STATUS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|st
)paren
(brace
id|i
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
r_else
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a play or read command to the drive&n; */
r_static
r_void
DECL|function|sendMcdCmd
id|sendMcdCmd
c_func
(paren
r_int
id|cmd
comma
r_struct
id|mcd_Play_msf
op_star
id|params
)paren
(brace
id|outb
c_func
(paren
id|cmd
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.min
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.sec
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.frame
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.min
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.sec
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.frame
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Timer interrupt routine to test for status ready from the drive.&n; * (see the next routine)&n; */
r_static
r_void
DECL|function|mcdStatTimer
id|mcdStatTimer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
id|MFL_STATUS
)paren
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|mcd_waitq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|McdTimeout
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|McdTimeout
op_le
l_int|0
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|mcd_waitq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SET_TIMER
c_func
(paren
id|mcdStatTimer
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for a status to be returned from the drive.  The actual test&n; * (see routine above) is done by the timer interrupt to avoid&n; * excessive rescheduling.&n; */
r_static
r_int
DECL|function|getMcdStatus
id|getMcdStatus
c_func
(paren
r_int
id|timeout
)paren
(brace
r_int
id|st
suffix:semicolon
id|McdTimeout
op_assign
id|timeout
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|mcdStatTimer
comma
l_int|1
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|mcd_waitq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|McdTimeout
op_le
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|st
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|st
op_eq
l_int|0xFF
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_amp
id|MST_BUSY
)paren
op_eq
l_int|0
op_logical_and
id|audioStatus
op_eq
id|CDROM_AUDIO_PLAY
)paren
multiline_comment|/* XXX might be an error? look at q-channel? */
id|audioStatus
op_assign
id|CDROM_AUDIO_COMPLETED
suffix:semicolon
r_if
c_cond
(paren
id|st
op_amp
id|MST_DSK_CHG
)paren
(brace
id|mcdDiskChanged
op_assign
l_int|1
suffix:semicolon
id|tocUpToDate
op_assign
l_int|0
suffix:semicolon
id|audioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
)brace
r_return
id|st
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a value from the drive.  Should return quickly, so a busy wait&n; * is used to avoid excessive rescheduling.&n; */
r_static
r_int
DECL|function|getValue
id|getValue
c_func
(paren
r_int
r_char
op_star
id|result
)paren
(brace
r_int
id|count
suffix:semicolon
r_int
id|s
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|2000
suffix:semicolon
id|count
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
id|MFL_STATUS
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
l_int|2000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: getValue timeout&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|s
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
op_amp
l_int|0xFF
suffix:semicolon
op_star
id|result
op_assign
(paren
r_int
r_char
)paren
id|s
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the current Q-channel info.  Also used for reading the&n; * table of contents.&n; */
r_int
DECL|function|GetQChannelInfo
id|GetQChannelInfo
c_func
(paren
r_struct
id|mcd_Toc
op_star
id|qp
)paren
(brace
r_int
r_char
id|notUsed
suffix:semicolon
r_int
id|retry
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|outb
c_func
(paren
id|MCMD_GET_Q_CHANNEL
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retry
op_ge
id|MCD_RETRY_ATTEMPTS
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|ctrl_addr
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|track
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|pointIndex
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|trackTime.min
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|trackTime.sec
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|trackTime.frame
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|notUsed
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|diskTime.min
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|diskTime.sec
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|diskTime.frame
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the table of contents (TOC) and TOC header if neccessary&n; */
r_static
r_int
DECL|function|updateToc
id|updateToc
c_func
(paren
)paren
(brace
r_if
c_cond
(paren
id|tocUpToDate
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|GetDiskInfo
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|GetToc
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|tocUpToDate
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the table of contents header&n; */
r_static
r_int
DECL|function|GetDiskInfo
id|GetDiskInfo
c_func
(paren
)paren
(brace
r_int
id|retry
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|outb
c_func
(paren
id|MCMD_GET_DISK_INFO
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retry
op_ge
id|MCD_RETRY_ATTEMPTS
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.first
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.last
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|DiskInfo.first
op_assign
id|bcd2bin
c_func
(paren
id|DiskInfo.first
)paren
suffix:semicolon
id|DiskInfo.last
op_assign
id|bcd2bin
c_func
(paren
id|DiskInfo.last
)paren
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.diskLength.min
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.diskLength.sec
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.diskLength.frame
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.firstTrack.min
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.firstTrack.sec
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.firstTrack.frame
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef MCD_DEBUG
id|printk
c_func
(paren
l_string|&quot;Disk Info: first %d last %d length %02x:%02x.%02x first %02x:%02x.%02x&bslash;n&quot;
comma
id|DiskInfo.first
comma
id|DiskInfo.last
comma
id|DiskInfo.diskLength.min
comma
id|DiskInfo.diskLength.sec
comma
id|DiskInfo.diskLength.frame
comma
id|DiskInfo.firstTrack.min
comma
id|DiskInfo.firstTrack.sec
comma
id|DiskInfo.firstTrack.frame
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the table of contents (TOC)&n; */
r_static
r_int
DECL|function|GetToc
id|GetToc
c_func
(paren
)paren
(brace
r_int
id|i
comma
id|px
suffix:semicolon
r_int
id|limit
suffix:semicolon
r_int
id|retry
suffix:semicolon
r_struct
id|mcd_Toc
id|qInfo
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TRACKS
suffix:semicolon
id|i
op_increment
)paren
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|DiskInfo.last
op_plus
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|outb
c_func
(paren
id|MCMD_STOP
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retry
op_ge
id|MCD_RETRY_ATTEMPTS
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|outb
c_func
(paren
id|MCMD_SET_MODE
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x05
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* mode: toc */
r_if
c_cond
(paren
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retry
op_ge
id|MCD_RETRY_ATTEMPTS
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|limit
op_assign
l_int|300
suffix:semicolon
id|limit
OG
l_int|0
suffix:semicolon
id|limit
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|GetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|px
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.pointIndex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|px
OG
l_int|0
op_logical_and
id|px
OL
id|MAX_TRACKS
op_logical_and
id|qInfo.track
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|Toc
(braket
id|px
)braket
dot
id|pointIndex
op_eq
l_int|0
)paren
(brace
id|Toc
(braket
id|px
)braket
op_assign
id|qInfo
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_le
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|Toc
(braket
id|DiskInfo.last
op_plus
l_int|1
)braket
dot
id|diskTime
op_assign
id|DiskInfo.diskLength
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|outb
c_func
(paren
id|MCMD_SET_MODE
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x01
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
macro_line|#ifdef MCD_DEBUG
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|DiskInfo.last
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;i = %2d ctl-adr = %02X track %2d px %02X %02X:%02X.%02X    %02X:%02X.%02X&bslash;n&quot;
comma
id|i
comma
id|Toc
(braket
id|i
)braket
dot
id|ctrl_addr
comma
id|Toc
(braket
id|i
)braket
dot
id|track
comma
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.frame
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.frame
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|100
suffix:semicolon
id|i
OL
l_int|103
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;i = %2d ctl-adr = %02X track %2d px %02X %02X:%02X.%02X    %02X:%02X.%02X&bslash;n&quot;
comma
id|i
comma
id|Toc
(braket
id|i
)braket
dot
id|ctrl_addr
comma
id|Toc
(braket
id|i
)braket
dot
id|track
comma
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.frame
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.frame
)paren
suffix:semicolon
macro_line|#endif
r_return
id|limit
OG
l_int|0
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
eof
