multiline_comment|/*  -*- linux-c -*-&n; *  linux/drivers/block/pdc4030.c&t;Version 0.08  Nov 30, 1997&n; *&n; *  Copyright (C) 1995-1998  Linus Torvalds &amp; authors (see below)&n; */
multiline_comment|/*&n; *  Principal Author/Maintainer:  peterd@pnd-pc.demon.co.uk&n; *&n; *  This file provides support for the second port and cache of Promise&n; *  IDE interfaces, e.g. DC4030, DC5030.&n; *&n; *  Thanks are due to Mark Lord for advice and patiently answering stupid&n; *  questions, and all those mugs^H^H^H^Hbrave souls who&squot;ve tested this.&n; *&n; *  Version 0.01&t;Initial version, #include&squot;d in ide.c rather than&n; *                      compiled separately.&n; *                      Reads use Promise commands, writes as before. Drives&n; *                      on second channel are read-only.&n; *  Version 0.02        Writes working on second channel, reads on both&n; *                      channels. Writes fail under high load. Suspect&n; *&t;&t;&t;transfers of &gt;127 sectors don&squot;t work.&n; *  Version 0.03        Brought into line with ide.c version 5.27.&n; *                      Other minor changes.&n; *  Version 0.04        Updated for ide.c version 5.30&n; *                      Changed initialization strategy&n; *  Version 0.05&t;Kernel integration.  -ml&n; *  Version 0.06&t;Ooops. Add hwgroup to direct call of ide_intr() -ml&n; *  Version 0.07&t;Added support for DC4030 variants&n; *&t;&t;&t;Secondary interface autodetection&n; *  Version 0.08&t;Renamed to pdc4030.c&n; */
multiline_comment|/*&n; * Once you&squot;ve compiled it in, you&squot;ll have to also enable the interface&n; * setup routine from the kernel command line, as in &n; *&n; *&t;&squot;linux ide0=dc4030&squot;&n; *&n; * As before, it seems that somewhere around 3Megs when writing, bad things&n; * start to happen [timeouts/retries -ml]. If anyone can give me more feedback,&n; * I&squot;d really appreciate it.  [email: peterd@pnd-pc.demon.co.uk]&n; *&n; */
DECL|macro|REALLY_SLOW_IO
macro_line|#undef REALLY_SLOW_IO&t;&t;/* most systems can safely undef this */
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &quot;ide.h&quot;
macro_line|#include &quot;pdc4030.h&quot;
multiline_comment|/* This is needed as the controller may not interrupt if the required data is&n;available in the cache. We have to simulate an interrupt. Ugh! */
r_extern
r_void
id|ide_intr
c_func
(paren
r_int
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
multiline_comment|/*&n; * promise_selectproc() is invoked by ide.c&n; * in preparation for access to the specified drive.&n; */
DECL|function|promise_selectproc
r_static
r_void
id|promise_selectproc
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
r_int
id|number
suffix:semicolon
id|number
op_assign
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|channel
op_lshift
l_int|1
)paren
op_plus
id|drive-&gt;select.b.unit
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|number
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * pdc4030_cmd handles the set of vendor specific commands that are initiated&n; * by command F0. They all have the same success/failure notification.&n; */
DECL|function|pdc4030_cmd
r_int
id|pdc4030_cmd
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|cmd
)paren
(brace
r_int
r_int
id|timeout
comma
id|timer
suffix:semicolon
id|byte
id|status_val
suffix:semicolon
id|promise_selectproc
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* redundant? */
id|OUT_BYTE
c_func
(paren
l_int|0xF3
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|cmd
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|PROMISE_EXTENDED_COMMAND
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|timeout
op_assign
id|HZ
op_star
l_int|10
suffix:semicolon
id|timeout
op_add_assign
id|jiffies
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|jiffies
OG
id|timeout
)paren
(brace
r_return
l_int|2
suffix:semicolon
multiline_comment|/* device timed out */
)brace
multiline_comment|/* This is out of delay_10ms() */
multiline_comment|/* Delays at least 10ms to give interface a chance */
id|timer
op_assign
id|jiffies
op_plus
(paren
id|HZ
op_plus
l_int|99
)paren
op_div
l_int|100
op_plus
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|timer
OG
id|jiffies
)paren
suffix:semicolon
id|status_val
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|status_val
op_ne
l_int|0x50
op_logical_and
id|status_val
op_ne
l_int|0x70
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status_val
op_eq
l_int|0x50
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* device returned success */
r_else
r_return
l_int|1
suffix:semicolon
multiline_comment|/* device returned failure */
)brace
DECL|variable|hwif_required
id|ide_hwif_t
op_star
id|hwif_required
op_assign
l_int|NULL
suffix:semicolon
DECL|function|setup_pdc4030
r_void
id|setup_pdc4030
(paren
id|ide_hwif_t
op_star
id|hwif
)paren
(brace
id|hwif_required
op_assign
id|hwif
suffix:semicolon
)brace
multiline_comment|/*&n;init_pdc4030: Test for presence of a Promise caching controller card.&n;Returns: 0 if no Promise card present at this io_base&n;&t; 1 if Promise card found&n;*/
DECL|function|init_pdc4030
r_int
id|init_pdc4030
(paren
r_void
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|hwif_required
suffix:semicolon
id|ide_drive_t
op_star
id|drive
suffix:semicolon
id|ide_hwif_t
op_star
id|second_hwif
suffix:semicolon
r_struct
id|dc_ident
id|ident
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hwif
)paren
r_return
l_int|0
suffix:semicolon
id|drive
op_assign
op_amp
id|hwif-&gt;drives
(braket
l_int|0
)braket
suffix:semicolon
id|second_hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|hwif-&gt;index
op_plus
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_pdc4030
)paren
(brace
multiline_comment|/* we&squot;ve already been found ! */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
op_eq
l_int|0xFF
op_logical_or
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
op_eq
l_int|0xFF
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|OUT_BYTE
c_func
(paren
l_int|0x08
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pdc4030_cmd
c_func
(paren
id|drive
comma
id|PROMISE_GET_CONFIG
)paren
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
id|drive
comma
id|DATA_READY
comma
id|BAD_W_STAT
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Failed Promise read config!&bslash;n&quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ide_input_data
c_func
(paren
id|drive
comma
op_amp
id|ident
comma
id|SECTOR_WORDS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ident.id
(braket
l_int|1
)braket
op_ne
l_char|&squot;P&squot;
op_logical_or
id|ident.id
(braket
l_int|0
)braket
op_ne
l_char|&squot;T&squot;
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: Promise caching controller, &quot;
comma
id|hwif-&gt;name
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ident.type
)paren
(brace
r_case
l_int|0x43
suffix:colon
id|printk
c_func
(paren
l_string|&quot;DC4030VL-2, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x41
suffix:colon
id|printk
c_func
(paren
l_string|&quot;DC4030VL-1, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
id|printk
c_func
(paren
l_string|&quot;DC4030VL, &quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;unknown - type 0x%02x - please report!&bslash;n&quot;
comma
id|ident.type
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%dKB cache, &quot;
comma
(paren
r_int
)paren
id|ident.cache_mem
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ident.irq
)paren
(brace
r_case
l_int|0x00
suffix:colon
id|hwif-&gt;irq
op_assign
l_int|14
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x01
suffix:colon
id|hwif-&gt;irq
op_assign
l_int|12
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|hwif-&gt;irq
op_assign
l_int|15
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;on IRQ %d&bslash;n&quot;
comma
id|hwif-&gt;irq
)paren
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|second_hwif-&gt;chipset
op_assign
id|ide_pdc4030
suffix:semicolon
id|hwif-&gt;mate
op_assign
id|second_hwif
suffix:semicolon
id|second_hwif-&gt;mate
op_assign
id|hwif
suffix:semicolon
id|second_hwif-&gt;channel
op_assign
l_int|1
suffix:semicolon
id|hwif-&gt;selectproc
op_assign
id|second_hwif-&gt;selectproc
op_assign
op_amp
id|promise_selectproc
suffix:semicolon
multiline_comment|/* Shift the remaining interfaces down by one */
r_for
c_loop
(paren
id|i
op_assign
id|MAX_HWIFS
op_minus
l_int|1
suffix:semicolon
id|i
OG
id|hwif-&gt;index
op_plus
l_int|1
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|ide_hwif_t
op_star
id|h
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Shifting i/f %d values to i/f %d&bslash;n&quot;
comma
id|i
op_minus
l_int|1
comma
id|i
)paren
suffix:semicolon
id|ide_init_hwif_ports
c_func
(paren
id|h-&gt;io_ports
comma
(paren
id|h
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
l_int|NULL
)paren
suffix:semicolon
id|h-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
op_assign
(paren
id|h
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
suffix:semicolon
id|h-&gt;noprobe
op_assign
(paren
id|h
op_minus
l_int|1
)paren
op_member_access_from_pointer
id|noprobe
suffix:semicolon
)brace
id|ide_init_hwif_ports
c_func
(paren
id|second_hwif-&gt;io_ports
comma
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
comma
l_int|NULL
)paren
suffix:semicolon
id|second_hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
op_assign
id|hwif-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
suffix:semicolon
id|second_hwif-&gt;irq
op_assign
id|hwif-&gt;irq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|2
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hwif-&gt;drives
(braket
id|i
)braket
dot
id|io_32bit
op_assign
l_int|3
suffix:semicolon
id|second_hwif-&gt;drives
(braket
id|i
)braket
dot
id|io_32bit
op_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ident.current_tm
(braket
id|i
op_plus
l_int|2
)braket
dot
id|cyl
)paren
(brace
id|second_hwif-&gt;drives
(braket
id|i
)braket
dot
id|noprobe
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * promise_read_intr() is the handler for disk read/multread interrupts&n; */
DECL|function|promise_read_intr
r_static
r_void
id|promise_read_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|byte
id|stat
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|sectors_left
comma
id|sectors_avail
comma
id|nsect
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STAT
c_func
(paren
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
comma
id|DATA_READY
comma
id|BAD_R_STAT
)paren
)paren
(brace
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;promise_read_intr&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|read_again
suffix:colon
r_do
(brace
id|sectors_left
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|IN_BYTE
c_func
(paren
id|IDE_SECTOR_REG
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
op_ne
id|sectors_left
)paren
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
id|sectors_avail
op_assign
id|rq-&gt;nr_sectors
op_minus
id|sectors_left
suffix:semicolon
id|read_next
suffix:colon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nsect
op_assign
id|rq-&gt;current_nr_sectors
)paren
OG
id|sectors_avail
)paren
id|nsect
op_assign
id|sectors_avail
suffix:semicolon
id|sectors_avail
op_sub_assign
id|nsect
suffix:semicolon
id|ide_input_data
c_func
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|nsect
op_star
id|SECTOR_WORDS
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;%s:  promise_read: sectors(%ld-%ld), buffer=0x%08lx, &quot;
l_string|&quot;remaining=%ld&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;sector
comma
id|rq-&gt;sector
op_plus
id|nsect
op_minus
l_int|1
comma
(paren
r_int
r_int
)paren
id|rq-&gt;buffer
op_plus
(paren
id|nsect
op_lshift
l_int|9
)paren
comma
id|rq-&gt;nr_sectors
op_minus
id|nsect
)paren
suffix:semicolon
macro_line|#endif
id|rq-&gt;sector
op_add_assign
id|nsect
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|nsect
op_lshift
l_int|9
suffix:semicolon
id|rq-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
(paren
id|rq-&gt;nr_sectors
op_sub_assign
id|nsect
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rq-&gt;current_nr_sectors
op_sub_assign
id|nsect
)paren
op_le
l_int|0
)paren
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|sectors_avail
)paren
r_goto
id|read_next
suffix:semicolon
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
(brace
r_goto
id|read_again
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|promise_read_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Ah! promise read intr: sectors left !DRQ !BUSY&bslash;n&quot;
)paren
suffix:semicolon
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;promise read intr&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * promise_write_pollfunc() is the handler for disk write completion polling.&n; */
DECL|function|promise_write_pollfunc
r_static
r_void
id|promise_write_pollfunc
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|i
suffix:semicolon
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_if
c_cond
(paren
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
op_ne
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|jiffies
OL
id|hwgroup-&gt;poll_timeout
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|promise_write_pollfunc
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
multiline_comment|/* continue polling... */
)brace
id|printk
c_func
(paren
l_string|&quot;%s: write timed-out!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|ide_error
(paren
id|drive
comma
l_string|&quot;write timeout&quot;
comma
id|GET_STAT
c_func
(paren
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ide_multwrite
c_func
(paren
id|drive
comma
l_int|4
)paren
suffix:semicolon
id|rq
op_assign
id|hwgroup-&gt;rq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|i
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|1
comma
id|hwgroup
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/*&n; * promise_write() transfers a block of one or more sectors of data to a&n; * drive as part of a disk write operation. All but 4 sectors are transfered&n; * in the first attempt, then the interface is polled (nicely!) for completion&n; * before the final 4 sectors are transfered. Don&squot;t ask me why, but this is&n; * how it&squot;s done in the drivers for other O/Ses. There is no interrupt&n; * generated on writes, which is why we have to do it like this.&n; */
DECL|function|promise_write
r_static
r_void
id|promise_write
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwgroup_t
op_star
id|hwgroup
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
op_amp
id|hwgroup-&gt;wrq
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;nr_sectors
OG
l_int|4
)paren
(brace
id|ide_multwrite
c_func
(paren
id|drive
comma
id|rq-&gt;nr_sectors
op_minus
l_int|4
)paren
suffix:semicolon
id|hwgroup-&gt;poll_timeout
op_assign
id|jiffies
op_plus
id|WAIT_WORSTCASE
suffix:semicolon
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|promise_write_pollfunc
comma
l_int|1
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
(brace
id|ide_multwrite
c_func
(paren
id|drive
comma
id|rq-&gt;nr_sectors
)paren
suffix:semicolon
id|rq
op_assign
id|hwgroup-&gt;rq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|i
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|1
comma
id|hwgroup
)paren
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n; * do_pdc4030_io() is called from do_rw_disk, having had the block number&n; * already set up. It issues a READ or WRITE command to the Promise&n; * controller, assuming LBA has been used to set up the block number.&n; */
DECL|function|do_pdc4030_io
r_void
id|do_pdc4030_io
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
)paren
(brace
r_int
r_int
id|timeout
suffix:semicolon
id|byte
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|READ
)paren
(brace
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|promise_read_intr
comma
id|WAIT_CMD
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|PROMISE_READ
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* The card&squot;s behaviour is odd at this point. If the data is&n;   available, DRQ will be true, and no interrupt will be&n;   generated by the card. If this is the case, we need to simulate&n;   an interrupt. Ugh! Otherwise, if an interrupt will occur, bit0&n;   of the SELECT register will be high, so we can just return and&n;   be interrupted.*/
id|timeout
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|20
suffix:semicolon
multiline_comment|/* 50ms wait */
r_do
(brace
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
(brace
multiline_comment|/*                    unsigned long flags;&n;                    save_flags(flags);&n;                    cli();&n;                    disable_irq(HWIF(drive)-&gt;irq);&n;*/
id|ide_intr
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|irq
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*                    enable_irq(HWIF(drive)-&gt;irq);&n;                    restore_flags(flags);&n;*/
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
op_amp
l_int|0x01
)paren
(brace
r_return
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|jiffies
OL
id|timeout
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: reading: No DRQ and not waiting - Odd!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|WRITE
)paren
(brace
id|OUT_BYTE
c_func
(paren
id|PROMISE_WRITE
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
id|drive
comma
id|DATA_READY
comma
id|drive-&gt;bad_wstat
comma
id|WAIT_DRQ
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: no DRQ after issuing PROMISE_WRITE&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;unmask
)paren
id|cli
c_func
(paren
)paren
suffix:semicolon
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|wrq
op_assign
op_star
id|rq
suffix:semicolon
multiline_comment|/* scratchpad */
id|promise_write
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s: bad command: %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;cmd
)paren
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|0
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
eof
