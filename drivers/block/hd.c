multiline_comment|/*&n; *  linux/kernel/hd.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; * This is the low-level hd interrupt support. It traverses the&n; * request-list, using interrupts to jump between functions. As&n; * all the functions are called within interrupts, we may not&n; * sleep. Special care is recommended.&n; * &n; *  modified by Drew Eckhardt to check nr of hd&squot;s from the CMOS.&n; *&n; *  Thanks to Branko Lankester, lankeste@fwi.uva.nl, who found a bug&n; *  in the early extended-partition checks and added DM partitions&n; *&n; *  IRQ-unmask, drive-id, multiple-mode, support for &quot;&gt;16 heads&quot;,&n; *  and general streamlining by mlord@bnr.ca (Mark Lord).&n; */
DECL|macro|DEFAULT_MULT_COUNT
mdefine_line|#define DEFAULT_MULT_COUNT  0&t;/* set to 0 to disable multiple mode at boot */
DECL|macro|DEFAULT_UNMASK_INTR
mdefine_line|#define DEFAULT_UNMASK_INTR 0&t;/* set to 0 to *NOT* unmask irq&squot;s more often */
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
DECL|macro|REALLY_SLOW_IO
mdefine_line|#define REALLY_SLOW_IO
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR HD_MAJOR
macro_line|#include &quot;blk.h&quot;
DECL|macro|HD_IRQ
mdefine_line|#define HD_IRQ 14
r_static
r_int
id|revalidate_hddisk
c_func
(paren
r_int
comma
r_int
)paren
suffix:semicolon
DECL|function|CMOS_READ
r_static
r_inline
r_int
r_char
id|CMOS_READ
c_func
(paren
r_int
r_char
id|addr
)paren
(brace
id|outb_p
c_func
(paren
id|addr
comma
l_int|0x70
)paren
suffix:semicolon
r_return
id|inb_p
c_func
(paren
l_int|0x71
)paren
suffix:semicolon
)brace
DECL|macro|HD_DELAY
mdefine_line|#define&t;HD_DELAY&t;0
DECL|macro|MAX_ERRORS
mdefine_line|#define MAX_ERRORS     16&t;/* Max read/write errors/sector */
DECL|macro|RESET_FREQ
mdefine_line|#define RESET_FREQ      8&t;/* Reset controller every 8th retry */
DECL|macro|RECAL_FREQ
mdefine_line|#define RECAL_FREQ      4&t;/* Recalibrate every 4th retry */
DECL|macro|MAX_HD
mdefine_line|#define MAX_HD&t;&t;2
DECL|macro|STAT_OK
mdefine_line|#define STAT_OK&t;&t;(READY_STAT|SEEK_STAT)
DECL|macro|OK_STATUS
mdefine_line|#define OK_STATUS(s)&t;(((s)&amp;(STAT_OK|(BUSY_STAT|WRERR_STAT|ERR_STAT)))==STAT_OK)
r_static
r_void
id|recal_intr
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|bad_rw_intr
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|recalibrate
r_static
r_char
id|recalibrate
(braket
id|MAX_HD
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|special_op
r_static
r_char
id|special_op
(braket
id|MAX_HD
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|access_count
r_static
r_int
id|access_count
(braket
id|MAX_HD
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|busy
r_static
r_char
id|busy
(braket
id|MAX_HD
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|busy_wait
r_static
r_struct
id|wait_queue
op_star
id|busy_wait
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|reset
r_static
r_int
id|reset
op_assign
l_int|0
suffix:semicolon
DECL|variable|hd_error
r_static
r_int
id|hd_error
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; *  This struct defines the HD&squot;s and their types.&n; */
DECL|struct|hd_i_struct
r_struct
id|hd_i_struct
(brace
DECL|member|head
DECL|member|sect
DECL|member|cyl
DECL|member|wpcom
DECL|member|lzone
DECL|member|ctl
r_int
r_int
id|head
comma
id|sect
comma
id|cyl
comma
id|wpcom
comma
id|lzone
comma
id|ctl
suffix:semicolon
)brace
suffix:semicolon
DECL|variable|hd_ident_info
r_static
r_struct
id|hd_driveid
op_star
id|hd_ident_info
(braket
id|MAX_HD
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
macro_line|#ifdef HD_TYPE
DECL|variable|hd_info
r_static
r_struct
id|hd_i_struct
id|hd_info
(braket
)braket
op_assign
(brace
id|HD_TYPE
)brace
suffix:semicolon
DECL|variable|bios_info
r_struct
id|hd_i_struct
id|bios_info
(braket
)braket
op_assign
(brace
id|HD_TYPE
)brace
suffix:semicolon
DECL|variable|NR_HD
r_static
r_int
id|NR_HD
op_assign
(paren
(paren
r_sizeof
(paren
id|hd_info
)paren
)paren
op_div
(paren
r_sizeof
(paren
r_struct
id|hd_i_struct
)paren
)paren
)paren
suffix:semicolon
macro_line|#else
DECL|variable|hd_info
r_static
r_struct
id|hd_i_struct
id|hd_info
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|bios_info
r_struct
id|hd_i_struct
id|bios_info
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
)brace
suffix:semicolon
DECL|variable|NR_HD
r_static
r_int
id|NR_HD
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|variable|hd
r_static
r_struct
id|hd_struct
id|hd
(braket
id|MAX_HD
op_lshift
l_int|6
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|hd_sizes
r_static
r_int
id|hd_sizes
(braket
id|MAX_HD
op_lshift
l_int|6
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|hd_blocksizes
r_static
r_int
id|hd_blocksizes
(braket
id|MAX_HD
op_lshift
l_int|6
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
macro_line|#if (HD_DELAY &gt; 0)
DECL|variable|last_req
r_int
r_int
id|last_req
suffix:semicolon
DECL|function|read_timer
r_int
r_int
id|read_timer
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|t
comma
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|t
op_assign
id|jiffies
op_star
l_int|11932
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
l_int|0x43
)paren
suffix:semicolon
id|i
op_assign
id|inb_p
c_func
(paren
l_int|0x40
)paren
suffix:semicolon
id|i
op_or_assign
id|inb
c_func
(paren
l_int|0x40
)paren
op_lshift
l_int|8
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|t
op_minus
id|i
suffix:semicolon
)brace
macro_line|#endif
DECL|function|hd_setup
r_void
id|hd_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
id|hdind
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|3
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|bios_info
(braket
l_int|0
)braket
dot
id|head
op_ne
l_int|0
)paren
id|hdind
op_assign
l_int|1
suffix:semicolon
id|bios_info
(braket
id|hdind
)braket
dot
id|head
op_assign
id|hd_info
(braket
id|hdind
)braket
dot
id|head
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
id|bios_info
(braket
id|hdind
)braket
dot
id|sect
op_assign
id|hd_info
(braket
id|hdind
)braket
dot
id|sect
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
id|bios_info
(braket
id|hdind
)braket
dot
id|cyl
op_assign
id|hd_info
(braket
id|hdind
)braket
dot
id|cyl
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|bios_info
(braket
id|hdind
)braket
dot
id|wpcom
op_assign
id|hd_info
(braket
id|hdind
)braket
dot
id|wpcom
op_assign
l_int|0
suffix:semicolon
id|bios_info
(braket
id|hdind
)braket
dot
id|lzone
op_assign
id|hd_info
(braket
id|hdind
)braket
dot
id|lzone
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
id|bios_info
(braket
id|hdind
)braket
dot
id|ctl
op_assign
id|hd_info
(braket
id|hdind
)braket
dot
id|ctl
op_assign
(paren
id|ints
(braket
l_int|2
)braket
OG
l_int|8
ques
c_cond
l_int|8
suffix:colon
l_int|0
)paren
suffix:semicolon
id|NR_HD
op_assign
id|hdind
op_plus
l_int|1
suffix:semicolon
)brace
DECL|function|dump_status
r_static
r_void
id|dump_status
(paren
r_char
op_star
id|msg
comma
r_int
r_int
id|stat
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_char
id|devc
suffix:semicolon
id|devc
op_assign
id|CURRENT
ques
c_cond
l_char|&squot;a&squot;
op_plus
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;dev
)paren
suffix:colon
l_char|&squot;?&squot;
suffix:semicolon
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;hd%c: %s: status=0x%02x { &quot;
comma
id|devc
comma
id|msg
comma
id|stat
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Busy &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|READY_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DriveReady &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|WRERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;WriteFault &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|SEEK_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;SeekComplete &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;DataRequest &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ECC_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;CorrectedError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|INDEX_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Index &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
id|printk
c_func
(paren
l_string|&quot;Error &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;}&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_eq
l_int|0
)paren
(brace
id|hd_error
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|hd_error
op_assign
id|inb
c_func
(paren
id|HD_ERROR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;hd%c: %s: error=0x%02x { &quot;
comma
id|devc
comma
id|msg
comma
id|hd_error
op_amp
l_int|0xff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd_error
op_amp
id|BBD_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;BadSector &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd_error
op_amp
id|ECC_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;UncorrectableError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd_error
op_amp
id|ID_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;SectorIdNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd_error
op_amp
id|ABRT_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;DriveStatusError &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd_error
op_amp
id|TRK0_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;TrackZeroNotFound &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd_error
op_amp
id|MARK_ERR
)paren
id|printk
c_func
(paren
l_string|&quot;AddrMarkNotFound &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;}&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hd_error
op_amp
(paren
id|BBD_ERR
op_or
id|ECC_ERR
op_or
id|ID_ERR
op_or
id|MARK_ERR
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, CHS=%d/%d/%d&quot;
comma
(paren
id|inb
c_func
(paren
id|HD_HCYL
)paren
op_lshift
l_int|8
)paren
op_plus
id|inb
c_func
(paren
id|HD_LCYL
)paren
comma
id|inb
c_func
(paren
id|HD_CURRENT
)paren
op_amp
l_int|0xf
comma
id|inb
c_func
(paren
id|HD_SECTOR
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
)paren
id|printk
c_func
(paren
l_string|&quot;, sector=%ld&quot;
comma
id|CURRENT-&gt;sector
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|restore_flags
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|check_status
r_void
id|check_status
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
id|inb_p
c_func
(paren
id|HD_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STATUS
c_func
(paren
id|i
)paren
)paren
(brace
id|dump_status
c_func
(paren
l_string|&quot;check_status&quot;
comma
id|i
)paren
suffix:semicolon
id|bad_rw_intr
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|controller_busy
r_static
r_int
id|controller_busy
c_func
(paren
r_void
)paren
(brace
r_int
id|retries
op_assign
l_int|100000
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_do
(brace
id|status
op_assign
id|inb_p
c_func
(paren
id|HD_STATUS
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|status
op_amp
id|BUSY_STAT
)paren
op_logical_and
op_decrement
id|retries
)paren
suffix:semicolon
r_return
id|status
suffix:semicolon
)brace
DECL|function|status_ok
r_static
r_int
id|status_ok
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|status
op_assign
id|inb_p
c_func
(paren
id|HD_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|BUSY_STAT
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Ancient, but does it make sense??? */
r_if
c_cond
(paren
id|status
op_amp
id|WRERR_STAT
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|READY_STAT
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|SEEK_STAT
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|controller_ready
r_static
r_int
id|controller_ready
c_func
(paren
r_int
r_int
id|drive
comma
r_int
r_int
id|head
)paren
(brace
r_int
id|retry
op_assign
l_int|100
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|controller_busy
c_func
(paren
)paren
op_amp
id|BUSY_STAT
)paren
r_return
l_int|0
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0xA0
op_or
(paren
id|drive
op_lshift
l_int|4
)paren
op_or
id|head
comma
id|HD_CURRENT
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status_ok
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|retry
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|hd_out
r_static
r_void
id|hd_out
c_func
(paren
r_int
r_int
id|drive
comma
r_int
r_int
id|nsect
comma
r_int
r_int
id|sect
comma
r_int
r_int
id|head
comma
r_int
r_int
id|cyl
comma
r_int
r_int
id|cmd
comma
r_void
(paren
op_star
id|intr_addr
)paren
(paren
r_void
)paren
)paren
(brace
r_int
r_int
id|port
suffix:semicolon
macro_line|#if (HD_DELAY &gt; 0)
r_while
c_loop
(paren
id|read_timer
c_func
(paren
)paren
op_minus
id|last_req
OL
id|HD_DELAY
)paren
multiline_comment|/* nothing */
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|reset
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|controller_ready
c_func
(paren
id|drive
comma
id|head
)paren
)paren
(brace
id|reset
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SET_INTR
c_func
(paren
id|intr_addr
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|hd_info
(braket
id|drive
)braket
dot
id|ctl
comma
id|HD_CMD
)paren
suffix:semicolon
id|port
op_assign
id|HD_DATA
suffix:semicolon
id|outb_p
c_func
(paren
id|hd_info
(braket
id|drive
)braket
dot
id|wpcom
op_rshift
l_int|2
comma
op_increment
id|port
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|nsect
comma
op_increment
id|port
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|sect
comma
op_increment
id|port
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|cyl
comma
op_increment
id|port
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|cyl
op_rshift
l_int|8
comma
op_increment
id|port
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0xA0
op_or
(paren
id|drive
op_lshift
l_int|4
)paren
op_or
id|head
comma
op_increment
id|port
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|cmd
comma
op_increment
id|port
)paren
suffix:semicolon
)brace
r_static
r_void
id|hd_request
(paren
r_void
)paren
suffix:semicolon
DECL|variable|identified
r_static
r_int
r_int
id|identified
(braket
id|MAX_HD
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* 1 = drive ID already displayed   */
DECL|variable|unmask_intr
r_static
r_int
r_int
id|unmask_intr
(braket
id|MAX_HD
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* 1 = unmask IRQs during I/O       */
DECL|variable|max_mult
r_static
r_int
r_int
id|max_mult
(braket
id|MAX_HD
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* max sectors for MultMode         */
DECL|variable|mult_req
r_static
r_int
r_int
id|mult_req
(braket
id|MAX_HD
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* requested MultMode count         */
DECL|variable|mult_count
r_static
r_int
r_int
id|mult_count
(braket
id|MAX_HD
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* currently enabled MultMode count */
DECL|variable|WCURRENT
r_static
r_struct
id|request
id|WCURRENT
suffix:semicolon
DECL|function|fixstring
r_static
r_void
id|fixstring
c_func
(paren
r_int
r_char
op_star
id|s
comma
r_int
id|n
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
op_star
id|ss
op_assign
(paren
r_int
r_int
op_star
)paren
id|s
suffix:semicolon
multiline_comment|/* convert from big-endian to little-endian */
r_for
c_loop
(paren
id|i
op_assign
id|n
suffix:semicolon
(paren
id|i
op_sub_assign
l_int|2
)paren
op_ge
l_int|0
suffix:semicolon
id|ss
op_increment
)paren
op_star
id|ss
op_assign
(paren
op_star
id|ss
op_rshift
l_int|8
)paren
op_or
(paren
op_star
id|ss
op_lshift
l_int|8
)paren
suffix:semicolon
multiline_comment|/* &quot;strnlen()&quot; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|s
(braket
id|i
)braket
)paren
(brace
id|n
op_assign
id|i
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* wipe out trailing spaces */
r_while
c_loop
(paren
id|n
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|s
(braket
id|n
op_minus
l_int|1
)braket
op_ne
l_char|&squot; &squot;
)paren
r_break
suffix:semicolon
id|n
op_decrement
suffix:semicolon
id|s
(braket
id|n
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
multiline_comment|/* wipe out leading spaces */
r_if
c_cond
(paren
op_star
id|s
op_eq
l_char|&squot; &squot;
)paren
(brace
r_int
r_char
op_star
id|t
op_assign
id|s
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
op_logical_and
op_star
op_increment
id|s
op_eq
l_char|&squot; &squot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|n
op_decrement
op_ge
l_int|0
)paren
(brace
op_star
id|t
op_increment
op_assign
op_star
id|s
suffix:semicolon
op_star
id|s
op_increment
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
)brace
)brace
)brace
DECL|function|identify_intr
r_static
r_void
id|identify_intr
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;dev
)paren
suffix:semicolon
r_int
r_int
id|stat
op_assign
id|inb_p
c_func
(paren
id|HD_STATUS
)paren
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|hd_ident_info
(braket
id|dev
)braket
suffix:semicolon
r_if
c_cond
(paren
id|unmask_intr
(braket
id|dev
)braket
)paren
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|BUSY_STAT
op_or
id|ERR_STAT
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;  hd%c: non-IDE device, CHS=%d/%d/%d&bslash;n&quot;
comma
id|dev
op_plus
l_char|&squot;a&squot;
comma
id|hd_info
(braket
id|dev
)braket
dot
id|cyl
comma
id|hd_info
(braket
id|dev
)braket
dot
id|head
comma
id|hd_info
(braket
id|dev
)braket
dot
id|sect
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_ne
l_int|NULL
)paren
(brace
id|hd_ident_info
(braket
id|dev
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree_s
(paren
id|id
comma
l_int|512
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|insw
c_func
(paren
id|HD_DATA
comma
id|id
comma
l_int|256
)paren
suffix:semicolon
multiline_comment|/* get ID info */
id|max_mult
(braket
id|dev
)braket
op_assign
id|id-&gt;max_multsect
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|1
)paren
op_logical_and
id|id-&gt;cur_cyls
op_logical_and
id|id-&gt;cur_heads
op_logical_and
(paren
id|id-&gt;cur_heads
op_le
l_int|16
)paren
op_logical_and
id|id-&gt;cur_sectors
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Extract the physical drive geometry for our use.&n;&t;&t;&t; * Note that we purposely do *not* update the bios_info.&n;&t;&t;&t; * This way, programs that use it (like fdisk) will &n;&t;&t;&t; * still have the same logical view as the BIOS does,&n;&t;&t;&t; * which keeps the partition table from being screwed.&n;&t;&t;&t; */
id|hd_info
(braket
id|dev
)braket
dot
id|cyl
op_assign
id|id-&gt;cur_cyls
suffix:semicolon
id|hd_info
(braket
id|dev
)braket
dot
id|head
op_assign
id|id-&gt;cur_heads
suffix:semicolon
id|hd_info
(braket
id|dev
)braket
dot
id|sect
op_assign
id|id-&gt;cur_sectors
suffix:semicolon
)brace
id|fixstring
(paren
id|id-&gt;serial_no
comma
r_sizeof
(paren
id|id-&gt;serial_no
)paren
)paren
suffix:semicolon
id|fixstring
(paren
id|id-&gt;fw_rev
comma
r_sizeof
(paren
id|id-&gt;fw_rev
)paren
)paren
suffix:semicolon
id|fixstring
(paren
id|id-&gt;model
comma
r_sizeof
(paren
id|id-&gt;model
)paren
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;  hd%c: %.40s, %dMB w/%dKB Cache, CHS=%d/%d/%d, MaxMult=%d&bslash;n&quot;
comma
id|dev
op_plus
l_char|&squot;a&squot;
comma
id|id-&gt;model
comma
id|id-&gt;cyls
op_star
id|id-&gt;heads
op_star
id|id-&gt;sectors
op_div
l_int|2048
comma
id|id-&gt;buf_size
op_div
l_int|2
comma
id|hd_info
(braket
id|dev
)braket
dot
id|cyl
comma
id|hd_info
(braket
id|dev
)braket
dot
id|head
comma
id|hd_info
(braket
id|dev
)braket
dot
id|sect
comma
id|id-&gt;max_multsect
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Early model Quantum drives go weird at this point,&n;&t;&t; *   but doing a recalibrate seems to &quot;fix&quot; them.&n;&t;&t; * (Doing a full reset confuses some other model Quantums)&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|id-&gt;model
comma
l_string|&quot;QUANTUM&quot;
comma
l_int|7
)paren
)paren
id|special_op
(braket
id|dev
)braket
op_assign
id|recalibrate
(braket
id|dev
)braket
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#if (HD_DELAY &gt; 0)
id|last_req
op_assign
id|read_timer
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|hd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|set_multmode_intr
r_static
r_void
id|set_multmode_intr
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;dev
)paren
comma
id|stat
op_assign
id|inb_p
c_func
(paren
id|HD_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unmask_intr
(braket
id|dev
)braket
)paren
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|BUSY_STAT
op_or
id|ERR_STAT
)paren
)paren
(brace
id|mult_req
(braket
id|dev
)braket
op_assign
id|mult_count
(braket
id|dev
)braket
op_assign
l_int|0
suffix:semicolon
id|dump_status
c_func
(paren
l_string|&quot;set multmode failed&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|mult_count
(braket
id|dev
)braket
op_assign
id|mult_req
(braket
id|dev
)braket
)paren
)paren
id|printk
(paren
l_string|&quot;  hd%c: enabled %d-sector multiple mode&bslash;n&quot;
comma
id|dev
op_plus
l_char|&squot;a&squot;
comma
id|mult_count
(braket
id|dev
)braket
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot;  hd%c: disabled multiple mode&bslash;n&quot;
comma
id|dev
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
)brace
macro_line|#if (HD_DELAY &gt; 0)
id|last_req
op_assign
id|read_timer
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|hd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|drive_busy
r_static
r_int
id|drive_busy
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|500000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
id|inb_p
c_func
(paren
id|HD_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_amp
(paren
id|BUSY_STAT
op_or
id|READY_STAT
op_or
id|SEEK_STAT
)paren
)paren
op_eq
id|STAT_OK
)paren
r_return
l_int|0
suffix:semicolon
)brace
id|dump_status
c_func
(paren
l_string|&quot;reset timed out&quot;
comma
id|c
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|reset_controller
r_static
r_void
id|reset_controller
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|outb_p
c_func
(paren
l_int|4
comma
id|HD_CMD
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nop
c_func
(paren
)paren
suffix:semicolon
)brace
id|outb_p
c_func
(paren
id|hd_info
(braket
l_int|0
)braket
dot
id|ctl
op_amp
l_int|0x0f
comma
id|HD_CMD
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nop
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|drive_busy
c_func
(paren
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;hd: controller still busy&bslash;n&quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|hd_error
op_assign
id|inb
c_func
(paren
id|HD_ERROR
)paren
)paren
op_ne
l_int|1
)paren
id|printk
c_func
(paren
l_string|&quot;hd: controller reset failed: %02x&bslash;n&quot;
comma
id|hd_error
)paren
suffix:semicolon
)brace
DECL|function|reset_hd
r_static
r_void
id|reset_hd
c_func
(paren
r_void
)paren
(brace
r_static
r_int
id|i
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
id|reset
)paren
(brace
id|reset
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
op_minus
l_int|1
suffix:semicolon
id|reset_controller
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|check_status
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|i
OL
id|NR_HD
)paren
(brace
id|special_op
(braket
id|i
)braket
op_assign
id|recalibrate
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|unmask_intr
(braket
id|i
)braket
)paren
(brace
id|unmask_intr
(braket
id|i
)braket
op_assign
id|DEFAULT_UNMASK_INTR
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;hd%c: reset irq-unmasking to %d&bslash;n&quot;
comma
id|i
op_plus
l_char|&squot;a&squot;
comma
id|DEFAULT_UNMASK_INTR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mult_req
(braket
id|i
)braket
op_logical_or
id|mult_count
(braket
id|i
)braket
)paren
(brace
id|mult_count
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|mult_req
(braket
id|i
)braket
op_assign
id|DEFAULT_MULT_COUNT
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;hd%c: reset multiple mode to %d&bslash;n&quot;
comma
id|i
op_plus
l_char|&squot;a&squot;
comma
id|DEFAULT_MULT_COUNT
)paren
suffix:semicolon
)brace
id|hd_out
c_func
(paren
id|i
comma
id|hd_info
(braket
id|i
)braket
dot
id|sect
comma
id|hd_info
(braket
id|i
)braket
dot
id|sect
comma
id|hd_info
(braket
id|i
)braket
dot
id|head
op_minus
l_int|1
comma
id|hd_info
(braket
id|i
)braket
dot
id|cyl
comma
id|WIN_SPECIFY
comma
op_amp
id|reset_hd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
r_goto
id|repeat
suffix:semicolon
)brace
r_else
id|hd_request
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Ok, don&squot;t know what to do with the unexpected interrupts: on some machines&n; * doing a reset and a retry seems to result in an eternal loop. Right now I&n; * ignore it, and just set the timeout.&n; *&n; * On laptops (and &quot;green&quot; PCs), an unexpected interrupt occurs whenever the&n; * drive enters &quot;idle&quot;, &quot;standby&quot;, or &quot;sleep&quot; mode, so if the status looks&n; * &quot;good&quot;, we just ignore the interrupt completely.&n; */
DECL|function|unexpected_hd_interrupt
r_void
id|unexpected_hd_interrupt
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|stat
op_assign
id|inb_p
c_func
(paren
id|HD_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_amp
(paren
id|BUSY_STAT
op_or
id|DRQ_STAT
op_or
id|ECC_STAT
op_or
id|ERR_STAT
)paren
)paren
(brace
id|dump_status
(paren
l_string|&quot;unexpected interrupt&quot;
comma
id|stat
)paren
suffix:semicolon
id|SET_TIMER
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * bad_rw_intr() now tries to be a bit smarter and does things&n; * according to the error returned by the controller.&n; * -Mika Liljeberg (liljeber@cs.Helsinki.FI)&n; */
DECL|function|bad_rw_intr
r_static
r_void
id|bad_rw_intr
c_func
(paren
r_void
)paren
(brace
r_int
id|dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CURRENT
)paren
r_return
suffix:semicolon
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|CURRENT-&gt;errors
op_ge
id|MAX_ERRORS
op_logical_or
(paren
id|hd_error
op_amp
id|BBD_ERR
)paren
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|special_op
(braket
id|dev
)braket
op_assign
id|recalibrate
(braket
id|dev
)braket
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CURRENT-&gt;errors
op_mod
id|RESET_FREQ
op_eq
l_int|0
)paren
id|reset
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|hd_error
op_amp
id|TRK0_ERR
)paren
op_logical_or
id|CURRENT-&gt;errors
op_mod
id|RECAL_FREQ
op_eq
l_int|0
)paren
id|special_op
(braket
id|dev
)braket
op_assign
id|recalibrate
(braket
id|dev
)braket
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Otherwise just retry */
)brace
DECL|function|wait_DRQ
r_static
r_inline
r_int
id|wait_DRQ
c_func
(paren
r_void
)paren
(brace
r_int
id|retries
op_assign
l_int|100000
comma
id|stat
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|retries
OG
l_int|0
)paren
r_if
c_cond
(paren
(paren
id|stat
op_assign
id|inb_p
c_func
(paren
id|HD_STATUS
)paren
)paren
op_amp
id|DRQ_STAT
)paren
r_return
l_int|0
suffix:semicolon
id|dump_status
c_func
(paren
l_string|&quot;wait_DRQ&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|read_intr
r_static
r_void
id|read_intr
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;dev
)paren
suffix:semicolon
r_int
id|i
comma
id|retries
op_assign
l_int|100000
comma
id|msect
op_assign
id|mult_count
(braket
id|dev
)braket
comma
id|nsect
suffix:semicolon
r_if
c_cond
(paren
id|unmask_intr
(braket
id|dev
)braket
)paren
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* permit other IRQs during xfer */
r_do
(brace
id|i
op_assign
(paren
r_int
)paren
id|inb_p
c_func
(paren
id|HD_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|BUSY_STAT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STATUS
c_func
(paren
id|i
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|DRQ_STAT
)paren
r_goto
id|ok_to_read
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|retries
OG
l_int|0
)paren
suffix:semicolon
id|dump_status
c_func
(paren
l_string|&quot;read_intr&quot;
comma
id|i
)paren
suffix:semicolon
id|bad_rw_intr
c_func
(paren
)paren
suffix:semicolon
id|hd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|ok_to_read
suffix:colon
r_if
c_cond
(paren
id|msect
)paren
(brace
r_if
c_cond
(paren
(paren
id|nsect
op_assign
id|CURRENT-&gt;current_nr_sectors
)paren
OG
id|msect
)paren
id|nsect
op_assign
id|msect
suffix:semicolon
id|msect
op_sub_assign
id|nsect
suffix:semicolon
)brace
r_else
id|nsect
op_assign
l_int|1
suffix:semicolon
id|insw
c_func
(paren
id|HD_DATA
comma
id|CURRENT-&gt;buffer
comma
id|nsect
op_lshift
l_int|8
)paren
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|nsect
suffix:semicolon
id|CURRENT-&gt;buffer
op_add_assign
id|nsect
op_lshift
l_int|9
suffix:semicolon
id|CURRENT-&gt;errors
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
(paren
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|nsect
)paren
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;hd%c: read: sectors(%ld-%ld), remaining=%ld, buffer=0x%08lx&bslash;n&quot;
comma
id|dev
op_plus
l_char|&squot;a&squot;
comma
id|CURRENT-&gt;sector
comma
id|CURRENT-&gt;sector
op_plus
id|nsect
comma
id|CURRENT-&gt;nr_sectors
comma
(paren
r_int
r_int
)paren
id|CURRENT-&gt;buffer
op_plus
(paren
id|nsect
op_lshift
l_int|9
)paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|CURRENT-&gt;current_nr_sectors
op_sub_assign
id|nsect
)paren
op_le
l_int|0
)paren
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|msect
)paren
r_goto
id|ok_to_read
suffix:semicolon
id|SET_INTR
c_func
(paren
op_amp
id|read_intr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
(paren
r_void
)paren
id|inb_p
c_func
(paren
id|HD_STATUS
)paren
suffix:semicolon
macro_line|#if (HD_DELAY &gt; 0)
id|last_req
op_assign
id|read_timer
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|CURRENT
)paren
id|hd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
DECL|function|multwrite
r_static
r_inline
r_void
id|multwrite
(paren
r_int
r_int
id|dev
)paren
(brace
r_int
r_int
id|mcount
op_assign
id|mult_count
(braket
id|dev
)braket
suffix:semicolon
r_while
c_loop
(paren
id|mcount
op_decrement
)paren
(brace
id|outsw
c_func
(paren
id|HD_DATA
comma
id|WCURRENT.buffer
comma
l_int|256
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|WCURRENT.nr_sectors
)paren
r_return
suffix:semicolon
id|WCURRENT.buffer
op_add_assign
l_int|512
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|WCURRENT.current_nr_sectors
)paren
(brace
id|WCURRENT.bh
op_assign
id|WCURRENT.bh-&gt;b_reqnext
suffix:semicolon
r_if
c_cond
(paren
id|WCURRENT.bh
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;buffer list corrupted&bslash;n&quot;
)paren
suffix:semicolon
id|WCURRENT.current_nr_sectors
op_assign
id|WCURRENT.bh-&gt;b_size
op_rshift
l_int|9
suffix:semicolon
id|WCURRENT.buffer
op_assign
id|WCURRENT.bh-&gt;b_data
suffix:semicolon
)brace
)brace
)brace
DECL|function|multwrite_intr
r_static
r_void
id|multwrite_intr
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|WCURRENT.dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unmask_intr
(braket
id|dev
)braket
)paren
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OK_STATUS
c_func
(paren
id|i
op_assign
id|inb_p
c_func
(paren
id|HD_STATUS
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_amp
id|DRQ_STAT
)paren
(brace
r_if
c_cond
(paren
id|WCURRENT.nr_sectors
)paren
(brace
id|multwrite
c_func
(paren
id|dev
)paren
suffix:semicolon
id|SET_INTR
c_func
(paren
op_amp
id|multwrite_intr
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
op_logical_neg
id|WCURRENT.nr_sectors
)paren
(brace
multiline_comment|/* all done? */
r_for
c_loop
(paren
id|i
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|i
op_sub_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
macro_line|#if (HD_DELAY &gt; 0)
id|last_req
op_assign
id|read_timer
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|CURRENT
)paren
id|hd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
)brace
id|dump_status
c_func
(paren
l_string|&quot;multwrite_intr&quot;
comma
id|i
)paren
suffix:semicolon
id|bad_rw_intr
c_func
(paren
)paren
suffix:semicolon
id|hd_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|write_intr
r_static
r_void
id|write_intr
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|retries
op_assign
l_int|100000
suffix:semicolon
r_if
c_cond
(paren
id|unmask_intr
(braket
id|DEVICE_NR
c_func
(paren
id|WCURRENT.dev
)paren
)braket
)paren
id|sti
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|i
op_assign
(paren
r_int
)paren
id|inb_p
c_func
(paren
id|HD_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
id|BUSY_STAT
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|OK_STATUS
c_func
(paren
id|i
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|CURRENT-&gt;nr_sectors
op_le
l_int|1
)paren
op_logical_or
(paren
id|i
op_amp
id|DRQ_STAT
)paren
)paren
r_goto
id|ok_to_write
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|retries
OG
l_int|0
)paren
suffix:semicolon
id|dump_status
c_func
(paren
l_string|&quot;write_intr&quot;
comma
id|i
)paren
suffix:semicolon
id|bad_rw_intr
c_func
(paren
)paren
suffix:semicolon
id|hd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
id|ok_to_write
suffix:colon
id|CURRENT-&gt;sector
op_increment
suffix:semicolon
id|i
op_assign
op_decrement
id|CURRENT-&gt;nr_sectors
suffix:semicolon
op_decrement
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|CURRENT-&gt;buffer
op_add_assign
l_int|512
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
op_logical_or
(paren
id|CURRENT-&gt;bh
op_logical_and
op_logical_neg
id|SUBSECTOR
c_func
(paren
id|i
)paren
)paren
)paren
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
id|SET_INTR
c_func
(paren
op_amp
id|write_intr
)paren
suffix:semicolon
id|outsw
c_func
(paren
id|HD_DATA
comma
id|CURRENT-&gt;buffer
comma
l_int|256
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if (HD_DELAY &gt; 0)
id|last_req
op_assign
id|read_timer
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|hd_request
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
DECL|function|recal_intr
r_static
r_void
id|recal_intr
c_func
(paren
r_void
)paren
(brace
id|check_status
c_func
(paren
)paren
suffix:semicolon
macro_line|#if (HD_DELAY &gt; 0)
id|last_req
op_assign
id|read_timer
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
id|hd_request
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is another of the error-routines I don&squot;t know what to do with. The&n; * best idea seems to just set reset, and start all over again.&n; */
DECL|function|hd_times_out
r_static
r_void
id|hd_times_out
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|dev
suffix:semicolon
id|DEVICE_INTR
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CURRENT
)paren
r_return
suffix:semicolon
id|disable_irq
c_func
(paren
id|HD_IRQ
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|reset
op_assign
l_int|1
suffix:semicolon
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|CURRENT-&gt;dev
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;hd%c: timeout&bslash;n&quot;
comma
id|dev
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|CURRENT-&gt;errors
op_ge
id|MAX_ERRORS
)paren
(brace
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;hd%c: too many errors&bslash;n&quot;
comma
id|dev
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
macro_line|#endif
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|hd_request
c_func
(paren
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|HD_IRQ
)paren
suffix:semicolon
)brace
DECL|function|do_special_op
r_int
id|do_special_op
(paren
r_int
r_int
id|dev
)paren
(brace
r_if
c_cond
(paren
id|recalibrate
(braket
id|dev
)braket
)paren
(brace
id|recalibrate
(braket
id|dev
)braket
op_assign
l_int|0
suffix:semicolon
id|hd_out
c_func
(paren
id|dev
comma
id|hd_info
(braket
id|dev
)braket
dot
id|sect
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|WIN_RESTORE
comma
op_amp
id|recal_intr
)paren
suffix:semicolon
r_return
id|reset
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|identified
(braket
id|dev
)braket
)paren
(brace
id|identified
(braket
id|dev
)braket
op_assign
l_int|1
suffix:semicolon
id|unmask_intr
(braket
id|dev
)braket
op_assign
id|DEFAULT_UNMASK_INTR
suffix:semicolon
id|mult_req
(braket
id|dev
)braket
op_assign
id|DEFAULT_MULT_COUNT
suffix:semicolon
id|hd_out
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|WIN_IDENTIFY
comma
op_amp
id|identify_intr
)paren
suffix:semicolon
r_return
id|reset
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mult_req
(braket
id|dev
)braket
op_ne
id|mult_count
(braket
id|dev
)braket
)paren
(brace
id|hd_out
c_func
(paren
id|dev
comma
id|mult_req
(braket
id|dev
)braket
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|WIN_SETMULT
comma
op_amp
id|set_multmode_intr
)paren
suffix:semicolon
r_return
id|reset
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hd_info
(braket
id|dev
)braket
dot
id|head
OG
l_int|16
)paren
(brace
id|printk
(paren
l_string|&quot;hd%c: cannot handle device with more than 16 heads - giving up&bslash;n&quot;
comma
id|dev
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|special_op
(braket
id|dev
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * The driver enables interrupts as much as possible.  In order to do this,&n; * (a) the device-interrupt is disabled before entering hd_request(),&n; * and (b) the timeout-interrupt is disabled before the sti().&n; *&n; * Interrupts are still masked (by default) whenever we are exchanging&n; * data/cmds with a drive, because some drives seem to have very poor&n; * tolerance for latency during I/O.  For devices which don&squot;t suffer from&n; * that problem (most don&squot;t), the unmask_intr[] flag can be set to unmask&n; * other interrupts during data/cmd transfers (by defining DEFAULT_UNMASK_INTR&n; * to 1, or by using &quot;hdparm -u1 /dev/hd?&quot; from the shell).&n; */
DECL|function|hd_request
r_static
r_void
id|hd_request
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|dev
comma
id|block
comma
id|nsect
comma
id|sec
comma
id|track
comma
id|head
comma
id|cyl
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_logical_and
id|CURRENT-&gt;dev
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|DEVICE_INTR
)paren
r_return
suffix:semicolon
id|repeat
suffix:colon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|HD_TIMER
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|INIT_REQUEST
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|reset_hd
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|dev
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
suffix:semicolon
id|block
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|nsect
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ge
(paren
id|NR_HD
op_lshift
l_int|6
)paren
op_logical_or
id|block
op_ge
id|hd
(braket
id|dev
)braket
dot
id|nr_sects
op_logical_or
(paren
(paren
id|block
op_plus
id|nsect
)paren
OG
id|hd
(braket
id|dev
)braket
dot
id|nr_sects
)paren
)paren
(brace
macro_line|#ifdef DEBUG
r_if
c_cond
(paren
id|dev
op_ge
(paren
id|NR_HD
op_lshift
l_int|6
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;hd: bad minor number: device=0x%04x&bslash;n&quot;
comma
id|CURRENT-&gt;dev
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;hd%c: bad access: block=%d, count=%d&bslash;n&quot;
comma
(paren
id|CURRENT-&gt;dev
op_rshift
l_int|6
)paren
op_plus
l_char|&squot;a&squot;
comma
id|block
comma
id|nsect
)paren
suffix:semicolon
macro_line|#endif
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|block
op_add_assign
id|hd
(braket
id|dev
)braket
dot
id|start_sect
suffix:semicolon
id|dev
op_rshift_assign
l_int|6
suffix:semicolon
r_if
c_cond
(paren
id|special_op
(braket
id|dev
)braket
)paren
(brace
r_if
c_cond
(paren
id|do_special_op
c_func
(paren
id|dev
)paren
)paren
r_goto
id|repeat
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sec
op_assign
id|block
op_mod
id|hd_info
(braket
id|dev
)braket
dot
id|sect
op_plus
l_int|1
suffix:semicolon
id|track
op_assign
id|block
op_div
id|hd_info
(braket
id|dev
)braket
dot
id|sect
suffix:semicolon
id|head
op_assign
id|track
op_mod
id|hd_info
(braket
id|dev
)braket
dot
id|head
suffix:semicolon
id|cyl
op_assign
id|track
op_div
id|hd_info
(braket
id|dev
)braket
dot
id|head
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;hd%c: %sing: CHS=%d/%d/%d, sectors=%d, buffer=0x%08lx&bslash;n&quot;
comma
id|dev
op_plus
l_char|&squot;a&squot;
comma
(paren
id|CURRENT-&gt;cmd
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;read&quot;
suffix:colon
l_string|&quot;writ&quot;
comma
id|cyl
comma
id|head
comma
id|sec
comma
id|nsect
comma
(paren
r_int
r_int
)paren
id|CURRENT-&gt;buffer
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|unmask_intr
(braket
id|dev
)braket
)paren
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|READ
)paren
(brace
r_int
r_int
id|cmd
op_assign
id|mult_count
(braket
id|dev
)braket
OG
l_int|1
ques
c_cond
id|WIN_MULTREAD
suffix:colon
id|WIN_READ
suffix:semicolon
id|hd_out
c_func
(paren
id|dev
comma
id|nsect
comma
id|sec
comma
id|head
comma
id|cyl
comma
id|cmd
comma
op_amp
id|read_intr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
r_goto
id|repeat
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|WRITE
)paren
(brace
r_if
c_cond
(paren
id|mult_count
(braket
id|dev
)braket
)paren
id|hd_out
c_func
(paren
id|dev
comma
id|nsect
comma
id|sec
comma
id|head
comma
id|cyl
comma
id|WIN_MULTWRITE
comma
op_amp
id|multwrite_intr
)paren
suffix:semicolon
r_else
id|hd_out
c_func
(paren
id|dev
comma
id|nsect
comma
id|sec
comma
id|head
comma
id|cyl
comma
id|WIN_WRITE
comma
op_amp
id|write_intr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
r_goto
id|repeat
suffix:semicolon
r_if
c_cond
(paren
id|wait_DRQ
c_func
(paren
)paren
)paren
(brace
id|bad_rw_intr
c_func
(paren
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mult_count
(braket
id|dev
)braket
)paren
(brace
id|WCURRENT
op_assign
op_star
id|CURRENT
suffix:semicolon
id|multwrite
c_func
(paren
id|dev
)paren
suffix:semicolon
)brace
r_else
id|outsw
c_func
(paren
id|HD_DATA
comma
id|CURRENT-&gt;buffer
comma
l_int|256
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|panic
c_func
(paren
l_string|&quot;unknown hd-command&quot;
)paren
suffix:semicolon
)brace
DECL|function|do_hd_request
r_static
r_void
id|do_hd_request
(paren
r_void
)paren
(brace
id|disable_irq
c_func
(paren
id|HD_IRQ
)paren
suffix:semicolon
id|hd_request
c_func
(paren
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|HD_IRQ
)paren
suffix:semicolon
)brace
DECL|function|hd_ioctl
r_static
r_int
id|hd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|hd_geometry
op_star
id|loc
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
r_int
id|dev
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|inode
)paren
op_logical_or
(paren
op_logical_neg
id|inode-&gt;i_rdev
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ge
id|NR_HD
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|loc
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|loc
comma
r_sizeof
(paren
op_star
id|loc
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|put_fs_byte
c_func
(paren
id|bios_info
(braket
id|dev
)braket
dot
id|head
comma
(paren
r_char
op_star
)paren
op_amp
id|loc-&gt;heads
)paren
suffix:semicolon
id|put_fs_byte
c_func
(paren
id|bios_info
(braket
id|dev
)braket
dot
id|sect
comma
(paren
r_char
op_star
)paren
op_amp
id|loc-&gt;sectors
)paren
suffix:semicolon
id|put_fs_word
c_func
(paren
id|bios_info
(braket
id|dev
)braket
dot
id|cyl
comma
(paren
r_int
op_star
)paren
op_amp
id|loc-&gt;cylinders
)paren
suffix:semicolon
id|put_fs_long
c_func
(paren
id|hd
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|start_sect
comma
(paren
r_int
op_star
)paren
op_amp
id|loc-&gt;start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRASET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
OG
l_int|0xff
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRAGET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|put_fs_long
c_func
(paren
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
multiline_comment|/* Return device size */
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|put_fs_long
c_func
(paren
id|hd
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|nr_sects
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKFLSBUF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRRPART
suffix:colon
multiline_comment|/* Re-read partition tables */
r_return
id|revalidate_hddisk
c_func
(paren
id|inode-&gt;i_rdev
comma
l_int|1
)paren
suffix:semicolon
r_case
id|HDIO_SETUNMASKINTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
l_int|0x3F
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|unmask_intr
(braket
id|dev
)braket
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|HDIO_GETUNMASKINTR
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|put_fs_long
c_func
(paren
id|unmask_intr
(braket
id|dev
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|HDIO_GETMULTCOUNT
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|put_fs_long
c_func
(paren
id|mult_count
(braket
id|dev
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|HDIO_SETMULTCOUNT
suffix:colon
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
l_int|0x3F
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|arg
op_assign
id|get_fs_long
c_func
(paren
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* a prior request might still be in progress */
r_if
c_cond
(paren
id|arg
OG
id|max_mult
(braket
id|dev
)braket
)paren
id|err
op_assign
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* out of range for device */
r_else
r_if
c_cond
(paren
id|mult_req
(braket
id|dev
)braket
op_ne
id|mult_count
(braket
id|dev
)braket
)paren
(brace
id|special_op
(braket
id|dev
)braket
op_assign
l_int|1
suffix:semicolon
id|err
op_assign
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* busy, try again */
)brace
r_else
(brace
id|mult_req
(braket
id|dev
)braket
op_assign
id|arg
suffix:semicolon
id|special_op
(braket
id|dev
)braket
op_assign
l_int|1
suffix:semicolon
id|err
op_assign
l_int|0
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
r_case
id|HDIO_GETIDENTITY
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
l_int|0x3F
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|hd_ident_info
(braket
id|dev
)braket
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENOMSG
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|hd_driveid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_char
op_star
)paren
id|arg
comma
(paren
r_char
op_star
)paren
id|hd_ident_info
(braket
id|dev
)braket
comma
r_sizeof
(paren
r_struct
id|hd_driveid
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|RO_IOCTLS
c_func
(paren
id|inode-&gt;i_rdev
comma
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|hd_open
r_static
r_int
id|hd_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|target
suffix:semicolon
id|target
op_assign
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_while
c_loop
(paren
id|busy
(braket
id|target
)braket
)paren
id|sleep_on
c_func
(paren
op_amp
id|busy_wait
)paren
suffix:semicolon
id|access_count
(braket
id|target
)braket
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Releasing a block device means we sync() it, so that it can safely&n; * be forgotten about...&n; */
DECL|function|hd_release
r_static
r_void
id|hd_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|target
suffix:semicolon
id|sync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|target
op_assign
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|access_count
(braket
id|target
)braket
op_decrement
suffix:semicolon
)brace
r_static
r_void
id|hd_geninit
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|hd_gendisk
r_static
r_struct
id|gendisk
id|hd_gendisk
op_assign
(brace
id|MAJOR_NR
comma
multiline_comment|/* Major number */
l_string|&quot;hd&quot;
comma
multiline_comment|/* Major name */
l_int|6
comma
multiline_comment|/* Bits to shift to get real from partition */
l_int|1
op_lshift
l_int|6
comma
multiline_comment|/* Number of partitions per real */
id|MAX_HD
comma
multiline_comment|/* maximum number of real */
id|hd_geninit
comma
multiline_comment|/* init function */
id|hd
comma
multiline_comment|/* hd struct */
id|hd_sizes
comma
multiline_comment|/* block sizes */
l_int|0
comma
multiline_comment|/* number */
(paren
r_void
op_star
)paren
id|bios_info
comma
multiline_comment|/* internal */
l_int|NULL
multiline_comment|/* next */
)brace
suffix:semicolon
DECL|function|hd_interrupt
r_static
r_void
id|hd_interrupt
c_func
(paren
r_int
id|unused
)paren
(brace
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
)paren
op_assign
id|DEVICE_INTR
suffix:semicolon
id|DEVICE_INTR
op_assign
l_int|NULL
suffix:semicolon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|HD_TIMER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
id|handler
op_assign
id|unexpected_hd_interrupt
suffix:semicolon
id|handler
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the harddisk IRQ description. The SA_INTERRUPT in sa_flags&n; * means we run the IRQ-handler with interrupts disabled: this is bad for&n; * interrupt latency, but anything else has led to problems on some&n; * machines...&n; *&n; * We enable interrupts in some of the routines after making sure it&squot;s&n; * safe.&n; */
DECL|function|hd_geninit
r_static
r_void
id|hd_geninit
c_func
(paren
r_void
)paren
(brace
r_int
id|drive
comma
id|i
suffix:semicolon
r_extern
r_struct
id|drive_info
id|drive_info
suffix:semicolon
r_int
r_char
op_star
id|BIOS
op_assign
(paren
r_int
r_char
op_star
)paren
op_amp
id|drive_info
suffix:semicolon
r_int
id|cmos_disks
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NR_HD
)paren
(brace
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
l_int|2
suffix:semicolon
id|drive
op_increment
)paren
(brace
id|bios_info
(braket
id|drive
)braket
dot
id|cyl
op_assign
id|hd_info
(braket
id|drive
)braket
dot
id|cyl
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
id|BIOS
suffix:semicolon
id|bios_info
(braket
id|drive
)braket
dot
id|head
op_assign
id|hd_info
(braket
id|drive
)braket
dot
id|head
op_assign
op_star
(paren
l_int|2
op_plus
id|BIOS
)paren
suffix:semicolon
id|bios_info
(braket
id|drive
)braket
dot
id|wpcom
op_assign
id|hd_info
(braket
id|drive
)braket
dot
id|wpcom
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
l_int|5
op_plus
id|BIOS
)paren
suffix:semicolon
id|bios_info
(braket
id|drive
)braket
dot
id|ctl
op_assign
id|hd_info
(braket
id|drive
)braket
dot
id|ctl
op_assign
op_star
(paren
l_int|8
op_plus
id|BIOS
)paren
suffix:semicolon
id|bios_info
(braket
id|drive
)braket
dot
id|lzone
op_assign
id|hd_info
(braket
id|drive
)braket
dot
id|lzone
op_assign
op_star
(paren
r_int
r_int
op_star
)paren
(paren
l_int|12
op_plus
id|BIOS
)paren
suffix:semicolon
id|bios_info
(braket
id|drive
)braket
dot
id|sect
op_assign
id|hd_info
(braket
id|drive
)braket
dot
id|sect
op_assign
op_star
(paren
l_int|14
op_plus
id|BIOS
)paren
suffix:semicolon
macro_line|#ifdef does_not_work_for_everybody_with_scsi_but_helps_ibm_vp
r_if
c_cond
(paren
id|hd_info
(braket
id|drive
)braket
dot
id|cyl
op_logical_and
id|NR_HD
op_eq
id|drive
)paren
id|NR_HD
op_increment
suffix:semicolon
macro_line|#endif
id|BIOS
op_add_assign
l_int|16
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;We query CMOS about hard disks : it could be that &n;&t;&t;we have a SCSI/ESDI/etc controller that is BIOS&n;&t;&t;compatible with ST-506, and thus showing up in our&n;&t;&t;BIOS table, but not register compatible, and therefore&n;&t;&t;not present in CMOS.&n;&n;&t;&t;Furthermore, we will assume that our ST-506 drives&n;&t;&t;&lt;if any&gt; are the primary drives in the system, and &n;&t;&t;the ones reflected as drive 1 or 2.&n;&n;&t;&t;The first drive is stored in the high nibble of CMOS&n;&t;&t;byte 0x12, the second in the low nibble.  This will be&n;&t;&t;either a 4 bit drive type or 0xf indicating use byte 0x19 &n;&t;&t;for an 8 bit type, drive 1, 0x1a for drive 2 in CMOS.&n;&n;&t;&t;Needless to say, a non-zero value means we have &n;&t;&t;an AT controller hard disk for that drive.&n;&n;&t;&t;&n;&t;*/
r_if
c_cond
(paren
(paren
id|cmos_disks
op_assign
id|CMOS_READ
c_func
(paren
l_int|0x12
)paren
)paren
op_amp
l_int|0xf0
)paren
r_if
c_cond
(paren
id|cmos_disks
op_amp
l_int|0x0f
)paren
id|NR_HD
op_assign
l_int|2
suffix:semicolon
r_else
id|NR_HD
op_assign
l_int|1
suffix:semicolon
)brace
id|i
op_assign
id|NR_HD
suffix:semicolon
r_while
c_loop
(paren
id|i
op_decrement
OG
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t; * The newer E-IDE BIOSs handle drives larger than 1024&n;&t;&t; * cylinders by increasing the number of logical heads&n;&t;&t; * to keep the number of logical cylinders below the&n;&t;&t; * sacred INT13 limit of 1024 (10 bits).  If that is&n;&t;&t; * what&squot;s happening here, we&squot;ll find out and correct&n;&t;&t; * it later when &quot;identifying&quot; the drive.&n;&t;&t; */
id|hd
(braket
id|i
op_lshift
l_int|6
)braket
dot
id|nr_sects
op_assign
id|bios_info
(braket
id|i
)braket
dot
id|head
op_star
id|bios_info
(braket
id|i
)braket
dot
id|sect
op_star
id|bios_info
(braket
id|i
)braket
dot
id|cyl
suffix:semicolon
id|hd_ident_info
(braket
id|i
)braket
op_assign
(paren
r_struct
id|hd_driveid
op_star
)paren
id|kmalloc
c_func
(paren
l_int|512
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|special_op
(braket
id|i
)braket
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NR_HD
)paren
(brace
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|HD_IRQ
comma
id|hd_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;hd&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;hd: unable to get IRQ%d for the harddisk driver&bslash;n&quot;
comma
id|HD_IRQ
)paren
suffix:semicolon
id|NR_HD
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|hd_gendisk.nr_real
op_assign
id|NR_HD
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
(paren
id|MAX_HD
op_lshift
l_int|6
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|hd_blocksizes
(braket
id|i
)braket
op_assign
l_int|1024
suffix:semicolon
)brace
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|hd_blocksizes
suffix:semicolon
)brace
DECL|variable|hd_fops
r_static
r_struct
id|file_operations
id|hd_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|hd_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|hd_open
comma
multiline_comment|/* open */
id|hd_release
comma
multiline_comment|/* release */
id|block_fsync
multiline_comment|/* fsync */
)brace
suffix:semicolon
DECL|function|hd_init
r_int
r_int
id|hd_init
c_func
(paren
r_int
r_int
id|mem_start
comma
r_int
r_int
id|mem_end
)paren
(brace
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;hd&quot;
comma
op_amp
id|hd_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;hd: unable to get major %d for harddisk&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* 8 sector (4kB) read-ahead */
id|hd_gendisk.next
op_assign
id|gendisk_head
suffix:semicolon
id|gendisk_head
op_assign
op_amp
id|hd_gendisk
suffix:semicolon
id|timer_table
(braket
id|HD_TIMER
)braket
dot
id|fn
op_assign
id|hd_times_out
suffix:semicolon
r_return
id|mem_start
suffix:semicolon
)brace
DECL|macro|DEVICE_BUSY
mdefine_line|#define DEVICE_BUSY busy[target]
DECL|macro|USAGE
mdefine_line|#define USAGE access_count[target]
DECL|macro|CAPACITY
mdefine_line|#define CAPACITY (bios_info[target].head*bios_info[target].sect*bios_info[target].cyl)
multiline_comment|/* We assume that the the bios parameters do not change, so the disk capacity&n;   will not change */
DECL|macro|MAYBE_REINIT
macro_line|#undef MAYBE_REINIT
DECL|macro|GENDISK_STRUCT
mdefine_line|#define GENDISK_STRUCT hd_gendisk
multiline_comment|/*&n; * This routine is called to flush all partitions and partition tables&n; * for a changed scsi disk, and then re-read the new partition table.&n; * If we are revalidating a disk because of a media change, then we&n; * enter with usage == 0.  If we are using an ioctl, we automatically have&n; * usage == 1 (we need an open channel to use an ioctl :-), so this&n; * is our limit.&n; */
DECL|function|revalidate_hddisk
r_static
r_int
id|revalidate_hddisk
c_func
(paren
r_int
id|dev
comma
r_int
id|maxusage
)paren
(brace
r_int
id|target
comma
id|major
suffix:semicolon
r_struct
id|gendisk
op_star
id|gdev
suffix:semicolon
r_int
id|max_p
suffix:semicolon
r_int
id|start
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|target
op_assign
id|DEVICE_NR
c_func
(paren
id|dev
)paren
suffix:semicolon
id|gdev
op_assign
op_amp
id|GENDISK_STRUCT
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEVICE_BUSY
op_logical_or
id|USAGE
OG
id|maxusage
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
suffix:semicolon
id|DEVICE_BUSY
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|max_p
op_assign
id|gdev-&gt;max_p
suffix:semicolon
id|start
op_assign
id|target
op_lshift
id|gdev-&gt;minor_shift
suffix:semicolon
id|major
op_assign
id|MAJOR_NR
op_lshift
l_int|8
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|max_p
op_minus
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|sync_dev
c_func
(paren
id|major
op_or
id|start
op_or
id|i
)paren
suffix:semicolon
id|invalidate_inodes
c_func
(paren
id|major
op_or
id|start
op_or
id|i
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|major
op_or
id|start
op_or
id|i
)paren
suffix:semicolon
id|gdev-&gt;part
(braket
id|start
op_plus
id|i
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|gdev-&gt;part
(braket
id|start
op_plus
id|i
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
)brace
suffix:semicolon
macro_line|#ifdef MAYBE_REINIT
id|MAYBE_REINIT
suffix:semicolon
macro_line|#endif
id|gdev-&gt;part
(braket
id|start
)braket
dot
id|nr_sects
op_assign
id|CAPACITY
suffix:semicolon
id|resetup_one_dev
c_func
(paren
id|gdev
comma
id|target
)paren
suffix:semicolon
id|DEVICE_BUSY
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|busy_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
eof
