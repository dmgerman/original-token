multiline_comment|/* &n;&t;ez.c&t;(c) 1996  Grant R. Guenther &lt;grant@torque.net&gt;&n;&t;&t;          Under the terms of the GNU public license.&n;&n;&t;This is a driver for the parallel port versions of SyQuest&squot;s &n;        EZ135 and EZ230 removable media disk drives.  &n;        &n;        Special thanks go to Pedro Soria-Rodriguez for his help testing &n;&t;the EZFlyer 230 support.&n;&n;&t;The drive is actually SyQuest&squot;s IDE product with a&n;        ShuttleTech IDE &lt;-&gt; parallel converter chip built in.&n;&n;&t;To compile the driver, ensure that /usr/include/linux and&n;        /usr/include/asm are links to the correct include files for &n;        the target system. Then compile the driver with &n;&n;&t;&t;cc -D__KERNEL__ -DMODULE -O2 -c ez.c&n;&n;        If you are using MODVERSIONS, add the following to the cc command:&n;&n;&t;&t;-DMODVERSIONS -I /usr/include/linux/modversions.h&n;&n;&t;You must then load it with insmod.&n;&n;&t;Before attempting to access the new driver, you will need to&n;        create some device special files.  The following commands will&n;&t;do that for you:&n;&n;&t;&t;mknod /dev/eza  b 40 0&n;&t;&t;mknod /dev/eza1 b 40 1&n;&t;&t;mknod /dev/eza2 b 40 2&n;&t;&t;mknod /dev/eza3 b 40 3&n;&t;&t;mknod /dev/eza4 b 40 4&n;&t;&t;chown root:disk /dev/ez*&n;&t;&t;chmod 660 /dev/ez*&n;&n;&t;You can make devices for more partitions (up to 15) if you need to.&n;&n;&t;You can alter the port used by the driver in two ways:  either&n;        change the definition of EZ_BASE or modify the ez_base variable&n;        on the insmod command line, for example:&n;&n;&t;&t;insmod ez ez_base=0x3bc&n;&n;&t;The driver can detect if the parallel port supports 8-bit&n;        transfers.  If so, it will use them.  You can force it to use&n;        4-bit (nybble) mode by setting the variable ez_nybble to 1.&n;&n;&t;The driver can be used with or without interrupts.  If an IRQ&n;        is specified in the variable ez_irq, the driver will use it.&n;        If ez_irq is set to 0, an alternative, polling-based, strategy &n;&t;will be used.&n;&n;&t;If you experience timeout errors while using this driver - and&n;        you have enabled interrupts - try disabling the interrupt.  I&n;        have heard reports of some parallel ports having exceptionally&n;        unreliable interrupts.  This could happen on misconfigured &n;        systems in which an inactive sound card shares the same IRQ with &n;        the parallel port. (Remember that most people do not use the&n;        parallel port interrupt for printing.)&n;&n;&t;It would be advantageous to use multiple mode transfers,&n;        but ShuttleTech&squot;s driver does not appear to use them, so I&squot;m not&n;        sure that the converter can handle it.&n;&n;&t;It is not currently possible to connect a printer to the chained&n;        port on the EZ135p and expect Linux to use both devices at once.&n;&n;&t;When the EZ230 powers on, the &quot;standby timer&quot; is set to about 6&n;        minutes:  if the drive is idle for that length of time, it will&n;        put itself into a low power standby mode.  It takes a couple of&n;        seconds for the drive to come out of standby mode.  So, if you&n;        load this driver while it is in standby mode, you will notice&n;        a &quot;freeze&quot; of a second or two as the driver waits for the EZ230&n;        to come back to life.  Once loaded, this driver disables the&n;        standby timer (until you next power up the EZ230 ...)&n;&n;&t;Keep an eye on http://www.torque.net/ez135.html for news and&n;        other information about the driver.  If you have any problems&n;        with this driver, please send me, grant@torque.net, some mail &n;        directly before posting into the newsgroups or mailing lists.&n;&n;*/
DECL|macro|EZ_VERSION
mdefine_line|#define&t;EZ_VERSION&t;&quot;0.11&quot;
DECL|macro|EZ_BASE
mdefine_line|#define&t;EZ_BASE&t;&t;0x378
DECL|macro|EZ_IRQ
mdefine_line|#define EZ_IRQ&t;&t;7
DECL|macro|EZ_REP
mdefine_line|#define EZ_REP&t;&t;4
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|EZ_BITS
mdefine_line|#define EZ_BITS&t;   4&t;&t;&t;/* compatible with SCSI version */
DECL|macro|EZ_MAJOR
mdefine_line|#define EZ_MAJOR   40&t;&t;&t;/* as assigned by hpa */
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR EZ_MAJOR
multiline_comment|/* set up defines for blk.h,  why don&squot;t all drivers do it this way ? */
DECL|macro|DEVICE_NAME
mdefine_line|#define DEVICE_NAME &quot;ez&quot;
DECL|macro|DEVICE_REQUEST
mdefine_line|#define DEVICE_REQUEST do_ez_request
DECL|macro|DEVICE_NR
mdefine_line|#define DEVICE_NR(device) (MINOR(device)&gt;&gt;EZ_BITS)
DECL|macro|DEVICE_ON
mdefine_line|#define DEVICE_ON(device)
DECL|macro|DEVICE_OFF
mdefine_line|#define DEVICE_OFF(device)
macro_line|#include &lt;linux/blk.h&gt;
DECL|macro|EZ_PARTNS
mdefine_line|#define EZ_PARTNS  (1&lt;&lt;EZ_BITS)
DECL|macro|EZ_LOG_HEADS
mdefine_line|#define EZ_LOG_HEADS&t;64&t;&t;
DECL|macro|EZ_LOG_SECTS
mdefine_line|#define EZ_LOG_SECTS&t;32&t;&t;/* SCSI compatible logical geometry */
DECL|macro|EZ_SIGOFF
mdefine_line|#define EZ_SIGOFF&t;54
DECL|macro|EZ_SIG
mdefine_line|#define EZ_SIG&t;&t;&quot;ySuQse tZE&quot;
DECL|macro|EZ_SIGLEN
mdefine_line|#define EZ_SIGLEN&t;10
DECL|macro|EZ_ID_LEN
mdefine_line|#define EZ_ID_LEN&t;14
DECL|macro|EZ_TMO
mdefine_line|#define EZ_TMO  &t;250&t;&t;/* interrupt timeout in jiffies */
DECL|macro|EZ_SPIN_DEL
mdefine_line|#define EZ_SPIN_DEL     50&t;&t;/* spin delay in micro-seconds  */
DECL|macro|EZ_SPIN
mdefine_line|#define EZ_SPIN&t;&t;(10000/EZ_SPIN_DEL)*EZ_TMO  
DECL|macro|EZ_ISPIN
mdefine_line|#define EZ_ISPIN&t;(10000/EZ_SPIN_DEL)*20
DECL|macro|EZ_DELAY
mdefine_line|#define EZ_DELAY        udelay(EZ_SPIN_DEL)
DECL|macro|STAT_ERR
mdefine_line|#define STAT_ERR&t;0x00001
DECL|macro|STAT_INDEX
mdefine_line|#define STAT_INDEX&t;0x00002
DECL|macro|STAT_ECC
mdefine_line|#define STAT_ECC&t;0x00004
DECL|macro|STAT_DRQ
mdefine_line|#define STAT_DRQ&t;0x00008
DECL|macro|STAT_SEEK
mdefine_line|#define STAT_SEEK&t;0x00010
DECL|macro|STAT_WRERR
mdefine_line|#define STAT_WRERR&t;0x00020
DECL|macro|STAT_READY
mdefine_line|#define STAT_READY&t;0x00040
DECL|macro|STAT_BUSY
mdefine_line|#define STAT_BUSY&t;0x00080
DECL|macro|ERR_AMNF
mdefine_line|#define ERR_AMNF&t;0x00100
DECL|macro|ERR_TK0NF
mdefine_line|#define ERR_TK0NF&t;0x00200
DECL|macro|ERR_ABRT
mdefine_line|#define ERR_ABRT&t;0x00400
DECL|macro|ERR_MCR
mdefine_line|#define ERR_MCR&t;&t;0x00800
DECL|macro|ERR_IDNF
mdefine_line|#define ERR_IDNF&t;0x01000
DECL|macro|ERR_MC
mdefine_line|#define ERR_MC&t;&t;0x02000
DECL|macro|ERR_UNC
mdefine_line|#define ERR_UNC&t;&t;0x04000
DECL|macro|ERR_TMO
mdefine_line|#define ERR_TMO&t;&t;0x10000
DECL|macro|IDE_READ
mdefine_line|#define IDE_READ&t;0x20
DECL|macro|IDE_WRITE
mdefine_line|#define IDE_WRITE&t;0x30
DECL|macro|IDE_STANDBY
mdefine_line|#define IDE_STANDBY     0x96
DECL|macro|IDE_DOORLOCK
mdefine_line|#define IDE_DOORLOCK&t;0xde
DECL|macro|IDE_DOORUNLOCK
mdefine_line|#define IDE_DOORUNLOCK  0xdf
DECL|macro|IDE_ACKCHANGE
mdefine_line|#define IDE_ACKCHANGE   0xdb
DECL|macro|IDE_IDENTIFY
mdefine_line|#define IDE_IDENTIFY    0xec
r_int
id|ez_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|ez_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
suffix:semicolon
macro_line|#ifdef MODULE
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|ez_geninit
c_func
(paren
r_struct
id|gendisk
op_star
id|ignored
)paren
suffix:semicolon
r_static
r_int
id|ez_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_void
id|do_ez_request
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|ez_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|ez_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|ez_revalidate
c_func
(paren
id|kdev_t
id|dev
)paren
suffix:semicolon
r_static
r_int
id|ez_check_media
c_func
(paren
id|kdev_t
id|dev
)paren
suffix:semicolon
r_static
r_void
id|ez_get_capacity
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|ez_detect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_ez_read
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_ez_write
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|ez_media_check
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|ez_doorlock
c_func
(paren
r_int
id|func
)paren
suffix:semicolon
r_static
r_void
id|ez_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_void
id|ez_pseudo
c_func
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_void
id|ez_timer_int
c_func
(paren
r_int
r_int
id|data
)paren
suffix:semicolon
r_static
r_void
id|do_ez_read_drq
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_ez_write_done
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|ez
r_static
r_struct
id|hd_struct
id|ez
(braket
id|EZ_PARTNS
)braket
suffix:semicolon
DECL|variable|ez_sizes
r_static
r_int
id|ez_sizes
(braket
id|EZ_PARTNS
)braket
suffix:semicolon
DECL|variable|ez_blocksizes
r_static
r_int
id|ez_blocksizes
(braket
id|EZ_PARTNS
)braket
suffix:semicolon
DECL|variable|ez_base
r_static
r_int
id|ez_base
op_assign
id|EZ_BASE
suffix:semicolon
DECL|variable|ez_irq
r_static
r_int
id|ez_irq
op_assign
id|EZ_IRQ
suffix:semicolon
DECL|variable|ez_rep
r_static
r_int
id|ez_rep
op_assign
id|EZ_REP
suffix:semicolon
DECL|variable|ez_nybble
r_static
r_int
id|ez_nybble
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* force 4-bit mode ? */
DECL|variable|ez_valid
r_static
r_int
id|ez_valid
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* OK to open */
DECL|variable|ez_access
r_static
r_int
id|ez_access
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* count of active opens ... */
DECL|variable|ez_changed
r_static
r_int
id|ez_changed
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Did we see new media on open ? */
DECL|variable|ez_capacity
r_static
r_int
id|ez_capacity
op_assign
l_int|512
op_star
l_int|16
op_star
l_int|32
suffix:semicolon
multiline_comment|/* Size of this volume in sectors */
DECL|variable|ez_heads
r_static
r_int
id|ez_heads
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* physical geometry */
DECL|variable|ez_sectors
r_static
r_int
id|ez_sectors
op_assign
l_int|32
suffix:semicolon
DECL|variable|ez_mode
r_static
r_int
id|ez_mode
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 4- or 8-bit mode */
DECL|variable|ez_loops
r_static
r_int
id|ez_loops
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* counter for pseudo-interrupts */
DECL|variable|ez_timeout
r_static
r_int
id|ez_timeout
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* did the interrupt time out ? */
DECL|variable|ez_int_seen
r_static
r_int
id|ez_int_seen
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* have we ever seen an interrupt ? */
DECL|variable|ez_busy
r_static
r_int
id|ez_busy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* request being processed ? */
DECL|variable|ez_block
r_static
r_int
id|ez_block
suffix:semicolon
multiline_comment|/* address of next requested block */
DECL|variable|ez_count
r_static
r_int
id|ez_count
suffix:semicolon
multiline_comment|/* number of blocks still to do */
DECL|variable|ez_buf
r_static
r_char
op_star
id|ez_buf
suffix:semicolon
multiline_comment|/* buffer for request in progress */
DECL|variable|ez_scratch
r_static
r_char
id|ez_scratch
(braket
l_int|512
)braket
suffix:semicolon
multiline_comment|/* scratch block buffer */
DECL|variable|ez_continuation
r_static
r_void
(paren
op_star
id|ez_continuation
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* i/o completion handler */
DECL|variable|ez_errs
r_char
op_star
id|ez_errs
(braket
l_int|17
)braket
op_assign
(brace
l_string|&quot;ERR&quot;
comma
l_string|&quot;INDEX&quot;
comma
l_string|&quot;ECC&quot;
comma
l_string|&quot;DRQ&quot;
comma
l_string|&quot;SEEK&quot;
comma
l_string|&quot;WRERR&quot;
comma
l_string|&quot;READY&quot;
comma
l_string|&quot;BUSY&quot;
comma
l_string|&quot;AMNF&quot;
comma
l_string|&quot;TK0NF&quot;
comma
l_string|&quot;ABRT&quot;
comma
l_string|&quot;MCR&quot;
comma
l_string|&quot;IDNF&quot;
comma
l_string|&quot;MC&quot;
comma
l_string|&quot;UNC&quot;
comma
l_string|&quot;???&quot;
comma
l_string|&quot;TMO&quot;
)brace
suffix:semicolon
DECL|variable|ez_tq
r_static
r_struct
id|tq_struct
id|ez_tq
op_assign
(brace
l_int|0
comma
l_int|0
comma
id|ez_pseudo
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|ez_timer
r_static
r_struct
id|timer_list
id|ez_timer
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|ez_timer_int
)brace
suffix:semicolon
DECL|variable|ez_wait_open
r_static
r_struct
id|wait_queue
op_star
id|ez_wait_open
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* kernel glue structures */
DECL|variable|ez_gendisk
r_static
r_struct
id|gendisk
id|ez_gendisk
op_assign
(brace
id|MAJOR_NR
comma
multiline_comment|/* Major number */
l_string|&quot;ez&quot;
comma
multiline_comment|/* Major name */
id|EZ_BITS
comma
multiline_comment|/* Bits to shift to get real from partition */
id|EZ_PARTNS
comma
multiline_comment|/* Number of partitions per real */
l_int|1
comma
multiline_comment|/* maximum number of real */
id|ez_geninit
comma
multiline_comment|/* init function */
id|ez
comma
multiline_comment|/* hd struct */
id|ez_sizes
comma
multiline_comment|/* block sizes */
l_int|0
comma
multiline_comment|/* number */
l_int|NULL
comma
multiline_comment|/* internal */
l_int|NULL
multiline_comment|/* next */
)brace
suffix:semicolon
DECL|variable|ez_fops
r_static
r_struct
id|file_operations
id|ez_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|ez_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|ez_open
comma
multiline_comment|/* open */
id|ez_release
comma
multiline_comment|/* release */
id|block_fsync
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
id|ez_check_media
comma
multiline_comment|/* media change ? */
id|ez_revalidate
multiline_comment|/* revalidate new media */
)brace
suffix:semicolon
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_int
id|ez_init
(paren
r_void
)paren
)paren
multiline_comment|/* preliminary initialisation */
(brace
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;ez&quot;
comma
op_amp
id|ez_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ez_init: unable to get major number %d&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* 8 sector (4kB) read ahead */
id|ez_gendisk.next
op_assign
id|gendisk_head
suffix:semicolon
id|gendisk_head
op_assign
op_amp
id|ez_gendisk
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|ez_geninit
(paren
r_struct
id|gendisk
op_star
id|ignored
)paren
)paren
multiline_comment|/* real init */
(brace
r_int
id|i
suffix:semicolon
id|ez_gendisk.nr_real
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ez_detect
c_func
(paren
)paren
)paren
(brace
id|ez_busy
op_assign
l_int|0
suffix:semicolon
id|ez_valid
op_assign
l_int|1
suffix:semicolon
id|ez_gendisk.nr_real
op_assign
l_int|1
suffix:semicolon
id|ez
(braket
l_int|0
)braket
dot
id|nr_sects
op_assign
id|ez_capacity
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|EZ_PARTNS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ez_blocksizes
(braket
id|i
)braket
op_assign
l_int|1024
suffix:semicolon
)brace
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|ez_blocksizes
suffix:semicolon
)brace
macro_line|#ifdef MODULE
r_else
id|cleanup_module
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|ez_open
r_static
r_int
id|ez_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|dev
op_assign
id|DEVICE_NR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ge
id|ez_gendisk.nr_real
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|ez_valid
)paren
id|sleep_on
c_func
(paren
op_amp
id|ez_wait_open
)paren
suffix:semicolon
id|ez_access
op_increment
suffix:semicolon
id|ez_media_check
c_func
(paren
)paren
suffix:semicolon
id|ez_doorlock
c_func
(paren
id|IDE_DOORLOCK
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|do_ez_request
r_static
r_void
id|do_ez_request
(paren
r_void
)paren
(brace
r_int
id|dev
suffix:semicolon
r_if
c_cond
(paren
id|ez_busy
)paren
r_return
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
(paren
op_logical_neg
id|CURRENT
)paren
op_logical_or
(paren
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
)paren
r_return
suffix:semicolon
id|INIT_REQUEST
suffix:semicolon
id|dev
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
suffix:semicolon
id|ez_block
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|ez_count
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
op_ge
id|EZ_PARTNS
)paren
op_logical_or
(paren
(paren
id|ez_block
op_plus
id|ez_count
)paren
OG
id|ez
(braket
id|dev
)braket
dot
id|nr_sects
)paren
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|ez_block
op_add_assign
id|ez
(braket
id|dev
)braket
dot
id|start_sect
suffix:semicolon
id|ez_buf
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|READ
)paren
id|do_ez_read
c_func
(paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|WRITE
)paren
id|do_ez_write
c_func
(paren
)paren
suffix:semicolon
r_else
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
DECL|function|ez_ioctl
r_static
r_int
id|ez_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|hd_geometry
op_star
id|geo
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
r_int
id|dev
comma
id|err
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|inode
)paren
op_logical_or
(paren
op_logical_neg
id|inode-&gt;i_rdev
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|dev
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
op_ge
id|EZ_PARTNS
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|geo
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|geo
comma
r_sizeof
(paren
op_star
id|geo
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
id|err
suffix:semicolon
id|put_user
c_func
(paren
id|ez_capacity
op_div
(paren
id|EZ_LOG_HEADS
op_star
id|EZ_LOG_SECTS
)paren
comma
(paren
r_int
op_star
)paren
op_amp
id|geo-&gt;cylinders
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|EZ_LOG_HEADS
comma
(paren
r_char
op_star
)paren
op_amp
id|geo-&gt;heads
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|EZ_LOG_SECTS
comma
(paren
r_char
op_star
)paren
op_amp
id|geo-&gt;sectors
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|ez
(braket
id|dev
)braket
dot
id|start_sect
comma
(paren
r_int
op_star
)paren
op_amp
id|geo-&gt;start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRASET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inode-&gt;i_rdev
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|arg
OG
l_int|0xff
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
op_assign
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRAGET
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
(paren
id|err
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|read_ahead
(braket
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|err
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
r_return
(paren
id|err
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|ez
(braket
id|dev
)braket
dot
id|nr_sects
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_case
id|BLKFLSBUF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inode-&gt;i_rdev
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRRPART
suffix:colon
r_return
id|ez_revalidate
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|RO_IOCTLS
c_func
(paren
id|inode-&gt;i_rdev
comma
id|arg
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|ez_release
r_static
r_void
id|ez_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|kdev_t
id|devp
suffix:semicolon
id|devp
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
r_if
c_cond
(paren
id|DEVICE_NR
c_func
(paren
id|devp
)paren
op_eq
l_int|0
)paren
(brace
id|fsync_dev
c_func
(paren
id|devp
)paren
suffix:semicolon
id|invalidate_inodes
c_func
(paren
id|devp
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|devp
)paren
suffix:semicolon
id|ez_access
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ez_access
)paren
id|ez_doorlock
c_func
(paren
id|IDE_DOORUNLOCK
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
)brace
DECL|function|ez_check_media
r_static
r_int
id|ez_check_media
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|t
suffix:semicolon
id|t
op_assign
id|ez_changed
suffix:semicolon
id|ez_changed
op_assign
l_int|0
suffix:semicolon
r_return
id|t
suffix:semicolon
)brace
DECL|function|ez_revalidate
r_static
r_int
id|ez_revalidate
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|p
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|kdev_t
id|devp
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ez_access
OG
l_int|1
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|ez_valid
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_for
c_loop
(paren
id|p
op_assign
(paren
id|EZ_PARTNS
op_minus
l_int|1
)paren
suffix:semicolon
id|p
op_ge
l_int|0
suffix:semicolon
id|p
op_decrement
)paren
(brace
id|devp
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|p
)paren
suffix:semicolon
id|fsync_dev
c_func
(paren
id|devp
)paren
suffix:semicolon
id|invalidate_inodes
c_func
(paren
id|devp
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|devp
)paren
suffix:semicolon
id|ez
(braket
id|p
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|ez
(braket
id|p
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
)brace
id|ez_get_capacity
c_func
(paren
)paren
suffix:semicolon
id|ez
(braket
l_int|0
)braket
dot
id|nr_sects
op_assign
id|ez_capacity
suffix:semicolon
id|resetup_one_dev
c_func
(paren
op_amp
id|ez_gendisk
comma
l_int|0
)paren
suffix:semicolon
id|ez_valid
op_assign
l_int|1
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|ez_wait_open
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/* Glue for modules ... */
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
id|ez_init
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|err
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
id|ez_geninit
c_func
(paren
op_amp
id|ez_gendisk
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ez_gendisk.nr_real
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|ez_valid
op_assign
l_int|0
suffix:semicolon
id|resetup_one_dev
c_func
(paren
op_amp
id|ez_gendisk
comma
l_int|0
)paren
suffix:semicolon
id|ez_valid
op_assign
l_int|1
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_struct
id|gendisk
op_star
op_star
id|gdp
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;ez&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|gdp
op_assign
op_amp
id|gendisk_head
suffix:semicolon
op_star
id|gdp
suffix:semicolon
id|gdp
op_assign
op_amp
(paren
(paren
op_star
id|gdp
)paren
op_member_access_from_pointer
id|next
)paren
)paren
r_if
c_cond
(paren
op_star
id|gdp
op_eq
op_amp
id|ez_gendisk
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_star
id|gdp
)paren
op_star
id|gdp
op_assign
(paren
op_star
id|gdp
)paren
op_member_access_from_pointer
id|next
suffix:semicolon
r_if
c_cond
(paren
id|ez_gendisk.nr_real
)paren
(brace
id|release_region
c_func
(paren
id|ez_base
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ez_irq
)paren
id|free_irq
c_func
(paren
id|ez_irq
comma
l_int|NULL
)paren
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#else 
multiline_comment|/* ez_setup:  process lilo command parameters ...&n;&n;   syntax:&t;ez=base[,irq[,rep[,nybble]]]&n;*/
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_void
id|ez_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|ez_base
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|1
)paren
id|ez_irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|2
)paren
id|ez_rep
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|3
)paren
id|ez_nybble
op_assign
id|ints
(braket
l_int|4
)braket
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Now the actual hardware interface to the EZ135p */
DECL|function|out_p
r_static
r_void
id|out_p
c_func
(paren
r_int
id|port
comma
r_char
id|byte
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ez_rep
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
id|byte
comma
id|ez_base
op_plus
id|port
)paren
suffix:semicolon
)brace
)brace
DECL|function|in_p
r_static
r_int
id|in_p
c_func
(paren
r_int
id|port
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
id|c
suffix:semicolon
id|c
op_assign
id|inb
c_func
(paren
id|ez_base
op_plus
id|port
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|ez_rep
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
id|inb
c_func
(paren
id|ez_base
op_plus
id|port
)paren
suffix:semicolon
)brace
r_return
id|c
op_amp
l_int|0xff
suffix:semicolon
)brace
DECL|macro|w0
mdefine_line|#define w0(byte)  out_p(0,byte)
DECL|macro|w2
mdefine_line|#define w2(byte)  out_p(2,byte)
DECL|macro|r0
mdefine_line|#define r0()      (in_p(0) &amp; 0xff)
DECL|macro|r1
mdefine_line|#define r1()      (in_p(1) &amp; 0xff)
multiline_comment|/*  register access functions */
DECL|function|read_regr
r_static
r_int
id|read_regr
c_func
(paren
r_char
id|regr
)paren
(brace
r_int
id|h
comma
id|l
suffix:semicolon
r_if
c_cond
(paren
id|ez_mode
op_eq
l_int|1
)paren
(brace
multiline_comment|/* nybble mode */
id|w0
c_func
(paren
id|regr
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|l
op_assign
id|r1
c_func
(paren
)paren
op_rshift
l_int|4
suffix:semicolon
id|w2
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|h
op_assign
id|r1
c_func
(paren
)paren
op_amp
l_int|0xf0
suffix:semicolon
r_return
id|h
op_plus
id|l
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* byte mode */
id|w0
c_func
(paren
id|regr
op_plus
l_int|0x20
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|0x25
)paren
suffix:semicolon
id|h
op_assign
id|r0
c_func
(paren
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|4
)paren
suffix:semicolon
r_return
id|h
suffix:semicolon
)brace
)brace
DECL|function|write_regr
r_static
r_void
id|write_regr
c_func
(paren
r_char
id|regr
comma
r_char
id|val
)paren
(brace
id|w0
c_func
(paren
id|regr
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|w0
c_func
(paren
id|val
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* connect / disconnect code */
DECL|function|prefix
r_static
r_void
id|prefix
c_func
(paren
r_char
id|byte
)paren
(brace
id|w2
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0x22
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0xaa
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0x55
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0xff
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0x87
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0x78
)paren
suffix:semicolon
id|w0
c_func
(paren
id|byte
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0xff
)paren
suffix:semicolon
)brace
DECL|function|connect
r_static
r_void
id|connect
(paren
r_void
)paren
(brace
id|prefix
c_func
(paren
l_int|0x40
)paren
suffix:semicolon
id|prefix
c_func
(paren
l_int|0x50
)paren
suffix:semicolon
id|prefix
c_func
(paren
l_int|0xe0
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|read_regr
c_func
(paren
l_int|0xd
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x6d
comma
l_int|0xe8
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x6c
comma
l_int|0x1c
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x72
comma
l_int|0x10
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x6a
comma
l_int|0x38
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x68
comma
l_int|0x10
)paren
suffix:semicolon
id|read_regr
c_func
(paren
l_int|0x12
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x72
comma
l_int|0x10
)paren
suffix:semicolon
id|read_regr
c_func
(paren
l_int|0xd
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x6d
comma
l_int|0xaa
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x6d
comma
l_int|0xaa
)paren
suffix:semicolon
)brace
DECL|function|disconnect
r_static
r_void
id|disconnect
(paren
r_void
)paren
(brace
id|read_regr
c_func
(paren
l_int|0xd
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x6d
comma
l_int|0xa8
)paren
suffix:semicolon
id|prefix
c_func
(paren
l_int|0x30
)paren
suffix:semicolon
)brace
multiline_comment|/* basic i/o */
DECL|function|read_block
r_static
r_void
id|read_block
c_func
(paren
r_char
op_star
id|buf
)paren
multiline_comment|/* the nybble mode read has a curious optimisation in it: there are actually&n;   five bits available on each read.  The extra bit is used to signal that&n;   the next nybble is identical ...  I wonder how much research went into&n;   designing this use of the extra bit ?&n;*/
(brace
r_int
id|j
comma
id|k
comma
id|n0
comma
id|n1
comma
id|n2
comma
id|n3
suffix:semicolon
id|read_regr
c_func
(paren
l_int|0xd
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x6d
comma
l_int|0xe9
)paren
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ez_mode
op_eq
l_int|1
)paren
(brace
multiline_comment|/* nybble mode */
id|w0
c_func
(paren
l_int|7
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0xff
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|256
suffix:semicolon
id|k
op_increment
)paren
(brace
id|w2
c_func
(paren
l_int|6
)paren
suffix:semicolon
id|n0
op_assign
id|r1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n0
op_amp
l_int|8
)paren
id|n1
op_assign
id|n0
suffix:semicolon
r_else
(brace
id|w2
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|n1
op_assign
id|r1
c_func
(paren
)paren
suffix:semicolon
)brace
id|w2
c_func
(paren
l_int|7
)paren
suffix:semicolon
id|n2
op_assign
id|r1
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|n2
op_amp
l_int|8
)paren
id|n3
op_assign
id|n2
suffix:semicolon
r_else
(brace
id|w2
c_func
(paren
l_int|5
)paren
suffix:semicolon
id|n3
op_assign
id|r1
c_func
(paren
)paren
suffix:semicolon
)brace
id|buf
(braket
id|j
op_increment
)braket
op_assign
(paren
id|n0
op_rshift
l_int|4
)paren
op_plus
(paren
id|n1
op_amp
l_int|0xf0
)paren
suffix:semicolon
id|buf
(braket
id|j
op_increment
)braket
op_assign
(paren
id|n2
op_rshift
l_int|4
)paren
op_plus
(paren
id|n3
op_amp
l_int|0xf0
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* byte mode */
id|w0
c_func
(paren
l_int|0x27
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|0x25
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|256
suffix:semicolon
id|k
op_increment
)paren
(brace
id|w2
c_func
(paren
l_int|0x24
)paren
suffix:semicolon
id|buf
(braket
id|j
op_increment
)braket
op_assign
id|r0
c_func
(paren
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|0x25
)paren
suffix:semicolon
id|buf
(braket
id|j
op_increment
)braket
op_assign
id|r0
c_func
(paren
)paren
suffix:semicolon
)brace
id|w2
c_func
(paren
l_int|0x26
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|0x27
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|0x25
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|4
)paren
suffix:semicolon
)brace
)brace
DECL|function|write_block
r_static
r_void
id|write_block
c_func
(paren
r_char
op_star
id|buf
)paren
(brace
r_int
id|j
suffix:semicolon
id|read_regr
c_func
(paren
l_int|0xd
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x6d
comma
l_int|0xe9
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0x67
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|5
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|256
suffix:semicolon
id|j
op_increment
)paren
(brace
id|w0
c_func
(paren
id|buf
(braket
l_int|2
op_star
id|j
)braket
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|w0
c_func
(paren
id|buf
(braket
l_int|2
op_star
id|j
op_plus
l_int|1
)braket
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|5
)paren
suffix:semicolon
)brace
id|w2
c_func
(paren
l_int|7
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/*  ide command interface */
DECL|function|ez_print_error
r_void
id|ez_print_error
c_func
(paren
r_char
op_star
id|msg
comma
r_int
id|status
)paren
(brace
r_char
op_star
id|e
comma
op_star
id|p
suffix:semicolon
r_int
id|i
suffix:semicolon
id|e
op_assign
id|ez_scratch
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|18
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|status
op_amp
(paren
l_int|1
op_lshift
id|i
)paren
)paren
(brace
id|p
op_assign
id|ez_errs
(braket
id|i
)braket
suffix:semicolon
r_while
c_loop
(paren
(paren
op_star
id|e
op_increment
op_assign
op_star
id|p
op_increment
)paren
)paren
suffix:semicolon
op_star
(paren
id|e
op_minus
l_int|1
)paren
op_assign
l_char|&squot; &squot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
)paren
id|e
op_decrement
suffix:semicolon
op_star
id|e
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ez: %s: status = 0x%x (%s)&bslash;n&quot;
comma
id|msg
comma
id|status
comma
id|ez_scratch
)paren
suffix:semicolon
)brace
DECL|function|wait_for
r_static
r_int
id|wait_for
c_func
(paren
r_int
id|w
comma
r_char
op_star
id|msg
)paren
multiline_comment|/* polled wait */
(brace
r_int
id|k
comma
id|r
comma
id|e
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|k
OL
id|EZ_SPIN
)paren
(brace
id|r
op_assign
id|read_regr
c_func
(paren
l_int|0x1f
)paren
suffix:semicolon
id|k
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ez_timeout
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|r
op_amp
id|w
)paren
op_eq
id|w
)paren
op_logical_and
op_logical_neg
(paren
id|r
op_amp
id|STAT_BUSY
)paren
)paren
r_break
suffix:semicolon
id|EZ_DELAY
suffix:semicolon
)brace
id|e
op_assign
(paren
id|read_regr
c_func
(paren
l_int|0x19
)paren
op_lshift
l_int|8
)paren
op_plus
id|r
suffix:semicolon
r_if
c_cond
(paren
(paren
id|k
op_ge
id|EZ_SPIN
)paren
op_logical_or
id|ez_timeout
)paren
id|e
op_or_assign
(paren
id|ERR_TMO
op_or
id|STAT_ERR
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|e
op_amp
id|STAT_ERR
)paren
op_amp
(paren
id|msg
op_ne
l_int|NULL
)paren
)paren
id|ez_print_error
c_func
(paren
id|msg
comma
id|e
)paren
suffix:semicolon
r_return
id|e
suffix:semicolon
)brace
DECL|function|send_command
r_static
r_void
id|send_command
c_func
(paren
r_int
id|n
comma
r_int
id|s
comma
r_int
id|h
comma
r_int
id|c0
comma
r_int
id|c1
comma
r_int
id|func
)paren
(brace
id|read_regr
c_func
(paren
l_int|0xd
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x6d
comma
l_int|0xa9
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x76
comma
l_int|0
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x79
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* the IDE task file */
id|write_regr
c_func
(paren
l_int|0x7a
comma
id|n
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x7b
comma
id|s
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x7c
comma
id|c0
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x7d
comma
id|c1
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x7e
comma
l_int|0xa0
op_plus
id|h
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x7f
comma
id|func
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|ez_ide_command
r_static
r_void
id|ez_ide_command
c_func
(paren
r_int
id|func
comma
r_int
id|block
)paren
(brace
r_int
id|c1
comma
id|c0
comma
id|h
comma
id|s
suffix:semicolon
id|s
op_assign
(paren
id|block
op_mod
id|ez_sectors
)paren
op_plus
l_int|1
suffix:semicolon
id|h
op_assign
(paren
id|block
op_div
id|ez_sectors
)paren
op_mod
id|ez_heads
suffix:semicolon
id|c0
op_assign
(paren
id|block
op_div
(paren
id|ez_sectors
op_star
id|ez_heads
)paren
)paren
op_mod
l_int|256
suffix:semicolon
id|c1
op_assign
(paren
id|block
op_div
(paren
id|ez_sectors
op_star
id|ez_heads
op_star
l_int|256
)paren
)paren
suffix:semicolon
id|send_command
c_func
(paren
l_int|1
comma
id|s
comma
id|h
comma
id|c0
comma
id|c1
comma
id|func
)paren
suffix:semicolon
)brace
DECL|function|ez_gate_intr
r_static
r_void
id|ez_gate_intr
c_func
(paren
r_int
id|flag
)paren
(brace
r_if
c_cond
(paren
id|flag
)paren
id|write_regr
c_func
(paren
l_int|0x6d
comma
l_int|0x39
)paren
suffix:semicolon
multiline_comment|/* gate interrupt line to bus */
r_if
c_cond
(paren
id|flag
op_logical_and
id|ez_irq
)paren
id|w2
c_func
(paren
l_int|0x14
)paren
suffix:semicolon
multiline_comment|/* enable IRQ */
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
id|w2
c_func
(paren
l_int|4
)paren
suffix:semicolon
multiline_comment|/* disable IRQ */
)brace
DECL|function|check_int
r_static
r_int
id|check_int
c_func
(paren
r_void
)paren
multiline_comment|/* is the interrupt bit set  ?  */
(brace
r_return
(paren
id|r1
c_func
(paren
)paren
op_amp
l_int|0x40
)paren
suffix:semicolon
)brace
DECL|function|ez_doorlock
r_static
r_void
id|ez_doorlock
c_func
(paren
r_int
id|func
)paren
(brace
id|connect
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_for
c_func
(paren
id|STAT_READY
comma
l_string|&quot;Lock&quot;
)paren
op_amp
id|STAT_ERR
)paren
(brace
id|disconnect
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ez_ide_command
c_func
(paren
id|func
comma
l_int|0
)paren
suffix:semicolon
id|wait_for
c_func
(paren
id|STAT_READY
comma
l_string|&quot;Lock done&quot;
)paren
suffix:semicolon
id|disconnect
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* ez_media_check: check for and acknowledge the MC flag */
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|ez_media_check
c_func
(paren
r_void
)paren
)paren
(brace
r_int
id|r
suffix:semicolon
id|ez_changed
op_assign
l_int|0
suffix:semicolon
id|connect
c_func
(paren
)paren
suffix:semicolon
id|r
op_assign
id|wait_for
c_func
(paren
id|STAT_READY
comma
l_string|&quot;Media check ready&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r
op_amp
id|STAT_ERR
)paren
)paren
(brace
id|ez_ide_command
c_func
(paren
id|IDE_READ
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* try to read block 0 */
id|r
op_assign
id|wait_for
c_func
(paren
id|STAT_DRQ
comma
l_string|&quot;Media check&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r
op_amp
id|STAT_ERR
)paren
)paren
id|read_block
c_func
(paren
id|ez_scratch
)paren
suffix:semicolon
)brace
r_else
id|ez_changed
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* say changed if other error */
r_if
c_cond
(paren
id|r
op_amp
id|ERR_MC
)paren
(brace
id|ez_changed
op_assign
l_int|1
suffix:semicolon
id|ez_ide_command
c_func
(paren
id|IDE_ACKCHANGE
comma
l_int|0
)paren
suffix:semicolon
id|wait_for
c_func
(paren
id|STAT_READY
comma
l_string|&quot;Ack. media change&quot;
)paren
suffix:semicolon
)brace
id|disconnect
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|ez_identify
c_func
(paren
r_void
)paren
)paren
(brace
r_int
id|k
comma
id|r
suffix:semicolon
id|connect
c_func
(paren
)paren
suffix:semicolon
id|wait_for
c_func
(paren
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* wait until not busy, quietly */
id|ez_ide_command
c_func
(paren
id|IDE_IDENTIFY
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ez_irq
)paren
(brace
multiline_comment|/* check that the interrupt works */
id|ez_gate_intr
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|k
op_increment
OL
id|EZ_ISPIN
)paren
op_logical_and
op_logical_neg
id|ez_int_seen
)paren
id|EZ_DELAY
suffix:semicolon
id|ez_gate_intr
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|r
op_assign
id|read_regr
c_func
(paren
l_int|0x1f
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|ez_int_seen
)paren
op_logical_or
op_logical_neg
(paren
id|r
op_amp
id|STAT_DRQ
)paren
)paren
(brace
id|free_irq
c_func
(paren
id|ez_irq
comma
l_int|NULL
)paren
suffix:semicolon
id|ez_irq
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|wait_for
c_func
(paren
id|STAT_DRQ
comma
l_int|NULL
)paren
op_amp
id|STAT_ERR
)paren
(brace
id|disconnect
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|read_block
c_func
(paren
id|ez_scratch
)paren
suffix:semicolon
id|disconnect
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|word_val
mdefine_line|#define  word_val(n) &t;(ez_scratch[2*n]+256*ez_scratch[2*n+1])
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|ez_get_capacity
c_func
(paren
r_void
)paren
)paren
(brace
r_int
id|ez_cylinders
suffix:semicolon
id|connect
c_func
(paren
)paren
suffix:semicolon
id|wait_for
c_func
(paren
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|ez_ide_command
c_func
(paren
id|IDE_IDENTIFY
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_for
c_func
(paren
id|STAT_DRQ
comma
l_string|&quot;Get capacity&quot;
)paren
op_amp
id|STAT_ERR
)paren
(brace
id|disconnect
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|read_block
c_func
(paren
id|ez_scratch
)paren
suffix:semicolon
id|disconnect
c_func
(paren
)paren
suffix:semicolon
id|ez_sectors
op_assign
id|word_val
c_func
(paren
l_int|6
)paren
suffix:semicolon
id|ez_heads
op_assign
id|word_val
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|ez_cylinders
op_assign
id|word_val
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|ez_capacity
op_assign
id|ez_sectors
op_star
id|ez_heads
op_star
id|ez_cylinders
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ez: Capacity = %d, (%d/%d/%d)&bslash;n&quot;
comma
id|ez_capacity
comma
id|ez_cylinders
comma
id|ez_heads
comma
id|ez_sectors
)paren
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_void
id|ez_standby_off
c_func
(paren
r_void
)paren
)paren
(brace
id|connect
c_func
(paren
)paren
suffix:semicolon
id|wait_for
c_func
(paren
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|send_command
c_func
(paren
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
id|IDE_STANDBY
)paren
suffix:semicolon
id|wait_for
c_func
(paren
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|disconnect
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|ez_port_check
c_func
(paren
r_void
)paren
)paren
multiline_comment|/* check for 8-bit port */
(brace
r_int
id|r
suffix:semicolon
id|w2
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0x55
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r0
c_func
(paren
)paren
op_ne
l_int|0x55
)paren
r_return
l_int|0
suffix:semicolon
id|w0
c_func
(paren
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r0
c_func
(paren
)paren
op_ne
l_int|0xaa
)paren
r_return
l_int|0
suffix:semicolon
id|w2
c_func
(paren
l_int|0x20
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0x55
)paren
suffix:semicolon
id|r
op_assign
id|r0
c_func
(paren
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r0
c_func
(paren
)paren
op_eq
id|r
)paren
r_return
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|r0
c_func
(paren
)paren
op_eq
l_int|0xaa
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|__initfunc
id|__initfunc
c_func
(paren
r_static
r_int
id|ez_detect
c_func
(paren
r_void
)paren
)paren
(brace
r_int
id|j
comma
id|k
suffix:semicolon
r_char
id|sig
(braket
id|EZ_SIGLEN
)braket
op_assign
id|EZ_SIG
suffix:semicolon
r_char
id|id
(braket
id|EZ_ID_LEN
op_plus
l_int|1
)braket
suffix:semicolon
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|ez_base
comma
l_int|3
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ez: Ports at 0x%x are not available&bslash;n&quot;
comma
id|ez_base
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|ez_mode
op_assign
id|ez_port_check
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ez_mode
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ez: No parallel port at 0x%x&bslash;n&quot;
comma
id|ez_base
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ez_irq
op_logical_and
id|request_irq
c_func
(paren
id|ez_irq
comma
id|ez_interrupt
comma
l_int|0
comma
l_string|&quot;ez&quot;
comma
l_int|NULL
)paren
)paren
id|ez_irq
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ez_nybble
)paren
id|ez_mode
op_assign
l_int|1
suffix:semicolon
id|request_region
c_func
(paren
id|ez_base
comma
l_int|3
comma
l_string|&quot;ez&quot;
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|k
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ez_identify
c_func
(paren
)paren
)paren
(brace
id|k
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|EZ_SIGLEN
suffix:semicolon
id|j
op_increment
)paren
(brace
id|k
op_and_assign
(paren
id|ez_scratch
(braket
id|j
op_plus
id|EZ_SIGOFF
)braket
op_eq
id|sig
(braket
id|j
)braket
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|k
)paren
(brace
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|EZ_ID_LEN
suffix:semicolon
id|j
op_increment
)paren
(brace
id|id
(braket
id|j
op_xor
l_int|1
)braket
op_assign
id|ez_scratch
(braket
id|j
op_plus
id|EZ_SIGOFF
)braket
suffix:semicolon
)brace
id|id
(braket
id|EZ_ID_LEN
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ez_irq
)paren
id|printk
c_func
(paren
l_string|&quot;ez %s: %s at 0x%x, %d-bit mode.&bslash;n&quot;
comma
id|EZ_VERSION
comma
id|id
comma
id|ez_base
comma
l_int|4
op_star
id|ez_mode
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;ez %s: %s at 0x%x, IRQ %d, %d-bit mode.&bslash;n&quot;
comma
id|EZ_VERSION
comma
id|id
comma
id|ez_base
comma
id|ez_irq
comma
l_int|4
op_star
id|ez_mode
)paren
suffix:semicolon
id|ez_standby_off
c_func
(paren
)paren
suffix:semicolon
id|ez_media_check
c_func
(paren
)paren
suffix:semicolon
id|ez_get_capacity
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|ez_base
comma
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ez_irq
)paren
id|free_irq
c_func
(paren
id|ez_irq
comma
l_int|NULL
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ez: Drive not detected&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* interrupt management */
DECL|function|ez_set_intr
r_static
r_void
id|ez_set_intr
c_func
(paren
r_void
(paren
op_star
id|continuation
)paren
(paren
r_void
)paren
)paren
(brace
id|ez_continuation
op_assign
id|continuation
suffix:semicolon
id|ez_loops
op_assign
l_int|1
suffix:semicolon
id|ez_timeout
op_assign
l_int|0
suffix:semicolon
id|ez_gate_intr
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ez_irq
)paren
(brace
id|ez_timer.expires
op_assign
id|jiffies
op_plus
id|EZ_TMO
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|ez_timer
)paren
suffix:semicolon
)brace
r_else
id|queue_task
c_func
(paren
op_amp
id|ez_tq
comma
op_amp
id|tq_scheduler
)paren
suffix:semicolon
)brace
DECL|function|ez_pseudo
r_static
r_void
id|ez_pseudo
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_void
(paren
op_star
id|con
)paren
(paren
r_void
)paren
suffix:semicolon
id|ez_timeout
op_assign
(paren
id|ez_loops
op_ge
id|EZ_TMO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|check_int
c_func
(paren
)paren
op_logical_or
id|ez_timeout
)paren
(brace
id|con
op_assign
id|ez_continuation
suffix:semicolon
id|ez_continuation
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|con
)paren
id|con
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|ez_loops
op_increment
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|ez_tq
comma
op_amp
id|tq_scheduler
)paren
suffix:semicolon
)brace
)brace
DECL|function|ez_timer_int
r_static
r_void
id|ez_timer_int
c_func
(paren
r_int
r_int
id|data
)paren
(brace
r_void
(paren
op_star
id|con
)paren
(paren
r_void
)paren
suffix:semicolon
id|con
op_assign
id|ez_continuation
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|con
)paren
r_return
suffix:semicolon
id|ez_continuation
op_assign
l_int|NULL
suffix:semicolon
id|ez_gate_intr
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|ez_timeout
op_assign
l_int|1
suffix:semicolon
id|con
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|ez_interrupt
r_static
r_void
id|ez_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_void
(paren
op_star
id|con
)paren
(paren
r_void
)paren
suffix:semicolon
id|ez_int_seen
op_assign
l_int|1
suffix:semicolon
id|con
op_assign
id|ez_continuation
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|con
)paren
r_return
suffix:semicolon
id|ez_gate_intr
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|ez_timer
)paren
suffix:semicolon
id|ez_continuation
op_assign
l_int|NULL
suffix:semicolon
id|con
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* The i/o request engine */
DECL|macro|EZ_DONE
mdefine_line|#define EZ_DONE(s) { disconnect(); end_request(s); ez_busy = 0;&bslash;&n;&t;&t;     cli(); do_ez_request(); return; }
DECL|function|do_ez_read
r_static
r_void
id|do_ez_read
c_func
(paren
r_void
)paren
(brace
id|ez_busy
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ez_count
)paren
(brace
id|ez_busy
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|connect
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_for
c_func
(paren
id|STAT_READY
comma
l_string|&quot;do_ez_read&quot;
)paren
op_amp
id|STAT_ERR
)paren
id|EZ_DONE
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|ez_ide_command
c_func
(paren
id|IDE_READ
comma
id|ez_block
)paren
suffix:semicolon
id|ez_set_intr
c_func
(paren
id|do_ez_read_drq
)paren
suffix:semicolon
)brace
DECL|function|do_ez_read_drq
r_static
r_void
id|do_ez_read_drq
c_func
(paren
r_void
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_for
c_func
(paren
id|STAT_DRQ
comma
l_string|&quot;do_ez_read_drq&quot;
)paren
op_amp
id|STAT_ERR
)paren
id|EZ_DONE
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|read_block
c_func
(paren
id|ez_buf
)paren
suffix:semicolon
id|ez_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ez_count
)paren
(brace
id|ez_buf
op_add_assign
l_int|512
suffix:semicolon
id|ez_block
op_increment
suffix:semicolon
id|disconnect
c_func
(paren
)paren
suffix:semicolon
id|do_ez_read
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|EZ_DONE
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|do_ez_write
r_static
r_void
id|do_ez_write
c_func
(paren
r_void
)paren
(brace
id|ez_busy
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ez_count
)paren
(brace
id|ez_busy
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|connect
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_for
c_func
(paren
id|STAT_READY
comma
l_string|&quot;do_ez_write&quot;
)paren
op_amp
id|STAT_ERR
)paren
id|EZ_DONE
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|ez_ide_command
c_func
(paren
id|IDE_WRITE
comma
id|ez_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_for
c_func
(paren
id|STAT_DRQ
comma
l_string|&quot;do_ez_write_drq&quot;
)paren
op_amp
id|STAT_ERR
)paren
id|EZ_DONE
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|write_block
c_func
(paren
id|ez_buf
)paren
suffix:semicolon
id|ez_set_intr
c_func
(paren
id|do_ez_write_done
)paren
suffix:semicolon
)brace
DECL|function|do_ez_write_done
r_static
r_void
id|do_ez_write_done
c_func
(paren
r_void
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_for
c_func
(paren
id|STAT_READY
comma
l_string|&quot;do_ez_write_done&quot;
)paren
op_amp
id|STAT_ERR
)paren
id|EZ_DONE
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|ez_count
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ez_count
)paren
(brace
id|ez_buf
op_add_assign
l_int|512
suffix:semicolon
id|ez_block
op_increment
suffix:semicolon
id|disconnect
c_func
(paren
)paren
suffix:semicolon
id|do_ez_write
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|EZ_DONE
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* end of ez.c */
eof
