multiline_comment|/*&n; *    Disk Array driver for Compaq SMART2 Controllers&n; *    Copyright 2000 Compaq Computer Corporation&n; *&n; *    This program is free software; you can redistribute it and/or modify&n; *    it under the terms of the GNU General Public License as published by&n; *    the Free Software Foundation; either version 2 of the License, or&n; *    (at your option) any later version.&n; *&n; *    This program is distributed in the hope that it will be useful,&n; *    but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or&n; *    NON INFRINGEMENT.  See the GNU General Public License for more details.&n; *&n; *    You should have received a copy of the GNU General Public License&n; *    along with this program; if not, write to the Free Software&n; *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; *    Questions/Comments/Bugfixes to arrays@compaq.com&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;&t;/* CONFIG_PROC_FS */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/proc_fs.h&gt;
macro_line|#include &lt;linux/init.h&gt; 
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/spinlock.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/genhd.h&gt;
DECL|macro|CCISS_DRIVER_VERSION
mdefine_line|#define CCISS_DRIVER_VERSION(maj,min,submin) ((maj&lt;&lt;16)|(min&lt;&lt;8)|(submin))
DECL|macro|DRIVER_NAME
mdefine_line|#define DRIVER_NAME &quot;Compaq CISS Driver (v 2.4.0)&quot;
DECL|macro|DRIVER_VERSION
mdefine_line|#define DRIVER_VERSION CCISS_DRIVER_VERSION(2,4,0)
multiline_comment|/* Embedded module documentation macros - see modules.h */
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Charles M. White III - Compaq Computer Corporation&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;Driver for Compaq Smart Array Controller 5300&quot;
)paren
suffix:semicolon
macro_line|#include &quot;cciss_cmd.h&quot;
macro_line|#include &quot;cciss.h&quot;
macro_line|#include &lt;linux/cciss_ioctl.h&gt;
DECL|macro|NR_PRODUCTS
mdefine_line|#define NR_PRODUCTS (sizeof(products)/sizeof(struct board_type))
multiline_comment|/*  board_id = Subsystem Device ID &amp; Vendor ID&n; *  product = Marketing Name for the board&n; *  access = Address of the struct of function pointers &n; */
DECL|variable|products
r_static
r_struct
id|board_type
id|products
(braket
)braket
op_assign
(brace
(brace
l_int|0x40700E11
comma
l_string|&quot;Smart Array 5300&quot;
comma
op_amp
id|SA5_access
)brace
comma
)brace
suffix:semicolon
multiline_comment|/* How long to wait (in millesconds) for board to go into simple mode */
DECL|macro|MAX_CONFIG_WAIT
mdefine_line|#define MAX_CONFIG_WAIT 1000 
DECL|macro|READ_AHEAD
mdefine_line|#define READ_AHEAD &t; 128
DECL|macro|NR_CMDS
mdefine_line|#define NR_CMDS&t;&t; 128 /* #commands that can be outstanding */
DECL|macro|MAX_CTLR
mdefine_line|#define MAX_CTLR 8
DECL|variable|nr_ctlr
r_static
r_int
id|nr_ctlr
suffix:semicolon
DECL|variable|hba
r_static
id|ctlr_info_t
op_star
id|hba
(braket
id|MAX_CTLR
)braket
suffix:semicolon
DECL|variable|proc_cciss
r_static
r_struct
id|proc_dir_entry
op_star
id|proc_cciss
suffix:semicolon
r_static
r_void
id|do_cciss_request
c_func
(paren
r_int
id|i
)paren
suffix:semicolon
multiline_comment|/*&n; * This is a hack.  This driver eats a major number for each controller, and&n; * sets blkdev[xxx].request_fn to each one of these so the real request&n; * function knows what controller its working with.&n; */
DECL|macro|DO_CCISS_REQUEST
mdefine_line|#define DO_CCISS_REQUEST(x) { do_cciss_request(x); }
r_static
r_void
id|do_cciss_request0
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_CCISS_REQUEST
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_static
r_void
id|do_cciss_request1
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_CCISS_REQUEST
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_static
r_void
id|do_cciss_request2
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_CCISS_REQUEST
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_static
r_void
id|do_cciss_request3
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_CCISS_REQUEST
c_func
(paren
l_int|3
)paren
suffix:semicolon
r_static
r_void
id|do_cciss_request4
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_CCISS_REQUEST
c_func
(paren
l_int|4
)paren
suffix:semicolon
r_static
r_void
id|do_cciss_request5
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_CCISS_REQUEST
c_func
(paren
l_int|5
)paren
suffix:semicolon
r_static
r_void
id|do_cciss_request6
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_CCISS_REQUEST
c_func
(paren
l_int|6
)paren
suffix:semicolon
r_static
r_void
id|do_cciss_request7
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
id|DO_CCISS_REQUEST
c_func
(paren
l_int|7
)paren
suffix:semicolon
r_static
r_int
id|cciss_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
)paren
suffix:semicolon
r_static
r_int
id|cciss_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
)paren
suffix:semicolon
r_static
r_int
id|cciss_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_int
id|revalidate_allvol
c_func
(paren
id|kdev_t
id|dev
)paren
suffix:semicolon
r_static
r_int
id|revalidate_logvol
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|maxusage
)paren
suffix:semicolon
r_static
r_int
id|frevalidate_logvol
c_func
(paren
id|kdev_t
id|dev
)paren
suffix:semicolon
r_static
r_void
id|cciss_getgeometry
c_func
(paren
r_int
id|cntl_num
)paren
suffix:semicolon
r_static
r_inline
r_void
id|addQ
c_func
(paren
id|CommandList_struct
op_star
op_star
id|Qptr
comma
id|CommandList_struct
op_star
id|c
)paren
suffix:semicolon
r_static
r_void
id|start_io
c_func
(paren
id|ctlr_info_t
op_star
id|h
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PROC_FS
r_static
r_int
id|cciss_proc_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
suffix:semicolon
r_static
r_void
id|cciss_procinit
c_func
(paren
r_int
id|i
)paren
suffix:semicolon
macro_line|#else
DECL|function|cciss_proc_get_info
r_static
r_int
id|cciss_proc_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cciss_procinit
r_static
r_void
id|cciss_procinit
c_func
(paren
r_int
id|i
)paren
(brace
)brace
macro_line|#endif /* CONFIG_PROC_FS */
DECL|variable|cciss_fops
r_static
r_struct
id|block_device_operations
id|cciss_fops
op_assign
(brace
id|open
suffix:colon
id|cciss_open
comma
id|release
suffix:colon
id|cciss_release
comma
id|ioctl
suffix:colon
id|cciss_ioctl
comma
id|revalidate
suffix:colon
id|frevalidate_logvol
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * Report information about this controller.&n; */
macro_line|#ifdef CONFIG_PROC_FS
DECL|function|cciss_proc_get_info
r_static
r_int
id|cciss_proc_get_info
c_func
(paren
r_char
op_star
id|buffer
comma
r_char
op_star
op_star
id|start
comma
id|off_t
id|offset
comma
r_int
id|length
comma
r_int
op_star
id|eof
comma
r_void
op_star
id|data
)paren
(brace
id|off_t
id|pos
op_assign
l_int|0
suffix:semicolon
id|off_t
id|len
op_assign
l_int|0
suffix:semicolon
r_int
id|size
comma
id|i
comma
id|ctlr
suffix:semicolon
id|ctlr_info_t
op_star
id|h
op_assign
(paren
id|ctlr_info_t
op_star
)paren
id|data
suffix:semicolon
id|drive_info_struct
op_star
id|drv
suffix:semicolon
id|ctlr
op_assign
id|h-&gt;ctlr
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
comma
l_string|&quot;%s:  Compaq %s Controller&bslash;n&quot;
l_string|&quot;       Board ID: %08lx&bslash;n&quot;
l_string|&quot;       Firmware Version: %c%c%c%c&bslash;n&quot;
l_string|&quot;       Memory Address: %08lx&bslash;n&quot;
l_string|&quot;       IRQ: 0x%x&bslash;n&quot;
l_string|&quot;       Logical drives: %d&bslash;n&quot;
l_string|&quot;       Current Q depth: %d&bslash;n&quot;
l_string|&quot;       Current # commands on controller %d&bslash;n&quot;
l_string|&quot;       Max Q depth since init: %d&bslash;n&quot;
l_string|&quot;       Max # commands on controller since init: %d&bslash;n&quot;
l_string|&quot;       Max SG entries since init: %d&bslash;n&bslash;n&quot;
comma
id|h-&gt;devname
comma
id|h-&gt;product_name
comma
(paren
r_int
r_int
)paren
id|h-&gt;board_id
comma
id|h-&gt;firm_ver
(braket
l_int|0
)braket
comma
id|h-&gt;firm_ver
(braket
l_int|1
)braket
comma
id|h-&gt;firm_ver
(braket
l_int|2
)braket
comma
id|h-&gt;firm_ver
(braket
l_int|3
)braket
comma
(paren
r_int
r_int
)paren
id|h-&gt;vaddr
comma
(paren
r_int
r_int
)paren
id|h-&gt;intr
comma
id|h-&gt;num_luns
comma
id|h-&gt;Qdepth
comma
id|h-&gt;commands_outstanding
comma
id|h-&gt;maxQsinceinit
comma
id|h-&gt;max_outstanding
comma
id|h-&gt;maxSG
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|h-&gt;num_luns
suffix:semicolon
id|i
op_increment
)paren
(brace
id|drv
op_assign
op_amp
id|h-&gt;drv
(braket
id|i
)braket
suffix:semicolon
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;cciss/c%dd%d: blksz=%d nr_blocks=%d&bslash;n&quot;
comma
id|ctlr
comma
id|i
comma
id|drv-&gt;block_size
comma
id|drv-&gt;nr_blocks
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
)brace
id|size
op_assign
id|sprintf
c_func
(paren
id|buffer
op_plus
id|len
comma
l_string|&quot;nr_allocs = %d&bslash;nnr_frees = %d&bslash;n&quot;
comma
id|h-&gt;nr_allocs
comma
id|h-&gt;nr_frees
)paren
suffix:semicolon
id|pos
op_add_assign
id|size
suffix:semicolon
id|len
op_add_assign
id|size
suffix:semicolon
op_star
id|eof
op_assign
l_int|1
suffix:semicolon
op_star
id|start
op_assign
id|buffer
op_plus
id|offset
suffix:semicolon
id|len
op_sub_assign
id|offset
suffix:semicolon
r_if
c_cond
(paren
id|len
OG
id|length
)paren
id|len
op_assign
id|length
suffix:semicolon
r_return
id|len
suffix:semicolon
)brace
multiline_comment|/*&n; * Get us a file in /proc/cciss that says something about each controller.&n; * Create /proc/cciss if it doesn&squot;t exist yet.&n; */
DECL|function|cciss_procinit
r_static
r_void
id|__init
id|cciss_procinit
c_func
(paren
r_int
id|i
)paren
(brace
r_if
c_cond
(paren
id|proc_cciss
op_eq
l_int|NULL
)paren
(brace
id|proc_cciss
op_assign
id|proc_mkdir
c_func
(paren
l_string|&quot;driver/cciss&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|proc_cciss
)paren
r_return
suffix:semicolon
)brace
id|create_proc_read_entry
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
comma
l_int|0
comma
id|proc_cciss
comma
id|cciss_proc_get_info
comma
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PROC_FS */
multiline_comment|/* &n; * For operations that cannot sleep, a command block is allocated at init, &n; * and managed by cmd_alloc() and cmd_free() using a simple bitmap to track&n; * which ones are free or in use.  For operations that can wait for kmalloc &n; * to possible sleep, this routine can be called with a NULL pointer. &n; * cmd_free() MUST be called with a NULL pointer if cmd_alloc was. &n; */
DECL|function|cmd_alloc
r_static
id|CommandList_struct
op_star
id|cmd_alloc
c_func
(paren
id|ctlr_info_t
op_star
id|h
)paren
(brace
id|CommandList_struct
op_star
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u64bit
id|temp64
suffix:semicolon
r_if
c_cond
(paren
id|h
op_eq
l_int|NULL
)paren
(brace
id|c
op_assign
(paren
id|CommandList_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|CommandList_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|NULL
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|c
comma
l_int|0
comma
r_sizeof
(paren
id|CommandList_struct
)paren
)paren
suffix:semicolon
id|c-&gt;err_info
op_assign
(paren
id|ErrorInfo_struct
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ErrorInfo_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;err_info
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|memset
c_func
(paren
id|c-&gt;err_info
comma
l_int|0
comma
r_sizeof
(paren
id|ErrorInfo_struct
)paren
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* get it out of the controllers pool */
(brace
r_do
(brace
id|i
op_assign
id|find_first_zero_bit
c_func
(paren
id|h-&gt;cmd_pool_bits
comma
id|NR_CMDS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|NR_CMDS
)paren
r_return
l_int|NULL
suffix:semicolon
)brace
r_while
c_loop
(paren
id|test_and_set_bit
c_func
(paren
id|i
op_mod
l_int|32
comma
id|h-&gt;cmd_pool_bits
op_plus
(paren
id|i
op_div
l_int|32
)paren
)paren
op_ne
l_int|0
)paren
(brace
suffix:semicolon
)brace
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cciss: using command buffer %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#endif
id|c
op_assign
id|h-&gt;cmd_pool
op_plus
id|i
suffix:semicolon
id|memset
c_func
(paren
id|c
comma
l_int|0
comma
r_sizeof
(paren
id|CommandList_struct
)paren
)paren
suffix:semicolon
id|c-&gt;err_info
op_assign
id|h-&gt;errinfo_pool
op_plus
id|i
suffix:semicolon
id|memset
c_func
(paren
id|c-&gt;err_info
comma
l_int|0
comma
r_sizeof
(paren
id|ErrorInfo_struct
)paren
)paren
suffix:semicolon
id|h-&gt;nr_allocs
op_increment
suffix:semicolon
)brace
id|temp64.val
op_assign
(paren
id|__u64
)paren
id|virt_to_bus
c_func
(paren
id|c-&gt;err_info
)paren
suffix:semicolon
id|c-&gt;ErrDesc.Addr.lower
op_assign
id|temp64.val32.lower
suffix:semicolon
id|c-&gt;ErrDesc.Addr.upper
op_assign
id|temp64.val32.upper
suffix:semicolon
id|c-&gt;ErrDesc.Len
op_assign
r_sizeof
(paren
id|ErrorInfo_struct
)paren
suffix:semicolon
id|c-&gt;busaddr
op_assign
id|virt_to_bus
c_func
(paren
id|c
)paren
suffix:semicolon
r_return
id|c
suffix:semicolon
)brace
multiline_comment|/* &n; * Frees a command block that was previously allocated with cmd_alloc(). &n; */
DECL|function|cmd_free
r_static
r_void
id|cmd_free
c_func
(paren
id|ctlr_info_t
op_star
id|h
comma
id|CommandList_struct
op_star
id|c
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|h
op_eq
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|c-&gt;err_info
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|c
)paren
suffix:semicolon
)brace
r_else
(brace
id|i
op_assign
id|c
op_minus
id|h-&gt;cmd_pool
suffix:semicolon
id|clear_bit
c_func
(paren
id|i
op_mod
l_int|32
comma
id|h-&gt;cmd_pool_bits
op_plus
(paren
id|i
op_div
l_int|32
)paren
)paren
suffix:semicolon
id|h-&gt;nr_frees
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*  &n; * fills in the disk information. &n; */
DECL|function|cciss_geninit
r_static
r_void
id|cciss_geninit
c_func
(paren
r_int
id|ctlr
)paren
(brace
id|drive_info_struct
op_star
id|drv
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/* Loop through each real device */
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|gendisk.nr_real
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NWD
suffix:semicolon
id|i
op_increment
)paren
(brace
id|drv
op_assign
op_amp
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|drv-&gt;nr_blocks
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|hd
(braket
id|i
op_lshift
id|NWD_SHIFT
)braket
dot
id|nr_sects
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|sizes
(braket
id|i
op_lshift
id|NWD_SHIFT
)braket
op_assign
id|drv-&gt;nr_blocks
suffix:semicolon
multiline_comment|/* for each partition */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|MAX_PART
suffix:semicolon
id|j
op_increment
)paren
(brace
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|blocksizes
(braket
(paren
id|i
op_lshift
id|NWD_SHIFT
)paren
op_plus
id|j
)braket
op_assign
l_int|1024
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|hardsizes
(braket
(paren
id|i
op_lshift
id|NWD_SHIFT
)paren
op_plus
id|j
)braket
op_assign
id|drv-&gt;block_size
suffix:semicolon
)brace
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|gendisk.nr_real
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Open.  Make sure the device is really there.&n; */
DECL|function|cciss_open
r_static
r_int
id|cciss_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
r_int
id|ctlr
op_assign
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_minus
id|MAJOR_NR
suffix:semicolon
r_int
id|dsk
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
id|NWD_SHIFT
suffix:semicolon
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cciss_open %x (%x:%x)&bslash;n&quot;
comma
id|inode-&gt;i_rdev
comma
id|ctlr
comma
id|dsk
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */ 
r_if
c_cond
(paren
id|ctlr
OG
id|MAX_CTLR
op_logical_or
id|hba
(braket
id|ctlr
)braket
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
op_logical_and
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|sizes
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/*&n;&t; * Root is allowed to open raw volume zero even if its not configured&n;&t; * so array config can still work.  I don&squot;t think I really like this,&n;&t; * but I&squot;m already using way to many device nodes to claim another one&n;&t; * for &quot;raw controller&quot;.&n;&t; */
r_if
c_cond
(paren
id|suser
c_func
(paren
)paren
op_logical_and
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|sizes
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
op_eq
l_int|0
)paren
op_logical_and
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_ne
l_int|0
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
dot
id|usage_count
op_increment
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|usage_count
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close.  Sync first.&n; */
DECL|function|cciss_release
r_static
r_int
id|cciss_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
)paren
(brace
r_int
id|ctlr
op_assign
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_minus
id|MAJOR_NR
suffix:semicolon
r_int
id|dsk
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
id|NWD_SHIFT
suffix:semicolon
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cciss_release %x (%x:%x)&bslash;n&quot;
comma
id|inode-&gt;i_rdev
comma
id|ctlr
comma
id|dsk
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */
multiline_comment|/* fsync_dev(inode-&gt;i_rdev); */
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
dot
id|usage_count
op_decrement
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|usage_count
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * ioctl &n; */
DECL|function|cciss_ioctl
r_static
r_int
id|cciss_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filep
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|ctlr
op_assign
id|MAJOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_minus
id|MAJOR_NR
suffix:semicolon
r_int
id|dsk
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
id|NWD_SHIFT
suffix:semicolon
r_int
id|diskinfo
(braket
l_int|4
)braket
suffix:semicolon
r_struct
id|hd_geometry
op_star
id|geo
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cciss_ioctl: Called with cmd=%x %lx&bslash;n&quot;
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */ 
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
r_if
c_cond
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
dot
id|cylinders
)paren
(brace
id|diskinfo
(braket
l_int|0
)braket
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
dot
id|heads
suffix:semicolon
id|diskinfo
(braket
l_int|1
)braket
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
dot
id|sectors
suffix:semicolon
id|diskinfo
(braket
l_int|2
)braket
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
dot
id|cylinders
suffix:semicolon
)brace
r_else
(brace
id|diskinfo
(braket
l_int|0
)braket
op_assign
l_int|0xff
suffix:semicolon
id|diskinfo
(braket
l_int|1
)braket
op_assign
l_int|0x3f
suffix:semicolon
id|diskinfo
(braket
l_int|2
)braket
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|dsk
)braket
dot
id|nr_blocks
op_div
(paren
l_int|0xff
op_star
l_int|0x3f
)paren
suffix:semicolon
)brace
id|put_user
c_func
(paren
id|diskinfo
(braket
l_int|0
)braket
comma
op_amp
id|geo-&gt;heads
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|diskinfo
(braket
l_int|1
)braket
comma
op_amp
id|geo-&gt;sectors
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|diskinfo
(braket
l_int|2
)braket
comma
op_amp
id|geo-&gt;cylinders
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|hd
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|start_sect
comma
op_amp
id|geo-&gt;start
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|put_user
c_func
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|hd
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|nr_sects
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRRPART
suffix:colon
r_return
id|revalidate_logvol
c_func
(paren
id|inode-&gt;i_rdev
comma
l_int|1
)paren
suffix:semicolon
r_case
id|BLKFLSBUF
suffix:colon
r_case
id|BLKROSET
suffix:colon
r_case
id|BLKROGET
suffix:colon
r_case
id|BLKRASET
suffix:colon
r_case
id|BLKRAGET
suffix:colon
r_case
id|BLKPG
suffix:colon
r_return
id|blk_ioctl
c_func
(paren
id|inode-&gt;i_rdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_case
id|CCISS_GETPCIINFO
suffix:colon
(brace
id|cciss_pci_info_struct
id|pciinfo
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|pciinfo.bus
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|pci_bus
suffix:semicolon
id|pciinfo.dev_fn
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|pci_dev_fn
suffix:semicolon
id|pciinfo.board_id
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|board_id
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|pciinfo
comma
r_sizeof
(paren
id|cciss_pci_info_struct
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CCISS_GETINTINFO
suffix:colon
(brace
id|cciss_coalint_struct
id|intinfo
suffix:semicolon
id|ctlr_info_t
op_star
id|c
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|intinfo.delay
op_assign
id|readl
c_func
(paren
op_amp
id|c-&gt;cfgtable-&gt;HostWrite.CoalIntDelay
)paren
suffix:semicolon
id|intinfo.count
op_assign
id|readl
c_func
(paren
op_amp
id|c-&gt;cfgtable-&gt;HostWrite.CoalIntCount
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|intinfo
comma
r_sizeof
(paren
id|cciss_coalint_struct
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CCISS_SETINTINFO
suffix:colon
(brace
id|cciss_coalint_struct
id|intinfo
suffix:semicolon
id|ctlr_info_t
op_star
id|c
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|intinfo
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|cciss_coalint_struct
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|intinfo.delay
op_eq
l_int|0
)paren
op_logical_and
(paren
id|intinfo.count
op_eq
l_int|0
)paren
)paren
(brace
singleline_comment|//&t;&t;&t;printk(&quot;cciss_ioctl: delay and count cannot be 0&bslash;n&quot;);
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Can only safely update if no commands outstanding */
r_if
c_cond
(paren
id|c-&gt;commands_outstanding
OG
l_int|0
)paren
(brace
singleline_comment|//&t;&t;&t;printk(&quot;cciss_ioctl: cannot change coalasing &quot;
singleline_comment|//&t;&t;&t;&t;&quot;%d commands outstanding on controller&bslash;n&quot;, 
singleline_comment|//&t;&t;&t;&t;&t;c-&gt;commands_outstanding);
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Update the field, and then ring the doorbell */
id|writel
c_func
(paren
id|intinfo.delay
comma
op_amp
(paren
id|c-&gt;cfgtable-&gt;HostWrite.CoalIntDelay
)paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|intinfo.count
comma
op_amp
(paren
id|c-&gt;cfgtable-&gt;HostWrite.CoalIntCount
)paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|CFGTBL_ChangeReq
comma
id|c-&gt;vaddr
op_plus
id|SA5_DOORBELL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_CONFIG_WAIT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
id|c-&gt;vaddr
op_plus
id|SA5_DOORBELL
)paren
op_amp
id|CFGTBL_ChangeReq
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* delay and try again */
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|MAX_CONFIG_WAIT
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CCISS_GETNODENAME
suffix:colon
(brace
id|NodeName_type
id|NodeName
suffix:semicolon
id|ctlr_info_t
op_star
id|c
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|NodeName
(braket
id|i
)braket
op_assign
id|readb
c_func
(paren
op_amp
id|c-&gt;cfgtable-&gt;ServerName
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|NodeName
comma
r_sizeof
(paren
id|NodeName_type
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CCISS_SETNODENAME
suffix:colon
(brace
id|NodeName_type
id|NodeName
suffix:semicolon
id|ctlr_info_t
op_star
id|c
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|NodeName
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|NodeName_type
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Update the field, and then ring the doorbell */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|writeb
c_func
(paren
id|NodeName
(braket
id|i
)braket
comma
op_amp
id|c-&gt;cfgtable-&gt;ServerName
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|writel
c_func
(paren
id|CFGTBL_ChangeReq
comma
id|c-&gt;vaddr
op_plus
id|SA5_DOORBELL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_CONFIG_WAIT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
id|c-&gt;vaddr
op_plus
id|SA5_DOORBELL
)paren
op_amp
id|CFGTBL_ChangeReq
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* delay and try again */
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|MAX_CONFIG_WAIT
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CCISS_GETHEARTBEAT
suffix:colon
(brace
id|Heartbeat_type
id|heartbeat
suffix:semicolon
id|ctlr_info_t
op_star
id|c
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|heartbeat
op_assign
id|readl
c_func
(paren
op_amp
id|c-&gt;cfgtable-&gt;HeartBeat
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|heartbeat
comma
r_sizeof
(paren
id|Heartbeat_type
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CCISS_GETBUSTYPES
suffix:colon
(brace
id|BusTypes_type
id|BusTypes
suffix:semicolon
id|ctlr_info_t
op_star
id|c
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|BusTypes
op_assign
id|readl
c_func
(paren
op_amp
id|c-&gt;cfgtable-&gt;BusTypes
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|BusTypes
comma
r_sizeof
(paren
id|BusTypes_type
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CCISS_GETFIRMVER
suffix:colon
(brace
id|FirmwareVer_type
id|firmware
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|memcpy
c_func
(paren
id|firmware
comma
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|firm_ver
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
id|firmware
comma
r_sizeof
(paren
id|FirmwareVer_type
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CCISS_GETDRIVVER
suffix:colon
(brace
id|DriverVer_type
id|DriverVer
op_assign
id|DRIVER_VERSION
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|DriverVer
comma
r_sizeof
(paren
id|DriverVer_type
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CCISS_REVALIDVOLS
suffix:colon
r_return
id|revalidate_allvol
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_case
id|CCISS_PASSTHRU
suffix:colon
(brace
id|IOCTL_Command_struct
id|iocommand
suffix:semicolon
id|ctlr_info_t
op_star
id|h
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
id|CommandList_struct
op_star
id|c
suffix:semicolon
r_char
op_star
id|buff
op_assign
l_int|NULL
suffix:semicolon
id|u64bit
id|temp64
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_RAWIO
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|iocommand
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|IOCTL_Command_struct
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|iocommand.buf_size
OL
l_int|1
)paren
op_logical_and
(paren
id|iocommand.Request.Type.Direction
op_ne
id|XFER_NONE
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
multiline_comment|/* Check kmalloc limits */
r_if
c_cond
(paren
id|iocommand.buf_size
OG
l_int|128000
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iocommand.buf_size
OG
l_int|0
)paren
(brace
id|buff
op_assign
id|kmalloc
c_func
(paren
id|iocommand.buf_size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_eq
l_int|NULL
)paren
(brace
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|iocommand.Request.Type.Direction
op_eq
id|XFER_WRITE
)paren
(brace
multiline_comment|/* Copy the data into the buffer we created */
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
id|buff
comma
id|iocommand.buf
comma
id|iocommand.buf_size
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|c
op_assign
id|cmd_alloc
c_func
(paren
l_int|NULL
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|buff
op_ne
l_int|NULL
)paren
(brace
id|kfree
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
singleline_comment|// Fill in the command type 
id|c-&gt;cmd_type
op_assign
id|CMD_IOCTL_PEND
suffix:semicolon
singleline_comment|// Fill in Command Header 
id|c-&gt;Header.ReplyQueue
op_assign
l_int|0
suffix:semicolon
singleline_comment|// unused in simple mode
r_if
c_cond
(paren
id|iocommand.buf_size
OG
l_int|0
)paren
singleline_comment|// buffer to fill 
(brace
id|c-&gt;Header.SGList
op_assign
l_int|1
suffix:semicolon
id|c-&gt;Header.SGTotal
op_assign
l_int|1
suffix:semicolon
)brace
r_else
singleline_comment|// no buffers to fill  
(brace
id|c-&gt;Header.SGList
op_assign
l_int|0
suffix:semicolon
id|c-&gt;Header.SGTotal
op_assign
l_int|0
suffix:semicolon
)brace
id|c-&gt;Header.LUN
op_assign
id|iocommand.LUN_info
suffix:semicolon
id|c-&gt;Header.Tag.lower
op_assign
id|c-&gt;busaddr
suffix:semicolon
singleline_comment|// use the kernel address the cmd block for tag
singleline_comment|// Fill in Request block 
id|c-&gt;Request
op_assign
id|iocommand.Request
suffix:semicolon
singleline_comment|// Fill in the scatter gather information
r_if
c_cond
(paren
id|iocommand.buf_size
OG
l_int|0
)paren
(brace
id|temp64.val
op_assign
(paren
id|__u64
)paren
id|virt_to_bus
c_func
(paren
id|buff
)paren
suffix:semicolon
id|c-&gt;SG
(braket
l_int|0
)braket
dot
id|Addr.lower
op_assign
id|temp64.val32.lower
suffix:semicolon
id|c-&gt;SG
(braket
l_int|0
)braket
dot
id|Addr.upper
op_assign
id|temp64.val32.upper
suffix:semicolon
id|c-&gt;SG
(braket
l_int|0
)braket
dot
id|Len
op_assign
id|iocommand.buf_size
suffix:semicolon
id|c-&gt;SG
(braket
l_int|0
)braket
dot
id|Ext
op_assign
l_int|0
suffix:semicolon
singleline_comment|// we are not chaining
)brace
multiline_comment|/* Put the request on the tail of the request queue */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|addQ
c_func
(paren
op_amp
id|h-&gt;reqQ
comma
id|c
)paren
suffix:semicolon
id|h-&gt;Qdepth
op_increment
suffix:semicolon
id|start_io
c_func
(paren
id|h
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
multiline_comment|/* Wait for completion */
r_while
c_loop
(paren
id|c-&gt;cmd_type
op_ne
id|CMD_IOCTL_DONE
)paren
(brace
id|schedule_timeout
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* Copy the error information out */
id|iocommand.error_info
op_assign
op_star
(paren
id|c-&gt;err_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|iocommand
comma
r_sizeof
(paren
id|IOCTL_Command_struct
)paren
)paren
)paren
(brace
id|cmd_free
c_func
(paren
l_int|NULL
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|buff
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_if
c_cond
(paren
id|iocommand.Request.Type.Direction
op_eq
id|XFER_READ
)paren
(brace
multiline_comment|/* Copy the data out of the buffer we created */
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
id|iocommand.buf
comma
id|buff
comma
id|iocommand.buf_size
)paren
)paren
(brace
id|cmd_free
c_func
(paren
l_int|NULL
comma
id|c
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|buff
)paren
suffix:semicolon
)brace
)brace
id|cmd_free
c_func
(paren
l_int|NULL
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|buff
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|buff
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EBADRQC
suffix:semicolon
)brace
)brace
multiline_comment|/* Borrowed and adapted from sd.c */
DECL|function|revalidate_logvol
r_static
r_int
id|revalidate_logvol
c_func
(paren
id|kdev_t
id|dev
comma
r_int
id|maxusage
)paren
(brace
r_int
id|ctlr
comma
id|target
suffix:semicolon
r_struct
id|gendisk
op_star
id|gdev
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|max_p
suffix:semicolon
r_int
id|start
suffix:semicolon
r_int
id|i
suffix:semicolon
id|target
op_assign
id|MINOR
c_func
(paren
id|dev
)paren
op_rshift
id|NWD_SHIFT
suffix:semicolon
id|ctlr
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
op_minus
id|MAJOR_NR
suffix:semicolon
id|gdev
op_assign
op_amp
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|gendisk
)paren
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|target
)braket
dot
id|usage_count
OG
id|maxusage
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Device busy for &quot;
l_string|&quot;revalidation (usage=%d)&bslash;n&quot;
comma
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|target
)braket
dot
id|usage_count
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|target
)braket
dot
id|usage_count
op_increment
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|max_p
op_assign
id|gdev-&gt;max_p
suffix:semicolon
id|start
op_assign
id|target
op_lshift
id|gdev-&gt;minor_shift
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|max_p
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_int
id|minor
op_assign
id|start
op_plus
id|i
suffix:semicolon
id|kdev_t
id|devi
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
op_plus
id|ctlr
comma
id|minor
)paren
suffix:semicolon
r_struct
id|super_block
op_star
id|sb
op_assign
id|get_super
c_func
(paren
id|devi
)paren
suffix:semicolon
id|sync_dev
c_func
(paren
id|devi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
)paren
id|invalidate_inodes
c_func
(paren
id|sb
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|devi
)paren
suffix:semicolon
id|gdev-&gt;part
(braket
id|minor
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|gdev-&gt;part
(braket
id|minor
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset the blocksize so we can read the partition table */
id|blksize_size
(braket
id|MAJOR_NR
op_plus
id|ctlr
)braket
(braket
id|minor
)braket
op_assign
l_int|1024
suffix:semicolon
)brace
multiline_comment|/* setup partitions per disk */
id|grok_partitions
c_func
(paren
id|gdev
comma
id|target
comma
id|MAX_PART
comma
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|target
)braket
dot
id|nr_blocks
)paren
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|target
)braket
dot
id|usage_count
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|frevalidate_logvol
r_static
r_int
id|frevalidate_logvol
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cciss: frevalidate has been called&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */ 
r_return
id|revalidate_logvol
c_func
(paren
id|dev
comma
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * revalidate_allvol is for online array config utilities.  After a&n; * utility reconfigures the drives in the array, it can use this function&n; * (through an ioctl) to make the driver zap any previous disk structs for&n; * that controller and get new ones.&n; *&n; * Right now I&squot;m using the getgeometry() function to do this, but this&n; * function should probably be finer grained and allow you to revalidate one&n; * particualar logical volume (instead of all of them on a particular&n; * controller).&n; */
DECL|function|revalidate_allvol
r_static
r_int
id|revalidate_allvol
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|ctlr
comma
id|i
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|ctlr
op_assign
id|MAJOR
c_func
(paren
id|dev
)paren
op_minus
id|MAJOR_NR
suffix:semicolon
r_if
c_cond
(paren
id|MINOR
c_func
(paren
id|dev
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|usage_count
OG
l_int|1
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: Device busy for volume&quot;
l_string|&quot; revalidation (usage=%d)&bslash;n&quot;
comma
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|usage_count
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|usage_count
op_increment
suffix:semicolon
multiline_comment|/*&n;         * Set the partition and block size structures for all volumes&n;         * on this controller to zero.  We will reread all of this data&n;         */
id|memset
c_func
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|hd
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|hd_struct
)paren
op_star
l_int|256
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|sizes
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
l_int|256
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|blocksizes
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
l_int|256
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|hardsizes
comma
l_int|0
comma
r_sizeof
(paren
r_int
)paren
op_star
l_int|256
)paren
suffix:semicolon
id|memset
c_func
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
comma
l_int|0
comma
r_sizeof
(paren
id|drive_info_struct
)paren
op_star
id|CISS_MAX_LUN
)paren
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|gendisk.nr_real
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;         * Tell the array controller not to give us any interupts while&n;         * we check the new geometry.  Then turn interrupts back on when&n;         * we&squot;re done.&n;         */
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|access
dot
id|set_intr_mask
c_func
(paren
id|hba
(braket
id|ctlr
)braket
comma
id|CCISS_INTR_OFF
)paren
suffix:semicolon
id|cciss_getgeometry
c_func
(paren
id|ctlr
)paren
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|access
dot
id|set_intr_mask
c_func
(paren
id|hba
(braket
id|ctlr
)braket
comma
id|CCISS_INTR_ON
)paren
suffix:semicolon
id|cciss_geninit
c_func
(paren
id|ctlr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NWD
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|sizes
(braket
id|i
op_lshift
id|NWD_SHIFT
)braket
)paren
id|revalidate_logvol
c_func
(paren
id|dev
op_plus
(paren
id|i
op_lshift
id|NWD_SHIFT
)paren
comma
l_int|2
)paren
suffix:semicolon
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|usage_count
op_decrement
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; *   Wait polling for a command to complete.&n; *   The memory mapped FIFO is polled for the completion.&n; *   Used only at init time, interrupts disabled.&n; */
DECL|function|pollcomplete
r_static
r_int
r_int
id|pollcomplete
c_func
(paren
r_int
id|ctlr
)paren
(brace
r_int
r_int
id|done
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Wait (up to 2 seconds) for a command to complete */
r_for
c_loop
(paren
id|i
op_assign
l_int|200000
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
id|done
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|access
dot
id|command_completed
c_func
(paren
id|hba
(braket
id|ctlr
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|done
op_eq
id|FIFO_EMPTY
)paren
(brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* a short fixed delay */
)brace
r_else
r_return
(paren
id|done
)paren
suffix:semicolon
)brace
multiline_comment|/* Invalid address to tell caller we ran out of time */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a command to the controller, and wait for it to complete.  &n; * Only used at init time. &n; */
DECL|function|sendcmd
r_static
r_int
id|sendcmd
c_func
(paren
id|__u8
id|cmd
comma
r_int
id|ctlr
comma
r_void
op_star
id|buff
comma
r_int
id|size
comma
r_int
r_int
id|use_unit_num
comma
r_int
r_int
id|log_unit
comma
id|__u8
id|page_code
)paren
(brace
id|CommandList_struct
op_star
id|c
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|complete
suffix:semicolon
id|ctlr_info_t
op_star
id|info_p
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
id|u64bit
id|temp64
suffix:semicolon
id|c
op_assign
id|cmd_alloc
c_func
(paren
id|info_p
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: unable to get memory&quot;
)paren
suffix:semicolon
r_return
id|IO_ERROR
suffix:semicolon
)brace
singleline_comment|// Fill in Command Header 
id|c-&gt;Header.ReplyQueue
op_assign
l_int|0
suffix:semicolon
singleline_comment|// unused in simple mode
r_if
c_cond
(paren
id|buff
op_ne
l_int|NULL
)paren
singleline_comment|// buffer to fill 
(brace
id|c-&gt;Header.SGList
op_assign
l_int|1
suffix:semicolon
id|c-&gt;Header.SGTotal
op_assign
l_int|1
suffix:semicolon
)brace
r_else
singleline_comment|// no buffers to fill  
(brace
id|c-&gt;Header.SGList
op_assign
l_int|0
suffix:semicolon
id|c-&gt;Header.SGTotal
op_assign
l_int|0
suffix:semicolon
)brace
id|c-&gt;Header.Tag.lower
op_assign
id|c-&gt;busaddr
suffix:semicolon
singleline_comment|// use the kernel address the cmd block for tag
singleline_comment|// Fill in Request block &t;
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CISS_INQUIRY
suffix:colon
multiline_comment|/* If the logical unit number is 0 then, this is going&n;&t;&t;&t;&t;to controller so It&squot;s a physical command&n;&t;&t;&t;&t;mode = 0 target = 0.&n;&t;&t;&t;&t;So we have nothing to write. &n;&t;&t;&t;&t;Otherwise &n;&t;&t;&t;&t;mode = 1  target = LUNID&n;&t;&t;&t;*/
r_if
c_cond
(paren
id|use_unit_num
op_ne
l_int|0
)paren
(brace
id|c-&gt;Header.LUN.LogDev.VolId
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|log_unit
)braket
dot
id|LunID
suffix:semicolon
id|c-&gt;Header.LUN.LogDev.Mode
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* are we trying to read a vital product page */
r_if
c_cond
(paren
id|page_code
op_ne
l_int|0
)paren
(brace
id|c-&gt;Request.CDB
(braket
l_int|1
)braket
op_assign
l_int|0x01
suffix:semicolon
id|c-&gt;Request.CDB
(braket
l_int|2
)braket
op_assign
id|page_code
suffix:semicolon
)brace
id|c-&gt;Request.CDBLen
op_assign
l_int|6
suffix:semicolon
id|c-&gt;Request.Type.Type
op_assign
id|TYPE_CMD
suffix:semicolon
singleline_comment|// It is a command. 
id|c-&gt;Request.Type.Attribute
op_assign
id|ATTR_SIMPLE
suffix:semicolon
id|c-&gt;Request.Type.Direction
op_assign
id|XFER_READ
suffix:semicolon
singleline_comment|// Read 
id|c-&gt;Request.Timeout
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Don&squot;t time out 
id|c-&gt;Request.CDB
(braket
l_int|0
)braket
op_assign
id|CISS_INQUIRY
suffix:semicolon
id|c-&gt;Request.CDB
(braket
l_int|4
)braket
op_assign
id|size
op_amp
l_int|0xFF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CISS_REPORT_LOG
suffix:colon
multiline_comment|/* Talking to controller so It&squot;s a physical command&n;                                mode = 00 target = 0.&n;                                So we have nothing to write.&n;                        */
id|c-&gt;Request.CDBLen
op_assign
l_int|12
suffix:semicolon
id|c-&gt;Request.Type.Type
op_assign
id|TYPE_CMD
suffix:semicolon
singleline_comment|// It is a command.
id|c-&gt;Request.Type.Attribute
op_assign
id|ATTR_SIMPLE
suffix:semicolon
id|c-&gt;Request.Type.Direction
op_assign
id|XFER_READ
suffix:semicolon
singleline_comment|// Read
id|c-&gt;Request.Timeout
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Don&squot;t time out
id|c-&gt;Request.CDB
(braket
l_int|0
)braket
op_assign
id|CISS_REPORT_LOG
suffix:semicolon
id|c-&gt;Request.CDB
(braket
l_int|6
)braket
op_assign
(paren
id|size
op_rshift
l_int|24
)paren
op_amp
l_int|0xFF
suffix:semicolon
singleline_comment|//MSB
id|c-&gt;Request.CDB
(braket
l_int|7
)braket
op_assign
(paren
id|size
op_rshift
l_int|16
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|c-&gt;Request.CDB
(braket
l_int|8
)braket
op_assign
(paren
id|size
op_rshift
l_int|8
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|c-&gt;Request.CDB
(braket
l_int|9
)braket
op_assign
id|size
op_amp
l_int|0xFF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CCISS_READ_CAPACITY
suffix:colon
id|c-&gt;Header.LUN.LogDev.VolId
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|log_unit
)braket
dot
id|LunID
suffix:semicolon
id|c-&gt;Header.LUN.LogDev.Mode
op_assign
l_int|1
suffix:semicolon
id|c-&gt;Request.CDBLen
op_assign
l_int|10
suffix:semicolon
id|c-&gt;Request.Type.Type
op_assign
id|TYPE_CMD
suffix:semicolon
singleline_comment|// It is a command.
id|c-&gt;Request.Type.Attribute
op_assign
id|ATTR_SIMPLE
suffix:semicolon
id|c-&gt;Request.Type.Direction
op_assign
id|XFER_READ
suffix:semicolon
singleline_comment|// Read
id|c-&gt;Request.Timeout
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Don&squot;t time out
id|c-&gt;Request.CDB
(braket
l_int|0
)braket
op_assign
id|CCISS_READ_CAPACITY
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss:  Unknown Command 0x%c sent attempted&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|info_p
comma
id|c
)paren
suffix:semicolon
r_return
id|IO_ERROR
suffix:semicolon
)brace
suffix:semicolon
singleline_comment|// Fill in the scatter gather information
r_if
c_cond
(paren
id|size
OG
l_int|0
)paren
(brace
id|temp64.val
op_assign
(paren
id|__u64
)paren
id|virt_to_bus
c_func
(paren
id|buff
)paren
suffix:semicolon
id|c-&gt;SG
(braket
l_int|0
)braket
dot
id|Addr.lower
op_assign
id|temp64.val32.lower
suffix:semicolon
id|c-&gt;SG
(braket
l_int|0
)braket
dot
id|Addr.upper
op_assign
id|temp64.val32.upper
suffix:semicolon
id|c-&gt;SG
(braket
l_int|0
)braket
dot
id|Len
op_assign
id|size
suffix:semicolon
id|c-&gt;SG
(braket
l_int|0
)braket
dot
id|Ext
op_assign
l_int|0
suffix:semicolon
singleline_comment|// we are not chaining
)brace
multiline_comment|/*&n;         * Disable interrupt&n;         */
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cciss: turning intr off&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */ 
id|info_p-&gt;access
dot
id|set_intr_mask
c_func
(paren
id|info_p
comma
id|CCISS_INTR_OFF
)paren
suffix:semicolon
multiline_comment|/* Make sure there is room in the command FIFO */
multiline_comment|/* Actually it should be completely empty at this time. */
r_for
c_loop
(paren
id|i
op_assign
l_int|200000
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
multiline_comment|/* if fifo isn&squot;t full go */
r_if
c_cond
(paren
op_logical_neg
(paren
id|info_p-&gt;access
dot
id|fifo_full
c_func
(paren
id|info_p
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss cciss%d: SendCmd FIFO full,&quot;
l_string|&quot; waiting!&bslash;n&quot;
comma
id|ctlr
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * Send the cmd&n;         */
id|info_p-&gt;access
dot
id|submit_command
c_func
(paren
id|info_p
comma
id|c
)paren
suffix:semicolon
id|complete
op_assign
id|pollcomplete
c_func
(paren
id|ctlr
)paren
suffix:semicolon
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cciss: command completed&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */
r_if
c_cond
(paren
id|complete
op_ne
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
id|complete
op_amp
id|CISS_ERROR_BIT
)paren
op_logical_and
(paren
id|complete
op_amp
op_complement
id|CISS_ERROR_BIT
)paren
op_eq
id|c-&gt;busaddr
)paren
(brace
multiline_comment|/* if data overrun or underun on Report command &n;&t;&t;&t;&t;ignore it &n;&t;&t;&t;*/
r_if
c_cond
(paren
(paren
(paren
id|c-&gt;Request.CDB
(braket
l_int|0
)braket
op_eq
id|CISS_REPORT_LOG
)paren
op_logical_or
(paren
id|c-&gt;Request.CDB
(braket
l_int|0
)braket
op_eq
id|CISS_INQUIRY
)paren
)paren
op_logical_and
(paren
(paren
id|c-&gt;err_info-&gt;CommandStatus
op_eq
id|CMD_DATA_OVERRUN
)paren
op_logical_or
(paren
id|c-&gt;err_info-&gt;CommandStatus
op_eq
id|CMD_DATA_UNDERRUN
)paren
)paren
)paren
(brace
id|complete
op_assign
id|c-&gt;busaddr
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ciss ciss%d: sendcmd&quot;
l_string|&quot; Error %x &bslash;n&quot;
comma
id|ctlr
comma
id|c-&gt;err_info-&gt;CommandStatus
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ciss ciss%d: sendcmd&quot;
l_string|&quot; offensive info&bslash;n&quot;
l_string|&quot;  size %x&bslash;n   num %x   value %x&bslash;n&quot;
comma
id|ctlr
comma
id|c-&gt;err_info-&gt;MoreErrInfo.Invalid_Cmd.offense_size
comma
id|c-&gt;err_info-&gt;MoreErrInfo.Invalid_Cmd.offense_num
comma
id|c-&gt;err_info-&gt;MoreErrInfo.Invalid_Cmd.offense_value
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|info_p
comma
id|c
)paren
suffix:semicolon
r_return
id|IO_ERROR
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|complete
op_ne
id|c-&gt;busaddr
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss cciss%d: SendCmd &quot;
l_string|&quot;Invalid command list address returned! (%lx)&bslash;n&quot;
comma
id|ctlr
comma
id|complete
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|info_p
comma
id|c
)paren
suffix:semicolon
r_return
(paren
id|IO_ERROR
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss cciss%d: SendCmd Timeout out, &quot;
l_string|&quot;No command list address returned!&bslash;n&quot;
comma
id|ctlr
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|info_p
comma
id|c
)paren
suffix:semicolon
r_return
(paren
id|IO_ERROR
)paren
suffix:semicolon
)brace
id|cmd_free
c_func
(paren
id|info_p
comma
id|c
)paren
suffix:semicolon
r_return
(paren
id|IO_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Map (physical) PCI mem into (virtual) kernel space&n; */
DECL|function|remap_pci_mem
r_static
id|ulong
id|remap_pci_mem
c_func
(paren
id|ulong
id|base
comma
id|ulong
id|size
)paren
(brace
id|ulong
id|page_base
op_assign
(paren
(paren
id|ulong
)paren
id|base
)paren
op_amp
id|PAGE_MASK
suffix:semicolon
id|ulong
id|page_offs
op_assign
(paren
(paren
id|ulong
)paren
id|base
)paren
op_minus
id|page_base
suffix:semicolon
id|ulong
id|page_remapped
op_assign
(paren
id|ulong
)paren
id|ioremap
c_func
(paren
id|page_base
comma
id|page_offs
op_plus
id|size
)paren
suffix:semicolon
r_return
(paren
id|ulong
)paren
(paren
id|page_remapped
ques
c_cond
(paren
id|page_remapped
op_plus
id|page_offs
)paren
suffix:colon
l_int|0UL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Enqueuing and dequeuing functions for cmdlists.&n; */
DECL|function|addQ
r_static
r_inline
r_void
id|addQ
c_func
(paren
id|CommandList_struct
op_star
op_star
id|Qptr
comma
id|CommandList_struct
op_star
id|c
)paren
(brace
r_if
c_cond
(paren
op_star
id|Qptr
op_eq
l_int|NULL
)paren
(brace
op_star
id|Qptr
op_assign
id|c
suffix:semicolon
id|c-&gt;next
op_assign
id|c-&gt;prev
op_assign
id|c
suffix:semicolon
)brace
r_else
(brace
id|c-&gt;prev
op_assign
(paren
op_star
id|Qptr
)paren
op_member_access_from_pointer
id|prev
suffix:semicolon
id|c-&gt;next
op_assign
(paren
op_star
id|Qptr
)paren
suffix:semicolon
(paren
op_star
id|Qptr
)paren
op_member_access_from_pointer
id|prev-&gt;next
op_assign
id|c
suffix:semicolon
(paren
op_star
id|Qptr
)paren
op_member_access_from_pointer
id|prev
op_assign
id|c
suffix:semicolon
)brace
)brace
DECL|function|removeQ
r_static
r_inline
id|CommandList_struct
op_star
id|removeQ
c_func
(paren
id|CommandList_struct
op_star
op_star
id|Qptr
comma
id|CommandList_struct
op_star
id|c
)paren
(brace
r_if
c_cond
(paren
id|c
op_logical_and
id|c-&gt;next
op_ne
id|c
)paren
(brace
r_if
c_cond
(paren
op_star
id|Qptr
op_eq
id|c
)paren
op_star
id|Qptr
op_assign
id|c-&gt;next
suffix:semicolon
id|c-&gt;prev-&gt;next
op_assign
id|c-&gt;next
suffix:semicolon
id|c-&gt;next-&gt;prev
op_assign
id|c-&gt;prev
suffix:semicolon
)brace
r_else
(brace
op_star
id|Qptr
op_assign
l_int|NULL
suffix:semicolon
)brace
r_return
id|c
suffix:semicolon
)brace
multiline_comment|/* &n; * Takes jobs of the Q and sends them to the hardware, then puts it on &n; * the Q to wait for completion. &n; */
DECL|function|start_io
r_static
r_void
id|start_io
c_func
(paren
id|ctlr_info_t
op_star
id|h
)paren
(brace
id|CommandList_struct
op_star
id|c
suffix:semicolon
r_while
c_loop
(paren
(paren
id|c
op_assign
id|h-&gt;reqQ
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* can&squot;t do anything if fifo is full */
r_if
c_cond
(paren
(paren
id|h-&gt;access
dot
id|fifo_full
c_func
(paren
id|h
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: fifo full &bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Get the frist entry from the Request Q */
id|removeQ
c_func
(paren
op_amp
(paren
id|h-&gt;reqQ
)paren
comma
id|c
)paren
suffix:semicolon
id|h-&gt;Qdepth
op_decrement
suffix:semicolon
multiline_comment|/* Tell the controller execute command */
id|h-&gt;access
dot
id|submit_command
c_func
(paren
id|h
comma
id|c
)paren
suffix:semicolon
multiline_comment|/* Put job onto the completed Q */
id|addQ
(paren
op_amp
(paren
id|h-&gt;cmpQ
)paren
comma
id|c
)paren
suffix:semicolon
)brace
)brace
DECL|function|complete_buffers
r_static
r_inline
r_void
id|complete_buffers
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
comma
r_int
id|status
)paren
(brace
r_struct
id|buffer_head
op_star
id|xbh
suffix:semicolon
r_while
c_loop
(paren
id|bh
)paren
(brace
id|xbh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
id|bh
op_member_access_from_pointer
id|b_end_io
c_func
(paren
id|bh
comma
id|status
)paren
suffix:semicolon
id|bh
op_assign
id|xbh
suffix:semicolon
)brace
)brace
multiline_comment|/* checks the status of the job and calls complete buffers to mark all &n; * buffers for the completed job. &n; */
DECL|function|complete_command
r_static
r_inline
r_void
id|complete_command
c_func
(paren
id|CommandList_struct
op_star
id|cmd
comma
r_int
id|timeout
)paren
(brace
r_int
id|status
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|timeout
)paren
id|status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;err_info-&gt;CommandStatus
op_ne
l_int|0
)paren
(brace
multiline_comment|/* an error has occured */
r_switch
c_cond
(paren
id|cmd-&gt;err_info-&gt;CommandStatus
)paren
(brace
r_case
id|CMD_TARGET_STATUS
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p has &quot;
l_string|&quot; completed with errors&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd-&gt;err_info-&gt;ScsiStatus
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p &quot;
l_string|&quot;has SCSI Status = %x&bslash;n&quot;
comma
id|cmd
comma
id|cmd-&gt;err_info-&gt;ScsiStatus
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|CMD_DATA_UNDERRUN
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p has&quot;
l_string|&quot; completed with data underrun &quot;
l_string|&quot;reported&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_DATA_OVERRUN
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p has&quot;
l_string|&quot; completed with data overrun &quot;
l_string|&quot;reported&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_INVALID
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p is &quot;
l_string|&quot;reported invalid&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_PROTOCOL_ERR
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p has &quot;
l_string|&quot;protocol error &bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_HARDWARE_ERR
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p had &quot;
l_string|&quot; hardware error&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_CONNECTION_LOST
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p had &quot;
l_string|&quot;connection lost&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_ABORTED
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p was &quot;
l_string|&quot;aborted&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_ABORT_FAILED
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p reports &quot;
l_string|&quot;abort failed&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_UNSOLICITED_ABORT
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p aborted &quot;
l_string|&quot;do to an unsolicited abort&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|CMD_TIMEOUT
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p timedout&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: cmd %p returned &quot;
l_string|&quot;unknown status %x&bslash;n&quot;
comma
id|cmd
comma
id|cmd-&gt;err_info-&gt;CommandStatus
)paren
suffix:semicolon
id|status
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|complete_buffers
c_func
(paren
id|cmd-&gt;bh
comma
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; * Get a request and submit it to the controller. &n; * Currently we do one request at a time.  Ideally we would like to send&n; * everything to the controller on the first call, but there is a danger&n; * of holding the io_request_lock for to long.  &n; */
DECL|function|do_cciss_request
r_static
r_void
id|do_cciss_request
c_func
(paren
r_int
id|ctlr
)paren
(brace
id|ctlr_info_t
op_star
id|h
op_assign
id|hba
(braket
id|ctlr
)braket
suffix:semicolon
id|CommandList_struct
op_star
id|c
suffix:semicolon
r_int
id|log_unit
comma
id|start_blk
comma
id|seg
comma
id|sect
suffix:semicolon
r_char
op_star
id|lastdataend
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_struct
id|list_head
op_star
id|queue_head
suffix:semicolon
r_struct
id|request
op_star
id|creq
suffix:semicolon
id|u64bit
id|temp64
suffix:semicolon
id|queue_head
op_assign
op_amp
id|blk_dev
(braket
id|MAJOR_NR
op_plus
id|ctlr
)braket
dot
id|request_queue.queue_head
suffix:semicolon
r_if
c_cond
(paren
id|list_empty
c_func
(paren
id|queue_head
)paren
)paren
(brace
multiline_comment|/* nothing to do... */
id|start_io
c_func
(paren
id|h
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|creq
op_assign
id|blkdev_entry_next_request
c_func
(paren
id|queue_head
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|creq
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|creq-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
)paren
(brace
multiline_comment|/* nothing to do... restart processing and return */
id|start_io
c_func
(paren
id|h
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ctlr
op_ne
(paren
id|MAJOR
c_func
(paren
id|creq-&gt;rq_dev
)paren
op_minus
id|MAJOR_NR
)paren
)paren
op_logical_or
(paren
id|ctlr
OG
id|nr_ctlr
)paren
op_logical_or
(paren
id|h
op_eq
l_int|NULL
)paren
)paren
(brace
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: doreq cmd of %d, %x at %p&bslash;n&quot;
comma
id|ctlr
comma
id|creq-&gt;rq_dev
comma
id|creq
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */
id|complete_buffers
c_func
(paren
id|creq-&gt;bh
comma
l_int|0
)paren
suffix:semicolon
id|start_io
c_func
(paren
id|h
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|c
op_assign
id|cmd_alloc
c_func
(paren
id|h
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
id|start_io
c_func
(paren
id|h
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|c-&gt;cmd_type
op_assign
id|CMD_RWREQ
suffix:semicolon
id|bh
op_assign
id|c-&gt;bh
op_assign
id|creq-&gt;bh
suffix:semicolon
multiline_comment|/* fill in the request */
id|log_unit
op_assign
id|MINOR
c_func
(paren
id|creq-&gt;rq_dev
)paren
op_rshift
id|NWD_SHIFT
suffix:semicolon
id|c-&gt;Header.ReplyQueue
op_assign
l_int|0
suffix:semicolon
singleline_comment|// unused in simple mode
id|c-&gt;Header.Tag.lower
op_assign
id|c-&gt;busaddr
suffix:semicolon
singleline_comment|// use the physical address the cmd block for tag
id|c-&gt;Header.LUN.LogDev.VolId
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|drv
(braket
id|log_unit
)braket
dot
id|LunID
suffix:semicolon
id|c-&gt;Header.LUN.LogDev.Mode
op_assign
l_int|1
suffix:semicolon
id|c-&gt;Request.CDBLen
op_assign
l_int|10
suffix:semicolon
singleline_comment|// 12 byte commands not in FW yet;
id|c-&gt;Request.Type.Type
op_assign
id|TYPE_CMD
suffix:semicolon
singleline_comment|// It is a command. 
id|c-&gt;Request.Type.Attribute
op_assign
id|ATTR_SIMPLE
suffix:semicolon
id|c-&gt;Request.Type.Direction
op_assign
(paren
id|creq-&gt;cmd
op_eq
id|READ
)paren
ques
c_cond
id|XFER_READ
suffix:colon
id|XFER_WRITE
suffix:semicolon
id|c-&gt;Request.Timeout
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Don&squot;t time out&t;
id|c-&gt;Request.CDB
(braket
l_int|0
)braket
op_assign
(paren
id|creq-&gt;cmd
op_eq
id|READ
)paren
ques
c_cond
id|CCISS_READ
suffix:colon
id|CCISS_WRITE
suffix:semicolon
id|start_blk
op_assign
id|hba
(braket
id|ctlr
)braket
op_member_access_from_pointer
id|hd
(braket
id|MINOR
c_func
(paren
id|creq-&gt;rq_dev
)paren
)braket
dot
id|start_sect
op_plus
id|creq-&gt;sector
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
id|panic
c_func
(paren
l_string|&quot;cciss: bh== NULL?&quot;
)paren
suffix:semicolon
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ciss: sector =%d nr_sectors=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|creq-&gt;sector
comma
(paren
r_int
)paren
id|creq-&gt;nr_sectors
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */
id|seg
op_assign
l_int|0
suffix:semicolon
id|lastdataend
op_assign
l_int|NULL
suffix:semicolon
id|sect
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|bh
)paren
(brace
id|sect
op_add_assign
id|bh-&gt;b_size
op_div
l_int|512
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_size
op_mod
l_int|512
)paren
(brace
id|printk
c_func
(paren
id|KERN_CRIT
l_string|&quot;cciss:  Oh Man.  %d+%d, size=%d&bslash;n&quot;
comma
(paren
r_int
)paren
id|creq-&gt;sector
comma
id|sect
comma
(paren
r_int
)paren
id|bh-&gt;b_size
)paren
suffix:semicolon
id|panic
c_func
(paren
l_string|&quot;b_size 512 != 0&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh-&gt;b_data
op_eq
id|lastdataend
)paren
(brace
singleline_comment|// tack it on to the last segment 
id|c-&gt;SG
(braket
id|seg
op_minus
l_int|1
)braket
dot
id|Len
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
id|lastdataend
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
)brace
r_else
(brace
id|c-&gt;SG
(braket
id|seg
)braket
dot
id|Len
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|temp64.val
op_assign
(paren
id|__u64
)paren
id|virt_to_bus
c_func
(paren
id|bh-&gt;b_data
)paren
suffix:semicolon
id|c-&gt;SG
(braket
id|seg
)braket
dot
id|Addr.lower
op_assign
id|temp64.val32.lower
suffix:semicolon
id|c-&gt;SG
(braket
id|seg
)braket
dot
id|Addr.upper
op_assign
id|temp64.val32.upper
suffix:semicolon
id|c-&gt;SG
(braket
l_int|0
)braket
dot
id|Ext
op_assign
l_int|0
suffix:semicolon
singleline_comment|// we are not chaining
id|lastdataend
op_assign
id|bh-&gt;b_data
op_plus
id|bh-&gt;b_size
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|seg
op_eq
id|MAXSGENTRIES
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
multiline_comment|/* track how many SG entries we are using */
r_if
c_cond
(paren
id|seg
OG
id|h-&gt;maxSG
)paren
(brace
id|h-&gt;maxSG
op_assign
id|seg
suffix:semicolon
)brace
multiline_comment|/* adjusting the remaining request, if any */
id|creq
op_member_access_from_pointer
id|sector
op_add_assign
id|sect
suffix:semicolon
id|creq-&gt;nr_sectors
op_sub_assign
id|sect
suffix:semicolon
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cciss: Submitting %d sectors in %d segments&bslash;n&quot;
comma
id|sect
comma
id|seg
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */
id|c-&gt;Header.SGList
op_assign
id|c-&gt;Header.SGTotal
op_assign
id|seg
suffix:semicolon
id|c-&gt;Request.CDB
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|c-&gt;Request.CDB
(braket
l_int|2
)braket
op_assign
(paren
id|start_blk
op_rshift
l_int|24
)paren
op_amp
l_int|0xff
suffix:semicolon
singleline_comment|//MSB
id|c-&gt;Request.CDB
(braket
l_int|3
)braket
op_assign
(paren
id|start_blk
op_rshift
l_int|16
)paren
op_amp
l_int|0xff
suffix:semicolon
id|c-&gt;Request.CDB
(braket
l_int|4
)braket
op_assign
(paren
id|start_blk
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|c-&gt;Request.CDB
(braket
l_int|5
)braket
op_assign
id|start_blk
op_amp
l_int|0xff
suffix:semicolon
id|c-&gt;Request.CDB
(braket
l_int|6
)braket
op_assign
l_int|0
suffix:semicolon
singleline_comment|// (sect &gt;&gt; 24) &amp; 0xff; MSB
singleline_comment|// c-&gt;Request.CDB[7]= (sect &gt;&gt; 16) &amp; 0xff; 
id|c-&gt;Request.CDB
(braket
l_int|7
)braket
op_assign
(paren
id|sect
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|c-&gt;Request.CDB
(braket
l_int|8
)braket
op_assign
id|sect
op_amp
l_int|0xff
suffix:semicolon
id|c-&gt;Request.CDB
(braket
l_int|9
)braket
op_assign
id|c-&gt;Request.CDB
(braket
l_int|11
)braket
op_assign
id|c-&gt;Request.CDB
(braket
l_int|12
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* check to see if we going to complete the entire request */
multiline_comment|/* if so, mark this request as Done and ready the next one */
r_if
c_cond
(paren
id|creq-&gt;nr_sectors
)paren
(brace
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cciss: More to do on the same request %p %ld&bslash;n&quot;
comma
id|creq
comma
id|creq-&gt;nr_sectors
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */
id|creq-&gt;bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
id|bh-&gt;b_reqnext
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
l_string|&quot;cciss: Done with %p, queueing %p&bslash;n&quot;
comma
id|creq
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */
id|blkdev_dequeue_request
c_func
(paren
id|creq
)paren
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|creq
)paren
suffix:semicolon
)brace
id|addQ
c_func
(paren
op_amp
(paren
id|h-&gt;reqQ
)paren
comma
id|c
)paren
suffix:semicolon
id|h-&gt;Qdepth
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|h-&gt;Qdepth
OG
id|h-&gt;maxQsinceinit
)paren
(brace
id|h-&gt;maxQsinceinit
op_assign
id|h-&gt;Qdepth
suffix:semicolon
)brace
id|start_io
c_func
(paren
id|h
)paren
suffix:semicolon
)brace
DECL|function|do_cciss_intr
r_static
r_void
id|do_cciss_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|ctlr_info_t
op_star
id|h
op_assign
id|dev_id
suffix:semicolon
id|CommandList_struct
op_star
id|c
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|__u32
id|a
comma
id|a1
suffix:semicolon
multiline_comment|/* Is this interrupt for us? */
r_if
c_cond
(paren
id|h-&gt;access
dot
id|intr_pending
c_func
(paren
id|h
)paren
op_eq
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If there are completed commands in the completion queue,&n;&t; * we had better do something about it.&n;&t; */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|h-&gt;access
dot
id|intr_pending
c_func
(paren
id|h
)paren
)paren
(brace
r_while
c_loop
(paren
(paren
id|a
op_assign
id|h-&gt;access
dot
id|command_completed
c_func
(paren
id|h
)paren
)paren
op_ne
id|FIFO_EMPTY
)paren
(brace
id|a1
op_assign
id|a
suffix:semicolon
id|a
op_and_assign
op_complement
l_int|3
suffix:semicolon
r_if
c_cond
(paren
(paren
id|c
op_assign
id|h-&gt;cmpQ
)paren
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cpqarray: Completion of %08lx ignored&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|a1
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_while
c_loop
(paren
id|c-&gt;busaddr
op_ne
id|a
)paren
(brace
id|c
op_assign
id|c-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
id|h-&gt;cmpQ
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If we&squot;ve found the command, take it off the&n;&t;&t;&t; * completion Q and free it&n;&t;&t;&t; */
r_if
c_cond
(paren
id|c-&gt;busaddr
op_eq
id|a
)paren
(brace
id|removeQ
c_func
(paren
op_amp
id|h-&gt;cmpQ
comma
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c-&gt;cmd_type
op_eq
id|CMD_RWREQ
)paren
(brace
id|complete_command
c_func
(paren
id|c
comma
l_int|0
)paren
suffix:semicolon
id|cmd_free
c_func
(paren
id|h
comma
id|c
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|c-&gt;cmd_type
op_eq
id|CMD_IOCTL_PEND
)paren
(brace
id|c-&gt;cmd_type
op_assign
id|CMD_IOCTL_DONE
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * See if we can queue up some more IO&n;&t; */
id|do_cciss_request
c_func
(paren
id|h-&gt;ctlr
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* &n; *  We cannot read the structure directly, for portablity we must use &n; *   the io functions.&n; *   This is for debug only. &n; */
macro_line|#ifdef CCISS_DEBUG
DECL|function|print_cfg_table
r_static
r_void
id|print_cfg_table
c_func
(paren
id|CfgTable_struct
op_star
id|tb
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
id|temp_name
(braket
l_int|17
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Controller Configuration information&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;------------------------------------&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|temp_name
(braket
id|i
)braket
op_assign
id|readb
c_func
(paren
op_amp
(paren
id|tb-&gt;Signature
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|temp_name
(braket
l_int|4
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   Signature = %s&bslash;n&quot;
comma
id|temp_name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   Spec Number = %d&bslash;n&quot;
comma
id|readl
c_func
(paren
op_amp
(paren
id|tb-&gt;SpecValence
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   Transport methods supported = 0x%x&bslash;n&quot;
comma
id|readl
c_func
(paren
op_amp
(paren
id|tb
op_member_access_from_pointer
id|TransportSupport
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   Transport methods active = 0x%x&bslash;n&quot;
comma
id|readl
c_func
(paren
op_amp
(paren
id|tb-&gt;TransportActive
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   Requested transport Method = 0x%x&bslash;n&quot;
comma
id|readl
c_func
(paren
op_amp
(paren
id|tb-&gt;HostWrite.TransportRequest
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   Coalese Interrupt Delay = 0x%x&bslash;n&quot;
comma
id|readl
c_func
(paren
op_amp
(paren
id|tb-&gt;HostWrite.CoalIntDelay
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   Coalese Interrupt Count = 0x%x&bslash;n&quot;
comma
id|readl
c_func
(paren
op_amp
(paren
id|tb-&gt;HostWrite.CoalIntCount
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   Max outstanding commands = 0x%d&bslash;n&quot;
comma
id|readl
c_func
(paren
op_amp
(paren
id|tb-&gt;CmdsOutMax
)paren
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   Bus Types = 0x%x&bslash;n&quot;
comma
id|readl
c_func
(paren
op_amp
(paren
id|tb
op_member_access_from_pointer
id|BusTypes
)paren
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
(brace
id|temp_name
(braket
id|i
)braket
op_assign
id|readb
c_func
(paren
op_amp
(paren
id|tb-&gt;ServerName
(braket
id|i
)braket
)paren
)paren
suffix:semicolon
)brace
id|temp_name
(braket
l_int|16
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   Server Name = %s&bslash;n&quot;
comma
id|temp_name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;   Heartbeat Counter = 0x%x&bslash;n&bslash;n&bslash;n&quot;
comma
id|readl
c_func
(paren
op_amp
(paren
id|tb-&gt;HeartBeat
)paren
)paren
)paren
suffix:semicolon
)brace
macro_line|#endif /* CCISS_DEBUG */
DECL|function|cciss_pci_init
r_static
r_int
id|cciss_pci_init
c_func
(paren
id|ctlr_info_t
op_star
id|c
comma
id|unchar
id|bus
comma
id|unchar
id|device_fn
)paren
(brace
id|ushort
id|vendor_id
comma
id|device_id
comma
id|command
suffix:semicolon
id|unchar
id|cache_line_size
comma
id|latency_timer
suffix:semicolon
id|unchar
id|irq
comma
id|revision
suffix:semicolon
id|uint
id|addr
(braket
l_int|6
)braket
suffix:semicolon
id|__u32
id|board_id
suffix:semicolon
r_struct
id|pci_dev
op_star
id|pdev
suffix:semicolon
r_int
id|i
suffix:semicolon
id|pdev
op_assign
id|pci_find_slot
c_func
(paren
id|bus
comma
id|device_fn
)paren
suffix:semicolon
id|vendor_id
op_assign
id|pdev-&gt;vendor
suffix:semicolon
id|device_id
op_assign
id|pdev-&gt;device
suffix:semicolon
id|irq
op_assign
id|pdev-&gt;irq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|addr
(braket
id|i
)braket
op_assign
id|pdev-&gt;resource
(braket
id|i
)braket
dot
id|start
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pci_enable_device
c_func
(paren
id|pdev
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
(paren
r_void
)paren
id|pci_read_config_word
c_func
(paren
id|pdev
comma
id|PCI_COMMAND
comma
op_amp
id|command
)paren
suffix:semicolon
(paren
r_void
)paren
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CLASS_REVISION
comma
op_amp
id|revision
)paren
suffix:semicolon
(paren
r_void
)paren
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_CACHE_LINE_SIZE
comma
op_amp
id|cache_line_size
)paren
suffix:semicolon
(paren
r_void
)paren
id|pci_read_config_byte
c_func
(paren
id|pdev
comma
id|PCI_LATENCY_TIMER
comma
op_amp
id|latency_timer
)paren
suffix:semicolon
(paren
r_void
)paren
id|pci_read_config_dword
c_func
(paren
id|pdev
comma
id|PCI_SUBSYSTEM_VENDOR_ID
comma
op_amp
id|board_id
)paren
suffix:semicolon
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
l_string|&quot;vendor_id = %x&bslash;n&quot;
comma
id|vendor_id
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;device_id = %x&bslash;n&quot;
comma
id|device_id
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;command = %x&bslash;n&quot;
comma
id|command
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;addr[%d] = %x&bslash;n&quot;
comma
id|i
comma
id|addr
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;revision = %x&bslash;n&quot;
comma
id|revision
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;irq = %x&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cache_line_size = %x&bslash;n&quot;
comma
id|cache_line_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;latency_timer = %x&bslash;n&quot;
comma
id|latency_timer
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;board_id = %x&bslash;n&quot;
comma
id|board_id
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */ 
id|c-&gt;intr
op_assign
id|irq
suffix:semicolon
multiline_comment|/*&n;&t; * Memory base addr is first addr , the second points to the config&n;         *   table&n;&t; */
id|c-&gt;paddr
op_assign
id|pci_resource_start
c_func
(paren
id|pdev
comma
l_int|0
)paren
suffix:semicolon
id|c-&gt;vaddr
op_assign
id|remap_pci_mem
c_func
(paren
id|c-&gt;paddr
comma
l_int|128
)paren
suffix:semicolon
id|c-&gt;cfgtable
op_assign
(paren
id|CfgTable_struct
op_star
)paren
id|remap_pci_mem
c_func
(paren
id|addr
(braket
l_int|1
)braket
comma
r_sizeof
(paren
id|CfgTable_struct
)paren
)paren
suffix:semicolon
id|c-&gt;board_id
op_assign
id|board_id
suffix:semicolon
macro_line|#ifdef CCISS_DEBUG
id|print_cfg_table
c_func
(paren
id|c-&gt;cfgtable
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_PRODUCTS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|board_id
op_eq
id|products
(braket
id|i
)braket
dot
id|board_id
)paren
(brace
id|c-&gt;product_name
op_assign
id|products
(braket
id|i
)braket
dot
id|product_name
suffix:semicolon
id|c-&gt;access
op_assign
op_star
(paren
id|products
(braket
id|i
)braket
dot
id|access
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|NR_PRODUCTS
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: Sorry, I don&squot;t know how&quot;
l_string|&quot; to access the Smart Array controller %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|board_id
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
l_string|&quot;Trying to put board into Simple mode&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */ 
id|c-&gt;max_commands
op_assign
id|readl
c_func
(paren
op_amp
(paren
id|c-&gt;cfgtable-&gt;CmdsOutMax
)paren
)paren
suffix:semicolon
multiline_comment|/* Update the field, and then ring the doorbell */
id|writel
c_func
(paren
id|CFGTBL_Trans_Simple
comma
op_amp
(paren
id|c-&gt;cfgtable-&gt;HostWrite.TransportRequest
)paren
)paren
suffix:semicolon
id|writel
c_func
(paren
id|CFGTBL_ChangeReq
comma
id|c-&gt;vaddr
op_plus
id|SA5_DOORBELL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_CONFIG_WAIT
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
id|c-&gt;vaddr
op_plus
id|SA5_DOORBELL
)paren
op_amp
id|CFGTBL_ChangeReq
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* delay and try again */
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
)brace
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;I counter got to %d %x&bslash;n&quot;
comma
id|i
comma
id|readl
c_func
(paren
id|c-&gt;vaddr
op_plus
id|SA5_DOORBELL
)paren
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */
macro_line|#ifdef CCISS_DEBUG
id|print_cfg_table
c_func
(paren
id|c-&gt;cfgtable
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */ 
r_if
c_cond
(paren
op_logical_neg
(paren
id|readl
c_func
(paren
op_amp
(paren
id|c-&gt;cfgtable-&gt;TransportActive
)paren
)paren
op_amp
id|CFGTBL_Trans_Simple
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: unable to get board into&quot;
l_string|&quot; simple mode&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * Scans PCI space for any controllers that this driver can control. &n; */
DECL|function|cciss_pci_detect
r_static
r_int
id|cciss_pci_detect
c_func
(paren
r_void
)paren
(brace
r_int
id|index
suffix:semicolon
id|unchar
id|bus
op_assign
l_int|0
comma
id|dev_fn
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
suffix:semicolon
id|index
op_increment
)paren
(brace
r_if
c_cond
(paren
id|pcibios_find_device
c_func
(paren
id|PCI_VENDOR_ID_COMPAQ
comma
id|PCI_DEVICE_ID_COMPAQ_CISS
comma
id|index
comma
op_amp
id|bus
comma
op_amp
id|dev_fn
)paren
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;cciss: Device %x has been found at %x %x&bslash;n&quot;
comma
id|PCI_DEVICE_ID_COMPAQ_CISS
comma
id|bus
comma
id|dev_fn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|index
op_eq
l_int|1000000
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|nr_ctlr
op_eq
l_int|8
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: This driver&quot;
l_string|&quot; supports a maximum of 8 controllers.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|hba
(braket
id|nr_ctlr
)braket
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ctlr_info_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hba
(braket
id|nr_ctlr
)braket
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cciss: out of memory.&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|memset
c_func
(paren
id|hba
(braket
id|nr_ctlr
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|ctlr_info_t
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cciss_pci_init
c_func
(paren
id|hba
(braket
id|nr_ctlr
)braket
comma
id|bus
comma
id|dev_fn
)paren
op_ne
l_int|0
)paren
(brace
id|kfree
c_func
(paren
id|hba
(braket
id|nr_ctlr
)braket
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|sprintf
c_func
(paren
id|hba
(braket
id|nr_ctlr
)braket
op_member_access_from_pointer
id|devname
comma
l_string|&quot;cciss%d&quot;
comma
id|nr_ctlr
)paren
suffix:semicolon
id|hba
(braket
id|nr_ctlr
)braket
op_member_access_from_pointer
id|ctlr
op_assign
id|nr_ctlr
suffix:semicolon
id|hba
(braket
id|nr_ctlr
)braket
op_member_access_from_pointer
id|pci_bus
op_assign
id|bus
suffix:semicolon
id|hba
(braket
id|nr_ctlr
)braket
op_member_access_from_pointer
id|pci_dev_fn
op_assign
id|dev_fn
suffix:semicolon
id|nr_ctlr
op_increment
suffix:semicolon
)brace
r_return
id|nr_ctlr
suffix:semicolon
)brace
multiline_comment|/* &n; * Gets information about the local volumes attached to the controller. &n; */
DECL|function|cciss_getgeometry
r_static
r_void
id|cciss_getgeometry
c_func
(paren
r_int
id|cntl_num
)paren
(brace
id|ReportLunData_struct
op_star
id|ld_buff
suffix:semicolon
id|ReadCapdata_struct
op_star
id|size_buff
suffix:semicolon
id|InquiryData_struct
op_star
id|inq_buff
suffix:semicolon
r_int
id|return_code
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
id|listlength
op_assign
l_int|0
suffix:semicolon
r_int
id|lunid
op_assign
l_int|0
suffix:semicolon
r_int
id|block_size
suffix:semicolon
r_int
id|total_size
suffix:semicolon
id|ld_buff
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ReportLunData_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ld_buff
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cciss: out of memory&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|ld_buff
comma
l_int|0
comma
r_sizeof
(paren
id|ReportLunData_struct
)paren
)paren
suffix:semicolon
id|size_buff
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|ReadCapdata_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|size_buff
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cciss: out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ld_buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|inq_buff
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|InquiryData_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inq_buff
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cciss: out of memory&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|ld_buff
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|size_buff
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Get the firmware version */
id|return_code
op_assign
id|sendcmd
c_func
(paren
id|CISS_INQUIRY
comma
id|cntl_num
comma
id|inq_buff
comma
r_sizeof
(paren
id|InquiryData_struct
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|return_code
op_eq
id|IO_OK
)paren
(brace
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|firm_ver
(braket
l_int|0
)braket
op_assign
id|inq_buff-&gt;data_byte
(braket
l_int|32
)braket
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|firm_ver
(braket
l_int|1
)braket
op_assign
id|inq_buff-&gt;data_byte
(braket
l_int|33
)braket
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|firm_ver
(braket
l_int|2
)braket
op_assign
id|inq_buff-&gt;data_byte
(braket
l_int|34
)braket
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|firm_ver
(braket
l_int|3
)braket
op_assign
id|inq_buff-&gt;data_byte
(braket
l_int|35
)braket
suffix:semicolon
)brace
r_else
multiline_comment|/* send command failed */
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: unable to determine firmware&quot;
l_string|&quot; version of controller&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the number of logical volumes */
id|return_code
op_assign
id|sendcmd
c_func
(paren
id|CISS_REPORT_LOG
comma
id|cntl_num
comma
id|ld_buff
comma
r_sizeof
(paren
id|ReportLunData_struct
)paren
comma
l_int|0
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|return_code
op_eq
id|IO_OK
)paren
(brace
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
l_string|&quot;LUN Data&bslash;n--------------------------&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */ 
id|listlength
op_or_assign
(paren
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|ld_buff-&gt;LUNListLength
(braket
l_int|0
)braket
)paren
)paren
op_lshift
l_int|24
suffix:semicolon
id|listlength
op_or_assign
(paren
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|ld_buff-&gt;LUNListLength
(braket
l_int|1
)braket
)paren
)paren
op_lshift
l_int|16
suffix:semicolon
id|listlength
op_or_assign
(paren
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|ld_buff-&gt;LUNListLength
(braket
l_int|2
)braket
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
id|listlength
op_or_assign
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|ld_buff-&gt;LUNListLength
(braket
l_int|3
)braket
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* reading number of logical volumes failed */
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: report logical volume&quot;
l_string|&quot; command failed&bslash;n&quot;
)paren
suffix:semicolon
id|listlength
op_assign
l_int|0
suffix:semicolon
)brace
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|num_luns
op_assign
id|listlength
op_div
l_int|8
suffix:semicolon
singleline_comment|// 8 bytes pre entry
r_if
c_cond
(paren
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|num_luns
OG
id|CISS_MAX_LUN
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ciss:  only %d number of logical volumes supported&bslash;n&quot;
comma
id|CISS_MAX_LUN
)paren
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|num_luns
op_assign
id|CISS_MAX_LUN
suffix:semicolon
)brace
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Length = %x %x %x %x = %d&bslash;n&quot;
comma
id|ld_buff-&gt;LUNListLength
(braket
l_int|0
)braket
comma
id|ld_buff-&gt;LUNListLength
(braket
l_int|1
)braket
comma
id|ld_buff-&gt;LUNListLength
(braket
l_int|2
)braket
comma
id|ld_buff-&gt;LUNListLength
(braket
l_int|3
)braket
comma
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|num_luns
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|num_luns
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lunid
op_assign
(paren
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|ld_buff-&gt;LUN
(braket
id|i
)braket
(braket
l_int|3
)braket
)paren
)paren
op_lshift
l_int|24
suffix:semicolon
id|lunid
op_or_assign
(paren
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|ld_buff-&gt;LUN
(braket
id|i
)braket
(braket
l_int|2
)braket
)paren
)paren
op_lshift
l_int|16
suffix:semicolon
id|lunid
op_or_assign
(paren
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|ld_buff-&gt;LUN
(braket
id|i
)braket
(braket
l_int|1
)braket
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
id|lunid
op_or_assign
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|ld_buff-&gt;LUN
(braket
id|i
)braket
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|LunID
op_assign
id|lunid
suffix:semicolon
macro_line|#ifdef CCISS_DEBUG
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;LUN[%d]:  %x %x %x %x = %x&bslash;n&quot;
comma
id|i
comma
id|ld_buff-&gt;LUN
(braket
id|i
)braket
(braket
l_int|0
)braket
comma
id|ld_buff-&gt;LUN
(braket
id|i
)braket
(braket
l_int|1
)braket
comma
id|ld_buff-&gt;LUN
(braket
id|i
)braket
(braket
l_int|2
)braket
comma
id|ld_buff-&gt;LUN
(braket
id|i
)braket
(braket
l_int|3
)braket
comma
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|LunID
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */
id|memset
c_func
(paren
id|size_buff
comma
l_int|0
comma
r_sizeof
(paren
id|ReadCapdata_struct
)paren
)paren
suffix:semicolon
id|return_code
op_assign
id|sendcmd
c_func
(paren
id|CCISS_READ_CAPACITY
comma
id|cntl_num
comma
id|size_buff
comma
r_sizeof
(paren
id|ReadCapdata_struct
)paren
comma
l_int|1
comma
id|i
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|return_code
op_eq
id|IO_OK
)paren
(brace
id|total_size
op_assign
(paren
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|size_buff-&gt;total_size
(braket
l_int|0
)braket
)paren
)paren
op_lshift
l_int|24
suffix:semicolon
id|total_size
op_or_assign
(paren
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|size_buff-&gt;total_size
(braket
l_int|1
)braket
)paren
)paren
op_lshift
l_int|16
suffix:semicolon
id|total_size
op_or_assign
(paren
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|size_buff-&gt;total_size
(braket
l_int|2
)braket
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
id|total_size
op_or_assign
(paren
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|size_buff-&gt;total_size
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
id|total_size
op_increment
suffix:semicolon
singleline_comment|// command returns highest block address
id|block_size
op_assign
(paren
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|size_buff-&gt;block_size
(braket
l_int|0
)braket
)paren
)paren
op_lshift
l_int|24
suffix:semicolon
id|block_size
op_or_assign
(paren
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|size_buff-&gt;block_size
(braket
l_int|1
)braket
)paren
)paren
op_lshift
l_int|16
suffix:semicolon
id|block_size
op_or_assign
(paren
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|size_buff-&gt;block_size
(braket
l_int|2
)braket
)paren
)paren
op_lshift
l_int|8
suffix:semicolon
id|block_size
op_or_assign
(paren
l_int|0xff
op_amp
(paren
r_int
r_int
)paren
(paren
id|size_buff-&gt;block_size
(braket
l_int|3
)braket
)paren
)paren
suffix:semicolon
)brace
r_else
multiline_comment|/* read capacity command failed */
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: read capacity failed&bslash;n&quot;
)paren
suffix:semicolon
id|total_size
op_assign
id|block_size
op_assign
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;      blocks= %d block_size= %d&bslash;n&quot;
comma
id|total_size
comma
id|block_size
)paren
suffix:semicolon
multiline_comment|/* Execute the command to read the disk geometry */
id|memset
c_func
(paren
id|inq_buff
comma
l_int|0
comma
r_sizeof
(paren
id|InquiryData_struct
)paren
)paren
suffix:semicolon
id|return_code
op_assign
id|sendcmd
c_func
(paren
id|CISS_INQUIRY
comma
id|cntl_num
comma
id|inq_buff
comma
r_sizeof
(paren
id|InquiryData_struct
)paren
comma
l_int|1
comma
id|i
comma
l_int|0xC1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|return_code
op_eq
id|IO_OK
)paren
(brace
r_if
c_cond
(paren
id|inq_buff-&gt;data_byte
(braket
l_int|8
)braket
op_eq
l_int|0xFF
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: reading geometry failed, volume does not support reading geometry&bslash;n&quot;
)paren
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|block_size
op_assign
id|block_size
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|nr_blocks
op_assign
id|total_size
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|heads
op_assign
l_int|255
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|sectors
op_assign
l_int|32
suffix:semicolon
singleline_comment|// Sectors per track
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|cylinders
op_assign
id|total_size
op_div
l_int|255
op_div
l_int|32
suffix:semicolon
)brace
r_else
(brace
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|block_size
op_assign
id|block_size
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|nr_blocks
op_assign
id|total_size
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|heads
op_assign
id|inq_buff-&gt;data_byte
(braket
l_int|6
)braket
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|sectors
op_assign
id|inq_buff-&gt;data_byte
(braket
l_int|7
)braket
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|cylinders
op_assign
(paren
id|inq_buff-&gt;data_byte
(braket
l_int|4
)braket
op_amp
l_int|0xff
)paren
op_lshift
l_int|8
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|cylinders
op_add_assign
id|inq_buff-&gt;data_byte
(braket
l_int|5
)braket
suffix:semicolon
)brace
)brace
r_else
multiline_comment|/* Get geometry failed */
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;cciss: reading geometry failed, continuing with default geometry&bslash;n&quot;
)paren
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|block_size
op_assign
id|block_size
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|nr_blocks
op_assign
id|total_size
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|heads
op_assign
l_int|255
suffix:semicolon
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|sectors
op_assign
l_int|32
suffix:semicolon
singleline_comment|// Sectors per track 
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|cylinders
op_assign
id|total_size
op_div
l_int|255
op_div
l_int|32
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;      heads= %d, sectors= %d, cylinders= %d&bslash;n&bslash;n&quot;
comma
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|heads
comma
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|sectors
comma
id|hba
(braket
id|cntl_num
)braket
op_member_access_from_pointer
id|drv
(braket
id|i
)braket
dot
id|cylinders
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|ld_buff
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|size_buff
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; *  This is it.  Find all the controllers and register them.  I really hate&n; *  stealing all these major device numbers.&n; *  returns the number of block devices registered.&n; */
DECL|function|cciss_init
r_int
id|__init
id|cciss_init
c_func
(paren
r_void
)paren
(brace
r_int
id|num_cntlrs_reg
op_assign
l_int|0
suffix:semicolon
r_int
id|i
comma
id|j
suffix:semicolon
r_void
(paren
op_star
id|request_fns
(braket
id|MAX_CTLR
)braket
)paren
(paren
id|request_queue_t
op_star
)paren
op_assign
(brace
id|do_cciss_request0
comma
id|do_cciss_request1
comma
id|do_cciss_request2
comma
id|do_cciss_request3
comma
id|do_cciss_request4
comma
id|do_cciss_request5
comma
id|do_cciss_request6
comma
id|do_cciss_request7
comma
)brace
suffix:semicolon
multiline_comment|/* detect controllers */
id|cciss_pci_detect
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nr_ctlr
op_eq
l_int|0
)paren
r_return
id|num_cntlrs_reg
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|DRIVER_NAME
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Found %d controller(s)&bslash;n&quot;
comma
id|nr_ctlr
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_ctlr
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
op_plus
id|i
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
comma
op_amp
id|cciss_fops
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cciss:  Unable to get major number &quot;
l_string|&quot;%d for %s&bslash;n&quot;
comma
id|MAJOR_NR
op_plus
id|i
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* make sure the board interrupts are off */
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|access
dot
id|set_intr_mask
c_func
(paren
id|hba
(braket
id|i
)braket
comma
id|CCISS_INTR_OFF
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|intr
comma
id|do_cciss_intr
comma
id|SA_INTERRUPT
op_or
id|SA_SHIRQ
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
comma
id|hba
(braket
id|i
)braket
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;ciss: Unable to get irq %d for %s&bslash;n&quot;
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|intr
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
op_plus
id|i
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|num_cntlrs_reg
op_increment
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
op_assign
(paren
id|__u32
op_star
)paren
id|kmalloc
c_func
(paren
(paren
(paren
id|NR_CMDS
op_plus
l_int|31
)paren
op_div
l_int|32
)paren
op_star
r_sizeof
(paren
id|__u32
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
op_assign
(paren
id|CommandList_struct
op_star
)paren
id|kmalloc
c_func
(paren
id|NR_CMDS
op_star
r_sizeof
(paren
id|CommandList_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|errinfo_pool
op_assign
(paren
id|ErrorInfo_struct
op_star
)paren
id|kmalloc
c_func
(paren
id|NR_CMDS
op_star
r_sizeof
(paren
id|ErrorInfo_struct
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|errinfo_pool
op_eq
l_int|NULL
)paren
)paren
(brace
id|nr_ctlr
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
)paren
(brace
id|kfree
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
)paren
(brace
id|kfree
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|errinfo_pool
)paren
(brace
id|kfree
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|errinfo_pool
)paren
suffix:semicolon
)brace
id|free_irq
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|intr
comma
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
op_plus
id|i
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
suffix:semicolon
id|num_cntlrs_reg
op_decrement
suffix:semicolon
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;cciss: out of memory&quot;
)paren
suffix:semicolon
r_return
id|num_cntlrs_reg
suffix:semicolon
)brace
multiline_comment|/* command and error info recs zeroed out before &n;&t;&t;&t;they are used */
id|memset
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
comma
l_int|0
comma
(paren
(paren
id|NR_CMDS
op_plus
l_int|31
)paren
op_div
l_int|32
)paren
op_star
r_sizeof
(paren
id|__u32
)paren
)paren
suffix:semicolon
macro_line|#ifdef CCISS_DEBUG&t;
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;Scanning for drives on controller cciss%d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
macro_line|#endif /* CCISS_DEBUG */
id|cciss_getgeometry
c_func
(paren
id|i
)paren
suffix:semicolon
multiline_comment|/* Turn the interrupts on so we can service requests */
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|access
dot
id|set_intr_mask
c_func
(paren
id|hba
(braket
id|i
)braket
comma
id|CCISS_INTR_ON
)paren
suffix:semicolon
id|cciss_procinit
c_func
(paren
id|i
)paren
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
op_plus
id|i
)paren
comma
id|request_fns
(braket
id|i
)braket
)paren
suffix:semicolon
id|blk_queue_headactive
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
op_plus
id|i
)paren
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* fill in the other Kernel structs */
id|blksize_size
(braket
id|MAJOR_NR
op_plus
id|i
)braket
op_assign
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|blocksizes
suffix:semicolon
id|hardsect_size
(braket
id|MAJOR_NR
op_plus
id|i
)braket
op_assign
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|hardsizes
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
op_plus
id|i
)braket
op_assign
id|READ_AHEAD
suffix:semicolon
multiline_comment|/* Fill in the gendisk data */
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|gendisk.major
op_assign
id|MAJOR_NR
op_plus
id|i
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|gendisk.major_name
op_assign
l_string|&quot;cciss&quot;
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|gendisk.minor_shift
op_assign
id|NWD_SHIFT
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|gendisk.max_p
op_assign
id|MAX_PART
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|gendisk.part
op_assign
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|hd
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|gendisk.sizes
op_assign
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|sizes
suffix:semicolon
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|gendisk.nr_real
op_assign
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|num_luns
suffix:semicolon
multiline_comment|/* Get on the disk list */
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|gendisk.next
op_assign
id|gendisk_head
suffix:semicolon
id|gendisk_head
op_assign
op_amp
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|gendisk
)paren
suffix:semicolon
id|cciss_geninit
c_func
(paren
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|NWD
suffix:semicolon
id|j
op_increment
)paren
(brace
id|register_disk
c_func
(paren
op_amp
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|gendisk
)paren
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
op_plus
id|i
comma
id|j
op_lshift
l_int|4
)paren
comma
id|MAX_PART
comma
op_amp
id|cciss_fops
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|drv
(braket
id|j
)braket
dot
id|nr_blocks
)paren
suffix:semicolon
)brace
)brace
r_return
id|nr_ctlr
suffix:semicolon
)brace
id|EXPORT_NO_SYMBOLS
suffix:semicolon
multiline_comment|/* This is a bit of a hack... */
DECL|function|init_cciss_module
r_static
r_int
id|__init
id|init_cciss_module
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|cciss_init
c_func
(paren
)paren
op_eq
l_int|0
)paren
multiline_comment|/* all the block dev numbers already used */
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* or no controllers were found */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_cciss_module
r_static
r_void
id|__exit
id|cleanup_cciss_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|gendisk
op_star
id|g
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nr_ctlr
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* Turn board interrupts off */
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|access
dot
id|set_intr_mask
c_func
(paren
id|hba
(braket
id|i
)braket
comma
id|CCISS_INTR_OFF
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|intr
comma
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|vaddr
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
op_plus
id|i
comma
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
)paren
suffix:semicolon
id|remove_proc_entry
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|devname
comma
id|proc_cciss
)paren
suffix:semicolon
multiline_comment|/* remove it from the disk list */
r_if
c_cond
(paren
id|gendisk_head
op_eq
op_amp
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|gendisk
)paren
)paren
(brace
id|gendisk_head
op_assign
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|gendisk.next
suffix:semicolon
)brace
r_else
(brace
r_for
c_loop
(paren
id|g
op_assign
id|gendisk_head
suffix:semicolon
id|g
suffix:semicolon
id|g
op_assign
id|g-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|g-&gt;next
op_eq
op_amp
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|gendisk
)paren
)paren
(brace
id|g-&gt;next
op_assign
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|gendisk.next
suffix:semicolon
)brace
)brace
)brace
id|remove_proc_entry
c_func
(paren
l_string|&quot;driver/cciss&quot;
comma
op_amp
id|proc_root
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|errinfo_pool
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hba
(braket
id|i
)braket
op_member_access_from_pointer
id|cmd_pool_bits
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|hba
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
DECL|variable|init_cciss_module
id|module_init
c_func
(paren
id|init_cciss_module
)paren
suffix:semicolon
DECL|variable|cleanup_cciss_module
id|module_exit
c_func
(paren
id|cleanup_cciss_module
)paren
suffix:semicolon
eof
