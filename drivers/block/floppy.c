multiline_comment|/*&n; *  linux/kernel/floppy.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *  Copyright (C) 1993, 1994  Alain Knaff&n; */
multiline_comment|/* Configuration */
multiline_comment|/* The following does some extra sanity checks */
DECL|macro|SANITY
mdefine_line|#define SANITY
multiline_comment|/* Undefine the following if you have to floppy disk controllers:&n; * This works at least for me; if you get two controllers working, with&n; * drives attached to both, please mail me: Alain.Knaff@imag.fr */
multiline_comment|/* #define HAVE_2_CONTROLLERS */
multiline_comment|/* Undefine the following if you have problems accessing ED disks, but don&squot;t&n; * have problems accessing them with the stock driver. If that is the case,&n; * please mail me: Alain.Knaff@imag.fr */
multiline_comment|/* #define FDC_FIFO_BUG */
multiline_comment|/* End of configuration */
multiline_comment|/*&n; * 02.12.91 - Changed to static variables to indicate need for reset&n; * and recalibrate. This makes some things easier (output_byte reset&n; * checking etc), and means less interrupt jumping in case of errors,&n; * so the code is hopefully easier to understand.&n; */
multiline_comment|/*&n; * This file is certainly a mess. I&squot;ve tried my best to get it working,&n; * but I don&squot;t like programming floppies, and I have only one anyway.&n; * Urgel. I should check for more errors, and do more graceful error&n; * recovery. Seems there are problems with several drives. I&squot;ve tried to&n; * correct them. No promises.&n; */
multiline_comment|/*&n; * As with hd.c, all routines within this file can (and will) be called&n; * by interrupts, so extreme caution is needed. A hardware interrupt&n; * handler may not sleep, or a kernel panic will happen. Thus I cannot&n; * call &quot;floppy-on&quot; directly, but have to set a special timer interrupt&n; * etc.&n; */
multiline_comment|/*&n; * 28.02.92 - made track-buffering routines, based on the routines written&n; * by entropy@wintermute.wpi.edu (Lawrence Foard). Linus.&n; */
multiline_comment|/*&n; * Automatic floppy-detection and formatting written by Werner Almesberger&n; * (almesber@nessie.cs.id.ethz.ch), who also corrected some problems with&n; * the floppy-change signal detection.&n; */
multiline_comment|/*&n; * 1992/7/22 -- Hennus Bergman: Added better error reporting, fixed&n; * FDC data overrun bug, added some preliminary stuff for vertical&n; * recording support.&n; *&n; * 1992/9/17: Added DMA allocation &amp; DMA functions. -- hhb.&n; *&n; * TODO: Errors are still not counted properly.&n; */
multiline_comment|/* 1992/9/20&n; * Modifications for ``Sector Shifting&squot;&squot; by Rob Hooft (hooft@chem.ruu.nl)&n; * modelled after the freeware MS/DOS program fdformat/88 V1.8 by&n; * Christoph H. Hochst&bslash;&quot;atter.&n; * I have fixed the shift values to the ones I always use. Maybe a new&n; * ioctl() should be created to be able to modify them.&n; * There is a bug in the driver that makes it impossible to format a&n; * floppy as the first thing after bootup.&n; */
multiline_comment|/*&n; * 1993/4/29 -- Linus -- cleaned up the timer handling in the kernel, and&n; * this helped the floppy driver as well. Much cleaner, and still seems to&n; * work.&n; */
multiline_comment|/* 1994/6/24 --bbroad-- added the floppy table entries and made&n; * minor modifications to allow 2.88 floppies to be run.&n; */
multiline_comment|/* 1994/7/13 -- Paul Vojta -- modified the probing code to allow three or more&n; * disk types.&n; */
DECL|macro|REALLY_SLOW_IO
mdefine_line|#define REALLY_SLOW_IO
DECL|macro|FLOPPY_IRQ
mdefine_line|#define FLOPPY_IRQ 6
DECL|macro|FLOPPY_DMA
mdefine_line|#define FLOPPY_DMA 2
DECL|macro|DEBUGT
mdefine_line|#define DEBUGT 2
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
DECL|macro|FDPATCHES
mdefine_line|#define FDPATCHES
macro_line|#include &lt;linux/fdreg.h&gt;
macro_line|#include &lt;linux/fd.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR FLOPPY_MAJOR
macro_line|#include &quot;blk.h&quot;
DECL|variable|changed_floppies
DECL|variable|fake_change
r_static
r_int
r_int
id|changed_floppies
op_assign
l_int|0
comma
id|fake_change
op_assign
l_int|0
suffix:semicolon
DECL|variable|initialising
r_static
r_int
id|initialising
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef HAVE_2_CONTROLLERS
DECL|macro|N_FDC
mdefine_line|#define N_FDC 2
DECL|macro|N_DRIVE
mdefine_line|#define N_DRIVE 8
macro_line|#else
DECL|macro|N_FDC
mdefine_line|#define N_FDC 1
DECL|macro|N_DRIVE
mdefine_line|#define N_DRIVE 2
macro_line|#endif
DECL|macro|TYPE
mdefine_line|#define TYPE(x) ( ((x)&gt;&gt;2) &amp; 0x1f )
DECL|macro|DRIVE
mdefine_line|#define DRIVE(x) ( ((x)&amp;0x03) | (((x)&amp;0x80 ) &gt;&gt; 5))
DECL|macro|UNIT
mdefine_line|#define UNIT(x) ( (x) &amp; 0x03 )&t;&t;/* drive on fdc */
DECL|macro|FDC
mdefine_line|#define FDC(x) ( ((x) &amp; 0x04) &gt;&gt; 2 )  /* fdc of drive */
DECL|macro|REVDRIVE
mdefine_line|#define REVDRIVE(fdc, unit) ( (unit) + ((fdc) &lt;&lt; 2 ))
multiline_comment|/* reverse mapping from unit and fdc to drive */
DECL|macro|DP
mdefine_line|#define DP (&amp;drive_params[current_drive])
DECL|macro|DRS
mdefine_line|#define DRS (&amp;drive_state[current_drive])
DECL|macro|FDCS
mdefine_line|#define FDCS (&amp;fdc_state[fdc])
DECL|macro|UDP
mdefine_line|#define UDP (&amp;drive_params[drive])
DECL|macro|UDRS
mdefine_line|#define UDRS (&amp;drive_state[drive])
DECL|macro|UFDCS
mdefine_line|#define UFDCS (&amp;fdc_state[FDC(drive)])
multiline_comment|/* read/write */
DECL|macro|COMMAND
mdefine_line|#define COMMAND raw_cmd.cmd[0]
DECL|macro|DR_SELECT
mdefine_line|#define DR_SELECT raw_cmd.cmd[1]
DECL|macro|TRACK
mdefine_line|#define TRACK raw_cmd.cmd[2]
DECL|macro|HEAD
mdefine_line|#define HEAD raw_cmd.cmd[3]
DECL|macro|SECTOR
mdefine_line|#define SECTOR raw_cmd.cmd[4]
DECL|macro|SIZECODE
mdefine_line|#define SIZECODE raw_cmd.cmd[5]
DECL|macro|SECT_PER_TRACK
mdefine_line|#define SECT_PER_TRACK raw_cmd.cmd[6]
DECL|macro|GAP
mdefine_line|#define GAP raw_cmd.cmd[7]
DECL|macro|SIZECODE2
mdefine_line|#define SIZECODE2 raw_cmd.cmd[8]
DECL|macro|NR_RW
mdefine_line|#define NR_RW 9
multiline_comment|/* format */
DECL|macro|F_SIZECODE
mdefine_line|#define F_SIZECODE raw_cmd.cmd[2]
DECL|macro|F_SECT_PER_TRACK
mdefine_line|#define F_SECT_PER_TRACK raw_cmd.cmd[3]
DECL|macro|F_GAP
mdefine_line|#define F_GAP raw_cmd.cmd[4]
DECL|macro|F_FILL
mdefine_line|#define F_FILL raw_cmd.cmd[5]
DECL|macro|NR_F
mdefine_line|#define NR_F 6
multiline_comment|/*&n; * Maximum disk size (in kilobytes). This default is used whenever the&n; * current disk size is unknown.&n; */
DECL|macro|MAX_DISK_SIZE
mdefine_line|#define MAX_DISK_SIZE 3984
multiline_comment|/*&n; * The DMA channel used by the floppy controller cannot access data at&n; * addresses &gt;= 16MB&n; *&n; * Went back to the 1MB limit, as some people had problems with the floppy&n; * driver otherwise. It doesn&squot;t matter much for performance anyway, as most&n; * floppy accesses go through the track buffer.&n; */
DECL|macro|LAST_DMA_ADDR
mdefine_line|#define LAST_DMA_ADDR&t;(0x1000000)
DECL|macro|K_64
mdefine_line|#define K_64 (0x10000) /* 64 k */
multiline_comment|/*&n; * globals used by &squot;result()&squot;&n; */
DECL|macro|MAX_REPLIES
mdefine_line|#define MAX_REPLIES 10
DECL|variable|reply_buffer
r_static
r_int
r_char
id|reply_buffer
(braket
id|MAX_REPLIES
)braket
suffix:semicolon
DECL|variable|inr
r_static
r_int
id|inr
suffix:semicolon
multiline_comment|/* size of reply buffer, when called from interrupt */
DECL|macro|ST0
mdefine_line|#define ST0 (reply_buffer[0])
DECL|macro|ST1
mdefine_line|#define ST1 (reply_buffer[1])
DECL|macro|ST2
mdefine_line|#define ST2 (reply_buffer[2])
DECL|macro|ST3
mdefine_line|#define ST3 (reply_buffer[0]) /* result of GETSTATUS */
DECL|macro|R_TRACK
mdefine_line|#define R_TRACK (reply_buffer[3])
DECL|macro|R_HEAD
mdefine_line|#define R_HEAD (reply_buffer[4])
DECL|macro|R_SECTOR
mdefine_line|#define R_SECTOR (reply_buffer[5])
DECL|macro|R_SIZECODE
mdefine_line|#define R_SIZECODE (reply_buffer[6])
multiline_comment|/*&n; * this struct defines the different floppy drive types.&n; */
r_static
r_struct
(brace
DECL|member|params
r_struct
id|floppy_drive_params
id|params
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/* name printed while booting */
DECL|variable|default_drive_params
)brace
id|default_drive_params
(braket
)braket
op_assign
(brace
multiline_comment|/* NOTE: the time values in jiffies should be in msec!&n; CMOS drive type&n;  |     Maximum data rate supported by drive type&n;  |     |   Head load time, msec&n;  |     |   |   Head unload time, msec (not used)&n;  |     |   |   |     Step rate interval, usec&n;  |     |   |   |     |    Time needed for spinup time (jiffies)&n;  |     |   |   |     |    |    Timeout for spinning down (jiffies)&n;  |     |   |   |     |    |    |   Spindown offset (where disk stops)&n;  |     |   |   |     |    |    |   |  Select delay&n;  |     |   |   |     |    |    |   |  |  RPS&n;  |     |   |   |     |    |    |   |  |  |    Max number of tracks&n;  |     |   |   |     |    |    |   |  |  |    |     Interrupt timeout&n;  |     |   |   |     |    |    |   |  |  |    |     |   Max nonintlv. sectors&n;  |     |   |   |     |    |    |   |  |  |    |     |   | -Max Errors- flags */
(brace
(brace
l_int|0
comma
l_int|500
comma
l_int|16
comma
l_int|16
comma
l_int|8000
comma
l_int|100
comma
l_int|300
comma
l_int|0
comma
l_int|2
comma
l_int|5
comma
l_int|80
comma
l_int|3
op_star
id|HZ
comma
l_int|20
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|7
comma
l_int|4
comma
l_int|8
comma
l_int|2
comma
l_int|1
comma
l_int|5
comma
l_int|3
comma
l_int|10
)brace
comma
l_int|150
comma
l_int|0
)brace
comma
l_string|&quot;unknown&quot;
)brace
comma
(brace
(brace
l_int|1
comma
l_int|300
comma
l_int|16
comma
l_int|16
comma
l_int|8000
comma
l_int|100
comma
l_int|300
comma
l_int|0
comma
l_int|2
comma
l_int|5
comma
l_int|40
comma
l_int|3
op_star
id|HZ
comma
l_int|17
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
l_int|150
comma
l_int|1
)brace
comma
l_string|&quot;360K PC&quot;
)brace
comma
multiline_comment|/*5 1/4 360 KB PC*/
(brace
(brace
l_int|2
comma
l_int|500
comma
l_int|16
comma
l_int|16
comma
l_int|6000
comma
l_int|40
comma
l_int|300
comma
l_int|14
comma
l_int|2
comma
l_int|6
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|17
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|2
comma
l_int|5
comma
l_int|6
comma
l_int|23
comma
l_int|10
comma
l_int|20
comma
l_int|11
comma
l_int|0
)brace
comma
l_int|150
comma
l_int|2
)brace
comma
l_string|&quot;1.2M&quot;
)brace
comma
multiline_comment|/*5 1/4 HD AT*/
(brace
(brace
l_int|3
comma
l_int|250
comma
l_int|16
comma
l_int|16
comma
l_int|3000
comma
l_int|100
comma
l_int|300
comma
l_int|0
comma
l_int|2
comma
l_int|5
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|20
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|4
comma
l_int|22
comma
l_int|21
comma
l_int|30
comma
l_int|3
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
l_int|150
comma
l_int|4
)brace
comma
l_string|&quot;720k&quot;
)brace
comma
multiline_comment|/*3 1/2 DD*/
(brace
(brace
l_int|4
comma
l_int|500
comma
l_int|16
comma
l_int|16
comma
l_int|4000
comma
l_int|40
comma
l_int|300
comma
l_int|10
comma
l_int|2
comma
l_int|5
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|20
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|7
comma
l_int|4
comma
l_int|25
comma
l_int|22
comma
l_int|31
comma
l_int|21
comma
l_int|29
comma
l_int|11
)brace
comma
l_int|150
comma
l_int|7
)brace
comma
l_string|&quot;1.44M&quot;
)brace
comma
multiline_comment|/*3 1/2 HD*/
(brace
(brace
l_int|5
comma
l_int|1000
comma
l_int|15
comma
l_int|8
comma
l_int|3000
comma
l_int|40
comma
l_int|300
comma
l_int|10
comma
l_int|2
comma
l_int|5
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|40
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|7
comma
l_int|8
comma
l_int|4
comma
l_int|25
comma
l_int|28
comma
l_int|22
comma
l_int|31
comma
l_int|21
)brace
comma
l_int|150
comma
l_int|8
)brace
comma
l_string|&quot;2.88M AMI BIOS&quot;
)brace
comma
multiline_comment|/*3 1/2 ED*/
(brace
(brace
l_int|6
comma
l_int|1000
comma
l_int|15
comma
l_int|8
comma
l_int|3000
comma
l_int|40
comma
l_int|300
comma
l_int|10
comma
l_int|2
comma
l_int|5
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|40
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|7
comma
l_int|8
comma
l_int|4
comma
l_int|25
comma
l_int|28
comma
l_int|22
comma
l_int|31
comma
l_int|21
)brace
comma
l_int|150
comma
l_int|8
)brace
comma
l_string|&quot;2.88M&quot;
)brace
multiline_comment|/*3 1/2 ED*/
multiline_comment|/*    |  ---autodetected formats--   |   |      |&n;      read_track                     |   |    Name printed when booting&n;                                     |  Native format&n;                                   Frequency of disk change checks */
)brace
suffix:semicolon
DECL|variable|drive_params
r_static
r_struct
id|floppy_drive_params
id|drive_params
(braket
id|N_DRIVE
)braket
suffix:semicolon
DECL|variable|drive_state
r_static
r_struct
id|floppy_drive_struct
r_volatile
id|drive_state
(braket
id|N_DRIVE
)braket
suffix:semicolon
DECL|variable|raw_cmd
r_static
r_struct
id|floppy_raw_cmd
id|raw_cmd
suffix:semicolon
multiline_comment|/*&n; * This struct defines the different floppy types.&n; *&n; * The &squot;stretch&squot; tells if the tracks need to be doubled for some&n; * types (ie 360kB diskette in 1.2MB drive etc). Others should&n; * be self-explanatory.&n; */
DECL|variable|floppy_type
r_static
r_struct
id|floppy_struct
id|floppy_type
(braket
l_int|32
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|NULL
)brace
comma
multiline_comment|/*  0 no testing    */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;d360&quot;
)brace
comma
multiline_comment|/*  1 360KB PC      */
(brace
l_int|2400
comma
l_int|15
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x54
comma
l_string|&quot;h1200&quot;
)brace
comma
multiline_comment|/*  2 1.2MB AT      */
(brace
l_int|720
comma
l_int|9
comma
l_int|1
comma
l_int|80
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;D360&quot;
)brace
comma
multiline_comment|/*  3 360KB SS 3.5&quot; */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;D720&quot;
)brace
comma
multiline_comment|/*  4 720KB 3.5&quot;    */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|1
comma
l_int|0x23
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;h360&quot;
)brace
comma
multiline_comment|/*  5 360KB AT      */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x23
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;h720&quot;
)brace
comma
multiline_comment|/*  6 720KB AT      */
(brace
l_int|2880
comma
l_int|18
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;H1440&quot;
)brace
comma
multiline_comment|/*  7 1.44MB 3.5&quot;   */
(brace
l_int|5760
comma
l_int|36
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x43
comma
l_int|0xAF
comma
l_int|0x54
comma
l_string|&quot;E2880&quot;
)brace
comma
multiline_comment|/*  8 2.88MB 3.5&quot;   */
(brace
l_int|5760
comma
l_int|36
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x43
comma
l_int|0xAF
comma
l_int|0x54
comma
l_string|&quot;CompaQ&quot;
)brace
comma
multiline_comment|/*  9 2.88MB 3.5&quot;   */
(brace
l_int|2880
comma
l_int|18
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x02
comma
l_string|&quot;h1440&quot;
)brace
comma
multiline_comment|/* 10 1.44MB 5.25&quot;  */
(brace
l_int|3360
comma
l_int|21
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x00
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;H1680&quot;
)brace
comma
multiline_comment|/* 11 1.68MB 3.5&quot;   */
(brace
l_int|820
comma
l_int|10
comma
l_int|2
comma
l_int|41
comma
l_int|1
comma
l_int|0x25
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;h410&quot;
)brace
comma
multiline_comment|/* 12 410KB 5.25&quot;   */
(brace
l_int|1640
comma
l_int|10
comma
l_int|2
comma
l_int|82
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;H820&quot;
)brace
comma
multiline_comment|/* 13 820KB 3.5&quot;    */
(brace
l_int|2952
comma
l_int|18
comma
l_int|2
comma
l_int|82
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x02
comma
l_string|&quot;h1476&quot;
)brace
comma
multiline_comment|/* 14 1.48MB 5.25&quot;  */
(brace
l_int|3444
comma
l_int|21
comma
l_int|2
comma
l_int|82
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x0C
comma
l_string|&quot;H1722&quot;
)brace
comma
multiline_comment|/* 15 1.72MB 3.5&quot;   */
(brace
l_int|840
comma
l_int|10
comma
l_int|2
comma
l_int|42
comma
l_int|1
comma
l_int|0x25
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;h420&quot;
)brace
comma
multiline_comment|/* 16 420KB 5.25&quot;   */
(brace
l_int|1660
comma
l_int|10
comma
l_int|2
comma
l_int|83
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;H830&quot;
)brace
comma
multiline_comment|/* 17 830KB 3.5&quot;    */
(brace
l_int|2988
comma
l_int|18
comma
l_int|2
comma
l_int|83
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x02
comma
l_string|&quot;h1494&quot;
)brace
comma
multiline_comment|/* 18 1.49MB 5.25&quot;  */
(brace
l_int|3486
comma
l_int|21
comma
l_int|2
comma
l_int|83
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x0C
comma
l_string|&quot;H1743&quot;
)brace
comma
multiline_comment|/* 19 1.74 MB 3.5&quot;  */
(brace
l_int|1760
comma
l_int|11
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x09
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;d880&quot;
)brace
comma
multiline_comment|/* 20 880KB 5.25&quot;   */
(brace
l_int|2080
comma
l_int|13
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x01
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;D1040&quot;
)brace
comma
multiline_comment|/* 21 1.04MB 3.5&quot;   */
(brace
l_int|2240
comma
l_int|14
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x19
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;D1120&quot;
)brace
comma
multiline_comment|/* 22 1.12MB 3.5&quot;   */
(brace
l_int|3200
comma
l_int|20
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x20
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;h1600&quot;
)brace
comma
multiline_comment|/* 23 1.6MB 5.25&quot;   */
(brace
l_int|3520
comma
l_int|22
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x08
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;H1760&quot;
)brace
comma
multiline_comment|/* 24 1.76MB 3.5&quot;   */
(brace
l_int|3840
comma
l_int|24
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x18
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;H1920&quot;
)brace
comma
multiline_comment|/* 25 1.92MB 3.5&quot;   */
(brace
l_int|6400
comma
l_int|40
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x5B
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;E3200&quot;
)brace
comma
multiline_comment|/* 26 3.20MB 3.5&quot;   */
(brace
l_int|7040
comma
l_int|44
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x5B
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;E3520&quot;
)brace
comma
multiline_comment|/* 27 3.52MB 3.5&quot;   */
(brace
l_int|7680
comma
l_int|48
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x63
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;E3840&quot;
)brace
comma
multiline_comment|/* 28 3.84MB 3.5&quot;   */
(brace
l_int|3680
comma
l_int|23
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x10
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;H1840&quot;
)brace
comma
multiline_comment|/* 29 1.84MB 3.5&quot;   */
(brace
l_int|1600
comma
l_int|10
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;D800&quot;
)brace
comma
multiline_comment|/* 30 800KB 3.5&quot;    */
(brace
l_int|3200
comma
l_int|20
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x00
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;H1600&quot;
)brace
comma
multiline_comment|/* 31 1.6MB 3.5&quot;    */
)brace
suffix:semicolon
DECL|macro|NUMBER
mdefine_line|#define&t;NUMBER(x)&t;(sizeof(x) / sizeof(*(x)))
DECL|macro|SECTSIZE
mdefine_line|#define SECTSIZE ( _FD_SECTSIZE(*floppy))
multiline_comment|/* Auto-detection: Disk type used until the next media change occurs. */
DECL|variable|current_type
r_struct
id|floppy_struct
op_star
id|current_type
(braket
id|N_DRIVE
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
macro_line|#ifdef HAVE_2_CONTROLLERS
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/*&n; * User-provided type information. current_type points to&n; * the respective entry of this array.&n; */
DECL|variable|user_params
r_struct
id|floppy_struct
id|user_params
(braket
id|N_DRIVE
)braket
suffix:semicolon
DECL|variable|floppy_sizes
r_static
r_int
id|floppy_sizes
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/*&n; * The driver is trying to determine the correct media format&n; * while probing is set. rw_interrupt() clears it after a&n; * successful access.&n; */
DECL|variable|probing
r_static
r_int
id|probing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Synchronization of FDC access. */
DECL|macro|FD_COMMAND_DETECT
mdefine_line|#define FD_COMMAND_DETECT -2
DECL|macro|FD_COMMAND_NONE
mdefine_line|#define FD_COMMAND_NONE -1
DECL|macro|FD_COMMAND_ERROR
mdefine_line|#define FD_COMMAND_ERROR 2
DECL|macro|FD_COMMAND_OKAY
mdefine_line|#define FD_COMMAND_OKAY 3
DECL|variable|command_status
DECL|variable|fdc_busy
r_static
r_volatile
r_int
id|command_status
op_assign
id|FD_COMMAND_NONE
comma
id|fdc_busy
op_assign
l_int|0
suffix:semicolon
DECL|variable|fdc_wait
DECL|variable|command_done
r_static
r_struct
id|wait_queue
op_star
id|fdc_wait
op_assign
l_int|NULL
comma
op_star
id|command_done
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Errors during formatting are counted here. */
DECL|variable|format_errors
r_static
r_int
id|format_errors
suffix:semicolon
multiline_comment|/* Format request descriptor. */
DECL|variable|format_req
r_static
r_struct
id|format_descr
id|format_req
suffix:semicolon
multiline_comment|/*&n; * Rate is 0 for 500kb/s, 1 for 300kbps, 2 for 250kbps&n; * Spec1 is 0xSH, where S is stepping rate (F=1ms, E=2ms, D=3ms etc),&n; * H is head unload time (1=16ms, 2=32ms, etc)&n; */
multiline_comment|/*&n; * Track buffer&n; * Because these are written to by the DMA controller, they must&n; * not contain a 64k byte boundary crossing, or data will be&n; * corrupted/lost. Alignment of these is enforced in boot/head.S.&n; * Note that you must not change the sizes below without updating head.S.&n; */
r_extern
r_char
id|floppy_track_buffer
(braket
l_int|512
op_star
l_int|2
op_star
id|MAX_BUFFER_SECTORS
)braket
suffix:semicolon
DECL|variable|errors
r_int
op_star
id|errors
suffix:semicolon
DECL|typedef|done_f
r_typedef
r_void
(paren
op_star
id|done_f
)paren
(paren
r_int
)paren
suffix:semicolon
DECL|struct|cont_t
r_struct
id|cont_t
(brace
DECL|member|interrupt
r_void
(paren
op_star
id|interrupt
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* this is called after the interrupt of the&n;&t;&t;&t;  * main command */
DECL|member|redo
r_void
(paren
op_star
id|redo
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* this is called to retry the operation */
DECL|member|error
r_void
(paren
op_star
id|error
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* this is called to tally an error */
DECL|member|done
id|done_f
id|done
suffix:semicolon
multiline_comment|/* this is called to say if the operation has succeeded/failed */
DECL|variable|cont
)brace
op_star
id|cont
suffix:semicolon
r_static
r_void
id|floppy_ready
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|recalibrate_floppy
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|seek_floppy
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|floppy_shutdown
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|floppy_grab_irq_and_dma
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|floppy_release_irq_and_dma
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * The &quot;reset&quot; variable should be tested whenever an interrupt is scheduled,&n; * after the commands have been sent. This is to ensure that the driver doesn&squot;t&n; * get wedged when the interrupt doesn&squot;t come because of a failed command.&n; * reset doesn&squot;t need to be tested before sending commands, because&n; * output_byte is automatically disabled when reset is set.&n; */
DECL|macro|CHECK_RESET
mdefine_line|#define CHECK_RESET { if ( FDCS-&gt;reset ){ reset_fdc(); return ; } }
r_static
r_void
id|reset_fdc
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * These are global variables, as that&squot;s the easiest way to give&n; * information to interrupts. They are the data used for the current&n; * request.&n; */
DECL|macro|NO_TRACK
mdefine_line|#define NO_TRACK -1
DECL|macro|NEED_1_RECAL
mdefine_line|#define NEED_1_RECAL -2
DECL|macro|NEED_2_RECAL
mdefine_line|#define NEED_2_RECAL -3
multiline_comment|/* buffer related variables */
DECL|variable|buffer_track
r_static
r_int
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|buffer_drive
r_static
r_int
id|buffer_drive
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|buffer_min
r_static
r_int
id|buffer_min
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|buffer_max
r_static
r_int
id|buffer_max
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef FDC_FIFO_BUG
DECL|variable|force
r_static
r_int
id|force
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/* fdc related variables, should end up in a struct */
DECL|variable|fdc_state
r_static
r_struct
id|floppy_fdc_state
id|fdc_state
(braket
id|N_FDC
)braket
suffix:semicolon
DECL|variable|fdc
r_int
id|fdc
suffix:semicolon
multiline_comment|/* current fdc */
DECL|variable|floppy
r_static
r_struct
id|floppy_struct
op_star
id|floppy
op_assign
id|floppy_type
suffix:semicolon
DECL|variable|current_drive
r_static
r_int
r_char
id|current_drive
op_assign
l_int|255
suffix:semicolon
DECL|variable|current_count_sectors
r_static
r_int
id|current_count_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_addr
r_static
r_char
op_star
id|current_addr
op_assign
l_int|0
suffix:semicolon
DECL|variable|sector_t
r_static
r_int
r_char
id|sector_t
suffix:semicolon
multiline_comment|/* sector in track */
macro_line|#ifdef DEBUGT
DECL|variable|debugtimer
r_int
r_int
id|debugtimer
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Debugging&n; * =========&n; */
DECL|function|set_debugt
r_static
r_inline
r_void
id|set_debugt
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUGT
id|debugtimer
op_assign
id|jiffies
suffix:semicolon
macro_line|#endif
)brace
DECL|function|debugt
r_static
r_inline
r_void
id|debugt
c_func
(paren
r_char
op_star
id|message
)paren
(brace
macro_line|#ifdef DEBUGT
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|DEBUGT
)paren
id|printk
c_func
(paren
l_string|&quot;%s dtime=%lu&bslash;n&quot;
comma
id|message
comma
id|jiffies
op_minus
id|debugtimer
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * Bottom half floppy driver.&n; * ==========================&n; *&n; * This part of the file contains the code talking directly to the hardware,&n; * and also the main service loop (seek-configure-spinup-command)&n; */
DECL|function|set_dor
r_static
r_int
id|set_dor
c_func
(paren
r_int
id|fdc
comma
r_char
id|mask
comma
r_char
id|data
)paren
(brace
r_register
r_int
r_char
id|drive
comma
id|unit
comma
id|newdor
comma
id|olddor
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|olddor
op_assign
id|FDCS-&gt;dor
suffix:semicolon
id|newdor
op_assign
(paren
id|olddor
op_amp
id|mask
)paren
op_or
id|data
suffix:semicolon
r_if
c_cond
(paren
id|newdor
op_ne
id|olddor
)paren
(brace
id|unit
op_assign
id|olddor
op_amp
l_int|0x3
suffix:semicolon
id|drive
op_assign
id|REVDRIVE
c_func
(paren
id|fdc
comma
id|unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|olddor
op_amp
(paren
l_int|0x10
op_lshift
id|unit
)paren
)paren
(brace
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|FD_DIR
)paren
op_amp
l_int|0x80
)paren
id|UDRS-&gt;flags
op_or_assign
id|FD_VERIFY
suffix:semicolon
r_else
id|UDRS-&gt;last_checked
op_assign
id|jiffies
suffix:semicolon
)brace
id|FDCS-&gt;dor
op_assign
id|newdor
suffix:semicolon
id|outb_p
c_func
(paren
id|newdor
comma
id|FD_DOR
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
id|olddor
suffix:semicolon
)brace
DECL|function|twaddle
r_static
r_void
id|twaddle
c_func
(paren
r_void
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|FDCS-&gt;dor
op_amp
op_complement
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
comma
id|FD_DOR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|FDCS-&gt;dor
comma
id|FD_DOR
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* reset all driver information about the current fdc. This is needed after&n; * a reset, and after a raw command. */
DECL|function|reset_fdc_info
r_static
r_void
id|reset_fdc_info
c_func
(paren
r_int
id|mode
)paren
(brace
r_int
id|drive
suffix:semicolon
id|FDCS-&gt;spec1
op_assign
id|FDCS-&gt;spec2
op_assign
op_minus
l_int|1
suffix:semicolon
id|FDCS-&gt;need_configure
op_assign
l_int|1
suffix:semicolon
id|FDCS-&gt;perp_mode
op_assign
l_int|1
suffix:semicolon
id|FDCS-&gt;rawcmd
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|N_DRIVE
suffix:semicolon
id|drive
op_increment
)paren
r_if
c_cond
(paren
id|FDC
c_func
(paren
id|drive
)paren
op_eq
id|fdc
op_logical_and
(paren
id|mode
op_logical_or
id|UDRS-&gt;track
op_ne
id|NEED_1_RECAL
)paren
)paren
id|UDRS-&gt;track
op_assign
id|NEED_2_RECAL
suffix:semicolon
)brace
multiline_comment|/* selects the fdc and drive, and enables the fdc&squot;s input/dma. */
DECL|function|set_fdc
r_static
r_void
id|set_fdc
c_func
(paren
r_int
id|drive
)paren
(brace
r_if
c_cond
(paren
id|drive
op_ge
l_int|0
)paren
(brace
id|fdc
op_assign
id|FDC
c_func
(paren
id|drive
)paren
suffix:semicolon
id|current_drive
op_assign
id|drive
suffix:semicolon
)brace
id|set_dor
c_func
(paren
id|fdc
comma
op_complement
l_int|0
comma
l_int|8
)paren
suffix:semicolon
macro_line|#ifdef HAVE_2_CONTROLLERS
id|set_dor
c_func
(paren
l_int|1
op_minus
id|fdc
comma
op_complement
l_int|8
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|FDCS-&gt;rawcmd
op_eq
l_int|2
)paren
id|reset_fdc_info
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|FD_STATUS
)paren
op_ne
id|STATUS_READY
)paren
(brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* locks the driver */
DECL|function|lock_fdc
r_static
r_void
id|lock_fdc
c_func
(paren
r_int
id|drive
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fdc_busy
)paren
id|sleep_on
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
id|fdc_busy
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|command_status
op_assign
id|FD_COMMAND_NONE
suffix:semicolon
id|set_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_ge
l_int|0
)paren
(brace
id|timer_table
(braket
id|FLOPPY_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|DP-&gt;timeout
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|FLOPPY_TIMER
suffix:semicolon
)brace
)brace
multiline_comment|/* unlocks the driver */
DECL|function|unlock_fdc
r_static
r_inline
r_int
id|unlock_fdc
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|current_drive
OL
id|N_DRIVE
)paren
id|floppy_off
c_func
(paren
id|current_drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fdc_busy
)paren
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: FDC access conflict!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEVICE_INTR
)paren
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;:device interrupt still active at FDC release: %p!&bslash;n&quot;
comma
id|DEVICE_INTR
)paren
suffix:semicolon
id|command_status
op_assign
id|FD_COMMAND_NONE
suffix:semicolon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|FLOPPY_TIMER
)paren
suffix:semicolon
id|fdc_busy
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* switches the motor off after a given timeout */
DECL|function|motor_off_callback
r_static
r_void
id|motor_off_callback
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
r_int
r_char
id|mask
op_assign
op_complement
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|nr
)paren
)paren
suffix:semicolon
id|set_dor
c_func
(paren
id|FDC
c_func
(paren
id|nr
)paren
comma
id|mask
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|motor_off_timer
r_static
r_struct
id|timer_list
id|motor_off_timer
(braket
id|N_DRIVE
)braket
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|1
comma
id|motor_off_callback
)brace
macro_line|#ifdef HAVE_2_CONTROLLERS
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|2
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|3
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|4
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|5
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|6
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|7
comma
id|motor_off_callback
)brace
macro_line|#endif
)brace
suffix:semicolon
multiline_comment|/* schedules motor off */
DECL|function|floppy_off
r_static
r_void
id|floppy_off
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
r_int
r_int
r_volatile
id|delta
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
id|motor_off_timer
op_plus
id|nr
)paren
suffix:semicolon
multiline_comment|/* make spindle stop in a position which minimizes spinup time&n;&t; * next time */
r_if
c_cond
(paren
id|drive_params
(braket
id|nr
)braket
dot
id|rps
)paren
(brace
id|delta
op_assign
id|jiffies
op_minus
id|drive_state
(braket
id|nr
)braket
dot
id|first_read_date
op_plus
id|HZ
op_minus
id|drive_params
(braket
id|nr
)braket
dot
id|spindown_offset
suffix:semicolon
id|delta
op_assign
(paren
(paren
id|delta
op_star
id|drive_params
(braket
id|nr
)braket
dot
id|rps
)paren
op_mod
id|HZ
)paren
op_div
id|drive_params
(braket
id|nr
)braket
dot
id|rps
suffix:semicolon
id|motor_off_timer
(braket
id|nr
)braket
dot
id|expires
op_assign
id|drive_params
(braket
id|nr
)braket
dot
id|spindown
op_minus
id|delta
suffix:semicolon
)brace
id|add_timer
c_func
(paren
id|motor_off_timer
op_plus
id|nr
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * cycle through all N_DRIVE floppy drives, for disk change testing.&n; * stopping at current drive. This is done before any long operation, to&n; * be sure to have up to date disk change information.&n; */
DECL|function|scandrives
r_static
r_void
id|scandrives
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|drive
comma
id|saved_drive
suffix:semicolon
id|saved_drive
op_assign
id|current_drive
op_mod
id|N_DRIVE
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_DRIVE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|drive
op_assign
(paren
id|saved_drive
op_plus
id|i
op_plus
l_int|1
)paren
op_mod
id|N_DRIVE
suffix:semicolon
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* skip closed drives */
id|set_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
id|UDRS-&gt;select_date
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|set_dor
c_func
(paren
id|fdc
comma
op_complement
l_int|3
comma
id|UNIT
c_func
(paren
id|drive
)paren
op_or
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|drive
)paren
)paren
)paren
op_amp
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|drive
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* switch the motor off again, if it was off to&n;&t;&t;&t; * begin with */
id|set_dor
c_func
(paren
id|fdc
comma
op_complement
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|drive
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|current_drive
op_assign
id|saved_drive
suffix:semicolon
)brace
DECL|typedef|timeout_fn
r_typedef
r_void
(paren
op_star
id|timeout_fn
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|fd_timer
r_static
r_struct
id|timer_list
id|fd_timer
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* this function makes sure that the disk stays in the drive during the&n; * transfer */
DECL|function|fd_watchdog
r_static
r_void
id|fd_watchdog
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|FD_DIR
)paren
op_amp
l_int|0x80
)paren
(brace
id|floppy_shutdown
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
id|fd_timer.function
op_assign
(paren
id|timeout_fn
)paren
id|fd_watchdog
suffix:semicolon
id|fd_timer.expires
op_assign
l_int|10
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|main_command_interrupt
r_static
r_void
id|main_command_interrupt
c_func
(paren
r_void
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|interrupt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* waits for a delay (spinup or select) to pass */
DECL|function|wait_for_completion
r_static
r_int
id|wait_for_completion
c_func
(paren
r_int
id|nr
comma
r_int
id|delay
comma
id|timeout_fn
id|function
)paren
(brace
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
(brace
id|reset_fdc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* do the reset during sleep to win time&n;&t;&t;&t;      * if we don&squot;t need to sleep, it&squot;s a good&n;&t;&t;&t;      * occasion anyways */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|jiffies
OL
id|delay
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
id|fd_timer.function
op_assign
id|function
suffix:semicolon
id|fd_timer.expires
op_assign
id|delay
op_minus
id|jiffies
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|setup_DMA
r_static
r_void
id|setup_DMA
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef SANITY
r_if
c_cond
(paren
(paren
op_logical_neg
id|CURRENT
op_logical_or
id|CURRENT-&gt;buffer
op_ne
id|current_addr
op_logical_or
id|raw_cmd.length
OG
l_int|512
op_star
id|CURRENT-&gt;nr_sectors
)paren
op_logical_and
(paren
id|current_addr
template_param
id|floppy_track_buffer
op_plus
l_int|1024
op_star
id|MAX_BUFFER_SECTORS
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bad address. start=%p lg=%lx tb=%p&bslash;n&quot;
comma
id|current_addr
comma
id|raw_cmd.length
comma
id|floppy_track_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;buffer=%p nr=%lx cnr=%lx&bslash;n&quot;
comma
id|CURRENT-&gt;buffer
comma
id|CURRENT-&gt;nr_sectors
comma
id|CURRENT-&gt;current_nr_sectors
)paren
suffix:semicolon
)brace
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|current_addr
op_mod
l_int|512
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;non aligned address: %p&bslash;n&quot;
comma
id|current_addr
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|current_addr
op_amp
op_complement
(paren
l_int|64
op_star
l_int|1024
op_minus
l_int|1
)paren
)paren
op_ne
(paren
(paren
r_int
)paren
(paren
id|current_addr
op_plus
id|raw_cmd.length
op_minus
l_int|1
)paren
op_amp
op_complement
(paren
l_int|64
op_star
l_int|1024
op_minus
l_int|1
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DMA crossing 64-K boundary %p-%p&bslash;n&quot;
comma
id|current_addr
comma
id|current_addr
op_plus
id|raw_cmd.length
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|cli
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|FLOPPY_DMA
comma
(paren
id|raw_cmd.flags
op_amp
id|FD_RAW_READ
)paren
ques
c_cond
id|DMA_MODE_READ
suffix:colon
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|FLOPPY_DMA
comma
(paren
r_int
)paren
id|current_addr
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|FLOPPY_DMA
comma
id|raw_cmd.length
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* sends a command byte to the fdc */
DECL|function|output_byte
r_static
r_int
id|output_byte
c_func
(paren
r_char
id|byte
)paren
(brace
r_int
id|counter
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
l_int|10000
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|status
op_assign
id|inb_p
c_func
(paren
id|FD_STATUS
)paren
op_amp
(paren
id|STATUS_READY
op_or
id|STATUS_DIR
op_or
id|STATUS_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|STATUS_READY
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|STATUS_READY
macro_line|#ifdef FDC_FIFO_BUG
op_logical_or
(paren
(paren
id|status
op_eq
id|STATUS_READY
op_or
id|STATUS_DIR
op_or
id|STATUS_BUSY
)paren
op_logical_and
id|force
)paren
macro_line|#endif
)paren
(brace
id|outb_p
c_func
(paren
id|byte
comma
id|FD_DATA
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initialising
)paren
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Unable to send byte to FDC %d (%x)&bslash;n&quot;
comma
id|fdc
comma
id|status
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|macro|LAST_OUT
mdefine_line|#define LAST_OUT(x) if(output_byte(x)){ reset_fdc();return;}
macro_line|#ifdef FDC_FIFO_BUG
DECL|macro|output_byte_force
mdefine_line|#define output_byte_force(x) force=1;output_byte(x);force=0;
macro_line|#else
DECL|macro|output_byte_force
mdefine_line|#define output_byte_force(x) output_byte(x);
macro_line|#endif
multiline_comment|/* gets the response from the fdc */
DECL|function|result
r_static
r_int
id|result
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|counter
comma
id|status
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
l_int|10000
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|status
op_assign
id|inb_p
c_func
(paren
id|FD_STATUS
)paren
op_amp
(paren
id|STATUS_DIR
op_or
id|STATUS_READY
op_or
id|STATUS_BUSY
op_or
id|STATUS_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|STATUS_READY
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|STATUS_READY
)paren
r_return
id|i
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|STATUS_DMA
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
(paren
id|STATUS_DIR
op_or
id|STATUS_READY
op_or
id|STATUS_BUSY
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_ge
id|MAX_REPLIES
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: floppy_stat reply overrun&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|reply_buffer
(braket
id|i
op_increment
)braket
op_assign
id|inb_p
c_func
(paren
id|FD_DATA
)paren
suffix:semicolon
)brace
)brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initialising
)paren
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Getstatus times out (%x) on fdc %d [%d]&bslash;n&quot;
comma
id|status
comma
id|fdc
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Set perpendicular mode as required, based on data rate, if supported.&n; * 82077 Untested! 1Mbps data rate only possible with 82077-1.&n; * TODO: increase MAX_BUFFER_SECTORS, add floppy_type entries.&n; */
DECL|function|perpendicular_mode
r_static
r_inline
r_void
id|perpendicular_mode
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|perp_mode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|floppy
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|floppy-&gt;rate
op_amp
l_int|0x40
)paren
(brace
r_switch
c_cond
(paren
id|raw_cmd.rate
)paren
(brace
r_case
l_int|0
suffix:colon
id|perp_mode
op_assign
multiline_comment|/*2*/
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|perp_mode
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Invalid data rate for perpendicular mode!&bslash;n&quot;
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* convenient way to return to&n;&t;&t;&t;&t;&t;  * redo without to much hassle (deep&n;&t;&t;&t;&t;&t;  * stack et al. */
r_return
suffix:semicolon
)brace
)brace
r_else
id|perp_mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;perp_mode
op_eq
id|perp_mode
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;version
op_ge
id|FDC_82077_ORIG
op_logical_and
id|FDCS-&gt;has_fifo
)paren
(brace
id|output_byte
c_func
(paren
id|FD_PERPENDICULAR
)paren
suffix:semicolon
id|output_byte_force
c_func
(paren
id|perp_mode
)paren
suffix:semicolon
id|FDCS-&gt;perp_mode
op_assign
id|perp_mode
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|perp_mode
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: perpendicular mode not supported by this FDC.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* perpendicular_mode */
DECL|macro|NOMINAL_DTR
mdefine_line|#define NOMINAL_DTR 500
multiline_comment|/* Issue a &quot;SPECIFY&quot; command to set the step rate time, head unload time,&n; * head load time, and DMA disable flag to values needed by floppy.&n; *&n; * The value &quot;dtr&quot; is the data transfer rate in Kbps.  It is needed&n; * to account for the data rate-based scaling done by the 82072 and 82077&n; * FDC types.  This parameter is ignored for other types of FDCs (i.e.&n; * 8272a).&n; *&n; * Note that changing the data transfer rate has a (probably deleterious)&n; * effect on the parameters subject to scaling for 82072/82077 FDCs, so&n; * fdc_specify is called again after each data transfer rate&n; * change.&n; *&n; * srt: 1000 to 16000 in microseconds&n; * hut: 16 to 240 milliseconds&n; * hlt: 2 to 254 milliseconds&n; *&n; * These values are rounded up to the next highest available delay time.&n; */
DECL|function|fdc_specify
r_static
r_void
id|fdc_specify
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|spec1
comma
id|spec2
suffix:semicolon
r_int
id|srt
comma
id|hlt
comma
id|hut
suffix:semicolon
r_int
r_int
id|dtr
op_assign
id|NOMINAL_DTR
suffix:semicolon
r_int
r_int
id|scale_dtr
op_assign
id|NOMINAL_DTR
suffix:semicolon
r_int
id|hlt_max_code
op_assign
l_int|0x7f
suffix:semicolon
r_int
id|hut_max_code
op_assign
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;need_configure
op_logical_and
id|FDCS-&gt;has_fifo
)paren
(brace
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
r_return
suffix:semicolon
multiline_comment|/* Turn on FIFO for 82077-class FDC (improves performance) */
multiline_comment|/* TODO: lock this in via LOCK during initialization */
id|output_byte
c_func
(paren
id|FD_CONFIGURE
)paren
suffix:semicolon
id|output_byte_force
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|0x1A
)paren
suffix:semicolon
multiline_comment|/* FIFO on, polling off, 10 byte threshold */
id|output_byte_force
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* precompensation from track 0 upwards */
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
(brace
id|FDCS-&gt;has_fifo
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|FDCS-&gt;need_configure
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*printk(DEVICE_NAME &quot;: FIFO enabled&bslash;n&quot;);*/
)brace
r_switch
c_cond
(paren
id|raw_cmd.rate
op_amp
l_int|0x03
)paren
(brace
r_case
l_int|3
suffix:colon
id|dtr
op_assign
l_int|1000
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|dtr
op_assign
l_int|300
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|dtr
op_assign
l_int|250
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FDCS-&gt;version
op_ge
id|FDC_82072
)paren
(brace
id|scale_dtr
op_assign
id|dtr
suffix:semicolon
id|hlt_max_code
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* 0==256msec*dtr0/dtr (not linear!) */
id|hut_max_code
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* 0==256msec*dtr0/dtr (not linear!) */
)brace
multiline_comment|/* Convert step rate from microseconds to milliseconds and 4 bits */
id|srt
op_assign
l_int|16
op_minus
(paren
id|DP-&gt;srt
op_star
id|scale_dtr
op_div
l_int|1000
op_plus
id|NOMINAL_DTR
op_minus
l_int|1
)paren
op_div
id|NOMINAL_DTR
suffix:semicolon
r_if
c_cond
(paren
id|srt
OG
l_int|0xf
)paren
id|srt
op_assign
l_int|0xf
suffix:semicolon
r_else
r_if
c_cond
(paren
id|srt
OL
l_int|0
)paren
id|srt
op_assign
l_int|0
suffix:semicolon
id|hlt
op_assign
(paren
id|DP-&gt;hlt
op_star
id|scale_dtr
op_div
l_int|2
op_plus
id|NOMINAL_DTR
op_minus
l_int|1
)paren
op_div
id|NOMINAL_DTR
suffix:semicolon
r_if
c_cond
(paren
id|hlt
OL
l_int|0x01
)paren
id|hlt
op_assign
l_int|0x01
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hlt
OG
l_int|0x7f
)paren
id|hlt
op_assign
id|hlt_max_code
suffix:semicolon
id|hut
op_assign
(paren
id|DP-&gt;hut
op_star
id|scale_dtr
op_div
l_int|16
op_plus
id|NOMINAL_DTR
op_minus
l_int|1
)paren
op_div
id|NOMINAL_DTR
suffix:semicolon
r_if
c_cond
(paren
id|hut
OL
l_int|0x1
)paren
id|hut
op_assign
l_int|0x1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hut
OG
l_int|0xf
)paren
id|hut
op_assign
id|hut_max_code
suffix:semicolon
id|spec1
op_assign
(paren
id|srt
op_lshift
l_int|4
)paren
op_or
id|hut
suffix:semicolon
DECL|macro|fd_disable_dma
mdefine_line|#define fd_disable_dma 0
id|spec2
op_assign
(paren
id|hlt
op_lshift
l_int|1
)paren
op_or
id|fd_disable_dma
suffix:semicolon
multiline_comment|/* If these parameters did not change, just return with success */
r_if
c_cond
(paren
id|FDCS-&gt;spec1
op_ne
id|spec1
op_logical_or
id|FDCS-&gt;spec2
op_ne
id|spec2
)paren
(brace
multiline_comment|/* Go ahead and set spec1 and spec2 */
id|output_byte
c_func
(paren
id|FD_SPECIFY
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FDCS-&gt;spec1
op_assign
id|spec1
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FDCS-&gt;spec2
op_assign
id|spec2
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* fdc_specify */
multiline_comment|/* Set the FDC&squot;s data transfer rate on behalf of the specified drive.&n; * NOTE: with 82072/82077 FDCs, changing the data rate requires a reissue&n; * of the specify command (i.e. using the fdc_specify function).&n; */
DECL|function|fdc_dtr
r_static
r_void
id|fdc_dtr
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* If data rate not already set to desired value, set it. */
r_if
c_cond
(paren
id|raw_cmd.rate
op_eq
id|FDCS-&gt;dtr
)paren
r_return
suffix:semicolon
multiline_comment|/* Set dtr */
id|outb_p
c_func
(paren
id|raw_cmd.rate
comma
id|FD_DCR
)paren
suffix:semicolon
multiline_comment|/* TODO: some FDC/drive combinations (C&amp;T 82C711 with TEAC 1.2MB)&n;&t; * need a stabilization period of several milliseconds to be&n;&t; * enforced after data rate changes before R/W operations.&n;&t; * Pause 5 msec to avoid trouble.&n;&t; */
id|udelay
c_func
(paren
l_int|5000
)paren
suffix:semicolon
id|FDCS-&gt;dtr
op_assign
id|raw_cmd.rate
suffix:semicolon
)brace
multiline_comment|/* fdc_dtr */
DECL|function|tell_sector
r_static
r_void
id|tell_sector
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;: track %d, head %d, sector %d, size %d&quot;
comma
id|R_TRACK
comma
id|R_HEAD
comma
id|R_SECTOR
comma
id|R_SIZECODE
)paren
suffix:semicolon
)brace
multiline_comment|/* tell_sector */
multiline_comment|/*&n; * Ok, this error interpreting routine is called after a&n; * DMA read/write has succeeded&n; * or failed, so we check the results, and copy any buffers.&n; * hhb: Added better error reporting.&n; * ak: Made this into a separate routine.&n; */
DECL|function|interpret_errors
r_static
r_int
id|interpret_errors
c_func
(paren
r_void
)paren
(brace
r_char
id|bad
suffix:semicolon
r_if
c_cond
(paren
id|inr
op_ne
l_int|7
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: -- FDC reply error&quot;
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* check IC to find cause of interrupt */
r_switch
c_cond
(paren
(paren
id|ST0
op_amp
id|ST0_INTR
)paren
op_rshift
l_int|6
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* error occured during command execution */
id|bad
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_WP
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Drive %d is write protected&bslash;n&quot;
comma
id|current_drive
)paren
suffix:semicolon
id|DRS-&gt;flags
op_and_assign
op_complement
id|FD_DISK_WRITABLE
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|bad
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_ND
)paren
(brace
id|DRS-&gt;flags
op_or_assign
id|FD_NEED_TWADDLE
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_OR
)paren
(brace
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FTD_MSG
)paren
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Over/Underrun - retrying&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* could continue from where we stopped, but ... */
id|bad
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|errors
op_ge
id|DP-&gt;max_errors.reporting
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot; %d: &quot;
comma
id|ST0
op_amp
id|ST0_DS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ST0
op_amp
id|ST0_ECE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Recalibrate failed!&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_CRC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;data CRC error&quot;
)paren
suffix:semicolon
id|tell_sector
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_CRC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CRC error&quot;
)paren
suffix:semicolon
id|tell_sector
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ST1
op_amp
(paren
id|ST1_MAM
op_or
id|ST1_ND
)paren
)paren
op_logical_or
(paren
id|ST2
op_amp
id|ST2_MAM
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|probing
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sector not found&quot;
)paren
suffix:semicolon
id|tell_sector
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;probe failed...&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_WC
)paren
(brace
multiline_comment|/* seek error */
id|printk
c_func
(paren
l_string|&quot;wrong cylinder&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_BC
)paren
(brace
multiline_comment|/* cylinder marked as bad */
id|printk
c_func
(paren
l_string|&quot;bad cylinder&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;unknown error. ST[0..3] are: 0x%x 0x%x 0x%x 0x%x&bslash;n&quot;
comma
id|ST0
comma
id|ST1
comma
id|ST2
comma
id|ST3
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_WC
op_logical_or
id|ST2
op_amp
id|ST2_BC
)paren
multiline_comment|/* wrong cylinder =&gt; recal */
id|DRS-&gt;track
op_assign
id|NEED_2_RECAL
suffix:semicolon
r_return
id|bad
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* invalid command given */
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Invalid FDC command given!&bslash;n&quot;
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Abnormal termination caused by polling&bslash;n&quot;
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* (0) Normal command termination */
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This routine is called when everything should be correctly set up&n; * for the transfer (ie floppy motor is on, the correct floppy is&n; * selected, and the head is sitting on the right track).&n; */
DECL|function|setup_rw_floppy
r_static
r_void
id|setup_rw_floppy
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|ready_date
comma
id|r
comma
id|flags
comma
id|dflags
suffix:semicolon
id|timeout_fn
id|function
suffix:semicolon
id|flags
op_assign
id|raw_cmd.flags
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|FD_RAW_READ
op_or
id|FD_RAW_WRITE
)paren
)paren
id|flags
op_or_assign
id|FD_RAW_INTR
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|FD_RAW_SPIN
)paren
(brace
id|ready_date
op_assign
id|DRS-&gt;spinup_date
op_plus
id|DP-&gt;spinup
suffix:semicolon
multiline_comment|/* If spinup will take a long time, rerun scandrives&n;&t;&t; * again just before spinup completion. Beware that&n;&t;&t; * after scandrives, we must again wait for selection.&n;&t;&t; */
r_if
c_cond
(paren
id|ready_date
OG
id|jiffies
op_plus
id|DP-&gt;select_delay
)paren
(brace
id|ready_date
op_sub_assign
id|DP-&gt;select_delay
suffix:semicolon
id|function
op_assign
(paren
id|timeout_fn
)paren
id|floppy_on
suffix:semicolon
)brace
r_else
id|function
op_assign
(paren
id|timeout_fn
)paren
id|setup_rw_floppy
suffix:semicolon
multiline_comment|/* wait until the floppy is spinning fast enough */
r_if
c_cond
(paren
id|wait_for_completion
c_func
(paren
id|current_drive
comma
id|ready_date
comma
id|function
)paren
)paren
r_return
suffix:semicolon
)brace
id|dflags
op_assign
id|DRS-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|FD_RAW_READ
)paren
op_logical_or
(paren
id|flags
op_amp
id|FD_RAW_WRITE
)paren
)paren
(brace
r_if
c_cond
(paren
id|flags
op_amp
id|FD_RAW_USER_SUPPLIED
)paren
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|setup_DMA
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|flags
op_amp
id|FD_RAW_INTR
)paren
id|SET_INTR
c_func
(paren
id|main_command_interrupt
)paren
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|raw_cmd.cmd_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|r
op_or_assign
id|output_byte
c_func
(paren
id|raw_cmd.cmd
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;rw_command: &quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|r
)paren
(brace
id|reset_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|FD_RAW_INTR
)paren
)paren
(brace
id|inr
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|interrupt
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|FD_RAW_NEED_DISK
)paren
id|fd_watchdog
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the routine called after every seek (or recalibrate) interrupt&n; * from the floppy controller.&n; */
DECL|function|seek_interrupt
r_static
r_void
id|seek_interrupt
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;seek interrupt:&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|inr
op_ne
l_int|2
op_logical_or
(paren
id|ST0
op_amp
l_int|0xF8
)paren
op_ne
l_int|0x20
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: seek failed&bslash;n&quot;
)paren
suffix:semicolon
id|DRS-&gt;track
op_assign
id|NEED_2_RECAL
suffix:semicolon
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DRS-&gt;track
op_ge
l_int|0
op_logical_and
id|DRS-&gt;track
op_ne
id|ST1
)paren
id|DRS-&gt;flags
op_and_assign
op_complement
id|FD_DISK_NEWCHANGE
suffix:semicolon
id|DRS-&gt;track
op_assign
id|ST1
suffix:semicolon
id|seek_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|seek_floppy
r_static
r_void
id|seek_floppy
c_func
(paren
r_void
)paren
(brace
r_int
id|track
suffix:semicolon
r_if
c_cond
(paren
(paren
id|raw_cmd.flags
op_amp
id|FD_RAW_NEED_DISK
)paren
op_logical_and
op_logical_neg
(paren
id|DRS-&gt;flags
op_amp
id|FD_DISK_NEWCHANGE
)paren
op_logical_and
(paren
id|inb_p
c_func
(paren
id|FD_DIR
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
multiline_comment|/* the media changed flag should be cleared after the seek.&n;&t;&t; * If it isn&squot;t, this means that there is really no disk in&n;&t;&t; * the drive.&n;&t;&t; */
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DRS-&gt;track
op_le
id|NEED_1_RECAL
)paren
(brace
id|recalibrate_floppy
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|DRS-&gt;flags
op_amp
id|FD_DISK_NEWCHANGE
)paren
op_logical_and
(paren
id|DRS-&gt;track
op_le
id|NO_TRACK
op_logical_or
id|DRS-&gt;track
op_eq
id|raw_cmd.track
)paren
)paren
(brace
multiline_comment|/* we seek to clear the media-changed condition. Does anybody&n;&t;&t; * know a more elegant way, which works on all drives? */
r_if
c_cond
(paren
id|raw_cmd.track
)paren
id|track
op_assign
id|raw_cmd.track
op_minus
l_int|1
suffix:semicolon
r_else
id|track
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|raw_cmd.track
op_ne
id|DRS-&gt;track
)paren
id|track
op_assign
id|raw_cmd.track
suffix:semicolon
r_else
(brace
id|setup_rw_floppy
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|track
op_logical_and
id|DRS-&gt;track
op_ge
l_int|0
op_logical_and
id|DRS-&gt;track
OL
l_int|80
)paren
(brace
id|DRS-&gt;flags
op_and_assign
op_complement
id|FD_DISK_NEWCHANGE
suffix:semicolon
multiline_comment|/* if we go to track 0 anyways, we can just as well use&n;&t;&t; * recalibrate */
id|recalibrate_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|SET_INTR
c_func
(paren
id|seek_interrupt
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_SEEK
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
id|LAST_OUT
c_func
(paren
id|track
)paren
suffix:semicolon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;seek command:&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
DECL|function|recal_interrupt
r_static
r_void
id|recal_interrupt
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;recal interrupt:&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|inr
op_ne
l_int|2
)paren
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ST0
op_amp
id|ST0_ECE
)paren
(brace
r_switch
c_cond
(paren
id|DRS-&gt;track
)paren
(brace
r_case
id|NEED_1_RECAL
suffix:colon
multiline_comment|/* after a second recalibrate, we still haven&squot;t&n;&t;&t;&t; * reached track 0. Probably no drive */
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NEED_2_RECAL
suffix:colon
multiline_comment|/* If we already did a recalibrate, and we are not at&n;&t;&t;&t; * track 0, this means we have moved. (The only way&n;&t;&t;&t; * not to move at recalibration is to be already at&n;&t;&t;&t; * track 0.) Clear the new change flag&n;&t;&t;&t; */
id|DRS-&gt;flags
op_and_assign
op_complement
id|FD_DISK_NEWCHANGE
suffix:semicolon
multiline_comment|/* fall through */
r_default
suffix:colon
multiline_comment|/* Recalibrate moves the head by at most 80 steps. If&n;&t;&t;&t; * after one recalibrate we don&squot;t have reached track&n;&t;&t;&t; * 0, this might mean that we started beyond track 80.&n;&t;&t;&t; * Try again.&n;&t;&t;&t; */
id|DRS-&gt;track
op_assign
id|NEED_1_RECAL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
id|DRS-&gt;track
op_assign
id|ST1
suffix:semicolon
id|seek_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Unexpected interrupt - Print as much debugging info as we can...&n; * All bets are off...&n; */
DECL|function|unexpected_floppy_interrupt
r_static
r_void
id|unexpected_floppy_interrupt
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|initialising
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: unexpected interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inr
op_ge
l_int|0
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|inr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d %x&bslash;n&quot;
comma
id|i
comma
id|reply_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
id|inr
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inr
op_ne
l_int|2
)paren
r_break
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sensei&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|inr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d %x&bslash;n&quot;
comma
id|i
comma
id|reply_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* interrupt handler */
DECL|function|floppy_interrupt
r_static
r_void
id|floppy_interrupt
c_func
(paren
r_int
id|unused
)paren
(brace
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
)paren
op_assign
id|DEVICE_INTR
suffix:semicolon
id|CLEAR_INTR
suffix:semicolon
r_if
c_cond
(paren
id|fdc
op_ge
id|N_FDC
)paren
multiline_comment|/* we don&squot;t even know which FDC is the culprit */
r_return
suffix:semicolon
id|inr
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
(brace
id|unexpected_floppy_interrupt
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inr
op_eq
l_int|0
)paren
(brace
r_do
(brace
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
id|inr
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|ST0
op_amp
l_int|0x83
)paren
op_ne
id|UNIT
c_func
(paren
id|current_drive
)paren
op_logical_and
id|inr
op_eq
l_int|2
)paren
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* this should help improve interrupt latency. */
id|handler
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|recalibrate_floppy
r_static
r_void
id|recalibrate_floppy
c_func
(paren
r_void
)paren
(brace
id|SET_INTR
c_func
(paren
id|recal_interrupt
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_RECALIBRATE
)paren
suffix:semicolon
id|LAST_OUT
c_func
(paren
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Must do 4 FD_SENSEIs after reset because of ``drive polling&squot;&squot;.&n; */
DECL|function|reset_interrupt
r_static
r_void
id|reset_interrupt
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;reset interrupt:&quot;
)paren
suffix:semicolon
macro_line|#endif
id|fdc_specify
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* reprogram fdc */
id|result
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* get the status ready for set_fdc */
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* a reset just after a reset. BAD! */
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * reset is done by pulling bit 2 of DOR low for a while (old FDC&squot;s),&n; * or by setting the self clearing bit 7 of STATUS (newer FDC&squot;s)&n; */
DECL|function|reset_fdc
r_static
r_void
id|reset_fdc
c_func
(paren
r_void
)paren
(brace
id|SET_INTR
c_func
(paren
id|reset_interrupt
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|0
suffix:semicolon
id|reset_fdc_info
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;version
op_ge
id|FDC_82077
)paren
id|outb_p
c_func
(paren
l_int|0x80
op_or
(paren
id|FDCS-&gt;dtr
op_amp
l_int|3
)paren
comma
id|FD_STATUS
)paren
suffix:semicolon
r_else
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|FDCS-&gt;dor
op_amp
op_complement
l_int|0x04
comma
id|FD_DOR
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|FD_RESET_DELAY
)paren
suffix:semicolon
id|outb
c_func
(paren
id|FDCS-&gt;dor
comma
id|FD_DOR
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|floppy_shutdown
r_static
r_void
id|floppy_shutdown
c_func
(paren
r_void
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DEVICE_INTR
)paren
(brace
multiline_comment|/* no interrupt pending. Probably has just been&n;&t;&t;&t;      * served */
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|CLEAR_INTR
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initialising
)paren
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: timeout&bslash;n&quot;
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* this will recall reset when needed */
)brace
multiline_comment|/* start motor, check media-changed condition and write protection */
DECL|function|start_motor
r_static
r_int
id|start_motor
c_func
(paren
r_void
)paren
(brace
r_int
id|cnt
suffix:semicolon
r_int
id|dir
suffix:semicolon
r_if
c_cond
(paren
(paren
id|FDCS-&gt;dor
op_amp
l_int|0x03
)paren
op_ne
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
multiline_comment|/* notes select time if floppy is not yet selected */
id|DRS-&gt;select_date
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|FDCS-&gt;dor
op_amp
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
)paren
)paren
(brace
id|set_debugt
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* no read since this drive is running */
id|DRS-&gt;first_read_date
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* note motor start time if motor is not yet running */
id|DRS-&gt;spinup_date
op_assign
id|jiffies
suffix:semicolon
)brace
multiline_comment|/* starts motor and selects floppy */
id|del_timer
c_func
(paren
id|motor_off_timer
op_plus
id|current_drive
)paren
suffix:semicolon
id|set_dor
c_func
(paren
id|fdc
comma
l_int|0xfc
comma
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
op_or
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
id|dir
op_assign
id|inb_p
c_func
(paren
id|FD_DIR
)paren
op_amp
l_int|0x80
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|dir
op_amp
l_int|0x80
)paren
)paren
id|DRS-&gt;last_checked
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|dir
op_logical_or
(paren
id|DRS-&gt;flags
op_amp
id|FD_VERIFY
)paren
)paren
(brace
id|DRS-&gt;flags
op_and_assign
id|FD_DRIVE_PRESENT
op_or
id|FD_DISK_NEWCHANGE
suffix:semicolon
id|DRS-&gt;flags
op_or_assign
id|FD_DISK_WRITABLE
suffix:semicolon
multiline_comment|/* check write protection */
id|output_byte
c_func
(paren
id|FD_GETSTATUS
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cnt
op_assign
id|result
c_func
(paren
)paren
)paren
op_ne
l_int|1
)paren
(brace
id|changed_floppies
op_or_assign
l_int|1
op_lshift
id|current_drive
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
id|DRS-&gt;flags
op_or_assign
id|FD_VERIFY
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|ST3
op_amp
l_int|0x60
)paren
op_eq
l_int|0x60
)paren
id|DRS-&gt;flags
op_and_assign
op_complement
id|FD_DISK_WRITABLE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|DRS-&gt;flags
op_amp
id|FD_DISK_NEWCHANGE
)paren
)paren
(brace
multiline_comment|/* the following code is only executed the first time&n;&t;&t;&t; * a particular disk change has been detected */
id|changed_floppies
op_or_assign
l_int|1
op_lshift
id|current_drive
suffix:semicolon
r_if
c_cond
(paren
id|DRS-&gt;keep_data
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|DP-&gt;flags
op_amp
id|FTD_MSG
)paren
op_logical_and
id|current_type
(braket
id|current_drive
)braket
op_ne
l_int|NULL
)paren
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Disk type is undefined after &quot;
l_string|&quot;disk change in fd%d&bslash;n&quot;
comma
id|current_drive
)paren
suffix:semicolon
id|current_type
(braket
id|current_drive
)braket
op_assign
l_int|NULL
suffix:semicolon
id|floppy_sizes
(braket
id|current_drive
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ST3
op_amp
l_int|0x10
)paren
id|DRS-&gt;track
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|dir
)paren
multiline_comment|/* check if media changed is still on */
id|DRS-&gt;flags
op_or_assign
id|FD_DISK_NEWCHANGE
suffix:semicolon
r_else
(brace
id|DRS-&gt;flags
op_and_assign
op_complement
id|FD_DISK_NEWCHANGE
suffix:semicolon
id|DRS-&gt;last_checked
op_assign
id|jiffies
suffix:semicolon
)brace
r_return
id|DRS-&gt;flags
suffix:semicolon
)brace
DECL|function|floppy_ready
r_static
r_void
id|floppy_ready
c_func
(paren
r_void
)paren
(brace
id|CHECK_RESET
suffix:semicolon
id|start_motor
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait_for_completion also schedules reset if needed. */
r_if
c_cond
(paren
id|wait_for_completion
c_func
(paren
id|current_drive
comma
id|DRS-&gt;select_date
op_plus
id|DP-&gt;select_delay
comma
(paren
id|timeout_fn
)paren
id|floppy_ready
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|fdc_dtr
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd.flags
op_amp
id|FD_RAW_NEED_SEEK
)paren
(brace
id|perpendicular_mode
c_func
(paren
)paren
suffix:semicolon
id|fdc_specify
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* must be done here because of hut, hlt ... */
id|seek_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|setup_rw_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|floppy_on
r_static
r_void
id|floppy_on
c_func
(paren
r_int
r_int
id|drive
)paren
(brace
id|timer_table
(braket
id|FLOPPY_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|DP-&gt;timeout
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|FLOPPY_TIMER
suffix:semicolon
id|scandrives
c_func
(paren
)paren
suffix:semicolon
id|floppy_ready
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ========================================================================&n; * here ends the bottom half. Exported routines are:&n;  * floppy_on, floppy_off, floppy_ready, lock_fdc, unlock_fdc, set_fdc,&n; * start_motor, reset_fdc, reset_fdc_info, interpret_errors.&n; * Initialisation also uses output_byte, result, set_dor, floppy_interrupt&n; * and set_dor.&n; * ========================================================================&n; */
multiline_comment|/*&n; * General purpose continuations.&n; * ==============================&n; */
DECL|function|empty
r_static
r_void
id|empty
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|do_wakeup
r_static
r_void
id|do_wakeup
c_func
(paren
r_void
)paren
(brace
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|FLOPPY_TIMER
)paren
suffix:semicolon
id|command_status
op_add_assign
l_int|2
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|command_done
)paren
suffix:semicolon
id|cont
op_assign
l_int|0
suffix:semicolon
)brace
DECL|variable|wakeup_cont
r_static
r_struct
id|cont_t
id|wakeup_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|wait_til_done
r_static
r_int
id|wait_til_done
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
r_while
c_loop
(paren
id|command_status
OL
l_int|2
)paren
r_if
c_cond
(paren
id|current-&gt;pid
)paren
id|sleep_on
c_func
(paren
op_amp
id|command_done
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
id|command_status
op_assign
id|FD_COMMAND_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|command_status
op_eq
id|FD_COMMAND_OKAY
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
r_else
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|command_status
op_assign
id|FD_COMMAND_NONE
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|generic_done
r_static
r_void
id|generic_done
c_func
(paren
r_int
id|result
)paren
(brace
id|command_status
op_assign
id|result
suffix:semicolon
id|cont
op_assign
op_amp
id|wakeup_cont
suffix:semicolon
)brace
DECL|function|generic_success
r_static
r_void
id|generic_success
c_func
(paren
r_void
)paren
(brace
id|generic_done
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|generic_failure
r_static
r_void
id|generic_failure
c_func
(paren
r_void
)paren
(brace
id|generic_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|success_and_wakeup
r_static
r_void
id|success_and_wakeup
c_func
(paren
r_void
)paren
(brace
id|generic_success
c_func
(paren
)paren
suffix:semicolon
id|do_wakeup
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|failure_and_wakeup
r_static
r_void
id|failure_and_wakeup
c_func
(paren
r_void
)paren
(brace
id|generic_failure
c_func
(paren
)paren
suffix:semicolon
id|do_wakeup
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * formatting and rw support.&n; * ==========================&n; */
DECL|function|next_valid_format
r_static
r_int
id|next_valid_format
c_func
(paren
r_void
)paren
(brace
r_int
id|probed_format
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|probed_format
op_assign
id|DRS-&gt;probed_format
suffix:semicolon
r_if
c_cond
(paren
id|probed_format
OG
id|N_DRIVE
op_logical_or
op_logical_neg
id|DP-&gt;autodetect
(braket
id|probed_format
)braket
)paren
(brace
id|DRS-&gt;probed_format
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|floppy_type
(braket
id|DP-&gt;autodetect
(braket
id|probed_format
)braket
)braket
dot
id|sect
)paren
(brace
id|DRS-&gt;probed_format
op_assign
id|probed_format
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|probed_format
op_increment
suffix:semicolon
)brace
)brace
DECL|function|bad_flp_intr
r_static
r_void
id|bad_flp_intr
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|probing
)paren
(brace
id|DRS-&gt;probed_format
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|next_valid_format
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
)brace
(paren
op_star
id|errors
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|errors
OG
id|DP-&gt;max_errors
dot
m_abort
)paren
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|errors
OG
id|DP-&gt;max_errors.reset
)paren
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|errors
OG
id|DP-&gt;max_errors.recal
)paren
id|DRS-&gt;track
op_assign
id|NEED_2_RECAL
suffix:semicolon
)brace
DECL|function|set_floppy
r_static
r_void
id|set_floppy
c_func
(paren
r_int
id|device
)paren
(brace
r_if
c_cond
(paren
id|TYPE
c_func
(paren
id|device
)paren
)paren
id|floppy
op_assign
id|TYPE
c_func
(paren
id|device
)paren
op_plus
id|floppy_type
suffix:semicolon
r_else
id|floppy
op_assign
id|current_type
(braket
id|DRIVE
c_func
(paren
id|device
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * formatting and support.&n; * =======================&n; */
DECL|function|format_interrupt
r_static
r_void
id|format_interrupt
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|interpret_errors
c_func
(paren
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
r_case
l_int|2
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|setup_format_params
r_static
r_void
id|setup_format_params
c_func
(paren
r_void
)paren
(brace
r_struct
id|fparm
(brace
r_int
r_char
id|track
comma
id|head
comma
id|sect
comma
id|size
suffix:semicolon
)brace
op_star
id|here
op_assign
(paren
r_struct
id|fparm
op_star
)paren
id|floppy_track_buffer
suffix:semicolon
r_int
id|ssize
comma
id|il
comma
id|n
suffix:semicolon
r_int
id|count
comma
id|head_shift
comma
id|track_shift
suffix:semicolon
id|raw_cmd.flags
op_assign
id|FD_RAW_WRITE
op_or
id|FD_RAW_INTR
op_or
id|FD_RAW_SPIN
op_or
id|FD_RAW_NEED_DISK
op_or
id|FD_RAW_NEED_SEEK
suffix:semicolon
id|raw_cmd.rate
op_assign
id|floppy-&gt;rate
op_amp
l_int|0x3
suffix:semicolon
id|raw_cmd.cmd_count
op_assign
id|NR_F
suffix:semicolon
id|COMMAND
op_assign
id|FD_FORMAT
suffix:semicolon
id|DR_SELECT
op_assign
id|UNIT
c_func
(paren
id|current_drive
)paren
op_plus
(paren
id|format_req.head
op_lshift
l_int|2
)paren
suffix:semicolon
id|F_SIZECODE
op_assign
id|FD_SIZECODE
c_func
(paren
id|floppy
)paren
suffix:semicolon
id|ssize
op_assign
l_int|1
op_lshift
(paren
id|F_SIZECODE
op_minus
l_int|2
)paren
suffix:semicolon
id|F_SECT_PER_TRACK
op_assign
id|floppy-&gt;sect
op_div
id|ssize
suffix:semicolon
id|F_GAP
op_assign
id|floppy-&gt;fmt_gap
suffix:semicolon
id|F_FILL
op_assign
id|FD_FILL_BYTE
suffix:semicolon
id|current_addr
op_assign
id|floppy_track_buffer
suffix:semicolon
id|raw_cmd.length
op_assign
l_int|4
op_star
id|F_SECT_PER_TRACK
suffix:semicolon
multiline_comment|/* allow for about 30ms for data transport per track */
id|head_shift
op_assign
(paren
id|F_SECT_PER_TRACK
op_plus
l_int|5
)paren
op_div
l_int|6
suffix:semicolon
multiline_comment|/* a ``cylinder&squot;&squot; is two tracks plus a little stepping time */
id|track_shift
op_assign
l_int|2
op_star
id|head_shift
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* position of logical sector 1 on this track */
id|n
op_assign
(paren
id|track_shift
op_star
id|format_req.track
op_plus
id|head_shift
op_star
id|format_req.head
)paren
op_mod
id|F_SECT_PER_TRACK
suffix:semicolon
multiline_comment|/* determine interleave */
id|il
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|floppy-&gt;sect
OG
id|DP-&gt;interleave_sect
op_logical_and
id|ssize
op_eq
l_int|1
)paren
id|il
op_increment
suffix:semicolon
multiline_comment|/* initialize field */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|F_SECT_PER_TRACK
suffix:semicolon
op_increment
id|count
)paren
(brace
id|here
(braket
id|count
)braket
dot
id|track
op_assign
id|format_req.track
suffix:semicolon
id|here
(braket
id|count
)braket
dot
id|head
op_assign
id|format_req.head
suffix:semicolon
id|here
(braket
id|count
)braket
dot
id|sect
op_assign
l_int|0
suffix:semicolon
id|here
(braket
id|count
)braket
dot
id|size
op_assign
id|F_SIZECODE
suffix:semicolon
)brace
multiline_comment|/* place logical sectors */
r_for
c_loop
(paren
id|count
op_assign
l_int|1
suffix:semicolon
id|count
op_le
id|F_SECT_PER_TRACK
suffix:semicolon
op_increment
id|count
)paren
(brace
id|here
(braket
id|n
)braket
dot
id|sect
op_assign
id|count
suffix:semicolon
id|n
op_assign
(paren
id|n
op_plus
id|il
)paren
op_mod
id|F_SECT_PER_TRACK
suffix:semicolon
r_if
c_cond
(paren
id|here
(braket
id|n
)braket
dot
id|sect
)paren
(brace
multiline_comment|/* sector busy, find next free sector */
op_increment
id|n
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ge
id|F_SECT_PER_TRACK
)paren
(brace
id|n
op_sub_assign
id|F_SECT_PER_TRACK
suffix:semicolon
r_while
c_loop
(paren
id|here
(braket
id|n
)braket
dot
id|sect
)paren
op_increment
id|n
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|redo_format
r_static
r_void
id|redo_format
c_func
(paren
r_void
)paren
(brace
id|raw_cmd.track
op_assign
id|format_req.track
op_lshift
id|floppy-&gt;stretch
suffix:semicolon
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|setup_format_params
c_func
(paren
)paren
suffix:semicolon
id|floppy_on
c_func
(paren
id|current_drive
)paren
suffix:semicolon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;queue format request&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|format_cont
r_static
r_struct
id|cont_t
id|format_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|do_format
r_static
r_int
id|do_format
c_func
(paren
r_int
id|device
comma
r_struct
id|format_descr
op_star
id|tmp_format_req
)paren
(brace
r_int
id|okay
suffix:semicolon
id|lock_fdc
c_func
(paren
id|DRIVE
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
id|set_floppy
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|floppy
op_logical_or
id|tmp_format_req-&gt;track
op_ge
id|floppy-&gt;track
op_logical_or
id|tmp_format_req-&gt;head
op_ge
id|floppy-&gt;head
)paren
(brace
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|format_req
op_assign
op_star
id|tmp_format_req
suffix:semicolon
id|format_errors
op_assign
l_int|0
suffix:semicolon
id|cont
op_assign
op_amp
id|format_cont
suffix:semicolon
id|errors
op_assign
op_amp
id|format_errors
suffix:semicolon
id|redo_format
c_func
(paren
)paren
suffix:semicolon
id|okay
op_assign
id|wait_til_done
c_func
(paren
)paren
suffix:semicolon
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
id|okay
suffix:semicolon
)brace
multiline_comment|/*&n; * Buffer read/write and support&n; * =============================&n; */
multiline_comment|/* new request_done. Can handle physical sectors which are smaller than a&n; * logical buffer */
DECL|function|request_done
r_static
r_void
id|request_done
c_func
(paren
r_int
id|uptodate
)paren
(brace
r_int
id|block
suffix:semicolon
id|probing
op_assign
l_int|0
suffix:semicolon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|FLOPPY_TIMER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CURRENT
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: request list destroyed in floppy request done&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uptodate
)paren
(brace
multiline_comment|/* maintain values for invalidation on geometry&n;&t;&t;   change */
id|block
op_assign
id|current_count_sectors
op_plus
id|CURRENT-&gt;sector
suffix:semicolon
r_if
c_cond
(paren
id|block
OG
id|DRS-&gt;maxblock
)paren
id|DRS-&gt;maxblock
op_assign
id|block
suffix:semicolon
r_if
c_cond
(paren
id|block
OG
id|floppy-&gt;sect
)paren
id|DRS-&gt;maxtrack
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* unlock chained buffers */
r_while
c_loop
(paren
id|current_count_sectors
op_logical_and
id|CURRENT
op_logical_and
id|current_count_sectors
op_ge
id|CURRENT-&gt;current_nr_sectors
)paren
(brace
id|current_count_sectors
op_sub_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current_count_sectors
op_logical_and
id|CURRENT
)paren
(brace
multiline_comment|/* &quot;unlock&quot; last subsector */
id|CURRENT-&gt;buffer
op_add_assign
id|current_count_sectors
op_lshift
l_int|9
suffix:semicolon
id|CURRENT-&gt;current_nr_sectors
op_sub_assign
id|current_count_sectors
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|current_count_sectors
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|current_count_sectors
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current_count_sectors
op_logical_and
op_logical_neg
id|CURRENT
)paren
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;request list destroyed in floppy request done&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef NO_WEIRD_UNLOCKED
r_if
c_cond
(paren
id|CURRENT-&gt;bh
)paren
multiline_comment|/* avoid those pesky &quot;Weird unlocked ... errors&quot; */
id|CURRENT-&gt;bh-&gt;b_req
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Interrupt handler evaluating the result of the r/w operation */
DECL|function|rw_interrupt
r_static
r_void
id|rw_interrupt
c_func
(paren
r_void
)paren
(brace
macro_line|#if 0
r_int
id|i
suffix:semicolon
macro_line|#endif
r_int
id|nr_sectors
comma
id|ssize
suffix:semicolon
r_char
id|bad
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DRS-&gt;first_read_date
)paren
id|DRS-&gt;first_read_date
op_assign
id|jiffies
suffix:semicolon
id|nr_sectors
op_assign
l_int|0
suffix:semicolon
id|ssize
op_assign
l_int|1
op_lshift
(paren
id|SIZECODE
op_minus
l_int|2
)paren
suffix:semicolon
id|nr_sectors
op_assign
(paren
(paren
id|R_TRACK
op_minus
id|TRACK
)paren
op_star
id|floppy-&gt;head
op_plus
id|R_HEAD
op_minus
id|HEAD
)paren
op_star
id|floppy-&gt;sect
op_plus
(paren
id|R_SECTOR
op_minus
id|SECTOR
)paren
op_star
id|ssize
op_minus
(paren
id|sector_t
op_mod
id|floppy-&gt;sect
)paren
op_mod
id|ssize
suffix:semicolon
macro_line|#ifdef SANITY
r_if
c_cond
(paren
id|nr_sectors
OG
id|current_count_sectors
op_plus
id|ssize
op_minus
(paren
id|current_count_sectors
op_plus
id|sector_t
)paren
op_mod
id|ssize
op_plus
id|sector_t
op_mod
id|ssize
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: long rw: %x instead of %lx&bslash;n&quot;
comma
id|nr_sectors
comma
id|current_count_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rs=%d s=%d&bslash;n&quot;
comma
id|R_SECTOR
comma
id|SECTOR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rh=%d h=%d&bslash;n&quot;
comma
id|R_HEAD
comma
id|HEAD
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rt=%d t=%d&bslash;n&quot;
comma
id|R_TRACK
comma
id|TRACK
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;spt=%d st=%d ss=%d&bslash;n&quot;
comma
id|SECT_PER_TRACK
comma
id|sector_t
comma
id|ssize
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|nr_sectors
OL
l_int|0
)paren
id|nr_sectors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nr_sectors
OL
id|current_count_sectors
)paren
(brace
macro_line|#if 0
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: short read got %d instead of %ld&bslash;n&quot;
comma
id|nr_sectors
comma
id|current_count_sectors
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;command: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|raw_cmd.cmd_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%x &quot;
comma
id|raw_cmd.cmd
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;rate=%x&bslash;n&quot;
comma
id|raw_cmd.rate
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;reply: &quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|inr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%x &quot;
comma
id|reply_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|current_count_sectors
op_assign
id|nr_sectors
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|interpret_errors
c_func
(paren
)paren
)paren
(brace
r_case
l_int|2
suffix:colon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|current_count_sectors
)paren
(brace
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|current_count_sectors
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: dma problem?&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|inr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2x,&quot;
comma
id|reply_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|bad
op_assign
l_int|1
suffix:semicolon
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|current_type
(braket
id|current_drive
)braket
op_assign
id|floppy
suffix:semicolon
id|floppy_sizes
(braket
id|DRIVE
c_func
(paren
id|current_drive
)paren
op_plus
(paren
id|FDC
c_func
(paren
id|current_drive
)paren
op_lshift
l_int|7
)paren
)braket
op_assign
id|floppy-&gt;size
op_rshift
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|probing
)paren
(brace
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FTD_MSG
)paren
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Auto-detected floppy type %s in fd%d&bslash;n&quot;
comma
id|floppy-&gt;name
comma
id|current_drive
)paren
suffix:semicolon
id|current_type
(braket
id|current_drive
)braket
op_assign
id|floppy
suffix:semicolon
id|floppy_sizes
(braket
id|DRIVE
c_func
(paren
id|current_drive
)paren
op_plus
(paren
id|FDC
c_func
(paren
id|current_drive
)paren
op_lshift
l_int|7
)paren
)braket
op_assign
id|floppy-&gt;size
op_rshift
l_int|1
suffix:semicolon
id|probing
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|COMMAND
op_ne
id|FD_READ
op_logical_or
id|current_addr
op_eq
id|CURRENT-&gt;buffer
)paren
(brace
multiline_comment|/* transfer directly from buffer */
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|COMMAND
op_eq
id|FD_READ
)paren
(brace
id|buffer_track
op_assign
id|raw_cmd.track
suffix:semicolon
id|buffer_drive
op_assign
id|current_drive
suffix:semicolon
r_if
c_cond
(paren
id|nr_sectors
op_plus
id|sector_t
OG
id|buffer_max
)paren
id|buffer_max
op_assign
id|nr_sectors
op_plus
id|sector_t
suffix:semicolon
)brace
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Compute maximal contiguous buffer size. */
DECL|function|buffer_chain_size
r_static
r_int
id|buffer_chain_size
c_func
(paren
r_void
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|size
suffix:semicolon
r_char
op_star
id|base
suffix:semicolon
id|base
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|size
op_assign
id|CURRENT-&gt;current_nr_sectors
op_lshift
l_int|9
suffix:semicolon
id|bh
op_assign
id|CURRENT-&gt;bh
suffix:semicolon
macro_line|#ifdef SANITY
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: null request in buffer_chain_size&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|size
op_rshift
l_int|9
suffix:semicolon
)brace
macro_line|#endif
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
r_while
c_loop
(paren
id|bh
op_logical_and
id|bh-&gt;b_data
op_eq
id|base
op_plus
id|size
)paren
(brace
id|size
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
r_return
id|size
op_rshift
l_int|9
suffix:semicolon
)brace
multiline_comment|/* Compute the maximal transfer size */
DECL|function|transfer_size
r_static
r_int
id|transfer_size
c_func
(paren
r_int
id|ssize
comma
r_int
id|max_sector
comma
r_int
id|max_size
)paren
(brace
r_if
c_cond
(paren
id|max_sector
OG
id|sector_t
op_plus
id|max_size
)paren
id|max_sector
op_assign
id|sector_t
op_plus
id|max_size
suffix:semicolon
multiline_comment|/* alignment */
id|max_sector
op_sub_assign
(paren
id|max_sector
op_mod
id|floppy-&gt;sect
)paren
op_mod
id|ssize
suffix:semicolon
multiline_comment|/* transfer size, beginning not aligned */
id|current_count_sectors
op_assign
id|max_sector
op_minus
id|sector_t
suffix:semicolon
r_return
id|max_sector
suffix:semicolon
)brace
multiline_comment|/*&n; * Move data from/to the track buffer to/from the buffer cache.&n; */
DECL|function|copy_buffer
r_static
r_void
id|copy_buffer
c_func
(paren
r_int
id|ssize
comma
r_int
id|max_sector
comma
r_int
id|max_sector_2
)paren
(brace
r_int
id|remaining
suffix:semicolon
multiline_comment|/* number of transferred 512-byte sectors */
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_char
op_star
id|buffer
comma
op_star
id|dma_buffer
suffix:semicolon
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|max_sector
OG
id|max_sector_2
)paren
id|max_sector
op_assign
id|max_sector_2
suffix:semicolon
id|max_sector
op_assign
id|transfer_size
c_func
(paren
id|ssize
comma
id|max_sector
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_count_sectors
op_le
l_int|0
op_logical_and
id|COMMAND
op_eq
id|FD_WRITE
op_logical_and
id|buffer_max
OG
id|sector_t
op_plus
id|CURRENT-&gt;nr_sectors
)paren
(brace
id|current_count_sectors
op_assign
id|buffer_max
op_minus
id|sector_t
suffix:semicolon
r_if
c_cond
(paren
id|current_count_sectors
OG
id|CURRENT-&gt;nr_sectors
)paren
id|current_count_sectors
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
)brace
id|remaining
op_assign
id|current_count_sectors
op_lshift
l_int|9
suffix:semicolon
macro_line|#ifdef SANITY
r_if
c_cond
(paren
(paren
id|remaining
op_rshift
l_int|9
)paren
OG
id|CURRENT-&gt;nr_sectors
op_logical_and
id|COMMAND
op_eq
l_int|0xc5
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: in copy buffer&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current_count_sectors=%ld&bslash;n&quot;
comma
id|current_count_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;remaining=%d&bslash;n&quot;
comma
id|remaining
op_rshift
l_int|9
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CURRENT-&gt;nr_sectors=%ld&bslash;n&quot;
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CURRENT-&gt;current_nr_sectors=%ld&bslash;n&quot;
comma
id|CURRENT-&gt;current_nr_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;max_sector=%d&bslash;n&quot;
comma
id|max_sector
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ssize=%d&bslash;n&quot;
comma
id|ssize
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|max_sector
OG
id|buffer_max
)paren
id|buffer_max
op_assign
id|max_sector
suffix:semicolon
id|dma_buffer
op_assign
id|floppy_track_buffer
op_plus
(paren
(paren
id|sector_t
op_minus
id|buffer_min
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
id|bh
op_assign
id|CURRENT-&gt;bh
suffix:semicolon
id|size
op_assign
id|CURRENT-&gt;current_nr_sectors
op_lshift
l_int|9
suffix:semicolon
id|buffer
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
r_while
c_loop
(paren
id|remaining
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|size
OG
id|remaining
)paren
id|size
op_assign
id|remaining
suffix:semicolon
macro_line|#ifdef SANITY
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: bh=null in copy buffer before copy&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma_buffer
op_plus
id|size
OG
id|floppy_track_buffer
op_plus
(paren
l_int|2
op_star
id|MAX_BUFFER_SECTORS
op_lshift
l_int|9
)paren
op_logical_or
id|dma_buffer
OL
id|floppy_track_buffer
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: buffer overrun in copy buffer %d&bslash;n&quot;
comma
(paren
id|floppy_track_buffer
op_minus
id|dma_buffer
)paren
op_rshift
l_int|9
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sector_t=%d buffer_min=%d&bslash;n&quot;
comma
id|sector_t
comma
id|buffer_min
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current_count_sectors=%ld&bslash;n&quot;
comma
id|current_count_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|COMMAND
op_eq
id|FD_READ
)paren
id|printk
c_func
(paren
l_string|&quot;read&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|COMMAND
op_eq
id|FD_READ
)paren
id|printk
c_func
(paren
l_string|&quot;write&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|buffer
)paren
op_mod
l_int|512
)paren
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: %p buffer not aligned&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|COMMAND
op_eq
id|FD_READ
)paren
id|memcpy
c_func
(paren
id|buffer
comma
id|dma_buffer
comma
id|size
)paren
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|dma_buffer
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
id|remaining
op_sub_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remaining
)paren
r_break
suffix:semicolon
id|dma_buffer
op_add_assign
id|size
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
macro_line|#ifdef SANITY
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: bh=null in copy buffer after copy&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
id|size
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
)brace
macro_line|#ifdef SANITY
r_if
c_cond
(paren
id|remaining
)paren
(brace
r_if
c_cond
(paren
id|remaining
OG
l_int|0
)paren
id|max_sector
op_sub_assign
id|remaining
op_rshift
l_int|9
suffix:semicolon
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: weirdness: remaining %d&bslash;n&quot;
comma
id|remaining
op_rshift
l_int|9
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * Formulate a read/write request.&n; * this routine decides where to load the data (directly to buffer, or to&n; * tmp floppy area), how much data to load (the size of the buffer, the whole&n; * track, or a single sector)&n; * All floppy_track_buffer handling goes in here. If we ever add track buffer&n; * allocation on the fly, it should be done here. No other part should need&n; * modification.&n; */
DECL|function|make_raw_rw_request
r_static
r_int
id|make_raw_rw_request
c_func
(paren
r_void
)paren
(brace
r_int
id|aligned_sector_t
suffix:semicolon
r_int
id|max_sector
comma
id|max_size
comma
id|tracksize
comma
id|ssize
suffix:semicolon
id|current_drive
op_assign
id|DRIVE
c_func
(paren
id|CURRENT-&gt;dev
)paren
suffix:semicolon
id|raw_cmd.flags
op_assign
id|FD_RAW_SPIN
op_or
id|FD_RAW_NEED_DISK
op_or
id|FD_RAW_NEED_DISK
op_or
id|FD_RAW_NEED_SEEK
suffix:semicolon
id|raw_cmd.cmd_count
op_assign
id|NR_RW
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|READ
)paren
(brace
id|raw_cmd.flags
op_or_assign
id|FD_RAW_READ
suffix:semicolon
id|COMMAND
op_assign
id|FD_READ
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|WRITE
)paren
(brace
id|raw_cmd.flags
op_or_assign
id|FD_RAW_WRITE
suffix:semicolon
id|COMMAND
op_assign
id|FD_WRITE
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: make_raw_rw_request: unknown command&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|max_sector
op_assign
id|floppy-&gt;sect
op_star
id|floppy-&gt;head
suffix:semicolon
id|TRACK
op_assign
id|CURRENT-&gt;sector
op_div
id|max_sector
suffix:semicolon
id|sector_t
op_assign
id|CURRENT-&gt;sector
op_mod
id|max_sector
suffix:semicolon
r_if
c_cond
(paren
id|floppy-&gt;track
op_logical_and
id|TRACK
op_ge
id|floppy-&gt;track
)paren
r_return
l_int|0
suffix:semicolon
id|HEAD
op_assign
id|sector_t
op_div
id|floppy-&gt;sect
suffix:semicolon
r_if
c_cond
(paren
(paren
id|DRS-&gt;flags
op_amp
id|FD_NEED_TWADDLE
)paren
op_logical_and
id|sector_t
OL
id|floppy-&gt;sect
)paren
id|max_sector
op_assign
id|floppy-&gt;sect
suffix:semicolon
multiline_comment|/* 2M disks have phantom sectors on the first track */
r_if
c_cond
(paren
(paren
id|floppy-&gt;rate
op_amp
id|FD_2M
)paren
op_logical_and
(paren
op_logical_neg
id|TRACK
)paren
op_logical_and
(paren
op_logical_neg
id|HEAD
)paren
)paren
(brace
id|max_sector
op_assign
l_int|2
op_star
id|floppy-&gt;sect
op_div
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|sector_t
op_ge
id|max_sector
)paren
(brace
id|current_count_sectors
op_assign
(paren
id|floppy-&gt;sect
op_minus
id|sector_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_count_sectors
OG
id|CURRENT-&gt;nr_sectors
)paren
id|current_count_sectors
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|SIZECODE
op_assign
l_int|2
suffix:semicolon
)brace
r_else
id|SIZECODE
op_assign
id|FD_SIZECODE
c_func
(paren
id|floppy
)paren
suffix:semicolon
id|raw_cmd.rate
op_assign
id|floppy-&gt;rate
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
(paren
id|floppy-&gt;rate
op_amp
id|FD_2M
)paren
op_logical_and
(paren
id|TRACK
op_logical_or
id|HEAD
)paren
op_logical_and
id|raw_cmd.rate
op_eq
l_int|2
)paren
id|raw_cmd.rate
op_assign
l_int|1
suffix:semicolon
id|SIZECODE2
op_assign
l_int|0xff
suffix:semicolon
id|raw_cmd.track
op_assign
id|TRACK
op_lshift
id|floppy-&gt;stretch
suffix:semicolon
id|DR_SELECT
op_assign
id|UNIT
c_func
(paren
id|current_drive
)paren
op_plus
(paren
id|HEAD
op_lshift
l_int|2
)paren
suffix:semicolon
id|GAP
op_assign
id|floppy-&gt;gap
suffix:semicolon
id|ssize
op_assign
l_int|1
op_lshift
(paren
id|SIZECODE
op_minus
l_int|2
)paren
suffix:semicolon
id|SECT_PER_TRACK
op_assign
id|floppy-&gt;sect
op_div
id|ssize
suffix:semicolon
id|SECTOR
op_assign
(paren
id|sector_t
op_mod
id|floppy-&gt;sect
)paren
op_div
id|ssize
op_plus
l_int|1
suffix:semicolon
id|tracksize
op_assign
id|floppy-&gt;sect
op_minus
id|floppy-&gt;sect
op_mod
id|ssize
suffix:semicolon
r_if
c_cond
(paren
id|tracksize
OL
id|floppy-&gt;sect
)paren
(brace
id|SECT_PER_TRACK
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tracksize
op_le
id|sector_t
op_mod
id|floppy-&gt;sect
)paren
id|SECTOR
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|tracksize
op_le
id|sector_t
op_mod
id|floppy-&gt;sect
)paren
(brace
r_while
c_loop
(paren
id|tracksize
op_plus
id|ssize
OG
id|floppy-&gt;sect
)paren
(brace
id|SIZECODE
op_decrement
suffix:semicolon
id|ssize
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|SECTOR
op_increment
suffix:semicolon
id|SECT_PER_TRACK
op_increment
suffix:semicolon
id|tracksize
op_add_assign
id|ssize
suffix:semicolon
)brace
id|max_sector
op_assign
id|HEAD
op_star
id|floppy-&gt;sect
op_plus
id|tracksize
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|TRACK
op_logical_and
op_logical_neg
id|HEAD
op_logical_and
op_logical_neg
(paren
id|floppy-&gt;rate
op_amp
id|FD_2M
)paren
op_logical_and
id|probing
)paren
id|max_sector
op_assign
id|floppy-&gt;sect
suffix:semicolon
id|aligned_sector_t
op_assign
id|sector_t
op_minus
(paren
id|sector_t
op_mod
id|floppy-&gt;sect
)paren
op_mod
id|ssize
suffix:semicolon
id|max_size
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
(paren
id|raw_cmd.track
op_eq
id|buffer_track
)paren
op_logical_and
(paren
id|current_drive
op_eq
id|buffer_drive
)paren
op_logical_and
(paren
id|sector_t
op_ge
id|buffer_min
)paren
op_logical_and
(paren
id|sector_t
OL
id|buffer_max
)paren
)paren
(brace
multiline_comment|/* data already in track buffer */
r_if
c_cond
(paren
id|COMMAND
op_eq
id|FD_READ
)paren
(brace
id|copy_buffer
c_func
(paren
l_int|1
comma
id|max_sector
comma
id|buffer_max
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|aligned_sector_t
op_ne
id|sector_t
op_logical_or
id|CURRENT-&gt;nr_sectors
OL
id|ssize
)paren
(brace
r_if
c_cond
(paren
id|COMMAND
op_eq
id|FD_WRITE
)paren
(brace
r_if
c_cond
(paren
id|sector_t
op_plus
id|CURRENT-&gt;nr_sectors
OG
id|ssize
op_logical_and
id|sector_t
op_plus
id|CURRENT-&gt;nr_sectors
OL
id|ssize
op_plus
id|ssize
)paren
(brace
id|max_size
op_assign
id|ssize
op_plus
id|ssize
suffix:semicolon
)brace
r_else
id|max_size
op_assign
id|ssize
suffix:semicolon
)brace
id|raw_cmd.flags
op_and_assign
op_complement
id|FD_RAW_WRITE
suffix:semicolon
id|raw_cmd.flags
op_or_assign
id|FD_RAW_READ
suffix:semicolon
id|COMMAND
op_assign
id|FD_READ
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
r_int
)paren
id|CURRENT-&gt;buffer
op_le
id|LAST_DMA_ADDR
)paren
(brace
r_int
id|direct
comma
id|indirect
suffix:semicolon
id|indirect
op_assign
id|transfer_size
c_func
(paren
id|ssize
comma
id|max_sector
comma
id|MAX_BUFFER_SECTORS
op_star
l_int|2
)paren
op_minus
id|sector_t
suffix:semicolon
id|max_size
op_assign
id|buffer_chain_size
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_size
OG
(paren
id|LAST_DMA_ADDR
op_minus
(paren
(paren
r_int
)paren
id|CURRENT-&gt;buffer
)paren
)paren
op_rshift
l_int|9
)paren
id|max_size
op_assign
(paren
id|LAST_DMA_ADDR
op_minus
(paren
(paren
r_int
)paren
id|CURRENT-&gt;buffer
)paren
)paren
op_rshift
l_int|9
suffix:semicolon
multiline_comment|/* 64 kb boundaries */
r_if
c_cond
(paren
(paren
(paren
id|max_size
op_lshift
l_int|9
)paren
op_plus
(paren
(paren
r_int
)paren
id|CURRENT-&gt;buffer
)paren
)paren
op_div
id|K_64
op_ne
(paren
(paren
r_int
)paren
id|CURRENT-&gt;buffer
)paren
op_div
id|K_64
)paren
id|max_size
op_assign
(paren
id|K_64
op_minus
(paren
(paren
r_int
)paren
id|CURRENT-&gt;buffer
)paren
op_mod
id|K_64
)paren
op_rshift
l_int|9
suffix:semicolon
id|direct
op_assign
id|transfer_size
c_func
(paren
id|ssize
comma
id|max_sector
comma
id|max_size
)paren
op_minus
id|sector_t
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We try to read tracks, but if we get too many errors, we&n;&t;&t; * go back to reading just one sector at a time.&n;&t;&t; *&n;&t;&t; * This means we should be able to read a sector even if there&n;&t;&t; * are other bad sectors on this track.&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|indirect
op_minus
id|sector_t
)paren
op_star
l_int|2
OG
(paren
id|direct
op_minus
id|sector_t
)paren
op_star
l_int|3
op_logical_and
op_star
id|errors
OL
id|DP-&gt;max_errors.read_track
op_logical_and
multiline_comment|/*!(DRS-&gt;flags &amp; FD_NEED_TWADDLE) &amp;&amp;*/
(paren
(paren
op_logical_neg
id|probing
op_logical_or
(paren
id|DP-&gt;read_track
op_amp
(paren
l_int|1
op_lshift
id|DRS-&gt;probed_format
)paren
)paren
)paren
)paren
)paren
(brace
id|max_size
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
)brace
r_else
(brace
id|current_addr
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|raw_cmd.length
op_assign
id|current_count_sectors
op_lshift
l_int|9
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|COMMAND
op_eq
id|FD_READ
)paren
id|max_size
op_assign
id|max_sector
suffix:semicolon
multiline_comment|/* unbounded */
multiline_comment|/* claim buffer track if needed */
r_if
c_cond
(paren
id|buffer_track
op_ne
id|raw_cmd.track
op_logical_or
multiline_comment|/* bad track */
id|buffer_drive
op_ne
id|current_drive
op_logical_or
multiline_comment|/* bad drive */
id|sector_t
OL
id|buffer_min
op_logical_or
(paren
(paren
id|COMMAND
op_eq
id|FD_READ
op_logical_or
(paren
id|aligned_sector_t
op_eq
id|sector_t
op_logical_and
id|CURRENT-&gt;nr_sectors
op_ge
id|ssize
)paren
)paren
op_logical_and
id|max_sector
OG
l_int|2
op_star
id|MAX_BUFFER_SECTORS
op_plus
id|buffer_min
op_logical_and
id|max_size
op_plus
id|sector_t
OG
l_int|2
op_star
id|MAX_BUFFER_SECTORS
op_plus
id|buffer_min
)paren
multiline_comment|/* not enough space */
)paren
(brace
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|buffer_drive
op_assign
id|current_drive
suffix:semicolon
id|buffer_max
op_assign
id|buffer_min
op_assign
id|aligned_sector_t
suffix:semicolon
)brace
id|current_addr
op_assign
id|floppy_track_buffer
op_plus
(paren
(paren
id|aligned_sector_t
op_minus
id|buffer_min
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|COMMAND
op_eq
id|FD_WRITE
)paren
(brace
multiline_comment|/* copy write buffer to track buffer.&n;&t;&t; * if we get here, we know that the write&n;&t;&t; * is either aligned or the data already in the buffer&n;&t;&t; * (buffer will be overwritten) */
macro_line|#ifdef SANITY
r_if
c_cond
(paren
id|sector_t
op_ne
id|aligned_sector_t
op_logical_and
id|buffer_track
op_eq
op_minus
l_int|1
)paren
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: internal error offset !=0 on write&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|buffer_track
op_assign
id|raw_cmd.track
suffix:semicolon
id|buffer_drive
op_assign
id|current_drive
suffix:semicolon
id|copy_buffer
c_func
(paren
id|ssize
comma
id|max_sector
comma
l_int|2
op_star
id|MAX_BUFFER_SECTORS
op_plus
id|buffer_min
)paren
suffix:semicolon
)brace
r_else
id|transfer_size
c_func
(paren
id|ssize
comma
id|max_sector
comma
l_int|2
op_star
id|MAX_BUFFER_SECTORS
op_plus
id|buffer_min
op_minus
id|aligned_sector_t
)paren
suffix:semicolon
multiline_comment|/* round up current_count_sectors to get dma xfer size */
id|raw_cmd.length
op_assign
id|sector_t
op_plus
id|current_count_sectors
op_minus
id|aligned_sector_t
suffix:semicolon
id|raw_cmd.length
op_assign
(paren
(paren
id|raw_cmd.length
op_minus
l_int|1
)paren
op_or
(paren
id|ssize
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
id|raw_cmd.length
op_lshift_assign
l_int|9
suffix:semicolon
macro_line|#ifdef SANITY
r_if
c_cond
(paren
(paren
id|raw_cmd.length
OL
id|current_count_sectors
op_lshift
l_int|9
)paren
op_logical_or
(paren
id|current_addr
op_ne
id|CURRENT-&gt;buffer
op_logical_and
id|COMMAND
op_eq
id|FD_WRITE
op_logical_and
(paren
id|aligned_sector_t
op_plus
(paren
id|raw_cmd.length
op_rshift
l_int|9
)paren
OG
id|buffer_max
op_logical_or
id|aligned_sector_t
OL
id|buffer_min
)paren
)paren
op_logical_or
id|raw_cmd.length
op_mod
(paren
l_int|512
op_lshift
(paren
id|SIZECODE
op_minus
l_int|2
)paren
)paren
op_logical_or
id|raw_cmd.length
op_le
l_int|0
op_logical_or
id|current_count_sectors
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: fractionary current count b=%lx s=%lx&bslash;n&quot;
comma
id|raw_cmd.length
comma
id|current_count_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_addr
op_ne
id|CURRENT-&gt;buffer
)paren
id|printk
c_func
(paren
l_string|&quot;addr=%d, length=%ld&bslash;n&quot;
comma
(paren
id|current_addr
op_minus
id|floppy_track_buffer
)paren
op_rshift
l_int|9
comma
id|current_count_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;st=%d ast=%d mse=%d msi=%d&bslash;n&quot;
comma
id|sector_t
comma
id|aligned_sector_t
comma
id|max_sector
comma
id|max_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ssize=%x SIZECODE=%d&bslash;n&quot;
comma
id|ssize
comma
id|SIZECODE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;command=%x SECTOR=%d HEAD=%d, TRACK=%d&bslash;n&quot;
comma
id|COMMAND
comma
id|SECTOR
comma
id|HEAD
comma
id|TRACK
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer drive=%d&bslash;n&quot;
comma
id|buffer_drive
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer track=%d&bslash;n&quot;
comma
id|buffer_track
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer_min=%d&bslash;n&quot;
comma
id|buffer_min
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer_max=%d&bslash;n&quot;
comma
id|buffer_max
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current_addr
op_ne
id|CURRENT-&gt;buffer
)paren
(brace
r_if
c_cond
(paren
id|current_addr
OL
id|floppy_track_buffer
op_logical_or
id|current_count_sectors
OL
l_int|0
op_logical_or
id|raw_cmd.length
template_param
id|floppy_track_buffer
op_plus
(paren
l_int|2
op_star
id|MAX_BUFFER_SECTORS
op_lshift
l_int|9
)paren
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: buffer overrun in schedule dma&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sector_t=%d buffer_min=%d current_count=%ld&bslash;n&quot;
comma
id|sector_t
comma
id|buffer_min
comma
id|raw_cmd.length
op_rshift
l_int|9
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current_count_sectors=%ld&bslash;n&quot;
comma
id|current_count_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|COMMAND
op_eq
id|FD_READ
)paren
id|printk
c_func
(paren
l_string|&quot;read&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|COMMAND
op_eq
id|FD_READ
)paren
id|printk
c_func
(paren
l_string|&quot;write&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|raw_cmd.length
OG
id|CURRENT-&gt;nr_sectors
op_lshift
l_int|9
op_logical_or
id|current_count_sectors
OG
id|CURRENT-&gt;nr_sectors
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: buffer overrun in direct transfer&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|raw_cmd.length
OL
id|current_count_sectors
op_lshift
l_int|9
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: more sectors than bytes&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bytes=%ld&bslash;n&quot;
comma
id|raw_cmd.length
op_rshift
l_int|9
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sectors=%ld&bslash;n&quot;
comma
id|current_count_sectors
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|2
suffix:semicolon
)brace
DECL|function|redo_fd_request
r_static
r_void
id|redo_fd_request
c_func
(paren
r_void
)paren
(brace
DECL|macro|REPEAT
mdefine_line|#define REPEAT {request_done(0); continue; }
r_int
id|device
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_logical_and
id|CURRENT-&gt;dev
OL
l_int|0
)paren
r_return
suffix:semicolon
multiline_comment|/* hooray, the goto is gone! */
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|CURRENT
)paren
(brace
id|CLEAR_INTR
suffix:semicolon
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
op_ne
id|MAJOR_NR
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: request list destroyed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;bh
op_logical_and
op_logical_neg
id|CURRENT-&gt;bh-&gt;b_lock
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
id|device
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
suffix:semicolon
id|set_fdc
c_func
(paren
id|DRIVE
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
id|CHECK_RESET
suffix:semicolon
id|start_motor
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|changed_floppies
op_or
id|fake_change
)paren
op_amp
(paren
l_int|1
op_lshift
id|DRIVE
c_func
(paren
id|device
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: disk absent or changed during operation&bslash;n&quot;
)paren
suffix:semicolon
id|REPEAT
suffix:semicolon
)brace
id|set_floppy
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|floppy
)paren
(brace
multiline_comment|/* Autodetection */
r_if
c_cond
(paren
op_logical_neg
id|probing
)paren
(brace
id|DRS-&gt;probed_format
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|next_valid_format
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: no autodetectable formats&bslash;n&quot;
)paren
suffix:semicolon
id|floppy
op_assign
l_int|NULL
suffix:semicolon
id|REPEAT
suffix:semicolon
)brace
)brace
id|probing
op_assign
l_int|1
suffix:semicolon
id|floppy
op_assign
id|floppy_type
op_plus
id|DP-&gt;autodetect
(braket
id|DRS-&gt;probed_format
)braket
suffix:semicolon
)brace
r_else
id|probing
op_assign
l_int|0
suffix:semicolon
id|errors
op_assign
op_amp
(paren
id|CURRENT-&gt;errors
)paren
suffix:semicolon
id|tmp
op_assign
id|make_raw_rw_request
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|2
)paren
(brace
id|request_done
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DRS-&gt;flags
op_amp
id|FD_NEED_TWADDLE
)paren
id|twaddle
c_func
(paren
)paren
suffix:semicolon
id|floppy_on
c_func
(paren
id|current_drive
)paren
suffix:semicolon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;queue fd request&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|macro|REPEAT
macro_line|#undef REPEAT
)brace
DECL|variable|rw_cont
r_static
r_struct
id|cont_t
id|rw_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|do_fd_request
r_void
id|do_fd_request
c_func
(paren
r_void
)paren
(brace
id|lock_fdc
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|cont
op_assign
op_amp
id|rw_cont
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * User triggered reset&n; * ====================&n; */
DECL|function|reset_intr
r_static
r_void
id|reset_intr
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;weird, reset interrupt called&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|reset_cont
r_static
r_struct
id|cont_t
id|reset_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|user_reset_fdc
r_static
r_int
id|user_reset_fdc
c_func
(paren
r_int
id|drive
comma
r_int
id|arg
)paren
(brace
r_int
id|result
suffix:semicolon
id|result
op_assign
l_int|0
suffix:semicolon
id|lock_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|arg
)paren
(brace
r_case
id|FD_RESET_ALWAYS
suffix:colon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FD_RESET_IF_RAWCMD
suffix:colon
r_if
c_cond
(paren
id|FDCS-&gt;rawcmd
op_eq
l_int|2
)paren
(brace
id|reset_fdc_info
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
(brace
id|cont
op_assign
op_amp
id|reset_cont
suffix:semicolon
id|timer_table
(braket
id|FLOPPY_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
l_int|5
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|FLOPPY_TIMER
suffix:semicolon
id|reset_fdc
c_func
(paren
)paren
suffix:semicolon
id|result
op_assign
id|wait_til_done
c_func
(paren
)paren
suffix:semicolon
)brace
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/*&n; * Misc Ioctl&squot;s and support&n; * ========================&n; */
DECL|function|fd_copyout
r_static
r_int
id|fd_copyout
c_func
(paren
r_void
op_star
id|param
comma
r_volatile
r_void
op_star
id|address
comma
r_int
id|size
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|param
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|param
comma
(paren
r_void
op_star
)paren
id|address
comma
id|size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|COPYOUT
mdefine_line|#define COPYOUT(x) (fd_copyout( (void *)param, &amp;(x), sizeof(x)))
DECL|macro|COPYIN
mdefine_line|#define COPYIN(x) (memcpy_fromfs( &amp;(x), (void *) param, sizeof(x)),0)
DECL|function|poll_drive
r_static
r_void
id|poll_drive
c_func
(paren
r_int
id|drive
)paren
(brace
id|lock_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
id|start_motor
c_func
(paren
)paren
suffix:semicolon
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|drive_name
r_static
r_char
op_star
id|drive_name
c_func
(paren
r_int
id|type
comma
r_int
id|drive
)paren
(brace
r_struct
id|floppy_struct
op_star
id|floppy
suffix:semicolon
r_if
c_cond
(paren
id|type
)paren
id|floppy
op_assign
id|floppy_type
op_plus
id|type
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|UDP-&gt;native_format
)paren
id|floppy
op_assign
id|floppy_type
op_plus
id|UDP-&gt;native_format
suffix:semicolon
r_else
r_return
l_string|&quot;(null)&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|floppy-&gt;name
)paren
r_return
id|floppy-&gt;name
suffix:semicolon
r_else
r_return
l_string|&quot;(null)&quot;
suffix:semicolon
)brace
multiline_comment|/* raw commands */
DECL|variable|raw_cmd_cont
r_static
r_struct
id|cont_t
id|raw_cmd_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|raw_cmd_ioctl
r_static
r_int
id|raw_cmd_ioctl
c_func
(paren
r_int
id|drive
comma
r_void
op_star
id|param
)paren
(brace
r_int
id|i
comma
id|count
comma
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;rawcmd
op_le
l_int|1
)paren
id|FDCS-&gt;rawcmd
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_DRIVE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|FDC
c_func
(paren
id|i
)paren
op_ne
id|fdc
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|drive
)paren
(brace
r_if
c_cond
(paren
id|drive_state
(braket
id|i
)braket
dot
id|fd_ref
OG
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|drive_state
(braket
id|i
)braket
dot
id|fd_ref
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|COPYIN
c_func
(paren
id|raw_cmd
)paren
suffix:semicolon
id|raw_cmd.rate
op_and_assign
l_int|0x03
suffix:semicolon
id|count
op_assign
id|raw_cmd.length
suffix:semicolon
r_if
c_cond
(paren
(paren
id|raw_cmd.flags
op_amp
(paren
id|FD_RAW_WRITE
op_or
id|FD_RAW_READ
)paren
)paren
op_logical_and
id|count
OG
id|MAX_BUFFER_SECTORS
op_star
l_int|512
op_star
l_int|2
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd.flags
op_amp
id|FD_RAW_WRITE
)paren
(brace
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|raw_cmd.data
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|floppy_track_buffer
comma
id|raw_cmd.data
comma
id|count
)paren
suffix:semicolon
)brace
id|current_addr
op_assign
id|floppy_track_buffer
suffix:semicolon
id|raw_cmd.flags
op_or_assign
id|FD_RAW_USER_SUPPLIED
suffix:semicolon
id|cont
op_assign
op_amp
id|raw_cmd_cont
suffix:semicolon
id|floppy_on
c_func
(paren
id|current_drive
)paren
suffix:semicolon
id|ret
op_assign
id|wait_til_done
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
op_logical_neg
id|FDCS-&gt;reset
)paren
(brace
id|raw_cmd.reply_count
op_assign
id|inr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|raw_cmd.reply_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|raw_cmd.reply
(braket
id|i
)braket
op_assign
id|reply_buffer
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raw_cmd.flags
op_amp
(paren
id|FD_RAW_READ
op_or
id|FD_RAW_WRITE
)paren
)paren
id|raw_cmd.length
op_assign
id|get_dma_residue
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
)brace
r_else
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|DRS-&gt;track
op_assign
id|NO_TRACK
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd.flags
op_amp
id|FD_RAW_READ
)paren
(brace
id|i
op_assign
id|fd_copyout
c_func
(paren
id|raw_cmd.data
comma
id|floppy_track_buffer
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
)brace
r_return
id|COPYOUT
c_func
(paren
id|raw_cmd
)paren
suffix:semicolon
)brace
DECL|function|invalidate_drive
r_static
r_int
id|invalidate_drive
c_func
(paren
r_int
id|rdev
)paren
(brace
multiline_comment|/* invalidate the buffer track to force a reread */
id|cli
c_func
(paren
)paren
suffix:semicolon
id|fake_change
op_or_assign
l_int|1
op_lshift
id|DRIVE
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
id|check_disk_change
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fd_ioctl
r_static
r_int
id|fd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|param
)paren
(brace
DECL|macro|IOCTL_MODE_BIT
mdefine_line|#define IOCTL_MODE_BIT 8
DECL|macro|IOCTL_ALLOWED
mdefine_line|#define IOCTL_ALLOWED (filp &amp;&amp; (filp-&gt;f_mode &amp; IOCTL_MODE_BIT))
r_struct
id|floppy_struct
id|newparams
suffix:semicolon
r_struct
id|format_descr
id|tmp_format_req
suffix:semicolon
r_int
id|i
comma
id|device
comma
id|drive
comma
id|type
comma
id|cnt
suffix:semicolon
r_struct
id|floppy_struct
op_star
id|this_floppy
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
id|device
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
id|RO_IOCTLS
c_func
(paren
id|device
comma
id|param
)paren
suffix:semicolon
)brace
id|type
op_assign
id|TYPE
c_func
(paren
id|MINOR
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
id|drive
op_assign
id|DRIVE
c_func
(paren
id|MINOR
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FDGETDRVTYP
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|param
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|name
op_assign
id|drive_name
c_func
(paren
id|type
comma
id|drive
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
l_int|16
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|put_fs_byte
c_func
(paren
id|name
(braket
id|cnt
)braket
comma
(paren
(paren
r_char
op_star
)paren
id|param
)paren
op_plus
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|name
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|FDGETMAXERRS
suffix:colon
r_return
id|COPYOUT
c_func
(paren
id|UDP-&gt;max_errors
)paren
suffix:semicolon
r_case
id|FDGETPRM
suffix:colon
r_if
c_cond
(paren
id|type
)paren
id|this_floppy
op_assign
op_amp
id|floppy_type
(braket
id|type
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|this_floppy
op_assign
id|current_type
(braket
id|drive
)braket
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
id|COPYOUT
c_func
(paren
id|this_floppy
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_case
id|FDPOLLDRVSTAT
suffix:colon
id|poll_drive
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|FDGETDRVSTAT
suffix:colon
r_return
id|COPYOUT
c_func
(paren
op_star
id|UDRS
)paren
suffix:semicolon
r_case
id|FDGETFDCSTAT
suffix:colon
r_return
id|COPYOUT
c_func
(paren
op_star
id|UFDCS
)paren
suffix:semicolon
r_case
id|FDGETDRVPRM
suffix:colon
r_return
id|COPYOUT
c_func
(paren
op_star
id|UDP
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|IOCTL_ALLOWED
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FDRAWCMD
suffix:colon
r_if
c_cond
(paren
id|type
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|lock_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
id|set_floppy
c_func
(paren
id|device
)paren
suffix:semicolon
id|i
op_assign
id|raw_cmd_ioctl
c_func
(paren
id|drive
comma
(paren
r_void
op_star
)paren
id|param
)paren
suffix:semicolon
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
r_case
id|FDFMTTRK
suffix:colon
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
op_ne
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|UDRS-&gt;flags
op_amp
id|FD_DRIVE_PRESENT
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|COPYIN
c_func
(paren
id|tmp_format_req
)paren
suffix:semicolon
r_return
id|do_format
c_func
(paren
id|device
comma
op_amp
id|tmp_format_req
)paren
suffix:semicolon
r_case
id|FDSETMAXERRS
suffix:colon
r_return
id|COPYIN
c_func
(paren
id|UDP-&gt;max_errors
)paren
suffix:semicolon
r_case
id|FDFMTBEG
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|FDCLRPRM
suffix:colon
id|lock_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
id|current_type
(braket
id|drive
)braket
op_assign
l_int|NULL
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
l_int|2
suffix:semicolon
id|UDRS-&gt;keep_data
op_assign
l_int|0
suffix:semicolon
r_return
id|invalidate_drive
c_func
(paren
id|device
)paren
suffix:semicolon
r_case
id|FDFMTEND
suffix:colon
r_case
id|FDFLUSH
suffix:colon
id|lock_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
id|invalidate_drive
c_func
(paren
id|device
)paren
suffix:semicolon
r_case
id|FDSETPRM
suffix:colon
r_case
id|FDDEFPRM
suffix:colon
id|COPYIN
c_func
(paren
id|newparams
)paren
suffix:semicolon
multiline_comment|/* sanity checking for parameters.*/
r_if
c_cond
(paren
id|newparams.sect
op_le
l_int|0
op_logical_or
id|newparams.head
op_le
l_int|0
op_logical_or
id|newparams.track
op_le
l_int|0
op_logical_or
id|newparams.track
OG
id|UDP-&gt;tracks
op_rshift
id|newparams.stretch
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|lock_fdc
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|N_DRIVE
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|TYPE
c_func
(paren
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_device
)paren
op_eq
id|type
op_logical_and
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_ref
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|fake_change
op_or_assign
l_int|1
op_lshift
id|cnt
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
id|floppy_type
(braket
id|type
)braket
op_assign
id|newparams
suffix:semicolon
id|floppy_type
(braket
id|type
)braket
dot
id|name
op_assign
l_string|&quot;user format&quot;
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
id|type
op_lshift
l_int|2
suffix:semicolon
id|cnt
OL
(paren
id|type
op_lshift
l_int|2
)paren
op_plus
l_int|4
suffix:semicolon
id|cnt
op_increment
)paren
id|floppy_sizes
(braket
id|cnt
)braket
op_assign
macro_line|#ifdef HAVE_2_CONTROLLERS
id|floppy_sizes
(braket
id|cnt
op_plus
l_int|0x80
)braket
op_assign
macro_line|#endif
id|floppy_type
(braket
id|type
)braket
dot
id|size
op_rshift
l_int|1
suffix:semicolon
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|N_DRIVE
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|TYPE
c_func
(paren
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_device
)paren
op_eq
id|type
op_logical_and
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_ref
)paren
id|check_disk_change
c_func
(paren
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_device
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|lock_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
id|FDDEFPRM
)paren
multiline_comment|/* notice a disk change immediately, else&n;&t;&t;&t; * we loose our settings immediately*/
id|start_motor
c_func
(paren
)paren
suffix:semicolon
id|user_params
(braket
id|drive
)braket
op_assign
id|newparams
suffix:semicolon
r_if
c_cond
(paren
id|buffer_drive
op_eq
id|drive
op_logical_and
id|buffer_max
OG
id|user_params
(braket
id|drive
)braket
dot
id|sect
)paren
id|buffer_max
op_assign
id|user_params
(braket
id|drive
)braket
dot
id|sect
suffix:semicolon
id|current_type
(braket
id|drive
)braket
op_assign
op_amp
id|user_params
(braket
id|drive
)braket
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|user_params
(braket
id|drive
)braket
dot
id|size
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|FDDEFPRM
)paren
id|DRS-&gt;keep_data
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|DRS-&gt;keep_data
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* invalidation. Invalidate only when needed, i.e.&n;&t;&t; * when there are already sectors in the buffer cache&n;&t;&t; * whose number will change. This is useful, because&n;&t;&t; * mtools often changes the geometry of the disk after&n;&t;&t; * looking at the boot block */
r_if
c_cond
(paren
id|DRS-&gt;maxblock
OG
id|user_params
(braket
id|drive
)braket
dot
id|sect
op_logical_or
id|DRS-&gt;maxtrack
)paren
r_return
id|invalidate_drive
c_func
(paren
id|device
)paren
suffix:semicolon
r_else
r_return
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
r_case
id|FDRESET
suffix:colon
r_return
id|user_reset_fdc
c_func
(paren
id|drive
comma
(paren
r_int
)paren
id|param
)paren
suffix:semicolon
r_case
id|FDMSGON
suffix:colon
id|UDP-&gt;flags
op_or_assign
id|FTD_MSG
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDMSGOFF
suffix:colon
id|UDP-&gt;flags
op_and_assign
op_complement
id|FTD_MSG
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDSETEMSGTRESH
suffix:colon
id|UDP-&gt;max_errors.reporting
op_assign
(paren
r_int
r_int
)paren
(paren
id|param
op_amp
l_int|0x0f
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDTWADDLE
suffix:colon
id|lock_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
id|twaddle
c_func
(paren
)paren
suffix:semicolon
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FDSETDRVPRM
suffix:colon
r_return
id|COPYIN
c_func
(paren
op_star
id|UDP
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
DECL|macro|IOCTL_ALLOWED
macro_line|#undef IOCTL_ALLOWED
)brace
DECL|macro|CMOS_READ
mdefine_line|#define CMOS_READ(addr) ({ &bslash;&n;outb_p(addr,0x70); &bslash;&n;inb_p(0x71); &bslash;&n;})
DECL|function|set_base_type
r_static
r_void
id|set_base_type
c_func
(paren
r_int
id|drive
comma
r_int
id|code
)paren
(brace
r_if
c_cond
(paren
id|code
OG
l_int|0
op_logical_and
id|code
op_le
id|NUMBER
c_func
(paren
id|default_drive_params
)paren
)paren
(brace
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|UDP
comma
(paren
r_char
op_star
)paren
(paren
op_amp
id|default_drive_params
(braket
id|code
)braket
dot
id|params
)paren
comma
r_sizeof
(paren
r_struct
id|floppy_drive_params
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fd%d is %s&quot;
comma
id|drive
comma
id|default_drive_params
(braket
id|code
)braket
dot
id|name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|code
)paren
id|printk
c_func
(paren
l_string|&quot;fd%d is not installed&quot;
comma
id|drive
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;fd%d is unknown type %d&quot;
comma
id|drive
comma
id|code
)paren
suffix:semicolon
)brace
DECL|function|config_types
r_static
r_void
id|config_types
c_func
(paren
r_void
)paren
(brace
r_int
id|drive
suffix:semicolon
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|N_DRIVE
suffix:semicolon
id|drive
op_increment
)paren
(brace
multiline_comment|/* default type for unidentifiable drives */
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|UDP
comma
(paren
r_char
op_star
)paren
(paren
op_amp
id|default_drive_params-&gt;params
)paren
comma
r_sizeof
(paren
r_struct
id|floppy_drive_params
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;Floppy drive(s): &quot;
)paren
suffix:semicolon
id|set_base_type
c_func
(paren
l_int|0
comma
(paren
id|CMOS_READ
c_func
(paren
l_int|0x10
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|15
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CMOS_READ
c_func
(paren
l_int|0x10
)paren
op_amp
l_int|15
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, &quot;
)paren
suffix:semicolon
id|set_base_type
c_func
(paren
l_int|1
comma
id|CMOS_READ
c_func
(paren
l_int|0x10
)paren
op_amp
l_int|15
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|maybe_check_change
r_static
r_void
id|maybe_check_change
c_func
(paren
r_int
id|device
)paren
(brace
r_register
r_int
id|drive
suffix:semicolon
id|drive
op_assign
id|DRIVE
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UDRS-&gt;last_checked
op_plus
id|UDP-&gt;checkfreq
OL
id|jiffies
op_logical_or
id|UDRS-&gt;flags
op_amp
id|FD_VERIFY
op_logical_or
(paren
(paren
id|changed_floppies
op_or
id|fake_change
)paren
op_amp
(paren
l_int|1
op_lshift
id|drive
)paren
)paren
)paren
id|check_disk_change
c_func
(paren
id|device
)paren
suffix:semicolon
)brace
DECL|function|floppy_is_wp
r_int
id|floppy_is_wp
c_func
(paren
r_int
id|minor
)paren
(brace
id|maybe_check_change
c_func
(paren
id|minor
op_plus
(paren
id|MAJOR_NR
op_lshift
l_int|8
)paren
)paren
suffix:semicolon
r_return
op_logical_neg
(paren
id|drive_state
(braket
id|DRIVE
c_func
(paren
id|minor
)paren
)braket
dot
id|flags
op_amp
id|FD_DISK_WRITABLE
)paren
suffix:semicolon
)brace
DECL|macro|WRAPPER
mdefine_line|#define WRAPPER(op) &bslash;&n;static int floppy_##op(struct inode * inode, struct file * filp, &bslash;&n;&t;&t;     char * buf, int count) &bslash;&n;{ &bslash;&n;&t;maybe_check_change(inode-&gt;i_rdev);&t;&bslash;&n;&t;if ( changed_floppies &amp; ( 1 &lt;&lt; DRIVE(inode-&gt;i_rdev) )) &bslash;&n;&t;&t;return -ENXIO; &bslash;&n;&t;return block_##op(inode, filp, buf, count); &bslash;&n;}
id|WRAPPER
c_func
(paren
id|read
)paren
id|WRAPPER
c_func
(paren
id|write
)paren
DECL|variable|exclusive
r_static
r_int
id|exclusive
op_assign
l_int|0
suffix:semicolon
DECL|function|floppy_release
r_static
r_void
id|floppy_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|drive
op_assign
id|DRIVE
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
OL
l_int|0
)paren
id|UDRS-&gt;fd_ref
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|UDRS-&gt;fd_ref
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: floppy_release with fd_ref == 0&quot;
)paren
suffix:semicolon
id|UDRS-&gt;fd_ref
op_assign
l_int|0
suffix:semicolon
)brace
id|floppy_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
id|exclusive
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * floppy_open check for aliasing (/dev/fd0 can be the same as&n; * /dev/PS0 etc), and disallows simultaneous access to the same&n; * drive with different device numbers.&n; */
DECL|macro|RETERR
mdefine_line|#define RETERR(x) &bslash;&n;&t;do{floppy_release(inode,filp); &bslash;&n;&t;   return -(x);}while(0)
DECL|variable|usage_count
r_static
r_int
id|usage_count
op_assign
l_int|0
suffix:semicolon
DECL|function|floppy_open
r_static
r_int
id|floppy_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|drive
suffix:semicolon
r_int
id|old_dev
suffix:semicolon
r_if
c_cond
(paren
id|exclusive
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Weird, open called with filp=0&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|drive
op_assign
id|DRIVE
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_ge
id|N_DRIVE
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|command_status
op_eq
id|FD_COMMAND_DETECT
op_logical_and
id|drive
op_ge
id|current_drive
)paren
(brace
id|lock_fdc
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TYPE
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_ge
id|NUMBER
c_func
(paren
id|floppy_type
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|UDRS-&gt;flags
op_amp
id|FD_DRIVE_PRESENT
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|old_dev
op_assign
id|UDRS-&gt;fd_device
suffix:semicolon
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
op_logical_and
id|old_dev
op_ne
id|inode-&gt;i_rdev
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_EXCL
)paren
(brace
r_if
c_cond
(paren
id|usage_count
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_else
id|exclusive
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|floppy_grab_irq_and_dma
c_func
(paren
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|UDRS-&gt;fd_ref
op_increment
suffix:semicolon
id|UDRS-&gt;fd_device
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
r_if
c_cond
(paren
id|old_dev
op_logical_and
id|old_dev
op_ne
id|inode-&gt;i_rdev
)paren
(brace
r_if
c_cond
(paren
id|buffer_drive
op_eq
id|drive
)paren
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|old_dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Allow ioctls if we have write-permissions even if read-only open */
r_if
c_cond
(paren
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
op_logical_or
id|permission
c_func
(paren
id|inode
comma
l_int|2
)paren
)paren
id|filp-&gt;f_mode
op_or_assign
id|IOCTL_MODE_BIT
suffix:semicolon
r_if
c_cond
(paren
id|UFDCS-&gt;rawcmd
op_eq
l_int|1
)paren
id|UFDCS-&gt;rawcmd
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NDELAY
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_logical_and
op_logical_neg
(paren
id|UDRS-&gt;flags
op_amp
id|FD_DRIVE_PRESENT
)paren
)paren
id|RETERR
c_func
(paren
id|ENXIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|user_reset_fdc
c_func
(paren
id|drive
comma
id|FD_RESET_IF_NEEDED
)paren
)paren
id|RETERR
c_func
(paren
id|EIO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
(brace
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|changed_floppies
op_amp
(paren
l_int|1
op_lshift
id|drive
)paren
)paren
id|RETERR
c_func
(paren
id|ENXIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
op_logical_and
op_logical_neg
(paren
id|UDRS-&gt;flags
op_amp
id|FD_DISK_WRITABLE
)paren
)paren
id|RETERR
c_func
(paren
id|EROFS
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
DECL|macro|RETERR
macro_line|#undef RETERR
)brace
multiline_comment|/*&n; * Acknowledge disk change&n; */
DECL|function|ack_change
r_static
r_int
id|ack_change
c_func
(paren
r_int
id|drive
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|1
op_lshift
id|drive
suffix:semicolon
id|UDRS-&gt;maxblock
op_assign
l_int|0
suffix:semicolon
id|UDRS-&gt;maxtrack
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buffer_drive
op_eq
id|drive
)paren
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|fake_change
op_and_assign
op_complement
id|mask
suffix:semicolon
id|changed_floppies
op_and_assign
op_complement
id|mask
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Check if the disk has been changed or if a change has been faked.&n; */
DECL|function|check_floppy_change
r_static
r_int
id|check_floppy_change
c_func
(paren
id|dev_t
id|dev
)paren
(brace
r_int
id|drive
op_assign
id|DRIVE
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
r_int
id|mask
op_assign
l_int|1
op_lshift
id|drive
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
op_ne
id|MAJOR_NR
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: floppy_changed: not a floppy&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fake_change
op_amp
id|mask
)paren
r_return
id|ack_change
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|UDRS-&gt;flags
op_amp
id|FD_VERIFY
)paren
op_logical_or
(paren
id|changed_floppies
op_amp
id|mask
)paren
op_logical_or
id|UDRS-&gt;last_checked
op_plus
id|UDP-&gt;checkfreq
OL
id|jiffies
)paren
(brace
id|user_reset_fdc
c_func
(paren
id|drive
comma
id|FD_RESET_IF_NEEDED
)paren
suffix:semicolon
id|poll_drive
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|changed_floppies
op_amp
id|mask
)paren
(brace
id|UDRS-&gt;generation
op_increment
suffix:semicolon
r_return
id|ack_change
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* revalidate the floppy disk, i.e. trigger format autodetection by reading&n; * the bootblock (block 0) */
DECL|function|floppy_revalidate
r_static
r_int
id|floppy_revalidate
c_func
(paren
id|dev_t
id|dev
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
id|TYPE
c_func
(paren
id|dev
)paren
op_logical_or
id|current_type
(braket
id|DRIVE
c_func
(paren
id|dev
)paren
)braket
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|getblk
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|1024
)paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bh
op_logical_and
op_logical_neg
id|bh-&gt;b_uptodate
)paren
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|floppy_fops
r_static
r_struct
id|file_operations
id|floppy_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|floppy_read
comma
multiline_comment|/* read - general block-dev read */
id|floppy_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|fd_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|floppy_open
comma
multiline_comment|/* open */
id|floppy_release
comma
multiline_comment|/* release */
id|block_fsync
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
id|check_floppy_change
comma
multiline_comment|/* media_change */
id|floppy_revalidate
comma
multiline_comment|/* revalidate */
)brace
suffix:semicolon
multiline_comment|/*&n; * Floppy Driver initialisation&n; * =============================&n; */
multiline_comment|/* Determine the floppy disk controller type */
multiline_comment|/* This routine was written by David C. Niemi */
DECL|function|get_fdc_version
r_static
r_char
id|get_fdc_version
c_func
(paren
r_void
)paren
(brace
r_int
id|r
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_DUMPREGS
)paren
suffix:semicolon
multiline_comment|/* 82072 and better know DUMPREGS */
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
r_return
id|FDC_NONE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_assign
id|result
c_func
(paren
)paren
)paren
op_le
l_int|0x00
)paren
r_return
id|FDC_NONE
suffix:semicolon
multiline_comment|/* No FDC present ??? */
r_if
c_cond
(paren
(paren
id|r
op_eq
l_int|1
)paren
op_logical_and
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC %d is a 8272A&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_8272A
suffix:semicolon
multiline_comment|/* 8272a/765 don&squot;t know DUMPREGS */
)brace
r_if
c_cond
(paren
id|r
op_ne
l_int|10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC init: DUMPREGS: unexpected return of %d bytes.&bslash;n&quot;
comma
id|r
)paren
suffix:semicolon
r_return
id|FDC_UNKNOWN
suffix:semicolon
)brace
id|output_byte
c_func
(paren
id|FD_VERSION
)paren
suffix:semicolon
id|r
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_eq
l_int|1
)paren
op_logical_and
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC %d is a 82072&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_82072
suffix:semicolon
multiline_comment|/* 82072 doesn&squot;t know VERSION */
)brace
r_if
c_cond
(paren
(paren
id|r
op_ne
l_int|1
)paren
op_logical_or
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_ne
l_int|0x90
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC init: VERSION: unexpected return of %d bytes.&bslash;n&quot;
comma
id|r
)paren
suffix:semicolon
r_return
id|FDC_UNKNOWN
suffix:semicolon
)brace
id|output_byte
c_func
(paren
id|FD_UNLOCK
)paren
suffix:semicolon
id|r
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_eq
l_int|1
)paren
op_logical_and
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC %d is a pre-1991 82077&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_82077_ORIG
suffix:semicolon
multiline_comment|/* Pre-1991 82077 doesn&squot;t know LOCK/UNLOCK */
)brace
r_if
c_cond
(paren
(paren
id|r
op_ne
l_int|1
)paren
op_logical_or
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_ne
l_int|0x00
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC init: UNLOCK: unexpected return of %d bytes.&bslash;n&quot;
comma
id|r
)paren
suffix:semicolon
r_return
id|FDC_UNKNOWN
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;FDC %d is a post-1991 82077&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_82077
suffix:semicolon
multiline_comment|/* Revised 82077AA passes all the tests */
)brace
multiline_comment|/* fdc_init */
multiline_comment|/*&n; * Drive detection routine. This runs in the background while the kernel&n; * does other (non floppy related) initialisation work.&n; */
DECL|function|detect_interrupt
r_static
r_void
id|detect_interrupt
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|DRS-&gt;track
op_eq
l_int|0
)paren
id|DRS-&gt;flags
op_or_assign
id|FD_DRIVE_PRESENT
op_or
id|FD_VERIFY
suffix:semicolon
r_else
r_if
c_cond
(paren
id|DRS-&gt;track
op_ne
id|NEED_1_RECAL
)paren
(brace
id|floppy_ready
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|floppy_off
c_func
(paren
id|current_drive
)paren
suffix:semicolon
id|current_drive
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|current_drive
op_eq
id|N_DRIVE
op_logical_or
id|fdc_state
(braket
id|FDC
c_func
(paren
id|current_drive
)paren
)braket
dot
id|version
op_eq
id|FDC_NONE
)paren
(brace
id|set_fdc
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
id|floppy_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|set_fdc
c_func
(paren
id|current_drive
)paren
suffix:semicolon
id|floppy_ready
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* next */
)brace
DECL|variable|detect_cont
r_static
r_struct
id|cont_t
id|detect_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|floppy_init
r_void
id|floppy_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
comma
op_amp
id|floppy_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major %d for floppy&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|TYPE
c_func
(paren
id|i
)paren
)paren
id|floppy_sizes
(braket
id|i
)braket
op_assign
id|floppy_type
(braket
id|TYPE
c_func
(paren
id|i
)paren
)braket
dot
id|size
op_rshift
l_int|1
suffix:semicolon
r_else
id|floppy_sizes
(braket
id|i
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|floppy_sizes
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|timer_table
(braket
id|FLOPPY_TIMER
)braket
dot
id|fn
op_assign
id|floppy_shutdown
suffix:semicolon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|FLOPPY_TIMER
)paren
suffix:semicolon
id|config_types
c_func
(paren
)paren
suffix:semicolon
id|fdc_state
(braket
l_int|0
)braket
dot
id|address
op_assign
l_int|0x3f0
suffix:semicolon
macro_line|#if N_FDC &gt; 1
id|fdc_state
(braket
l_int|1
)braket
dot
id|address
op_assign
l_int|0x370
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_FDC
suffix:semicolon
id|i
op_increment
)paren
(brace
id|fdc
op_assign
id|i
suffix:semicolon
id|FDCS-&gt;dtr
op_assign
op_minus
l_int|1
suffix:semicolon
id|FDCS-&gt;dor
op_assign
l_int|0
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|0
suffix:semicolon
id|FDCS-&gt;version
op_assign
id|FDC_NONE
suffix:semicolon
id|set_dor
c_func
(paren
id|fdc
comma
op_complement
l_int|0
comma
l_int|0xc
)paren
suffix:semicolon
)brace
multiline_comment|/* initialise drive state */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_DRIVE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|current_drive
op_assign
id|i
suffix:semicolon
id|DRS-&gt;flags
op_assign
id|FD_VERIFY
suffix:semicolon
id|DRS-&gt;generation
op_assign
l_int|0
suffix:semicolon
id|DRS-&gt;keep_data
op_assign
l_int|0
suffix:semicolon
id|DRS-&gt;fd_ref
op_assign
l_int|0
suffix:semicolon
id|DRS-&gt;fd_device
op_assign
l_int|0
suffix:semicolon
)brace
id|floppy_grab_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_FDC
suffix:semicolon
id|i
op_increment
)paren
(brace
id|fdc
op_assign
id|i
suffix:semicolon
id|FDCS-&gt;rawcmd
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|user_reset_fdc
c_func
(paren
op_minus
l_int|1
comma
id|FD_RESET_IF_NEEDED
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* Try to determine the floppy controller type */
id|FDCS-&gt;version
op_assign
id|get_fdc_version
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;version
op_eq
id|FDC_NONE
)paren
r_continue
suffix:semicolon
multiline_comment|/* Not all FDCs seem to be able to handle the version command&n;&t;&t; * properly, so force a reset for the standard FDC clones,&n;&t;&t; * to avoid interrupt garbage.&n;&t;&t; */
id|FDCS-&gt;has_fifo
op_assign
id|FDCS-&gt;version
op_ge
id|FDC_82077_ORIG
suffix:semicolon
id|user_reset_fdc
c_func
(paren
op_minus
l_int|1
comma
id|FD_RESET_ALWAYS
)paren
suffix:semicolon
)brace
id|fdc
op_assign
l_int|0
suffix:semicolon
id|current_drive
op_assign
l_int|0
suffix:semicolon
id|lock_fdc
c_func
(paren
op_minus
l_int|1
)paren
suffix:semicolon
id|initialising
op_assign
l_int|0
suffix:semicolon
id|command_status
op_assign
id|FD_COMMAND_DETECT
suffix:semicolon
id|cont
op_assign
op_amp
id|detect_cont
suffix:semicolon
id|raw_cmd.cmd_count
op_assign
l_int|0
suffix:semicolon
id|raw_cmd.flags
op_assign
id|FD_RAW_NEED_SEEK
suffix:semicolon
id|raw_cmd.track
op_assign
l_int|0
suffix:semicolon
id|floppy_ready
c_func
(paren
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|floppy_grab_irq_and_dma
r_int
id|floppy_grab_irq_and_dma
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|usage_count
op_increment
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|FLOPPY_IRQ
comma
id|floppy_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;floppy&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Unable to grab IRQ%d for the floppy driver&bslash;n&quot;
comma
id|FLOPPY_IRQ
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|FLOPPY_DMA
comma
l_string|&quot;floppy&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Unable to grab DMA%d for the floppy driver&bslash;n&quot;
comma
id|FLOPPY_DMA
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|FLOPPY_IRQ
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|enable_irq
c_func
(paren
id|FLOPPY_IRQ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|floppy_release_irq_and_dma
r_void
id|floppy_release_irq_and_dma
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|usage_count
)paren
r_return
suffix:semicolon
id|disable_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|disable_irq
c_func
(paren
id|FLOPPY_IRQ
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|FLOPPY_IRQ
)paren
suffix:semicolon
macro_line|#ifdef HAVE_2_CONTROLLERS
multiline_comment|/* switch on first controller.&n;&t; * This saves us trouble on the next reboot. */
id|set_dor
c_func
(paren
l_int|0
comma
op_complement
l_int|0
comma
l_int|8
)paren
suffix:semicolon
id|set_dor
c_func
(paren
l_int|1
comma
op_complement
l_int|8
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
)brace
eof
