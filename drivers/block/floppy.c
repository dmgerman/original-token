multiline_comment|/*&n; *  linux/drivers/block/floppy.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *  Copyright (C) 1993, 1994  Alain Knaff&n; *  Copyright (C) 1998 Alan Cox&n; */
multiline_comment|/*&n; * 02.12.91 - Changed to static variables to indicate need for reset&n; * and recalibrate. This makes some things easier (output_byte reset&n; * checking etc), and means less interrupt jumping in case of errors,&n; * so the code is hopefully easier to understand.&n; */
multiline_comment|/*&n; * This file is certainly a mess. I&squot;ve tried my best to get it working,&n; * but I don&squot;t like programming floppies, and I have only one anyway.&n; * Urgel. I should check for more errors, and do more graceful error&n; * recovery. Seems there are problems with several drives. I&squot;ve tried to&n; * correct them. No promises.&n; */
multiline_comment|/*&n; * As with hd.c, all routines within this file can (and will) be called&n; * by interrupts, so extreme caution is needed. A hardware interrupt&n; * handler may not sleep, or a kernel panic will happen. Thus I cannot&n; * call &quot;floppy-on&quot; directly, but have to set a special timer interrupt&n; * etc.&n; */
multiline_comment|/*&n; * 28.02.92 - made track-buffering routines, based on the routines written&n; * by entropy@wintermute.wpi.edu (Lawrence Foard). Linus.&n; */
multiline_comment|/*&n; * Automatic floppy-detection and formatting written by Werner Almesberger&n; * (almesber@nessie.cs.id.ethz.ch), who also corrected some problems with&n; * the floppy-change signal detection.&n; */
multiline_comment|/*&n; * 1992/7/22 -- Hennus Bergman: Added better error reporting, fixed&n; * FDC data overrun bug, added some preliminary stuff for vertical&n; * recording support.&n; *&n; * 1992/9/17: Added DMA allocation &amp; DMA functions. -- hhb.&n; *&n; * TODO: Errors are still not counted properly.&n; */
multiline_comment|/* 1992/9/20&n; * Modifications for ``Sector Shifting&squot;&squot; by Rob Hooft (hooft@chem.ruu.nl)&n; * modeled after the freeware MS-DOS program fdformat/88 V1.8 by&n; * Christoph H. Hochst&bslash;&quot;atter.&n; * I have fixed the shift values to the ones I always use. Maybe a new&n; * ioctl() should be created to be able to modify them.&n; * There is a bug in the driver that makes it impossible to format a&n; * floppy as the first thing after bootup.&n; */
multiline_comment|/*&n; * 1993/4/29 -- Linus -- cleaned up the timer handling in the kernel, and&n; * this helped the floppy driver as well. Much cleaner, and still seems to&n; * work.&n; */
multiline_comment|/* 1994/6/24 --bbroad-- added the floppy table entries and made&n; * minor modifications to allow 2.88 floppies to be run.&n; */
multiline_comment|/* 1994/7/13 -- Paul Vojta -- modified the probing code to allow three or more&n; * disk types.&n; */
multiline_comment|/*&n; * 1994/8/8 -- Alain Knaff -- Switched to fdpatch driver: Support for bigger&n; * format bug fixes, but unfortunately some new bugs too...&n; */
multiline_comment|/* 1994/9/17 -- Koen Holtman -- added logging of physical floppy write&n; * errors to allow safe writing by specialized programs.&n; */
multiline_comment|/* 1995/4/24 -- Dan Fandrich -- added support for Commodore 1581 3.5&quot; disks&n; * by defining bit 1 of the &quot;stretch&quot; parameter to mean put sectors on the&n; * opposite side of the disk, leaving the sector IDs alone (i.e. Commodore&squot;s&n; * drives are &quot;upside-down&quot;).&n; */
multiline_comment|/*&n; * 1995/8/26 -- Andreas Busse -- added Mips support.&n; */
multiline_comment|/*&n; * 1995/10/18 -- Ralf Baechle -- Portability cleanup; move machine dependent&n; * features to asm/floppy.h.&n; */
multiline_comment|/*&n; * 1998/05/07 -- Russell King -- More portability cleanups; moved definition of&n; * interrupt and dma channel to asm/floppy.h. Cleaned up some formatting &amp;&n; * use of &squot;0&squot; for NULL.&n; */
multiline_comment|/*&n; * 1998/06/07 -- Alan Cox -- Merged the 2.0.34 fixes for resource allocation&n; * failures.&n; */
multiline_comment|/*&n; * 1998/09/20 -- David Weinehall -- Added slow-down code for buggy PS/2-drives.&n; */
multiline_comment|/*&n; * 1999/08/13 -- Paul Slootman -- floppy stopped working on Alpha after 24&n; * days, 6 hours, 32 minutes and 32 seconds (i.e. MAXINT jiffies; ints were&n; * being used to store jiffies, which are unsigned longs).&n; */
multiline_comment|/*&n; * 2000/08/28 -- Arnaldo Carvalho de Melo &lt;acme@conectiva.com.br&gt;&n; * - get rid of check_region&n; * - s/suser/capable/&n; */
DECL|macro|FLOPPY_SANITY_CHECK
mdefine_line|#define FLOPPY_SANITY_CHECK
DECL|macro|FLOPPY_SILENT_DCL_CLEAR
macro_line|#undef  FLOPPY_SILENT_DCL_CLEAR
DECL|macro|REALLY_SLOW_IO
mdefine_line|#define REALLY_SLOW_IO
DECL|macro|DEBUGT
mdefine_line|#define DEBUGT 2
DECL|macro|DCL_DEBUG
mdefine_line|#define DCL_DEBUG /* debug disk change line */
multiline_comment|/* do print messages for unexpected interrupts */
DECL|variable|print_unex
r_static
r_int
id|print_unex
op_assign
l_int|1
suffix:semicolon
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
DECL|macro|FDPATCHES
mdefine_line|#define FDPATCHES
macro_line|#include &lt;linux/fdreg.h&gt;
multiline_comment|/*&n; * 1998/1/21 -- Richard Gooch &lt;rgooch@atnf.csiro.au&gt; -- devfs support&n; */
macro_line|#include &lt;linux/fd.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/mc146818rtc.h&gt; /* CMOS defines */
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
multiline_comment|/*&n; * PS/2 floppies have much slower step rates than regular floppies.&n; * It&squot;s been recommended that take about 1/4 of the default speed&n; * in some more extreme cases.&n; */
DECL|variable|slow_floppy
r_static
r_int
id|slow_floppy
suffix:semicolon
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|variable|FLOPPY_IRQ
r_static
r_int
id|FLOPPY_IRQ
op_assign
l_int|6
suffix:semicolon
DECL|variable|FLOPPY_DMA
r_static
r_int
id|FLOPPY_DMA
op_assign
l_int|2
suffix:semicolon
DECL|variable|can_use_virtual_dma
r_static
r_int
id|can_use_virtual_dma
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* =======&n; * can use virtual DMA:&n; * 0 = use of virtual DMA disallowed by config&n; * 1 = use of virtual DMA prescribed by config&n; * 2 = no virtual DMA preference configured.  By default try hard DMA,&n; * but fall back on virtual DMA when not enough memory available&n; */
DECL|variable|use_virtual_dma
r_static
r_int
id|use_virtual_dma
suffix:semicolon
multiline_comment|/* =======&n; * use virtual DMA&n; * 0 using hard DMA&n; * 1 using virtual DMA&n; * This variable is set to virtual when a DMA mem problem arises, and&n; * reset back in floppy_grab_irq_and_dma.&n; * It is not safe to reset it in other circumstances, because the floppy&n; * driver may have several buffers in use at once, and we do currently not&n; * record each buffers capabilities&n; */
DECL|variable|virtual_dma_port
r_static
r_int
r_int
id|virtual_dma_port
op_assign
l_int|0x3f0
suffix:semicolon
r_void
id|floppy_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
suffix:semicolon
r_static
r_int
id|set_dor
c_func
(paren
r_int
id|fdc
comma
r_char
id|mask
comma
r_char
id|data
)paren
suffix:semicolon
r_static
r_void
id|register_devfs_entries
(paren
r_int
id|drive
)paren
id|__init
suffix:semicolon
DECL|variable|devfs_handle
r_static
id|devfs_handle_t
id|devfs_handle
suffix:semicolon
DECL|macro|K_64
mdefine_line|#define K_64&t;0x10000&t;&t;/* 64KB */
multiline_comment|/* the following is the mask of allowed drives. By default units 2 and&n; * 3 of both floppy controllers are disabled, because switching on the&n; * motor of these drives causes system hangs on some PCI computers. drive&n; * 0 is the low bit (0x1), and drive 7 is the high bit (0x80). Bits are on if&n; * a drive is allowed.&n; *&n; * NOTE: This must come before we include the arch floppy header because&n; *       some ports reference this variable from there. -DaveM&n; */
DECL|variable|allowed_drive_mask
r_static
r_int
id|allowed_drive_mask
op_assign
l_int|0x33
suffix:semicolon
macro_line|#include &lt;asm/floppy.h&gt;
DECL|variable|irqdma_allocated
r_static
r_int
id|irqdma_allocated
suffix:semicolon
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR FLOPPY_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt; /* for the compatibility eject ioctl */
macro_line|#ifndef fd_get_dma_residue
DECL|macro|fd_get_dma_residue
mdefine_line|#define fd_get_dma_residue() get_dma_residue(FLOPPY_DMA)
macro_line|#endif
multiline_comment|/* Dma Memory related stuff */
macro_line|#ifndef fd_dma_mem_free
DECL|macro|fd_dma_mem_free
mdefine_line|#define fd_dma_mem_free(addr, size) free_pages(addr, get_order(size))
macro_line|#endif
macro_line|#ifndef fd_dma_mem_alloc
DECL|macro|fd_dma_mem_alloc
mdefine_line|#define fd_dma_mem_alloc(size) __get_dma_pages(GFP_KERNEL,get_order(size))
macro_line|#endif
DECL|function|fallback_on_nodma_alloc
r_static
r_inline
r_void
id|fallback_on_nodma_alloc
c_func
(paren
r_char
op_star
op_star
id|addr
comma
r_int
id|l
)paren
(brace
macro_line|#ifdef FLOPPY_CAN_FALLBACK_ON_NODMA
r_if
c_cond
(paren
op_star
id|addr
)paren
r_return
suffix:semicolon
multiline_comment|/* we have the memory */
r_if
c_cond
(paren
id|can_use_virtual_dma
op_ne
l_int|2
)paren
r_return
suffix:semicolon
multiline_comment|/* no fallback allowed */
id|printk
c_func
(paren
l_string|&quot;DMA memory shortage. Temporarily falling back on virtual DMA&bslash;n&quot;
)paren
suffix:semicolon
op_star
id|addr
op_assign
(paren
r_char
op_star
)paren
id|nodma_mem_alloc
c_func
(paren
id|l
)paren
suffix:semicolon
macro_line|#else
r_return
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* End dma memory related stuff */
DECL|variable|fake_change
r_static
r_int
r_int
id|fake_change
suffix:semicolon
DECL|variable|initialising
r_static
r_int
id|initialising
op_assign
l_int|1
suffix:semicolon
DECL|function|TYPE
r_static
r_inline
r_int
id|TYPE
c_func
(paren
id|kdev_t
id|x
)paren
(brace
r_return
(paren
id|MINOR
c_func
(paren
id|x
)paren
op_rshift
l_int|2
)paren
op_amp
l_int|0x1f
suffix:semicolon
)brace
DECL|function|DRIVE
r_static
r_inline
r_int
id|DRIVE
c_func
(paren
id|kdev_t
id|x
)paren
(brace
r_return
(paren
id|MINOR
c_func
(paren
id|x
)paren
op_amp
l_int|0x03
)paren
op_or
(paren
(paren
id|MINOR
c_func
(paren
id|x
)paren
op_amp
l_int|0x80
)paren
op_rshift
l_int|5
)paren
suffix:semicolon
)brace
DECL|macro|ITYPE
mdefine_line|#define ITYPE(x) (((x)&gt;&gt;2) &amp; 0x1f)
DECL|macro|TOMINOR
mdefine_line|#define TOMINOR(x) ((x &amp; 3) | ((x &amp; 4) &lt;&lt; 5))
DECL|macro|UNIT
mdefine_line|#define UNIT(x) ((x) &amp; 0x03)&t;&t;/* drive on fdc */
DECL|macro|FDC
mdefine_line|#define FDC(x) (((x) &amp; 0x04) &gt;&gt; 2)  /* fdc of drive */
DECL|macro|REVDRIVE
mdefine_line|#define REVDRIVE(fdc, unit) ((unit) + ((fdc) &lt;&lt; 2))
multiline_comment|/* reverse mapping from unit and fdc to drive */
DECL|macro|DP
mdefine_line|#define DP (&amp;drive_params[current_drive])
DECL|macro|DRS
mdefine_line|#define DRS (&amp;drive_state[current_drive])
DECL|macro|DRWE
mdefine_line|#define DRWE (&amp;write_errors[current_drive])
DECL|macro|FDCS
mdefine_line|#define FDCS (&amp;fdc_state[fdc])
DECL|macro|CLEARF
mdefine_line|#define CLEARF(x) (clear_bit(x##_BIT, &amp;DRS-&gt;flags))
DECL|macro|SETF
mdefine_line|#define SETF(x) (set_bit(x##_BIT, &amp;DRS-&gt;flags))
DECL|macro|TESTF
mdefine_line|#define TESTF(x) (test_bit(x##_BIT, &amp;DRS-&gt;flags))
DECL|macro|UDP
mdefine_line|#define UDP (&amp;drive_params[drive])
DECL|macro|UDRS
mdefine_line|#define UDRS (&amp;drive_state[drive])
DECL|macro|UDRWE
mdefine_line|#define UDRWE (&amp;write_errors[drive])
DECL|macro|UFDCS
mdefine_line|#define UFDCS (&amp;fdc_state[FDC(drive)])
DECL|macro|UCLEARF
mdefine_line|#define UCLEARF(x) (clear_bit(x##_BIT, &amp;UDRS-&gt;flags))
DECL|macro|USETF
mdefine_line|#define USETF(x) (set_bit(x##_BIT, &amp;UDRS-&gt;flags))
DECL|macro|UTESTF
mdefine_line|#define UTESTF(x) (test_bit(x##_BIT, &amp;UDRS-&gt;flags))
DECL|macro|DPRINT
mdefine_line|#define DPRINT(format, args...) printk(DEVICE_NAME &quot;%d: &quot; format, current_drive , ## args)
DECL|macro|PH_HEAD
mdefine_line|#define PH_HEAD(floppy,head) (((((floppy)-&gt;stretch &amp; 2) &gt;&gt;1) ^ head) &lt;&lt; 2)
DECL|macro|STRETCH
mdefine_line|#define STRETCH(floppy) ((floppy)-&gt;stretch &amp; FD_STRETCH)
DECL|macro|CLEARSTRUCT
mdefine_line|#define CLEARSTRUCT(x) memset((x), 0, sizeof(*(x)))
multiline_comment|/* read/write */
DECL|macro|COMMAND
mdefine_line|#define COMMAND raw_cmd-&gt;cmd[0]
DECL|macro|DR_SELECT
mdefine_line|#define DR_SELECT raw_cmd-&gt;cmd[1]
DECL|macro|TRACK
mdefine_line|#define TRACK raw_cmd-&gt;cmd[2]
DECL|macro|HEAD
mdefine_line|#define HEAD raw_cmd-&gt;cmd[3]
DECL|macro|SECTOR
mdefine_line|#define SECTOR raw_cmd-&gt;cmd[4]
DECL|macro|SIZECODE
mdefine_line|#define SIZECODE raw_cmd-&gt;cmd[5]
DECL|macro|SECT_PER_TRACK
mdefine_line|#define SECT_PER_TRACK raw_cmd-&gt;cmd[6]
DECL|macro|GAP
mdefine_line|#define GAP raw_cmd-&gt;cmd[7]
DECL|macro|SIZECODE2
mdefine_line|#define SIZECODE2 raw_cmd-&gt;cmd[8]
DECL|macro|NR_RW
mdefine_line|#define NR_RW 9
multiline_comment|/* format */
DECL|macro|F_SIZECODE
mdefine_line|#define F_SIZECODE raw_cmd-&gt;cmd[2]
DECL|macro|F_SECT_PER_TRACK
mdefine_line|#define F_SECT_PER_TRACK raw_cmd-&gt;cmd[3]
DECL|macro|F_GAP
mdefine_line|#define F_GAP raw_cmd-&gt;cmd[4]
DECL|macro|F_FILL
mdefine_line|#define F_FILL raw_cmd-&gt;cmd[5]
DECL|macro|NR_F
mdefine_line|#define NR_F 6
multiline_comment|/*&n; * Maximum disk size (in kilobytes). This default is used whenever the&n; * current disk size is unknown.&n; * [Now it is rather a minimum]&n; */
DECL|macro|MAX_DISK_SIZE
mdefine_line|#define MAX_DISK_SIZE 4 /* 3984*/
multiline_comment|/*&n; * globals used by &squot;result()&squot;&n; */
DECL|macro|MAX_REPLIES
mdefine_line|#define MAX_REPLIES 16
DECL|variable|reply_buffer
r_static
r_int
r_char
id|reply_buffer
(braket
id|MAX_REPLIES
)braket
suffix:semicolon
DECL|variable|inr
r_static
r_int
id|inr
suffix:semicolon
multiline_comment|/* size of reply buffer, when called from interrupt */
DECL|macro|ST0
mdefine_line|#define ST0 (reply_buffer[0])
DECL|macro|ST1
mdefine_line|#define ST1 (reply_buffer[1])
DECL|macro|ST2
mdefine_line|#define ST2 (reply_buffer[2])
DECL|macro|ST3
mdefine_line|#define ST3 (reply_buffer[0]) /* result of GETSTATUS */
DECL|macro|R_TRACK
mdefine_line|#define R_TRACK (reply_buffer[3])
DECL|macro|R_HEAD
mdefine_line|#define R_HEAD (reply_buffer[4])
DECL|macro|R_SECTOR
mdefine_line|#define R_SECTOR (reply_buffer[5])
DECL|macro|R_SIZECODE
mdefine_line|#define R_SIZECODE (reply_buffer[6])
DECL|macro|SEL_DLY
mdefine_line|#define SEL_DLY (2*HZ/100)
multiline_comment|/*&n; * this struct defines the different floppy drive types.&n; */
r_static
r_struct
(brace
DECL|member|params
r_struct
id|floppy_drive_params
id|params
suffix:semicolon
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/* name printed while booting */
DECL|variable|default_drive_params
)brace
id|default_drive_params
(braket
)braket
op_assign
(brace
multiline_comment|/* NOTE: the time values in jiffies should be in msec!&n; CMOS drive type&n;  |     Maximum data rate supported by drive type&n;  |     |   Head load time, msec&n;  |     |   |   Head unload time, msec (not used)&n;  |     |   |   |     Step rate interval, usec&n;  |     |   |   |     |       Time needed for spinup time (jiffies)&n;  |     |   |   |     |       |      Timeout for spinning down (jiffies)&n;  |     |   |   |     |       |      |   Spindown offset (where disk stops)&n;  |     |   |   |     |       |      |   |     Select delay&n;  |     |   |   |     |       |      |   |     |     RPS&n;  |     |   |   |     |       |      |   |     |     |    Max number of tracks&n;  |     |   |   |     |       |      |   |     |     |    |     Interrupt timeout&n;  |     |   |   |     |       |      |   |     |     |    |     |   Max nonintlv. sectors&n;  |     |   |   |     |       |      |   |     |     |    |     |   | -Max Errors- flags */
(brace
(brace
l_int|0
comma
l_int|500
comma
l_int|16
comma
l_int|16
comma
l_int|8000
comma
l_int|1
op_star
id|HZ
comma
l_int|3
op_star
id|HZ
comma
l_int|0
comma
id|SEL_DLY
comma
l_int|5
comma
l_int|80
comma
l_int|3
op_star
id|HZ
comma
l_int|20
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|7
comma
l_int|4
comma
l_int|8
comma
l_int|2
comma
l_int|1
comma
l_int|5
comma
l_int|3
comma
l_int|10
)brace
comma
l_int|3
op_star
id|HZ
op_div
l_int|2
comma
l_int|0
)brace
comma
l_string|&quot;unknown&quot;
)brace
comma
(brace
(brace
l_int|1
comma
l_int|300
comma
l_int|16
comma
l_int|16
comma
l_int|8000
comma
l_int|1
op_star
id|HZ
comma
l_int|3
op_star
id|HZ
comma
l_int|0
comma
id|SEL_DLY
comma
l_int|5
comma
l_int|40
comma
l_int|3
op_star
id|HZ
comma
l_int|17
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
l_int|3
op_star
id|HZ
op_div
l_int|2
comma
l_int|1
)brace
comma
l_string|&quot;360K PC&quot;
)brace
comma
multiline_comment|/*5 1/4 360 KB PC*/
(brace
(brace
l_int|2
comma
l_int|500
comma
l_int|16
comma
l_int|16
comma
l_int|6000
comma
l_int|4
op_star
id|HZ
op_div
l_int|10
comma
l_int|3
op_star
id|HZ
comma
l_int|14
comma
id|SEL_DLY
comma
l_int|6
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|17
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|2
comma
l_int|5
comma
l_int|6
comma
l_int|23
comma
l_int|10
comma
l_int|20
comma
l_int|12
comma
l_int|0
)brace
comma
l_int|3
op_star
id|HZ
op_div
l_int|2
comma
l_int|2
)brace
comma
l_string|&quot;1.2M&quot;
)brace
comma
multiline_comment|/*5 1/4 HD AT*/
(brace
(brace
l_int|3
comma
l_int|250
comma
l_int|16
comma
l_int|16
comma
l_int|3000
comma
l_int|1
op_star
id|HZ
comma
l_int|3
op_star
id|HZ
comma
l_int|0
comma
id|SEL_DLY
comma
l_int|5
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|20
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|4
comma
l_int|22
comma
l_int|21
comma
l_int|30
comma
l_int|3
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
l_int|3
op_star
id|HZ
op_div
l_int|2
comma
l_int|4
)brace
comma
l_string|&quot;720k&quot;
)brace
comma
multiline_comment|/*3 1/2 DD*/
(brace
(brace
l_int|4
comma
l_int|500
comma
l_int|16
comma
l_int|16
comma
l_int|4000
comma
l_int|4
op_star
id|HZ
op_div
l_int|10
comma
l_int|3
op_star
id|HZ
comma
l_int|10
comma
id|SEL_DLY
comma
l_int|5
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|20
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|7
comma
l_int|4
comma
l_int|25
comma
l_int|22
comma
l_int|31
comma
l_int|21
comma
l_int|29
comma
l_int|11
)brace
comma
l_int|3
op_star
id|HZ
op_div
l_int|2
comma
l_int|7
)brace
comma
l_string|&quot;1.44M&quot;
)brace
comma
multiline_comment|/*3 1/2 HD*/
(brace
(brace
l_int|5
comma
l_int|1000
comma
l_int|15
comma
l_int|8
comma
l_int|3000
comma
l_int|4
op_star
id|HZ
op_div
l_int|10
comma
l_int|3
op_star
id|HZ
comma
l_int|10
comma
id|SEL_DLY
comma
l_int|5
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|40
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|7
comma
l_int|8
comma
l_int|4
comma
l_int|25
comma
l_int|28
comma
l_int|22
comma
l_int|31
comma
l_int|21
)brace
comma
l_int|3
op_star
id|HZ
op_div
l_int|2
comma
l_int|8
)brace
comma
l_string|&quot;2.88M AMI BIOS&quot;
)brace
comma
multiline_comment|/*3 1/2 ED*/
(brace
(brace
l_int|6
comma
l_int|1000
comma
l_int|15
comma
l_int|8
comma
l_int|3000
comma
l_int|4
op_star
id|HZ
op_div
l_int|10
comma
l_int|3
op_star
id|HZ
comma
l_int|10
comma
id|SEL_DLY
comma
l_int|5
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|40
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|7
comma
l_int|8
comma
l_int|4
comma
l_int|25
comma
l_int|28
comma
l_int|22
comma
l_int|31
comma
l_int|21
)brace
comma
l_int|3
op_star
id|HZ
op_div
l_int|2
comma
l_int|8
)brace
comma
l_string|&quot;2.88M&quot;
)brace
multiline_comment|/*3 1/2 ED*/
multiline_comment|/*    |  --autodetected formats---    |      |      |&n; *    read_track                      |      |    Name printed when booting&n; *&t;&t;&t;&t;      |     Native format&n; *&t;            Frequency of disk change checks */
)brace
suffix:semicolon
DECL|variable|drive_params
r_static
r_struct
id|floppy_drive_params
id|drive_params
(braket
id|N_DRIVE
)braket
suffix:semicolon
DECL|variable|drive_state
r_static
r_struct
id|floppy_drive_struct
id|drive_state
(braket
id|N_DRIVE
)braket
suffix:semicolon
DECL|variable|write_errors
r_static
r_struct
id|floppy_write_errors
id|write_errors
(braket
id|N_DRIVE
)braket
suffix:semicolon
DECL|variable|raw_cmd
DECL|variable|default_raw_cmd
r_static
r_struct
id|floppy_raw_cmd
op_star
id|raw_cmd
comma
id|default_raw_cmd
suffix:semicolon
multiline_comment|/*&n; * This struct defines the different floppy types.&n; *&n; * Bit 0 of &squot;stretch&squot; tells if the tracks need to be doubled for some&n; * types (e.g. 360kB diskette in 1.2MB drive, etc.).  Bit 1 of &squot;stretch&squot;&n; * tells if the disk is in Commodore 1581 format, which means side 0 sectors&n; * are located on side 1 of the disk but with a side 0 ID, and vice-versa.&n; * This is the same as the Sharp MZ-80 5.25&quot; CP/M disk format, except that the&n; * 1581&squot;s logical side 0 is on physical side 1, whereas the Sharp&squot;s logical&n; * side 0 is on physical side 0 (but with the misnamed sector IDs).&n; * &squot;stretch&squot; should probably be renamed to something more general, like&n; * &squot;options&squot;.  Other parameters should be self-explanatory (see also&n; * setfdprm(8)).&n; */
multiline_comment|/*&n;&t;    Size&n;&t;     |  Sectors per track&n;&t;     |  | Head&n;&t;     |  | |  Tracks&n;&t;     |  | |  | Stretch&n;&t;     |  | |  | |  Gap 1 size&n;&t;     |  | |  | |    |  Data rate, | 0x40 for perp&n;&t;     |  | |  | |    |    |  Spec1 (stepping rate, head unload&n;&t;     |  | |  | |    |    |    |    /fmt gap (gap2) */
DECL|variable|floppy_type
r_static
r_struct
id|floppy_struct
id|floppy_type
(braket
l_int|32
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|NULL
)brace
comma
multiline_comment|/*  0 no testing    */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;d360&quot;
)brace
comma
multiline_comment|/*  1 360KB PC      */
(brace
l_int|2400
comma
l_int|15
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x54
comma
l_string|&quot;h1200&quot;
)brace
comma
multiline_comment|/*  2 1.2MB AT      */
(brace
l_int|720
comma
l_int|9
comma
l_int|1
comma
l_int|80
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;D360&quot;
)brace
comma
multiline_comment|/*  3 360KB SS 3.5&quot; */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;D720&quot;
)brace
comma
multiline_comment|/*  4 720KB 3.5&quot;    */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|1
comma
l_int|0x23
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;h360&quot;
)brace
comma
multiline_comment|/*  5 360KB AT      */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x23
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;h720&quot;
)brace
comma
multiline_comment|/*  6 720KB AT      */
(brace
l_int|2880
comma
l_int|18
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;H1440&quot;
)brace
comma
multiline_comment|/*  7 1.44MB 3.5&quot;   */
(brace
l_int|5760
comma
l_int|36
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x43
comma
l_int|0xAF
comma
l_int|0x54
comma
l_string|&quot;E2880&quot;
)brace
comma
multiline_comment|/*  8 2.88MB 3.5&quot;   */
(brace
l_int|6240
comma
l_int|39
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x43
comma
l_int|0xAF
comma
l_int|0x28
comma
l_string|&quot;E3120&quot;
)brace
comma
multiline_comment|/*  9 3.12MB 3.5&quot;   */
(brace
l_int|2880
comma
l_int|18
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x02
comma
l_string|&quot;h1440&quot;
)brace
comma
multiline_comment|/* 10 1.44MB 5.25&quot;  */
(brace
l_int|3360
comma
l_int|21
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x00
comma
l_int|0xCF
comma
l_int|0x0C
comma
l_string|&quot;H1680&quot;
)brace
comma
multiline_comment|/* 11 1.68MB 3.5&quot;   */
(brace
l_int|820
comma
l_int|10
comma
l_int|2
comma
l_int|41
comma
l_int|1
comma
l_int|0x25
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;h410&quot;
)brace
comma
multiline_comment|/* 12 410KB 5.25&quot;   */
(brace
l_int|1640
comma
l_int|10
comma
l_int|2
comma
l_int|82
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;H820&quot;
)brace
comma
multiline_comment|/* 13 820KB 3.5&quot;    */
(brace
l_int|2952
comma
l_int|18
comma
l_int|2
comma
l_int|82
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x02
comma
l_string|&quot;h1476&quot;
)brace
comma
multiline_comment|/* 14 1.48MB 5.25&quot;  */
(brace
l_int|3444
comma
l_int|21
comma
l_int|2
comma
l_int|82
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x0C
comma
l_string|&quot;H1722&quot;
)brace
comma
multiline_comment|/* 15 1.72MB 3.5&quot;   */
(brace
l_int|840
comma
l_int|10
comma
l_int|2
comma
l_int|42
comma
l_int|1
comma
l_int|0x25
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;h420&quot;
)brace
comma
multiline_comment|/* 16 420KB 5.25&quot;   */
(brace
l_int|1660
comma
l_int|10
comma
l_int|2
comma
l_int|83
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;H830&quot;
)brace
comma
multiline_comment|/* 17 830KB 3.5&quot;    */
(brace
l_int|2988
comma
l_int|18
comma
l_int|2
comma
l_int|83
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x02
comma
l_string|&quot;h1494&quot;
)brace
comma
multiline_comment|/* 18 1.49MB 5.25&quot;  */
(brace
l_int|3486
comma
l_int|21
comma
l_int|2
comma
l_int|83
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x0C
comma
l_string|&quot;H1743&quot;
)brace
comma
multiline_comment|/* 19 1.74 MB 3.5&quot;  */
(brace
l_int|1760
comma
l_int|11
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x09
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;h880&quot;
)brace
comma
multiline_comment|/* 20 880KB 5.25&quot;   */
(brace
l_int|2080
comma
l_int|13
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x01
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;D1040&quot;
)brace
comma
multiline_comment|/* 21 1.04MB 3.5&quot;   */
(brace
l_int|2240
comma
l_int|14
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x19
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;D1120&quot;
)brace
comma
multiline_comment|/* 22 1.12MB 3.5&quot;   */
(brace
l_int|3200
comma
l_int|20
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x20
comma
l_int|0xCF
comma
l_int|0x2C
comma
l_string|&quot;h1600&quot;
)brace
comma
multiline_comment|/* 23 1.6MB 5.25&quot;   */
(brace
l_int|3520
comma
l_int|22
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x08
comma
l_int|0xCF
comma
l_int|0x2e
comma
l_string|&quot;H1760&quot;
)brace
comma
multiline_comment|/* 24 1.76MB 3.5&quot;   */
(brace
l_int|3840
comma
l_int|24
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x20
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;H1920&quot;
)brace
comma
multiline_comment|/* 25 1.92MB 3.5&quot;   */
(brace
l_int|6400
comma
l_int|40
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x5B
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;E3200&quot;
)brace
comma
multiline_comment|/* 26 3.20MB 3.5&quot;   */
(brace
l_int|7040
comma
l_int|44
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x5B
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;E3520&quot;
)brace
comma
multiline_comment|/* 27 3.52MB 3.5&quot;   */
(brace
l_int|7680
comma
l_int|48
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x63
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;E3840&quot;
)brace
comma
multiline_comment|/* 28 3.84MB 3.5&quot;   */
(brace
l_int|3680
comma
l_int|23
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x10
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;H1840&quot;
)brace
comma
multiline_comment|/* 29 1.84MB 3.5&quot;   */
(brace
l_int|1600
comma
l_int|10
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;D800&quot;
)brace
comma
multiline_comment|/* 30 800KB 3.5&quot;    */
(brace
l_int|3200
comma
l_int|20
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x00
comma
l_int|0xCF
comma
l_int|0x2C
comma
l_string|&quot;H1600&quot;
)brace
comma
multiline_comment|/* 31 1.6MB 3.5&quot;    */
)brace
suffix:semicolon
DECL|macro|NUMBER
mdefine_line|#define&t;NUMBER(x)&t;(sizeof(x) / sizeof(*(x)))
DECL|macro|SECTSIZE
mdefine_line|#define SECTSIZE (_FD_SECTSIZE(*floppy))
multiline_comment|/* Auto-detection: Disk type used until the next media change occurs. */
DECL|variable|current_type
r_static
r_struct
id|floppy_struct
op_star
id|current_type
(braket
id|N_DRIVE
)braket
suffix:semicolon
multiline_comment|/*&n; * User-provided type information. current_type points to&n; * the respective entry of this array.&n; */
DECL|variable|user_params
r_static
r_struct
id|floppy_struct
id|user_params
(braket
id|N_DRIVE
)braket
suffix:semicolon
DECL|variable|floppy_sizes
r_static
r_int
id|floppy_sizes
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|floppy_blocksizes
r_static
r_int
id|floppy_blocksizes
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/*&n; * The driver is trying to determine the correct media format&n; * while probing is set. rw_interrupt() clears it after a&n; * successful access.&n; */
DECL|variable|probing
r_static
r_int
id|probing
suffix:semicolon
multiline_comment|/* Synchronization of FDC access. */
DECL|macro|FD_COMMAND_NONE
mdefine_line|#define FD_COMMAND_NONE -1
DECL|macro|FD_COMMAND_ERROR
mdefine_line|#define FD_COMMAND_ERROR 2
DECL|macro|FD_COMMAND_OKAY
mdefine_line|#define FD_COMMAND_OKAY 3
DECL|variable|command_status
r_static
r_volatile
r_int
id|command_status
op_assign
id|FD_COMMAND_NONE
suffix:semicolon
DECL|variable|fdc_busy
r_static
r_int
r_int
id|fdc_busy
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|fdc_wait
)paren
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|command_done
)paren
suffix:semicolon
DECL|macro|NO_SIGNAL
mdefine_line|#define NO_SIGNAL (!interruptible || !signal_pending(current))
DECL|macro|CALL
mdefine_line|#define CALL(x) if ((x) == -EINTR) return -EINTR
DECL|macro|ECALL
mdefine_line|#define ECALL(x) if ((ret = (x))) return ret;
DECL|macro|_WAIT
mdefine_line|#define _WAIT(x,i) CALL(ret=wait_til_done((x),i))
DECL|macro|WAIT
mdefine_line|#define WAIT(x) _WAIT((x),interruptible)
DECL|macro|IWAIT
mdefine_line|#define IWAIT(x) _WAIT((x),1)
multiline_comment|/* Errors during formatting are counted here. */
DECL|variable|format_errors
r_static
r_int
id|format_errors
suffix:semicolon
multiline_comment|/* Format request descriptor. */
DECL|variable|format_req
r_static
r_struct
id|format_descr
id|format_req
suffix:semicolon
multiline_comment|/*&n; * Rate is 0 for 500kb/s, 1 for 300kbps, 2 for 250kbps&n; * Spec1 is 0xSH, where S is stepping rate (F=1ms, E=2ms, D=3ms etc),&n; * H is head unload time (1=16ms, 2=32ms, etc)&n; */
multiline_comment|/*&n; * Track buffer&n; * Because these are written to by the DMA controller, they must&n; * not contain a 64k byte boundary crossing, or data will be&n; * corrupted/lost.&n; */
DECL|variable|floppy_track_buffer
r_static
r_char
op_star
id|floppy_track_buffer
suffix:semicolon
DECL|variable|max_buffer_sectors
r_static
r_int
id|max_buffer_sectors
suffix:semicolon
DECL|variable|errors
r_static
r_int
op_star
id|errors
suffix:semicolon
DECL|typedef|done_f
r_typedef
r_void
(paren
op_star
id|done_f
)paren
(paren
r_int
)paren
suffix:semicolon
DECL|struct|cont_t
r_static
r_struct
id|cont_t
(brace
DECL|member|interrupt
r_void
(paren
op_star
id|interrupt
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* this is called after the interrupt of the&n;&t;&t;&t;&t;  * main command */
DECL|member|redo
r_void
(paren
op_star
id|redo
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* this is called to retry the operation */
DECL|member|error
r_void
(paren
op_star
id|error
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* this is called to tally an error */
DECL|member|done
id|done_f
id|done
suffix:semicolon
multiline_comment|/* this is called to say if the operation has &n;&t;&t;      * succeeded/failed */
DECL|variable|cont
)brace
op_star
id|cont
suffix:semicolon
r_static
r_void
id|floppy_ready
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|floppy_start
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|process_fd_request
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|recalibrate_floppy
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|floppy_shutdown
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|floppy_grab_irq_and_dma
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|floppy_release_irq_and_dma
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * The &quot;reset&quot; variable should be tested whenever an interrupt is scheduled,&n; * after the commands have been sent. This is to ensure that the driver doesn&squot;t&n; * get wedged when the interrupt doesn&squot;t come because of a failed command.&n; * reset doesn&squot;t need to be tested before sending commands, because&n; * output_byte is automatically disabled when reset is set.&n; */
DECL|macro|CHECK_RESET
mdefine_line|#define CHECK_RESET { if (FDCS-&gt;reset){ reset_fdc(); return; } }
r_static
r_void
id|reset_fdc
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * These are global variables, as that&squot;s the easiest way to give&n; * information to interrupts. They are the data used for the current&n; * request.&n; */
DECL|macro|NO_TRACK
mdefine_line|#define NO_TRACK -1
DECL|macro|NEED_1_RECAL
mdefine_line|#define NEED_1_RECAL -2
DECL|macro|NEED_2_RECAL
mdefine_line|#define NEED_2_RECAL -3
DECL|variable|usage_count
r_static
r_int
id|usage_count
suffix:semicolon
multiline_comment|/* buffer related variables */
DECL|variable|buffer_track
r_static
r_int
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|buffer_drive
r_static
r_int
id|buffer_drive
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|buffer_min
r_static
r_int
id|buffer_min
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|buffer_max
r_static
r_int
id|buffer_max
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* fdc related variables, should end up in a struct */
DECL|variable|fdc_state
r_static
r_struct
id|floppy_fdc_state
id|fdc_state
(braket
id|N_FDC
)braket
suffix:semicolon
DECL|variable|fdc
r_static
r_int
id|fdc
suffix:semicolon
multiline_comment|/* current fdc */
DECL|variable|_floppy
r_static
r_struct
id|floppy_struct
op_star
id|_floppy
op_assign
id|floppy_type
suffix:semicolon
DECL|variable|current_drive
r_static
r_int
r_char
id|current_drive
suffix:semicolon
DECL|variable|current_count_sectors
r_static
r_int
id|current_count_sectors
suffix:semicolon
DECL|variable|sector_t
r_static
r_int
r_char
id|sector_t
suffix:semicolon
multiline_comment|/* sector in track */
DECL|variable|in_sector_offset
r_static
r_int
r_char
id|in_sector_offset
suffix:semicolon
multiline_comment|/* offset within physical sector,&n;&t;&t;&t;&t;&t; * expressed in units of 512 bytes */
macro_line|#ifndef fd_eject
DECL|macro|fd_eject
mdefine_line|#define fd_eject(x) -EINVAL
macro_line|#endif
macro_line|#ifdef DEBUGT
DECL|variable|debugtimer
r_static
r_int
r_int
id|debugtimer
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Debugging&n; * =========&n; */
DECL|function|set_debugt
r_static
r_inline
r_void
id|set_debugt
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUGT
id|debugtimer
op_assign
id|jiffies
suffix:semicolon
macro_line|#endif
)brace
DECL|function|debugt
r_static
r_inline
r_void
id|debugt
c_func
(paren
r_const
r_char
op_star
id|message
)paren
(brace
macro_line|#ifdef DEBUGT
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|DEBUGT
)paren
id|printk
c_func
(paren
l_string|&quot;%s dtime=%lu&bslash;n&quot;
comma
id|message
comma
id|jiffies
op_minus
id|debugtimer
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|typedef|timeout_fn
r_typedef
r_void
(paren
op_star
id|timeout_fn
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|fd_timeout
r_static
r_struct
id|timer_list
id|fd_timeout
op_assign
initialization_block
suffix:semicolon
DECL|variable|timeout_message
r_static
r_const
r_char
op_star
id|timeout_message
suffix:semicolon
macro_line|#ifdef FLOPPY_SANITY_CHECK
DECL|function|is_alive
r_static
r_void
id|is_alive
c_func
(paren
r_const
r_char
op_star
id|message
)paren
(brace
multiline_comment|/* this routine checks whether the floppy driver is &quot;alive&quot; */
r_if
c_cond
(paren
id|fdc_busy
op_logical_and
id|command_status
OL
l_int|2
op_logical_and
op_logical_neg
id|timer_pending
c_func
(paren
op_amp
id|fd_timeout
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;timeout handler died: %s&bslash;n&quot;
comma
id|message
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef FLOPPY_SANITY_CHECK
DECL|macro|OLOGSIZE
mdefine_line|#define OLOGSIZE 20
DECL|variable|lasthandler
r_static
r_void
(paren
op_star
id|lasthandler
)paren
(paren
r_void
)paren
suffix:semicolon
DECL|variable|interruptjiffies
r_static
r_int
r_int
id|interruptjiffies
suffix:semicolon
DECL|variable|resultjiffies
r_static
r_int
r_int
id|resultjiffies
suffix:semicolon
DECL|variable|resultsize
r_static
r_int
id|resultsize
suffix:semicolon
DECL|variable|lastredo
r_static
r_int
r_int
id|lastredo
suffix:semicolon
DECL|struct|output_log
r_static
r_struct
id|output_log
(brace
DECL|member|data
r_int
r_char
id|data
suffix:semicolon
DECL|member|status
r_int
r_char
id|status
suffix:semicolon
DECL|member|jiffies
r_int
r_int
id|jiffies
suffix:semicolon
DECL|variable|output_log
)brace
id|output_log
(braket
id|OLOGSIZE
)braket
suffix:semicolon
DECL|variable|output_log_pos
r_static
r_int
id|output_log_pos
suffix:semicolon
macro_line|#endif
DECL|macro|CURRENTD
mdefine_line|#define CURRENTD -1
DECL|macro|MAXTIMEOUT
mdefine_line|#define MAXTIMEOUT -2
DECL|function|reschedule_timeout
r_static
r_void
id|reschedule_timeout
c_func
(paren
r_int
id|drive
comma
r_const
r_char
op_star
id|message
comma
r_int
id|marg
)paren
(brace
r_if
c_cond
(paren
id|drive
op_eq
id|CURRENTD
)paren
id|drive
op_assign
id|current_drive
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|fd_timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
template_param
id|N_DRIVE
)paren
(brace
id|fd_timeout.expires
op_assign
id|jiffies
op_plus
l_int|20UL
op_star
id|HZ
suffix:semicolon
id|drive
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|fd_timeout.expires
op_assign
id|jiffies
op_plus
id|UDP-&gt;timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|fd_timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UDP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;reschedule timeout &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|message
comma
id|marg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|timeout_message
op_assign
id|message
suffix:semicolon
)brace
DECL|function|maximum
r_static
r_int
id|maximum
c_func
(paren
r_int
id|a
comma
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
OG
id|b
)paren
r_return
id|a
suffix:semicolon
r_else
r_return
id|b
suffix:semicolon
)brace
DECL|macro|INFBOUND
mdefine_line|#define INFBOUND(a,b) (a)=maximum((a),(b));
DECL|function|minimum
r_static
r_int
id|minimum
c_func
(paren
r_int
id|a
comma
r_int
id|b
)paren
(brace
r_if
c_cond
(paren
id|a
OL
id|b
)paren
r_return
id|a
suffix:semicolon
r_else
r_return
id|b
suffix:semicolon
)brace
DECL|macro|SUPBOUND
mdefine_line|#define SUPBOUND(a,b) (a)=minimum((a),(b));
multiline_comment|/*&n; * Bottom half floppy driver.&n; * ==========================&n; *&n; * This part of the file contains the code talking directly to the hardware,&n; * and also the main service loop (seek-configure-spinup-command)&n; */
multiline_comment|/*&n; * disk change.&n; * This routine is responsible for maintaining the FD_DISK_CHANGE flag,&n; * and the last_checked date.&n; *&n; * last_checked is the date of the last check which showed &squot;no disk change&squot;&n; * FD_DISK_CHANGE is set under two conditions:&n; * 1. The floppy has been changed after some i/o to that floppy already&n; *    took place.&n; * 2. No floppy disk is in the drive. This is done in order to ensure that&n; *    requests are quickly flushed in case there is no disk in the drive. It&n; *    follows that FD_DISK_CHANGE can only be cleared if there is a disk in&n; *    the drive.&n; *&n; * For 1., maxblock is observed. Maxblock is 0 if no i/o has taken place yet.&n; * For 2., FD_DISK_NEWCHANGE is watched. FD_DISK_NEWCHANGE is cleared on&n; *  each seek. If a disk is present, the disk change line should also be&n; *  cleared on each seek. Thus, if FD_DISK_NEWCHANGE is clear, but the disk&n; *  change line is set, this means either that no disk is in the drive, or&n; *  that it has been removed since the last seek.&n; *&n; * This means that we really have a third possibility too:&n; *  The floppy has been changed after the last seek.&n; */
DECL|function|disk_change
r_static
r_int
id|disk_change
c_func
(paren
r_int
id|drive
)paren
(brace
r_int
id|fdc
op_assign
id|FDC
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#ifdef FLOPPY_SANITY_CHECK
r_if
c_cond
(paren
id|jiffies
op_minus
id|UDRS-&gt;select_date
OL
id|UDP-&gt;select_delay
)paren
id|DPRINT
c_func
(paren
l_string|&quot;WARNING disk change called early&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|FDCS-&gt;dor
op_amp
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|drive
)paren
)paren
)paren
op_logical_or
(paren
id|FDCS-&gt;dor
op_amp
l_int|3
)paren
op_ne
id|UNIT
c_func
(paren
id|drive
)paren
op_logical_or
id|fdc
op_ne
id|FDC
c_func
(paren
id|drive
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;probing disk change on unselected drive&bslash;n&quot;
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;drive=%d fdc=%d dor=%x&bslash;n&quot;
comma
id|drive
comma
id|FDC
c_func
(paren
id|drive
)paren
comma
(paren
r_int
r_int
)paren
id|FDCS-&gt;dor
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|UDP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;checking disk change line for drive %d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;jiffies=%lu&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;disk change line=%x&bslash;n&quot;
comma
id|fd_inb
c_func
(paren
id|FD_DIR
)paren
op_amp
l_int|0x80
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;flags=%lx&bslash;n&quot;
comma
id|UDRS-&gt;flags
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|UDP-&gt;flags
op_amp
id|FD_BROKEN_DCL
)paren
r_return
id|UTESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|fd_inb
c_func
(paren
id|FD_DIR
)paren
op_xor
id|UDP-&gt;flags
)paren
op_amp
l_int|0x80
)paren
(brace
id|USETF
c_func
(paren
id|FD_VERIFY
)paren
suffix:semicolon
multiline_comment|/* verify write protection */
r_if
c_cond
(paren
id|UDRS-&gt;maxblock
)paren
(brace
multiline_comment|/* mark it changed */
id|USETF
c_func
(paren
id|FD_DISK_CHANGED
)paren
suffix:semicolon
)brace
multiline_comment|/* invalidate its geometry */
r_if
c_cond
(paren
id|UDRS-&gt;keep_data
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|UDP-&gt;flags
op_amp
id|FTD_MSG
)paren
op_logical_and
id|current_type
(braket
id|drive
)braket
op_ne
l_int|NULL
)paren
id|DPRINT
c_func
(paren
l_string|&quot;Disk type is undefined after &quot;
l_string|&quot;disk change&bslash;n&quot;
)paren
suffix:semicolon
id|current_type
(braket
id|drive
)braket
op_assign
l_int|NULL
suffix:semicolon
id|floppy_sizes
(braket
id|TOMINOR
c_func
(paren
id|drive
)paren
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
)brace
multiline_comment|/*USETF(FD_DISK_NEWCHANGE);*/
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|UDRS-&gt;last_checked
op_assign
id|jiffies
suffix:semicolon
id|UCLEARF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|is_selected
r_static
r_inline
r_int
id|is_selected
c_func
(paren
r_int
id|dor
comma
r_int
id|unit
)paren
(brace
r_return
(paren
(paren
id|dor
op_amp
(paren
l_int|0x10
op_lshift
id|unit
)paren
)paren
op_logical_and
(paren
id|dor
op_amp
l_int|3
)paren
op_eq
id|unit
)paren
suffix:semicolon
)brace
DECL|function|set_dor
r_static
r_int
id|set_dor
c_func
(paren
r_int
id|fdc
comma
r_char
id|mask
comma
r_char
id|data
)paren
(brace
r_register
r_int
r_char
id|drive
comma
id|unit
comma
id|newdor
comma
id|olddor
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;address
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|olddor
op_assign
id|FDCS-&gt;dor
suffix:semicolon
id|newdor
op_assign
(paren
id|olddor
op_amp
id|mask
)paren
op_or
id|data
suffix:semicolon
r_if
c_cond
(paren
id|newdor
op_ne
id|olddor
)paren
(brace
id|unit
op_assign
id|olddor
op_amp
l_int|0x3
suffix:semicolon
r_if
c_cond
(paren
id|is_selected
c_func
(paren
id|olddor
comma
id|unit
)paren
op_logical_and
op_logical_neg
id|is_selected
c_func
(paren
id|newdor
comma
id|unit
)paren
)paren
(brace
id|drive
op_assign
id|REVDRIVE
c_func
(paren
id|fdc
comma
id|unit
)paren
suffix:semicolon
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|UDP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;calling disk change from set_dor&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|disk_change
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
id|FDCS-&gt;dor
op_assign
id|newdor
suffix:semicolon
id|fd_outb
c_func
(paren
id|newdor
comma
id|FD_DOR
)paren
suffix:semicolon
id|unit
op_assign
id|newdor
op_amp
l_int|0x3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_selected
c_func
(paren
id|olddor
comma
id|unit
)paren
op_logical_and
id|is_selected
c_func
(paren
id|newdor
comma
id|unit
)paren
)paren
(brace
id|drive
op_assign
id|REVDRIVE
c_func
(paren
id|fdc
comma
id|unit
)paren
suffix:semicolon
id|UDRS-&gt;select_date
op_assign
id|jiffies
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; *&t;We should propogate failures to grab the resources back&n;&t; *&t;nicely from here. Actually we ought to rewrite the fd&n;&t; *&t;driver some day too.&n;&t; */
r_if
c_cond
(paren
id|newdor
op_amp
id|FLOPPY_MOTOR_MASK
)paren
id|floppy_grab_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|olddor
op_amp
id|FLOPPY_MOTOR_MASK
)paren
id|floppy_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
r_return
id|olddor
suffix:semicolon
)brace
DECL|function|twaddle
r_static
r_void
id|twaddle
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|DP-&gt;select_delay
)paren
r_return
suffix:semicolon
id|fd_outb
c_func
(paren
id|FDCS-&gt;dor
op_amp
op_complement
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
comma
id|FD_DOR
)paren
suffix:semicolon
id|fd_outb
c_func
(paren
id|FDCS-&gt;dor
comma
id|FD_DOR
)paren
suffix:semicolon
id|DRS-&gt;select_date
op_assign
id|jiffies
suffix:semicolon
)brace
multiline_comment|/* reset all driver information about the current fdc. This is needed after&n; * a reset, and after a raw command. */
DECL|function|reset_fdc_info
r_static
r_void
id|reset_fdc_info
c_func
(paren
r_int
id|mode
)paren
(brace
r_int
id|drive
suffix:semicolon
id|FDCS-&gt;spec1
op_assign
id|FDCS-&gt;spec2
op_assign
op_minus
l_int|1
suffix:semicolon
id|FDCS-&gt;need_configure
op_assign
l_int|1
suffix:semicolon
id|FDCS-&gt;perp_mode
op_assign
l_int|1
suffix:semicolon
id|FDCS-&gt;rawcmd
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|N_DRIVE
suffix:semicolon
id|drive
op_increment
)paren
r_if
c_cond
(paren
id|FDC
c_func
(paren
id|drive
)paren
op_eq
id|fdc
op_logical_and
(paren
id|mode
op_logical_or
id|UDRS-&gt;track
op_ne
id|NEED_1_RECAL
)paren
)paren
id|UDRS-&gt;track
op_assign
id|NEED_2_RECAL
suffix:semicolon
)brace
multiline_comment|/* selects the fdc and drive, and enables the fdc&squot;s input/dma. */
DECL|function|set_fdc
r_static
r_void
id|set_fdc
c_func
(paren
r_int
id|drive
)paren
(brace
r_if
c_cond
(paren
id|drive
op_ge
l_int|0
op_logical_and
id|drive
OL
id|N_DRIVE
)paren
(brace
id|fdc
op_assign
id|FDC
c_func
(paren
id|drive
)paren
suffix:semicolon
id|current_drive
op_assign
id|drive
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdc
op_ne
l_int|1
op_logical_and
id|fdc
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bad fdc value&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|set_dor
c_func
(paren
id|fdc
comma
op_complement
l_int|0
comma
l_int|8
)paren
suffix:semicolon
macro_line|#if N_FDC &gt; 1
id|set_dor
c_func
(paren
l_int|1
op_minus
id|fdc
comma
op_complement
l_int|8
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|FDCS-&gt;rawcmd
op_eq
l_int|2
)paren
id|reset_fdc_info
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fd_inb
c_func
(paren
id|FD_STATUS
)paren
op_ne
id|STATUS_READY
)paren
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* locks the driver */
DECL|function|_lock_fdc
r_static
r_int
id|_lock_fdc
c_func
(paren
r_int
id|drive
comma
r_int
id|interruptible
comma
r_int
id|line
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|usage_count
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Trying to lock fdc while usage count=0 at line %d&bslash;n&quot;
comma
id|line
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|floppy_grab_irq_and_dma
c_func
(paren
)paren
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|fdc_busy
)paren
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|fdc_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|test_and_set_bit
c_func
(paren
l_int|0
comma
op_amp
id|fdc_busy
)paren
)paren
r_break
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NO_SIGNAL
)paren
(brace
id|remove_wait_queue
c_func
(paren
op_amp
id|fdc_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|fdc_wait
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
id|command_status
op_assign
id|FD_COMMAND_NONE
suffix:semicolon
id|reschedule_timeout
c_func
(paren
id|drive
comma
l_string|&quot;lock fdc&quot;
comma
l_int|0
)paren
suffix:semicolon
id|set_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|lock_fdc
mdefine_line|#define lock_fdc(drive,interruptible) _lock_fdc(drive,interruptible, __LINE__)
DECL|macro|LOCK_FDC
mdefine_line|#define LOCK_FDC(drive,interruptible) &bslash;&n;if (lock_fdc(drive,interruptible)) return -EINTR;
multiline_comment|/* unlocks the driver */
DECL|function|unlock_fdc
r_static
r_inline
r_void
id|unlock_fdc
c_func
(paren
r_void
)paren
(brace
id|raw_cmd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fdc_busy
)paren
id|DPRINT
c_func
(paren
l_string|&quot;FDC access conflict!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEVICE_INTR
)paren
id|DPRINT
c_func
(paren
l_string|&quot;device interrupt still active at FDC release: %p!&bslash;n&quot;
comma
id|DEVICE_INTR
)paren
suffix:semicolon
id|command_status
op_assign
id|FD_COMMAND_NONE
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|fd_timeout
)paren
suffix:semicolon
id|cont
op_assign
l_int|NULL
suffix:semicolon
id|clear_bit
c_func
(paren
l_int|0
comma
op_amp
id|fdc_busy
)paren
suffix:semicolon
id|floppy_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* switches the motor off after a given timeout */
DECL|function|motor_off_callback
r_static
r_void
id|motor_off_callback
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
r_int
r_char
id|mask
op_assign
op_complement
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|nr
)paren
)paren
suffix:semicolon
id|set_dor
c_func
(paren
id|FDC
c_func
(paren
id|nr
)paren
comma
id|mask
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|motor_off_timer
r_static
r_struct
id|timer_list
id|motor_off_timer
(braket
id|N_DRIVE
)braket
op_assign
(brace
(brace
id|data
suffix:colon
l_int|0
comma
id|function
suffix:colon
id|motor_off_callback
)brace
comma
(brace
id|data
suffix:colon
l_int|1
comma
id|function
suffix:colon
id|motor_off_callback
)brace
comma
(brace
id|data
suffix:colon
l_int|2
comma
id|function
suffix:colon
id|motor_off_callback
)brace
comma
(brace
id|data
suffix:colon
l_int|3
comma
id|function
suffix:colon
id|motor_off_callback
)brace
comma
(brace
id|data
suffix:colon
l_int|4
comma
id|function
suffix:colon
id|motor_off_callback
)brace
comma
(brace
id|data
suffix:colon
l_int|5
comma
id|function
suffix:colon
id|motor_off_callback
)brace
comma
(brace
id|data
suffix:colon
l_int|6
comma
id|function
suffix:colon
id|motor_off_callback
)brace
comma
(brace
id|data
suffix:colon
l_int|7
comma
id|function
suffix:colon
id|motor_off_callback
)brace
)brace
suffix:semicolon
multiline_comment|/* schedules motor off */
DECL|function|floppy_off
r_static
r_void
id|floppy_off
c_func
(paren
r_int
r_int
id|drive
)paren
(brace
r_int
r_int
r_volatile
id|delta
suffix:semicolon
r_register
r_int
id|fdc
op_assign
id|FDC
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|FDCS-&gt;dor
op_amp
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|drive
)paren
)paren
)paren
)paren
r_return
suffix:semicolon
id|del_timer
c_func
(paren
id|motor_off_timer
op_plus
id|drive
)paren
suffix:semicolon
multiline_comment|/* make spindle stop in a position which minimizes spinup time&n;&t; * next time */
r_if
c_cond
(paren
id|UDP-&gt;rps
)paren
(brace
id|delta
op_assign
id|jiffies
op_minus
id|UDRS-&gt;first_read_date
op_plus
id|HZ
op_minus
id|UDP-&gt;spindown_offset
suffix:semicolon
id|delta
op_assign
(paren
(paren
id|delta
op_star
id|UDP-&gt;rps
)paren
op_mod
id|HZ
)paren
op_div
id|UDP-&gt;rps
suffix:semicolon
id|motor_off_timer
(braket
id|drive
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
id|UDP-&gt;spindown
op_minus
id|delta
suffix:semicolon
)brace
id|add_timer
c_func
(paren
id|motor_off_timer
op_plus
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * cycle through all N_DRIVE floppy drives, for disk change testing.&n; * stopping at current drive. This is done before any long operation, to&n; * be sure to have up to date disk change information.&n; */
DECL|function|scandrives
r_static
r_void
id|scandrives
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|drive
comma
id|saved_drive
suffix:semicolon
r_if
c_cond
(paren
id|DP-&gt;select_delay
)paren
r_return
suffix:semicolon
id|saved_drive
op_assign
id|current_drive
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_DRIVE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|drive
op_assign
(paren
id|saved_drive
op_plus
id|i
op_plus
l_int|1
)paren
op_mod
id|N_DRIVE
suffix:semicolon
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
op_eq
l_int|0
op_logical_or
id|UDP-&gt;select_delay
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* skip closed drives */
id|set_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|set_dor
c_func
(paren
id|fdc
comma
op_complement
l_int|3
comma
id|UNIT
c_func
(paren
id|drive
)paren
op_or
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|drive
)paren
)paren
)paren
op_amp
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|drive
)paren
)paren
)paren
)paren
multiline_comment|/* switch the motor off again, if it was off to&n;&t;&t;&t; * begin with */
id|set_dor
c_func
(paren
id|fdc
comma
op_complement
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|drive
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
id|set_fdc
c_func
(paren
id|saved_drive
)paren
suffix:semicolon
)brace
DECL|function|empty
r_static
r_void
id|empty
c_func
(paren
r_void
)paren
(brace
)brace
DECL|variable|floppy_tq
r_static
r_struct
id|tq_struct
id|floppy_tq
suffix:semicolon
DECL|function|schedule_bh
r_static
r_void
id|schedule_bh
c_func
(paren
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
op_star
)paren
)paren
(brace
id|floppy_tq.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|handler
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|floppy_tq
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
DECL|variable|fd_timer
r_static
r_struct
id|timer_list
id|fd_timer
suffix:semicolon
DECL|function|cancel_activity
r_static
r_void
id|cancel_activity
c_func
(paren
r_void
)paren
(brace
id|CLEAR_INTR
suffix:semicolon
id|floppy_tq.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|empty
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
)brace
multiline_comment|/* this function makes sure that the disk stays in the drive during the&n; * transfer */
DECL|function|fd_watchdog
r_static
r_void
id|fd_watchdog
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;calling disk change from watchdog&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|disk_change
c_func
(paren
id|current_drive
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;disk removed during i/o&bslash;n&quot;
)paren
suffix:semicolon
id|cancel_activity
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|reset_fdc
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
id|fd_timer.function
op_assign
(paren
id|timeout_fn
)paren
id|fd_watchdog
suffix:semicolon
id|fd_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|10
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
)brace
)brace
DECL|function|main_command_interrupt
r_static
r_void
id|main_command_interrupt
c_func
(paren
r_void
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|interrupt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* waits for a delay (spinup or select) to pass */
DECL|function|wait_for_completion
r_static
r_int
id|wait_for_completion
c_func
(paren
r_int
r_int
id|delay
comma
id|timeout_fn
id|function
)paren
(brace
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
(brace
id|reset_fdc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* do the reset during sleep to win time&n;&t;&t;&t;      * if we don&squot;t need to sleep, it&squot;s a good&n;&t;&t;&t;      * occasion anyways */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|jiffies
op_minus
id|delay
)paren
OL
l_int|0
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
id|fd_timer.function
op_assign
id|function
suffix:semicolon
id|fd_timer.expires
op_assign
id|delay
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|floppy_hlt_lock
r_static
id|spinlock_t
id|floppy_hlt_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|variable|hlt_disabled
r_static
r_int
id|hlt_disabled
suffix:semicolon
DECL|function|floppy_disable_hlt
r_static
r_void
id|floppy_disable_hlt
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|floppy_hlt_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hlt_disabled
)paren
(brace
id|hlt_disabled
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef HAVE_DISABLE_HLT
id|disable_hlt
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|floppy_hlt_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|floppy_enable_hlt
r_static
r_void
id|floppy_enable_hlt
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|floppy_hlt_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hlt_disabled
)paren
(brace
id|hlt_disabled
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef HAVE_DISABLE_HLT
id|enable_hlt
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|floppy_hlt_lock
comma
id|flags
)paren
suffix:semicolon
)brace
DECL|function|setup_DMA
r_static
r_void
id|setup_DMA
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|f
suffix:semicolon
macro_line|#ifdef FLOPPY_SANITY_CHECK
r_if
c_cond
(paren
id|raw_cmd-&gt;length
op_eq
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;zero dma transfer size:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|raw_cmd-&gt;cmd_count
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%x,&quot;
comma
id|raw_cmd-&gt;cmd
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|raw_cmd-&gt;kernel_data
)paren
op_mod
l_int|512
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;non aligned address: %p&bslash;n&quot;
comma
id|raw_cmd-&gt;kernel_data
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|f
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|fd_disable_dma
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef fd_dma_setup
r_if
c_cond
(paren
id|fd_dma_setup
c_func
(paren
id|raw_cmd-&gt;kernel_data
comma
id|raw_cmd-&gt;length
comma
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_READ
)paren
ques
c_cond
id|DMA_MODE_READ
suffix:colon
id|DMA_MODE_WRITE
comma
id|FDCS-&gt;address
)paren
OL
l_int|0
)paren
(brace
id|release_dma_lock
c_func
(paren
id|f
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|release_dma_lock
c_func
(paren
id|f
)paren
suffix:semicolon
macro_line|#else&t;
id|fd_clear_dma_ff
c_func
(paren
)paren
suffix:semicolon
id|fd_cacheflush
c_func
(paren
id|raw_cmd-&gt;kernel_data
comma
id|raw_cmd-&gt;length
)paren
suffix:semicolon
id|fd_set_dma_mode
c_func
(paren
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_READ
)paren
ques
c_cond
id|DMA_MODE_READ
suffix:colon
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|fd_set_dma_addr
c_func
(paren
id|raw_cmd-&gt;kernel_data
)paren
suffix:semicolon
id|fd_set_dma_count
c_func
(paren
id|raw_cmd-&gt;length
)paren
suffix:semicolon
id|virtual_dma_port
op_assign
id|FDCS-&gt;address
suffix:semicolon
id|fd_enable_dma
c_func
(paren
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|f
)paren
suffix:semicolon
macro_line|#endif
id|floppy_disable_hlt
c_func
(paren
)paren
suffix:semicolon
)brace
r_static
r_void
id|show_floppy
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* waits until the fdc becomes ready */
DECL|function|wait_til_ready
r_static
r_int
id|wait_til_ready
c_func
(paren
r_void
)paren
(brace
r_int
id|counter
comma
id|status
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
l_int|10000
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|status
op_assign
id|fd_inb
c_func
(paren
id|FD_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_amp
id|STATUS_READY
)paren
r_return
id|status
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|initialising
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;Getstatus times out (%x) on fdc %d&bslash;n&quot;
comma
id|status
comma
id|fdc
)paren
suffix:semicolon
id|show_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* sends a command byte to the fdc */
DECL|function|output_byte
r_static
r_int
id|output_byte
c_func
(paren
r_char
id|byte
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|wait_til_ready
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
(paren
id|STATUS_READY
op_or
id|STATUS_DIR
op_or
id|STATUS_DMA
)paren
)paren
op_eq
id|STATUS_READY
)paren
(brace
id|fd_outb
c_func
(paren
id|byte
comma
id|FD_DATA
)paren
suffix:semicolon
macro_line|#ifdef FLOPPY_SANITY_CHECK
id|output_log
(braket
id|output_log_pos
)braket
dot
id|data
op_assign
id|byte
suffix:semicolon
id|output_log
(braket
id|output_log_pos
)braket
dot
id|status
op_assign
id|status
suffix:semicolon
id|output_log
(braket
id|output_log_pos
)braket
dot
id|jiffies
op_assign
id|jiffies
suffix:semicolon
id|output_log_pos
op_assign
(paren
id|output_log_pos
op_plus
l_int|1
)paren
op_mod
id|OLOGSIZE
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initialising
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;Unable to send byte %x to FDC. Fdc=%x Status=%x&bslash;n&quot;
comma
id|byte
comma
id|fdc
comma
id|status
)paren
suffix:semicolon
id|show_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|macro|LAST_OUT
mdefine_line|#define LAST_OUT(x) if (output_byte(x)&lt;0){ reset_fdc();return;}
multiline_comment|/* gets the response from the fdc */
DECL|function|result
r_static
r_int
id|result
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|status
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_REPLIES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|status
op_assign
id|wait_til_ready
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|status
op_and_assign
id|STATUS_DIR
op_or
id|STATUS_READY
op_or
id|STATUS_BUSY
op_or
id|STATUS_DMA
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
op_complement
id|STATUS_BUSY
)paren
op_eq
id|STATUS_READY
)paren
(brace
macro_line|#ifdef FLOPPY_SANITY_CHECK
id|resultjiffies
op_assign
id|jiffies
suffix:semicolon
id|resultsize
op_assign
id|i
suffix:semicolon
macro_line|#endif
r_return
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_eq
(paren
id|STATUS_DIR
op_or
id|STATUS_READY
op_or
id|STATUS_BUSY
)paren
)paren
id|reply_buffer
(braket
id|i
)braket
op_assign
id|fd_inb
c_func
(paren
id|FD_DATA
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|initialising
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;get result error. Fdc=%d Last status=%x Read bytes=%d&bslash;n&quot;
comma
id|fdc
comma
id|status
comma
id|i
)paren
suffix:semicolon
id|show_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|macro|MORE_OUTPUT
mdefine_line|#define MORE_OUTPUT -2
multiline_comment|/* does the fdc need more output? */
DECL|function|need_more_output
r_static
r_int
id|need_more_output
c_func
(paren
r_void
)paren
(brace
r_int
id|status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_assign
id|wait_til_ready
c_func
(paren
)paren
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
(paren
id|STATUS_READY
op_or
id|STATUS_DIR
op_or
id|STATUS_DMA
)paren
)paren
op_eq
id|STATUS_READY
)paren
r_return
id|MORE_OUTPUT
suffix:semicolon
r_return
id|result
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Set perpendicular mode as required, based on data rate, if supported.&n; * 82077 Now tested. 1Mbps data rate only possible with 82077-1.&n; */
DECL|function|perpendicular_mode
r_static
r_inline
r_void
id|perpendicular_mode
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|perp_mode
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd-&gt;rate
op_amp
l_int|0x40
)paren
(brace
r_switch
c_cond
(paren
id|raw_cmd-&gt;rate
op_amp
l_int|3
)paren
(brace
r_case
l_int|0
suffix:colon
id|perp_mode
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|perp_mode
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DPRINT
c_func
(paren
l_string|&quot;Invalid data rate for perpendicular mode!&bslash;n&quot;
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* convenient way to return to&n;&t;&t;&t;&t;&t;&t;  * redo without to much hassle (deep&n;&t;&t;&t;&t;&t;&t;  * stack et al. */
r_return
suffix:semicolon
)brace
)brace
r_else
id|perp_mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;perp_mode
op_eq
id|perp_mode
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;version
op_ge
id|FDC_82077_ORIG
)paren
(brace
id|output_byte
c_func
(paren
id|FD_PERPENDICULAR
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|perp_mode
)paren
suffix:semicolon
id|FDCS-&gt;perp_mode
op_assign
id|perp_mode
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|perp_mode
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;perpendicular mode not supported by this FDC.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* perpendicular_mode */
DECL|variable|fifo_depth
r_static
r_int
id|fifo_depth
op_assign
l_int|0xa
suffix:semicolon
DECL|variable|no_fifo
r_static
r_int
id|no_fifo
suffix:semicolon
DECL|function|fdc_configure
r_static
r_int
id|fdc_configure
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* Turn on FIFO */
id|output_byte
c_func
(paren
id|FD_CONFIGURE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_more_output
c_func
(paren
)paren
op_ne
id|MORE_OUTPUT
)paren
r_return
l_int|0
suffix:semicolon
id|output_byte
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|0x10
op_or
(paren
id|no_fifo
op_amp
l_int|0x20
)paren
op_or
(paren
id|fifo_depth
op_amp
l_int|0xf
)paren
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* pre-compensation from track &n;&t;&t;&t;   0 upwards */
r_return
l_int|1
suffix:semicolon
)brace
DECL|macro|NOMINAL_DTR
mdefine_line|#define NOMINAL_DTR 500
multiline_comment|/* Issue a &quot;SPECIFY&quot; command to set the step rate time, head unload time,&n; * head load time, and DMA disable flag to values needed by floppy.&n; *&n; * The value &quot;dtr&quot; is the data transfer rate in Kbps.  It is needed&n; * to account for the data rate-based scaling done by the 82072 and 82077&n; * FDC types.  This parameter is ignored for other types of FDCs (i.e.&n; * 8272a).&n; *&n; * Note that changing the data transfer rate has a (probably deleterious)&n; * effect on the parameters subject to scaling for 82072/82077 FDCs, so&n; * fdc_specify is called again after each data transfer rate&n; * change.&n; *&n; * srt: 1000 to 16000 in microseconds&n; * hut: 16 to 240 milliseconds&n; * hlt: 2 to 254 milliseconds&n; *&n; * These values are rounded up to the next highest available delay time.&n; */
DECL|function|fdc_specify
r_static
r_void
id|fdc_specify
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|spec1
comma
id|spec2
suffix:semicolon
r_int
r_int
id|srt
comma
id|hlt
comma
id|hut
suffix:semicolon
r_int
r_int
id|dtr
op_assign
id|NOMINAL_DTR
suffix:semicolon
r_int
r_int
id|scale_dtr
op_assign
id|NOMINAL_DTR
suffix:semicolon
r_int
id|hlt_max_code
op_assign
l_int|0x7f
suffix:semicolon
r_int
id|hut_max_code
op_assign
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;need_configure
op_logical_and
id|FDCS-&gt;version
op_ge
id|FDC_82072A
)paren
(brace
id|fdc_configure
c_func
(paren
)paren
suffix:semicolon
id|FDCS-&gt;need_configure
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*DPRINT(&quot;FIFO enabled&bslash;n&quot;);*/
)brace
r_switch
c_cond
(paren
id|raw_cmd-&gt;rate
op_amp
l_int|0x03
)paren
(brace
r_case
l_int|3
suffix:colon
id|dtr
op_assign
l_int|1000
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|dtr
op_assign
l_int|300
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;version
op_ge
id|FDC_82078
)paren
(brace
multiline_comment|/* chose the default rate table, not the one&n;&t;&t;&t;&t; * where 1 = 2 Mbps */
id|output_byte
c_func
(paren
id|FD_DRIVESPEC
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_more_output
c_func
(paren
)paren
op_eq
id|MORE_OUTPUT
)paren
(brace
id|output_byte
c_func
(paren
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|0xc0
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|dtr
op_assign
l_int|250
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FDCS-&gt;version
op_ge
id|FDC_82072
)paren
(brace
id|scale_dtr
op_assign
id|dtr
suffix:semicolon
id|hlt_max_code
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* 0==256msec*dtr0/dtr (not linear!) */
id|hut_max_code
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* 0==256msec*dtr0/dtr (not linear!) */
)brace
multiline_comment|/* Convert step rate from microseconds to milliseconds and 4 bits */
id|srt
op_assign
l_int|16
op_minus
(paren
id|DP-&gt;srt
op_star
id|scale_dtr
op_div
l_int|1000
op_plus
id|NOMINAL_DTR
op_minus
l_int|1
)paren
op_div
id|NOMINAL_DTR
suffix:semicolon
r_if
c_cond
(paren
id|slow_floppy
)paren
(brace
id|srt
op_assign
id|srt
op_div
l_int|4
suffix:semicolon
)brace
id|SUPBOUND
c_func
(paren
id|srt
comma
l_int|0xf
)paren
suffix:semicolon
id|INFBOUND
c_func
(paren
id|srt
comma
l_int|0
)paren
suffix:semicolon
id|hlt
op_assign
(paren
id|DP-&gt;hlt
op_star
id|scale_dtr
op_div
l_int|2
op_plus
id|NOMINAL_DTR
op_minus
l_int|1
)paren
op_div
id|NOMINAL_DTR
suffix:semicolon
r_if
c_cond
(paren
id|hlt
OL
l_int|0x01
)paren
id|hlt
op_assign
l_int|0x01
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hlt
OG
l_int|0x7f
)paren
id|hlt
op_assign
id|hlt_max_code
suffix:semicolon
id|hut
op_assign
(paren
id|DP-&gt;hut
op_star
id|scale_dtr
op_div
l_int|16
op_plus
id|NOMINAL_DTR
op_minus
l_int|1
)paren
op_div
id|NOMINAL_DTR
suffix:semicolon
r_if
c_cond
(paren
id|hut
OL
l_int|0x1
)paren
id|hut
op_assign
l_int|0x1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hut
OG
l_int|0xf
)paren
id|hut
op_assign
id|hut_max_code
suffix:semicolon
id|spec1
op_assign
(paren
id|srt
op_lshift
l_int|4
)paren
op_or
id|hut
suffix:semicolon
id|spec2
op_assign
(paren
id|hlt
op_lshift
l_int|1
)paren
op_or
(paren
id|use_virtual_dma
op_amp
l_int|1
)paren
suffix:semicolon
multiline_comment|/* If these parameters did not change, just return with success */
r_if
c_cond
(paren
id|FDCS-&gt;spec1
op_ne
id|spec1
op_logical_or
id|FDCS-&gt;spec2
op_ne
id|spec2
)paren
(brace
multiline_comment|/* Go ahead and set spec1 and spec2 */
id|output_byte
c_func
(paren
id|FD_SPECIFY
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FDCS-&gt;spec1
op_assign
id|spec1
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FDCS-&gt;spec2
op_assign
id|spec2
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* fdc_specify */
multiline_comment|/* Set the FDC&squot;s data transfer rate on behalf of the specified drive.&n; * NOTE: with 82072/82077 FDCs, changing the data rate requires a reissue&n; * of the specify command (i.e. using the fdc_specify function).&n; */
DECL|function|fdc_dtr
r_static
r_int
id|fdc_dtr
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* If data rate not already set to desired value, set it. */
r_if
c_cond
(paren
(paren
id|raw_cmd-&gt;rate
op_amp
l_int|3
)paren
op_eq
id|FDCS-&gt;dtr
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Set dtr */
id|fd_outb
c_func
(paren
id|raw_cmd-&gt;rate
op_amp
l_int|3
comma
id|FD_DCR
)paren
suffix:semicolon
multiline_comment|/* TODO: some FDC/drive combinations (C&amp;T 82C711 with TEAC 1.2MB)&n;&t; * need a stabilization period of several milliseconds to be&n;&t; * enforced after data rate changes before R/W operations.&n;&t; * Pause 5 msec to avoid trouble. (Needs to be 2 jiffies)&n;&t; */
id|FDCS-&gt;dtr
op_assign
id|raw_cmd-&gt;rate
op_amp
l_int|3
suffix:semicolon
r_return
id|wait_for_completion
c_func
(paren
id|jiffies
op_plus
l_int|2UL
op_star
id|HZ
op_div
l_int|100
comma
(paren
id|timeout_fn
)paren
id|floppy_ready
)paren
suffix:semicolon
)brace
multiline_comment|/* fdc_dtr */
DECL|function|tell_sector
r_static
r_void
id|tell_sector
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;: track %d, head %d, sector %d, size %d&quot;
comma
id|R_TRACK
comma
id|R_HEAD
comma
id|R_SECTOR
comma
id|R_SIZECODE
)paren
suffix:semicolon
)brace
multiline_comment|/* tell_sector */
multiline_comment|/*&n; * OK, this error interpreting routine is called after a&n; * DMA read/write has succeeded&n; * or failed, so we check the results, and copy any buffers.&n; * hhb: Added better error reporting.&n; * ak: Made this into a separate routine.&n; */
DECL|function|interpret_errors
r_static
r_int
id|interpret_errors
c_func
(paren
r_void
)paren
(brace
r_char
id|bad
suffix:semicolon
r_if
c_cond
(paren
id|inr
op_ne
l_int|7
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;-- FDC reply error&quot;
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* check IC to find cause of interrupt */
r_switch
c_cond
(paren
id|ST0
op_amp
id|ST0_INTR
)paren
(brace
r_case
l_int|0x40
suffix:colon
multiline_comment|/* error occurred during command execution */
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_EOC
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* occurs with pseudo-DMA */
id|bad
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_WP
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;Drive is write protected&bslash;n&quot;
)paren
suffix:semicolon
id|CLEARF
c_func
(paren
id|FD_DISK_WRITABLE
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|bad
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_ND
)paren
(brace
id|SETF
c_func
(paren
id|FD_NEED_TWADDLE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_OR
)paren
(brace
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FTD_MSG
)paren
id|DPRINT
c_func
(paren
l_string|&quot;Over/Underrun - retrying&bslash;n&quot;
)paren
suffix:semicolon
id|bad
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|errors
op_ge
id|DP-&gt;max_errors.reporting
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ST0
op_amp
id|ST0_ECE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Recalibrate failed!&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_CRC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;data CRC error&quot;
)paren
suffix:semicolon
id|tell_sector
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_CRC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CRC error&quot;
)paren
suffix:semicolon
id|tell_sector
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ST1
op_amp
(paren
id|ST1_MAM
op_or
id|ST1_ND
)paren
)paren
op_logical_or
(paren
id|ST2
op_amp
id|ST2_MAM
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|probing
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sector not found&quot;
)paren
suffix:semicolon
id|tell_sector
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;probe failed...&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_WC
)paren
(brace
multiline_comment|/* seek error */
id|printk
c_func
(paren
l_string|&quot;wrong cylinder&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_BC
)paren
(brace
multiline_comment|/* cylinder marked as bad */
id|printk
c_func
(paren
l_string|&quot;bad cylinder&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;unknown error. ST[0..2] are: 0x%x 0x%x 0x%x&quot;
comma
id|ST0
comma
id|ST1
comma
id|ST2
)paren
suffix:semicolon
id|tell_sector
c_func
(paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_WC
op_logical_or
id|ST2
op_amp
id|ST2_BC
)paren
multiline_comment|/* wrong cylinder =&gt; recal */
id|DRS-&gt;track
op_assign
id|NEED_2_RECAL
suffix:semicolon
r_return
id|bad
suffix:semicolon
r_case
l_int|0x80
suffix:colon
multiline_comment|/* invalid command given */
id|DPRINT
c_func
(paren
l_string|&quot;Invalid FDC command given!&bslash;n&quot;
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
r_case
l_int|0xc0
suffix:colon
id|DPRINT
c_func
(paren
l_string|&quot;Abnormal termination caused by polling&bslash;n&quot;
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* (0) Normal command termination */
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This routine is called when everything should be correctly set up&n; * for the transfer (i.e. floppy motor is on, the correct floppy is&n; * selected, and the head is sitting on the right track).&n; */
DECL|function|setup_rw_floppy
r_static
r_void
id|setup_rw_floppy
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|r
comma
id|flags
comma
id|dflags
suffix:semicolon
r_int
r_int
id|ready_date
suffix:semicolon
id|timeout_fn
id|function
suffix:semicolon
id|flags
op_assign
id|raw_cmd-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|FD_RAW_READ
op_or
id|FD_RAW_WRITE
)paren
)paren
id|flags
op_or_assign
id|FD_RAW_INTR
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|FD_RAW_SPIN
)paren
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|FD_RAW_NO_MOTOR
)paren
)paren
(brace
id|ready_date
op_assign
id|DRS-&gt;spinup_date
op_plus
id|DP-&gt;spinup
suffix:semicolon
multiline_comment|/* If spinup will take a long time, rerun scandrives&n;&t;&t; * again just before spinup completion. Beware that&n;&t;&t; * after scandrives, we must again wait for selection.&n;&t;&t; */
r_if
c_cond
(paren
(paren
r_int
)paren
(paren
id|ready_date
op_minus
id|jiffies
)paren
OG
id|DP-&gt;select_delay
)paren
(brace
id|ready_date
op_sub_assign
id|DP-&gt;select_delay
suffix:semicolon
id|function
op_assign
(paren
id|timeout_fn
)paren
id|floppy_start
suffix:semicolon
)brace
r_else
id|function
op_assign
(paren
id|timeout_fn
)paren
id|setup_rw_floppy
suffix:semicolon
multiline_comment|/* wait until the floppy is spinning fast enough */
r_if
c_cond
(paren
id|wait_for_completion
c_func
(paren
id|ready_date
comma
id|function
)paren
)paren
r_return
suffix:semicolon
)brace
id|dflags
op_assign
id|DRS-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|FD_RAW_READ
)paren
op_logical_or
(paren
id|flags
op_amp
id|FD_RAW_WRITE
)paren
)paren
id|setup_DMA
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|FD_RAW_INTR
)paren
id|SET_INTR
c_func
(paren
id|main_command_interrupt
)paren
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|raw_cmd-&gt;cmd_count
suffix:semicolon
id|i
op_increment
)paren
id|r
op_or_assign
id|output_byte
c_func
(paren
id|raw_cmd-&gt;cmd
(braket
id|i
)braket
)paren
suffix:semicolon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;rw_command: &quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|r
)paren
(brace
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|reset_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|FD_RAW_INTR
)paren
)paren
(brace
id|inr
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|interrupt
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|FD_RAW_NEED_DISK
)paren
id|fd_watchdog
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|blind_seek
r_static
r_int
id|blind_seek
suffix:semicolon
multiline_comment|/*&n; * This is the routine called after every seek (or recalibrate) interrupt&n; * from the floppy controller.&n; */
DECL|function|seek_interrupt
r_static
r_void
id|seek_interrupt
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;seek interrupt:&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|inr
op_ne
l_int|2
op_logical_or
(paren
id|ST0
op_amp
l_int|0xF8
)paren
op_ne
l_int|0x20
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;seek failed&bslash;n&quot;
)paren
suffix:semicolon
id|DRS-&gt;track
op_assign
id|NEED_2_RECAL
suffix:semicolon
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DRS-&gt;track
op_ge
l_int|0
op_logical_and
id|DRS-&gt;track
op_ne
id|ST1
op_logical_and
op_logical_neg
id|blind_seek
)paren
(brace
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;clearing NEWCHANGE flag because of effective seek&bslash;n&quot;
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;jiffies=%lu&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
)brace
macro_line|#endif
id|CLEARF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
suffix:semicolon
multiline_comment|/* effective seek */
id|DRS-&gt;select_date
op_assign
id|jiffies
suffix:semicolon
)brace
id|DRS-&gt;track
op_assign
id|ST1
suffix:semicolon
id|floppy_ready
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|check_wp
r_static
r_void
id|check_wp
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|TESTF
c_func
(paren
id|FD_VERIFY
)paren
)paren
(brace
multiline_comment|/* check write protection */
id|output_byte
c_func
(paren
id|FD_GETSTATUS
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
c_func
(paren
)paren
op_ne
l_int|1
)paren
(brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|CLEARF
c_func
(paren
id|FD_VERIFY
)paren
suffix:semicolon
id|CLEARF
c_func
(paren
id|FD_NEED_TWADDLE
)paren
suffix:semicolon
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;checking whether disk is write protected&bslash;n&quot;
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;wp=%x&bslash;n&quot;
comma
id|ST3
op_amp
l_int|0x40
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|ST3
op_amp
l_int|0x40
)paren
)paren
id|SETF
c_func
(paren
id|FD_DISK_WRITABLE
)paren
suffix:semicolon
r_else
id|CLEARF
c_func
(paren
id|FD_DISK_WRITABLE
)paren
suffix:semicolon
)brace
)brace
DECL|function|seek_floppy
r_static
r_void
id|seek_floppy
c_func
(paren
r_void
)paren
(brace
r_int
id|track
suffix:semicolon
id|blind_seek
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;calling disk change from seek&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|TESTF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
op_logical_and
id|disk_change
c_func
(paren
id|current_drive
)paren
op_logical_and
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_NEED_DISK
)paren
)paren
(brace
multiline_comment|/* the media changed flag should be cleared after the seek.&n;&t;&t; * If it isn&squot;t, this means that there is really no disk in&n;&t;&t; * the drive.&n;&t;&t; */
id|SETF
c_func
(paren
id|FD_DISK_CHANGED
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DRS-&gt;track
op_le
id|NEED_1_RECAL
)paren
(brace
id|recalibrate_floppy
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|TESTF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
op_logical_and
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_NEED_DISK
)paren
op_logical_and
(paren
id|DRS-&gt;track
op_le
id|NO_TRACK
op_logical_or
id|DRS-&gt;track
op_eq
id|raw_cmd-&gt;track
)paren
)paren
(brace
multiline_comment|/* we seek to clear the media-changed condition. Does anybody&n;&t;&t; * know a more elegant way, which works on all drives? */
r_if
c_cond
(paren
id|raw_cmd-&gt;track
)paren
id|track
op_assign
id|raw_cmd-&gt;track
op_minus
l_int|1
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_SILENT_DCL_CLEAR
)paren
(brace
id|set_dor
c_func
(paren
id|fdc
comma
op_complement
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
id|blind_seek
op_assign
l_int|1
suffix:semicolon
id|raw_cmd-&gt;flags
op_or_assign
id|FD_RAW_NEED_SEEK
suffix:semicolon
)brace
id|track
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|check_wp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd-&gt;track
op_ne
id|DRS-&gt;track
op_logical_and
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_NEED_SEEK
)paren
)paren
id|track
op_assign
id|raw_cmd-&gt;track
suffix:semicolon
r_else
(brace
id|setup_rw_floppy
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|SET_INTR
c_func
(paren
id|seek_interrupt
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_SEEK
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
id|LAST_OUT
c_func
(paren
id|track
)paren
suffix:semicolon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;seek command:&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|recal_interrupt
r_static
r_void
id|recal_interrupt
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;recal interrupt:&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|inr
op_ne
l_int|2
)paren
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ST0
op_amp
id|ST0_ECE
)paren
(brace
r_switch
c_cond
(paren
id|DRS-&gt;track
)paren
(brace
r_case
id|NEED_1_RECAL
suffix:colon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;recal interrupt need 1 recal:&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* after a second recalibrate, we still haven&squot;t&n;&t;&t;&t;&t; * reached track 0. Probably no drive. Raise an&n;&t;&t;&t;&t; * error, as failing immediately might upset&n;&t;&t;&t;&t; * computers possessed by the Devil :-) */
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NEED_2_RECAL
suffix:colon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;recal interrupt need 2 recal:&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If we already did a recalibrate,&n;&t;&t;&t;&t; * and we are not at track 0, this&n;&t;&t;&t;&t; * means we have moved. (The only way&n;&t;&t;&t;&t; * not to move at recalibration is to&n;&t;&t;&t;&t; * be already at track 0.) Clear the&n;&t;&t;&t;&t; * new change flag */
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;clearing NEWCHANGE flag because of second recalibrate&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|CLEARF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
suffix:semicolon
id|DRS-&gt;select_date
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* fall through */
r_default
suffix:colon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;recal interrupt default:&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Recalibrate moves the head by at&n;&t;&t;&t;&t; * most 80 steps. If after one&n;&t;&t;&t;&t; * recalibrate we don&squot;t have reached&n;&t;&t;&t;&t; * track 0, this might mean that we&n;&t;&t;&t;&t; * started beyond track 80.  Try&n;&t;&t;&t;&t; * again.  */
id|DRS-&gt;track
op_assign
id|NEED_1_RECAL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
id|DRS-&gt;track
op_assign
id|ST1
suffix:semicolon
id|floppy_ready
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|print_result
r_static
r_void
id|print_result
c_func
(paren
r_char
op_star
id|message
comma
r_int
id|inr
)paren
(brace
r_int
id|i
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;%s &quot;
comma
id|message
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inr
op_ge
l_int|0
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|inr
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;repl[%d]=%x &quot;
comma
id|i
comma
id|reply_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* interrupt handler. Note that this can be called externally on the Sparc */
DECL|function|floppy_interrupt
r_void
id|floppy_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
)paren
op_assign
id|DEVICE_INTR
suffix:semicolon
r_int
id|do_print
suffix:semicolon
r_int
r_int
id|f
suffix:semicolon
id|lasthandler
op_assign
id|handler
suffix:semicolon
id|interruptjiffies
op_assign
id|jiffies
suffix:semicolon
id|f
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|fd_disable_dma
c_func
(paren
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|f
)paren
suffix:semicolon
id|floppy_enable_hlt
c_func
(paren
)paren
suffix:semicolon
id|CLEAR_INTR
suffix:semicolon
r_if
c_cond
(paren
id|fdc
op_ge
id|N_FDC
op_logical_or
id|FDCS-&gt;address
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* we don&squot;t even know which FDC is the culprit */
id|printk
c_func
(paren
l_string|&quot;DOR0=%x&bslash;n&quot;
comma
id|fdc_state
(braket
l_int|0
)braket
dot
id|dor
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;floppy interrupt on bizarre fdc %d&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;handler=%p&bslash;n&quot;
comma
id|handler
)paren
suffix:semicolon
id|is_alive
c_func
(paren
l_string|&quot;bizarre fdc&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|FDCS-&gt;reset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* We have to clear the reset flag here, because apparently on boxes&n;&t; * with level triggered interrupts (PS/2, Sparc, ...), it is needed to&n;&t; * emit SENSEI&squot;s to clear the interrupt line. And FDCS-&gt;reset blocks the&n;&t; * emission of the SENSEI&squot;s.&n;&t; * It is OK to emit floppy commands because we are in an interrupt&n;&t; * handler here, and thus we have to fear no interference of other&n;&t; * activity.&n;&t; */
id|do_print
op_assign
op_logical_neg
id|handler
op_logical_and
id|print_unex
op_logical_and
op_logical_neg
id|initialising
suffix:semicolon
id|inr
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_print
)paren
id|print_result
c_func
(paren
l_string|&quot;unexpected interrupt&quot;
comma
id|inr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inr
op_eq
l_int|0
)paren
(brace
r_int
id|max_sensei
op_assign
l_int|4
suffix:semicolon
r_do
(brace
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
id|inr
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|do_print
)paren
id|print_result
c_func
(paren
l_string|&quot;sensei&quot;
comma
id|inr
)paren
suffix:semicolon
id|max_sensei
op_decrement
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|ST0
op_amp
l_int|0x83
)paren
op_ne
id|UNIT
c_func
(paren
id|current_drive
)paren
op_logical_and
id|inr
op_eq
l_int|2
op_logical_and
id|max_sensei
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|handler
)paren
(brace
id|schedule_bh
c_func
(paren
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|handler
)paren
suffix:semicolon
)brace
r_else
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
id|is_alive
c_func
(paren
l_string|&quot;normal interrupt end&quot;
)paren
suffix:semicolon
)brace
DECL|function|recalibrate_floppy
r_static
r_void
id|recalibrate_floppy
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;recalibrate floppy:&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SET_INTR
c_func
(paren
id|recal_interrupt
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_RECALIBRATE
)paren
suffix:semicolon
id|LAST_OUT
c_func
(paren
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Must do 4 FD_SENSEIs after reset because of ``drive polling&squot;&squot;.&n; */
DECL|function|reset_interrupt
r_static
r_void
id|reset_interrupt
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;reset interrupt:&quot;
)paren
suffix:semicolon
macro_line|#endif
id|result
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* get the status ready for set_fdc */
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;reset set in interrupt, calling %p&bslash;n&quot;
comma
id|cont-&gt;error
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* a reset just after a reset. BAD! */
)brace
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * reset is done by pulling bit 2 of DOR low for a while (old FDCs),&n; * or by setting the self clearing bit 7 of STATUS (newer FDCs)&n; */
DECL|function|reset_fdc
r_static
r_void
id|reset_fdc
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|SET_INTR
c_func
(paren
id|reset_interrupt
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|0
suffix:semicolon
id|reset_fdc_info
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Pseudo-DMA may intercept &squot;reset finished&squot; interrupt.  */
multiline_comment|/* Irrelevant for systems with true DMA (i386).          */
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|fd_disable_dma
c_func
(paren
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;version
op_ge
id|FDC_82072A
)paren
id|fd_outb
c_func
(paren
l_int|0x80
op_or
(paren
id|FDCS-&gt;dtr
op_amp
l_int|3
)paren
comma
id|FD_STATUS
)paren
suffix:semicolon
r_else
(brace
id|fd_outb
c_func
(paren
id|FDCS-&gt;dor
op_amp
op_complement
l_int|0x04
comma
id|FD_DOR
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|FD_RESET_DELAY
)paren
suffix:semicolon
id|fd_outb
c_func
(paren
id|FDCS-&gt;dor
comma
id|FD_DOR
)paren
suffix:semicolon
)brace
)brace
DECL|function|show_floppy
r_static
r_void
id|show_floppy
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;floppy driver state&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;-------------------&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;now=%lu last interrupt=%lu diff=%lu last called handler=%p&bslash;n&quot;
comma
id|jiffies
comma
id|interruptjiffies
comma
id|jiffies
op_minus
id|interruptjiffies
comma
id|lasthandler
)paren
suffix:semicolon
macro_line|#ifdef FLOPPY_SANITY_CHECK
id|printk
c_func
(paren
l_string|&quot;timeout_message=%s&bslash;n&quot;
comma
id|timeout_message
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;last output bytes:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|OLOGSIZE
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;%2x %2x %lu&bslash;n&quot;
comma
id|output_log
(braket
(paren
id|i
op_plus
id|output_log_pos
)paren
op_mod
id|OLOGSIZE
)braket
dot
id|data
comma
id|output_log
(braket
(paren
id|i
op_plus
id|output_log_pos
)paren
op_mod
id|OLOGSIZE
)braket
dot
id|status
comma
id|output_log
(braket
(paren
id|i
op_plus
id|output_log_pos
)paren
op_mod
id|OLOGSIZE
)braket
dot
id|jiffies
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;last result at %lu&bslash;n&quot;
comma
id|resultjiffies
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;last redo_fd_request at %lu&bslash;n&quot;
comma
id|lastredo
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|resultsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2x &quot;
comma
id|reply_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;status=%x&bslash;n&quot;
comma
id|fd_inb
c_func
(paren
id|FD_STATUS
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fdc_busy=%lu&bslash;n&quot;
comma
id|fdc_busy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEVICE_INTR
)paren
id|printk
c_func
(paren
l_string|&quot;DEVICE_INTR=%p&bslash;n&quot;
comma
id|DEVICE_INTR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|floppy_tq.sync
)paren
id|printk
c_func
(paren
l_string|&quot;floppy_tq.routine=%p&bslash;n&quot;
comma
id|floppy_tq.routine
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|fd_timer
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;fd_timer.function=%p&bslash;n&quot;
comma
id|fd_timer.function
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|fd_timeout
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;timer_function=%p&bslash;n&quot;
comma
id|fd_timeout.function
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;expires=%lu&bslash;n&quot;
comma
id|fd_timeout.expires
op_minus
id|jiffies
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;now=%lu&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;cont=%p&bslash;n&quot;
comma
id|cont
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CURRENT=%p&bslash;n&quot;
comma
id|CURRENT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;command_status=%d&bslash;n&quot;
comma
id|command_status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|floppy_shutdown
r_static
r_void
id|floppy_shutdown
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initialising
)paren
id|show_floppy
c_func
(paren
)paren
suffix:semicolon
id|cancel_activity
c_func
(paren
)paren
suffix:semicolon
id|floppy_enable_hlt
c_func
(paren
)paren
suffix:semicolon
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|fd_disable_dma
c_func
(paren
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* avoid dma going to a random drive after shutdown */
r_if
c_cond
(paren
op_logical_neg
id|initialising
)paren
id|DPRINT
c_func
(paren
l_string|&quot;floppy timeout called&bslash;n&quot;
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cont
)paren
(brace
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* this will recall reset when needed */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;no cont in shutdown!&bslash;n&quot;
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
id|is_alive
c_func
(paren
l_string|&quot;floppy shutdown&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*typedef void (*timeout_fn)(unsigned long);*/
multiline_comment|/* start motor, check media-changed condition and write protection */
DECL|function|start_motor
r_static
r_int
id|start_motor
c_func
(paren
r_void
(paren
op_star
id|function
)paren
(paren
r_void
)paren
)paren
(brace
r_int
id|mask
comma
id|data
suffix:semicolon
id|mask
op_assign
l_int|0xfc
suffix:semicolon
id|data
op_assign
id|UNIT
c_func
(paren
id|current_drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_NO_MOTOR
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|FDCS-&gt;dor
op_amp
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
)paren
)paren
(brace
id|set_debugt
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* no read since this drive is running */
id|DRS-&gt;first_read_date
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* note motor start time if motor is not yet running */
id|DRS-&gt;spinup_date
op_assign
id|jiffies
suffix:semicolon
id|data
op_or_assign
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|FDCS-&gt;dor
op_amp
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
)paren
id|mask
op_and_assign
op_complement
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
multiline_comment|/* starts motor and selects floppy */
id|del_timer
c_func
(paren
id|motor_off_timer
op_plus
id|current_drive
)paren
suffix:semicolon
id|set_dor
c_func
(paren
id|fdc
comma
id|mask
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* wait_for_completion also schedules reset if needed. */
r_return
id|wait_for_completion
c_func
(paren
id|DRS-&gt;select_date
op_plus
id|DP-&gt;select_delay
comma
(paren
id|timeout_fn
)paren
id|function
)paren
suffix:semicolon
)brace
DECL|function|floppy_ready
r_static
r_void
id|floppy_ready
c_func
(paren
r_void
)paren
(brace
id|CHECK_RESET
suffix:semicolon
r_if
c_cond
(paren
id|start_motor
c_func
(paren
id|floppy_ready
)paren
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|fdc_dtr
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;calling disk change from floppy_ready&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_NO_MOTOR
)paren
op_logical_and
id|disk_change
c_func
(paren
id|current_drive
)paren
op_logical_and
op_logical_neg
id|DP-&gt;select_delay
)paren
id|twaddle
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* this clears the dcl on certain drive/controller&n;&t;&t;&t;    * combinations */
macro_line|#ifdef fd_chose_dma_mode
r_if
c_cond
(paren
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_READ
)paren
op_logical_or
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_WRITE
)paren
)paren
(brace
r_int
r_int
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|fd_chose_dma_mode
c_func
(paren
id|raw_cmd-&gt;kernel_data
comma
id|raw_cmd-&gt;length
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|raw_cmd-&gt;flags
op_amp
(paren
id|FD_RAW_NEED_SEEK
op_or
id|FD_RAW_NEED_DISK
)paren
)paren
(brace
id|perpendicular_mode
c_func
(paren
)paren
suffix:semicolon
id|fdc_specify
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* must be done here because of hut, hlt ... */
id|seek_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_READ
)paren
op_logical_or
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_WRITE
)paren
)paren
id|fdc_specify
c_func
(paren
)paren
suffix:semicolon
id|setup_rw_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|function|floppy_start
r_static
r_void
id|floppy_start
c_func
(paren
r_void
)paren
(brace
id|reschedule_timeout
c_func
(paren
id|CURRENTD
comma
l_string|&quot;floppy start&quot;
comma
l_int|0
)paren
suffix:semicolon
id|scandrives
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;setting NEWCHANGE in floppy_start&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|SETF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
suffix:semicolon
id|floppy_ready
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ========================================================================&n; * here ends the bottom half. Exported routines are:&n; * floppy_start, floppy_off, floppy_ready, lock_fdc, unlock_fdc, set_fdc,&n; * start_motor, reset_fdc, reset_fdc_info, interpret_errors.&n; * Initialization also uses output_byte, result, set_dor, floppy_interrupt&n; * and set_dor.&n; * ========================================================================&n; */
multiline_comment|/*&n; * General purpose continuations.&n; * ==============================&n; */
DECL|function|do_wakeup
r_static
r_void
id|do_wakeup
c_func
(paren
r_void
)paren
(brace
id|reschedule_timeout
c_func
(paren
id|MAXTIMEOUT
comma
l_string|&quot;do wakeup&quot;
comma
l_int|0
)paren
suffix:semicolon
id|cont
op_assign
l_int|0
suffix:semicolon
id|command_status
op_add_assign
l_int|2
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|command_done
)paren
suffix:semicolon
)brace
DECL|variable|wakeup_cont
r_static
r_struct
id|cont_t
id|wakeup_cont
op_assign
initialization_block
suffix:semicolon
DECL|variable|intr_cont
r_static
r_struct
id|cont_t
id|intr_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|wait_til_done
r_static
r_int
id|wait_til_done
c_func
(paren
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
)paren
comma
r_int
id|interruptible
)paren
(brace
r_int
id|ret
suffix:semicolon
id|schedule_bh
c_func
(paren
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|handler
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command_status
OL
l_int|2
op_logical_and
id|NO_SIGNAL
)paren
(brace
id|DECLARE_WAITQUEUE
c_func
(paren
id|wait
comma
id|current
)paren
suffix:semicolon
id|add_wait_queue
c_func
(paren
op_amp
id|command_done
comma
op_amp
id|wait
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|set_current_state
c_func
(paren
id|interruptible
ques
c_cond
id|TASK_INTERRUPTIBLE
suffix:colon
id|TASK_UNINTERRUPTIBLE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command_status
op_ge
l_int|2
op_logical_or
op_logical_neg
id|NO_SIGNAL
)paren
r_break
suffix:semicolon
id|is_alive
c_func
(paren
l_string|&quot;wait_til_done&quot;
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
id|set_current_state
c_func
(paren
id|TASK_RUNNING
)paren
suffix:semicolon
id|remove_wait_queue
c_func
(paren
op_amp
id|command_done
comma
op_amp
id|wait
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|command_status
OL
l_int|2
)paren
(brace
id|cancel_activity
c_func
(paren
)paren
suffix:semicolon
id|cont
op_assign
op_amp
id|intr_cont
suffix:semicolon
id|reset_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
id|command_status
op_assign
id|FD_COMMAND_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|command_status
op_eq
id|FD_COMMAND_OKAY
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
r_else
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|command_status
op_assign
id|FD_COMMAND_NONE
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|generic_done
r_static
r_void
id|generic_done
c_func
(paren
r_int
id|result
)paren
(brace
id|command_status
op_assign
id|result
suffix:semicolon
id|cont
op_assign
op_amp
id|wakeup_cont
suffix:semicolon
)brace
DECL|function|generic_success
r_static
r_void
id|generic_success
c_func
(paren
r_void
)paren
(brace
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|generic_failure
r_static
r_void
id|generic_failure
c_func
(paren
r_void
)paren
(brace
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|success_and_wakeup
r_static
r_void
id|success_and_wakeup
c_func
(paren
r_void
)paren
(brace
id|generic_success
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * formatting and rw support.&n; * ==========================&n; */
DECL|function|next_valid_format
r_static
r_int
id|next_valid_format
c_func
(paren
r_void
)paren
(brace
r_int
id|probed_format
suffix:semicolon
id|probed_format
op_assign
id|DRS-&gt;probed_format
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|probed_format
op_ge
l_int|8
op_logical_or
op_logical_neg
id|DP-&gt;autodetect
(braket
id|probed_format
)braket
)paren
(brace
id|DRS-&gt;probed_format
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|floppy_type
(braket
id|DP-&gt;autodetect
(braket
id|probed_format
)braket
)braket
dot
id|sect
)paren
(brace
id|DRS-&gt;probed_format
op_assign
id|probed_format
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|probed_format
op_increment
suffix:semicolon
)brace
)brace
DECL|function|bad_flp_intr
r_static
r_void
id|bad_flp_intr
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|probing
)paren
(brace
id|DRS-&gt;probed_format
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|next_valid_format
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
)brace
(paren
op_star
id|errors
)paren
op_increment
suffix:semicolon
id|INFBOUND
c_func
(paren
id|DRWE-&gt;badness
comma
op_star
id|errors
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|errors
OG
id|DP-&gt;max_errors
dot
m_abort
)paren
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|errors
OG
id|DP-&gt;max_errors.reset
)paren
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|errors
OG
id|DP-&gt;max_errors.recal
)paren
id|DRS-&gt;track
op_assign
id|NEED_2_RECAL
suffix:semicolon
)brace
DECL|function|set_floppy
r_static
r_void
id|set_floppy
c_func
(paren
id|kdev_t
id|device
)paren
(brace
r_if
c_cond
(paren
id|TYPE
c_func
(paren
id|device
)paren
)paren
id|_floppy
op_assign
id|TYPE
c_func
(paren
id|device
)paren
op_plus
id|floppy_type
suffix:semicolon
r_else
id|_floppy
op_assign
id|current_type
(braket
id|DRIVE
c_func
(paren
id|device
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * formatting support.&n; * ===================&n; */
DECL|function|format_interrupt
r_static
r_void
id|format_interrupt
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|interpret_errors
c_func
(paren
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
r_case
l_int|2
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|macro|CODE2SIZE
mdefine_line|#define CODE2SIZE (ssize = ((1 &lt;&lt; SIZECODE) + 3) &gt;&gt; 2)
DECL|macro|FM_MODE
mdefine_line|#define FM_MODE(x,y) ((y) &amp; ~(((x)-&gt;rate &amp; 0x80) &gt;&gt;1))
DECL|macro|CT
mdefine_line|#define CT(x) ((x) | 0xc0)
DECL|function|setup_format_params
r_static
r_void
id|setup_format_params
c_func
(paren
r_int
id|track
)paren
(brace
r_struct
id|fparm
(brace
r_int
r_char
id|track
comma
id|head
comma
id|sect
comma
id|size
suffix:semicolon
)brace
op_star
id|here
op_assign
(paren
r_struct
id|fparm
op_star
)paren
id|floppy_track_buffer
suffix:semicolon
r_int
id|il
comma
id|n
suffix:semicolon
r_int
id|count
comma
id|head_shift
comma
id|track_shift
suffix:semicolon
id|raw_cmd
op_assign
op_amp
id|default_raw_cmd
suffix:semicolon
id|raw_cmd-&gt;track
op_assign
id|track
suffix:semicolon
id|raw_cmd-&gt;flags
op_assign
id|FD_RAW_WRITE
op_or
id|FD_RAW_INTR
op_or
id|FD_RAW_SPIN
op_or
id|FD_RAW_NEED_DISK
op_or
id|FD_RAW_NEED_SEEK
suffix:semicolon
id|raw_cmd-&gt;rate
op_assign
id|_floppy-&gt;rate
op_amp
l_int|0x43
suffix:semicolon
id|raw_cmd-&gt;cmd_count
op_assign
id|NR_F
suffix:semicolon
id|COMMAND
op_assign
id|FM_MODE
c_func
(paren
id|_floppy
comma
id|FD_FORMAT
)paren
suffix:semicolon
id|DR_SELECT
op_assign
id|UNIT
c_func
(paren
id|current_drive
)paren
op_plus
id|PH_HEAD
c_func
(paren
id|_floppy
comma
id|format_req.head
)paren
suffix:semicolon
id|F_SIZECODE
op_assign
id|FD_SIZECODE
c_func
(paren
id|_floppy
)paren
suffix:semicolon
id|F_SECT_PER_TRACK
op_assign
id|_floppy-&gt;sect
op_lshift
l_int|2
op_rshift
id|F_SIZECODE
suffix:semicolon
id|F_GAP
op_assign
id|_floppy-&gt;fmt_gap
suffix:semicolon
id|F_FILL
op_assign
id|FD_FILL_BYTE
suffix:semicolon
id|raw_cmd-&gt;kernel_data
op_assign
id|floppy_track_buffer
suffix:semicolon
id|raw_cmd-&gt;length
op_assign
l_int|4
op_star
id|F_SECT_PER_TRACK
suffix:semicolon
multiline_comment|/* allow for about 30ms for data transport per track */
id|head_shift
op_assign
(paren
id|F_SECT_PER_TRACK
op_plus
l_int|5
)paren
op_div
l_int|6
suffix:semicolon
multiline_comment|/* a ``cylinder&squot;&squot; is two tracks plus a little stepping time */
id|track_shift
op_assign
l_int|2
op_star
id|head_shift
op_plus
l_int|3
suffix:semicolon
multiline_comment|/* position of logical sector 1 on this track */
id|n
op_assign
(paren
id|track_shift
op_star
id|format_req.track
op_plus
id|head_shift
op_star
id|format_req.head
)paren
op_mod
id|F_SECT_PER_TRACK
suffix:semicolon
multiline_comment|/* determine interleave */
id|il
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|_floppy-&gt;fmt_gap
OL
l_int|0x22
)paren
id|il
op_increment
suffix:semicolon
multiline_comment|/* initialize field */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|F_SECT_PER_TRACK
suffix:semicolon
op_increment
id|count
)paren
(brace
id|here
(braket
id|count
)braket
dot
id|track
op_assign
id|format_req.track
suffix:semicolon
id|here
(braket
id|count
)braket
dot
id|head
op_assign
id|format_req.head
suffix:semicolon
id|here
(braket
id|count
)braket
dot
id|sect
op_assign
l_int|0
suffix:semicolon
id|here
(braket
id|count
)braket
dot
id|size
op_assign
id|F_SIZECODE
suffix:semicolon
)brace
multiline_comment|/* place logical sectors */
r_for
c_loop
(paren
id|count
op_assign
l_int|1
suffix:semicolon
id|count
op_le
id|F_SECT_PER_TRACK
suffix:semicolon
op_increment
id|count
)paren
(brace
id|here
(braket
id|n
)braket
dot
id|sect
op_assign
id|count
suffix:semicolon
id|n
op_assign
(paren
id|n
op_plus
id|il
)paren
op_mod
id|F_SECT_PER_TRACK
suffix:semicolon
r_if
c_cond
(paren
id|here
(braket
id|n
)braket
dot
id|sect
)paren
(brace
multiline_comment|/* sector busy, find next free sector */
op_increment
id|n
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ge
id|F_SECT_PER_TRACK
)paren
(brace
id|n
op_sub_assign
id|F_SECT_PER_TRACK
suffix:semicolon
r_while
c_loop
(paren
id|here
(braket
id|n
)braket
dot
id|sect
)paren
op_increment
id|n
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|redo_format
r_static
r_void
id|redo_format
c_func
(paren
r_void
)paren
(brace
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|setup_format_params
c_func
(paren
id|format_req.track
op_lshift
id|STRETCH
c_func
(paren
id|_floppy
)paren
)paren
suffix:semicolon
id|floppy_start
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;queue format request&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|format_cont
r_static
r_struct
id|cont_t
id|format_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|do_format
r_static
r_int
id|do_format
c_func
(paren
id|kdev_t
id|device
comma
r_struct
id|format_descr
op_star
id|tmp_format_req
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|drive
op_assign
id|DRIVE
c_func
(paren
id|device
)paren
suffix:semicolon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
id|set_floppy
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|_floppy
op_logical_or
id|_floppy-&gt;track
OG
id|DP-&gt;tracks
op_logical_or
id|tmp_format_req-&gt;track
op_ge
id|_floppy-&gt;track
op_logical_or
id|tmp_format_req-&gt;head
op_ge
id|_floppy-&gt;head
op_logical_or
(paren
id|_floppy-&gt;sect
op_lshift
l_int|2
)paren
op_mod
(paren
l_int|1
op_lshift
id|FD_SIZECODE
c_func
(paren
id|_floppy
)paren
)paren
op_logical_or
op_logical_neg
id|_floppy-&gt;fmt_gap
)paren
(brace
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|format_req
op_assign
op_star
id|tmp_format_req
suffix:semicolon
id|format_errors
op_assign
l_int|0
suffix:semicolon
id|cont
op_assign
op_amp
id|format_cont
suffix:semicolon
id|errors
op_assign
op_amp
id|format_errors
suffix:semicolon
id|IWAIT
c_func
(paren
id|redo_format
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Buffer read/write and support&n; * =============================&n; */
multiline_comment|/* new request_done. Can handle physical sectors which are smaller than a&n; * logical buffer */
DECL|function|request_done
r_static
r_void
id|request_done
c_func
(paren
r_int
id|uptodate
)paren
(brace
r_int
id|block
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|probing
op_assign
l_int|0
suffix:semicolon
id|reschedule_timeout
c_func
(paren
id|MAXTIMEOUT
comma
l_string|&quot;request done %d&quot;
comma
id|uptodate
)paren
suffix:semicolon
r_if
c_cond
(paren
id|QUEUE_EMPTY
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;request list destroyed in floppy request done&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uptodate
)paren
(brace
multiline_comment|/* maintain values for invalidation on geometry&n;&t;&t; * change */
id|block
op_assign
id|current_count_sectors
op_plus
id|CURRENT-&gt;sector
suffix:semicolon
id|INFBOUND
c_func
(paren
id|DRS-&gt;maxblock
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
OG
id|_floppy-&gt;sect
)paren
id|DRS-&gt;maxtrack
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* unlock chained buffers */
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_while
c_loop
(paren
id|current_count_sectors
op_logical_and
op_logical_neg
id|QUEUE_EMPTY
op_logical_and
id|current_count_sectors
op_ge
id|CURRENT-&gt;current_nr_sectors
)paren
(brace
id|current_count_sectors
op_sub_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_count_sectors
op_logical_and
op_logical_neg
id|QUEUE_EMPTY
)paren
(brace
multiline_comment|/* &quot;unlock&quot; last subsector */
id|CURRENT-&gt;buffer
op_add_assign
id|current_count_sectors
op_lshift
l_int|9
suffix:semicolon
id|CURRENT-&gt;current_nr_sectors
op_sub_assign
id|current_count_sectors
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|current_count_sectors
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|current_count_sectors
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current_count_sectors
op_logical_and
id|QUEUE_EMPTY
)paren
id|DPRINT
c_func
(paren
l_string|&quot;request list destroyed in floppy request done&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|WRITE
)paren
(brace
multiline_comment|/* record write error information */
id|DRWE-&gt;write_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|DRWE-&gt;write_errors
op_eq
l_int|1
)paren
(brace
id|DRWE-&gt;first_error_sector
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|DRWE-&gt;first_error_generation
op_assign
id|DRS-&gt;generation
suffix:semicolon
)brace
id|DRWE-&gt;last_error_sector
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|DRWE-&gt;last_error_generation
op_assign
id|DRS-&gt;generation
suffix:semicolon
)brace
id|spin_lock_irqsave
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|io_request_lock
comma
id|flags
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Interrupt handler evaluating the result of the r/w operation */
DECL|function|rw_interrupt
r_static
r_void
id|rw_interrupt
c_func
(paren
r_void
)paren
(brace
r_int
id|nr_sectors
comma
id|ssize
comma
id|eoc
comma
id|heads
suffix:semicolon
r_if
c_cond
(paren
id|R_HEAD
op_ge
l_int|2
)paren
(brace
multiline_comment|/* some Toshiba floppy controllers occasionnally seem to&n;&t;     * return bogus interrupts after read/write operations, which&n;&t;     * can be recognized by a bad head number (&gt;= 2) */
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|DRS-&gt;first_read_date
)paren
id|DRS-&gt;first_read_date
op_assign
id|jiffies
suffix:semicolon
id|nr_sectors
op_assign
l_int|0
suffix:semicolon
id|CODE2SIZE
suffix:semicolon
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_EOC
)paren
id|eoc
op_assign
l_int|1
suffix:semicolon
r_else
id|eoc
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|COMMAND
op_amp
l_int|0x80
)paren
id|heads
op_assign
l_int|2
suffix:semicolon
r_else
id|heads
op_assign
l_int|1
suffix:semicolon
id|nr_sectors
op_assign
(paren
(paren
(paren
id|R_TRACK
op_minus
id|TRACK
)paren
op_star
id|heads
op_plus
id|R_HEAD
op_minus
id|HEAD
)paren
op_star
id|SECT_PER_TRACK
op_plus
id|R_SECTOR
op_minus
id|SECTOR
op_plus
id|eoc
)paren
op_lshift
id|SIZECODE
op_rshift
l_int|2
suffix:semicolon
macro_line|#ifdef FLOPPY_SANITY_CHECK
r_if
c_cond
(paren
id|nr_sectors
op_div
id|ssize
OG
(paren
id|in_sector_offset
op_plus
id|current_count_sectors
op_plus
id|ssize
op_minus
l_int|1
)paren
op_div
id|ssize
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;long rw: %x instead of %lx&bslash;n&quot;
comma
id|nr_sectors
comma
id|current_count_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rs=%d s=%d&bslash;n&quot;
comma
id|R_SECTOR
comma
id|SECTOR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rh=%d h=%d&bslash;n&quot;
comma
id|R_HEAD
comma
id|HEAD
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rt=%d t=%d&bslash;n&quot;
comma
id|R_TRACK
comma
id|TRACK
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;heads=%d eoc=%d&bslash;n&quot;
comma
id|heads
comma
id|eoc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;spt=%d st=%d ss=%d&bslash;n&quot;
comma
id|SECT_PER_TRACK
comma
id|sector_t
comma
id|ssize
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;in_sector_offset=%d&bslash;n&quot;
comma
id|in_sector_offset
)paren
suffix:semicolon
)brace
macro_line|#endif
id|nr_sectors
op_sub_assign
id|in_sector_offset
suffix:semicolon
id|INFBOUND
c_func
(paren
id|nr_sectors
comma
l_int|0
)paren
suffix:semicolon
id|SUPBOUND
c_func
(paren
id|current_count_sectors
comma
id|nr_sectors
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|interpret_errors
c_func
(paren
)paren
)paren
(brace
r_case
l_int|2
suffix:colon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|current_count_sectors
)paren
(brace
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|current_count_sectors
)paren
(brace
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|current_type
(braket
id|current_drive
)braket
op_assign
id|_floppy
suffix:semicolon
id|floppy_sizes
(braket
id|TOMINOR
c_func
(paren
id|current_drive
)paren
)braket
op_assign
(paren
id|_floppy-&gt;size
op_plus
l_int|1
)paren
op_rshift
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|probing
)paren
(brace
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FTD_MSG
)paren
id|DPRINT
c_func
(paren
l_string|&quot;Auto-detected floppy type %s in fd%d&bslash;n&quot;
comma
id|_floppy-&gt;name
comma
id|current_drive
)paren
suffix:semicolon
id|current_type
(braket
id|current_drive
)braket
op_assign
id|_floppy
suffix:semicolon
id|floppy_sizes
(braket
id|TOMINOR
c_func
(paren
id|current_drive
)paren
)braket
op_assign
(paren
id|_floppy-&gt;size
op_plus
l_int|1
)paren
op_rshift
l_int|1
suffix:semicolon
id|probing
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_ne
id|FD_READ
op_logical_or
id|raw_cmd-&gt;kernel_data
op_eq
id|CURRENT-&gt;buffer
)paren
(brace
multiline_comment|/* transfer directly from buffer */
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
(brace
id|buffer_track
op_assign
id|raw_cmd-&gt;track
suffix:semicolon
id|buffer_drive
op_assign
id|current_drive
suffix:semicolon
id|INFBOUND
c_func
(paren
id|buffer_max
comma
id|nr_sectors
op_plus
id|sector_t
)paren
suffix:semicolon
)brace
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Compute maximal contiguous buffer size. */
DECL|function|buffer_chain_size
r_static
r_int
id|buffer_chain_size
c_func
(paren
r_void
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|size
suffix:semicolon
r_char
op_star
id|base
suffix:semicolon
id|base
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|size
op_assign
id|CURRENT-&gt;current_nr_sectors
op_lshift
l_int|9
suffix:semicolon
id|bh
op_assign
id|CURRENT-&gt;bh
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
r_while
c_loop
(paren
id|bh
op_logical_and
id|bh-&gt;b_data
op_eq
id|base
op_plus
id|size
)paren
(brace
id|size
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
)brace
r_return
id|size
op_rshift
l_int|9
suffix:semicolon
)brace
multiline_comment|/* Compute the maximal transfer size */
DECL|function|transfer_size
r_static
r_int
id|transfer_size
c_func
(paren
r_int
id|ssize
comma
r_int
id|max_sector
comma
r_int
id|max_size
)paren
(brace
id|SUPBOUND
c_func
(paren
id|max_sector
comma
id|sector_t
op_plus
id|max_size
)paren
suffix:semicolon
multiline_comment|/* alignment */
id|max_sector
op_sub_assign
(paren
id|max_sector
op_mod
id|_floppy-&gt;sect
)paren
op_mod
id|ssize
suffix:semicolon
multiline_comment|/* transfer size, beginning not aligned */
id|current_count_sectors
op_assign
id|max_sector
op_minus
id|sector_t
suffix:semicolon
r_return
id|max_sector
suffix:semicolon
)brace
multiline_comment|/*&n; * Move data from/to the track buffer to/from the buffer cache.&n; */
DECL|function|copy_buffer
r_static
r_void
id|copy_buffer
c_func
(paren
r_int
id|ssize
comma
r_int
id|max_sector
comma
r_int
id|max_sector_2
)paren
(brace
r_int
id|remaining
suffix:semicolon
multiline_comment|/* number of transferred 512-byte sectors */
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_char
op_star
id|buffer
comma
op_star
id|dma_buffer
suffix:semicolon
r_int
id|size
suffix:semicolon
id|max_sector
op_assign
id|transfer_size
c_func
(paren
id|ssize
comma
id|minimum
c_func
(paren
id|max_sector
comma
id|max_sector_2
)paren
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_count_sectors
op_le
l_int|0
op_logical_and
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_WRITE
op_logical_and
id|buffer_max
OG
id|sector_t
op_plus
id|CURRENT-&gt;nr_sectors
)paren
id|current_count_sectors
op_assign
id|minimum
c_func
(paren
id|buffer_max
op_minus
id|sector_t
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
id|remaining
op_assign
id|current_count_sectors
op_lshift
l_int|9
suffix:semicolon
macro_line|#ifdef FLOPPY_SANITY_CHECK
r_if
c_cond
(paren
(paren
id|remaining
op_rshift
l_int|9
)paren
OG
id|CURRENT-&gt;nr_sectors
op_logical_and
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_WRITE
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;in copy buffer&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current_count_sectors=%ld&bslash;n&quot;
comma
id|current_count_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;remaining=%d&bslash;n&quot;
comma
id|remaining
op_rshift
l_int|9
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CURRENT-&gt;nr_sectors=%ld&bslash;n&quot;
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CURRENT-&gt;current_nr_sectors=%ld&bslash;n&quot;
comma
id|CURRENT-&gt;current_nr_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;max_sector=%d&bslash;n&quot;
comma
id|max_sector
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ssize=%d&bslash;n&quot;
comma
id|ssize
)paren
suffix:semicolon
)brace
macro_line|#endif
id|buffer_max
op_assign
id|maximum
c_func
(paren
id|max_sector
comma
id|buffer_max
)paren
suffix:semicolon
id|dma_buffer
op_assign
id|floppy_track_buffer
op_plus
(paren
(paren
id|sector_t
op_minus
id|buffer_min
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
id|bh
op_assign
id|CURRENT-&gt;bh
suffix:semicolon
id|size
op_assign
id|CURRENT-&gt;current_nr_sectors
op_lshift
l_int|9
suffix:semicolon
id|buffer
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
r_while
c_loop
(paren
id|remaining
OG
l_int|0
)paren
(brace
id|SUPBOUND
c_func
(paren
id|size
comma
id|remaining
)paren
suffix:semicolon
macro_line|#ifdef FLOPPY_SANITY_CHECK
r_if
c_cond
(paren
id|dma_buffer
op_plus
id|size
OG
id|floppy_track_buffer
op_plus
(paren
id|max_buffer_sectors
op_lshift
l_int|10
)paren
op_logical_or
id|dma_buffer
OL
id|floppy_track_buffer
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;buffer overrun in copy buffer %d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
(paren
id|floppy_track_buffer
op_minus
id|dma_buffer
)paren
op_rshift
l_int|9
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sector_t=%d buffer_min=%d&bslash;n&quot;
comma
id|sector_t
comma
id|buffer_min
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current_count_sectors=%ld&bslash;n&quot;
comma
id|current_count_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
id|printk
c_func
(paren
l_string|&quot;read&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
id|printk
c_func
(paren
l_string|&quot;write&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
op_mod
l_int|512
)paren
id|DPRINT
c_func
(paren
l_string|&quot;%p buffer not aligned&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
id|memcpy
c_func
(paren
id|buffer
comma
id|dma_buffer
comma
id|size
)paren
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|dma_buffer
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
id|remaining
op_sub_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remaining
)paren
r_break
suffix:semicolon
id|dma_buffer
op_add_assign
id|size
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
macro_line|#ifdef FLOPPY_SANITY_CHECK
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;bh=null in copy buffer after copy&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
id|size
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
)brace
macro_line|#ifdef FLOPPY_SANITY_CHECK
r_if
c_cond
(paren
id|remaining
)paren
(brace
r_if
c_cond
(paren
id|remaining
OG
l_int|0
)paren
id|max_sector
op_sub_assign
id|remaining
op_rshift
l_int|9
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;weirdness: remaining %d&bslash;n&quot;
comma
id|remaining
op_rshift
l_int|9
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
macro_line|#if 0
r_static
r_inline
r_int
id|check_dma_crossing
c_func
(paren
r_char
op_star
id|start
comma
r_int
r_int
id|length
comma
r_char
op_star
id|message
)paren
(brace
r_if
c_cond
(paren
id|CROSS_64KB
c_func
(paren
id|start
comma
id|length
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DMA xfer crosses 64KB boundary in %s %p-%p&bslash;n&quot;
comma
id|message
comma
id|start
comma
id|start
op_plus
id|length
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* work around a bug in pseudo DMA&n; * (on some FDCs) pseudo DMA does not stop when the CPU stops&n; * sending data.  Hence we need a different way to signal the&n; * transfer length:  We use SECT_PER_TRACK.  Unfortunately, this&n; * does not work with MT, hence we can only transfer one head at&n; * a time&n; */
DECL|function|virtualdmabug_workaround
r_static
r_void
id|virtualdmabug_workaround
c_func
(paren
r_void
)paren
(brace
r_int
id|hard_sectors
comma
id|end_sector
suffix:semicolon
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_WRITE
)paren
(brace
id|COMMAND
op_and_assign
op_complement
l_int|0x80
suffix:semicolon
multiline_comment|/* switch off multiple track mode */
id|hard_sectors
op_assign
id|raw_cmd-&gt;length
op_rshift
(paren
l_int|7
op_plus
id|SIZECODE
)paren
suffix:semicolon
id|end_sector
op_assign
id|SECTOR
op_plus
id|hard_sectors
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef FLOPPY_SANITY_CHECK
r_if
c_cond
(paren
id|end_sector
OG
id|SECT_PER_TRACK
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;too many sectors %d &gt; %d&bslash;n&quot;
comma
id|end_sector
comma
id|SECT_PER_TRACK
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|SECT_PER_TRACK
op_assign
id|end_sector
suffix:semicolon
multiline_comment|/* make sure SECT_PER_TRACK points&n;&t;&t;&t;&t;&t;      * to end of transfer */
)brace
)brace
multiline_comment|/*&n; * Formulate a read/write request.&n; * this routine decides where to load the data (directly to buffer, or to&n; * tmp floppy area), how much data to load (the size of the buffer, the whole&n; * track, or a single sector)&n; * All floppy_track_buffer handling goes in here. If we ever add track buffer&n; * allocation on the fly, it should be done here. No other part should need&n; * modification.&n; */
DECL|function|make_raw_rw_request
r_static
r_int
id|make_raw_rw_request
c_func
(paren
r_void
)paren
(brace
r_int
id|aligned_sector_t
suffix:semicolon
r_int
id|max_sector
comma
id|max_size
comma
id|tracksize
comma
id|ssize
suffix:semicolon
r_if
c_cond
(paren
id|max_buffer_sectors
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: Block I/O scheduled on unopened device&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|set_fdc
c_func
(paren
id|DRIVE
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
)paren
suffix:semicolon
id|raw_cmd
op_assign
op_amp
id|default_raw_cmd
suffix:semicolon
id|raw_cmd-&gt;flags
op_assign
id|FD_RAW_SPIN
op_or
id|FD_RAW_NEED_DISK
op_or
id|FD_RAW_NEED_DISK
op_or
id|FD_RAW_NEED_SEEK
suffix:semicolon
id|raw_cmd-&gt;cmd_count
op_assign
id|NR_RW
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|READ
)paren
(brace
id|raw_cmd-&gt;flags
op_or_assign
id|FD_RAW_READ
suffix:semicolon
id|COMMAND
op_assign
id|FM_MODE
c_func
(paren
id|_floppy
comma
id|FD_READ
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|WRITE
)paren
(brace
id|raw_cmd-&gt;flags
op_or_assign
id|FD_RAW_WRITE
suffix:semicolon
id|COMMAND
op_assign
id|FM_MODE
c_func
(paren
id|_floppy
comma
id|FD_WRITE
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
c_func
(paren
l_string|&quot;make_raw_rw_request: unknown command&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|max_sector
op_assign
id|_floppy-&gt;sect
op_star
id|_floppy-&gt;head
suffix:semicolon
id|TRACK
op_assign
id|CURRENT-&gt;sector
op_div
id|max_sector
suffix:semicolon
id|sector_t
op_assign
id|CURRENT-&gt;sector
op_mod
id|max_sector
suffix:semicolon
r_if
c_cond
(paren
id|_floppy-&gt;track
op_logical_and
id|TRACK
op_ge
id|_floppy-&gt;track
)paren
(brace
r_if
c_cond
(paren
id|CURRENT-&gt;current_nr_sectors
op_amp
l_int|1
)paren
(brace
id|current_count_sectors
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
id|HEAD
op_assign
id|sector_t
op_div
id|_floppy-&gt;sect
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|_floppy-&gt;stretch
op_amp
id|FD_SWAPSIDES
)paren
op_logical_or
id|TESTF
c_func
(paren
id|FD_NEED_TWADDLE
)paren
)paren
op_logical_and
id|sector_t
OL
id|_floppy-&gt;sect
)paren
id|max_sector
op_assign
id|_floppy-&gt;sect
suffix:semicolon
multiline_comment|/* 2M disks have phantom sectors on the first track */
r_if
c_cond
(paren
(paren
id|_floppy-&gt;rate
op_amp
id|FD_2M
)paren
op_logical_and
(paren
op_logical_neg
id|TRACK
)paren
op_logical_and
(paren
op_logical_neg
id|HEAD
)paren
)paren
(brace
id|max_sector
op_assign
l_int|2
op_star
id|_floppy-&gt;sect
op_div
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|sector_t
op_ge
id|max_sector
)paren
(brace
id|current_count_sectors
op_assign
id|minimum
c_func
(paren
id|_floppy-&gt;sect
op_minus
id|sector_t
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|SIZECODE
op_assign
l_int|2
suffix:semicolon
)brace
r_else
id|SIZECODE
op_assign
id|FD_SIZECODE
c_func
(paren
id|_floppy
)paren
suffix:semicolon
id|raw_cmd-&gt;rate
op_assign
id|_floppy-&gt;rate
op_amp
l_int|0x43
suffix:semicolon
r_if
c_cond
(paren
(paren
id|_floppy-&gt;rate
op_amp
id|FD_2M
)paren
op_logical_and
(paren
id|TRACK
op_logical_or
id|HEAD
)paren
op_logical_and
id|raw_cmd-&gt;rate
op_eq
l_int|2
)paren
id|raw_cmd-&gt;rate
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|SIZECODE
)paren
id|SIZECODE2
op_assign
l_int|0xff
suffix:semicolon
r_else
id|SIZECODE2
op_assign
l_int|0x80
suffix:semicolon
id|raw_cmd-&gt;track
op_assign
id|TRACK
op_lshift
id|STRETCH
c_func
(paren
id|_floppy
)paren
suffix:semicolon
id|DR_SELECT
op_assign
id|UNIT
c_func
(paren
id|current_drive
)paren
op_plus
id|PH_HEAD
c_func
(paren
id|_floppy
comma
id|HEAD
)paren
suffix:semicolon
id|GAP
op_assign
id|_floppy-&gt;gap
suffix:semicolon
id|CODE2SIZE
suffix:semicolon
id|SECT_PER_TRACK
op_assign
id|_floppy-&gt;sect
op_lshift
l_int|2
op_rshift
id|SIZECODE
suffix:semicolon
id|SECTOR
op_assign
(paren
(paren
id|sector_t
op_mod
id|_floppy-&gt;sect
)paren
op_lshift
l_int|2
op_rshift
id|SIZECODE
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* tracksize describes the size which can be filled up with sectors&n;&t; * of size ssize.&n;&t; */
id|tracksize
op_assign
id|_floppy-&gt;sect
op_minus
id|_floppy-&gt;sect
op_mod
id|ssize
suffix:semicolon
r_if
c_cond
(paren
id|tracksize
OL
id|_floppy-&gt;sect
)paren
(brace
id|SECT_PER_TRACK
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tracksize
op_le
id|sector_t
op_mod
id|_floppy-&gt;sect
)paren
id|SECTOR
op_decrement
suffix:semicolon
multiline_comment|/* if we are beyond tracksize, fill up using smaller sectors */
r_while
c_loop
(paren
id|tracksize
op_le
id|sector_t
op_mod
id|_floppy-&gt;sect
)paren
(brace
r_while
c_loop
(paren
id|tracksize
op_plus
id|ssize
OG
id|_floppy-&gt;sect
)paren
(brace
id|SIZECODE
op_decrement
suffix:semicolon
id|ssize
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|SECTOR
op_increment
suffix:semicolon
id|SECT_PER_TRACK
op_increment
suffix:semicolon
id|tracksize
op_add_assign
id|ssize
suffix:semicolon
)brace
id|max_sector
op_assign
id|HEAD
op_star
id|_floppy-&gt;sect
op_plus
id|tracksize
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|TRACK
op_logical_and
op_logical_neg
id|HEAD
op_logical_and
op_logical_neg
(paren
id|_floppy-&gt;rate
op_amp
id|FD_2M
)paren
op_logical_and
id|probing
)paren
(brace
id|max_sector
op_assign
id|_floppy-&gt;sect
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|HEAD
op_logical_and
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_WRITE
)paren
(brace
multiline_comment|/* for virtual DMA bug workaround */
id|max_sector
op_assign
id|_floppy-&gt;sect
suffix:semicolon
)brace
id|in_sector_offset
op_assign
(paren
id|sector_t
op_mod
id|_floppy-&gt;sect
)paren
op_mod
id|ssize
suffix:semicolon
id|aligned_sector_t
op_assign
id|sector_t
op_minus
id|in_sector_offset
suffix:semicolon
id|max_size
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
(paren
id|raw_cmd-&gt;track
op_eq
id|buffer_track
)paren
op_logical_and
(paren
id|current_drive
op_eq
id|buffer_drive
)paren
op_logical_and
(paren
id|sector_t
op_ge
id|buffer_min
)paren
op_logical_and
(paren
id|sector_t
OL
id|buffer_max
)paren
)paren
(brace
multiline_comment|/* data already in track buffer */
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
(brace
id|copy_buffer
c_func
(paren
l_int|1
comma
id|max_sector
comma
id|buffer_max
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|in_sector_offset
op_logical_or
id|CURRENT-&gt;nr_sectors
OL
id|ssize
)paren
(brace
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_WRITE
)paren
(brace
r_if
c_cond
(paren
id|sector_t
op_plus
id|CURRENT-&gt;nr_sectors
OG
id|ssize
op_logical_and
id|sector_t
op_plus
id|CURRENT-&gt;nr_sectors
OL
id|ssize
op_plus
id|ssize
)paren
id|max_size
op_assign
id|ssize
op_plus
id|ssize
suffix:semicolon
r_else
id|max_size
op_assign
id|ssize
suffix:semicolon
)brace
id|raw_cmd-&gt;flags
op_and_assign
op_complement
id|FD_RAW_WRITE
suffix:semicolon
id|raw_cmd-&gt;flags
op_or_assign
id|FD_RAW_READ
suffix:semicolon
id|COMMAND
op_assign
id|FM_MODE
c_func
(paren
id|_floppy
comma
id|FD_READ
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|CURRENT-&gt;buffer
OL
id|MAX_DMA_ADDRESS
)paren
(brace
r_int
r_int
id|dma_limit
suffix:semicolon
r_int
id|direct
comma
id|indirect
suffix:semicolon
id|indirect
op_assign
id|transfer_size
c_func
(paren
id|ssize
comma
id|max_sector
comma
id|max_buffer_sectors
op_star
l_int|2
)paren
op_minus
id|sector_t
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Do NOT use minimum() here---MAX_DMA_ADDRESS is 64 bits wide&n;&t;&t; * on a 64 bit machine!&n;&t;&t; */
id|max_size
op_assign
id|buffer_chain_size
c_func
(paren
)paren
suffix:semicolon
id|dma_limit
op_assign
(paren
id|MAX_DMA_ADDRESS
op_minus
(paren
(paren
r_int
r_int
)paren
id|CURRENT-&gt;buffer
)paren
)paren
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|max_size
OG
id|dma_limit
)paren
(brace
id|max_size
op_assign
id|dma_limit
suffix:semicolon
)brace
multiline_comment|/* 64 kb boundaries */
r_if
c_cond
(paren
id|CROSS_64KB
c_func
(paren
id|CURRENT-&gt;buffer
comma
id|max_size
op_lshift
l_int|9
)paren
)paren
id|max_size
op_assign
(paren
id|K_64
op_minus
(paren
(paren
r_int
r_int
)paren
id|CURRENT-&gt;buffer
)paren
op_mod
id|K_64
)paren
op_rshift
l_int|9
suffix:semicolon
id|direct
op_assign
id|transfer_size
c_func
(paren
id|ssize
comma
id|max_sector
comma
id|max_size
)paren
op_minus
id|sector_t
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We try to read tracks, but if we get too many errors, we&n;&t;&t; * go back to reading just one sector at a time.&n;&t;&t; *&n;&t;&t; * This means we should be able to read a sector even if there&n;&t;&t; * are other bad sectors on this track.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|direct
op_logical_or
(paren
id|indirect
op_star
l_int|2
OG
id|direct
op_star
l_int|3
op_logical_and
op_star
id|errors
OL
id|DP-&gt;max_errors.read_track
op_logical_and
multiline_comment|/*!TESTF(FD_NEED_TWADDLE) &amp;&amp;*/
(paren
(paren
op_logical_neg
id|probing
op_logical_or
(paren
id|DP-&gt;read_track
op_amp
(paren
l_int|1
op_lshift
id|DRS-&gt;probed_format
)paren
)paren
)paren
)paren
)paren
)paren
(brace
id|max_size
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
)brace
r_else
(brace
id|raw_cmd-&gt;kernel_data
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|raw_cmd-&gt;length
op_assign
id|current_count_sectors
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd-&gt;length
op_eq
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;zero dma transfer attempted from make_raw_request&bslash;n&quot;
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;indirect=%d direct=%d sector_t=%d&quot;
comma
id|indirect
comma
id|direct
comma
id|sector_t
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&t;&t;&t;check_dma_crossing(raw_cmd-&gt;kernel_data, &n;&t;&t;&t;&t;&t;   raw_cmd-&gt;length, &n;&t;&t;&t;&t;&t;   &quot;end of make_raw_request [1]&quot;);*/
id|virtualdmabug_workaround
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
id|max_size
op_assign
id|max_sector
suffix:semicolon
multiline_comment|/* unbounded */
multiline_comment|/* claim buffer track if needed */
r_if
c_cond
(paren
id|buffer_track
op_ne
id|raw_cmd-&gt;track
op_logical_or
multiline_comment|/* bad track */
id|buffer_drive
op_ne
id|current_drive
op_logical_or
multiline_comment|/* bad drive */
id|sector_t
OG
id|buffer_max
op_logical_or
id|sector_t
OL
id|buffer_min
op_logical_or
(paren
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
op_logical_or
(paren
op_logical_neg
id|in_sector_offset
op_logical_and
id|CURRENT-&gt;nr_sectors
op_ge
id|ssize
)paren
)paren
op_logical_and
id|max_sector
OG
l_int|2
op_star
id|max_buffer_sectors
op_plus
id|buffer_min
op_logical_and
id|max_size
op_plus
id|sector_t
OG
l_int|2
op_star
id|max_buffer_sectors
op_plus
id|buffer_min
)paren
multiline_comment|/* not enough space */
)paren
(brace
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|buffer_drive
op_assign
id|current_drive
suffix:semicolon
id|buffer_max
op_assign
id|buffer_min
op_assign
id|aligned_sector_t
suffix:semicolon
)brace
id|raw_cmd-&gt;kernel_data
op_assign
id|floppy_track_buffer
op_plus
(paren
(paren
id|aligned_sector_t
op_minus
id|buffer_min
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_WRITE
)paren
(brace
multiline_comment|/* copy write buffer to track buffer.&n;&t;&t; * if we get here, we know that the write&n;&t;&t; * is either aligned or the data already in the buffer&n;&t;&t; * (buffer will be overwritten) */
macro_line|#ifdef FLOPPY_SANITY_CHECK
r_if
c_cond
(paren
id|in_sector_offset
op_logical_and
id|buffer_track
op_eq
op_minus
l_int|1
)paren
id|DPRINT
c_func
(paren
l_string|&quot;internal error offset !=0 on write&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|buffer_track
op_assign
id|raw_cmd-&gt;track
suffix:semicolon
id|buffer_drive
op_assign
id|current_drive
suffix:semicolon
id|copy_buffer
c_func
(paren
id|ssize
comma
id|max_sector
comma
l_int|2
op_star
id|max_buffer_sectors
op_plus
id|buffer_min
)paren
suffix:semicolon
)brace
r_else
id|transfer_size
c_func
(paren
id|ssize
comma
id|max_sector
comma
l_int|2
op_star
id|max_buffer_sectors
op_plus
id|buffer_min
op_minus
id|aligned_sector_t
)paren
suffix:semicolon
multiline_comment|/* round up current_count_sectors to get dma xfer size */
id|raw_cmd-&gt;length
op_assign
id|in_sector_offset
op_plus
id|current_count_sectors
suffix:semicolon
id|raw_cmd-&gt;length
op_assign
(paren
(paren
id|raw_cmd-&gt;length
op_minus
l_int|1
)paren
op_or
(paren
id|ssize
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
id|raw_cmd-&gt;length
op_lshift_assign
l_int|9
suffix:semicolon
macro_line|#ifdef FLOPPY_SANITY_CHECK
multiline_comment|/*check_dma_crossing(raw_cmd-&gt;kernel_data, raw_cmd-&gt;length, &n;&t;  &quot;end of make_raw_request&quot;);*/
r_if
c_cond
(paren
(paren
id|raw_cmd-&gt;length
OL
id|current_count_sectors
op_lshift
l_int|9
)paren
op_logical_or
(paren
id|raw_cmd-&gt;kernel_data
op_ne
id|CURRENT-&gt;buffer
op_logical_and
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_WRITE
op_logical_and
(paren
id|aligned_sector_t
op_plus
(paren
id|raw_cmd-&gt;length
op_rshift
l_int|9
)paren
OG
id|buffer_max
op_logical_or
id|aligned_sector_t
OL
id|buffer_min
)paren
)paren
op_logical_or
id|raw_cmd-&gt;length
op_mod
(paren
l_int|128
op_lshift
id|SIZECODE
)paren
op_logical_or
id|raw_cmd-&gt;length
op_le
l_int|0
op_logical_or
id|current_count_sectors
op_le
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;fractionary current count b=%lx s=%lx&bslash;n&quot;
comma
id|raw_cmd-&gt;length
comma
id|current_count_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd-&gt;kernel_data
op_ne
id|CURRENT-&gt;buffer
)paren
id|printk
c_func
(paren
l_string|&quot;addr=%d, length=%ld&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
(paren
id|raw_cmd-&gt;kernel_data
op_minus
id|floppy_track_buffer
)paren
op_rshift
l_int|9
)paren
comma
id|current_count_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;st=%d ast=%d mse=%d msi=%d&bslash;n&quot;
comma
id|sector_t
comma
id|aligned_sector_t
comma
id|max_sector
comma
id|max_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ssize=%x SIZECODE=%d&bslash;n&quot;
comma
id|ssize
comma
id|SIZECODE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;command=%x SECTOR=%d HEAD=%d, TRACK=%d&bslash;n&quot;
comma
id|COMMAND
comma
id|SECTOR
comma
id|HEAD
comma
id|TRACK
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer drive=%d&bslash;n&quot;
comma
id|buffer_drive
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer track=%d&bslash;n&quot;
comma
id|buffer_track
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer_min=%d&bslash;n&quot;
comma
id|buffer_min
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer_max=%d&bslash;n&quot;
comma
id|buffer_max
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raw_cmd-&gt;kernel_data
op_ne
id|CURRENT-&gt;buffer
)paren
(brace
r_if
c_cond
(paren
id|raw_cmd-&gt;kernel_data
OL
id|floppy_track_buffer
op_logical_or
id|current_count_sectors
OL
l_int|0
op_logical_or
id|raw_cmd-&gt;length
template_param
id|floppy_track_buffer
op_plus
(paren
id|max_buffer_sectors
op_lshift
l_int|10
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;buffer overrun in schedule dma&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sector_t=%d buffer_min=%d current_count=%ld&bslash;n&quot;
comma
id|sector_t
comma
id|buffer_min
comma
id|raw_cmd-&gt;length
op_rshift
l_int|9
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current_count_sectors=%ld&bslash;n&quot;
comma
id|current_count_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
id|printk
c_func
(paren
l_string|&quot;read&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
id|printk
c_func
(paren
l_string|&quot;write&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|raw_cmd-&gt;length
OG
id|CURRENT-&gt;nr_sectors
op_lshift
l_int|9
op_logical_or
id|current_count_sectors
OG
id|CURRENT-&gt;nr_sectors
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;buffer overrun in direct transfer&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|raw_cmd-&gt;length
OL
id|current_count_sectors
op_lshift
l_int|9
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;more sectors than bytes&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bytes=%ld&bslash;n&quot;
comma
id|raw_cmd-&gt;length
op_rshift
l_int|9
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sectors=%ld&bslash;n&quot;
comma
id|current_count_sectors
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raw_cmd-&gt;length
op_eq
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;zero dma transfer attempted from make_raw_request&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
id|virtualdmabug_workaround
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
DECL|function|redo_fd_request
r_static
r_void
id|redo_fd_request
c_func
(paren
r_void
)paren
(brace
DECL|macro|REPEAT
mdefine_line|#define REPEAT {request_done(0); continue; }
id|kdev_t
id|device
suffix:semicolon
r_int
id|tmp
suffix:semicolon
id|lastredo
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|current_drive
OL
id|N_DRIVE
)paren
id|floppy_off
c_func
(paren
id|current_drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|QUEUE_EMPTY
op_logical_and
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
id|CLEAR_INTR
suffix:semicolon
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|QUEUE_EMPTY
)paren
(brace
id|CLEAR_INTR
suffix:semicolon
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
op_ne
id|MAJOR_NR
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: request list destroyed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;bh
op_logical_and
op_logical_neg
id|buffer_locked
c_func
(paren
id|CURRENT-&gt;bh
)paren
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
id|device
op_assign
id|CURRENT-&gt;rq_dev
suffix:semicolon
id|set_fdc
c_func
(paren
id|DRIVE
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
id|reschedule_timeout
c_func
(paren
id|CURRENTD
comma
l_string|&quot;redo fd request&quot;
comma
l_int|0
)paren
suffix:semicolon
id|set_floppy
c_func
(paren
id|device
)paren
suffix:semicolon
id|raw_cmd
op_assign
op_amp
id|default_raw_cmd
suffix:semicolon
id|raw_cmd-&gt;flags
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|start_motor
c_func
(paren
id|redo_fd_request
)paren
)paren
r_return
suffix:semicolon
id|disk_change
c_func
(paren
id|current_drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|current_drive
comma
op_amp
id|fake_change
)paren
op_logical_or
id|TESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;disk absent or changed during operation&bslash;n&quot;
)paren
suffix:semicolon
id|REPEAT
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|_floppy
)paren
(brace
multiline_comment|/* Autodetection */
r_if
c_cond
(paren
op_logical_neg
id|probing
)paren
(brace
id|DRS-&gt;probed_format
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|next_valid_format
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;no autodetectable formats&bslash;n&quot;
)paren
suffix:semicolon
id|_floppy
op_assign
l_int|NULL
suffix:semicolon
id|REPEAT
suffix:semicolon
)brace
)brace
id|probing
op_assign
l_int|1
suffix:semicolon
id|_floppy
op_assign
id|floppy_type
op_plus
id|DP-&gt;autodetect
(braket
id|DRS-&gt;probed_format
)braket
suffix:semicolon
)brace
r_else
id|probing
op_assign
l_int|0
suffix:semicolon
id|errors
op_assign
op_amp
(paren
id|CURRENT-&gt;errors
)paren
suffix:semicolon
id|tmp
op_assign
id|make_raw_rw_request
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|2
)paren
(brace
id|request_done
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TESTF
c_func
(paren
id|FD_NEED_TWADDLE
)paren
)paren
id|twaddle
c_func
(paren
)paren
suffix:semicolon
id|schedule_bh
c_func
(paren
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|floppy_start
)paren
suffix:semicolon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;queue fd request&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|macro|REPEAT
macro_line|#undef REPEAT
)brace
DECL|variable|rw_cont
r_static
r_struct
id|cont_t
id|rw_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|process_fd_request
r_static
r_void
id|process_fd_request
c_func
(paren
r_void
)paren
(brace
id|cont
op_assign
op_amp
id|rw_cont
suffix:semicolon
id|schedule_bh
c_func
(paren
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|redo_fd_request
)paren
suffix:semicolon
)brace
DECL|function|do_fd_request
r_static
r_void
id|do_fd_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_if
c_cond
(paren
id|max_buffer_sectors
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: do_fd_request called on non-open device&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|usage_count
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;warning: usage count=0, CURRENT=%p exiting&bslash;n&quot;
comma
id|CURRENT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sect=%ld cmd=%d&bslash;n&quot;
comma
id|CURRENT-&gt;sector
comma
id|CURRENT-&gt;cmd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdc_busy
)paren
(brace
multiline_comment|/* fdc busy, this new request will be treated when the&n;&t;&t;   current one is done */
id|is_alive
c_func
(paren
l_string|&quot;do fd request, old request running&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|lock_fdc
c_func
(paren
id|MAXTIMEOUT
comma
l_int|0
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
id|is_alive
c_func
(paren
l_string|&quot;do fd request&quot;
)paren
suffix:semicolon
)brace
DECL|variable|poll_cont
r_static
r_struct
id|cont_t
id|poll_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|poll_drive
r_static
r_int
id|poll_drive
c_func
(paren
r_int
id|interruptible
comma
r_int
id|flag
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* no auto-sense, just clear dcl */
id|raw_cmd
op_assign
op_amp
id|default_raw_cmd
suffix:semicolon
id|raw_cmd-&gt;flags
op_assign
id|flag
suffix:semicolon
id|raw_cmd-&gt;track
op_assign
l_int|0
suffix:semicolon
id|raw_cmd-&gt;cmd_count
op_assign
l_int|0
suffix:semicolon
id|cont
op_assign
op_amp
id|poll_cont
suffix:semicolon
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;setting NEWCHANGE in poll_drive&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|SETF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
suffix:semicolon
id|WAIT
c_func
(paren
id|floppy_ready
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * User triggered reset&n; * ====================&n; */
DECL|function|reset_intr
r_static
r_void
id|reset_intr
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;weird, reset interrupt called&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|reset_cont
r_static
r_struct
id|cont_t
id|reset_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|user_reset_fdc
r_static
r_int
id|user_reset_fdc
c_func
(paren
r_int
id|drive
comma
r_int
id|arg
comma
r_int
id|interruptible
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
id|LOCK_FDC
c_func
(paren
id|drive
comma
id|interruptible
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
id|FD_RESET_ALWAYS
)paren
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
(brace
id|cont
op_assign
op_amp
id|reset_cont
suffix:semicolon
id|WAIT
c_func
(paren
id|reset_fdc
)paren
suffix:semicolon
)brace
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Misc Ioctl&squot;s and support&n; * ========================&n; */
DECL|function|fd_copyout
r_static
r_inline
r_int
id|fd_copyout
c_func
(paren
r_void
op_star
id|param
comma
r_const
r_void
op_star
id|address
comma
r_int
r_int
id|size
)paren
(brace
r_return
id|copy_to_user
c_func
(paren
id|param
comma
id|address
comma
id|size
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|function|fd_copyin
r_static
r_inline
r_int
id|fd_copyin
c_func
(paren
r_void
op_star
id|param
comma
r_void
op_star
id|address
comma
r_int
r_int
id|size
)paren
(brace
r_return
id|copy_from_user
c_func
(paren
id|address
comma
id|param
comma
id|size
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
DECL|macro|_COPYOUT
mdefine_line|#define _COPYOUT(x) (copy_to_user((void *)param, &amp;(x), sizeof(x)) ? -EFAULT : 0)
DECL|macro|_COPYIN
mdefine_line|#define _COPYIN(x) (copy_from_user(&amp;(x), (void *)param, sizeof(x)) ? -EFAULT : 0)
DECL|macro|COPYOUT
mdefine_line|#define COPYOUT(x) ECALL(_COPYOUT(x))
DECL|macro|COPYIN
mdefine_line|#define COPYIN(x) ECALL(_COPYIN(x))
DECL|function|drive_name
r_static
r_inline
r_const
r_char
op_star
id|drive_name
c_func
(paren
r_int
id|type
comma
r_int
id|drive
)paren
(brace
r_struct
id|floppy_struct
op_star
id|floppy
suffix:semicolon
r_if
c_cond
(paren
id|type
)paren
id|floppy
op_assign
id|floppy_type
op_plus
id|type
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|UDP-&gt;native_format
)paren
id|floppy
op_assign
id|floppy_type
op_plus
id|UDP-&gt;native_format
suffix:semicolon
r_else
r_return
l_string|&quot;(null)&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|floppy-&gt;name
)paren
r_return
id|floppy-&gt;name
suffix:semicolon
r_else
r_return
l_string|&quot;(null)&quot;
suffix:semicolon
)brace
multiline_comment|/* raw commands */
DECL|function|raw_cmd_done
r_static
r_void
id|raw_cmd_done
c_func
(paren
r_int
id|flag
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|flag
)paren
(brace
id|raw_cmd-&gt;flags
op_or_assign
id|FD_RAW_FAILURE
suffix:semicolon
id|raw_cmd-&gt;flags
op_or_assign
id|FD_RAW_HARDFAILURE
suffix:semicolon
)brace
r_else
(brace
id|raw_cmd-&gt;reply_count
op_assign
id|inr
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd-&gt;reply_count
OG
id|MAX_REPLIES
)paren
id|raw_cmd-&gt;reply_count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|raw_cmd-&gt;reply_count
suffix:semicolon
id|i
op_increment
)paren
id|raw_cmd-&gt;reply
(braket
id|i
)braket
op_assign
id|reply_buffer
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd-&gt;flags
op_amp
(paren
id|FD_RAW_READ
op_or
id|FD_RAW_WRITE
)paren
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|flags
op_assign
id|claim_dma_lock
c_func
(paren
)paren
suffix:semicolon
id|raw_cmd-&gt;length
op_assign
id|fd_get_dma_residue
c_func
(paren
)paren
suffix:semicolon
id|release_dma_lock
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_SOFTFAILURE
)paren
op_logical_and
(paren
op_logical_neg
id|raw_cmd-&gt;reply_count
op_logical_or
(paren
id|raw_cmd-&gt;reply
(braket
l_int|0
)braket
op_amp
l_int|0xc0
)paren
)paren
)paren
id|raw_cmd-&gt;flags
op_or_assign
id|FD_RAW_FAILURE
suffix:semicolon
r_if
c_cond
(paren
id|disk_change
c_func
(paren
id|current_drive
)paren
)paren
id|raw_cmd-&gt;flags
op_or_assign
id|FD_RAW_DISK_CHANGE
suffix:semicolon
r_else
id|raw_cmd-&gt;flags
op_and_assign
op_complement
id|FD_RAW_DISK_CHANGE
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_NO_MOTOR_AFTER
)paren
id|motor_off_callback
c_func
(paren
id|current_drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd-&gt;next
op_logical_and
(paren
op_logical_neg
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_FAILURE
)paren
op_logical_or
op_logical_neg
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_STOP_IF_FAILURE
)paren
)paren
op_logical_and
(paren
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_FAILURE
)paren
op_logical_or
op_logical_neg
(paren
id|raw_cmd-&gt;flags
op_amp
id|FD_RAW_STOP_IF_SUCCESS
)paren
)paren
)paren
(brace
id|raw_cmd
op_assign
id|raw_cmd-&gt;next
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|generic_done
c_func
(paren
id|flag
)paren
suffix:semicolon
)brace
DECL|variable|raw_cmd_cont
r_static
r_struct
id|cont_t
id|raw_cmd_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|raw_cmd_copyout
r_static
r_inline
r_int
id|raw_cmd_copyout
c_func
(paren
r_int
id|cmd
comma
r_char
op_star
id|param
comma
r_struct
id|floppy_raw_cmd
op_star
id|ptr
)paren
(brace
r_int
id|ret
suffix:semicolon
r_while
c_loop
(paren
id|ptr
)paren
(brace
id|COPYOUT
c_func
(paren
op_star
id|ptr
)paren
suffix:semicolon
id|param
op_add_assign
r_sizeof
(paren
r_struct
id|floppy_raw_cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ptr-&gt;flags
op_amp
id|FD_RAW_READ
)paren
op_logical_and
id|ptr-&gt;buffer_length
)paren
(brace
r_if
c_cond
(paren
id|ptr-&gt;length
op_ge
l_int|0
op_logical_and
id|ptr-&gt;length
op_le
id|ptr-&gt;buffer_length
)paren
id|ECALL
c_func
(paren
id|fd_copyout
c_func
(paren
id|ptr-&gt;data
comma
id|ptr-&gt;kernel_data
comma
id|ptr-&gt;buffer_length
op_minus
id|ptr-&gt;length
)paren
)paren
suffix:semicolon
)brace
id|ptr
op_assign
id|ptr-&gt;next
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|raw_cmd_free
r_static
r_void
id|raw_cmd_free
c_func
(paren
r_struct
id|floppy_raw_cmd
op_star
op_star
id|ptr
)paren
(brace
r_struct
id|floppy_raw_cmd
op_star
id|next
comma
op_star
id|this
suffix:semicolon
id|this
op_assign
op_star
id|ptr
suffix:semicolon
op_star
id|ptr
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|this
)paren
(brace
r_if
c_cond
(paren
id|this-&gt;buffer_length
)paren
(brace
id|fd_dma_mem_free
c_func
(paren
(paren
r_int
r_int
)paren
id|this-&gt;kernel_data
comma
id|this-&gt;buffer_length
)paren
suffix:semicolon
id|this-&gt;buffer_length
op_assign
l_int|0
suffix:semicolon
)brace
id|next
op_assign
id|this-&gt;next
suffix:semicolon
id|kfree
c_func
(paren
id|this
)paren
suffix:semicolon
id|this
op_assign
id|next
suffix:semicolon
)brace
)brace
DECL|function|raw_cmd_copyin
r_static
r_inline
r_int
id|raw_cmd_copyin
c_func
(paren
r_int
id|cmd
comma
r_char
op_star
id|param
comma
r_struct
id|floppy_raw_cmd
op_star
op_star
id|rcmd
)paren
(brace
r_struct
id|floppy_raw_cmd
op_star
id|ptr
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|i
suffix:semicolon
op_star
id|rcmd
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|ptr
op_assign
(paren
r_struct
id|floppy_raw_cmd
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|floppy_raw_cmd
)paren
comma
id|GFP_USER
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
op_star
id|rcmd
op_assign
id|ptr
suffix:semicolon
id|COPYIN
c_func
(paren
op_star
id|ptr
)paren
suffix:semicolon
id|ptr-&gt;next
op_assign
l_int|0
suffix:semicolon
id|ptr-&gt;buffer_length
op_assign
l_int|0
suffix:semicolon
id|param
op_add_assign
r_sizeof
(paren
r_struct
id|floppy_raw_cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ptr-&gt;cmd_count
OG
l_int|33
)paren
multiline_comment|/* the command may now also take up the space&n;&t;&t;&t; * initially intended for the reply &amp; the&n;&t;&t;&t; * reply count. Needed for long 82078 commands&n;&t;&t;&t; * such as RESTORE, which takes ... 17 command&n;&t;&t;&t; * bytes. Murphy&squot;s law #137: When you reserve&n;&t;&t;&t; * 16 bytes for a structure, you&squot;ll one day&n;&t;&t;&t; * discover that you really need 17...&n;&t;&t;&t; */
r_return
op_minus
id|EINVAL
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|16
suffix:semicolon
id|i
op_increment
)paren
id|ptr-&gt;reply
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|ptr-&gt;resultcode
op_assign
l_int|0
suffix:semicolon
id|ptr-&gt;kernel_data
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ptr-&gt;flags
op_amp
(paren
id|FD_RAW_READ
op_or
id|FD_RAW_WRITE
)paren
)paren
(brace
r_if
c_cond
(paren
id|ptr-&gt;length
op_le
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ptr-&gt;kernel_data
op_assign
(paren
r_char
op_star
)paren
id|fd_dma_mem_alloc
c_func
(paren
id|ptr-&gt;length
)paren
suffix:semicolon
id|fallback_on_nodma_alloc
c_func
(paren
op_amp
id|ptr-&gt;kernel_data
comma
id|ptr-&gt;length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ptr-&gt;kernel_data
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|ptr-&gt;buffer_length
op_assign
id|ptr-&gt;length
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ptr-&gt;flags
op_amp
id|FD_RAW_WRITE
)paren
id|ECALL
c_func
(paren
id|fd_copyin
c_func
(paren
id|ptr-&gt;data
comma
id|ptr-&gt;kernel_data
comma
id|ptr-&gt;length
)paren
)paren
suffix:semicolon
id|rcmd
op_assign
op_amp
(paren
id|ptr-&gt;next
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ptr-&gt;flags
op_amp
id|FD_RAW_MORE
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|ptr-&gt;rate
op_and_assign
l_int|0x43
suffix:semicolon
)brace
)brace
DECL|function|raw_cmd_ioctl
r_static
r_int
id|raw_cmd_ioctl
c_func
(paren
r_int
id|cmd
comma
r_void
op_star
id|param
)paren
(brace
r_int
id|drive
comma
id|ret
comma
id|ret2
suffix:semicolon
r_struct
id|floppy_raw_cmd
op_star
id|my_raw_cmd
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;rawcmd
op_le
l_int|1
)paren
id|FDCS-&gt;rawcmd
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|N_DRIVE
suffix:semicolon
id|drive
op_increment
)paren
(brace
r_if
c_cond
(paren
id|FDC
c_func
(paren
id|drive
)paren
op_ne
id|fdc
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
id|current_drive
)paren
(brace
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
OG
l_int|1
)paren
(brace
id|FDCS-&gt;rawcmd
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
)paren
(brace
id|FDCS-&gt;rawcmd
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|ret
op_assign
id|raw_cmd_copyin
c_func
(paren
id|cmd
comma
id|param
comma
op_amp
id|my_raw_cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|raw_cmd_free
c_func
(paren
op_amp
id|my_raw_cmd
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|raw_cmd
op_assign
id|my_raw_cmd
suffix:semicolon
id|cont
op_assign
op_amp
id|raw_cmd_cont
suffix:semicolon
id|ret
op_assign
id|wait_til_done
c_func
(paren
id|floppy_start
comma
l_int|1
)paren
suffix:semicolon
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;calling disk change from raw_cmd ioctl&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|EINTR
op_logical_and
id|FDCS-&gt;reset
)paren
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|DRS-&gt;track
op_assign
id|NO_TRACK
suffix:semicolon
id|ret2
op_assign
id|raw_cmd_copyout
c_func
(paren
id|cmd
comma
id|param
comma
id|my_raw_cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|ret
op_assign
id|ret2
suffix:semicolon
id|raw_cmd_free
c_func
(paren
op_amp
id|my_raw_cmd
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|invalidate_drive
r_static
r_int
id|invalidate_drive
c_func
(paren
id|kdev_t
id|rdev
)paren
(brace
multiline_comment|/* invalidate the buffer track to force a reread */
id|set_bit
c_func
(paren
id|DRIVE
c_func
(paren
id|rdev
)paren
comma
op_amp
id|fake_change
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
id|check_disk_change
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|clear_write_error
r_static
r_inline
r_void
id|clear_write_error
c_func
(paren
r_int
id|drive
)paren
(brace
id|CLEARSTRUCT
c_func
(paren
id|UDRWE
)paren
suffix:semicolon
)brace
DECL|function|set_geometry
r_static
r_inline
r_int
id|set_geometry
c_func
(paren
r_int
r_int
id|cmd
comma
r_struct
id|floppy_struct
op_star
id|g
comma
r_int
id|drive
comma
r_int
id|type
comma
id|kdev_t
id|device
)paren
(brace
r_int
id|cnt
suffix:semicolon
multiline_comment|/* sanity checking for parameters.*/
r_if
c_cond
(paren
id|g-&gt;sect
op_le
l_int|0
op_logical_or
id|g-&gt;head
op_le
l_int|0
op_logical_or
id|g-&gt;track
op_le
l_int|0
op_logical_or
id|g-&gt;track
OG
id|UDP-&gt;tracks
op_rshift
id|STRETCH
c_func
(paren
id|g
)paren
op_logical_or
multiline_comment|/* check if reserved bits are set */
(paren
id|g-&gt;stretch
op_amp
op_complement
(paren
id|FD_STRETCH
op_or
id|FD_SWAPSIDES
)paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|type
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|N_DRIVE
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ITYPE
c_func
(paren
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_device
)paren
op_eq
id|type
op_logical_and
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_ref
)paren
id|set_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
suffix:semicolon
)brace
id|floppy_type
(braket
id|type
)braket
op_assign
op_star
id|g
suffix:semicolon
id|floppy_type
(braket
id|type
)braket
dot
id|name
op_assign
l_string|&quot;user format&quot;
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
id|type
op_lshift
l_int|2
suffix:semicolon
id|cnt
OL
(paren
id|type
op_lshift
l_int|2
)paren
op_plus
l_int|4
suffix:semicolon
id|cnt
op_increment
)paren
id|floppy_sizes
(braket
id|cnt
)braket
op_assign
id|floppy_sizes
(braket
id|cnt
op_plus
l_int|0x80
)braket
op_assign
(paren
id|floppy_type
(braket
id|type
)braket
dot
id|size
op_plus
l_int|1
)paren
op_rshift
l_int|1
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|N_DRIVE
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ITYPE
c_func
(paren
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_device
)paren
op_eq
id|type
op_logical_and
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_ref
)paren
id|check_disk_change
c_func
(paren
id|MKDEV
c_func
(paren
id|FLOPPY_MAJOR
comma
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_device
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
id|FDDEFPRM
)paren
multiline_comment|/* notice a disk change immediately, else&n;&t;&t;&t; * we lose our settings immediately*/
id|CALL
c_func
(paren
id|poll_drive
c_func
(paren
l_int|1
comma
id|FD_RAW_NEED_DISK
)paren
)paren
suffix:semicolon
id|user_params
(braket
id|drive
)braket
op_assign
op_star
id|g
suffix:semicolon
r_if
c_cond
(paren
id|buffer_drive
op_eq
id|drive
)paren
id|SUPBOUND
c_func
(paren
id|buffer_max
comma
id|user_params
(braket
id|drive
)braket
dot
id|sect
)paren
suffix:semicolon
id|current_type
(braket
id|drive
)braket
op_assign
op_amp
id|user_params
(braket
id|drive
)braket
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
(paren
id|user_params
(braket
id|drive
)braket
dot
id|size
op_plus
l_int|1
)paren
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|FDDEFPRM
)paren
id|DRS-&gt;keep_data
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|DRS-&gt;keep_data
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* invalidation. Invalidate only when needed, i.e.&n;&t;&t; * when there are already sectors in the buffer cache&n;&t;&t; * whose number will change. This is useful, because&n;&t;&t; * mtools often changes the geometry of the disk after&n;&t;&t; * looking at the boot block */
r_if
c_cond
(paren
id|DRS-&gt;maxblock
OG
id|user_params
(braket
id|drive
)braket
dot
id|sect
op_logical_or
id|DRS-&gt;maxtrack
)paren
id|invalidate_drive
c_func
(paren
id|device
)paren
suffix:semicolon
r_else
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* handle obsolete ioctl&squot;s */
DECL|variable|ioctl_table
r_static
r_int
id|ioctl_table
(braket
)braket
op_assign
(brace
id|FDCLRPRM
comma
id|FDSETPRM
comma
id|FDDEFPRM
comma
id|FDGETPRM
comma
id|FDMSGON
comma
id|FDMSGOFF
comma
id|FDFMTBEG
comma
id|FDFMTTRK
comma
id|FDFMTEND
comma
id|FDSETEMSGTRESH
comma
id|FDFLUSH
comma
id|FDSETMAXERRS
comma
id|FDGETMAXERRS
comma
id|FDGETDRVTYP
comma
id|FDSETDRVPRM
comma
id|FDGETDRVPRM
comma
id|FDGETDRVSTAT
comma
id|FDPOLLDRVSTAT
comma
id|FDRESET
comma
id|FDGETFDCSTAT
comma
id|FDWERRORCLR
comma
id|FDWERRORGET
comma
id|FDRAWCMD
comma
id|FDEJECT
comma
id|FDTWADDLE
)brace
suffix:semicolon
DECL|function|normalize_ioctl
r_static
r_inline
r_int
id|normalize_ioctl
c_func
(paren
r_int
op_star
id|cmd
comma
r_int
op_star
id|size
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|ioctl_table
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
op_star
id|cmd
op_amp
l_int|0xffff
)paren
op_eq
(paren
id|ioctl_table
(braket
id|i
)braket
op_amp
l_int|0xffff
)paren
)paren
(brace
op_star
id|size
op_assign
id|_IOC_SIZE
c_func
(paren
op_star
id|cmd
)paren
suffix:semicolon
op_star
id|cmd
op_assign
id|ioctl_table
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_star
id|size
OG
id|_IOC_SIZE
c_func
(paren
op_star
id|cmd
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ioctl not yet supported&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
DECL|function|get_floppy_geometry
r_static
r_int
id|get_floppy_geometry
c_func
(paren
r_int
id|drive
comma
r_int
id|type
comma
r_struct
id|floppy_struct
op_star
op_star
id|g
)paren
(brace
r_if
c_cond
(paren
id|type
)paren
op_star
id|g
op_assign
op_amp
id|floppy_type
(braket
id|type
)braket
suffix:semicolon
r_else
(brace
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|CALL
c_func
(paren
id|poll_drive
c_func
(paren
l_int|0
comma
l_int|0
)paren
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
op_star
id|g
op_assign
id|current_type
(braket
id|drive
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
op_star
id|g
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fd_ioctl
r_static
r_int
id|fd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|param
)paren
(brace
DECL|macro|FD_IOCTL_ALLOWED
mdefine_line|#define FD_IOCTL_ALLOWED ((filp) &amp;&amp; (filp)-&gt;private_data)
DECL|macro|OUT
mdefine_line|#define OUT(c,x) case c: outparam = (const char *) (x); break
DECL|macro|IN
mdefine_line|#define IN(c,x,tag) case c: *(x) = inparam. tag ; return 0
r_int
id|i
comma
id|drive
comma
id|type
suffix:semicolon
id|kdev_t
id|device
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|size
suffix:semicolon
r_union
id|inparam
(brace
r_struct
id|floppy_struct
id|g
suffix:semicolon
multiline_comment|/* geometry */
r_struct
id|format_descr
id|f
suffix:semicolon
r_struct
id|floppy_max_errors
id|max_errors
suffix:semicolon
r_struct
id|floppy_drive_params
id|dp
suffix:semicolon
)brace
id|inparam
suffix:semicolon
multiline_comment|/* parameters coming from user space */
r_const
r_char
op_star
id|outparam
suffix:semicolon
multiline_comment|/* parameters passed back to user space */
id|device
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|BLKROSET
suffix:colon
r_case
id|BLKROGET
suffix:colon
r_case
id|BLKRASET
suffix:colon
r_case
id|BLKRAGET
suffix:colon
r_case
id|BLKFLSBUF
suffix:colon
r_return
id|blk_ioctl
c_func
(paren
id|device
comma
id|cmd
comma
id|param
)paren
suffix:semicolon
)brace
id|type
op_assign
id|TYPE
c_func
(paren
id|device
)paren
suffix:semicolon
id|drive
op_assign
id|DRIVE
c_func
(paren
id|device
)paren
suffix:semicolon
multiline_comment|/* convert compatibility eject ioctls into floppy eject ioctl.&n;&t; * We do this in order to provide a means to eject floppy disks before&n;&t; * installing the new fdutils package */
r_if
c_cond
(paren
id|cmd
op_eq
id|CDROMEJECT
op_logical_or
multiline_comment|/* CD-ROM eject */
id|cmd
op_eq
l_int|0x6470
multiline_comment|/* SunOS floppy eject */
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;obsolete eject ioctl&bslash;n&quot;
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;please use floppycontrol --eject&bslash;n&quot;
)paren
suffix:semicolon
id|cmd
op_assign
id|FDEJECT
suffix:semicolon
)brace
multiline_comment|/* generic block device ioctls */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/* the following have been inspired by the corresponding&n;&t;&t; * code for other block devices. */
r_struct
id|floppy_struct
op_star
id|g
suffix:semicolon
r_case
id|HDIO_GETGEO
suffix:colon
(brace
r_struct
id|hd_geometry
id|loc
suffix:semicolon
id|ECALL
c_func
(paren
id|get_floppy_geometry
c_func
(paren
id|drive
comma
id|type
comma
op_amp
id|g
)paren
)paren
suffix:semicolon
id|loc.heads
op_assign
id|g-&gt;head
suffix:semicolon
id|loc.sectors
op_assign
id|g-&gt;sect
suffix:semicolon
id|loc.cylinders
op_assign
id|g-&gt;track
suffix:semicolon
id|loc.start
op_assign
l_int|0
suffix:semicolon
r_return
id|_COPYOUT
c_func
(paren
id|loc
)paren
suffix:semicolon
)brace
r_case
id|BLKGETSIZE
suffix:colon
id|ECALL
c_func
(paren
id|get_floppy_geometry
c_func
(paren
id|drive
comma
id|type
comma
op_amp
id|g
)paren
)paren
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|g-&gt;size
comma
(paren
r_int
op_star
)paren
id|param
)paren
suffix:semicolon
multiline_comment|/* BLKRRPART is not defined as floppies don&squot;t have&n;&t;&t; * partition tables */
)brace
multiline_comment|/* convert the old style command into a new style command */
r_if
c_cond
(paren
(paren
id|cmd
op_amp
l_int|0xff00
)paren
op_eq
l_int|0x0200
)paren
(brace
id|ECALL
c_func
(paren
id|normalize_ioctl
c_func
(paren
op_amp
id|cmd
comma
op_amp
id|size
)paren
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* permission checks */
r_if
c_cond
(paren
(paren
(paren
id|cmd
op_amp
l_int|0x40
)paren
op_logical_and
op_logical_neg
id|FD_IOCTL_ALLOWED
)paren
op_logical_or
(paren
(paren
id|cmd
op_amp
l_int|0x80
)paren
op_logical_and
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
multiline_comment|/* copyin */
id|CLEARSTRUCT
c_func
(paren
op_amp
id|inparam
)paren
suffix:semicolon
r_if
c_cond
(paren
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
op_amp
id|_IOC_WRITE
)paren
id|ECALL
c_func
(paren
id|fd_copyin
c_func
(paren
(paren
r_void
op_star
)paren
id|param
comma
op_amp
id|inparam
comma
id|size
)paren
)paren
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FDEJECT
suffix:colon
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
op_ne
l_int|1
)paren
multiline_comment|/* somebody else has this drive open */
r_return
op_minus
id|EBUSY
suffix:semicolon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/* do the actual eject. Fails on&n;&t;&t;&t; * non-Sparc architectures */
id|ret
op_assign
id|fd_eject
c_func
(paren
id|UNIT
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
id|USETF
c_func
(paren
id|FD_DISK_CHANGED
)paren
suffix:semicolon
id|USETF
c_func
(paren
id|FD_VERIFY
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
r_case
id|FDCLRPRM
suffix:colon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
id|current_type
(braket
id|drive
)braket
op_assign
l_int|NULL
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
id|UDRS-&gt;keep_data
op_assign
l_int|0
suffix:semicolon
r_return
id|invalidate_drive
c_func
(paren
id|device
)paren
suffix:semicolon
r_case
id|FDSETPRM
suffix:colon
r_case
id|FDDEFPRM
suffix:colon
r_return
id|set_geometry
c_func
(paren
id|cmd
comma
op_amp
id|inparam.g
comma
id|drive
comma
id|type
comma
id|device
)paren
suffix:semicolon
r_case
id|FDGETPRM
suffix:colon
id|ECALL
c_func
(paren
id|get_floppy_geometry
c_func
(paren
id|drive
comma
id|type
comma
(paren
r_struct
id|floppy_struct
op_star
op_star
)paren
op_amp
id|outparam
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDMSGON
suffix:colon
id|UDP-&gt;flags
op_or_assign
id|FTD_MSG
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDMSGOFF
suffix:colon
id|UDP-&gt;flags
op_and_assign
op_complement
id|FTD_MSG
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDFMTBEG
suffix:colon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
id|CALL
c_func
(paren
id|poll_drive
c_func
(paren
l_int|1
comma
id|FD_RAW_NEED_DISK
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|UDRS-&gt;flags
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_amp
id|FD_VERIFY
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ret
op_amp
id|FD_DISK_WRITABLE
)paren
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDFMTTRK
suffix:colon
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
op_ne
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_return
id|do_format
c_func
(paren
id|device
comma
op_amp
id|inparam.f
)paren
suffix:semicolon
r_case
id|FDFMTEND
suffix:colon
r_case
id|FDFLUSH
suffix:colon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_return
id|invalidate_drive
c_func
(paren
id|device
)paren
suffix:semicolon
r_case
id|FDSETEMSGTRESH
suffix:colon
id|UDP-&gt;max_errors.reporting
op_assign
(paren
r_int
r_int
)paren
(paren
id|param
op_amp
l_int|0x0f
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|OUT
c_func
(paren
id|FDGETMAXERRS
comma
op_amp
id|UDP-&gt;max_errors
)paren
suffix:semicolon
id|IN
c_func
(paren
id|FDSETMAXERRS
comma
op_amp
id|UDP-&gt;max_errors
comma
id|max_errors
)paren
suffix:semicolon
r_case
id|FDGETDRVTYP
suffix:colon
id|outparam
op_assign
id|drive_name
c_func
(paren
id|type
comma
id|drive
)paren
suffix:semicolon
id|SUPBOUND
c_func
(paren
id|size
comma
id|strlen
c_func
(paren
id|outparam
)paren
op_plus
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
id|IN
c_func
(paren
id|FDSETDRVPRM
comma
id|UDP
comma
id|dp
)paren
suffix:semicolon
id|OUT
c_func
(paren
id|FDGETDRVPRM
comma
id|UDP
)paren
suffix:semicolon
r_case
id|FDPOLLDRVSTAT
suffix:colon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
id|CALL
c_func
(paren
id|poll_drive
c_func
(paren
l_int|1
comma
id|FD_RAW_NEED_DISK
)paren
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* fall through */
id|OUT
c_func
(paren
id|FDGETDRVSTAT
comma
id|UDRS
)paren
suffix:semicolon
r_case
id|FDRESET
suffix:colon
r_return
id|user_reset_fdc
c_func
(paren
id|drive
comma
(paren
r_int
)paren
id|param
comma
l_int|1
)paren
suffix:semicolon
id|OUT
c_func
(paren
id|FDGETFDCSTAT
comma
id|UFDCS
)paren
suffix:semicolon
r_case
id|FDWERRORCLR
suffix:colon
id|CLEARSTRUCT
c_func
(paren
id|UDRWE
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|OUT
c_func
(paren
id|FDWERRORGET
comma
id|UDRWE
)paren
suffix:semicolon
r_case
id|FDRAWCMD
suffix:colon
r_if
c_cond
(paren
id|type
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
id|set_floppy
c_func
(paren
id|device
)paren
suffix:semicolon
id|CALL
c_func
(paren
id|i
op_assign
id|raw_cmd_ioctl
c_func
(paren
id|cmd
comma
(paren
r_void
op_star
)paren
id|param
)paren
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
r_case
id|FDTWADDLE
suffix:colon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
id|twaddle
c_func
(paren
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|_IOC_DIR
c_func
(paren
id|cmd
)paren
op_amp
id|_IOC_READ
)paren
r_return
id|fd_copyout
c_func
(paren
(paren
r_void
op_star
)paren
id|param
comma
id|outparam
comma
id|size
)paren
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
DECL|macro|OUT
macro_line|#undef OUT
DECL|macro|IN
macro_line|#undef IN
)brace
DECL|function|config_types
r_static
r_void
id|__init
id|config_types
c_func
(paren
r_void
)paren
(brace
r_int
id|first
op_assign
l_int|1
suffix:semicolon
r_int
id|drive
suffix:semicolon
multiline_comment|/* read drive info out of physical CMOS */
id|drive
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|UDP-&gt;cmos
)paren
id|UDP-&gt;cmos
op_assign
id|FLOPPY0_TYPE
suffix:semicolon
id|drive
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|UDP-&gt;cmos
op_logical_and
id|FLOPPY1_TYPE
)paren
id|UDP-&gt;cmos
op_assign
id|FLOPPY1_TYPE
suffix:semicolon
multiline_comment|/* XXX */
multiline_comment|/* additional physical CMOS drive detection should go here */
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|N_DRIVE
suffix:semicolon
id|drive
op_increment
)paren
(brace
r_int
r_int
id|type
op_assign
id|UDP-&gt;cmos
suffix:semicolon
r_struct
id|floppy_drive_params
op_star
id|params
suffix:semicolon
r_const
r_char
op_star
id|name
op_assign
l_int|NULL
suffix:semicolon
r_static
r_char
id|temparea
(braket
l_int|32
)braket
suffix:semicolon
r_if
c_cond
(paren
id|type
OL
id|NUMBER
c_func
(paren
id|default_drive_params
)paren
)paren
(brace
id|params
op_assign
op_amp
id|default_drive_params
(braket
id|type
)braket
dot
id|params
suffix:semicolon
r_if
c_cond
(paren
id|type
)paren
(brace
id|name
op_assign
id|default_drive_params
(braket
id|type
)braket
dot
id|name
suffix:semicolon
id|allowed_drive_mask
op_or_assign
l_int|1
op_lshift
id|drive
suffix:semicolon
)brace
)brace
r_else
(brace
id|params
op_assign
op_amp
id|default_drive_params
(braket
l_int|0
)braket
dot
id|params
suffix:semicolon
id|sprintf
c_func
(paren
id|temparea
comma
l_string|&quot;unknown type %d (usb?)&quot;
comma
id|type
)paren
suffix:semicolon
id|name
op_assign
id|temparea
suffix:semicolon
)brace
r_if
c_cond
(paren
id|name
)paren
(brace
r_const
r_char
op_star
id|prepend
op_assign
l_string|&quot;,&quot;
suffix:semicolon
r_if
c_cond
(paren
id|first
)paren
(brace
id|prepend
op_assign
id|KERN_INFO
l_string|&quot;Floppy drive(s):&quot;
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%s fd%d is %s&quot;
comma
id|prepend
comma
id|drive
comma
id|name
)paren
suffix:semicolon
id|register_devfs_entries
(paren
id|drive
)paren
suffix:semicolon
)brace
op_star
id|UDP
op_assign
op_star
id|params
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|first
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|floppy_release
r_static
r_int
id|floppy_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|drive
op_assign
id|DRIVE
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
OL
l_int|0
)paren
id|UDRS-&gt;fd_ref
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|UDRS-&gt;fd_ref
op_decrement
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;floppy_release with fd_ref == 0&quot;
)paren
suffix:semicolon
id|UDRS-&gt;fd_ref
op_assign
l_int|0
suffix:semicolon
)brace
id|floppy_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * floppy_open check for aliasing (/dev/fd0 can be the same as&n; * /dev/PS0 etc), and disallows simultaneous access to the same&n; * drive with different device numbers.&n; */
DECL|macro|RETERR
mdefine_line|#define RETERR(x) do{floppy_release(inode,filp); return -(x);}while(0)
DECL|function|floppy_open
r_static
r_int
id|floppy_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|drive
suffix:semicolon
r_int
id|old_dev
suffix:semicolon
r_int
r_try
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;Weird, open called with filp=0&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|filp-&gt;private_data
op_assign
(paren
r_void
op_star
)paren
l_int|0
suffix:semicolon
id|drive
op_assign
id|DRIVE
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_ge
id|N_DRIVE
op_logical_or
op_logical_neg
(paren
id|allowed_drive_mask
op_amp
(paren
l_int|1
op_lshift
id|drive
)paren
)paren
op_logical_or
id|fdc_state
(braket
id|FDC
c_func
(paren
id|drive
)paren
)braket
dot
id|version
op_eq
id|FDC_NONE
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|TYPE
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_ge
id|NUMBER
c_func
(paren
id|floppy_type
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|old_dev
op_assign
id|UDRS-&gt;fd_device
suffix:semicolon
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
op_logical_and
id|old_dev
op_ne
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|UDRS-&gt;fd_ref
op_logical_and
(paren
id|UDP-&gt;flags
op_amp
id|FD_BROKEN_DCL
)paren
)paren
(brace
id|USETF
c_func
(paren
id|FD_DISK_CHANGED
)paren
suffix:semicolon
id|USETF
c_func
(paren
id|FD_VERIFY
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
op_eq
op_minus
l_int|1
op_logical_or
(paren
id|UDRS-&gt;fd_ref
op_logical_and
(paren
id|filp-&gt;f_flags
op_amp
id|O_EXCL
)paren
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|floppy_grab_irq_and_dma
c_func
(paren
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_EXCL
)paren
id|UDRS-&gt;fd_ref
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|UDRS-&gt;fd_ref
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|floppy_track_buffer
)paren
(brace
multiline_comment|/* if opening an ED drive, reserve a big buffer,&n;&t;&t; * else reserve a small one */
r_if
c_cond
(paren
(paren
id|UDP-&gt;cmos
op_eq
l_int|6
)paren
op_logical_or
(paren
id|UDP-&gt;cmos
op_eq
l_int|5
)paren
)paren
r_try
op_assign
l_int|64
suffix:semicolon
multiline_comment|/* Only 48 actually useful */
r_else
r_try
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* Only 24 actually useful */
id|tmp
op_assign
(paren
r_char
op_star
)paren
id|fd_dma_mem_alloc
c_func
(paren
l_int|1024
op_star
r_try
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
op_logical_and
op_logical_neg
id|floppy_track_buffer
)paren
(brace
r_try
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* buffer only one side */
id|INFBOUND
c_func
(paren
r_try
comma
l_int|16
)paren
suffix:semicolon
id|tmp
op_assign
(paren
r_char
op_star
)paren
id|fd_dma_mem_alloc
c_func
(paren
l_int|1024
op_star
r_try
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp
op_logical_and
op_logical_neg
id|floppy_track_buffer
)paren
(brace
id|fallback_on_nodma_alloc
c_func
(paren
op_amp
id|tmp
comma
l_int|2048
op_star
r_try
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp
op_logical_and
op_logical_neg
id|floppy_track_buffer
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;Unable to allocate DMA memory&bslash;n&quot;
)paren
suffix:semicolon
id|RETERR
c_func
(paren
id|ENXIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|floppy_track_buffer
)paren
(brace
r_if
c_cond
(paren
id|tmp
)paren
id|fd_dma_mem_free
c_func
(paren
(paren
r_int
r_int
)paren
id|tmp
comma
r_try
op_star
l_int|1024
)paren
suffix:semicolon
)brace
r_else
(brace
id|buffer_min
op_assign
id|buffer_max
op_assign
op_minus
l_int|1
suffix:semicolon
id|floppy_track_buffer
op_assign
id|tmp
suffix:semicolon
id|max_buffer_sectors
op_assign
r_try
suffix:semicolon
)brace
)brace
id|UDRS-&gt;fd_device
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|old_dev
op_ne
op_minus
l_int|1
op_logical_and
id|old_dev
op_ne
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)paren
(brace
r_if
c_cond
(paren
id|buffer_drive
op_eq
id|drive
)paren
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|MKDEV
c_func
(paren
id|FLOPPY_MAJOR
comma
id|old_dev
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Allow ioctls if we have write-permissions even if read-only open.&n;&t; * Needed so that programs such as fdrawcmd still can work on write&n;&t; * protected disks */
r_if
c_cond
(paren
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
op_logical_or
(paren
id|inode-&gt;i_sb
op_logical_and
(paren
id|permission
c_func
(paren
id|inode
comma
l_int|2
)paren
op_eq
l_int|0
)paren
)paren
)paren
id|filp-&gt;private_data
op_assign
(paren
r_void
op_star
)paren
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|UFDCS-&gt;rawcmd
op_eq
l_int|1
)paren
id|UFDCS-&gt;rawcmd
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NDELAY
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
(brace
id|UDRS-&gt;last_checked
op_assign
l_int|0
suffix:semicolon
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UTESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
)paren
id|RETERR
c_func
(paren
id|ENXIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
op_logical_and
op_logical_neg
(paren
id|UTESTF
c_func
(paren
id|FD_DISK_WRITABLE
)paren
)paren
)paren
id|RETERR
c_func
(paren
id|EROFS
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
DECL|macro|RETERR
macro_line|#undef RETERR
)brace
multiline_comment|/*&n; * Check if the disk has been changed or if a change has been faked.&n; */
DECL|function|check_floppy_change
r_static
r_int
id|check_floppy_change
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
r_int
id|drive
op_assign
id|DRIVE
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
op_ne
id|MAJOR_NR
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;check_floppy_change: not a floppy&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|UTESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
op_logical_or
id|UTESTF
c_func
(paren
id|FD_VERIFY
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|UDP-&gt;checkfreq
OL
(paren
r_int
)paren
(paren
id|jiffies
op_minus
id|UDRS-&gt;last_checked
)paren
)paren
(brace
r_if
c_cond
(paren
id|floppy_grab_irq_and_dma
c_func
(paren
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
id|lock_fdc
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|poll_drive
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
id|floppy_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|UTESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
op_logical_or
id|UTESTF
c_func
(paren
id|FD_VERIFY
)paren
op_logical_or
id|test_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
op_logical_or
(paren
op_logical_neg
id|TYPE
c_func
(paren
id|dev
)paren
op_logical_and
op_logical_neg
id|current_type
(braket
id|drive
)braket
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* revalidate the floppy disk, i.e. trigger format autodetection by reading&n; * the bootblock (block 0). &quot;Autodetection&quot; is also needed to check whether&n; * there is a disk in the drive at all... Thus we also do it for fixed&n; * geometry formats */
DECL|function|floppy_revalidate
r_static
r_int
id|floppy_revalidate
c_func
(paren
id|kdev_t
id|dev
)paren
(brace
DECL|macro|NO_GEOM
mdefine_line|#define NO_GEOM (!current_type[drive] &amp;&amp; !TYPE(dev))
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|drive
op_assign
id|DRIVE
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|cf
suffix:semicolon
r_if
c_cond
(paren
id|UTESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
op_logical_or
id|UTESTF
c_func
(paren
id|FD_VERIFY
)paren
op_logical_or
id|test_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
op_logical_or
id|NO_GEOM
)paren
(brace
r_if
c_cond
(paren
id|usage_count
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;VFS: revalidate called on non-open device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EFAULT
suffix:semicolon
)brace
id|lock_fdc
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|cf
op_assign
id|UTESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
op_logical_or
id|UTESTF
c_func
(paren
id|FD_VERIFY
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cf
op_logical_or
id|test_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
op_logical_or
id|NO_GEOM
)paren
)paren
(brace
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*already done by another thread*/
r_return
l_int|0
suffix:semicolon
)brace
id|UDRS-&gt;maxblock
op_assign
l_int|0
suffix:semicolon
id|UDRS-&gt;maxtrack
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buffer_drive
op_eq
id|drive
)paren
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|clear_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
suffix:semicolon
id|UCLEARF
c_func
(paren
id|FD_DISK_CHANGED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cf
)paren
id|UDRS-&gt;generation
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|NO_GEOM
)paren
(brace
multiline_comment|/* auto-sensing */
r_int
id|size
op_assign
id|floppy_blocksizes
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
id|size
op_assign
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|getblk
c_func
(paren
id|dev
comma
l_int|0
comma
id|size
)paren
)paren
)paren
(brace
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh
op_logical_and
op_logical_neg
id|buffer_uptodate
c_func
(paren
id|bh
)paren
)paren
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cf
)paren
id|poll_drive
c_func
(paren
l_int|0
comma
id|FD_RAW_NEED_DISK
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|floppy_fops
r_static
r_struct
id|block_device_operations
id|floppy_fops
op_assign
(brace
id|open
suffix:colon
id|floppy_open
comma
id|release
suffix:colon
id|floppy_release
comma
id|ioctl
suffix:colon
id|fd_ioctl
comma
id|check_media_change
suffix:colon
id|check_floppy_change
comma
id|revalidate
suffix:colon
id|floppy_revalidate
comma
)brace
suffix:semicolon
DECL|function|register_devfs_entries
r_static
r_void
id|__init
id|register_devfs_entries
(paren
r_int
id|drive
)paren
(brace
r_int
id|base_minor
comma
id|i
suffix:semicolon
r_static
r_char
op_star
id|table
(braket
)braket
op_assign
(brace
l_string|&quot;&quot;
comma
l_string|&quot;d360&quot;
comma
l_string|&quot;h1200&quot;
comma
l_string|&quot;u360&quot;
comma
l_string|&quot;u720&quot;
comma
l_string|&quot;h360&quot;
comma
l_string|&quot;h720&quot;
comma
l_string|&quot;u1440&quot;
comma
l_string|&quot;u2880&quot;
comma
l_string|&quot;CompaQ&quot;
comma
l_string|&quot;h1440&quot;
comma
l_string|&quot;u1680&quot;
comma
l_string|&quot;h410&quot;
comma
l_string|&quot;u820&quot;
comma
l_string|&quot;h1476&quot;
comma
l_string|&quot;u1722&quot;
comma
l_string|&quot;h420&quot;
comma
l_string|&quot;u830&quot;
comma
l_string|&quot;h1494&quot;
comma
l_string|&quot;u1743&quot;
comma
l_string|&quot;h880&quot;
comma
l_string|&quot;u1040&quot;
comma
l_string|&quot;u1120&quot;
comma
l_string|&quot;h1600&quot;
comma
l_string|&quot;u1760&quot;
comma
l_string|&quot;u1920&quot;
comma
l_string|&quot;u3200&quot;
comma
l_string|&quot;u3520&quot;
comma
l_string|&quot;u3840&quot;
comma
l_string|&quot;u1840&quot;
comma
l_string|&quot;u800&quot;
comma
l_string|&quot;u1600&quot;
comma
l_int|NULL
)brace
suffix:semicolon
r_static
r_int
id|t360
(braket
)braket
op_assign
(brace
l_int|1
comma
l_int|0
)brace
comma
id|t1200
(braket
)braket
op_assign
(brace
l_int|2
comma
l_int|5
comma
l_int|6
comma
l_int|10
comma
l_int|12
comma
l_int|14
comma
l_int|16
comma
l_int|18
comma
l_int|20
comma
l_int|23
comma
l_int|0
)brace
comma
id|t3in
(braket
)braket
op_assign
(brace
l_int|8
comma
l_int|9
comma
l_int|26
comma
l_int|27
comma
l_int|28
comma
l_int|7
comma
l_int|11
comma
l_int|15
comma
l_int|19
comma
l_int|24
comma
l_int|25
comma
l_int|29
comma
l_int|31
comma
l_int|3
comma
l_int|4
comma
l_int|13
comma
l_int|17
comma
l_int|21
comma
l_int|22
comma
l_int|30
comma
l_int|0
)brace
suffix:semicolon
r_static
r_int
op_star
id|table_sup
(braket
)braket
op_assign
(brace
l_int|NULL
comma
id|t360
comma
id|t1200
comma
id|t3in
op_plus
l_int|5
op_plus
l_int|8
comma
id|t3in
op_plus
l_int|5
comma
id|t3in
comma
id|t3in
)brace
suffix:semicolon
id|base_minor
op_assign
(paren
id|drive
OL
l_int|4
)paren
ques
c_cond
id|drive
suffix:colon
(paren
l_int|124
op_plus
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UDP-&gt;cmos
op_le
id|NUMBER
c_func
(paren
id|default_drive_params
)paren
)paren
(brace
id|i
op_assign
l_int|0
suffix:semicolon
r_do
(brace
r_char
id|name
(braket
l_int|16
)braket
suffix:semicolon
id|sprintf
(paren
id|name
comma
l_string|&quot;%d%s&quot;
comma
id|drive
comma
id|table
(braket
id|table_sup
(braket
id|UDP-&gt;cmos
)braket
(braket
id|i
)braket
)braket
)paren
suffix:semicolon
id|devfs_register
(paren
id|devfs_handle
comma
id|name
comma
id|DEVFS_FL_DEFAULT
comma
id|MAJOR_NR
comma
id|base_minor
op_plus
(paren
id|table_sup
(braket
id|UDP-&gt;cmos
)braket
(braket
id|i
)braket
op_lshift
l_int|2
)paren
comma
id|S_IFBLK
op_or
id|S_IRUSR
op_or
id|S_IWUSR
op_or
id|S_IRGRP
op_or
id|S_IWGRP
comma
op_amp
id|floppy_fops
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|table_sup
(braket
id|UDP-&gt;cmos
)braket
(braket
id|i
op_increment
)braket
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Floppy Driver initialization&n; * =============================&n; */
multiline_comment|/* Determine the floppy disk controller type */
multiline_comment|/* This routine was written by David C. Niemi */
DECL|function|get_fdc_version
r_static
r_char
id|__init
id|get_fdc_version
c_func
(paren
r_void
)paren
(brace
r_int
id|r
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_DUMPREGS
)paren
suffix:semicolon
multiline_comment|/* 82072 and better know DUMPREGS */
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
r_return
id|FDC_NONE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_assign
id|result
c_func
(paren
)paren
)paren
op_le
l_int|0x00
)paren
r_return
id|FDC_NONE
suffix:semicolon
multiline_comment|/* No FDC present ??? */
r_if
c_cond
(paren
(paren
id|r
op_eq
l_int|1
)paren
op_logical_and
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FDC %d is an 8272A&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_8272A
suffix:semicolon
multiline_comment|/* 8272a/765 don&squot;t know DUMPREGS */
)brace
r_if
c_cond
(paren
id|r
op_ne
l_int|10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC %d init: DUMPREGS: unexpected return of %d bytes.&bslash;n&quot;
comma
id|fdc
comma
id|r
)paren
suffix:semicolon
r_return
id|FDC_UNKNOWN
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|fdc_configure
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FDC %d is an 82072&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_82072
suffix:semicolon
multiline_comment|/* 82072 doesn&squot;t know CONFIGURE */
)brace
id|output_byte
c_func
(paren
id|FD_PERPENDICULAR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|need_more_output
c_func
(paren
)paren
op_eq
id|MORE_OUTPUT
)paren
(brace
id|output_byte
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FDC %d is an 82072A&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_82072A
suffix:semicolon
multiline_comment|/* 82072A as found on Sparcs. */
)brace
id|output_byte
c_func
(paren
id|FD_UNLOCK
)paren
suffix:semicolon
id|r
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_eq
l_int|1
)paren
op_logical_and
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FDC %d is a pre-1991 82077&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_82077_ORIG
suffix:semicolon
multiline_comment|/* Pre-1991 82077, doesn&squot;t know &n;&t;&t;&t;&t;&t; * LOCK/UNLOCK */
)brace
r_if
c_cond
(paren
(paren
id|r
op_ne
l_int|1
)paren
op_logical_or
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_ne
l_int|0x00
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC %d init: UNLOCK: unexpected return of %d bytes.&bslash;n&quot;
comma
id|fdc
comma
id|r
)paren
suffix:semicolon
r_return
id|FDC_UNKNOWN
suffix:semicolon
)brace
id|output_byte
c_func
(paren
id|FD_PARTID
)paren
suffix:semicolon
id|r
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC %d init: PARTID: unexpected return of %d bytes.&bslash;n&quot;
comma
id|fdc
comma
id|r
)paren
suffix:semicolon
r_return
id|FDC_UNKNOWN
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FDC %d is a post-1991 82077&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_82077
suffix:semicolon
multiline_comment|/* Revised 82077AA passes all the tests */
)brace
r_switch
c_cond
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
(brace
r_case
l_int|0x0
suffix:colon
multiline_comment|/* Either a 82078-1 or a 82078SL running at 5Volt */
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FDC %d is an 82078.&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_82078
suffix:semicolon
r_case
l_int|0x1
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FDC %d is a 44pin 82078&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_82078
suffix:semicolon
r_case
l_int|0x2
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FDC %d is a S82078B&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_S82078B
suffix:semicolon
r_case
l_int|0x3
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FDC %d is a National Semiconductor PC87306&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_87306
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;FDC %d init: 82078 variant with unknown PARTID=%d.&bslash;n&quot;
comma
id|fdc
comma
id|reply_buffer
(braket
l_int|0
)braket
op_rshift
l_int|5
)paren
suffix:semicolon
r_return
id|FDC_82078_UNKN
suffix:semicolon
)brace
)brace
multiline_comment|/* get_fdc_version */
multiline_comment|/* lilo configuration */
DECL|function|floppy_set_flags
r_static
r_void
id|__init
id|floppy_set_flags
c_func
(paren
r_int
op_star
id|ints
comma
r_int
id|param
comma
r_int
id|param2
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|default_drive_params
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|param
)paren
id|default_drive_params
(braket
id|i
)braket
dot
id|params.flags
op_or_assign
id|param2
suffix:semicolon
r_else
id|default_drive_params
(braket
id|i
)braket
dot
id|params.flags
op_and_assign
op_complement
id|param2
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
l_string|&quot;%s flag 0x%x&bslash;n&quot;
comma
id|param2
ques
c_cond
l_string|&quot;Setting&quot;
suffix:colon
l_string|&quot;Clearing&quot;
comma
id|param
)paren
suffix:semicolon
)brace
DECL|function|daring
r_static
r_void
id|__init
id|daring
c_func
(paren
r_int
op_star
id|ints
comma
r_int
id|param
comma
r_int
id|param2
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|default_drive_params
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|param
)paren
(brace
id|default_drive_params
(braket
id|i
)braket
dot
id|params.select_delay
op_assign
l_int|0
suffix:semicolon
id|default_drive_params
(braket
id|i
)braket
dot
id|params.flags
op_or_assign
id|FD_SILENT_DCL_CLEAR
suffix:semicolon
)brace
r_else
(brace
id|default_drive_params
(braket
id|i
)braket
dot
id|params.select_delay
op_assign
l_int|2
op_star
id|HZ
op_div
l_int|100
suffix:semicolon
id|default_drive_params
(braket
id|i
)braket
dot
id|params.flags
op_and_assign
op_complement
id|FD_SILENT_DCL_CLEAR
suffix:semicolon
)brace
)brace
id|DPRINT
c_func
(paren
l_string|&quot;Assuming %s floppy hardware&bslash;n&quot;
comma
id|param
ques
c_cond
l_string|&quot;standard&quot;
suffix:colon
l_string|&quot;broken&quot;
)paren
suffix:semicolon
)brace
DECL|function|set_cmos
r_static
r_void
id|__init
id|set_cmos
c_func
(paren
r_int
op_star
id|ints
comma
r_int
id|dummy
comma
r_int
id|dummy2
)paren
(brace
r_int
id|current_drive
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|2
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;wrong number of parameters for CMOS&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|current_drive
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|current_drive
OL
l_int|0
op_logical_or
id|current_drive
op_ge
l_int|8
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;bad drive for set_cmos&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current_drive
op_ge
l_int|4
op_logical_and
op_logical_neg
id|FDC2
)paren
id|FDC2
op_assign
l_int|0x370
suffix:semicolon
id|DP-&gt;cmos
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;setting CMOS code to %d&bslash;n&quot;
comma
id|ints
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
DECL|struct|param_table
r_static
r_struct
id|param_table
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|fn
r_void
(paren
op_star
id|fn
)paren
(paren
r_int
op_star
id|ints
comma
r_int
id|param
comma
r_int
id|param2
)paren
suffix:semicolon
DECL|member|var
r_int
op_star
id|var
suffix:semicolon
DECL|member|def_param
r_int
id|def_param
suffix:semicolon
DECL|member|param2
r_int
id|param2
suffix:semicolon
DECL|variable|config_params
)brace
id|config_params
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|function|floppy_setup
r_static
r_int
id|__init
id|floppy_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|param
suffix:semicolon
r_int
id|ints
(braket
l_int|11
)braket
suffix:semicolon
id|str
op_assign
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_if
c_cond
(paren
id|str
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|config_params
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|str
comma
id|config_params
(braket
id|i
)braket
dot
id|name
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
)paren
id|param
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|param
op_assign
id|config_params
(braket
id|i
)braket
dot
id|def_param
suffix:semicolon
r_if
c_cond
(paren
id|config_params
(braket
id|i
)braket
dot
id|fn
)paren
id|config_params
(braket
id|i
)braket
dot
id|fn
c_func
(paren
id|ints
comma
id|param
comma
id|config_params
(braket
id|i
)braket
dot
id|param2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|config_params
(braket
id|i
)braket
dot
id|var
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;%s=%d&bslash;n&quot;
comma
id|str
comma
id|param
)paren
suffix:semicolon
op_star
id|config_params
(braket
id|i
)braket
dot
id|var
op_assign
id|param
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
id|str
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;unknown floppy option [%s]&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;allowed options are:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|config_params
)paren
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot; %s&quot;
comma
id|config_params
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
id|DPRINT
c_func
(paren
l_string|&quot;botched floppy option&bslash;n&quot;
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;Read linux/Documentation/floppy.txt&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|have_no_fdc
r_static
r_int
id|have_no_fdc
op_assign
op_minus
id|EIO
suffix:semicolon
DECL|function|floppy_init
r_int
id|__init
id|floppy_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|unit
comma
id|drive
suffix:semicolon
id|raw_cmd
op_assign
l_int|NULL
suffix:semicolon
id|devfs_handle
op_assign
id|devfs_mk_dir
(paren
l_int|NULL
comma
l_string|&quot;floppy&quot;
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
comma
op_amp
id|floppy_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major %d for floppy&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|ITYPE
c_func
(paren
id|i
)paren
)paren
id|floppy_sizes
(braket
id|i
)braket
op_assign
(paren
id|floppy_type
(braket
id|ITYPE
c_func
(paren
id|i
)paren
)braket
dot
id|size
op_plus
l_int|1
)paren
op_rshift
l_int|1
suffix:semicolon
r_else
id|floppy_sizes
(braket
id|i
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|floppy_sizes
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|floppy_blocksizes
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|DEVICE_REQUEST
)paren
suffix:semicolon
id|reschedule_timeout
c_func
(paren
id|MAXTIMEOUT
comma
l_string|&quot;floppy init&quot;
comma
id|MAXTIMEOUT
)paren
suffix:semicolon
id|config_types
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_FDC
suffix:semicolon
id|i
op_increment
)paren
(brace
id|fdc
op_assign
id|i
suffix:semicolon
id|CLEARSTRUCT
c_func
(paren
id|FDCS
)paren
suffix:semicolon
id|FDCS-&gt;dtr
op_assign
op_minus
l_int|1
suffix:semicolon
id|FDCS-&gt;dor
op_assign
l_int|0x4
suffix:semicolon
macro_line|#ifdef __sparc__
multiline_comment|/*sparcs don&squot;t have a DOR reset which we can fall back on to*/
id|FDCS-&gt;version
op_assign
id|FDC_82072A
suffix:semicolon
macro_line|#endif
)brace
id|use_virtual_dma
op_assign
id|can_use_virtual_dma
op_amp
l_int|1
suffix:semicolon
id|fdc_state
(braket
l_int|0
)braket
dot
id|address
op_assign
id|FDC1
suffix:semicolon
r_if
c_cond
(paren
id|fdc_state
(braket
l_int|0
)braket
dot
id|address
op_eq
op_minus
l_int|1
)paren
(brace
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|fd_timeout
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#if N_FDC &gt; 1
id|fdc_state
(braket
l_int|1
)braket
dot
id|address
op_assign
id|FDC2
suffix:semicolon
macro_line|#endif
id|fdc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* reset fdc in case of unexpected interrupt */
r_if
c_cond
(paren
id|floppy_grab_irq_and_dma
c_func
(paren
)paren
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|fd_timeout
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|fd_timeout
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* initialise drive state */
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|N_DRIVE
suffix:semicolon
id|drive
op_increment
)paren
(brace
id|CLEARSTRUCT
c_func
(paren
id|UDRS
)paren
suffix:semicolon
id|CLEARSTRUCT
c_func
(paren
id|UDRWE
)paren
suffix:semicolon
id|USETF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
suffix:semicolon
id|USETF
c_func
(paren
id|FD_DISK_CHANGED
)paren
suffix:semicolon
id|USETF
c_func
(paren
id|FD_VERIFY
)paren
suffix:semicolon
id|UDRS-&gt;fd_device
op_assign
op_minus
l_int|1
suffix:semicolon
id|floppy_track_buffer
op_assign
l_int|NULL
suffix:semicolon
id|max_buffer_sectors
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_FDC
suffix:semicolon
id|i
op_increment
)paren
(brace
id|fdc
op_assign
id|i
suffix:semicolon
id|FDCS-&gt;driver_version
op_assign
id|FD_DRIVER_VERSION
suffix:semicolon
r_for
c_loop
(paren
id|unit
op_assign
l_int|0
suffix:semicolon
id|unit
OL
l_int|4
suffix:semicolon
id|unit
op_increment
)paren
id|FDCS-&gt;track
(braket
id|unit
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;address
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
id|FDCS-&gt;rawcmd
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|user_reset_fdc
c_func
(paren
op_minus
l_int|1
comma
id|FD_RESET_ALWAYS
comma
l_int|0
)paren
)paren
(brace
multiline_comment|/* free ioports reserved by floppy_grab_irq_and_dma() */
id|release_region
c_func
(paren
id|FDCS-&gt;address
comma
l_int|6
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|FDCS-&gt;address
op_plus
l_int|7
comma
l_int|1
)paren
suffix:semicolon
id|FDCS-&gt;address
op_assign
op_minus
l_int|1
suffix:semicolon
id|FDCS-&gt;version
op_assign
id|FDC_NONE
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Try to determine the floppy controller type */
id|FDCS-&gt;version
op_assign
id|get_fdc_version
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;version
op_eq
id|FDC_NONE
)paren
(brace
multiline_comment|/* free ioports reserved by floppy_grab_irq_and_dma() */
id|release_region
c_func
(paren
id|FDCS-&gt;address
comma
l_int|6
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|FDCS-&gt;address
op_plus
l_int|7
comma
l_int|1
)paren
suffix:semicolon
id|FDCS-&gt;address
op_assign
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|can_use_virtual_dma
op_eq
l_int|2
op_logical_and
id|FDCS-&gt;version
OL
id|FDC_82072A
)paren
id|can_use_virtual_dma
op_assign
l_int|0
suffix:semicolon
id|have_no_fdc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Not all FDCs seem to be able to handle the version command&n;&t;&t; * properly, so force a reset for the standard FDC clones,&n;&t;&t; * to avoid interrupt garbage.&n;&t;&t; */
id|user_reset_fdc
c_func
(paren
op_minus
l_int|1
comma
id|FD_RESET_ALWAYS
comma
l_int|0
)paren
suffix:semicolon
)brace
id|fdc
op_assign
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|fd_timeout
)paren
suffix:semicolon
id|current_drive
op_assign
l_int|0
suffix:semicolon
id|floppy_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
id|initialising
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|have_no_fdc
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;no floppy controllers found&bslash;n&quot;
)paren
suffix:semicolon
id|floppy_tq.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|empty
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usage_count
)paren
id|floppy_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
)brace
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|N_DRIVE
suffix:semicolon
id|drive
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|allowed_drive_mask
op_amp
(paren
l_int|1
op_lshift
id|drive
)paren
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|fdc_state
(braket
id|FDC
c_func
(paren
id|drive
)paren
)braket
dot
id|version
op_eq
id|FDC_NONE
)paren
r_continue
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUMBER
c_func
(paren
id|floppy_type
)paren
suffix:semicolon
id|i
op_increment
)paren
id|register_disk
c_func
(paren
l_int|NULL
comma
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
id|TOMINOR
c_func
(paren
id|drive
)paren
op_plus
id|i
op_star
l_int|4
)paren
comma
l_int|1
comma
op_amp
id|floppy_fops
comma
l_int|0
)paren
suffix:semicolon
)brace
r_return
id|have_no_fdc
suffix:semicolon
)brace
DECL|variable|floppy_usage_lock
r_static
id|spinlock_t
id|floppy_usage_lock
op_assign
id|SPIN_LOCK_UNLOCKED
suffix:semicolon
DECL|function|floppy_grab_irq_and_dma
r_static
r_int
id|floppy_grab_irq_and_dma
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|floppy_usage_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usage_count
op_increment
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|floppy_usage_lock
comma
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|floppy_usage_lock
comma
id|flags
)paren
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|fd_request_irq
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;Unable to grab IRQ%d for the floppy driver&bslash;n&quot;
comma
id|FLOPPY_IRQ
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|floppy_usage_lock
comma
id|flags
)paren
suffix:semicolon
id|usage_count
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|floppy_usage_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fd_request_dma
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;Unable to grab DMA%d for the floppy driver&bslash;n&quot;
comma
id|FLOPPY_DMA
)paren
suffix:semicolon
id|fd_free_irq
c_func
(paren
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|floppy_usage_lock
comma
id|flags
)paren
suffix:semicolon
id|usage_count
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|floppy_usage_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|fdc
op_assign
l_int|0
suffix:semicolon
id|fdc
OL
id|N_FDC
suffix:semicolon
id|fdc
op_increment
)paren
(brace
r_if
c_cond
(paren
id|FDCS-&gt;address
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|FDCS-&gt;address
comma
l_int|6
comma
l_string|&quot;floppy&quot;
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;Floppy io-port 0x%04lx in use&bslash;n&quot;
comma
id|FDCS-&gt;address
)paren
suffix:semicolon
r_goto
id|cleanup1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|request_region
c_func
(paren
id|FDCS-&gt;address
op_plus
l_int|7
comma
l_int|1
comma
l_string|&quot;floppy DIR&quot;
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;Floppy io-port 0x%04lx in use&bslash;n&quot;
comma
id|FDCS-&gt;address
op_plus
l_int|7
)paren
suffix:semicolon
r_goto
id|cleanup2
suffix:semicolon
)brace
multiline_comment|/* address + 6 is reserved, and may be taken by IDE.&n;&t;&t;&t; * Unfortunately, Adaptec doesn&squot;t know this :-(, */
)brace
)brace
r_for
c_loop
(paren
id|fdc
op_assign
l_int|0
suffix:semicolon
id|fdc
OL
id|N_FDC
suffix:semicolon
id|fdc
op_increment
)paren
(brace
r_if
c_cond
(paren
id|FDCS-&gt;address
op_ne
op_minus
l_int|1
)paren
(brace
id|reset_fdc_info
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|fd_outb
c_func
(paren
id|FDCS-&gt;dor
comma
id|FD_DOR
)paren
suffix:semicolon
)brace
)brace
id|fdc
op_assign
l_int|0
suffix:semicolon
id|set_dor
c_func
(paren
l_int|0
comma
op_complement
l_int|0
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* avoid immediate interrupt */
r_for
c_loop
(paren
id|fdc
op_assign
l_int|0
suffix:semicolon
id|fdc
OL
id|N_FDC
suffix:semicolon
id|fdc
op_increment
)paren
r_if
c_cond
(paren
id|FDCS-&gt;address
op_ne
op_minus
l_int|1
)paren
id|fd_outb
c_func
(paren
id|FDCS-&gt;dor
comma
id|FD_DOR
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *&t;The driver will try and free resources and relies on us&n;&t; *&t;to know if they were allocated or not.&n;&t; */
id|fdc
op_assign
l_int|0
suffix:semicolon
id|irqdma_allocated
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|cleanup2
suffix:colon
id|release_region
c_func
(paren
id|FDCS-&gt;address
comma
l_int|6
)paren
suffix:semicolon
id|cleanup1
suffix:colon
id|fd_free_irq
c_func
(paren
)paren
suffix:semicolon
id|fd_free_dma
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|fdc
op_ge
l_int|0
)paren
(brace
id|release_region
c_func
(paren
id|FDCS-&gt;address
comma
l_int|6
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|FDCS-&gt;address
op_plus
l_int|7
comma
l_int|1
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|floppy_usage_lock
comma
id|flags
)paren
suffix:semicolon
id|usage_count
op_decrement
suffix:semicolon
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|floppy_usage_lock
comma
id|flags
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|floppy_release_irq_and_dma
r_static
r_void
id|floppy_release_irq_and_dma
c_func
(paren
r_void
)paren
(brace
r_int
id|old_fdc
suffix:semicolon
macro_line|#ifdef FLOPPY_SANITY_CHECK
macro_line|#ifndef __sparc__
r_int
id|drive
suffix:semicolon
macro_line|#endif
macro_line|#endif
r_int
id|tmpsize
suffix:semicolon
r_int
r_int
id|tmpaddr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|spin_lock_irqsave
c_func
(paren
op_amp
id|floppy_usage_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|usage_count
)paren
(brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|floppy_usage_lock
comma
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|spin_unlock_irqrestore
c_func
(paren
op_amp
id|floppy_usage_lock
comma
id|flags
)paren
suffix:semicolon
r_if
c_cond
(paren
id|irqdma_allocated
)paren
(brace
id|fd_disable_dma
c_func
(paren
)paren
suffix:semicolon
id|fd_free_dma
c_func
(paren
)paren
suffix:semicolon
id|fd_free_irq
c_func
(paren
)paren
suffix:semicolon
id|irqdma_allocated
op_assign
l_int|0
suffix:semicolon
)brace
id|set_dor
c_func
(paren
l_int|0
comma
op_complement
l_int|0
comma
l_int|8
)paren
suffix:semicolon
macro_line|#if N_FDC &gt; 1
id|set_dor
c_func
(paren
l_int|1
comma
op_complement
l_int|8
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|floppy_enable_hlt
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|floppy_track_buffer
op_logical_and
id|max_buffer_sectors
)paren
(brace
id|tmpsize
op_assign
id|max_buffer_sectors
op_star
l_int|1024
suffix:semicolon
id|tmpaddr
op_assign
(paren
r_int
r_int
)paren
id|floppy_track_buffer
suffix:semicolon
id|floppy_track_buffer
op_assign
l_int|NULL
suffix:semicolon
id|max_buffer_sectors
op_assign
l_int|0
suffix:semicolon
id|buffer_min
op_assign
id|buffer_max
op_assign
op_minus
l_int|1
suffix:semicolon
id|fd_dma_mem_free
c_func
(paren
id|tmpaddr
comma
id|tmpsize
)paren
suffix:semicolon
)brace
macro_line|#ifdef FLOPPY_SANITY_CHECK
macro_line|#ifndef __sparc__
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|N_FDC
op_star
l_int|4
suffix:semicolon
id|drive
op_increment
)paren
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
id|motor_off_timer
op_plus
id|drive
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;motor off timer %d still active&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|fd_timeout
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;floppy timer still active:%s&bslash;n&quot;
comma
id|timeout_message
)paren
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|fd_timer
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;auxiliary floppy timer still active&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|floppy_tq.sync
)paren
id|printk
c_func
(paren
l_string|&quot;task queue still active&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|old_fdc
op_assign
id|fdc
suffix:semicolon
r_for
c_loop
(paren
id|fdc
op_assign
l_int|0
suffix:semicolon
id|fdc
OL
id|N_FDC
suffix:semicolon
id|fdc
op_increment
)paren
r_if
c_cond
(paren
id|FDCS-&gt;address
op_ne
op_minus
l_int|1
)paren
(brace
id|release_region
c_func
(paren
id|FDCS-&gt;address
comma
l_int|6
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|FDCS-&gt;address
op_plus
l_int|7
comma
l_int|1
)paren
suffix:semicolon
)brace
id|fdc
op_assign
id|old_fdc
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|floppy
r_char
op_star
id|floppy
suffix:semicolon
DECL|function|parse_floppy_cfg_string
r_static
r_void
id|__init
id|parse_floppy_cfg_string
c_func
(paren
r_char
op_star
id|cfg
)paren
(brace
r_char
op_star
id|ptr
suffix:semicolon
r_while
c_loop
(paren
op_star
id|cfg
)paren
(brace
r_for
c_loop
(paren
id|ptr
op_assign
id|cfg
suffix:semicolon
op_star
id|cfg
op_logical_and
op_star
id|cfg
op_ne
l_char|&squot; &squot;
op_logical_and
op_star
id|cfg
op_ne
l_char|&squot;&bslash;t&squot;
suffix:semicolon
id|cfg
op_increment
)paren
(brace
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|cfg
)paren
(brace
op_star
id|cfg
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
id|cfg
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_star
id|ptr
)paren
id|floppy_setup
c_func
(paren
id|ptr
)paren
suffix:semicolon
)brace
)brace
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;inserting floppy driver for &quot;
id|UTS_RELEASE
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|floppy
)paren
id|parse_floppy_cfg_string
c_func
(paren
id|floppy
)paren
suffix:semicolon
r_return
id|floppy_init
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|dummy
suffix:semicolon
id|devfs_unregister
(paren
id|devfs_handle
)paren
suffix:semicolon
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
multiline_comment|/* eject disk, if any */
id|dummy
op_assign
id|fd_eject
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|MODULE_PARM
c_func
(paren
id|floppy
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|FLOPPY_IRQ
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|FLOPPY_DMA
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Alain L. Knaff&quot;
)paren
suffix:semicolon
id|MODULE_SUPPORTED_DEVICE
c_func
(paren
l_string|&quot;fd&quot;
)paren
suffix:semicolon
macro_line|#else
id|__setup
(paren
l_string|&quot;floppy=&quot;
comma
id|floppy_setup
)paren
suffix:semicolon
multiline_comment|/* eject the boot floppy (if we need the drive for a different root floppy) */
multiline_comment|/* This should only be called at boot time when we&squot;re sure that there&squot;s no&n; * resource contention. */
DECL|function|floppy_eject
r_void
id|floppy_eject
c_func
(paren
r_void
)paren
(brace
r_int
id|dummy
suffix:semicolon
r_if
c_cond
(paren
id|have_no_fdc
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|floppy_grab_irq_and_dma
c_func
(paren
)paren
op_eq
l_int|0
)paren
(brace
id|lock_fdc
c_func
(paren
id|MAXTIMEOUT
comma
l_int|0
)paren
suffix:semicolon
id|dummy
op_assign
id|fd_eject
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
id|floppy_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
eof
