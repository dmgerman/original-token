multiline_comment|/*&n; *  linux/kernel/floppy.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; *  Copyright (C) 1993, 1994  Alain Knaff&n; */
multiline_comment|/*&n; * 02.12.91 - Changed to static variables to indicate need for reset&n; * and recalibrate. This makes some things easier (output_byte reset&n; * checking etc), and means less interrupt jumping in case of errors,&n; * so the code is hopefully easier to understand.&n; */
multiline_comment|/*&n; * This file is certainly a mess. I&squot;ve tried my best to get it working,&n; * but I don&squot;t like programming floppies, and I have only one anyway.&n; * Urgel. I should check for more errors, and do more graceful error&n; * recovery. Seems there are problems with several drives. I&squot;ve tried to&n; * correct them. No promises.&n; */
multiline_comment|/*&n; * As with hd.c, all routines within this file can (and will) be called&n; * by interrupts, so extreme caution is needed. A hardware interrupt&n; * handler may not sleep, or a kernel panic will happen. Thus I cannot&n; * call &quot;floppy-on&quot; directly, but have to set a special timer interrupt&n; * etc.&n; */
multiline_comment|/*&n; * 28.02.92 - made track-buffering routines, based on the routines written&n; * by entropy@wintermute.wpi.edu (Lawrence Foard). Linus.&n; */
multiline_comment|/*&n; * Automatic floppy-detection and formatting written by Werner Almesberger&n; * (almesber@nessie.cs.id.ethz.ch), who also corrected some problems with&n; * the floppy-change signal detection.&n; */
multiline_comment|/*&n; * 1992/7/22 -- Hennus Bergman: Added better error reporting, fixed&n; * FDC data overrun bug, added some preliminary stuff for vertical&n; * recording support.&n; *&n; * 1992/9/17: Added DMA allocation &amp; DMA functions. -- hhb.&n; *&n; * TODO: Errors are still not counted properly.&n; */
multiline_comment|/* 1992/9/20&n; * Modifications for ``Sector Shifting&squot;&squot; by Rob Hooft (hooft@chem.ruu.nl)&n; * modelled after the freeware MS/DOS program fdformat/88 V1.8 by&n; * Christoph H. Hochst&bslash;&quot;atter.&n; * I have fixed the shift values to the ones I always use. Maybe a new&n; * ioctl() should be created to be able to modify them.&n; * There is a bug in the driver that makes it impossible to format a&n; * floppy as the first thing after bootup.&n; */
multiline_comment|/*&n; * 1993/4/29 -- Linus -- cleaned up the timer handling in the kernel, and&n; * this helped the floppy driver as well. Much cleaner, and still seems to&n; * work.&n; */
multiline_comment|/* 1994/6/24 --bbroad-- added the floppy table entries and made&n; * minor modifications to allow 2.88 floppies to be run.&n; */
multiline_comment|/* 1994/7/13 -- Paul Vojta -- modified the probing code to allow three or more&n; * disk types.&n; */
multiline_comment|/*&n; * 1994/8/8 -- Alain Knaff -- Switched to fdpatch driver: Support for bigger&n; * format bug fixes, but unfortunately some new bugs too...&n; */
multiline_comment|/* 1994/9/17 -- Koen Holtman -- added logging of physical floppy write &n; * errors to allow safe writing by specialized programs.&n; */
multiline_comment|/* 1994/4/24 -- Dan Fandrich -- added support for Commodore 1581 3.5&quot; disks&n; * by defining bit 1 of the &quot;stretch&quot; parameter to mean put sectors on the&n; * opposite side of the disk, leaving the sector IDs alone (i.e. Commodore&squot;s&n; * drives are &quot;upside-down&quot;).&n; */
DECL|macro|CONFIG_FLOPPY_SANITY
mdefine_line|#define CONFIG_FLOPPY_SANITY
DECL|macro|CONFIG_FLOPPY_SILENT_DCL_CLEAR
macro_line|#undef  CONFIG_FLOPPY_SILENT_DCL_CLEAR
DECL|macro|REALLY_SLOW_IO
mdefine_line|#define REALLY_SLOW_IO
DECL|macro|DEBUGT
mdefine_line|#define DEBUGT 2
DECL|macro|DCL_DEBUG
mdefine_line|#define DCL_DEBUG /* debug disk change line */
macro_line|#include &lt;linux/config.h&gt;
multiline_comment|/* do print messages for unexpected interrupts */
DECL|variable|print_unex
r_static
r_int
id|print_unex
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef MODULE
DECL|macro|FD_MODULE
mdefine_line|#define FD_MODULE
macro_line|#include &lt;linux/module.h&gt;
multiline_comment|/*&n; * NB. we must include the kernel idenfication string in to install the module.&n; */
macro_line|#include &lt;linux/version.h&gt;
DECL|variable|kernel_version
r_char
id|kernel_version
(braket
)braket
op_assign
id|UTS_RELEASE
suffix:semicolon
DECL|variable|FLOPPY_IRQ
r_int
id|FLOPPY_IRQ
op_assign
l_int|6
suffix:semicolon
DECL|variable|FLOPPY_DMA
r_int
id|FLOPPY_DMA
op_assign
l_int|2
suffix:semicolon
DECL|variable|ALLOWED_DRIVE_MASK
r_int
id|ALLOWED_DRIVE_MASK
op_assign
l_int|0x33
suffix:semicolon
DECL|variable|FDC1
r_int
id|FDC1
op_assign
l_int|0x3f0
suffix:semicolon
DECL|variable|FDC2
r_int
id|FDC2
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
macro_line|#ifndef FD_MODULE
multiline_comment|/* the following is the mask of allowed drives. By default units 2 and&n; * 3 of both floppy controllers are disabled, because switching on the&n; * motor of these drives causes system hangs on some PCI computers. drive&n; * 0 is the low bit (0x1), and drive 7 is the high bit (0x80). Bits are on if&n; * a drive is allowed. */
DECL|variable|ALLOWED_DRIVE_MASK
r_static
r_int
id|ALLOWED_DRIVE_MASK
op_assign
l_int|0x33
suffix:semicolon
DECL|macro|FLOPPY_IRQ
mdefine_line|#define FLOPPY_IRQ 6
DECL|macro|FLOPPY_DMA
mdefine_line|#define FLOPPY_DMA 2
DECL|macro|FDC1
mdefine_line|#define FDC1 0x3f0
DECL|variable|FDC2
r_static
r_int
id|FDC2
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
DECL|macro|MODULE_AWARE_DRIVER
mdefine_line|#define MODULE_AWARE_DRIVER
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
DECL|macro|FDPATCHES
mdefine_line|#define FDPATCHES
macro_line|#include &lt;linux/fdreg.h&gt;
macro_line|#include &lt;linux/fd.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/mc146818rtc.h&gt; /* CMOS defines */
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR FLOPPY_MAJOR
macro_line|#include &quot;blk.h&quot;
multiline_comment|/* Dma Memory related stuff */
multiline_comment|/* Pure 2^n version of get_order */
DECL|function|__get_order
r_static
r_inline
r_int
id|__get_order
(paren
r_int
id|size
)paren
(brace
r_int
id|order
suffix:semicolon
macro_line|#ifdef  _ASM_IO_H2
id|__asm__
id|__volatile__
c_func
(paren
l_string|&quot;bsr %1,%0&quot;
suffix:colon
l_string|&quot;=r&quot;
(paren
id|order
)paren
suffix:colon
l_string|&quot;r&quot;
(paren
id|size
op_div
id|PAGE_SIZE
)paren
)paren
suffix:semicolon
macro_line|#else
r_for
c_loop
(paren
id|order
op_assign
l_int|0
suffix:semicolon
id|order
OL
id|NR_MEM_LISTS
suffix:semicolon
op_increment
id|order
)paren
r_if
c_cond
(paren
id|size
op_le
(paren
id|PAGE_SIZE
op_lshift
id|order
)paren
)paren
r_return
id|order
suffix:semicolon
macro_line|#endif
r_return
id|NR_MEM_LISTS
suffix:semicolon
)brace
DECL|function|dma_mem_alloc
r_static
r_int
r_int
id|dma_mem_alloc
c_func
(paren
r_int
id|size
)paren
(brace
r_int
id|order
op_assign
id|__get_order
c_func
(paren
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|order
op_ge
id|NR_MEM_LISTS
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|__get_dma_pages
c_func
(paren
id|GFP_KERNEL
comma
id|order
)paren
suffix:semicolon
)brace
multiline_comment|/* End dma memory related stuff */
DECL|variable|fake_change
r_static
r_int
r_int
id|fake_change
op_assign
l_int|0
suffix:semicolon
DECL|variable|initialising
r_static
r_int
id|initialising
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n; * Again, the CMOS information doesn&squot;t work on the alpha..&n; */
macro_line|#ifdef __alpha__
DECL|macro|FLOPPY0_TYPE
mdefine_line|#define FLOPPY0_TYPE 6
DECL|macro|FLOPPY1_TYPE
mdefine_line|#define FLOPPY1_TYPE 0
macro_line|#else
DECL|macro|FLOPPY0_TYPE
mdefine_line|#define FLOPPY0_TYPE&t;((CMOS_READ(0x10) &gt;&gt; 4) &amp; 15)
DECL|macro|FLOPPY1_TYPE
mdefine_line|#define FLOPPY1_TYPE&t;(CMOS_READ(0x10) &amp; 15)
macro_line|#endif
DECL|macro|N_FDC
mdefine_line|#define N_FDC 2
DECL|macro|N_DRIVE
mdefine_line|#define N_DRIVE 8
DECL|macro|TYPE
mdefine_line|#define TYPE(x) ( ((x)&gt;&gt;2) &amp; 0x1f )
DECL|macro|DRIVE
mdefine_line|#define DRIVE(x) ( ((x)&amp;0x03) | (((x)&amp;0x80 ) &gt;&gt; 5))
DECL|macro|UNIT
mdefine_line|#define UNIT(x) ( (x) &amp; 0x03 )&t;&t;/* drive on fdc */
DECL|macro|FDC
mdefine_line|#define FDC(x) ( ((x) &amp; 0x04) &gt;&gt; 2 )  /* fdc of drive */
DECL|macro|REVDRIVE
mdefine_line|#define REVDRIVE(fdc, unit) ( (unit) + ((fdc) &lt;&lt; 2 ))
multiline_comment|/* reverse mapping from unit and fdc to drive */
DECL|macro|DP
mdefine_line|#define DP (&amp;drive_params[current_drive])
DECL|macro|DRS
mdefine_line|#define DRS (&amp;drive_state[current_drive])
DECL|macro|DRWE
mdefine_line|#define DRWE (&amp;write_errors[current_drive])
DECL|macro|FDCS
mdefine_line|#define FDCS (&amp;fdc_state[fdc])
DECL|macro|CLEARF
mdefine_line|#define CLEARF(x) (clear_bit(x##_BIT, &amp;DRS-&gt;flags))
DECL|macro|SETF
mdefine_line|#define SETF(x) (set_bit(x##_BIT, &amp;DRS-&gt;flags))
DECL|macro|TESTF
mdefine_line|#define TESTF(x) (test_bit(x##_BIT, &amp;DRS-&gt;flags))
DECL|macro|UDP
mdefine_line|#define UDP (&amp;drive_params[drive])
DECL|macro|UDRS
mdefine_line|#define UDRS (&amp;drive_state[drive])
DECL|macro|UDRWE
mdefine_line|#define UDRWE (&amp;write_errors[drive])
DECL|macro|UFDCS
mdefine_line|#define UFDCS (&amp;fdc_state[FDC(drive)])
DECL|macro|UCLEARF
mdefine_line|#define UCLEARF(x) (clear_bit(x##_BIT, &amp;UDRS-&gt;flags))
DECL|macro|USETF
mdefine_line|#define USETF(x) (set_bit(x##_BIT, &amp;UDRS-&gt;flags))
DECL|macro|UTESTF
mdefine_line|#define UTESTF(x) (test_bit(x##_BIT, &amp;UDRS-&gt;flags))
DECL|macro|DPRINT
mdefine_line|#define DPRINT(x) printk(DEVICE_NAME &quot;%d: &quot; x,current_drive)
DECL|macro|DPRINT1
mdefine_line|#define DPRINT1(x,x1) &bslash;&n;printk(DEVICE_NAME &quot;%d: &quot; x,current_drive,(x1))
DECL|macro|DPRINT2
mdefine_line|#define DPRINT2(x,x1,x2) &bslash;&n;printk(DEVICE_NAME &quot;%d: &quot; x,current_drive,(x1),(x2))
DECL|macro|DPRINT3
mdefine_line|#define DPRINT3(x,x1,x2,x3) &bslash;&n;printk(DEVICE_NAME &quot;%d: &quot; x,current_drive,(x1),(x2),(x3))
DECL|macro|PH_HEAD
mdefine_line|#define PH_HEAD(floppy,head) (((((floppy)-&gt;stretch &amp; 2) &gt;&gt;1) ^ head) &lt;&lt; 2)
DECL|macro|STRETCH
mdefine_line|#define STRETCH(floppy) ((floppy)-&gt;stretch &amp; FD_STRETCH)
multiline_comment|/* read/write */
DECL|macro|COMMAND
mdefine_line|#define COMMAND raw_cmd.cmd[0]
DECL|macro|DR_SELECT
mdefine_line|#define DR_SELECT raw_cmd.cmd[1]
DECL|macro|TRACK
mdefine_line|#define TRACK raw_cmd.cmd[2]
DECL|macro|HEAD
mdefine_line|#define HEAD raw_cmd.cmd[3]
DECL|macro|SECTOR
mdefine_line|#define SECTOR raw_cmd.cmd[4]
DECL|macro|SIZECODE
mdefine_line|#define SIZECODE raw_cmd.cmd[5]
DECL|macro|SECT_PER_TRACK
mdefine_line|#define SECT_PER_TRACK raw_cmd.cmd[6]
DECL|macro|GAP
mdefine_line|#define GAP raw_cmd.cmd[7]
DECL|macro|SIZECODE2
mdefine_line|#define SIZECODE2 raw_cmd.cmd[8]
DECL|macro|NR_RW
mdefine_line|#define NR_RW 9
multiline_comment|/* format */
DECL|macro|F_SIZECODE
mdefine_line|#define F_SIZECODE raw_cmd.cmd[2]
DECL|macro|F_SECT_PER_TRACK
mdefine_line|#define F_SECT_PER_TRACK raw_cmd.cmd[3]
DECL|macro|F_GAP
mdefine_line|#define F_GAP raw_cmd.cmd[4]
DECL|macro|F_FILL
mdefine_line|#define F_FILL raw_cmd.cmd[5]
DECL|macro|NR_F
mdefine_line|#define NR_F 6
multiline_comment|/*&n; * Maximum disk size (in kilobytes). This default is used whenever the&n; * current disk size is unknown.&n; * [Now it is rather a minimum]&n; */
DECL|macro|MAX_DISK_SIZE
mdefine_line|#define MAX_DISK_SIZE 2 /* 3984*/
DECL|macro|K_64
mdefine_line|#define K_64&t;0x10000&t;&t;/* 64KB */
multiline_comment|/*&n; * The DMA channel used by the floppy controller cannot access data at&n; * addresses &gt;= 16MB&n; *&n; * Went back to the 1MB limit, as some people had problems with the floppy&n; * driver otherwise. It doesn&squot;t matter much for performance anyway, as most&n; * floppy accesses go through the track buffer.&n; */
macro_line|#ifdef __alpha__
DECL|macro|CROSS_64KB
macro_line|# define CROSS_64KB(a,s)&t;(0)
macro_line|#else
DECL|macro|CROSS_64KB
macro_line|# define CROSS_64KB(a,s) &bslash;&n;&t;((unsigned long)(a)/K_64 != ((unsigned long)(a) + (s) - 1) / K_64)
macro_line|#endif
multiline_comment|/*&n; * globals used by &squot;result()&squot;&n; */
DECL|macro|MAX_REPLIES
mdefine_line|#define MAX_REPLIES 10
DECL|variable|reply_buffer
r_static
r_int
r_char
id|reply_buffer
(braket
id|MAX_REPLIES
)braket
suffix:semicolon
DECL|variable|inr
r_static
r_int
id|inr
suffix:semicolon
multiline_comment|/* size of reply buffer, when called from interrupt */
DECL|macro|ST0
mdefine_line|#define ST0 (reply_buffer[0])
DECL|macro|ST1
mdefine_line|#define ST1 (reply_buffer[1])
DECL|macro|ST2
mdefine_line|#define ST2 (reply_buffer[2])
DECL|macro|ST3
mdefine_line|#define ST3 (reply_buffer[0]) /* result of GETSTATUS */
DECL|macro|R_TRACK
mdefine_line|#define R_TRACK (reply_buffer[3])
DECL|macro|R_HEAD
mdefine_line|#define R_HEAD (reply_buffer[4])
DECL|macro|R_SECTOR
mdefine_line|#define R_SECTOR (reply_buffer[5])
DECL|macro|R_SIZECODE
mdefine_line|#define R_SIZECODE (reply_buffer[6])
DECL|macro|SEL_DLY
mdefine_line|#define SEL_DLY (2*HZ/100)
DECL|macro|ARRAY_SIZE
mdefine_line|#define ARRAY_SIZE(x) (sizeof(x) / sizeof( (x)[0] ))
multiline_comment|/*&n; * this struct defines the different floppy drive types.&n; */
r_static
r_struct
(brace
DECL|member|params
r_struct
id|floppy_drive_params
id|params
suffix:semicolon
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
multiline_comment|/* name printed while booting */
DECL|variable|default_drive_params
)brace
id|default_drive_params
(braket
)braket
op_assign
(brace
multiline_comment|/* NOTE: the time values in jiffies should be in msec!&n; CMOS drive type&n;  |     Maximum data rate supported by drive type&n;  |     |   Head load time, msec&n;  |     |   |   Head unload time, msec (not used)&n;  |     |   |   |     Step rate interval, usec&n;  |     |   |   |     |       Time needed for spinup time (jiffies)&n;  |     |   |   |     |       |      Timeout for spinning down (jiffies)&n;  |     |   |   |     |       |      |   Spindown offset (where disk stops)&n;  |     |   |   |     |       |      |   |     Select delay&n;  |     |   |   |     |       |      |   |     |     RPS&n;  |     |   |   |     |       |      |   |     |     |    Max number of tracks&n;  |     |   |   |     |       |      |   |     |     |    |     Interrupt timeout&n;  |     |   |   |     |       |      |   |     |     |    |     |   Max nonintlv. sectors&n;  |     |   |   |     |       |      |   |     |     |    |     |   | -Max Errors- flags */
(brace
(brace
l_int|0
comma
l_int|500
comma
l_int|16
comma
l_int|16
comma
l_int|8000
comma
l_int|1
op_star
id|HZ
comma
l_int|3
op_star
id|HZ
comma
l_int|0
comma
id|SEL_DLY
comma
l_int|5
comma
l_int|80
comma
l_int|3
op_star
id|HZ
comma
l_int|20
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|7
comma
l_int|4
comma
l_int|8
comma
l_int|2
comma
l_int|1
comma
l_int|5
comma
l_int|3
comma
l_int|10
)brace
comma
l_int|3
op_star
id|HZ
op_div
l_int|2
comma
l_int|0
)brace
comma
l_string|&quot;unknown&quot;
)brace
comma
(brace
(brace
l_int|1
comma
l_int|300
comma
l_int|16
comma
l_int|16
comma
l_int|8000
comma
l_int|1
op_star
id|HZ
comma
l_int|3
op_star
id|HZ
comma
l_int|0
comma
id|SEL_DLY
comma
l_int|5
comma
l_int|40
comma
l_int|3
op_star
id|HZ
comma
l_int|17
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
l_int|3
op_star
id|HZ
op_div
l_int|2
comma
l_int|1
)brace
comma
l_string|&quot;360K PC&quot;
)brace
comma
multiline_comment|/*5 1/4 360 KB PC*/
(brace
(brace
l_int|2
comma
l_int|500
comma
l_int|16
comma
l_int|16
comma
l_int|6000
comma
l_int|4
op_star
id|HZ
op_div
l_int|10
comma
l_int|3
op_star
id|HZ
comma
l_int|14
comma
id|SEL_DLY
comma
l_int|6
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|17
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|2
comma
l_int|5
comma
l_int|6
comma
l_int|23
comma
l_int|10
comma
l_int|20
comma
l_int|11
comma
l_int|0
)brace
comma
l_int|3
op_star
id|HZ
op_div
l_int|2
comma
l_int|2
)brace
comma
l_string|&quot;1.2M&quot;
)brace
comma
multiline_comment|/*5 1/4 HD AT*/
(brace
(brace
l_int|3
comma
l_int|250
comma
l_int|16
comma
l_int|16
comma
l_int|3000
comma
l_int|1
op_star
id|HZ
comma
l_int|3
op_star
id|HZ
comma
l_int|0
comma
id|SEL_DLY
comma
l_int|5
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|20
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|4
comma
l_int|22
comma
l_int|21
comma
l_int|30
comma
l_int|3
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
comma
l_int|3
op_star
id|HZ
op_div
l_int|2
comma
l_int|4
)brace
comma
l_string|&quot;720k&quot;
)brace
comma
multiline_comment|/*3 1/2 DD*/
(brace
(brace
l_int|4
comma
l_int|500
comma
l_int|16
comma
l_int|16
comma
l_int|4000
comma
l_int|4
op_star
id|HZ
op_div
l_int|10
comma
l_int|3
op_star
id|HZ
comma
l_int|10
comma
id|SEL_DLY
comma
l_int|5
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|20
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|7
comma
l_int|4
comma
l_int|25
comma
l_int|22
comma
l_int|31
comma
l_int|21
comma
l_int|29
comma
l_int|11
)brace
comma
l_int|3
op_star
id|HZ
op_div
l_int|2
comma
l_int|7
)brace
comma
l_string|&quot;1.44M&quot;
)brace
comma
multiline_comment|/*3 1/2 HD*/
(brace
(brace
l_int|5
comma
l_int|1000
comma
l_int|15
comma
l_int|8
comma
l_int|3000
comma
l_int|4
op_star
id|HZ
op_div
l_int|10
comma
l_int|3
op_star
id|HZ
comma
l_int|10
comma
id|SEL_DLY
comma
l_int|5
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|40
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|7
comma
l_int|8
comma
l_int|4
comma
l_int|25
comma
l_int|28
comma
l_int|22
comma
l_int|31
comma
l_int|21
)brace
comma
l_int|3
op_star
id|HZ
op_div
l_int|2
comma
l_int|8
)brace
comma
l_string|&quot;2.88M AMI BIOS&quot;
)brace
comma
multiline_comment|/*3 1/2 ED*/
(brace
(brace
l_int|6
comma
l_int|1000
comma
l_int|15
comma
l_int|8
comma
l_int|3000
comma
l_int|4
op_star
id|HZ
op_div
l_int|10
comma
l_int|3
op_star
id|HZ
comma
l_int|10
comma
id|SEL_DLY
comma
l_int|5
comma
l_int|83
comma
l_int|3
op_star
id|HZ
comma
l_int|40
comma
(brace
l_int|3
comma
l_int|1
comma
l_int|2
comma
l_int|0
comma
l_int|2
)brace
comma
l_int|0
comma
l_int|0
comma
(brace
l_int|7
comma
l_int|8
comma
l_int|4
comma
l_int|25
comma
l_int|28
comma
l_int|22
comma
l_int|31
comma
l_int|21
)brace
comma
l_int|3
op_star
id|HZ
op_div
l_int|2
comma
l_int|8
)brace
comma
l_string|&quot;2.88M&quot;
)brace
multiline_comment|/*3 1/2 ED*/
multiline_comment|/*    |  ---autodetected formats--   |      |      |&n;      read_track                     |      |    Name printed when booting&n;                                     |     Native format&n;                                   Frequency of disk change checks */
)brace
suffix:semicolon
DECL|variable|drive_params
r_static
r_struct
id|floppy_drive_params
id|drive_params
(braket
id|N_DRIVE
)braket
suffix:semicolon
DECL|variable|drive_state
r_static
r_struct
id|floppy_drive_struct
id|drive_state
(braket
id|N_DRIVE
)braket
suffix:semicolon
DECL|variable|write_errors
r_static
r_struct
id|floppy_write_errors
id|write_errors
(braket
id|N_DRIVE
)braket
suffix:semicolon
DECL|variable|raw_cmd
r_static
r_struct
id|floppy_raw_cmd
id|raw_cmd
suffix:semicolon
multiline_comment|/*&n; * This struct defines the different floppy types.&n; *&n; * Bit 0 of &squot;stretch&squot; tells if the tracks need to be doubled for some&n; * types (e.g. 360kB diskette in 1.2MB drive, etc.).  Bit 1 of &squot;stretch&squot;&n; * tells if the disk is in Commodore 1581 format, which means side 0 sectors&n; * are located on side 1 of the disk but with a side 0 ID, and vice-versa.&n; * This is the same as the Sharp MZ-80 5.25&quot; CP/M disk format, except that the&n; * 1581&squot;s logical side 0 is on physical side 1, whereas the Sharp&squot;s logical&n; * side 0 is on physical side 0 (but with the misnamed sector IDs).&n; * &squot;stretch&squot; should probably be renamed to something more general, like&n; * &squot;options&squot;.  Other parameters should be self-explanatory (see also&n; * setfdprm(8)).&n; */
DECL|variable|floppy_type
r_static
r_struct
id|floppy_struct
id|floppy_type
(braket
l_int|32
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|NULL
)brace
comma
multiline_comment|/*  0 no testing    */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;d360&quot;
)brace
comma
multiline_comment|/*  1 360KB PC      */
(brace
l_int|2400
comma
l_int|15
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x54
comma
l_string|&quot;h1200&quot;
)brace
comma
multiline_comment|/*  2 1.2MB AT      */
(brace
l_int|720
comma
l_int|9
comma
l_int|1
comma
l_int|80
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;D360&quot;
)brace
comma
multiline_comment|/*  3 360KB SS 3.5&quot; */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;D720&quot;
)brace
comma
multiline_comment|/*  4 720KB 3.5&quot;    */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|1
comma
l_int|0x23
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;h360&quot;
)brace
comma
multiline_comment|/*  5 360KB AT      */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x23
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;h720&quot;
)brace
comma
multiline_comment|/*  6 720KB AT      */
(brace
l_int|2880
comma
l_int|18
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;H1440&quot;
)brace
comma
multiline_comment|/*  7 1.44MB 3.5&quot;   */
(brace
l_int|5760
comma
l_int|36
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x43
comma
l_int|0xAF
comma
l_int|0x54
comma
l_string|&quot;E2880&quot;
)brace
comma
multiline_comment|/*  8 2.88MB 3.5&quot;   */
(brace
l_int|5760
comma
l_int|36
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x43
comma
l_int|0xAF
comma
l_int|0x54
comma
l_string|&quot;CompaQ&quot;
)brace
comma
multiline_comment|/*  9 2.88MB 3.5&quot;   */
(brace
l_int|2880
comma
l_int|18
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x02
comma
l_string|&quot;h1440&quot;
)brace
comma
multiline_comment|/* 10 1.44MB 5.25&quot;  */
(brace
l_int|3360
comma
l_int|21
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x00
comma
l_int|0xCF
comma
l_int|0x0C
comma
l_string|&quot;H1680&quot;
)brace
comma
multiline_comment|/* 11 1.68MB 3.5&quot;   */
(brace
l_int|820
comma
l_int|10
comma
l_int|2
comma
l_int|41
comma
l_int|1
comma
l_int|0x25
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;h410&quot;
)brace
comma
multiline_comment|/* 12 410KB 5.25&quot;   */
(brace
l_int|1640
comma
l_int|10
comma
l_int|2
comma
l_int|82
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;H820&quot;
)brace
comma
multiline_comment|/* 13 820KB 3.5&quot;    */
(brace
l_int|2952
comma
l_int|18
comma
l_int|2
comma
l_int|82
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x02
comma
l_string|&quot;h1476&quot;
)brace
comma
multiline_comment|/* 14 1.48MB 5.25&quot;  */
(brace
l_int|3444
comma
l_int|21
comma
l_int|2
comma
l_int|82
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x0C
comma
l_string|&quot;H1722&quot;
)brace
comma
multiline_comment|/* 15 1.72MB 3.5&quot;   */
(brace
l_int|840
comma
l_int|10
comma
l_int|2
comma
l_int|42
comma
l_int|1
comma
l_int|0x25
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;h420&quot;
)brace
comma
multiline_comment|/* 16 420KB 5.25&quot;   */
(brace
l_int|1660
comma
l_int|10
comma
l_int|2
comma
l_int|83
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;H830&quot;
)brace
comma
multiline_comment|/* 17 830KB 3.5&quot;    */
(brace
l_int|2988
comma
l_int|18
comma
l_int|2
comma
l_int|83
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x02
comma
l_string|&quot;h1494&quot;
)brace
comma
multiline_comment|/* 18 1.49MB 5.25&quot;  */
(brace
l_int|3486
comma
l_int|21
comma
l_int|2
comma
l_int|83
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x0C
comma
l_string|&quot;H1743&quot;
)brace
comma
multiline_comment|/* 19 1.74 MB 3.5&quot;  */
(brace
l_int|1760
comma
l_int|11
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x09
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;h880&quot;
)brace
comma
multiline_comment|/* 20 880KB 5.25&quot;   */
(brace
l_int|2080
comma
l_int|13
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x01
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;D1040&quot;
)brace
comma
multiline_comment|/* 21 1.04MB 3.5&quot;   */
(brace
l_int|2240
comma
l_int|14
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x19
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;D1120&quot;
)brace
comma
multiline_comment|/* 22 1.12MB 3.5&quot;   */
(brace
l_int|3200
comma
l_int|20
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x20
comma
l_int|0xCF
comma
l_int|0x2C
comma
l_string|&quot;h1600&quot;
)brace
comma
multiline_comment|/* 23 1.6MB 5.25&quot;   */
(brace
l_int|3520
comma
l_int|22
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x08
comma
l_int|0xCF
comma
l_int|0x2e
comma
l_string|&quot;H1760&quot;
)brace
comma
multiline_comment|/* 24 1.76MB 3.5&quot;   */
(brace
l_int|3840
comma
l_int|24
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x20
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;H1920&quot;
)brace
comma
multiline_comment|/* 25 1.92MB 3.5&quot;   */
(brace
l_int|6400
comma
l_int|40
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x5B
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;E3200&quot;
)brace
comma
multiline_comment|/* 26 3.20MB 3.5&quot;   */
(brace
l_int|7040
comma
l_int|44
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x5B
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;E3520&quot;
)brace
comma
multiline_comment|/* 27 3.52MB 3.5&quot;   */
(brace
l_int|7680
comma
l_int|48
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x63
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;E3840&quot;
)brace
comma
multiline_comment|/* 28 3.84MB 3.5&quot;   */
(brace
l_int|3680
comma
l_int|23
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x10
comma
l_int|0xCF
comma
l_int|0x00
comma
l_string|&quot;H1840&quot;
)brace
comma
multiline_comment|/* 29 1.84MB 3.5&quot;   */
(brace
l_int|1600
comma
l_int|10
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x25
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x2E
comma
l_string|&quot;D800&quot;
)brace
comma
multiline_comment|/* 30 800KB 3.5&quot;    */
(brace
l_int|3200
comma
l_int|20
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1C
comma
l_int|0x00
comma
l_int|0xCF
comma
l_int|0x2C
comma
l_string|&quot;H1600&quot;
)brace
comma
multiline_comment|/* 31 1.6MB 3.5&quot;    */
)brace
suffix:semicolon
DECL|macro|NUMBER
mdefine_line|#define&t;NUMBER(x)&t;(sizeof(x) / sizeof(*(x)))
DECL|macro|SECTSIZE
mdefine_line|#define SECTSIZE ( _FD_SECTSIZE(*floppy))
multiline_comment|/* Auto-detection: Disk type used until the next media change occurs. */
DECL|variable|current_type
r_struct
id|floppy_struct
op_star
id|current_type
(braket
id|N_DRIVE
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/*&n; * User-provided type information. current_type points to&n; * the respective entry of this array.&n; */
DECL|variable|user_params
r_struct
id|floppy_struct
id|user_params
(braket
id|N_DRIVE
)braket
suffix:semicolon
DECL|variable|floppy_sizes
r_static
r_int
id|floppy_sizes
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|floppy_blocksizes
r_static
r_int
id|floppy_blocksizes
(braket
l_int|256
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/*&n; * The driver is trying to determine the correct media format&n; * while probing is set. rw_interrupt() clears it after a&n; * successful access.&n; */
DECL|variable|probing
r_static
r_int
id|probing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Synchronization of FDC access. */
DECL|macro|FD_COMMAND_DETECT
mdefine_line|#define FD_COMMAND_DETECT -2
DECL|macro|FD_COMMAND_NONE
mdefine_line|#define FD_COMMAND_NONE -1
DECL|macro|FD_COMMAND_ERROR
mdefine_line|#define FD_COMMAND_ERROR 2
DECL|macro|FD_COMMAND_OKAY
mdefine_line|#define FD_COMMAND_OKAY 3
DECL|variable|command_status
DECL|variable|fdc_busy
r_static
r_volatile
r_int
id|command_status
op_assign
id|FD_COMMAND_NONE
comma
id|fdc_busy
op_assign
l_int|0
suffix:semicolon
DECL|variable|fdc_wait
DECL|variable|command_done
r_static
r_struct
id|wait_queue
op_star
id|fdc_wait
op_assign
l_int|NULL
comma
op_star
id|command_done
op_assign
l_int|NULL
suffix:semicolon
DECL|macro|NO_SIGNAL
mdefine_line|#define NO_SIGNAL (!(current-&gt;signal &amp; ~current-&gt;blocked) || !interruptible)
DECL|macro|CALL
mdefine_line|#define CALL(x) if( (x) == -EINTR) return -EINTR;
DECL|macro|_WAIT
mdefine_line|#define _WAIT(x,i) CALL(ret=wait_til_done((x),i))
DECL|macro|WAIT
mdefine_line|#define WAIT(x) _WAIT((x),interruptible)
DECL|macro|IWAIT
mdefine_line|#define IWAIT(x) _WAIT((x),1)
multiline_comment|/* Errors during formatting are counted here. */
DECL|variable|format_errors
r_static
r_int
id|format_errors
suffix:semicolon
multiline_comment|/* Format request descriptor. */
DECL|variable|format_req
r_static
r_struct
id|format_descr
id|format_req
suffix:semicolon
multiline_comment|/*&n; * Rate is 0 for 500kb/s, 1 for 300kbps, 2 for 250kbps&n; * Spec1 is 0xSH, where S is stepping rate (F=1ms, E=2ms, D=3ms etc),&n; * H is head unload time (1=16ms, 2=32ms, etc)&n; */
multiline_comment|/*&n; * Track buffer&n; * Because these are written to by the DMA controller, they must&n; * not contain a 64k byte boundary crossing, or data will be&n; * corrupted/lost. Alignment of these is enforced in boot/head.S.&n; * Note that you must not change the sizes below without updating head.S.&n; */
DECL|variable|floppy_track_buffer
r_char
op_star
id|floppy_track_buffer
op_assign
l_int|0
suffix:semicolon
DECL|variable|max_buffer_sectors
r_int
id|max_buffer_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|errors
r_int
op_star
id|errors
suffix:semicolon
DECL|typedef|done_f
r_typedef
r_void
(paren
op_star
id|done_f
)paren
(paren
r_int
)paren
suffix:semicolon
DECL|struct|cont_t
r_struct
id|cont_t
(brace
DECL|member|interrupt
r_void
(paren
op_star
id|interrupt
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* this is called after the interrupt of the&n;&t;&t;&t;  * main command */
DECL|member|redo
r_void
(paren
op_star
id|redo
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* this is called to retry the operation */
DECL|member|error
r_void
(paren
op_star
id|error
)paren
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* this is called to tally an error */
DECL|member|done
id|done_f
id|done
suffix:semicolon
multiline_comment|/* this is called to say if the operation has succeeded/failed */
DECL|variable|cont
)brace
op_star
id|cont
op_assign
l_int|NULL
suffix:semicolon
r_static
r_void
id|floppy_ready
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|floppy_start
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|process_fd_request
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|recalibrate_floppy
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|floppy_shutdown
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|floppy_grab_irq_and_dma
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|floppy_release_irq_and_dma
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * The &quot;reset&quot; variable should be tested whenever an interrupt is scheduled,&n; * after the commands have been sent. This is to ensure that the driver doesn&squot;t&n; * get wedged when the interrupt doesn&squot;t come because of a failed command.&n; * reset doesn&squot;t need to be tested before sending commands, because&n; * output_byte is automatically disabled when reset is set.&n; */
DECL|macro|CHECK_RESET
mdefine_line|#define CHECK_RESET { if ( FDCS-&gt;reset ){ reset_fdc(); return ; } }
r_static
r_void
id|reset_fdc
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * These are global variables, as that&squot;s the easiest way to give&n; * information to interrupts. They are the data used for the current&n; * request.&n; */
DECL|macro|NO_TRACK
mdefine_line|#define NO_TRACK -1
DECL|macro|NEED_1_RECAL
mdefine_line|#define NEED_1_RECAL -2
DECL|macro|NEED_2_RECAL
mdefine_line|#define NEED_2_RECAL -3
multiline_comment|/* */
DECL|variable|usage_count
r_static
r_int
id|usage_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* buffer related variables */
DECL|variable|buffer_track
r_static
r_int
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|buffer_drive
r_static
r_int
id|buffer_drive
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|buffer_min
r_static
r_int
id|buffer_min
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|buffer_max
r_static
r_int
id|buffer_max
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* fdc related variables, should end up in a struct */
DECL|variable|fdc_state
r_static
r_struct
id|floppy_fdc_state
id|fdc_state
(braket
id|N_FDC
)braket
suffix:semicolon
DECL|variable|fdc
r_static
r_int
id|fdc
suffix:semicolon
multiline_comment|/* current fdc */
DECL|variable|floppy
r_static
r_struct
id|floppy_struct
op_star
id|floppy
op_assign
id|floppy_type
suffix:semicolon
DECL|variable|current_drive
r_static
r_int
r_char
id|current_drive
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_count_sectors
r_static
r_int
id|current_count_sectors
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_addr
r_static
r_char
op_star
id|current_addr
op_assign
l_int|0
suffix:semicolon
DECL|variable|sector_t
r_static
r_int
r_char
id|sector_t
suffix:semicolon
multiline_comment|/* sector in track */
macro_line|#ifdef DEBUGT
DECL|variable|debugtimer
r_int
r_int
id|debugtimer
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Debugging&n; * =========&n; */
DECL|function|set_debugt
r_static
r_inline
r_void
id|set_debugt
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUGT
id|debugtimer
op_assign
id|jiffies
suffix:semicolon
macro_line|#endif
)brace
DECL|function|debugt
r_static
r_inline
r_void
id|debugt
c_func
(paren
r_char
op_star
id|message
)paren
(brace
macro_line|#ifdef DEBUGT
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|DEBUGT
)paren
id|printk
c_func
(paren
l_string|&quot;%s dtime=%lu&bslash;n&quot;
comma
id|message
comma
id|jiffies
op_minus
id|debugtimer
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|typedef|timeout_fn
r_typedef
r_void
(paren
op_star
id|timeout_fn
)paren
(paren
r_int
r_int
)paren
suffix:semicolon
DECL|variable|fd_timeout
r_static
r_struct
id|timer_list
id|fd_timeout
op_assign
initialization_block
suffix:semicolon
DECL|variable|timeout_message
r_static
r_char
op_star
id|timeout_message
suffix:semicolon
macro_line|#ifdef CONFIG_FLOPPY_SANITY
DECL|function|is_alive
r_static
r_void
id|is_alive
c_func
(paren
r_char
op_star
id|message
)paren
(brace
multiline_comment|/* this routine checks whether the floppy driver is &quot;alive&quot; */
r_if
c_cond
(paren
id|fdc_busy
op_logical_and
id|command_status
OL
l_int|2
op_logical_and
op_logical_neg
id|fd_timeout.prev
)paren
(brace
id|DPRINT1
c_func
(paren
l_string|&quot;timeout handler died: %s&bslash;n&quot;
comma
id|message
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef CONFIG_FLOPPY_SANITY
DECL|macro|OLOGSIZE
mdefine_line|#define OLOGSIZE 20
DECL|variable|lasthandler
r_void
(paren
op_star
id|lasthandler
)paren
(paren
r_void
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|variable|interruptjiffies
r_int
id|interruptjiffies
op_assign
l_int|0
suffix:semicolon
DECL|variable|resultjiffies
r_int
id|resultjiffies
op_assign
l_int|0
suffix:semicolon
DECL|variable|resultsize
r_int
id|resultsize
op_assign
l_int|0
suffix:semicolon
DECL|variable|lastredo
r_int
id|lastredo
op_assign
l_int|0
suffix:semicolon
DECL|struct|output_log
r_static
r_struct
id|output_log
(brace
DECL|member|data
r_int
r_char
id|data
suffix:semicolon
DECL|member|status
r_int
r_char
id|status
suffix:semicolon
DECL|member|jiffies
r_int
r_int
id|jiffies
suffix:semicolon
DECL|variable|output_log
)brace
id|output_log
(braket
id|OLOGSIZE
)braket
suffix:semicolon
DECL|variable|output_log_pos
r_static
r_int
id|output_log_pos
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|macro|CURRENTD
mdefine_line|#define CURRENTD -1
DECL|macro|MAXTIMEOUT
mdefine_line|#define MAXTIMEOUT -2
DECL|function|reschedule_timeout
r_static
r_void
id|reschedule_timeout
c_func
(paren
r_int
id|drive
comma
r_char
op_star
id|message
comma
r_int
id|marg
)paren
(brace
r_if
c_cond
(paren
id|drive
op_eq
id|CURRENTD
)paren
id|drive
op_assign
id|current_drive
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|fd_timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
template_param
id|N_DRIVE
)paren
(brace
id|fd_timeout.expires
op_assign
l_int|2000
suffix:semicolon
id|drive
op_assign
l_int|0
suffix:semicolon
)brace
r_else
id|fd_timeout.expires
op_assign
id|UDP-&gt;timeout
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|fd_timeout
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UDP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;reschedule timeout &quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|message
comma
id|marg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|timeout_message
op_assign
id|message
suffix:semicolon
)brace
multiline_comment|/*&n; * Bottom half floppy driver.&n; * ==========================&n; *&n; * This part of the file contains the code talking directly to the hardware,&n; * and also the main service loop (seek-configure-spinup-command)&n; */
multiline_comment|/*&n; * disk change.&n; * This routine is responsible for maintaining the FD_DISK_CHANGE flag,&n; * and the last_checked date.&n; *&n; * last_checked is the date of the last check which showed &squot;no disk change&squot;&n; * FD_DISK_CHANGE is set under two conditions:&n; * 1. The floppy has been changed after some i/o to that floppy already&n; *    took place.&n; * 2. No floppy disk is in the drive. This is done in order to ensure that&n; *    requests are quickly flushed in case there is no disk in the drive. It&n; *    follows that FD_DISK_CHANGE can only be cleared if there is a disk in&n; *    the drive.&n; *&n; * For 1., maxblock is observed. Maxblock is 0 if no i/o has taken place yet.&n; * For 2., FD_DISK_NEWCHANGE is watched. FD_DISK_NEWCHANGE is cleared on&n; *  each seek. If a disk is present, the disk change line should also be&n; *  cleared on each seek. Thus, if FD_DISK_NEWCHANGE is clear, but the disk&n; *  change line is set, this means either that no disk is in the drive, or&n; *  that it has been removed since the last seek.&n; *&n; * This means that we really have a third possibility too:&n; *  The floppy has been changed after the last seek.&n; */
DECL|function|disk_change
r_static
r_int
id|disk_change
c_func
(paren
r_int
id|drive
)paren
(brace
r_int
id|fdc
op_assign
id|FDC
c_func
(paren
id|drive
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_FLOPPY_SANITY
r_if
c_cond
(paren
id|jiffies
OL
id|UDP-&gt;select_delay
op_plus
id|UDRS-&gt;select_date
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;WARNING disk change called early&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|FDCS-&gt;dor
op_amp
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|drive
)paren
)paren
)paren
op_logical_or
(paren
id|FDCS-&gt;dor
op_amp
l_int|3
)paren
op_ne
id|UNIT
c_func
(paren
id|drive
)paren
op_logical_or
id|fdc
op_ne
id|FDC
c_func
(paren
id|drive
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;probing disk change on unselected drive&bslash;n&quot;
)paren
suffix:semicolon
id|DPRINT3
c_func
(paren
l_string|&quot;drive=%d fdc=%d dor=%x&bslash;n&quot;
comma
id|drive
comma
id|FDC
c_func
(paren
id|drive
)paren
comma
id|FDCS-&gt;dor
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|UDP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT1
c_func
(paren
l_string|&quot;checking disk change line for drive %d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
id|DPRINT1
c_func
(paren
l_string|&quot;jiffies=%ld&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
id|DPRINT1
c_func
(paren
l_string|&quot;disk change line=%x&bslash;n&quot;
comma
id|inb_p
c_func
(paren
id|FD_DIR
)paren
op_amp
l_int|0x80
)paren
suffix:semicolon
id|DPRINT1
c_func
(paren
l_string|&quot;flags=%x&bslash;n&quot;
comma
id|UDRS-&gt;flags
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|UDP-&gt;flags
op_amp
id|FD_BROKEN_DCL
)paren
r_return
id|UTESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
id|FD_DIR
)paren
op_xor
id|UDP-&gt;flags
)paren
op_amp
l_int|0x80
)paren
(brace
id|USETF
c_func
(paren
id|FD_VERIFY
)paren
suffix:semicolon
multiline_comment|/* verify write protection */
r_if
c_cond
(paren
id|UDRS-&gt;maxblock
)paren
(brace
multiline_comment|/* mark it changed */
id|USETF
c_func
(paren
id|FD_DISK_CHANGED
)paren
suffix:semicolon
multiline_comment|/* invalidate its geometry */
r_if
c_cond
(paren
id|UDRS-&gt;keep_data
op_ge
l_int|0
)paren
(brace
r_if
c_cond
(paren
(paren
id|UDP-&gt;flags
op_amp
id|FTD_MSG
)paren
op_logical_and
id|current_type
(braket
id|drive
)braket
op_ne
l_int|NULL
)paren
id|DPRINT
c_func
(paren
l_string|&quot;Disk type is undefined after &quot;
l_string|&quot;disk change&bslash;n&quot;
)paren
suffix:semicolon
id|current_type
(braket
id|drive
)braket
op_assign
l_int|NULL
suffix:semicolon
id|floppy_sizes
(braket
id|DRIVE
c_func
(paren
id|current_drive
)paren
op_plus
(paren
id|FDC
c_func
(paren
id|current_drive
)paren
op_lshift
l_int|7
)paren
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
)brace
)brace
multiline_comment|/*USETF(FD_DISK_NEWCHANGE);*/
r_return
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|UDRS-&gt;last_checked
op_assign
id|jiffies
suffix:semicolon
id|UCLEARF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|is_selected
r_static
r_inline
r_int
id|is_selected
c_func
(paren
r_int
id|dor
comma
r_int
id|unit
)paren
(brace
r_return
(paren
(paren
id|dor
op_amp
(paren
l_int|0x10
op_lshift
id|unit
)paren
)paren
op_logical_and
(paren
id|dor
op_amp
l_int|3
)paren
op_eq
id|unit
)paren
suffix:semicolon
)brace
DECL|function|set_dor
r_static
r_int
id|set_dor
c_func
(paren
r_int
id|fdc
comma
r_char
id|mask
comma
r_char
id|data
)paren
(brace
r_register
r_int
r_char
id|drive
comma
id|unit
comma
id|newdor
comma
id|olddor
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;address
op_eq
op_minus
l_int|1
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|olddor
op_assign
id|FDCS-&gt;dor
suffix:semicolon
id|newdor
op_assign
(paren
id|olddor
op_amp
id|mask
)paren
op_or
id|data
suffix:semicolon
r_if
c_cond
(paren
id|newdor
op_ne
id|olddor
)paren
(brace
id|unit
op_assign
id|olddor
op_amp
l_int|0x3
suffix:semicolon
r_if
c_cond
(paren
id|is_selected
c_func
(paren
id|olddor
comma
id|unit
)paren
op_logical_and
op_logical_neg
id|is_selected
c_func
(paren
id|newdor
comma
id|unit
)paren
)paren
(brace
id|drive
op_assign
id|REVDRIVE
c_func
(paren
id|fdc
comma
id|unit
)paren
suffix:semicolon
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|UDP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;calling disk change from set_dor&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|disk_change
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
id|FDCS-&gt;dor
op_assign
id|newdor
suffix:semicolon
id|outb_p
c_func
(paren
id|newdor
comma
id|FD_DOR
)paren
suffix:semicolon
id|unit
op_assign
id|newdor
op_amp
l_int|0x3
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|is_selected
c_func
(paren
id|olddor
comma
id|unit
)paren
op_logical_and
id|is_selected
c_func
(paren
id|newdor
comma
id|unit
)paren
)paren
(brace
id|drive
op_assign
id|REVDRIVE
c_func
(paren
id|fdc
comma
id|unit
)paren
suffix:semicolon
id|UDRS-&gt;select_date
op_assign
id|jiffies
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|newdor
op_amp
l_int|0xf0
)paren
id|floppy_grab_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|olddor
op_amp
l_int|0xf0
)paren
(brace
id|floppy_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
id|olddor
suffix:semicolon
)brace
DECL|function|twaddle
r_static
r_void
id|twaddle
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|DP-&gt;select_delay
)paren
r_return
suffix:semicolon
id|outb_p
c_func
(paren
id|FDCS-&gt;dor
op_amp
op_complement
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
comma
id|FD_DOR
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|FDCS-&gt;dor
comma
id|FD_DOR
)paren
suffix:semicolon
id|DRS-&gt;select_date
op_assign
id|jiffies
suffix:semicolon
)brace
multiline_comment|/* reset all driver information about the current fdc. This is needed after&n; * a reset, and after a raw command. */
DECL|function|reset_fdc_info
r_static
r_void
id|reset_fdc_info
c_func
(paren
r_int
id|mode
)paren
(brace
r_int
id|drive
suffix:semicolon
id|FDCS-&gt;spec1
op_assign
id|FDCS-&gt;spec2
op_assign
op_minus
l_int|1
suffix:semicolon
id|FDCS-&gt;need_configure
op_assign
l_int|1
suffix:semicolon
id|FDCS-&gt;perp_mode
op_assign
l_int|1
suffix:semicolon
id|FDCS-&gt;rawcmd
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|N_DRIVE
suffix:semicolon
id|drive
op_increment
)paren
r_if
c_cond
(paren
id|FDC
c_func
(paren
id|drive
)paren
op_eq
id|fdc
op_logical_and
(paren
id|mode
op_logical_or
id|UDRS-&gt;track
op_ne
id|NEED_1_RECAL
)paren
)paren
id|UDRS-&gt;track
op_assign
id|NEED_2_RECAL
suffix:semicolon
)brace
multiline_comment|/* selects the fdc and drive, and enables the fdc&squot;s input/dma. */
DECL|function|set_fdc
r_static
r_void
id|set_fdc
c_func
(paren
r_int
id|drive
)paren
(brace
r_if
c_cond
(paren
id|drive
op_ge
l_int|0
op_logical_and
id|drive
OL
id|N_DRIVE
)paren
(brace
id|fdc
op_assign
id|FDC
c_func
(paren
id|drive
)paren
suffix:semicolon
id|current_drive
op_assign
id|drive
suffix:semicolon
)brace
id|set_dor
c_func
(paren
id|fdc
comma
op_complement
l_int|0
comma
l_int|8
)paren
suffix:semicolon
id|set_dor
c_func
(paren
l_int|1
op_minus
id|fdc
comma
op_complement
l_int|8
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;rawcmd
op_eq
l_int|2
)paren
id|reset_fdc_info
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb_p
c_func
(paren
id|FD_STATUS
)paren
op_ne
id|STATUS_READY
)paren
(brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* locks the driver */
DECL|function|lock_fdc
r_static
r_int
id|lock_fdc
c_func
(paren
r_int
id|drive
comma
r_int
id|interruptible
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|usage_count
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;trying to lock fdc while usage count=0&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|floppy_grab_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|current-&gt;pid
)paren
id|run_task_queue
c_func
(paren
op_amp
id|tq_timer
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fdc_busy
op_logical_and
id|NO_SIGNAL
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc_busy
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|fdc_busy
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|command_status
op_assign
id|FD_COMMAND_NONE
suffix:semicolon
id|set_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
id|reschedule_timeout
c_func
(paren
id|drive
comma
l_string|&quot;lock fdc&quot;
comma
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|LOCK_FDC
mdefine_line|#define LOCK_FDC(drive,interruptible) &bslash;&n;if(lock_fdc(drive,interruptible)) return -EINTR;
multiline_comment|/* unlocks the driver */
DECL|function|unlock_fdc
r_static
r_inline
r_void
id|unlock_fdc
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fdc_busy
)paren
id|DPRINT
c_func
(paren
l_string|&quot;FDC access conflict!&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEVICE_INTR
)paren
id|DPRINT1
c_func
(paren
l_string|&quot;device interrupt still active at FDC release: %p!&bslash;n&quot;
comma
id|DEVICE_INTR
)paren
suffix:semicolon
id|command_status
op_assign
id|FD_COMMAND_NONE
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|fd_timeout
)paren
suffix:semicolon
id|cont
op_assign
l_int|NULL
suffix:semicolon
id|fdc_busy
op_assign
l_int|0
suffix:semicolon
id|floppy_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
)brace
multiline_comment|/* switches the motor off after a given timeout */
DECL|function|motor_off_callback
r_static
r_void
id|motor_off_callback
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
r_int
r_char
id|mask
op_assign
op_complement
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|nr
)paren
)paren
suffix:semicolon
id|set_dor
c_func
(paren
id|FDC
c_func
(paren
id|nr
)paren
comma
id|mask
comma
l_int|0
)paren
suffix:semicolon
)brace
DECL|variable|motor_off_timer
r_static
r_struct
id|timer_list
id|motor_off_timer
(braket
id|N_DRIVE
)braket
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|1
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|2
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|3
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|4
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|5
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|6
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|7
comma
id|motor_off_callback
)brace
)brace
suffix:semicolon
multiline_comment|/* schedules motor off */
DECL|function|floppy_off
r_static
r_void
id|floppy_off
c_func
(paren
r_int
r_int
id|drive
)paren
(brace
r_int
r_int
r_volatile
id|delta
suffix:semicolon
r_register
r_int
id|fdc
op_assign
id|FDC
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|FDCS-&gt;dor
op_amp
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|drive
)paren
)paren
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|del_timer
c_func
(paren
id|motor_off_timer
op_plus
id|drive
)paren
suffix:semicolon
multiline_comment|/* make spindle stop in a position which minimizes spinup time&n;&t; * next time */
r_if
c_cond
(paren
id|UDP-&gt;rps
)paren
(brace
id|delta
op_assign
id|jiffies
op_minus
id|UDRS-&gt;first_read_date
op_plus
id|HZ
op_minus
id|UDP-&gt;spindown_offset
suffix:semicolon
id|delta
op_assign
(paren
(paren
id|delta
op_star
id|UDP-&gt;rps
)paren
op_mod
id|HZ
)paren
op_div
id|UDP-&gt;rps
suffix:semicolon
id|motor_off_timer
(braket
id|drive
)braket
dot
id|expires
op_assign
id|UDP-&gt;spindown
op_minus
id|delta
suffix:semicolon
)brace
id|add_timer
c_func
(paren
id|motor_off_timer
op_plus
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * cycle through all N_DRIVE floppy drives, for disk change testing.&n; * stopping at current drive. This is done before any long operation, to&n; * be sure to have up to date disk change information.&n; */
DECL|function|scandrives
r_static
r_void
id|scandrives
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|drive
comma
id|saved_drive
suffix:semicolon
r_if
c_cond
(paren
id|DP-&gt;select_delay
)paren
r_return
suffix:semicolon
id|saved_drive
op_assign
id|current_drive
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_DRIVE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|drive
op_assign
(paren
id|saved_drive
op_plus
id|i
op_plus
l_int|1
)paren
op_mod
id|N_DRIVE
suffix:semicolon
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
op_eq
l_int|0
op_logical_or
id|UDP-&gt;select_delay
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* skip closed drives */
id|set_fdc
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|set_dor
c_func
(paren
id|fdc
comma
op_complement
l_int|3
comma
id|UNIT
c_func
(paren
id|drive
)paren
op_or
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|drive
)paren
)paren
)paren
op_amp
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|drive
)paren
)paren
)paren
)paren
(brace
multiline_comment|/* switch the motor off again, if it was off to&n;&t;&t;&t; * begin with */
id|set_dor
c_func
(paren
id|fdc
comma
op_complement
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|drive
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
id|set_fdc
c_func
(paren
id|saved_drive
)paren
suffix:semicolon
)brace
DECL|variable|fd_timer
r_static
r_struct
id|timer_list
id|fd_timer
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* this function makes sure that the disk stays in the drive during the&n; * transfer */
DECL|function|fd_watchdog
r_static
r_void
id|fd_watchdog
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;calling disk change from watchdog&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|disk_change
c_func
(paren
id|current_drive
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;disk removed during i/o&bslash;n&quot;
)paren
suffix:semicolon
id|floppy_shutdown
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|del_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
id|fd_timer.function
op_assign
(paren
id|timeout_fn
)paren
id|fd_watchdog
suffix:semicolon
id|fd_timer.expires
op_assign
l_int|10
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
)brace
)brace
DECL|function|main_command_interrupt
r_static
r_void
id|main_command_interrupt
c_func
(paren
r_void
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|interrupt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* waits for a delay (spinup or select) to pass */
DECL|function|wait_for_completion
r_static
r_int
id|wait_for_completion
c_func
(paren
r_int
id|delay
comma
id|timeout_fn
id|function
)paren
(brace
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
(brace
id|reset_fdc
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* do the reset during sleep to win time&n;&t;&t;&t;      * if we don&squot;t need to sleep, it&squot;s a good&n;&t;&t;&t;      * occasion anyways */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|jiffies
OL
id|delay
)paren
(brace
id|del_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
id|fd_timer.function
op_assign
id|function
suffix:semicolon
id|fd_timer.expires
op_assign
id|delay
op_minus
id|jiffies
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|hlt_disabled
r_static
r_int
id|hlt_disabled
op_assign
l_int|0
suffix:semicolon
DECL|function|floppy_disable_hlt
r_static
r_void
id|floppy_disable_hlt
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|hlt_disabled
)paren
(brace
id|hlt_disabled
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef HAVE_DISABLE_HLT
id|disable_hlt
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|floppy_enable_hlt
r_static
r_void
id|floppy_enable_hlt
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hlt_disabled
)paren
(brace
id|hlt_disabled
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef HAVE_DISABLE_HLT
id|enable_hlt
c_func
(paren
)paren
suffix:semicolon
macro_line|#endif
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|setup_DMA
r_static
r_void
id|setup_DMA
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_FLOPPY_SANITY
r_if
c_cond
(paren
id|raw_cmd.length
op_eq
l_int|0
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;zero dma transfer size:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|raw_cmd.cmd_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%x,&quot;
comma
id|raw_cmd.cmd
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|CURRENT
op_logical_or
id|CURRENT-&gt;buffer
op_ne
id|current_addr
op_logical_or
id|raw_cmd.length
OG
l_int|512
op_star
id|CURRENT-&gt;nr_sectors
)paren
op_logical_and
(paren
id|current_addr
template_param
id|floppy_track_buffer
op_plus
l_int|1024
op_star
id|max_buffer_sectors
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bad address. start=%p lg=%lx tb=%p&bslash;n&quot;
comma
id|current_addr
comma
id|raw_cmd.length
comma
id|floppy_track_buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;buffer=%p nr=%lx cnr=%lx&bslash;n&quot;
comma
id|CURRENT-&gt;buffer
comma
id|CURRENT-&gt;nr_sectors
comma
id|CURRENT-&gt;current_nr_sectors
)paren
suffix:semicolon
)brace
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
r_int
)paren
id|current_addr
op_mod
l_int|512
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;non aligned address: %p&bslash;n&quot;
comma
id|current_addr
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CROSS_64KB
c_func
(paren
id|current_addr
comma
id|raw_cmd.length
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DMA crossing 64-K boundary %p-%p&bslash;n&quot;
comma
id|current_addr
comma
id|current_addr
op_plus
id|raw_cmd.length
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif
id|cli
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|FLOPPY_DMA
comma
(paren
id|raw_cmd.flags
op_amp
id|FD_RAW_READ
)paren
ques
c_cond
id|DMA_MODE_READ
suffix:colon
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|FLOPPY_DMA
comma
id|virt_to_bus
c_func
(paren
id|current_addr
)paren
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|FLOPPY_DMA
comma
id|raw_cmd.length
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|floppy_disable_hlt
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* sends a command byte to the fdc */
DECL|function|output_byte
r_static
r_int
id|output_byte
c_func
(paren
r_char
id|byte
)paren
(brace
r_int
id|counter
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
r_char
id|rstatus
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
l_int|10000
op_logical_and
op_logical_neg
id|FDCS-&gt;reset
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|rstatus
op_assign
id|inb_p
c_func
(paren
id|FD_STATUS
)paren
suffix:semicolon
id|status
op_assign
id|rstatus
op_amp
(paren
id|STATUS_READY
op_or
id|STATUS_DIR
op_or
id|STATUS_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|STATUS_READY
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|STATUS_READY
)paren
(brace
id|outb_p
c_func
(paren
id|byte
comma
id|FD_DATA
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_FLOPPY_SANITY
id|output_log
(braket
id|output_log_pos
)braket
dot
id|data
op_assign
id|byte
suffix:semicolon
id|output_log
(braket
id|output_log_pos
)braket
dot
id|status
op_assign
id|rstatus
suffix:semicolon
id|output_log
(braket
id|output_log_pos
)braket
dot
id|jiffies
op_assign
id|jiffies
suffix:semicolon
id|output_log_pos
op_assign
(paren
id|output_log_pos
op_plus
l_int|1
)paren
op_mod
id|OLOGSIZE
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
)brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initialising
)paren
id|DPRINT2
c_func
(paren
l_string|&quot;Unable to send byte %x to FDC. Status=%x&bslash;n&quot;
comma
id|byte
comma
id|status
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|macro|LAST_OUT
mdefine_line|#define LAST_OUT(x) if(output_byte(x)){ reset_fdc();return;}
multiline_comment|/* gets the response from the fdc */
DECL|function|result
r_static
r_int
id|result
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|counter
comma
id|status
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
l_int|10000
op_logical_and
op_logical_neg
id|FDCS-&gt;reset
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|status
op_assign
id|inb_p
c_func
(paren
id|FD_STATUS
)paren
op_amp
(paren
id|STATUS_DIR
op_or
id|STATUS_READY
op_or
id|STATUS_BUSY
op_or
id|STATUS_DMA
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|STATUS_READY
)paren
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|STATUS_READY
)paren
(brace
macro_line|#ifdef CONFIG_FLOPPY_SANITY
id|resultjiffies
op_assign
id|jiffies
suffix:semicolon
id|resultsize
op_assign
id|i
suffix:semicolon
macro_line|#endif
r_return
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|STATUS_DMA
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
(paren
id|STATUS_DIR
op_or
id|STATUS_READY
op_or
id|STATUS_BUSY
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_ge
id|MAX_REPLIES
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;floppy_stat reply overrun&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|reply_buffer
(braket
id|i
op_increment
)braket
op_assign
id|inb_p
c_func
(paren
id|FD_DATA
)paren
suffix:semicolon
)brace
)brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initialising
)paren
id|DPRINT3
c_func
(paren
l_string|&quot;Getstatus times out (%x) on fdc %d [%d]&bslash;n&quot;
comma
id|status
comma
id|fdc
comma
id|i
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Set perpendicular mode as required, based on data rate, if supported.&n; * 82077 Now tested. 1Mbps data rate only possible with 82077-1.&n; */
DECL|function|perpendicular_mode
r_static
r_inline
r_void
id|perpendicular_mode
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|perp_mode
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|floppy
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|floppy-&gt;rate
op_amp
l_int|0x40
)paren
(brace
r_switch
c_cond
(paren
id|raw_cmd.rate
)paren
(brace
r_case
l_int|0
suffix:colon
id|perp_mode
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|perp_mode
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|DPRINT
c_func
(paren
l_string|&quot;Invalid data rate for perpendicular mode!&bslash;n&quot;
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* convenient way to return to&n;&t;&t;&t;&t;&t;  * redo without to much hassle (deep&n;&t;&t;&t;&t;&t;  * stack et al. */
r_return
suffix:semicolon
)brace
)brace
r_else
id|perp_mode
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;perp_mode
op_eq
id|perp_mode
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;version
op_ge
id|FDC_82077_ORIG
op_logical_and
id|FDCS-&gt;has_fifo
)paren
(brace
id|output_byte
c_func
(paren
id|FD_PERPENDICULAR
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|perp_mode
)paren
suffix:semicolon
id|FDCS-&gt;perp_mode
op_assign
id|perp_mode
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|perp_mode
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;perpendicular mode not supported by this FDC.&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* perpendicular_mode */
DECL|macro|NOMINAL_DTR
mdefine_line|#define NOMINAL_DTR 500
multiline_comment|/* Issue a &quot;SPECIFY&quot; command to set the step rate time, head unload time,&n; * head load time, and DMA disable flag to values needed by floppy.&n; *&n; * The value &quot;dtr&quot; is the data transfer rate in Kbps.  It is needed&n; * to account for the data rate-based scaling done by the 82072 and 82077&n; * FDC types.  This parameter is ignored for other types of FDCs (i.e.&n; * 8272a).&n; *&n; * Note that changing the data transfer rate has a (probably deleterious)&n; * effect on the parameters subject to scaling for 82072/82077 FDCs, so&n; * fdc_specify is called again after each data transfer rate&n; * change.&n; *&n; * srt: 1000 to 16000 in microseconds&n; * hut: 16 to 240 milliseconds&n; * hlt: 2 to 254 milliseconds&n; *&n; * These values are rounded up to the next highest available delay time.&n; */
DECL|function|fdc_specify
r_static
r_void
id|fdc_specify
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|spec1
comma
id|spec2
suffix:semicolon
r_int
id|srt
comma
id|hlt
comma
id|hut
suffix:semicolon
r_int
r_int
id|dtr
op_assign
id|NOMINAL_DTR
suffix:semicolon
r_int
r_int
id|scale_dtr
op_assign
id|NOMINAL_DTR
suffix:semicolon
r_int
id|hlt_max_code
op_assign
l_int|0x7f
suffix:semicolon
r_int
id|hut_max_code
op_assign
l_int|0xf
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;need_configure
op_logical_and
id|FDCS-&gt;has_fifo
)paren
(brace
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
r_return
suffix:semicolon
multiline_comment|/* Turn on FIFO for 82077-class FDC (improves performance) */
multiline_comment|/* TODO: lock this in via LOCK during initialization */
id|output_byte
c_func
(paren
id|FD_CONFIGURE
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|0x2A
)paren
suffix:semicolon
multiline_comment|/* FIFO on, polling off, 10 byte threshold */
id|output_byte
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* precompensation from track 0 upwards */
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
(brace
id|FDCS-&gt;has_fifo
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|FDCS-&gt;need_configure
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*DPRINT(&quot;FIFO enabled&bslash;n&quot;);*/
)brace
r_switch
c_cond
(paren
id|raw_cmd.rate
op_amp
l_int|0x03
)paren
(brace
r_case
l_int|3
suffix:colon
id|dtr
op_assign
l_int|1000
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|dtr
op_assign
l_int|300
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|dtr
op_assign
l_int|250
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FDCS-&gt;version
op_ge
id|FDC_82072
)paren
(brace
id|scale_dtr
op_assign
id|dtr
suffix:semicolon
id|hlt_max_code
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* 0==256msec*dtr0/dtr (not linear!) */
id|hut_max_code
op_assign
l_int|0x0
suffix:semicolon
multiline_comment|/* 0==256msec*dtr0/dtr (not linear!) */
)brace
multiline_comment|/* Convert step rate from microseconds to milliseconds and 4 bits */
id|srt
op_assign
l_int|16
op_minus
(paren
id|DP-&gt;srt
op_star
id|scale_dtr
op_div
l_int|1000
op_plus
id|NOMINAL_DTR
op_minus
l_int|1
)paren
op_div
id|NOMINAL_DTR
suffix:semicolon
r_if
c_cond
(paren
id|srt
OG
l_int|0xf
)paren
id|srt
op_assign
l_int|0xf
suffix:semicolon
r_else
r_if
c_cond
(paren
id|srt
OL
l_int|0
)paren
id|srt
op_assign
l_int|0
suffix:semicolon
id|hlt
op_assign
(paren
id|DP-&gt;hlt
op_star
id|scale_dtr
op_div
l_int|2
op_plus
id|NOMINAL_DTR
op_minus
l_int|1
)paren
op_div
id|NOMINAL_DTR
suffix:semicolon
r_if
c_cond
(paren
id|hlt
OL
l_int|0x01
)paren
id|hlt
op_assign
l_int|0x01
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hlt
OG
l_int|0x7f
)paren
id|hlt
op_assign
id|hlt_max_code
suffix:semicolon
id|hut
op_assign
(paren
id|DP-&gt;hut
op_star
id|scale_dtr
op_div
l_int|16
op_plus
id|NOMINAL_DTR
op_minus
l_int|1
)paren
op_div
id|NOMINAL_DTR
suffix:semicolon
r_if
c_cond
(paren
id|hut
OL
l_int|0x1
)paren
id|hut
op_assign
l_int|0x1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hut
OG
l_int|0xf
)paren
id|hut
op_assign
id|hut_max_code
suffix:semicolon
id|spec1
op_assign
(paren
id|srt
op_lshift
l_int|4
)paren
op_or
id|hut
suffix:semicolon
id|spec2
op_assign
(paren
id|hlt
op_lshift
l_int|1
)paren
suffix:semicolon
multiline_comment|/* If these parameters did not change, just return with success */
r_if
c_cond
(paren
id|FDCS-&gt;spec1
op_ne
id|spec1
op_logical_or
id|FDCS-&gt;spec2
op_ne
id|spec2
)paren
(brace
multiline_comment|/* Go ahead and set spec1 and spec2 */
id|output_byte
c_func
(paren
id|FD_SPECIFY
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FDCS-&gt;spec1
op_assign
id|spec1
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FDCS-&gt;spec2
op_assign
id|spec2
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* fdc_specify */
multiline_comment|/* Set the FDC&squot;s data transfer rate on behalf of the specified drive.&n; * NOTE: with 82072/82077 FDCs, changing the data rate requires a reissue&n; * of the specify command (i.e. using the fdc_specify function).&n; */
DECL|function|fdc_dtr
r_static
r_int
id|fdc_dtr
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* If data rate not already set to desired value, set it. */
r_if
c_cond
(paren
id|raw_cmd.rate
op_eq
id|FDCS-&gt;dtr
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Set dtr */
id|outb_p
c_func
(paren
id|raw_cmd.rate
comma
id|FD_DCR
)paren
suffix:semicolon
multiline_comment|/* TODO: some FDC/drive combinations (C&amp;T 82C711 with TEAC 1.2MB)&n;&t; * need a stabilization period of several milliseconds to be&n;&t; * enforced after data rate changes before R/W operations.&n;&t; * Pause 5 msec to avoid trouble. (Needs to be 2 jiffies)&n;&t; */
id|FDCS-&gt;dtr
op_assign
id|raw_cmd.rate
suffix:semicolon
r_return
id|wait_for_completion
c_func
(paren
id|jiffies
op_plus
l_int|2
op_star
id|HZ
op_div
l_int|100
comma
(paren
id|timeout_fn
)paren
id|floppy_ready
)paren
suffix:semicolon
)brace
multiline_comment|/* fdc_dtr */
DECL|function|tell_sector
r_static
r_void
id|tell_sector
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;: track %d, head %d, sector %d, size %d&quot;
comma
id|R_TRACK
comma
id|R_HEAD
comma
id|R_SECTOR
comma
id|R_SIZECODE
)paren
suffix:semicolon
)brace
multiline_comment|/* tell_sector */
multiline_comment|/*&n; * Ok, this error interpreting routine is called after a&n; * DMA read/write has succeeded&n; * or failed, so we check the results, and copy any buffers.&n; * hhb: Added better error reporting.&n; * ak: Made this into a separate routine.&n; */
DECL|function|interpret_errors
r_static
r_int
id|interpret_errors
c_func
(paren
r_void
)paren
(brace
r_char
id|bad
suffix:semicolon
r_if
c_cond
(paren
id|inr
op_ne
l_int|7
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;-- FDC reply error&quot;
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* check IC to find cause of interrupt */
r_switch
c_cond
(paren
(paren
id|ST0
op_amp
id|ST0_INTR
)paren
op_rshift
l_int|6
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* error occurred during command execution */
id|bad
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_WP
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;Drive is write protected&bslash;n&quot;
)paren
suffix:semicolon
id|CLEARF
c_func
(paren
id|FD_DISK_WRITABLE
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|bad
op_assign
l_int|2
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_ND
)paren
(brace
id|SETF
c_func
(paren
id|FD_NEED_TWADDLE
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_OR
)paren
(brace
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FTD_MSG
)paren
id|DPRINT
c_func
(paren
l_string|&quot;Over/Underrun - retrying&bslash;n&quot;
)paren
suffix:semicolon
id|bad
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_star
id|errors
op_ge
id|DP-&gt;max_errors.reporting
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ST0
op_amp
id|ST0_ECE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Recalibrate failed!&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_CRC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;data CRC error&quot;
)paren
suffix:semicolon
id|tell_sector
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_CRC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CRC error&quot;
)paren
suffix:semicolon
id|tell_sector
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ST1
op_amp
(paren
id|ST1_MAM
op_or
id|ST1_ND
)paren
)paren
op_logical_or
(paren
id|ST2
op_amp
id|ST2_MAM
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|probing
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sector not found&quot;
)paren
suffix:semicolon
id|tell_sector
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;probe failed...&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_WC
)paren
(brace
multiline_comment|/* seek error */
id|printk
c_func
(paren
l_string|&quot;wrong cylinder&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_BC
)paren
(brace
multiline_comment|/* cylinder marked as bad */
id|printk
c_func
(paren
l_string|&quot;bad cylinder&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;unknown error. ST[0..2] are: 0x%x 0x%x 0x%x&quot;
comma
id|ST0
comma
id|ST1
comma
id|ST2
)paren
suffix:semicolon
id|tell_sector
c_func
(paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_WC
op_logical_or
id|ST2
op_amp
id|ST2_BC
)paren
multiline_comment|/* wrong cylinder =&gt; recal */
id|DRS-&gt;track
op_assign
id|NEED_2_RECAL
suffix:semicolon
r_return
id|bad
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* invalid command given */
id|DPRINT
c_func
(paren
l_string|&quot;Invalid FDC command given!&bslash;n&quot;
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
r_case
l_int|3
suffix:colon
id|DPRINT
c_func
(paren
l_string|&quot;Abnormal termination caused by polling&bslash;n&quot;
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* (0) Normal command termination */
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * This routine is called when everything should be correctly set up&n; * for the transfer (ie floppy motor is on, the correct floppy is&n; * selected, and the head is sitting on the right track).&n; */
DECL|function|setup_rw_floppy
r_static
r_void
id|setup_rw_floppy
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|ready_date
comma
id|r
comma
id|flags
comma
id|dflags
suffix:semicolon
id|timeout_fn
id|function
suffix:semicolon
id|flags
op_assign
id|raw_cmd.flags
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
(paren
id|FD_RAW_READ
op_or
id|FD_RAW_WRITE
)paren
)paren
id|flags
op_or_assign
id|FD_RAW_INTR
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|FD_RAW_SPIN
)paren
op_logical_and
op_logical_neg
(paren
id|flags
op_amp
id|FD_RAW_NO_MOTOR
)paren
)paren
(brace
id|ready_date
op_assign
id|DRS-&gt;spinup_date
op_plus
id|DP-&gt;spinup
suffix:semicolon
multiline_comment|/* If spinup will take a long time, rerun scandrives&n;&t;&t; * again just before spinup completion. Beware that&n;&t;&t; * after scandrives, we must again wait for selection.&n;&t;&t; */
r_if
c_cond
(paren
id|ready_date
OG
id|jiffies
op_plus
id|DP-&gt;select_delay
)paren
(brace
id|ready_date
op_sub_assign
id|DP-&gt;select_delay
suffix:semicolon
id|function
op_assign
(paren
id|timeout_fn
)paren
id|floppy_start
suffix:semicolon
)brace
r_else
id|function
op_assign
(paren
id|timeout_fn
)paren
id|setup_rw_floppy
suffix:semicolon
multiline_comment|/* wait until the floppy is spinning fast enough */
r_if
c_cond
(paren
id|wait_for_completion
c_func
(paren
id|ready_date
comma
id|function
)paren
)paren
r_return
suffix:semicolon
)brace
id|dflags
op_assign
id|DRS-&gt;flags
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flags
op_amp
id|FD_RAW_READ
)paren
op_logical_or
(paren
id|flags
op_amp
id|FD_RAW_WRITE
)paren
)paren
id|setup_DMA
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|flags
op_amp
id|FD_RAW_INTR
)paren
id|SET_INTR
c_func
(paren
id|main_command_interrupt
)paren
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|raw_cmd.cmd_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|r
op_or_assign
id|output_byte
c_func
(paren
id|raw_cmd.cmd
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;rw_command: &quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|r
)paren
(brace
id|reset_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|flags
op_amp
id|FD_RAW_INTR
)paren
)paren
(brace
id|inr
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|interrupt
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|flags
op_amp
id|FD_RAW_NEED_DISK
)paren
id|fd_watchdog
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|blind_seek
r_static
r_int
id|blind_seek
suffix:semicolon
multiline_comment|/*&n; * This is the routine called after every seek (or recalibrate) interrupt&n; * from the floppy controller.&n; */
DECL|function|seek_interrupt
r_static
r_void
id|seek_interrupt
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;seek interrupt:&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|inr
op_ne
l_int|2
op_logical_or
(paren
id|ST0
op_amp
l_int|0xF8
)paren
op_ne
l_int|0x20
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;seek failed&bslash;n&quot;
)paren
suffix:semicolon
id|DRS-&gt;track
op_assign
id|NEED_2_RECAL
suffix:semicolon
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DRS-&gt;track
op_ge
l_int|0
op_logical_and
id|DRS-&gt;track
op_ne
id|ST1
op_logical_and
op_logical_neg
id|blind_seek
)paren
(brace
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;clearing NEWCHANGE flag because of effective seek&bslash;n&quot;
)paren
suffix:semicolon
id|DPRINT1
c_func
(paren
l_string|&quot;jiffies=%ld&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
)brace
macro_line|#endif
id|CLEARF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
suffix:semicolon
multiline_comment|/* effective seek */
id|DRS-&gt;select_date
op_assign
id|jiffies
suffix:semicolon
)brace
id|DRS-&gt;track
op_assign
id|ST1
suffix:semicolon
id|floppy_ready
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|check_wp
r_static
r_void
id|check_wp
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|TESTF
c_func
(paren
id|FD_VERIFY
)paren
)paren
(brace
multiline_comment|/* check write protection */
id|output_byte
c_func
(paren
id|FD_GETSTATUS
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
c_func
(paren
)paren
op_ne
l_int|1
)paren
(brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
id|CLEARF
c_func
(paren
id|FD_VERIFY
)paren
suffix:semicolon
id|CLEARF
c_func
(paren
id|FD_NEED_TWADDLE
)paren
suffix:semicolon
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;checking whether disk is write protected&bslash;n&quot;
)paren
suffix:semicolon
id|DPRINT1
c_func
(paren
l_string|&quot;wp=%x&bslash;n&quot;
comma
id|ST3
op_amp
l_int|0x40
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|ST3
op_amp
l_int|0x40
)paren
)paren
id|SETF
c_func
(paren
id|FD_DISK_WRITABLE
)paren
suffix:semicolon
r_else
id|CLEARF
c_func
(paren
id|FD_DISK_WRITABLE
)paren
suffix:semicolon
)brace
)brace
DECL|function|seek_floppy
r_static
r_void
id|seek_floppy
c_func
(paren
r_void
)paren
(brace
r_int
id|track
suffix:semicolon
id|blind_seek
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;calling disk change from seek&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|TESTF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
op_logical_and
id|disk_change
c_func
(paren
id|current_drive
)paren
op_logical_and
(paren
id|raw_cmd.flags
op_amp
id|FD_RAW_NEED_DISK
)paren
)paren
(brace
multiline_comment|/* the media changed flag should be cleared after the seek.&n;&t;&t; * If it isn&squot;t, this means that there is really no disk in&n;&t;&t; * the drive.&n;&t;&t; */
id|SETF
c_func
(paren
id|FD_DISK_CHANGED
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|DRS-&gt;track
op_le
id|NEED_1_RECAL
)paren
(brace
id|recalibrate_floppy
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|TESTF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
op_logical_and
(paren
id|raw_cmd.flags
op_amp
id|FD_RAW_NEED_DISK
)paren
op_logical_and
(paren
id|DRS-&gt;track
op_le
id|NO_TRACK
op_logical_or
id|DRS-&gt;track
op_eq
id|raw_cmd.track
)paren
)paren
(brace
multiline_comment|/* we seek to clear the media-changed condition. Does anybody&n;&t;&t; * know a more elegant way, which works on all drives? */
r_if
c_cond
(paren
id|raw_cmd.track
)paren
id|track
op_assign
id|raw_cmd.track
op_minus
l_int|1
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_SILENT_DCL_CLEAR
)paren
(brace
id|set_dor
c_func
(paren
id|fdc
comma
op_complement
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
comma
l_int|0
)paren
suffix:semicolon
id|blind_seek
op_assign
l_int|1
suffix:semicolon
id|raw_cmd.flags
op_or_assign
id|FD_RAW_NEED_SEEK
suffix:semicolon
)brace
id|track
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|check_wp
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd.track
op_ne
id|DRS-&gt;track
op_logical_and
(paren
id|raw_cmd.flags
op_amp
id|FD_RAW_NEED_SEEK
)paren
)paren
id|track
op_assign
id|raw_cmd.track
suffix:semicolon
r_else
(brace
id|setup_rw_floppy
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|SET_INTR
c_func
(paren
id|seek_interrupt
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_SEEK
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
id|LAST_OUT
c_func
(paren
id|track
)paren
suffix:semicolon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;seek command:&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|recal_interrupt
r_static
r_void
id|recal_interrupt
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;recal interrupt:&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|inr
op_ne
l_int|2
)paren
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ST0
op_amp
id|ST0_ECE
)paren
(brace
r_switch
c_cond
(paren
id|DRS-&gt;track
)paren
(brace
r_case
id|NEED_1_RECAL
suffix:colon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;recal interrupt need 1 recal:&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* after a second recalibrate, we still haven&squot;t&n;&t;&t;&t; * reached track 0. Probably no drive. Raise an&n;&t;&t;&t; * error, as failing immediately might upset &n;&t;&t;&t; * computers possessed by the Devil :-) */
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|NEED_2_RECAL
suffix:colon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;recal interrupt need 2 recal:&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If we already did a recalibrate, and we are not at&n;&t;&t;&t; * track 0, this means we have moved. (The only way&n;&t;&t;&t; * not to move at recalibration is to be already at&n;&t;&t;&t; * track 0.) Clear the new change flag&n;&t;&t;&t; */
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;clearing NEWCHANGE flag because of second recalibrate&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|CLEARF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
suffix:semicolon
id|DRS-&gt;select_date
op_assign
id|jiffies
suffix:semicolon
multiline_comment|/* fall through */
r_default
suffix:colon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;recal interrupt default:&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Recalibrate moves the head by at most 80 steps. If&n;&t;&t;&t; * after one recalibrate we don&squot;t have reached track&n;&t;&t;&t; * 0, this might mean that we started beyond track 80.&n;&t;&t;&t; * Try again.&n;&t;&t;&t; */
id|DRS-&gt;track
op_assign
id|NEED_1_RECAL
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
id|DRS-&gt;track
op_assign
id|ST1
suffix:semicolon
id|floppy_ready
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Unexpected interrupt - Print as much debugging info as we can...&n; * All bets are off...&n; */
DECL|function|unexpected_floppy_interrupt
r_static
r_void
id|unexpected_floppy_interrupt
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|initialising
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|print_unex
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;unexpected interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inr
op_ge
l_int|0
)paren
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|inr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d %x&bslash;n&quot;
comma
id|i
comma
id|reply_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
id|inr
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inr
op_ne
l_int|2
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|print_unex
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sensei&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|inr
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%d %x&bslash;n&quot;
comma
id|i
comma
id|reply_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
)brace
)brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
)brace
DECL|variable|floppy_tq
r_struct
id|tq_struct
id|floppy_tq
op_assign
(brace
l_int|0
comma
l_int|0
comma
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|unexpected_floppy_interrupt
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* interrupt handler */
DECL|function|floppy_interrupt
r_static
r_void
id|floppy_interrupt
c_func
(paren
r_int
id|irq
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
)paren
op_assign
id|DEVICE_INTR
suffix:semicolon
id|lasthandler
op_assign
id|handler
suffix:semicolon
id|interruptjiffies
op_assign
id|jiffies
suffix:semicolon
id|floppy_enable_hlt
c_func
(paren
)paren
suffix:semicolon
id|CLEAR_INTR
suffix:semicolon
r_if
c_cond
(paren
id|fdc
op_ge
id|N_FDC
op_logical_or
id|FDCS-&gt;address
op_eq
op_minus
l_int|1
)paren
(brace
multiline_comment|/* we don&squot;t even know which FDC is the culprit */
id|printk
c_func
(paren
l_string|&quot;DOR0=%x&bslash;n&quot;
comma
id|fdc_state
(braket
l_int|0
)braket
dot
id|dor
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;floppy interrupt on bizarre fdc %d&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;handler=%p&bslash;n&quot;
comma
id|handler
)paren
suffix:semicolon
id|is_alive
c_func
(paren
l_string|&quot;bizarre fdc&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|inr
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
(brace
id|unexpected_floppy_interrupt
c_func
(paren
)paren
suffix:semicolon
id|is_alive
c_func
(paren
l_string|&quot;unexpected&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inr
op_eq
l_int|0
)paren
(brace
r_do
(brace
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
id|inr
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|ST0
op_amp
l_int|0x83
)paren
op_ne
id|UNIT
c_func
(paren
id|current_drive
)paren
op_logical_and
id|inr
op_eq
l_int|2
)paren
suffix:semicolon
)brace
id|floppy_tq.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|handler
suffix:semicolon
id|queue_task_irq
c_func
(paren
op_amp
id|floppy_tq
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
id|is_alive
c_func
(paren
l_string|&quot;normal interrupt end&quot;
)paren
suffix:semicolon
)brace
DECL|function|recalibrate_floppy
r_static
r_void
id|recalibrate_floppy
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;recalibrate floppy:&quot;
)paren
suffix:semicolon
macro_line|#endif
id|SET_INTR
c_func
(paren
id|recal_interrupt
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_RECALIBRATE
)paren
suffix:semicolon
id|LAST_OUT
c_func
(paren
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Must do 4 FD_SENSEIs after reset because of ``drive polling&squot;&squot;.&n; */
DECL|function|reset_interrupt
r_static
r_void
id|reset_interrupt
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;reset interrupt:&quot;
)paren
suffix:semicolon
macro_line|#endif
id|fdc_specify
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* reprogram fdc */
id|result
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* get the status ready for set_fdc */
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* a reset just after a reset. BAD! */
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * reset is done by pulling bit 2 of DOR low for a while (old FDC&squot;s),&n; * or by setting the self clearing bit 7 of STATUS (newer FDC&squot;s)&n; */
DECL|function|reset_fdc
r_static
r_void
id|reset_fdc
c_func
(paren
r_void
)paren
(brace
id|SET_INTR
c_func
(paren
id|reset_interrupt
)paren
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|0
suffix:semicolon
id|reset_fdc_info
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;version
op_ge
id|FDC_82077
)paren
id|outb_p
c_func
(paren
l_int|0x80
op_or
(paren
id|FDCS-&gt;dtr
op_amp
l_int|3
)paren
comma
id|FD_STATUS
)paren
suffix:semicolon
r_else
(brace
id|outb_p
c_func
(paren
id|FDCS-&gt;dor
op_amp
op_complement
l_int|0x04
comma
id|FD_DOR
)paren
suffix:semicolon
id|udelay
c_func
(paren
id|FD_RESET_DELAY
)paren
suffix:semicolon
id|outb
c_func
(paren
id|FDCS-&gt;dor
comma
id|FD_DOR
)paren
suffix:semicolon
)brace
)brace
DECL|function|empty
r_static
r_void
id|empty
c_func
(paren
r_void
)paren
(brace
)brace
DECL|function|show_floppy
r_void
id|show_floppy
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;floppy driver state&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;-------------------&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;now=%ld last interrupt=%d last called handler=%p&bslash;n&quot;
comma
id|jiffies
comma
id|interruptjiffies
comma
id|lasthandler
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_FLOPPY_SANITY
id|printk
c_func
(paren
l_string|&quot;timeout_message=%s&bslash;n&quot;
comma
id|timeout_message
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;last output bytes:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|OLOGSIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2x %2x %ld&bslash;n&quot;
comma
id|output_log
(braket
(paren
id|i
op_plus
id|output_log_pos
)paren
op_mod
id|OLOGSIZE
)braket
dot
id|data
comma
id|output_log
(braket
(paren
id|i
op_plus
id|output_log_pos
)paren
op_mod
id|OLOGSIZE
)braket
dot
id|status
comma
id|output_log
(braket
(paren
id|i
op_plus
id|output_log_pos
)paren
op_mod
id|OLOGSIZE
)braket
dot
id|jiffies
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;last result at %d&bslash;n&quot;
comma
id|resultjiffies
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;last redo_fd_request at %d&bslash;n&quot;
comma
id|lastredo
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|resultsize
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%2x &quot;
comma
id|reply_buffer
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#if 0
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_FDC
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|FDCS-&gt;address
op_ne
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;dor %d = %x&bslash;n&quot;
comma
id|i
comma
id|fdc_state
(braket
id|i
)braket
dot
id|dor
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|fdc_state
(braket
id|i
)braket
dot
id|address
op_plus
l_int|2
comma
id|fdc_state
(braket
id|i
)braket
dot
id|dor
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|1000
)paren
suffix:semicolon
multiline_comment|/* maybe we&squot;ll catch an interrupt... */
)brace
)brace
macro_line|#endif
id|printk
c_func
(paren
l_string|&quot;status=%x&bslash;n&quot;
comma
id|inb_p
c_func
(paren
id|FD_STATUS
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fdc_busy=%d&bslash;n&quot;
comma
id|fdc_busy
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DEVICE_INTR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;DEVICE_INTR=%p&bslash;n&quot;
comma
id|DEVICE_INTR
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|floppy_tq.sync
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;floppy_tq.routine=%p&bslash;n&quot;
comma
id|floppy_tq.routine
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fd_timer.prev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd_timer.function=%p&bslash;n&quot;
comma
id|fd_timer.function
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fd_timeout.prev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;timer_table=%p&bslash;n&quot;
comma
id|fd_timeout.function
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;expires=%ld&bslash;n&quot;
comma
id|fd_timeout.expires
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;now=%ld&bslash;n&quot;
comma
id|jiffies
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;cont=%p&bslash;n&quot;
comma
id|cont
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CURRENT=%p&bslash;n&quot;
comma
id|CURRENT
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;command_status=%d&bslash;n&quot;
comma
id|command_status
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|floppy_shutdown
r_static
r_void
id|floppy_shutdown
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|initialising
)paren
(brace
id|show_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
id|CLEAR_INTR
suffix:semicolon
id|floppy_tq.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|empty
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
id|floppy_enable_hlt
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
multiline_comment|/* avoid dma going to a random drive after shutdown */
r_if
c_cond
(paren
op_logical_neg
id|initialising
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;floppy timeout&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cont
)paren
(brace
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* this will recall reset when needed */
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;no cont in shutdown!&bslash;n&quot;
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
id|is_alive
c_func
(paren
l_string|&quot;floppy shutdown&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*typedef void (*timeout_fn)(unsigned long);*/
multiline_comment|/* start motor, check media-changed condition and write protection */
DECL|function|start_motor
r_static
r_int
id|start_motor
c_func
(paren
r_void
(paren
op_star
id|function
)paren
(paren
r_void
)paren
)paren
(brace
r_int
id|mask
comma
id|data
suffix:semicolon
id|mask
op_assign
l_int|0xfc
suffix:semicolon
id|data
op_assign
id|UNIT
c_func
(paren
id|current_drive
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|raw_cmd.flags
op_amp
id|FD_RAW_NO_MOTOR
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|FDCS-&gt;dor
op_amp
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
)paren
)paren
(brace
id|set_debugt
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* no read since this drive is running */
id|DRS-&gt;first_read_date
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* note motor start time if motor is not yet running */
id|DRS-&gt;spinup_date
op_assign
id|jiffies
suffix:semicolon
id|data
op_or_assign
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|FDCS-&gt;dor
op_amp
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
)paren
id|mask
op_and_assign
op_complement
(paren
l_int|0x10
op_lshift
id|UNIT
c_func
(paren
id|current_drive
)paren
)paren
suffix:semicolon
multiline_comment|/* starts motor and selects floppy */
id|del_timer
c_func
(paren
id|motor_off_timer
op_plus
id|current_drive
)paren
suffix:semicolon
id|set_dor
c_func
(paren
id|fdc
comma
id|mask
comma
id|data
)paren
suffix:semicolon
multiline_comment|/* wait_for_completion also schedules reset if needed. */
r_return
id|wait_for_completion
c_func
(paren
id|DRS-&gt;select_date
op_plus
id|DP-&gt;select_delay
comma
(paren
id|timeout_fn
)paren
id|function
)paren
suffix:semicolon
)brace
DECL|function|floppy_ready
r_static
r_void
id|floppy_ready
c_func
(paren
r_void
)paren
(brace
id|CHECK_RESET
suffix:semicolon
r_if
c_cond
(paren
id|start_motor
c_func
(paren
id|floppy_ready
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fdc_dtr
c_func
(paren
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;calling disk change from floppy_ready&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|raw_cmd.flags
op_amp
id|FD_RAW_NO_MOTOR
)paren
op_logical_and
id|disk_change
c_func
(paren
id|current_drive
)paren
op_logical_and
op_logical_neg
id|DP-&gt;select_delay
)paren
(brace
id|twaddle
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* this clears the dcl on certain drive/controller&n;&t;&t;&t;    * combinations */
r_if
c_cond
(paren
id|raw_cmd.flags
op_amp
(paren
id|FD_RAW_NEED_SEEK
op_or
id|FD_RAW_NEED_DISK
)paren
)paren
(brace
id|perpendicular_mode
c_func
(paren
)paren
suffix:semicolon
id|fdc_specify
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* must be done here because of hut, hlt ... */
id|seek_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
id|setup_rw_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|floppy_start
r_static
r_void
id|floppy_start
c_func
(paren
r_void
)paren
(brace
id|reschedule_timeout
c_func
(paren
id|CURRENTD
comma
l_string|&quot;floppy start&quot;
comma
l_int|0
)paren
suffix:semicolon
id|scandrives
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;setting NEWCHANGE in floppy_start&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|SETF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
suffix:semicolon
id|floppy_ready
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * ========================================================================&n; * here ends the bottom half. Exported routines are:&n; * floppy_start, floppy_off, floppy_ready, lock_fdc, unlock_fdc, set_fdc,&n; * start_motor, reset_fdc, reset_fdc_info, interpret_errors.&n; * Initialisation also uses output_byte, result, set_dor, floppy_interrupt&n; * and set_dor.&n; * ========================================================================&n; */
multiline_comment|/*&n; * General purpose continuations.&n; * ==============================&n; */
DECL|function|do_wakeup
r_static
r_void
id|do_wakeup
c_func
(paren
r_void
)paren
(brace
id|reschedule_timeout
c_func
(paren
id|MAXTIMEOUT
comma
l_string|&quot;do wakeup&quot;
comma
l_int|0
)paren
suffix:semicolon
id|cont
op_assign
l_int|0
suffix:semicolon
id|command_status
op_add_assign
l_int|2
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|command_done
)paren
suffix:semicolon
)brace
DECL|variable|wakeup_cont
r_static
r_struct
id|cont_t
id|wakeup_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|wait_til_done
r_static
r_int
id|wait_til_done
c_func
(paren
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
)paren
comma
r_int
id|interruptible
)paren
(brace
r_int
id|ret
suffix:semicolon
id|floppy_tq.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|handler
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|floppy_tq
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|command_status
OL
l_int|2
op_logical_and
id|NO_SIGNAL
)paren
(brace
id|is_alive
c_func
(paren
l_string|&quot;wait_til_done&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current-&gt;pid
)paren
id|interruptible_sleep_on
c_func
(paren
op_amp
id|command_done
)paren
suffix:semicolon
r_else
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|run_task_queue
c_func
(paren
op_amp
id|tq_timer
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|command_status
OL
l_int|2
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|floppy_shutdown
c_func
(paren
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINTR
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
id|command_status
op_assign
id|FD_COMMAND_ERROR
suffix:semicolon
r_if
c_cond
(paren
id|command_status
op_eq
id|FD_COMMAND_OKAY
)paren
id|ret
op_assign
l_int|0
suffix:semicolon
r_else
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|command_status
op_assign
id|FD_COMMAND_NONE
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|generic_done
r_static
r_void
id|generic_done
c_func
(paren
r_int
id|result
)paren
(brace
id|command_status
op_assign
id|result
suffix:semicolon
id|cont
op_assign
op_amp
id|wakeup_cont
suffix:semicolon
)brace
DECL|function|generic_success
r_static
r_void
id|generic_success
c_func
(paren
r_void
)paren
(brace
id|generic_done
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|generic_failure
r_static
r_void
id|generic_failure
c_func
(paren
r_void
)paren
(brace
id|generic_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|success_and_wakeup
r_static
r_void
id|success_and_wakeup
c_func
(paren
r_void
)paren
(brace
id|generic_success
c_func
(paren
)paren
suffix:semicolon
id|do_wakeup
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|failure_and_wakeup
r_static
r_void
id|failure_and_wakeup
c_func
(paren
r_void
)paren
(brace
id|generic_failure
c_func
(paren
)paren
suffix:semicolon
id|do_wakeup
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * formatting and rw support.&n; * ==========================&n; */
DECL|function|next_valid_format
r_static
r_int
id|next_valid_format
c_func
(paren
r_void
)paren
(brace
r_int
id|probed_format
suffix:semicolon
id|probed_format
op_assign
id|DRS-&gt;probed_format
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|probed_format
op_ge
l_int|8
op_logical_or
op_logical_neg
id|DP-&gt;autodetect
(braket
id|probed_format
)braket
)paren
(brace
id|DRS-&gt;probed_format
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|floppy_type
(braket
id|DP-&gt;autodetect
(braket
id|probed_format
)braket
)braket
dot
id|sect
)paren
(brace
id|DRS-&gt;probed_format
op_assign
id|probed_format
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|probed_format
op_increment
suffix:semicolon
)brace
)brace
DECL|function|bad_flp_intr
r_static
r_void
id|bad_flp_intr
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|probing
)paren
(brace
id|DRS-&gt;probed_format
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|next_valid_format
c_func
(paren
)paren
)paren
r_return
suffix:semicolon
)brace
(paren
op_star
id|errors
)paren
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_star
id|errors
OG
id|DRWE-&gt;badness
)paren
id|DRWE-&gt;badness
op_assign
op_star
id|errors
suffix:semicolon
r_if
c_cond
(paren
op_star
id|errors
OG
id|DP-&gt;max_errors
dot
m_abort
)paren
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|errors
OG
id|DP-&gt;max_errors.reset
)paren
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_star
id|errors
OG
id|DP-&gt;max_errors.recal
)paren
id|DRS-&gt;track
op_assign
id|NEED_2_RECAL
suffix:semicolon
)brace
DECL|function|set_floppy
r_static
r_void
id|set_floppy
c_func
(paren
r_int
id|device
)paren
(brace
r_if
c_cond
(paren
id|TYPE
c_func
(paren
id|device
)paren
)paren
id|floppy
op_assign
id|TYPE
c_func
(paren
id|device
)paren
op_plus
id|floppy_type
suffix:semicolon
r_else
id|floppy
op_assign
id|current_type
(braket
id|DRIVE
c_func
(paren
id|device
)paren
)braket
suffix:semicolon
)brace
multiline_comment|/*&n; * formatting and support.&n; * =======================&n; */
DECL|function|format_interrupt
r_static
r_void
id|format_interrupt
c_func
(paren
r_void
)paren
(brace
r_switch
c_cond
(paren
id|interpret_errors
c_func
(paren
)paren
)paren
(brace
r_case
l_int|1
suffix:colon
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
r_case
l_int|2
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|macro|CODE2SIZE
mdefine_line|#define CODE2SIZE (ssize = ( ( 1 &lt;&lt; SIZECODE ) + 3 ) &gt;&gt; 2)
DECL|macro|FM_MODE
mdefine_line|#define FM_MODE(x,y) ((y) &amp; ~(((x)-&gt;rate &amp; 0x80 ) &gt;&gt;1))
DECL|macro|CT
mdefine_line|#define CT(x) ( (x) | 0x40 )
DECL|function|setup_format_params
r_static
r_void
id|setup_format_params
c_func
(paren
r_void
)paren
(brace
r_struct
id|fparm
(brace
r_int
r_char
id|track
comma
id|head
comma
id|sect
comma
id|size
suffix:semicolon
)brace
op_star
id|here
op_assign
(paren
r_struct
id|fparm
op_star
)paren
id|floppy_track_buffer
suffix:semicolon
r_int
id|il
comma
id|n
suffix:semicolon
r_int
id|count
comma
id|head_shift
comma
id|track_shift
suffix:semicolon
id|raw_cmd.flags
op_assign
id|FD_RAW_WRITE
op_or
id|FD_RAW_INTR
op_or
id|FD_RAW_SPIN
op_or
multiline_comment|/*FD_RAW_NEED_DISK |*/
id|FD_RAW_NEED_SEEK
suffix:semicolon
id|raw_cmd.rate
op_assign
id|floppy-&gt;rate
op_amp
l_int|0x3
suffix:semicolon
id|raw_cmd.cmd_count
op_assign
id|NR_F
suffix:semicolon
id|COMMAND
op_assign
id|FM_MODE
c_func
(paren
id|floppy
comma
id|FD_FORMAT
)paren
suffix:semicolon
id|DR_SELECT
op_assign
id|UNIT
c_func
(paren
id|current_drive
)paren
op_plus
id|PH_HEAD
c_func
(paren
id|floppy
comma
id|format_req.head
)paren
suffix:semicolon
id|F_SIZECODE
op_assign
id|FD_SIZECODE
c_func
(paren
id|floppy
)paren
suffix:semicolon
id|F_SECT_PER_TRACK
op_assign
id|floppy-&gt;sect
op_lshift
l_int|2
op_rshift
id|F_SIZECODE
suffix:semicolon
id|F_GAP
op_assign
id|floppy-&gt;fmt_gap
suffix:semicolon
id|F_FILL
op_assign
id|FD_FILL_BYTE
suffix:semicolon
id|current_addr
op_assign
id|floppy_track_buffer
suffix:semicolon
id|raw_cmd.length
op_assign
l_int|4
op_star
id|F_SECT_PER_TRACK
suffix:semicolon
multiline_comment|/* allow for about 30ms for data transport per track */
id|head_shift
op_assign
(paren
id|F_SECT_PER_TRACK
op_plus
l_int|5
)paren
op_div
l_int|6
suffix:semicolon
multiline_comment|/* a ``cylinder&squot;&squot; is two tracks plus a little stepping time */
id|track_shift
op_assign
l_int|2
op_star
id|head_shift
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* position of logical sector 1 on this track */
id|n
op_assign
(paren
id|track_shift
op_star
id|format_req.track
op_plus
id|head_shift
op_star
id|format_req.head
)paren
op_mod
id|F_SECT_PER_TRACK
suffix:semicolon
multiline_comment|/* determine interleave */
id|il
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|floppy-&gt;sect
OG
id|DP-&gt;interleave_sect
op_logical_and
id|F_SIZECODE
op_eq
l_int|2
)paren
id|il
op_increment
suffix:semicolon
multiline_comment|/* initialize field */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|F_SECT_PER_TRACK
suffix:semicolon
op_increment
id|count
)paren
(brace
id|here
(braket
id|count
)braket
dot
id|track
op_assign
id|format_req.track
suffix:semicolon
id|here
(braket
id|count
)braket
dot
id|head
op_assign
id|format_req.head
suffix:semicolon
id|here
(braket
id|count
)braket
dot
id|sect
op_assign
l_int|0
suffix:semicolon
id|here
(braket
id|count
)braket
dot
id|size
op_assign
id|F_SIZECODE
suffix:semicolon
)brace
multiline_comment|/* place logical sectors */
r_for
c_loop
(paren
id|count
op_assign
l_int|1
suffix:semicolon
id|count
op_le
id|F_SECT_PER_TRACK
suffix:semicolon
op_increment
id|count
)paren
(brace
id|here
(braket
id|n
)braket
dot
id|sect
op_assign
id|count
suffix:semicolon
id|n
op_assign
(paren
id|n
op_plus
id|il
)paren
op_mod
id|F_SECT_PER_TRACK
suffix:semicolon
r_if
c_cond
(paren
id|here
(braket
id|n
)braket
dot
id|sect
)paren
(brace
multiline_comment|/* sector busy, find next free sector */
op_increment
id|n
suffix:semicolon
r_if
c_cond
(paren
id|n
op_ge
id|F_SECT_PER_TRACK
)paren
(brace
id|n
op_sub_assign
id|F_SECT_PER_TRACK
suffix:semicolon
r_while
c_loop
(paren
id|here
(braket
id|n
)braket
dot
id|sect
)paren
op_increment
id|n
suffix:semicolon
)brace
)brace
)brace
)brace
DECL|function|redo_format
r_static
r_void
id|redo_format
c_func
(paren
r_void
)paren
(brace
id|raw_cmd.track
op_assign
id|format_req.track
op_lshift
id|STRETCH
c_func
(paren
id|floppy
)paren
suffix:semicolon
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|setup_format_params
c_func
(paren
)paren
suffix:semicolon
id|floppy_start
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;queue format request&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|variable|format_cont
r_static
r_struct
id|cont_t
id|format_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|do_format
r_static
r_int
id|do_format
c_func
(paren
r_int
id|device
comma
r_struct
id|format_descr
op_star
id|tmp_format_req
)paren
(brace
r_int
id|ret
suffix:semicolon
r_int
id|drive
op_assign
id|DRIVE
c_func
(paren
id|device
)paren
suffix:semicolon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
id|set_floppy
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|floppy
op_logical_or
id|floppy-&gt;track
OG
id|DP-&gt;tracks
op_logical_or
id|tmp_format_req-&gt;track
op_ge
id|floppy-&gt;track
op_logical_or
id|tmp_format_req-&gt;head
op_ge
id|floppy-&gt;head
op_logical_or
(paren
id|floppy-&gt;sect
op_lshift
l_int|2
)paren
op_mod
(paren
l_int|1
op_lshift
id|FD_SIZECODE
c_func
(paren
id|floppy
)paren
)paren
op_logical_or
op_logical_neg
id|floppy-&gt;fmt_gap
)paren
(brace
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|format_req
op_assign
op_star
id|tmp_format_req
suffix:semicolon
id|format_errors
op_assign
l_int|0
suffix:semicolon
id|cont
op_assign
op_amp
id|format_cont
suffix:semicolon
id|errors
op_assign
op_amp
id|format_errors
suffix:semicolon
id|IWAIT
c_func
(paren
id|redo_format
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Buffer read/write and support&n; * =============================&n; */
multiline_comment|/* new request_done. Can handle physical sectors which are smaller than a&n; * logical buffer */
DECL|function|request_done
r_static
r_void
id|request_done
c_func
(paren
r_int
id|uptodate
)paren
(brace
r_int
id|block
suffix:semicolon
id|probing
op_assign
l_int|0
suffix:semicolon
id|reschedule_timeout
c_func
(paren
id|MAXTIMEOUT
comma
l_string|&quot;request done %d&quot;
comma
id|uptodate
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CURRENT
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;request list destroyed in floppy request done&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|uptodate
)paren
(brace
multiline_comment|/* maintain values for invalidation on geometry&n;&t;&t;   change */
id|block
op_assign
id|current_count_sectors
op_plus
id|CURRENT-&gt;sector
suffix:semicolon
r_if
c_cond
(paren
id|block
OG
id|DRS-&gt;maxblock
)paren
id|DRS-&gt;maxblock
op_assign
id|block
suffix:semicolon
r_if
c_cond
(paren
id|block
OG
id|floppy-&gt;sect
)paren
id|DRS-&gt;maxtrack
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* unlock chained buffers */
r_while
c_loop
(paren
id|current_count_sectors
op_logical_and
id|CURRENT
op_logical_and
id|current_count_sectors
op_ge
id|CURRENT-&gt;current_nr_sectors
)paren
(brace
id|current_count_sectors
op_sub_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current_count_sectors
op_logical_and
id|CURRENT
)paren
(brace
multiline_comment|/* &quot;unlock&quot; last subsector */
id|CURRENT-&gt;buffer
op_add_assign
id|current_count_sectors
op_lshift
l_int|9
suffix:semicolon
id|CURRENT-&gt;current_nr_sectors
op_sub_assign
id|current_count_sectors
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|current_count_sectors
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|current_count_sectors
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current_count_sectors
op_logical_and
op_logical_neg
id|CURRENT
)paren
id|DPRINT
c_func
(paren
l_string|&quot;request list destroyed in floppy request done&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|WRITE
)paren
(brace
multiline_comment|/* record write error information */
id|DRWE-&gt;write_errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|DRWE-&gt;write_errors
op_eq
l_int|1
)paren
(brace
id|DRWE-&gt;first_error_sector
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|DRWE-&gt;first_error_generation
op_assign
id|DRS-&gt;generation
suffix:semicolon
)brace
id|DRWE-&gt;last_error_sector
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|DRWE-&gt;last_error_generation
op_assign
id|DRS-&gt;generation
suffix:semicolon
)brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Interrupt handler evaluating the result of the r/w operation */
DECL|function|rw_interrupt
r_static
r_void
id|rw_interrupt
c_func
(paren
r_void
)paren
(brace
r_int
id|nr_sectors
comma
id|ssize
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|DRS-&gt;first_read_date
)paren
id|DRS-&gt;first_read_date
op_assign
id|jiffies
suffix:semicolon
id|nr_sectors
op_assign
l_int|0
suffix:semicolon
id|CODE2SIZE
suffix:semicolon
id|nr_sectors
op_assign
(paren
(paren
id|R_TRACK
op_minus
id|TRACK
)paren
op_star
id|floppy-&gt;head
op_plus
id|R_HEAD
op_minus
id|HEAD
)paren
op_star
id|floppy-&gt;sect
op_plus
(paren
(paren
id|R_SECTOR
op_minus
id|SECTOR
)paren
op_lshift
id|SIZECODE
op_rshift
l_int|2
)paren
op_minus
(paren
id|sector_t
op_mod
id|floppy-&gt;sect
)paren
op_mod
id|ssize
suffix:semicolon
macro_line|#ifdef CONFIG_FLOPPY_SANITY
r_if
c_cond
(paren
id|nr_sectors
OG
id|current_count_sectors
op_plus
id|ssize
op_minus
(paren
id|current_count_sectors
op_plus
id|sector_t
)paren
op_mod
id|ssize
op_plus
id|sector_t
op_mod
id|ssize
)paren
(brace
id|DPRINT2
c_func
(paren
l_string|&quot;long rw: %x instead of %lx&bslash;n&quot;
comma
id|nr_sectors
comma
id|current_count_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rs=%d s=%d&bslash;n&quot;
comma
id|R_SECTOR
comma
id|SECTOR
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rh=%d h=%d&bslash;n&quot;
comma
id|R_HEAD
comma
id|HEAD
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;rt=%d t=%d&bslash;n&quot;
comma
id|R_TRACK
comma
id|TRACK
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;spt=%d st=%d ss=%d&bslash;n&quot;
comma
id|SECT_PER_TRACK
comma
id|sector_t
comma
id|ssize
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|nr_sectors
OL
l_int|0
)paren
id|nr_sectors
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|nr_sectors
OL
id|current_count_sectors
)paren
id|current_count_sectors
op_assign
id|nr_sectors
suffix:semicolon
r_switch
c_cond
(paren
id|interpret_errors
c_func
(paren
)paren
)paren
(brace
r_case
l_int|2
suffix:colon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|current_count_sectors
)paren
(brace
id|cont
op_member_access_from_pointer
id|error
c_func
(paren
)paren
suffix:semicolon
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
l_int|0
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|current_count_sectors
)paren
(brace
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|current_type
(braket
id|current_drive
)braket
op_assign
id|floppy
suffix:semicolon
id|floppy_sizes
(braket
id|DRIVE
c_func
(paren
id|current_drive
)paren
op_plus
(paren
id|FDC
c_func
(paren
id|current_drive
)paren
op_lshift
l_int|7
)paren
)braket
op_assign
id|floppy-&gt;size
op_rshift
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|probing
)paren
(brace
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FTD_MSG
)paren
id|DPRINT2
c_func
(paren
l_string|&quot;Auto-detected floppy type %s in fd%d&bslash;n&quot;
comma
id|floppy-&gt;name
comma
id|current_drive
)paren
suffix:semicolon
id|current_type
(braket
id|current_drive
)braket
op_assign
id|floppy
suffix:semicolon
id|floppy_sizes
(braket
id|DRIVE
c_func
(paren
id|current_drive
)paren
op_plus
(paren
id|FDC
c_func
(paren
id|current_drive
)paren
op_lshift
l_int|7
)paren
)braket
op_assign
id|floppy-&gt;size
op_rshift
l_int|1
suffix:semicolon
id|probing
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_ne
id|FD_READ
op_logical_or
id|current_addr
op_eq
id|CURRENT-&gt;buffer
)paren
(brace
multiline_comment|/* transfer directly from buffer */
id|cont
op_member_access_from_pointer
id|done
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
(brace
id|buffer_track
op_assign
id|raw_cmd.track
suffix:semicolon
id|buffer_drive
op_assign
id|current_drive
suffix:semicolon
r_if
c_cond
(paren
id|nr_sectors
op_plus
id|sector_t
OG
id|buffer_max
)paren
id|buffer_max
op_assign
id|nr_sectors
op_plus
id|sector_t
suffix:semicolon
)brace
id|cont
op_member_access_from_pointer
id|redo
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Compute maximal contiguous buffer size. */
DECL|function|buffer_chain_size
r_static
r_int
id|buffer_chain_size
c_func
(paren
r_void
)paren
(brace
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|size
suffix:semicolon
r_char
op_star
id|base
suffix:semicolon
id|base
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|size
op_assign
id|CURRENT-&gt;current_nr_sectors
op_lshift
l_int|9
suffix:semicolon
id|bh
op_assign
id|CURRENT-&gt;bh
suffix:semicolon
r_if
c_cond
(paren
id|bh
)paren
(brace
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
r_while
c_loop
(paren
id|bh
op_logical_and
id|bh-&gt;b_data
op_eq
id|base
op_plus
id|size
)paren
(brace
id|size
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
)brace
)brace
r_return
id|size
op_rshift
l_int|9
suffix:semicolon
)brace
multiline_comment|/* Compute the maximal transfer size */
DECL|function|transfer_size
r_static
r_int
id|transfer_size
c_func
(paren
r_int
id|ssize
comma
r_int
id|max_sector
comma
r_int
id|max_size
)paren
(brace
r_if
c_cond
(paren
id|max_sector
OG
id|sector_t
op_plus
id|max_size
)paren
id|max_sector
op_assign
id|sector_t
op_plus
id|max_size
suffix:semicolon
multiline_comment|/* alignment */
id|max_sector
op_sub_assign
(paren
id|max_sector
op_mod
id|floppy-&gt;sect
)paren
op_mod
id|ssize
suffix:semicolon
multiline_comment|/* transfer size, beginning not aligned */
id|current_count_sectors
op_assign
id|max_sector
op_minus
id|sector_t
suffix:semicolon
r_return
id|max_sector
suffix:semicolon
)brace
multiline_comment|/*&n; * Move data from/to the track buffer to/from the buffer cache.&n; */
DECL|function|copy_buffer
r_static
r_void
id|copy_buffer
c_func
(paren
r_int
id|ssize
comma
r_int
id|max_sector
comma
r_int
id|max_sector_2
)paren
(brace
r_int
id|remaining
suffix:semicolon
multiline_comment|/* number of transferred 512-byte sectors */
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_char
op_star
id|buffer
comma
op_star
id|dma_buffer
suffix:semicolon
r_int
id|size
suffix:semicolon
r_if
c_cond
(paren
id|max_sector
OG
id|max_sector_2
)paren
id|max_sector
op_assign
id|max_sector_2
suffix:semicolon
id|max_sector
op_assign
id|transfer_size
c_func
(paren
id|ssize
comma
id|max_sector
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_count_sectors
op_le
l_int|0
op_logical_and
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_WRITE
op_logical_and
id|buffer_max
OG
id|sector_t
op_plus
id|CURRENT-&gt;nr_sectors
)paren
(brace
id|current_count_sectors
op_assign
id|buffer_max
op_minus
id|sector_t
suffix:semicolon
r_if
c_cond
(paren
id|current_count_sectors
OG
id|CURRENT-&gt;nr_sectors
)paren
id|current_count_sectors
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
)brace
id|remaining
op_assign
id|current_count_sectors
op_lshift
l_int|9
suffix:semicolon
macro_line|#ifdef CONFIG_FLOPPY_SANITY
r_if
c_cond
(paren
(paren
id|remaining
op_rshift
l_int|9
)paren
OG
id|CURRENT-&gt;nr_sectors
op_logical_and
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_WRITE
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;in copy buffer&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current_count_sectors=%ld&bslash;n&quot;
comma
id|current_count_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;remaining=%d&bslash;n&quot;
comma
id|remaining
op_rshift
l_int|9
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CURRENT-&gt;nr_sectors=%ld&bslash;n&quot;
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;CURRENT-&gt;current_nr_sectors=%ld&bslash;n&quot;
comma
id|CURRENT-&gt;current_nr_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;max_sector=%d&bslash;n&quot;
comma
id|max_sector
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ssize=%d&bslash;n&quot;
comma
id|ssize
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|max_sector
OG
id|buffer_max
)paren
id|buffer_max
op_assign
id|max_sector
suffix:semicolon
id|dma_buffer
op_assign
id|floppy_track_buffer
op_plus
(paren
(paren
id|sector_t
op_minus
id|buffer_min
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
id|bh
op_assign
id|CURRENT-&gt;bh
suffix:semicolon
id|size
op_assign
id|CURRENT-&gt;current_nr_sectors
op_lshift
l_int|9
suffix:semicolon
id|buffer
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
r_while
c_loop
(paren
id|remaining
OG
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|size
OG
id|remaining
)paren
id|size
op_assign
id|remaining
suffix:semicolon
macro_line|#ifdef CONFIG_FLOPPY_SANITY
r_if
c_cond
(paren
id|dma_buffer
op_plus
id|size
OG
id|floppy_track_buffer
op_plus
(paren
id|max_buffer_sectors
op_lshift
l_int|10
)paren
op_logical_or
id|dma_buffer
OL
id|floppy_track_buffer
)paren
(brace
id|DPRINT1
c_func
(paren
l_string|&quot;buffer overrun in copy buffer %d&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
(paren
id|floppy_track_buffer
op_minus
id|dma_buffer
)paren
op_rshift
l_int|9
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sector_t=%d buffer_min=%d&bslash;n&quot;
comma
id|sector_t
comma
id|buffer_min
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current_count_sectors=%ld&bslash;n&quot;
comma
id|current_count_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
id|printk
c_func
(paren
l_string|&quot;read&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
id|printk
c_func
(paren
l_string|&quot;write&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
(paren
r_int
r_int
)paren
id|buffer
)paren
op_mod
l_int|512
)paren
id|DPRINT1
c_func
(paren
l_string|&quot;%p buffer not aligned&bslash;n&quot;
comma
id|buffer
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
id|memcpy
c_func
(paren
id|buffer
comma
id|dma_buffer
comma
id|size
)paren
suffix:semicolon
r_else
id|memcpy
c_func
(paren
id|dma_buffer
comma
id|buffer
comma
id|size
)paren
suffix:semicolon
id|remaining
op_sub_assign
id|size
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|remaining
)paren
r_break
suffix:semicolon
id|dma_buffer
op_add_assign
id|size
suffix:semicolon
id|bh
op_assign
id|bh-&gt;b_reqnext
suffix:semicolon
macro_line|#ifdef CONFIG_FLOPPY_SANITY
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;bh=null in copy buffer after copy&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
id|size
op_assign
id|bh-&gt;b_size
suffix:semicolon
id|buffer
op_assign
id|bh-&gt;b_data
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_FLOPPY_SANITY
r_if
c_cond
(paren
id|remaining
)paren
(brace
r_if
c_cond
(paren
id|remaining
OG
l_int|0
)paren
id|max_sector
op_sub_assign
id|remaining
op_rshift
l_int|9
suffix:semicolon
id|DPRINT1
c_func
(paren
l_string|&quot;weirdness: remaining %d&bslash;n&quot;
comma
id|remaining
op_rshift
l_int|9
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/*&n; * Formulate a read/write request.&n; * this routine decides where to load the data (directly to buffer, or to&n; * tmp floppy area), how much data to load (the size of the buffer, the whole&n; * track, or a single sector)&n; * All floppy_track_buffer handling goes in here. If we ever add track buffer&n; * allocation on the fly, it should be done here. No other part should need&n; * modification.&n; */
DECL|function|make_raw_rw_request
r_static
r_int
id|make_raw_rw_request
c_func
(paren
r_void
)paren
(brace
r_int
id|aligned_sector_t
suffix:semicolon
r_int
id|max_sector
comma
id|max_size
comma
id|tracksize
comma
id|ssize
suffix:semicolon
id|set_fdc
c_func
(paren
id|DRIVE
c_func
(paren
id|CURRENT-&gt;dev
)paren
)paren
suffix:semicolon
id|raw_cmd.flags
op_assign
id|FD_RAW_SPIN
op_or
id|FD_RAW_NEED_DISK
op_or
id|FD_RAW_NEED_DISK
op_or
id|FD_RAW_NEED_SEEK
suffix:semicolon
id|raw_cmd.cmd_count
op_assign
id|NR_RW
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|READ
)paren
(brace
id|raw_cmd.flags
op_or_assign
id|FD_RAW_READ
suffix:semicolon
id|COMMAND
op_assign
id|FM_MODE
c_func
(paren
id|floppy
comma
id|FD_READ
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|WRITE
)paren
(brace
id|raw_cmd.flags
op_or_assign
id|FD_RAW_WRITE
suffix:semicolon
id|COMMAND
op_assign
id|FM_MODE
c_func
(paren
id|floppy
comma
id|FD_WRITE
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
c_func
(paren
l_string|&quot;make_raw_rw_request: unknown command&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|max_sector
op_assign
id|floppy-&gt;sect
op_star
id|floppy-&gt;head
suffix:semicolon
id|TRACK
op_assign
id|CURRENT-&gt;sector
op_div
id|max_sector
suffix:semicolon
id|sector_t
op_assign
id|CURRENT-&gt;sector
op_mod
id|max_sector
suffix:semicolon
r_if
c_cond
(paren
id|floppy-&gt;track
op_logical_and
id|TRACK
op_ge
id|floppy-&gt;track
)paren
r_return
l_int|0
suffix:semicolon
id|HEAD
op_assign
id|sector_t
op_div
id|floppy-&gt;sect
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|floppy-&gt;stretch
op_amp
id|FD_SWAPSIDES
)paren
op_logical_or
id|TESTF
c_func
(paren
id|FD_NEED_TWADDLE
)paren
)paren
op_logical_and
id|sector_t
OL
id|floppy-&gt;sect
)paren
id|max_sector
op_assign
id|floppy-&gt;sect
suffix:semicolon
multiline_comment|/* 2M disks have phantom sectors on the first track */
r_if
c_cond
(paren
(paren
id|floppy-&gt;rate
op_amp
id|FD_2M
)paren
op_logical_and
(paren
op_logical_neg
id|TRACK
)paren
op_logical_and
(paren
op_logical_neg
id|HEAD
)paren
)paren
(brace
id|max_sector
op_assign
l_int|2
op_star
id|floppy-&gt;sect
op_div
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|sector_t
op_ge
id|max_sector
)paren
(brace
id|current_count_sectors
op_assign
(paren
id|floppy-&gt;sect
op_minus
id|sector_t
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_count_sectors
OG
id|CURRENT-&gt;nr_sectors
)paren
id|current_count_sectors
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|SIZECODE
op_assign
l_int|2
suffix:semicolon
)brace
r_else
id|SIZECODE
op_assign
id|FD_SIZECODE
c_func
(paren
id|floppy
)paren
suffix:semicolon
id|raw_cmd.rate
op_assign
id|floppy-&gt;rate
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
(paren
id|floppy-&gt;rate
op_amp
id|FD_2M
)paren
op_logical_and
(paren
id|TRACK
op_logical_or
id|HEAD
)paren
op_logical_and
id|raw_cmd.rate
op_eq
l_int|2
)paren
id|raw_cmd.rate
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|SIZECODE
)paren
id|SIZECODE2
op_assign
l_int|0xff
suffix:semicolon
r_else
id|SIZECODE2
op_assign
l_int|0x80
suffix:semicolon
id|raw_cmd.track
op_assign
id|TRACK
op_lshift
id|STRETCH
c_func
(paren
id|floppy
)paren
suffix:semicolon
id|DR_SELECT
op_assign
id|UNIT
c_func
(paren
id|current_drive
)paren
op_plus
id|PH_HEAD
c_func
(paren
id|floppy
comma
id|HEAD
)paren
suffix:semicolon
id|GAP
op_assign
id|floppy-&gt;gap
suffix:semicolon
id|CODE2SIZE
suffix:semicolon
id|SECT_PER_TRACK
op_assign
id|floppy-&gt;sect
op_lshift
l_int|2
op_rshift
id|SIZECODE
suffix:semicolon
id|SECTOR
op_assign
(paren
(paren
id|sector_t
op_mod
id|floppy-&gt;sect
)paren
op_lshift
l_int|2
op_rshift
id|SIZECODE
)paren
op_plus
l_int|1
suffix:semicolon
id|tracksize
op_assign
id|floppy-&gt;sect
op_minus
id|floppy-&gt;sect
op_mod
id|ssize
suffix:semicolon
r_if
c_cond
(paren
id|tracksize
OL
id|floppy-&gt;sect
)paren
(brace
id|SECT_PER_TRACK
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|tracksize
op_le
id|sector_t
op_mod
id|floppy-&gt;sect
)paren
id|SECTOR
op_decrement
suffix:semicolon
r_while
c_loop
(paren
id|tracksize
op_le
id|sector_t
op_mod
id|floppy-&gt;sect
)paren
(brace
r_while
c_loop
(paren
id|tracksize
op_plus
id|ssize
OG
id|floppy-&gt;sect
)paren
(brace
id|SIZECODE
op_decrement
suffix:semicolon
id|ssize
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|SECTOR
op_increment
suffix:semicolon
id|SECT_PER_TRACK
op_increment
suffix:semicolon
id|tracksize
op_add_assign
id|ssize
suffix:semicolon
)brace
id|max_sector
op_assign
id|HEAD
op_star
id|floppy-&gt;sect
op_plus
id|tracksize
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|TRACK
op_logical_and
op_logical_neg
id|HEAD
op_logical_and
op_logical_neg
(paren
id|floppy-&gt;rate
op_amp
id|FD_2M
)paren
op_logical_and
id|probing
)paren
id|max_sector
op_assign
id|floppy-&gt;sect
suffix:semicolon
id|aligned_sector_t
op_assign
id|sector_t
op_minus
(paren
id|sector_t
op_mod
id|floppy-&gt;sect
)paren
op_mod
id|ssize
suffix:semicolon
id|max_size
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
r_if
c_cond
(paren
(paren
id|raw_cmd.track
op_eq
id|buffer_track
)paren
op_logical_and
(paren
id|current_drive
op_eq
id|buffer_drive
)paren
op_logical_and
(paren
id|sector_t
op_ge
id|buffer_min
)paren
op_logical_and
(paren
id|sector_t
OL
id|buffer_max
)paren
)paren
(brace
multiline_comment|/* data already in track buffer */
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
(brace
id|copy_buffer
c_func
(paren
l_int|1
comma
id|max_sector
comma
id|buffer_max
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|aligned_sector_t
op_ne
id|sector_t
op_logical_or
id|CURRENT-&gt;nr_sectors
OL
id|ssize
)paren
(brace
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_WRITE
)paren
(brace
r_if
c_cond
(paren
id|sector_t
op_plus
id|CURRENT-&gt;nr_sectors
OG
id|ssize
op_logical_and
id|sector_t
op_plus
id|CURRENT-&gt;nr_sectors
OL
id|ssize
op_plus
id|ssize
)paren
(brace
id|max_size
op_assign
id|ssize
op_plus
id|ssize
suffix:semicolon
)brace
r_else
id|max_size
op_assign
id|ssize
suffix:semicolon
)brace
id|raw_cmd.flags
op_and_assign
op_complement
id|FD_RAW_WRITE
suffix:semicolon
id|raw_cmd.flags
op_or_assign
id|FD_RAW_READ
suffix:semicolon
id|COMMAND
op_assign
id|FM_MODE
c_func
(paren
id|floppy
comma
id|FD_READ
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
r_int
r_int
)paren
id|CURRENT-&gt;buffer
OL
id|MAX_DMA_ADDRESS
)paren
(brace
r_int
id|direct
comma
id|indirect
suffix:semicolon
id|indirect
op_assign
id|transfer_size
c_func
(paren
id|ssize
comma
id|max_sector
comma
id|max_buffer_sectors
op_star
l_int|2
)paren
op_minus
id|sector_t
suffix:semicolon
id|max_size
op_assign
id|buffer_chain_size
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|max_size
OG
(paren
id|MAX_DMA_ADDRESS
op_minus
(paren
(paren
r_int
r_int
)paren
id|CURRENT-&gt;buffer
)paren
)paren
op_rshift
l_int|9
)paren
id|max_size
op_assign
(paren
id|MAX_DMA_ADDRESS
op_minus
(paren
(paren
r_int
r_int
)paren
id|CURRENT-&gt;buffer
)paren
)paren
op_rshift
l_int|9
suffix:semicolon
multiline_comment|/* 64 kb boundaries */
r_if
c_cond
(paren
id|CROSS_64KB
c_func
(paren
id|CURRENT-&gt;buffer
comma
id|max_size
op_lshift
l_int|9
)paren
)paren
id|max_size
op_assign
(paren
id|K_64
op_minus
(paren
(paren
r_int
)paren
id|CURRENT-&gt;buffer
)paren
op_mod
id|K_64
)paren
op_rshift
l_int|9
suffix:semicolon
id|direct
op_assign
id|transfer_size
c_func
(paren
id|ssize
comma
id|max_sector
comma
id|max_size
)paren
op_minus
id|sector_t
suffix:semicolon
multiline_comment|/*&n;&t;&t; * We try to read tracks, but if we get too many errors, we&n;&t;&t; * go back to reading just one sector at a time.&n;&t;&t; *&n;&t;&t; * This means we should be able to read a sector even if there&n;&t;&t; * are other bad sectors on this track.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|direct
op_logical_or
(paren
id|indirect
op_star
l_int|2
OG
id|direct
op_star
l_int|3
op_logical_and
op_star
id|errors
OL
id|DP-&gt;max_errors.read_track
op_logical_and
multiline_comment|/*!TESTF( FD_NEED_TWADDLE) &amp;&amp;*/
(paren
(paren
op_logical_neg
id|probing
op_logical_or
(paren
id|DP-&gt;read_track
op_amp
(paren
l_int|1
op_lshift
id|DRS-&gt;probed_format
)paren
)paren
)paren
)paren
)paren
)paren
(brace
id|max_size
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
)brace
r_else
(brace
id|current_addr
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|raw_cmd.length
op_assign
id|current_count_sectors
op_lshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd.length
op_eq
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;zero dma transfer attempted from make_raw_request&bslash;n&quot;
)paren
suffix:semicolon
id|DPRINT3
c_func
(paren
l_string|&quot;indirect=%d direct=%d sector_t=%d&quot;
comma
id|indirect
comma
id|direct
comma
id|sector_t
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|2
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
id|max_size
op_assign
id|max_sector
suffix:semicolon
multiline_comment|/* unbounded */
multiline_comment|/* claim buffer track if needed */
r_if
c_cond
(paren
id|buffer_track
op_ne
id|raw_cmd.track
op_logical_or
multiline_comment|/* bad track */
id|buffer_drive
op_ne
id|current_drive
op_logical_or
multiline_comment|/* bad drive */
id|sector_t
OG
id|buffer_max
op_logical_or
id|sector_t
OL
id|buffer_min
op_logical_or
(paren
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
op_logical_or
(paren
id|aligned_sector_t
op_eq
id|sector_t
op_logical_and
id|CURRENT-&gt;nr_sectors
op_ge
id|ssize
)paren
)paren
op_logical_and
id|max_sector
OG
l_int|2
op_star
id|max_buffer_sectors
op_plus
id|buffer_min
op_logical_and
id|max_size
op_plus
id|sector_t
OG
l_int|2
op_star
id|max_buffer_sectors
op_plus
id|buffer_min
)paren
multiline_comment|/* not enough space */
)paren
(brace
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|buffer_drive
op_assign
id|current_drive
suffix:semicolon
id|buffer_max
op_assign
id|buffer_min
op_assign
id|aligned_sector_t
suffix:semicolon
)brace
id|current_addr
op_assign
id|floppy_track_buffer
op_plus
(paren
(paren
id|aligned_sector_t
op_minus
id|buffer_min
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_WRITE
)paren
(brace
multiline_comment|/* copy write buffer to track buffer.&n;&t;&t; * if we get here, we know that the write&n;&t;&t; * is either aligned or the data already in the buffer&n;&t;&t; * (buffer will be overwritten) */
macro_line|#ifdef CONFIG_FLOPPY_SANITY
r_if
c_cond
(paren
id|sector_t
op_ne
id|aligned_sector_t
op_logical_and
id|buffer_track
op_eq
op_minus
l_int|1
)paren
id|DPRINT
c_func
(paren
l_string|&quot;internal error offset !=0 on write&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|buffer_track
op_assign
id|raw_cmd.track
suffix:semicolon
id|buffer_drive
op_assign
id|current_drive
suffix:semicolon
id|copy_buffer
c_func
(paren
id|ssize
comma
id|max_sector
comma
l_int|2
op_star
id|max_buffer_sectors
op_plus
id|buffer_min
)paren
suffix:semicolon
)brace
r_else
id|transfer_size
c_func
(paren
id|ssize
comma
id|max_sector
comma
l_int|2
op_star
id|max_buffer_sectors
op_plus
id|buffer_min
op_minus
id|aligned_sector_t
)paren
suffix:semicolon
multiline_comment|/* round up current_count_sectors to get dma xfer size */
id|raw_cmd.length
op_assign
id|sector_t
op_plus
id|current_count_sectors
op_minus
id|aligned_sector_t
suffix:semicolon
id|raw_cmd.length
op_assign
(paren
(paren
id|raw_cmd.length
op_minus
l_int|1
)paren
op_or
(paren
id|ssize
op_minus
l_int|1
)paren
)paren
op_plus
l_int|1
suffix:semicolon
id|raw_cmd.length
op_lshift_assign
l_int|9
suffix:semicolon
macro_line|#ifdef CONFIG_FLOPPY_SANITY
r_if
c_cond
(paren
(paren
id|raw_cmd.length
OL
id|current_count_sectors
op_lshift
l_int|9
)paren
op_logical_or
(paren
id|current_addr
op_ne
id|CURRENT-&gt;buffer
op_logical_and
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_WRITE
op_logical_and
(paren
id|aligned_sector_t
op_plus
(paren
id|raw_cmd.length
op_rshift
l_int|9
)paren
OG
id|buffer_max
op_logical_or
id|aligned_sector_t
OL
id|buffer_min
)paren
)paren
op_logical_or
id|raw_cmd.length
op_mod
(paren
l_int|128
op_lshift
id|SIZECODE
)paren
op_logical_or
id|raw_cmd.length
op_le
l_int|0
op_logical_or
id|current_count_sectors
op_le
l_int|0
)paren
(brace
id|DPRINT2
c_func
(paren
l_string|&quot;fractionary current count b=%lx s=%lx&bslash;n&quot;
comma
id|raw_cmd.length
comma
id|current_count_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|current_addr
op_ne
id|CURRENT-&gt;buffer
)paren
id|printk
c_func
(paren
l_string|&quot;addr=%d, length=%ld&bslash;n&quot;
comma
(paren
r_int
)paren
(paren
(paren
id|current_addr
op_minus
id|floppy_track_buffer
)paren
op_rshift
l_int|9
)paren
comma
id|current_count_sectors
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;st=%d ast=%d mse=%d msi=%d&bslash;n&quot;
comma
id|sector_t
comma
id|aligned_sector_t
comma
id|max_sector
comma
id|max_size
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;ssize=%x SIZECODE=%d&bslash;n&quot;
comma
id|ssize
comma
id|SIZECODE
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;command=%x SECTOR=%d HEAD=%d, TRACK=%d&bslash;n&quot;
comma
id|COMMAND
comma
id|SECTOR
comma
id|HEAD
comma
id|TRACK
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer drive=%d&bslash;n&quot;
comma
id|buffer_drive
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer track=%d&bslash;n&quot;
comma
id|buffer_track
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer_min=%d&bslash;n&quot;
comma
id|buffer_min
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;buffer_max=%d&bslash;n&quot;
comma
id|buffer_max
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|current_addr
op_ne
id|CURRENT-&gt;buffer
)paren
(brace
r_if
c_cond
(paren
id|current_addr
OL
id|floppy_track_buffer
op_logical_or
id|current_count_sectors
OL
l_int|0
op_logical_or
id|raw_cmd.length
template_param
id|floppy_track_buffer
op_plus
(paren
id|max_buffer_sectors
op_lshift
l_int|10
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;buffer overrun in schedule dma&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sector_t=%d buffer_min=%d current_count=%ld&bslash;n&quot;
comma
id|sector_t
comma
id|buffer_min
comma
id|raw_cmd.length
op_rshift
l_int|9
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;current_count_sectors=%ld&bslash;n&quot;
comma
id|current_count_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
id|printk
c_func
(paren
l_string|&quot;read&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CT
c_func
(paren
id|COMMAND
)paren
op_eq
id|FD_READ
)paren
id|printk
c_func
(paren
l_string|&quot;write&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|raw_cmd.length
OG
id|CURRENT-&gt;nr_sectors
op_lshift
l_int|9
op_logical_or
id|current_count_sectors
OG
id|CURRENT-&gt;nr_sectors
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;buffer overrun in direct transfer&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|raw_cmd.length
OL
id|current_count_sectors
op_lshift
l_int|9
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;more sectors than bytes&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bytes=%ld&bslash;n&quot;
comma
id|raw_cmd.length
op_rshift
l_int|9
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;sectors=%ld&bslash;n&quot;
comma
id|current_count_sectors
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raw_cmd.length
op_eq
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;zero dma transfer attempted from make_raw_request&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|2
suffix:semicolon
)brace
DECL|function|redo_fd_request
r_static
r_void
id|redo_fd_request
c_func
(paren
r_void
)paren
(brace
DECL|macro|REPEAT
mdefine_line|#define REPEAT {request_done(0); continue; }
r_int
id|device
suffix:semicolon
r_int
id|tmp
suffix:semicolon
r_int
id|error
suffix:semicolon
id|error
op_assign
op_minus
l_int|1
suffix:semicolon
id|lastredo
op_assign
id|jiffies
suffix:semicolon
r_if
c_cond
(paren
id|current_drive
OL
id|N_DRIVE
)paren
id|floppy_off
c_func
(paren
id|current_drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_logical_and
id|CURRENT-&gt;dev
OL
l_int|0
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;current dev &lt; 0!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|CURRENT
)paren
(brace
id|CLEAR_INTR
suffix:semicolon
id|unlock_fdc
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
op_ne
id|MAJOR_NR
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: request list destroyed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;bh
op_logical_and
op_logical_neg
id|CURRENT-&gt;bh-&gt;b_lock
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
op_logical_neg
id|CURRENT-&gt;bh-&gt;b_count
op_logical_and
(paren
id|CURRENT-&gt;errors
op_logical_or
id|error
op_eq
id|CURRENT-&gt;dev
)paren
)paren
(brace
id|error
op_assign
id|CURRENT-&gt;dev
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;skipping read ahead buffer&bslash;n&quot;
)paren
suffix:semicolon
id|REPEAT
suffix:semicolon
)brace
macro_line|#endif
id|error
op_assign
op_minus
l_int|1
suffix:semicolon
id|device
op_assign
id|CURRENT-&gt;dev
suffix:semicolon
id|set_fdc
c_func
(paren
id|DRIVE
c_func
(paren
id|device
)paren
)paren
suffix:semicolon
id|reschedule_timeout
c_func
(paren
id|CURRENTD
comma
l_string|&quot;redo fd request&quot;
comma
l_int|0
)paren
suffix:semicolon
id|set_floppy
c_func
(paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_motor
c_func
(paren
id|redo_fd_request
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|current_drive
comma
op_amp
id|fake_change
)paren
op_logical_or
id|TESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;disk absent or changed during operation&bslash;n&quot;
)paren
suffix:semicolon
id|REPEAT
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|floppy
)paren
(brace
multiline_comment|/* Autodetection */
r_if
c_cond
(paren
op_logical_neg
id|probing
)paren
(brace
id|DRS-&gt;probed_format
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|next_valid_format
c_func
(paren
)paren
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;no autodetectable formats&bslash;n&quot;
)paren
suffix:semicolon
id|floppy
op_assign
l_int|NULL
suffix:semicolon
id|REPEAT
suffix:semicolon
)brace
)brace
id|probing
op_assign
l_int|1
suffix:semicolon
id|floppy
op_assign
id|floppy_type
op_plus
id|DP-&gt;autodetect
(braket
id|DRS-&gt;probed_format
)braket
suffix:semicolon
)brace
r_else
id|probing
op_assign
l_int|0
suffix:semicolon
id|errors
op_assign
op_amp
(paren
id|CURRENT-&gt;errors
)paren
suffix:semicolon
id|tmp
op_assign
id|make_raw_rw_request
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp
OL
l_int|2
)paren
(brace
id|request_done
c_func
(paren
id|tmp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|TESTF
c_func
(paren
id|FD_NEED_TWADDLE
)paren
)paren
id|twaddle
c_func
(paren
)paren
suffix:semicolon
id|floppy_tq.routine
op_assign
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|floppy_start
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|floppy_tq
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
macro_line|#ifdef DEBUGT
id|debugt
c_func
(paren
l_string|&quot;queue fd request&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
DECL|macro|REPEAT
macro_line|#undef REPEAT
)brace
DECL|variable|rw_cont
r_static
r_struct
id|cont_t
id|rw_cont
op_assign
initialization_block
suffix:semicolon
DECL|variable|request_tq
r_struct
id|tq_struct
id|request_tq
op_assign
(brace
l_int|0
comma
l_int|0
comma
(paren
r_void
op_star
)paren
(paren
r_void
op_star
)paren
id|redo_fd_request
comma
l_int|0
)brace
suffix:semicolon
DECL|function|process_fd_request
r_static
r_void
id|process_fd_request
c_func
(paren
r_void
)paren
(brace
id|cont
op_assign
op_amp
id|rw_cont
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|request_tq
comma
op_amp
id|tq_timer
)paren
suffix:semicolon
)brace
DECL|function|do_fd_request
r_static
r_void
id|do_fd_request
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|fdc_busy
)paren
(brace
multiline_comment|/* fdc busy, this new request will be treated when the&n;&t;&t;   current one is done */
id|is_alive
c_func
(paren
l_string|&quot;do fd request, old request running&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* fdc_busy cannot be set by an interrupt or a bh */
id|floppy_grab_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
id|fdc_busy
op_assign
l_int|1
suffix:semicolon
id|reschedule_timeout
c_func
(paren
id|MAXTIMEOUT
comma
l_string|&quot;do fd request&quot;
comma
l_int|0
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
id|is_alive
c_func
(paren
l_string|&quot;do fd request&quot;
)paren
suffix:semicolon
)brace
DECL|variable|poll_cont
r_static
r_struct
id|cont_t
id|poll_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|poll_drive
r_static
r_int
(def_block
id|poll_drive
c_func
(paren
r_int
id|interruptible
comma
r_int
id|flag
)paren
(brace
r_int
id|ret
suffix:semicolon
multiline_comment|/* no auto-sense, just clear dcl */
id|raw_cmd.flags
op_assign
id|flag
suffix:semicolon
id|raw_cmd.track
op_assign
l_int|0
suffix:semicolon
id|raw_cmd.cmd_count
op_assign
l_int|0
suffix:semicolon
id|cont
op_assign
op_amp
id|poll_cont
suffix:semicolon
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;setting NEWCHANGE in poll_drive&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
id|SETF
c_func
(paren
id|FD_DISK_NEWCHANGE
)paren
suffix:semicolon
id|WAIT
c_func
(paren
id|floppy_ready
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)def_block
multiline_comment|/*&n; * User triggered reset&n; * ====================&n; */
DECL|function|reset_intr
r_static
r_void
id|reset_intr
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;weird, reset interrupt called&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|variable|reset_cont
r_static
r_struct
id|cont_t
id|reset_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|user_reset_fdc
r_static
r_int
id|user_reset_fdc
c_func
(paren
r_int
id|drive
comma
r_int
id|arg
comma
r_int
id|interruptible
)paren
(brace
r_int
id|ret
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
id|FD_RESET_IF_NEEDED
op_logical_and
op_logical_neg
id|FDCS-&gt;reset
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
id|LOCK_FDC
c_func
(paren
id|drive
comma
id|interruptible
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
op_eq
id|FD_RESET_ALWAYS
)paren
(brace
id|FDCS-&gt;reset
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
(brace
id|cont
op_assign
op_amp
id|reset_cont
suffix:semicolon
id|reschedule_timeout
c_func
(paren
id|CURRENTD
comma
l_string|&quot;user reset fdc&quot;
comma
l_int|0
)paren
suffix:semicolon
id|WAIT
c_func
(paren
id|reset_fdc
)paren
suffix:semicolon
)brace
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/*&n; * Misc Ioctl&squot;s and support&n; * ========================&n; */
DECL|function|fd_copyout
r_static
r_int
id|fd_copyout
c_func
(paren
r_void
op_star
id|param
comma
r_volatile
r_void
op_star
id|address
comma
r_int
id|size
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
id|param
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|memcpy_tofs
c_func
(paren
id|param
comma
(paren
r_void
op_star
)paren
id|address
comma
id|size
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|COPYOUT
mdefine_line|#define COPYOUT(x) (fd_copyout( (void *)param, &amp;(x), sizeof(x)))
DECL|macro|COPYIN
mdefine_line|#define COPYIN(x) (memcpy_fromfs( &amp;(x), (void *) param, sizeof(x)),0)
DECL|function|drive_name
r_static
r_char
op_star
id|drive_name
c_func
(paren
r_int
id|type
comma
r_int
id|drive
)paren
(brace
r_struct
id|floppy_struct
op_star
id|floppy
suffix:semicolon
r_if
c_cond
(paren
id|type
)paren
id|floppy
op_assign
id|floppy_type
op_plus
id|type
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|UDP-&gt;native_format
)paren
id|floppy
op_assign
id|floppy_type
op_plus
id|UDP-&gt;native_format
suffix:semicolon
r_else
r_return
l_string|&quot;(null)&quot;
suffix:semicolon
)brace
r_if
c_cond
(paren
id|floppy-&gt;name
)paren
r_return
id|floppy-&gt;name
suffix:semicolon
r_else
r_return
l_string|&quot;(null)&quot;
suffix:semicolon
)brace
multiline_comment|/* raw commands */
DECL|variable|raw_cmd_cont
r_static
r_struct
id|cont_t
id|raw_cmd_cont
op_assign
initialization_block
suffix:semicolon
DECL|function|raw_cmd_ioctl
r_static
r_int
id|raw_cmd_ioctl
c_func
(paren
r_void
op_star
id|param
)paren
(brace
r_int
id|i
comma
id|drive
comma
id|count
comma
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;rawcmd
op_le
l_int|1
)paren
id|FDCS-&gt;rawcmd
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|N_DRIVE
suffix:semicolon
id|drive
op_increment
)paren
(brace
r_if
c_cond
(paren
id|FDC
c_func
(paren
id|drive
)paren
op_ne
id|fdc
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
id|current_drive
)paren
(brace
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
OG
l_int|1
)paren
(brace
id|FDCS-&gt;rawcmd
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
)paren
(brace
id|FDCS-&gt;rawcmd
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
(brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|COPYIN
c_func
(paren
id|raw_cmd
)paren
suffix:semicolon
id|raw_cmd.rate
op_and_assign
l_int|0x03
suffix:semicolon
id|count
op_assign
id|raw_cmd.length
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd.flags
op_amp
(paren
id|FD_RAW_WRITE
op_or
id|FD_RAW_READ
)paren
)paren
(brace
r_if
c_cond
(paren
id|count
OG
id|max_buffer_sectors
op_star
l_int|1024
)paren
(brace
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;attempt to do a 0 byte dma transfer&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raw_cmd.flags
op_amp
id|FD_RAW_WRITE
)paren
(brace
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
id|raw_cmd.data
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
id|floppy_track_buffer
comma
id|raw_cmd.data
comma
id|count
)paren
suffix:semicolon
)brace
id|current_addr
op_assign
id|floppy_track_buffer
suffix:semicolon
id|cont
op_assign
op_amp
id|raw_cmd_cont
suffix:semicolon
id|IWAIT
c_func
(paren
id|floppy_start
)paren
suffix:semicolon
macro_line|#ifdef DCL_DEBUG
r_if
c_cond
(paren
id|DP-&gt;flags
op_amp
id|FD_DEBUG
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;calling disk change from raw_cmd ioctl&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|disk_change
c_func
(paren
id|current_drive
)paren
)paren
(brace
id|raw_cmd.flags
op_or_assign
id|FD_RAW_DISK_CHANGE
suffix:semicolon
)brace
r_else
id|raw_cmd.flags
op_and_assign
op_complement
id|FD_RAW_DISK_CHANGE
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd.flags
op_amp
id|FD_RAW_NO_MOTOR_AFTER
)paren
(brace
id|motor_off_callback
c_func
(paren
id|current_drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ret
op_logical_and
op_logical_neg
id|FDCS-&gt;reset
)paren
(brace
id|raw_cmd.reply_count
op_assign
id|inr
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|raw_cmd.reply_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|raw_cmd.reply
(braket
id|i
)braket
op_assign
id|reply_buffer
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|raw_cmd.flags
op_amp
(paren
id|FD_RAW_READ
op_or
id|FD_RAW_WRITE
)paren
)paren
id|raw_cmd.length
op_assign
id|get_dma_residue
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
)brace
r_else
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
id|DRS-&gt;track
op_assign
id|NO_TRACK
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|raw_cmd.flags
op_amp
id|FD_RAW_READ
)paren
(brace
id|i
op_assign
id|fd_copyout
c_func
(paren
id|raw_cmd.data
comma
id|floppy_track_buffer
comma
id|count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
)brace
r_return
id|COPYOUT
c_func
(paren
id|raw_cmd
)paren
suffix:semicolon
)brace
DECL|function|invalidate_drive
r_static
r_int
id|invalidate_drive
c_func
(paren
r_int
id|rdev
)paren
(brace
multiline_comment|/* invalidate the buffer track to force a reread */
id|set_bit
c_func
(paren
id|DRIVE
c_func
(paren
id|rdev
)paren
comma
op_amp
id|fake_change
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
id|check_disk_change
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fd_ioctl
r_static
r_int
id|fd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|param
)paren
(brace
DECL|macro|IOCTL_MODE_BIT
mdefine_line|#define IOCTL_MODE_BIT 8
DECL|macro|OPEN_WRITE_BIT
mdefine_line|#define OPEN_WRITE_BIT 16
DECL|macro|IOCTL_ALLOWED
mdefine_line|#define IOCTL_ALLOWED (filp &amp;&amp; (filp-&gt;f_mode &amp; IOCTL_MODE_BIT))
r_struct
id|floppy_struct
id|newparams
suffix:semicolon
r_struct
id|format_descr
id|tmp_format_req
suffix:semicolon
r_int
id|i
comma
id|device
comma
id|drive
comma
id|type
comma
id|cnt
suffix:semicolon
r_struct
id|floppy_struct
op_star
id|this_floppy
suffix:semicolon
r_char
op_star
id|name
suffix:semicolon
id|device
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
id|RO_IOCTLS
c_func
(paren
id|device
comma
id|param
)paren
suffix:semicolon
)brace
id|type
op_assign
id|TYPE
c_func
(paren
id|device
)paren
suffix:semicolon
id|drive
op_assign
id|DRIVE
c_func
(paren
id|device
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FDGETDRVTYP
suffix:colon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|param
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
id|name
op_assign
id|drive_name
c_func
(paren
id|type
comma
id|drive
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
l_int|16
suffix:semicolon
id|cnt
op_increment
)paren
(brace
id|put_user
c_func
(paren
id|name
(braket
id|cnt
)braket
comma
(paren
(paren
r_char
op_star
)paren
id|param
)paren
op_plus
id|cnt
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_star
id|name
)paren
r_break
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_case
id|FDGETMAXERRS
suffix:colon
r_return
id|COPYOUT
c_func
(paren
id|UDP-&gt;max_errors
)paren
suffix:semicolon
r_case
id|FDGETPRM
suffix:colon
r_if
c_cond
(paren
id|type
)paren
id|this_floppy
op_assign
op_amp
id|floppy_type
(braket
id|type
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|this_floppy
op_assign
id|current_type
(braket
id|drive
)braket
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_return
id|COPYOUT
c_func
(paren
id|this_floppy
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_case
id|FDPOLLDRVSTAT
suffix:colon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
id|CALL
c_func
(paren
id|poll_drive
c_func
(paren
l_int|1
comma
id|FD_RAW_NEED_DISK
)paren
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* fall through */
r_case
id|FDGETDRVSTAT
suffix:colon
r_return
id|COPYOUT
c_func
(paren
op_star
id|UDRS
)paren
suffix:semicolon
r_case
id|FDGETFDCSTAT
suffix:colon
r_return
id|COPYOUT
c_func
(paren
op_star
id|UFDCS
)paren
suffix:semicolon
r_case
id|FDGETDRVPRM
suffix:colon
r_return
id|COPYOUT
c_func
(paren
op_star
id|UDP
)paren
suffix:semicolon
r_case
id|FDWERRORGET
suffix:colon
r_return
id|COPYOUT
c_func
(paren
op_star
id|UDRWE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|IOCTL_ALLOWED
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FDWERRORCLR
suffix:colon
id|UDRWE-&gt;write_errors
op_assign
l_int|0
suffix:semicolon
id|UDRWE-&gt;first_error_sector
op_assign
l_int|0
suffix:semicolon
id|UDRWE-&gt;first_error_generation
op_assign
l_int|0
suffix:semicolon
id|UDRWE-&gt;last_error_sector
op_assign
l_int|0
suffix:semicolon
id|UDRWE-&gt;last_error_generation
op_assign
l_int|0
suffix:semicolon
id|UDRWE-&gt;badness
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDRAWCMD
suffix:colon
r_if
c_cond
(paren
id|type
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
id|set_floppy
c_func
(paren
id|device
)paren
suffix:semicolon
id|CALL
c_func
(paren
id|i
op_assign
id|raw_cmd_ioctl
c_func
(paren
(paren
r_void
op_star
)paren
id|param
)paren
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
r_case
id|FDFMTTRK
suffix:colon
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
op_ne
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|COPYIN
c_func
(paren
id|tmp_format_req
)paren
suffix:semicolon
r_return
id|do_format
c_func
(paren
id|device
comma
op_amp
id|tmp_format_req
)paren
suffix:semicolon
r_case
id|FDSETMAXERRS
suffix:colon
r_return
id|COPYIN
c_func
(paren
id|UDP-&gt;max_errors
)paren
suffix:semicolon
r_case
id|FDFMTBEG
suffix:colon
r_return
l_int|0
suffix:semicolon
r_case
id|FDCLRPRM
suffix:colon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
id|current_type
(braket
id|drive
)braket
op_assign
l_int|NULL
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
id|UDRS-&gt;keep_data
op_assign
l_int|0
suffix:semicolon
r_return
id|invalidate_drive
c_func
(paren
id|device
)paren
suffix:semicolon
r_case
id|FDFMTEND
suffix:colon
r_case
id|FDFLUSH
suffix:colon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_return
id|invalidate_drive
c_func
(paren
id|device
)paren
suffix:semicolon
r_case
id|FDSETPRM
suffix:colon
r_case
id|FDDEFPRM
suffix:colon
id|COPYIN
c_func
(paren
id|newparams
)paren
suffix:semicolon
multiline_comment|/* sanity checking for parameters.*/
r_if
c_cond
(paren
id|newparams.sect
op_le
l_int|0
op_logical_or
id|newparams.head
op_le
l_int|0
op_logical_or
id|newparams.track
op_le
l_int|0
op_logical_or
id|newparams.track
OG
id|UDP-&gt;tracks
op_rshift
id|STRETCH
c_func
(paren
op_amp
id|newparams
)paren
op_logical_or
multiline_comment|/* check if reserved bits are set */
(paren
id|newparams.stretch
op_amp
op_complement
(paren
id|FD_STRETCH
op_or
id|FD_SWAPSIDES
)paren
)paren
op_ne
l_int|0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|N_DRIVE
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|TYPE
c_func
(paren
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_device
)paren
op_eq
id|type
op_logical_and
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_ref
)paren
id|set_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
suffix:semicolon
)brace
id|floppy_type
(braket
id|type
)braket
op_assign
id|newparams
suffix:semicolon
id|floppy_type
(braket
id|type
)braket
dot
id|name
op_assign
l_string|&quot;user format&quot;
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
id|type
op_lshift
l_int|2
suffix:semicolon
id|cnt
OL
(paren
id|type
op_lshift
l_int|2
)paren
op_plus
l_int|4
suffix:semicolon
id|cnt
op_increment
)paren
id|floppy_sizes
(braket
id|cnt
)braket
op_assign
id|floppy_sizes
(braket
id|cnt
op_plus
l_int|0x80
)braket
op_assign
id|floppy_type
(braket
id|type
)braket
dot
id|size
op_rshift
l_int|1
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
id|N_DRIVE
suffix:semicolon
id|cnt
op_increment
)paren
(brace
r_if
c_cond
(paren
id|TYPE
c_func
(paren
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_device
)paren
op_eq
id|type
op_logical_and
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_ref
)paren
id|check_disk_change
c_func
(paren
id|drive_state
(braket
id|cnt
)braket
dot
id|fd_device
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_ne
id|FDDEFPRM
)paren
multiline_comment|/* notice a disk change immediately, else&n;&t;&t;&t; * we loose our settings immediately*/
id|CALL
c_func
(paren
id|poll_drive
c_func
(paren
l_int|1
comma
l_int|0
)paren
)paren
suffix:semicolon
id|user_params
(braket
id|drive
)braket
op_assign
id|newparams
suffix:semicolon
r_if
c_cond
(paren
id|buffer_drive
op_eq
id|drive
op_logical_and
id|buffer_max
OG
id|user_params
(braket
id|drive
)braket
dot
id|sect
)paren
id|buffer_max
op_assign
id|user_params
(braket
id|drive
)braket
dot
id|sect
suffix:semicolon
id|current_type
(braket
id|drive
)braket
op_assign
op_amp
id|user_params
(braket
id|drive
)braket
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|user_params
(braket
id|drive
)braket
dot
id|size
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|FDDEFPRM
)paren
id|DRS-&gt;keep_data
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|DRS-&gt;keep_data
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* invalidation. Invalidate only when needed, i.e.&n;&t;&t; * when there are already sectors in the buffer cache&n;&t;&t; * whose number will change. This is useful, because&n;&t;&t; * mtools often changes the geometry of the disk after&n;&t;&t; * looking at the boot block */
r_if
c_cond
(paren
id|DRS-&gt;maxblock
OG
id|user_params
(braket
id|drive
)braket
dot
id|sect
op_logical_or
id|DRS-&gt;maxtrack
)paren
id|invalidate_drive
c_func
(paren
id|device
)paren
suffix:semicolon
r_else
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDRESET
suffix:colon
r_return
id|user_reset_fdc
c_func
(paren
id|drive
comma
(paren
r_int
)paren
id|param
comma
l_int|1
)paren
suffix:semicolon
r_case
id|FDMSGON
suffix:colon
id|UDP-&gt;flags
op_or_assign
id|FTD_MSG
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDMSGOFF
suffix:colon
id|UDP-&gt;flags
op_and_assign
op_complement
id|FTD_MSG
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDSETEMSGTRESH
suffix:colon
id|UDP-&gt;max_errors.reporting
op_assign
(paren
r_int
r_int
)paren
(paren
id|param
op_amp
l_int|0x0f
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDTWADDLE
suffix:colon
id|LOCK_FDC
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
id|twaddle
c_func
(paren
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FDSETDRVPRM
suffix:colon
r_return
id|COPYIN
c_func
(paren
op_star
id|UDP
)paren
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
DECL|macro|IOCTL_ALLOWED
macro_line|#undef IOCTL_ALLOWED
)brace
DECL|function|config_types
r_static
r_void
id|config_types
c_func
(paren
r_void
)paren
(brace
r_int
id|first
op_assign
l_int|1
suffix:semicolon
r_int
id|drive
suffix:semicolon
multiline_comment|/* read drive info out of physical cmos */
id|drive
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|UDP-&gt;cmos
)paren
id|UDP-&gt;cmos
op_assign
id|FLOPPY0_TYPE
suffix:semicolon
id|drive
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|UDP-&gt;cmos
op_logical_and
id|FLOPPY1_TYPE
)paren
id|UDP-&gt;cmos
op_assign
id|FLOPPY1_TYPE
suffix:semicolon
multiline_comment|/* XXX */
multiline_comment|/* additional physical CMOS drive detection should go here */
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|N_DRIVE
suffix:semicolon
id|drive
op_increment
)paren
(brace
r_if
c_cond
(paren
id|UDP-&gt;cmos
op_ge
l_int|0
op_logical_and
id|UDP-&gt;cmos
op_le
id|NUMBER
c_func
(paren
id|default_drive_params
)paren
)paren
id|memcpy
c_func
(paren
(paren
r_char
op_star
)paren
id|UDP
comma
(paren
r_char
op_star
)paren
(paren
op_amp
id|default_drive_params
(braket
(paren
r_int
)paren
id|UDP-&gt;cmos
)braket
dot
id|params
)paren
comma
r_sizeof
(paren
r_struct
id|floppy_drive_params
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UDP-&gt;cmos
)paren
(brace
r_if
c_cond
(paren
id|first
)paren
id|printk
c_func
(paren
l_string|&quot;Floppy drive(s): &quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;, &quot;
)paren
suffix:semicolon
id|first
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|UDP-&gt;cmos
OG
l_int|0
)paren
(brace
id|ALLOWED_DRIVE_MASK
op_or_assign
l_int|1
op_lshift
id|drive
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fd%d is %s&quot;
comma
id|drive
comma
id|default_drive_params
(braket
(paren
r_int
)paren
id|UDP-&gt;cmos
)braket
dot
id|name
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;fd%d is unknown type %d&quot;
comma
id|drive
comma
id|UDP-&gt;cmos
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|first
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
DECL|function|floppy_read
r_static
r_int
id|floppy_read
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|drive
op_assign
id|DRIVE
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UTESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_return
id|block_read
c_func
(paren
id|inode
comma
id|filp
comma
id|buf
comma
id|count
)paren
suffix:semicolon
)brace
DECL|function|floppy_write
r_static
r_int
id|floppy_write
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_char
op_star
id|buf
comma
r_int
id|count
)paren
(brace
r_int
id|block
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|drive
op_assign
id|DRIVE
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|UDRS-&gt;maxblock
)paren
(brace
id|UDRS-&gt;maxblock
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* make change detectable */
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UTESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|UTESTF
c_func
(paren
id|FD_DISK_WRITABLE
)paren
)paren
(brace
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
id|block
op_assign
(paren
id|filp-&gt;f_pos
op_plus
id|count
)paren
op_rshift
l_int|9
suffix:semicolon
r_if
c_cond
(paren
id|block
OG
id|UDRS-&gt;maxblock
)paren
(brace
id|UDRS-&gt;maxblock
op_assign
id|block
suffix:semicolon
)brace
id|ret
op_assign
id|block_write
c_func
(paren
id|inode
comma
id|filp
comma
id|buf
comma
id|count
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
DECL|function|floppy_release
r_static
r_void
id|floppy_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|drive
suffix:semicolon
id|drive
op_assign
id|DRIVE
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
op_logical_or
(paren
id|filp-&gt;f_mode
op_amp
(paren
l_int|2
op_or
id|OPEN_WRITE_BIT
)paren
)paren
)paren
(brace
multiline_comment|/* if the file is mounted OR (writable now AND writable at&n;&t;&t; * open time) Linus: Does this cover all cases? */
id|block_fsync
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
OL
l_int|0
)paren
id|UDRS-&gt;fd_ref
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|UDRS-&gt;fd_ref
op_decrement
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;floppy_release with fd_ref == 0&quot;
)paren
suffix:semicolon
id|UDRS-&gt;fd_ref
op_assign
l_int|0
suffix:semicolon
)brace
id|floppy_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * floppy_open check for aliasing (/dev/fd0 can be the same as&n; * /dev/PS0 etc), and disallows simultaneous access to the same&n; * drive with different device numbers.&n; */
DECL|macro|RETERR
mdefine_line|#define RETERR(x) &bslash;&n;&t;do{floppy_release(inode,filp); &bslash;&n;&t;   return -(x);}while(0)
DECL|function|floppy_open
r_static
r_int
id|floppy_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|drive
suffix:semicolon
r_int
id|old_dev
suffix:semicolon
r_int
r_try
suffix:semicolon
r_char
op_star
id|tmp
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;Weird, open called with filp=0&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|drive
op_assign
id|DRIVE
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_ge
id|N_DRIVE
op_logical_or
op_logical_neg
(paren
id|ALLOWED_DRIVE_MASK
op_amp
(paren
l_int|1
op_lshift
id|drive
)paren
)paren
op_logical_or
id|fdc_state
(braket
id|FDC
c_func
(paren
id|drive
)paren
)braket
dot
id|version
op_eq
id|FDC_NONE
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|TYPE
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_ge
id|NUMBER
c_func
(paren
id|floppy_type
)paren
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|old_dev
op_assign
id|UDRS-&gt;fd_device
suffix:semicolon
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
op_logical_and
id|old_dev
op_ne
id|inode-&gt;i_rdev
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|UDRS-&gt;fd_ref
op_logical_and
(paren
id|UDP-&gt;flags
op_amp
id|FD_BROKEN_DCL
)paren
)paren
(brace
id|USETF
c_func
(paren
id|FD_DISK_CHANGED
)paren
suffix:semicolon
id|USETF
c_func
(paren
id|FD_VERIFY
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|UDRS-&gt;fd_ref
op_eq
op_minus
l_int|1
op_logical_or
(paren
id|UDRS-&gt;fd_ref
op_logical_and
(paren
id|filp-&gt;f_flags
op_amp
id|O_EXCL
)paren
)paren
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_if
c_cond
(paren
id|floppy_grab_irq_and_dma
c_func
(paren
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_EXCL
)paren
id|UDRS-&gt;fd_ref
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|UDRS-&gt;fd_ref
op_increment
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|floppy_track_buffer
)paren
(brace
multiline_comment|/* if opening an ED drive, reserve a big buffer,&n;&t;&t; * else reserve a small one */
r_if
c_cond
(paren
(paren
id|UDP-&gt;cmos
op_eq
l_int|6
)paren
op_logical_or
(paren
id|UDP-&gt;cmos
op_eq
l_int|5
)paren
)paren
r_try
op_assign
l_int|64
suffix:semicolon
multiline_comment|/* Only 48 actually useful */
r_else
r_try
op_assign
l_int|32
suffix:semicolon
multiline_comment|/* Only 24 actually useful */
id|tmp
op_assign
(paren
r_char
op_star
)paren
id|dma_mem_alloc
c_func
(paren
l_int|1024
op_star
r_try
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
r_try
op_rshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* buffer only one side */
r_if
c_cond
(paren
r_try
OL
l_int|16
)paren
r_try
op_assign
l_int|16
suffix:semicolon
id|tmp
op_assign
(paren
r_char
op_star
)paren
id|dma_mem_alloc
c_func
(paren
l_int|1024
op_star
r_try
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|tmp
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;Unable to allocate DMA memory&bslash;n&quot;
)paren
suffix:semicolon
id|RETERR
c_func
(paren
id|ENXIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|floppy_track_buffer
)paren
(brace
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|tmp
comma
id|__get_order
c_func
(paren
r_try
op_star
l_int|1024
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|floppy_track_buffer
op_assign
id|tmp
suffix:semicolon
id|max_buffer_sectors
op_assign
r_try
suffix:semicolon
)brace
)brace
id|UDRS-&gt;fd_device
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
r_if
c_cond
(paren
id|old_dev
op_logical_and
id|old_dev
op_ne
id|inode-&gt;i_rdev
)paren
(brace
r_if
c_cond
(paren
id|buffer_drive
op_eq
id|drive
)paren
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|old_dev
)paren
suffix:semicolon
)brace
multiline_comment|/* Allow ioctls if we have write-permissions even if read-only open */
r_if
c_cond
(paren
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
op_logical_or
(paren
id|permission
c_func
(paren
id|inode
comma
l_int|2
)paren
op_eq
l_int|0
)paren
)paren
id|filp-&gt;f_mode
op_or_assign
id|IOCTL_MODE_BIT
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
id|filp-&gt;f_mode
op_or_assign
id|OPEN_WRITE_BIT
suffix:semicolon
r_if
c_cond
(paren
id|UFDCS-&gt;rawcmd
op_eq
l_int|1
)paren
id|UFDCS-&gt;rawcmd
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NDELAY
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
(brace
id|UDRS-&gt;last_checked
op_assign
l_int|0
suffix:semicolon
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|UTESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
)paren
id|RETERR
c_func
(paren
id|ENXIO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
op_logical_and
op_logical_neg
(paren
id|UTESTF
c_func
(paren
id|FD_DISK_WRITABLE
)paren
)paren
)paren
id|RETERR
c_func
(paren
id|EROFS
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
DECL|macro|RETERR
macro_line|#undef RETERR
)brace
multiline_comment|/*&n; * Check if the disk has been changed or if a change has been faked.&n; */
DECL|function|check_floppy_change
r_static
r_int
id|check_floppy_change
c_func
(paren
id|dev_t
id|dev
)paren
(brace
r_int
id|drive
op_assign
id|DRIVE
c_func
(paren
id|dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
op_ne
id|MAJOR_NR
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;floppy_changed: not a floppy&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|UTESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|UDRS-&gt;last_checked
op_plus
id|UDP-&gt;checkfreq
OL
id|jiffies
)paren
(brace
id|lock_fdc
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|poll_drive
c_func
(paren
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|UTESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
op_logical_or
id|test_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
op_logical_or
(paren
op_logical_neg
id|TYPE
c_func
(paren
id|dev
)paren
op_logical_and
op_logical_neg
id|current_type
(braket
id|drive
)braket
)paren
)paren
(brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* revalidate the floppy disk, i.e. trigger format autodetection by reading&n; * the bootblock (block 0). &quot;Autodetection&quot; is also needed to check whether&n; * there is a disk in the drive at all... Thus we also do it for fixed&n; * geometry formats */
DECL|function|floppy_revalidate
r_static
r_int
id|floppy_revalidate
c_func
(paren
id|dev_t
id|dev
)paren
(brace
DECL|macro|NO_GEOM
mdefine_line|#define NO_GEOM (!current_type[drive] &amp;&amp; !TYPE(dev))
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_int
id|drive
op_assign
id|DRIVE
c_func
(paren
id|dev
)paren
suffix:semicolon
r_int
id|cf
suffix:semicolon
r_if
c_cond
(paren
id|UTESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
op_logical_or
id|test_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
op_logical_or
id|NO_GEOM
)paren
(brace
id|lock_fdc
c_func
(paren
id|drive
comma
l_int|0
)paren
suffix:semicolon
id|cf
op_assign
id|UTESTF
c_func
(paren
id|FD_DISK_CHANGED
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|cf
op_logical_or
id|test_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
op_logical_or
id|NO_GEOM
)paren
)paren
(brace
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*already done by another thread*/
r_return
l_int|0
suffix:semicolon
)brace
id|UDRS-&gt;maxblock
op_assign
l_int|0
suffix:semicolon
id|UDRS-&gt;maxtrack
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|buffer_drive
op_eq
id|drive
)paren
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|clear_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
suffix:semicolon
id|UCLEARF
c_func
(paren
id|FD_DISK_CHANGED
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cf
)paren
(brace
id|UDRS-&gt;generation
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NO_GEOM
)paren
(brace
multiline_comment|/* auto-sensing */
r_int
id|size
op_assign
id|floppy_blocksizes
(braket
id|MINOR
c_func
(paren
id|dev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|size
)paren
id|size
op_assign
l_int|1024
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|getblk
c_func
(paren
id|dev
comma
l_int|0
comma
id|size
)paren
)paren
)paren
(brace
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bh
op_logical_and
op_logical_neg
id|bh-&gt;b_uptodate
)paren
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cf
)paren
(brace
id|poll_drive
c_func
(paren
l_int|0
comma
id|FD_RAW_NEED_DISK
)paren
suffix:semicolon
)brace
id|process_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|floppy_fops
r_static
r_struct
id|file_operations
id|floppy_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|floppy_read
comma
multiline_comment|/* read - general block-dev read */
id|floppy_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|fd_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|floppy_open
comma
multiline_comment|/* open */
id|floppy_release
comma
multiline_comment|/* release */
id|block_fsync
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
id|check_floppy_change
comma
multiline_comment|/* media_change */
id|floppy_revalidate
comma
multiline_comment|/* revalidate */
)brace
suffix:semicolon
multiline_comment|/*&n; * Floppy Driver initialisation&n; * =============================&n; */
multiline_comment|/* Determine the floppy disk controller type */
multiline_comment|/* This routine was written by David C. Niemi */
DECL|function|get_fdc_version
r_static
r_char
id|get_fdc_version
c_func
(paren
r_void
)paren
(brace
r_int
id|r
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_DUMPREGS
)paren
suffix:semicolon
multiline_comment|/* 82072 and better know DUMPREGS */
r_if
c_cond
(paren
id|FDCS-&gt;reset
)paren
r_return
id|FDC_NONE
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_assign
id|result
c_func
(paren
)paren
)paren
op_le
l_int|0x00
)paren
r_return
id|FDC_NONE
suffix:semicolon
multiline_comment|/* No FDC present ??? */
r_if
c_cond
(paren
(paren
id|r
op_eq
l_int|1
)paren
op_logical_and
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC %d is a 8272A&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_8272A
suffix:semicolon
multiline_comment|/* 8272a/765 don&squot;t know DUMPREGS */
)brace
r_if
c_cond
(paren
id|r
op_ne
l_int|10
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC init: DUMPREGS: unexpected return of %d bytes.&bslash;n&quot;
comma
id|r
)paren
suffix:semicolon
r_return
id|FDC_UNKNOWN
suffix:semicolon
)brace
id|output_byte
c_func
(paren
id|FD_VERSION
)paren
suffix:semicolon
id|r
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_eq
l_int|1
)paren
op_logical_and
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC %d is a 82072&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_82072
suffix:semicolon
multiline_comment|/* 82072 doesn&squot;t know VERSION */
)brace
r_if
c_cond
(paren
(paren
id|r
op_ne
l_int|1
)paren
op_logical_or
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_ne
l_int|0x90
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC init: VERSION: unexpected return of %d bytes.&bslash;n&quot;
comma
id|r
)paren
suffix:semicolon
r_return
id|FDC_UNKNOWN
suffix:semicolon
)brace
id|output_byte
c_func
(paren
id|FD_UNLOCK
)paren
suffix:semicolon
id|r
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_eq
l_int|1
)paren
op_logical_and
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_eq
l_int|0x80
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC %d is a pre-1991 82077&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_82077_ORIG
suffix:semicolon
multiline_comment|/* Pre-1991 82077 doesn&squot;t know LOCK/UNLOCK */
)brace
r_if
c_cond
(paren
(paren
id|r
op_ne
l_int|1
)paren
op_logical_or
(paren
id|reply_buffer
(braket
l_int|0
)braket
op_ne
l_int|0x00
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC init: UNLOCK: unexpected return of %d bytes.&bslash;n&quot;
comma
id|r
)paren
suffix:semicolon
r_return
id|FDC_UNKNOWN
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;FDC %d is a post-1991 82077&bslash;n&quot;
comma
id|fdc
)paren
suffix:semicolon
r_return
id|FDC_82077
suffix:semicolon
multiline_comment|/* Revised 82077AA passes all the tests */
)brace
multiline_comment|/* get_fdc_version */
multiline_comment|/* lilo configuration */
multiline_comment|/* we make the invert_dcl function global. One day, somebody might&n;want to centralize all thinkpad related options into one lilo option,&n;there are just so many thinkpad related quirks! */
DECL|function|floppy_invert_dcl
r_void
id|floppy_invert_dcl
c_func
(paren
r_int
op_star
id|ints
comma
r_int
id|param
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|default_drive_params
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|param
)paren
id|default_drive_params
(braket
id|i
)braket
dot
id|params.flags
op_or_assign
l_int|0x80
suffix:semicolon
r_else
id|default_drive_params
(braket
id|i
)braket
dot
id|params.flags
op_and_assign
op_complement
l_int|0x80
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
l_string|&quot;Configuring drives for inverted dcl&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|daring
r_static
r_void
id|daring
c_func
(paren
r_int
op_star
id|ints
comma
r_int
id|param
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|default_drive_params
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|param
)paren
(brace
id|default_drive_params
(braket
id|i
)braket
dot
id|params.select_delay
op_assign
l_int|0
suffix:semicolon
id|default_drive_params
(braket
id|i
)braket
dot
id|params.flags
op_or_assign
id|FD_SILENT_DCL_CLEAR
suffix:semicolon
)brace
r_else
(brace
id|default_drive_params
(braket
id|i
)braket
dot
id|params.select_delay
op_assign
l_int|2
op_star
id|HZ
op_div
l_int|100
suffix:semicolon
id|default_drive_params
(braket
id|i
)braket
dot
id|params.flags
op_and_assign
op_complement
id|FD_SILENT_DCL_CLEAR
suffix:semicolon
)brace
)brace
id|DPRINT1
c_func
(paren
l_string|&quot;Assuming %s floppy hardware&bslash;n&quot;
comma
id|param
ques
c_cond
l_string|&quot;standard&quot;
suffix:colon
l_string|&quot;broken&quot;
)paren
suffix:semicolon
)brace
DECL|function|allow_drives
r_static
r_void
id|allow_drives
c_func
(paren
r_int
op_star
id|ints
comma
r_int
id|param
)paren
(brace
id|ALLOWED_DRIVE_MASK
op_assign
id|param
suffix:semicolon
id|DPRINT1
c_func
(paren
l_string|&quot;setting allowed_drive_mask to 0x%x&bslash;n&quot;
comma
id|param
)paren
suffix:semicolon
)brace
DECL|function|fdc2_adr
r_static
r_void
id|fdc2_adr
c_func
(paren
r_int
op_star
id|ints
comma
r_int
id|param
)paren
(brace
id|FDC2
op_assign
id|param
suffix:semicolon
r_if
c_cond
(paren
id|param
)paren
(brace
id|DPRINT1
c_func
(paren
l_string|&quot;enabling second fdc at address 0x%3x&bslash;n&quot;
comma
id|FDC2
)paren
suffix:semicolon
)brace
r_else
id|DPRINT
c_func
(paren
l_string|&quot;disabling second fdc&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|unex
r_static
r_void
id|unex
c_func
(paren
r_int
op_star
id|ints
comma
r_int
id|param
)paren
(brace
id|print_unex
op_assign
id|param
suffix:semicolon
id|DPRINT1
c_func
(paren
l_string|&quot;%sprinting messages for unexpected interrupts&bslash;n&quot;
comma
id|param
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;not &quot;
)paren
suffix:semicolon
)brace
DECL|function|set_cmos
r_static
r_void
id|set_cmos
c_func
(paren
r_int
op_star
id|ints
comma
r_int
id|dummy
)paren
(brace
r_int
id|current_drive
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
op_ne
l_int|2
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;wrong number of parameter for cmos&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|current_drive
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|current_drive
OL
l_int|0
op_logical_or
id|current_drive
op_ge
l_int|8
)paren
(brace
id|DPRINT
c_func
(paren
l_string|&quot;bad drive for set_cmos&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ints
(braket
l_int|2
)braket
op_le
l_int|0
op_logical_or
id|ints
(braket
l_int|2
)braket
op_ge
id|NUMBER
c_func
(paren
id|default_drive_params
)paren
)paren
(brace
id|DPRINT1
c_func
(paren
l_string|&quot;bad cmos code %d&bslash;n&quot;
comma
id|ints
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DP-&gt;cmos
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
id|DPRINT1
c_func
(paren
l_string|&quot;setting cmos code to %d&bslash;n&quot;
comma
id|ints
(braket
l_int|2
)braket
)paren
suffix:semicolon
)brace
DECL|struct|param_table
r_static
r_struct
id|param_table
(brace
DECL|member|name
r_char
op_star
id|name
suffix:semicolon
DECL|member|fn
r_void
(paren
op_star
id|fn
)paren
(paren
r_int
op_star
id|ints
comma
r_int
id|param
)paren
suffix:semicolon
DECL|member|def_param
r_int
id|def_param
suffix:semicolon
DECL|variable|config_params
)brace
id|config_params
(braket
)braket
op_assign
initialization_block
suffix:semicolon
DECL|macro|FLOPPY_SETUP
mdefine_line|#define FLOPPY_SETUP
DECL|function|floppy_setup
r_void
id|floppy_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|param
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|str
)paren
(brace
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|config_params
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|str
comma
id|config_params
(braket
id|i
)braket
dot
id|name
)paren
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
)paren
id|param
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|param
op_assign
id|config_params
(braket
id|i
)braket
dot
id|def_param
suffix:semicolon
id|config_params
(braket
id|i
)braket
dot
id|fn
c_func
(paren
id|ints
comma
id|param
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|DPRINT1
c_func
(paren
l_string|&quot;unknown floppy option %s&bslash;n&quot;
comma
id|str
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;allowed options are:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ARRAY_SIZE
c_func
(paren
id|config_params
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; %s&quot;
comma
id|config_params
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
l_string|&quot;Read linux/drivers/block/README.fd&bslash;n&quot;
)paren
suffix:semicolon
)brace
DECL|function|floppy_init
r_int
id|floppy_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|drive
suffix:semicolon
r_int
id|have_no_fdc
op_assign
l_int|0
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
comma
op_amp
id|floppy_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major %d for floppy&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|TYPE
c_func
(paren
id|i
)paren
)paren
id|floppy_sizes
(braket
id|i
)braket
op_assign
id|floppy_type
(braket
id|TYPE
c_func
(paren
id|i
)paren
)braket
dot
id|size
op_rshift
l_int|1
suffix:semicolon
r_else
id|floppy_sizes
(braket
id|i
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|floppy_sizes
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|floppy_blocksizes
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|reschedule_timeout
c_func
(paren
id|MAXTIMEOUT
comma
l_string|&quot;floppy init&quot;
comma
id|MAXTIMEOUT
)paren
suffix:semicolon
id|config_types
c_func
(paren
)paren
suffix:semicolon
id|fdc_state
(braket
l_int|0
)braket
dot
id|address
op_assign
id|FDC1
suffix:semicolon
id|fdc_state
(braket
l_int|0
)braket
dot
id|dor
op_assign
l_int|0
suffix:semicolon
macro_line|#if N_FDC &gt; 1
id|fdc_state
(braket
l_int|1
)braket
dot
id|address
op_assign
id|FDC2
suffix:semicolon
id|fdc_state
(braket
l_int|1
)braket
dot
id|dor
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_FDC
suffix:semicolon
id|i
op_increment
)paren
(brace
id|fdc
op_assign
id|i
suffix:semicolon
id|FDCS-&gt;dtr
op_assign
op_minus
l_int|1
suffix:semicolon
id|FDCS-&gt;dor
op_assign
l_int|0x4
suffix:semicolon
id|FDCS-&gt;reset
op_assign
l_int|0
suffix:semicolon
id|FDCS-&gt;version
op_assign
id|FDC_NONE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|floppy_grab_irq_and_dma
c_func
(paren
)paren
)paren
(brace
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
multiline_comment|/* initialise drive state */
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|N_DRIVE
suffix:semicolon
id|drive
op_increment
)paren
(brace
id|UDRS-&gt;flags
op_assign
id|FD_VERIFY
op_or
id|FD_DISK_NEWCHANGE
op_or
id|FD_DISK_CHANGED
suffix:semicolon
id|UDRS-&gt;generation
op_assign
l_int|0
suffix:semicolon
id|UDRS-&gt;keep_data
op_assign
l_int|0
suffix:semicolon
id|UDRS-&gt;fd_ref
op_assign
l_int|0
suffix:semicolon
id|UDRS-&gt;fd_device
op_assign
l_int|0
suffix:semicolon
id|floppy_track_buffer
op_assign
l_int|NULL
suffix:semicolon
id|max_buffer_sectors
op_assign
l_int|0
suffix:semicolon
id|UDRWE-&gt;write_errors
op_assign
l_int|0
suffix:semicolon
id|UDRWE-&gt;first_error_sector
op_assign
l_int|0
suffix:semicolon
id|UDRWE-&gt;first_error_generation
op_assign
l_int|0
suffix:semicolon
id|UDRWE-&gt;last_error_sector
op_assign
l_int|0
suffix:semicolon
id|UDRWE-&gt;last_error_generation
op_assign
l_int|0
suffix:semicolon
id|UDRWE-&gt;badness
op_assign
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_FDC
suffix:semicolon
id|i
op_increment
)paren
(brace
id|fdc
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;address
op_eq
op_minus
l_int|1
)paren
r_continue
suffix:semicolon
id|FDCS-&gt;rawcmd
op_assign
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|user_reset_fdc
c_func
(paren
op_minus
l_int|1
comma
id|FD_RESET_IF_NEEDED
comma
l_int|0
)paren
)paren
(brace
id|FDCS-&gt;address
op_assign
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Try to determine the floppy controller type */
id|FDCS-&gt;version
op_assign
id|get_fdc_version
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|FDCS-&gt;version
op_eq
id|FDC_NONE
)paren
(brace
id|FDCS-&gt;address
op_assign
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|request_region
c_func
(paren
id|FDCS-&gt;address
comma
l_int|6
comma
l_string|&quot;floppy&quot;
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|FDCS-&gt;address
op_plus
l_int|7
comma
l_int|1
comma
l_string|&quot;floppy DIR&quot;
)paren
suffix:semicolon
multiline_comment|/* address + 6 is reserved, and may be taken by IDE.&n;&t;&t; * Unfortunately, Adaptec doesn&squot;t know this :-(, */
id|have_no_fdc
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Not all FDCs seem to be able to handle the version command&n;&t;&t; * properly, so force a reset for the standard FDC clones,&n;&t;&t; * to avoid interrupt garbage.&n;&t;&t; */
id|FDCS-&gt;has_fifo
op_assign
id|FDCS-&gt;version
op_ge
id|FDC_82077_ORIG
suffix:semicolon
id|user_reset_fdc
c_func
(paren
op_minus
l_int|1
comma
id|FD_RESET_ALWAYS
comma
l_int|0
)paren
suffix:semicolon
)brace
id|fdc
op_assign
l_int|0
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|fd_timeout
)paren
suffix:semicolon
id|current_drive
op_assign
l_int|0
suffix:semicolon
id|floppy_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
id|initialising
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|have_no_fdc
)paren
(brace
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
)brace
r_return
id|have_no_fdc
suffix:semicolon
)brace
DECL|function|floppy_grab_irq_and_dma
r_static
r_int
id|floppy_grab_irq_and_dma
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|usage_count
op_increment
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef FD_MODULE
id|MOD_INC_USE_COUNT
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|N_FDC
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|FDCS-&gt;address
op_ne
op_minus
l_int|1
)paren
(brace
id|fdc
op_assign
id|i
suffix:semicolon
id|reset_fdc_info
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|FDCS-&gt;dor
comma
id|FD_DOR
)paren
suffix:semicolon
)brace
)brace
id|set_dor
c_func
(paren
l_int|0
comma
op_complement
l_int|0
comma
l_int|8
)paren
suffix:semicolon
multiline_comment|/* avoid immediate interrupt */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|FLOPPY_IRQ
comma
id|floppy_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;floppy&quot;
)paren
)paren
(brace
id|DPRINT1
c_func
(paren
l_string|&quot;Unable to grab IRQ%d for the floppy driver&bslash;n&quot;
comma
id|FLOPPY_IRQ
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|FLOPPY_DMA
comma
l_string|&quot;floppy&quot;
)paren
)paren
(brace
id|DPRINT1
c_func
(paren
l_string|&quot;Unable to grab DMA%d for the floppy driver&bslash;n&quot;
comma
id|FLOPPY_DMA
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|FLOPPY_IRQ
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|fdc
op_assign
l_int|0
suffix:semicolon
id|fdc
OL
id|N_FDC
suffix:semicolon
id|fdc
op_increment
)paren
r_if
c_cond
(paren
id|FDCS-&gt;address
op_ne
op_minus
l_int|1
)paren
(brace
id|outb_p
c_func
(paren
id|FDCS-&gt;dor
comma
id|FD_DOR
)paren
suffix:semicolon
)brace
id|fdc
op_assign
l_int|0
suffix:semicolon
id|enable_irq
c_func
(paren
id|FLOPPY_IRQ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|floppy_release_irq_and_dma
r_static
r_void
id|floppy_release_irq_and_dma
c_func
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_FLOPPY_SANITY
r_int
id|drive
suffix:semicolon
macro_line|#endif
r_int
id|tmpsize
suffix:semicolon
r_void
op_star
id|tmpaddr
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_decrement
id|usage_count
)paren
(brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef FD_MODULE
id|MOD_DEC_USE_COUNT
suffix:semicolon
macro_line|#endif
id|disable_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|disable_irq
c_func
(paren
id|FLOPPY_IRQ
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|FLOPPY_IRQ
)paren
suffix:semicolon
id|set_dor
c_func
(paren
l_int|0
comma
op_complement
l_int|0
comma
l_int|8
)paren
suffix:semicolon
macro_line|#if N_FDC &gt; 1
id|set_dor
c_func
(paren
l_int|1
comma
op_complement
l_int|8
comma
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|floppy_enable_hlt
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|floppy_track_buffer
op_logical_and
id|max_buffer_sectors
)paren
(brace
id|tmpsize
op_assign
id|max_buffer_sectors
op_star
l_int|1024
suffix:semicolon
id|tmpaddr
op_assign
(paren
r_void
op_star
)paren
id|floppy_track_buffer
suffix:semicolon
id|floppy_track_buffer
op_assign
l_int|0
suffix:semicolon
id|max_buffer_sectors
op_assign
l_int|0
suffix:semicolon
id|free_pages
c_func
(paren
(paren
r_int
r_int
)paren
id|tmpaddr
comma
id|__get_order
c_func
(paren
id|tmpsize
)paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_FLOPPY_SANITY
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|N_FDC
op_star
l_int|4
suffix:semicolon
id|drive
op_increment
)paren
r_if
c_cond
(paren
id|motor_off_timer
(braket
id|drive
)braket
dot
id|next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;motor off timer %d still active&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fd_timeout.next
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;floppy timer still active:%s&bslash;n&quot;
comma
id|timeout_message
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fd_timer.next
)paren
id|printk
c_func
(paren
l_string|&quot;auxiliary floppy timer still active&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|floppy_tq.sync
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;task queue still active&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
macro_line|#ifdef MODULE
r_extern
r_char
op_star
id|get_options
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
suffix:semicolon
macro_line|#if 0
multiline_comment|/* assuming that insmod is compiled as a.out binary using a shared&n;   C library ... */
r_int
id|ENVIRON
op_assign
l_int|0x60090b34
suffix:semicolon
r_static
r_void
id|mod_setup
c_func
(paren
r_char
op_star
id|name
comma
r_void
(paren
op_star
id|setup
)paren
(paren
r_char
op_star
comma
r_int
op_star
)paren
)paren
(brace
r_char
op_star
op_star
id|environ
comma
op_star
id|env
comma
op_star
id|ptr
comma
id|c
comma
id|i
suffix:semicolon
r_char
id|line
(braket
l_int|100
)braket
suffix:semicolon
r_int
id|ints
(braket
l_int|11
)braket
suffix:semicolon
id|environ
op_assign
(paren
r_char
op_star
op_star
)paren
id|get_fs_long
c_func
(paren
id|ENVIRON
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|env
op_assign
(paren
r_char
op_star
)paren
id|get_fs_long
c_func
(paren
id|environ
)paren
)paren
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|strlen
c_func
(paren
id|name
)paren
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
r_char
)paren
id|get_fs_byte
c_func
(paren
id|env
op_increment
)paren
op_ne
id|name
(braket
id|i
)braket
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|strlen
c_func
(paren
id|name
)paren
)paren
(brace
id|ptr
op_assign
id|line
suffix:semicolon
r_while
c_loop
(paren
id|ptr
OL
id|line
op_plus
l_int|99
)paren
(brace
id|c
op_assign
(paren
r_char
)paren
id|get_fs_byte
c_func
(paren
id|env
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_char|&squot; &squot;
op_logical_or
op_logical_neg
id|c
)paren
(brace
op_star
id|ptr
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_if
c_cond
(paren
id|ptr
op_ne
id|line
)paren
(brace
id|setup
c_func
(paren
id|get_options
c_func
(paren
id|line
comma
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
)brace
id|ptr
op_assign
id|line
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|c
)paren
r_break
suffix:semicolon
)brace
r_else
op_star
id|ptr
op_increment
op_assign
id|c
suffix:semicolon
)brace
)brace
id|environ
op_increment
suffix:semicolon
)brace
)brace
macro_line|#endif
macro_line|#ifdef __cplusplus
r_extern
l_string|&quot;C&quot;
(brace
macro_line|#endif
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|ret
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;inserting floppy driver for %s&bslash;n&quot;
comma
id|kernel_version
)paren
suffix:semicolon
multiline_comment|/*mod_setup(&quot;floppy=&quot;, floppy_setup);*/
multiline_comment|/* Can&squot;t do that any more, insmod is now ELF */
id|ret
op_assign
id|floppy_init
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|fdc
suffix:semicolon
r_for
c_loop
(paren
id|fdc
op_assign
l_int|0
suffix:semicolon
id|fdc
OL
l_int|2
suffix:semicolon
id|fdc
op_increment
)paren
r_if
c_cond
(paren
id|FDCS-&gt;address
op_ne
op_minus
l_int|1
)paren
(brace
id|release_region
c_func
(paren
id|FDCS-&gt;address
comma
l_int|6
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|FDCS-&gt;address
op_plus
l_int|7
comma
l_int|1
)paren
suffix:semicolon
)brace
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
)paren
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef __cplusplus
)brace
macro_line|#endif
macro_line|#endif
eof
