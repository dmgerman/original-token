multiline_comment|/*&n; *  linux/kernel/floppy.c&n; *&n; *  Copyright (C) 1991, 1992  Linus Torvalds&n; */
multiline_comment|/*&n; * 02.12.91 - Changed to static variables to indicate need for reset&n; * and recalibrate. This makes some things easier (output_byte reset&n; * checking etc), and means less interrupt jumping in case of errors,&n; * so the code is hopefully easier to understand.&n; */
multiline_comment|/*&n; * This file is certainly a mess. I&squot;ve tried my best to get it working,&n; * but I don&squot;t like programming floppies, and I have only one anyway.&n; * Urgel. I should check for more errors, and do more graceful error&n; * recovery. Seems there are problems with several drives. I&squot;ve tried to&n; * correct them. No promises. &n; */
multiline_comment|/*&n; * As with hd.c, all routines within this file can (and will) be called&n; * by interrupts, so extreme caution is needed. A hardware interrupt&n; * handler may not sleep, or a kernel panic will happen. Thus I cannot&n; * call &quot;floppy-on&quot; directly, but have to set a special timer interrupt&n; * etc.&n; */
multiline_comment|/*&n; * 28.02.92 - made track-buffering routines, based on the routines written&n; * by entropy@wintermute.wpi.edu (Lawrence Foard). Linus.&n; */
multiline_comment|/*&n; * Automatic floppy-detection and formatting written by Werner Almesberger&n; * (almesber@nessie.cs.id.ethz.ch), who also corrected some problems with&n; * the floppy-change signal detection.&n; */
multiline_comment|/*&n; * 1992/7/22 -- Hennus Bergman: Added better error reporting, fixed &n; * FDC data overrun bug, added some preliminary stuff for vertical&n; * recording support.&n; *&n; * 1992/9/17: Added DMA allocation &amp; DMA functions. -- hhb.&n; *&n; * TODO: Errors are still not counted properly.&n; */
multiline_comment|/* 1992/9/20&n; * Modifications for ``Sector Shifting&squot;&squot; by Rob Hooft (hooft@chem.ruu.nl)&n; * modelled after the freeware MS/DOS program fdformat/88 V1.8 by &n; * Christoph H. Hochst&bslash;&quot;atter.&n; * I have fixed the shift values to the ones I always use. Maybe a new&n; * ioctl() should be created to be able to modify them.&n; * There is a bug in the driver that makes it impossible to format a&n; * floppy as the first thing after bootup.&n; */
multiline_comment|/*&n; * 1993/4/29 -- Linus -- cleaned up the timer handling in the kernel, and&n; * this helped the floppy driver as well. Much cleaner, and still seems to&n; * work.&n; */
multiline_comment|/* 1994/6/24 --bbroad-- added the floppy table entries and made&n; * minor modifications to allow 2.88 floppies to be run. &n; */
DECL|macro|REALLY_SLOW_IO
mdefine_line|#define REALLY_SLOW_IO
DECL|macro|FLOPPY_IRQ
mdefine_line|#define FLOPPY_IRQ 6
DECL|macro|FLOPPY_DMA
mdefine_line|#define FLOPPY_DMA 2
DECL|macro|FDC_FIFO_UNTESTED
mdefine_line|#define FDC_FIFO_UNTESTED           /* -bb */
DECL|macro|FDC_FIFO_BUG
mdefine_line|#define FDC_FIFO_BUG
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fdreg.h&gt;
macro_line|#include &lt;linux/fd.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR FLOPPY_MAJOR
macro_line|#include &quot;blk.h&quot;
DECL|variable|changed_floppies
DECL|variable|fake_change
r_static
r_int
r_int
id|changed_floppies
op_assign
l_int|0
comma
id|fake_change
op_assign
l_int|0
suffix:semicolon
DECL|variable|initial_reset_flag
r_static
r_int
id|initial_reset_flag
op_assign
l_int|0
suffix:semicolon
DECL|variable|need_configure
r_static
r_int
id|need_configure
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* for 82077 */
DECL|variable|recalibrate
r_static
r_int
id|recalibrate
op_assign
l_int|0
suffix:semicolon
DECL|variable|reset
r_static
r_int
id|reset
op_assign
l_int|0
suffix:semicolon
DECL|variable|recover
r_static
r_int
id|recover
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* recalibrate immediately after resetting */
DECL|variable|seek
r_static
r_int
id|seek
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_DOR
r_static
r_int
r_char
id|current_DOR
op_assign
l_int|0x0C
suffix:semicolon
DECL|variable|running
r_static
r_int
r_char
id|running
op_assign
l_int|0
suffix:semicolon
DECL|macro|TYPE
mdefine_line|#define TYPE(x) ((x)&gt;&gt;2)
DECL|macro|DRIVE
mdefine_line|#define DRIVE(x) ((x)&amp;0x03)
multiline_comment|/*&n; * Note that MAX_ERRORS=X doesn&squot;t imply that we retry every bad read&n; * max X times - some types of errors increase the errorcount by 2 or&n; * even 3, so we might actually retry only X/2 times before giving up.&n; */
DECL|macro|MAX_ERRORS
mdefine_line|#define MAX_ERRORS 12
multiline_comment|/*&n; * Maximum disk size (in kilobytes). This default is used whenever the&n; * current disk size is unknown.&n; */
DECL|macro|MAX_DISK_SIZE
mdefine_line|#define MAX_DISK_SIZE 2880 /* was 1440 -bb */
multiline_comment|/*&n; * Maximum number of sectors in a track buffer. Track buffering is disabled&n; * if tracks are bigger.&n; */
DECL|macro|MAX_BUFFER_SECTORS
mdefine_line|#define MAX_BUFFER_SECTORS 36 /* was 18 -bb */
multiline_comment|/*&n; * The DMA channel used by the floppy controller cannot access data at&n; * addresses &gt;= 16MB&n; *&n; * Went back to the 1MB limit, as some people had problems with the floppy&n; * driver otherwise. It doesn&squot;t matter much for performance anyway, as most&n; * floppy accesses go through the track buffer.&n; */
DECL|macro|LAST_DMA_ADDR
mdefine_line|#define LAST_DMA_ADDR&t;(0x100000 - BLOCK_SIZE)
multiline_comment|/*&n; * globals used by &squot;result()&squot;&n; */
DECL|macro|MAX_REPLIES
mdefine_line|#define MAX_REPLIES 7
DECL|variable|reply_buffer
r_static
r_int
r_char
id|reply_buffer
(braket
id|MAX_REPLIES
)braket
suffix:semicolon
DECL|macro|ST0
mdefine_line|#define ST0 (reply_buffer[0])
DECL|macro|ST1
mdefine_line|#define ST1 (reply_buffer[1])
DECL|macro|ST2
mdefine_line|#define ST2 (reply_buffer[2])
DECL|macro|ST3
mdefine_line|#define ST3 (reply_buffer[3])
multiline_comment|/*&n; * This struct defines the different floppy types.&n; *&n; * The &squot;stretch&squot; tells if the tracks need to be doubled for some&n; * types (ie 360kB diskette in 1.2MB drive etc). Others should&n; * be self-explanatory.&n; */
DECL|variable|floppy_type
r_static
r_struct
id|floppy_struct
id|floppy_type
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|0x00
comma
l_int|NULL
)brace
comma
multiline_comment|/* no testing */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_int|NULL
)brace
comma
multiline_comment|/* 360kB PC diskettes */
(brace
l_int|2400
comma
l_int|15
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x54
comma
l_int|NULL
)brace
comma
multiline_comment|/* 1.2 MB AT-diskettes */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|1
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_int|NULL
)brace
comma
multiline_comment|/* 360kB in 720kB drive */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_int|NULL
)brace
comma
multiline_comment|/* 3.5&quot; 720kB diskette */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|1
comma
l_int|0x23
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x50
comma
l_int|NULL
)brace
comma
multiline_comment|/* 360kB in 1.2MB drive */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x23
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x50
comma
l_int|NULL
)brace
comma
multiline_comment|/* 720kB in 1.2MB drive */
(brace
l_int|2880
comma
l_int|18
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_int|NULL
)brace
comma
multiline_comment|/* 1.44MB diskette */
(brace
l_int|5760
comma
l_int|36
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x43
comma
l_int|0xAF
comma
l_int|0x54
comma
l_int|NULL
)brace
comma
multiline_comment|/* 2.88MB diskette */
(brace
l_int|5760
comma
l_int|36
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x43
comma
l_int|0xAF
comma
l_int|0x54
comma
l_int|NULL
)brace
comma
multiline_comment|/* 2.88MB diskette */
)brace
suffix:semicolon
multiline_comment|/*&n; * Auto-detection. Each drive type has a pair of formats which are&n; * used in succession to try to read the disk. If the FDC cannot lock onto&n; * the disk, the next format is tried. This uses the variable &squot;probing&squot;.&n; */
DECL|variable|floppy_types
r_static
r_struct
id|floppy_struct
id|floppy_types
(braket
)braket
op_assign
(brace
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;360k/PC&quot;
)brace
comma
multiline_comment|/* 360kB PC diskettes */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;360k/PC&quot;
)brace
comma
multiline_comment|/* 360kB PC diskettes */
(brace
l_int|2400
comma
l_int|15
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xDF
comma
l_int|0x54
comma
l_string|&quot;1.2M&quot;
)brace
comma
multiline_comment|/* 1.2 MB AT-diskettes */
(brace
l_int|720
comma
l_int|9
comma
l_int|2
comma
l_int|40
comma
l_int|1
comma
l_int|0x23
comma
l_int|0x01
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;360k/AT&quot;
)brace
comma
multiline_comment|/* 360kB in 1.2MB drive */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;720k&quot;
)brace
comma
multiline_comment|/* 3.5&quot; 720kB diskette */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;720k&quot;
)brace
comma
multiline_comment|/* 3.5&quot; 720kB diskette */
(brace
l_int|2880
comma
l_int|18
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;1.44M&quot;
)brace
comma
multiline_comment|/* 1.44MB diskette */
(brace
l_int|1440
comma
l_int|9
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x2A
comma
l_int|0x02
comma
l_int|0xDF
comma
l_int|0x50
comma
l_string|&quot;720k/AT&quot;
)brace
comma
multiline_comment|/* 3.5&quot; 720kB diskette */
(brace
l_int|5760
comma
l_int|36
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x43
comma
l_int|0xAF
comma
l_int|0x54
comma
l_string|&quot;2.88M-AMI&quot;
)brace
comma
multiline_comment|/* DUMMY */
(brace
l_int|2880
comma
l_int|18
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x00
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;1.44M-AMI&quot;
)brace
comma
multiline_comment|/* Dummy */
(brace
l_int|5760
comma
l_int|36
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x43
comma
l_int|0xAF
comma
l_int|0x54
comma
l_string|&quot;2.88M&quot;
)brace
comma
multiline_comment|/* 2.88MB diskette */
(brace
l_int|2880
comma
l_int|18
comma
l_int|2
comma
l_int|80
comma
l_int|0
comma
l_int|0x1B
comma
l_int|0x40
comma
l_int|0xCF
comma
l_int|0x6C
comma
l_string|&quot;1.44MX&quot;
)brace
comma
multiline_comment|/* 1.44MB diskette */
)brace
suffix:semicolon
multiline_comment|/* Auto-detection: Disk type used until the next media change occurs. */
DECL|variable|current_type
r_struct
id|floppy_struct
op_star
id|current_type
(braket
l_int|4
)braket
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* This type is tried first. */
DECL|variable|base_type
r_struct
id|floppy_struct
op_star
id|base_type
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/*&n; * User-provided type information. current_type points to&n; * the respective entry of this array.&n; */
DECL|variable|user_params
r_struct
id|floppy_struct
id|user_params
(braket
l_int|4
)braket
suffix:semicolon
DECL|variable|floppy_sizes
r_static
r_int
id|floppy_sizes
(braket
)braket
op_assign
initialization_block
suffix:semicolon
multiline_comment|/*&n; * The driver is trying to determine the correct media format&n; * while probing is set. rw_interrupt() clears it after a&n; * successful access.&n; */
DECL|variable|probing
r_static
r_int
id|probing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * (User-provided) media information is _not_ discarded after a media change&n; * if the corresponding keep_data flag is non-zero. Positive values are&n; * decremented after each probe.&n; */
DECL|variable|keep_data
r_static
r_int
id|keep_data
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * Announce successful media type detection and media information loss after&n; * disk changes.&n; * Also used to enable/disable printing of overrun warnings.&n; */
DECL|variable|ftd_msg
r_static
id|ftd_msg
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* Prevent &quot;aliased&quot; accesses. */
DECL|variable|fd_ref
r_static
id|fd_ref
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|fd_device
r_static
id|fd_device
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/* Synchronization of FDC access. */
DECL|variable|format_status
DECL|variable|fdc_busy
r_static
r_volatile
r_int
id|format_status
op_assign
id|FORMAT_NONE
comma
id|fdc_busy
op_assign
l_int|0
suffix:semicolon
DECL|variable|fdc_wait
DECL|variable|format_done
r_static
r_struct
id|wait_queue
op_star
id|fdc_wait
op_assign
l_int|NULL
comma
op_star
id|format_done
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Errors during formatting are counted here. */
DECL|variable|format_errors
r_static
r_int
id|format_errors
suffix:semicolon
multiline_comment|/* Format request descriptor. */
DECL|variable|format_req
r_static
r_struct
id|format_descr
id|format_req
suffix:semicolon
multiline_comment|/*&n; * Current device number. Taken either from the block header or from the&n; * format request descriptor.&n; */
DECL|macro|CURRENT_DEVICE
mdefine_line|#define CURRENT_DEVICE (format_status == FORMAT_BUSY ? format_req.device : &bslash;&n;   (CURRENT-&gt;dev))
multiline_comment|/* Current error count. */
DECL|macro|CURRENT_ERRORS
mdefine_line|#define CURRENT_ERRORS (format_status == FORMAT_BUSY ? format_errors : &bslash;&n;    (CURRENT-&gt;errors))
multiline_comment|/*&n; * Threshold for reporting FDC errors to the console.&n; * Setting this to zero may flood your screen when using&n; * ultra cheap floppies ;-)&n; */
DECL|variable|min_report_error_cnt
r_static
r_int
r_int
id|min_report_error_cnt
(braket
l_int|4
)braket
op_assign
(brace
l_int|2
comma
l_int|2
comma
l_int|2
comma
l_int|2
)brace
suffix:semicolon
multiline_comment|/*&n; * Rate is 0 for 500kb/s, 1 for 300kbps, 2 for 250kbps&n; * Spec1 is 0xSH, where S is stepping rate (F=1ms, E=2ms, D=3ms etc),&n; * H is head unload time (1=16ms, 2=32ms, etc)&n; *&n; * Spec2 is (HLD&lt;&lt;1 | ND), where HLD is head load time (1=2ms, 2=4 ms etc)&n; * and ND is set means no DMA. Hardcoded to 6 (HLD=6ms, use DMA).&n; */
multiline_comment|/*&n; * Track buffer and block buffer (in case track buffering doesn&squot;t work).&n; * Because these are written to by the DMA controller, they must&n; * not contain a 64k byte boundary crossing, or data will be&n; * corrupted/lost. Alignment of these is enforced in boot/head.s.&n; * Note that you must not change the sizes below without updating head.s.&n; */
r_extern
r_char
id|tmp_floppy_area
(braket
id|BLOCK_SIZE
)braket
suffix:semicolon
r_extern
r_char
id|floppy_track_buffer
(braket
l_int|512
op_star
l_int|2
op_star
id|MAX_BUFFER_SECTORS
)braket
suffix:semicolon
r_static
r_void
id|redo_fd_request
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|floppy_ready
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|recalibrate_floppy
c_func
(paren
r_void
)paren
suffix:semicolon
r_int
id|floppy_grab_irq_and_dma
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|floppy_release_irq_and_dma
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/*&n; * These are global variables, as that&squot;s the easiest way to give&n; * information to interrupts. They are the data used for the current&n; * request.&n; */
DECL|macro|NO_TRACK
mdefine_line|#define NO_TRACK 255
DECL|variable|read_track
r_static
r_int
id|read_track
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* flag to indicate if we want to read entire track */
DECL|variable|buffer_track
r_static
r_int
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|buffer_drive
r_static
r_int
id|buffer_drive
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|cur_spec1
r_static
r_int
id|cur_spec1
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|cur_rate
r_static
r_int
id|cur_rate
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|floppy
r_static
r_struct
id|floppy_struct
op_star
id|floppy
op_assign
id|floppy_type
suffix:semicolon
DECL|variable|current_drive
r_static
r_int
r_char
id|current_drive
op_assign
l_int|255
suffix:semicolon
DECL|variable|sector
r_static
r_int
r_char
id|sector
op_assign
l_int|0
suffix:semicolon
DECL|variable|head
r_static
r_int
r_char
id|head
op_assign
l_int|0
suffix:semicolon
DECL|variable|track
r_static
r_int
r_char
id|track
op_assign
l_int|0
suffix:semicolon
DECL|variable|seek_track
r_static
r_int
r_char
id|seek_track
op_assign
l_int|0
suffix:semicolon
DECL|variable|current_track
r_static
r_int
r_char
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
DECL|variable|command
r_static
r_int
r_char
id|command
op_assign
l_int|0
suffix:semicolon
DECL|variable|fdc_version
r_static
r_int
r_char
id|fdc_version
op_assign
l_int|0x90
suffix:semicolon
multiline_comment|/* FDC version code */
DECL|function|select_callback
r_static
r_void
id|select_callback
c_func
(paren
r_int
r_int
id|unused
)paren
(brace
id|floppy_ready
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|floppy_select
r_static
r_void
id|floppy_select
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
r_static
r_struct
id|timer_list
id|select
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|select_callback
)brace
suffix:semicolon
r_if
c_cond
(paren
id|current_drive
op_eq
(paren
id|current_DOR
op_amp
l_int|3
)paren
)paren
(brace
id|floppy_ready
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|seek
op_assign
l_int|1
suffix:semicolon
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|current_DOR
op_and_assign
l_int|0xFC
suffix:semicolon
id|current_DOR
op_or_assign
id|current_drive
suffix:semicolon
id|outb
c_func
(paren
id|current_DOR
comma
id|FD_DOR
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|select
)paren
suffix:semicolon
id|select.expires
op_assign
l_int|2
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|select
)paren
suffix:semicolon
)brace
DECL|function|motor_on_callback
r_static
r_void
id|motor_on_callback
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
id|running
op_or_assign
l_int|0x10
op_lshift
id|nr
suffix:semicolon
id|floppy_select
c_func
(paren
id|nr
)paren
suffix:semicolon
)brace
DECL|variable|motor_on_timer
r_static
r_struct
id|timer_list
id|motor_on_timer
(braket
l_int|4
)braket
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|motor_on_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|1
comma
id|motor_on_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|2
comma
id|motor_on_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|3
comma
id|motor_on_callback
)brace
)brace
suffix:semicolon
DECL|function|motor_off_callback
r_static
r_void
id|motor_off_callback
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
r_int
r_char
id|mask
op_assign
op_complement
(paren
l_int|0x10
op_lshift
id|nr
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|running
op_and_assign
id|mask
suffix:semicolon
id|current_DOR
op_and_assign
id|mask
suffix:semicolon
id|outb
c_func
(paren
id|current_DOR
comma
id|FD_DOR
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|variable|motor_off_timer
r_static
r_struct
id|timer_list
id|motor_off_timer
(braket
l_int|4
)braket
op_assign
(brace
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|1
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|2
comma
id|motor_off_callback
)brace
comma
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|3
comma
id|motor_off_callback
)brace
)brace
suffix:semicolon
DECL|function|floppy_on
r_static
r_void
id|floppy_on
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
r_int
r_char
id|mask
op_assign
l_int|0x10
op_lshift
id|nr
suffix:semicolon
id|del_timer
c_func
(paren
id|motor_off_timer
op_plus
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_amp
id|running
)paren
id|floppy_select
c_func
(paren
id|nr
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|mask
op_amp
id|current_DOR
)paren
)paren
(brace
id|del_timer
c_func
(paren
id|motor_on_timer
op_plus
id|nr
)paren
suffix:semicolon
id|motor_on_timer
(braket
id|nr
)braket
dot
id|expires
op_assign
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
id|motor_on_timer
op_plus
id|nr
)paren
suffix:semicolon
)brace
id|current_DOR
op_and_assign
l_int|0xFC
suffix:semicolon
id|current_DOR
op_or_assign
id|mask
suffix:semicolon
id|current_DOR
op_or_assign
id|nr
suffix:semicolon
id|outb
c_func
(paren
id|current_DOR
comma
id|FD_DOR
)paren
suffix:semicolon
)brace
DECL|function|floppy_off
r_static
r_void
id|floppy_off
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
id|del_timer
c_func
(paren
id|motor_off_timer
op_plus
id|nr
)paren
suffix:semicolon
id|motor_off_timer
(braket
id|nr
)braket
dot
id|expires
op_assign
l_int|3
op_star
id|HZ
suffix:semicolon
id|add_timer
c_func
(paren
id|motor_off_timer
op_plus
id|nr
)paren
suffix:semicolon
)brace
DECL|function|request_done
r_void
id|request_done
c_func
(paren
r_int
id|uptodate
)paren
(brace
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|FLOPPY_TIMER
)paren
suffix:semicolon
r_if
c_cond
(paren
id|format_status
op_ne
id|FORMAT_BUSY
)paren
id|end_request
c_func
(paren
id|uptodate
)paren
suffix:semicolon
r_else
(brace
id|format_status
op_assign
id|uptodate
ques
c_cond
id|FORMAT_OKAY
suffix:colon
id|FORMAT_ERROR
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|format_done
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * floppy-change is never called from an interrupt, so we can relax a bit&n; * here, sleep etc. Note that floppy-on tries to set current_DOR to point&n; * to the desired drive, but it will probably not survive the sleep if&n; * several floppies are used at the same time: thus the loop.&n; */
DECL|function|floppy_change
r_static
r_int
id|floppy_change
c_func
(paren
r_struct
id|buffer_head
op_star
id|bh
)paren
(brace
r_int
r_int
id|mask
op_assign
l_int|1
op_lshift
(paren
id|bh-&gt;b_dev
op_amp
l_int|0x03
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|bh-&gt;b_dev
)paren
op_ne
id|MAJOR_NR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;floppy_changed: not a floppy&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|fake_change
op_amp
id|mask
)paren
(brace
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|fake_change
op_and_assign
op_complement
id|mask
suffix:semicolon
multiline_comment|/* omitting the next line breaks formatting in a horrible way ... */
id|changed_floppies
op_and_assign
op_complement
id|mask
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|changed_floppies
op_amp
id|mask
)paren
(brace
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|changed_floppies
op_and_assign
op_complement
id|mask
suffix:semicolon
id|recalibrate
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|bh
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|bh-&gt;b_dirt
)paren
id|ll_rw_block
c_func
(paren
id|WRITE
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
r_else
(brace
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|bh-&gt;b_uptodate
op_assign
l_int|0
suffix:semicolon
id|ll_rw_block
c_func
(paren
id|READ
comma
l_int|1
comma
op_amp
id|bh
)paren
suffix:semicolon
)brace
id|wait_on_buffer
c_func
(paren
id|bh
)paren
suffix:semicolon
r_if
c_cond
(paren
id|changed_floppies
op_amp
id|mask
)paren
(brace
id|changed_floppies
op_and_assign
op_complement
id|mask
suffix:semicolon
id|recalibrate
op_assign
l_int|1
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|copy_buffer
mdefine_line|#define copy_buffer(from,to) &bslash;&n;__asm__(&quot;cld ; rep ; movsl&quot; &bslash;&n;&t;: &bslash;&n;&t;:&quot;c&quot; (BLOCK_SIZE/4),&quot;S&quot; ((long)(from)),&quot;D&quot; ((long)(to)) &bslash;&n;&t;:&quot;cx&quot;,&quot;di&quot;,&quot;si&quot;)
DECL|function|setup_DMA
r_static
r_void
id|setup_DMA
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|addr
comma
id|count
suffix:semicolon
r_int
r_char
id|dma_code
suffix:semicolon
id|dma_code
op_assign
id|DMA_WRITE
suffix:semicolon
r_if
c_cond
(paren
id|command
op_eq
id|FD_READ
)paren
id|dma_code
op_assign
id|DMA_READ
suffix:semicolon
r_if
c_cond
(paren
id|command
op_eq
id|FD_FORMAT
)paren
(brace
id|addr
op_assign
(paren
r_int
)paren
id|tmp_floppy_area
suffix:semicolon
id|count
op_assign
id|floppy-&gt;sect
op_star
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|addr
op_assign
(paren
r_int
)paren
id|CURRENT-&gt;buffer
suffix:semicolon
id|count
op_assign
l_int|1024
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_track
)paren
(brace
multiline_comment|/* mark buffer-track bad, in case all this fails.. */
id|buffer_drive
op_assign
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|count
op_assign
id|floppy-&gt;sect
op_star
id|floppy-&gt;head
op_star
l_int|512
suffix:semicolon
id|addr
op_assign
(paren
r_int
)paren
id|floppy_track_buffer
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|addr
op_ge
id|LAST_DMA_ADDR
)paren
(brace
id|addr
op_assign
(paren
r_int
)paren
id|tmp_floppy_area
suffix:semicolon
r_if
c_cond
(paren
id|command
op_eq
id|FD_WRITE
)paren
id|copy_buffer
c_func
(paren
id|CURRENT-&gt;buffer
comma
id|tmp_floppy_area
)paren
suffix:semicolon
)brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|clear_dma_ff
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|FLOPPY_DMA
comma
(paren
id|command
op_eq
id|FD_READ
)paren
ques
c_cond
id|DMA_MODE_READ
suffix:colon
id|DMA_MODE_WRITE
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|FLOPPY_DMA
comma
id|addr
)paren
suffix:semicolon
id|set_dma_count
c_func
(paren
id|FLOPPY_DMA
comma
id|count
)paren
suffix:semicolon
id|enable_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|output_byte
r_static
r_void
id|output_byte
c_func
(paren
r_char
id|byte
)paren
(brace
r_int
id|counter
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
l_int|10000
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|status
op_assign
id|inb_p
c_func
(paren
id|FD_STATUS
)paren
op_amp
(paren
id|STATUS_READY
op_or
id|STATUS_DIR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|STATUS_READY
)paren
(brace
id|outb
c_func
(paren
id|byte
comma
id|FD_DATA
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|reset
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unable to send byte to FDC&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#ifdef FDC_FIFO_BUG
DECL|function|output_byte_force
r_static
r_void
id|output_byte_force
c_func
(paren
r_char
id|byte
)paren
(brace
r_int
id|counter
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
l_int|10000
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|status
op_assign
id|inb_p
c_func
(paren
id|FD_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|status
op_amp
(paren
id|STATUS_READY
op_or
id|STATUS_DIR
)paren
)paren
op_eq
id|STATUS_READY
)paren
(brace
id|outb
c_func
(paren
id|byte
comma
id|FD_DATA
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_amp
(paren
id|STATUS_READY
op_or
id|STATUS_BUSY
)paren
)paren
op_eq
(paren
id|STATUS_READY
op_or
id|STATUS_BUSY
)paren
)paren
(brace
id|outb
c_func
(paren
id|byte
comma
id|FD_DATA
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|reset
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Unable to send byte to FDC&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif&t;&t;/* FDC_FIFO_BUG */
DECL|function|result
r_static
r_int
id|result
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
comma
id|counter
comma
id|status
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|counter
op_assign
l_int|0
suffix:semicolon
id|counter
OL
l_int|10000
suffix:semicolon
id|counter
op_increment
)paren
(brace
id|status
op_assign
id|inb_p
c_func
(paren
id|FD_STATUS
)paren
op_amp
(paren
id|STATUS_DIR
op_or
id|STATUS_READY
op_or
id|STATUS_BUSY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|STATUS_READY
)paren
(brace
r_return
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_eq
(paren
id|STATUS_DIR
op_or
id|STATUS_READY
op_or
id|STATUS_BUSY
)paren
)paren
(brace
r_if
c_cond
(paren
id|i
op_ge
id|MAX_REPLIES
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;floppy_stat reply overrun&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|reply_buffer
(braket
id|i
op_increment
)braket
op_assign
id|inb_p
c_func
(paren
id|FD_DATA
)paren
suffix:semicolon
)brace
)brace
id|reset
op_assign
l_int|1
suffix:semicolon
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Getstatus times out&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|bad_flp_intr
r_static
r_void
id|bad_flp_intr
c_func
(paren
r_void
)paren
(brace
r_int
id|errors
suffix:semicolon
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
r_if
c_cond
(paren
id|format_status
op_eq
id|FORMAT_BUSY
)paren
id|errors
op_assign
op_increment
id|format_errors
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|CURRENT
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: no current request&bslash;n&quot;
)paren
suffix:semicolon
id|reset
op_assign
id|recalibrate
op_assign
l_int|1
suffix:semicolon
r_return
suffix:semicolon
)brace
r_else
id|errors
op_assign
op_increment
id|CURRENT-&gt;errors
suffix:semicolon
r_if
c_cond
(paren
id|errors
OG
id|MAX_ERRORS
)paren
(brace
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|errors
OG
id|MAX_ERRORS
op_div
l_int|2
)paren
id|reset
op_assign
l_int|1
suffix:semicolon
r_else
id|recalibrate
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Set perpendicular mode as required, based on data rate, if supported.&n; * 82077 Untested! 1Mbps data rate only possible with 82077-1.&n; * TODO: increase MAX_BUFFER_SECTORS, add floppy_type entries.&n; */
DECL|function|perpendicular_mode
r_static
r_inline
r_void
id|perpendicular_mode
c_func
(paren
r_int
r_char
id|rate
)paren
(brace
r_if
c_cond
(paren
id|fdc_version
op_eq
id|FDC_TYPE_82077
)paren
(brace
id|output_byte
c_func
(paren
id|FD_PERPENDICULAR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|rate
op_amp
l_int|0x40
)paren
(brace
r_int
r_char
id|r
op_assign
id|rate
op_amp
l_int|0x03
suffix:semicolon
r_if
c_cond
(paren
id|r
op_eq
l_int|0
)paren
macro_line|#ifndef FDC_FIFO_BUG
id|output_byte
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* perpendicular, 500 kbps */
macro_line|#else
id|output_byte_force
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* perpendicular, 500 kbps */
macro_line|#endif
r_else
r_if
c_cond
(paren
id|r
op_eq
l_int|3
)paren
macro_line|#ifndef FDC_FIFO_BUG
id|output_byte
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* perpendicular, 1Mbps */
macro_line|#else
id|output_byte_force
c_func
(paren
l_int|3
)paren
suffix:semicolon
multiline_comment|/* perpendicular, 1Mbps */
macro_line|#endif
r_else
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Invalid data rate for perpendicular mode!&bslash;n&quot;
)paren
suffix:semicolon
id|reset
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
macro_line|#ifndef FDC_FIFO_BUG
id|output_byte
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* conventional mode */
macro_line|#else
id|output_byte_force
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* conventional mode */
macro_line|#endif
)brace
r_else
(brace
r_if
c_cond
(paren
id|rate
op_amp
l_int|0x40
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: perpendicular mode not supported by this FDC.&bslash;n&quot;
)paren
suffix:semicolon
id|reset
op_assign
l_int|1
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* perpendicular_mode */
multiline_comment|/*&n; * This has only been tested for the case fdc_version == FDC_TYPE_STD.&n; * In case you have a 82077 and want to test it, you&squot;ll have to compile&n; * with `FDC_FIFO_UNTESTED&squot; defined. You may also want to add support for&n; * recognizing drives with vertical recording support.&n; */
DECL|function|configure_fdc_mode
r_static
r_void
id|configure_fdc_mode
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|need_configure
op_logical_and
(paren
id|fdc_version
op_eq
id|FDC_TYPE_82077
)paren
)paren
(brace
multiline_comment|/* Enhanced version with FIFO &amp; vertical recording. */
id|output_byte
c_func
(paren
id|FD_CONFIGURE
)paren
suffix:semicolon
macro_line|#ifndef FDC_FIFO_BUG
id|output_byte
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#else
id|output_byte_force
c_func
(paren
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|output_byte
c_func
(paren
l_int|0x1A
)paren
suffix:semicolon
multiline_comment|/* FIFO on, polling off, 10 byte threshold */
macro_line|#ifndef FDC_FIFO_BUG
id|output_byte
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* precompensation from track 0 upwards */
macro_line|#else
id|output_byte_force
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/* precompensation from track 0 upwards */
macro_line|#endif
id|need_configure
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: FIFO enabled&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cur_spec1
op_ne
id|floppy-&gt;spec1
)paren
(brace
id|cur_spec1
op_assign
id|floppy-&gt;spec1
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_SPECIFY
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|cur_spec1
)paren
suffix:semicolon
multiline_comment|/* hut etc */
id|output_byte
c_func
(paren
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Head load time =6ms, DMA */
)brace
r_if
c_cond
(paren
id|cur_rate
op_ne
id|floppy-&gt;rate
)paren
(brace
multiline_comment|/* use bit 6 of floppy-&gt;rate to indicate perpendicular mode */
id|perpendicular_mode
c_func
(paren
id|floppy-&gt;rate
)paren
suffix:semicolon
id|outb_p
c_func
(paren
(paren
id|cur_rate
op_assign
(paren
id|floppy-&gt;rate
)paren
)paren
op_amp
op_complement
l_int|0x40
comma
id|FD_DCR
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* configure_fdc_mode */
DECL|function|tell_sector
r_static
r_void
id|tell_sector
c_func
(paren
r_int
id|nr
)paren
(brace
r_if
c_cond
(paren
id|nr
op_ne
l_int|7
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; -- FDC reply errror&quot;
)paren
suffix:semicolon
id|reset
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;: track %d, head %d, sector %d&quot;
comma
id|reply_buffer
(braket
l_int|3
)braket
comma
id|reply_buffer
(braket
l_int|4
)braket
comma
id|reply_buffer
(braket
l_int|5
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* tell_sector */
multiline_comment|/*&n; * Ok, this interrupt is called after a DMA read/write has succeeded&n; * or failed, so we check the results, and copy any buffers.&n; * hhb: Added better error reporting.&n; */
DECL|function|rw_interrupt
r_static
r_void
id|rw_interrupt
c_func
(paren
r_void
)paren
(brace
r_char
op_star
id|buffer_area
suffix:semicolon
r_int
id|nr
suffix:semicolon
r_char
id|bad
suffix:semicolon
id|nr
op_assign
id|result
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* check IC to find cause of interrupt */
r_switch
c_cond
(paren
(paren
id|ST0
op_amp
id|ST0_INTR
)paren
op_rshift
l_int|6
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* error occured during command execution */
id|bad
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_WP
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Drive %d is write protected&bslash;n&quot;
comma
id|current_drive
)paren
suffix:semicolon
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|bad
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_OR
)paren
(brace
r_if
c_cond
(paren
id|ftd_msg
(braket
id|ST0
op_amp
id|ST0_DS
)braket
)paren
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Over/Underrun - retrying&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* could continue from where we stopped, but ... */
id|bad
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CURRENT_ERRORS
OG
id|min_report_error_cnt
(braket
id|ST0
op_amp
id|ST0_DS
)braket
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot; %d: &quot;
comma
id|ST0
op_amp
id|ST0_DS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ST0
op_amp
id|ST0_ECE
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Recalibrate failed!&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_CRC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;data CRC error&quot;
)paren
suffix:semicolon
id|tell_sector
c_func
(paren
id|nr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST1
op_amp
id|ST1_CRC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;CRC error&quot;
)paren
suffix:semicolon
id|tell_sector
c_func
(paren
id|nr
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|ST1
op_amp
(paren
id|ST1_MAM
op_or
id|ST1_ND
)paren
)paren
op_logical_or
(paren
id|ST2
op_amp
id|ST2_MAM
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|probing
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;sector not found&quot;
)paren
suffix:semicolon
id|tell_sector
c_func
(paren
id|nr
)paren
suffix:semicolon
)brace
r_else
id|printk
c_func
(paren
l_string|&quot;probe failed...&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_WC
)paren
(brace
multiline_comment|/* seek error */
id|printk
c_func
(paren
l_string|&quot;wrong cylinder&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ST2
op_amp
id|ST2_BC
)paren
(brace
multiline_comment|/* cylinder marked as bad */
id|printk
c_func
(paren
l_string|&quot;bad cylinder&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;unknown error. ST[0..3] are: 0x%x 0x%x 0x%x 0x%x&bslash;n&quot;
comma
id|ST0
comma
id|ST1
comma
id|ST2
comma
id|ST3
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bad
)paren
id|bad_flp_intr
c_func
(paren
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* invalid command given */
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Invalid FDC command given!&bslash;n&quot;
)paren
suffix:semicolon
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|3
suffix:colon
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: Abnormal termination caused by polling&bslash;n&quot;
)paren
suffix:semicolon
id|bad_flp_intr
c_func
(paren
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* (0) Normal command termination */
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|probing
)paren
(brace
r_int
id|drive
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ftd_msg
(braket
id|drive
)braket
)paren
id|printk
c_func
(paren
l_string|&quot;Auto-detected floppy type %s in fd%d&bslash;n&quot;
comma
id|floppy-&gt;name
comma
id|drive
)paren
suffix:semicolon
id|current_type
(braket
id|drive
)braket
op_assign
id|floppy
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|floppy-&gt;size
op_rshift
l_int|1
suffix:semicolon
id|probing
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_track
)paren
(brace
id|buffer_track
op_assign
id|seek_track
suffix:semicolon
id|buffer_drive
op_assign
id|current_drive
suffix:semicolon
id|buffer_area
op_assign
id|floppy_track_buffer
op_plus
(paren
(paren
id|sector
op_minus
l_int|1
op_plus
id|head
op_star
id|floppy-&gt;sect
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
id|copy_buffer
c_func
(paren
id|buffer_area
comma
id|CURRENT-&gt;buffer
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|command
op_eq
id|FD_READ
op_logical_and
(paren
r_int
r_int
)paren
(paren
id|CURRENT-&gt;buffer
)paren
op_ge
id|LAST_DMA_ADDR
)paren
id|copy_buffer
c_func
(paren
id|tmp_floppy_area
comma
id|CURRENT-&gt;buffer
)paren
suffix:semicolon
id|request_done
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * We try to read tracks, but if we get too many errors, we&n; * go back to reading just one sector at a time.&n; *&n; * This means we should be able to read a sector even if there&n; * are other bad sectors on this track.&n; */
DECL|function|setup_rw_floppy
r_inline
r_void
id|setup_rw_floppy
c_func
(paren
r_void
)paren
(brace
id|setup_DMA
c_func
(paren
)paren
suffix:semicolon
id|do_floppy
op_assign
id|rw_interrupt
suffix:semicolon
id|output_byte
c_func
(paren
id|command
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command
op_ne
id|FD_FORMAT
)paren
(brace
r_if
c_cond
(paren
id|read_track
)paren
(brace
id|output_byte
c_func
(paren
id|current_drive
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|track
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|output_byte
c_func
(paren
id|head
op_lshift
l_int|2
op_or
id|current_drive
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|track
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|head
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|sector
)paren
suffix:semicolon
)brace
id|output_byte
c_func
(paren
l_int|2
)paren
suffix:semicolon
multiline_comment|/* sector size = 512 */
id|output_byte
c_func
(paren
id|floppy-&gt;sect
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|floppy-&gt;gap
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|0xFF
)paren
suffix:semicolon
multiline_comment|/* sector size (0xff when n!=0 ?) */
)brace
r_else
(brace
id|output_byte
c_func
(paren
id|head
op_lshift
l_int|2
op_or
id|current_drive
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|floppy-&gt;sect
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|floppy-&gt;fmt_gap
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_FILL_BYTE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|reset
)paren
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the routine called after every seek (or recalibrate) interrupt&n; * from the floppy controller. Note that the &quot;unexpected interrupt&quot; routine&n; * also does a recalibrate, but doesn&squot;t come here.&n; */
DECL|function|seek_interrupt
r_static
r_void
id|seek_interrupt
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* sense drive status */
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
c_func
(paren
)paren
op_ne
l_int|2
op_logical_or
(paren
id|ST0
op_amp
l_int|0xF8
)paren
op_ne
l_int|0x20
op_logical_or
id|ST1
op_ne
id|seek_track
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: seek failed&bslash;n&quot;
)paren
suffix:semicolon
id|recalibrate
op_assign
l_int|1
suffix:semicolon
id|bad_flp_intr
c_func
(paren
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|current_track
op_assign
id|ST1
suffix:semicolon
id|setup_rw_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine is called when everything should be correctly set up&n; * for the transfer (ie floppy motor is on and the correct floppy is&n; * selected).&n; */
DECL|function|transfer
r_static
r_void
id|transfer
c_func
(paren
r_void
)paren
(brace
id|read_track
op_assign
(paren
id|command
op_eq
id|FD_READ
)paren
op_logical_and
(paren
id|CURRENT_ERRORS
OL
l_int|4
)paren
op_logical_and
(paren
id|floppy-&gt;sect
op_le
id|MAX_BUFFER_SECTORS
)paren
suffix:semicolon
id|configure_fdc_mode
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
(brace
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|seek
)paren
(brace
id|setup_rw_floppy
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|do_floppy
op_assign
id|seek_interrupt
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_SEEK
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_track
)paren
id|output_byte
c_func
(paren
id|current_drive
)paren
suffix:semicolon
r_else
id|output_byte
c_func
(paren
(paren
id|head
op_lshift
l_int|2
)paren
op_or
id|current_drive
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|seek_track
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Special case - used after a unexpected interrupt (or reset)&n; */
DECL|function|recal_interrupt
r_static
r_void
id|recal_interrupt
c_func
(paren
r_void
)paren
(brace
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
r_if
c_cond
(paren
id|result
c_func
(paren
)paren
op_ne
l_int|2
op_logical_or
(paren
id|ST0
op_amp
l_int|0xE0
)paren
op_eq
l_int|0x60
)paren
id|reset
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Recalibrate until track 0 is reached. Might help on some errors. */
r_if
c_cond
(paren
(paren
id|ST0
op_amp
l_int|0x10
)paren
op_eq
l_int|0x10
)paren
id|recalibrate_floppy
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* FIXME: should limit nr of recalibrates */
r_else
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|unexpected_floppy_interrupt
r_static
r_void
id|unexpected_floppy_interrupt
c_func
(paren
r_void
)paren
(brace
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: unexpected interrupt&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
c_func
(paren
)paren
op_ne
l_int|2
op_logical_or
(paren
id|ST0
op_amp
l_int|0xE0
)paren
op_eq
l_int|0x60
)paren
id|reset
op_assign
l_int|1
suffix:semicolon
r_else
id|recalibrate
op_assign
l_int|1
suffix:semicolon
)brace
DECL|function|recalibrate_floppy
r_static
r_void
id|recalibrate_floppy
c_func
(paren
r_void
)paren
(brace
id|recalibrate
op_assign
l_int|0
suffix:semicolon
id|current_track
op_assign
l_int|0
suffix:semicolon
id|do_floppy
op_assign
id|recal_interrupt
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_RECALIBRATE
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|head
op_lshift
l_int|2
op_or
id|current_drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|reset
)paren
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Must do 4 FD_SENSEIs after reset because of ``drive polling&squot;&squot;.&n; */
DECL|function|reset_interrupt
r_static
r_void
id|reset_interrupt
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
(paren
r_void
)paren
id|result
c_func
(paren
)paren
suffix:semicolon
)brace
id|output_byte
c_func
(paren
id|FD_SPECIFY
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|cur_spec1
)paren
suffix:semicolon
multiline_comment|/* hut etc */
id|output_byte
c_func
(paren
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Head load time =6ms, DMA */
id|configure_fdc_mode
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* reprogram fdc */
r_if
c_cond
(paren
id|initial_reset_flag
)paren
(brace
id|initial_reset_flag
op_assign
l_int|0
suffix:semicolon
id|recalibrate
op_assign
l_int|1
suffix:semicolon
id|reset
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|recover
)paren
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_else
(brace
id|recalibrate_floppy
c_func
(paren
)paren
suffix:semicolon
id|recover
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * reset is done by pulling bit 2 of DOR low for a while.&n; */
DECL|function|reset_floppy
r_static
r_void
id|reset_floppy
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|do_floppy
op_assign
id|reset_interrupt
suffix:semicolon
id|reset
op_assign
l_int|0
suffix:semicolon
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|cur_spec1
op_assign
op_minus
l_int|1
suffix:semicolon
id|cur_rate
op_assign
op_minus
l_int|1
suffix:semicolon
id|recalibrate
op_assign
l_int|1
suffix:semicolon
id|need_configure
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|initial_reset_flag
)paren
id|printk
c_func
(paren
l_string|&quot;Reset-floppy called&bslash;n&quot;
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|current_DOR
op_amp
op_complement
l_int|0x04
comma
id|FD_DOR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|1000
suffix:semicolon
id|i
op_increment
)paren
id|__asm__
c_func
(paren
l_string|&quot;nop&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
id|current_DOR
comma
id|FD_DOR
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|floppy_shutdown
r_static
r_void
id|floppy_shutdown
c_func
(paren
r_void
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|do_floppy
op_assign
l_int|NULL
suffix:semicolon
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|recover
op_assign
l_int|1
suffix:semicolon
id|reset_floppy
c_func
(paren
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|shake_done
r_static
r_void
id|shake_done
c_func
(paren
r_void
)paren
(brace
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|FD_DIR
)paren
op_amp
l_int|0x80
)paren
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|retry_recal
r_static
r_int
id|retry_recal
c_func
(paren
r_void
(paren
op_star
id|proc
)paren
(paren
r_void
)paren
)paren
(brace
id|output_byte
c_func
(paren
id|FD_SENSEI
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
c_func
(paren
)paren
op_eq
l_int|2
op_logical_and
(paren
id|ST0
op_amp
l_int|0x10
)paren
op_ne
l_int|0x10
)paren
r_return
l_int|0
suffix:semicolon
id|do_floppy
op_assign
id|proc
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_RECALIBRATE
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|head
op_lshift
l_int|2
op_or
id|current_drive
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|shake_zero
r_static
r_void
id|shake_zero
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|retry_recal
c_func
(paren
id|shake_zero
)paren
)paren
id|shake_done
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|shake_one
r_static
r_void
id|shake_one
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|retry_recal
c_func
(paren
id|shake_one
)paren
)paren
r_return
suffix:semicolon
id|do_floppy
op_assign
id|shake_done
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_SEEK
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|head
op_lshift
l_int|2
op_or
id|current_drive
)paren
suffix:semicolon
id|output_byte
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|floppy_ready
r_static
r_void
id|floppy_ready
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|inb
c_func
(paren
id|FD_DIR
)paren
op_amp
l_int|0x80
)paren
(brace
id|changed_floppies
op_or_assign
l_int|1
op_lshift
id|current_drive
suffix:semicolon
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|keep_data
(braket
id|current_drive
)braket
)paren
(brace
r_if
c_cond
(paren
id|keep_data
(braket
id|current_drive
)braket
OG
l_int|0
)paren
id|keep_data
(braket
id|current_drive
)braket
op_decrement
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|ftd_msg
(braket
id|current_drive
)braket
op_logical_and
id|current_type
(braket
id|current_drive
)braket
op_ne
l_int|NULL
)paren
id|printk
c_func
(paren
l_string|&quot;Disk type is undefined after disk &quot;
l_string|&quot;change in fd%d&bslash;n&quot;
comma
id|current_drive
)paren
suffix:semicolon
id|current_type
(braket
id|current_drive
)braket
op_assign
l_int|NULL
suffix:semicolon
id|floppy_sizes
(braket
id|current_drive
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
)brace
multiline_comment|/* Forcing the drive to seek makes the &quot;media changed&quot; condition go away.&n; * There should be a cleaner solution for that ...&n; */
r_if
c_cond
(paren
op_logical_neg
id|reset
op_logical_and
op_logical_neg
id|recalibrate
)paren
(brace
r_if
c_cond
(paren
id|current_track
op_logical_and
id|current_track
op_ne
id|NO_TRACK
)paren
id|do_floppy
op_assign
id|shake_zero
suffix:semicolon
r_else
id|do_floppy
op_assign
id|shake_one
suffix:semicolon
id|output_byte
c_func
(paren
id|FD_RECALIBRATE
)paren
suffix:semicolon
id|output_byte
c_func
(paren
id|head
op_lshift
l_int|2
op_or
id|current_drive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|reset
)paren
(brace
id|reset_floppy
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|recalibrate
)paren
(brace
id|recalibrate_floppy
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|transfer
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|setup_format_params
r_static
r_void
id|setup_format_params
c_func
(paren
r_void
)paren
(brace
r_int
r_char
op_star
id|here
op_assign
(paren
r_int
r_char
op_star
)paren
id|tmp_floppy_area
suffix:semicolon
r_int
id|count
comma
id|head_shift
comma
id|track_shift
comma
id|total_shift
suffix:semicolon
multiline_comment|/* allow for about 30ms for data transport per track */
id|head_shift
op_assign
id|floppy-&gt;sect
op_div
l_int|6
suffix:semicolon
multiline_comment|/* a ``cylinder&squot;&squot; is two tracks plus a little stepping time */
id|track_shift
op_assign
l_int|2
op_star
id|head_shift
op_plus
l_int|1
suffix:semicolon
multiline_comment|/* count backwards */
id|total_shift
op_assign
id|floppy-&gt;sect
op_minus
(paren
(paren
id|track_shift
op_star
id|track
op_plus
id|head_shift
op_star
id|head
)paren
op_mod
id|floppy-&gt;sect
)paren
suffix:semicolon
multiline_comment|/* XXX: should do a check to see this fits in tmp_floppy_area!! */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|floppy-&gt;sect
suffix:semicolon
id|count
op_increment
)paren
(brace
op_star
id|here
op_increment
op_assign
id|track
suffix:semicolon
op_star
id|here
op_increment
op_assign
id|head
suffix:semicolon
op_star
id|here
op_increment
op_assign
l_int|1
op_plus
(paren
(paren
id|count
op_plus
id|total_shift
)paren
op_mod
id|floppy-&gt;sect
)paren
suffix:semicolon
op_star
id|here
op_increment
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* 512 bytes */
)brace
)brace
DECL|function|redo_fd_request
r_static
r_void
id|redo_fd_request
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|block
suffix:semicolon
r_char
op_star
id|buffer_area
suffix:semicolon
r_int
id|device
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_logical_and
id|CURRENT-&gt;dev
OL
l_int|0
)paren
r_return
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
id|format_status
op_eq
id|FORMAT_WAIT
)paren
id|format_status
op_assign
id|FORMAT_BUSY
suffix:semicolon
r_if
c_cond
(paren
id|format_status
op_ne
id|FORMAT_BUSY
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|CURRENT
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|fdc_busy
)paren
id|printk
c_func
(paren
l_string|&quot;FDC access conflict!&quot;
)paren
suffix:semicolon
id|fdc_busy
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
id|CLEAR_INTR
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|CURRENT-&gt;dev
)paren
op_ne
id|MAJOR_NR
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: request list destroyed&quot;
)paren
suffix:semicolon
"&bslash;"
r_if
c_cond
(paren
id|CURRENT-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|CURRENT-&gt;bh-&gt;b_lock
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
)brace
)brace
id|seek
op_assign
l_int|0
suffix:semicolon
id|probing
op_assign
l_int|0
suffix:semicolon
id|device
op_assign
id|MINOR
c_func
(paren
id|CURRENT_DEVICE
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
OG
l_int|3
)paren
id|floppy
op_assign
(paren
id|device
op_rshift
l_int|2
)paren
op_plus
id|floppy_type
suffix:semicolon
r_else
(brace
multiline_comment|/* Auto-detection */
id|floppy
op_assign
id|current_type
(braket
id|device
op_amp
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|floppy
)paren
(brace
id|probing
op_assign
l_int|1
suffix:semicolon
id|floppy
op_assign
id|base_type
(braket
id|device
op_amp
l_int|3
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|floppy
)paren
(brace
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_ERRORS
op_amp
l_int|1
)paren
id|floppy
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|format_status
op_ne
id|FORMAT_BUSY
)paren
(brace
r_if
c_cond
(paren
id|current_drive
op_ne
id|CURRENT_DEV
)paren
(brace
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|current_drive
op_assign
id|CURRENT_DEV
suffix:semicolon
)brace
id|block
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
r_if
c_cond
(paren
id|block
op_plus
l_int|2
OG
id|floppy-&gt;size
)paren
(brace
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|sector
op_assign
id|block
op_mod
id|floppy-&gt;sect
suffix:semicolon
id|block
op_div_assign
id|floppy-&gt;sect
suffix:semicolon
id|head
op_assign
id|block
op_mod
id|floppy-&gt;head
suffix:semicolon
id|track
op_assign
id|block
op_div
id|floppy-&gt;head
suffix:semicolon
id|seek_track
op_assign
id|track
op_lshift
id|floppy-&gt;stretch
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|READ
)paren
id|command
op_assign
id|FD_READ
suffix:semicolon
r_else
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|WRITE
)paren
id|command
op_assign
id|FD_WRITE
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;do_fd_request: unknown command&bslash;n&quot;
)paren
suffix:semicolon
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
r_else
(brace
r_if
c_cond
(paren
id|current_drive
op_ne
(paren
id|format_req.device
op_amp
l_int|3
)paren
)paren
id|current_track
op_assign
id|NO_TRACK
suffix:semicolon
id|current_drive
op_assign
id|format_req.device
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
r_int
)paren
id|format_req.track
)paren
op_ge
id|floppy-&gt;track
op_logical_or
(paren
id|format_req.head
op_amp
l_int|0xfffe
)paren
op_logical_or
id|probing
)paren
(brace
id|request_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|head
op_assign
id|format_req.head
suffix:semicolon
id|track
op_assign
id|format_req.track
suffix:semicolon
id|seek_track
op_assign
id|track
op_lshift
id|floppy-&gt;stretch
suffix:semicolon
r_if
c_cond
(paren
id|seek_track
op_eq
id|buffer_track
)paren
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
id|command
op_assign
id|FD_FORMAT
suffix:semicolon
id|setup_format_params
c_func
(paren
)paren
suffix:semicolon
)brace
id|timer_table
(braket
id|FLOPPY_TIMER
)braket
dot
id|expires
op_assign
id|jiffies
op_plus
l_int|10
op_star
id|HZ
suffix:semicolon
id|timer_active
op_or_assign
l_int|1
op_lshift
id|FLOPPY_TIMER
suffix:semicolon
r_if
c_cond
(paren
(paren
id|seek_track
op_eq
id|buffer_track
)paren
op_logical_and
(paren
id|current_drive
op_eq
id|buffer_drive
)paren
)paren
(brace
id|buffer_area
op_assign
id|floppy_track_buffer
op_plus
(paren
(paren
id|sector
op_plus
id|head
op_star
id|floppy-&gt;sect
)paren
op_lshift
l_int|9
)paren
suffix:semicolon
r_if
c_cond
(paren
id|command
op_eq
id|FD_READ
)paren
(brace
id|copy_buffer
c_func
(paren
id|buffer_area
comma
id|CURRENT-&gt;buffer
)paren
suffix:semicolon
id|request_done
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|command
op_eq
id|FD_WRITE
)paren
id|copy_buffer
c_func
(paren
id|CURRENT-&gt;buffer
comma
id|buffer_area
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|seek_track
op_ne
id|current_track
)paren
id|seek
op_assign
l_int|1
suffix:semicolon
id|sector
op_increment
suffix:semicolon
id|del_timer
c_func
(paren
id|motor_off_timer
op_plus
id|current_drive
)paren
suffix:semicolon
id|floppy_on
c_func
(paren
id|current_drive
)paren
suffix:semicolon
)brace
DECL|function|do_fd_request
r_void
id|do_fd_request
c_func
(paren
r_void
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fdc_busy
)paren
id|sleep_on
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
id|fdc_busy
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fd_ioctl
r_static
r_int
id|fd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|param
)paren
(brace
r_int
id|i
comma
id|drive
comma
id|cnt
comma
id|okay
suffix:semicolon
r_struct
id|floppy_struct
op_star
id|this_floppy
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
id|RO_IOCTLS
c_func
(paren
id|inode-&gt;i_rdev
comma
id|param
)paren
suffix:semicolon
)brace
id|drive
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FDFMTBEG
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDFMTEND
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|fake_change
op_or_assign
l_int|1
op_lshift
(paren
id|drive
op_amp
l_int|3
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|drive
op_and_assign
l_int|3
suffix:semicolon
id|cmd
op_assign
id|FDCLRPRM
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDGETPRM
suffix:colon
r_if
c_cond
(paren
id|drive
OG
l_int|3
)paren
id|this_floppy
op_assign
op_amp
id|floppy_type
(braket
id|drive
op_rshift
l_int|2
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|this_floppy
op_assign
id|current_type
(braket
id|drive
op_amp
l_int|3
)braket
)paren
op_eq
l_int|NULL
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|i
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|param
comma
r_sizeof
(paren
r_struct
id|floppy_struct
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
)paren
r_return
id|i
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
r_sizeof
(paren
r_struct
id|floppy_struct
)paren
suffix:semicolon
id|cnt
op_increment
)paren
id|put_fs_byte
c_func
(paren
(paren
(paren
r_char
op_star
)paren
id|this_floppy
)paren
(braket
id|cnt
)braket
comma
(paren
r_char
op_star
)paren
id|param
op_plus
id|cnt
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|FDFMTTRK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|fd_ref
(braket
id|drive
op_amp
l_int|3
)braket
op_ne
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|format_status
op_ne
id|FORMAT_NONE
)paren
id|sleep_on
c_func
(paren
op_amp
id|format_done
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
r_sizeof
(paren
r_struct
id|format_descr
)paren
suffix:semicolon
id|cnt
op_increment
)paren
(paren
(paren
r_char
op_star
)paren
op_amp
id|format_req
)paren
(braket
id|cnt
)braket
op_assign
id|get_fs_byte
c_func
(paren
(paren
r_char
op_star
)paren
id|param
op_plus
id|cnt
)paren
suffix:semicolon
id|format_req.device
op_assign
id|drive
suffix:semicolon
id|format_status
op_assign
id|FORMAT_WAIT
suffix:semicolon
id|format_errors
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|format_status
op_ne
id|FORMAT_OKAY
op_logical_and
id|format_status
op_ne
id|FORMAT_ERROR
)paren
(brace
r_if
c_cond
(paren
id|fdc_busy
)paren
id|sleep_on
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
r_else
(brace
id|fdc_busy
op_assign
l_int|1
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|format_status
op_ne
id|FORMAT_OKAY
op_logical_and
id|format_status
op_ne
id|FORMAT_ERROR
)paren
id|sleep_on
c_func
(paren
op_amp
id|format_done
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|okay
op_assign
id|format_status
op_eq
id|FORMAT_OKAY
suffix:semicolon
id|format_status
op_assign
id|FORMAT_NONE
suffix:semicolon
id|floppy_off
c_func
(paren
id|drive
op_amp
l_int|3
)paren
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|format_done
)paren
suffix:semicolon
r_return
id|okay
ques
c_cond
l_int|0
suffix:colon
op_minus
id|EIO
suffix:semicolon
r_case
id|FDFLUSH
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|permission
c_func
(paren
id|inode
comma
l_int|2
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|fake_change
op_or_assign
l_int|1
op_lshift
(paren
id|drive
op_amp
l_int|3
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|suser
c_func
(paren
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|drive
template_param
l_int|3
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FDCLRPRM
suffix:colon
id|current_type
(braket
id|drive
)braket
op_assign
l_int|NULL
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
id|keep_data
(braket
id|drive
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDSETPRM
suffix:colon
r_case
id|FDDEFPRM
suffix:colon
id|memcpy_fromfs
c_func
(paren
id|user_params
op_plus
id|drive
comma
(paren
r_void
op_star
)paren
id|param
comma
r_sizeof
(paren
r_struct
id|floppy_struct
)paren
)paren
suffix:semicolon
id|current_type
(braket
id|drive
)braket
op_assign
op_amp
id|user_params
(braket
id|drive
)braket
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|user_params
(braket
id|drive
)braket
dot
id|size
op_rshift
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cmd
op_eq
id|FDDEFPRM
)paren
id|keep_data
(braket
id|drive
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fdc_busy
)paren
id|sleep_on
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
id|fdc_busy
op_assign
l_int|1
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
(paren
id|current_DOR
op_amp
l_int|0xfc
)paren
op_or
id|drive
op_or
(paren
l_int|0x10
op_lshift
id|drive
)paren
comma
id|FD_DOR
)paren
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|0
suffix:semicolon
id|cnt
OL
l_int|1000
suffix:semicolon
id|cnt
op_increment
)paren
id|__asm__
c_func
(paren
l_string|&quot;nop&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|inb
c_func
(paren
id|FD_DIR
)paren
op_amp
l_int|0x80
)paren
id|keep_data
(braket
id|drive
)braket
op_assign
l_int|1
suffix:semicolon
r_else
id|keep_data
(braket
id|drive
)braket
op_assign
l_int|0
suffix:semicolon
id|outb_p
c_func
(paren
id|current_DOR
comma
id|FD_DOR
)paren
suffix:semicolon
id|fdc_busy
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|FDMSGON
suffix:colon
id|ftd_msg
(braket
id|drive
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDMSGOFF
suffix:colon
id|ftd_msg
(braket
id|drive
)braket
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FDSETEMSGTRESH
suffix:colon
id|min_report_error_cnt
(braket
id|drive
)braket
op_assign
(paren
r_int
r_int
)paren
(paren
id|param
op_amp
l_int|0x0f
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|macro|CMOS_READ
mdefine_line|#define CMOS_READ(addr) ({ &bslash;&n;outb_p(addr,0x70); &bslash;&n;inb_p(0x71); &bslash;&n;})
DECL|function|find_base
r_static
r_struct
id|floppy_struct
op_star
id|find_base
c_func
(paren
r_int
id|drive
comma
r_int
id|code
)paren
(brace
r_struct
id|floppy_struct
op_star
id|base
suffix:semicolon
r_if
c_cond
(paren
id|code
OG
l_int|0
op_logical_and
id|code
OL
l_int|7
)paren
(brace
multiline_comment|/* -bb*/
id|base
op_assign
op_amp
id|floppy_types
(braket
(paren
id|code
op_minus
l_int|1
)paren
op_star
l_int|2
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fd%d is %s&quot;
comma
id|drive
comma
id|base-&gt;name
)paren
suffix:semicolon
r_return
id|base
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|code
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd%d is not installed&quot;
comma
id|drive
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;fd%d is unknown type %d&quot;
comma
id|drive
comma
id|code
)paren
suffix:semicolon
r_return
l_int|NULL
suffix:semicolon
)brace
DECL|function|config_types
r_static
r_void
id|config_types
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Floppy drive(s): &quot;
)paren
suffix:semicolon
id|base_type
(braket
l_int|0
)braket
op_assign
id|find_base
c_func
(paren
l_int|0
comma
(paren
id|CMOS_READ
c_func
(paren
l_int|0x10
)paren
op_rshift
l_int|4
)paren
op_amp
l_int|15
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|CMOS_READ
c_func
(paren
l_int|0x10
)paren
op_amp
l_int|15
)paren
op_eq
l_int|0
)paren
id|base_type
(braket
l_int|1
)braket
op_assign
l_int|NULL
suffix:semicolon
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;, &quot;
)paren
suffix:semicolon
id|base_type
(braket
l_int|1
)braket
op_assign
id|find_base
c_func
(paren
l_int|1
comma
id|CMOS_READ
c_func
(paren
l_int|0x10
)paren
op_amp
l_int|15
)paren
suffix:semicolon
)brace
id|base_type
(braket
l_int|2
)braket
op_assign
id|base_type
(braket
l_int|3
)braket
op_assign
l_int|NULL
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * floppy_open check for aliasing (/dev/fd0 can be the same as&n; * /dev/PS0 etc), and disallows simultaneous access to the same&n; * drive with different device numbers.&n; */
DECL|function|floppy_open
r_static
r_int
id|floppy_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|drive
suffix:semicolon
r_int
id|old_dev
suffix:semicolon
id|drive
op_assign
id|inode-&gt;i_rdev
op_amp
l_int|3
suffix:semicolon
id|old_dev
op_assign
id|fd_device
(braket
id|drive
)braket
suffix:semicolon
r_if
c_cond
(paren
id|fd_ref
(braket
id|drive
)braket
)paren
r_if
c_cond
(paren
id|old_dev
op_ne
id|inode-&gt;i_rdev
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|floppy_grab_irq_and_dma
c_func
(paren
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
id|fd_ref
(braket
id|drive
)braket
op_increment
suffix:semicolon
id|fd_device
(braket
id|drive
)braket
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
id|buffer_drive
op_assign
id|buffer_track
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|old_dev
op_logical_and
id|old_dev
op_ne
id|inode-&gt;i_rdev
)paren
id|invalidate_buffers
c_func
(paren
id|old_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp
op_logical_and
id|filp-&gt;f_mode
)paren
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|floppy_release
r_static
r_void
id|floppy_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd_ref
(braket
id|inode-&gt;i_rdev
op_amp
l_int|3
)braket
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;floppy_release with fd_ref == 0&quot;
)paren
suffix:semicolon
id|fd_ref
(braket
id|inode-&gt;i_rdev
op_amp
l_int|3
)braket
op_assign
l_int|0
suffix:semicolon
)brace
id|floppy_release_irq_and_dma
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|check_floppy_change
r_static
r_int
id|check_floppy_change
c_func
(paren
id|dev_t
id|dev
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|bh
op_assign
id|getblk
c_func
(paren
id|dev
comma
l_int|0
comma
l_int|1024
)paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|i
op_assign
id|floppy_change
c_func
(paren
id|bh
)paren
suffix:semicolon
id|brelse
c_func
(paren
id|bh
)paren
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
DECL|variable|floppy_fops
r_static
r_struct
id|file_operations
id|floppy_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|fd_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|floppy_open
comma
multiline_comment|/* open */
id|floppy_release
comma
multiline_comment|/* release */
id|block_fsync
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
id|check_floppy_change
comma
multiline_comment|/* media_change */
l_int|NULL
multiline_comment|/* revalidate */
)brace
suffix:semicolon
DECL|function|floppy_interrupt
r_static
r_void
id|floppy_interrupt
c_func
(paren
r_int
id|unused
)paren
(brace
r_void
(paren
op_star
id|handler
)paren
(paren
r_void
)paren
op_assign
id|DEVICE_INTR
suffix:semicolon
id|DEVICE_INTR
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handler
)paren
id|handler
op_assign
id|unexpected_floppy_interrupt
suffix:semicolon
id|handler
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This is the floppy IRQ description. The SA_INTERRUPT in sa_flags&n; * means we run the IRQ-handler with interrupts disabled.&n; */
DECL|variable|floppy_sigaction
r_static
r_struct
id|sigaction
id|floppy_sigaction
op_assign
(brace
id|floppy_interrupt
comma
l_int|0
comma
id|SA_INTERRUPT
comma
l_int|NULL
)brace
suffix:semicolon
DECL|function|floppy_init
r_void
id|floppy_init
c_func
(paren
r_void
)paren
(brace
id|outb
c_func
(paren
id|current_DOR
comma
id|FD_DOR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
comma
op_amp
id|floppy_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major %d for floppy&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|floppy_sizes
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|timer_table
(braket
id|FLOPPY_TIMER
)braket
dot
id|fn
op_assign
id|floppy_shutdown
suffix:semicolon
id|timer_active
op_and_assign
op_complement
(paren
l_int|1
op_lshift
id|FLOPPY_TIMER
)paren
suffix:semicolon
id|config_types
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* Try to determine the floppy controller type */
id|output_byte
c_func
(paren
id|FD_VERSION
)paren
suffix:semicolon
multiline_comment|/* get FDC version code */
r_if
c_cond
(paren
id|result
c_func
(paren
)paren
op_ne
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: FDC failed to return version byte&bslash;n&quot;
)paren
suffix:semicolon
id|fdc_version
op_assign
id|FDC_TYPE_STD
suffix:semicolon
)brace
r_else
id|fdc_version
op_assign
id|reply_buffer
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|fdc_version
op_ne
id|FDC_TYPE_STD
)paren
id|printk
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: FDC version 0x%x&bslash;n&quot;
comma
id|fdc_version
)paren
suffix:semicolon
macro_line|#ifndef FDC_FIFO_UNTESTED
id|fdc_version
op_assign
id|FDC_TYPE_STD
suffix:semicolon
multiline_comment|/* force std fdc type; can&squot;t test other. */
macro_line|#endif
multiline_comment|/* Not all FDCs seem to be able to handle the version command&n;&t; * properly, so force a reset for the standard FDC clones,&n;&t; * to avoid interrupt garbage.&n;&t; */
r_if
c_cond
(paren
id|fdc_version
op_eq
id|FDC_TYPE_STD
)paren
(brace
id|initial_reset_flag
op_assign
l_int|1
suffix:semicolon
id|reset_floppy
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
DECL|variable|usage_count
r_static
r_int
id|usage_count
op_assign
l_int|0
suffix:semicolon
DECL|function|floppy_grab_irq_and_dma
r_int
id|floppy_grab_irq_and_dma
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|usage_count
op_increment
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|irqaction
c_func
(paren
id|FLOPPY_IRQ
comma
op_amp
id|floppy_sigaction
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to grab IRQ%d for the floppy driver&bslash;n&quot;
comma
id|FLOPPY_IRQ
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|FLOPPY_DMA
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to grab DMA%d for the floppy driver&bslash;n&quot;
comma
id|FLOPPY_DMA
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|FLOPPY_IRQ
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|enable_irq
c_func
(paren
id|FLOPPY_IRQ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|floppy_release_irq_and_dma
r_void
id|floppy_release_irq_and_dma
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|usage_count
)paren
r_return
suffix:semicolon
id|disable_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|disable_irq
c_func
(paren
id|FLOPPY_IRQ
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|FLOPPY_IRQ
)paren
suffix:semicolon
)brace
eof
