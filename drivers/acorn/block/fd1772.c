multiline_comment|/*&n; *  linux/kernel/arch/arm/drivers/block/fd1772.c&n; *  Based on ataflop.c in the m68k Linux&n; *  Copyright (C) 1993  Greg Harp&n; *  Atari Support by Bjoern Brauel, Roman Hodek&n; *  Archimedes Support by Dave Gilbert (gilbertd@cs.man.ac.uk)&n; *&n; *  Big cleanup Sep 11..14 1994 Roman Hodek:&n; *   - Driver now works interrupt driven&n; *   - Support for two drives; should work, but I cannot test that :-(&n; *   - Reading is done in whole tracks and buffered to speed up things&n; *   - Disk change detection and drive deselecting after motor-off&n; *     similar to TOS&n; *   - Autodetection of disk format (DD/HD); untested yet, because I&n; *     don&squot;t have an HD drive :-(&n; *&n; *  Fixes Nov 13 1994 Martin Schaller:&n; *   - Autodetection works now&n; *   - Support for 5 1/4&quot; disks&n; *   - Removed drive type (unknown on atari)&n; *   - Do seeks with 8 Mhz&n; *&n; *  Changes by Andreas Schwab:&n; *   - After errors in multiple read mode try again reading single sectors&n; *  (Feb 1995):&n; *   - Clean up error handling&n; *   - Set blk_size for proper size checking&n; *   - Initialize track register when testing presence of floppy&n; *   - Implement some ioctl&squot;s&n; *&n; *  Changes by Torsten Lang:&n; *   - When probing the floppies we should add the FDC1772CMDADD_H flag since&n; *     the FDC1772 will otherwise wait forever when no disk is inserted...&n; *&n; *  Things left to do:&n; *   - Formatting&n; *   - Maybe a better strategy for disk change detection (does anyone&n; *     know one?)&n; *   - There are some strange problems left: The strangest one is&n; *     that, at least on my TT (4+4MB), the first 2 Bytes of the last&n; *     page of the TT-Ram (!) change their contents (some bits get&n; *     set) while a floppy DMA is going on. But there are no accesses&n; *     to these memory locations from the kernel... (I tested that by&n; *     making the page read-only). I cannot explain what&squot;s going on...&n; *   - Sometimes the drive-change-detection stops to work. The&n; *     function is still called, but the WP bit always reads as 0...&n; *     Maybe a problem with the status reg mode or a timing problem.&n; *     Note 10/12/94: The change detection now seems to work reliably.&n; *     There is no proof, but I&squot;ve seen no hang for a long time...&n; *&n; * ARCHIMEDES changes: (gilbertd@cs.man.ac.uk)&n; *     26/12/95 - Changed all names starting with FDC to FDC1772&n; *                Removed all references to clock speed of FDC - we&squot;re stuck with 8MHz&n; *                Modified disk_type structure to remove HD formats&n; *&n; *      7/ 1/96 - Wrote FIQ code, removed most remaining atariisms&n; *&n; *     13/ 1/96 - Well I think its read a single sector; but there is a problem&n; *                fd_rwsec_done which is called in FIQ mode starts another transfer&n; *                off (in fd_rwsec) while still in FIQ mode.  Because its still in&n; *                FIQ mode it can&squot;t service the DMA and loses data. So need to&n; *                heavily restructure.&n; *     14/ 1/96 - Found that the definitions of the register numbers of the&n; *                FDC were multiplied by 2 in the header for the 16bit words&n; *                of the atari so half the writes were going in the wrong place.&n; *                Also realised that the FIQ entry didn&squot;t make any attempt to&n; *                preserve registers or return correctly; now in assembler.&n; *&n; *     11/ 2/96 - Hmm - doesn&squot;t work on real machine.  Auto detect doesn&squot;t&n; *                and hacking that past seems to wait forever - check motor&n; *                being turned on.&n; *&n; *     17/ 2/96 - still having problems - forcing track to -1 when selecting&n; *                new drives seems to allow it to read first few sectors&n; *                but then we get solid hangs at apparently random places&n; *                which change depending what is happening.&n; *&n; *      9/ 3/96 - Fiddled a lot of stuff around to move to kernel 1.3.35&n; *                A lot of fiddling in DMA stuff. Having problems with it&n; *                constnatly thinking its timeing out. Ah - its timeout&n; *                was set to (6*HZ) rather than jiffies+(6*HZ).  Now giving&n; *                duff data!&n; *&n; *      5/ 4/96 - Made it use the new IOC_ macros rather than *ioc&n; *                Hmm - giving unexpected FIQ and then timeouts&n; *     18/ 8/96 - Ran through indent -kr -i8&n; *                Some changes to disc change detect; don&squot;t know how well it&n; *                works.&n; *     24/ 8/96 - Put all the track buffering code back in from the atari&n; *                code - I wonder if it will still work... No :-)&n; *                Still works if I turn off track buffering.&n; *     25/ 8/96 - Changed the timer expires that I&squot;d added back to be &n; *                jiffies + ....; and it all sprang to life! Got 2.8K/sec&n; *                off a cp -r of a 679K disc (showed 94% cpu usage!)&n; *                (PC gets 14.3K/sec - 0% CPU!) Hmm - hard drive corrupt!&n; *                Also perhaps that compile was with cache off.&n; *                changed cli in fd_readtrack_check to cliIF&n; *                changed vmallocs to kmalloc (whats the difference!!)&n; *                Removed the busy wait loop in do_fd_request and replaced&n; *                by a routine on tq_immediate; only 11% cpu on a dd off the&n; *                raw disc - but the speed is the same.&n; *&t;1/ 9/96 - Idea (failed!) - set the &squot;disable spin-up seqeunce&squot;&n; *&t;&t;  when we read the track if we know the motor is on; didn&squot;t&n; *&t;&t;  help - perhaps we have to do it in stepping as well.&n; *&t;&t;  Nope. Still doesn&squot;t help.&n; *&t;&t;  Hmm - what seems to be happening is that fd_readtrack_check&n; *&t;&t;  is never getting called. Its job is to terminate the read&n; *&t;&t;  just after we think we should have got the data; otherwise&n; *&t;&t;  the fdc takes 1 second to timeout; which is what&squot;s happening&n; *&t;&t;  Now I can see &squot;readtrack_timer&squot; being set (which should do the&n; *&t;&t;  call); but it never seems to be called - hmm!&n; *&t;&t;  OK - I&squot;ve moved the check to my tq_immediate code -&n; *&t;&t;  and it WORKS! 13.95K/second at 19% CPU.&n; *&t;&t;  I wish I knew why that timer didn&squot;t work.....&n; *&n; *     16/11/96 - Fiddled and frigged for 2.0.18&n; *&n; * DAG 30/01/99 - Started frobbing for 2.2.1&n; * DAG 20/06/99 - A little more frobbing:&n; *     Included include/asm/uaccess.h for get_user/put_user&n; */
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/fcntl.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/fd.h&gt;
macro_line|#include &lt;linux/fd1772.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;asm/arch/oldlatches.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/dma.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/ioc.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/mach-types.h&gt;
macro_line|#include &lt;asm/pgtable.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR FLOPPY_MAJOR
DECL|macro|FLOPPY_DMA
mdefine_line|#define FLOPPY_DMA 0
macro_line|#include &lt;linux/blk.h&gt;
multiline_comment|/* Note: FD_MAX_UNITS could be redefined to 2 for the Atari (with&n; * little additional rework in this file). But I&squot;m not yet sure if&n; * some other code depends on the number of floppies... (It is defined&n; * in a public header!)&n; */
macro_line|#if 0
DECL|macro|FD_MAX_UNITS
macro_line|#undef FD_MAX_UNITS
DECL|macro|FD_MAX_UNITS
mdefine_line|#define&t;FD_MAX_UNITS&t;2
macro_line|#endif
multiline_comment|/* Ditto worries for Arc - DAG */
DECL|macro|FD_MAX_UNITS
mdefine_line|#define FD_MAX_UNITS 4
DECL|macro|TRACKBUFFER
mdefine_line|#define TRACKBUFFER 0
multiline_comment|/*#define DEBUG*/
macro_line|#ifdef DEBUG
DECL|macro|DPRINT
mdefine_line|#define DPRINT(a)&t;printk a
macro_line|#else
DECL|macro|DPRINT
mdefine_line|#define DPRINT(a)
macro_line|#endif
multiline_comment|/* Disk types: DD */
DECL|struct|archy_disk_type
r_static
r_struct
id|archy_disk_type
(brace
DECL|member|name
r_const
r_char
op_star
id|name
suffix:semicolon
DECL|member|spt
r_int
id|spt
suffix:semicolon
multiline_comment|/* sectors per track */
DECL|member|blocks
r_int
id|blocks
suffix:semicolon
multiline_comment|/* total number of blocks */
DECL|member|stretch
r_int
id|stretch
suffix:semicolon
multiline_comment|/* track doubling ? */
DECL|variable|disk_type
)brace
id|disk_type
(braket
)braket
op_assign
(brace
(brace
l_string|&quot;d360&quot;
comma
l_int|9
comma
l_int|720
comma
l_int|0
)brace
comma
multiline_comment|/* 360kB diskette */
(brace
l_string|&quot;D360&quot;
comma
l_int|9
comma
l_int|720
comma
l_int|1
)brace
comma
multiline_comment|/* 360kb in 720kb drive */
(brace
l_string|&quot;D720&quot;
comma
l_int|9
comma
l_int|1440
comma
l_int|0
)brace
comma
multiline_comment|/* 720kb diskette (DD) */
multiline_comment|/*{ &quot;D820&quot;, 10,1640, 0}, */
multiline_comment|/* DD disk with 82 tracks/10 sectors &n;&t;                              - DAG - can&squot;t see how type detect can distinguish this&n;&t;&t;&t;&t;      from 720K until it reads block 4 by which time its too late! */
)brace
suffix:semicolon
DECL|macro|NUM_DISK_TYPES
mdefine_line|#define&t;NUM_DISK_TYPES (sizeof(disk_type)/sizeof(*disk_type))
multiline_comment|/*&n; * Maximum disk size (in kilobytes). This default is used whenever the&n; * current disk size is unknown.&n; */
DECL|macro|MAX_DISK_SIZE
mdefine_line|#define MAX_DISK_SIZE 720
DECL|variable|floppy_sizes
r_static
r_int
id|floppy_sizes
(braket
l_int|256
)braket
suffix:semicolon
DECL|variable|floppy_blocksizes
r_static
r_int
id|floppy_blocksizes
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* current info on each unit */
DECL|struct|archy_floppy_struct
r_static
r_struct
id|archy_floppy_struct
(brace
DECL|member|connected
r_int
id|connected
suffix:semicolon
multiline_comment|/* !=0 : drive is connected */
DECL|member|autoprobe
r_int
id|autoprobe
suffix:semicolon
multiline_comment|/* !=0 : do autoprobe       */
DECL|member|disktype
r_struct
id|archy_disk_type
op_star
id|disktype
suffix:semicolon
multiline_comment|/* current type of disk */
DECL|member|track
r_int
id|track
suffix:semicolon
multiline_comment|/* current head position or -1&n;&t;&t;&t;&t;   * if unknown */
DECL|member|steprate
r_int
r_int
id|steprate
suffix:semicolon
multiline_comment|/* steprate setting */
DECL|member|wpstat
r_int
r_int
id|wpstat
suffix:semicolon
multiline_comment|/* current state of WP signal&n;&t;&t;&t;&t;   * (for disk change detection) */
DECL|variable|unit
)brace
id|unit
(braket
id|FD_MAX_UNITS
)braket
suffix:semicolon
multiline_comment|/* DAG: On Arc we spin on a flag being cleared by fdc1772_comendhandler which&n;   is an assembler routine */
r_extern
r_void
id|fdc1772_comendhandler
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* Actually doens&squot;t have these parameters - see fd1772.S */
r_extern
r_volatile
r_int
id|fdc1772_comendstatus
suffix:semicolon
r_extern
r_volatile
r_int
id|fdc1772_fdc_int_done
suffix:semicolon
DECL|macro|FDC1772BASE
mdefine_line|#define FDC1772BASE ((0x210000&gt;&gt;2)|0x80000000)
DECL|macro|FDC1772_READ
mdefine_line|#define FDC1772_READ(reg) inb(FDC1772BASE+(reg/2))
multiline_comment|/* DAG: You wouldn&squot;t be silly to ask why FDC1772_WRITE is a function rather&n;   than the #def below - well simple - the #def won&squot;t compile - and I&n;   don&squot;t understand why (__outwc not defined) */
multiline_comment|/* NOTE: Reg is 0,2,4,6 as opposed to 0,1,2,3 or 0,4,8,12 to keep compatibility&n;   with the ST version of fd1772.h */
multiline_comment|/*#define FDC1772_WRITE(reg,val) outw(val,(reg+FDC1772BASE)); */
DECL|function|FDC1772_WRITE
r_void
id|FDC1772_WRITE
c_func
(paren
r_int
id|reg
comma
r_int
r_char
id|val
)paren
(brace
r_if
c_cond
(paren
id|reg
op_eq
id|FDC1772REG_CMD
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;FDC1772_WRITE new command 0x%x @ %d&bslash;n&quot;
comma
id|val
comma
id|jiffies
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc1772_fdc_int_done
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;FDC1772_WRITE: Hmm fdc1772_fdc_int_done true - resetting&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|fdc1772_fdc_int_done
op_assign
l_int|0
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
id|outb
c_func
(paren
id|val
comma
(paren
id|reg
op_div
l_int|2
)paren
op_plus
id|FDC1772BASE
)paren
suffix:semicolon
)brace
suffix:semicolon
DECL|macro|MAX_SECTORS
mdefine_line|#define&t;MAX_SECTORS&t;22
DECL|variable|DMABuffer
r_int
r_char
op_star
id|DMABuffer
suffix:semicolon
multiline_comment|/* buffer for writes */
multiline_comment|/*static unsigned long PhysDMABuffer; */
multiline_comment|/* physical address */
multiline_comment|/* DAG: On Arc we just go straight for the DMA buffer */
DECL|macro|PhysDMABuffer
mdefine_line|#define PhysDMABuffer DMABuffer
macro_line|#ifdef TRACKBUFFER   
DECL|variable|TrackBuffer
r_int
r_char
op_star
id|TrackBuffer
suffix:semicolon
multiline_comment|/* buffer for reads */
DECL|macro|PhysTrackBuffer
mdefine_line|#define PhysTrackBuffer TrackBuffer /* physical address */
DECL|variable|BufferDrive
DECL|variable|BufferSide
DECL|variable|BufferTrack
r_static
r_int
id|BufferDrive
comma
id|BufferSide
comma
id|BufferTrack
suffix:semicolon
DECL|variable|read_track
r_static
r_int
id|read_track
suffix:semicolon
multiline_comment|/* non-zero if we are reading whole tracks */
DECL|macro|SECTOR_BUFFER
mdefine_line|#define SECTOR_BUFFER(sec)  (TrackBuffer + ((sec)-1)*512)
DECL|macro|IS_BUFFERED
mdefine_line|#define IS_BUFFERED(drive,side,track) &bslash;&n;    (BufferDrive == (drive) &amp;&amp; BufferSide == (side) &amp;&amp; BufferTrack == (track))
macro_line|#endif
multiline_comment|/*&n; * These are global variables, as that&squot;s the easiest way to give&n; * information to interrupts. They are the data used for the current&n; * request.&n; */
DECL|variable|SelectedDrive
r_static
r_int
id|SelectedDrive
op_assign
l_int|0
suffix:semicolon
DECL|variable|ReqCmd
DECL|variable|ReqBlock
r_static
r_int
id|ReqCmd
comma
id|ReqBlock
suffix:semicolon
DECL|variable|ReqSide
DECL|variable|ReqTrack
DECL|variable|ReqSector
DECL|variable|ReqCnt
r_static
r_int
id|ReqSide
comma
id|ReqTrack
comma
id|ReqSector
comma
id|ReqCnt
suffix:semicolon
DECL|variable|HeadSettleFlag
r_static
r_int
id|HeadSettleFlag
op_assign
l_int|0
suffix:semicolon
DECL|variable|ReqData
DECL|variable|ReqBuffer
r_static
r_int
r_char
op_star
id|ReqData
comma
op_star
id|ReqBuffer
suffix:semicolon
DECL|variable|MotorOn
DECL|variable|MotorOffTrys
r_static
r_int
id|MotorOn
op_assign
l_int|0
comma
id|MotorOffTrys
suffix:semicolon
multiline_comment|/* Synchronization of FDC1772 access. */
DECL|variable|fdc_busy
r_static
r_volatile
r_int
id|fdc_busy
op_assign
l_int|0
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|fdc_wait
)paren
suffix:semicolon
DECL|variable|changed_floppies
DECL|variable|fake_change
r_static
r_int
r_int
id|changed_floppies
op_assign
l_int|0xff
comma
id|fake_change
op_assign
l_int|0
suffix:semicolon
DECL|macro|CHECK_CHANGE_DELAY
mdefine_line|#define&t;CHECK_CHANGE_DELAY&t;HZ/2
multiline_comment|/* DAG - increased to 30*HZ - not sure if this is the correct thing to do */
DECL|macro|FD_MOTOR_OFF_DELAY
mdefine_line|#define&t;FD_MOTOR_OFF_DELAY&t;(10*HZ)
DECL|macro|FD_MOTOR_OFF_MAXTRY
mdefine_line|#define&t;FD_MOTOR_OFF_MAXTRY&t;(10*20)
DECL|macro|FLOPPY_TIMEOUT
mdefine_line|#define FLOPPY_TIMEOUT&t;&t;(6*HZ)
DECL|macro|RECALIBRATE_ERRORS
mdefine_line|#define RECALIBRATE_ERRORS&t;4&t;/* After this many errors the drive&n;&t;&t;&t;&t;&t; * will be recalibrated. */
DECL|macro|MAX_ERRORS
mdefine_line|#define MAX_ERRORS&t;&t;&t;8&t;/* After this many errors the driver&n;&t;&t;&t;&t;&t;&t; * will give up. */
DECL|variable|fd_timer
r_static
r_struct
id|timer_list
id|fd_timer
suffix:semicolon
DECL|macro|START_MOTOR_OFF_TIMER
mdefine_line|#define&t;START_MOTOR_OFF_TIMER(delay)&t;&t;&t;&bslash;&n;    do {&t;&t;&t;&t;&t;&t;&bslash;&n;        motor_off_timer.expires = jiffies + (delay);&t;&t;&bslash;&n;        add_timer( &amp;motor_off_timer );&t;&t;&t;&bslash;&n;        MotorOffTrys = 0;&t;&t;&t;&t;&bslash;&n;&t;} while(0)
DECL|macro|START_CHECK_CHANGE_TIMER
mdefine_line|#define&t;START_CHECK_CHANGE_TIMER(delay)&t;&t;&t;&t;&bslash;&n;    do {&t;&t;&t;&t;&t;&t;&t;&bslash;&n;        mod_timer(&amp;fd_timer, jiffies + (delay));&t;&t;&bslash;&n;&t;} while(0)
DECL|macro|START_TIMEOUT
mdefine_line|#define&t;START_TIMEOUT()&t;&t;&t;&t;&t;     &bslash;&n;    do {&t;&t;&t;&t;&t;&t;     &bslash;&n;        mod_timer(&amp;timeout_timer, jiffies+FLOPPY_TIMEOUT); &bslash;&n;&t;} while(0)
DECL|macro|STOP_TIMEOUT
mdefine_line|#define&t;STOP_TIMEOUT()&t;&t;&t;&t;&t;&bslash;&n;    do {&t;&t;&t;&t;&t;&t;&bslash;&n;        del_timer( &amp;timeout_timer );&t;&t;&t;&bslash;&n;&t;} while(0)
DECL|macro|ENABLE_IRQ
mdefine_line|#define ENABLE_IRQ() enable_irq(FIQ_FD1772+64);
DECL|macro|DISABLE_IRQ
mdefine_line|#define DISABLE_IRQ() disable_irq(FIQ_FD1772+64);
r_static
r_void
id|fd1772_checkint
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|fd1772_tq
r_struct
id|tq_struct
id|fd1772_tq
op_assign
(brace
l_int|0
comma
l_int|0
comma
(paren
r_void
op_star
)paren
id|fd1772_checkint
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * The driver is trying to determine the correct media format&n; * while Probing is set. fd_rwsec_done() clears it after a&n; * successful access.&n; */
DECL|variable|Probing
r_static
r_int
id|Probing
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* This flag is set when a dummy seek is necesary to make the WP&n; * status bit accessible.&n; */
DECL|variable|NeedSeek
r_static
r_int
id|NeedSeek
op_assign
l_int|0
suffix:semicolon
multiline_comment|/***************************** Prototypes *****************************/
r_static
r_void
id|fd_select_side
c_func
(paren
r_int
id|side
)paren
suffix:semicolon
r_static
r_void
id|fd_select_drive
c_func
(paren
r_int
id|drive
)paren
suffix:semicolon
r_static
r_void
id|fd_deselect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|fd_motor_off_timer
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
r_static
r_void
id|check_change
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
r_static
id|__inline__
r_void
id|set_head_settle_flag
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
id|__inline__
r_int
id|get_head_settle_flag
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|floppy_irqconsequencehandler
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|fd_error
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_fd_action
c_func
(paren
r_int
id|drive
)paren
suffix:semicolon
r_static
r_void
id|fd_calibrate
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|fd_calibrate_done
c_func
(paren
r_int
id|status
)paren
suffix:semicolon
r_static
r_void
id|fd_seek
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|fd_seek_done
c_func
(paren
r_int
id|status
)paren
suffix:semicolon
r_static
r_void
id|fd_rwsec
c_func
(paren
r_void
)paren
suffix:semicolon
macro_line|#ifdef TRACKBUFFER   
r_static
r_void
id|fd_readtrack_check
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
macro_line|#endif
r_static
r_void
id|fd_rwsec_done
c_func
(paren
r_int
id|status
)paren
suffix:semicolon
r_static
r_void
id|fd_times_out
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
r_static
r_void
id|finish_fdc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|finish_fdc_done
c_func
(paren
r_int
id|dummy
)paren
suffix:semicolon
r_static
r_void
id|floppy_off
c_func
(paren
r_int
r_int
id|nr
)paren
suffix:semicolon
r_static
id|__inline__
r_void
id|copy_buffer
c_func
(paren
r_void
op_star
id|from
comma
r_void
op_star
id|to
)paren
suffix:semicolon
r_static
r_void
id|setup_req_params
c_func
(paren
r_int
id|drive
)paren
suffix:semicolon
r_static
r_void
id|redo_fd_request
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|fd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|param
)paren
suffix:semicolon
r_static
r_void
id|fd_probe
c_func
(paren
r_int
id|drive
)paren
suffix:semicolon
r_static
r_int
id|fd_test_drive_present
c_func
(paren
r_int
id|drive
)paren
suffix:semicolon
r_static
r_void
id|config_types
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|floppy_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
r_static
r_void
id|floppy_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
suffix:semicolon
multiline_comment|/************************* End of Prototypes **************************/
DECL|variable|motor_off_timer
r_static
r_struct
id|timer_list
id|motor_off_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|fd_motor_off_timer
)brace
suffix:semicolon
macro_line|#ifdef TRACKBUFFER
DECL|variable|readtrack_timer
r_static
r_struct
id|timer_list
id|readtrack_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|fd_readtrack_check
)brace
suffix:semicolon
macro_line|#endif
DECL|variable|timeout_timer
r_static
r_struct
id|timer_list
id|timeout_timer
op_assign
(brace
l_int|NULL
comma
l_int|NULL
comma
l_int|0
comma
l_int|0
comma
id|fd_times_out
)brace
suffix:semicolon
multiline_comment|/* DAG: Haven&squot;t got a clue what this is? */
DECL|function|stdma_islocked
r_int
id|stdma_islocked
c_func
(paren
r_void
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Select the side to use. */
DECL|function|fd_select_side
r_static
r_void
id|fd_select_side
c_func
(paren
r_int
id|side
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|oldlatch_aupdate
c_func
(paren
id|LATCHA_SIDESEL
comma
id|side
ques
c_cond
l_int|0
suffix:colon
id|LATCHA_SIDESEL
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* Select a drive, update the FDC1772&squot;s track register&n; */
DECL|function|fd_select_drive
r_static
r_void
id|fd_select_drive
c_func
(paren
r_int
id|drive
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
macro_line|#ifdef DEBUG
id|printk
c_func
(paren
l_string|&quot;fd_select_drive:%d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Hmm - nowhere do we seem to turn the motor on - I&squot;m going to do it here! */
id|oldlatch_aupdate
c_func
(paren
id|LATCHA_MOTOR
op_or
id|LATCHA_INUSE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
op_eq
id|SelectedDrive
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|oldlatch_aupdate
c_func
(paren
id|LATCHA_FDSELALL
comma
l_int|0xf
op_minus
(paren
l_int|1
op_lshift
id|drive
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* restore track register to saved value */
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_TRACK
comma
id|unit
(braket
id|drive
)braket
dot
id|track
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|SelectedDrive
op_assign
id|drive
suffix:semicolon
)brace
multiline_comment|/* Deselect both drives. */
DECL|function|fd_deselect
r_static
r_void
id|fd_deselect
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_deselect&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|oldlatch_aupdate
c_func
(paren
id|LATCHA_FDSELALL
op_or
id|LATCHA_MOTOR
op_or
id|LATCHA_INUSE
comma
l_int|0xf
op_or
id|LATCHA_MOTOR
op_or
id|LATCHA_INUSE
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|SelectedDrive
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* This timer function deselects the drives when the FDC1772 switched the&n; * motor off. The deselection cannot happen earlier because the FDC1772&n; * counts the index signals, which arrive only if one drive is selected.&n; */
DECL|function|fd_motor_off_timer
r_static
r_void
id|fd_motor_off_timer
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
id|delay
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|motor_off_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SelectedDrive
OL
l_int|0
)paren
multiline_comment|/* no drive selected, needn&squot;t deselect anyone */
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc_busy
)paren
multiline_comment|/* was stdma_islocked */
r_goto
id|retry
suffix:semicolon
id|status
op_assign
id|FDC1772_READ
c_func
(paren
id|FDC1772REG_STATUS
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
l_int|0x80
)paren
)paren
(brace
multiline_comment|/* motor already turned off by FDC1772 -&gt; deselect drives */
multiline_comment|/* In actual fact its this deselection which turns the motor off on the&n;        Arc, since the motor control is actually on Latch A */
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fdc1772: deselecting in fd_motor_off_timer&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|fd_deselect
c_func
(paren
)paren
suffix:semicolon
id|MotorOn
op_assign
l_int|0
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* not yet off, try again */
id|retry
suffix:colon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
multiline_comment|/* Test again later; if tested too often, it seems there is no disk&n;&t; * in the drive and the FDC1772 will leave the motor on forever (or,&n;&t; * at least until a disk is inserted). So we&squot;ll test only twice&n;&t; * per second from then on...&n;&t; */
id|delay
op_assign
(paren
id|MotorOffTrys
OL
id|FD_MOTOR_OFF_MAXTRY
)paren
ques
c_cond
(paren
op_increment
id|MotorOffTrys
comma
id|HZ
op_div
l_int|20
)paren
suffix:colon
id|HZ
op_div
l_int|2
suffix:semicolon
id|START_MOTOR_OFF_TIMER
c_func
(paren
id|delay
)paren
suffix:semicolon
)brace
multiline_comment|/* This function is repeatedly called to detect disk changes (as good&n; * as possible) and keep track of the current state of the write protection.&n; */
DECL|function|check_change
r_static
r_void
id|check_change
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_static
r_int
id|drive
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|fdc_busy
)paren
r_return
suffix:semicolon
multiline_comment|/* Don&squot;t start poking about if the fdc is busy */
r_return
suffix:semicolon
multiline_comment|/* let&squot;s just forget it for the mo DAG */
r_if
c_cond
(paren
op_increment
id|drive
OG
l_int|1
op_logical_or
op_logical_neg
id|unit
(braket
id|drive
)braket
dot
id|connected
)paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stdma_islocked
c_func
(paren
)paren
)paren
(brace
id|stat
op_assign
op_logical_neg
op_logical_neg
(paren
id|FDC1772_READ
c_func
(paren
id|FDC1772REG_STATUS
)paren
op_amp
id|FDC1772STAT_WPROT
)paren
suffix:semicolon
multiline_comment|/* The idea here is that if the write protect line has changed then&n;&t;&t;the disc must have changed */
r_if
c_cond
(paren
id|stat
op_ne
id|unit
(braket
id|drive
)braket
dot
id|wpstat
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;wpstat[%d] = %d&bslash;n&quot;
comma
id|drive
comma
id|stat
)paren
)paren
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|wpstat
op_assign
id|stat
suffix:semicolon
id|set_bit
c_func
(paren
id|drive
comma
op_amp
id|changed_floppies
)paren
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|START_CHECK_CHANGE_TIMER
c_func
(paren
id|CHECK_CHANGE_DELAY
)paren
suffix:semicolon
)brace
multiline_comment|/* Handling of the Head Settling Flag: This flag should be set after each&n; * seek operation, because we don&squot;t use seeks with verify.&n; */
DECL|function|set_head_settle_flag
r_static
id|__inline__
r_void
id|set_head_settle_flag
c_func
(paren
r_void
)paren
(brace
id|HeadSettleFlag
op_assign
id|FDC1772CMDADD_E
suffix:semicolon
)brace
DECL|function|get_head_settle_flag
r_static
id|__inline__
r_int
id|get_head_settle_flag
c_func
(paren
r_void
)paren
(brace
r_int
id|tmp
op_assign
id|HeadSettleFlag
suffix:semicolon
id|HeadSettleFlag
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|tmp
)paren
suffix:semicolon
)brace
multiline_comment|/* General Interrupt Handling */
DECL|variable|FloppyIRQHandler
r_static
r_void
(paren
op_star
id|FloppyIRQHandler
)paren
(paren
r_int
id|status
)paren
op_assign
l_int|NULL
suffix:semicolon
DECL|function|floppy_irqconsequencehandler
r_static
r_void
id|floppy_irqconsequencehandler
c_func
(paren
r_void
)paren
(brace
r_int
r_char
id|status
suffix:semicolon
r_void
(paren
op_star
id|handler
)paren
(paren
r_int
)paren
suffix:semicolon
id|fdc1772_fdc_int_done
op_assign
l_int|0
suffix:semicolon
id|handler
op_assign
id|FloppyIRQHandler
suffix:semicolon
id|FloppyIRQHandler
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|handler
)paren
(brace
id|nop
c_func
(paren
)paren
suffix:semicolon
id|status
op_assign
(paren
r_int
r_char
)paren
id|fdc1772_comendstatus
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;FDC1772 irq, status = %02x handler = %08lx&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|status
comma
(paren
r_int
r_int
)paren
id|handler
)paren
)paren
suffix:semicolon
id|handler
c_func
(paren
id|status
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;FDC1772 irq, no handler status=%02x&bslash;n&quot;
comma
id|fdc1772_comendstatus
)paren
)paren
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;FDC1772 irq: end of floppy_irq&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Error handling: If some error happened, retry some times, then&n; * recalibrate, then try again, and fail after MAX_ERRORS.&n; */
DECL|function|fd_error
r_static
r_void
id|fd_error
c_func
(paren
r_void
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;FDC1772: fd_error&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/*panic(&quot;fd1772: fd_error&quot;); */
multiline_comment|/* DAG tmp */
r_if
c_cond
(paren
id|QUEUE_EMPTY
)paren
r_return
suffix:semicolon
id|CURRENT-&gt;errors
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;errors
op_ge
id|MAX_ERRORS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd%d: too many errors.&bslash;n&quot;
comma
id|SelectedDrive
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|CURRENT-&gt;errors
op_eq
id|RECALIBRATE_ERRORS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd%d: recalibrating&bslash;n&quot;
comma
id|SelectedDrive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SelectedDrive
op_ne
op_minus
l_int|1
)paren
id|unit
(braket
id|SelectedDrive
)braket
dot
id|track
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|macro|SET_IRQ_HANDLER
mdefine_line|#define&t;SET_IRQ_HANDLER(proc) do { FloppyIRQHandler = (proc); } while(0)
multiline_comment|/* do_fd_action() is the general procedure for a fd request: All&n; * required parameter settings (drive select, side select, track&n; * position) are checked and set if needed. For each of these&n; * parameters and the actual reading or writing exist two functions:&n; * one that starts the setting (or skips it if possible) and one&n; * callback for the &quot;done&quot; interrupt. Each done func calls the next&n; * set function to propagate the request down to fd_rwsec_done().&n; */
DECL|function|do_fd_action
r_static
r_void
id|do_fd_action
c_func
(paren
r_int
id|drive
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;do_fd_action unit[drive].track=%d&bslash;n&quot;
comma
id|unit
(braket
id|drive
)braket
dot
id|track
)paren
)paren
suffix:semicolon
macro_line|#ifdef TRACKBUFFER
id|repeat
suffix:colon
r_if
c_cond
(paren
id|IS_BUFFERED
c_func
(paren
id|drive
comma
id|ReqSide
comma
id|ReqTrack
)paren
)paren
(brace
r_if
c_cond
(paren
id|ReqCmd
op_eq
id|READ
)paren
(brace
id|copy_buffer
c_func
(paren
id|SECTOR_BUFFER
c_func
(paren
id|ReqSector
)paren
comma
id|ReqData
)paren
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|ReqCnt
OL
id|CURRENT-&gt;current_nr_sectors
)paren
(brace
multiline_comment|/* read next sector */
id|setup_req_params
c_func
(paren
id|drive
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* all sectors finished */
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* cmd == WRITE, pay attention to track buffer&n;       * consistency! */
id|copy_buffer
c_func
(paren
id|ReqData
comma
id|SECTOR_BUFFER
c_func
(paren
id|ReqSector
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
r_if
c_cond
(paren
id|SelectedDrive
op_ne
id|drive
)paren
(brace
multiline_comment|/*unit[drive].track = -1; DAG */
id|fd_select_drive
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|track
op_eq
op_minus
l_int|1
)paren
id|fd_calibrate
c_func
(paren
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|track
op_ne
id|ReqTrack
op_lshift
id|unit
(braket
id|drive
)braket
dot
id|disktype-&gt;stretch
)paren
id|fd_seek
c_func
(paren
)paren
suffix:semicolon
r_else
id|fd_rwsec
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Seek to track 0 if the current track is unknown */
DECL|function|fd_calibrate
r_static
r_void
id|fd_calibrate
c_func
(paren
r_void
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_calibrate&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit
(braket
id|SelectedDrive
)braket
dot
id|track
op_ge
l_int|0
)paren
(brace
id|fd_calibrate_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_calibrate (after track compare)&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|SET_IRQ_HANDLER
c_func
(paren
id|fd_calibrate_done
)paren
suffix:semicolon
multiline_comment|/* we can&squot;t verify, since the speed may be incorrect */
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_CMD
comma
id|FDC1772CMD_RESTORE
op_or
id|unit
(braket
id|SelectedDrive
)braket
dot
id|steprate
)paren
suffix:semicolon
id|NeedSeek
op_assign
l_int|1
suffix:semicolon
id|MotorOn
op_assign
l_int|1
suffix:semicolon
id|START_TIMEOUT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for IRQ */
)brace
DECL|function|fd_calibrate_done
r_static
r_void
id|fd_calibrate_done
c_func
(paren
r_int
id|status
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_calibrate_done()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|STOP_TIMEOUT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set the correct speed now */
r_if
c_cond
(paren
id|status
op_amp
id|FDC1772STAT_RECNF
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd%d: restore failed&bslash;n&quot;
comma
id|SelectedDrive
)paren
suffix:semicolon
id|fd_error
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|unit
(braket
id|SelectedDrive
)braket
dot
id|track
op_assign
l_int|0
suffix:semicolon
id|fd_seek
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Seek the drive to the requested track. The drive must have been&n; * calibrated at some point before this.&n; */
DECL|function|fd_seek
r_static
r_void
id|fd_seek
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_seek() to track %d (unit[SelectedDrive].track=%d)&bslash;n&quot;
comma
id|ReqTrack
comma
id|unit
(braket
id|SelectedDrive
)braket
dot
id|track
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit
(braket
id|SelectedDrive
)braket
dot
id|track
op_eq
id|ReqTrack
op_lshift
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype-&gt;stretch
)paren
(brace
id|fd_seek_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_DATA
comma
id|ReqTrack
op_lshift
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype-&gt;stretch
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cliIF
c_func
(paren
)paren
suffix:semicolon
id|SET_IRQ_HANDLER
c_func
(paren
id|fd_seek_done
)paren
suffix:semicolon
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_CMD
comma
id|FDC1772CMD_SEEK
op_or
id|unit
(braket
id|SelectedDrive
)braket
dot
id|steprate
op_or
multiline_comment|/* DAG */
(paren
id|MotorOn
ques
c_cond
id|FDC1772CMDADD_H
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|MotorOn
op_assign
l_int|1
suffix:semicolon
id|set_head_settle_flag
c_func
(paren
)paren
suffix:semicolon
id|START_TIMEOUT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* wait for IRQ */
)brace
DECL|function|fd_seek_done
r_static
r_void
id|fd_seek_done
c_func
(paren
r_int
id|status
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_seek_done()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|STOP_TIMEOUT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* set the correct speed */
r_if
c_cond
(paren
id|status
op_amp
id|FDC1772STAT_RECNF
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd%d: seek error (to track %d)&bslash;n&quot;
comma
id|SelectedDrive
comma
id|ReqTrack
)paren
suffix:semicolon
multiline_comment|/* we don&squot;t know exactly which track we are on now! */
id|unit
(braket
id|SelectedDrive
)braket
dot
id|track
op_assign
op_minus
l_int|1
suffix:semicolon
id|fd_error
c_func
(paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|unit
(braket
id|SelectedDrive
)braket
dot
id|track
op_assign
id|ReqTrack
op_lshift
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype-&gt;stretch
suffix:semicolon
id|NeedSeek
op_assign
l_int|0
suffix:semicolon
id|fd_rwsec
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This does the actual reading/writing after positioning the head&n; * over the correct track.&n; */
macro_line|#ifdef TRACKBUFFER
DECL|variable|MultReadInProgress
r_static
r_int
id|MultReadInProgress
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
DECL|function|fd_rwsec
r_static
r_void
id|fd_rwsec
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|paddr
comma
id|flags
suffix:semicolon
r_int
r_int
id|rwflag
comma
id|old_motoron
suffix:semicolon
r_int
r_int
id|track
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_rwsec(), Sec=%d, Access=%c&bslash;n&quot;
comma
id|ReqSector
comma
id|ReqCmd
op_eq
id|WRITE
ques
c_cond
l_char|&squot;w&squot;
suffix:colon
l_char|&squot;r&squot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReqCmd
op_eq
id|WRITE
)paren
(brace
multiline_comment|/*cache_push( (unsigned long)ReqData, 512 ); */
id|paddr
op_assign
(paren
r_int
r_int
)paren
id|ReqData
suffix:semicolon
id|rwflag
op_assign
l_int|0x100
suffix:semicolon
)brace
r_else
(brace
macro_line|#ifdef TRACKBUFFER
r_if
c_cond
(paren
id|read_track
)paren
id|paddr
op_assign
(paren
r_int
r_int
)paren
id|PhysTrackBuffer
suffix:semicolon
r_else
id|paddr
op_assign
(paren
r_int
r_int
)paren
id|PhysDMABuffer
suffix:semicolon
macro_line|#else
id|paddr
op_assign
(paren
r_int
r_int
)paren
id|PhysDMABuffer
suffix:semicolon
macro_line|#endif
id|rwflag
op_assign
l_int|0
suffix:semicolon
)brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_rwsec() before sidesel rwflag=%d sec=%d trk=%d&bslash;n&quot;
comma
id|rwflag
comma
id|ReqSector
comma
id|FDC1772_READ
c_func
(paren
id|FDC1772REG_TRACK
)paren
)paren
)paren
suffix:semicolon
id|fd_select_side
c_func
(paren
id|ReqSide
)paren
suffix:semicolon
multiline_comment|/*DPRINT((&quot;fd_rwsec() before start sector &bslash;n&quot;)); */
multiline_comment|/* Start sector of this operation */
macro_line|#ifdef TRACKBUFFER
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_SECTOR
comma
op_logical_neg
id|read_track
ques
c_cond
id|ReqSector
suffix:colon
l_int|1
)paren
suffix:semicolon
macro_line|#else
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_SECTOR
comma
id|ReqSector
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Cheat for track if stretch != 0 */
r_if
c_cond
(paren
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype-&gt;stretch
)paren
(brace
id|track
op_assign
id|FDC1772_READ
c_func
(paren
id|FDC1772REG_TRACK
)paren
suffix:semicolon
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_TRACK
comma
id|track
op_rshift
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype-&gt;stretch
)paren
suffix:semicolon
)brace
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_rwsec() before setup DMA &bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Setup DMA - Heavily modified by DAG */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cliIF
c_func
(paren
)paren
suffix:semicolon
id|disable_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
id|set_dma_mode
c_func
(paren
id|FLOPPY_DMA
comma
id|rwflag
ques
c_cond
id|DMA_MODE_WRITE
suffix:colon
id|DMA_MODE_READ
)paren
suffix:semicolon
id|set_dma_addr
c_func
(paren
id|FLOPPY_DMA
comma
(paren
r_int
)paren
id|paddr
)paren
suffix:semicolon
multiline_comment|/* DAG - changed from Atari specific */
macro_line|#ifdef TRACKBUFFER
id|set_dma_count
c_func
(paren
id|FLOPPY_DMA
comma
(paren
op_logical_neg
id|read_track
ques
c_cond
l_int|1
suffix:colon
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype-&gt;spt
)paren
op_star
l_int|512
)paren
suffix:semicolon
macro_line|#else
id|set_dma_count
c_func
(paren
id|FLOPPY_DMA
comma
l_int|512
)paren
suffix:semicolon
multiline_comment|/* Block/sector size - going to have to change */
macro_line|#endif
id|SET_IRQ_HANDLER
c_func
(paren
id|fd_rwsec_done
)paren
suffix:semicolon
multiline_comment|/* Turn on dma int */
id|enable_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
multiline_comment|/* Now give it something to do */
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_CMD
comma
(paren
id|rwflag
ques
c_cond
(paren
id|FDC1772CMD_WRSEC
op_or
id|FDC1772CMDADD_P
)paren
suffix:colon
macro_line|#ifdef TRACKBUFFER
(paren
id|FDC1772CMD_RDSEC
op_or
(paren
id|read_track
ques
c_cond
id|FDC1772CMDADD_M
suffix:colon
l_int|0
)paren
op_or
multiline_comment|/* Hmm - the idea here is to stop the FDC spinning the disc&n;&t;      up when we know that we already still have it spinning */
(paren
id|MotorOn
ques
c_cond
id|FDC1772CMDADD_H
suffix:colon
l_int|0
)paren
)paren
macro_line|#else
id|FDC1772CMD_RDSEC
macro_line|#endif
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_rwsec() after DMA setup flags=0x%08x&bslash;n&quot;
comma
id|flags
)paren
)paren
suffix:semicolon
multiline_comment|/*sti(); */
multiline_comment|/* DAG - Hmm */
multiline_comment|/* Hmm - should do something DAG */
id|old_motoron
op_assign
id|MotorOn
suffix:semicolon
id|MotorOn
op_assign
l_int|1
suffix:semicolon
id|NeedSeek
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* wait for interrupt */
macro_line|#ifdef TRACKBUFFER
r_if
c_cond
(paren
id|read_track
)paren
(brace
multiline_comment|/* If reading a whole track, wait about one disk rotation and&n;     * then check if all sectors are read. The FDC will even&n;     * search for the first non-existant sector and need 1 sec to&n;     * recognise that it isn&squot;t present :-(&n;     */
id|del_timer
c_func
(paren
op_amp
id|readtrack_timer
)paren
suffix:semicolon
id|readtrack_timer.function
op_assign
id|fd_readtrack_check
suffix:semicolon
id|readtrack_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|5
op_plus
(paren
id|old_motoron
ques
c_cond
l_int|0
suffix:colon
id|HZ
)paren
suffix:semicolon
multiline_comment|/* 1 rot. + 5 rot.s if motor was off  */
id|DPRINT
c_func
(paren
(paren
l_string|&quot;Setting readtrack_timer to %d @ %d&bslash;n&quot;
comma
id|readtrack_timer.expires
comma
id|jiffies
)paren
)paren
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|readtrack_timer
)paren
suffix:semicolon
id|MultReadInProgress
op_assign
l_int|1
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*DPRINT((&quot;fd_rwsec() before START_TIMEOUT &bslash;n&quot;)); */
id|START_TIMEOUT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*DPRINT((&quot;fd_rwsec() after START_TIMEOUT &bslash;n&quot;)); */
)brace
macro_line|#ifdef TRACKBUFFER
DECL|function|fd_readtrack_check
r_static
r_void
id|fd_readtrack_check
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
r_int
id|flags
comma
id|addr
suffix:semicolon
r_extern
r_int
r_char
op_star
id|fdc1772_dataaddr
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_readtrack_check @ %d&bslash;n&quot;
comma
id|jiffies
)paren
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cliIF
c_func
(paren
)paren
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|readtrack_timer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|MultReadInProgress
)paren
(brace
multiline_comment|/* This prevents a race condition that could arise if the&n;     * interrupt is triggered while the calling of this timer&n;     * callback function takes place. The IRQ function then has&n;     * already cleared &squot;MultReadInProgress&squot;  when control flow&n;     * gets here.&n;     */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* get the current DMA address */
id|addr
op_assign
id|fdc1772_dataaddr
suffix:semicolon
multiline_comment|/* DAG - ? */
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_readtrack_check: addr=%x PhysTrackBuffer=%x&bslash;n&quot;
comma
id|addr
comma
id|PhysTrackBuffer
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|addr
op_ge
id|PhysTrackBuffer
op_plus
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype-&gt;spt
op_star
l_int|512
)paren
(brace
multiline_comment|/* already read enough data, force an FDC interrupt to stop&n;     * the read operation&n;     */
id|SET_IRQ_HANDLER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_readtrack_check(): done&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_CMD
comma
id|FDC1772CMD_FORCI
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
multiline_comment|/* No error until now -- the FDC would have interrupted&n;     * otherwise!&n;     */
id|fd_rwsec_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* not yet finished, wait another tenth rotation */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_readtrack_check(): not yet finished&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|readtrack_timer.expires
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|5
op_div
l_int|10
suffix:semicolon
id|add_timer
c_func
(paren
op_amp
id|readtrack_timer
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
DECL|function|fd_rwsec_done
r_static
r_void
id|fd_rwsec_done
c_func
(paren
r_int
id|status
)paren
(brace
r_int
r_int
id|track
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;fd_rwsec_done() status=%d @ %d&bslash;n&quot;
comma
id|status
comma
id|jiffies
)paren
)paren
suffix:semicolon
macro_line|#ifdef TRACKBUFFER
r_if
c_cond
(paren
id|read_track
op_logical_and
op_logical_neg
id|MultReadInProgress
)paren
r_return
suffix:semicolon
id|MultReadInProgress
op_assign
l_int|0
suffix:semicolon
id|STOP_TIMEOUT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_track
)paren
id|del_timer
c_func
(paren
op_amp
id|readtrack_timer
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Correct the track if stretch != 0 */
r_if
c_cond
(paren
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype-&gt;stretch
)paren
(brace
id|track
op_assign
id|FDC1772_READ
c_func
(paren
id|FDC1772REG_TRACK
)paren
suffix:semicolon
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_TRACK
comma
id|track
op_lshift
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype-&gt;stretch
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ReqCmd
op_eq
id|WRITE
op_logical_and
(paren
id|status
op_amp
id|FDC1772STAT_WPROT
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd%d: is write protected&bslash;n&quot;
comma
id|SelectedDrive
)paren
suffix:semicolon
r_goto
id|err_end
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|status
op_amp
id|FDC1772STAT_RECNF
)paren
macro_line|#ifdef TRACKBUFFER
multiline_comment|/* RECNF is no error after a multiple read when the FDC&n;     * searched for a non-existant sector!&n;     */
op_logical_and
op_logical_neg
(paren
id|read_track
op_logical_and
id|FDC1772_READ
c_func
(paren
id|FDC1772REG_SECTOR
)paren
OG
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype-&gt;spt
)paren
macro_line|#endif
)paren
(brace
r_if
c_cond
(paren
id|Probing
)paren
(brace
r_if
c_cond
(paren
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype
OG
id|disk_type
)paren
(brace
multiline_comment|/* try another disk type */
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype
op_decrement
suffix:semicolon
id|floppy_sizes
(braket
id|SelectedDrive
)braket
op_assign
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype-&gt;blocks
op_rshift
l_int|1
suffix:semicolon
)brace
r_else
id|Probing
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* record not found, but not probing. Maybe stretch wrong ? Restart probing */
r_if
c_cond
(paren
id|unit
(braket
id|SelectedDrive
)braket
dot
id|autoprobe
)paren
(brace
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype
op_assign
id|disk_type
op_plus
id|NUM_DISK_TYPES
op_minus
l_int|1
suffix:semicolon
id|floppy_sizes
(braket
id|SelectedDrive
)braket
op_assign
id|unit
(braket
id|SelectedDrive
)braket
dot
id|disktype-&gt;blocks
op_rshift
l_int|1
suffix:semicolon
id|Probing
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|Probing
)paren
(brace
id|setup_req_params
c_func
(paren
id|SelectedDrive
)paren
suffix:semicolon
macro_line|#ifdef TRACKBUFFER
id|BufferDrive
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
id|do_fd_action
c_func
(paren
id|SelectedDrive
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;fd%d: sector %d not found (side %d, track %d)&bslash;n&quot;
comma
id|SelectedDrive
comma
id|FDC1772_READ
c_func
(paren
id|FDC1772REG_SECTOR
)paren
comma
id|ReqSide
comma
id|ReqTrack
)paren
suffix:semicolon
r_goto
id|err_end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|FDC1772STAT_CRC
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd%d: CRC error (side %d, track %d, sector %d)&bslash;n&quot;
comma
id|SelectedDrive
comma
id|ReqSide
comma
id|ReqTrack
comma
id|FDC1772_READ
c_func
(paren
id|FDC1772REG_SECTOR
)paren
)paren
suffix:semicolon
r_goto
id|err_end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_amp
id|FDC1772STAT_LOST
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd%d: lost data (side %d, track %d, sector %d)&bslash;n&quot;
comma
id|SelectedDrive
comma
id|ReqSide
comma
id|ReqTrack
comma
id|FDC1772_READ
c_func
(paren
id|FDC1772REG_SECTOR
)paren
)paren
suffix:semicolon
r_goto
id|err_end
suffix:semicolon
)brace
id|Probing
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ReqCmd
op_eq
id|READ
)paren
(brace
macro_line|#ifdef TRACKBUFFER
r_if
c_cond
(paren
op_logical_neg
id|read_track
)paren
(brace
multiline_comment|/*cache_clear (PhysDMABuffer, 512);*/
id|copy_buffer
(paren
id|DMABuffer
comma
id|ReqData
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*cache_clear (PhysTrackBuffer, MAX_SECTORS * 512);*/
id|BufferDrive
op_assign
id|SelectedDrive
suffix:semicolon
id|BufferSide
op_assign
id|ReqSide
suffix:semicolon
id|BufferTrack
op_assign
id|ReqTrack
suffix:semicolon
id|copy_buffer
(paren
id|SECTOR_BUFFER
(paren
id|ReqSector
)paren
comma
id|ReqData
)paren
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*cache_clear( PhysDMABuffer, 512 ); */
id|copy_buffer
c_func
(paren
id|DMABuffer
comma
id|ReqData
)paren
suffix:semicolon
macro_line|#endif
)brace
r_if
c_cond
(paren
op_increment
id|ReqCnt
OL
id|CURRENT-&gt;current_nr_sectors
)paren
(brace
multiline_comment|/* read next sector */
id|setup_req_params
c_func
(paren
id|SelectedDrive
)paren
suffix:semicolon
id|do_fd_action
c_func
(paren
id|SelectedDrive
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* all sectors finished */
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|CURRENT-&gt;sector
op_add_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
suffix:semicolon
id|err_end
suffix:colon
macro_line|#ifdef TRACKBUFFER
id|BufferDrive
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
id|fd_error
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fd_times_out
r_static
r_void
id|fd_times_out
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
id|SET_IRQ_HANDLER
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* If the timeout occurred while the readtrack_check timer was&n;&t; * active, we need to cancel it, else bad things will happen */
id|del_timer
c_func
(paren
op_amp
id|readtrack_timer
)paren
suffix:semicolon
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_CMD
comma
id|FDC1772CMD_FORCI
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|25
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;floppy timeout&bslash;n&quot;
)paren
suffix:semicolon
id|STOP_TIMEOUT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* hmm - should we do this ? */
id|fd_error
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* The (noop) seek operation here is needed to make the WP bit in the&n; * FDC1772 status register accessible for check_change. If the last disk&n; * operation would have been a RDSEC, this bit would always read as 0&n; * no matter what :-( To save time, the seek goes to the track we&squot;re&n; * already on.&n; */
DECL|function|finish_fdc
r_static
r_void
id|finish_fdc
c_func
(paren
r_void
)paren
(brace
multiline_comment|/* DAG - just try without this dummy seek! */
id|finish_fdc_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|NeedSeek
)paren
(brace
id|finish_fdc_done
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
r_else
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;finish_fdc: dummy seek started&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_DATA
comma
id|unit
(braket
id|SelectedDrive
)braket
dot
id|track
)paren
suffix:semicolon
id|SET_IRQ_HANDLER
c_func
(paren
id|finish_fdc_done
)paren
suffix:semicolon
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_CMD
comma
id|FDC1772CMD_SEEK
)paren
suffix:semicolon
id|MotorOn
op_assign
l_int|1
suffix:semicolon
id|START_TIMEOUT
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* we must wait for the IRQ here, because the ST-DMA is&n;&t;&t; * released immediatly afterwards and the interrupt may be&n;&t;&t; * delivered to the wrong driver.&n;&t;&t; */
)brace
)brace
DECL|function|finish_fdc_done
r_static
r_void
id|finish_fdc_done
c_func
(paren
r_int
id|dummy
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;finish_fdc_done entered&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|STOP_TIMEOUT
c_func
(paren
)paren
suffix:semicolon
id|NeedSeek
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|timer_pending
c_func
(paren
op_amp
id|fd_timer
)paren
op_logical_and
id|time_after
c_func
(paren
id|jiffies
op_plus
l_int|5
comma
id|fd_timer.expires
)paren
)paren
multiline_comment|/* If the check for a disk change is done too early after this&n;&t;&t; * last seek command, the WP bit still reads wrong :-((&n;&t;&t; */
id|mod_timer
c_func
(paren
op_amp
id|fd_timer
comma
id|jiffies
op_plus
l_int|5
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/*      START_CHECK_CHANGE_TIMER( CHECK_CHANGE_DELAY ); */
)brace
suffix:semicolon
id|del_timer
c_func
(paren
op_amp
id|motor_off_timer
)paren
suffix:semicolon
id|START_MOTOR_OFF_TIMER
c_func
(paren
id|FD_MOTOR_OFF_DELAY
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* stdma_release(); - not sure if I should do something DAG  */
id|fdc_busy
op_assign
l_int|0
suffix:semicolon
id|wake_up
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;finish_fdc() finished&bslash;n&quot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Prevent &quot;aliased&quot; accesses. */
DECL|variable|fd_ref
r_static
id|fd_ref
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|fd_device
r_static
id|fd_device
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
multiline_comment|/*&n; * Current device number. Taken either from the block header or from the&n; * format request descriptor.&n; */
DECL|macro|CURRENT_DEVICE
mdefine_line|#define CURRENT_DEVICE (CURRENT-&gt;rq_dev)
multiline_comment|/* Current error count. */
DECL|macro|CURRENT_ERRORS
mdefine_line|#define CURRENT_ERRORS (CURRENT-&gt;errors)
multiline_comment|/* dummy for blk.h */
DECL|function|floppy_off
r_static
r_void
id|floppy_off
c_func
(paren
r_int
r_int
id|nr
)paren
(brace
)brace
multiline_comment|/* On the old arcs write protect depends on the particular model&n;   of machine.  On the A310, R140, and A440 there is a disc changed&n;   detect, however on the A4x0/1 range there is not.  There&n;   is nothing to tell you which machine your on.&n;   At the moment I&squot;m just marking changed always. I&squot;ve&n;   left the Atari&squot;s &squot;change on write protect change&squot; code in this&n;   part (but nothing sets it).&n;   RiscOS apparently checks the disc serial number etc. to detect changes&n;   - but if it sees a disc change line go high (?) it flips to using&n;   it. Well  maybe I&squot;ll add that in the future (!?)&n;*/
DECL|function|check_floppy_change
r_static
r_int
id|check_floppy_change
c_func
(paren
id|dev_t
id|dev
)paren
(brace
r_int
r_int
id|drive
op_assign
(paren
id|dev
op_amp
l_int|0x03
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|dev
)paren
op_ne
id|MAJOR_NR
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;floppy_changed: not a floppy&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
)paren
(brace
multiline_comment|/* simulated change (e.g. after formatting) */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|drive
comma
op_amp
id|changed_floppies
)paren
)paren
(brace
multiline_comment|/* surely changed (the WP signal changed at least once) */
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|wpstat
)paren
(brace
multiline_comment|/* WP is on -&gt; could be changed: to be sure, buffers should be&n;&t;&t;   * invalidated...&n;&t;&t; */
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* DAG - was 0 */
)brace
DECL|function|floppy_revalidate
r_static
r_int
id|floppy_revalidate
c_func
(paren
id|dev_t
id|dev
)paren
(brace
r_int
id|drive
op_assign
id|dev
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|test_bit
c_func
(paren
id|drive
comma
op_amp
id|changed_floppies
)paren
op_logical_or
id|test_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
op_logical_or
id|unit
(braket
id|drive
)braket
dot
id|disktype
op_eq
l_int|0
)paren
(brace
macro_line|#ifdef TRACKBUFFER
id|BufferDrive
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
id|clear_bit
c_func
(paren
id|drive
comma
op_amp
id|fake_change
)paren
suffix:semicolon
id|clear_bit
c_func
(paren
id|drive
comma
op_amp
id|changed_floppies
)paren
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|disktype
op_assign
l_int|0
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|copy_buffer
r_static
id|__inline__
r_void
id|copy_buffer
c_func
(paren
r_void
op_star
id|from
comma
r_void
op_star
id|to
)paren
(brace
id|ulong
op_star
id|p1
op_assign
(paren
id|ulong
op_star
)paren
id|from
comma
op_star
id|p2
op_assign
(paren
id|ulong
op_star
)paren
id|to
suffix:semicolon
r_int
id|cnt
suffix:semicolon
r_for
c_loop
(paren
id|cnt
op_assign
l_int|512
op_div
l_int|4
suffix:semicolon
id|cnt
suffix:semicolon
id|cnt
op_decrement
)paren
op_star
id|p2
op_increment
op_assign
op_star
id|p1
op_increment
suffix:semicolon
)brace
multiline_comment|/* This sets up the global variables describing the current request. */
DECL|function|setup_req_params
r_static
r_void
id|setup_req_params
c_func
(paren
r_int
id|drive
)paren
(brace
r_int
id|block
op_assign
id|ReqBlock
op_plus
id|ReqCnt
suffix:semicolon
id|ReqTrack
op_assign
id|block
op_div
id|unit
(braket
id|drive
)braket
dot
id|disktype-&gt;spt
suffix:semicolon
id|ReqSector
op_assign
id|block
op_minus
id|ReqTrack
op_star
id|unit
(braket
id|drive
)braket
dot
id|disktype-&gt;spt
op_plus
l_int|1
suffix:semicolon
id|ReqSide
op_assign
id|ReqTrack
op_amp
l_int|1
suffix:semicolon
id|ReqTrack
op_rshift_assign
l_int|1
suffix:semicolon
id|ReqData
op_assign
id|ReqBuffer
op_plus
l_int|512
op_star
id|ReqCnt
suffix:semicolon
macro_line|#ifdef TRACKBUFFER
id|read_track
op_assign
(paren
id|ReqCmd
op_eq
id|READ
op_logical_and
id|CURRENT_ERRORS
op_eq
l_int|0
)paren
suffix:semicolon
macro_line|#endif
id|DPRINT
c_func
(paren
(paren
l_string|&quot;Request params: Si=%d Tr=%d Se=%d Data=%08lx&bslash;n&quot;
comma
id|ReqSide
comma
id|ReqTrack
comma
id|ReqSector
comma
(paren
r_int
r_int
)paren
id|ReqData
)paren
)paren
suffix:semicolon
)brace
DECL|function|redo_fd_request
r_static
r_void
id|redo_fd_request
c_func
(paren
r_void
)paren
(brace
r_int
id|device
comma
id|drive
comma
id|type
suffix:semicolon
r_struct
id|archy_floppy_struct
op_star
id|floppy
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;redo_fd_request: CURRENT=%08lx CURRENT-&gt;rq_dev=%04x CURRENT-&gt;sector=%ld&bslash;n&quot;
comma
(paren
r_int
r_int
)paren
id|CURRENT
comma
id|CURRENT
ques
c_cond
id|CURRENT-&gt;rq_dev
suffix:colon
l_int|0
comma
op_logical_neg
id|QUEUE_EMPTY
ques
c_cond
id|CURRENT-&gt;sector
suffix:colon
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|QUEUE_EMPTY
op_logical_and
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
r_goto
id|the_end
suffix:semicolon
id|repeat
suffix:colon
r_if
c_cond
(paren
id|QUEUE_EMPTY
)paren
r_goto
id|the_end
suffix:semicolon
r_if
c_cond
(paren
id|MAJOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
op_ne
id|MAJOR_NR
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: request list destroyed&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|CURRENT-&gt;bh
)paren
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
)brace
id|device
op_assign
id|MINOR
c_func
(paren
id|CURRENT_DEVICE
)paren
suffix:semicolon
id|drive
op_assign
id|device
op_amp
l_int|3
suffix:semicolon
id|type
op_assign
id|device
op_rshift
l_int|2
suffix:semicolon
id|floppy
op_assign
op_amp
id|unit
(braket
id|drive
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|floppy-&gt;connected
)paren
(brace
multiline_comment|/* drive not connected */
id|printk
c_func
(paren
l_string|&quot;Unknown Device: fd%d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_if
c_cond
(paren
id|type
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|floppy-&gt;disktype
)paren
(brace
id|Probing
op_assign
l_int|1
suffix:semicolon
id|floppy-&gt;disktype
op_assign
id|disk_type
op_plus
id|NUM_DISK_TYPES
op_minus
l_int|1
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|floppy-&gt;disktype-&gt;blocks
op_rshift
l_int|1
suffix:semicolon
id|floppy-&gt;autoprobe
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* user supplied disk type */
op_decrement
id|type
suffix:semicolon
r_if
c_cond
(paren
id|type
op_ge
id|NUM_DISK_TYPES
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd%d: invalid disk format&quot;
comma
id|drive
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|floppy-&gt;disktype
op_assign
op_amp
id|disk_type
(braket
id|type
)braket
suffix:semicolon
id|floppy_sizes
(braket
id|drive
)braket
op_assign
id|disk_type
(braket
id|type
)braket
dot
id|blocks
op_rshift
l_int|1
suffix:semicolon
id|floppy-&gt;autoprobe
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT-&gt;sector
op_plus
l_int|1
OG
id|floppy-&gt;disktype-&gt;blocks
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
multiline_comment|/* stop deselect timer */
id|del_timer
c_func
(paren
op_amp
id|motor_off_timer
)paren
suffix:semicolon
id|ReqCnt
op_assign
l_int|0
suffix:semicolon
id|ReqCmd
op_assign
id|CURRENT-&gt;cmd
suffix:semicolon
id|ReqBlock
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|ReqBuffer
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|setup_req_params
c_func
(paren
id|drive
)paren
suffix:semicolon
id|do_fd_action
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
suffix:semicolon
id|the_end
suffix:colon
id|finish_fdc
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|fd1772_checkint
r_static
r_void
id|fd1772_checkint
c_func
(paren
r_void
)paren
(brace
r_extern
r_int
id|fdc1772_bytestogo
suffix:semicolon
multiline_comment|/*printk(&quot;fd1772_checkint %d&bslash;n&quot;,fdc1772_fdc_int_done);*/
r_if
c_cond
(paren
id|fdc1772_fdc_int_done
)paren
id|floppy_irqconsequencehandler
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|MultReadInProgress
)paren
op_logical_and
(paren
id|fdc1772_bytestogo
op_eq
l_int|0
)paren
)paren
id|fd_readtrack_check
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc_busy
)paren
(brace
id|queue_task
c_func
(paren
op_amp
id|fd1772_tq
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
suffix:semicolon
)brace
suffix:semicolon
DECL|function|do_fd_request
r_void
id|do_fd_request
c_func
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|DPRINT
c_func
(paren
(paren
l_string|&quot;do_fd_request for pid %d&bslash;n&quot;
comma
id|current-&gt;pid
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fdc_busy
)paren
r_return
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_while
c_loop
(paren
id|fdc_busy
)paren
id|sleep_on
c_func
(paren
op_amp
id|fdc_wait
)paren
suffix:semicolon
id|fdc_busy
op_assign
l_int|1
suffix:semicolon
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|fdc1772_fdc_int_done
op_assign
l_int|0
suffix:semicolon
id|redo_fd_request
c_func
(paren
)paren
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|fd1772_tq
comma
op_amp
id|tq_immediate
)paren
suffix:semicolon
id|mark_bh
c_func
(paren
id|IMMEDIATE_BH
)paren
suffix:semicolon
)brace
DECL|function|invalidate_drive
r_static
r_int
id|invalidate_drive
c_func
(paren
r_int
id|rdev
)paren
(brace
multiline_comment|/* invalidate the buffer track to force a reread */
macro_line|#ifdef TRACKBUFFER
id|BufferDrive
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
id|set_bit
c_func
(paren
id|rdev
op_amp
l_int|3
comma
op_amp
id|fake_change
)paren
suffix:semicolon
id|check_disk_change
c_func
(paren
id|rdev
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|fd_ioctl
r_static
r_int
id|fd_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|param
)paren
(brace
r_int
id|drive
comma
id|device
suffix:semicolon
id|device
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
id|RO_IOCTLS
c_func
(paren
id|inode-&gt;i_rdev
comma
id|param
)paren
suffix:semicolon
)brace
id|drive
op_assign
id|MINOR
c_func
(paren
id|device
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|FDFMTBEG
suffix:colon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* case FDC1772LRPRM:  ??? DAG what does this do?? &n;&t;&t;   unit[drive].disktype = NULL;&n;&t;&t;   floppy_sizes[drive] = MAX_DISK_SIZE;&n;&t;&t;   return invalidate_drive (device); */
r_case
id|FDFMTEND
suffix:colon
r_case
id|FDFLUSH
suffix:colon
r_return
id|invalidate_drive
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EPERM
suffix:semicolon
r_if
c_cond
(paren
id|drive
template_param
l_int|3
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Initialize the &squot;unit&squot; variable for drive &squot;drive&squot; */
DECL|function|fd_probe
r_static
r_void
id|fd_probe
c_func
(paren
r_int
id|drive
)paren
(brace
id|unit
(braket
id|drive
)braket
dot
id|connected
op_assign
l_int|0
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|disktype
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|fd_test_drive_present
c_func
(paren
id|drive
)paren
)paren
r_return
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|connected
op_assign
l_int|1
suffix:semicolon
id|unit
(braket
id|drive
)braket
dot
id|track
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* If we put the auto detect back in this can go to 0 */
id|unit
(braket
id|drive
)braket
dot
id|steprate
op_assign
id|FDC1772STEP_6
suffix:semicolon
id|MotorOn
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* from probe restore operation! */
)brace
multiline_comment|/* This function tests the physical presence of a floppy drive (not&n; * whether a disk is inserted). This is done by issuing a restore&n; * command, waiting max. 2 seconds (that should be enough to move the&n; * head across the whole disk) and looking at the state of the &quot;TR00&quot;&n; * signal. This should now be raised if there is a drive connected&n; * (and there is no hardware failure :-) Otherwise, the drive is&n; * declared absent.&n; */
DECL|function|fd_test_drive_present
r_static
r_int
id|fd_test_drive_present
c_func
(paren
r_int
id|drive
)paren
(brace
r_int
r_int
id|timeout
suffix:semicolon
r_int
r_char
id|status
suffix:semicolon
r_int
id|ok
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fd_test_drive_present %d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive
OG
l_int|1
)paren
r_return
(paren
l_int|0
)paren
suffix:semicolon
r_return
(paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Simple hack for the moment - the autodetect doesn&squot;t seem to work on arc */
id|fd_select_drive
c_func
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* disable interrupt temporarily */
id|DISABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_TRACK
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* was ff00 why? */
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_CMD
comma
id|FDC1772CMD_RESTORE
op_or
id|FDC1772CMDADD_H
op_or
id|FDC1772STEP_6
)paren
suffix:semicolon
multiline_comment|/*printk(&quot;fd_test_drive_present: Going into timeout loop&bslash;n&quot;); */
r_for
c_loop
(paren
id|ok
op_assign
l_int|0
comma
id|timeout
op_assign
id|jiffies
op_plus
l_int|2
op_star
id|HZ
op_plus
id|HZ
op_div
l_int|2
suffix:semicolon
id|time_before
c_func
(paren
id|jiffies
comma
id|timeout
)paren
suffix:semicolon
)paren
(brace
multiline_comment|/*  What does this piece of atariism do? - query for an interrupt? */
multiline_comment|/*  if (!(mfp.par_dt_reg &amp; 0x20))&n;&t;&t;   break; */
multiline_comment|/* Well this is my nearest guess - quit when we get an FDC interrupt */
r_if
c_cond
(paren
id|IOC_FIQSTAT
op_amp
l_int|2
)paren
r_break
suffix:semicolon
)brace
multiline_comment|/*printk(&quot;fd_test_drive_present: Coming out of timeout loop&bslash;n&quot;); */
id|status
op_assign
id|FDC1772_READ
c_func
(paren
id|FDC1772REG_STATUS
)paren
suffix:semicolon
id|ok
op_assign
(paren
id|status
op_amp
id|FDC1772STAT_TR00
)paren
op_ne
l_int|0
suffix:semicolon
multiline_comment|/*printk(&quot;fd_test_drive_present: ok=%d&bslash;n&quot;,ok); */
multiline_comment|/* force interrupt to abort restore operation (FDC1772 would try&n;&t; * about 50 seconds!) */
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_CMD
comma
id|FDC1772CMD_FORCI
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
id|status
op_assign
id|FDC1772_READ
c_func
(paren
id|FDC1772REG_STATUS
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
multiline_comment|/*printk(&quot;fd_test_drive_present: just before OK code %d&bslash;n&quot;,ok); */
r_if
c_cond
(paren
id|ok
)paren
(brace
multiline_comment|/* dummy seek command to make WP bit accessible */
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_DATA
comma
l_int|0
)paren
suffix:semicolon
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_CMD
comma
id|FDC1772CMD_SEEK
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fd_test_drive_present: just before wait for int&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* DAG: Guess means wait for interrupt */
r_while
c_loop
(paren
op_logical_neg
(paren
id|IOC_FIQSTAT
op_amp
l_int|2
)paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fd_test_drive_present: just after wait for int&bslash;n&quot;
)paren
suffix:semicolon
id|status
op_assign
id|FDC1772_READ
c_func
(paren
id|FDC1772REG_STATUS
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;fd_test_drive_present: just before ENABLE_IRQ&bslash;n&quot;
)paren
suffix:semicolon
id|ENABLE_IRQ
c_func
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;fd_test_drive_present: about to return&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|ok
)paren
suffix:semicolon
)brace
multiline_comment|/* Look how many and which kind of drives are connected. If there are&n; * floppies, additionally start the disk-change and motor-off timers.&n; */
DECL|function|config_types
r_static
r_void
id|config_types
c_func
(paren
r_void
)paren
(brace
r_int
id|drive
comma
id|cnt
op_assign
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Probing floppy drive(s):&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|FD_MAX_UNITS
suffix:semicolon
id|drive
op_increment
)paren
(brace
id|fd_probe
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|connected
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fd%d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
op_increment
id|cnt
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|FDC1772_READ
c_func
(paren
id|FDC1772REG_STATUS
)paren
op_amp
id|FDC1772STAT_BUSY
)paren
(brace
multiline_comment|/* If FDC1772 is still busy from probing, give it another FORCI&n;&t;&t; * command to abort the operation. If this isn&squot;t done, the FDC1772&n;&t;&t; * will interrupt later and its IRQ line stays low, because&n;&t;&t; * the status register isn&squot;t read. And this will block any&n;&t;&t; * interrupts on this IRQ line :-(&n;&t;&t; */
id|FDC1772_WRITE
c_func
(paren
id|FDC1772REG_CMD
comma
id|FDC1772CMD_FORCI
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500
)paren
suffix:semicolon
id|FDC1772_READ
c_func
(paren
id|FDC1772REG_STATUS
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|20
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cnt
OG
l_int|0
)paren
(brace
id|START_MOTOR_OFF_TIMER
c_func
(paren
id|FD_MOTOR_OFF_DELAY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cnt
op_eq
l_int|1
)paren
id|fd_select_drive
c_func
(paren
l_int|0
)paren
suffix:semicolon
multiline_comment|/*START_CHECK_CHANGE_TIMER( CHECK_CHANGE_DELAY ); */
)brace
)brace
multiline_comment|/*&n; * floppy_open check for aliasing (/dev/fd0 can be the same as&n; * /dev/PS0 etc), and disallows simultaneous access to the same&n; * drive with different device numbers.&n; */
DECL|function|floppy_open
r_static
r_int
id|floppy_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|drive
suffix:semicolon
r_int
id|old_dev
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|filp
)paren
(brace
id|DPRINT
c_func
(paren
(paren
l_string|&quot;Weird, open called with filp=0&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|drive
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
(paren
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_rshift
l_int|2
)paren
OG
id|NUM_DISK_TYPES
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|old_dev
op_assign
id|fd_device
(braket
id|drive
)braket
suffix:semicolon
r_if
c_cond
(paren
id|fd_ref
(braket
id|drive
)braket
)paren
r_if
c_cond
(paren
id|old_dev
op_ne
id|inode-&gt;i_rdev
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|fd_ref
(braket
id|drive
)braket
op_eq
op_minus
l_int|1
op_logical_or
(paren
id|fd_ref
(braket
id|drive
)braket
op_logical_and
id|filp-&gt;f_flags
op_amp
id|O_EXCL
)paren
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_EXCL
)paren
id|fd_ref
(braket
id|drive
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
id|fd_ref
(braket
id|drive
)braket
op_increment
suffix:semicolon
id|fd_device
(braket
id|drive
)braket
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
r_if
c_cond
(paren
id|old_dev
op_logical_and
id|old_dev
op_ne
id|inode-&gt;i_rdev
)paren
id|invalidate_buffers
c_func
(paren
id|old_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_flags
op_amp
id|O_NDELAY
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
l_int|3
)paren
(brace
id|check_disk_change
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|filp-&gt;f_mode
op_amp
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|unit
(braket
id|drive
)braket
dot
id|wpstat
)paren
(brace
id|floppy_release
c_func
(paren
id|inode
comma
id|filp
)paren
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|floppy_release
r_static
r_void
id|floppy_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|filp
)paren
(brace
r_int
id|drive
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_amp
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|fd_ref
(braket
id|drive
)braket
OL
l_int|0
)paren
id|fd_ref
(braket
id|drive
)braket
op_assign
l_int|0
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|fd_ref
(braket
id|drive
)braket
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;floppy_release with fd_ref == 0&quot;
)paren
suffix:semicolon
id|fd_ref
(braket
id|drive
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
DECL|variable|floppy_fops
r_static
r_struct
id|block_device_operations
id|floppy_fops
op_assign
(brace
id|owner
suffix:colon
id|THIS_MODULE
comma
id|open
suffix:colon
id|floppy_open
comma
id|release
suffix:colon
id|floppy_release
comma
id|ioctl
suffix:colon
id|fd_ioctl
comma
id|check_media_change
suffix:colon
id|check_floppy_change
comma
id|revalidate
suffix:colon
id|floppy_revalidate
comma
)brace
suffix:semicolon
DECL|function|fd1772_init
r_int
id|fd1772_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|machine_is_arc
c_func
(paren
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;fd&quot;
comma
op_amp
id|floppy_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major %d for floppy&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|FLOPPY_DMA
comma
l_string|&quot;fd1772&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to grab DMA%d for the floppy (1772) driver&bslash;n&quot;
comma
id|FLOPPY_DMA
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
suffix:semicolon
r_if
c_cond
(paren
id|request_dma
c_func
(paren
id|FIQ_FD1772
comma
l_string|&quot;fd1772 end&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to grab DMA%d for the floppy (1772) driver&bslash;n&quot;
comma
id|FIQ_FD1772
)paren
suffix:semicolon
id|free_dma
c_func
(paren
id|FLOPPY_DMA
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
suffix:semicolon
id|enable_dma
c_func
(paren
id|FIQ_FD1772
)paren
suffix:semicolon
multiline_comment|/* This inserts a call to our command end routine */
multiline_comment|/* initialize variables */
id|SelectedDrive
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#ifdef TRACKBUFFER
id|BufferDrive
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
multiline_comment|/* initialize check_change timer */
id|init_timer
c_func
(paren
op_amp
id|fd_timer
)paren
suffix:semicolon
id|fd_timer.function
op_assign
id|check_change
suffix:semicolon
)brace
macro_line|#ifdef TRACKBUFFER
id|DMABuffer
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
(paren
id|MAX_SECTORS
op_plus
l_int|1
)paren
op_star
l_int|512
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* Atari uses 512 - I want to eventually cope with 1K sectors */
id|TrackBuffer
op_assign
id|DMABuffer
op_plus
l_int|512
suffix:semicolon
macro_line|#else
multiline_comment|/* Allocate memory for the DMAbuffer - on the Atari this takes it&n;&t;   out of some special memory... */
id|DMABuffer
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
l_int|2048
)paren
suffix:semicolon
multiline_comment|/* Copes with pretty large sectors */
macro_line|#endif
macro_line|#ifdef TRACKBUFFER  
id|BufferDrive
op_assign
id|BufferSide
op_assign
id|BufferTrack
op_assign
op_minus
l_int|1
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|FD_MAX_UNITS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|unit
(braket
id|i
)braket
dot
id|track
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
(paren
id|i
op_rshift
l_int|2
)paren
OG
l_int|0
op_logical_and
(paren
id|i
op_rshift
l_int|2
)paren
op_le
id|NUM_DISK_TYPES
)paren
id|floppy_sizes
(braket
id|i
)braket
op_assign
id|disk_type
(braket
(paren
id|i
op_rshift
l_int|2
)paren
op_minus
l_int|1
)braket
dot
id|blocks
op_rshift
l_int|1
suffix:semicolon
r_else
id|floppy_sizes
(braket
id|i
)braket
op_assign
id|MAX_DISK_SIZE
suffix:semicolon
id|blk_size
(braket
id|MAJOR_NR
)braket
op_assign
id|floppy_sizes
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|floppy_blocksizes
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|config_types
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Just a dummy at the moment */
r_void
id|floppy_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
)brace
r_void
id|floppy_eject
c_func
(paren
r_void
)paren
(brace
)brace
eof
