multiline_comment|/*&n; *  linux/drivers/acorn/char/keyb_arc.c&n; *&n; *  Copyright (C) 2000 Russell King&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License version 2 as&n; * published by the Free Software Foundation.&n; *&n; *  Acorn keyboard driver for ARM Linux.&n; *&n; *  The Acorn keyboard appears to have a ***very*** buggy reset protocol -&n; *  every reset behaves differently.  We try to get round this by attempting&n; *  a few things...&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/tty.h&gt;
macro_line|#include &lt;linux/tty_flip.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/random.h&gt;
macro_line|#include &lt;linux/ctype.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/kbd_ll.h&gt;
macro_line|#include &lt;linux/kbd_kern.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;asm/bitops.h&gt;
macro_line|#include &lt;asm/keyboard.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/hardware.h&gt;
macro_line|#include &lt;asm/hardware/ioc.h&gt;
macro_line|#include &quot;../../char/busmouse.h&quot;
r_extern
r_struct
id|tasklet_struct
id|keyboard_tasklet
suffix:semicolon
r_extern
r_void
id|kbd_reset_kdown
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|macro|VERSION
mdefine_line|#define VERSION 108
DECL|macro|KBD_REPORT_ERR
mdefine_line|#define KBD_REPORT_ERR
DECL|macro|KBD_REPORT_UNKN
mdefine_line|#define KBD_REPORT_UNKN
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
DECL|variable|kbd_txval
r_static
r_char
id|kbd_txval
(braket
l_int|4
)braket
suffix:semicolon
DECL|variable|kbd_txhead
DECL|variable|kbd_txtail
r_static
r_int
r_char
id|kbd_txhead
comma
id|kbd_txtail
suffix:semicolon
DECL|macro|KBD_INCTXPTR
mdefine_line|#define KBD_INCTXPTR(ptr) ((ptr) = ((ptr) + 1) &amp; 3)
DECL|variable|kbd_id
r_static
r_int
id|kbd_id
op_assign
op_minus
l_int|1
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|kbd_waitq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KBDMOUSE
DECL|variable|mousedev
r_static
r_int
id|mousedev
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Protocol codes to send the keyboard.&n; */
DECL|macro|HRST
mdefine_line|#define HRST 0xff&t;/* reset keyboard */
DECL|macro|RAK1
mdefine_line|#define RAK1 0xfe&t;/* reset response */
DECL|macro|RAK2
mdefine_line|#define RAK2 0xfd&t;/* reset response */
DECL|macro|BACK
mdefine_line|#define BACK 0x3f&t;/* Ack for first keyboard pair */
DECL|macro|SMAK
mdefine_line|#define SMAK 0x33&t;/* Last data byte ack (key scanning + mouse movement scanning) */
DECL|macro|MACK
mdefine_line|#define MACK 0x32&t;/* Last data byte ack (mouse movement scanning) */
DECL|macro|SACK
mdefine_line|#define SACK 0x31&t;/* Last data byte ack (key scanning) */
DECL|macro|NACK
mdefine_line|#define NACK 0x30&t;/* Last data byte ack (no scanning, mouse data) */
DECL|macro|RQMP
mdefine_line|#define RQMP 0x22&t;/* Request mouse data */
DECL|macro|PRST
mdefine_line|#define PRST 0x21&t;/* nothing */
DECL|macro|RQID
mdefine_line|#define RQID 0x20&t;/* Request ID */
DECL|macro|UP_FLAG
mdefine_line|#define UP_FLAG 1
macro_line|#ifdef CONFIG_MAGIC_SYSRQ
DECL|variable|a5kkbd_sysrq_xlate
r_int
r_char
id|a5kkbd_sysrq_xlate
(braket
)braket
op_assign
(brace
l_int|27
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_char|&squot;`&squot;
comma
l_char|&squot;1&squot;
comma
l_char|&squot;2&squot;
comma
l_char|&squot;3&squot;
comma
l_char|&squot;4&squot;
comma
l_char|&squot;5&squot;
comma
l_char|&squot;6&squot;
comma
l_char|&squot;7&squot;
comma
l_char|&squot;8&squot;
comma
l_char|&squot;9&squot;
comma
l_char|&squot;0&squot;
comma
l_char|&squot;-&squot;
comma
l_char|&squot;=&squot;
comma
l_char|&squot;&#xfffd;&squot;
comma
l_int|127
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_char|&squot;/&squot;
comma
l_char|&squot;*&squot;
comma
l_char|&squot;#&squot;
comma
l_int|9
comma
l_char|&squot;q&squot;
comma
l_char|&squot;w&squot;
comma
l_char|&squot;e&squot;
comma
l_char|&squot;r&squot;
comma
l_char|&squot;t&squot;
comma
l_char|&squot;y&squot;
comma
l_char|&squot;u&squot;
comma
l_char|&squot;i&squot;
comma
l_char|&squot;o&squot;
comma
l_char|&squot;p&squot;
comma
l_char|&squot;[&squot;
comma
l_char|&squot;]&squot;
comma
l_char|&squot;&bslash;&bslash;&squot;
comma
l_int|22
comma
l_int|23
comma
l_int|25
comma
l_char|&squot;7&squot;
comma
l_char|&squot;8&squot;
comma
l_char|&squot;9&squot;
comma
l_char|&squot;-&squot;
comma
l_int|0
comma
l_char|&squot;a&squot;
comma
l_char|&squot;s&squot;
comma
l_char|&squot;d&squot;
comma
l_char|&squot;f&squot;
comma
l_char|&squot;g&squot;
comma
l_char|&squot;h&squot;
comma
l_char|&squot;j&squot;
comma
l_char|&squot;k&squot;
comma
l_char|&squot;l&squot;
comma
l_char|&squot;;&squot;
comma
l_char|&squot;&bslash;&squot;&squot;
comma
l_int|13
comma
l_char|&squot;4&squot;
comma
l_char|&squot;5&squot;
comma
l_char|&squot;6&squot;
comma
l_char|&squot;+&squot;
comma
l_int|0
comma
l_int|0
comma
l_char|&squot;z&squot;
comma
l_char|&squot;x&squot;
comma
l_char|&squot;c&squot;
comma
l_char|&squot;v&squot;
comma
l_char|&squot;b&squot;
comma
l_char|&squot;n&squot;
comma
l_char|&squot;m&squot;
comma
l_char|&squot;,&squot;
comma
l_char|&squot;.&squot;
comma
l_char|&squot;/&squot;
comma
l_int|0
comma
l_int|0
comma
l_char|&squot;1&squot;
comma
l_char|&squot;2&squot;
comma
l_char|&squot;3&squot;
comma
l_int|0
comma
l_int|0
comma
l_char|&squot; &squot;
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_char|&squot;0&squot;
comma
l_char|&squot;.&squot;
comma
l_int|10
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * This array converts the scancode that we get from the keyboard to the&n; * real rows/columns on the A5000 keyboard.  This might be keyboard specific...&n; *&n; * It is these values that we use to maintain the key down array.  That way, we&n; * should pick up on the ghost key presses (which is what happens when you press&n; * three keys, and the keyboard thinks you have pressed four!)&n; *&n; * Row 8 (0x80+c) is actually a column with one key per row.  It is isolated from&n; * the other keys, and can&squot;t cause these problems (its used for shift, ctrl, alt etc).&n; *&n; * Illegal scancodes are denoted by an 0xff (in other words, we don&squot;t know about&n; * them, and can&squot;t process them for ghosts).  This does however, cause problems with&n; * autorepeat processing...&n; */
DECL|variable|scancode_2_colrow
r_static
r_int
r_char
id|scancode_2_colrow
(braket
l_int|256
)braket
op_assign
(brace
l_int|0x01
comma
l_int|0x42
comma
l_int|0x32
comma
l_int|0x33
comma
l_int|0x43
comma
l_int|0x56
comma
l_int|0x5a
comma
l_int|0x6c
comma
l_int|0x7c
comma
l_int|0x5c
comma
l_int|0x5b
comma
l_int|0x6b
comma
l_int|0x7b
comma
l_int|0x84
comma
l_int|0x70
comma
l_int|0x60
comma
l_int|0x11
comma
l_int|0x51
comma
l_int|0x62
comma
l_int|0x63
comma
l_int|0x44
comma
l_int|0x54
comma
l_int|0x55
comma
l_int|0x45
comma
l_int|0x46
comma
l_int|0x4a
comma
l_int|0x3c
comma
l_int|0x4b
comma
l_int|0x59
comma
l_int|0x49
comma
l_int|0x69
comma
l_int|0x79
comma
l_int|0x83
comma
l_int|0x40
comma
l_int|0x30
comma
l_int|0x3b
comma
l_int|0x39
comma
l_int|0x38
comma
l_int|0x31
comma
l_int|0x61
comma
l_int|0x72
comma
l_int|0x73
comma
l_int|0x64
comma
l_int|0x74
comma
l_int|0x75
comma
l_int|0x65
comma
l_int|0x66
comma
l_int|0x6a
comma
l_int|0x1c
comma
l_int|0x2c
comma
l_int|0x7a
comma
l_int|0x36
comma
l_int|0x48
comma
l_int|0x68
comma
l_int|0x78
comma
l_int|0x20
comma
l_int|0x2b
comma
l_int|0x29
comma
l_int|0x28
comma
l_int|0x81
comma
l_int|0x71
comma
l_int|0x22
comma
l_int|0x23
comma
l_int|0x34
comma
l_int|0x24
comma
l_int|0x25
comma
l_int|0x35
comma
l_int|0x26
comma
l_int|0x3a
comma
l_int|0x0c
comma
l_int|0x2a
comma
l_int|0x76
comma
l_int|0x10
comma
l_int|0x1b
comma
l_int|0x19
comma
l_int|0x18
comma
l_int|0x82
comma
l_int|0xff
comma
l_int|0x21
comma
l_int|0x12
comma
l_int|0x13
comma
l_int|0x14
comma
l_int|0x04
comma
l_int|0x05
comma
l_int|0x15
comma
l_int|0x16
comma
l_int|0x1a
comma
l_int|0x0a
comma
l_int|0x85
comma
l_int|0x77
comma
l_int|0x00
comma
l_int|0x0b
comma
l_int|0x09
comma
l_int|0x02
comma
l_int|0x80
comma
l_int|0x03
comma
l_int|0x87
comma
l_int|0x86
comma
l_int|0x06
comma
l_int|0x17
comma
l_int|0x27
comma
l_int|0x07
comma
l_int|0x37
comma
l_int|0x08
comma
l_int|0xff
comma
)brace
suffix:semicolon
DECL|macro|BITS_PER_SHORT
mdefine_line|#define BITS_PER_SHORT (8*sizeof(unsigned short))
DECL|variable|ghost_down
r_static
r_int
r_int
id|ghost_down
(braket
l_int|128
op_div
id|BITS_PER_SHORT
)braket
suffix:semicolon
DECL|function|a5kkbd_key
r_static
r_void
id|a5kkbd_key
c_func
(paren
r_int
r_int
id|keycode
comma
r_int
r_int
id|up_flag
)paren
(brace
r_int
r_int
id|real_keycode
suffix:semicolon
r_if
c_cond
(paren
id|keycode
OG
l_int|0x72
)paren
(brace
macro_line|#ifdef KBD_REPORT_UNKN
id|printk
(paren
l_string|&quot;kbd: unknown scancode 0x%04x&bslash;n&quot;
comma
id|keycode
)paren
suffix:semicolon
macro_line|#endif
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|keycode
op_ge
l_int|0x70
)paren
(brace
macro_line|#ifdef CONFIG_KBDMOUSE
r_if
c_cond
(paren
id|mousedev
op_ge
l_int|0
)paren
r_switch
c_cond
(paren
id|keycode
)paren
(brace
r_case
l_int|0x70
suffix:colon
multiline_comment|/* Left mouse button */
id|busmouse_add_buttons
c_func
(paren
id|mousedev
comma
l_int|4
comma
id|up_flag
ques
c_cond
l_int|4
suffix:colon
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x71
suffix:colon
multiline_comment|/* Middle mouse button */
id|busmouse_add_buttons
c_func
(paren
id|mousedev
comma
l_int|2
comma
id|up_flag
ques
c_cond
l_int|2
suffix:colon
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x72
suffix:colon
multiline_comment|/* Right mouse button */
id|busmouse_add_buttons
c_func
(paren
id|mousedev
comma
l_int|1
comma
id|up_flag
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
macro_line|#endif
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We have to work out if we accept this key press as a real key, or&n;&t; * if it is a ghost.  IE. If you press three keys, the keyboard will think&n;&t; * that you&squot;ve pressed a fourth: (@ = key down, # = ghost)&n;&t; *&n;&t; *   0 1 2 3 4 5 6 7&n;&t; *   | | | | | | | |&n;&t; * 0-+-+-+-+-+-+-+-+-&n;&t; *   | | | | | | | |&n;&t; * 1-+-@-+-+-+-@-+-+-&n;&t; *   | | | | | | | |&n;&t; * 2-+-+-+-+-+-+-+-+-&n;&t; *   | | | | | | | |&n;&t; * 3-+-@-+-+-+-#-+-+-&n;&t; *   | | | | | | | |&n;&t; *&n;&t; * This is what happens when you have a matrix keyboard...&n;&t; */
id|real_keycode
op_assign
id|scancode_2_colrow
(braket
id|keycode
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|real_keycode
op_amp
l_int|0x80
)paren
op_eq
l_int|0
)paren
(brace
r_int
id|rr
comma
id|kc
op_assign
(paren
id|real_keycode
op_rshift
l_int|4
)paren
op_amp
l_int|7
suffix:semicolon
r_int
id|cc
suffix:semicolon
r_int
r_int
id|res
comma
id|kdownkc
suffix:semicolon
id|kdownkc
op_assign
id|ghost_down
(braket
id|kc
)braket
op_or
(paren
l_int|1
op_lshift
(paren
id|real_keycode
op_amp
l_int|15
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|rr
op_assign
l_int|0
suffix:semicolon
id|rr
OL
l_int|128
op_div
id|BITS_PER_SHORT
suffix:semicolon
id|rr
op_increment
)paren
r_if
c_cond
(paren
id|rr
op_ne
id|kc
op_logical_and
(paren
id|res
op_assign
id|ghost_down
(braket
id|rr
)braket
op_amp
id|kdownkc
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * we have found a second row with at least one key pressed in the&n;&t;&t;&t;    &t; * same column.&n;&t;&t;&t;    &t; */
r_for
c_loop
(paren
id|cc
op_assign
l_int|0
suffix:semicolon
id|res
suffix:semicolon
id|res
op_rshift_assign
l_int|1
)paren
id|cc
op_add_assign
(paren
id|res
op_amp
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|cc
OG
l_int|1
)paren
r_return
suffix:semicolon
multiline_comment|/* ignore it */
)brace
r_if
c_cond
(paren
id|up_flag
)paren
id|clear_bit
(paren
id|real_keycode
comma
id|ghost_down
)paren
suffix:semicolon
r_else
id|set_bit
(paren
id|real_keycode
comma
id|ghost_down
)paren
suffix:semicolon
)brace
id|handle_scancode
c_func
(paren
id|keycode
comma
op_logical_neg
id|up_flag
)paren
suffix:semicolon
)brace
DECL|function|a5kkbd_sendbyte
r_static
r_inline
r_void
id|a5kkbd_sendbyte
c_func
(paren
r_int
r_char
id|val
)paren
(brace
id|kbd_txval
(braket
id|kbd_txhead
)braket
op_assign
id|val
suffix:semicolon
id|KBD_INCTXPTR
c_func
(paren
id|kbd_txhead
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|IRQ_KEYBOARDTX
)paren
suffix:semicolon
)brace
DECL|function|a5kkbd_reset
r_static
r_inline
r_void
id|a5kkbd_reset
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NR_SCANCODES
op_div
id|BITS_PER_SHORT
suffix:semicolon
id|i
op_increment
)paren
id|ghost_down
(braket
id|i
)braket
op_assign
l_int|0
suffix:semicolon
id|kbd_reset_kdown
c_func
(paren
)paren
suffix:semicolon
)brace
DECL|function|a5kkbd_leds
r_void
id|a5kkbd_leds
c_func
(paren
r_int
r_char
id|leds
)paren
(brace
id|leds
op_assign
(paren
(paren
id|leds
op_amp
(paren
l_int|1
op_lshift
id|VC_SCROLLOCK
)paren
)paren
ques
c_cond
l_int|4
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|leds
op_amp
(paren
l_int|1
op_lshift
id|VC_NUMLOCK
)paren
)paren
ques
c_cond
l_int|2
suffix:colon
l_int|0
)paren
op_or
(paren
(paren
id|leds
op_amp
(paren
l_int|1
op_lshift
id|VC_CAPSLOCK
)paren
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
id|a5kkbd_sendbyte
c_func
(paren
id|leds
)paren
suffix:semicolon
)brace
multiline_comment|/* Keyboard states:&n; *  0 initial reset condition, receive HRST, send RRAK1&n; *  1 Sent RAK1, wait for RAK1, send RRAK2&n; *  2 Sent RAK2, wait for RAK2, send SMAK or RQID&n; *  3 Sent RQID, expect KBID, send SMAK&n; *  4 Sent SMAK, wait for anything&n; *  5 Wait for second keyboard nibble for key pressed&n; *  6 Wait for second keyboard nibble for key released&n; *  7 Wait for second part of mouse data&n; *&n; * This function returns 1 when we successfully enter the IDLE state&n; * (and hence need to do some keyboard processing).&n; */
DECL|macro|KBD_INITRST
mdefine_line|#define KBD_INITRST&t;0
DECL|macro|KBD_RAK1
mdefine_line|#define KBD_RAK1&t;1
DECL|macro|KBD_RAK2
mdefine_line|#define KBD_RAK2&t;2
DECL|macro|KBD_ID
mdefine_line|#define KBD_ID&t;&t;3
DECL|macro|KBD_IDLE
mdefine_line|#define KBD_IDLE&t;4
DECL|macro|KBD_KEYDOWN
mdefine_line|#define KBD_KEYDOWN&t;5
DECL|macro|KBD_KEYUP
mdefine_line|#define KBD_KEYUP&t;6
DECL|macro|KBD_MOUSE
mdefine_line|#define KBD_MOUSE&t;7
DECL|function|handle_rawcode
r_static
r_int
id|handle_rawcode
c_func
(paren
r_int
r_int
id|keyval
)paren
(brace
r_static
r_int
r_char
id|kbd_mousedx
op_assign
l_int|0
suffix:semicolon
r_int
r_char
id|kbd_mousedy
suffix:semicolon
r_static
r_int
r_char
id|kbd_state
op_assign
id|KBD_INITRST
suffix:semicolon
r_static
r_int
r_char
id|kbd_keyhigh
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|keyval
op_eq
id|HRST
op_logical_and
id|kbd_state
op_ne
id|KBD_INITRST
op_logical_and
id|kbd_state
op_ne
id|KBD_ID
)paren
(brace
id|a5kkbd_sendbyte
(paren
id|HRST
)paren
suffix:semicolon
id|a5kkbd_reset
(paren
)paren
suffix:semicolon
id|kbd_state
op_assign
id|KBD_INITRST
suffix:semicolon
)brace
r_else
r_switch
c_cond
(paren
id|kbd_state
)paren
(brace
r_case
id|KBD_INITRST
suffix:colon
multiline_comment|/* hard reset - sent HRST */
r_if
c_cond
(paren
id|keyval
op_eq
id|HRST
)paren
(brace
id|a5kkbd_sendbyte
(paren
id|RAK1
)paren
suffix:semicolon
id|kbd_state
op_assign
id|KBD_RAK1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|keyval
op_eq
id|RAK1
)paren
(brace
multiline_comment|/* Some A5000 keyboards are very fussy and don&squot;t follow Acorn&squot;s&n;&t;&t;&t; * specs - this appears to fix them, but them it might stop&n;&t;&t;&t; * them from being initialised.&n;&t;&t;&t; *  fix by Philip Blundell&n;&t;&t;&t; */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;keyboard sent early RAK1 -- ignored&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_goto
id|kbd_wontreset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KBD_RAK1
suffix:colon
multiline_comment|/* sent RAK1 - expect RAK1 and send RAK2 */
r_if
c_cond
(paren
id|keyval
op_eq
id|RAK1
)paren
(brace
id|a5kkbd_sendbyte
(paren
id|RAK2
)paren
suffix:semicolon
id|kbd_state
op_assign
id|KBD_RAK2
suffix:semicolon
)brace
r_else
r_goto
id|kbd_wontreset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KBD_RAK2
suffix:colon
multiline_comment|/* Sent RAK2 - expect RAK2 and send either RQID or SMAK */
r_if
c_cond
(paren
id|keyval
op_eq
id|RAK2
)paren
(brace
r_if
c_cond
(paren
id|kbd_id
op_eq
op_minus
l_int|1
)paren
(brace
id|a5kkbd_sendbyte
(paren
id|NACK
)paren
suffix:semicolon
id|a5kkbd_sendbyte
(paren
id|RQID
)paren
suffix:semicolon
id|kbd_state
op_assign
id|KBD_ID
suffix:semicolon
)brace
r_else
(brace
id|a5kkbd_sendbyte
(paren
id|SMAK
)paren
suffix:semicolon
id|kbd_state
op_assign
id|KBD_IDLE
suffix:semicolon
)brace
)brace
r_else
r_goto
id|kbd_wontreset
suffix:semicolon
r_break
suffix:semicolon
r_case
id|KBD_ID
suffix:colon
multiline_comment|/* Sent RQID - expect KBID */
r_if
c_cond
(paren
id|keyval
op_eq
id|HRST
)paren
(brace
id|kbd_id
op_assign
op_minus
l_int|2
suffix:semicolon
id|a5kkbd_reset
(paren
)paren
suffix:semicolon
id|a5kkbd_sendbyte
(paren
id|HRST
)paren
suffix:semicolon
id|kbd_state
op_assign
id|KBD_INITRST
suffix:semicolon
id|wake_up
(paren
op_amp
id|kbd_waitq
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|keyval
op_amp
l_int|0xc0
)paren
op_eq
l_int|0x80
)paren
(brace
id|kbd_id
op_assign
id|keyval
op_amp
l_int|0x3f
suffix:semicolon
id|a5kkbd_sendbyte
(paren
id|SMAK
)paren
suffix:semicolon
id|kbd_state
op_assign
id|KBD_IDLE
suffix:semicolon
id|wake_up
(paren
op_amp
id|kbd_waitq
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|KBD_IDLE
suffix:colon
multiline_comment|/* Send SMAK, ready for any reply */
r_switch
c_cond
(paren
id|keyval
op_amp
l_int|0xf0
)paren
(brace
r_default
suffix:colon
multiline_comment|/* 0x00 - 0x7f */
id|kbd_mousedx
op_assign
id|keyval
op_amp
l_int|0x40
ques
c_cond
id|keyval
op_or
l_int|0x80
suffix:colon
id|keyval
suffix:semicolon
id|kbd_state
op_assign
id|KBD_MOUSE
suffix:semicolon
id|a5kkbd_sendbyte
(paren
id|BACK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
r_case
l_int|0x90
suffix:colon
r_case
l_int|0xa0
suffix:colon
r_case
l_int|0xb0
suffix:colon
r_if
c_cond
(paren
id|kbd_id
op_eq
op_minus
l_int|1
)paren
id|kbd_id
op_assign
id|keyval
op_amp
l_int|0x3f
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xc0
suffix:colon
id|kbd_keyhigh
op_assign
id|keyval
suffix:semicolon
id|kbd_state
op_assign
id|KBD_KEYDOWN
suffix:semicolon
id|a5kkbd_sendbyte
(paren
id|BACK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xd0
suffix:colon
id|kbd_keyhigh
op_assign
id|keyval
suffix:semicolon
id|kbd_state
op_assign
id|KBD_KEYUP
suffix:semicolon
id|a5kkbd_sendbyte
(paren
id|BACK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xe0
suffix:colon
r_case
l_int|0xf0
suffix:colon
r_goto
id|kbd_error
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|KBD_KEYDOWN
suffix:colon
r_if
c_cond
(paren
(paren
id|keyval
op_amp
l_int|0xf0
)paren
op_ne
l_int|0xc0
)paren
r_goto
id|kbd_error
suffix:semicolon
r_else
(brace
id|kbd_state
op_assign
id|KBD_IDLE
suffix:semicolon
id|a5kkbd_sendbyte
(paren
id|SMAK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|kbd_keyhigh
op_xor
id|keyval
)paren
op_amp
l_int|0xf0
)paren
op_eq
l_int|0
)paren
id|a5kkbd_key
(paren
(paren
id|keyval
op_amp
l_int|0x0f
)paren
op_or
(paren
(paren
id|kbd_keyhigh
op_lshift
l_int|4
)paren
op_amp
l_int|0xf0
)paren
comma
l_int|0
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|KBD_KEYUP
suffix:colon
r_if
c_cond
(paren
(paren
id|keyval
op_amp
l_int|0xf0
)paren
op_ne
l_int|0xd0
)paren
r_goto
id|kbd_error
suffix:semicolon
r_else
(brace
id|kbd_state
op_assign
id|KBD_IDLE
suffix:semicolon
id|a5kkbd_sendbyte
(paren
id|SMAK
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|kbd_keyhigh
op_xor
id|keyval
)paren
op_amp
l_int|0xf0
)paren
op_eq
l_int|0
)paren
id|a5kkbd_key
(paren
(paren
id|keyval
op_amp
l_int|0x0f
)paren
op_or
(paren
(paren
id|kbd_keyhigh
op_lshift
l_int|4
)paren
op_amp
l_int|0xf0
)paren
comma
id|UP_FLAG
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|KBD_MOUSE
suffix:colon
r_if
c_cond
(paren
id|keyval
op_amp
l_int|0x80
)paren
r_goto
id|kbd_error
suffix:semicolon
r_else
(brace
id|kbd_state
op_assign
id|KBD_IDLE
suffix:semicolon
id|a5kkbd_sendbyte
(paren
id|SMAK
)paren
suffix:semicolon
id|kbd_mousedy
op_assign
(paren
r_char
)paren
(paren
id|keyval
op_amp
l_int|0x40
ques
c_cond
id|keyval
op_or
l_int|0x80
suffix:colon
id|keyval
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KBDMOUSE
r_if
c_cond
(paren
id|mousedev
op_ge
l_int|0
)paren
id|busmouse_add_movement
c_func
(paren
id|mousedev
comma
(paren
r_int
)paren
id|kbd_mousedx
comma
(paren
r_int
)paren
id|kbd_mousedy
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
r_return
id|kbd_state
op_eq
id|KBD_IDLE
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|kbd_wontreset
suffix:colon
macro_line|#ifdef KBD_REPORT_ERR
id|printk
(paren
l_string|&quot;kbd: keyboard won&squot;t reset (kbdstate %d, keyval %02X)&bslash;n&quot;
comma
id|kbd_state
comma
id|keyval
)paren
suffix:semicolon
macro_line|#endif
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|inb
c_func
(paren
id|IOC_KARTRX
)paren
suffix:semicolon
id|a5kkbd_sendbyte
(paren
id|HRST
)paren
suffix:semicolon
id|kbd_state
op_assign
id|KBD_INITRST
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|kbd_error
suffix:colon
macro_line|#ifdef KBD_REPORT_ERR
id|printk
(paren
l_string|&quot;kbd: keyboard out of sync - resetting&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|a5kkbd_sendbyte
(paren
id|HRST
)paren
suffix:semicolon
id|kbd_state
op_assign
id|KBD_INITRST
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|a5kkbd_rx
r_static
r_void
id|a5kkbd_rx
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|kbd_pt_regs
op_assign
id|regs
suffix:semicolon
r_if
c_cond
(paren
id|handle_rawcode
c_func
(paren
id|inb
c_func
(paren
id|IOC_KARTRX
)paren
)paren
)paren
id|tasklet_schedule
c_func
(paren
op_amp
id|keyboard_tasklet
)paren
suffix:semicolon
)brace
DECL|function|a5kkbd_tx
r_static
r_void
id|a5kkbd_tx
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
id|outb
(paren
id|kbd_txval
(braket
id|kbd_txtail
)braket
comma
id|IOC_KARTTX
)paren
suffix:semicolon
id|KBD_INCTXPTR
c_func
(paren
id|kbd_txtail
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_txtail
op_eq
id|kbd_txhead
)paren
id|disable_irq
c_func
(paren
id|irq
)paren
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_KBDMOUSE
DECL|variable|a5kkbd_mouse
r_static
r_struct
id|busmouse
id|a5kkbd_mouse
op_assign
(brace
l_int|6
comma
l_string|&quot;kbdmouse&quot;
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|7
)brace
suffix:semicolon
macro_line|#endif
DECL|function|a5kkbd_init_hw
r_void
id|__init
id|a5kkbd_init_hw
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
(paren
id|IRQ_KEYBOARDTX
comma
id|a5kkbd_tx
comma
l_int|0
comma
l_string|&quot;keyboard&quot;
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Could not allocate keyboard transmit IRQ!&quot;
)paren
suffix:semicolon
(paren
r_void
)paren
id|inb
c_func
(paren
id|IOC_KARTRX
)paren
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
(paren
id|IRQ_KEYBOARDRX
comma
id|a5kkbd_rx
comma
l_int|0
comma
l_string|&quot;keyboard&quot;
comma
l_int|NULL
)paren
op_ne
l_int|0
)paren
id|panic
c_func
(paren
l_string|&quot;Could not allocate keyboard receive IRQ!&quot;
)paren
suffix:semicolon
id|a5kkbd_sendbyte
(paren
id|HRST
)paren
suffix:semicolon
multiline_comment|/* send HRST (expect HRST) */
multiline_comment|/* wait 1s for keyboard to initialise */
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|kbd_waitq
comma
id|HZ
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KBDMOUSE
id|mousedev
op_assign
id|register_busmouse
c_func
(paren
op_amp
id|a5kkbd_mouse
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mousedev
OL
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;Unable to register mouse driver&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|printk
(paren
id|KERN_INFO
l_string|&quot;Keyboard driver v%d.%02d. (&quot;
comma
id|VERSION
op_div
l_int|100
comma
id|VERSION
op_mod
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
id|kbd_id
op_ne
op_minus
l_int|1
)paren
id|printk
(paren
l_string|&quot;id=%d &quot;
comma
id|kbd_id
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;English)&bslash;n&quot;
)paren
suffix:semicolon
)brace
eof
