multiline_comment|/******************************************************************************&n; *&n; * Module Name: evevent - Fixed and General Purpose Acpi_event&n; *                          handling and dispatch&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;hardware.h&quot;
macro_line|#include &quot;events.h&quot;
macro_line|#include &quot;namesp.h&quot;
macro_line|#include &quot;common.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          EVENT_HANDLING
id|MODULE_NAME
(paren
l_string|&quot;evevent&quot;
)paren
suffix:semicolon
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_fixed_event_initialize&n; *&n; * PARAMETERS:  None&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Initialize the Fixed Acpi_event data structures&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_fixed_event_initialize
id|acpi_ev_fixed_event_initialize
c_func
(paren
r_void
)paren
(brace
r_int
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Initialize the structure that keeps track of fixed event handlers */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NUM_FIXED_EVENTS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|acpi_gbl_fixed_event_handlers
(braket
id|i
)braket
dot
id|handler
op_assign
l_int|NULL
suffix:semicolon
id|acpi_gbl_fixed_event_handlers
(braket
id|i
)braket
dot
id|context
op_assign
l_int|NULL
suffix:semicolon
)brace
id|acpi_hw_register_access
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_LOCK
comma
id|ACPI_EVENT_PMTIMER
op_plus
id|TMR_EN
comma
l_int|0
)paren
suffix:semicolon
id|acpi_hw_register_access
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_LOCK
comma
id|ACPI_EVENT_GLOBAL
op_plus
id|TMR_EN
comma
l_int|0
)paren
suffix:semicolon
id|acpi_hw_register_access
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_LOCK
comma
id|ACPI_EVENT_POWER_BUTTON
op_plus
id|TMR_EN
comma
l_int|0
)paren
suffix:semicolon
id|acpi_hw_register_access
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_LOCK
comma
id|ACPI_EVENT_SLEEP_BUTTON
op_plus
id|TMR_EN
comma
l_int|0
)paren
suffix:semicolon
id|acpi_hw_register_access
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_LOCK
comma
id|ACPI_EVENT_RTC
op_plus
id|TMR_EN
comma
l_int|0
)paren
suffix:semicolon
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_fixed_event_detect&n; *&n; * PARAMETERS:  None&n; *&n; * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED&n; *&n; * DESCRIPTION: Checks the PM status register for fixed events&n; *&n; ******************************************************************************/
id|u32
DECL|function|acpi_ev_fixed_event_detect
id|acpi_ev_fixed_event_detect
c_func
(paren
r_void
)paren
(brace
id|u32
id|int_status
op_assign
id|INTERRUPT_NOT_HANDLED
suffix:semicolon
id|u32
id|status_register
op_assign
l_int|0
suffix:semicolon
id|u32
id|enable_register
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Read the fixed feature status and enable registers, as all the cases&n;&t; * depend on their values.&n;&t; */
id|status_register
op_assign
(paren
id|u32
)paren
id|acpi_os_in16
(paren
id|acpi_gbl_FACP-&gt;pm1a_evt_blk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_gbl_FACP-&gt;pm1b_evt_blk
)paren
(brace
id|status_register
op_or_assign
(paren
id|u32
)paren
id|acpi_os_in16
(paren
id|acpi_gbl_FACP-&gt;pm1b_evt_blk
)paren
suffix:semicolon
)brace
id|enable_register
op_assign
(paren
id|u32
)paren
id|acpi_os_in16
(paren
id|acpi_gbl_FACP-&gt;pm1a_evt_blk
op_plus
id|DIV_2
(paren
id|acpi_gbl_FACP-&gt;pm1_evt_len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_gbl_FACP-&gt;pm1b_evt_blk
)paren
(brace
id|enable_register
op_or_assign
(paren
id|u32
)paren
id|acpi_os_in16
(paren
id|acpi_gbl_FACP-&gt;pm1b_evt_blk
op_plus
id|DIV_2
(paren
id|acpi_gbl_FACP-&gt;pm1_evt_len
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* power management timer roll over */
r_if
c_cond
(paren
(paren
id|status_register
op_amp
id|ACPI_STATUS_PMTIMER
)paren
op_logical_and
(paren
id|enable_register
op_amp
id|ACPI_ENABLE_PMTIMER
)paren
)paren
(brace
id|int_status
op_or_assign
id|acpi_ev_fixed_event_dispatch
(paren
id|ACPI_EVENT_PMTIMER
)paren
suffix:semicolon
)brace
multiline_comment|/* global event (BIOS want&squot;s the global lock) */
r_if
c_cond
(paren
(paren
id|status_register
op_amp
id|ACPI_STATUS_GLOBAL
)paren
op_logical_and
(paren
id|enable_register
op_amp
id|ACPI_ENABLE_GLOBAL
)paren
)paren
(brace
id|int_status
op_or_assign
id|acpi_ev_fixed_event_dispatch
(paren
id|ACPI_EVENT_GLOBAL
)paren
suffix:semicolon
)brace
multiline_comment|/* power button event */
r_if
c_cond
(paren
(paren
id|status_register
op_amp
id|ACPI_STATUS_POWER_BUTTON
)paren
op_logical_and
(paren
id|enable_register
op_amp
id|ACPI_ENABLE_POWER_BUTTON
)paren
)paren
(brace
id|int_status
op_or_assign
id|acpi_ev_fixed_event_dispatch
(paren
id|ACPI_EVENT_POWER_BUTTON
)paren
suffix:semicolon
)brace
multiline_comment|/* sleep button event */
r_if
c_cond
(paren
(paren
id|status_register
op_amp
id|ACPI_STATUS_SLEEP_BUTTON
)paren
op_logical_and
(paren
id|enable_register
op_amp
id|ACPI_ENABLE_SLEEP_BUTTON
)paren
)paren
(brace
id|int_status
op_or_assign
id|acpi_ev_fixed_event_dispatch
(paren
id|ACPI_EVENT_SLEEP_BUTTON
)paren
suffix:semicolon
)brace
r_return
id|int_status
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_fixed_event_dispatch&n; *&n; * PARAMETERS:  Event               - Event type&n; *&n; * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED&n; *&n; * DESCRIPTION: Clears the status bit for the requested event, calls the&n; *              handler that previously registered for the event.&n; *&n; ******************************************************************************/
id|u32
DECL|function|acpi_ev_fixed_event_dispatch
id|acpi_ev_fixed_event_dispatch
(paren
id|u32
id|event
)paren
(brace
multiline_comment|/* Clear the status bit */
id|acpi_hw_register_access
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_DO_NOT_LOCK
comma
(paren
id|s32
)paren
id|TMR_STS
op_plus
id|event
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Make sure we&squot;ve got a handler.  If not, report an error.&n;&t; * The event is disabled to prevent further interrupts.&n;&t; */
r_if
c_cond
(paren
l_int|NULL
op_eq
id|acpi_gbl_fixed_event_handlers
(braket
id|event
)braket
dot
id|handler
)paren
(brace
id|acpi_hw_register_access
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_DO_NOT_LOCK
comma
id|TMR_EN
op_plus
id|event
comma
l_int|0
)paren
suffix:semicolon
id|REPORT_ERROR
c_func
(paren
l_string|&quot;No installed handler for fixed event.&quot;
)paren
suffix:semicolon
r_return
id|INTERRUPT_NOT_HANDLED
suffix:semicolon
)brace
multiline_comment|/* Invoke the handler */
r_return
(paren
id|acpi_gbl_fixed_event_handlers
(braket
id|event
)braket
dot
id|handler
)paren
(paren
id|acpi_gbl_fixed_event_handlers
(braket
id|event
)braket
dot
id|context
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_gpe_initialize&n; *&n; * PARAMETERS:  None&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Initialize the GPE data structures&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_gpe_initialize
id|acpi_ev_gpe_initialize
(paren
r_void
)paren
(brace
id|u32
id|i
suffix:semicolon
id|u32
id|j
suffix:semicolon
id|u32
id|register_index
suffix:semicolon
id|u32
id|gpe_number
suffix:semicolon
id|u16
id|gpe0register_count
suffix:semicolon
id|u16
id|gpe1_register_count
suffix:semicolon
multiline_comment|/*&n;&t; * Setup various GPE counts&n;&t; */
id|gpe0register_count
op_assign
(paren
id|u16
)paren
id|DIV_2
(paren
id|acpi_gbl_FACP-&gt;gpe0blk_len
)paren
suffix:semicolon
id|gpe1_register_count
op_assign
(paren
id|u16
)paren
id|DIV_2
(paren
id|acpi_gbl_FACP-&gt;gpe1_blk_len
)paren
suffix:semicolon
id|acpi_gbl_gpe_register_count
op_assign
id|gpe0register_count
op_plus
id|gpe1_register_count
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate the Gpe information block&n;&t; */
id|acpi_gbl_gpe_registers
op_assign
id|acpi_cm_callocate
(paren
id|acpi_gbl_gpe_register_count
op_star
r_sizeof
(paren
id|ACPI_GPE_REGISTERS
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_gpe_registers
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Allocate the Gpe dispatch handler block&n;&t; * There are eight distinct GP events per register.&n;&t; * Initialization to zeros is sufficient&n;&t; */
id|acpi_gbl_gpe_info
op_assign
id|acpi_cm_callocate
(paren
id|MUL_8
(paren
id|acpi_gbl_gpe_register_count
)paren
op_star
r_sizeof
(paren
id|ACPI_GPE_LEVEL_INFO
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_gpe_info
)paren
(brace
id|acpi_cm_free
(paren
id|acpi_gbl_gpe_registers
)paren
suffix:semicolon
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the Gpe validation table to GPE_INVALID */
id|MEMSET
(paren
id|acpi_gbl_gpe_valid
comma
(paren
r_int
)paren
id|ACPI_GPE_INVALID
comma
id|NUM_GPE
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Initialize the Gpe information and validation blocks.  A goal of these&n;&t; * blocks is to hide the fact that there are two separate GPE register sets&n;&t; * In a given block, the status registers occupy the first half, and&n;&t; * the enable registers occupy the second half.&n;&t; */
multiline_comment|/* GPE Block 0 */
id|register_index
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|gpe0register_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|acpi_gbl_gpe_registers
(braket
id|register_index
)braket
dot
id|status_addr
op_assign
(paren
id|u16
)paren
(paren
id|acpi_gbl_FACP-&gt;gpe0blk
op_plus
id|i
)paren
suffix:semicolon
id|acpi_gbl_gpe_registers
(braket
id|register_index
)braket
dot
id|enable_addr
op_assign
(paren
id|u16
)paren
(paren
id|acpi_gbl_FACP-&gt;gpe0blk
op_plus
id|i
op_plus
id|gpe0register_count
)paren
suffix:semicolon
id|acpi_gbl_gpe_registers
(braket
id|register_index
)braket
dot
id|gpe_base
op_assign
(paren
id|u8
)paren
id|MUL_8
(paren
id|i
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
(brace
id|gpe_number
op_assign
id|acpi_gbl_gpe_registers
(braket
id|register_index
)braket
dot
id|gpe_base
op_plus
id|j
suffix:semicolon
id|acpi_gbl_gpe_valid
(braket
id|gpe_number
)braket
op_assign
(paren
id|u8
)paren
id|register_index
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Clear the status/enable registers.  Note that status registers&n;&t;&t; * are cleared by writing a &squot;1&squot;, while enable registers are cleared&n;&t;&t; * by writing a &squot;0&squot;.&n;&t;&t; */
id|acpi_os_out8
(paren
id|acpi_gbl_gpe_registers
(braket
id|register_index
)braket
dot
id|enable_addr
comma
l_int|0x00
)paren
suffix:semicolon
id|acpi_os_out8
(paren
id|acpi_gbl_gpe_registers
(braket
id|register_index
)braket
dot
id|status_addr
comma
l_int|0xFF
)paren
suffix:semicolon
id|register_index
op_increment
suffix:semicolon
)brace
multiline_comment|/* GPE Block 1 */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|gpe1_register_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|acpi_gbl_gpe_registers
(braket
id|register_index
)braket
dot
id|status_addr
op_assign
(paren
id|u16
)paren
(paren
id|acpi_gbl_FACP-&gt;gpe1_blk
op_plus
id|i
)paren
suffix:semicolon
id|acpi_gbl_gpe_registers
(braket
id|register_index
)braket
dot
id|enable_addr
op_assign
(paren
id|u16
)paren
(paren
id|acpi_gbl_FACP-&gt;gpe1_blk
op_plus
id|i
op_plus
id|gpe1_register_count
)paren
suffix:semicolon
id|acpi_gbl_gpe_registers
(braket
id|register_index
)braket
dot
id|gpe_base
op_assign
(paren
id|u8
)paren
(paren
id|acpi_gbl_FACP-&gt;gpe1_base
op_plus
id|MUL_8
(paren
id|i
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
)paren
(brace
id|gpe_number
op_assign
id|acpi_gbl_gpe_registers
(braket
id|register_index
)braket
dot
id|gpe_base
op_plus
id|j
suffix:semicolon
id|acpi_gbl_gpe_valid
(braket
id|gpe_number
)braket
op_assign
(paren
id|u8
)paren
id|register_index
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Clear the status/enable registers.  Note that status registers&n;&t;&t; * are cleared by writing a &squot;1&squot;, while enable registers are cleared&n;&t;&t; * by writing a &squot;0&squot;.&n;&t;&t; */
id|acpi_os_out8
(paren
id|acpi_gbl_gpe_registers
(braket
id|register_index
)braket
dot
id|enable_addr
comma
l_int|0x00
)paren
suffix:semicolon
id|acpi_os_out8
(paren
id|acpi_gbl_gpe_registers
(braket
id|register_index
)braket
dot
id|status_addr
comma
l_int|0xFF
)paren
suffix:semicolon
id|register_index
op_increment
suffix:semicolon
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_save_method_info&n; *&n; * PARAMETERS:  None&n; *&n; * RETURN:      None&n; *&n; * DESCRIPTION: Called from Acpi_walk_namespace. Expects each object to be a&n; *              control method under the _GPE portion of the namespace.&n; *              Extract the name and GPE type from the object, saving this&n; *              information for quick lookup during GPE dispatch&n; *&n; *              The name of each GPE control method is of the form:&n; *                  &quot;_Lnn&quot; or &quot;_Enn&quot;&n; *              Where:&n; *                  L      - means that the GPE is level triggered&n; *                  E      - means that the GPE is edge triggered&n; *                  nn     - is the GPE number&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_save_method_info
id|acpi_ev_save_method_info
(paren
id|ACPI_HANDLE
id|obj_handle
comma
id|u32
id|level
comma
r_void
op_star
id|obj_desc
comma
r_void
op_star
op_star
id|return_value
)paren
(brace
id|u32
id|gpe_number
suffix:semicolon
r_char
id|name
(braket
id|ACPI_NAME_SIZE
op_plus
l_int|1
)braket
suffix:semicolon
id|u8
id|type
suffix:semicolon
multiline_comment|/* Extract the name from the object and convert to a string */
id|MOVE_UNALIGNED32_TO_32
(paren
id|name
comma
op_amp
(paren
(paren
id|ACPI_NAMED_OBJECT
op_star
)paren
id|obj_handle
)paren
op_member_access_from_pointer
id|name
)paren
suffix:semicolon
id|name
(braket
id|ACPI_NAME_SIZE
)braket
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Edge/Level determination is based on the 2nd char of the method name&n;&t; */
r_if
c_cond
(paren
id|name
(braket
l_int|1
)braket
op_eq
l_char|&squot;L&squot;
)paren
(brace
id|type
op_assign
id|ACPI_EVENT_LEVEL_TRIGGERED
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|name
(braket
l_int|1
)braket
op_eq
l_char|&squot;E&squot;
)paren
(brace
id|type
op_assign
id|ACPI_EVENT_EDGE_TRIGGERED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Unknown method type, just ignore it! */
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/* Convert the last two characters of the name to the Gpe Number */
id|gpe_number
op_assign
id|STRTOUL
(paren
op_amp
id|name
(braket
l_int|2
)braket
comma
l_int|NULL
comma
l_int|16
)paren
suffix:semicolon
r_if
c_cond
(paren
id|gpe_number
op_eq
id|ACPI_UINT32_MAX
)paren
(brace
multiline_comment|/* Conversion failed; invalid method, just ignore it */
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/* Ensure that we have a valid GPE number */
r_if
c_cond
(paren
id|acpi_gbl_gpe_valid
(braket
id|gpe_number
)braket
op_eq
id|ACPI_GPE_INVALID
)paren
(brace
multiline_comment|/* Not valid, all we can do here is ignore it */
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Now we can add this information to the Gpe_info block&n;&t; * for use during dispatch of this GPE.&n;&t; */
id|acpi_gbl_gpe_info
(braket
id|gpe_number
)braket
dot
id|type
op_assign
id|type
suffix:semicolon
id|acpi_gbl_gpe_info
(braket
id|gpe_number
)braket
dot
id|method_handle
op_assign
id|obj_handle
suffix:semicolon
multiline_comment|/*&n;&t; * Enable the GPE (SCIs should be disabled at this point)&n;&t; */
id|acpi_hw_enable_gpe
(paren
id|gpe_number
)paren
suffix:semicolon
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_init_gpe_control_methods&n; *&n; * PARAMETERS:  None&n; *&n; * RETURN:      None&n; *&n; * DESCRIPTION: Obtain the control methods associated with the GPEs.&n; *&n; *              NOTE: Must be called AFTER namespace initialization!&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_init_gpe_control_methods
id|acpi_ev_init_gpe_control_methods
(paren
r_void
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
multiline_comment|/* Get a permanent handle to the _GPE object */
id|status
op_assign
id|acpi_get_handle
(paren
l_int|NULL
comma
l_string|&quot;&bslash;&bslash;_GPE&quot;
comma
op_amp
id|acpi_gbl_gpe_obj_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* Traverse the namespace under &bslash;_GPE to find all methods there */
id|status
op_assign
id|acpi_walk_namespace
(paren
id|ACPI_TYPE_METHOD
comma
id|acpi_gbl_gpe_obj_handle
comma
id|ACPI_INT32_MAX
comma
id|acpi_ev_save_method_info
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_gpe_cleanup&n; *&n; * PARAMETERS:  None&n; *&n; * RETURN:      None&n; *&n; * DESCRIPTION: Cleanup in preparation for unload.&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ev_gpe_cleanup
id|acpi_ev_gpe_cleanup
(paren
r_void
)paren
(brace
id|acpi_cm_free
(paren
id|acpi_gbl_gpe_registers
)paren
suffix:semicolon
id|acpi_cm_free
(paren
id|acpi_gbl_gpe_info
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_gpe_detect&n; *&n; * PARAMETERS:  None&n; *&n; * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED&n; *&n; * DESCRIPTION: Detect if any GP events have occurred&n; *&n; ******************************************************************************/
id|u32
DECL|function|acpi_ev_gpe_detect
id|acpi_ev_gpe_detect
(paren
r_void
)paren
(brace
id|u32
id|int_status
op_assign
id|INTERRUPT_NOT_HANDLED
suffix:semicolon
id|u32
id|i
suffix:semicolon
id|u32
id|j
suffix:semicolon
id|u8
id|enabled_status_byte
suffix:semicolon
id|u8
id|bit_mask
suffix:semicolon
multiline_comment|/*&n;&t; * Read all of the 8-bit GPE status and enable registers&n;&t; * in both of the register blocks, saving all of it.&n;&t; * Find all currently active GP events.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|acpi_gbl_gpe_register_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|acpi_gbl_gpe_registers
(braket
id|i
)braket
dot
id|status
op_assign
id|acpi_os_in8
(paren
id|acpi_gbl_gpe_registers
(braket
id|i
)braket
dot
id|status_addr
)paren
suffix:semicolon
id|acpi_gbl_gpe_registers
(braket
id|i
)braket
dot
id|enable
op_assign
id|acpi_os_in8
(paren
id|acpi_gbl_gpe_registers
(braket
id|i
)braket
dot
id|enable_addr
)paren
suffix:semicolon
multiline_comment|/* First check if there is anything active at all in this register */
id|enabled_status_byte
op_assign
(paren
id|u8
)paren
(paren
id|acpi_gbl_gpe_registers
(braket
id|i
)braket
dot
id|status
op_amp
id|acpi_gbl_gpe_registers
(braket
id|i
)braket
dot
id|enable
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|enabled_status_byte
)paren
(brace
multiline_comment|/* No active GPEs in this register, move on */
r_continue
suffix:semicolon
)brace
multiline_comment|/* Now look at the individual GPEs in this byte register */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
comma
id|bit_mask
op_assign
l_int|1
suffix:semicolon
id|j
OL
l_int|8
suffix:semicolon
id|j
op_increment
comma
id|bit_mask
op_lshift_assign
l_int|1
)paren
(brace
multiline_comment|/* Examine one GPE bit */
r_if
c_cond
(paren
id|enabled_status_byte
op_amp
id|bit_mask
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Found an active GPE.  Dispatch the event to a handler&n;&t;&t;&t;&t; * or method.&n;&t;&t;&t;&t; */
id|int_status
op_or_assign
id|acpi_ev_gpe_dispatch
(paren
id|acpi_gbl_gpe_registers
(braket
id|i
)braket
dot
id|gpe_base
op_plus
id|j
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
id|int_status
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_asynch_execute_gpe_method&n; *&n; * PARAMETERS:  Gpe_number      - The 0-based Gpe number&n; *&n; * RETURN:      None&n; *&n; * DESCRIPTION: Perform the actual execution of a GPE control method.  This&n; *              function is called from an invocation of Acpi_os_queue_for_execution&n; *              (and therefore does NOT execute at interrupt level) so that&n; *              the control method itself is not executed in the context of&n; *              the SCI interrupt handler.&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ev_asynch_execute_gpe_method
id|acpi_ev_asynch_execute_gpe_method
(paren
r_void
op_star
id|context
)paren
(brace
id|u32
id|gpe_number
op_assign
(paren
id|u32
)paren
id|context
suffix:semicolon
id|ACPI_GPE_LEVEL_INFO
id|gpe_info
suffix:semicolon
multiline_comment|/* Take a snapshot of the GPE info for this level */
id|acpi_cm_acquire_mutex
(paren
id|ACPI_MTX_EVENTS
)paren
suffix:semicolon
id|gpe_info
op_assign
id|acpi_gbl_gpe_info
(braket
id|gpe_number
)braket
suffix:semicolon
id|acpi_cm_release_mutex
(paren
id|ACPI_MTX_EVENTS
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Function Handler (e.g. EC):&n;&t; * ---------------------------&n;&t; * Execute the installed function handler to handle this event.&n;&t; */
r_if
c_cond
(paren
id|gpe_info.handler
)paren
(brace
id|gpe_info.handler
(paren
id|gpe_info.context
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Method Handler (_Lxx, _Exx):&n;&t; * ----------------------------&n;&t; * Acpi_evaluate the _Lxx/_Exx control method that corresponds to this GPE.&n;&t; */
r_else
r_if
c_cond
(paren
id|gpe_info.method_handle
)paren
(brace
id|acpi_ns_evaluate_by_handle
(paren
id|gpe_info.method_handle
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Level-Triggered?&n;&t; * ----------------&n;&t; * If level-triggered, clear the GPE status bit after execution.  Note&n;&t; * that edge-triggered events are cleared prior to calling (via DPC)&n;&t; * this function.&n;&t; */
r_if
c_cond
(paren
id|gpe_info.type
op_or
id|ACPI_EVENT_LEVEL_TRIGGERED
)paren
(brace
id|acpi_hw_clear_gpe
(paren
id|gpe_number
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Enable the GPE.&n;&t; */
id|acpi_hw_enable_gpe
(paren
id|gpe_number
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_gpe_dispatch&n; *&n; * PARAMETERS:  Gpe_number      - The 0-based Gpe number&n; *&n; * RETURN:      INTERRUPT_HANDLED or INTERRUPT_NOT_HANDLED&n; *&n; * DESCRIPTION: Handle and dispatch a General Purpose Acpi_event.&n; *              Clears the status bit for the requested event.&n; *&n; * TBD: [Investigate] is this still valid or necessary:&n; * The Gpe handler differs from the fixed events in that it clears the enable&n; * bit rather than the status bit to clear the interrupt.  This allows&n; * software outside of interrupt context to determine what caused the SCI and&n; * dispatch the correct AML.&n; *&n; ******************************************************************************/
id|u32
DECL|function|acpi_ev_gpe_dispatch
id|acpi_ev_gpe_dispatch
(paren
id|u32
id|gpe_number
)paren
(brace
multiline_comment|/*DEBUG_INCREMENT_EVENT_COUNT (EVENT_GENERAL);*/
multiline_comment|/* Ensure that we have a valid GPE number */
r_if
c_cond
(paren
id|acpi_gbl_gpe_valid
(braket
id|gpe_number
)braket
op_eq
id|ACPI_GPE_INVALID
)paren
(brace
r_return
(paren
id|INTERRUPT_NOT_HANDLED
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Disable the GPE.&n;&t; */
id|acpi_hw_disable_gpe
(paren
id|gpe_number
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Edge-Triggered?&n;&t; * ---------------&n;&t; * If edge-triggered, clear the GPE status bit now.  Note that&n;&t; * level-triggered events are cleared after the GPE is serviced&n;&t; * (see Acpi_ev_asynch_execute_gpe_method).&n;&t; */
r_if
c_cond
(paren
id|acpi_gbl_gpe_info
(braket
id|gpe_number
)braket
dot
id|type
op_or
id|ACPI_EVENT_EDGE_TRIGGERED
)paren
(brace
id|acpi_hw_clear_gpe
(paren
id|gpe_number
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Queue-up the Handler:&n;&t; * ---------------------&n;&t; * Queue the handler, which is either an installable function handler&n;&t; * (e.g. EC) or a control method (e.g. _Lxx/_Exx) for later execution.&n;&t; */
r_if
c_cond
(paren
id|acpi_gbl_gpe_info
(braket
id|gpe_number
)braket
dot
id|handler
op_logical_or
id|acpi_gbl_gpe_info
(braket
id|gpe_number
)braket
dot
id|method_handle
)paren
(brace
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|acpi_os_queue_for_execution
(paren
id|OSD_PRIORITY_GPE
comma
id|acpi_ev_asynch_execute_gpe_method
comma
(paren
r_void
op_star
)paren
(paren
id|NATIVE_UINT
)paren
id|gpe_number
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Shoudn&squot;t occur, but if it does report an error. Note that&n;&t;&t;&t; * the GPE will remain disabled until the ACPI Core Subsystem&n;&t;&t;&t; * is restarted, or the handler is removed/reinstalled.&n;&t;&t;&t; */
id|REPORT_ERROR
(paren
l_string|&quot;Unable to queue-up handler for GPE.&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Non Handled GPEs:&n;&t; * -----------------&n;&t; * GPEs without handlers are disabled and kept that way until a handler&n;&t; * is registered for them.&n;&t; */
r_else
(brace
id|REPORT_ERROR
(paren
l_string|&quot;No installed handler for GPE.&quot;
)paren
suffix:semicolon
)brace
r_return
(paren
id|INTERRUPT_HANDLED
)paren
suffix:semicolon
)brace
eof
