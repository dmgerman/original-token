multiline_comment|/******************************************************************************&n; *&n; * Module Name: evregion - ACPI Address_space / Op_region handler dispatch&n; *              $Revision: 76 $&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;acevents.h&quot;
macro_line|#include &quot;acnamesp.h&quot;
macro_line|#include &quot;acinterp.h&quot;
macro_line|#include &quot;amlcode.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          EVENT_HANDLING
id|MODULE_NAME
(paren
l_string|&quot;evregion&quot;
)paren
DECL|macro|PCI_ROOT_HID_STRING
mdefine_line|#define PCI_ROOT_HID_STRING        &quot;PNP0A03&quot;
DECL|macro|PCI_ROOT_HID_VALUE
mdefine_line|#define PCI_ROOT_HID_VALUE         0x030AD041       /* EISAID(&quot;PNP0A03&quot;) */
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_find_one_pci_root_bus&n; *&n; * PARAMETERS:&n; *&n; * RETURN:      None&n; *&n; * DESCRIPTION:&n; *&n; *****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_find_one_pci_root_bus
id|acpi_ev_find_one_pci_root_bus
(paren
id|ACPI_HANDLE
id|obj_handle
comma
id|u32
id|nesting_level
comma
r_void
op_star
id|context
comma
r_void
op_star
op_star
id|return_value
)paren
(brace
id|ACPI_NAMESPACE_NODE
op_star
id|node
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
suffix:semicolon
id|ACPI_STATUS
id|status
suffix:semicolon
id|node
op_assign
(paren
id|ACPI_NAMESPACE_NODE
op_star
)paren
id|obj_handle
suffix:semicolon
id|obj_desc
op_assign
(paren
(paren
id|ACPI_NAMESPACE_NODE
op_star
)paren
id|obj_handle
)paren
op_member_access_from_pointer
id|object
suffix:semicolon
multiline_comment|/*&n;&t; * We are looking for all valid _HID objects.&n;&t; */
r_if
c_cond
(paren
id|STRNCMP
(paren
(paren
id|NATIVE_CHAR
op_star
)paren
op_amp
id|node-&gt;name
comma
id|METHOD_NAME__HID
comma
id|ACPI_NAME_SIZE
)paren
op_logical_or
(paren
op_logical_neg
id|obj_desc
)paren
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Found an _HID object.&n;&t; * Now we need a HID with the value EISAID(&quot;PNP0A03&quot;)&n;&t; * HID can be either a number or a string.&n;&t; */
r_switch
c_cond
(paren
id|obj_desc-&gt;common.type
)paren
(brace
r_case
id|ACPI_TYPE_NUMBER
suffix:colon
r_if
c_cond
(paren
id|obj_desc-&gt;number.value
op_ne
id|PCI_ROOT_HID_VALUE
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|ACPI_TYPE_STRING
suffix:colon
r_if
c_cond
(paren
id|STRNCMP
(paren
id|obj_desc-&gt;string.pointer
comma
id|PCI_ROOT_HID_STRING
comma
r_sizeof
(paren
id|PCI_ROOT_HID_STRING
)paren
)paren
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We found a valid PCI_ROOT_HID.&n;&t; * The parent of the HID entry is the PCI device;  Install the default PCI&n;&t; * handler for this PCI device.&n;&t; */
id|status
op_assign
id|acpi_install_address_space_handler
(paren
id|acpi_ns_get_parent_object
(paren
id|node
)paren
comma
id|ADDRESS_SPACE_PCI_CONFIG
comma
id|ACPI_DEFAULT_HANDLER
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_find_pci_root_buses&n; *&n; * PARAMETERS:&n; *&n; * RETURN:      None&n; *&n; * DESCRIPTION:&n; *&n; *****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_find_pci_root_buses
id|acpi_ev_find_pci_root_buses
(paren
r_void
)paren
(brace
id|acpi_ns_walk_namespace
(paren
id|ACPI_TYPE_ANY
comma
id|ACPI_ROOT_OBJECT
comma
id|ACPI_UINT32_MAX
comma
id|FALSE
comma
id|acpi_ev_find_one_pci_root_bus
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_init_one_device&n; *&n; * PARAMETERS:  The usual &quot;I&squot;m a namespace callback&quot; stuff&n; *&n; * RETURN:      ACPI_STATUS&n; *&n; * DESCRIPTION: This is called once per device soon after ACPI is enabled&n; *              to initialize each device. It determines if the device is&n; *              present, and if so, calls _INI.&n; *&n; *****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_init_one_device
id|acpi_ev_init_one_device
(paren
id|ACPI_HANDLE
id|obj_handle
comma
id|u32
id|nesting_level
comma
r_void
op_star
id|context
comma
r_void
op_star
op_star
id|return_value
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|ret_obj
suffix:semicolon
multiline_comment|/*&n;&t; * Run _STA to determine if we can run _INI on the device.&n;&t; */
id|status
op_assign
id|acpi_ns_evaluate_relative
c_func
(paren
id|obj_handle
comma
l_string|&quot;_STA&quot;
comma
l_int|NULL
comma
op_amp
id|ret_obj
)paren
suffix:semicolon
r_if
c_cond
(paren
id|AE_NOT_FOUND
op_eq
id|status
)paren
(brace
multiline_comment|/* No _STA means device is present */
)brace
r_else
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ret_obj
)paren
(brace
r_if
c_cond
(paren
id|ACPI_TYPE_NUMBER
op_ne
id|ret_obj-&gt;common.type
)paren
(brace
id|status
op_assign
id|AE_AML_OPERAND_TYPE
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * if _STA &quot;present&quot; bit not set, we&squot;re done.&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|ret_obj-&gt;number.value
op_amp
l_int|1
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * The device is present. Run _INI.&n;&t; */
id|status
op_assign
id|acpi_ns_evaluate_relative
c_func
(paren
id|obj_handle
comma
l_string|&quot;_INI&quot;
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
id|cleanup
suffix:colon
id|acpi_cm_remove_reference
(paren
id|ret_obj
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_init_devices&n; *&n; * PARAMETERS:  None&n; *&n; * RETURN:      ACPI_STATUS&n; *&n; * DESCRIPTION: This initializes all ACPI devices.&n; *&n; *****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_init_devices
id|acpi_ev_init_devices
(paren
r_void
)paren
(brace
id|acpi_ns_walk_namespace
(paren
id|ACPI_TYPE_ANY
comma
id|ACPI_ROOT_OBJECT
comma
id|ACPI_UINT32_MAX
comma
id|FALSE
comma
id|acpi_ev_init_one_device
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_install_default_address_space_handlers&n; *&n; * PARAMETERS:&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Installs the core subsystem address space handlers.&n; *&n; *************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_install_default_address_space_handlers
id|acpi_ev_install_default_address_space_handlers
(paren
r_void
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
multiline_comment|/*&n;&t; * NOTE:    All address spaces (PCI Config, EC, SMBus) are scope dependent&n;&t; *          and registration must occur for a specific device.  In the case&n;&t; *          system memory and IO address spaces there is currently no device&n;&t; *          associated with the address space.  For these we use the root.&n;&t; */
id|status
op_assign
id|acpi_install_address_space_handler
(paren
id|acpi_gbl_root_node
comma
id|ADDRESS_SPACE_SYSTEM_MEMORY
comma
id|ACPI_DEFAULT_HANDLER
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
id|status
op_assign
id|acpi_install_address_space_handler
(paren
id|acpi_gbl_root_node
comma
id|ADDRESS_SPACE_SYSTEM_IO
comma
id|ACPI_DEFAULT_HANDLER
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* TBD: [Restructure] Move to the methods directory */
multiline_comment|/**************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_execute_reg_method&n; *&n; * PARAMETERS:  Region_obj          - Object structure&n; *              Function            - On (1) or Off (0)&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Execute _REG method for a region&n; *&n; *************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_execute_reg_method
id|acpi_ev_execute_reg_method
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|region_obj
comma
id|u32
id|function
)paren
(brace
id|ACPI_OPERAND_OBJECT
op_star
id|params
(braket
l_int|3
)braket
suffix:semicolon
id|ACPI_OPERAND_OBJECT
id|space_iD_obj
suffix:semicolon
id|ACPI_OPERAND_OBJECT
id|function_obj
suffix:semicolon
id|ACPI_STATUS
id|status
suffix:semicolon
r_if
c_cond
(paren
id|region_obj-&gt;region.REGmethod
op_eq
l_int|NULL
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  _REG method has two arguments&n;&t; *  Arg0:   Integer: Operation region space ID&n;&t; *          Same value as Region_obj-&gt;Region.Space_id&n;&t; *  Arg1:   Integer: connection status&n;&t; *          1 for connecting the handler,&n;&t; *          0 for disconnecting the handler&n;&t; *          Passed as a parameter&n;&t; */
id|acpi_cm_init_static_object
(paren
op_amp
id|space_iD_obj
)paren
suffix:semicolon
id|acpi_cm_init_static_object
(paren
op_amp
id|function_obj
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Method requires two parameters.&n;&t; */
id|params
(braket
l_int|0
)braket
op_assign
op_amp
id|space_iD_obj
suffix:semicolon
id|params
(braket
l_int|1
)braket
op_assign
op_amp
id|function_obj
suffix:semicolon
id|params
(braket
l_int|2
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *  Set up the parameter objects&n;&t; */
id|space_iD_obj.common.type
op_assign
id|ACPI_TYPE_NUMBER
suffix:semicolon
id|space_iD_obj.number.value
op_assign
id|region_obj-&gt;region.space_id
suffix:semicolon
id|function_obj.common.type
op_assign
id|ACPI_TYPE_NUMBER
suffix:semicolon
id|function_obj.number.value
op_assign
id|function
suffix:semicolon
multiline_comment|/*&n;&t; *  Execute the method, no return value&n;&t; */
id|status
op_assign
id|acpi_ns_evaluate_by_handle
(paren
id|region_obj-&gt;region.REGmethod
comma
id|params
comma
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_address_space_dispatch&n; *&n; * PARAMETERS:  Region_obj          - internal region object&n; *              Space_id            - ID of the address space (0-255)&n; *              Function            - Read or Write operation&n; *              Address             - Where in the space to read or write&n; *              Bit_width           - Field width in bits (8, 16, or 32)&n; *              Value               - Pointer to in or out value&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Dispatch an address space or operation region access to&n; *              a previously installed handler.&n; *&n; *************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_address_space_dispatch
id|acpi_ev_address_space_dispatch
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|region_obj
comma
id|u32
id|function
comma
id|u32
id|address
comma
id|u32
id|bit_width
comma
id|u32
op_star
id|value
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|ADDRESS_SPACE_HANDLER
id|handler
suffix:semicolon
id|ADDRESS_SPACE_SETUP
id|region_setup
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|handler_desc
suffix:semicolon
r_void
op_star
id|region_context
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; *  Check for an installed handler&n;&t; */
id|handler_desc
op_assign
id|region_obj-&gt;region.addr_handler
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handler_desc
)paren
(brace
r_return
id|AE_EXIST
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  It may be the case that the region has never been initialized&n;&t; *  Some types of regions require special init code&n;&t; */
r_if
c_cond
(paren
op_logical_neg
(paren
id|region_obj-&gt;region.flags
op_amp
id|AOPOBJ_INITIALIZED
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *  This region has not been initialized yet, do it&n;&t;&t; */
id|region_setup
op_assign
id|handler_desc-&gt;addr_handler.setup
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|region_setup
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  Bad news, no init routine and not init&squot;d&n;&t;&t;&t; */
r_return
(paren
id|AE_UNKNOWN_STATUS
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * We must exit the interpreter because the region setup will potentially&n;&t;&t; * execute control methods&n;&t;&t; */
id|acpi_aml_exit_interpreter
(paren
)paren
suffix:semicolon
id|status
op_assign
id|region_setup
(paren
id|region_obj
comma
id|ACPI_REGION_ACTIVATE
comma
id|handler_desc-&gt;addr_handler.context
comma
op_amp
id|region_context
)paren
suffix:semicolon
multiline_comment|/* Re-enter the interpreter */
id|acpi_aml_enter_interpreter
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; *  Init routine may fail&n;&t;&t; */
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
id|status
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Save the returned context for use in all accesses to&n;&t;&t; *  this particular region.&n;&t;&t; */
id|region_obj-&gt;region.region_context
op_assign
id|region_context
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  We have everything we need, begin the process&n;&t; */
id|handler
op_assign
id|handler_desc-&gt;addr_handler.handler
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|handler_desc-&gt;addr_handler.flags
op_amp
id|ADDR_HANDLER_DEFAULT_INSTALLED
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *  For handlers other than the default (supplied) handlers, we must&n;&t;&t; *  exit the interpreter because the handler *might* block -- we don&squot;t&n;&t;&t; *  know what it will do, so we can&squot;t hold the lock on the intepreter.&n;&t;&t; */
id|acpi_aml_exit_interpreter
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Invoke the handler.&n;&t; */
id|status
op_assign
id|handler
(paren
id|function
comma
id|address
comma
id|bit_width
comma
id|value
comma
id|handler_desc-&gt;addr_handler.context
comma
id|region_obj-&gt;region.region_context
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|handler_desc-&gt;addr_handler.flags
op_amp
id|ADDR_HANDLER_DEFAULT_INSTALLED
)paren
)paren
(brace
multiline_comment|/* We just returned from a non-default handler, we must re-enter the&n;&t;&t;interpreter */
id|acpi_aml_enter_interpreter
(paren
)paren
suffix:semicolon
)brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_disassociate_region_and_handler&n; *&n; * PARAMETERS:  Handler_obj     - Handler Object&n; *              Region_obj      - Region Object&n; *&n; * RETURN:      None&n; *&n; * DESCRIPTION: Break the association between the handler and the region&n; *              this is a two way association.&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ev_disassociate_region_from_handler
id|acpi_ev_disassociate_region_from_handler
c_func
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|region_obj
)paren
(brace
id|ACPI_OPERAND_OBJECT
op_star
id|handler_obj
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
op_star
id|last_obj_ptr
suffix:semicolon
id|ADDRESS_SPACE_SETUP
id|region_setup
suffix:semicolon
r_void
op_star
id|region_context
op_assign
id|region_obj-&gt;region.region_context
suffix:semicolon
id|ACPI_STATUS
id|status
suffix:semicolon
multiline_comment|/*&n;&t; *  Get the address handler from the region object&n;&t; */
id|handler_obj
op_assign
id|region_obj-&gt;region.addr_handler
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|handler_obj
)paren
(brace
multiline_comment|/*&n;&t;&t; *  This region has no handler, all done&n;&t;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Find this region in the handler&squot;s list&n;&t; */
id|obj_desc
op_assign
id|handler_obj-&gt;addr_handler.region_list
suffix:semicolon
id|last_obj_ptr
op_assign
op_amp
id|handler_obj-&gt;addr_handler.region_list
suffix:semicolon
r_while
c_loop
(paren
id|obj_desc
)paren
(brace
multiline_comment|/*&n;&t;&t; *  See if this is the one&n;&t;&t; */
r_if
c_cond
(paren
id|obj_desc
op_eq
id|region_obj
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  This is it, remove it from the handler&squot;s list&n;&t;&t;&t; */
op_star
id|last_obj_ptr
op_assign
id|obj_desc-&gt;region.next
suffix:semicolon
id|obj_desc-&gt;region.next
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Must clear field */
multiline_comment|/*&n;&t;&t;&t; *  Now stop region accesses by executing the _REG method&n;&t;&t;&t; */
id|acpi_ev_execute_reg_method
(paren
id|region_obj
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Call the setup handler with the deactivate notification&n;&t;&t;&t; */
id|region_setup
op_assign
id|handler_obj-&gt;addr_handler.setup
suffix:semicolon
id|status
op_assign
id|region_setup
(paren
id|region_obj
comma
id|ACPI_REGION_DEACTIVATE
comma
id|handler_obj-&gt;addr_handler.context
comma
op_amp
id|region_context
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; *  Init routine may fail, Just ignore errors&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; *  Remove handler reference in the region&n;&t;&t;&t; *&n;&t;&t;&t; *  NOTE: this doesn&squot;t mean that the region goes away&n;&t;&t;&t; *  The region is just inaccessible as indicated to&n;&t;&t;&t; *  the _REG method&n;&t;&t;&t; *&n;&t;&t;&t; *  If the region is on the handler&squot;s list&n;&t;&t;&t; *  this better be the region&squot;s handler&n;&t;&t;&t; */
id|ACPI_ASSERT
(paren
id|region_obj-&gt;region.addr_handler
op_eq
id|handler_obj
)paren
suffix:semicolon
id|region_obj-&gt;region.addr_handler
op_assign
l_int|NULL
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* found the right handler */
multiline_comment|/*&n;&t;&t; *  Move through the linked list of handlers&n;&t;&t; */
id|last_obj_ptr
op_assign
op_amp
id|obj_desc-&gt;region.next
suffix:semicolon
id|obj_desc
op_assign
id|obj_desc-&gt;region.next
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  If we get here, the region was not in the handler&squot;s region list&n;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_associate_region_and_handler&n; *&n; * PARAMETERS:  Handler_obj     - Handler Object&n; *              Region_obj      - Region Object&n; *&n; * RETURN:      None&n; *&n; * DESCRIPTION: Create the association between the handler and the region&n; *              this is a two way association.&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_associate_region_and_handler
id|acpi_ev_associate_region_and_handler
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|handler_obj
comma
id|ACPI_OPERAND_OBJECT
op_star
id|region_obj
comma
id|u8
id|acpi_ns_is_locked
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|ACPI_ASSERT
(paren
id|region_obj-&gt;region.space_id
op_eq
id|handler_obj-&gt;addr_handler.space_id
)paren
suffix:semicolon
id|ACPI_ASSERT
(paren
id|region_obj-&gt;region.addr_handler
op_eq
l_int|0
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Link this region to the front of the handler&squot;s list&n;&t; */
id|region_obj-&gt;region.next
op_assign
id|handler_obj-&gt;addr_handler.region_list
suffix:semicolon
id|handler_obj-&gt;addr_handler.region_list
op_assign
id|region_obj
suffix:semicolon
multiline_comment|/*&n;&t; *  set the region&squot;s handler&n;&t; */
multiline_comment|/*&n;&t;Handler_obj-&gt;Common.Reference_count =&n;&t;&t;&t;  (u16) (Handler_obj-&gt;Common.Reference_count +&n;&t;&t;&t;  Region_obj-&gt;Common.Reference_count - 1);&n;*/
id|region_obj-&gt;region.addr_handler
op_assign
id|handler_obj
suffix:semicolon
multiline_comment|/*&n;&t; *  Last thing, tell all users that this region is usable&n;&t; */
r_if
c_cond
(paren
id|acpi_ns_is_locked
)paren
(brace
id|acpi_cm_release_mutex
(paren
id|ACPI_MTX_NAMESPACE
)paren
suffix:semicolon
)brace
id|status
op_assign
id|acpi_ev_execute_reg_method
(paren
id|region_obj
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_ns_is_locked
)paren
(brace
id|acpi_cm_acquire_mutex
(paren
id|ACPI_MTX_NAMESPACE
)paren
suffix:semicolon
)brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_addr_handler_helper&n; *&n; * PARAMETERS:  Handle              - Node to be dumped&n; *              Level               - Nesting level of the handle&n; *              Context             - Passed into Acpi_ns_walk_namespace&n; *&n; * DESCRIPTION: This routine checks to see if the object is a Region if it&n; *              is then the address handler is installed in it.&n; *&n; *              If the Object is a Device, and the device has a handler of&n; *              the same type then the search is terminated in that branch.&n; *&n; *              This is because the existing handler is closer in proximity&n; *              to any more regions than the one we are trying to install.&n; *&n; ***************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_addr_handler_helper
id|acpi_ev_addr_handler_helper
(paren
id|ACPI_HANDLE
id|obj_handle
comma
id|u32
id|level
comma
r_void
op_star
id|context
comma
r_void
op_star
op_star
id|return_value
)paren
(brace
id|ACPI_OPERAND_OBJECT
op_star
id|handler_obj
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|tmp_obj
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
suffix:semicolon
id|ACPI_NAMESPACE_NODE
op_star
id|node
suffix:semicolon
id|ACPI_STATUS
id|status
suffix:semicolon
id|handler_obj
op_assign
(paren
id|ACPI_OPERAND_OBJECT
op_star
)paren
id|context
suffix:semicolon
multiline_comment|/* Parameter validation */
r_if
c_cond
(paren
op_logical_neg
id|handler_obj
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Convert and validate the device handle */
id|node
op_assign
id|acpi_ns_convert_handle_to_entry
(paren
id|obj_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|node
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  We only care about regions.and objects&n;&t; *  that can have address handlers&n;&t; */
r_if
c_cond
(paren
(paren
id|node-&gt;type
op_ne
id|ACPI_TYPE_DEVICE
)paren
op_logical_and
(paren
id|node-&gt;type
op_ne
id|ACPI_TYPE_REGION
)paren
op_logical_and
(paren
id|node
op_ne
id|acpi_gbl_root_node
)paren
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for an existing internal object */
id|obj_desc
op_assign
id|acpi_ns_get_attached_object
(paren
(paren
id|ACPI_HANDLE
)paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj_desc
)paren
(brace
multiline_comment|/*&n;&t;&t; *  The object DNE, we don&squot;t care about it&n;&t;&t; */
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Devices are handled different than regions&n;&t; */
r_if
c_cond
(paren
id|IS_THIS_OBJECT_TYPE
(paren
id|obj_desc
comma
id|ACPI_TYPE_DEVICE
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *  See if this guy has any handlers&n;&t;&t; */
id|tmp_obj
op_assign
id|obj_desc-&gt;device.addr_handler
suffix:semicolon
r_while
c_loop
(paren
id|tmp_obj
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; *  Now let&squot;s see if it&squot;s for the same address space.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|tmp_obj-&gt;addr_handler.space_id
op_eq
id|handler_obj-&gt;addr_handler.space_id
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; *  It&squot;s for the same address space&n;&t;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t;&t; *  Since the object we found it on was a device, then it&n;&t;&t;&t;&t; *  means that someone has already installed a handler for&n;&t;&t;&t;&t; *  the branch of the namespace from this device on.  Just&n;&t;&t;&t;&t; *  bail out telling the walk routine to not traverse this&n;&t;&t;&t;&t; *  branch.  This preserves the scoping rule for handlers.&n;&t;&t;&t;&t; */
r_return
(paren
id|AE_CTRL_DEPTH
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; *  Move through the linked list of handlers&n;&t;&t;&t; */
id|tmp_obj
op_assign
id|tmp_obj-&gt;addr_handler.next
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  As long as the device didn&squot;t have a handler for this&n;&t;&t; *  space we don&squot;t care about it.  We just ignore it and&n;&t;&t; *  proceed.&n;&t;&t; */
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Only here if it was a region&n;&t; */
id|ACPI_ASSERT
(paren
id|obj_desc-&gt;common.type
op_eq
id|ACPI_TYPE_REGION
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj_desc-&gt;region.space_id
op_ne
id|handler_obj-&gt;addr_handler.space_id
)paren
(brace
multiline_comment|/*&n;&t;&t; *  This region is for a different address space&n;&t;&t; *  ignore it&n;&t;&t; */
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Now we have a region and it is for the handler&squot;s address&n;&t; *  space type.&n;&t; *&n;&t; *  First disconnect region for any previous handler (if any)&n;&t; */
id|acpi_ev_disassociate_region_from_handler
(paren
id|obj_desc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Then connect the region to the new handler&n;&t; */
id|status
op_assign
id|acpi_ev_associate_region_and_handler
(paren
id|handler_obj
comma
id|obj_desc
comma
id|FALSE
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
eof
