multiline_comment|/******************************************************************************&n; *&n; * Module Name: evmisc - ACPI device notification handler dispatch&n; *                       and ACPI Global Lock support&n; *              $Revision: 20 $&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;acevents.h&quot;
macro_line|#include &quot;acnamesp.h&quot;
macro_line|#include &quot;acinterp.h&quot;
macro_line|#include &quot;achware.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          EVENT_HANDLING
id|MODULE_NAME
(paren
l_string|&quot;evmisc&quot;
)paren
multiline_comment|/**************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_notify_dispatch&n; *&n; * PARAMETERS:&n; *&n; * RETURN:      None.&n; *&n; * DESCRIPTION: Dispatch a device notification event to a previously&n; *              installed handler.&n; *&n; *************************************************************************/
r_void
DECL|function|acpi_ev_notify_dispatch
id|acpi_ev_notify_dispatch
(paren
id|ACPI_HANDLE
id|device
comma
id|u32
id|notify_value
)paren
(brace
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|handler_obj
suffix:semicolon
id|NOTIFY_HANDLER
id|handler
suffix:semicolon
multiline_comment|/*&n;&t; * For value 1 (Ejection Request), some device method may need to be run.&n;&t; * For value 2 (Device Wake) if _PRW exists, the _PS0 method may need to be run.&n;&t; * For value 0x80 (Status Change) on the power button or sleep button,&n;&t; * initiate soft-off or sleep operation?&n;&t; */
r_switch
c_cond
(paren
id|notify_value
)paren
(brace
r_case
l_int|0
suffix:colon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Invoke a global notify handler if installed.&n;&t; * This is done _before_ we invoke the per-device handler attached to the device.&n;&t; */
r_if
c_cond
(paren
id|notify_value
op_le
id|MAX_SYS_NOTIFY
)paren
(brace
multiline_comment|/* Global system notification handler */
r_if
c_cond
(paren
id|acpi_gbl_sys_notify.handler
)paren
(brace
id|acpi_gbl_sys_notify.handler
(paren
id|device
comma
id|notify_value
comma
id|acpi_gbl_sys_notify.context
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Global driver notification handler */
r_if
c_cond
(paren
id|acpi_gbl_drv_notify.handler
)paren
(brace
id|acpi_gbl_drv_notify.handler
(paren
id|device
comma
id|notify_value
comma
id|acpi_gbl_drv_notify.context
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Get the notify object which must be attached to the device Node&n;&t; */
id|obj_desc
op_assign
id|acpi_ns_get_attached_object
(paren
(paren
id|ACPI_HANDLE
)paren
id|device
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj_desc
)paren
(brace
multiline_comment|/* There can be no notify handler for this device */
r_return
suffix:semicolon
)brace
multiline_comment|/* We have the notify object, Get the right handler */
r_if
c_cond
(paren
id|notify_value
op_le
id|MAX_SYS_NOTIFY
)paren
(brace
id|handler_obj
op_assign
id|obj_desc-&gt;device.sys_handler
suffix:semicolon
)brace
r_else
(brace
id|handler_obj
op_assign
id|obj_desc-&gt;device.drv_handler
suffix:semicolon
)brace
multiline_comment|/* Validate the handler */
r_if
c_cond
(paren
op_logical_neg
id|handler_obj
)paren
(brace
multiline_comment|/* There is no notify handler for this device */
r_return
suffix:semicolon
)brace
multiline_comment|/* There is a handler, invoke it */
id|handler
op_assign
id|handler_obj-&gt;notify_handler.handler
suffix:semicolon
id|handler
(paren
id|device
comma
id|notify_value
comma
id|handler_obj-&gt;notify_handler.context
)paren
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_global_lock_thread&n; *&n; * RETURN:      None&n; *&n; * DESCRIPTION: Invoked by SCI interrupt handler upon acquisition of the&n; *              Global Lock.  Simply signal all threads that are waiting&n; *              for the lock.&n; *&n; **************************************************************************/
r_static
r_void
DECL|function|acpi_ev_global_lock_thread
id|acpi_ev_global_lock_thread
(paren
r_void
op_star
id|context
)paren
(brace
multiline_comment|/* Signal threads that are waiting for the lock */
r_if
c_cond
(paren
id|acpi_gbl_global_lock_thread_count
)paren
(brace
multiline_comment|/* Send sufficient units to the semaphore */
id|acpi_os_signal_semaphore
(paren
id|acpi_gbl_global_lock_semaphore
comma
id|acpi_gbl_global_lock_thread_count
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/***************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_global_lock_handler&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Invoked directly from the SCI handler when a global lock&n; *              release interrupt occurs.  Grab the global lock and queue&n; *              the global lock thread for execution&n; *&n; **************************************************************************/
r_static
id|u32
DECL|function|acpi_ev_global_lock_handler
id|acpi_ev_global_lock_handler
(paren
r_void
op_star
id|context
)paren
(brace
id|u8
id|acquired
op_assign
id|FALSE
suffix:semicolon
r_void
op_star
id|global_lock
suffix:semicolon
multiline_comment|/*&n;&t; * Attempt to get the lock&n;&t; * If we don&squot;t get it now, it will be marked pending and we will&n;&t; * take another interrupt when it becomes free.&n;&t; */
id|global_lock
op_assign
id|acpi_gbl_FACS-&gt;global_lock
suffix:semicolon
id|ACPI_ACQUIRE_GLOBAL_LOCK
(paren
id|global_lock
comma
id|acquired
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acquired
)paren
(brace
multiline_comment|/* Got the lock, now wake all threads waiting for it */
id|acpi_gbl_global_lock_acquired
op_assign
id|TRUE
suffix:semicolon
multiline_comment|/* Run the Global Lock thread which will signal all waiting threads */
id|acpi_os_queue_for_execution
(paren
id|OSD_PRIORITY_HIGH
comma
id|acpi_ev_global_lock_thread
comma
id|context
)paren
suffix:semicolon
)brace
r_return
(paren
id|INTERRUPT_HANDLED
)paren
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_init_global_lock_handler&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Install a handler for the global lock release event&n; *&n; **************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_init_global_lock_handler
id|acpi_ev_init_global_lock_handler
(paren
r_void
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|status
op_assign
id|acpi_install_fixed_event_handler
(paren
id|ACPI_EVENT_GLOBAL
comma
id|acpi_ev_global_lock_handler
comma
l_int|NULL
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_acquire_global_lock&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Attempt to gain ownership of the Global Lock.&n; *&n; **************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ev_acquire_global_lock
id|acpi_ev_acquire_global_lock
c_func
(paren
r_void
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|u8
id|acquired
op_assign
id|FALSE
suffix:semicolon
r_void
op_star
id|global_lock
suffix:semicolon
multiline_comment|/* One more thread wants the global lock */
id|acpi_gbl_global_lock_thread_count
op_increment
suffix:semicolon
multiline_comment|/* If we (OS side) have the hardware lock already, we are done */
r_if
c_cond
(paren
id|acpi_gbl_global_lock_acquired
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Only if the FACS is valid */
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_FACS
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* We must acquire the actual hardware lock */
id|global_lock
op_assign
id|acpi_gbl_FACS-&gt;global_lock
suffix:semicolon
id|ACPI_ACQUIRE_GLOBAL_LOCK
(paren
id|global_lock
comma
id|acquired
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acquired
)paren
(brace
multiline_comment|/* We got the lock */
id|acpi_gbl_global_lock_acquired
op_assign
id|TRUE
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Did not get the lock.  The pending bit was set above, and we must now&n;&t; * wait until we get the global lock released interrupt.&n;&t; */
multiline_comment|/*&n;&t;  * Acquire the global lock semaphore first.&n;&t;  * Since this wait will block, we must release the interpreter&n;&t;  */
id|status
op_assign
id|acpi_aml_system_wait_semaphore
(paren
id|acpi_gbl_global_lock_semaphore
comma
id|ACPI_UINT32_MAX
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/***************************************************************************&n; *&n; * FUNCTION:    Acpi_ev_release_global_lock&n; *&n; * DESCRIPTION: Releases ownership of the Global Lock.&n; *&n; **************************************************************************/
r_void
DECL|function|acpi_ev_release_global_lock
id|acpi_ev_release_global_lock
(paren
r_void
)paren
(brace
id|u8
id|pending
op_assign
id|FALSE
suffix:semicolon
r_void
op_star
id|global_lock
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_global_lock_thread_count
)paren
(brace
id|REPORT_WARNING
c_func
(paren
(paren
l_string|&quot;Releasing a non-acquired Global Lock&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* One fewer thread has the global lock */
id|acpi_gbl_global_lock_thread_count
op_decrement
suffix:semicolon
multiline_comment|/* Have all threads released the lock? */
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_global_lock_thread_count
)paren
(brace
multiline_comment|/*&n;&t;&t; * No more threads holding lock, we can do the actual hardware&n;&t;&t; * release&n;&t;&t; */
id|global_lock
op_assign
id|acpi_gbl_FACS-&gt;global_lock
suffix:semicolon
id|ACPI_RELEASE_GLOBAL_LOCK
(paren
id|global_lock
comma
id|pending
)paren
suffix:semicolon
id|acpi_gbl_global_lock_acquired
op_assign
id|FALSE
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If the pending bit was set, we must write GBL_RLS to the control&n;&t;&t; * register&n;&t;&t; */
r_if
c_cond
(paren
id|pending
)paren
(brace
id|acpi_hw_register_bit_access
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_LOCK
comma
id|GBL_RLS
comma
l_int|1
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
eof
