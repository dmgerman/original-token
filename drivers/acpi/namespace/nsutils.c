multiline_comment|/******************************************************************************&n; *&n; * Module Name: nsutils - Utilities for accessing ACPI namespace, accessing&n; *                          parents and siblings and Scope manipulation&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;namesp.h&quot;
macro_line|#include &quot;interp.h&quot;
macro_line|#include &quot;amlcode.h&quot;
macro_line|#include &quot;tables.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          NAMESPACE
id|MODULE_NAME
(paren
l_string|&quot;nsutils&quot;
)paren
suffix:semicolon
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_valid_root_prefix&n; *&n; * PARAMETERS:  Prefix          - Character to be checked&n; *&n; * RETURN:      TRUE if a valid prefix&n; *&n; * DESCRIPTION: Check if a character is a valid ACPI Root prefix&n; *&n; ***************************************************************************/
id|u8
DECL|function|acpi_ns_valid_root_prefix
id|acpi_ns_valid_root_prefix
(paren
r_char
id|prefix
)paren
(brace
r_return
(paren
(paren
id|u8
)paren
(paren
id|prefix
op_eq
l_char|&squot;&bslash;&bslash;&squot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_valid_path_separator&n; *&n; * PARAMETERS:  Sep              - Character to be checked&n; *&n; * RETURN:      TRUE if a valid path separator&n; *&n; * DESCRIPTION: Check if a character is a valid ACPI path separator&n; *&n; ***************************************************************************/
id|u8
DECL|function|acpi_ns_valid_path_separator
id|acpi_ns_valid_path_separator
(paren
r_char
id|sep
)paren
(brace
r_return
(paren
(paren
id|u8
)paren
(paren
id|sep
op_eq
l_char|&squot;.&squot;
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_get_type&n; *&n; * PARAMETERS:  Handle              - Handle of nte to be examined&n; *&n; * RETURN:      Type field from nte whose handle is passed&n; *&n; ***************************************************************************/
id|OBJECT_TYPE_INTERNAL
DECL|function|acpi_ns_get_type
id|acpi_ns_get_type
(paren
id|ACPI_HANDLE
id|handle
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
(brace
multiline_comment|/*  Handle invalid  */
id|REPORT_WARNING
(paren
l_string|&quot;Ns_get_type: Null handle&quot;
)paren
suffix:semicolon
r_return
(paren
id|ACPI_TYPE_ANY
)paren
suffix:semicolon
)brace
r_return
(paren
(paren
(paren
id|ACPI_NAMED_OBJECT
op_star
)paren
id|handle
)paren
op_member_access_from_pointer
id|type
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_local&n; *&n; * PARAMETERS:  Type            - A namespace object type&n; *&n; * RETURN:      LOCAL if names must be found locally in objects of the&n; *              passed type, 0 if enclosing scopes should be searched&n; *&n; ***************************************************************************/
id|s32
DECL|function|acpi_ns_local
id|acpi_ns_local
(paren
id|OBJECT_TYPE_INTERNAL
id|type
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|acpi_cm_valid_object_type
(paren
id|type
)paren
)paren
(brace
multiline_comment|/*  type code out of range  */
id|REPORT_WARNING
(paren
l_string|&quot;Ns_local: Invalid Object Type&quot;
)paren
suffix:semicolon
r_return
(paren
id|NSP_NORMAL
)paren
suffix:semicolon
)brace
r_return
(paren
(paren
id|s32
)paren
id|acpi_gbl_ns_properties
(braket
id|type
)braket
op_amp
id|NSP_LOCAL
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_internalize_name&n; *&n; * PARAMETERS:  *External_name            - External representation of name&n; *              **Converted Name        - Where to return the resulting&n; *                                        internal represention of the name&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Convert an external representation (e.g. &quot;&bslash;_PR_.CPU0&quot;)&n; *              to internal form (e.g. 5c 2f 02 5f 50 52 5f 43 50 55 30)&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ns_internalize_name
id|acpi_ns_internalize_name
(paren
r_char
op_star
id|external_name
comma
r_char
op_star
op_star
id|converted_name
)paren
(brace
r_char
op_star
id|result
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|internal_name
suffix:semicolon
id|ACPI_SIZE
id|num_segments
suffix:semicolon
id|u8
id|fully_qualified
op_assign
id|FALSE
suffix:semicolon
id|u32
id|i
suffix:semicolon
r_if
c_cond
(paren
(paren
op_logical_neg
id|external_name
)paren
op_logical_or
(paren
op_star
id|external_name
op_eq
l_int|0
)paren
op_logical_or
(paren
op_logical_neg
id|converted_name
)paren
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * For the internal name, the required length is 4 bytes&n;&t; * per segment, plus 1 each for Root_prefix, Multi_name_prefix_op,&n;&t; * segment count, trailing null (which is not really needed,&n;&t; * but no there&squot;s harm in putting it there)&n;&t; *&n;&t; * strlen() + 1 covers the first Name_seg, which has no&n;&t; * path separator&n;&t; */
r_if
c_cond
(paren
id|acpi_ns_valid_root_prefix
(paren
id|external_name
(braket
l_int|0
)braket
)paren
)paren
(brace
id|fully_qualified
op_assign
id|TRUE
suffix:semicolon
id|external_name
op_increment
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Determine the number of ACPI name &quot;segments&quot; by counting&n;&t; * the number of path separators within the string.  Start&n;&t; * with one segment since the segment count is (# separators)&n;&t; * + 1, and zero separators is ok.&n;&t; */
id|num_segments
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|external_name
(braket
id|i
)braket
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|acpi_ns_valid_path_separator
(paren
id|external_name
(braket
id|i
)braket
)paren
)paren
(brace
id|num_segments
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* We need a segment to store the internal version of the name */
id|internal_name
op_assign
id|acpi_cm_callocate
(paren
(paren
id|ACPI_NAME_SIZE
op_star
id|num_segments
)paren
op_plus
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|internal_name
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
multiline_comment|/* Setup the correct prefixes, counts, and pointers */
r_if
c_cond
(paren
id|fully_qualified
)paren
(brace
id|internal_name
(braket
l_int|0
)braket
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
id|internal_name
(braket
l_int|1
)braket
op_assign
id|AML_MULTI_NAME_PREFIX_OP
suffix:semicolon
id|internal_name
(braket
l_int|2
)braket
op_assign
(paren
r_char
)paren
id|num_segments
suffix:semicolon
id|result
op_assign
op_amp
id|internal_name
(braket
l_int|3
)braket
suffix:semicolon
)brace
r_else
(brace
id|internal_name
(braket
l_int|0
)braket
op_assign
id|AML_MULTI_NAME_PREFIX_OP
suffix:semicolon
id|internal_name
(braket
l_int|1
)braket
op_assign
(paren
r_char
)paren
id|num_segments
suffix:semicolon
id|result
op_assign
op_amp
id|internal_name
(braket
l_int|2
)braket
suffix:semicolon
)brace
multiline_comment|/* Build the name (minus path separators) */
r_for
c_loop
(paren
suffix:semicolon
id|num_segments
suffix:semicolon
id|num_segments
op_decrement
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ACPI_NAME_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|acpi_ns_valid_path_separator
(paren
op_star
id|external_name
)paren
op_logical_or
(paren
op_star
id|external_name
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Pad the segment with underscore(s) if&n;&t;&t;&t;&t; * segment is short&n;&t;&t;&t;&t; */
id|result
(braket
id|i
)braket
op_assign
l_char|&squot;_&squot;
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Convert char to uppercase and save it */
id|result
(braket
id|i
)braket
op_assign
(paren
r_char
)paren
id|TOUPPER
(paren
op_star
id|external_name
)paren
suffix:semicolon
id|external_name
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Now we must have a path separator, or the pathname is bad */
r_if
c_cond
(paren
op_logical_neg
id|acpi_ns_valid_path_separator
(paren
op_star
id|external_name
)paren
op_logical_and
(paren
op_star
id|external_name
op_ne
l_int|0
)paren
)paren
(brace
id|acpi_cm_free
(paren
id|internal_name
)paren
suffix:semicolon
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/* Move on the next segment */
id|external_name
op_increment
suffix:semicolon
id|result
op_add_assign
id|ACPI_NAME_SIZE
suffix:semicolon
)brace
multiline_comment|/* Return the completed name */
multiline_comment|/* Terminate the string! */
op_star
id|result
op_assign
l_int|0
suffix:semicolon
op_star
id|converted_name
op_assign
id|internal_name
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_externalize_name&n; *&n; * PARAMETERS:  *Internal_name         - Internal representation of name&n; *              **Converted_name       - Where to return the resulting&n; *                                        external representation of name&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Convert internal name (e.g. 5c 2f 02 5f 50 52 5f 43 50 55 30)&n; *              to its external form (e.g. &quot;&bslash;_PR_.CPU0&quot;)&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ns_externalize_name
id|acpi_ns_externalize_name
(paren
id|u32
id|internal_name_length
comma
r_char
op_star
id|internal_name
comma
id|u32
op_star
id|converted_name_length
comma
r_char
op_star
op_star
id|converted_name
)paren
(brace
id|u32
id|prefix_length
op_assign
l_int|0
suffix:semicolon
id|u32
id|names_index
op_assign
l_int|0
suffix:semicolon
id|u32
id|names_count
op_assign
l_int|0
suffix:semicolon
id|u32
id|i
op_assign
l_int|0
suffix:semicolon
id|u32
id|j
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|internal_name_length
OL
l_int|0
op_logical_or
op_logical_neg
id|internal_name
op_logical_or
op_logical_neg
id|converted_name_length
op_logical_or
op_logical_neg
id|converted_name
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for a prefix (one &squot;&bslash;&squot; | one or more &squot;^&squot;).&n;&t; */
r_switch
c_cond
(paren
id|internal_name
(braket
l_int|0
)braket
)paren
(brace
r_case
l_char|&squot;&bslash;&bslash;&squot;
suffix:colon
id|prefix_length
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;^&squot;
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|internal_name_length
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|internal_name
(braket
id|i
)braket
op_ne
l_char|&squot;^&squot;
)paren
(brace
id|prefix_length
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|i
op_eq
id|internal_name_length
)paren
(brace
id|prefix_length
op_assign
id|i
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check for object names.  Note that there could be 0-255 of these&n;&t; * 4-byte elements.&n;&t; */
r_if
c_cond
(paren
id|prefix_length
OL
id|internal_name_length
)paren
(brace
r_switch
c_cond
(paren
id|internal_name
(braket
id|prefix_length
)braket
)paren
(brace
multiline_comment|/* &lt;count&gt; 4-byte names */
r_case
id|AML_MULTI_NAME_PREFIX_OP
suffix:colon
id|names_index
op_assign
id|prefix_length
op_plus
l_int|2
suffix:semicolon
id|names_count
op_assign
(paren
id|u32
)paren
id|internal_name
(braket
id|prefix_length
op_plus
l_int|1
)braket
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* two 4-byte names */
r_case
id|AML_DUAL_NAME_PREFIX
suffix:colon
id|names_index
op_assign
id|prefix_length
op_plus
l_int|1
suffix:semicolon
id|names_count
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Null_name */
r_case
l_int|0
suffix:colon
id|names_index
op_assign
l_int|0
suffix:semicolon
id|names_count
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* one 4-byte name */
r_default
suffix:colon
id|names_index
op_assign
id|prefix_length
suffix:semicolon
id|names_count
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Calculate the length of Converted_name, which equals the length&n;&t; * of the prefix, length of all object names, length of any required&n;&t; * punctuation (&squot;.&squot;) between object names, plus the NULL terminator.&n;&t; */
op_star
id|converted_name_length
op_assign
id|prefix_length
op_plus
(paren
l_int|4
op_star
id|names_count
)paren
op_plus
(paren
(paren
id|names_count
OG
l_int|0
)paren
ques
c_cond
(paren
id|names_count
op_minus
l_int|1
)paren
suffix:colon
l_int|0
)paren
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; * Check to see if we&squot;re still in bounds.  If not, there&squot;s a problem&n;&t; * with Internal_name (invalid format).&n;&t; */
r_if
c_cond
(paren
op_star
id|converted_name_length
OG
id|internal_name_length
)paren
(brace
id|REPORT_ERROR
(paren
l_string|&quot;Ns_externalize_name: Invalid internal name.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|AE_BAD_PATHNAME
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Build Converted_name...&n;&t; */
(paren
op_star
id|converted_name
)paren
op_assign
id|acpi_cm_callocate
(paren
op_star
id|converted_name_length
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|converted_name
)paren
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
id|j
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|prefix_length
suffix:semicolon
id|i
op_increment
)paren
(brace
(paren
op_star
id|converted_name
)paren
(braket
id|j
op_increment
)braket
op_assign
id|internal_name
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|names_count
OG
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|names_count
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|i
OG
l_int|0
)paren
(brace
(paren
op_star
id|converted_name
)paren
(braket
id|j
op_increment
)braket
op_assign
l_char|&squot;.&squot;
suffix:semicolon
)brace
(paren
op_star
id|converted_name
)paren
(braket
id|j
op_increment
)braket
op_assign
id|internal_name
(braket
id|names_index
op_increment
)braket
suffix:semicolon
(paren
op_star
id|converted_name
)paren
(braket
id|j
op_increment
)braket
op_assign
id|internal_name
(braket
id|names_index
op_increment
)braket
suffix:semicolon
(paren
op_star
id|converted_name
)paren
(braket
id|j
op_increment
)braket
op_assign
id|internal_name
(braket
id|names_index
op_increment
)braket
suffix:semicolon
(paren
op_star
id|converted_name
)paren
(braket
id|j
op_increment
)braket
op_assign
id|internal_name
(braket
id|names_index
op_increment
)braket
suffix:semicolon
)brace
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_convert_handle_to_entry&n; *&n; * PARAMETERS:  Handle          - Handle to be converted to an NTE&n; *&n; * RETURN:      A Name table entry pointer&n; *&n; * DESCRIPTION: Convert a namespace handle to a real NTE&n; *&n; ****************************************************************************/
id|ACPI_NAMED_OBJECT
op_star
DECL|function|acpi_ns_convert_handle_to_entry
id|acpi_ns_convert_handle_to_entry
(paren
id|ACPI_HANDLE
id|handle
)paren
(brace
multiline_comment|/*&n;&t; * Simple implementation for now;&n;&t; * TBD: [Future] Real integer handles allow for more verification&n;&t; * and keep all pointers within this subsystem!&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|handle
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|handle
op_eq
id|ACPI_ROOT_OBJECT
)paren
(brace
r_return
id|acpi_gbl_root_object
suffix:semicolon
)brace
multiline_comment|/* We can at least attempt to verify the handle */
r_if
c_cond
(paren
op_logical_neg
id|VALID_DESCRIPTOR_TYPE
(paren
id|handle
comma
id|ACPI_DESC_TYPE_NAMED
)paren
)paren
(brace
r_return
l_int|NULL
suffix:semicolon
)brace
r_return
(paren
id|ACPI_NAMED_OBJECT
op_star
)paren
id|handle
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_convert_entry_to_handle&n; *&n; * PARAMETERS:  Nte          - NTE to be converted to a Handle&n; *&n; * RETURN:      An USER ACPI_HANDLE&n; *&n; * DESCRIPTION: Convert a real NTE to a namespace handle&n; *&n; ****************************************************************************/
id|ACPI_HANDLE
DECL|function|acpi_ns_convert_entry_to_handle
id|acpi_ns_convert_entry_to_handle
c_func
(paren
id|ACPI_NAMED_OBJECT
op_star
id|nte
)paren
(brace
multiline_comment|/*&n;&t; * Simple implementation for now;&n;&t; * TBD: [Future] Real integer handles allow for more verification&n;&t; * and keep all pointers within this subsystem!&n;&t; */
r_return
(paren
id|ACPI_HANDLE
)paren
id|nte
suffix:semicolon
multiline_comment|/* ---------------------------------------------------&n;&n;&t;if (!Nte) {&n;&t;&t;return NULL;&n;&t;}&n;&n;&t;if (Nte == Acpi_gbl_Root_object) {&n;&t;&t;return ACPI_ROOT_OBJECT;&n;&t;}&n;&n;&n;&t;return (ACPI_HANDLE) Nte;&n;------------------------------------------------------*/
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_terminate&n; *&n; * PARAMETERS:  none&n; *&n; * RETURN:      none&n; *&n; * DESCRIPTION: free memory allocated for table storage.&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ns_terminate
id|acpi_ns_terminate
(paren
r_void
)paren
(brace
id|ACPI_OBJECT_INTERNAL
op_star
id|obj_desc
suffix:semicolon
id|ACPI_NAMED_OBJECT
op_star
id|entry
suffix:semicolon
id|entry
op_assign
id|acpi_gbl_root_object
suffix:semicolon
multiline_comment|/*&n;&t; * 1) Free the entire namespace -- all objects, tables, and stacks&n;&t; */
multiline_comment|/*&n;&t; * Delete all objects linked to the root&n;&t; * (additional table descriptors)&n;&t; */
id|acpi_ns_delete_namespace_subtree
(paren
id|entry
)paren
suffix:semicolon
multiline_comment|/* Detach any object(s) attached to the root */
id|obj_desc
op_assign
id|acpi_ns_get_attached_object
(paren
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|obj_desc
)paren
(brace
id|acpi_ns_detach_object
(paren
id|entry
)paren
suffix:semicolon
id|acpi_cm_remove_reference
(paren
id|obj_desc
)paren
suffix:semicolon
)brace
id|acpi_ns_delete_name_table
(paren
id|entry-&gt;child_table
)paren
suffix:semicolon
id|entry-&gt;child_table
op_assign
l_int|NULL
suffix:semicolon
id|REPORT_SUCCESS
(paren
l_string|&quot;Entire namespace and objects deleted&quot;
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * 2) Now we can delete the ACPI tables&n;&t; */
id|acpi_tb_delete_acpi_tables
(paren
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_opens_scope&n; *&n; * PARAMETERS:  Type        - A valid namespace type&n; *&n; * RETURN:      NEWSCOPE if the passed type &quot;opens a name scope&quot; according&n; *              to the ACPI specification, else 0&n; *&n; ***************************************************************************/
id|s32
DECL|function|acpi_ns_opens_scope
id|acpi_ns_opens_scope
(paren
id|OBJECT_TYPE_INTERNAL
id|type
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|acpi_cm_valid_object_type
(paren
id|type
)paren
)paren
(brace
multiline_comment|/* type code out of range  */
id|REPORT_WARNING
(paren
l_string|&quot;Ns_opens_scope: Invalid Object Type&quot;
)paren
suffix:semicolon
r_return
(paren
id|NSP_NORMAL
)paren
suffix:semicolon
)brace
r_return
(paren
(paren
(paren
id|s32
)paren
id|acpi_gbl_ns_properties
(braket
id|type
)braket
)paren
op_amp
id|NSP_NEWSCOPE
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_get_named_object&n; *&n; * PARAMETERS:  *Pathname   - Name to be found, in external (ASL) format. The&n; *                            &bslash; (backslash) and ^ (carat) prefixes, and the&n; *                            . (period) to separate segments are supported.&n; *              In_scope    - Root of subtree to be searched, or NS_ALL for the&n; *                            root of the name space.  If Name is fully&n; *                            qualified (first char is &squot;&bslash;&squot;), the passed value&n; *                            of Scope will not be accessed.&n; *              Out_nte     - Where the Nte is returned&n; *&n; * DESCRIPTION: Look up a name relative to a given scope and return the&n; *              corresponding NTE.  NOTE: Scope can be null.&n; *&n; * MUTEX:       Locks namespace&n; *&n; ***************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ns_get_named_object
id|acpi_ns_get_named_object
(paren
r_char
op_star
id|pathname
comma
id|ACPI_NAME_TABLE
op_star
id|in_scope
comma
id|ACPI_NAMED_OBJECT
op_star
op_star
id|out_nte
)paren
(brace
id|ACPI_GENERIC_STATE
id|scope_info
suffix:semicolon
id|ACPI_STATUS
id|status
suffix:semicolon
id|ACPI_NAMED_OBJECT
op_star
id|obj_entry
op_assign
l_int|NULL
suffix:semicolon
r_char
op_star
id|internal_path
op_assign
l_int|NULL
suffix:semicolon
id|scope_info.scope.name_table
op_assign
id|in_scope
suffix:semicolon
multiline_comment|/* Ensure that the namespace has been initialized */
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_root_object-&gt;child_table
)paren
(brace
r_return
(paren
id|AE_NO_NAMESPACE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pathname
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/* Convert path to internal representation */
id|status
op_assign
id|acpi_ns_internalize_name
(paren
id|pathname
comma
op_amp
id|internal_path
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
id|acpi_cm_acquire_mutex
(paren
id|ACPI_MTX_NAMESPACE
)paren
suffix:semicolon
multiline_comment|/* NS_ALL means start from the root */
r_if
c_cond
(paren
id|NS_ALL
op_eq
id|scope_info.scope.name_table
)paren
(brace
id|scope_info.scope.name_table
op_assign
id|acpi_gbl_root_object-&gt;child_table
suffix:semicolon
)brace
r_else
(brace
id|scope_info.scope.name_table
op_assign
id|in_scope
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|scope_info.scope.name_table
)paren
(brace
id|status
op_assign
id|AE_BAD_PARAMETER
suffix:semicolon
r_goto
id|unlock_and_exit
suffix:semicolon
)brace
)brace
multiline_comment|/* Lookup the name in the namespace */
id|status
op_assign
id|acpi_ns_lookup
(paren
op_amp
id|scope_info
comma
id|internal_path
comma
id|ACPI_TYPE_ANY
comma
id|IMODE_EXECUTE
comma
id|NS_NO_UPSEARCH
op_or
id|NS_DONT_OPEN_SCOPE
comma
l_int|NULL
comma
op_amp
id|obj_entry
)paren
suffix:semicolon
multiline_comment|/* Return what was wanted - the NTE that matches the name */
op_star
id|out_nte
op_assign
id|obj_entry
suffix:semicolon
id|unlock_and_exit
suffix:colon
id|acpi_cm_release_mutex
(paren
id|ACPI_MTX_NAMESPACE
)paren
suffix:semicolon
multiline_comment|/* Cleanup */
id|acpi_cm_free
(paren
id|internal_path
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_find_parent_name&n; *&n; * PARAMETERS:  *Child_entry            - nte whose name is to be found&n; *&n; * RETURN:      The ACPI name&n; *&n; * DESCRIPTION: Search for the given nte in its parent scope and return the&n; *              name segment, or &quot;????&quot; if the parent name can&squot;t be found&n; *              (which &quot;should not happen&quot;).&n; *&n; ***************************************************************************/
id|ACPI_NAME
DECL|function|acpi_ns_find_parent_name
id|acpi_ns_find_parent_name
(paren
id|ACPI_NAMED_OBJECT
op_star
id|child_entry
)paren
(brace
id|ACPI_NAMED_OBJECT
op_star
id|parent_entry
suffix:semicolon
r_if
c_cond
(paren
id|child_entry
)paren
(brace
multiline_comment|/* Valid entry.  Get the parent Nte */
id|parent_entry
op_assign
id|acpi_ns_get_parent_entry
(paren
id|child_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent_entry
)paren
(brace
r_if
c_cond
(paren
id|parent_entry-&gt;name
)paren
(brace
r_return
(paren
id|parent_entry-&gt;name
)paren
suffix:semicolon
)brace
)brace
)brace
r_return
(paren
id|ACPI_UNKNOWN_NAME
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_exist_downstream_sibling&n; *&n; * PARAMETERS:  *This_entry         - pointer to first nte to examine&n; *&n; * RETURN:      TRUE if sibling is found, FALSE otherwise&n; *&n; * DESCRIPTION: Searches remainder of scope being processed to determine&n; *              whether there is a downstream sibling to the current&n; *              object.  This function is used to determine what type of&n; *              line drawing character to use when displaying namespace&n; *              trees.&n; *&n; ***************************************************************************/
id|u8
DECL|function|acpi_ns_exist_downstream_sibling
id|acpi_ns_exist_downstream_sibling
(paren
id|ACPI_NAMED_OBJECT
op_star
id|this_entry
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|this_entry
)paren
(brace
r_return
id|FALSE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|this_entry-&gt;name
)paren
(brace
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/* TBD: what did this really do?&n;&t;if (This_entry-&gt;Next_entry) {&n;&t;&t;return TRUE;&n;&t;}&n;*/
r_return
id|FALSE
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_get_owner_table&n; *&n; * PARAMETERS:&n; *&n; * RETURN:&n; *&n; * DESCRIPTION:&n; *&n; ***************************************************************************/
id|ACPI_NAME_TABLE
op_star
DECL|function|acpi_ns_get_owner_table
id|acpi_ns_get_owner_table
(paren
id|ACPI_NAMED_OBJECT
op_star
id|this_entry
)paren
(brace
multiline_comment|/*&n;&t; * Given an entry in the Name_table-&gt;Entries field of a name table,&n;&t; * we can create a pointer to the beginning of the table as follows:&n;&t; *&n;&t; * 1) Starting with the the pointer to the entry,&n;&t; * 2) Subtract the entry index * size of each entry to get a&n;&t; *    pointer to Entries[0]&n;&t; * 3) Subtract the size of NAME_TABLE structure to get a pointer&n;&t; *    to the start.&n;&t; *&n;&t; * This saves having to put a pointer in every entry that points&n;&t; * back to the beginning of the table and/or a pointer back to&n;&t; * the parent.&n;&t; */
r_return
(paren
id|ACPI_NAME_TABLE
op_star
)paren
(paren
(paren
r_char
op_star
)paren
id|this_entry
op_minus
(paren
id|this_entry-&gt;this_index
op_star
r_sizeof
(paren
id|ACPI_NAMED_OBJECT
)paren
)paren
op_minus
(paren
r_sizeof
(paren
id|ACPI_NAME_TABLE
)paren
op_minus
r_sizeof
(paren
id|ACPI_NAMED_OBJECT
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_get_parent_entry&n; *&n; * PARAMETERS:  This_entry      - Current table entry&n; *&n; * RETURN:      Parent entry of the given entry&n; *&n; * DESCRIPTION: Obtain the parent entry for a given entry in the namespace.&n; *&n; ***************************************************************************/
id|ACPI_NAMED_OBJECT
op_star
DECL|function|acpi_ns_get_parent_entry
id|acpi_ns_get_parent_entry
(paren
id|ACPI_NAMED_OBJECT
op_star
id|this_entry
)paren
(brace
id|ACPI_NAME_TABLE
op_star
id|name_table
suffix:semicolon
id|name_table
op_assign
id|acpi_ns_get_owner_table
(paren
id|this_entry
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Now that we have a pointer to the name table, we can just pluck&n;&t; * the parent&n;&t; */
r_return
(paren
id|name_table-&gt;parent_entry
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_get_next_valid_entry&n; *&n; * PARAMETERS:  This_entry      - Current table entry&n; *&n; * RETURN:      Next valid object in the table.  NULL if no more valid&n; *              objects&n; *&n; * DESCRIPTION: Find the next valid object within a name table.&n; *&n; ***************************************************************************/
id|ACPI_NAMED_OBJECT
op_star
DECL|function|acpi_ns_get_next_valid_entry
id|acpi_ns_get_next_valid_entry
(paren
id|ACPI_NAMED_OBJECT
op_star
id|this_entry
)paren
(brace
id|ACPI_NAME_TABLE
op_star
id|name_table
suffix:semicolon
id|u32
id|index
suffix:semicolon
id|index
op_assign
id|this_entry-&gt;this_index
op_plus
l_int|1
suffix:semicolon
id|name_table
op_assign
id|acpi_ns_get_owner_table
(paren
id|this_entry
)paren
suffix:semicolon
r_while
c_loop
(paren
id|name_table
)paren
(brace
r_if
c_cond
(paren
id|index
op_ge
id|NS_TABLE_SIZE
)paren
(brace
multiline_comment|/* We are at the end of this table */
id|name_table
op_assign
id|name_table-&gt;next_table
suffix:semicolon
id|index
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Is this a valid (occupied) slot? */
r_if
c_cond
(paren
id|name_table-&gt;entries
(braket
id|index
)braket
dot
id|name
)paren
(brace
multiline_comment|/* Found a valid entry, all done */
r_return
(paren
op_amp
id|name_table-&gt;entries
(braket
id|index
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Go to the next slot */
id|index
op_increment
suffix:semicolon
)brace
multiline_comment|/* No more valid entries in this name table */
r_return
l_int|NULL
suffix:semicolon
)brace
eof
