multiline_comment|/******************************************************************************&n; *&n; * Module Name: nsnames - Name manipulation and search&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;amlcode.h&quot;
macro_line|#include &quot;interp.h&quot;
macro_line|#include &quot;namesp.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          NAMESPACE
id|MODULE_NAME
(paren
l_string|&quot;nsnames&quot;
)paren
suffix:semicolon
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_name_of_scope&n; *&n; * PARAMETERS:  Scope           - Scope whose name is needed&n; *&n; * RETURN:      Pointer to storage containing the fully qualified name of&n; *              the scope, in Label format (all segments strung together&n; *              with no separators)&n; *&n; * DESCRIPTION: Used via Acpi_ns_name_of_current_scope() and Acpi_ns_last_fQN()&n; *              for label generation in the interpreter, and for debug&n; *              printing in Acpi_ns_search_table().&n; *&n; ***************************************************************************/
r_char
op_star
DECL|function|acpi_ns_name_of_scope
id|acpi_ns_name_of_scope
(paren
id|ACPI_NAME_TABLE
op_star
id|scope
)paren
(brace
r_char
op_star
id|name_buffer
suffix:semicolon
id|ACPI_SIZE
id|size
suffix:semicolon
id|ACPI_NAME
id|name
suffix:semicolon
id|ACPI_NAMED_OBJECT
op_star
id|entry_to_search
suffix:semicolon
id|ACPI_NAMED_OBJECT
op_star
id|parent_entry
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_root_object-&gt;child_table
op_logical_or
op_logical_neg
id|scope
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the name space has not been initialized,&n;&t;&t; * this function should not have been called.&n;&t;&t; */
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|entry_to_search
op_assign
id|scope-&gt;entries
suffix:semicolon
multiline_comment|/* Calculate required buffer size based on depth below root NT */
id|size
op_assign
l_int|1
suffix:semicolon
id|parent_entry
op_assign
id|entry_to_search
suffix:semicolon
r_while
c_loop
(paren
id|parent_entry
)paren
(brace
id|parent_entry
op_assign
id|acpi_ns_get_parent_entry
(paren
id|parent_entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parent_entry
)paren
(brace
id|size
op_add_assign
id|ACPI_NAME_SIZE
suffix:semicolon
)brace
)brace
multiline_comment|/* Allocate the buffer */
id|name_buffer
op_assign
id|acpi_cm_callocate
(paren
id|size
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|name_buffer
)paren
(brace
id|REPORT_ERROR
(paren
l_string|&quot;Ns_name_of_scope: allocation failure&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Store terminator byte, then build name backwards */
id|name_buffer
(braket
id|size
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_while
c_loop
(paren
(paren
id|size
OG
id|ACPI_NAME_SIZE
)paren
op_logical_and
id|acpi_ns_get_parent_entry
(paren
id|entry_to_search
)paren
)paren
(brace
id|size
op_sub_assign
id|ACPI_NAME_SIZE
suffix:semicolon
id|name
op_assign
id|acpi_ns_find_parent_name
(paren
id|entry_to_search
)paren
suffix:semicolon
multiline_comment|/* Put the name into the buffer */
id|MOVE_UNALIGNED32_TO_32
(paren
(paren
id|name_buffer
op_plus
id|size
)paren
comma
op_amp
id|name
)paren
suffix:semicolon
id|entry_to_search
op_assign
id|acpi_ns_get_parent_entry
(paren
id|entry_to_search
)paren
suffix:semicolon
)brace
id|name_buffer
(braket
op_decrement
id|size
)braket
op_assign
id|AML_ROOT_PREFIX
suffix:semicolon
r_return
(paren
id|name_buffer
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_name_of_current_scope&n; *&n; * PARAMETERS:  none&n; *&n; * RETURN:      pointer to storage containing the name of the current scope&n; *&n; ***************************************************************************/
r_char
op_star
DECL|function|acpi_ns_name_of_current_scope
id|acpi_ns_name_of_current_scope
(paren
id|ACPI_WALK_STATE
op_star
id|walk_state
)paren
(brace
r_char
op_star
id|scope_name
suffix:semicolon
r_if
c_cond
(paren
id|walk_state
op_logical_and
id|walk_state-&gt;scope_info
)paren
(brace
id|scope_name
op_assign
id|acpi_ns_name_of_scope
(paren
id|walk_state-&gt;scope_info-&gt;scope.name_table
)paren
suffix:semicolon
r_return
(paren
id|scope_name
)paren
suffix:semicolon
)brace
id|REPORT_ERROR
(paren
l_string|&quot;Current scope pointer is invalid&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_handle_to_pathname&n; *&n; * PARAMETERS:  Target_handle           - Handle of nte whose name is to be found&n; *              Buf_size                - Size of the buffer provided&n; *              User_buffer             - Where the pathname is returned&n; *&n; * RETURN:      Status, Buffer is filled with pathname if status == AE_OK&n; *&n; * DESCRIPTION: Build and return a full namespace pathname&n; *&n; * MUTEX:       Locks Namespace&n; *&n; ***************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ns_handle_to_pathname
id|acpi_ns_handle_to_pathname
(paren
id|ACPI_HANDLE
id|target_handle
comma
id|u32
op_star
id|buf_size
comma
r_char
op_star
id|user_buffer
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|ACPI_NAMED_OBJECT
op_star
id|entry_to_search
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_NAMED_OBJECT
op_star
id|temp
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_SIZE
id|path_length
op_assign
l_int|0
suffix:semicolon
id|ACPI_SIZE
id|size
suffix:semicolon
id|u32
id|user_buf_size
suffix:semicolon
id|ACPI_NAME
id|name
suffix:semicolon
id|u8
id|namespace_was_locked
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_root_object-&gt;child_table
op_logical_or
op_logical_neg
id|target_handle
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the name space has not been initialized,&n;&t;&t; * this function should not have been called.&n;&t;&t; */
r_return
(paren
id|AE_NO_NAMESPACE
)paren
suffix:semicolon
)brace
id|namespace_was_locked
op_assign
id|acpi_gbl_acpi_mutex_info
(braket
id|ACPI_MTX_NAMESPACE
)braket
dot
id|locked
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|namespace_was_locked
)paren
(brace
id|acpi_cm_acquire_mutex
(paren
id|ACPI_MTX_NAMESPACE
)paren
suffix:semicolon
)brace
id|entry_to_search
op_assign
id|acpi_ns_convert_handle_to_entry
(paren
id|target_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|entry_to_search
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Compute length of pathname as 5 * number of name segments.&n;&t; * Go back up the parent tree to the root&n;&t; */
r_for
c_loop
(paren
id|size
op_assign
l_int|0
comma
id|temp
op_assign
id|entry_to_search
suffix:semicolon
id|acpi_ns_get_parent_entry
(paren
id|temp
)paren
suffix:semicolon
id|temp
op_assign
id|acpi_ns_get_parent_entry
(paren
id|temp
)paren
)paren
(brace
id|size
op_add_assign
id|PATH_SEGMENT_LENGTH
suffix:semicolon
)brace
multiline_comment|/* Set return length to the required path length */
id|path_length
op_assign
id|size
op_plus
l_int|1
suffix:semicolon
id|user_buf_size
op_assign
op_star
id|buf_size
suffix:semicolon
op_star
id|buf_size
op_assign
id|path_length
suffix:semicolon
multiline_comment|/* Check if the user buffer is sufficiently large */
r_if
c_cond
(paren
id|path_length
OG
id|user_buf_size
)paren
(brace
id|status
op_assign
id|AE_BUFFER_OVERFLOW
suffix:semicolon
r_goto
id|unlock_and_exit
suffix:semicolon
)brace
multiline_comment|/* Store null terminator */
id|user_buffer
(braket
id|size
)braket
op_assign
l_int|0
suffix:semicolon
id|size
op_sub_assign
id|ACPI_NAME_SIZE
suffix:semicolon
multiline_comment|/* Put the original ACPI name at the end of the path */
id|MOVE_UNALIGNED32_TO_32
(paren
(paren
id|user_buffer
op_plus
id|size
)paren
comma
op_amp
id|entry_to_search-&gt;name
)paren
suffix:semicolon
id|user_buffer
(braket
op_decrement
id|size
)braket
op_assign
id|PATH_SEPARATOR
suffix:semicolon
multiline_comment|/* Build name backwards, putting &quot;.&quot; between segments */
r_while
c_loop
(paren
(paren
id|size
OG
id|ACPI_NAME_SIZE
)paren
op_logical_and
id|entry_to_search
)paren
(brace
id|size
op_sub_assign
id|ACPI_NAME_SIZE
suffix:semicolon
id|name
op_assign
id|acpi_ns_find_parent_name
(paren
id|entry_to_search
)paren
suffix:semicolon
id|MOVE_UNALIGNED32_TO_32
(paren
(paren
id|user_buffer
op_plus
id|size
)paren
comma
op_amp
id|name
)paren
suffix:semicolon
id|user_buffer
(braket
op_decrement
id|size
)braket
op_assign
id|PATH_SEPARATOR
suffix:semicolon
id|entry_to_search
op_assign
id|acpi_ns_get_parent_entry
(paren
id|entry_to_search
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Overlay the &quot;.&quot; preceding the first segment with&n;&t; * the root name &quot;&bslash;&quot;&n;&t; */
id|user_buffer
(braket
id|size
)braket
op_assign
l_char|&squot;&bslash;&bslash;&squot;
suffix:semicolon
id|unlock_and_exit
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|namespace_was_locked
)paren
(brace
id|acpi_cm_release_mutex
(paren
id|ACPI_MTX_NAMESPACE
)paren
suffix:semicolon
)brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_pattern_match&n; *&n; * PARAMETERS:  Obj_entry       - A namespace entry&n; *              Search_for      - Wildcard pattern string&n; *&n; * DESCRIPTION: Matches a namespace name against a wildcard pattern.  Only&n; *              a very simple pattern - 4 chars, either a valid char or a &quot;?&quot;&n; *              to match any.&n; *&n; ***************************************************************************/
id|u8
DECL|function|acpi_ns_pattern_match
id|acpi_ns_pattern_match
(paren
id|ACPI_NAMED_OBJECT
op_star
id|obj_entry
comma
r_char
op_star
id|search_for
)paren
(brace
id|s32
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|ACPI_NAME_SIZE
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|search_for
(braket
id|i
)braket
op_ne
l_char|&squot;?&squot;
op_logical_and
id|search_for
(braket
id|i
)braket
op_ne
(paren
(paren
r_char
op_star
)paren
op_amp
id|obj_entry-&gt;name
)paren
(braket
id|i
)braket
)paren
(brace
multiline_comment|/* No match */
r_return
id|FALSE
suffix:semicolon
)brace
)brace
multiline_comment|/* name matches pattern */
r_return
id|TRUE
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_name_compare&n; *&n; * PARAMETERS:  Obj_handle      - A namespace entry&n; *              Level           - Current nesting level&n; *              Context         - A FIND_CONTEXT structure&n; *&n; * DESCRIPTION: A User_function called by Acpi_ns_walk_namespace(). It performs&n; *              a pattern match for Acpi_ns_low_find_names(), and updates the list&n; *              and count as required.&n; *&n; ***************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ns_name_compare
id|acpi_ns_name_compare
(paren
id|ACPI_HANDLE
id|obj_handle
comma
id|u32
id|level
comma
r_void
op_star
id|context
comma
r_void
op_star
op_star
id|return_value
)paren
(brace
id|FIND_CONTEXT
op_star
id|find
op_assign
id|context
suffix:semicolon
multiline_comment|/* Match, yes or no? */
r_if
c_cond
(paren
id|acpi_ns_pattern_match
(paren
(paren
id|ACPI_NAMED_OBJECT
op_star
)paren
id|obj_handle
comma
id|find-&gt;search_for
)paren
)paren
(brace
multiline_comment|/* Name matches pattern */
r_if
c_cond
(paren
id|find-&gt;list
)paren
(brace
id|find-&gt;list
(braket
op_star
(paren
id|find-&gt;count
)paren
)braket
op_assign
id|obj_handle
suffix:semicolon
)brace
op_increment
op_star
(paren
id|find-&gt;count
)paren
suffix:semicolon
)brace
multiline_comment|/* Don&squot;t terminate the walk */
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_low_find_names&n; *&n; * PARAMETERS:  *This_entry         - Table to be searched&n; *              *Search_for         - Pattern to be found.&n; *                                    4 bytes, ? matches any character.&n; *              *Count              - Output count of matches found.&n; *                                    Outermost caller should preset to 0&n; *              List[]              - Output array of handles.  If&n; *                                    null, only the count is obtained.&n; *              Max_depth           - Maximum depth of search.  Use&n; *                                    INT_MAX for an effectively&n; *                                    unlimited depth.&n; *&n; * DESCRIPTION: Low-level find name.&n; *              Traverse the name space finding names which match a search&n; *              pattern, and return an array of handles in List[].&n; *&n; ***************************************************************************/
r_void
DECL|function|acpi_ns_low_find_names
id|acpi_ns_low_find_names
(paren
id|ACPI_NAMED_OBJECT
op_star
id|this_entry
comma
r_char
op_star
id|search_for
comma
id|s32
op_star
id|count
comma
id|ACPI_HANDLE
id|list
(braket
)braket
comma
id|s32
id|max_depth
)paren
(brace
id|FIND_CONTEXT
id|find
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|max_depth
op_logical_or
op_logical_neg
id|this_entry
op_logical_or
op_logical_neg
id|search_for
op_logical_or
op_logical_neg
id|count
)paren
(brace
multiline_comment|/*&n;&t;&t; * Zero requested depth, nothing to search,&n;&t;&t; * nothing to search for, or count pointer bad&n;&t;&t; */
r_return
suffix:semicolon
)brace
multiline_comment|/* Init the context structure used by compare routine */
id|find.list
op_assign
id|list
suffix:semicolon
id|find.count
op_assign
id|count
suffix:semicolon
id|find.search_for
op_assign
id|search_for
suffix:semicolon
multiline_comment|/* Walk the namespace and find all matches */
id|acpi_ns_walk_namespace
(paren
id|ACPI_TYPE_ANY
comma
(paren
id|ACPI_HANDLE
)paren
id|this_entry
comma
id|max_depth
comma
id|NS_WALK_NO_UNLOCK
comma
id|acpi_ns_name_compare
comma
op_amp
id|find
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|list
)paren
(brace
multiline_comment|/* null-terminate the output array */
id|list
(braket
op_star
id|count
)braket
op_assign
(paren
id|ACPI_HANDLE
)paren
l_int|0
suffix:semicolon
)brace
r_return
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_ns_find_names&n;&n; *&n; * PARAMETERS:  *Search_for         - pattern to be found.&n; *                                    4 bytes, ? matches any character.&n; *                                    If NULL, &quot;????&quot; will be used.&n; *              Start_handle        - Root of subtree to be searched, or&n; *                                    NS_ALL to search the entire namespace&n; *              Max_depth           - Maximum depth of search.  Use INT_MAX&n; *                                    for an effectively unlimited depth.&n; *&n; * DESCRIPTION: Traverse the name space finding names which match a search&n; *              pattern, and return an array of handles.  The end of the&n; *              array is marked by the value (ACPI_HANDLE)0.  A return value&n; *              of (ACPI_HANDLE *)0 indicates that no matching names were&n; *              found or that space for the list could not be allocated.&n; *              if Start_handle is NS_ALL (null) search from the root,&n; *              else it is a handle whose children are to be searched.&n; *&n; ***************************************************************************/
id|ACPI_HANDLE
op_star
DECL|function|acpi_ns_find_names
id|acpi_ns_find_names
(paren
r_char
op_star
id|search_for
comma
id|ACPI_HANDLE
id|start_handle
comma
id|s32
id|max_depth
)paren
(brace
id|ACPI_HANDLE
op_star
id|list
op_assign
l_int|NULL
suffix:semicolon
id|s32
id|count
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_root_object-&gt;child_table
)paren
(brace
multiline_comment|/*&n;&t;&t; * If the name space has not been initialized,&n;&t;&t; * there surely are no matching names.&n;&t;&t; */
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|NS_ALL
op_eq
id|start_handle
)paren
(brace
multiline_comment|/* base is root */
id|start_handle
op_assign
id|acpi_gbl_root_object
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|ACPI_NAMED_OBJECT
op_star
)paren
id|start_handle
)paren
op_member_access_from_pointer
id|child_table
)paren
(brace
multiline_comment|/* base has children to search */
id|start_handle
op_assign
(paren
(paren
id|ACPI_NAMED_OBJECT
op_star
)paren
id|start_handle
)paren
op_member_access_from_pointer
id|child_table-&gt;entries
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * If base is not the root and has no children,&n;&t;&t; * there is nothing to search.&n;&t;&t; */
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|search_for
)paren
(brace
multiline_comment|/* Search name not specified */
id|search_for
op_assign
l_string|&quot;????&quot;
suffix:semicolon
)brace
multiline_comment|/* Pass 1.  Get required buffer size, don&squot;t try to build list */
id|count
op_assign
l_int|0
suffix:semicolon
id|acpi_ns_low_find_names
(paren
id|start_handle
comma
id|search_for
comma
op_amp
id|count
comma
l_int|NULL
comma
id|max_depth
)paren
suffix:semicolon
r_if
c_cond
(paren
l_int|0
op_eq
id|count
)paren
(brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Allow for trailing null */
id|count
op_increment
suffix:semicolon
id|list
op_assign
id|acpi_cm_callocate
(paren
id|count
op_star
r_sizeof
(paren
id|ACPI_HANDLE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|list
)paren
(brace
id|REPORT_ERROR
(paren
l_string|&quot;Ns_find_names: allocation failure&quot;
)paren
suffix:semicolon
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Pass 2.  Fill buffer */
id|count
op_assign
l_int|0
suffix:semicolon
id|acpi_ns_low_find_names
(paren
id|start_handle
comma
id|search_for
comma
op_amp
id|count
comma
id|list
comma
id|max_depth
)paren
suffix:semicolon
r_return
(paren
id|list
)paren
suffix:semicolon
)brace
eof
