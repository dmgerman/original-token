multiline_comment|/*******************************************************************************&n; *&n; * Module Name: rscalc - Acpi_rs_calculate_byte_stream_length&n; *                       Acpi_rs_calculate_list_length&n; *              $Revision: 16 $&n; *&n; ******************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;acresrc.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          RESOURCE_MANAGER
id|MODULE_NAME
(paren
l_string|&quot;rscalc&quot;
)paren
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_rs_calculate_byte_stream_length&n; *&n; * PARAMETERS:  Linked_list         - Pointer to the resource linked list&n; *              Size_needed         - u32 pointer of the size buffer needed&n; *                                      to properly return the parsed data&n; *&n; * RETURN:      Status  AE_OK if okay, else a valid ACPI_STATUS code&n; *&n; * DESCRIPTION: Takes the resource byte stream and parses it once, calculating&n; *              the size buffer needed to hold the linked list that conveys&n; *              the resource data.&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_rs_calculate_byte_stream_length
id|acpi_rs_calculate_byte_stream_length
(paren
id|RESOURCE
op_star
id|linked_list
comma
id|u32
op_star
id|size_needed
)paren
(brace
id|u32
id|byte_stream_size_needed
op_assign
l_int|0
suffix:semicolon
id|u32
id|segment_size
suffix:semicolon
id|EXTENDED_IRQ_RESOURCE
op_star
id|ex_irq
op_assign
l_int|NULL
suffix:semicolon
id|u8
id|done
op_assign
id|FALSE
suffix:semicolon
r_while
c_loop
(paren
op_logical_neg
id|done
)paren
(brace
multiline_comment|/*&n;&t;&t; * Init the variable that will hold the size to add to the&n;&t;&t; *  total.&n;&t;&t; */
id|segment_size
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|linked_list-&gt;id
)paren
(brace
r_case
id|irq
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * IRQ Resource&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * For an IRQ Resource, Byte 3, although optional, will&n;&t;&t;&t; *  always be created - it holds IRQ information.&n;&t;&t;&t; */
id|segment_size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
id|dma
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * DMA Resource&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * For this resource the size is static&n;&t;&t;&t; */
id|segment_size
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
id|start_dependent_functions
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Start Dependent Functions Resource&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * For a Start_dependent_functions Resource, Byte 1,&n;&t;&t;&t; * although optional, will always be created.&n;&t;&t;&t; */
id|segment_size
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
id|end_dependent_functions
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * End Dependent Functions Resource&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * For this resource the size is static&n;&t;&t;&t; */
id|segment_size
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|io
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * IO Port Resource&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * For this resource the size is static&n;&t;&t;&t; */
id|segment_size
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fixed_io
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Fixed IO Port Resource&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * For this resource the size is static&n;&t;&t;&t; */
id|segment_size
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
id|vendor_specific
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Vendor Defined Resource&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * For a Vendor Specific resource, if the Length is&n;&t;&t;&t; *  between 1 and 7 it will be created as a Small&n;&t;&t;&t; *  Resource data type, otherwise it is a Large&n;&t;&t;&t; *  Resource data type.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|linked_list-&gt;data.vendor_specific.length
OG
l_int|7
)paren
(brace
id|segment_size
op_assign
l_int|3
suffix:semicolon
)brace
r_else
(brace
id|segment_size
op_assign
l_int|1
suffix:semicolon
)brace
id|segment_size
op_add_assign
id|linked_list-&gt;data.vendor_specific.length
suffix:semicolon
r_break
suffix:semicolon
r_case
id|end_tag
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * End Tag&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * For this resource the size is static&n;&t;&t;&t; */
id|segment_size
op_assign
l_int|2
suffix:semicolon
id|done
op_assign
id|TRUE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|memory24
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * 24-Bit Memory Resource&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * For this resource the size is static&n;&t;&t;&t; */
id|segment_size
op_assign
l_int|12
suffix:semicolon
r_break
suffix:semicolon
r_case
id|memory32
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * 32-Bit Memory Range Resource&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * For this resource the size is static&n;&t;&t;&t; */
id|segment_size
op_assign
l_int|20
suffix:semicolon
r_break
suffix:semicolon
r_case
id|fixed_memory32
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * 32-Bit Fixed Memory Resource&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * For this resource the size is static&n;&t;&t;&t; */
id|segment_size
op_assign
l_int|12
suffix:semicolon
r_break
suffix:semicolon
r_case
id|address16
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * 16-Bit Address Resource&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * The base size of this byte stream is 16. If a&n;&t;&t;&t; *  Resource Source string is not NULL, add 1 for&n;&t;&t;&t; *  the Index + the length of the null terminated&n;&t;&t;&t; *  string Resource Source + 1 for the null.&n;&t;&t;&t; */
id|segment_size
op_assign
l_int|16
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_ne
id|linked_list-&gt;data.address16.resource_source
)paren
(brace
id|segment_size
op_add_assign
(paren
l_int|1
op_plus
id|linked_list-&gt;data.address16.resource_source_string_length
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|address32
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * 32-Bit Address Resource&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * The base size of this byte stream is 26. If a Resource&n;&t;&t;&t; *  Source string is not NULL, add 1 for the Index + the&n;&t;&t;&t; *  length of the null terminated string Resource Source +&n;&t;&t;&t; *  1 for the null.&n;&t;&t;&t; */
id|segment_size
op_assign
l_int|26
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_ne
id|linked_list-&gt;data.address16.resource_source
)paren
(brace
id|segment_size
op_add_assign
(paren
l_int|1
op_plus
id|linked_list-&gt;data.address16.resource_source_string_length
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|extended_irq
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Extended IRQ Resource&n;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t; * The base size of this byte stream is 9. This is for an&n;&t;&t;&t; *  Interrupt table length of 1.  For each additional&n;&t;&t;&t; *  interrupt, add 4.&n;&t;&t;&t; * If a Resource Source string is not NULL, add 1 for the&n;&t;&t;&t; *  Index + the length of the null terminated string&n;&t;&t;&t; *  Resource Source + 1 for the null.&n;&t;&t;&t; */
id|segment_size
op_assign
l_int|9
suffix:semicolon
id|segment_size
op_add_assign
(paren
id|linked_list-&gt;data.extended_irq.number_of_interrupts
op_minus
l_int|1
)paren
op_star
l_int|4
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_ne
id|ex_irq-&gt;resource_source
)paren
(brace
id|segment_size
op_add_assign
(paren
l_int|1
op_plus
id|linked_list-&gt;data.extended_irq.resource_source_string_length
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * If we get here, everything is out of sync,&n;&t;&t;&t; *  so exit with an error&n;&t;&t;&t; */
r_return
(paren
id|AE_AML_ERROR
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* switch (Linked_list-&gt;Id) */
multiline_comment|/*&n;&t;&t; * Update the total&n;&t;&t; */
id|byte_stream_size_needed
op_add_assign
id|segment_size
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Point to the next object&n;&t;&t; */
id|linked_list
op_assign
(paren
id|RESOURCE
op_star
)paren
(paren
(paren
id|NATIVE_UINT
)paren
id|linked_list
op_plus
(paren
id|NATIVE_UINT
)paren
id|linked_list-&gt;length
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This is the data the caller needs&n;&t; */
op_star
id|size_needed
op_assign
id|byte_stream_size_needed
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_rs_calculate_list_length&n; *&n; * PARAMETERS:  Byte_stream_buffer      - Pointer to the resource byte stream&n; *              Byte_stream_buffer_length - Size of Byte_stream_buffer&n; *              Size_needed             - u32 pointer of the size buffer&n; *                                          needed to properly return the&n; *                                          parsed data&n; *&n; * RETURN:      Status  AE_OK if okay, else a valid ACPI_STATUS code&n; *&n; * DESCRIPTION: Takes the resource byte stream and parses it once, calculating&n; *              the size buffer needed to hold the linked list that conveys&n; *              the resource data.&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_rs_calculate_list_length
id|acpi_rs_calculate_list_length
(paren
id|u8
op_star
id|byte_stream_buffer
comma
id|u32
id|byte_stream_buffer_length
comma
id|u32
op_star
id|size_needed
)paren
(brace
id|u32
id|buffer_size
op_assign
l_int|0
suffix:semicolon
id|u32
id|bytes_parsed
op_assign
l_int|0
suffix:semicolon
id|u8
id|number_of_interrupts
op_assign
l_int|0
suffix:semicolon
id|u8
id|number_of_channels
op_assign
l_int|0
suffix:semicolon
id|u8
id|resource_type
suffix:semicolon
id|u32
id|structure_size
suffix:semicolon
id|u32
id|bytes_consumed
suffix:semicolon
id|u8
op_star
id|buffer
suffix:semicolon
id|u8
id|temp8
suffix:semicolon
id|u16
id|temp16
suffix:semicolon
id|u8
id|index
suffix:semicolon
id|u8
id|additional_bytes
suffix:semicolon
r_while
c_loop
(paren
id|bytes_parsed
OL
id|byte_stream_buffer_length
)paren
(brace
multiline_comment|/*&n;&t;&t; * Look at the next byte in the stream&n;&t;&t; */
id|resource_type
op_assign
op_star
id|byte_stream_buffer
suffix:semicolon
multiline_comment|/*&n;&t;&t; * See if this is a small or large resource&n;&t;&t; */
r_if
c_cond
(paren
id|resource_type
op_amp
l_int|0x80
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Large Resource Type&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|resource_type
)paren
(brace
r_case
id|MEMORY_RANGE_24
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * 24-Bit Memory Resource&n;&t;&t;&t;&t; */
id|bytes_consumed
op_assign
l_int|12
suffix:semicolon
id|structure_size
op_assign
r_sizeof
(paren
id|MEMORY24_RESOURCE
)paren
op_plus
id|RESOURCE_LENGTH_NO_DATA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|LARGE_VENDOR_DEFINED
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Vendor Defined Resource&n;&t;&t;&t;&t; */
id|buffer
op_assign
id|byte_stream_buffer
suffix:semicolon
op_increment
id|buffer
suffix:semicolon
id|MOVE_UNALIGNED16_TO_16
(paren
op_amp
id|temp16
comma
id|buffer
)paren
suffix:semicolon
id|bytes_consumed
op_assign
id|temp16
op_plus
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Ensure a 32-bit boundary for the structure&n;&t;&t;&t;&t; */
id|temp16
op_assign
(paren
id|u16
)paren
id|ROUND_UP_TO_32_bITS
(paren
id|temp16
)paren
suffix:semicolon
id|structure_size
op_assign
r_sizeof
(paren
id|VENDOR_RESOURCE
)paren
op_plus
id|RESOURCE_LENGTH_NO_DATA
op_plus
(paren
id|temp16
op_star
r_sizeof
(paren
id|u8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MEMORY_RANGE_32
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * 32-Bit Memory Range Resource&n;&t;&t;&t;&t; */
id|bytes_consumed
op_assign
l_int|20
suffix:semicolon
id|structure_size
op_assign
r_sizeof
(paren
id|MEMORY32_RESOURCE
)paren
op_plus
id|RESOURCE_LENGTH_NO_DATA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIXED_MEMORY_RANGE_32
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * 32-Bit Fixed Memory Resource&n;&t;&t;&t;&t; */
id|bytes_consumed
op_assign
l_int|12
suffix:semicolon
id|structure_size
op_assign
r_sizeof
(paren
id|FIXED_MEMORY32_RESOURCE
)paren
op_plus
id|RESOURCE_LENGTH_NO_DATA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DWORD_ADDRESS_SPACE
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * 32-Bit Address Resource&n;&t;&t;&t;&t; */
id|buffer
op_assign
id|byte_stream_buffer
suffix:semicolon
op_increment
id|buffer
suffix:semicolon
id|MOVE_UNALIGNED16_TO_16
(paren
op_amp
id|temp16
comma
id|buffer
)paren
suffix:semicolon
id|bytes_consumed
op_assign
id|temp16
op_plus
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Resource Source Index and Resource Source are&n;&t;&t;&t;&t; *  optional elements.  Check the length of the&n;&t;&t;&t;&t; *  Bytestream.  If it is greater than 23, that&n;&t;&t;&t;&t; *  means that an Index exists and is followed by&n;&t;&t;&t;&t; *  a null termininated string.  Therefore, set&n;&t;&t;&t;&t; *  the temp variable to the length minus the minimum&n;&t;&t;&t;&t; *  byte stream length plus the byte for the Index to&n;&t;&t;&t;&t; *  determine the size of the NULL terminiated string.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
l_int|23
OL
id|temp16
)paren
(brace
id|temp8
op_assign
(paren
id|u8
)paren
(paren
id|temp16
op_minus
l_int|24
)paren
suffix:semicolon
)brace
r_else
(brace
id|temp8
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Ensure a 32-bit boundary for the structure&n;&t;&t;&t;&t; */
id|temp8
op_assign
(paren
id|u8
)paren
id|ROUND_UP_TO_32_bITS
(paren
id|temp8
)paren
suffix:semicolon
id|structure_size
op_assign
r_sizeof
(paren
id|ADDRESS32_RESOURCE
)paren
op_plus
id|RESOURCE_LENGTH_NO_DATA
op_plus
(paren
id|temp8
op_star
r_sizeof
(paren
id|u8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WORD_ADDRESS_SPACE
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * 16-Bit Address Resource&n;&t;&t;&t;&t; */
id|buffer
op_assign
id|byte_stream_buffer
suffix:semicolon
op_increment
id|buffer
suffix:semicolon
id|MOVE_UNALIGNED16_TO_16
(paren
op_amp
id|temp16
comma
id|buffer
)paren
suffix:semicolon
id|bytes_consumed
op_assign
id|temp16
op_plus
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Resource Source Index and Resource Source are&n;&t;&t;&t;&t; *  optional elements.  Check the length of the&n;&t;&t;&t;&t; *  Bytestream.  If it is greater than 13, that&n;&t;&t;&t;&t; *  means that an Index exists and is followed by&n;&t;&t;&t;&t; *  a null termininated string.  Therefore, set&n;&t;&t;&t;&t; *  the temp variable to the length minus the minimum&n;&t;&t;&t;&t; *  byte stream length plus the byte for the Index to&n;&t;&t;&t;&t; *  determine the size of the NULL terminiated string.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
l_int|13
OL
id|temp16
)paren
(brace
id|temp8
op_assign
(paren
id|u8
)paren
(paren
id|temp16
op_minus
l_int|14
)paren
suffix:semicolon
)brace
r_else
(brace
id|temp8
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Ensure a 32-bit boundry for the structure&n;&t;&t;&t;&t; */
id|temp8
op_assign
(paren
id|u8
)paren
id|ROUND_UP_TO_32_bITS
(paren
id|temp8
)paren
suffix:semicolon
id|structure_size
op_assign
r_sizeof
(paren
id|ADDRESS16_RESOURCE
)paren
op_plus
id|RESOURCE_LENGTH_NO_DATA
op_plus
(paren
id|temp8
op_star
r_sizeof
(paren
id|u8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|EXTENDED_IRQ
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Extended IRQ&n;&t;&t;&t;&t; */
id|buffer
op_assign
id|byte_stream_buffer
suffix:semicolon
op_increment
id|buffer
suffix:semicolon
id|MOVE_UNALIGNED16_TO_16
(paren
op_amp
id|temp16
comma
id|buffer
)paren
suffix:semicolon
id|bytes_consumed
op_assign
id|temp16
op_plus
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Point past the length field and the&n;&t;&t;&t;&t; *  Interrupt vector flags to save off the&n;&t;&t;&t;&t; *  Interrupt table length to the Temp8 variable.&n;&t;&t;&t;&t; */
id|buffer
op_add_assign
l_int|3
suffix:semicolon
id|temp8
op_assign
op_star
id|buffer
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * To compensate for multiple interrupt numbers,&n;&t;&t;&t;&t; *  Add 4 bytes for each additional interrupts&n;&t;&t;&t;&t; *  greater than 1&n;&t;&t;&t;&t; */
id|additional_bytes
op_assign
(paren
id|u8
)paren
(paren
(paren
id|temp8
op_minus
l_int|1
)paren
op_star
l_int|4
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Resource Source Index and Resource Source are&n;&t;&t;&t;&t; *  optional elements.  Check the length of the&n;&t;&t;&t;&t; *  Bytestream.  If it is greater than 9, that&n;&t;&t;&t;&t; *  means that an Index exists and is followed by&n;&t;&t;&t;&t; *  a null termininated string.  Therefore, set&n;&t;&t;&t;&t; *  the temp variable to the length minus the minimum&n;&t;&t;&t;&t; *  byte stream length plus the byte for the Index to&n;&t;&t;&t;&t; *  determine the size of the NULL terminiated string.&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
l_int|9
op_plus
id|additional_bytes
OL
id|temp16
)paren
(brace
id|temp8
op_assign
(paren
id|u8
)paren
(paren
id|temp16
op_minus
(paren
l_int|9
op_plus
id|additional_bytes
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|temp8
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Ensure a 32-bit boundry for the structure&n;&t;&t;&t;&t; */
id|temp8
op_assign
(paren
id|u8
)paren
id|ROUND_UP_TO_32_bITS
(paren
id|temp8
)paren
suffix:semicolon
id|structure_size
op_assign
r_sizeof
(paren
id|EXTENDED_IRQ_RESOURCE
)paren
op_plus
id|RESOURCE_LENGTH_NO_DATA
op_plus
(paren
id|additional_bytes
op_star
r_sizeof
(paren
id|u8
)paren
)paren
op_plus
(paren
id|temp8
op_star
r_sizeof
(paren
id|u8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* TBD: [Future] 64-bit not currently supported */
multiline_comment|/*&n;&t;&t;&t;case 0x8A:&n;&t;&t;&t;&t;break;&n;*/
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * If we get here, everything is out of sync,&n;&t;&t;&t;&t; *  so exit with an error&n;&t;&t;&t;&t; */
r_return
(paren
id|AE_AML_ERROR
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Small Resource Type&n;&t;&t;&t; *  Only bits 7:3 are valid&n;&t;&t;&t; */
id|resource_type
op_rshift_assign
l_int|3
suffix:semicolon
r_switch
c_cond
(paren
id|resource_type
)paren
(brace
r_case
id|IRQ_FORMAT
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * IRQ Resource&n;&t;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t;&t; * Determine if it there are two or three&n;&t;&t;&t;&t; *  trailing bytes&n;&t;&t;&t;&t; */
id|buffer
op_assign
id|byte_stream_buffer
suffix:semicolon
id|temp8
op_assign
op_star
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|temp8
op_amp
l_int|0x01
)paren
(brace
id|bytes_consumed
op_assign
l_int|4
suffix:semicolon
)brace
r_else
(brace
id|bytes_consumed
op_assign
l_int|3
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t;&t; * Point past the descriptor&n;&t;&t;&t;&t; */
op_increment
id|buffer
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Look at the number of bits set&n;&t;&t;&t;&t; */
id|MOVE_UNALIGNED16_TO_16
(paren
op_amp
id|temp16
comma
id|buffer
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
l_int|16
suffix:semicolon
id|index
op_increment
)paren
(brace
r_if
c_cond
(paren
id|temp16
op_amp
l_int|0x1
)paren
(brace
op_increment
id|number_of_interrupts
suffix:semicolon
)brace
id|temp16
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|structure_size
op_assign
r_sizeof
(paren
id|IO_RESOURCE
)paren
op_plus
id|RESOURCE_LENGTH_NO_DATA
op_plus
(paren
id|number_of_interrupts
op_star
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DMA_FORMAT
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * DMA Resource&n;&t;&t;&t;&t; */
id|buffer
op_assign
id|byte_stream_buffer
suffix:semicolon
id|bytes_consumed
op_assign
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Point past the descriptor&n;&t;&t;&t;&t; */
op_increment
id|buffer
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Look at the number of bits set&n;&t;&t;&t;&t; */
id|temp8
op_assign
op_star
id|buffer
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
l_int|8
suffix:semicolon
id|index
op_increment
)paren
(brace
r_if
c_cond
(paren
id|temp8
op_amp
l_int|0x1
)paren
(brace
op_increment
id|number_of_channels
suffix:semicolon
)brace
id|temp8
op_rshift_assign
l_int|1
suffix:semicolon
)brace
id|structure_size
op_assign
r_sizeof
(paren
id|DMA_RESOURCE
)paren
op_plus
id|RESOURCE_LENGTH_NO_DATA
op_plus
(paren
id|number_of_channels
op_star
r_sizeof
(paren
id|u32
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|START_DEPENDENT_TAG
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Start Dependent Functions Resource&n;&t;&t;&t;&t; */
multiline_comment|/*&n;&t;&t;&t;&t; * Determine if it there are two or three trailing bytes&n;&t;&t;&t;&t; */
id|buffer
op_assign
id|byte_stream_buffer
suffix:semicolon
id|temp8
op_assign
op_star
id|buffer
suffix:semicolon
r_if
c_cond
(paren
id|temp8
op_amp
l_int|0x01
)paren
(brace
id|bytes_consumed
op_assign
l_int|2
suffix:semicolon
)brace
r_else
(brace
id|bytes_consumed
op_assign
l_int|1
suffix:semicolon
)brace
id|structure_size
op_assign
r_sizeof
(paren
id|START_DEPENDENT_FUNCTIONS_RESOURCE
)paren
op_plus
id|RESOURCE_LENGTH_NO_DATA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|END_DEPENDENT_TAG
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * End Dependent Functions Resource&n;&t;&t;&t;&t; */
id|bytes_consumed
op_assign
l_int|1
suffix:semicolon
id|structure_size
op_assign
id|RESOURCE_LENGTH
suffix:semicolon
r_break
suffix:semicolon
r_case
id|IO_PORT_DESCRIPTOR
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * IO Port Resource&n;&t;&t;&t;&t; */
id|bytes_consumed
op_assign
l_int|8
suffix:semicolon
id|structure_size
op_assign
r_sizeof
(paren
id|IO_RESOURCE
)paren
op_plus
id|RESOURCE_LENGTH_NO_DATA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|FIXED_LOCATION_IO_DESCRIPTOR
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Fixed IO Port Resource&n;&t;&t;&t;&t; */
id|bytes_consumed
op_assign
l_int|4
suffix:semicolon
id|structure_size
op_assign
r_sizeof
(paren
id|FIXED_IO_RESOURCE
)paren
op_plus
id|RESOURCE_LENGTH_NO_DATA
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SMALL_VENDOR_DEFINED
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Vendor Specific Resource&n;&t;&t;&t;&t; */
id|buffer
op_assign
id|byte_stream_buffer
suffix:semicolon
id|temp8
op_assign
op_star
id|buffer
suffix:semicolon
id|temp8
op_assign
(paren
id|u8
)paren
(paren
id|temp8
op_amp
l_int|0x7
)paren
suffix:semicolon
id|bytes_consumed
op_assign
id|temp8
op_plus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * Ensure a 32-bit boundry for the structure&n;&t;&t;&t;&t; */
id|temp8
op_assign
(paren
id|u8
)paren
id|ROUND_UP_TO_32_bITS
(paren
id|temp8
)paren
suffix:semicolon
id|structure_size
op_assign
r_sizeof
(paren
id|VENDOR_RESOURCE
)paren
op_plus
id|RESOURCE_LENGTH_NO_DATA
op_plus
(paren
id|temp8
op_star
r_sizeof
(paren
id|u8
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|END_TAG
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * End Tag&n;&t;&t;&t;&t; */
id|bytes_consumed
op_assign
l_int|2
suffix:semicolon
id|structure_size
op_assign
id|RESOURCE_LENGTH
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * If we get here, everything is out of sync,&n;&t;&t;&t;&t; *  so exit with an error&n;&t;&t;&t;&t; */
r_return
(paren
id|AE_AML_ERROR
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* switch */
)brace
multiline_comment|/* if(Resource_type &amp; 0x80) */
multiline_comment|/*&n;&t;&t; * Update the return value and counter&n;&t;&t; */
id|buffer_size
op_add_assign
id|structure_size
suffix:semicolon
id|bytes_parsed
op_add_assign
id|bytes_consumed
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Set the byte stream to point to the next resource&n;&t;&t; */
id|byte_stream_buffer
op_add_assign
id|bytes_consumed
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * This is the data the caller needs&n;&t; */
op_star
id|size_needed
op_assign
id|buffer_size
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_rs_calculate_pci_routing_table_length&n; *&n; * PARAMETERS:  Package_object          - Pointer to the package object&n; *              Buffer_size_needed      - u32 pointer of the size buffer&n; *                                          needed to properly return the&n; *                                          parsed data&n; *&n; * RETURN:      Status  AE_OK&n; *&n; * DESCRIPTION: Given a package representing a PCI routing table, this&n; *                calculates the size of the corresponding linked list of&n; *                descriptions.&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_rs_calculate_pci_routing_table_length
id|acpi_rs_calculate_pci_routing_table_length
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|package_object
comma
id|u32
op_star
id|buffer_size_needed
)paren
(brace
id|u32
id|number_of_elements
suffix:semicolon
id|u32
id|temp_size_needed
op_assign
l_int|0
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
op_star
id|top_object_list
suffix:semicolon
id|u32
id|index
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|package_element
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
op_star
id|sub_object_list
suffix:semicolon
id|u8
id|name_found
suffix:semicolon
id|u32
id|table_index
suffix:semicolon
id|number_of_elements
op_assign
id|package_object-&gt;package.count
suffix:semicolon
multiline_comment|/*&n;&t; * Calculate the size of the return buffer.&n;&t; * The base size is the number of elements * the sizes of the&n;&t; * structures.  Additional space for the strings is added below.&n;&t; * The minus one is to subtract the size of the u8 Source[1]&n;&t; * member because it is added below.&n;&t; *&n;&t; * NOTE: The Number_of_elements is incremented by one to add an end&n;&t; * table structure that is essentially a structure of zeros.&n;&t; */
multiline_comment|/*&n;&t; * But each PRT_ENTRY structure has a pointer to a string and&n;&t; * the size of that string must be found.&n;&t; */
id|top_object_list
op_assign
id|package_object-&gt;package.elements
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|number_of_elements
suffix:semicolon
id|index
op_increment
)paren
(brace
multiline_comment|/*&n;&t;&t; * Dereference the sub-package&n;&t;&t; */
id|package_element
op_assign
op_star
id|top_object_list
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The Sub_object_list will now point to an array of the&n;&t;&t; * four IRQ elements: Address, Pin, Source and Source_index&n;&t;&t; */
id|sub_object_list
op_assign
id|package_element-&gt;package.elements
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Scan the Irq_table_elements for the Source Name String&n;&t;&t; */
id|name_found
op_assign
id|FALSE
suffix:semicolon
r_for
c_loop
(paren
id|table_index
op_assign
l_int|0
suffix:semicolon
id|table_index
OL
l_int|4
op_logical_and
op_logical_neg
id|name_found
suffix:semicolon
id|table_index
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ACPI_TYPE_STRING
op_eq
(paren
op_star
id|sub_object_list
)paren
op_member_access_from_pointer
id|common.type
)paren
(brace
id|name_found
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Look at the next element&n;&t;&t;&t;&t; */
id|sub_object_list
op_increment
suffix:semicolon
)brace
)brace
id|temp_size_needed
op_add_assign
(paren
r_sizeof
(paren
id|PCI_ROUTING_TABLE
)paren
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Was a String type found?&n;&t;&t; */
r_if
c_cond
(paren
id|TRUE
op_eq
id|name_found
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The length String.Length field includes the&n;&t;&t;&t; * terminating NULL&n;&t;&t;&t; */
id|temp_size_needed
op_add_assign
(paren
op_star
id|sub_object_list
)paren
op_member_access_from_pointer
id|string.length
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * If no name was found, then this is a NULL, which is&n;&t;&t;&t; *  translated as a u32 zero.&n;&t;&t;&t; */
id|temp_size_needed
op_add_assign
r_sizeof
(paren
id|u32
)paren
suffix:semicolon
)brace
multiline_comment|/* Round up the size since each element must be aligned */
id|temp_size_needed
op_assign
id|ROUND_UP_TO_64_bITS
(paren
id|temp_size_needed
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Point to the next ACPI_OPERAND_OBJECT&n;&t;&t; */
id|top_object_list
op_increment
suffix:semicolon
)brace
op_star
id|buffer_size_needed
op_assign
id|temp_size_needed
op_plus
r_sizeof
(paren
id|PCI_ROUTING_TABLE
)paren
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
eof
