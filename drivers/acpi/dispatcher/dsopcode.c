multiline_comment|/******************************************************************************&n; *&n; * Module Name: dsopcode - Dispatcher Op Region support and handling of&n; *                         &quot;control&quot; opcodes&n; *              $Revision: 28 $&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;acparser.h&quot;
macro_line|#include &quot;amlcode.h&quot;
macro_line|#include &quot;acdispat.h&quot;
macro_line|#include &quot;acinterp.h&quot;
macro_line|#include &quot;acnamesp.h&quot;
macro_line|#include &quot;acevents.h&quot;
macro_line|#include &quot;actables.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          DISPATCHER
id|MODULE_NAME
(paren
l_string|&quot;dsopcode&quot;
)paren
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    Acpi_ds_get_field_unit_arguments&n; *&n; * PARAMETERS:  Obj_desc        - A valid Field_unit object&n; *&n; * RETURN:      Status.&n; *&n; * DESCRIPTION: Get Field_unit Buffer and Index. This implements the late&n; *              evaluation of these field attributes.&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ds_get_field_unit_arguments
id|acpi_ds_get_field_unit_arguments
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
)paren
(brace
id|ACPI_OPERAND_OBJECT
op_star
id|extra_desc
suffix:semicolon
id|ACPI_NAMESPACE_NODE
op_star
id|node
suffix:semicolon
id|ACPI_PARSE_OBJECT
op_star
id|op
suffix:semicolon
id|ACPI_PARSE_OBJECT
op_star
id|field_op
suffix:semicolon
id|ACPI_STATUS
id|status
suffix:semicolon
id|ACPI_TABLE_DESC
op_star
id|table_desc
suffix:semicolon
r_if
c_cond
(paren
id|obj_desc-&gt;common.flags
op_amp
id|AOPOBJ_DATA_VALID
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the AML pointer (method object) and Field_unit node */
id|extra_desc
op_assign
id|obj_desc-&gt;field_unit.extra
suffix:semicolon
id|node
op_assign
id|obj_desc-&gt;field_unit.node
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a new parser op to be the root of the parsed&n;&t; * Op_region tree&n;&t; */
id|op
op_assign
id|acpi_ps_alloc_op
(paren
id|AML_SCOPE_OP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
multiline_comment|/* Save the Node for use in Acpi_ps_parse_aml */
id|op-&gt;node
op_assign
id|acpi_ns_get_parent_object
(paren
id|node
)paren
suffix:semicolon
multiline_comment|/* Get a handle to the parent ACPI table */
id|status
op_assign
id|acpi_tb_handle_to_object
(paren
id|node-&gt;owner_id
comma
op_amp
id|table_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* Pass1: Parse the entire Field_unit declaration */
id|status
op_assign
id|acpi_ps_parse_aml
(paren
id|op
comma
id|extra_desc-&gt;extra.pcode
comma
id|extra_desc-&gt;extra.pcode_length
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
id|acpi_ds_load1_begin_op
comma
id|acpi_ds_load1_end_op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|acpi_ps_delete_parse_tree
(paren
id|op
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* Get and init the actual Fiel_unit_op created above */
id|field_op
op_assign
id|op-&gt;value.arg
suffix:semicolon
id|op-&gt;node
op_assign
id|node
suffix:semicolon
id|field_op
op_assign
id|op-&gt;value.arg
suffix:semicolon
id|field_op-&gt;node
op_assign
id|node
suffix:semicolon
id|acpi_ps_delete_parse_tree
(paren
id|op
)paren
suffix:semicolon
multiline_comment|/* Acpi_evaluate the address and length arguments for the Op_region */
id|op
op_assign
id|acpi_ps_alloc_op
(paren
id|AML_SCOPE_OP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
id|op-&gt;node
op_assign
id|acpi_ns_get_parent_object
(paren
id|node
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ps_parse_aml
(paren
id|op
comma
id|extra_desc-&gt;extra.pcode
comma
id|extra_desc-&gt;extra.pcode_length
comma
id|ACPI_PARSE_EXECUTE
op_or
id|ACPI_PARSE_DELETE_TREE
comma
l_int|NULL
multiline_comment|/*Method_desc*/
comma
l_int|NULL
comma
l_int|NULL
comma
id|acpi_ds_exec_begin_op
comma
id|acpi_ds_exec_end_op
)paren
suffix:semicolon
multiline_comment|/* All done with the parse tree, delete it */
id|acpi_ps_delete_parse_tree
(paren
id|op
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * The pseudo-method object is no longer needed since the region is&n;&t; * now initialized&n;&t; */
id|acpi_cm_remove_reference
(paren
id|obj_desc-&gt;field_unit.extra
)paren
suffix:semicolon
id|obj_desc-&gt;field_unit.extra
op_assign
l_int|NULL
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    Acpi_ds_get_region_arguments&n; *&n; * PARAMETERS:  Obj_desc        - A valid region object&n; *&n; * RETURN:      Status.&n; *&n; * DESCRIPTION: Get region address and length.  This implements the late&n; *              evaluation of these region attributes.&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ds_get_region_arguments
id|acpi_ds_get_region_arguments
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
)paren
(brace
id|ACPI_OPERAND_OBJECT
op_star
id|extra_desc
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_NAMESPACE_NODE
op_star
id|node
suffix:semicolon
id|ACPI_PARSE_OBJECT
op_star
id|op
suffix:semicolon
id|ACPI_PARSE_OBJECT
op_star
id|region_op
suffix:semicolon
id|ACPI_STATUS
id|status
suffix:semicolon
id|ACPI_TABLE_DESC
op_star
id|table_desc
suffix:semicolon
r_if
c_cond
(paren
id|obj_desc-&gt;region.flags
op_amp
id|AOPOBJ_DATA_VALID
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the AML pointer (method object) and region node */
id|extra_desc
op_assign
id|obj_desc-&gt;region.extra
suffix:semicolon
id|node
op_assign
id|obj_desc-&gt;region.node
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate a new parser op to be the root of the parsed&n;&t; * Op_region tree&n;&t; */
id|op
op_assign
id|acpi_ps_alloc_op
(paren
id|AML_SCOPE_OP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
multiline_comment|/* Save the Node for use in Acpi_ps_parse_aml */
id|op-&gt;node
op_assign
id|acpi_ns_get_parent_object
(paren
id|node
)paren
suffix:semicolon
multiline_comment|/* Get a handle to the parent ACPI table */
id|status
op_assign
id|acpi_tb_handle_to_object
(paren
id|node-&gt;owner_id
comma
op_amp
id|table_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* Parse the entire Op_region declaration, creating a parse tree */
id|status
op_assign
id|acpi_ps_parse_aml
(paren
id|op
comma
id|extra_desc-&gt;extra.pcode
comma
id|extra_desc-&gt;extra.pcode_length
comma
l_int|0
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
comma
id|acpi_ds_load1_begin_op
comma
id|acpi_ds_load1_end_op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|acpi_ps_delete_parse_tree
(paren
id|op
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* Get and init the actual Region_op created above */
id|region_op
op_assign
id|op-&gt;value.arg
suffix:semicolon
id|op-&gt;node
op_assign
id|node
suffix:semicolon
id|region_op
op_assign
id|op-&gt;value.arg
suffix:semicolon
id|region_op-&gt;node
op_assign
id|node
suffix:semicolon
id|acpi_ps_delete_parse_tree
(paren
id|op
)paren
suffix:semicolon
multiline_comment|/* Acpi_evaluate the address and length arguments for the Op_region */
id|op
op_assign
id|acpi_ps_alloc_op
(paren
id|AML_SCOPE_OP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
id|op-&gt;node
op_assign
id|acpi_ns_get_parent_object
(paren
id|node
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ps_parse_aml
(paren
id|op
comma
id|extra_desc-&gt;extra.pcode
comma
id|extra_desc-&gt;extra.pcode_length
comma
id|ACPI_PARSE_EXECUTE
op_or
id|ACPI_PARSE_DELETE_TREE
comma
l_int|NULL
multiline_comment|/*Method_desc*/
comma
l_int|NULL
comma
l_int|NULL
comma
id|acpi_ds_exec_begin_op
comma
id|acpi_ds_exec_end_op
)paren
suffix:semicolon
multiline_comment|/* All done with the parse tree, delete it */
id|acpi_ps_delete_parse_tree
(paren
id|op
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    Acpi_ds_initialize_region&n; *&n; * PARAMETERS:  Op              - A valid region Op object&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION:&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ds_initialize_region
id|acpi_ds_initialize_region
(paren
id|ACPI_HANDLE
id|obj_handle
)paren
(brace
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
suffix:semicolon
id|ACPI_STATUS
id|status
suffix:semicolon
id|obj_desc
op_assign
id|acpi_ns_get_attached_object
(paren
id|obj_handle
)paren
suffix:semicolon
multiline_comment|/* Namespace is NOT locked */
id|status
op_assign
id|acpi_ev_initialize_region
(paren
id|obj_desc
comma
id|FALSE
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    Acpi_ds_eval_field_unit_operands&n; *&n; * PARAMETERS:  Op              - A valid Field_unit Op object&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Get Field_unit Buffer and Index&n; *              Called from Acpi_ds_exec_end_op during Field_unit parse tree walk&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ds_eval_field_unit_operands
id|acpi_ds_eval_field_unit_operands
(paren
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_PARSE_OBJECT
op_star
id|op
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|field_desc
suffix:semicolon
id|ACPI_NAMESPACE_NODE
op_star
id|node
suffix:semicolon
id|ACPI_PARSE_OBJECT
op_star
id|next_op
suffix:semicolon
id|u32
id|offset
suffix:semicolon
id|u32
id|bit_offset
suffix:semicolon
id|u16
id|bit_count
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|res_desc
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|cnt_desc
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|off_desc
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|src_desc
op_assign
l_int|NULL
suffix:semicolon
id|u32
id|num_operands
op_assign
l_int|3
suffix:semicolon
multiline_comment|/*&n;&t; * This is where we evaluate the address and length fields of the Op_field_unit declaration&n;&t; */
id|node
op_assign
id|op-&gt;node
suffix:semicolon
multiline_comment|/* Next_op points to the op that holds the Buffer */
id|next_op
op_assign
id|op-&gt;value.arg
suffix:semicolon
multiline_comment|/* Acpi_evaluate/create the address and length operands */
id|status
op_assign
id|acpi_ds_create_operands
(paren
id|walk_state
comma
id|next_op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
id|field_desc
op_assign
id|acpi_ns_get_attached_object
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|field_desc
)paren
(brace
r_return
(paren
id|AE_NOT_EXIST
)paren
suffix:semicolon
)brace
multiline_comment|/* Resolve the operands */
id|status
op_assign
id|acpi_aml_resolve_operands
(paren
id|op-&gt;opcode
comma
id|WALK_OPERANDS
comma
id|walk_state
)paren
suffix:semicolon
multiline_comment|/* Get the operands */
id|status
op_or_assign
id|acpi_ds_obj_stack_pop_object
(paren
op_amp
id|res_desc
comma
id|walk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|AML_CREATE_FIELD_OP
op_eq
id|op-&gt;opcode
)paren
(brace
id|num_operands
op_assign
l_int|4
suffix:semicolon
id|status
op_or_assign
id|acpi_ds_obj_stack_pop_object
(paren
op_amp
id|cnt_desc
comma
id|walk_state
)paren
suffix:semicolon
)brace
id|status
op_or_assign
id|acpi_ds_obj_stack_pop_object
(paren
op_amp
id|off_desc
comma
id|walk_state
)paren
suffix:semicolon
id|status
op_or_assign
id|acpi_ds_obj_stack_pop_object
(paren
op_amp
id|src_desc
comma
id|walk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
multiline_comment|/* Invalid parameters on object stack  */
r_goto
id|cleanup
suffix:semicolon
)brace
id|offset
op_assign
(paren
id|u32
)paren
id|off_desc-&gt;number.value
suffix:semicolon
multiline_comment|/*&n;&t; * If Res_desc is a Name, it will be a direct name pointer after&n;&t; * Acpi_aml_resolve_operands()&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|VALID_DESCRIPTOR_TYPE
(paren
id|res_desc
comma
id|ACPI_DESC_TYPE_NAMED
)paren
)paren
(brace
id|status
op_assign
id|AE_AML_OPERAND_TYPE
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Setup the Bit offsets and counts, according to the opcode&n;&t; */
r_switch
c_cond
(paren
id|op-&gt;opcode
)paren
(brace
multiline_comment|/* Def_create_bit_field */
r_case
id|AML_BIT_FIELD_OP
suffix:colon
multiline_comment|/* Offset is in bits, Field is a bit */
id|bit_offset
op_assign
id|offset
suffix:semicolon
id|bit_count
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Def_create_byte_field */
r_case
id|AML_BYTE_FIELD_OP
suffix:colon
multiline_comment|/* Offset is in bytes, field is a byte */
id|bit_offset
op_assign
l_int|8
op_star
id|offset
suffix:semicolon
id|bit_count
op_assign
l_int|8
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Def_create_word_field */
r_case
id|AML_WORD_FIELD_OP
suffix:colon
multiline_comment|/* Offset is in bytes, field is a word */
id|bit_offset
op_assign
l_int|8
op_star
id|offset
suffix:semicolon
id|bit_count
op_assign
l_int|16
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Def_create_dWord_field */
r_case
id|AML_DWORD_FIELD_OP
suffix:colon
multiline_comment|/* Offset is in bytes, field is a dword */
id|bit_offset
op_assign
l_int|8
op_star
id|offset
suffix:semicolon
id|bit_count
op_assign
l_int|32
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Def_create_field */
r_case
id|AML_CREATE_FIELD_OP
suffix:colon
multiline_comment|/* Offset is in bits, count is in bits */
id|bit_offset
op_assign
id|offset
suffix:semicolon
id|bit_count
op_assign
(paren
id|u16
)paren
id|cnt_desc-&gt;number.value
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
id|AE_AML_BAD_OPCODE
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Setup field according to the object type&n;&t; */
r_switch
c_cond
(paren
id|src_desc-&gt;common.type
)paren
(brace
multiline_comment|/* Source_buff :=  Term_arg=&gt;Buffer */
r_case
id|ACPI_TYPE_BUFFER
suffix:colon
r_if
c_cond
(paren
id|bit_offset
op_plus
(paren
id|u32
)paren
id|bit_count
OG
(paren
l_int|8
op_star
(paren
id|u32
)paren
id|src_desc-&gt;buffer.length
)paren
)paren
(brace
id|status
op_assign
id|AE_AML_BUFFER_LIMIT
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* Construct the remainder of the field object */
id|field_desc-&gt;field_unit.access
op_assign
(paren
id|u8
)paren
id|ACCESS_ANY_ACC
suffix:semicolon
id|field_desc-&gt;field_unit.lock_rule
op_assign
(paren
id|u8
)paren
id|GLOCK_NEVER_LOCK
suffix:semicolon
id|field_desc-&gt;field_unit.update_rule
op_assign
(paren
id|u8
)paren
id|UPDATE_PRESERVE
suffix:semicolon
id|field_desc-&gt;field_unit.length
op_assign
id|bit_count
suffix:semicolon
id|field_desc-&gt;field_unit.bit_offset
op_assign
(paren
id|u8
)paren
(paren
id|bit_offset
op_mod
l_int|8
)paren
suffix:semicolon
id|field_desc-&gt;field_unit.offset
op_assign
id|DIV_8
(paren
id|bit_offset
)paren
suffix:semicolon
id|field_desc-&gt;field_unit.container
op_assign
id|src_desc
suffix:semicolon
multiline_comment|/* Reference count for Src_desc inherits Field_desc count */
id|src_desc-&gt;common.reference_count
op_assign
(paren
id|u16
)paren
(paren
id|src_desc-&gt;common.reference_count
op_plus
id|field_desc-&gt;common.reference_count
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Improper object type */
r_default
suffix:colon
(brace
)brace
r_if
c_cond
(paren
(paren
id|src_desc-&gt;common.type
OG
(paren
id|u8
)paren
id|INTERNAL_TYPE_REFERENCE
)paren
op_logical_or
op_logical_neg
id|acpi_cm_valid_object_type
(paren
id|src_desc-&gt;common.type
)paren
)paren
id|status
op_assign
id|AE_AML_OPERAND_TYPE
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_if
c_cond
(paren
id|AML_CREATE_FIELD_OP
op_eq
id|op-&gt;opcode
)paren
(brace
multiline_comment|/* Delete object descriptor unique to Create_field */
id|acpi_cm_remove_reference
(paren
id|cnt_desc
)paren
suffix:semicolon
id|cnt_desc
op_assign
l_int|NULL
suffix:semicolon
)brace
id|cleanup
suffix:colon
multiline_comment|/* Always delete the operands */
id|acpi_cm_remove_reference
(paren
id|off_desc
)paren
suffix:semicolon
id|acpi_cm_remove_reference
(paren
id|src_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|AML_CREATE_FIELD_OP
op_eq
id|op-&gt;opcode
)paren
(brace
id|acpi_cm_remove_reference
(paren
id|cnt_desc
)paren
suffix:semicolon
)brace
multiline_comment|/* On failure, delete the result descriptor */
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|acpi_cm_remove_reference
(paren
id|res_desc
)paren
suffix:semicolon
multiline_comment|/* Result descriptor */
)brace
r_else
(brace
multiline_comment|/* Now the address and length are valid for this op_field_unit */
id|field_desc-&gt;field_unit.flags
op_or_assign
id|AOPOBJ_DATA_VALID
suffix:semicolon
)brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    Acpi_ds_eval_region_operands&n; *&n; * PARAMETERS:  Op              - A valid region Op object&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Get region address and length&n; *              Called from Acpi_ds_exec_end_op during Op_region parse tree walk&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ds_eval_region_operands
id|acpi_ds_eval_region_operands
(paren
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_PARSE_OBJECT
op_star
id|op
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|operand_desc
suffix:semicolon
id|ACPI_NAMESPACE_NODE
op_star
id|node
suffix:semicolon
id|ACPI_PARSE_OBJECT
op_star
id|next_op
suffix:semicolon
multiline_comment|/*&n;&t; * This is where we evaluate the address and length fields of the Op_region declaration&n;&t; */
id|node
op_assign
id|op-&gt;node
suffix:semicolon
multiline_comment|/* Next_op points to the op that holds the Space_iD */
id|next_op
op_assign
id|op-&gt;value.arg
suffix:semicolon
multiline_comment|/* Next_op points to address op */
id|next_op
op_assign
id|next_op-&gt;next
suffix:semicolon
multiline_comment|/* Acpi_evaluate/create the address and length operands */
id|status
op_assign
id|acpi_ds_create_operands
(paren
id|walk_state
comma
id|next_op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* Resolve the length and address operands to numbers */
id|status
op_assign
id|acpi_aml_resolve_operands
(paren
id|op-&gt;opcode
comma
id|WALK_OPERANDS
comma
id|walk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
id|obj_desc
op_assign
id|acpi_ns_get_attached_object
(paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|obj_desc
)paren
(brace
r_return
(paren
id|AE_NOT_EXIST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Get the length operand and save it&n;&t; * (at Top of stack)&n;&t; */
id|operand_desc
op_assign
id|walk_state-&gt;operands
(braket
id|walk_state-&gt;num_operands
op_minus
l_int|1
)braket
suffix:semicolon
id|obj_desc-&gt;region.length
op_assign
(paren
id|u32
)paren
id|operand_desc-&gt;number.value
suffix:semicolon
id|acpi_cm_remove_reference
(paren
id|operand_desc
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the address and save it&n;&t; * (at top of stack - 1)&n;&t; */
id|operand_desc
op_assign
id|walk_state-&gt;operands
(braket
id|walk_state-&gt;num_operands
op_minus
l_int|2
)braket
suffix:semicolon
id|obj_desc-&gt;region.address
op_assign
(paren
id|ACPI_PHYSICAL_ADDRESS
)paren
id|operand_desc-&gt;number.value
suffix:semicolon
id|acpi_cm_remove_reference
(paren
id|operand_desc
)paren
suffix:semicolon
multiline_comment|/* Now the address and length are valid for this opregion */
id|obj_desc-&gt;region.flags
op_or_assign
id|AOPOBJ_DATA_VALID
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ds_exec_begin_control_op&n; *&n; * PARAMETERS:  Walk_list       - The list that owns the walk stack&n; *              Op              - The control Op&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Handles all control ops encountered during control method&n; *              execution.&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ds_exec_begin_control_op
id|acpi_ds_exec_begin_control_op
(paren
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_PARSE_OBJECT
op_star
id|op
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|ACPI_GENERIC_STATE
op_star
id|control_state
suffix:semicolon
r_switch
c_cond
(paren
id|op-&gt;opcode
)paren
(brace
r_case
id|AML_IF_OP
suffix:colon
r_case
id|AML_WHILE_OP
suffix:colon
multiline_comment|/*&n;&t;&t; * IF/WHILE: Create a new control state to manage these&n;&t;&t; * constructs. We need to manage these as a stack, in order&n;&t;&t; * to handle nesting.&n;&t;&t; */
id|control_state
op_assign
id|acpi_cm_create_control_state
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|control_state
)paren
(brace
id|status
op_assign
id|AE_NO_MEMORY
suffix:semicolon
r_break
suffix:semicolon
)brace
id|acpi_cm_push_generic_state
(paren
op_amp
id|walk_state-&gt;control_state
comma
id|control_state
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Save a pointer to the predicate for multiple executions&n;&t;&t; * of a loop&n;&t;&t; */
id|walk_state-&gt;control_state-&gt;control.aml_predicate_start
op_assign
id|walk_state-&gt;parser_state-&gt;aml
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* TBD: can this be removed? */
multiline_comment|/*Acpi_ps_pkg_length_encoding_size (GET8 (Walk_state-&gt;Parser_state-&gt;Aml));*/
r_break
suffix:semicolon
r_case
id|AML_ELSE_OP
suffix:colon
multiline_comment|/* Predicate is in the state object */
multiline_comment|/* If predicate is true, the IF was executed, ignore ELSE part */
r_if
c_cond
(paren
id|walk_state-&gt;last_predicate
)paren
(brace
id|status
op_assign
id|AE_CTRL_TRUE
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AML_RETURN_OP
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ds_exec_end_control_op&n; *&n; * PARAMETERS:  Walk_list       - The list that owns the walk stack&n; *              Op              - The control Op&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Handles all control ops encountered during control method&n; *              execution.&n; *&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ds_exec_end_control_op
id|acpi_ds_exec_end_control_op
(paren
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_PARSE_OBJECT
op_star
id|op
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|ACPI_GENERIC_STATE
op_star
id|control_state
suffix:semicolon
r_switch
c_cond
(paren
id|op-&gt;opcode
)paren
(brace
r_case
id|AML_IF_OP
suffix:colon
multiline_comment|/*&n;&t;&t; * Save the result of the predicate in case there is an&n;&t;&t; * ELSE to come&n;&t;&t; */
id|walk_state-&gt;last_predicate
op_assign
(paren
id|u8
)paren
id|walk_state-&gt;control_state-&gt;common.value
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Pop the control state that was created at the start&n;&t;&t; * of the IF and free it&n;&t;&t; */
id|control_state
op_assign
id|acpi_cm_pop_generic_state
(paren
op_amp
id|walk_state-&gt;control_state
)paren
suffix:semicolon
id|acpi_cm_delete_generic_state
(paren
id|control_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_ELSE_OP
suffix:colon
r_break
suffix:semicolon
r_case
id|AML_WHILE_OP
suffix:colon
r_if
c_cond
(paren
id|walk_state-&gt;control_state-&gt;common.value
)paren
(brace
multiline_comment|/* Predicate was true, go back and evaluate it again! */
id|status
op_assign
id|AE_CTRL_PENDING
suffix:semicolon
)brace
multiline_comment|/* Pop this control state and free it */
id|control_state
op_assign
id|acpi_cm_pop_generic_state
(paren
op_amp
id|walk_state-&gt;control_state
)paren
suffix:semicolon
id|walk_state-&gt;aml_last_while
op_assign
id|control_state-&gt;control.aml_predicate_start
suffix:semicolon
id|acpi_cm_delete_generic_state
(paren
id|control_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_RETURN_OP
suffix:colon
multiline_comment|/*&n;&t;&t; * One optional operand -- the return value&n;&t;&t; * It can be either an immediate operand or a result that&n;&t;&t; * has been bubbled up the tree&n;&t;&t; */
r_if
c_cond
(paren
id|op-&gt;value.arg
)paren
(brace
multiline_comment|/* Return statement has an immediate operand */
id|status
op_assign
id|acpi_ds_create_operands
(paren
id|walk_state
comma
id|op-&gt;value.arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * If value being returned is a Reference (such as&n;&t;&t;&t; * an arg or local), resolve it now because it may&n;&t;&t;&t; * cease to exist at the end of the method.&n;&t;&t;&t; */
id|status
op_assign
id|acpi_aml_resolve_to_value
(paren
op_amp
id|walk_state-&gt;operands
(braket
l_int|0
)braket
comma
id|walk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Get the return value and save as the last result&n;&t;&t;&t; * value.  This is the only place where Walk_state-&gt;Return_desc&n;&t;&t;&t; * is set to anything other than zero!&n;&t;&t;&t; */
id|walk_state-&gt;return_desc
op_assign
id|walk_state-&gt;operands
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|walk_state-&gt;results
)paren
op_logical_and
(paren
id|walk_state-&gt;results-&gt;results.num_results
OG
l_int|0
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * The return value has come from a previous calculation.&n;&t;&t;&t; *&n;&t;&t;&t; * If value being returned is a Reference (such as&n;&t;&t;&t; * an arg or local), resolve it now because it may&n;&t;&t;&t; * cease to exist at the end of the method.&n;&t;&t;&t; */
id|status
op_assign
id|acpi_aml_resolve_to_value
(paren
op_amp
id|walk_state-&gt;results-&gt;results.obj_desc
(braket
l_int|0
)braket
comma
id|walk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
id|walk_state-&gt;return_desc
op_assign
id|walk_state-&gt;results-&gt;results.obj_desc
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* No return operand */
r_if
c_cond
(paren
id|walk_state-&gt;num_operands
)paren
(brace
id|acpi_cm_remove_reference
(paren
id|walk_state-&gt;operands
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
id|walk_state-&gt;operands
(braket
l_int|0
)braket
op_assign
l_int|NULL
suffix:semicolon
id|walk_state-&gt;num_operands
op_assign
l_int|0
suffix:semicolon
id|walk_state-&gt;return_desc
op_assign
l_int|NULL
suffix:semicolon
)brace
multiline_comment|/* End the control method execution right now */
id|status
op_assign
id|AE_CTRL_TERMINATE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_NOOP_OP
suffix:colon
multiline_comment|/* Just do nothing! */
r_break
suffix:semicolon
r_case
id|AML_BREAK_POINT_OP
suffix:colon
multiline_comment|/* Call up to the OS dependent layer to handle this */
id|acpi_os_breakpoint
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* If it returns, we are done! */
r_break
suffix:semicolon
r_case
id|AML_BREAK_OP
suffix:colon
multiline_comment|/*&n;&t;&t; * As per the ACPI specification:&n;&t;&t; *      &quot;The break operation causes the current package&n;&t;&t; *          execution to complete&quot;&n;&t;&t; *      &quot;Break -- Stop executing the current code package&n;&t;&t; *          at this point&quot;&n;&t;&t; *&n;&t;&t; * Returning AE_FALSE here will cause termination of&n;&t;&t; * the current package, and execution will continue one&n;&t;&t; * level up, starting with the completion of the parent Op.&n;&t;&t; */
id|status
op_assign
id|AE_CTRL_FALSE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
id|AE_AML_BAD_OPCODE
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
eof
