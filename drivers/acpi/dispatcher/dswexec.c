multiline_comment|/******************************************************************************&n; *&n; * Module Name: dswexec - Dispatcher method execution callbacks;&n; *                          Dispatch to interpreter.&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;parser.h&quot;
macro_line|#include &quot;amlcode.h&quot;
macro_line|#include &quot;dispatch.h&quot;
macro_line|#include &quot;interp.h&quot;
macro_line|#include &quot;namesp.h&quot;
macro_line|#include &quot;debugger.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          DISPATCHER
id|MODULE_NAME
(paren
l_string|&quot;dswexec&quot;
)paren
suffix:semicolon
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    Acpi_ds_exec_begin_op&n; *&n; * PARAMETERS:  Walk_state      - Current state of the parse tree walk&n; *              Op              - Op that has been just been reached in the&n; *                                walk;  Arguments have not been evaluated yet.&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Descending callback used during the execution of control&n; *              methods.  This is where most operators and operands are&n; *              dispatched to the interpreter.&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ds_exec_begin_op
id|acpi_ds_exec_begin_op
(paren
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_GENERIC_OP
op_star
id|op
)paren
(brace
id|ACPI_OP_INFO
op_star
id|op_info
suffix:semicolon
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
r_if
c_cond
(paren
id|op
op_eq
id|walk_state-&gt;origin
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * If the previous opcode was a conditional, this opcode&n;&t; * must be the beginning of the associated predicate.&n;&t; * Save this knowledge in the current scope descriptor&n;&t; */
r_if
c_cond
(paren
(paren
id|walk_state-&gt;control_state
)paren
op_logical_and
(paren
id|walk_state-&gt;control_state-&gt;common.state
op_eq
id|CONTROL_CONDITIONAL_EXECUTING
)paren
)paren
(brace
id|walk_state-&gt;control_state-&gt;common.state
op_assign
id|CONTROL_PREDICATE_EXECUTING
suffix:semicolon
multiline_comment|/* Save start of predicate */
id|walk_state-&gt;control_state-&gt;control.predicate_op
op_assign
id|op
suffix:semicolon
)brace
id|op_info
op_assign
id|acpi_ps_get_opcode_info
(paren
id|op-&gt;opcode
)paren
suffix:semicolon
multiline_comment|/* We want to send namepaths to the load code */
r_if
c_cond
(paren
id|op-&gt;opcode
op_eq
id|AML_NAMEPATH_OP
)paren
(brace
id|op_info-&gt;flags
op_assign
id|OPTYPE_NAMED_OBJECT
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Handle the opcode based upon the opcode type&n;&t; */
r_switch
c_cond
(paren
id|op_info-&gt;flags
op_amp
id|OP_INFO_TYPE
)paren
(brace
r_case
id|OPTYPE_CONTROL
suffix:colon
id|status
op_assign
id|acpi_ds_exec_begin_control_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPTYPE_NAMED_OBJECT
suffix:colon
r_if
c_cond
(paren
id|walk_state-&gt;origin-&gt;opcode
op_eq
id|AML_METHOD_OP
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Found a named object declaration during method&n;&t;&t;&t; * execution;  we must enter this object into the&n;&t;&t;&t; * namespace.  The created object is temporary and&n;&t;&t;&t; * will be deleted upon completion of the execution&n;&t;&t;&t; * of this method.&n;&t;&t;&t; */
id|status
op_assign
id|acpi_ds_load2_begin_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
multiline_comment|/* Nothing to do here during method execution */
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    Acpi_ds_exec_end_op&n; *&n; * PARAMETERS:  Walk_state      - Current state of the parse tree walk&n; *              Op              - Op that has been just been completed in the&n; *                                walk;  Arguments have now been evaluated.&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Ascending callback used during the execution of control&n; *              methods.  The only thing we really need to do here is to&n; *              notice the beginning of IF, ELSE, and WHILE blocks.&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ds_exec_end_op
id|acpi_ds_exec_end_op
(paren
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_GENERIC_OP
op_star
id|op
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|u16
id|opcode
suffix:semicolon
id|u8
id|optype
suffix:semicolon
id|ACPI_OBJECT_INTERNAL
op_star
id|obj_desc
suffix:semicolon
id|ACPI_GENERIC_OP
op_star
id|next_op
suffix:semicolon
id|ACPI_NAMED_OBJECT
op_star
id|entry
suffix:semicolon
id|ACPI_GENERIC_OP
op_star
id|first_arg
suffix:semicolon
id|ACPI_OBJECT_INTERNAL
op_star
id|result_obj
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_OP_INFO
op_star
id|op_info
suffix:semicolon
id|u32
id|operand_index
suffix:semicolon
id|opcode
op_assign
(paren
id|u16
)paren
id|op-&gt;opcode
suffix:semicolon
id|op_info
op_assign
id|acpi_ps_get_opcode_info
(paren
id|op-&gt;opcode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op_info
)paren
(brace
r_return
(paren
id|AE_NOT_IMPLEMENTED
)paren
suffix:semicolon
)brace
id|optype
op_assign
(paren
id|u8
)paren
(paren
id|op_info-&gt;flags
op_amp
id|OP_INFO_TYPE
)paren
suffix:semicolon
id|first_arg
op_assign
id|op-&gt;value.arg
suffix:semicolon
multiline_comment|/* Init the walk state */
id|walk_state-&gt;num_operands
op_assign
l_int|0
suffix:semicolon
id|walk_state-&gt;return_desc
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Call debugger for single step support (DEBUG build only) */
multiline_comment|/* Decode the opcode */
r_switch
c_cond
(paren
id|optype
)paren
(brace
r_case
id|OPTYPE_UNDEFINED
suffix:colon
r_return
(paren
id|AE_NOT_IMPLEMENTED
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPTYPE_BOGUS
suffix:colon
r_break
suffix:semicolon
r_case
id|OPTYPE_CONSTANT
suffix:colon
multiline_comment|/* argument type only */
r_case
id|OPTYPE_LITERAL
suffix:colon
multiline_comment|/* argument type only */
r_case
id|OPTYPE_DATA_TERM
suffix:colon
multiline_comment|/* argument type only */
r_case
id|OPTYPE_LOCAL_VARIABLE
suffix:colon
multiline_comment|/* argument type only */
r_case
id|OPTYPE_METHOD_ARGUMENT
suffix:colon
multiline_comment|/* argument type only */
r_break
suffix:semicolon
multiline_comment|/* most operators with arguments */
r_case
id|OPTYPE_MONADIC1
suffix:colon
r_case
id|OPTYPE_DYADIC1
suffix:colon
r_case
id|OPTYPE_MONADIC2
suffix:colon
r_case
id|OPTYPE_MONADIC2_r
suffix:colon
r_case
id|OPTYPE_DYADIC2
suffix:colon
r_case
id|OPTYPE_DYADIC2_r
suffix:colon
r_case
id|OPTYPE_DYADIC2_s
suffix:colon
r_case
id|OPTYPE_RECONFIGURATION
suffix:colon
r_case
id|OPTYPE_INDEX
suffix:colon
r_case
id|OPTYPE_MATCH
suffix:colon
r_case
id|OPTYPE_CREATE_FIELD
suffix:colon
r_case
id|OPTYPE_FATAL
suffix:colon
id|status
op_assign
id|acpi_ds_create_operands
(paren
id|walk_state
comma
id|first_arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
id|operand_index
op_assign
id|walk_state-&gt;num_operands
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|optype
)paren
(brace
r_case
id|OPTYPE_MONADIC1
suffix:colon
multiline_comment|/* 1 Operand, 0 External_result, 0 Internal_result */
id|status
op_assign
id|acpi_aml_exec_monadic1
(paren
id|opcode
comma
id|walk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPTYPE_MONADIC2
suffix:colon
multiline_comment|/* 1 Operand, 0 External_result, 1 Internal_result */
id|status
op_assign
id|acpi_aml_exec_monadic2
(paren
id|opcode
comma
id|walk_state
comma
op_amp
id|result_obj
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_result_stack_push
(paren
id|result_obj
comma
id|walk_state
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OPTYPE_MONADIC2_r
suffix:colon
multiline_comment|/* 1 Operand, 1 External_result, 1 Internal_result */
id|status
op_assign
id|acpi_aml_exec_monadic2_r
(paren
id|opcode
comma
id|walk_state
comma
op_amp
id|result_obj
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_result_stack_push
(paren
id|result_obj
comma
id|walk_state
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OPTYPE_DYADIC1
suffix:colon
multiline_comment|/* 2 Operands, 0 External_result, 0 Internal_result */
id|status
op_assign
id|acpi_aml_exec_dyadic1
(paren
id|opcode
comma
id|walk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPTYPE_DYADIC2
suffix:colon
multiline_comment|/* 2 Operands, 0 External_result, 1 Internal_result */
id|status
op_assign
id|acpi_aml_exec_dyadic2
(paren
id|opcode
comma
id|walk_state
comma
op_amp
id|result_obj
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_result_stack_push
(paren
id|result_obj
comma
id|walk_state
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OPTYPE_DYADIC2_r
suffix:colon
multiline_comment|/* 2 Operands, 1 or 2 External_results, 1 Internal_result */
multiline_comment|/* NEW INTERFACE:&n;&t;&t;&t; * Pass in Walk_state, keep result obj but let interpreter&n;&t;&t;&t; * push the result&n;&t;&t;&t; */
id|status
op_assign
id|acpi_aml_exec_dyadic2_r
(paren
id|opcode
comma
id|walk_state
comma
op_amp
id|result_obj
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_result_stack_push
(paren
id|result_obj
comma
id|walk_state
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OPTYPE_DYADIC2_s
suffix:colon
multiline_comment|/* Synchronization Operator */
multiline_comment|/* 2 Operands, 0 External_result, 1 Internal_result */
id|status
op_assign
id|acpi_aml_exec_dyadic2_s
(paren
id|opcode
comma
id|walk_state
comma
op_amp
id|result_obj
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_result_stack_push
(paren
id|result_obj
comma
id|walk_state
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OPTYPE_RECONFIGURATION
suffix:colon
multiline_comment|/* 1 or 2 operands, 0 Internal Result */
id|status
op_assign
id|acpi_aml_exec_reconfiguration
(paren
id|opcode
comma
id|walk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPTYPE_CREATE_FIELD
suffix:colon
multiline_comment|/* 3 or 4 Operands, 0 External_result, 0 Internal_result */
id|status
op_assign
id|acpi_aml_exec_create_field
(paren
id|opcode
comma
id|walk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPTYPE_FATAL
suffix:colon
multiline_comment|/* 3 Operands, 0 External_result, 0 Internal_result */
id|status
op_assign
id|acpi_aml_exec_fatal
(paren
id|walk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPTYPE_INDEX
suffix:colon
multiline_comment|/* Type 2 opcode with 3 operands */
multiline_comment|/* 3 Operands, 1 External_result, 1 Internal_result */
id|status
op_assign
id|acpi_aml_exec_index
(paren
id|walk_state
comma
op_amp
id|result_obj
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_result_stack_push
(paren
id|result_obj
comma
id|walk_state
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OPTYPE_MATCH
suffix:colon
multiline_comment|/* Type 2 opcode with 6 operands */
multiline_comment|/* 6 Operands, 0 External_result, 1 Internal_result */
id|status
op_assign
id|acpi_aml_exec_match
(paren
id|walk_state
comma
op_amp
id|result_obj
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_result_stack_push
(paren
id|result_obj
comma
id|walk_state
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|OPTYPE_CONTROL
suffix:colon
multiline_comment|/* Type 1 opcode, IF/ELSE/WHILE/NOOP */
multiline_comment|/* 1 Operand, 0 External_result, 0 Internal_result */
id|status
op_assign
id|acpi_ds_exec_end_control_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPTYPE_METHOD_CALL
suffix:colon
multiline_comment|/*&n;&t;&t; * (AML_METHODCALL) Op-&gt;Value-&gt;Arg-&gt;Acpi_named_object contains&n;&t;&t; * the method NTE pointer&n;&t;&t; */
multiline_comment|/* Next_op points to the op that holds the method name */
id|next_op
op_assign
id|first_arg
suffix:semicolon
id|entry
op_assign
id|next_op-&gt;acpi_named_object
suffix:semicolon
multiline_comment|/* Next_op points to first argument op */
id|next_op
op_assign
id|next_op-&gt;next
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Get the method&squot;s arguments and put them on the operand stack&n;&t;&t; */
id|status
op_assign
id|acpi_ds_create_operands
(paren
id|walk_state
comma
id|next_op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Since the operands will be passed to another&n;&t;&t; * control method, we must resolve all local&n;&t;&t; * references here (Local variables, arguments&n;&t;&t; * to *this* method, etc.)&n;&t;&t; */
id|status
op_assign
id|acpi_ds_resolve_operands
(paren
id|walk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/* Open new scope on the scope stack */
multiline_comment|/*&n;&t;&t;Status = Acpi_ns_scope_stack_push_entry (Entry);&n;&t;&t;if (ACPI_FAILURE (Status)) {&n;&t;&t;&t;break;&n;&t;&t;}&n;*/
multiline_comment|/* Tell the walk loop to preempt this running method and&n;&t;&t;execute the new method */
id|status
op_assign
id|AE_CTRL_PENDING
suffix:semicolon
multiline_comment|/* Return now; we don&squot;t want to disturb anything,&n;&t;&t;especially the operand count! */
r_return
(paren
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|OPTYPE_NAMED_OBJECT
suffix:colon
r_if
c_cond
(paren
(paren
id|walk_state-&gt;origin-&gt;opcode
op_eq
id|AML_METHOD_OP
)paren
op_logical_and
(paren
id|walk_state-&gt;origin
op_ne
id|op
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_load2_end_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|op-&gt;opcode
)paren
(brace
r_case
id|AML_REGION_OP
suffix:colon
id|status
op_assign
id|acpi_ds_eval_region_operands
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_METHOD_OP
suffix:colon
r_break
suffix:semicolon
r_case
id|AML_ALIAS_OP
suffix:colon
multiline_comment|/* Alias creation was already handled by call&n;&t;&t;&t;to psxload above */
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* Nothing needs to be done */
id|status
op_assign
id|AE_OK
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
id|AE_NOT_IMPLEMENTED
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check if we just completed the evaluation of a&n;&t; * conditional predicate&n;&t; */
r_if
c_cond
(paren
(paren
id|walk_state-&gt;control_state
)paren
op_logical_and
(paren
id|walk_state-&gt;control_state-&gt;common.state
op_eq
id|CONTROL_PREDICATE_EXECUTING
)paren
op_logical_and
(paren
id|walk_state-&gt;control_state-&gt;control.predicate_op
op_eq
id|op
)paren
)paren
(brace
multiline_comment|/* Completed the predicate, the result must be a number */
id|walk_state-&gt;control_state-&gt;common.state
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|result_obj
)paren
(brace
id|status
op_assign
id|acpi_ds_result_stack_pop
(paren
op_amp
id|obj_desc
comma
id|walk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
r_else
(brace
id|status
op_assign
id|acpi_ds_create_operand
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
id|status
op_assign
id|acpi_aml_resolve_to_value
(paren
op_amp
id|walk_state-&gt;operands
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
id|obj_desc
op_assign
id|walk_state-&gt;operands
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|obj_desc
)paren
(brace
id|status
op_assign
id|AE_AML_NO_OPERAND
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
r_if
c_cond
(paren
id|obj_desc-&gt;common.type
op_ne
id|ACPI_TYPE_NUMBER
)paren
(brace
id|status
op_assign
id|AE_AML_OPERAND_TYPE
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* Save the result of the predicate evaluation on&n;&t;&t;the control stack */
r_if
c_cond
(paren
id|obj_desc-&gt;number.value
)paren
(brace
id|walk_state-&gt;control_state-&gt;common.value
op_assign
id|TRUE
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Predicate is FALSE, we will just toss the&n;&t;&t;&t;rest of the package */
id|walk_state-&gt;control_state-&gt;common.value
op_assign
id|FALSE
suffix:semicolon
id|status
op_assign
id|AE_CTRL_FALSE
suffix:semicolon
)brace
multiline_comment|/* Break to debugger to display result */
multiline_comment|/* Delete the predicate result object (we know that&n;&t;&t;we don&squot;t need it anymore) and cleanup the stack */
id|acpi_cm_remove_reference
(paren
id|obj_desc
)paren
suffix:semicolon
id|result_obj
op_assign
l_int|NULL
suffix:semicolon
id|walk_state-&gt;control_state-&gt;common.state
op_assign
id|CONTROL_NORMAL
suffix:semicolon
)brace
id|cleanup
suffix:colon
r_if
c_cond
(paren
id|result_obj
)paren
(brace
multiline_comment|/* Break to debugger to display result */
multiline_comment|/*&n;&t;&t; * Delete the result op if and only if:&n;&t;&t; * Parent will not use the result -- such as any&n;&t;&t; * non-nested type2 op in a method (parent will be method)&n;&t;&t; */
id|acpi_ds_delete_result_if_not_used
(paren
id|op
comma
id|result_obj
comma
id|walk_state
)paren
suffix:semicolon
)brace
multiline_comment|/* Always clear the object stack */
multiline_comment|/* TBD: [Investigate] Clear stack of return value,&n;&t;but don&squot;t delete it */
id|walk_state-&gt;num_operands
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
eof
