multiline_comment|/******************************************************************************&n; *&n; * Module Name: dswload - Dispatcher namespace load callbacks&n; *              $Revision: 24 $&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;acparser.h&quot;
macro_line|#include &quot;amlcode.h&quot;
macro_line|#include &quot;acdispat.h&quot;
macro_line|#include &quot;acinterp.h&quot;
macro_line|#include &quot;acnamesp.h&quot;
macro_line|#include &quot;acevents.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          DISPATCHER
id|MODULE_NAME
(paren
l_string|&quot;dswload&quot;
)paren
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    Acpi_ds_load1_begin_op&n; *&n; * PARAMETERS:  Walk_state      - Current state of the parse tree walk&n; *              Op              - Op that has been just been reached in the&n; *                                walk;  Arguments have not been evaluated yet.&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Descending callback used during the loading of ACPI tables.&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ds_load1_begin_op
id|acpi_ds_load1_begin_op
(paren
id|u16
id|opcode
comma
id|ACPI_PARSE_OBJECT
op_star
id|op
comma
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_PARSE_OBJECT
op_star
op_star
id|out_op
)paren
(brace
id|ACPI_NAMESPACE_NODE
op_star
id|node
suffix:semicolon
id|ACPI_STATUS
id|status
suffix:semicolon
id|OBJECT_TYPE_INTERNAL
id|data_type
suffix:semicolon
id|NATIVE_CHAR
op_star
id|path
suffix:semicolon
multiline_comment|/* We are only interested in opcodes that have an associated name */
r_if
c_cond
(paren
op_logical_neg
id|acpi_ps_is_named_op
(paren
id|opcode
)paren
)paren
(brace
op_star
id|out_op
op_assign
id|op
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Check if this object has already been installed in the namespace */
r_if
c_cond
(paren
id|op
op_logical_and
id|op-&gt;node
)paren
(brace
op_star
id|out_op
op_assign
id|op
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
id|path
op_assign
id|acpi_ps_get_next_namestring
(paren
id|walk_state-&gt;parser_state
)paren
suffix:semicolon
multiline_comment|/* Map the raw opcode into an internal object type */
id|data_type
op_assign
id|acpi_ds_map_named_opcode_to_data_type
(paren
id|opcode
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enter the named type into the internal namespace.  We enter the name&n;&t; * as we go downward in the parse tree.  Any necessary subobjects that involve&n;&t; * arguments to the opcode must be created as we go back up the parse tree later.&n;&t; */
id|status
op_assign
id|acpi_ns_lookup
(paren
id|walk_state-&gt;scope_info
comma
id|path
comma
id|data_type
comma
id|IMODE_LOAD_PASS1
comma
id|NS_NO_UPSEARCH
comma
id|walk_state
comma
op_amp
(paren
id|node
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
multiline_comment|/* Create a new op */
id|op
op_assign
id|acpi_ps_alloc_op
(paren
id|opcode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Initialize */
(paren
(paren
id|ACPI_PARSE2_OBJECT
op_star
)paren
id|op
)paren
op_member_access_from_pointer
id|name
op_assign
id|node-&gt;name
suffix:semicolon
multiline_comment|/*&n;&t; * Put the Node in the &quot;op&quot; object that the parser uses, so we&n;&t; * can get it again quickly when this scope is closed&n;&t; */
id|op-&gt;node
op_assign
id|node
suffix:semicolon
id|acpi_ps_append_arg
(paren
id|acpi_ps_get_parent_scope
(paren
id|walk_state-&gt;parser_state
)paren
comma
id|op
)paren
suffix:semicolon
op_star
id|out_op
op_assign
id|op
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    Acpi_ds_load1_end_op&n; *&n; * PARAMETERS:  Walk_state      - Current state of the parse tree walk&n; *              Op              - Op that has been just been completed in the&n; *                                walk;  Arguments have now been evaluated.&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Ascending callback used during the loading of the namespace,&n; *              both control methods and everything else.&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ds_load1_end_op
id|acpi_ds_load1_end_op
(paren
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_PARSE_OBJECT
op_star
id|op
)paren
(brace
id|OBJECT_TYPE_INTERNAL
id|data_type
suffix:semicolon
multiline_comment|/* We are only interested in opcodes that have an associated name */
r_if
c_cond
(paren
op_logical_neg
id|acpi_ps_is_named_op
(paren
id|op-&gt;opcode
)paren
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the type to determine if we should pop the scope */
id|data_type
op_assign
id|acpi_ds_map_named_opcode_to_data_type
(paren
id|op-&gt;opcode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|op-&gt;opcode
op_eq
id|AML_NAME_OP
)paren
(brace
multiline_comment|/* For Name opcode, check the argument */
r_if
c_cond
(paren
id|op-&gt;value.arg
)paren
(brace
id|data_type
op_assign
id|acpi_ds_map_opcode_to_data_type
(paren
(paren
id|op-&gt;value.arg
)paren
op_member_access_from_pointer
id|opcode
comma
l_int|NULL
)paren
suffix:semicolon
(paren
(paren
id|ACPI_NAMESPACE_NODE
op_star
)paren
id|op-&gt;node
)paren
op_member_access_from_pointer
id|type
op_assign
(paren
id|u8
)paren
id|data_type
suffix:semicolon
)brace
)brace
multiline_comment|/* Pop the scope stack */
r_if
c_cond
(paren
id|acpi_ns_opens_scope
(paren
id|data_type
)paren
)paren
(brace
id|acpi_ds_scope_stack_pop
(paren
id|walk_state
)paren
suffix:semicolon
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    Acpi_ds_load2_begin_op&n; *&n; * PARAMETERS:  Walk_state      - Current state of the parse tree walk&n; *              Op              - Op that has been just been reached in the&n; *                                walk;  Arguments have not been evaluated yet.&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Descending callback used during the loading of ACPI tables.&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ds_load2_begin_op
id|acpi_ds_load2_begin_op
(paren
id|u16
id|opcode
comma
id|ACPI_PARSE_OBJECT
op_star
id|op
comma
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_PARSE_OBJECT
op_star
op_star
id|out_op
)paren
(brace
id|ACPI_NAMESPACE_NODE
op_star
id|node
suffix:semicolon
id|ACPI_STATUS
id|status
suffix:semicolon
id|OBJECT_TYPE_INTERNAL
id|data_type
suffix:semicolon
id|NATIVE_CHAR
op_star
id|buffer_ptr
suffix:semicolon
r_void
op_star
id|original
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* We only care about Namespace opcodes here */
r_if
c_cond
(paren
op_logical_neg
id|acpi_ps_is_namespace_op
(paren
id|opcode
)paren
op_logical_and
id|opcode
op_ne
id|AML_NAMEPATH_OP
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Temp! same code as in psparse */
r_if
c_cond
(paren
op_logical_neg
id|acpi_ps_is_named_op
(paren
id|opcode
)paren
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|op
)paren
(brace
multiline_comment|/*&n;&t;&t; * Get the name we are going to enter or lookup in the namespace&n;&t;&t; */
r_if
c_cond
(paren
id|opcode
op_eq
id|AML_NAMEPATH_OP
)paren
(brace
multiline_comment|/* For Namepath op, get the path string */
id|buffer_ptr
op_assign
id|op-&gt;value.string
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buffer_ptr
)paren
(brace
multiline_comment|/* No name, just exit */
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Get name from the op */
id|buffer_ptr
op_assign
(paren
id|NATIVE_CHAR
op_star
)paren
op_amp
(paren
(paren
id|ACPI_PARSE2_OBJECT
op_star
)paren
id|op
)paren
op_member_access_from_pointer
id|name
suffix:semicolon
)brace
)brace
r_else
(brace
id|buffer_ptr
op_assign
id|acpi_ps_get_next_namestring
(paren
id|walk_state-&gt;parser_state
)paren
suffix:semicolon
)brace
multiline_comment|/* Map the raw opcode into an internal object type */
id|data_type
op_assign
id|acpi_ds_map_named_opcode_to_data_type
(paren
id|opcode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|opcode
op_eq
id|AML_DEF_FIELD_OP
op_logical_or
id|opcode
op_eq
id|AML_BANK_FIELD_OP
op_logical_or
id|opcode
op_eq
id|AML_INDEX_FIELD_OP
)paren
(brace
id|node
op_assign
l_int|NULL
suffix:semicolon
id|status
op_assign
id|AE_OK
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|opcode
op_eq
id|AML_NAMEPATH_OP
)paren
(brace
multiline_comment|/*&n;&t;&t; * The Name_path is an object reference to an existing object. Don&squot;t enter the&n;&t;&t; * name into the namespace, but look it up for use later&n;&t;&t; */
id|status
op_assign
id|acpi_ns_lookup
(paren
id|walk_state-&gt;scope_info
comma
id|buffer_ptr
comma
id|data_type
comma
id|IMODE_EXECUTE
comma
id|NS_SEARCH_PARENT
comma
id|walk_state
comma
op_amp
(paren
id|node
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|op
op_logical_and
id|op-&gt;node
)paren
(brace
id|original
op_assign
id|op-&gt;node
suffix:semicolon
id|node
op_assign
id|op-&gt;node
suffix:semicolon
r_if
c_cond
(paren
id|acpi_ns_opens_scope
(paren
id|data_type
)paren
)paren
(brace
id|status
op_assign
id|acpi_ds_scope_stack_push
(paren
id|node
comma
id|data_type
comma
id|walk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Enter the named type into the internal namespace.  We enter the name&n;&t;&t; * as we go downward in the parse tree.  Any necessary subobjects that involve&n;&t;&t; * arguments to the opcode must be created as we go back up the parse tree later.&n;&t;&t; */
id|status
op_assign
id|acpi_ns_lookup
(paren
id|walk_state-&gt;scope_info
comma
id|buffer_ptr
comma
id|data_type
comma
id|IMODE_EXECUTE
comma
id|NS_NO_UPSEARCH
comma
id|walk_state
comma
op_amp
(paren
id|node
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
multiline_comment|/* Create a new op */
id|op
op_assign
id|acpi_ps_alloc_op
(paren
id|opcode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize */
(paren
(paren
id|ACPI_PARSE2_OBJECT
op_star
)paren
id|op
)paren
op_member_access_from_pointer
id|name
op_assign
id|node-&gt;name
suffix:semicolon
op_star
id|out_op
op_assign
id|op
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Put the Node in the &quot;op&quot; object that the parser uses, so we&n;&t;&t; * can get it again quickly when this scope is closed&n;&t;&t; */
id|op-&gt;node
op_assign
id|node
suffix:semicolon
)brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    Acpi_ds_load2_end_op&n; *&n; * PARAMETERS:  Walk_state      - Current state of the parse tree walk&n; *              Op              - Op that has been just been completed in the&n; *                                walk;  Arguments have now been evaluated.&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Ascending callback used during the loading of the namespace,&n; *              both control methods and everything else.&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ds_load2_end_op
id|acpi_ds_load2_end_op
(paren
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_PARSE_OBJECT
op_star
id|op
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|OBJECT_TYPE_INTERNAL
id|data_type
suffix:semicolon
id|ACPI_NAMESPACE_NODE
op_star
id|node
suffix:semicolon
id|ACPI_PARSE_OBJECT
op_star
id|arg
suffix:semicolon
id|ACPI_NAMESPACE_NODE
op_star
id|new_node
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|acpi_ps_is_namespace_object_op
(paren
id|op-&gt;opcode
)paren
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|op-&gt;opcode
op_eq
id|AML_SCOPE_OP
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|ACPI_PARSE2_OBJECT
op_star
)paren
id|op
)paren
op_member_access_from_pointer
id|name
op_eq
op_minus
l_int|1
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
)brace
id|data_type
op_assign
id|acpi_ds_map_named_opcode_to_data_type
(paren
id|op-&gt;opcode
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the Node/name from the earlier lookup&n;&t; * (It was saved in the *op structure)&n;&t; */
id|node
op_assign
id|op-&gt;node
suffix:semicolon
multiline_comment|/*&n;&t; * Put the Node on the object stack (Contains the ACPI Name of&n;&t; * this object)&n;&t; */
id|walk_state-&gt;operands
(braket
l_int|0
)braket
op_assign
(paren
r_void
op_star
)paren
id|node
suffix:semicolon
id|walk_state-&gt;num_operands
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Pop the scope stack */
r_if
c_cond
(paren
id|acpi_ns_opens_scope
(paren
id|data_type
)paren
)paren
(brace
id|acpi_ds_scope_stack_pop
(paren
id|walk_state
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Named operations are as follows:&n;&t; *&n;&t; * AML_SCOPE&n;&t; * AML_DEVICE&n;&t; * AML_THERMALZONE&n;&t; * AML_METHOD&n;&t; * AML_POWERRES&n;&t; * AML_PROCESSOR&n;&t; * AML_FIELD&n;&t; * AML_INDEXFIELD&n;&t; * AML_BANKFIELD&n;&t; * AML_NAMEDFIELD&n;&t; * AML_NAME&n;&t; * AML_ALIAS&n;&t; * AML_MUTEX&n;&t; * AML_EVENT&n;&t; * AML_OPREGION&n;&t; * AML_CREATEFIELD&n;&t; * AML_CREATEBITFIELD&n;&t; * AML_CREATEBYTEFIELD&n;&t; * AML_CREATEWORDFIELD&n;&t; * AML_CREATEDWORDFIELD&n;&t; * AML_METHODCALL&n;&t; */
multiline_comment|/* Decode the opcode */
id|arg
op_assign
id|op-&gt;value.arg
suffix:semicolon
r_switch
c_cond
(paren
id|op-&gt;opcode
)paren
(brace
r_case
id|AML_CREATE_FIELD_OP
suffix:colon
r_case
id|AML_BIT_FIELD_OP
suffix:colon
r_case
id|AML_BYTE_FIELD_OP
suffix:colon
r_case
id|AML_WORD_FIELD_OP
suffix:colon
r_case
id|AML_DWORD_FIELD_OP
suffix:colon
multiline_comment|/*&n;&t;&t; * Create the field object, but the field buffer and index must&n;&t;&t; * be evaluated later during the execution phase&n;&t;&t; */
multiline_comment|/* Get the Name_string argument */
r_if
c_cond
(paren
id|op-&gt;opcode
op_eq
id|AML_CREATE_FIELD_OP
)paren
(brace
id|arg
op_assign
id|acpi_ps_get_arg
(paren
id|op
comma
l_int|3
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Create Bit/Byte/Word/Dword field */
id|arg
op_assign
id|acpi_ps_get_arg
(paren
id|op
comma
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Enter the Name_string into the namespace&n;&t;&t; */
id|status
op_assign
id|acpi_ns_lookup
(paren
id|walk_state-&gt;scope_info
comma
id|arg-&gt;value.string
comma
id|INTERNAL_TYPE_DEF_ANY
comma
id|IMODE_LOAD_PASS1
comma
id|NS_NO_UPSEARCH
op_or
id|NS_DONT_OPEN_SCOPE
comma
id|walk_state
comma
op_amp
(paren
id|new_node
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
multiline_comment|/* We could put the returned object (Node) on the object stack for later, but&n;&t;&t;&t; * for now, we will put it in the &quot;op&quot; object that the parser uses, so we&n;&t;&t;&t; * can get it again at the end of this scope&n;&t;&t;&t; */
id|op-&gt;node
op_assign
id|new_node
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If there is no object attached to the node, this node was just created and&n;&t;&t;&t; * we need to create the field object.  Otherwise, this was a lookup of an&n;&t;&t;&t; * existing node and we don&squot;t want to create the field object again.&n;&t;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|new_node-&gt;object
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * The Field definition is not fully parsed at this time.&n;&t;&t;&t;&t; * (We must save the address of the AML for the buffer and index operands)&n;&t;&t;&t;&t; */
id|status
op_assign
id|acpi_aml_exec_create_field
(paren
(paren
(paren
id|ACPI_PARSE2_OBJECT
op_star
)paren
id|op
)paren
op_member_access_from_pointer
id|data
comma
(paren
(paren
id|ACPI_PARSE2_OBJECT
op_star
)paren
id|op
)paren
op_member_access_from_pointer
id|length
comma
id|new_node
comma
id|walk_state
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|AML_METHODCALL_OP
suffix:colon
multiline_comment|/*&n;&t;&t; * Lookup the method name and save the Node&n;&t;&t; */
id|status
op_assign
id|acpi_ns_lookup
(paren
id|walk_state-&gt;scope_info
comma
id|arg-&gt;value.string
comma
id|ACPI_TYPE_ANY
comma
id|IMODE_LOAD_PASS2
comma
id|NS_SEARCH_PARENT
op_or
id|NS_DONT_OPEN_SCOPE
comma
id|walk_state
comma
op_amp
(paren
id|new_node
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
multiline_comment|/* has name already been resolved by here ??*/
multiline_comment|/* TBD: [Restructure] Make sure that what we found is indeed a method! */
multiline_comment|/* We didn&squot;t search for a method on purpose, to see if the name would resolve! */
multiline_comment|/* We could put the returned object (Node) on the object stack for later, but&n;&t;&t;&t; * for now, we will put it in the &quot;op&quot; object that the parser uses, so we&n;&t;&t;&t; * can get it again at the end of this scope&n;&t;&t;&t; */
id|op-&gt;node
op_assign
id|new_node
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AML_PROCESSOR_OP
suffix:colon
multiline_comment|/* Nothing to do other than enter object into namespace */
id|status
op_assign
id|acpi_aml_exec_create_processor
(paren
id|op
comma
(paren
id|ACPI_HANDLE
)paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AML_POWER_RES_OP
suffix:colon
multiline_comment|/* Nothing to do other than enter object into namespace */
id|status
op_assign
id|acpi_aml_exec_create_power_resource
(paren
id|op
comma
(paren
id|ACPI_HANDLE
)paren
id|node
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AML_THERMAL_ZONE_OP
suffix:colon
multiline_comment|/* Nothing to do other than enter object into namespace */
r_break
suffix:semicolon
r_case
id|AML_DEF_FIELD_OP
suffix:colon
id|arg
op_assign
id|op-&gt;value.arg
suffix:semicolon
id|status
op_assign
id|acpi_ds_create_field
(paren
id|op
comma
id|arg-&gt;node
comma
id|walk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_INDEX_FIELD_OP
suffix:colon
id|arg
op_assign
id|op-&gt;value.arg
suffix:semicolon
id|status
op_assign
id|acpi_ds_create_index_field
(paren
id|op
comma
(paren
id|ACPI_HANDLE
)paren
id|arg-&gt;node
comma
id|walk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_BANK_FIELD_OP
suffix:colon
id|arg
op_assign
id|op-&gt;value.arg
suffix:semicolon
id|status
op_assign
id|acpi_ds_create_bank_field
(paren
id|op
comma
id|arg-&gt;node
comma
id|walk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/*&n;&t; * Method_op Pkg_length Names_string Method_flags Term_list&n;&t; */
r_case
id|AML_METHOD_OP
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|node-&gt;object
)paren
(brace
id|status
op_assign
id|acpi_aml_exec_create_method
(paren
(paren
(paren
id|ACPI_PARSE2_OBJECT
op_star
)paren
id|op
)paren
op_member_access_from_pointer
id|data
comma
(paren
(paren
id|ACPI_PARSE2_OBJECT
op_star
)paren
id|op
)paren
op_member_access_from_pointer
id|length
comma
id|arg-&gt;value.integer
comma
(paren
id|ACPI_HANDLE
)paren
id|node
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AML_MUTEX_OP
suffix:colon
id|status
op_assign
id|acpi_ds_create_operands
(paren
id|walk_state
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
id|status
op_assign
id|acpi_aml_exec_create_mutex
(paren
id|walk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_EVENT_OP
suffix:colon
id|status
op_assign
id|acpi_ds_create_operands
(paren
id|walk_state
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
id|status
op_assign
id|acpi_aml_exec_create_event
(paren
id|walk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_REGION_OP
suffix:colon
r_if
c_cond
(paren
id|node-&gt;object
)paren
(brace
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * The Op_region is not fully parsed at this time. Only valid argument is the Space_id.&n;&t;&t; * (We must save the address of the AML of the address and length operands)&n;&t;&t; */
id|status
op_assign
id|acpi_aml_exec_create_region
(paren
(paren
(paren
id|ACPI_PARSE2_OBJECT
op_star
)paren
id|op
)paren
op_member_access_from_pointer
id|data
comma
(paren
(paren
id|ACPI_PARSE2_OBJECT
op_star
)paren
id|op
)paren
op_member_access_from_pointer
id|length
comma
(paren
id|ACPI_ADDRESS_SPACE_TYPE
)paren
id|arg-&gt;value.integer
comma
id|walk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
multiline_comment|/* Namespace Modifier Opcodes */
r_case
id|AML_ALIAS_OP
suffix:colon
id|status
op_assign
id|acpi_ds_create_operands
(paren
id|walk_state
comma
id|arg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
id|status
op_assign
id|acpi_aml_exec_create_alias
(paren
id|walk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_NAME_OP
suffix:colon
multiline_comment|/*&n;&t;&t; * Because of the execution pass through the non-control-method&n;&t;&t; * parts of the table, we can arrive here twice.  Only init&n;&t;&t; * the named object node the first time through&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|node-&gt;object
)paren
(brace
id|status
op_assign
id|acpi_ds_create_node
(paren
id|walk_state
comma
id|node
comma
id|op
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|AML_NAMEPATH_OP
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|cleanup
suffix:colon
multiline_comment|/* Remove the Node pushed at the very beginning */
id|acpi_ds_obj_stack_pop
(paren
l_int|1
comma
id|walk_state
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
eof
