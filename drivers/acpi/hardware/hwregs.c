multiline_comment|/*******************************************************************************&n; *&n; * Module Name: hwregs - Read/write access functions for the various ACPI&n; *                       control and status registers.&n; *              $Revision: 67 $&n; *&n; ******************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;achware.h&quot;
macro_line|#include &quot;acnamesp.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          HARDWARE
id|MODULE_NAME
(paren
l_string|&quot;hwregs&quot;
)paren
multiline_comment|/* This matches the #defines in actypes.h. */
DECL|variable|sleep_state_table
id|NATIVE_CHAR
op_star
id|sleep_state_table
(braket
)braket
op_assign
(brace
l_string|&quot;&bslash;&bslash;_S0_&quot;
comma
l_string|&quot;&bslash;&bslash;_S1_&quot;
comma
l_string|&quot;&bslash;&bslash;_S2_&quot;
comma
l_string|&quot;&bslash;&bslash;_S3_&quot;
comma
l_string|&quot;&bslash;&bslash;_S4_&quot;
comma
l_string|&quot;&bslash;&bslash;_S4_b&quot;
comma
l_string|&quot;&bslash;&bslash;_S5_&quot;
)brace
suffix:semicolon
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_hw_get_bit_shift&n; *&n; * PARAMETERS:  Mask            - Input mask to determine bit shift from.&n; *                                Must have at least 1 bit set.&n; *&n; * RETURN:      Bit location of the lsb of the mask&n; *&n; * DESCRIPTION: Returns the bit number for the low order bit that&squot;s set.&n; *&n; ******************************************************************************/
id|u32
DECL|function|acpi_hw_get_bit_shift
id|acpi_hw_get_bit_shift
(paren
id|u32
id|mask
)paren
(brace
id|u32
id|shift
suffix:semicolon
r_for
c_loop
(paren
id|shift
op_assign
l_int|0
suffix:semicolon
(paren
(paren
id|mask
op_rshift
id|shift
)paren
op_amp
l_int|1
)paren
op_eq
l_int|0
suffix:semicolon
id|shift
op_increment
)paren
(brace
suffix:semicolon
)brace
r_return
(paren
id|shift
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_hw_clear_acpi_status&n; *&n; * PARAMETERS:  none&n; *&n; * RETURN:      none&n; *&n; * DESCRIPTION: Clears all fixed and general purpose status bits&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_hw_clear_acpi_status
id|acpi_hw_clear_acpi_status
(paren
r_void
)paren
(brace
id|u16
id|gpe_length
suffix:semicolon
id|u16
id|index
suffix:semicolon
id|acpi_cm_acquire_mutex
(paren
id|ACPI_MTX_HARDWARE
)paren
suffix:semicolon
id|acpi_os_out16
(paren
id|acpi_gbl_FACP-&gt;pm1a_evt_blk
comma
(paren
id|u16
)paren
id|ALL_FIXED_STS_BITS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_gbl_FACP-&gt;pm1b_evt_blk
)paren
(brace
id|acpi_os_out16
(paren
(paren
id|u16
)paren
id|acpi_gbl_FACP-&gt;pm1b_evt_blk
comma
(paren
id|u16
)paren
id|ALL_FIXED_STS_BITS
)paren
suffix:semicolon
)brace
multiline_comment|/* now clear the GPE Bits */
r_if
c_cond
(paren
id|acpi_gbl_FACP-&gt;gpe0blk_len
)paren
(brace
id|gpe_length
op_assign
(paren
id|u16
)paren
id|DIV_2
(paren
id|acpi_gbl_FACP-&gt;gpe0blk_len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|gpe_length
suffix:semicolon
id|index
op_increment
)paren
(brace
id|acpi_os_out8
(paren
(paren
id|acpi_gbl_FACP-&gt;gpe0blk
op_plus
id|index
)paren
comma
(paren
id|u8
)paren
l_int|0xff
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|acpi_gbl_FACP-&gt;gpe1_blk_len
)paren
(brace
id|gpe_length
op_assign
(paren
id|u16
)paren
id|DIV_2
(paren
id|acpi_gbl_FACP-&gt;gpe1_blk_len
)paren
suffix:semicolon
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
id|gpe_length
suffix:semicolon
id|index
op_increment
)paren
(brace
id|acpi_os_out8
(paren
(paren
id|acpi_gbl_FACP-&gt;gpe1_blk
op_plus
id|index
)paren
comma
(paren
id|u8
)paren
l_int|0xff
)paren
suffix:semicolon
)brace
)brace
id|acpi_cm_release_mutex
(paren
id|ACPI_MTX_HARDWARE
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_hw_obtain_sleep_type_register_data&n; *&n; * PARAMETERS:  Sleep_state       - Numeric state requested&n; *              *Slp_Typ_a         - Pointer to byte to receive SLP_TYPa value&n; *              *Slp_Typ_b         - Pointer to byte to receive SLP_TYPb value&n; *&n; * RETURN:      Status - ACPI status&n; *&n; * DESCRIPTION: Acpi_hw_obtain_sleep_type_register_data() obtains the SLP_TYP and&n; *              SLP_TYPb values for the sleep state requested.&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_hw_obtain_sleep_type_register_data
id|acpi_hw_obtain_sleep_type_register_data
(paren
id|u8
id|sleep_state
comma
id|u8
op_star
id|slp_typ_a
comma
id|u8
op_star
id|slp_typ_b
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
suffix:semicolon
multiline_comment|/*&n;&t; *  Validate parameters&n;&t; */
r_if
c_cond
(paren
(paren
id|sleep_state
OG
id|ACPI_S_STATES_MAX
)paren
op_logical_or
op_logical_neg
id|slp_typ_a
op_logical_or
op_logical_neg
id|slp_typ_b
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Acpi_evaluate the namespace object containing the values for this state&n;&t; */
id|status
op_assign
id|acpi_ns_evaluate_by_name
(paren
id|sleep_state_table
(braket
id|sleep_state
)braket
comma
l_int|NULL
comma
op_amp
id|obj_desc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|obj_desc
)paren
(brace
id|REPORT_ERROR
(paren
l_string|&quot;Missing Sleep State object&quot;
)paren
suffix:semicolon
r_return
(paren
id|AE_NOT_EXIST
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  We got something, now ensure it is correct.  The object must&n;&t; *  be a package and must have at least 2 numeric values as the&n;&t; *  two elements&n;&t; */
r_if
c_cond
(paren
id|obj_desc-&gt;common.type
op_ne
id|ACPI_TYPE_PACKAGE
)paren
(brace
multiline_comment|/* Must be a package */
id|REPORT_ERROR
(paren
l_string|&quot;Sleep State object is not of type Package&quot;
)paren
suffix:semicolon
id|status
op_assign
id|AE_ERROR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|obj_desc-&gt;package.count
OL
l_int|2
)paren
(brace
multiline_comment|/* Must have at least two elements */
id|REPORT_ERROR
(paren
l_string|&quot;Sleep State package does not have at least two elements&quot;
)paren
suffix:semicolon
id|status
op_assign
id|AE_ERROR
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
(paren
id|obj_desc-&gt;package.elements
(braket
l_int|0
)braket
)paren
op_member_access_from_pointer
id|common.type
op_ne
id|ACPI_TYPE_NUMBER
)paren
op_logical_or
(paren
(paren
id|obj_desc-&gt;package.elements
(braket
l_int|1
)braket
)paren
op_member_access_from_pointer
id|common.type
op_ne
id|ACPI_TYPE_NUMBER
)paren
)paren
(brace
multiline_comment|/* Must have two  */
id|REPORT_ERROR
(paren
l_string|&quot;Sleep State package elements are not both of type Number&quot;
)paren
suffix:semicolon
id|status
op_assign
id|AE_ERROR
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; *  Valid _Sx_ package size, type, and value&n;&t;&t; */
op_star
id|slp_typ_a
op_assign
(paren
id|u8
)paren
(paren
id|obj_desc-&gt;package.elements
(braket
l_int|0
)braket
)paren
op_member_access_from_pointer
id|number.value
suffix:semicolon
op_star
id|slp_typ_b
op_assign
(paren
id|u8
)paren
(paren
id|obj_desc-&gt;package.elements
(braket
l_int|1
)braket
)paren
op_member_access_from_pointer
id|number.value
suffix:semicolon
)brace
id|acpi_cm_remove_reference
(paren
id|obj_desc
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_hw_register_access&n; *&n; * PARAMETERS:  Read_write      - Either ACPI_READ or ACPI_WRITE.&n; *              Use_lock        - Lock the hardware&n; *              Register_id     - index of ACPI register to access&n; *              Value           - (only used on write) value to write to the&n; *                                 register.  Shifted all the way right.&n; *&n; * RETURN:      Value written to or read from specified register.  This value&n; *              is shifted all the way right.&n; *&n; * DESCRIPTION: Generic ACPI register read/write function.&n; *&n; ******************************************************************************/
id|u32
DECL|function|acpi_hw_register_access
id|acpi_hw_register_access
(paren
id|NATIVE_UINT
id|read_write
comma
id|u8
id|use_lock
comma
id|u32
id|register_id
comma
dot
dot
dot
)paren
multiline_comment|/* Value (only used on write) */
(brace
id|u32
id|register_value
op_assign
l_int|0
suffix:semicolon
id|u32
id|mask
op_assign
l_int|0
suffix:semicolon
id|u32
id|value
op_assign
l_int|0
suffix:semicolon
id|ACPI_IO_ADDRESS
id|gpe_reg
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_WRITE
)paren
(brace
id|va_list
id|marker
suffix:semicolon
id|va_start
(paren
id|marker
comma
id|register_id
)paren
suffix:semicolon
id|value
op_assign
id|va_arg
(paren
id|marker
comma
id|u32
)paren
suffix:semicolon
id|va_end
(paren
id|marker
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * TBD: [Restructure] May want to split the Acpi_event code and the&n;&t; * Control code&n;&t; */
multiline_comment|/*&n;&t; * Decode the Register ID&n;&t; */
r_switch
c_cond
(paren
id|register_id
op_amp
id|REGISTER_BLOCK_MASK
)paren
(brace
r_case
id|PM1_EVT
suffix:colon
r_if
c_cond
(paren
id|register_id
OL
id|TMR_EN
)paren
(brace
multiline_comment|/* status register */
r_if
c_cond
(paren
id|ACPI_MTX_LOCK
op_eq
id|use_lock
)paren
(brace
id|acpi_cm_acquire_mutex
(paren
id|ACPI_MTX_HARDWARE
)paren
suffix:semicolon
)brace
id|register_value
op_assign
(paren
id|u32
)paren
id|acpi_os_in16
(paren
id|acpi_gbl_FACP-&gt;pm1a_evt_blk
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_gbl_FACP-&gt;pm1b_evt_blk
)paren
(brace
id|register_value
op_or_assign
(paren
id|u32
)paren
id|acpi_os_in16
(paren
id|acpi_gbl_FACP-&gt;pm1b_evt_blk
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|register_id
)paren
(brace
r_case
id|TMR_STS
suffix:colon
id|mask
op_assign
id|TMR_STS_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BM_STS
suffix:colon
id|mask
op_assign
id|BM_STS_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GBL_STS
suffix:colon
id|mask
op_assign
id|GBL_STS_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PWRBTN_STS
suffix:colon
id|mask
op_assign
id|PWRBTN_STS_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SLPBTN_STS
suffix:colon
id|mask
op_assign
id|SLPBTN_STS_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RTC_STS
suffix:colon
id|mask
op_assign
id|RTC_STS_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WAK_STS
suffix:colon
id|mask
op_assign
id|WAK_STS_MASK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|mask
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_WRITE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Status registers are different from the rest.  Clear by&n;&t;&t;&t;&t; * writing 1, writing 0 has no effect.  So, the only relevent&n;&t;&t;&t;&t; * information is the single bit we&squot;re interested in, all&n;&t;&t;&t;&t; * others should be written as 0 so they will be left&n;&t;&t;&t;&t; * unchanged&n;&t;&t;&t;&t; */
id|value
op_lshift_assign
id|acpi_hw_get_bit_shift
(paren
id|mask
)paren
suffix:semicolon
id|value
op_and_assign
id|mask
suffix:semicolon
r_if
c_cond
(paren
id|value
)paren
(brace
id|acpi_os_out16
(paren
id|acpi_gbl_FACP-&gt;pm1a_evt_blk
comma
(paren
id|u16
)paren
id|value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_gbl_FACP-&gt;pm1b_evt_blk
)paren
(brace
id|acpi_os_out16
(paren
id|acpi_gbl_FACP-&gt;pm1b_evt_blk
comma
(paren
id|u16
)paren
id|value
)paren
suffix:semicolon
)brace
id|register_value
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ACPI_MTX_LOCK
op_eq
id|use_lock
)paren
(brace
id|acpi_cm_release_mutex
(paren
id|ACPI_MTX_HARDWARE
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* enable register */
r_if
c_cond
(paren
id|ACPI_MTX_LOCK
op_eq
id|use_lock
)paren
(brace
id|acpi_cm_acquire_mutex
(paren
id|ACPI_MTX_HARDWARE
)paren
suffix:semicolon
)brace
id|register_value
op_assign
(paren
id|u32
)paren
id|acpi_os_in16
(paren
id|acpi_gbl_FACP-&gt;pm1a_evt_blk
op_plus
id|DIV_2
(paren
id|acpi_gbl_FACP-&gt;pm1_evt_len
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_gbl_FACP-&gt;pm1b_evt_blk
)paren
(brace
id|register_value
op_or_assign
(paren
id|u32
)paren
id|acpi_os_in16
(paren
id|acpi_gbl_FACP-&gt;pm1b_evt_blk
op_plus
id|DIV_2
(paren
id|acpi_gbl_FACP-&gt;pm1_evt_len
)paren
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|register_id
)paren
(brace
r_case
id|TMR_EN
suffix:colon
id|mask
op_assign
id|TMR_EN_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GBL_EN
suffix:colon
id|mask
op_assign
id|GBL_EN_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|PWRBTN_EN
suffix:colon
id|mask
op_assign
id|PWRBTN_EN_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SLPBTN_EN
suffix:colon
id|mask
op_assign
id|SLPBTN_EN_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RTC_EN
suffix:colon
id|mask
op_assign
id|RTC_EN_MASK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|mask
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_WRITE
)paren
(brace
id|register_value
op_and_assign
op_complement
id|mask
suffix:semicolon
id|value
op_lshift_assign
id|acpi_hw_get_bit_shift
(paren
id|mask
)paren
suffix:semicolon
id|value
op_and_assign
id|mask
suffix:semicolon
id|register_value
op_or_assign
id|value
suffix:semicolon
id|acpi_os_out16
(paren
(paren
id|acpi_gbl_FACP-&gt;pm1a_evt_blk
op_plus
id|DIV_2
(paren
id|acpi_gbl_FACP-&gt;pm1_evt_len
)paren
)paren
comma
(paren
id|u16
)paren
id|register_value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|acpi_gbl_FACP-&gt;pm1b_evt_blk
)paren
(brace
id|acpi_os_out16
(paren
(paren
id|acpi_gbl_FACP-&gt;pm1b_evt_blk
op_plus
id|DIV_2
(paren
id|acpi_gbl_FACP-&gt;pm1_evt_len
)paren
)paren
comma
(paren
id|u16
)paren
id|register_value
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ACPI_MTX_LOCK
op_eq
id|use_lock
)paren
(brace
id|acpi_cm_release_mutex
(paren
id|ACPI_MTX_HARDWARE
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|PM1_CONTROL
suffix:colon
id|register_value
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_MTX_LOCK
op_eq
id|use_lock
)paren
(brace
id|acpi_cm_acquire_mutex
(paren
id|ACPI_MTX_HARDWARE
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|register_id
op_ne
id|SLP_TYPE_B
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * SLP_TYPx registers are written differently&n;&t;&t;&t; * than any other control registers with&n;&t;&t;&t; * respect to A and B registers.  The value&n;&t;&t;&t; * for A may be different than the value for B&n;&t;&t;&t; */
id|register_value
op_assign
(paren
id|u32
)paren
id|acpi_os_in16
(paren
id|acpi_gbl_FACP-&gt;pm1a_cnt_blk
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|acpi_gbl_FACP-&gt;pm1b_cnt_blk
op_logical_and
id|register_id
op_ne
(paren
id|u32
)paren
id|SLP_TYPE_A
)paren
(brace
id|register_value
op_or_assign
(paren
id|u32
)paren
id|acpi_os_in16
(paren
id|acpi_gbl_FACP-&gt;pm1b_cnt_blk
)paren
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|register_id
)paren
(brace
r_case
id|SCI_EN
suffix:colon
id|mask
op_assign
id|SCI_EN_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BM_RLD
suffix:colon
id|mask
op_assign
id|BM_RLD_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GBL_RLS
suffix:colon
id|mask
op_assign
id|GBL_RLS_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SLP_TYPE_A
suffix:colon
r_case
id|SLP_TYPE_B
suffix:colon
id|mask
op_assign
id|SLP_TYPE_X_MASK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SLP_EN
suffix:colon
id|mask
op_assign
id|SLP_EN_MASK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|mask
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_WRITE
)paren
(brace
id|register_value
op_and_assign
op_complement
id|mask
suffix:semicolon
id|value
op_lshift_assign
id|acpi_hw_get_bit_shift
(paren
id|mask
)paren
suffix:semicolon
id|value
op_and_assign
id|mask
suffix:semicolon
id|register_value
op_or_assign
id|value
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * SLP_TYPE_x registers are written differently&n;&t;&t;&t; * than any other control registers with&n;&t;&t;&t; * respect to A and B registers.  The value&n;&t;&t;&t; * for A may be different than the value for B&n;&t;&t;&t; */
r_if
c_cond
(paren
id|register_id
op_ne
id|SLP_TYPE_B
)paren
(brace
r_if
c_cond
(paren
id|mask
op_eq
id|SLP_EN_MASK
)paren
(brace
id|disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* disable interrupts */
)brace
id|acpi_os_out16
(paren
id|acpi_gbl_FACP-&gt;pm1a_cnt_blk
comma
(paren
id|u16
)paren
id|register_value
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mask
op_eq
id|SLP_EN_MASK
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Enable interrupts, the SCI handler is likely going to&n;&t;&t;&t;&t;&t; * be invoked as soon as interrupts are enabled, since gpe&squot;s&n;&t;&t;&t;&t;&t; * and most fixed resume events also generate SCI&squot;s.&n;&t;&t;&t;&t;&t; */
id|enable
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|acpi_gbl_FACP-&gt;pm1b_cnt_blk
op_logical_and
id|register_id
op_ne
(paren
id|u32
)paren
id|SLP_TYPE_A
)paren
(brace
id|acpi_os_out16
(paren
id|acpi_gbl_FACP-&gt;pm1b_cnt_blk
comma
(paren
id|u16
)paren
id|register_value
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ACPI_MTX_LOCK
op_eq
id|use_lock
)paren
(brace
id|acpi_cm_release_mutex
(paren
id|ACPI_MTX_HARDWARE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PM2_CONTROL
suffix:colon
r_if
c_cond
(paren
id|ACPI_MTX_LOCK
op_eq
id|use_lock
)paren
(brace
id|acpi_cm_acquire_mutex
(paren
id|ACPI_MTX_HARDWARE
)paren
suffix:semicolon
)brace
id|register_value
op_assign
(paren
id|u32
)paren
id|acpi_os_in16
(paren
id|acpi_gbl_FACP-&gt;pm2_cnt_blk
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|register_id
)paren
(brace
r_case
id|ARB_DIS
suffix:colon
id|mask
op_assign
id|ARB_DIS_MASK
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|mask
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_WRITE
)paren
(brace
id|register_value
op_and_assign
op_complement
id|mask
suffix:semicolon
id|value
op_lshift_assign
id|acpi_hw_get_bit_shift
(paren
id|mask
)paren
suffix:semicolon
id|value
op_and_assign
id|mask
suffix:semicolon
id|register_value
op_or_assign
id|value
suffix:semicolon
id|acpi_os_out16
(paren
id|acpi_gbl_FACP-&gt;pm2_cnt_blk
comma
(paren
id|u16
)paren
id|register_value
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_MTX_LOCK
op_eq
id|use_lock
)paren
(brace
id|acpi_cm_release_mutex
(paren
id|ACPI_MTX_HARDWARE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PM_TIMER
suffix:colon
id|register_value
op_assign
id|acpi_os_in32
(paren
id|acpi_gbl_FACP-&gt;pm_tmr_blk
)paren
suffix:semicolon
id|mask
op_assign
l_int|0xFFFFFFFF
suffix:semicolon
r_break
suffix:semicolon
r_case
id|GPE1_EN_BLOCK
suffix:colon
id|gpe_reg
op_assign
(paren
id|acpi_gbl_FACP-&gt;gpe1_blk
op_plus
id|acpi_gbl_FACP-&gt;gpe1_base
)paren
op_plus
(paren
id|gpe_reg
op_plus
(paren
id|DIV_2
(paren
id|acpi_gbl_FACP-&gt;gpe1_blk_len
)paren
)paren
)paren
suffix:semicolon
r_case
id|GPE1_STS_BLOCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|gpe_reg
)paren
(brace
id|gpe_reg
op_assign
(paren
id|acpi_gbl_FACP-&gt;gpe1_blk
op_plus
id|acpi_gbl_FACP-&gt;gpe1_base
)paren
suffix:semicolon
)brace
r_case
id|GPE0_EN_BLOCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|gpe_reg
)paren
(brace
id|gpe_reg
op_assign
id|acpi_gbl_FACP-&gt;gpe0blk
op_plus
id|DIV_2
(paren
id|acpi_gbl_FACP-&gt;gpe0blk_len
)paren
suffix:semicolon
)brace
r_case
id|GPE0_STS_BLOCK
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|gpe_reg
)paren
(brace
id|gpe_reg
op_assign
id|acpi_gbl_FACP-&gt;gpe0blk
suffix:semicolon
)brace
multiline_comment|/* Determine the bit to be accessed */
id|mask
op_assign
(paren
(paren
(paren
id|u32
)paren
id|register_id
)paren
op_amp
id|BIT_IN_REGISTER_MASK
)paren
suffix:semicolon
id|mask
op_assign
l_int|1
op_lshift
(paren
id|mask
op_minus
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * The base address of the GPE 0 Register Block&n;&t;&t; * Plus 1/2 the length of the GPE 0 Register Block&n;&t;&t; * The enable register is the register following the Status Register&n;&t;&t; * and each register is defined as 1/2 of the total Register Block&n;&t;&t; */
multiline_comment|/*&n;&t;&t; * This sets the bit within Enable_bit that needs to be written to&n;&t;&t; * the register indicated in Mask to a 1, all others are 0&n;&t;&t; */
r_if
c_cond
(paren
id|mask
OG
id|LOW_BYTE
)paren
(brace
multiline_comment|/* Shift the value 1 byte to the right and add 1 to the register */
id|mask
op_rshift_assign
id|ONE_BYTE
suffix:semicolon
id|gpe_reg
op_increment
suffix:semicolon
)brace
multiline_comment|/* Now get the current Enable Bits in the selected Reg */
r_if
c_cond
(paren
id|ACPI_MTX_LOCK
op_eq
id|use_lock
)paren
(brace
id|acpi_cm_acquire_mutex
(paren
id|ACPI_MTX_HARDWARE
)paren
suffix:semicolon
)brace
id|register_value
op_assign
(paren
id|u32
)paren
id|acpi_os_in8
(paren
id|gpe_reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|read_write
op_eq
id|ACPI_WRITE
)paren
(brace
id|register_value
op_and_assign
op_complement
id|mask
suffix:semicolon
id|value
op_lshift_assign
id|acpi_hw_get_bit_shift
(paren
id|mask
)paren
suffix:semicolon
id|value
op_and_assign
id|mask
suffix:semicolon
id|register_value
op_or_assign
id|value
suffix:semicolon
multiline_comment|/* This write will put the Action state into the General Purpose */
multiline_comment|/* Enable Register indexed by the value in Mask */
id|acpi_os_out8
(paren
id|gpe_reg
comma
(paren
id|u8
)paren
id|register_value
)paren
suffix:semicolon
id|register_value
op_assign
(paren
id|u32
)paren
id|acpi_os_in8
(paren
id|gpe_reg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_MTX_LOCK
op_eq
id|use_lock
)paren
(brace
id|acpi_cm_release_mutex
(paren
id|ACPI_MTX_HARDWARE
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PROCESSOR_BLOCK
suffix:colon
r_default
suffix:colon
id|mask
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|register_value
op_and_assign
id|mask
suffix:semicolon
id|register_value
op_rshift_assign
id|acpi_hw_get_bit_shift
(paren
id|mask
)paren
suffix:semicolon
r_return
(paren
id|register_value
)paren
suffix:semicolon
)brace
eof
