multiline_comment|/******************************************************************************&n; *&n; * Name: hwcpu32.c - CPU support for IA32 (Throttling, Cx_states)&n; *              $Revision: 39 $&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;acnamesp.h&quot;
macro_line|#include &quot;achware.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          HARDWARE
id|MODULE_NAME
(paren
l_string|&quot;Hwcpu32&quot;
)paren
DECL|macro|BIT_4
mdefine_line|#define BIT_4               0x10  /* TBD: [investigate] is this correct?  */
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_hw_enter_c1&n; *&n; * PARAMETERS:  Pblk_address    - Address of the processor control block&n; *              Pm_timer_ticks  - Number of PM timer ticks elapsed while asleep&n; *&n; * RETURN:      Function status.&n; *&n; * DESCRIPTION: Set C1 state on IA32 processor (halt)&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_hw_enter_c1
id|acpi_hw_enter_c1
c_func
(paren
id|ACPI_IO_ADDRESS
id|pblk_address
comma
id|u32
op_star
id|pm_timer_ticks
)paren
(brace
id|u32
id|timer
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pm_timer_ticks
)paren
(brace
multiline_comment|/*&n;&t;&t; * Enter C1:&n;&t;&t; * ---------&n;&t;&t; */
id|enable
c_func
(paren
)paren
suffix:semicolon
id|halt
c_func
(paren
)paren
suffix:semicolon
op_star
id|pm_timer_ticks
op_assign
id|ACPI_UINT32_MAX
suffix:semicolon
)brace
r_else
(brace
id|timer
op_assign
id|acpi_hw_pmt_ticks
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Enter C1:&n;&t;&t; * ---------&n;&t;&t; */
id|enable
(paren
)paren
suffix:semicolon
id|halt
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Compute Time in C1:&n;&t;&t; * -------------------&n;&t;&t; */
id|timer
op_assign
id|acpi_hw_pmt_ticks
(paren
)paren
op_minus
id|timer
suffix:semicolon
op_star
id|pm_timer_ticks
op_assign
id|timer
suffix:semicolon
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_hw_enter_c2&n; *&n; * PARAMETERS:  Pblk_address    - Address of the processor control block&n; *              Pm_timer_ticks  - Number of PM timer ticks elapsed while asleep&n; *&n; * RETURN:      &lt;none&gt;&n; *&n; * DESCRIPTION: Set C2 state on IA32 processor&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_hw_enter_c2
id|acpi_hw_enter_c2
c_func
(paren
id|ACPI_IO_ADDRESS
id|pblk_address
comma
id|u32
op_star
id|pm_timer_ticks
)paren
(brace
id|u32
id|timer
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pblk_address
op_logical_or
op_logical_neg
id|pm_timer_ticks
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Disable interrupts before all C2/C3 transitions.&n;&t; */
id|disable
(paren
)paren
suffix:semicolon
id|timer
op_assign
id|acpi_hw_pmt_ticks
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enter C2:&n;&t; * ---------&n;&t; * Read from the P_LVL2 (P_BLK+4) register to invoke a C2 transition.&n;&t; */
id|acpi_os_in8
(paren
(paren
id|ACPI_IO_ADDRESS
)paren
(paren
id|pblk_address
op_plus
l_int|4
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Perform Dummy Op:&n;&t; * -----------------&n;&t; * We have to do something useless after reading LVL2 because chipsets&n;&t; * cannot guarantee that STPCLK# gets asserted in time to freeze execution.&n;&t; */
id|acpi_hw_register_read
(paren
id|ACPI_MTX_DO_NOT_LOCK
comma
id|PM2_CONTROL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Compute Time in C2:&n;&t; * -------------------&n;&t; */
id|timer
op_assign
id|acpi_hw_pmt_ticks
(paren
)paren
op_minus
id|timer
suffix:semicolon
op_star
id|pm_timer_ticks
op_assign
id|timer
suffix:semicolon
multiline_comment|/*&n;&t; * Re-enable interrupts after coming out of C2/C3.&n;&t; */
id|enable
(paren
)paren
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_hw_enter_c3&n; *&n; * PARAMETERS:  Pblk_address    - Address of the processor control block&n; *              Pm_timer_ticks  - Number of PM timer ticks elapsed while asleep&n; *&n; * RETURN:      Status of function&n; *&n; * DESCRIPTION: Set C3 state on IA32 processor (UP only, cache coherency via&n; *              disabling bus mastering)&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_hw_enter_c3
id|acpi_hw_enter_c3
c_func
(paren
id|ACPI_IO_ADDRESS
id|pblk_address
comma
id|u32
op_star
id|pm_timer_ticks
)paren
(brace
id|u32
id|timer
op_assign
l_int|0
suffix:semicolon
id|u32
id|bus_master_status
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pblk_address
op_logical_or
op_logical_neg
id|pm_timer_ticks
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check the BM_STS bit, if it is set, do not enter C3&n;&t; *  but clear the bit (with a write) and exit, telling&n;&t; *  the calling module that we spent zero time in C3.&n;&t; *  If bus mastering continues, this action should&n;&t; *  eventually cause a demotion to C2&n;&t; */
r_if
c_cond
(paren
l_int|1
op_eq
(paren
id|bus_master_status
op_assign
id|acpi_hw_register_bit_access
(paren
id|ACPI_READ
comma
id|ACPI_MTX_LOCK
comma
id|BM_STS
)paren
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; * Clear the BM_STS bit by setting it.&n;&t;&t; */
id|acpi_hw_register_bit_access
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_LOCK
comma
id|BM_STS
comma
l_int|1
)paren
suffix:semicolon
op_star
id|pm_timer_ticks
op_assign
l_int|0
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Disable interrupts before all C2/C3 transitions.&n;&t; */
id|disable
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Disable Bus Mastering:&n;&t; * ----------------------&n;&t; * Set the PM2_CNT.ARB_DIS bit (bit #0), preserving all other bits.&n;&t; */
id|acpi_hw_register_bit_access
c_func
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_LOCK
comma
id|ARB_DIS
comma
l_int|1
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Get the timer base before entering C state&n;&t; */
id|timer
op_assign
id|acpi_hw_pmt_ticks
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enter C3:&n;&t; * ---------&n;&t; * Read from the P_LVL3 (P_BLK+5) register to invoke a C3 transition.&n;&t; */
id|acpi_os_in8
(paren
(paren
id|ACPI_IO_ADDRESS
)paren
(paren
id|pblk_address
op_plus
l_int|5
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Perform Dummy Op:&n;&t; * -----------------&n;&t; * We have to do something useless after reading LVL3 because chipsets&n;&t; * cannot guarantee that STPCLK# gets asserted in time to freeze execution.&n;&t; */
id|acpi_hw_register_read
(paren
id|ACPI_MTX_DO_NOT_LOCK
comma
id|PM2_CONTROL
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Immediately compute the time in the C state&n;&t; */
id|timer
op_assign
id|acpi_hw_pmt_ticks
c_func
(paren
)paren
op_minus
id|timer
suffix:semicolon
multiline_comment|/*&n;&t; * Re-Enable Bus Mastering:&n;&t; * ------------------------&n;&t; * Clear the PM2_CNT.ARB_DIS bit (bit #0), preserving all other bits.&n;&t; */
id|acpi_hw_register_bit_access
c_func
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_LOCK
comma
id|ARB_DIS
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* TBD: [Unhandled]: Support 24-bit timers (this algorithm assumes 32-bit) */
op_star
id|pm_timer_ticks
op_assign
id|timer
suffix:semicolon
multiline_comment|/*&n;&t; * Re-enable interrupts after coming out of C2/C3.&n;&t; */
id|enable
c_func
(paren
)paren
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_hw_enter_cx&n; *&n; * PARAMETERS:  Processor_handle    - handle of the processor&n; *&n; * RETURN:      Status of function&n; *&n; * DESCRIPTION: Invoke the currently active processor Cx handler to put this&n; *              processor to sleep.&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_hw_enter_cx
id|acpi_hw_enter_cx
(paren
id|ACPI_IO_ADDRESS
id|pblk_address
comma
id|u32
op_star
id|pm_timer_ticks
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|acpi_hw_cx_handlers
(braket
id|acpi_hw_active_cx_state
)braket
)paren
(brace
r_return
(paren
id|AE_SUPPORT
)paren
suffix:semicolon
)brace
r_return
(paren
id|acpi_hw_cx_handlers
(braket
id|acpi_hw_active_cx_state
)braket
(paren
id|pblk_address
comma
id|pm_timer_ticks
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_hw_set_cx&n; *&n; * PARAMETERS:  State               - value (1-3) of the Cx state to &squot;make active&squot;&n; *&n; * RETURN:      Function status.&n; *&n; * DESCRIPTION: Sets the state to use during calls to Acpi_hw_enter_cx().&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_hw_set_cx
id|acpi_hw_set_cx
(paren
id|u32
id|cx_state
)paren
(brace
multiline_comment|/*&n;&t; * Supported State?&n;&t; * ----------------&n;&t; */
r_if
c_cond
(paren
(paren
id|cx_state
OL
l_int|1
)paren
op_logical_or
(paren
id|cx_state
OG
l_int|3
)paren
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|acpi_hw_cx_handlers
(braket
id|cx_state
)braket
)paren
(brace
r_return
(paren
id|AE_SUPPORT
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * New Cx State?&n;&t; * -------------&n;&t; * We only care when moving from one state to another...&n;&t; */
r_if
c_cond
(paren
id|acpi_hw_active_cx_state
op_eq
id|cx_state
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Prepare to Use New State:&n;&t; * -------------------------&n;&t; * If the new Cx_state is C3, the BM_RLD bit must be set to allow&n;&t; *  the generation of a bus master requets to cause the processor&n;&t; *  in the C3 state to transition to the C0 state.&n;&t; */
r_switch
c_cond
(paren
id|cx_state
)paren
(brace
r_case
l_int|3
suffix:colon
id|acpi_hw_register_bit_access
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_LOCK
comma
id|BM_RLD
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Clean up from Old State:&n;&t; * ------------------------&n;&t; * If the old Cx_state was C3, the BM_RLD bit is reset. When the&n;&t; *  bit is reset, the generation of a bus master request does not&n;&t; *  effect any processor in the C3 state.&n;&t; */
r_switch
c_cond
(paren
id|acpi_hw_active_cx_state
)paren
(brace
r_case
l_int|3
suffix:colon
id|acpi_hw_register_bit_access
(paren
id|ACPI_WRITE
comma
id|ACPI_MTX_LOCK
comma
id|BM_RLD
comma
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Enable:&n;&t; * -------&n;&t; */
id|acpi_hw_active_cx_state
op_assign
id|cx_state
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_hw_get_cx_info&n; *&n; * PARAMETERS:  Cx_states       - Information (latencies) on all Cx states&n; *&n; * RETURN:      Status of function&n; *&n; * DESCRIPTION: This function is called both to initialize Cx handling&n; *              and retrieve the current Cx information (latency values).&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_hw_get_cx_info
id|acpi_hw_get_cx_info
(paren
id|u32
id|cx_states
(braket
)braket
)paren
(brace
id|u8
id|SMP_system
op_assign
id|FALSE
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cx_states
)paren
(brace
r_return
id|AE_BAD_PARAMETER
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  TBD: [Unhandled] need to init SMP_system using info from the MAPIC&n;&t; *       table.&n;&t; */
multiline_comment|/*&n;&t; * Set Defaults:&n;&t; * -------------&n;&t; * C0 and C1 support is implied (but what about that PROC_C1 register&n;&t; * in the FADT?!?!).  Set C2/C3 to max. latency (not supported until&n;&t; * proven otherwise).&n;&t; */
id|cx_states
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|cx_states
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|cx_states
(braket
l_int|2
)braket
op_assign
id|MAX_CX_STATE_LATENCY
suffix:semicolon
id|cx_states
(braket
l_int|3
)braket
op_assign
id|MAX_CX_STATE_LATENCY
suffix:semicolon
multiline_comment|/*&n;&t; * C2 Supported?&n;&t; * -------------&n;&t; * We&squot;re only supporting C2 when the latency is &lt;= 100 microseconds,&n;&t; * and on SMP systems when P_LVL2_UP (which indicates C2 only on UP)&n;&t; * is not set.&n;&t; */
r_if
c_cond
(paren
id|acpi_gbl_FADT-&gt;plvl2_lat
op_le
l_int|100
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|SMP_system
)paren
(brace
id|acpi_hw_cx_handlers
(braket
l_int|2
)braket
op_assign
id|acpi_hw_enter_c2
suffix:semicolon
id|cx_states
(braket
l_int|2
)braket
op_assign
id|acpi_gbl_FADT-&gt;plvl2_lat
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_FADT-&gt;plvl2_up
)paren
(brace
id|acpi_hw_cx_handlers
(braket
l_int|2
)braket
op_assign
id|acpi_hw_enter_c2
suffix:semicolon
id|cx_states
(braket
l_int|2
)braket
op_assign
id|acpi_gbl_FADT-&gt;plvl2_lat
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * C3 Supported?&n;&t; * -------------&n;&t; * We&squot;re only supporting C3 on UP systems when the latency is&n;&t; * &lt;= 1000 microseconds and that include the ability to disable&n;&t; * Bus Mastering while in C3 (ARB_DIS) but allows Bus Mastering&n;&t; * requests to wake the system from C3 (BM_RLD).  Note his method&n;&t; * of maintaining cache coherency (disabling of bus mastering)&n;&t; * cannot be used on SMP systems, and flushing caches (e.g. WBINVD)&n;&t; * is simply too costly (at this time).&n;&t; */
r_if
c_cond
(paren
id|acpi_gbl_FADT-&gt;plvl3_lat
op_le
l_int|1000
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|SMP_system
op_logical_and
(paren
id|acpi_gbl_FADT-&gt;Xpm2_cnt_blk.address
op_logical_and
id|acpi_gbl_FADT-&gt;pm2_cnt_len
)paren
)paren
(brace
id|acpi_hw_cx_handlers
(braket
l_int|3
)braket
op_assign
id|acpi_hw_enter_c3
suffix:semicolon
id|cx_states
(braket
l_int|3
)braket
op_assign
id|acpi_gbl_FADT-&gt;plvl3_lat
suffix:semicolon
)brace
)brace
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_hw_get_cx_handler&n; *&n; * PARAMETERS:  State           - the Cx state&n; *              Handler         - pointer to location for the returned handler&n; *&n; * RETURN:      Status of function&n; *&n; * DESCRIPTION: This function is called to get an installed Cx state handler.&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_hw_get_cx_handler
id|acpi_hw_get_cx_handler
(paren
id|u32
id|cx_state
comma
id|ACPI_C_STATE_HANDLER
op_star
id|handler
)paren
(brace
r_if
c_cond
(paren
(paren
id|cx_state
op_eq
l_int|0
)paren
op_logical_or
(paren
id|cx_state
op_ge
id|MAX_CX_STATES
)paren
op_logical_or
op_logical_neg
id|handler
)paren
(brace
r_return
id|AE_BAD_PARAMETER
suffix:semicolon
)brace
op_star
id|handler
op_assign
id|acpi_hw_cx_handlers
(braket
id|cx_state
)braket
suffix:semicolon
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_hw_set_cx_handler&n; *&n; * PARAMETERS:  Cx_state        - the Cx state&n; *              Handler         - new Cx state handler&n; *&n; * RETURN:      Status of function&n; *&n; * DESCRIPTION: This function is called to install a new Cx state handler.&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_hw_set_cx_handler
id|acpi_hw_set_cx_handler
(paren
id|u32
id|cx_state
comma
id|ACPI_C_STATE_HANDLER
id|handler
)paren
(brace
r_if
c_cond
(paren
(paren
id|cx_state
op_eq
l_int|0
)paren
op_logical_or
(paren
id|cx_state
op_ge
id|MAX_CX_STATES
)paren
op_logical_or
op_logical_neg
id|handler
)paren
(brace
r_return
id|AE_BAD_PARAMETER
suffix:semicolon
)brace
id|acpi_hw_cx_handlers
(braket
id|cx_state
)braket
op_assign
id|handler
suffix:semicolon
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; *&n; *  FUNCTION:    Acpi_hw_local_pow&n; *&n; *  PARAMETERS:  x,y operands&n; *&n; *  RETURN:      result&n; *&n; *  DESCRIPTION: Compute x ^ y&n; *&n; *************************************************************************/
id|NATIVE_UINT
DECL|function|acpi_hw_local_pow
id|acpi_hw_local_pow
(paren
id|NATIVE_UINT
id|x
comma
id|NATIVE_UINT
id|y
)paren
(brace
id|NATIVE_UINT
id|i
suffix:semicolon
id|NATIVE_UINT
id|result
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|y
suffix:semicolon
id|i
op_increment
)paren
(brace
id|result
op_assign
id|result
op_star
id|x
suffix:semicolon
)brace
r_return
(paren
id|result
)paren
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; *&n; *  FUNCTION:    Acpi_hw_enable_throttling&n; *&n; *  PARAMETERS:  Pblk_address       - Address of Pcnt (Processor Control)&n; *                                      register&n; *&n; *  RETURN:      none&n; *&n; *  DESCRIPTION: Enable throttling by setting the THT_EN bit.&n; *&n; *************************************************************************/
r_void
DECL|function|acpi_hw_enable_throttling
id|acpi_hw_enable_throttling
(paren
id|ACPI_IO_ADDRESS
id|pblk_address
)paren
(brace
id|u32
id|pblk_value
suffix:semicolon
id|pblk_value
op_assign
id|acpi_os_in32
(paren
id|pblk_address
)paren
suffix:semicolon
id|pblk_value
op_assign
id|pblk_value
op_or
id|BIT_4
suffix:semicolon
id|acpi_os_out32
(paren
id|pblk_address
comma
id|pblk_value
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; *&n; *  FUNCTION:   Acpi_hw_disable_throttling&n; *&n; *  PARAMETERS: Pblk_address        - Address of Pcnt (Processor Control)&n; *                                      register&n; *&n; *  RETURN:     none&n; *&n; *  DESCRIPTION:Disable throttling by clearing the THT_EN bit&n; *&n; *************************************************************************/
r_void
DECL|function|acpi_hw_disable_throttling
id|acpi_hw_disable_throttling
(paren
id|ACPI_IO_ADDRESS
id|pblk_address
)paren
(brace
id|u32
id|pblk_value
suffix:semicolon
id|pblk_value
op_assign
id|acpi_os_in32
(paren
id|pblk_address
)paren
suffix:semicolon
id|pblk_value
op_assign
id|pblk_value
op_amp
(paren
op_complement
(paren
id|u32
)paren
id|BIT_4
)paren
suffix:semicolon
id|acpi_os_out32
(paren
id|pblk_address
comma
id|pblk_value
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; *&n; *  FUNCTION:    Acpi_hw_get_duty_cycle&n; *&n; *  PARAMETERS:  Duty_offset         Pcnt register duty cycle field offset&n; *               Pblk_address        Pcnt register address in chipset&n; *               Num_throttle_states # of CPU throttle states this system&n; *                                      supports&n; *&n; *  RETURN:      none&n; *&n; *  DESCRIPTION: Get the duty cycle from the chipset&n; *&n; *************************************************************************/
id|u32
DECL|function|acpi_hw_get_duty_cycle
id|acpi_hw_get_duty_cycle
(paren
id|u8
id|duty_offset
comma
id|ACPI_IO_ADDRESS
id|pblk_address
comma
id|u32
id|num_throttle_states
)paren
(brace
id|NATIVE_UINT
id|index
suffix:semicolon
id|u32
id|duty32_value
suffix:semicolon
id|u32
id|pcnt_mask_off_duty_field
suffix:semicolon
multiline_comment|/*&n;&t; *  Use Num_throttle_states - 1 as mask [ex. 8 - 1 = 7 (Fh)]&n;&t; *  and then shift it into the right position&n;&t; */
id|pcnt_mask_off_duty_field
op_assign
id|num_throttle_states
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *  Read in the current value from the port&n;&t; */
id|duty32_value
op_assign
id|acpi_os_in32
(paren
(paren
id|ACPI_IO_ADDRESS
)paren
id|pblk_address
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Shift the the value to LSB&n;&t; */
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
(paren
id|NATIVE_UINT
)paren
id|duty_offset
suffix:semicolon
id|index
op_increment
)paren
(brace
id|duty32_value
op_assign
id|duty32_value
op_rshift
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Get the duty field only&n;&t; */
id|duty32_value
op_assign
id|duty32_value
op_amp
id|pcnt_mask_off_duty_field
suffix:semicolon
r_return
(paren
(paren
id|u32
)paren
id|duty32_value
)paren
suffix:semicolon
)brace
multiline_comment|/**************************************************************************&n; *&n; * FUNCTION:    Acpi_hw_program_duty_cycle&n; *&n; * PARAMETERS:  Duty_offset         Pcnt register duty cycle field offset&n; *              Duty_cycle          duty cycle to program into chipset&n; *              Pblk_address        Pcnt register address in chipset&n; *              Num_throttle_states # of CPU throttle states this system&n; *                                      supports&n; *&n; * RETURN:      none&n; *&n; * DESCRIPTION: Program chipset with specified duty cycle by bit-shifting the&n; *              duty cycle bits to the appropriate offset, reading the duty&n; *              cycle register, OR-ing in the duty cycle, and writing it to&n; *              the Pcnt register.&n; *&n; *************************************************************************/
r_void
DECL|function|acpi_hw_program_duty_cycle
id|acpi_hw_program_duty_cycle
(paren
id|u8
id|duty_offset
comma
id|u32
id|duty_cycle
comma
id|ACPI_IO_ADDRESS
id|pblk_address
comma
id|u32
id|num_throttle_states
)paren
(brace
id|NATIVE_UINT
id|index
suffix:semicolon
id|u32
id|duty32_value
suffix:semicolon
id|u32
id|pcnt_mask_off_duty_field
suffix:semicolon
id|u32
id|port_value
suffix:semicolon
multiline_comment|/*&n;&t; *  valid Duty_cycle passed&n;&t; */
id|duty32_value
op_assign
id|duty_cycle
suffix:semicolon
multiline_comment|/*&n;&t; *  use Num_throttle_states - 1 as mask [ex. 8 - 1 = 7 (Fh)]&n;&t; *  and then shift it into the right position&n;&t; */
id|pcnt_mask_off_duty_field
op_assign
id|num_throttle_states
op_minus
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t; *  Shift the mask&n;&t; */
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
(paren
id|NATIVE_UINT
)paren
id|duty_offset
suffix:semicolon
id|index
op_increment
)paren
(brace
id|pcnt_mask_off_duty_field
op_assign
id|pcnt_mask_off_duty_field
op_lshift
l_int|1
suffix:semicolon
id|duty32_value
op_assign
id|duty32_value
op_lshift
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Read in the current value from the port&n;&t; */
id|port_value
op_assign
id|acpi_os_in32
(paren
(paren
id|ACPI_IO_ADDRESS
)paren
id|pblk_address
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Mask off the duty field so we don&squot;t OR in junk!&n;&t; */
id|port_value
op_assign
id|port_value
op_amp
(paren
op_complement
id|pcnt_mask_off_duty_field
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  OR in the bits we want to write out to the port&n;&t; */
id|port_value
op_assign
(paren
id|port_value
op_or
id|duty32_value
)paren
op_amp
(paren
op_complement
(paren
id|u32
)paren
id|BIT_4
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  write it to the port&n;&t; */
id|acpi_os_out32
(paren
(paren
id|ACPI_IO_ADDRESS
)paren
id|pblk_address
comma
id|port_value
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
eof
