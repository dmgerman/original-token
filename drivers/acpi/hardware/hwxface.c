multiline_comment|/******************************************************************************&n; *&n; * Name: hwxface.c - Hardware access external interfaces&n; *              $Revision: 36 $&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;acnamesp.h&quot;
macro_line|#include &quot;achware.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          HARDWARE
id|MODULE_NAME
(paren
l_string|&quot;hwxface&quot;
)paren
multiline_comment|/******************************************************************************&n; *&n; * Hardware globals&n; *&n; ******************************************************************************/
DECL|variable|acpi_hw_cx_handlers
id|ACPI_C_STATE_HANDLER
id|acpi_hw_cx_handlers
(braket
id|MAX_CX_STATES
)braket
op_assign
(brace
l_int|NULL
comma
id|acpi_hw_enter_c1
comma
l_int|NULL
comma
l_int|NULL
)brace
suffix:semicolon
DECL|variable|acpi_hw_active_cx_state
id|u32
id|acpi_hw_active_cx_state
op_assign
l_int|1
suffix:semicolon
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_get_processor_throttling_info&n; *&n; * PARAMETERS:  Processor_handle    - handle for the cpu to get info about&n; *              User_buffer         - caller supplied buffer&n; *&n; * RETURN:      Status of function&n; *&n; * DESCRIPTION: Get throttling capabilities for the processor, this routine&n; *              builds the data directly into the callers buffer&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_get_processor_throttling_info
id|acpi_get_processor_throttling_info
(paren
id|ACPI_HANDLE
id|processor_handle
comma
id|ACPI_BUFFER
op_star
id|user_buffer
)paren
(brace
id|NATIVE_UINT
id|percent_step
suffix:semicolon
id|NATIVE_UINT
id|next_percent
suffix:semicolon
id|NATIVE_UINT
id|num_throttle_states
suffix:semicolon
id|NATIVE_UINT
id|buffer_space_needed
suffix:semicolon
id|NATIVE_UINT
id|i
suffix:semicolon
id|u8
id|duty_width
suffix:semicolon
id|ACPI_NAMESPACE_NODE
op_star
id|cpu_node
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|cpu_obj
suffix:semicolon
id|ACPI_CPU_THROTTLING_STATE
op_star
id|state_ptr
suffix:semicolon
multiline_comment|/*&n;&t; *  Have to at least have a buffer to return info in&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|user_buffer
)paren
(brace
r_return
id|AE_BAD_PARAMETER
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Convert and validate the device handle&n;&t; */
id|cpu_node
op_assign
id|acpi_ns_convert_handle_to_entry
(paren
id|processor_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_node
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;*   Check for an existing internal object&n;&t;*/
id|cpu_obj
op_assign
id|acpi_ns_get_attached_object
(paren
(paren
id|ACPI_HANDLE
)paren
id|cpu_node
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_obj
)paren
(brace
r_return
(paren
id|AE_NOT_FOUND
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * (Duty Width on IA-64 is zero)&n;&t; */
id|duty_width
op_assign
id|acpi_gbl_FADT-&gt;duty_width
suffix:semicolon
multiline_comment|/*&n;&t; *  P0 must always have a P_BLK all others may be null&n;&t; *  in either case, we can&squot;t throttle a processor that has no P_BLK&n;&t; *&n;&t; *  Also if no Duty width, one state and it is 100%&n;&t; *&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cpu_obj-&gt;processor.length
op_logical_or
op_logical_neg
id|duty_width
op_logical_or
(paren
id|ACPI_UINT16_MAX
OL
id|cpu_obj-&gt;processor.address
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *  Acpi_even though we can&squot;t throttle, we still have one state (100%)&n;&t;&t; */
id|num_throttle_states
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|num_throttle_states
op_assign
(paren
r_int
)paren
id|acpi_hw_local_pow
(paren
l_int|2
comma
id|duty_width
)paren
suffix:semicolon
)brace
id|buffer_space_needed
op_assign
id|num_throttle_states
op_star
r_sizeof
(paren
id|ACPI_CPU_THROTTLING_STATE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|user_buffer-&gt;length
OL
id|buffer_space_needed
)paren
op_logical_or
op_logical_neg
id|user_buffer-&gt;pointer
)paren
(brace
id|user_buffer-&gt;length
op_assign
id|buffer_space_needed
suffix:semicolon
r_return
(paren
id|AE_BUFFER_OVERFLOW
)paren
suffix:semicolon
)brace
id|user_buffer-&gt;length
op_assign
id|buffer_space_needed
suffix:semicolon
id|state_ptr
op_assign
(paren
id|ACPI_CPU_THROTTLING_STATE
op_star
)paren
id|user_buffer-&gt;pointer
suffix:semicolon
id|percent_step
op_assign
l_int|1000
op_div
id|num_throttle_states
suffix:semicolon
multiline_comment|/*&n;&t; * Build each entry in the buffer.  Note that we&squot;re using the value&n;&t; * 1000 and dividing each state by 10 to better avoid round-off&n;&t; * accumulation.  Also note that the throttling STATES are ordered&n;&t; * sequentially from 100% (state 0) on down (e.g. 87.5% = state 1),&n;&t; * which is exactly opposite from duty cycle values (12.5% = state 1).&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|next_percent
op_assign
l_int|1000
suffix:semicolon
id|i
OL
id|num_throttle_states
suffix:semicolon
id|i
op_increment
)paren
(brace
id|state_ptr
(braket
id|i
)braket
dot
id|state_number
op_assign
id|i
suffix:semicolon
id|state_ptr
(braket
id|i
)braket
dot
id|percent_of_clock
op_assign
id|next_percent
op_div
l_int|10
suffix:semicolon
id|next_percent
op_sub_assign
id|percent_step
suffix:semicolon
)brace
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_get_processor_throttling_state&n; *&n; * PARAMETERS:  Processor_handle    - handle for the cpu to throttle&n; *              Throttle_state      - throttling state to enter&n; *&n; * RETURN:      Status of function&n; *&n; * DESCRIPTION: Get current hardware throttling state&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_get_processor_throttling_state
id|acpi_get_processor_throttling_state
(paren
id|ACPI_HANDLE
id|processor_handle
comma
id|u32
op_star
id|throttle_state
)paren
(brace
id|ACPI_NAMESPACE_NODE
op_star
id|cpu_node
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|cpu_obj
suffix:semicolon
id|u32
id|num_throttle_states
suffix:semicolon
id|u32
id|duty_cycle
suffix:semicolon
id|u8
id|duty_offset
suffix:semicolon
id|u8
id|duty_width
suffix:semicolon
multiline_comment|/* Convert and validate the device handle */
id|cpu_node
op_assign
id|acpi_ns_convert_handle_to_entry
(paren
id|processor_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_node
op_logical_or
op_logical_neg
id|throttle_state
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for an existing internal object */
id|cpu_obj
op_assign
id|acpi_ns_get_attached_object
(paren
(paren
id|ACPI_HANDLE
)paren
id|cpu_node
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_obj
)paren
(brace
r_return
(paren
id|AE_NOT_FOUND
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * No Duty fields in IA64 tables&n;&t; */
id|duty_offset
op_assign
id|acpi_gbl_FADT-&gt;duty_offset
suffix:semicolon
id|duty_width
op_assign
id|acpi_gbl_FADT-&gt;duty_width
suffix:semicolon
multiline_comment|/*&n;&t; *  Must have a valid P_BLK P0 must have a P_BLK all others may be null&n;&t; *  in either case, we can&squot;t thottle a processor that has no P_BLK&n;&t; *  that means we are in the only supported state (0 - 100%)&n;&t; *&n;&t; *  also, if Duty_width is zero there are no additional states&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cpu_obj-&gt;processor.length
op_logical_or
op_logical_neg
id|duty_width
op_logical_or
(paren
id|ACPI_UINT16_MAX
OL
id|cpu_obj-&gt;processor.address
)paren
)paren
(brace
op_star
id|throttle_state
op_assign
l_int|0
suffix:semicolon
r_return
id|AE_OK
suffix:semicolon
)brace
id|num_throttle_states
op_assign
(paren
id|u32
)paren
id|acpi_hw_local_pow
(paren
l_int|2
comma
id|duty_width
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Get the current duty cycle value.&n;&t; */
id|duty_cycle
op_assign
id|acpi_hw_get_duty_cycle
(paren
id|duty_offset
comma
id|cpu_obj-&gt;processor.address
comma
id|num_throttle_states
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert duty cycle to throttling state (invert).&n;&t; */
r_if
c_cond
(paren
id|duty_cycle
op_eq
l_int|0
)paren
(brace
op_star
id|throttle_state
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
op_star
id|throttle_state
op_assign
id|num_throttle_states
op_minus
id|duty_cycle
suffix:semicolon
)brace
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_set_processor_throttling_state&n; *&n; * PARAMETERS:  Processor_handle    - handle for the cpu to throttle&n; *              Throttle_state      - throttling state to enter&n; *&n; * RETURN:      Status of function&n; *&n; * DESCRIPTION: Set hardware into requested throttling state, the handle&n; *              passed in must have a valid P_BLK&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_set_processor_throttling_state
id|acpi_set_processor_throttling_state
(paren
id|ACPI_HANDLE
id|processor_handle
comma
id|u32
id|throttle_state
)paren
(brace
id|ACPI_NAMESPACE_NODE
op_star
id|cpu_node
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|cpu_obj
suffix:semicolon
id|u32
id|num_throttle_states
op_assign
l_int|0
suffix:semicolon
id|u8
id|duty_offset
suffix:semicolon
id|u8
id|duty_width
suffix:semicolon
id|u32
id|duty_cycle
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Convert and validate the device handle */
id|cpu_node
op_assign
id|acpi_ns_convert_handle_to_entry
(paren
id|processor_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_node
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for an existing internal object */
id|cpu_obj
op_assign
id|acpi_ns_get_attached_object
(paren
(paren
id|ACPI_HANDLE
)paren
id|cpu_node
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_obj
)paren
(brace
r_return
(paren
id|AE_NOT_FOUND
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * No Duty fields in IA64 tables&n;&t; */
id|duty_offset
op_assign
id|acpi_gbl_FADT-&gt;duty_offset
suffix:semicolon
id|duty_width
op_assign
id|acpi_gbl_FADT-&gt;duty_width
suffix:semicolon
multiline_comment|/*&n;&t; *  Must have a valid P_BLK P0 must have a P_BLK all others may be null&n;&t; *  in either case, we can&squot;t thottle a processor that has no P_BLK&n;&t; *  that means we are in the only supported state (0 - 100%)&n;&t; *&n;&t; *  also, if Duty_width is zero there are no additional states&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|cpu_obj-&gt;processor.length
op_logical_or
op_logical_neg
id|duty_width
op_logical_or
(paren
id|ACPI_UINT16_MAX
OL
id|cpu_obj-&gt;processor.address
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t; *  If caller wants to set the state to the only state we handle&n;&t;&t; *  we&squot;re done.&n;&t;&t; */
r_if
c_cond
(paren
id|throttle_state
op_eq
l_int|0
)paren
(brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; *  Can&squot;t set this state&n;&t;&t; */
r_return
(paren
id|AE_SUPPORT
)paren
suffix:semicolon
)brace
id|num_throttle_states
op_assign
(paren
id|u32
)paren
id|acpi_hw_local_pow
(paren
l_int|2
comma
id|duty_width
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Convert throttling state to duty cycle (invert).&n;&t; */
r_if
c_cond
(paren
id|throttle_state
OG
l_int|0
)paren
(brace
id|duty_cycle
op_assign
id|num_throttle_states
op_minus
id|throttle_state
suffix:semicolon
)brace
multiline_comment|/*&n;&t; *  Turn off throttling (don&squot;t muck with the h/w while throttling).&n;&t; */
id|acpi_hw_disable_throttling
(paren
id|cpu_obj-&gt;processor.address
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Program the throttling state.&n;&t; */
id|acpi_hw_program_duty_cycle
(paren
id|duty_offset
comma
id|duty_cycle
comma
id|cpu_obj-&gt;processor.address
comma
id|num_throttle_states
)paren
suffix:semicolon
multiline_comment|/*&n;&t; *  Only enable throttling for non-zero states (0 - 100%)&n;&t; */
r_if
c_cond
(paren
id|throttle_state
)paren
(brace
id|acpi_hw_enable_throttling
(paren
id|cpu_obj-&gt;processor.address
)paren
suffix:semicolon
)brace
r_return
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_get_processor_cx_info&n; *&n; * PARAMETERS:  Processor_handle    - handle for the cpu return info about&n; *              User_buffer         - caller supplied buffer&n; *&n; * RETURN:      Status of function&n; *&n; * DESCRIPTION: Get Cx state latencies, this routine&n; *              builds the data directly into the callers buffer&n; *&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_get_processor_cx_info
id|acpi_get_processor_cx_info
(paren
id|ACPI_HANDLE
id|processor_handle
comma
id|ACPI_BUFFER
op_star
id|user_buffer
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|u32
id|cx_state_latencies
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|NATIVE_UINT
id|buffer_space_needed
op_assign
l_int|0
suffix:semicolon
id|ACPI_CX_STATE
op_star
id|state_ptr
op_assign
l_int|NULL
suffix:semicolon
id|NATIVE_UINT
id|i
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; *  Have to at least have a buffer to return info in&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|user_buffer
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
id|status
op_assign
id|acpi_hw_get_cx_info
(paren
id|cx_state_latencies
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
id|buffer_space_needed
op_assign
l_int|4
op_star
r_sizeof
(paren
id|ACPI_CX_STATE
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|user_buffer-&gt;length
OL
id|buffer_space_needed
)paren
op_logical_or
op_logical_neg
id|user_buffer-&gt;pointer
)paren
(brace
id|user_buffer-&gt;length
op_assign
id|buffer_space_needed
suffix:semicolon
r_return
(paren
id|AE_BUFFER_OVERFLOW
)paren
suffix:semicolon
)brace
id|user_buffer-&gt;length
op_assign
id|buffer_space_needed
suffix:semicolon
id|state_ptr
op_assign
(paren
id|ACPI_CX_STATE
op_star
)paren
id|user_buffer-&gt;pointer
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|state_ptr
(braket
id|i
)braket
dot
id|state_number
op_assign
id|i
suffix:semicolon
id|state_ptr
(braket
id|i
)braket
dot
id|latency
op_assign
id|cx_state_latencies
(braket
id|i
)braket
suffix:semicolon
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_set_processor_sleep_state&n; *&n; * PARAMETERS:  Processor_handle    - handle for the cpu return info about&n; *              Cx_state            - the Cx sleeping state (C1-C3) to make&n; *                                      &squot;active&squot;&n; *&n; * RETURN:      Status of function&n; *&n; * DESCRIPTION: Sets which Cx state will be used during calls to&n; *              Acpi_processor_sleep ()&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_set_processor_sleep_state
id|acpi_set_processor_sleep_state
(paren
id|ACPI_HANDLE
id|processor_handle
comma
id|u32
id|cx_state
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|status
op_assign
id|acpi_hw_set_cx
(paren
id|cx_state
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * FUNCTION:    Acpi_processor_sleep&n; *&n; * PARAMETERS:  Processor_handle    - handle for the cpu to put to sleep (Cx)&n; *              Time_sleeping       - time (in microseconds) elapsed while&n; *                                      sleeping&n; *&n; * RETURN:      Status of function&n; *&n; * DESCRIPTION: Puts the processor into the currently active sleep state (Cx)&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_processor_sleep
id|acpi_processor_sleep
(paren
id|ACPI_HANDLE
id|processor_handle
comma
id|u32
op_star
id|pm_timer_ticks
)paren
(brace
id|ACPI_NAMESPACE_NODE
op_star
id|cpu_node
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|cpu_obj
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_IO_ADDRESS
id|address
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Convert Processor_handle to Pblk_addres...&n;&t; */
multiline_comment|/* Convert and validate the device handle */
id|cpu_node
op_assign
id|acpi_ns_convert_handle_to_entry
(paren
id|processor_handle
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_node
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/* Check for an existing internal object */
id|cpu_obj
op_assign
id|acpi_ns_get_attached_object
(paren
(paren
id|ACPI_HANDLE
)paren
id|cpu_node
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_obj
)paren
(brace
r_return
(paren
id|AE_NOT_FOUND
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the processor register block (P_BLK) address */
id|address
op_assign
id|cpu_obj-&gt;processor.address
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|cpu_obj-&gt;processor.length
)paren
(brace
multiline_comment|/* Ensure a NULL addresss (note that P_BLK isn&squot;t required for C1) */
id|address
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Enter the currently active Cx sleep state.&n;&t; */
r_return
(paren
id|acpi_hw_enter_cx
(paren
id|address
comma
id|pm_timer_ticks
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_get_timer&n; *&n; * PARAMETERS:  none&n; *&n; * RETURN:      Current value of the ACPI PMT (timer)&n; *&n; * DESCRIPTION: Obtains current value of ACPI PMT&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_get_timer
id|acpi_get_timer
(paren
id|u32
op_star
id|out_ticks
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|out_ticks
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
op_star
id|out_ticks
op_assign
id|acpi_hw_pmt_ticks
(paren
)paren
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_set_firmware_waking_vector&n; *&n; * PARAMETERS:  Physical_address    - Physical address of ACPI real mode&n; *                                    entry point.&n; *&n; * RETURN:      AE_OK or AE_ERROR&n; *&n; * DESCRIPTION: Access function for d_firmware_waking_vector field in FACS&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_set_firmware_waking_vector
id|acpi_set_firmware_waking_vector
(paren
id|ACPI_PHYSICAL_ADDRESS
id|physical_address
)paren
(brace
multiline_comment|/* Make sure that we have an FACS */
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_FACS
)paren
(brace
r_return
(paren
id|AE_NO_ACPI_TABLES
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the vector */
r_if
c_cond
(paren
id|acpi_gbl_FACS-&gt;vector_width
op_eq
l_int|32
)paren
(brace
op_star
(paren
id|u32
op_star
)paren
id|acpi_gbl_FACS-&gt;firmware_waking_vector
op_assign
(paren
id|u32
)paren
id|physical_address
suffix:semicolon
)brace
r_else
(brace
op_star
id|acpi_gbl_FACS-&gt;firmware_waking_vector
op_assign
id|physical_address
suffix:semicolon
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/******************************************************************************&n; *&n; * FUNCTION:    Acpi_get_firmware_waking_vector&n; *&n; * PARAMETERS:  *Physical_address   - Output buffer where contents of&n; *                                    the Firmware_waking_vector field of&n; *                                    the FACS will be stored.&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Access function for d_firmware_waking_vector field in FACS&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_get_firmware_waking_vector
id|acpi_get_firmware_waking_vector
(paren
id|ACPI_PHYSICAL_ADDRESS
op_star
id|physical_address
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|physical_address
)paren
(brace
r_return
(paren
id|AE_BAD_PARAMETER
)paren
suffix:semicolon
)brace
multiline_comment|/* Make sure that we have an FACS */
r_if
c_cond
(paren
op_logical_neg
id|acpi_gbl_FACS
)paren
(brace
r_return
(paren
id|AE_NO_ACPI_TABLES
)paren
suffix:semicolon
)brace
multiline_comment|/* Get the vector */
r_if
c_cond
(paren
id|acpi_gbl_FACS-&gt;vector_width
op_eq
l_int|32
)paren
(brace
op_star
id|physical_address
op_assign
op_star
(paren
id|u32
op_star
)paren
id|acpi_gbl_FACS-&gt;firmware_waking_vector
suffix:semicolon
)brace
r_else
(brace
op_star
id|physical_address
op_assign
op_star
id|acpi_gbl_FACS-&gt;firmware_waking_vector
suffix:semicolon
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
eof
