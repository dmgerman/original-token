multiline_comment|/******************************************************************************&n; *&n; * Module Name: psparse - Parser top level AML parse routines&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
multiline_comment|/*&n; * Parse the AML and build an operation tree as most interpreters,&n; * like Perl, do.  Parsing is done by hand rather than with a YACC&n; * generated parser to tightly constrain stack and dynamic memory&n; * usage.  At the same time, parsing is kept flexible and the code&n; * fairly compact by parsing based on a list of AML opcode&n; * templates in Acpi_gbl_Aml_op_info[]&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;parser.h&quot;
macro_line|#include &quot;dispatch.h&quot;
macro_line|#include &quot;amlcode.h&quot;
macro_line|#include &quot;namesp.h&quot;
macro_line|#include &quot;debugger.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          PARSER
id|MODULE_NAME
(paren
l_string|&quot;psparse&quot;
)paren
suffix:semicolon
DECL|variable|acpi_gbl_depth
id|u32
id|acpi_gbl_depth
op_assign
l_int|0
suffix:semicolon
r_extern
id|u32
id|acpi_gbl_scope_depth
suffix:semicolon
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_delete_completed_op&n; *&n; * PARAMETERS:  State           - Walk state&n; *              Op              - Completed op&n; *&n; * RETURN:      AE_OK&n; *&n; * DESCRIPTION: Callback function for Acpi_ps_get_next_walk_op(). Used during&n; *              Acpi_ps_delete_parse tree to delete Op objects when all sub-objects&n; *              have been visited (and deleted.)&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ps_delete_completed_op
id|acpi_ps_delete_completed_op
(paren
id|ACPI_WALK_STATE
op_star
id|state
comma
id|ACPI_GENERIC_OP
op_star
id|op
)paren
(brace
id|acpi_ps_free_op
(paren
id|op
)paren
suffix:semicolon
r_return
id|AE_OK
suffix:semicolon
)brace
macro_line|#ifndef PARSER_ONLY
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_delete_parse_tree&n; *&n; * PARAMETERS:  Root            - Root of tree (or subtree) to delete&n; *&n; * RETURN:      None&n; *&n; * DESCRIPTION: Delete a portion of or an entire parse tree.&n; *&n; ******************************************************************************/
r_void
DECL|function|acpi_ps_delete_parse_tree
id|acpi_ps_delete_parse_tree
(paren
id|ACPI_GENERIC_OP
op_star
id|root
)paren
(brace
id|ACPI_GENERIC_OP
op_star
id|op
suffix:semicolon
id|ACPI_WALK_STATE
id|walk_state
suffix:semicolon
id|walk_state.origin
op_assign
id|root
suffix:semicolon
id|op
op_assign
id|root
suffix:semicolon
multiline_comment|/* TBD: [Restructure] hack for root case */
r_if
c_cond
(paren
id|op
op_eq
id|acpi_gbl_parsed_namespace_root
)paren
(brace
id|op
op_assign
id|acpi_ps_get_child
(paren
id|op
)paren
suffix:semicolon
)brace
multiline_comment|/* Save root until last, so that we know when the tree has been walked */
id|walk_state.next_op
op_assign
id|op
suffix:semicolon
id|walk_state.next_op_info
op_assign
id|NEXT_OP_DOWNWARD
suffix:semicolon
r_while
c_loop
(paren
id|walk_state.next_op
)paren
(brace
id|acpi_ps_get_next_walk_op
(paren
op_amp
id|walk_state
comma
id|walk_state.next_op
comma
id|acpi_ps_delete_completed_op
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_peek_opcode&n; *&n; * PARAMETERS:  None&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Get next AML opcode (without incrementing AML pointer)&n; *&n; ******************************************************************************/
id|u32
DECL|function|acpi_ps_get_opcode_size
id|acpi_ps_get_opcode_size
(paren
id|u32
id|opcode
)paren
(brace
multiline_comment|/* Extended (2-byte) opcode if &gt; 255 */
r_if
c_cond
(paren
id|opcode
OG
l_int|0x00FF
)paren
(brace
r_return
l_int|2
suffix:semicolon
)brace
multiline_comment|/* Otherwise, just a single byte opcode */
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_peek_opcode&n; *&n; * PARAMETERS:  Parser_state        - A parser state object&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Get next AML opcode (without incrementing AML pointer)&n; *&n; ******************************************************************************/
id|u16
DECL|function|acpi_ps_peek_opcode
id|acpi_ps_peek_opcode
(paren
id|ACPI_PARSE_STATE
op_star
id|parser_state
)paren
(brace
id|u8
op_star
id|aml
suffix:semicolon
id|u16
id|opcode
suffix:semicolon
id|aml
op_assign
id|parser_state-&gt;aml
suffix:semicolon
id|opcode
op_assign
(paren
id|u16
)paren
id|GET8
(paren
id|aml
)paren
suffix:semicolon
id|aml
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Original code special cased LNOTEQUAL, LLESSEQUAL, LGREATEREQUAL.&n;&t; * These opcodes are no longer recognized. Instead, they are broken into&n;&t; * two opcodes.&n;&t; *&n;&t; *&n;&t; *    if (Opcode == AML_EXTOP&n;&t; *       || (Opcode == AML_LNOT&n;&t; *          &amp;&amp; (GET8 (Acpi_aml) == AML_LEQUAL&n;&t; *               || GET8 (Acpi_aml) == AML_LGREATER&n;&t; *               || GET8 (Acpi_aml) == AML_LLESS)))&n;&t; *&n;&t; *     extended Opcode, !=, &lt;=, or &gt;=&n;&t; */
r_if
c_cond
(paren
id|opcode
op_eq
id|AML_EXTOP
)paren
(brace
multiline_comment|/* Extended opcode */
id|opcode
op_assign
(paren
id|u16
)paren
(paren
(paren
id|opcode
op_lshift
l_int|8
)paren
op_or
id|GET8
(paren
id|aml
)paren
)paren
suffix:semicolon
id|aml
op_increment
suffix:semicolon
)brace
multiline_comment|/* don&squot;t convert bare name to a namepath */
r_return
id|opcode
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_create_state&n; *&n; * PARAMETERS:  Acpi_aml            - Acpi_aml code pointer&n; *              Acpi_aml_size       - Length of AML code&n; *&n; * RETURN:      A new parser state object&n; *&n; * DESCRIPTION: Create and initialize a new parser state object&n; *&n; ******************************************************************************/
id|ACPI_PARSE_STATE
op_star
DECL|function|acpi_ps_create_state
id|acpi_ps_create_state
(paren
id|u8
op_star
id|aml
comma
id|s32
id|aml_size
)paren
(brace
id|ACPI_PARSE_STATE
op_star
id|parser_state
suffix:semicolon
id|parser_state
op_assign
id|acpi_cm_callocate
(paren
r_sizeof
(paren
id|ACPI_PARSE_STATE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parser_state
)paren
(brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|parser_state-&gt;aml
op_assign
id|aml
suffix:semicolon
id|parser_state-&gt;aml_end
op_assign
id|aml
op_plus
id|aml_size
suffix:semicolon
id|parser_state-&gt;pkg_end
op_assign
id|parser_state-&gt;aml_end
suffix:semicolon
id|parser_state-&gt;aml_start
op_assign
id|aml
suffix:semicolon
r_return
(paren
id|parser_state
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_find_object&n; *&n; * PARAMETERS:  Opcode          - Current opcode&n; *              Parser_state    - Current state&n; *              Walk_state      - Current state&n; *              *Op             - Where found/new op is returned&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Find a named object.  Two versions - one to search the parse&n; *              tree (for parser-only applications such as acpidump), another&n; *              to search the ACPI internal namespace (the parse tree may no&n; *              longer exist)&n; *&n; ******************************************************************************/
macro_line|#ifdef PARSER_ONLY
id|ACPI_STATUS
DECL|function|acpi_ps_find_object
id|acpi_ps_find_object
(paren
id|u16
id|opcode
comma
id|ACPI_PARSE_STATE
op_star
id|parser_state
comma
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_GENERIC_OP
op_star
op_star
id|op
)paren
(brace
r_char
op_star
id|path
suffix:semicolon
multiline_comment|/* Find the name in the parse tree */
id|path
op_assign
id|acpi_ps_get_next_namestring
(paren
id|parser_state
)paren
suffix:semicolon
op_star
id|op
op_assign
id|acpi_ps_find
(paren
id|acpi_ps_get_parent_scope
(paren
id|parser_state
)paren
comma
id|path
comma
id|opcode
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|op
)paren
)paren
(brace
r_return
id|AE_NOT_FOUND
suffix:semicolon
)brace
r_return
id|AE_OK
suffix:semicolon
)brace
macro_line|#else
id|ACPI_STATUS
DECL|function|acpi_ps_find_object
id|acpi_ps_find_object
(paren
id|u16
id|opcode
comma
id|ACPI_PARSE_STATE
op_star
id|parser_state
comma
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_GENERIC_OP
op_star
op_star
id|out_op
)paren
(brace
r_char
op_star
id|path
suffix:semicolon
id|ACPI_GENERIC_OP
op_star
id|op
suffix:semicolon
id|OBJECT_TYPE_INTERNAL
id|data_type
suffix:semicolon
id|ACPI_STATUS
id|status
suffix:semicolon
id|ACPI_NAMED_OBJECT
op_star
id|entry
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/*&n;&t; * The full parse tree has already been deleted -- therefore, we are parsing&n;&t; * a control method.  We can lookup the name in the namespace instead of&n;&t; * the parse tree!&n;&t; */
id|path
op_assign
id|acpi_ps_get_next_namestring
(paren
id|parser_state
)paren
suffix:semicolon
multiline_comment|/* Map the raw opcode into an internal object type */
id|data_type
op_assign
id|acpi_ds_map_named_opcode_to_data_type
(paren
id|opcode
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Enter the object into the namespace&n;&t; * LOAD_PASS1 means Create if not found&n;&t; */
id|status
op_assign
id|acpi_ns_lookup
(paren
id|walk_state-&gt;scope_info
comma
id|path
comma
id|data_type
comma
id|IMODE_LOAD_PASS1
comma
id|NS_NO_UPSEARCH
comma
id|walk_state
comma
op_amp
id|entry
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* Create a new op */
id|op
op_assign
id|acpi_ps_alloc_op
(paren
id|opcode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
multiline_comment|/* Initialize */
(paren
(paren
id|ACPI_NAMED_OP
op_star
)paren
id|op
)paren
op_member_access_from_pointer
id|name
op_assign
id|entry-&gt;name
suffix:semicolon
id|op-&gt;acpi_named_object
op_assign
id|entry
suffix:semicolon
id|acpi_ps_append_arg
(paren
id|acpi_ps_get_parent_scope
(paren
id|parser_state
)paren
comma
id|op
)paren
suffix:semicolon
op_star
id|out_op
op_assign
id|op
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_parse_loop&n; *&n; * PARAMETERS:  Parser_state        - Current parser state object&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Parse AML (pointed to by the current parser state) and return&n; *              a tree of ops.&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ps_parse_loop
id|acpi_ps_parse_loop
(paren
id|ACPI_PARSE_STATE
op_star
id|parser_state
comma
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|u32
id|parse_flags
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|ACPI_GENERIC_OP
op_star
id|op
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* current op */
id|ACPI_OP_INFO
op_star
id|op_info
suffix:semicolon
id|ACPI_GENERIC_OP
op_star
id|arg
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_DEFERRED_OP
op_star
id|deferred_op
suffix:semicolon
id|u32
id|arg_count
suffix:semicolon
multiline_comment|/* push for fixed or var args */
id|u32
id|arg_types
op_assign
l_int|0
suffix:semicolon
id|ACPI_PTRDIFF
id|aml_offset
suffix:semicolon
id|u16
id|opcode
suffix:semicolon
id|ACPI_GENERIC_OP
id|pre_op
suffix:semicolon
macro_line|#ifndef PARSER_ONLY
id|OBJECT_TYPE_INTERNAL
id|data_type
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Iterative parsing loop, while there is more aml to process:&n;&t; */
r_while
c_loop
(paren
id|parser_state-&gt;aml
OL
id|parser_state-&gt;aml_end
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
multiline_comment|/* Get the next opcode from the AML stream */
id|aml_offset
op_assign
id|parser_state-&gt;aml
op_minus
id|parser_state-&gt;aml_start
suffix:semicolon
id|opcode
op_assign
id|acpi_ps_peek_opcode
(paren
id|parser_state
)paren
suffix:semicolon
id|op_info
op_assign
id|acpi_ps_get_opcode_info
(paren
id|opcode
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * First cut to determine what we have found:&n;&t;&t;&t; * 1) A valid AML opcode&n;&t;&t;&t; * 2) A name string&n;&t;&t;&t; * 3) An unknown/invalid opcode&n;&t;&t;&t; */
r_if
c_cond
(paren
id|op_info
)paren
(brace
multiline_comment|/* Found opcode info, this is a normal opcode */
id|parser_state-&gt;aml
op_add_assign
id|acpi_ps_get_opcode_size
(paren
id|opcode
)paren
suffix:semicolon
id|arg_types
op_assign
id|op_info-&gt;parse_args
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|acpi_ps_is_prefix_char
(paren
id|opcode
)paren
op_logical_or
id|acpi_ps_is_leading_char
(paren
id|opcode
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Starts with a valid prefix or ASCII char, this is a name&n;&t;&t;&t;&t; * string.  Convert the bare name string to a namepath.&n;&t;&t;&t;&t; */
id|opcode
op_assign
id|AML_NAMEPATH_OP
suffix:semicolon
id|arg_types
op_assign
id|ARGP_NAMESTRING
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The opcode is unrecognized.  Just skip unknown opcodes */
id|parser_state-&gt;aml
op_add_assign
id|acpi_ps_get_opcode_size
(paren
id|opcode
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Create Op structure and append to parent&squot;s argument list */
r_if
c_cond
(paren
id|acpi_ps_is_named_op
(paren
id|opcode
)paren
)paren
(brace
id|pre_op.value.arg
op_assign
l_int|NULL
suffix:semicolon
id|pre_op.opcode
op_assign
id|opcode
suffix:semicolon
r_while
c_loop
(paren
id|GET_CURRENT_ARG_TYPE
(paren
id|arg_types
)paren
op_ne
id|ARGP_NAME
)paren
(brace
id|arg
op_assign
id|acpi_ps_get_next_arg
(paren
id|parser_state
comma
id|GET_CURRENT_ARG_TYPE
(paren
id|arg_types
)paren
comma
op_amp
id|arg_count
)paren
suffix:semicolon
id|acpi_ps_append_arg
(paren
op_amp
id|pre_op
comma
id|arg
)paren
suffix:semicolon
id|INCREMENT_ARG_LIST
(paren
id|arg_types
)paren
suffix:semicolon
)brace
multiline_comment|/* We know that this arg is a name, move to next arg */
id|INCREMENT_ARG_LIST
(paren
id|arg_types
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ps_find_object
(paren
id|opcode
comma
id|parser_state
comma
id|walk_state
comma
op_amp
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|AE_NOT_FOUND
)paren
suffix:semicolon
)brace
id|acpi_ps_append_arg
(paren
id|op
comma
id|pre_op.value.arg
)paren
suffix:semicolon
id|acpi_gbl_depth
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|op-&gt;opcode
op_eq
id|AML_REGION_OP
)paren
(brace
id|deferred_op
op_assign
id|acpi_ps_to_deferred_op
(paren
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deferred_op
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Skip parsing of control method or opregion body,&n;&t;&t;&t;&t;&t;&t; * because we don&squot;t have enough info in the first pass&n;&t;&t;&t;&t;&t;&t; * to parse them correctly.&n;&t;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t;&t; * Backup to beginning of Op_region declaration (2 for&n;&t;&t;&t;&t;&t;&t; * Opcode, 4 for name)&n;&t;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t;&t; * Body_length is unknown until we parse the body&n;&t;&t;&t;&t;&t;&t; */
id|deferred_op-&gt;body
op_assign
id|parser_state-&gt;aml
op_minus
l_int|6
suffix:semicolon
id|deferred_op-&gt;body_length
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Not a named opcode, just allocate Op and append to parent */
id|op
op_assign
id|acpi_ps_alloc_op
(paren
id|opcode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
id|acpi_ps_append_arg
(paren
id|acpi_ps_get_parent_scope
(paren
id|parser_state
)paren
comma
id|op
)paren
suffix:semicolon
)brace
id|op-&gt;aml_offset
op_assign
id|aml_offset
suffix:semicolon
)brace
id|arg_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|arg_types
)paren
multiline_comment|/* Are there any arguments that must be processed? */
(brace
multiline_comment|/* get arguments */
r_switch
c_cond
(paren
id|op-&gt;opcode
)paren
(brace
r_case
id|AML_BYTE_OP
suffix:colon
multiline_comment|/* AML_BYTEDATA_ARG */
r_case
id|AML_WORD_OP
suffix:colon
multiline_comment|/* AML_WORDDATA_ARG */
r_case
id|AML_DWORD_OP
suffix:colon
multiline_comment|/* AML_DWORDATA_ARG */
r_case
id|AML_STRING_OP
suffix:colon
multiline_comment|/* AML_ASCIICHARLIST_ARG */
multiline_comment|/* fill in constant or string argument directly */
id|acpi_ps_get_next_simple_arg
(paren
id|parser_state
comma
id|GET_CURRENT_ARG_TYPE
(paren
id|arg_types
)paren
comma
id|op
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_NAMEPATH_OP
suffix:colon
multiline_comment|/* AML_NAMESTRING_ARG */
id|acpi_ps_get_next_namepath
(paren
id|parser_state
comma
id|op
comma
op_amp
id|arg_count
comma
l_int|1
)paren
suffix:semicolon
id|arg_types
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* Op is not a constant or string, append each argument */
r_while
c_loop
(paren
id|GET_CURRENT_ARG_TYPE
(paren
id|arg_types
)paren
op_logical_and
op_logical_neg
id|arg_count
)paren
(brace
id|aml_offset
op_assign
id|parser_state-&gt;aml
op_minus
id|parser_state-&gt;aml_start
suffix:semicolon
id|arg
op_assign
id|acpi_ps_get_next_arg
(paren
id|parser_state
comma
id|GET_CURRENT_ARG_TYPE
(paren
id|arg_types
)paren
comma
op_amp
id|arg_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
(brace
id|arg-&gt;aml_offset
op_assign
id|aml_offset
suffix:semicolon
)brace
id|acpi_ps_append_arg
(paren
id|op
comma
id|arg
)paren
suffix:semicolon
id|INCREMENT_ARG_LIST
(paren
id|arg_types
)paren
suffix:semicolon
)brace
multiline_comment|/* For a method, save the length and address of the body */
r_if
c_cond
(paren
id|op-&gt;opcode
op_eq
id|AML_METHOD_OP
)paren
(brace
id|deferred_op
op_assign
id|acpi_ps_to_deferred_op
(paren
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deferred_op
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Skip parsing of control method or opregion body,&n;&t;&t;&t;&t;&t;&t; * because we don&squot;t have enough info in the first pass&n;&t;&t;&t;&t;&t;&t; * to parse them correctly.&n;&t;&t;&t;&t;&t;&t; */
id|deferred_op-&gt;body
op_assign
id|parser_state-&gt;aml
suffix:semicolon
id|deferred_op-&gt;body_length
op_assign
id|parser_state-&gt;pkg_end
op_minus
id|parser_state-&gt;aml
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Skip body of method.  For Op_regions, we must continue&n;&t;&t;&t;&t;&t;&t; * parsing because the opregion is not a standalone&n;&t;&t;&t;&t;&t;&t; * package (We don&squot;t know where the end is).&n;&t;&t;&t;&t;&t;&t; */
id|parser_state-&gt;aml
op_assign
id|parser_state-&gt;pkg_end
suffix:semicolon
id|arg_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|arg_count
)paren
(brace
multiline_comment|/* completed Op, prepare for next */
r_if
c_cond
(paren
id|acpi_ps_is_named_op
(paren
id|op-&gt;opcode
)paren
)paren
(brace
r_if
c_cond
(paren
id|acpi_gbl_depth
)paren
(brace
id|acpi_gbl_depth
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|op-&gt;opcode
op_eq
id|AML_REGION_OP
)paren
(brace
id|deferred_op
op_assign
id|acpi_ps_to_deferred_op
(paren
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deferred_op
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Skip parsing of control method or opregion body,&n;&t;&t;&t;&t;&t;&t; * because we don&squot;t have enough info in the first pass&n;&t;&t;&t;&t;&t;&t; * to parse them correctly.&n;&t;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t;&t; * Completed parsing an Op_region declaration, we now&n;&t;&t;&t;&t;&t;&t; * know the length.&n;&t;&t;&t;&t;&t;&t; */
id|deferred_op-&gt;body_length
op_assign
id|parser_state-&gt;aml
op_minus
id|deferred_op-&gt;body
suffix:semicolon
)brace
)brace
macro_line|#ifndef PARSER_ONLY
id|data_type
op_assign
id|acpi_ds_map_named_opcode_to_data_type
(paren
id|op-&gt;opcode
)paren
suffix:semicolon
r_if
c_cond
(paren
id|op-&gt;opcode
op_eq
id|AML_NAME_OP
)paren
(brace
r_if
c_cond
(paren
id|op-&gt;value.arg
)paren
(brace
id|data_type
op_assign
id|acpi_ds_map_opcode_to_data_type
(paren
(paren
id|op-&gt;value.arg
)paren
op_member_access_from_pointer
id|opcode
comma
l_int|NULL
)paren
suffix:semicolon
(paren
(paren
id|ACPI_NAMED_OBJECT
op_star
)paren
id|op-&gt;acpi_named_object
)paren
op_member_access_from_pointer
id|type
op_assign
(paren
id|u8
)paren
id|data_type
suffix:semicolon
)brace
)brace
multiline_comment|/* Pop the scope stack */
r_if
c_cond
(paren
id|acpi_ns_opens_scope
(paren
id|data_type
)paren
)paren
(brace
id|acpi_ds_scope_stack_pop
(paren
id|walk_state
)paren
suffix:semicolon
)brace
macro_line|#endif
)brace
id|parser_state-&gt;scope-&gt;arg_count
op_decrement
suffix:semicolon
multiline_comment|/* Delete op if asked to */
macro_line|#ifndef PARSER_ONLY
r_if
c_cond
(paren
id|parse_flags
op_amp
id|PARSE_DELETE_TREE
)paren
(brace
id|acpi_ps_delete_parse_tree
(paren
id|op
)paren
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
id|acpi_ps_has_completed_scope
(paren
id|parser_state
)paren
)paren
(brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|arg_types
)paren
suffix:semicolon
)brace
r_else
(brace
id|op
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* complex argument, push Op and prepare for argument */
id|acpi_ps_push_scope
(paren
id|parser_state
comma
id|op
comma
id|arg_types
comma
id|arg_count
)paren
suffix:semicolon
id|op
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* while Parser_state-&gt;Aml */
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_parse_aml&n; *&n; * PARAMETERS:  Start_scope     - The starting point of the parse.  Becomes the&n; *                                root of the parsed op tree.&n; *              Aml             - Pointer to the raw AML code to parse&n; *              Aml_size        - Length of the AML to parse&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Parse raw AML and return a tree of ops&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ps_parse_aml
id|acpi_ps_parse_aml
(paren
id|ACPI_GENERIC_OP
op_star
id|start_scope
comma
id|u8
op_star
id|aml
comma
id|u32
id|aml_size
comma
id|u32
id|parse_flags
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|ACPI_PARSE_STATE
op_star
id|parser_state
suffix:semicolon
id|ACPI_WALK_STATE
op_star
id|walk_state
suffix:semicolon
id|ACPI_WALK_LIST
id|walk_list
suffix:semicolon
id|ACPI_NAMED_OBJECT
op_star
id|entry
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Initialize parser state and scope */
id|parser_state
op_assign
id|acpi_ps_create_state
(paren
id|aml
comma
id|aml_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parser_state
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
id|acpi_ps_init_scope
(paren
id|parser_state
comma
id|start_scope
)paren
suffix:semicolon
multiline_comment|/* Initialize a new walk list */
id|walk_list.walk_state
op_assign
l_int|NULL
suffix:semicolon
id|walk_state
op_assign
id|acpi_ds_create_walk_state
(paren
id|TABLE_ID_DSDT
comma
l_int|NULL
comma
l_int|NULL
comma
op_amp
id|walk_list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|walk_state
)paren
(brace
id|status
op_assign
id|AE_NO_MEMORY
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* Setup the current scope */
id|entry
op_assign
id|parser_state-&gt;start_op-&gt;acpi_named_object
suffix:semicolon
r_if
c_cond
(paren
id|entry
)paren
(brace
multiline_comment|/* Push start scope on scope stack and make it current  */
id|status
op_assign
id|acpi_ds_scope_stack_push
(paren
id|entry-&gt;child_table
comma
id|entry-&gt;type
comma
id|walk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
multiline_comment|/* Create the parse tree */
id|status
op_assign
id|acpi_ps_parse_loop
(paren
id|parser_state
comma
id|walk_state
comma
id|parse_flags
)paren
suffix:semicolon
id|cleanup
suffix:colon
multiline_comment|/* Cleanup */
id|acpi_ds_delete_walk_state
(paren
id|walk_state
)paren
suffix:semicolon
id|acpi_ps_cleanup_scope
(paren
id|parser_state
)paren
suffix:semicolon
id|acpi_cm_free
(paren
id|parser_state
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
eof
