multiline_comment|/******************************************************************************&n; *&n; * Module Name: psparse - Parser top level AML parse routines&n; *              $Revision: 71 $&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
multiline_comment|/*&n; * Parse the AML and build an operation tree as most interpreters,&n; * like Perl, do.  Parsing is done by hand rather than with a YACC&n; * generated parser to tightly constrain stack and dynamic memory&n; * usage.  At the same time, parsing is kept flexible and the code&n; * fairly compact by parsing based on a list of AML opcode&n; * templates in Aml_op_info[]&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;acparser.h&quot;
macro_line|#include &quot;acdispat.h&quot;
macro_line|#include &quot;amlcode.h&quot;
macro_line|#include &quot;acnamesp.h&quot;
macro_line|#include &quot;acdebug.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          PARSER
id|MODULE_NAME
(paren
l_string|&quot;psparse&quot;
)paren
DECL|variable|acpi_gbl_depth
id|u32
id|acpi_gbl_depth
op_assign
l_int|0
suffix:semicolon
r_extern
id|u32
id|acpi_gbl_scope_depth
suffix:semicolon
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_peek_opcode&n; *&n; * PARAMETERS:  None&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Get next AML opcode (without incrementing AML pointer)&n; *&n; ******************************************************************************/
r_static
id|u32
DECL|function|acpi_ps_get_opcode_size
id|acpi_ps_get_opcode_size
(paren
id|u32
id|opcode
)paren
(brace
multiline_comment|/* Extended (2-byte) opcode if &gt; 255 */
r_if
c_cond
(paren
id|opcode
OG
l_int|0x00FF
)paren
(brace
r_return
(paren
l_int|2
)paren
suffix:semicolon
)brace
multiline_comment|/* Otherwise, just a single byte opcode */
r_return
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_peek_opcode&n; *&n; * PARAMETERS:  Parser_state        - A parser state object&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Get next AML opcode (without incrementing AML pointer)&n; *&n; ******************************************************************************/
id|u16
DECL|function|acpi_ps_peek_opcode
id|acpi_ps_peek_opcode
(paren
id|ACPI_PARSE_STATE
op_star
id|parser_state
)paren
(brace
id|u8
op_star
id|aml
suffix:semicolon
id|u16
id|opcode
suffix:semicolon
id|aml
op_assign
id|parser_state-&gt;aml
suffix:semicolon
id|opcode
op_assign
(paren
id|u16
)paren
id|GET8
(paren
id|aml
)paren
suffix:semicolon
id|aml
op_increment
suffix:semicolon
multiline_comment|/*&n;&t; * Original code special cased LNOTEQUAL, LLESSEQUAL, LGREATEREQUAL.&n;&t; * These opcodes are no longer recognized. Instead, they are broken into&n;&t; * two opcodes.&n;&t; *&n;&t; *&n;&t; *    if (Opcode == AML_EXTOP&n;&t; *       || (Opcode == AML_LNOT&n;&t; *          &amp;&amp; (GET8 (Acpi_aml) == AML_LEQUAL&n;&t; *               || GET8 (Acpi_aml) == AML_LGREATER&n;&t; *               || GET8 (Acpi_aml) == AML_LLESS)))&n;&t; *&n;&t; *     extended Opcode, !=, &lt;=, or &gt;=&n;&t; */
r_if
c_cond
(paren
id|opcode
op_eq
id|AML_EXTOP
)paren
(brace
multiline_comment|/* Extended opcode */
id|opcode
op_assign
(paren
id|u16
)paren
(paren
(paren
id|opcode
op_lshift
l_int|8
)paren
op_or
id|GET8
(paren
id|aml
)paren
)paren
suffix:semicolon
id|aml
op_increment
suffix:semicolon
)brace
multiline_comment|/* don&squot;t convert bare name to a namepath */
r_return
(paren
id|opcode
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_create_state&n; *&n; * PARAMETERS:  Acpi_aml            - Acpi_aml code pointer&n; *              Acpi_aml_size       - Length of AML code&n; *&n; * RETURN:      A new parser state object&n; *&n; * DESCRIPTION: Create and initialize a new parser state object&n; *&n; ******************************************************************************/
id|ACPI_PARSE_STATE
op_star
DECL|function|acpi_ps_create_state
id|acpi_ps_create_state
(paren
id|u8
op_star
id|aml
comma
id|u32
id|aml_size
)paren
(brace
id|ACPI_PARSE_STATE
op_star
id|parser_state
suffix:semicolon
id|parser_state
op_assign
id|acpi_cm_callocate
(paren
r_sizeof
(paren
id|ACPI_PARSE_STATE
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parser_state
)paren
(brace
r_return
(paren
l_int|NULL
)paren
suffix:semicolon
)brace
id|parser_state-&gt;aml
op_assign
id|aml
suffix:semicolon
id|parser_state-&gt;aml_end
op_assign
id|aml
op_plus
id|aml_size
suffix:semicolon
id|parser_state-&gt;pkg_end
op_assign
id|parser_state-&gt;aml_end
suffix:semicolon
id|parser_state-&gt;aml_start
op_assign
id|aml
suffix:semicolon
r_return
(paren
id|parser_state
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_find_object&n; *&n; * PARAMETERS:  Opcode          - Current opcode&n; *              Parser_state    - Current state&n; *              Walk_state      - Current state&n; *              *Op             - Where found/new op is returned&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Find a named object.  Two versions - one to search the parse&n; *              tree (for parser-only applications such as acpidump), another&n; *              to search the ACPI internal namespace (the parse tree may no&n; *              longer exist)&n; *&n; ******************************************************************************/
macro_line|#ifdef PARSER_ONLY
id|ACPI_STATUS
DECL|function|acpi_ps_find_object
id|acpi_ps_find_object
(paren
id|u16
id|opcode
comma
id|ACPI_PARSE_OBJECT
op_star
id|op
comma
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_PARSE_OBJECT
op_star
op_star
id|out_op
)paren
(brace
id|NATIVE_CHAR
op_star
id|path
suffix:semicolon
multiline_comment|/* We are only interested in opcodes that have an associated name */
r_if
c_cond
(paren
op_logical_neg
id|acpi_ps_is_named_op
(paren
id|opcode
)paren
)paren
(brace
op_star
id|out_op
op_assign
id|op
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/* Find the name in the parse tree */
id|path
op_assign
id|acpi_ps_get_next_namestring
(paren
id|walk_state-&gt;parser_state
)paren
suffix:semicolon
op_star
id|out_op
op_assign
id|acpi_ps_find
(paren
id|acpi_ps_get_parent_scope
(paren
id|walk_state-&gt;parser_state
)paren
comma
id|path
comma
id|opcode
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
op_star
id|out_op
)paren
)paren
(brace
r_return
(paren
id|AE_NOT_FOUND
)paren
suffix:semicolon
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_complete_this_op&n; *&n; * PARAMETERS:  Walk_state      - Current State&n; *              Op              - Op to complete&n; *&n; * RETURN:      TRUE if Op and subtree was deleted&n; *&n; * DESCRIPTION: Perform any cleanup at the completion of an Op.&n; *&n; ******************************************************************************/
r_static
id|u8
DECL|function|acpi_ps_complete_this_op
id|acpi_ps_complete_this_op
(paren
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_PARSE_OBJECT
op_star
id|op
)paren
(brace
macro_line|#ifndef PARSER_ONLY
id|ACPI_PARSE_OBJECT
op_star
id|prev
suffix:semicolon
id|ACPI_PARSE_OBJECT
op_star
id|next
suffix:semicolon
id|ACPI_OPCODE_INFO
op_star
id|op_info
suffix:semicolon
id|ACPI_OPCODE_INFO
op_star
id|parent_info
suffix:semicolon
id|u32
id|opcode_class
suffix:semicolon
id|ACPI_PARSE_OBJECT
op_star
id|replacement_op
op_assign
l_int|NULL
suffix:semicolon
id|op_info
op_assign
id|acpi_ps_get_opcode_info
(paren
id|op-&gt;opcode
)paren
suffix:semicolon
id|opcode_class
op_assign
id|ACPI_GET_OP_CLASS
(paren
id|op_info
)paren
suffix:semicolon
multiline_comment|/* Delete this op and the subtree below it if asked to */
r_if
c_cond
(paren
(paren
(paren
id|walk_state-&gt;parse_flags
op_amp
id|ACPI_PARSE_TREE_MASK
)paren
op_eq
id|ACPI_PARSE_DELETE_TREE
)paren
op_logical_and
(paren
id|opcode_class
op_ne
id|OPTYPE_CONSTANT
)paren
op_logical_and
(paren
id|opcode_class
op_ne
id|OPTYPE_LITERAL
)paren
op_logical_and
(paren
id|opcode_class
op_ne
id|OPTYPE_LOCAL_VARIABLE
)paren
op_logical_and
(paren
id|opcode_class
op_ne
id|OPTYPE_METHOD_ARGUMENT
)paren
op_logical_and
(paren
id|opcode_class
op_ne
id|OPTYPE_DATA_TERM
)paren
op_logical_and
(paren
id|op-&gt;opcode
op_ne
id|AML_NAMEPATH_OP
)paren
)paren
(brace
multiline_comment|/* Make sure that we only delete this subtree */
r_if
c_cond
(paren
id|op-&gt;parent
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Check if we need to replace the operator and its subtree&n;&t;&t;&t; * with a return value op (placeholder op)&n;&t;&t;&t; */
id|parent_info
op_assign
id|acpi_ps_get_opcode_info
(paren
id|op-&gt;parent-&gt;opcode
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ACPI_GET_OP_CLASS
(paren
id|parent_info
)paren
)paren
(brace
r_case
id|OPTYPE_CONTROL
suffix:colon
multiline_comment|/* IF, ELSE, WHILE only */
r_break
suffix:semicolon
r_case
id|OPTYPE_NAMED_OBJECT
suffix:colon
multiline_comment|/* Scope, method, etc. */
multiline_comment|/*&n;&t;&t;&t;&t; * These opcodes contain Term_arg operands. The current&n;&t;&t;&t;&t; * op must be replace by a placeholder return op&n;&t;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|op-&gt;parent-&gt;opcode
op_eq
id|AML_REGION_OP
)paren
op_logical_or
(paren
id|op-&gt;parent-&gt;opcode
op_eq
id|AML_CREATE_FIELD_OP
)paren
op_logical_or
(paren
id|op-&gt;parent-&gt;opcode
op_eq
id|AML_BIT_FIELD_OP
)paren
op_logical_or
(paren
id|op-&gt;parent-&gt;opcode
op_eq
id|AML_BYTE_FIELD_OP
)paren
op_logical_or
(paren
id|op-&gt;parent-&gt;opcode
op_eq
id|AML_WORD_FIELD_OP
)paren
op_logical_or
(paren
id|op-&gt;parent-&gt;opcode
op_eq
id|AML_DWORD_FIELD_OP
)paren
op_logical_or
(paren
id|op-&gt;parent-&gt;opcode
op_eq
id|AML_QWORD_FIELD_OP
)paren
)paren
(brace
id|replacement_op
op_assign
id|acpi_ps_alloc_op
(paren
id|AML_RETURN_VALUE_OP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|replacement_op
)paren
(brace
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|replacement_op
op_assign
id|acpi_ps_alloc_op
(paren
id|AML_RETURN_VALUE_OP
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|replacement_op
)paren
(brace
r_return
(paren
id|FALSE
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* We must unlink this op from the parent tree */
id|prev
op_assign
id|op-&gt;parent-&gt;value.arg
suffix:semicolon
r_if
c_cond
(paren
id|prev
op_eq
id|op
)paren
(brace
multiline_comment|/* This op is the first in the list */
r_if
c_cond
(paren
id|replacement_op
)paren
(brace
id|replacement_op-&gt;parent
op_assign
id|op-&gt;parent
suffix:semicolon
id|replacement_op-&gt;value.arg
op_assign
l_int|NULL
suffix:semicolon
id|op-&gt;parent-&gt;value.arg
op_assign
id|replacement_op
suffix:semicolon
id|replacement_op-&gt;next
op_assign
id|op-&gt;next
suffix:semicolon
)brace
r_else
(brace
id|op-&gt;parent-&gt;value.arg
op_assign
id|op-&gt;next
suffix:semicolon
)brace
)brace
multiline_comment|/* Search the parent list */
r_else
r_while
c_loop
(paren
id|prev
)paren
(brace
multiline_comment|/* Traverse all siblings in the parent&squot;s argument list */
id|next
op_assign
id|prev-&gt;next
suffix:semicolon
r_if
c_cond
(paren
id|next
op_eq
id|op
)paren
(brace
r_if
c_cond
(paren
id|replacement_op
)paren
(brace
id|replacement_op-&gt;parent
op_assign
id|op-&gt;parent
suffix:semicolon
id|replacement_op-&gt;value.arg
op_assign
l_int|NULL
suffix:semicolon
id|prev-&gt;next
op_assign
id|replacement_op
suffix:semicolon
id|replacement_op-&gt;next
op_assign
id|op-&gt;next
suffix:semicolon
id|next
op_assign
l_int|NULL
suffix:semicolon
)brace
r_else
(brace
id|prev-&gt;next
op_assign
id|op-&gt;next
suffix:semicolon
id|next
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
id|prev
op_assign
id|next
suffix:semicolon
)brace
)brace
multiline_comment|/* Now we can actually delete the subtree rooted at op */
id|acpi_ps_delete_parse_tree
(paren
id|op
)paren
suffix:semicolon
r_return
(paren
id|TRUE
)paren
suffix:semicolon
)brace
r_return
(paren
id|FALSE
)paren
suffix:semicolon
macro_line|#else
r_return
(paren
id|FALSE
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_next_parse_state&n; *&n; * PARAMETERS:  Parser_state        - Current parser state object&n; *&n; * RETURN:&n; *&n; * DESCRIPTION:&n; *&n; ******************************************************************************/
r_static
id|ACPI_STATUS
DECL|function|acpi_ps_next_parse_state
id|acpi_ps_next_parse_state
(paren
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_PARSE_OBJECT
op_star
id|op
comma
id|ACPI_STATUS
id|callback_status
)paren
(brace
id|ACPI_PARSE_STATE
op_star
id|parser_state
op_assign
id|walk_state-&gt;parser_state
suffix:semicolon
id|ACPI_STATUS
id|status
op_assign
id|AE_CTRL_PENDING
suffix:semicolon
id|u8
op_star
id|start
suffix:semicolon
id|u32
id|package_length
suffix:semicolon
r_switch
c_cond
(paren
id|callback_status
)paren
(brace
r_case
id|AE_CTRL_TERMINATE
suffix:colon
multiline_comment|/*&n;&t;&t; * A control method was terminated via a RETURN statement.&n;&t;&t; * The walk of this method is complete.&n;&t;&t; */
id|parser_state-&gt;aml
op_assign
id|parser_state-&gt;aml_end
suffix:semicolon
id|status
op_assign
id|AE_CTRL_TERMINATE
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_PENDING
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Predicate of a WHILE was true and the loop just completed an&n;&t;&t;&t; * execution.  Go back to the start of the loop and reevaluate the&n;&t;&t;&t; * predicate.&n;&t;&t;&t; */
multiline_comment|/*            Walk_state-&gt;Control_state-&gt;Common.State =&n;&t;&t;&t;&t;&t;CONTROL_PREDICATE_EXECUTING;*/
multiline_comment|/* TBD: How to handle a break within a while. */
multiline_comment|/* This code attempts it */
id|parser_state-&gt;aml
op_assign
id|walk_state-&gt;aml_last_while
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_TRUE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Predicate of an IF was true, and we are at the matching ELSE.&n;&t;&t;&t; * Just close out this package&n;&t;&t;&t; *&n;&t;&t;&t; * Note: Parser_state-&gt;Aml is modified by the package length procedure&n;&t;&t;&t; * TBD: [Investigate] perhaps it shouldn&squot;t, too much trouble&n;&t;&t;&t; */
id|start
op_assign
id|parser_state-&gt;aml
suffix:semicolon
id|package_length
op_assign
id|acpi_ps_get_next_package_length
(paren
id|parser_state
)paren
suffix:semicolon
id|parser_state-&gt;aml
op_assign
id|start
op_plus
id|package_length
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_FALSE
suffix:colon
multiline_comment|/*&n;&t;&t; * Either an IF/WHILE Predicate was false or we encountered a BREAK&n;&t;&t; * opcode.  In both cases, we do not execute the rest of the&n;&t;&t; * package;  We simply close out the parent (finishing the walk of&n;&t;&t; * this branch of the tree) and continue execution at the parent&n;&t;&t; * level.&n;&t;&t; */
id|parser_state-&gt;aml
op_assign
id|parser_state-&gt;scope-&gt;parse_scope.pkg_end
suffix:semicolon
multiline_comment|/* In the case of a BREAK, just force a predicate (if any) to FALSE */
id|walk_state-&gt;control_state-&gt;common.value
op_assign
id|FALSE
suffix:semicolon
id|status
op_assign
id|AE_CTRL_END
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_TRANSFER
suffix:colon
multiline_comment|/*&n;&t;&t; * A method call (invocation) -- transfer control&n;&t;&t; */
id|status
op_assign
id|AE_CTRL_TRANSFER
suffix:semicolon
id|walk_state-&gt;prev_op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;method_call_op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;method_call_node
op_assign
(paren
id|op-&gt;value.arg
)paren
op_member_access_from_pointer
id|node
suffix:semicolon
multiline_comment|/* Will return value (if any) be used by the caller? */
id|walk_state-&gt;return_used
op_assign
id|acpi_ds_is_result_used
(paren
id|op
comma
id|walk_state
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
id|callback_status
suffix:semicolon
r_if
c_cond
(paren
(paren
id|callback_status
op_amp
id|AE_CODE_MASK
)paren
op_eq
id|AE_CODE_CONTROL
)paren
(brace
id|status
op_assign
id|AE_OK
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_parse_loop&n; *&n; * PARAMETERS:  Parser_state        - Current parser state object&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Parse AML (pointed to by the current parser state) and return&n; *              a tree of ops.&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ps_parse_loop
id|acpi_ps_parse_loop
(paren
id|ACPI_WALK_STATE
op_star
id|walk_state
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|ACPI_PARSE_OBJECT
op_star
id|op
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* current op */
id|ACPI_OPCODE_INFO
op_star
id|op_info
suffix:semicolon
id|ACPI_PARSE_OBJECT
op_star
id|arg
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_PARSE2_OBJECT
op_star
id|deferred_op
suffix:semicolon
id|u32
id|arg_count
suffix:semicolon
multiline_comment|/* push for fixed or var args */
id|u32
id|arg_types
op_assign
l_int|0
suffix:semicolon
id|ACPI_PTRDIFF
id|aml_offset
suffix:semicolon
id|u16
id|opcode
suffix:semicolon
id|ACPI_PARSE_OBJECT
id|pre_op
suffix:semicolon
id|ACPI_PARSE_STATE
op_star
id|parser_state
suffix:semicolon
id|u8
op_star
id|aml_op_start
suffix:semicolon
id|parser_state
op_assign
id|walk_state-&gt;parser_state
suffix:semicolon
macro_line|#ifndef PARSER_ONLY
r_if
c_cond
(paren
id|walk_state-&gt;walk_type
op_amp
id|WALK_METHOD_RESTART
)paren
(brace
multiline_comment|/* We are restarting a preempted control method */
r_if
c_cond
(paren
id|acpi_ps_has_completed_scope
(paren
id|parser_state
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * We must check if a predicate to an IF or WHILE statement&n;&t;&t;&t; * was just completed&n;&t;&t;&t; */
r_if
c_cond
(paren
(paren
id|parser_state-&gt;scope-&gt;parse_scope.op
)paren
op_logical_and
(paren
(paren
id|parser_state-&gt;scope-&gt;parse_scope.op-&gt;opcode
op_eq
id|AML_IF_OP
)paren
op_logical_or
(paren
id|parser_state-&gt;scope-&gt;parse_scope.op-&gt;opcode
op_eq
id|AML_WHILE_OP
)paren
)paren
op_logical_and
(paren
id|walk_state-&gt;control_state
)paren
op_logical_and
(paren
id|walk_state-&gt;control_state-&gt;common.state
op_eq
id|CONTROL_PREDICATE_EXECUTING
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * A predicate was just completed, get the value of the&n;&t;&t;&t;&t; * predicate and branch based on that value&n;&t;&t;&t;&t; */
id|status
op_assign
id|acpi_ds_get_predicate_value
(paren
id|walk_state
comma
l_int|NULL
comma
id|TRUE
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ps_next_parse_state
(paren
id|walk_state
comma
id|op
comma
id|status
)paren
suffix:semicolon
)brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|arg_types
comma
op_amp
id|arg_count
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|walk_state-&gt;prev_op
)paren
(brace
multiline_comment|/* We were in the middle of an op */
id|op
op_assign
id|walk_state-&gt;prev_op
suffix:semicolon
id|arg_types
op_assign
id|walk_state-&gt;prev_arg_types
suffix:semicolon
)brace
)brace
macro_line|#endif
multiline_comment|/*&n;&t; * Iterative parsing loop, while there is more aml to process:&n;&t; */
r_while
c_loop
(paren
(paren
id|parser_state-&gt;aml
OL
id|parser_state-&gt;aml_end
)paren
op_logical_or
(paren
id|op
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
multiline_comment|/* Get the next opcode from the AML stream */
id|aml_op_start
op_assign
id|parser_state-&gt;aml
suffix:semicolon
id|aml_offset
op_assign
id|parser_state-&gt;aml
op_minus
id|parser_state-&gt;aml_start
suffix:semicolon
id|opcode
op_assign
id|acpi_ps_peek_opcode
(paren
id|parser_state
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * First cut to determine what we have found:&n;&t;&t;&t; * 1) A valid AML opcode&n;&t;&t;&t; * 2) A name string&n;&t;&t;&t; * 3) An unknown/invalid opcode&n;&t;&t;&t; */
id|op_info
op_assign
id|acpi_ps_get_opcode_info
(paren
id|opcode
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|ACPI_GET_OP_TYPE
(paren
id|op_info
)paren
)paren
(brace
r_case
id|ACPI_OP_TYPE_OPCODE
suffix:colon
multiline_comment|/* Found opcode info, this is a normal opcode */
id|parser_state-&gt;aml
op_add_assign
id|acpi_ps_get_opcode_size
(paren
id|opcode
)paren
suffix:semicolon
id|arg_types
op_assign
id|op_info-&gt;parse_args
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_OP_TYPE_ASCII
suffix:colon
r_case
id|ACPI_OP_TYPE_PREFIX
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * Starts with a valid prefix or ASCII char, this is a name&n;&t;&t;&t;&t; * string.  Convert the bare name string to a namepath.&n;&t;&t;&t;&t; */
id|opcode
op_assign
id|AML_NAMEPATH_OP
suffix:semicolon
id|arg_types
op_assign
id|ARGP_NAMESTRING
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ACPI_OP_TYPE_UNKNOWN
suffix:colon
multiline_comment|/* The opcode is unrecognized.  Just skip unknown opcodes */
multiline_comment|/* Assume one-byte bad opcode */
id|parser_state-&gt;aml
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Create Op structure and append to parent&squot;s argument list */
r_if
c_cond
(paren
id|acpi_ps_is_named_op
(paren
id|opcode
)paren
)paren
(brace
id|pre_op.value.arg
op_assign
l_int|NULL
suffix:semicolon
id|pre_op.opcode
op_assign
id|opcode
suffix:semicolon
r_while
c_loop
(paren
id|GET_CURRENT_ARG_TYPE
(paren
id|arg_types
)paren
op_ne
id|ARGP_NAME
)paren
(brace
id|arg
op_assign
id|acpi_ps_get_next_arg
(paren
id|parser_state
comma
id|GET_CURRENT_ARG_TYPE
(paren
id|arg_types
)paren
comma
op_amp
id|arg_count
)paren
suffix:semicolon
id|acpi_ps_append_arg
(paren
op_amp
id|pre_op
comma
id|arg
)paren
suffix:semicolon
id|INCREMENT_ARG_LIST
(paren
id|arg_types
)paren
suffix:semicolon
)brace
multiline_comment|/* We know that this arg is a name, move to next arg */
id|INCREMENT_ARG_LIST
(paren
id|arg_types
)paren
suffix:semicolon
r_if
c_cond
(paren
id|walk_state-&gt;descending_callback
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Find the object.  This will either insert the object into&n;&t;&t;&t;&t;&t; * the namespace or simply look it up&n;&t;&t;&t;&t;&t; */
id|status
op_assign
id|walk_state-&gt;descending_callback
(paren
id|opcode
comma
l_int|NULL
comma
id|walk_state
comma
op_amp
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|op
op_eq
l_int|NULL
)paren
(brace
r_continue
suffix:semicolon
)brace
id|status
op_assign
id|acpi_ps_next_parse_state
(paren
id|walk_state
comma
id|op
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_PENDING
)paren
(brace
id|status
op_assign
id|AE_OK
suffix:semicolon
r_goto
id|close_this_op
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|close_this_op
suffix:semicolon
)brace
)brace
id|acpi_ps_append_arg
(paren
id|op
comma
id|pre_op.value.arg
)paren
suffix:semicolon
id|acpi_gbl_depth
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|op-&gt;opcode
op_eq
id|AML_REGION_OP
)paren
(brace
id|deferred_op
op_assign
id|acpi_ps_to_extended_op
(paren
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deferred_op
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Defer final parsing of an Operation_region body,&n;&t;&t;&t;&t;&t;&t; * because we don&squot;t have enough info in the first pass&n;&t;&t;&t;&t;&t;&t; * to parse it correctly (i.e., there may be method&n;&t;&t;&t;&t;&t;&t; * calls within the Term_arg elements of the body.&n;&t;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t;&t; * However, we must continue parsing because&n;&t;&t;&t;&t;&t;&t; * the opregion is not a standalone package --&n;&t;&t;&t;&t;&t;&t; * we don&squot;t know where the end is at this point.&n;&t;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t;&t; * (Length is unknown until parse of the body complete)&n;&t;&t;&t;&t;&t;&t; */
id|deferred_op-&gt;data
op_assign
id|aml_op_start
suffix:semicolon
id|deferred_op-&gt;length
op_assign
l_int|0
suffix:semicolon
)brace
)brace
)brace
r_else
(brace
multiline_comment|/* Not a named opcode, just allocate Op and append to parent */
id|op
op_assign
id|acpi_ps_alloc_op
(paren
id|opcode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|op
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|op-&gt;opcode
op_eq
id|AML_CREATE_FIELD_OP
)paren
op_logical_or
(paren
id|op-&gt;opcode
op_eq
id|AML_BIT_FIELD_OP
)paren
op_logical_or
(paren
id|op-&gt;opcode
op_eq
id|AML_BYTE_FIELD_OP
)paren
op_logical_or
(paren
id|op-&gt;opcode
op_eq
id|AML_WORD_FIELD_OP
)paren
op_logical_or
(paren
id|op-&gt;opcode
op_eq
id|AML_DWORD_FIELD_OP
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Backup to beginning of Create_xXXfield declaration&n;&t;&t;&t;&t;&t; * Body_length is unknown until we parse the body&n;&t;&t;&t;&t;&t; */
id|deferred_op
op_assign
(paren
id|ACPI_PARSE2_OBJECT
op_star
)paren
id|op
suffix:semicolon
id|deferred_op-&gt;data
op_assign
id|aml_op_start
suffix:semicolon
id|deferred_op-&gt;length
op_assign
l_int|0
suffix:semicolon
)brace
id|acpi_ps_append_arg
(paren
id|acpi_ps_get_parent_scope
(paren
id|parser_state
)paren
comma
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|walk_state-&gt;descending_callback
op_ne
l_int|NULL
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t; * Find the object.  This will either insert the object into&n;&t;&t;&t;&t;&t; * the namespace or simply look it up&n;&t;&t;&t;&t;&t; */
id|status
op_assign
id|walk_state-&gt;descending_callback
(paren
id|opcode
comma
id|op
comma
id|walk_state
comma
op_amp
id|op
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ps_next_parse_state
(paren
id|walk_state
comma
id|op
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_PENDING
)paren
(brace
id|status
op_assign
id|AE_OK
suffix:semicolon
r_goto
id|close_this_op
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|close_this_op
suffix:semicolon
)brace
)brace
)brace
id|op-&gt;aml_offset
op_assign
id|aml_offset
suffix:semicolon
)brace
multiline_comment|/* Start Arg_count at zero because we don&squot;t know if there are any args yet */
id|arg_count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|arg_types
)paren
multiline_comment|/* Are there any arguments that must be processed? */
(brace
multiline_comment|/* get arguments */
r_switch
c_cond
(paren
id|op-&gt;opcode
)paren
(brace
r_case
id|AML_BYTE_OP
suffix:colon
multiline_comment|/* AML_BYTEDATA_ARG */
r_case
id|AML_WORD_OP
suffix:colon
multiline_comment|/* AML_WORDDATA_ARG */
r_case
id|AML_DWORD_OP
suffix:colon
multiline_comment|/* AML_DWORDATA_ARG */
r_case
id|AML_STRING_OP
suffix:colon
multiline_comment|/* AML_ASCIICHARLIST_ARG */
multiline_comment|/* fill in constant or string argument directly */
id|acpi_ps_get_next_simple_arg
(paren
id|parser_state
comma
id|GET_CURRENT_ARG_TYPE
(paren
id|arg_types
)paren
comma
id|op
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AML_NAMEPATH_OP
suffix:colon
multiline_comment|/* AML_NAMESTRING_ARG */
id|acpi_ps_get_next_namepath
(paren
id|parser_state
comma
id|op
comma
op_amp
id|arg_count
comma
l_int|1
)paren
suffix:semicolon
id|arg_types
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* Op is not a constant or string, append each argument */
r_while
c_loop
(paren
id|GET_CURRENT_ARG_TYPE
(paren
id|arg_types
)paren
op_logical_and
op_logical_neg
id|arg_count
)paren
(brace
id|aml_offset
op_assign
id|parser_state-&gt;aml
op_minus
id|parser_state-&gt;aml_start
suffix:semicolon
id|arg
op_assign
id|acpi_ps_get_next_arg
(paren
id|parser_state
comma
id|GET_CURRENT_ARG_TYPE
(paren
id|arg_types
)paren
comma
op_amp
id|arg_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|arg
)paren
(brace
id|arg-&gt;aml_offset
op_assign
id|aml_offset
suffix:semicolon
id|acpi_ps_append_arg
(paren
id|op
comma
id|arg
)paren
suffix:semicolon
)brace
id|INCREMENT_ARG_LIST
(paren
id|arg_types
)paren
suffix:semicolon
)brace
multiline_comment|/* For a method, save the length and address of the body */
r_if
c_cond
(paren
id|op-&gt;opcode
op_eq
id|AML_METHOD_OP
)paren
(brace
id|deferred_op
op_assign
id|acpi_ps_to_extended_op
(paren
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deferred_op
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Skip parsing of control method or opregion body,&n;&t;&t;&t;&t;&t;&t; * because we don&squot;t have enough info in the first pass&n;&t;&t;&t;&t;&t;&t; * to parse them correctly.&n;&t;&t;&t;&t;&t;&t; */
id|deferred_op-&gt;data
op_assign
id|parser_state-&gt;aml
suffix:semicolon
id|deferred_op-&gt;length
op_assign
id|parser_state-&gt;pkg_end
op_minus
id|parser_state-&gt;aml
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Skip body of method.  For Op_regions, we must continue&n;&t;&t;&t;&t;&t;&t; * parsing because the opregion is not a standalone&n;&t;&t;&t;&t;&t;&t; * package (We don&squot;t know where the end is).&n;&t;&t;&t;&t;&t;&t; */
id|parser_state-&gt;aml
op_assign
id|parser_state-&gt;pkg_end
suffix:semicolon
id|arg_count
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Zero Arg_count means that all arguments for this op have been processed&n;&t;&t; */
r_if
c_cond
(paren
op_logical_neg
id|arg_count
)paren
(brace
multiline_comment|/* completed Op, prepare for next */
r_if
c_cond
(paren
id|acpi_ps_is_named_op
(paren
id|op-&gt;opcode
)paren
)paren
(brace
r_if
c_cond
(paren
id|acpi_gbl_depth
)paren
(brace
id|acpi_gbl_depth
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|op-&gt;opcode
op_eq
id|AML_REGION_OP
)paren
(brace
id|deferred_op
op_assign
id|acpi_ps_to_extended_op
(paren
id|op
)paren
suffix:semicolon
r_if
c_cond
(paren
id|deferred_op
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t;&t;&t; * Skip parsing of control method or opregion body,&n;&t;&t;&t;&t;&t;&t; * because we don&squot;t have enough info in the first pass&n;&t;&t;&t;&t;&t;&t; * to parse them correctly.&n;&t;&t;&t;&t;&t;&t; *&n;&t;&t;&t;&t;&t;&t; * Completed parsing an Op_region declaration, we now&n;&t;&t;&t;&t;&t;&t; * know the length.&n;&t;&t;&t;&t;&t;&t; */
id|deferred_op-&gt;length
op_assign
id|parser_state-&gt;aml
op_minus
id|deferred_op-&gt;data
suffix:semicolon
)brace
)brace
)brace
r_if
c_cond
(paren
(paren
id|op-&gt;opcode
op_eq
id|AML_CREATE_FIELD_OP
)paren
op_logical_or
(paren
id|op-&gt;opcode
op_eq
id|AML_BIT_FIELD_OP
)paren
op_logical_or
(paren
id|op-&gt;opcode
op_eq
id|AML_BYTE_FIELD_OP
)paren
op_logical_or
(paren
id|op-&gt;opcode
op_eq
id|AML_WORD_FIELD_OP
)paren
op_logical_or
(paren
id|op-&gt;opcode
op_eq
id|AML_DWORD_FIELD_OP
)paren
op_logical_or
(paren
id|op-&gt;opcode
op_eq
id|AML_QWORD_FIELD_OP
)paren
)paren
(brace
multiline_comment|/*&n;&t;&t;&t;&t; * Backup to beginning of Create_xXXfield declaration (1 for&n;&t;&t;&t;&t; * Opcode)&n;&t;&t;&t;&t; *&n;&t;&t;&t;&t; * Body_length is unknown until we parse the body&n;&t;&t;&t;&t; */
id|deferred_op
op_assign
(paren
id|ACPI_PARSE2_OBJECT
op_star
)paren
id|op
suffix:semicolon
id|deferred_op-&gt;length
op_assign
id|parser_state-&gt;aml
op_minus
id|deferred_op-&gt;data
suffix:semicolon
)brace
multiline_comment|/* This op complete, notify the dispatcher */
r_if
c_cond
(paren
id|walk_state-&gt;ascending_callback
op_ne
l_int|NULL
)paren
(brace
id|status
op_assign
id|walk_state-&gt;ascending_callback
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ps_next_parse_state
(paren
id|walk_state
comma
id|op
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_PENDING
)paren
(brace
id|status
op_assign
id|AE_OK
suffix:semicolon
r_goto
id|close_this_op
suffix:semicolon
)brace
)brace
id|close_this_op
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Finished one argument of the containing scope&n;&t;&t;&t; */
id|parser_state-&gt;scope-&gt;parse_scope.arg_count
op_decrement
suffix:semicolon
multiline_comment|/* Close this Op (may result in parse subtree deletion) */
r_if
c_cond
(paren
id|acpi_ps_complete_this_op
(paren
id|walk_state
comma
id|op
)paren
)paren
(brace
id|op
op_assign
l_int|NULL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|AE_OK
suffix:colon
r_break
suffix:semicolon
r_case
id|AE_CTRL_TRANSFER
suffix:colon
multiline_comment|/*&n;&t;&t;&t;&t; * We are about to transfer to a called method.&n;&t;&t;&t;&t; */
id|walk_state-&gt;prev_op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;prev_arg_types
op_assign
id|arg_types
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_END
suffix:colon
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|arg_types
comma
op_amp
id|arg_count
)paren
suffix:semicolon
id|status
op_assign
id|walk_state-&gt;ascending_callback
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ps_next_parse_state
(paren
id|walk_state
comma
id|op
comma
id|status
)paren
suffix:semicolon
id|acpi_ps_complete_this_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
id|op
op_assign
l_int|NULL
suffix:semicolon
id|status
op_assign
id|AE_OK
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_TERMINATE
suffix:colon
id|status
op_assign
id|AE_OK
suffix:semicolon
multiline_comment|/* Clean up */
r_do
(brace
r_if
c_cond
(paren
id|op
)paren
(brace
id|acpi_ps_complete_this_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
)brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|arg_types
comma
op_amp
id|arg_count
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|op
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/* All other non-AE_OK status */
r_if
c_cond
(paren
id|op
op_eq
l_int|NULL
)paren
(brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|arg_types
comma
op_amp
id|arg_count
)paren
suffix:semicolon
)brace
id|walk_state-&gt;prev_op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;prev_arg_types
op_assign
id|arg_types
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t;&t; * TEMP:&n;&t;&t;&t;&t; */
r_return
(paren
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* This scope complete? */
r_if
c_cond
(paren
id|acpi_ps_has_completed_scope
(paren
id|parser_state
)paren
)paren
(brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|arg_types
comma
op_amp
id|arg_count
)paren
suffix:semicolon
)brace
r_else
(brace
id|op
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* Arg_count is non-zero */
r_else
(brace
multiline_comment|/* complex argument, push Op and prepare for argument */
id|acpi_ps_push_scope
(paren
id|parser_state
comma
id|op
comma
id|arg_types
comma
id|arg_count
)paren
suffix:semicolon
id|op
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* while Parser_state-&gt;Aml */
multiline_comment|/*&n;&t; * Complete the last Op (if not completed), and clear the scope stack.&n;&t; * It is easily possible to end an AML &quot;package&quot; with an unbounded number&n;&t; * of open scopes (such as when several AML blocks are closed with&n;&t; * sequential closing braces).  We want to terminate each one cleanly.&n;&t; */
r_do
(brace
r_if
c_cond
(paren
id|op
)paren
(brace
r_if
c_cond
(paren
id|walk_state-&gt;ascending_callback
op_ne
l_int|NULL
)paren
(brace
id|status
op_assign
id|walk_state-&gt;ascending_callback
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
id|status
op_assign
id|acpi_ps_next_parse_state
(paren
id|walk_state
comma
id|op
comma
id|status
)paren
suffix:semicolon
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_PENDING
)paren
(brace
id|status
op_assign
id|AE_OK
suffix:semicolon
r_goto
id|close_this_op
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_TERMINATE
)paren
(brace
id|status
op_assign
id|AE_OK
suffix:semicolon
multiline_comment|/* Clean up */
r_do
(brace
r_if
c_cond
(paren
id|op
)paren
(brace
id|acpi_ps_complete_this_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
)brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|arg_types
comma
op_amp
id|arg_count
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|op
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
id|acpi_ps_complete_this_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
id|acpi_ps_complete_this_op
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
)brace
id|acpi_ps_pop_scope
(paren
id|parser_state
comma
op_amp
id|op
comma
op_amp
id|arg_types
comma
op_amp
id|arg_count
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|op
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_parse_aml&n; *&n; * PARAMETERS:  Start_scope     - The starting point of the parse.  Becomes the&n; *                                root of the parsed op tree.&n; *              Aml             - Pointer to the raw AML code to parse&n; *              Aml_size        - Length of the AML to parse&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Parse raw AML and return a tree of ops&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ps_parse_aml
id|acpi_ps_parse_aml
(paren
id|ACPI_PARSE_OBJECT
op_star
id|start_scope
comma
id|u8
op_star
id|aml
comma
id|u32
id|aml_size
comma
id|u32
id|parse_flags
comma
id|ACPI_NAMESPACE_NODE
op_star
id|method_node
comma
id|ACPI_OPERAND_OBJECT
op_star
op_star
id|params
comma
id|ACPI_OPERAND_OBJECT
op_star
op_star
id|caller_return_desc
comma
id|ACPI_PARSE_DOWNWARDS
id|descending_callback
comma
id|ACPI_PARSE_UPWARDS
id|ascending_callback
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|ACPI_PARSE_STATE
op_star
id|parser_state
suffix:semicolon
id|ACPI_WALK_STATE
op_star
id|walk_state
suffix:semicolon
id|ACPI_WALK_LIST
id|walk_list
suffix:semicolon
id|ACPI_NAMESPACE_NODE
op_star
id|node
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_WALK_LIST
op_star
id|prev_walk_list
op_assign
id|acpi_gbl_current_walk_list
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|return_desc
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|mth_desc
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Create and initialize a new parser state */
id|parser_state
op_assign
id|acpi_ps_create_state
(paren
id|aml
comma
id|aml_size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|parser_state
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
id|acpi_ps_init_scope
(paren
id|parser_state
comma
id|start_scope
)paren
suffix:semicolon
r_if
c_cond
(paren
id|method_node
)paren
(brace
id|mth_desc
op_assign
id|acpi_ns_get_attached_object
(paren
id|method_node
)paren
suffix:semicolon
)brace
multiline_comment|/* Create and initialize a new walk list */
id|walk_list.walk_state
op_assign
l_int|NULL
suffix:semicolon
id|walk_state
op_assign
id|acpi_ds_create_walk_state
(paren
id|TABLE_ID_DSDT
comma
id|parser_state-&gt;start_op
comma
id|mth_desc
comma
op_amp
id|walk_list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|walk_state
)paren
(brace
id|status
op_assign
id|AE_NO_MEMORY
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
id|walk_state-&gt;method_node
op_assign
id|method_node
suffix:semicolon
id|walk_state-&gt;parser_state
op_assign
id|parser_state
suffix:semicolon
id|walk_state-&gt;parse_flags
op_assign
id|parse_flags
suffix:semicolon
id|walk_state-&gt;descending_callback
op_assign
id|descending_callback
suffix:semicolon
id|walk_state-&gt;ascending_callback
op_assign
id|ascending_callback
suffix:semicolon
multiline_comment|/* TBD: [Restructure] TEMP until we pass Walk_state to the interpreter&n;&t; */
id|acpi_gbl_current_walk_list
op_assign
op_amp
id|walk_list
suffix:semicolon
r_if
c_cond
(paren
id|method_node
)paren
(brace
id|parser_state-&gt;start_node
op_assign
id|method_node
suffix:semicolon
id|walk_state-&gt;walk_type
op_assign
id|WALK_METHOD
suffix:semicolon
multiline_comment|/* Push start scope on scope stack and make it current  */
id|status
op_assign
id|acpi_ds_scope_stack_push
(paren
id|method_node
comma
id|ACPI_TYPE_METHOD
comma
id|walk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* Init arguments if this is a control method */
multiline_comment|/* TBD: [Restructure] add walkstate as a param */
id|acpi_ds_method_data_init_args
(paren
id|params
comma
id|MTH_NUM_ARGS
comma
id|walk_state
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Setup the current scope */
id|node
op_assign
id|parser_state-&gt;start_op-&gt;node
suffix:semicolon
id|parser_state-&gt;start_node
op_assign
id|node
suffix:semicolon
r_if
c_cond
(paren
id|node
)paren
(brace
multiline_comment|/* Push start scope on scope stack and make it current  */
id|status
op_assign
id|acpi_ds_scope_stack_push
(paren
id|node
comma
id|node-&gt;type
comma
id|walk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
)brace
id|status
op_assign
id|AE_OK
suffix:semicolon
multiline_comment|/*&n;&t; * Execute the walk loop as long as there is a valid Walk State.  This&n;&t; * handles nested control method invocations without recursion.&n;&t; */
r_while
c_loop
(paren
id|walk_state
)paren
(brace
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
id|status
op_assign
id|acpi_ps_parse_loop
(paren
id|walk_state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_TRANSFER
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * A method call was detected.&n;&t;&t;&t; * Transfer control to the called control method&n;&t;&t;&t; */
id|status
op_assign
id|acpi_ds_call_control_method
(paren
op_amp
id|walk_list
comma
id|walk_state
comma
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the transfer to the new method method call worked, a new walk&n;&t;&t;&t; * state was created -- get it&n;&t;&t;&t; */
id|walk_state
op_assign
id|acpi_ds_get_current_walk_state
(paren
op_amp
id|walk_list
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_TERMINATE
)paren
(brace
id|status
op_assign
id|AE_OK
suffix:semicolon
)brace
multiline_comment|/* We are done with this walk, move on to the parent if any */
id|walk_state
op_assign
id|acpi_ds_pop_walk_state
(paren
op_amp
id|walk_list
)paren
suffix:semicolon
multiline_comment|/* Extract return value before we delete Walk_state */
id|return_desc
op_assign
id|walk_state-&gt;return_desc
suffix:semicolon
multiline_comment|/* Reset the current scope to the beginning of scope stack */
id|acpi_ds_scope_stack_clear
(paren
id|walk_state
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we just returned from the execution of a control method,&n;&t;&t; * there&squot;s lots of cleanup to do&n;&t;&t; */
r_if
c_cond
(paren
(paren
id|walk_state-&gt;parse_flags
op_amp
id|ACPI_PARSE_MODE_MASK
)paren
op_eq
id|ACPI_PARSE_EXECUTE
)paren
(brace
id|acpi_ds_terminate_control_method
(paren
id|walk_state
)paren
suffix:semicolon
)brace
multiline_comment|/* Delete this walk state and all linked control states */
id|acpi_ps_cleanup_scope
(paren
id|walk_state-&gt;parser_state
)paren
suffix:semicolon
id|acpi_cm_free
(paren
id|walk_state-&gt;parser_state
)paren
suffix:semicolon
id|acpi_ds_delete_walk_state
(paren
id|walk_state
)paren
suffix:semicolon
multiline_comment|/* Check if we have restarted a preempted walk */
id|walk_state
op_assign
id|acpi_ds_get_current_walk_state
(paren
op_amp
id|walk_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|walk_state
op_logical_and
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
multiline_comment|/* There is another walk state, restart it */
multiline_comment|/*&n;&t;&t;&t; * If the method returned value is not used by the parent,&n;&t;&t;&t; * The object is deleted&n;&t;&t;&t; */
id|acpi_ds_restart_control_method
(paren
id|walk_state
comma
id|return_desc
)paren
suffix:semicolon
id|walk_state-&gt;walk_type
op_or_assign
id|WALK_METHOD_RESTART
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Just completed a 1st-level method, save the final internal return&n;&t;&t; * value (if any)&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|caller_return_desc
)paren
(brace
op_star
id|caller_return_desc
op_assign
id|return_desc
suffix:semicolon
multiline_comment|/* NULL if no return value */
)brace
r_else
r_if
c_cond
(paren
id|return_desc
)paren
(brace
multiline_comment|/* Caller doesn&squot;t want it, must delete it */
id|acpi_cm_remove_reference
(paren
id|return_desc
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Normal exit */
id|acpi_gbl_current_walk_list
op_assign
id|prev_walk_list
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
id|cleanup
suffix:colon
multiline_comment|/* Cleanup */
id|acpi_ds_delete_walk_state
(paren
id|walk_state
)paren
suffix:semicolon
id|acpi_ps_cleanup_scope
(paren
id|parser_state
)paren
suffix:semicolon
id|acpi_cm_free
(paren
id|parser_state
)paren
suffix:semicolon
id|acpi_gbl_current_walk_list
op_assign
id|prev_walk_list
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
eof
