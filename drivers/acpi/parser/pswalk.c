multiline_comment|/******************************************************************************&n; *&n; * Module Name: pswalk - Parser routines to walk parsed op tree(s)&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;amlcode.h&quot;
macro_line|#include &quot;parser.h&quot;
macro_line|#include &quot;dispatch.h&quot;
macro_line|#include &quot;namesp.h&quot;
macro_line|#include &quot;interp.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          PARSER
id|MODULE_NAME
(paren
l_string|&quot;pswalk&quot;
)paren
suffix:semicolon
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_get_next_walk_op&n; *&n; * PARAMETERS:  Walk_state          - Current state of the walk&n; *              Op                  - Current Op to be walked&n; *              Ascending_callback  - Procedure called when Op is complete&n; *              Prev_op             - Where the previous Op is stored&n; *              Next_op             - Where the next Op in the walk is stored&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Get the next Op in a walk of the parse tree.&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ps_get_next_walk_op
id|acpi_ps_get_next_walk_op
(paren
id|ACPI_WALK_STATE
op_star
id|walk_state
comma
id|ACPI_GENERIC_OP
op_star
id|op
comma
id|INTERPRETER_CALLBACK
id|ascending_callback
)paren
(brace
id|ACPI_GENERIC_OP
op_star
id|next
suffix:semicolon
id|ACPI_GENERIC_OP
op_star
id|parent
suffix:semicolon
id|ACPI_GENERIC_OP
op_star
id|grand_parent
suffix:semicolon
id|ACPI_STATUS
id|status
suffix:semicolon
multiline_comment|/* Check for a argument only if we are descending in the tree */
r_if
c_cond
(paren
id|walk_state-&gt;next_op_info
op_ne
id|NEXT_OP_UPWARD
)paren
(brace
multiline_comment|/* Look for an argument or child of the current op */
id|next
op_assign
id|acpi_ps_get_arg
(paren
id|op
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|next
)paren
(brace
multiline_comment|/* Still going downward in tree (Op is not completed yet) */
id|walk_state-&gt;prev_op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;next_op
op_assign
id|next
suffix:semicolon
id|walk_state-&gt;next_op_info
op_assign
id|NEXT_OP_DOWNWARD
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * No more children, this Op is complete.  Save Next and Parent&n;&t;&t; * in case the Op object gets deleted by the callback routine&n;&t;&t; */
id|next
op_assign
id|op-&gt;next
suffix:semicolon
id|parent
op_assign
id|op-&gt;parent
suffix:semicolon
id|status
op_assign
id|ascending_callback
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|AE_CTRL_TERMINATE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * A control method was terminated via a RETURN statement.&n;&t;&t;&t; * The walk of this method is complete.&n;&t;&t;&t; */
id|walk_state-&gt;prev_op
op_assign
id|walk_state-&gt;origin
suffix:semicolon
id|walk_state-&gt;next_op
op_assign
l_int|NULL
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_FALSE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Either an IF/WHILE Predicate was false or we encountered a BREAK&n;&t;&t;&t; * opcode.  In both cases, we do not execute the rest of the&n;&t;&t;&t; * package;  We simply close out the parent (finishing the walk of&n;&t;&t;&t; * this branch of the tree) and continue execution at the parent&n;&t;&t;&t; * level.&n;&t;&t;&t; */
id|next
op_assign
id|parent-&gt;next
suffix:semicolon
id|status
op_assign
id|AE_OK
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If there is a sibling to the parent, we must close out the&n;&t;&t;&t; * parent now, because we are going to continue to go downward (to&n;&t;&t;&t; * the sibling) in the parse tree.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|next
)paren
(brace
id|status
op_assign
id|ascending_callback
(paren
id|walk_state
comma
id|parent
)paren
suffix:semicolon
multiline_comment|/* The parent sibling will be next */
id|walk_state-&gt;prev_op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;next_op
op_assign
id|next
suffix:semicolon
id|walk_state-&gt;next_op_info
op_assign
id|NEXT_OP_DOWNWARD
suffix:semicolon
multiline_comment|/* Continue downward */
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Drop into the loop below because we are moving upwards in&n;&t;&t;&t; * the tree&n;&t;&t;&t; */
r_break
suffix:semicolon
r_default
suffix:colon
(brace
)brace
multiline_comment|/*&n;&t;&t;&t; * Check for a sibling to the current op.  A sibling means&n;&t;&t;&t; * we are still going &quot;downward&quot; in the tree.&n;&t;&t;&t; */
r_if
c_cond
(paren
id|next
)paren
(brace
multiline_comment|/* There is a sibling, it will be next */
id|walk_state-&gt;prev_op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;next_op
op_assign
id|next
suffix:semicolon
id|walk_state-&gt;next_op_info
op_assign
id|NEXT_OP_DOWNWARD
suffix:semicolon
multiline_comment|/* Continue downward */
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * No sibling, but check status.&n;&t;&t;&t; * Abort on error from callback routine&n;&t;&t;&t; */
r_if
c_cond
(paren
id|status
op_ne
id|AE_OK
)paren
(brace
multiline_comment|/* Next op will be the parent */
id|walk_state-&gt;prev_op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;next_op
op_assign
id|parent
suffix:semicolon
id|walk_state-&gt;next_op_info
op_assign
id|NEXT_OP_UPWARD
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Drop into the loop below because we are moving upwards in&n;&t;&t;&t; * the tree&n;&t;&t;&t; */
r_break
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t; * We are resuming a walk, and we were (are) going upward in the tree.&n;&t;&t; * So, we want to drop into the parent loop below.&n;&t;&t; */
id|parent
op_assign
id|op
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Look for a sibling of the current Op&squot;s parent&n;&t; * Continue moving up the tree until we find a node that has not been&n;&t; * visited, or we get back to where we started.&n;&t; */
r_while
c_loop
(paren
id|parent
)paren
(brace
multiline_comment|/* We are moving up the tree, therefore this parent Op is complete */
id|grand_parent
op_assign
id|parent-&gt;parent
suffix:semicolon
id|next
op_assign
id|parent-&gt;next
suffix:semicolon
id|status
op_assign
id|ascending_callback
(paren
id|walk_state
comma
id|parent
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|AE_CTRL_FALSE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Either an IF/WHILE Predicate was false or we encountered a&n;&t;&t;&t; * BREAK opcode.  In both cases, we do not execute the rest of the&n;&t;&t;&t; * package;  We simply close out the parent (finishing the walk of&n;&t;&t;&t; * this branch of the tree) and continue execution at the parent&n;&t;&t;&t; * level.&n;&t;&t;&t; */
id|parent
op_assign
id|grand_parent
suffix:semicolon
id|next
op_assign
id|grand_parent-&gt;next
suffix:semicolon
id|grand_parent
op_assign
id|grand_parent-&gt;parent
suffix:semicolon
id|status
op_assign
id|ascending_callback
(paren
id|walk_state
comma
id|parent
)paren
suffix:semicolon
multiline_comment|/* Now continue to the next node in the tree */
r_break
suffix:semicolon
r_case
id|AE_CTRL_TRUE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Predicate of a WHILE was true and the loop just completed an&n;&t;&t;&t; * execution.  Go back to the start of the loop and reevaluate the&n;&t;&t;&t; * predicate.&n;&t;&t;&t; */
id|op
op_assign
id|walk_state-&gt;control_state-&gt;control.predicate_op
suffix:semicolon
id|walk_state-&gt;control_state-&gt;common.state
op_assign
id|CONTROL_PREDICATE_EXECUTING
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * Acpi_evaluate the predicate again (next)&n;&t;&t;&t; * Because we will traverse WHILE tree again&n;&t;&t;&t; */
id|walk_state-&gt;prev_op
op_assign
id|op-&gt;parent
suffix:semicolon
id|walk_state-&gt;next_op
op_assign
id|op
suffix:semicolon
id|walk_state-&gt;next_op_info
op_assign
id|NEXT_OP_DOWNWARD
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|AE_CTRL_TERMINATE
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * A control method was terminated via a RETURN statement.&n;&t;&t;&t; * The walk of this method is complete.&n;&t;&t;&t; */
id|walk_state-&gt;prev_op
op_assign
id|walk_state-&gt;origin
suffix:semicolon
id|walk_state-&gt;next_op
op_assign
l_int|NULL
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If we are back to the starting point, the walk is complete.&n;&t;&t; */
r_if
c_cond
(paren
id|parent
op_eq
id|walk_state-&gt;origin
)paren
(brace
multiline_comment|/* Reached the point of origin, the walk is complete */
id|walk_state-&gt;prev_op
op_assign
id|parent
suffix:semicolon
id|walk_state-&gt;next_op
op_assign
l_int|NULL
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If there is a sibling to this parent (it is not the starting point&n;&t;&t; * Op), then we will visit it.&n;&t;&t; */
r_if
c_cond
(paren
id|next
)paren
(brace
multiline_comment|/* found sibling of parent */
id|walk_state-&gt;prev_op
op_assign
id|parent
suffix:semicolon
id|walk_state-&gt;next_op
op_assign
id|next
suffix:semicolon
id|walk_state-&gt;next_op_info
op_assign
id|NEXT_OP_DOWNWARD
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * No sibling, check for an error from closing the parent&n;&t;&t; * (Also, AE_PENDING if a method call was encountered)&n;&t;&t; */
r_if
c_cond
(paren
id|status
op_ne
id|AE_OK
)paren
(brace
id|walk_state-&gt;prev_op
op_assign
id|parent
suffix:semicolon
id|walk_state-&gt;next_op
op_assign
id|grand_parent
suffix:semicolon
id|walk_state-&gt;next_op_info
op_assign
id|NEXT_OP_UPWARD
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* No siblings, no errors, just move up one more level in the tree */
id|op
op_assign
id|parent
suffix:semicolon
id|parent
op_assign
id|grand_parent
suffix:semicolon
id|walk_state-&gt;prev_op
op_assign
id|op
suffix:semicolon
)brace
multiline_comment|/* Got all the way to the top of the tree, we must be done! */
multiline_comment|/* However, the code should have terminated in the loop above */
id|walk_state-&gt;next_op
op_assign
l_int|NULL
suffix:semicolon
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_walk_loop&n; *&n; * PARAMETERS:  Walk_list           - State of the walk&n; *              Start_op            - Starting Op of the subtree to be walked&n; *              Descending_callback - Procedure called when a new Op is&n; *                                    encountered&n; *              Ascending_callback  - Procedure called when Op is complete&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Perform a walk of the parsed AML tree.  Begins and terminates at&n; *              the Start_op.&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ps_walk_loop
id|acpi_ps_walk_loop
(paren
id|ACPI_WALK_LIST
op_star
id|walk_list
comma
id|ACPI_GENERIC_OP
op_star
id|start_op
comma
id|INTERPRETER_CALLBACK
id|descending_callback
comma
id|INTERPRETER_CALLBACK
id|ascending_callback
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|ACPI_WALK_STATE
op_star
id|walk_state
suffix:semicolon
id|ACPI_GENERIC_OP
op_star
id|op
op_assign
id|start_op
suffix:semicolon
id|walk_state
op_assign
id|acpi_ds_get_current_walk_state
(paren
id|walk_list
)paren
suffix:semicolon
multiline_comment|/* Walk entire subtree, visiting all nodes depth-first */
r_while
c_loop
(paren
id|op
)paren
(brace
r_if
c_cond
(paren
id|walk_state-&gt;next_op_info
op_ne
id|NEXT_OP_UPWARD
)paren
(brace
id|status
op_assign
id|descending_callback
(paren
id|walk_state
comma
id|op
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * A TRUE exception means that an ELSE was detected, but the IF&n;&t;&t; * predicate evaluated TRUE.&n;&t;&t; */
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_TRUE
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Ignore the entire ELSE block by moving on to the the next opcode.&n;&t;&t;&t; * And we do that by simply going up in the tree (either to the next&n;&t;&t;&t; * sibling or to the parent) from here.&n;&t;&t;&t; */
id|walk_state-&gt;next_op_info
op_assign
id|NEXT_OP_UPWARD
suffix:semicolon
)brace
multiline_comment|/* Get the next node (op) in the depth-first walk */
id|status
op_assign
id|acpi_ps_get_next_walk_op
(paren
id|walk_state
comma
id|op
comma
id|ascending_callback
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * A PENDING exception means that a control method invocation has been&n;&t;&t; * detected&n;&t;&t; */
r_if
c_cond
(paren
id|status
op_eq
id|AE_CTRL_PENDING
)paren
(brace
multiline_comment|/* Transfer control to the called control method */
id|status
op_assign
id|acpi_ds_call_control_method
(paren
id|walk_list
comma
id|walk_state
comma
id|op
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t;&t; * If the transfer to the new method method call worked, a new walk&n;&t;&t;&t; * state was created -- get it&n;&t;&t;&t; */
id|walk_state
op_assign
id|acpi_ds_get_current_walk_state
(paren
id|walk_list
)paren
suffix:semicolon
)brace
multiline_comment|/* Abort the walk on any exception */
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
id|op
op_assign
id|walk_state-&gt;next_op
suffix:semicolon
)brace
r_return
(paren
id|AE_OK
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_ps_walk_parsed_aml&n; *&n; * PARAMETERS:  Start_op            - Starting Op of the subtree to be walked&n; *              End_op              - Where to terminate the walk&n; *              Descending_callback - Procedure called when a new Op is&n; *                                    encountered&n; *              Ascending_callback  - Procedure called when Op is complete&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Top level interface to walk the parsed AML tree.  Handles&n; *              preemption of executing control methods.&n; *&n; *              NOTE: The End_op is usually only different from the Start_op if&n; *              we don&squot;t want to visit the Start_op during the tree descent.&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_ps_walk_parsed_aml
id|acpi_ps_walk_parsed_aml
(paren
id|ACPI_GENERIC_OP
op_star
id|start_op
comma
id|ACPI_GENERIC_OP
op_star
id|end_op
comma
id|ACPI_OBJECT_INTERNAL
op_star
id|mth_desc
comma
id|ACPI_NAME_TABLE
op_star
id|start_scope
comma
id|ACPI_OBJECT_INTERNAL
op_star
op_star
id|params
comma
id|ACPI_OBJECT_INTERNAL
op_star
op_star
id|caller_return_desc
comma
id|ACPI_OWNER_ID
id|owner_id
comma
id|INTERPRETER_CALLBACK
id|descending_callback
comma
id|INTERPRETER_CALLBACK
id|ascending_callback
)paren
(brace
id|ACPI_GENERIC_OP
op_star
id|op
suffix:semicolon
id|ACPI_WALK_STATE
op_star
id|walk_state
suffix:semicolon
id|ACPI_OBJECT_INTERNAL
op_star
id|return_desc
suffix:semicolon
id|ACPI_STATUS
id|status
suffix:semicolon
id|ACPI_WALK_LIST
id|walk_list
suffix:semicolon
id|ACPI_WALK_LIST
op_star
id|prev_walk_list
suffix:semicolon
multiline_comment|/* Parameter Validation */
r_if
c_cond
(paren
op_logical_neg
id|start_op
op_logical_or
op_logical_neg
id|end_op
)paren
(brace
r_return
id|AE_BAD_PARAMETER
suffix:semicolon
)brace
multiline_comment|/* Initialize a new walk list */
id|walk_list.walk_state
op_assign
l_int|NULL
suffix:semicolon
id|walk_state
op_assign
id|acpi_ds_create_walk_state
(paren
id|owner_id
comma
id|end_op
comma
id|mth_desc
comma
op_amp
id|walk_list
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|walk_state
)paren
(brace
r_return
(paren
id|AE_NO_MEMORY
)paren
suffix:semicolon
)brace
multiline_comment|/* TBD: [Restructure] TEMP until we pass Walk_state to the interpreter&n;&t; */
id|prev_walk_list
op_assign
id|acpi_gbl_current_walk_list
suffix:semicolon
id|acpi_gbl_current_walk_list
op_assign
op_amp
id|walk_list
suffix:semicolon
r_if
c_cond
(paren
id|start_scope
)paren
(brace
multiline_comment|/* Push start scope on scope stack and make it current  */
id|status
op_assign
id|acpi_ds_scope_stack_push
(paren
id|start_scope
comma
id|ACPI_TYPE_METHOD
comma
id|walk_state
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mth_desc
)paren
(brace
multiline_comment|/* Init arguments if this is a control method */
multiline_comment|/* TBD: [Restructure] add walkstate as a param */
id|acpi_ds_method_data_init_args
(paren
id|params
comma
id|MTH_NUM_ARGS
)paren
suffix:semicolon
)brace
id|op
op_assign
id|start_op
suffix:semicolon
id|status
op_assign
id|AE_OK
suffix:semicolon
multiline_comment|/*&n;&t; * Execute the walk loop as long as there is a valid Walk State.  This&n;&t; * handles nested control method invocations without recursion.&n;&t; */
r_while
c_loop
(paren
id|walk_state
)paren
(brace
r_if
c_cond
(paren
id|status
op_eq
id|AE_OK
)paren
(brace
id|status
op_assign
id|acpi_ps_walk_loop
(paren
op_amp
id|walk_list
comma
id|op
comma
id|descending_callback
comma
id|ascending_callback
)paren
suffix:semicolon
)brace
multiline_comment|/* We are done with this walk, move on to the parent if any */
id|BREAKPOINT3
suffix:semicolon
id|walk_state
op_assign
id|acpi_ds_pop_walk_state
(paren
op_amp
id|walk_list
)paren
suffix:semicolon
multiline_comment|/* Extract return value before we delete Walk_state */
id|return_desc
op_assign
id|walk_state-&gt;return_desc
suffix:semicolon
multiline_comment|/* Reset the current scope to the beginning of scope stack */
id|acpi_ds_scope_stack_clear
(paren
id|walk_state
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If we just returned from the execution of a control method,&n;&t;&t; * there&squot;s lots of cleanup to do&n;&t;&t; */
r_if
c_cond
(paren
id|walk_state-&gt;method_desc
op_logical_and
id|walk_state-&gt;method_desc-&gt;method.parser_op
)paren
(brace
id|acpi_ds_terminate_control_method
(paren
id|walk_state
)paren
suffix:semicolon
)brace
multiline_comment|/* Delete this walk state and all linked control states */
id|acpi_ds_delete_walk_state
(paren
id|walk_state
)paren
suffix:semicolon
multiline_comment|/* Check if we have restarted a preempted walk */
id|walk_state
op_assign
id|acpi_ds_get_current_walk_state
(paren
op_amp
id|walk_list
)paren
suffix:semicolon
r_if
c_cond
(paren
id|walk_state
op_logical_and
id|status
op_eq
id|AE_OK
)paren
(brace
multiline_comment|/* There is another walk state, restart it */
multiline_comment|/*&n;&t;&t;&t; * If the method returned value is not used by the parent,&n;&t;&t;&t; * The object is deleted&n;&t;&t;&t; */
id|acpi_ds_restart_control_method
(paren
id|walk_state
comma
id|return_desc
)paren
suffix:semicolon
multiline_comment|/* Get the next Op to process */
id|op
op_assign
id|walk_state-&gt;next_op
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Just completed a 1st-level method, save the final internal return&n;&t;&t; * value (if any)&n;&t;&t; */
r_else
r_if
c_cond
(paren
id|caller_return_desc
)paren
(brace
op_star
id|caller_return_desc
op_assign
id|return_desc
suffix:semicolon
multiline_comment|/* NULL if no return value */
)brace
r_else
r_if
c_cond
(paren
id|return_desc
)paren
(brace
multiline_comment|/* Caller doesn&squot;t want it, must delete it */
id|acpi_cm_remove_reference
(paren
id|return_desc
)paren
suffix:semicolon
)brace
)brace
id|acpi_gbl_current_walk_list
op_assign
id|prev_walk_list
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
eof
