multiline_comment|/******************************************************************************&n; *&n; * Module Name: amfldio - Aml Field I/O&n; *              $Revision: 32 $&n; *&n; *****************************************************************************/
multiline_comment|/*&n; *  Copyright (C) 2000 R. Byron Moore&n; *&n; *  This program is free software; you can redistribute it and/or modify&n; *  it under the terms of the GNU General Public License as published by&n; *  the Free Software Foundation; either version 2 of the License, or&n; *  (at your option) any later version.&n; *&n; *  This program is distributed in the hope that it will be useful,&n; *  but WITHOUT ANY WARRANTY; without even the implied warranty of&n; *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; *  GNU General Public License for more details.&n; *&n; *  You should have received a copy of the GNU General Public License&n; *  along with this program; if not, write to the Free Software&n; *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &quot;acpi.h&quot;
macro_line|#include &quot;acinterp.h&quot;
macro_line|#include &quot;amlcode.h&quot;
macro_line|#include &quot;acnamesp.h&quot;
macro_line|#include &quot;achware.h&quot;
macro_line|#include &quot;acevents.h&quot;
DECL|macro|_COMPONENT
mdefine_line|#define _COMPONENT          INTERPRETER
id|MODULE_NAME
(paren
l_string|&quot;amfldio&quot;
)paren
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_aml_read_field_data&n; *&n; * PARAMETERS:  *Obj_desc           - Field to be read&n; *              *Value              - Where to store value&n; *              Field_bit_width     - Field Width in bits (8, 16, or 32)&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Retrieve the value of the given field&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_aml_read_field_data
id|acpi_aml_read_field_data
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
comma
id|u32
id|field_byte_offset
comma
id|u32
id|field_bit_width
comma
id|u32
op_star
id|value
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|rgn_desc
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_PHYSICAL_ADDRESS
id|address
suffix:semicolon
id|u32
id|local_value
op_assign
l_int|0
suffix:semicolon
id|u32
id|field_byte_width
suffix:semicolon
multiline_comment|/* Obj_desc is validated by callers */
r_if
c_cond
(paren
id|obj_desc
)paren
(brace
id|rgn_desc
op_assign
id|obj_desc-&gt;field.container
suffix:semicolon
)brace
id|field_byte_width
op_assign
id|DIV_8
(paren
id|field_bit_width
)paren
suffix:semicolon
id|status
op_assign
id|acpi_aml_setup_field
(paren
id|obj_desc
comma
id|rgn_desc
comma
id|field_bit_width
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/* Setup_field validated Rgn_desc and Field_bit_width */
r_if
c_cond
(paren
op_logical_neg
id|value
)paren
(brace
id|value
op_assign
op_amp
id|local_value
suffix:semicolon
multiline_comment|/*  support reads without saving value  */
)brace
multiline_comment|/*&n;&t; * Set offset to next multiple of field width,&n;&t; *  add region base address and offset within the field&n;&t; */
id|address
op_assign
id|rgn_desc-&gt;region.address
op_plus
(paren
id|obj_desc-&gt;field.offset
op_star
id|field_byte_width
)paren
op_plus
id|field_byte_offset
suffix:semicolon
multiline_comment|/* Invoke the appropriate Address_space/Op_region handler */
id|status
op_assign
id|acpi_ev_address_space_dispatch
(paren
id|rgn_desc
comma
id|ADDRESS_SPACE_READ
comma
id|address
comma
id|field_bit_width
comma
id|value
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_aml_read_field&n; *&n; * PARAMETERS:  *Obj_desc           - Field to be read&n; *              *Value              - Where to store value&n; *              Field_bit_width     - Field Width in bits (8, 16, or 32)&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Retrieve the value of the given field&n; *&n; ******************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_aml_read_field
id|acpi_aml_read_field
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
comma
r_void
op_star
id|buffer
comma
id|u32
id|buffer_length
comma
id|u32
id|byte_length
comma
id|u32
id|datum_length
comma
id|u32
id|bit_granularity
comma
id|u32
id|byte_granularity
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|u32
id|this_field_byte_offset
suffix:semicolon
id|u32
id|this_field_datum_offset
suffix:semicolon
id|u32
id|previous_raw_datum
suffix:semicolon
id|u32
id|this_raw_datum
suffix:semicolon
id|u32
id|valid_field_bits
suffix:semicolon
id|u32
id|mask
suffix:semicolon
id|u32
id|merged_datum
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Clear the caller&squot;s buffer (the whole buffer length as given)&n;&t; * This is very important, especially in the cases where a byte is read,&n;&t; * but the buffer is really a u32 (4 bytes).&n;&t; */
id|MEMSET
(paren
id|buffer
comma
l_int|0
comma
id|buffer_length
)paren
suffix:semicolon
multiline_comment|/* Read the first raw datum to prime the loop */
id|this_field_byte_offset
op_assign
l_int|0
suffix:semicolon
id|this_field_datum_offset
op_assign
l_int|0
suffix:semicolon
id|status
op_assign
id|acpi_aml_read_field_data
(paren
id|obj_desc
comma
id|this_field_byte_offset
comma
id|bit_granularity
comma
op_amp
id|previous_raw_datum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* We might actually be done if the request fits in one datum */
r_if
c_cond
(paren
(paren
id|datum_length
op_eq
l_int|1
)paren
op_logical_and
(paren
(paren
id|obj_desc-&gt;field.bit_offset
op_plus
id|obj_desc-&gt;field_unit.length
)paren
op_le
(paren
id|u16
)paren
id|bit_granularity
)paren
)paren
(brace
id|merged_datum
op_assign
id|previous_raw_datum
suffix:semicolon
id|merged_datum
op_assign
(paren
id|merged_datum
op_rshift
id|obj_desc-&gt;field.bit_offset
)paren
suffix:semicolon
id|valid_field_bits
op_assign
id|obj_desc-&gt;field_unit.length
op_mod
id|bit_granularity
suffix:semicolon
r_if
c_cond
(paren
id|valid_field_bits
)paren
(brace
id|mask
op_assign
(paren
(paren
(paren
id|u32
)paren
l_int|1
op_lshift
id|valid_field_bits
)paren
op_minus
(paren
id|u32
)paren
l_int|1
)paren
suffix:semicolon
id|merged_datum
op_and_assign
id|mask
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Place the Merged_datum into the proper format and return buffer&n;&t;&t; * field&n;&t;&t; */
r_switch
c_cond
(paren
id|byte_granularity
)paren
(brace
r_case
l_int|1
suffix:colon
(paren
(paren
id|u8
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
op_assign
(paren
id|u8
)paren
id|merged_datum
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|MOVE_UNALIGNED16_TO_16
(paren
op_amp
(paren
(paren
(paren
id|u16
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
)paren
comma
op_amp
id|merged_datum
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|MOVE_UNALIGNED32_TO_32
(paren
op_amp
(paren
(paren
(paren
id|u32
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
)paren
comma
op_amp
id|merged_datum
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|this_field_byte_offset
op_assign
l_int|1
suffix:semicolon
id|this_field_datum_offset
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We need to get more raw data to complete one or more field data */
r_while
c_loop
(paren
id|this_field_datum_offset
OL
id|datum_length
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * Get the next raw datum, it contains bits of the current&n;&t;&t;&t; * field datum&n;&t;&t;&t; */
id|status
op_assign
id|acpi_aml_read_field_data
(paren
id|obj_desc
comma
id|this_field_byte_offset
op_plus
id|byte_granularity
comma
id|bit_granularity
comma
op_amp
id|this_raw_datum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* Before merging the data, make sure the unused bits are clear */
r_switch
c_cond
(paren
id|byte_granularity
)paren
(brace
r_case
l_int|1
suffix:colon
id|this_raw_datum
op_and_assign
l_int|0x000000FF
suffix:semicolon
id|previous_raw_datum
op_and_assign
l_int|0x000000FF
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|this_raw_datum
op_and_assign
l_int|0x0000FFFF
suffix:semicolon
id|previous_raw_datum
op_and_assign
l_int|0x0000FFFF
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Put together bits of the two raw data to make a complete&n;&t;&t;&t; * field datum&n;&t;&t;&t; */
r_if
c_cond
(paren
id|obj_desc-&gt;field.bit_offset
op_ne
l_int|0
)paren
(brace
id|merged_datum
op_assign
(paren
id|previous_raw_datum
op_rshift
id|obj_desc-&gt;field.bit_offset
)paren
op_or
(paren
id|this_raw_datum
op_lshift
(paren
id|bit_granularity
op_minus
id|obj_desc-&gt;field.bit_offset
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|merged_datum
op_assign
id|previous_raw_datum
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Prepare the merged datum for storing into the caller&squot;s&n;&t;&t;&t; *  buffer.  It is possible to have a 32-bit buffer&n;&t;&t;&t; *  (Byte_granularity == 4), but a Obj_desc-&gt;Field.Length&n;&t;&t;&t; *  of 8 or 16, meaning that the upper bytes of merged data&n;&t;&t;&t; *  are undesired.  This section fixes that.&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|obj_desc-&gt;field.length
)paren
(brace
r_case
l_int|8
suffix:colon
id|merged_datum
op_and_assign
l_int|0x000000FF
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|16
suffix:colon
id|merged_datum
op_and_assign
l_int|0x0000FFFF
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Now store the datum in the caller&squot;s buffer, according to&n;&t;&t;&t; * the data type&n;&t;&t;&t; */
r_switch
c_cond
(paren
id|byte_granularity
)paren
(brace
r_case
l_int|1
suffix:colon
(paren
(paren
id|u8
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
op_assign
(paren
id|u8
)paren
id|merged_datum
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|MOVE_UNALIGNED16_TO_16
(paren
op_amp
(paren
(paren
(paren
id|u16
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
)paren
comma
op_amp
id|merged_datum
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|MOVE_UNALIGNED32_TO_32
(paren
op_amp
(paren
(paren
(paren
id|u32
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
)paren
comma
op_amp
id|merged_datum
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * Save the most recent datum since it contains bits of&n;&t;&t;&t; * the *next* field datum&n;&t;&t;&t; */
id|previous_raw_datum
op_assign
id|this_raw_datum
suffix:semicolon
id|this_field_byte_offset
op_add_assign
id|byte_granularity
suffix:semicolon
id|this_field_datum_offset
op_increment
suffix:semicolon
)brace
multiline_comment|/* while */
)brace
id|cleanup
suffix:colon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*******************************************************************************&n; *&n; * FUNCTION:    Acpi_aml_write_field_data&n; *&n; * PARAMETERS:  *Obj_desc           - Field to be set&n; *              Value               - Value to store&n; *              Field_bit_width     - Field Width in bits (8, 16, or 32)&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Store the value into the given field&n; *&n; ******************************************************************************/
r_static
id|ACPI_STATUS
DECL|function|acpi_aml_write_field_data
id|acpi_aml_write_field_data
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
comma
id|u32
id|field_byte_offset
comma
id|u32
id|field_bit_width
comma
id|u32
id|value
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|ACPI_OPERAND_OBJECT
op_star
id|rgn_desc
op_assign
l_int|NULL
suffix:semicolon
id|ACPI_PHYSICAL_ADDRESS
id|address
suffix:semicolon
id|u32
id|field_byte_width
suffix:semicolon
multiline_comment|/* Obj_desc is validated by callers */
r_if
c_cond
(paren
id|obj_desc
)paren
(brace
id|rgn_desc
op_assign
id|obj_desc-&gt;field.container
suffix:semicolon
)brace
id|field_byte_width
op_assign
id|DIV_8
(paren
id|field_bit_width
)paren
suffix:semicolon
id|status
op_assign
id|acpi_aml_setup_field
(paren
id|obj_desc
comma
id|rgn_desc
comma
id|field_bit_width
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Set offset to next multiple of field width,&n;&t; *  add region base address and offset within the field&n;&t; */
id|address
op_assign
id|rgn_desc-&gt;region.address
op_plus
(paren
id|obj_desc-&gt;field.offset
op_star
id|field_byte_width
)paren
op_plus
id|field_byte_offset
suffix:semicolon
multiline_comment|/* Invoke the appropriate Address_space/Op_region handler */
id|status
op_assign
id|acpi_ev_address_space_dispatch
(paren
id|rgn_desc
comma
id|ADDRESS_SPACE_WRITE
comma
id|address
comma
id|field_bit_width
comma
op_amp
id|value
)paren
suffix:semicolon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    Acpi_aml_write_field_data_with_update_rule&n; *&n; * PARAMETERS:  *Obj_desc           - Field to be set&n; *              Value               - Value to store&n; *              Field_bit_width     - Field Width in bits (8, 16, or 32)&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Apply the field update rule to a field write&n; *&n; ****************************************************************************/
r_static
id|ACPI_STATUS
DECL|function|acpi_aml_write_field_data_with_update_rule
id|acpi_aml_write_field_data_with_update_rule
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
comma
id|u32
id|mask
comma
id|u32
id|field_value
comma
id|u32
id|this_field_byte_offset
comma
id|u32
id|bit_granularity
)paren
(brace
id|ACPI_STATUS
id|status
op_assign
id|AE_OK
suffix:semicolon
id|u32
id|merged_value
suffix:semicolon
id|u32
id|current_value
suffix:semicolon
multiline_comment|/* Start with the new bits  */
id|merged_value
op_assign
id|field_value
suffix:semicolon
multiline_comment|/* Check if update rule needs to be applied (not if mask is all ones) */
multiline_comment|/* Decode the update rule */
r_switch
c_cond
(paren
id|obj_desc-&gt;field.update_rule
)paren
(brace
r_case
id|UPDATE_PRESERVE
suffix:colon
multiline_comment|/*&n;&t;&t; * Read the current contents of the byte/word/dword containing&n;&t;&t; * the field, and merge with the new field value.&n;&t;&t; */
id|status
op_assign
id|acpi_aml_read_field_data
(paren
id|obj_desc
comma
id|this_field_byte_offset
comma
id|bit_granularity
comma
op_amp
id|current_value
)paren
suffix:semicolon
id|merged_value
op_or_assign
(paren
id|current_value
op_amp
op_complement
id|mask
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UPDATE_WRITE_AS_ONES
suffix:colon
multiline_comment|/* Set positions outside the field to all ones */
id|merged_value
op_or_assign
op_complement
id|mask
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UPDATE_WRITE_AS_ZEROS
suffix:colon
multiline_comment|/* Set positions outside the field to all zeros */
id|merged_value
op_and_assign
id|mask
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
id|AE_AML_OPERAND_VALUE
suffix:semicolon
)brace
multiline_comment|/* Write the merged value */
r_if
c_cond
(paren
id|ACPI_SUCCESS
(paren
id|status
)paren
)paren
(brace
id|status
op_assign
id|acpi_aml_write_field_data
(paren
id|obj_desc
comma
id|this_field_byte_offset
comma
id|bit_granularity
comma
id|merged_value
)paren
suffix:semicolon
)brace
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
multiline_comment|/*****************************************************************************&n; *&n; * FUNCTION:    Acpi_aml_write_field&n; *&n; * PARAMETERS:  *Obj_desc           - Field to be set&n; *              Value               - Value to store&n; *              Field_bit_width     - Field Width in bits (8, 16, or 32)&n; *&n; * RETURN:      Status&n; *&n; * DESCRIPTION: Store the value into the given field&n; *&n; ****************************************************************************/
id|ACPI_STATUS
DECL|function|acpi_aml_write_field
id|acpi_aml_write_field
(paren
id|ACPI_OPERAND_OBJECT
op_star
id|obj_desc
comma
r_void
op_star
id|buffer
comma
id|u32
id|buffer_length
comma
id|u32
id|byte_length
comma
id|u32
id|datum_length
comma
id|u32
id|bit_granularity
comma
id|u32
id|byte_granularity
)paren
(brace
id|ACPI_STATUS
id|status
suffix:semicolon
id|u32
id|this_field_byte_offset
suffix:semicolon
id|u32
id|this_field_datum_offset
suffix:semicolon
id|u32
id|mask
suffix:semicolon
id|u32
id|merged_datum
suffix:semicolon
id|u32
id|previous_raw_datum
suffix:semicolon
id|u32
id|this_raw_datum
suffix:semicolon
id|u32
id|field_value
suffix:semicolon
id|u32
id|valid_field_bits
suffix:semicolon
multiline_comment|/*&n;&t; * Break the request into up to three parts:&n;&t; * non-aligned part at start, aligned part in middle, non-aligned part&n;&t; * at end --- Just like an I/O request ---&n;&t; */
id|this_field_byte_offset
op_assign
l_int|0
suffix:semicolon
id|this_field_datum_offset
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Get a datum */
r_switch
c_cond
(paren
id|byte_granularity
)paren
(brace
r_case
l_int|1
suffix:colon
id|previous_raw_datum
op_assign
(paren
(paren
id|u8
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|MOVE_UNALIGNED16_TO_32
(paren
op_amp
id|previous_raw_datum
comma
op_amp
(paren
(paren
(paren
id|u16
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|MOVE_UNALIGNED32_TO_32
(paren
op_amp
id|previous_raw_datum
comma
op_amp
(paren
(paren
(paren
id|u32
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
id|AE_AML_OPERAND_VALUE
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Write a partial field datum if field does not begin on a datum boundary&n;&t; *&n;&t; * Construct Mask with 1 bits where the field is, 0 bits elsewhere&n;&t; *&n;&t; * 1) Bits above the field&n;&t; */
id|mask
op_assign
(paren
(paren
(paren
id|u32
)paren
(paren
op_minus
l_int|1
)paren
)paren
op_lshift
(paren
id|u32
)paren
id|obj_desc-&gt;field.bit_offset
)paren
suffix:semicolon
multiline_comment|/* 2) Only the bottom 5 bits are valid for a shift operation. */
r_if
c_cond
(paren
(paren
id|obj_desc-&gt;field.bit_offset
op_plus
id|obj_desc-&gt;field_unit.length
)paren
OL
l_int|32
)paren
(brace
multiline_comment|/* Bits above the field */
id|mask
op_and_assign
(paren
op_complement
(paren
(paren
(paren
id|u32
)paren
(paren
op_minus
l_int|1
)paren
)paren
op_lshift
(paren
(paren
id|u32
)paren
id|obj_desc-&gt;field.bit_offset
op_plus
(paren
id|u32
)paren
id|obj_desc-&gt;field_unit.length
)paren
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* 3) Shift and mask the value into the field position */
id|field_value
op_assign
(paren
id|previous_raw_datum
op_lshift
id|obj_desc-&gt;field.bit_offset
)paren
op_amp
id|mask
suffix:semicolon
id|status
op_assign
id|acpi_aml_write_field_data_with_update_rule
(paren
id|obj_desc
comma
id|mask
comma
id|field_value
comma
id|this_field_byte_offset
comma
id|bit_granularity
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/* If the field fits within one datum, we are done. */
r_if
c_cond
(paren
(paren
id|datum_length
op_eq
l_int|1
)paren
op_logical_and
(paren
(paren
id|obj_desc-&gt;field.bit_offset
op_plus
id|obj_desc-&gt;field_unit.length
)paren
op_le
(paren
id|u16
)paren
id|bit_granularity
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * We don&squot;t need to worry about the update rule for these data, because&n;&t; * all of the bits are part of the field.&n;&t; *&n;&t; * Can&squot;t write the last datum, however, because it might contain bits that&n;&t; * are not part of the field -- the update rule must be applied.&n;&t; */
r_while
c_loop
(paren
id|this_field_datum_offset
OL
(paren
id|datum_length
op_minus
l_int|1
)paren
)paren
(brace
id|this_field_datum_offset
op_increment
suffix:semicolon
multiline_comment|/* Get the next raw datum, it contains bits of the current field datum... */
r_switch
c_cond
(paren
id|byte_granularity
)paren
(brace
r_case
l_int|1
suffix:colon
id|this_raw_datum
op_assign
(paren
(paren
id|u8
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|MOVE_UNALIGNED16_TO_32
(paren
op_amp
id|this_raw_datum
comma
op_amp
(paren
(paren
(paren
id|u16
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|MOVE_UNALIGNED32_TO_32
(paren
op_amp
id|this_raw_datum
comma
op_amp
(paren
(paren
(paren
id|u32
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|status
op_assign
id|AE_AML_OPERAND_VALUE
suffix:semicolon
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Put together bits of the two raw data to make a complete field&n;&t;&t; * datum&n;&t;&t; */
r_if
c_cond
(paren
id|obj_desc-&gt;field.bit_offset
op_ne
l_int|0
)paren
(brace
id|merged_datum
op_assign
(paren
id|previous_raw_datum
op_rshift
(paren
id|bit_granularity
op_minus
id|obj_desc-&gt;field.bit_offset
)paren
)paren
op_or
(paren
id|this_raw_datum
op_lshift
id|obj_desc-&gt;field.bit_offset
)paren
suffix:semicolon
)brace
r_else
(brace
id|merged_datum
op_assign
id|this_raw_datum
suffix:semicolon
)brace
multiline_comment|/* Now write the completed datum  */
id|status
op_assign
id|acpi_aml_write_field_data
(paren
id|obj_desc
comma
id|this_field_byte_offset
op_plus
id|byte_granularity
comma
id|bit_granularity
comma
id|merged_datum
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Save the most recent datum since it contains bits of&n;&t;&t; * the *next* field datum&n;&t;&t; */
id|previous_raw_datum
op_assign
id|this_raw_datum
suffix:semicolon
id|this_field_byte_offset
op_add_assign
id|byte_granularity
suffix:semicolon
)brace
multiline_comment|/* while */
multiline_comment|/* Write a partial field datum if field does not end on a datum boundary */
r_if
c_cond
(paren
(paren
id|obj_desc-&gt;field_unit.length
op_plus
id|obj_desc-&gt;field_unit.bit_offset
)paren
op_mod
id|bit_granularity
)paren
(brace
r_switch
c_cond
(paren
id|byte_granularity
)paren
(brace
r_case
l_int|1
suffix:colon
id|this_raw_datum
op_assign
(paren
(paren
id|u8
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|MOVE_UNALIGNED16_TO_32
(paren
op_amp
id|this_raw_datum
comma
op_amp
(paren
(paren
(paren
id|u16
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|4
suffix:colon
id|MOVE_UNALIGNED32_TO_32
(paren
op_amp
id|this_raw_datum
comma
op_amp
(paren
(paren
(paren
id|u32
op_star
)paren
id|buffer
)paren
(braket
id|this_field_datum_offset
)braket
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
multiline_comment|/* Construct Mask with 1 bits where the field is, 0 bits elsewhere */
id|valid_field_bits
op_assign
(paren
(paren
id|obj_desc-&gt;field_unit.length
op_mod
id|bit_granularity
)paren
op_plus
id|obj_desc-&gt;field.bit_offset
)paren
suffix:semicolon
id|mask
op_assign
(paren
(paren
(paren
id|u32
)paren
l_int|1
op_lshift
id|valid_field_bits
)paren
op_minus
(paren
id|u32
)paren
l_int|1
)paren
suffix:semicolon
multiline_comment|/* Shift and mask the value into the field position */
id|field_value
op_assign
(paren
id|previous_raw_datum
op_rshift
(paren
id|bit_granularity
op_minus
id|obj_desc-&gt;field.bit_offset
)paren
)paren
op_amp
id|mask
suffix:semicolon
id|status
op_assign
id|acpi_aml_write_field_data_with_update_rule
(paren
id|obj_desc
comma
id|mask
comma
id|field_value
comma
id|this_field_byte_offset
op_plus
id|byte_granularity
comma
id|bit_granularity
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ACPI_FAILURE
(paren
id|status
)paren
)paren
(brace
r_goto
id|cleanup
suffix:semicolon
)brace
)brace
id|cleanup
suffix:colon
r_return
(paren
id|status
)paren
suffix:semicolon
)brace
eof
