multiline_comment|/* Linux driver for Disk-On-Chip 2000       */
multiline_comment|/* (c) 1999 Machine Vision Holdings, Inc.   */
multiline_comment|/* Author: David Woodhouse &lt;dwmw2@mvhi.com&gt; */
multiline_comment|/* $Id: doc2000.c,v 1.24 2000/07/13 10:03:31 dwmw2 Exp $ */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nand.h&gt;
macro_line|#include &lt;linux/mtd/doc2000.h&gt;
singleline_comment|//#define PRERELEASE
r_static
r_int
id|doc_read
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|doc_write
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|doc_read_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eecbuf
)paren
suffix:semicolon
r_static
r_int
id|doc_write_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
)paren
suffix:semicolon
r_static
r_int
id|doc_read_oob
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|doc_write_oob
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|doc_erase
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
suffix:semicolon
DECL|variable|doc2klist
r_static
r_struct
id|mtd_info
op_star
id|doc2klist
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* DOC_WaitReady: Wait for RDY line to be asserted by the flash chip */
DECL|function|_DoC_WaitReady
r_static
r_int
id|_DoC_WaitReady
(paren
r_int
r_int
id|docptr
)paren
(brace
singleline_comment|//long c=-1;
r_int
id|c
op_assign
op_minus
l_int|1
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;_DoC_WaitReady called for out-of-line wait&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Out-of-line routine to wait for chip response */
r_while
c_loop
(paren
op_logical_neg
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
op_amp
id|CDSN_CTRL_FR_B
)paren
op_logical_and
op_decrement
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|0
)paren
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;_DoC_WaitReady timed out.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|c
op_eq
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|DoC_WaitReady
r_static
r_inline
r_int
id|DoC_WaitReady
c_func
(paren
r_int
r_int
id|docptr
)paren
(brace
multiline_comment|/* This is inline, to optimise the common case, where it&squot;s ready instantly */
r_volatile
r_char
id|dummy
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Out-of-line routine to wait for chip response */
multiline_comment|/* TPW: Add 4 reads - see Software Requirement 2.3.2 */
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
op_amp
id|CDSN_CTRL_FR_B
)paren
)paren
id|ret
op_assign
id|_DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
multiline_comment|/* Call the out-of-line routine to wait */
multiline_comment|/* TPW: Add 2 reads - see Software Requirement 2.3.2 */
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* DoC_Command: Send a flash command to the flash chip */
DECL|function|DoC_Command
r_static
r_inline
r_int
id|DoC_Command
c_func
(paren
r_int
r_int
id|docptr
comma
r_int
r_char
id|command
comma
r_int
r_char
id|xtraflags
)paren
(brace
multiline_comment|/* Assert the CLE (Command Latch Enable) line to the flash chip */
id|WriteDOC
c_func
(paren
id|CDSN_CTRL_FLASH_IO
op_or
id|xtraflags
op_or
id|CDSN_CTRL_CLE
op_or
id|CDSN_CTRL_CE
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
multiline_comment|/* Send the command */
id|WriteDOC
c_func
(paren
id|command
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
multiline_comment|/* Lower the CLE line */
id|WriteDOC
c_func
(paren
id|CDSN_CTRL_FLASH_IO
op_or
id|xtraflags
op_or
id|CDSN_CTRL_CE
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
multiline_comment|/* Wait for the chip to respond */
r_return
id|DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
)brace
multiline_comment|/* DoC_Address: Set the current address for the flash chip */
DECL|function|DoC_Address
r_static
r_inline
r_int
id|DoC_Address
(paren
r_int
r_int
id|docptr
comma
r_int
id|numbytes
comma
r_int
r_int
id|ofs
comma
r_int
r_char
id|xtraflags1
comma
r_int
r_char
id|xtraflags2
)paren
(brace
multiline_comment|/* Assert the ALE (Address Latch Enable line to the flash chip */
id|WriteDOC
c_func
(paren
id|CDSN_CTRL_FLASH_IO
op_or
id|xtraflags1
op_or
id|CDSN_CTRL_ALE
op_or
id|CDSN_CTRL_CE
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
multiline_comment|/* Send the address */
multiline_comment|/* Three cases:&n;&t;   numbytes == 1: Send single byte, bits 0-7.&n;&t;   numbytes == 2: Send bits 9-16 followed by 17-23&n;&t;   numbytes == 3: Send 0-7, 9-16, then 17-23 &n;&t;*/
r_if
c_cond
(paren
id|numbytes
op_ne
l_int|2
)paren
id|WriteDOC
c_func
(paren
id|ofs
op_amp
l_int|0xff
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|numbytes
op_ne
l_int|1
)paren
(brace
id|WriteDOC
c_func
(paren
(paren
id|ofs
op_rshift
l_int|9
)paren
op_amp
l_int|0xff
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
(paren
id|ofs
op_rshift
l_int|17
)paren
op_amp
l_int|0xff
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
)brace
multiline_comment|/* Lower the ALE line */
id|WriteDOC
c_func
(paren
id|CDSN_CTRL_FLASH_IO
op_or
id|xtraflags1
op_or
id|xtraflags2
op_or
id|CDSN_CTRL_CE
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
multiline_comment|/* Wait for the chip to respond */
r_return
id|DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
)brace
multiline_comment|/* DoC_SelectChip: Select a given flash chip within the current floor */
DECL|function|DoC_SelectChip
r_static
r_inline
r_int
id|DoC_SelectChip
c_func
(paren
r_int
r_int
id|docptr
comma
r_int
id|chip
)paren
(brace
multiline_comment|/* Select the individual flash chip requested */
id|WriteDOC
c_func
(paren
id|chip
comma
id|docptr
comma
id|CDSNDeviceSelect
)paren
suffix:semicolon
multiline_comment|/* Wait for it to be ready */
r_return
id|DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
)brace
multiline_comment|/* DoC_SelectFloor: Select a given floor (bank of flash chips) */
DECL|function|DoC_SelectFloor
r_static
r_inline
r_int
id|DoC_SelectFloor
c_func
(paren
r_int
r_int
id|docptr
comma
r_int
id|floor
)paren
(brace
multiline_comment|/* Select the floor (bank) of chips required */
id|WriteDOC
c_func
(paren
id|floor
comma
id|docptr
comma
id|FloorSelect
)paren
suffix:semicolon
multiline_comment|/* Wait for the chip to be ready */
r_return
id|DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
)brace
multiline_comment|/* DoC_IdentChip: Identify a given NAND chip given {floor,chip} */
DECL|function|DoC_IdentChip
r_static
r_int
id|DoC_IdentChip
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc
comma
r_int
id|floor
comma
r_int
id|chip
)paren
(brace
r_int
id|mfr
comma
id|id
comma
id|chipshift
op_assign
l_int|0
suffix:semicolon
r_char
op_star
id|mfrname
op_assign
l_int|NULL
comma
op_star
id|idname
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Page in the required floor/chip */
id|DoC_SelectFloor
c_func
(paren
id|doc-&gt;virtadr
comma
id|floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|doc-&gt;virtadr
comma
id|chip
)paren
suffix:semicolon
multiline_comment|/* Reset the chip */
r_if
c_cond
(paren
id|DoC_Command
c_func
(paren
id|doc-&gt;virtadr
comma
id|NAND_CMD_RESET
comma
id|CDSN_CTRL_WP
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;DoC_Command (reset) for %d,%d returned true&bslash;n&quot;
comma
id|floor
comma
id|chip
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read the NAND chip ID: 1. Send ReadID command */
r_if
c_cond
(paren
id|DoC_Command
c_func
(paren
id|doc-&gt;virtadr
comma
id|NAND_CMD_READID
comma
id|CDSN_CTRL_WP
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;DoC_Command (ReadID) for %d,%d returned true&bslash;n&quot;
comma
id|floor
comma
id|chip
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read the NAND chip ID: 2. Send address byte zero &n;&t; */
id|DoC_Address
c_func
(paren
id|doc-&gt;virtadr
comma
l_int|1
comma
l_int|0
comma
id|CDSN_CTRL_WP
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Read the manufacturer and device id codes from the device */
id|mfr
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
id|id
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
multiline_comment|/* No response - return failure */
r_if
c_cond
(paren
id|mfr
op_eq
l_int|0xff
op_logical_or
id|mfr
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Check it&squot;s the same as the first chip we identified. &n;&t; * M-Systems say that any given DiskOnChip device should only&n;&t; * contain _one_ type of flash part, although that&squot;s not a &n;&t; * hardware restriction. */
r_if
c_cond
(paren
id|doc-&gt;mfr
)paren
(brace
r_if
c_cond
(paren
id|doc-&gt;mfr
op_eq
id|mfr
op_logical_and
id|doc-&gt;id
op_eq
id|id
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* This is another the same the first */
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Flash chip at floor %d, chip %d is different:&bslash;n&quot;
comma
id|floor
comma
id|chip
)paren
suffix:semicolon
)brace
multiline_comment|/* Print (and store if first time) the manufacturer and ID codes. */
r_switch
c_cond
(paren
id|mfr
)paren
(brace
r_case
id|NAND_MFR_TOSHIBA
suffix:colon
multiline_comment|/* Toshiba */
id|mfrname
op_assign
l_string|&quot;Toshiba&quot;
suffix:semicolon
r_switch
c_cond
(paren
id|id
)paren
(brace
r_case
l_int|0x64
suffix:colon
id|idname
op_assign
l_string|&quot;TC5816BDC&quot;
suffix:semicolon
id|chipshift
op_assign
l_int|21
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x6b
suffix:colon
id|idname
op_assign
l_string|&quot;TC5832DC&quot;
suffix:semicolon
id|chipshift
op_assign
l_int|22
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x73
suffix:colon
id|idname
op_assign
l_string|&quot;TH58V128DC&quot;
suffix:semicolon
id|chipshift
op_assign
l_int|24
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x75
suffix:colon
id|idname
op_assign
l_string|&quot;TC58256FT/DC&quot;
suffix:semicolon
id|chipshift
op_assign
l_int|25
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xe5
suffix:colon
id|idname
op_assign
l_string|&quot;TC58V32DC&quot;
suffix:semicolon
id|chipshift
op_assign
l_int|22
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xe6
suffix:colon
id|idname
op_assign
l_string|&quot;TC58V64DC&quot;
suffix:semicolon
id|chipshift
op_assign
l_int|23
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xea
suffix:colon
id|idname
op_assign
l_string|&quot;TC58V16BDC&quot;
suffix:semicolon
id|chipshift
op_assign
l_int|21
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* End of Toshiba parts */
r_case
id|NAND_MFR_SAMSUNG
suffix:colon
multiline_comment|/* Samsung */
id|mfrname
op_assign
l_string|&quot;Samsung&quot;
suffix:semicolon
r_switch
c_cond
(paren
id|id
)paren
(brace
r_case
l_int|0x64
suffix:colon
id|idname
op_assign
l_string|&quot;KM29N16000&quot;
suffix:semicolon
id|chipshift
op_assign
l_int|21
suffix:semicolon
r_case
l_int|0x73
suffix:colon
id|idname
op_assign
l_string|&quot;KM29U128T&quot;
suffix:semicolon
id|chipshift
op_assign
l_int|24
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x75
suffix:colon
id|idname
op_assign
l_string|&quot;KM29U256T&quot;
suffix:semicolon
id|chipshift
op_assign
l_int|25
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xe3
suffix:colon
id|idname
op_assign
l_string|&quot;KM29W32000&quot;
suffix:semicolon
id|chipshift
op_assign
l_int|22
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xe6
suffix:colon
id|idname
op_assign
l_string|&quot;KM29U64000&quot;
suffix:semicolon
id|chipshift
op_assign
l_int|23
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0xea
suffix:colon
id|idname
op_assign
l_string|&quot;KM29W16000&quot;
suffix:semicolon
id|chipshift
op_assign
l_int|21
suffix:semicolon
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
multiline_comment|/* End of Samsung parts */
)brace
multiline_comment|/* If we&squot;ve identified it fully, print the full names */
r_if
c_cond
(paren
id|idname
)paren
(brace
macro_line|#ifdef PRERELEASE
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Flash chip found: %2.2X %2.2X (%s %s)&bslash;n&quot;
comma
id|mfr
comma
id|id
comma
id|mfrname
comma
id|idname
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* If this is the first chip, store the id codes */
r_if
c_cond
(paren
op_logical_neg
id|doc-&gt;mfr
)paren
(brace
id|doc-&gt;mfr
op_assign
id|mfr
suffix:semicolon
id|doc-&gt;id
op_assign
id|id
suffix:semicolon
id|doc-&gt;chipshift
op_assign
id|chipshift
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* We haven&squot;t fully identified the chip. Print as much as we know. */
r_if
c_cond
(paren
id|mfrname
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Unknown %s flash chip found: %2.2X %2.2X&bslash;n&quot;
comma
id|mfrname
comma
id|id
comma
id|mfr
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Unknown flash chip found: %2.2X %2.2X&bslash;n&quot;
comma
id|id
comma
id|mfr
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Please report to David.Woodhouse@mvhi.com&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* DoC_ScanChips: Find all NAND chips present in a DiskOnChip, and identify them */
DECL|function|DoC_ScanChips
r_static
r_void
id|DoC_ScanChips
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|this
)paren
(brace
r_int
id|floor
comma
id|chip
suffix:semicolon
r_int
id|numchips
(braket
id|MAX_FLOORS
)braket
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
id|this-&gt;numchips
op_assign
l_int|0
suffix:semicolon
id|this-&gt;mfr
op_assign
l_int|0
suffix:semicolon
id|this-&gt;id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* For each floor, find the number of valid chips it contains */
r_for
c_loop
(paren
id|floor
op_assign
l_int|0
suffix:semicolon
id|floor
OL
id|MAX_FLOORS
suffix:semicolon
id|floor
op_increment
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
id|numchips
(braket
id|floor
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|chip
op_assign
l_int|0
suffix:semicolon
id|chip
OL
id|MAX_CHIPS
op_logical_and
id|ret
op_ne
l_int|0
suffix:semicolon
id|chip
op_increment
)paren
(brace
id|ret
op_assign
id|DoC_IdentChip
c_func
(paren
id|this
comma
id|floor
comma
id|chip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|numchips
(braket
id|floor
)braket
op_increment
suffix:semicolon
id|this-&gt;numchips
op_increment
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* If there are none at all that we recognise, bail */
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;numchips
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No flash chips recognised.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Allocate an array to hold the information for each chip */
id|this-&gt;chips
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|Nand
)paren
op_star
id|this-&gt;numchips
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;chips
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No memory for allocating chip info structures&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill out the chip array with {floor, chipno} for each &n;&t; * detected chip in the device. */
r_for
c_loop
(paren
id|floor
op_assign
l_int|0
suffix:semicolon
id|floor
OL
id|MAX_FLOORS
suffix:semicolon
id|floor
op_increment
)paren
(brace
r_for
c_loop
(paren
id|chip
op_assign
l_int|0
suffix:semicolon
id|chip
OL
id|numchips
(braket
id|floor
)braket
suffix:semicolon
id|chip
op_increment
)paren
(brace
id|this-&gt;chips
(braket
id|ret
)braket
dot
id|floor
op_assign
id|floor
suffix:semicolon
id|this-&gt;chips
(braket
id|ret
)braket
dot
id|chip
op_assign
id|chip
suffix:semicolon
id|this-&gt;chips
(braket
id|ret
)braket
dot
id|curadr
op_assign
l_int|0
suffix:semicolon
id|this-&gt;chips
(braket
id|ret
)braket
dot
id|curmode
op_assign
l_int|0x50
suffix:semicolon
id|ret
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Calculate and print the total size of the device */
id|this-&gt;totlen
op_assign
id|this-&gt;numchips
op_star
(paren
l_int|1
op_lshift
id|this-&gt;chipshift
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d flash chips found. Total DiskOnChip size: %ld Mb&bslash;n&quot;
comma
id|this-&gt;numchips
comma
id|this-&gt;totlen
op_rshift
l_int|20
)paren
suffix:semicolon
)brace
DECL|function|DoC2k_is_alias
r_static
r_int
id|DoC2k_is_alias
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc1
comma
r_struct
id|DiskOnChip
op_star
id|doc2
)paren
(brace
r_int
id|tmp1
comma
id|tmp2
comma
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|doc1-&gt;physadr
op_eq
id|doc2-&gt;physadr
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Use the alias resolution register which was set aside for this&n;&t; * purpose. If it&squot;s value is the same on both chips, they might&n;&t; * be the same chip, and we write to one and check for a change in&n;&t; * the other. It&squot;s unclear if this register is usuable in the&n;&t; * DoC 2000 (it&squot;s in the Millenium docs), but it seems to work. */
id|tmp1
op_assign
id|ReadDOC
c_func
(paren
id|doc1-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
id|tmp2
op_assign
id|ReadDOC
c_func
(paren
id|doc2-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp1
op_ne
id|tmp2
)paren
r_return
l_int|0
suffix:semicolon
id|WriteDOC
c_func
(paren
(paren
id|tmp1
op_plus
l_int|1
)paren
op_mod
l_int|0xff
comma
id|doc1-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
id|tmp2
op_assign
id|ReadDOC
c_func
(paren
id|doc2-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp2
op_eq
(paren
id|tmp1
op_plus
l_int|1
)paren
op_mod
l_int|0xff
)paren
id|retval
op_assign
l_int|1
suffix:semicolon
r_else
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Restore register contents.  May not be necessary, but do it just to&n;&t; * be safe. */
id|WriteDOC
c_func
(paren
id|tmp1
comma
id|doc1-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|function|DoC2k_init
r_void
id|DoC2k_init
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|DiskOnChip
op_star
id|old
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* We must avoid being called twice for the same device. */
r_if
c_cond
(paren
id|doc2klist
)paren
id|old
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|doc2klist-&gt;priv
suffix:semicolon
r_while
c_loop
(paren
id|old
)paren
(brace
r_if
c_cond
(paren
id|DoC2k_is_alias
c_func
(paren
id|old
comma
id|this
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Ignoring DiskOnChip 2000 at 0x%lX - already configured&bslash;n&quot;
comma
id|this-&gt;physadr
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|this-&gt;virtadr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old-&gt;nextdoc
)paren
id|old
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|old-&gt;nextdoc-&gt;priv
suffix:semicolon
r_else
id|old
op_assign
l_int|NULL
suffix:semicolon
)brace
id|mtd-&gt;name
op_assign
l_string|&quot;DiskOnChip 2000&quot;
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;DiskOnChip 2000 found at address 0x%lX&bslash;n&quot;
comma
id|this-&gt;physadr
)paren
suffix:semicolon
id|mtd-&gt;type
op_assign
id|MTD_NANDFLASH
suffix:semicolon
id|mtd-&gt;flags
op_assign
id|MTD_CAP_NANDFLASH
suffix:semicolon
id|mtd-&gt;size
op_assign
l_int|0
suffix:semicolon
id|mtd-&gt;erasesize
op_assign
l_int|0x2000
suffix:semicolon
id|mtd-&gt;oobblock
op_assign
l_int|512
suffix:semicolon
id|mtd-&gt;oobsize
op_assign
l_int|16
suffix:semicolon
id|mtd-&gt;module
op_assign
id|THIS_MODULE
suffix:semicolon
id|mtd-&gt;erase
op_assign
id|doc_erase
suffix:semicolon
id|mtd-&gt;point
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;unpoint
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;read
op_assign
id|doc_read
suffix:semicolon
id|mtd-&gt;write
op_assign
id|doc_write
suffix:semicolon
id|mtd-&gt;read_ecc
op_assign
id|doc_read_ecc
suffix:semicolon
id|mtd-&gt;write_ecc
op_assign
id|doc_write_ecc
suffix:semicolon
id|mtd-&gt;read_oob
op_assign
id|doc_read_oob
suffix:semicolon
id|mtd-&gt;write_oob
op_assign
id|doc_write_oob
suffix:semicolon
id|mtd-&gt;sync
op_assign
l_int|NULL
suffix:semicolon
id|this-&gt;totlen
op_assign
l_int|0
suffix:semicolon
id|this-&gt;numchips
op_assign
l_int|0
suffix:semicolon
id|this-&gt;curfloor
op_assign
op_minus
l_int|1
suffix:semicolon
id|this-&gt;curchip
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Ident all the chips present. */
id|DoC_ScanChips
c_func
(paren
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;totlen
)paren
(brace
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|this-&gt;virtadr
)paren
suffix:semicolon
)brace
r_else
(brace
id|this-&gt;nextdoc
op_assign
id|doc2klist
suffix:semicolon
id|doc2klist
op_assign
id|mtd
suffix:semicolon
id|mtd-&gt;size
op_assign
id|this-&gt;totlen
suffix:semicolon
id|add_mtd_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|variable|DoC2k_init
id|EXPORT_SYMBOL
c_func
(paren
id|DoC2k_init
)paren
suffix:semicolon
DECL|function|doc_read
r_static
r_int
id|doc_read
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
multiline_comment|/* Just a special case of doc_read_ecc */
r_return
id|doc_read_ecc
c_func
(paren
id|mtd
comma
id|from
comma
id|len
comma
id|retlen
comma
id|buf
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|doc_read_ecc
r_static
r_int
id|doc_read_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
)paren
(brace
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
id|di
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Yes, DI is a hangover from when I was disassembling the binary driver */
r_int
r_int
id|docptr
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
suffix:semicolon
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
multiline_comment|/* Don&squot;t allow read past end of device */
r_if
c_cond
(paren
id|from
op_ge
id|this-&gt;totlen
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Don&squot;t allow a single read to cross a 512-byte block boundary */
r_if
c_cond
(paren
id|from
op_plus
id|len
OG
(paren
(paren
id|from
op_or
l_int|0x1ff
)paren
op_plus
l_int|1
)paren
)paren
id|len
op_assign
(paren
(paren
id|from
op_or
l_int|0x1ff
)paren
op_plus
l_int|1
)paren
op_minus
id|from
suffix:semicolon
multiline_comment|/* Find the chip which is to be used and select it */
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|from
op_rshift
(paren
id|this-&gt;chipshift
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|docptr
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
r_if
c_cond
(paren
id|eccbuf
)paren
(brace
multiline_comment|/* Prime the ECC engine */
id|WriteDOC
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
(paren
id|DOC_ECC_EN
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
id|DoC_Command
c_func
(paren
id|docptr
comma
(paren
id|from
op_rshift
l_int|8
)paren
op_amp
l_int|1
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|docptr
comma
l_int|3
comma
id|from
comma
id|CDSN_CTRL_WP
comma
id|CDSN_CTRL_ECC_IO
)paren
suffix:semicolon
r_for
c_loop
(paren
id|di
op_assign
l_int|0
suffix:semicolon
id|di
OL
id|len
suffix:semicolon
id|di
op_increment
)paren
(brace
id|buf
(braket
id|di
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
)brace
multiline_comment|/* Let the caller know we completed it */
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|eccbuf
)paren
(brace
multiline_comment|/* Read the ECC data through the DiskOnChip ECC logic */
r_for
c_loop
(paren
id|di
op_assign
l_int|0
suffix:semicolon
id|di
OL
l_int|6
suffix:semicolon
id|di
op_increment
)paren
(brace
id|eccbuf
(braket
id|di
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
)brace
multiline_comment|/* Flush the pipeline */
(paren
r_void
)paren
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_ECCStatus
)paren
suffix:semicolon
(paren
r_void
)paren
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_ECCStatus
)paren
suffix:semicolon
multiline_comment|/* Check the ECC Status */
r_if
c_cond
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_ECCStatus
)paren
op_amp
l_int|0x80
)paren
(brace
multiline_comment|/* There was an ECC error */
id|printk
c_func
(paren
l_string|&quot;DiskOnChip ECC Error: Read at %lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|from
)paren
suffix:semicolon
multiline_comment|/* FIXME: Implement ECC error correction, don&squot;t just whinge */
multiline_comment|/* We return error, but have actually done the read. Not that&n;&t;&t;&t;   this can be told to user-space, via sys_read(), but at least&n;&t;&t;&t;   MTD-aware stuff can know about it by checking *retlen */
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#ifdef PSYCHO_DEBUG
r_else
id|printk
c_func
(paren
l_string|&quot;ECC OK at %lx: %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X&bslash;n&quot;
comma
(paren
r_int
)paren
id|from
comma
id|eccbuf
(braket
l_int|0
)braket
comma
id|eccbuf
(braket
l_int|1
)braket
comma
id|eccbuf
(braket
l_int|2
)braket
comma
id|eccbuf
(braket
l_int|3
)braket
comma
id|eccbuf
(braket
l_int|4
)braket
comma
id|eccbuf
(braket
l_int|5
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Reset the ECC engine */
id|WriteDOC
c_func
(paren
id|DOC_ECC_RESV
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc_write
r_static
r_int
id|doc_write
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_static
r_char
id|as
(braket
l_int|6
)braket
suffix:semicolon
r_return
id|doc_write_ecc
c_func
(paren
id|mtd
comma
id|to
comma
id|len
comma
id|retlen
comma
id|buf
comma
id|as
)paren
suffix:semicolon
)brace
DECL|function|doc_write_ecc
r_static
r_int
id|doc_write_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
)paren
(brace
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
id|di
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|docptr
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
suffix:semicolon
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
multiline_comment|/* Don&squot;t allow write past end of device */
r_if
c_cond
(paren
id|to
op_ge
id|this-&gt;totlen
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#if 0&t;
multiline_comment|/* Don&squot;t allow a single write to cross a 512-byte block boundary */
r_if
c_cond
(paren
id|to
op_plus
id|len
OG
(paren
(paren
id|to
op_or
l_int|0x1ff
)paren
op_plus
l_int|1
)paren
)paren
id|len
op_assign
(paren
(paren
id|to
op_or
l_int|0x1ff
)paren
op_plus
l_int|1
)paren
op_minus
id|to
suffix:semicolon
macro_line|#else
multiline_comment|/* Don&squot;t allow writes which aren&squot;t exactly one block */
r_if
c_cond
(paren
id|to
op_amp
l_int|0x1ff
op_logical_or
id|len
op_ne
l_int|0x200
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
multiline_comment|/* Find the chip which is to be used and select it */
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|to
op_rshift
(paren
id|this-&gt;chipshift
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|docptr
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
multiline_comment|/* Set device to main plane of flash */
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_RESET
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_READ0
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eccbuf
)paren
(brace
multiline_comment|/* Prime the ECC engine */
id|WriteDOC
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
(paren
id|DOC_ECC_EN
op_or
id|DOC_ECC_RW
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_SEQIN
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|docptr
comma
l_int|3
comma
id|to
comma
l_int|0
comma
id|CDSN_CTRL_ECC_IO
)paren
suffix:semicolon
r_for
c_loop
(paren
id|di
op_assign
l_int|0
suffix:semicolon
id|di
OL
id|len
suffix:semicolon
id|di
op_increment
)paren
(brace
id|WriteDOC
c_func
(paren
id|buf
(braket
id|di
)braket
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|eccbuf
)paren
(brace
id|WriteDOC
c_func
(paren
id|CDSN_CTRL_ECC_IO
op_or
id|CDSN_CTRL_CE
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
macro_line|#if 1
multiline_comment|/* eduardp@m-sys.com says this shouldn&squot;t be necessary,&n;&t;&t; * but it doesn&squot;t actually work without it, so I&squot;ve&n;&t;&t; * left it in for now. dwmw2.&n;&t;&t; */
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Read the ECC data through the DiskOnChip ECC logic */
r_for
c_loop
(paren
id|di
op_assign
l_int|0
suffix:semicolon
id|di
OL
l_int|6
suffix:semicolon
id|di
op_increment
)paren
(brace
id|eccbuf
(braket
id|di
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCSyndrome0
op_plus
id|di
)paren
suffix:semicolon
)brace
macro_line|#ifdef PSYCHO_DEBUG
id|printk
c_func
(paren
l_string|&quot;OOB data at %lx is %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X&bslash;n&quot;
comma
(paren
r_int
)paren
id|to
comma
id|eccbuf
(braket
l_int|0
)braket
comma
id|eccbuf
(braket
l_int|1
)braket
comma
id|eccbuf
(braket
l_int|2
)braket
comma
id|eccbuf
(braket
l_int|3
)braket
comma
id|eccbuf
(braket
l_int|4
)braket
comma
id|eccbuf
(braket
l_int|5
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Reset the ECC engine */
id|WriteDOC
c_func
(paren
id|DOC_ECC_RESV
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_PAGEPROG
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_STATUS
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
multiline_comment|/* There&squot;s an implicit DoC_WaitReady() in DoC_Command */
r_if
c_cond
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error programming flash&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Error in programming */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Let the caller know we completed it */
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc_read_oob
r_static
r_int
id|doc_read_oob
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|docptr
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
suffix:semicolon
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|ofs
op_rshift
id|this-&gt;chipshift
)braket
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|docptr
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_READOOB
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|docptr
comma
l_int|3
comma
id|ofs
comma
id|CDSN_CTRL_WP
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|buf
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc_write_oob
r_static
r_int
id|doc_write_oob
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
id|i
suffix:semicolon
r_int
r_int
id|docptr
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
suffix:semicolon
singleline_comment|//&t;printk(&quot;doc_write_oob(%lx, %d): %2.2X %2.2X %2.2X %2.2X ... %2.2X %2.2X .. %2.2X %2.2X&bslash;n&quot;,(long)ofs, len,
singleline_comment|//   buf[0], buf[1], buf[2], buf[3], buf[8], buf[9], buf[14],buf[15]);
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|ofs
op_rshift
id|this-&gt;chipshift
)braket
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|docptr
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_RESET
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_READOOB
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_SEQIN
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|docptr
comma
l_int|3
comma
id|ofs
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|WriteDOC
c_func
(paren
id|buf
(braket
id|i
)braket
comma
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_PAGEPROG
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_STATUS
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* DoC_WaitReady() is implicit in DoC_Command */
r_if
c_cond
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error programming oob data&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* There was an error */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc_erase
r_int
id|doc_erase
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
(brace
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
r_int
id|ofs
op_assign
id|instr-&gt;addr
suffix:semicolon
r_int
r_int
id|len
op_assign
id|instr-&gt;len
suffix:semicolon
r_int
r_int
id|docptr
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|mtd-&gt;erasesize
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Erase not right size (%lx != %lx)n&quot;
comma
id|len
comma
id|mtd-&gt;erasesize
)paren
suffix:semicolon
)brace
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|ofs
op_rshift
id|this-&gt;chipshift
)braket
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|docptr
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_PENDING
suffix:semicolon
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_ERASE1
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|docptr
comma
l_int|2
comma
id|ofs
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_ERASE2
comma
l_int|0
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASING
suffix:semicolon
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_STATUS
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_CDSN_IO
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error writing&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* There was an error */
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
)brace
r_else
id|instr-&gt;state
op_assign
id|MTD_ERASE_DONE
suffix:semicolon
r_if
c_cond
(paren
id|instr-&gt;callback
)paren
id|instr
op_member_access_from_pointer
id|callback
c_func
(paren
id|instr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * Module stuff&n; *&n; ****************************************************************************/
macro_line|#if LINUX_VERSION_CODE &lt; 0x20300
macro_line|#ifdef MODULE
DECL|macro|cleanup_doc2000
mdefine_line|#define cleanup_doc2000 cleanup_module
macro_line|#endif
DECL|macro|__exit
mdefine_line|#define __exit
macro_line|#endif
DECL|function|cleanup_doc2000
r_static
r_void
id|__exit
id|cleanup_doc2000
c_func
(paren
r_void
)paren
(brace
r_struct
id|mtd_info
op_star
id|mtd
suffix:semicolon
r_struct
id|DiskOnChip
op_star
id|this
suffix:semicolon
r_while
c_loop
(paren
(paren
id|mtd
op_assign
id|doc2klist
)paren
)paren
(brace
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
id|doc2klist
op_assign
id|this-&gt;nextdoc
suffix:semicolon
id|del_mtd_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|this-&gt;virtadr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|this-&gt;chips
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
)brace
)brace
macro_line|#if LINUX_VERSION_CODE &gt; 0x20300
DECL|variable|cleanup_doc2000
id|module_exit
c_func
(paren
id|cleanup_doc2000
)paren
suffix:semicolon
macro_line|#endif
eof
