multiline_comment|/*&n; * Linux driver for Disk-On-Chip 2000 and Millennium&n; * (c) 1999 Machine Vision Holdings, Inc.&n; * (c) 1999, 2000 David Woodhouse &lt;dwmw2@infradead.org&gt;&n; *&n; * $Id: doc2000.c,v 1.39 2000/12/01 17:34:29 dwmw2 Exp $&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nand.h&gt;
macro_line|#include &lt;linux/mtd/nand_ids.h&gt;
macro_line|#include &lt;linux/mtd/doc2000.h&gt;
DECL|macro|DOC_SUPPORT_2000
mdefine_line|#define DOC_SUPPORT_2000
DECL|macro|DOC_SUPPORT_MILLENNIUM
mdefine_line|#define DOC_SUPPORT_MILLENNIUM
macro_line|#ifdef DOC_SUPPORT_2000
DECL|macro|DoC_is_2000
mdefine_line|#define DoC_is_2000(doc) (doc-&gt;ChipID == DOC_ChipID_Doc2k)
macro_line|#else
DECL|macro|DoC_is_2000
mdefine_line|#define DoC_is_2000(doc) (0)
macro_line|#endif
macro_line|#ifdef DOC_SUPPORT_MILLENNIUM
DECL|macro|DoC_is_Millennium
mdefine_line|#define DoC_is_Millennium(doc) (doc-&gt;ChipID == DOC_ChipID_DocMil)
macro_line|#else
DECL|macro|DoC_is_Millennium
mdefine_line|#define DoC_is_Millennium(doc) (0)
macro_line|#endif
multiline_comment|/* #define ECC_DEBUG */
multiline_comment|/* I have no idea why some DoC chips can not use memcpy_from|to_io().&n; * This may be due to the different revisions of the ASIC controller built-in or&n; * simplily a QA/Bug issue. Who knows ?? If you have trouble, please uncomment&n; * this:&n; #undef USE_MEMCPY&n;*/
r_static
r_int
id|doc_read
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|doc_write
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|doc_read_ecc
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
)paren
suffix:semicolon
r_static
r_int
id|doc_write_ecc
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
)paren
suffix:semicolon
r_static
r_int
id|doc_read_oob
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|doc_write_oob
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|doc_erase
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
suffix:semicolon
DECL|variable|doc2klist
r_static
r_struct
id|mtd_info
op_star
id|doc2klist
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Perform the required delay cycles by reading from the appropriate register */
DECL|function|DoC_Delay
r_static
r_void
id|DoC_Delay
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc
comma
r_int
r_int
id|cycles
)paren
(brace
r_volatile
r_char
id|dummy
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cycles
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|DoC_is_Millennium
c_func
(paren
id|doc
)paren
)paren
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|NOP
)paren
suffix:semicolon
r_else
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|DOCStatus
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* DOC_WaitReady: Wait for RDY line to be asserted by the flash chip */
DECL|function|_DoC_WaitReady
r_static
r_int
id|_DoC_WaitReady
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc
)paren
(brace
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_int
r_int
id|c
op_assign
l_int|0xffff
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;_DoC_WaitReady called for out-of-line wait&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Out-of-line routine to wait for chip response */
r_while
c_loop
(paren
op_logical_neg
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
op_amp
id|CDSN_CTRL_FR_B
)paren
op_logical_and
op_decrement
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|0
)paren
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;_DoC_WaitReady timed out.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|c
op_eq
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|DoC_WaitReady
r_static
r_inline
r_int
id|DoC_WaitReady
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc
)paren
(brace
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
multiline_comment|/* This is inline, to optimise the common case, where it&squot;s ready instantly */
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 4 read form NOP register should be issued in prior to the read from CDSNControl&n;&t;   see Software Requirement 11.4 item 2. */
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
op_amp
id|CDSN_CTRL_FR_B
)paren
)paren
multiline_comment|/* Call the out-of-line routine to wait */
id|ret
op_assign
id|_DoC_WaitReady
c_func
(paren
id|doc
)paren
suffix:semicolon
multiline_comment|/* issue 2 read from NOP register after reading from CDSNControl register&n;&t;   see Software Requirement 11.4 item 2. */
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|2
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* DoC_Command: Send a flash command to the flash chip through the CDSN Slow IO register to&n;   bypass the internal pipeline. Each of 4 delay cycles (read from the NOP register) is&n;   required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */
DECL|function|DoC_Command
r_static
r_inline
r_int
id|DoC_Command
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc
comma
r_int
r_char
id|command
comma
r_int
r_char
id|xtraflags
)paren
(brace
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_if
c_cond
(paren
id|DoC_is_2000
c_func
(paren
id|doc
)paren
)paren
id|xtraflags
op_or_assign
id|CDSN_CTRL_FLASH_IO
suffix:semicolon
multiline_comment|/* Assert the CLE (Command Latch Enable) line to the flash chip */
id|WriteDOC
c_func
(paren
id|xtraflags
op_or
id|CDSN_CTRL_CLE
op_or
id|CDSN_CTRL_CE
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Software requirement 11.4.3 for Millennium */
r_if
c_cond
(paren
id|DoC_is_Millennium
c_func
(paren
id|doc
)paren
)paren
id|WriteDOC
c_func
(paren
id|command
comma
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
multiline_comment|/* Send the command */
id|WriteDOC_
c_func
(paren
id|command
comma
id|docptr
comma
id|doc-&gt;ioreg
)paren
suffix:semicolon
multiline_comment|/* Lower the CLE line */
id|WriteDOC
c_func
(paren
id|xtraflags
op_or
id|CDSN_CTRL_CE
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Software requirement 11.4.3 for Millennium */
multiline_comment|/* Wait for the chip to respond - Software requirement 11.4.1 (extended for any command) */
r_return
id|DoC_WaitReady
c_func
(paren
id|doc
)paren
suffix:semicolon
)brace
multiline_comment|/* DoC_Address: Set the current address for the flash chip through the CDSN Slow IO register to&n;   bypass the internal pipeline. Each of 4 delay cycles (read from the NOP register) is&n;   required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */
DECL|function|DoC_Address
r_static
r_int
id|DoC_Address
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc
comma
r_int
id|numbytes
comma
r_int
r_int
id|ofs
comma
r_int
r_char
id|xtraflags1
comma
r_int
r_char
id|xtraflags2
)paren
(brace
r_int
r_int
id|docptr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_if
c_cond
(paren
id|DoC_is_2000
c_func
(paren
id|doc
)paren
)paren
id|xtraflags1
op_or_assign
id|CDSN_CTRL_FLASH_IO
suffix:semicolon
multiline_comment|/* Assert the ALE (Address Latch Enable) line to the flash chip */
id|WriteDOC
c_func
(paren
id|xtraflags1
op_or
id|CDSN_CTRL_ALE
op_or
id|CDSN_CTRL_CE
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Software requirement 11.4.3 for Millennium */
multiline_comment|/* Send the address */
multiline_comment|/* Devices with 256-byte page are addressed as:&n;&t;   Column (bits 0-7), Page (bits 8-15, 16-23, 24-31)&n;&t;   * there is no device on the market with page256&n;&t;   and more than 24 bits.&n;&t;   Devices with 512-byte page are addressed as:&n;&t;   Column (bits 0-7), Page (bits 9-16, 17-24, 25-31)&n;&t;   * 25-31 is sent only if the chip support it.&n;&t;   * bit 8 changes the read command to be sent&n;&t;   (NAND_CMD_READ0 or NAND_CMD_READ1).&n;&t; */
r_if
c_cond
(paren
id|numbytes
op_eq
id|ADDR_COLUMN
op_logical_or
id|numbytes
op_eq
id|ADDR_COLUMN_PAGE
)paren
(brace
r_if
c_cond
(paren
id|DoC_is_Millennium
c_func
(paren
id|doc
)paren
)paren
id|WriteDOC
c_func
(paren
id|ofs
op_amp
l_int|0xff
comma
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|WriteDOC_
c_func
(paren
id|ofs
op_amp
l_int|0xff
comma
id|docptr
comma
id|doc-&gt;ioreg
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|doc-&gt;page256
)paren
(brace
id|ofs
op_assign
id|ofs
op_rshift
l_int|8
suffix:semicolon
)brace
r_else
(brace
id|ofs
op_assign
id|ofs
op_rshift
l_int|9
suffix:semicolon
)brace
r_if
c_cond
(paren
id|numbytes
op_eq
id|ADDR_PAGE
op_logical_or
id|numbytes
op_eq
id|ADDR_COLUMN_PAGE
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|doc-&gt;pageadrlen
suffix:semicolon
id|i
op_increment
comma
id|ofs
op_assign
id|ofs
op_rshift
l_int|8
)paren
(brace
r_if
c_cond
(paren
id|DoC_is_Millennium
c_func
(paren
id|doc
)paren
)paren
id|WriteDOC
c_func
(paren
id|ofs
op_amp
l_int|0xff
comma
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|WriteDOC_
c_func
(paren
id|ofs
op_amp
l_int|0xff
comma
id|docptr
comma
id|doc-&gt;ioreg
)paren
suffix:semicolon
)brace
)brace
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|2
)paren
suffix:semicolon
multiline_comment|/* Needed for some slow flash chips. mf. */
multiline_comment|/* FIXME: The SlowIO&squot;s for millennium could be replaced by &n;&t;   a single WritePipeTerm here. mf. */
multiline_comment|/* Lower the ALE line */
id|WriteDOC
c_func
(paren
id|xtraflags1
op_or
id|xtraflags2
op_or
id|CDSN_CTRL_CE
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Software requirement 11.4.3 for Millennium */
multiline_comment|/* Wait for the chip to respond - Software requirement 11.4.1 */
r_return
id|DoC_WaitReady
c_func
(paren
id|doc
)paren
suffix:semicolon
)brace
multiline_comment|/* Read a buffer from DoC, taking care of Millennium odditys */
DECL|function|DoC_ReadBuf
r_static
r_void
id|DoC_ReadBuf
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc
comma
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|dummy
suffix:semicolon
r_int
id|modulus
op_assign
l_int|0xffff
suffix:semicolon
r_int
r_int
id|docptr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|DoC_is_Millennium
c_func
(paren
id|doc
)paren
)paren
(brace
multiline_comment|/* Read the data via the internal pipeline through CDSN IO register,&n;&t;&t;   see Pipelined Read Operations 11.3 */
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ReadPipeInit
)paren
suffix:semicolon
multiline_comment|/* Millennium should use the LastDataRead register - Pipeline Reads */
id|len
op_decrement
suffix:semicolon
multiline_comment|/* This is needed for correctly ECC calculation */
id|modulus
op_assign
l_int|0xff
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|buf
(braket
id|i
)braket
op_assign
id|ReadDOC_
c_func
(paren
id|docptr
comma
id|doc-&gt;ioreg
op_plus
(paren
id|i
op_amp
id|modulus
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DoC_is_Millennium
c_func
(paren
id|doc
)paren
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|LastDataRead
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Write a buffer to DoC, taking care of Millennium odditys */
DECL|function|DoC_WriteBuf
r_static
r_void
id|DoC_WriteBuf
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc
comma
r_const
id|u_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
r_int
id|docptr
suffix:semicolon
r_int
id|i
suffix:semicolon
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
id|WriteDOC_
c_func
(paren
id|buf
(braket
id|i
)braket
comma
id|docptr
comma
id|doc-&gt;ioreg
op_plus
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DoC_is_Millennium
c_func
(paren
id|doc
)paren
)paren
(brace
id|WriteDOC
c_func
(paren
l_int|0x00
comma
id|docptr
comma
id|WritePipeTerm
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* DoC_SelectChip: Select a given flash chip within the current floor */
DECL|function|DoC_SelectChip
r_static
r_inline
r_int
id|DoC_SelectChip
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc
comma
r_int
id|chip
)paren
(brace
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
multiline_comment|/* Software requirement 11.4.4 before writing DeviceSelect */
multiline_comment|/* Deassert the CE line to eliminate glitches on the FCE# outputs */
id|WriteDOC
c_func
(paren
id|CDSN_CTRL_WP
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Software requirement 11.4.3 for Millennium */
multiline_comment|/* Select the individual flash chip requested */
id|WriteDOC
c_func
(paren
id|chip
comma
id|docptr
comma
id|CDSNDeviceSelect
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Reassert the CE line */
id|WriteDOC
c_func
(paren
id|CDSN_CTRL_CE
op_or
id|CDSN_CTRL_FLASH_IO
op_or
id|CDSN_CTRL_WP
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Software requirement 11.4.3 for Millennium */
multiline_comment|/* Wait for it to be ready */
r_return
id|DoC_WaitReady
c_func
(paren
id|doc
)paren
suffix:semicolon
)brace
multiline_comment|/* DoC_SelectFloor: Select a given floor (bank of flash chips) */
DECL|function|DoC_SelectFloor
r_static
r_inline
r_int
id|DoC_SelectFloor
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc
comma
r_int
id|floor
)paren
(brace
r_int
r_int
id|docptr
op_assign
id|doc-&gt;virtadr
suffix:semicolon
multiline_comment|/* Select the floor (bank) of chips required */
id|WriteDOC
c_func
(paren
id|floor
comma
id|docptr
comma
id|FloorSelect
)paren
suffix:semicolon
multiline_comment|/* Wait for the chip to be ready */
r_return
id|DoC_WaitReady
c_func
(paren
id|doc
)paren
suffix:semicolon
)brace
multiline_comment|/* DoC_IdentChip: Identify a given NAND chip given {floor,chip} */
DECL|function|DoC_IdentChip
r_static
r_int
id|DoC_IdentChip
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc
comma
r_int
id|floor
comma
r_int
id|chip
)paren
(brace
r_int
id|mfr
comma
id|id
comma
id|i
suffix:semicolon
r_volatile
r_char
id|dummy
suffix:semicolon
multiline_comment|/* Page in the required floor/chip */
id|DoC_SelectFloor
c_func
(paren
id|doc
comma
id|floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|doc
comma
id|chip
)paren
suffix:semicolon
multiline_comment|/* Reset the chip */
r_if
c_cond
(paren
id|DoC_Command
c_func
(paren
id|doc
comma
id|NAND_CMD_RESET
comma
id|CDSN_CTRL_WP
)paren
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;DoC_Command (reset) for %d,%d returned true&bslash;n&quot;
comma
id|floor
comma
id|chip
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read the NAND chip ID: 1. Send ReadID command */
r_if
c_cond
(paren
id|DoC_Command
c_func
(paren
id|doc
comma
id|NAND_CMD_READID
comma
id|CDSN_CTRL_WP
)paren
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;DoC_Command (ReadID) for %d,%d returned true&bslash;n&quot;
comma
id|floor
comma
id|chip
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Read the NAND chip ID: 2. Send address byte zero */
id|DoC_Address
c_func
(paren
id|doc
comma
id|ADDR_COLUMN
comma
l_int|0
comma
id|CDSN_CTRL_WP
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Read the manufacturer and device id codes from the device */
multiline_comment|/* CDSN Slow IO register see Software Requirement 11.4 item 5. */
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|2
)paren
suffix:semicolon
id|mfr
op_assign
id|ReadDOC_
c_func
(paren
id|doc-&gt;virtadr
comma
id|doc-&gt;ioreg
)paren
suffix:semicolon
multiline_comment|/* CDSN Slow IO register see Software Requirement 11.4 item 5. */
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc
comma
l_int|2
)paren
suffix:semicolon
id|id
op_assign
id|ReadDOC_
c_func
(paren
id|doc-&gt;virtadr
comma
id|doc-&gt;ioreg
)paren
suffix:semicolon
multiline_comment|/* No response - return failure */
r_if
c_cond
(paren
id|mfr
op_eq
l_int|0xff
op_logical_or
id|mfr
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Check it&squot;s the same as the first chip we identified. &n;&t; * M-Systems say that any given DiskOnChip device should only&n;&t; * contain _one_ type of flash part, although that&squot;s not a &n;&t; * hardware restriction. */
r_if
c_cond
(paren
id|doc-&gt;mfr
)paren
(brace
r_if
c_cond
(paren
id|doc-&gt;mfr
op_eq
id|mfr
op_logical_and
id|doc-&gt;id
op_eq
id|id
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* This is another the same the first */
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Flash chip at floor %d, chip %d is different:&bslash;n&quot;
comma
id|floor
comma
id|chip
)paren
suffix:semicolon
)brace
multiline_comment|/* Print and store the manufacturer and ID codes. */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|nand_flash_ids
(braket
id|i
)braket
dot
id|name
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mfr
op_eq
id|nand_flash_ids
(braket
id|i
)braket
dot
id|manufacture_id
op_logical_and
id|id
op_eq
id|nand_flash_ids
(braket
id|i
)braket
dot
id|model_id
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Flash chip found: Manufacturer ID: %2.2X, &quot;
l_string|&quot;Chip ID: %2.2X (%s)&bslash;n&quot;
comma
id|mfr
comma
id|id
comma
id|nand_flash_ids
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|doc-&gt;mfr
)paren
(brace
id|doc-&gt;mfr
op_assign
id|mfr
suffix:semicolon
id|doc-&gt;id
op_assign
id|id
suffix:semicolon
id|doc-&gt;chipshift
op_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|chipshift
suffix:semicolon
id|doc-&gt;page256
op_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|page256
suffix:semicolon
id|doc-&gt;pageadrlen
op_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|pageadrlen
suffix:semicolon
id|doc-&gt;erasesize
op_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|erasesize
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* We haven&squot;t fully identified the chip. Print as much as we know. */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Unknown flash chip found: %2.2X %2.2X&bslash;n&quot;
comma
id|id
comma
id|mfr
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Please report to dwmw2@infradead.org&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* DoC_ScanChips: Find all NAND chips present in a DiskOnChip, and identify them */
DECL|function|DoC_ScanChips
r_static
r_void
id|DoC_ScanChips
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|this
)paren
(brace
r_int
id|floor
comma
id|chip
suffix:semicolon
r_int
id|numchips
(braket
id|MAX_FLOORS
)braket
suffix:semicolon
r_int
id|maxchips
op_assign
id|MAX_CHIPS
suffix:semicolon
r_int
id|ret
op_assign
l_int|1
suffix:semicolon
id|this-&gt;numchips
op_assign
l_int|0
suffix:semicolon
id|this-&gt;mfr
op_assign
l_int|0
suffix:semicolon
id|this-&gt;id
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|DoC_is_Millennium
c_func
(paren
id|this
)paren
)paren
id|maxchips
op_assign
id|MAX_CHIPS_MIL
suffix:semicolon
multiline_comment|/* For each floor, find the number of valid chips it contains */
r_for
c_loop
(paren
id|floor
op_assign
l_int|0
suffix:semicolon
id|floor
OL
id|MAX_FLOORS
suffix:semicolon
id|floor
op_increment
)paren
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
id|numchips
(braket
id|floor
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|chip
op_assign
l_int|0
suffix:semicolon
id|chip
OL
id|maxchips
op_logical_and
id|ret
op_ne
l_int|0
suffix:semicolon
id|chip
op_increment
)paren
(brace
id|ret
op_assign
id|DoC_IdentChip
c_func
(paren
id|this
comma
id|floor
comma
id|chip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|numchips
(braket
id|floor
)braket
op_increment
suffix:semicolon
id|this-&gt;numchips
op_increment
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* If there are none at all that we recognise, bail */
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;numchips
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No flash chips recognised.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Allocate an array to hold the information for each chip */
id|this-&gt;chips
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|Nand
)paren
op_star
id|this-&gt;numchips
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;chips
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No memory for allocating chip info structures&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Fill out the chip array with {floor, chipno} for each &n;&t; * detected chip in the device. */
r_for
c_loop
(paren
id|floor
op_assign
l_int|0
suffix:semicolon
id|floor
OL
id|MAX_FLOORS
suffix:semicolon
id|floor
op_increment
)paren
(brace
r_for
c_loop
(paren
id|chip
op_assign
l_int|0
suffix:semicolon
id|chip
OL
id|numchips
(braket
id|floor
)braket
suffix:semicolon
id|chip
op_increment
)paren
(brace
id|this-&gt;chips
(braket
id|ret
)braket
dot
id|floor
op_assign
id|floor
suffix:semicolon
id|this-&gt;chips
(braket
id|ret
)braket
dot
id|chip
op_assign
id|chip
suffix:semicolon
id|this-&gt;chips
(braket
id|ret
)braket
dot
id|curadr
op_assign
l_int|0
suffix:semicolon
id|this-&gt;chips
(braket
id|ret
)braket
dot
id|curmode
op_assign
l_int|0x50
suffix:semicolon
id|ret
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Calculate and print the total size of the device */
id|this-&gt;totlen
op_assign
id|this-&gt;numchips
op_star
(paren
l_int|1
op_lshift
id|this-&gt;chipshift
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;%d flash chips found. Total DiskOnChip size: %ld Mb&bslash;n&quot;
comma
id|this-&gt;numchips
comma
id|this-&gt;totlen
op_rshift
l_int|20
)paren
suffix:semicolon
)brace
DECL|function|DoC2k_is_alias
r_static
r_int
id|DoC2k_is_alias
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc1
comma
r_struct
id|DiskOnChip
op_star
id|doc2
)paren
(brace
r_int
id|tmp1
comma
id|tmp2
comma
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|doc1-&gt;physadr
op_eq
id|doc2-&gt;physadr
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Use the alias resolution register which was set aside for this&n;&t; * purpose. If it&squot;s value is the same on both chips, they might&n;&t; * be the same chip, and we write to one and check for a change in&n;&t; * the other. It&squot;s unclear if this register is usuable in the&n;&t; * DoC 2000 (it&squot;s in the Millennium docs), but it seems to work. */
id|tmp1
op_assign
id|ReadDOC
c_func
(paren
id|doc1-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
id|tmp2
op_assign
id|ReadDOC
c_func
(paren
id|doc2-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp1
op_ne
id|tmp2
)paren
r_return
l_int|0
suffix:semicolon
id|WriteDOC
c_func
(paren
(paren
id|tmp1
op_plus
l_int|1
)paren
op_mod
l_int|0xff
comma
id|doc1-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
id|tmp2
op_assign
id|ReadDOC
c_func
(paren
id|doc2-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp2
op_eq
(paren
id|tmp1
op_plus
l_int|1
)paren
op_mod
l_int|0xff
)paren
id|retval
op_assign
l_int|1
suffix:semicolon
r_else
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Restore register contents.  May not be necessary, but do it just to&n;&t; * be safe. */
id|WriteDOC
c_func
(paren
id|tmp1
comma
id|doc1-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|im_name
r_static
r_const
r_char
id|im_name
(braket
)braket
op_assign
l_string|&quot;DoC2k_init&quot;
suffix:semicolon
multiline_comment|/* This routine is made available to other mtd code via&n; * inter_module_register.  It must only be accessed through&n; * inter_module_get which will bump the use count of this module.  The&n; * addresses passed back in mtd are valid as long as the use count of&n; * this module is non-zero, i.e. between inter_module_get and&n; * inter_module_put.  Keith Owens &lt;kaos@ocs.com.au&gt; 29 Oct 2000.&n; */
DECL|function|DoC2k_init
r_static
r_void
id|DoC2k_init
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|DiskOnChip
op_star
id|old
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* We must avoid being called twice for the same device. */
r_if
c_cond
(paren
id|doc2klist
)paren
id|old
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|doc2klist-&gt;priv
suffix:semicolon
r_while
c_loop
(paren
id|old
)paren
(brace
r_if
c_cond
(paren
id|DoC2k_is_alias
c_func
(paren
id|old
comma
id|this
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Ignoring DiskOnChip 2000 at 0x%lX - already configured&bslash;n&quot;
comma
id|this-&gt;physadr
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|this-&gt;virtadr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old-&gt;nextdoc
)paren
id|old
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|old-&gt;nextdoc-&gt;priv
suffix:semicolon
r_else
id|old
op_assign
l_int|NULL
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|this-&gt;ChipID
)paren
(brace
r_case
id|DOC_ChipID_Doc2k
suffix:colon
id|mtd-&gt;name
op_assign
l_string|&quot;DiskOnChip 2000&quot;
suffix:semicolon
id|this-&gt;ioreg
op_assign
id|DoC_2k_CDSN_IO
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DOC_ChipID_DocMil
suffix:colon
id|mtd-&gt;name
op_assign
l_string|&quot;DiskOnChip Millennium&quot;
suffix:semicolon
id|this-&gt;ioreg
op_assign
id|DoC_Mil_CDSN_IO
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%s found at address 0x%lX&bslash;n&quot;
comma
id|mtd-&gt;name
comma
id|this-&gt;physadr
)paren
suffix:semicolon
id|mtd-&gt;type
op_assign
id|MTD_NANDFLASH
suffix:semicolon
id|mtd-&gt;flags
op_assign
id|MTD_CAP_NANDFLASH
suffix:semicolon
id|mtd-&gt;size
op_assign
l_int|0
suffix:semicolon
id|mtd-&gt;erasesize
op_assign
l_int|0
suffix:semicolon
id|mtd-&gt;oobblock
op_assign
l_int|512
suffix:semicolon
id|mtd-&gt;oobsize
op_assign
l_int|16
suffix:semicolon
id|mtd-&gt;module
op_assign
id|THIS_MODULE
suffix:semicolon
id|mtd-&gt;erase
op_assign
id|doc_erase
suffix:semicolon
id|mtd-&gt;point
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;unpoint
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;read
op_assign
id|doc_read
suffix:semicolon
id|mtd-&gt;write
op_assign
id|doc_write
suffix:semicolon
id|mtd-&gt;read_ecc
op_assign
id|doc_read_ecc
suffix:semicolon
id|mtd-&gt;write_ecc
op_assign
id|doc_write_ecc
suffix:semicolon
id|mtd-&gt;read_oob
op_assign
id|doc_read_oob
suffix:semicolon
id|mtd-&gt;write_oob
op_assign
id|doc_write_oob
suffix:semicolon
id|mtd-&gt;sync
op_assign
l_int|NULL
suffix:semicolon
id|this-&gt;totlen
op_assign
l_int|0
suffix:semicolon
id|this-&gt;numchips
op_assign
l_int|0
suffix:semicolon
id|this-&gt;curfloor
op_assign
op_minus
l_int|1
suffix:semicolon
id|this-&gt;curchip
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Ident all the chips present. */
id|DoC_ScanChips
c_func
(paren
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;totlen
)paren
(brace
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|this-&gt;virtadr
)paren
suffix:semicolon
)brace
r_else
(brace
id|this-&gt;nextdoc
op_assign
id|doc2klist
suffix:semicolon
id|doc2klist
op_assign
id|mtd
suffix:semicolon
id|mtd-&gt;size
op_assign
id|this-&gt;totlen
suffix:semicolon
id|mtd-&gt;erasesize
op_assign
id|this-&gt;erasesize
suffix:semicolon
id|add_mtd_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|function|doc_read
r_static
r_int
id|doc_read
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
multiline_comment|/* Just a special case of doc_read_ecc */
r_return
id|doc_read_ecc
c_func
(paren
id|mtd
comma
id|from
comma
id|len
comma
id|retlen
comma
id|buf
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|doc_read_ecc
r_static
r_int
id|doc_read_ecc
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
)paren
(brace
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
suffix:semicolon
r_int
r_char
id|syndrome
(braket
l_int|6
)braket
suffix:semicolon
r_volatile
r_char
id|dummy
suffix:semicolon
r_int
id|i
comma
id|len256
op_assign
l_int|0
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
multiline_comment|/* Don&squot;t allow read past end of device */
r_if
c_cond
(paren
id|from
op_ge
id|this-&gt;totlen
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Don&squot;t allow a single read to cross a 512-byte block boundary */
r_if
c_cond
(paren
id|from
op_plus
id|len
OG
(paren
(paren
id|from
op_or
l_int|0x1ff
)paren
op_plus
l_int|1
)paren
)paren
id|len
op_assign
(paren
(paren
id|from
op_or
l_int|0x1ff
)paren
op_plus
l_int|1
)paren
op_minus
id|from
suffix:semicolon
multiline_comment|/* The ECC will not be calculated correctly if less than 512 is read */
r_if
c_cond
(paren
id|len
op_ne
l_int|0x200
op_logical_and
id|eccbuf
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ECC needs a full sector read (adr: %lx size %lx)&bslash;n&quot;
comma
(paren
r_int
)paren
id|from
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/* printk(&quot;DoC_Read (adr: %lx size %lx)&bslash;n&quot;, (long) from, (long) len); */
multiline_comment|/* Find the chip which is to be used and select it */
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|from
op_rshift
(paren
id|this-&gt;chipshift
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|this
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|this
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|this
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
(paren
op_logical_neg
id|this-&gt;page256
op_logical_and
(paren
id|from
op_amp
l_int|0x100
)paren
)paren
ques
c_cond
id|NAND_CMD_READ1
suffix:colon
id|NAND_CMD_READ0
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|this
comma
id|ADDR_COLUMN_PAGE
comma
id|from
comma
id|CDSN_CTRL_WP
comma
id|CDSN_CTRL_ECC_IO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eccbuf
)paren
(brace
multiline_comment|/* Prime the ECC engine */
id|WriteDOC
c_func
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|DOC_ECC_EN
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* disable the ECC engine */
id|WriteDOC
c_func
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
multiline_comment|/* treat crossing 256-byte sector for 2M x 8bits devices */
r_if
c_cond
(paren
id|this-&gt;page256
op_logical_and
id|from
op_plus
id|len
OG
(paren
id|from
op_or
l_int|0xff
)paren
op_plus
l_int|1
)paren
(brace
id|len256
op_assign
(paren
id|from
op_or
l_int|0xff
)paren
op_plus
l_int|1
op_minus
id|from
suffix:semicolon
id|DoC_ReadBuf
c_func
(paren
id|this
comma
id|buf
comma
id|len256
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_READ0
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|this
comma
id|ADDR_COLUMN_PAGE
comma
id|from
op_plus
id|len256
comma
id|CDSN_CTRL_WP
comma
id|CDSN_CTRL_ECC_IO
)paren
suffix:semicolon
)brace
id|DoC_ReadBuf
c_func
(paren
id|this
comma
op_amp
id|buf
(braket
id|len256
)braket
comma
id|len
op_minus
id|len256
)paren
suffix:semicolon
multiline_comment|/* Let the caller know we completed it */
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|eccbuf
)paren
(brace
multiline_comment|/* Read the ECC data through the DiskOnChip ECC logic */
multiline_comment|/* Note: this will work even with 2M x 8bit devices as   */
multiline_comment|/*       they have 8 bytes of OOB per 256 page. mf.      */
id|DoC_ReadBuf
c_func
(paren
id|this
comma
id|eccbuf
comma
l_int|6
)paren
suffix:semicolon
multiline_comment|/* Flush the pipeline */
r_if
c_cond
(paren
id|DoC_is_Millennium
c_func
(paren
id|this
)paren
)paren
(brace
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|i
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
r_else
(brace
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_ECCStatus
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_ECCStatus
)paren
suffix:semicolon
id|i
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
l_int|2
id|k_ECCStatus
)paren
suffix:semicolon
)brace
multiline_comment|/* Check the ECC Status */
r_if
c_cond
(paren
id|i
op_amp
l_int|0x80
)paren
(brace
r_int
id|nb_errors
suffix:semicolon
multiline_comment|/* There was an ECC error */
macro_line|#ifdef ECC_DEBUG
id|printk
c_func
(paren
l_string|&quot;DiskOnChip ECC Error: Read at %lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|from
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Read the ECC syndrom through the DiskOnChip ECC logic.&n;&t;&t;&t;   These syndrome will be all ZERO when there is no error */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|syndrome
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCSyndrome0
op_plus
id|i
)paren
suffix:semicolon
)brace
id|nb_errors
op_assign
id|doc_decode_ecc
c_func
(paren
id|buf
comma
id|syndrome
)paren
suffix:semicolon
macro_line|#ifdef ECC_DEBUG
id|printk
c_func
(paren
l_string|&quot;Errors corrected: %x&bslash;n&quot;
comma
id|nb_errors
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|nb_errors
OL
l_int|0
)paren
(brace
multiline_comment|/* We return error, but have actually done the read. Not that&n;&t;&t;&t;&t;   this can be told to user-space, via sys_read(), but at least&n;&t;&t;&t;&t;   MTD-aware stuff can know about it by checking *retlen */
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
macro_line|#ifdef PSYCHO_DEBUG
id|printk
c_func
(paren
l_string|&quot;ECC DATA at %lxB: %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X&bslash;n&quot;
comma
(paren
r_int
)paren
id|from
comma
id|eccbuf
(braket
l_int|0
)braket
comma
id|eccbuf
(braket
l_int|1
)braket
comma
id|eccbuf
(braket
l_int|2
)braket
comma
id|eccbuf
(braket
l_int|3
)braket
comma
id|eccbuf
(braket
l_int|4
)braket
comma
id|eccbuf
(braket
l_int|5
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* disable the ECC engine */
id|WriteDOC
c_func
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|doc_write
r_static
r_int
id|doc_write
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_char
id|eccbuf
(braket
l_int|6
)braket
suffix:semicolon
r_return
id|doc_write_ecc
c_func
(paren
id|mtd
comma
id|to
comma
id|len
comma
id|retlen
comma
id|buf
comma
id|eccbuf
)paren
suffix:semicolon
)brace
DECL|function|doc_write_ecc
r_static
r_int
id|doc_write_ecc
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
)paren
(brace
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
id|di
suffix:semicolon
multiline_comment|/* Yes, DI is a hangover from when I was disassembling the binary driver */
r_int
r_int
id|docptr
suffix:semicolon
r_volatile
r_char
id|dummy
suffix:semicolon
r_int
id|len256
op_assign
l_int|0
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
suffix:semicolon
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
multiline_comment|/* Don&squot;t allow write past end of device */
r_if
c_cond
(paren
id|to
op_ge
id|this-&gt;totlen
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Don&squot;t allow a single write to cross a 512-byte block boundary */
r_if
c_cond
(paren
id|to
op_plus
id|len
OG
(paren
(paren
id|to
op_or
l_int|0x1ff
)paren
op_plus
l_int|1
)paren
)paren
id|len
op_assign
(paren
(paren
id|to
op_or
l_int|0x1ff
)paren
op_plus
l_int|1
)paren
op_minus
id|to
suffix:semicolon
multiline_comment|/* The ECC will not be calculated correctly if less than 512 is written */
r_if
c_cond
(paren
id|len
op_ne
l_int|0x200
op_logical_and
id|eccbuf
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ECC needs a full sector write (adr: %lx size %lx)&bslash;n&quot;
comma
(paren
r_int
)paren
id|to
comma
(paren
r_int
)paren
id|len
)paren
suffix:semicolon
multiline_comment|/* printk(&quot;DoC_Write (adr: %lx size %lx)&bslash;n&quot;, (long) to, (long) len); */
multiline_comment|/* Find the chip which is to be used and select it */
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|to
op_rshift
(paren
id|this-&gt;chipshift
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|this
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|this
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|this
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
multiline_comment|/* Set device to main plane of flash */
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_RESET
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
(paren
op_logical_neg
id|this-&gt;page256
op_logical_and
(paren
id|to
op_amp
l_int|0x100
)paren
)paren
ques
c_cond
id|NAND_CMD_READ1
suffix:colon
id|NAND_CMD_READ0
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_SEQIN
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|this
comma
id|ADDR_COLUMN_PAGE
comma
id|to
comma
l_int|0
comma
id|CDSN_CTRL_ECC_IO
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eccbuf
)paren
(brace
multiline_comment|/* Prime the ECC engine */
id|WriteDOC
c_func
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|DOC_ECC_EN
op_or
id|DOC_ECC_RW
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* disable the ECC engine */
id|WriteDOC
c_func
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
multiline_comment|/* treat crossing 256-byte sector for 2M x 8bits devices */
r_if
c_cond
(paren
id|this-&gt;page256
op_logical_and
id|to
op_plus
id|len
OG
(paren
id|to
op_or
l_int|0xff
)paren
op_plus
l_int|1
)paren
(brace
id|len256
op_assign
(paren
id|to
op_or
l_int|0xff
)paren
op_plus
l_int|1
op_minus
id|to
suffix:semicolon
id|DoC_WriteBuf
c_func
(paren
id|this
comma
id|buf
comma
id|len256
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_PAGEPROG
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_STATUS
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
multiline_comment|/* There&squot;s an implicit DoC_WaitReady() in DoC_Command */
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|this
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReadDOC_
c_func
(paren
id|docptr
comma
id|this-&gt;ioreg
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error programming flash&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Error in programming */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_SEQIN
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|this
comma
id|ADDR_COLUMN_PAGE
comma
id|to
op_plus
id|len256
comma
l_int|0
comma
id|CDSN_CTRL_ECC_IO
)paren
suffix:semicolon
)brace
id|DoC_WriteBuf
c_func
(paren
id|this
comma
op_amp
id|buf
(braket
id|len256
)braket
comma
id|len
op_minus
id|len256
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eccbuf
)paren
(brace
id|WriteDOC
c_func
(paren
id|CDSN_CTRL_ECC_IO
op_or
id|CDSN_CTRL_CE
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|DoC_is_Millennium
c_func
(paren
id|this
)paren
)paren
(brace
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|NOP
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|NOP
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|NOP
)paren
suffix:semicolon
)brace
r_else
(brace
id|WriteDOC_
c_func
(paren
l_int|0
comma
id|docptr
comma
id|this-&gt;ioreg
)paren
suffix:semicolon
id|WriteDOC_
c_func
(paren
l_int|0
comma
id|docptr
comma
id|this-&gt;ioreg
)paren
suffix:semicolon
id|WriteDOC_
c_func
(paren
l_int|0
comma
id|docptr
comma
id|this-&gt;ioreg
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the ECC data through the DiskOnChip ECC logic */
r_for
c_loop
(paren
id|di
op_assign
l_int|0
suffix:semicolon
id|di
OL
l_int|6
suffix:semicolon
id|di
op_increment
)paren
(brace
id|eccbuf
(braket
id|di
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCSyndrome0
op_plus
id|di
)paren
suffix:semicolon
)brace
multiline_comment|/* Reset the ECC engine */
id|WriteDOC
c_func
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
macro_line|#ifdef PSYCHO_DEBUG
id|printk
(paren
l_string|&quot;OOB data at %lx is %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X&bslash;n&quot;
comma
(paren
r_int
)paren
id|to
comma
id|eccbuf
(braket
l_int|0
)braket
comma
id|eccbuf
(braket
l_int|1
)braket
comma
id|eccbuf
(braket
l_int|2
)braket
comma
id|eccbuf
(braket
l_int|3
)braket
comma
id|eccbuf
(braket
l_int|4
)braket
comma
id|eccbuf
(braket
l_int|5
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_PAGEPROG
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_STATUS
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
multiline_comment|/* There&squot;s an implicit DoC_WaitReady() in DoC_Command */
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|this
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReadDOC_
c_func
(paren
id|docptr
comma
id|this-&gt;ioreg
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error programming flash&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Error in programming */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Let the caller know we completed it */
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|eccbuf
)paren
(brace
r_int
r_char
id|x
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|dummy
suffix:semicolon
multiline_comment|/* Write the ECC data to flash */
r_for
c_loop
(paren
id|di
op_assign
l_int|0
suffix:semicolon
id|di
OL
l_int|6
suffix:semicolon
id|di
op_increment
)paren
id|x
(braket
id|di
)braket
op_assign
id|eccbuf
(braket
id|di
)braket
suffix:semicolon
id|x
(braket
l_int|6
)braket
op_assign
l_int|0x55
suffix:semicolon
id|x
(braket
l_int|7
)braket
op_assign
l_int|0x55
suffix:semicolon
r_return
id|doc_write_oob
c_func
(paren
id|mtd
comma
id|to
comma
l_int|8
comma
op_amp
id|dummy
comma
id|x
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc_read_oob
r_static
r_int
id|doc_read_oob
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
id|len256
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|docptr
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
suffix:semicolon
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|ofs
op_rshift
id|this-&gt;chipshift
)braket
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|this
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|this
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|this
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
multiline_comment|/* update address for 2M x 8bit devices. OOB starts on the second */
multiline_comment|/* page to maintain compatibility with doc_read_ecc. */
r_if
c_cond
(paren
id|this-&gt;page256
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ofs
op_amp
l_int|0x8
)paren
)paren
id|ofs
op_add_assign
l_int|0x100
suffix:semicolon
r_else
id|ofs
op_sub_assign
l_int|0x8
suffix:semicolon
)brace
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_READOOB
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|this
comma
id|ADDR_COLUMN_PAGE
comma
id|ofs
comma
id|CDSN_CTRL_WP
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* treat crossing 8-byte OOB data for 2M x 8bit devices */
multiline_comment|/* Note: datasheet says it should automaticaly wrap to the */
multiline_comment|/*       next OOB block, but it didn&squot;t work here. mf.      */
r_if
c_cond
(paren
id|this-&gt;page256
op_logical_and
id|ofs
op_plus
id|len
OG
(paren
id|ofs
op_or
l_int|0x7
)paren
op_plus
l_int|1
)paren
(brace
id|len256
op_assign
(paren
id|ofs
op_or
l_int|0x7
)paren
op_plus
l_int|1
op_minus
id|ofs
suffix:semicolon
id|DoC_ReadBuf
c_func
(paren
id|this
comma
id|buf
comma
id|len256
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_READOOB
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|this
comma
id|ADDR_COLUMN_PAGE
comma
id|ofs
op_amp
(paren
op_complement
l_int|0x1ff
)paren
comma
id|CDSN_CTRL_WP
comma
l_int|0
)paren
suffix:semicolon
)brace
id|DoC_ReadBuf
c_func
(paren
id|this
comma
op_amp
id|buf
(braket
id|len256
)braket
comma
id|len
op_minus
id|len256
)paren
suffix:semicolon
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc_write_oob
r_static
r_int
id|doc_write_oob
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
id|len256
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|ofs
op_rshift
id|this-&gt;chipshift
)braket
suffix:semicolon
r_int
id|dummy
suffix:semicolon
singleline_comment|//      printk(&quot;doc_write_oob(%lx, %d): %2.2X %2.2X %2.2X %2.2X ... %2.2X %2.2X .. %2.2X %2.2X&bslash;n&quot;,(long)ofs, len,
singleline_comment|//   buf[0], buf[1], buf[2], buf[3], buf[8], buf[9], buf[14],buf[15]);
multiline_comment|/* Find the chip which is to be used and select it */
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|this
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|this
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|this
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
multiline_comment|/* disable the ECC engine */
id|WriteDOC
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
multiline_comment|/* Reset the chip, see Software Requirement 11.4 item 1. */
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_RESET
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
multiline_comment|/* issue the Read2 command to set the pointer to the Spare Data Area. */
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_READOOB
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
multiline_comment|/* update address for 2M x 8bit devices. OOB starts on the second */
multiline_comment|/* page to maintain compatibility with doc_read_ecc. */
r_if
c_cond
(paren
id|this-&gt;page256
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|ofs
op_amp
l_int|0x8
)paren
)paren
id|ofs
op_add_assign
l_int|0x100
suffix:semicolon
r_else
id|ofs
op_sub_assign
l_int|0x8
suffix:semicolon
)brace
multiline_comment|/* issue the Serial Data In command to initial the Page Program process */
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_SEQIN
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|this
comma
id|ADDR_COLUMN_PAGE
comma
id|ofs
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* treat crossing 8-byte OOB data for 2M x 8bit devices */
multiline_comment|/* Note: datasheet says it should automaticaly wrap to the */
multiline_comment|/*       next OOB block, but it didn&squot;t work here. mf.      */
r_if
c_cond
(paren
id|this-&gt;page256
op_logical_and
id|ofs
op_plus
id|len
OG
(paren
id|ofs
op_or
l_int|0x7
)paren
op_plus
l_int|1
)paren
(brace
id|len256
op_assign
(paren
id|ofs
op_or
l_int|0x7
)paren
op_plus
l_int|1
op_minus
id|ofs
suffix:semicolon
id|DoC_WriteBuf
c_func
(paren
id|this
comma
id|buf
comma
id|len256
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_PAGEPROG
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_STATUS
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* DoC_WaitReady() is implicit in DoC_Command */
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|this
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReadDOC_
c_func
(paren
id|docptr
comma
id|this-&gt;ioreg
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error programming oob data&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* There was an error */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_SEQIN
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|this
comma
id|ADDR_COLUMN_PAGE
comma
id|ofs
op_amp
(paren
op_complement
l_int|0x1ff
)paren
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
)brace
id|DoC_WriteBuf
c_func
(paren
id|this
comma
op_amp
id|buf
(braket
id|len256
)braket
comma
id|len
op_minus
id|len256
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_PAGEPROG
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_STATUS
comma
l_int|0
)paren
suffix:semicolon
multiline_comment|/* DoC_WaitReady() is implicit in DoC_Command */
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|this
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReadDOC_
c_func
(paren
id|docptr
comma
id|this-&gt;ioreg
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error programming oob data&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* There was an error */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc_erase
r_int
id|doc_erase
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
(brace
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
r_int
id|ofs
op_assign
id|instr-&gt;addr
suffix:semicolon
r_int
r_int
id|len
op_assign
id|instr-&gt;len
suffix:semicolon
r_int
r_int
id|docptr
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|mtd-&gt;erasesize
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Erase not right size (%lx != %lx)n&quot;
comma
id|len
comma
id|mtd-&gt;erasesize
)paren
suffix:semicolon
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|ofs
op_rshift
id|this-&gt;chipshift
)braket
suffix:semicolon
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|this
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|this
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|this
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_PENDING
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_ERASE1
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|this
comma
id|ADDR_PAGE
comma
id|ofs
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_ERASE2
comma
l_int|0
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASING
suffix:semicolon
id|DoC_Command
c_func
(paren
id|this
comma
id|NAND_CMD_STATUS
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReadDOC_
c_func
(paren
id|docptr
comma
id|this-&gt;ioreg
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error writing&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* There was an error */
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
)brace
r_else
id|instr-&gt;state
op_assign
id|MTD_ERASE_DONE
suffix:semicolon
r_if
c_cond
(paren
id|instr-&gt;callback
)paren
id|instr
op_member_access_from_pointer
id|callback
c_func
(paren
id|instr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * Module stuff&n; *&n; ****************************************************************************/
macro_line|#if LINUX_VERSION_CODE &lt; 0x20212 &amp;&amp; defined(MODULE)
DECL|macro|cleanup_doc2000
mdefine_line|#define cleanup_doc2000 cleanup_module
DECL|macro|init_doc2000
mdefine_line|#define init_doc2000 init_module
macro_line|#endif
DECL|function|init_doc2000
r_int
id|__init
id|init_doc2000
c_func
(paren
r_void
)paren
(brace
id|inter_module_register
c_func
(paren
id|im_name
comma
id|THIS_MODULE
comma
op_amp
id|DoC2k_init
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_doc2000
r_static
r_void
id|__exit
id|cleanup_doc2000
c_func
(paren
r_void
)paren
(brace
r_struct
id|mtd_info
op_star
id|mtd
suffix:semicolon
r_struct
id|DiskOnChip
op_star
id|this
suffix:semicolon
r_while
c_loop
(paren
(paren
id|mtd
op_assign
id|doc2klist
)paren
)paren
(brace
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
id|doc2klist
op_assign
id|this-&gt;nextdoc
suffix:semicolon
id|del_mtd_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|this-&gt;virtadr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|this-&gt;chips
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
)brace
id|inter_module_unregister
c_func
(paren
id|im_name
)paren
suffix:semicolon
)brace
DECL|variable|cleanup_doc2000
id|module_exit
c_func
(paren
id|cleanup_doc2000
)paren
suffix:semicolon
DECL|variable|init_doc2000
id|module_init
c_func
(paren
id|init_doc2000
)paren
suffix:semicolon
eof
