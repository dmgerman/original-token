multiline_comment|/* JEDEC Flash Interface.&n; * This is an older type of interface for self programming flash. It is &n; * commonly use in older AMD chips and is obsolete compared with CFI.&n; * It is called JEDEC because the JEDEC association distributes the ID codes&n; * for the chips.&n; *&n; * See the AMD flash databook for information on how to operate the interface.&n; *&n; * This code does not support anything wider than 8 bit flash chips, I am&n; * not going to guess how to send commands to them, plus I expect they will&n; * all speak CFI..&n; *&n; * $Id: jedec.c,v 1.1 2000/07/04 07:21:57 jgg Exp $&n; */
macro_line|#include &lt;linux/mtd/jedec.h&gt;
r_struct
id|mtd_info
op_star
id|jedec_probe
c_func
(paren
r_struct
id|map_info
op_star
)paren
suffix:semicolon
r_int
id|jedec_probe8
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_int
r_int
id|base
comma
r_struct
id|jedec_private
op_star
id|priv
)paren
suffix:semicolon
r_int
id|jedec_probe16
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_int
r_int
id|base
comma
r_struct
id|jedec_private
op_star
id|priv
)paren
suffix:semicolon
r_int
id|jedec_probe32
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_int
r_int
id|base
comma
r_struct
id|jedec_private
op_star
id|priv
)paren
suffix:semicolon
r_static
r_void
id|jedec_flash_chip_scan
c_func
(paren
r_struct
id|jedec_private
op_star
id|priv
comma
r_int
r_int
id|start
comma
r_int
r_int
id|len
)paren
suffix:semicolon
r_static
r_int
id|flash_erase
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
suffix:semicolon
r_static
r_int
id|flash_write
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|start
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
suffix:semicolon
DECL|variable|jedec_probe
id|EXPORT_SYMBOL
c_func
(paren
id|jedec_probe
)paren
suffix:semicolon
multiline_comment|/* Listing of parts and sizes. We need this table to learn the sector&n;   size of the chip and the total length */
DECL|variable|JEDEC_table
r_static
r_const
r_struct
id|JEDECTable
id|JEDEC_table
(braket
)braket
op_assign
(brace
(brace
l_int|0x01AD
comma
l_string|&quot;AMD Am29F016&quot;
comma
l_int|2
op_star
l_int|1024
op_star
l_int|1024
comma
l_int|64
op_star
l_int|1024
comma
id|MTD_CAP_NORFLASH
)brace
comma
(brace
l_int|0x01D5
comma
l_string|&quot;AMD Am29F080&quot;
comma
l_int|1
op_star
l_int|1024
op_star
l_int|1024
comma
l_int|64
op_star
l_int|1024
comma
id|MTD_CAP_NORFLASH
)brace
comma
(brace
l_int|0x01A4
comma
l_string|&quot;AMD Am29F040&quot;
comma
l_int|512
op_star
l_int|1024
comma
l_int|64
op_star
l_int|1024
comma
id|MTD_CAP_NORFLASH
)brace
comma
(brace
)brace
)brace
suffix:semicolon
DECL|function|jedec_sync
r_static
r_void
id|jedec_sync
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
)brace
suffix:semicolon
r_static
r_int
id|jedec_read
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|jedec_read_banked
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
suffix:semicolon
multiline_comment|/* Probe entry point */
DECL|variable|priv
r_struct
id|jedec_private
id|priv
suffix:semicolon
DECL|variable|__MTD
r_struct
id|mtd_info
id|__MTD
suffix:semicolon
DECL|function|jedec_probe
r_struct
id|mtd_info
op_star
id|jedec_probe
c_func
(paren
r_struct
id|map_info
op_star
id|map
)paren
(brace
r_struct
id|mtd_info
op_star
id|MTD
op_assign
op_amp
id|__MTD
suffix:semicolon
r_int
r_int
id|Base
suffix:semicolon
r_int
r_int
id|SectorSize
suffix:semicolon
r_int
id|count
suffix:semicolon
r_int
id|I
comma
id|Uniq
suffix:semicolon
r_char
id|Part
(braket
l_int|200
)braket
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|priv
comma
l_int|0
comma
r_sizeof
(paren
id|priv
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;bank_size
op_eq
l_int|0
)paren
id|map-&gt;bank_size
op_assign
id|map-&gt;size
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;size
op_div
id|map-&gt;bank_size
OG
id|MAX_JEDEC_CHIPS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mtd: Increase MAX_JEDEC_CHIPS, too many banks.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_for
c_loop
(paren
id|Base
op_assign
l_int|0
suffix:semicolon
id|Base
OL
id|map-&gt;size
suffix:semicolon
id|Base
op_add_assign
id|map-&gt;bank_size
)paren
(brace
singleline_comment|// Perhaps zero could designate all tests?
r_if
c_cond
(paren
id|map-&gt;bus_width
op_eq
l_int|0
)paren
id|map-&gt;bus_width
op_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;bus_width
op_eq
l_int|8
)paren
id|jedec_probe8
c_func
(paren
id|map
comma
id|Base
comma
op_amp
id|priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;bus_width
op_eq
l_int|16
)paren
id|jedec_probe16
c_func
(paren
id|map
comma
id|Base
comma
op_amp
id|priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;bus_width
op_eq
l_int|32
)paren
id|jedec_probe32
c_func
(paren
id|map
comma
id|Base
comma
op_amp
id|priv
)paren
suffix:semicolon
)brace
singleline_comment|// Get the biggest sector size
id|SectorSize
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|priv.chips
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
op_logical_and
id|I
OL
id|MAX_JEDEC_CHIPS
suffix:semicolon
id|I
op_increment
)paren
(brace
r_if
c_cond
(paren
id|priv.chips
(braket
id|I
)braket
dot
id|sectorsize
OG
id|SectorSize
)paren
id|SectorSize
op_assign
id|priv.chips
(braket
id|I
)braket
dot
id|sectorsize
suffix:semicolon
)brace
singleline_comment|// Quickly ensure that the other sector sizes are factors of the largest
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|priv.chips
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
op_logical_and
id|I
OL
id|MAX_JEDEC_CHIPS
suffix:semicolon
id|I
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|SectorSize
op_div
id|priv.chips
(braket
id|I
)braket
dot
id|sectorsize
)paren
op_star
id|priv.chips
(braket
id|I
)braket
dot
id|sectorsize
op_ne
id|SectorSize
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mtd: Failed. Device has incompatible mixed sector sizes&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Generate a part name that includes the number of different chips and&n;      other configuration information */
id|count
op_assign
l_int|1
suffix:semicolon
id|strncpy
c_func
(paren
id|Part
comma
id|map-&gt;name
comma
r_sizeof
(paren
id|Part
)paren
op_minus
l_int|10
)paren
suffix:semicolon
id|Part
(braket
r_sizeof
(paren
id|Part
)paren
op_minus
l_int|11
)braket
op_assign
l_int|0
suffix:semicolon
id|strcat
c_func
(paren
id|Part
comma
l_string|&quot; &quot;
)paren
suffix:semicolon
id|Uniq
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|priv.chips
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
op_logical_and
id|I
OL
id|MAX_JEDEC_CHIPS
suffix:semicolon
id|I
op_increment
)paren
(brace
r_const
r_struct
id|JEDECTable
op_star
id|JEDEC
suffix:semicolon
r_if
c_cond
(paren
id|priv.chips
(braket
id|I
op_plus
l_int|1
)braket
dot
id|jedec
op_eq
id|priv.chips
(braket
id|I
)braket
dot
id|jedec
)paren
(brace
id|count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
singleline_comment|// Locate the chip in the jedec table
id|JEDEC
op_assign
id|jedec_idtoinf
c_func
(paren
id|priv.chips
(braket
id|I
)braket
dot
id|jedec
op_rshift
l_int|8
comma
id|priv.chips
(braket
id|I
)braket
dot
id|jedec
)paren
suffix:semicolon
r_if
c_cond
(paren
id|JEDEC
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mtd: Internal Error, JEDEC not set&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Uniq
op_ne
l_int|0
)paren
id|strcat
c_func
(paren
id|Part
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
id|Uniq
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ne
l_int|1
)paren
id|sprintf
c_func
(paren
id|Part
op_plus
id|strlen
c_func
(paren
id|Part
)paren
comma
l_string|&quot;%x*[%s]&quot;
comma
id|count
comma
id|JEDEC-&gt;name
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|Part
op_plus
id|strlen
c_func
(paren
id|Part
)paren
comma
l_string|&quot;%s&quot;
comma
id|JEDEC-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|strlen
c_func
(paren
id|Part
)paren
OG
r_sizeof
(paren
id|Part
)paren
op_star
l_int|2
op_div
l_int|3
)paren
r_break
suffix:semicolon
id|count
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Determine if the chips are organized in a linear fashion, or if there&n;      are empty banks. Note, the last bank does not count here, only the&n;      first banks are important. Holes on non-bank boundaries can not exist&n;      due to the way the detection algorithm works. */
r_if
c_cond
(paren
id|priv.size
OL
id|map-&gt;bank_size
)paren
id|map-&gt;bank_size
op_assign
id|priv.size
suffix:semicolon
id|priv.is_banked
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|I
op_ne
id|priv.size
op_div
id|map-&gt;bank_size
op_minus
l_int|1
suffix:semicolon
id|I
op_increment
)paren
(brace
r_if
c_cond
(paren
id|priv.bank_fill
(braket
id|I
)braket
op_ne
id|map-&gt;bank_size
)paren
id|priv.is_banked
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* This even could be eliminated, but new de-optimized read/write&n;         functions have to be written */
r_if
c_cond
(paren
id|priv.bank_fill
(braket
id|I
)braket
op_ne
id|priv.bank_fill
(braket
l_int|0
)braket
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mtd: Failed. Cannot handle unsymetric banking&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|priv.is_banked
op_eq
l_int|1
)paren
id|strcat
c_func
(paren
id|Part
comma
l_string|&quot;, banked&quot;
)paren
suffix:semicolon
id|xprintf
c_func
(paren
l_string|&quot;Part: &squot;%s&squot;&bslash;n&quot;
comma
id|Part
)paren
suffix:semicolon
id|memset
c_func
(paren
id|MTD
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|MTD
)paren
)paren
suffix:semicolon
id|strncpy
c_func
(paren
id|MTD-&gt;name
comma
id|Part
comma
r_sizeof
(paren
id|MTD-&gt;name
)paren
)paren
suffix:semicolon
id|MTD-&gt;name
(braket
r_sizeof
(paren
id|MTD-&gt;name
)paren
op_minus
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
id|MTD-&gt;type
op_assign
id|MTD_NORFLASH
suffix:semicolon
id|MTD-&gt;flags
op_assign
id|MTD_CAP_NORFLASH
suffix:semicolon
id|MTD-&gt;erasesize
op_assign
id|SectorSize
op_star
(paren
id|map-&gt;bus_width
op_div
l_int|8
)paren
suffix:semicolon
id|MTD-&gt;size
op_assign
id|priv.size
suffix:semicolon
singleline_comment|//MTD-&gt;module = THIS_MODULE; // ? Maybe this should be the low level module?
id|MTD-&gt;erase
op_assign
id|flash_erase
suffix:semicolon
r_if
c_cond
(paren
id|priv.is_banked
op_eq
l_int|1
)paren
id|MTD-&gt;read
op_assign
id|jedec_read_banked
suffix:semicolon
r_else
id|MTD-&gt;read
op_assign
id|jedec_read
suffix:semicolon
id|MTD-&gt;write
op_assign
id|flash_write
suffix:semicolon
id|MTD-&gt;sync
op_assign
id|jedec_sync
suffix:semicolon
id|MTD-&gt;priv
op_assign
id|map
suffix:semicolon
id|map-&gt;fldrv_priv
op_assign
op_amp
id|priv
suffix:semicolon
r_return
id|MTD
suffix:semicolon
)brace
multiline_comment|/* Helper for the JEDEC function, JEDEC numbers all have odd parity */
DECL|function|checkparity
r_static
r_int
id|checkparity
c_func
(paren
id|u_char
id|C
)paren
(brace
id|u_char
id|parity
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|C
op_ne
l_int|0
)paren
(brace
id|parity
op_xor_assign
id|C
op_amp
l_int|1
suffix:semicolon
id|C
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_return
id|parity
op_eq
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Take an array of JEDEC numbers that represent interleved flash chips&n;   and process them. Check to make sure they are good JEDEC numbers, look&n;   them up and then add them to the chip list */
DECL|function|handle_jedecs
r_int
id|handle_jedecs
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
id|__u8
op_star
id|Mfg
comma
id|__u8
op_star
id|Id
comma
r_int
id|Count
comma
r_int
r_int
id|base
comma
r_struct
id|jedec_private
op_star
id|priv
)paren
(brace
r_int
id|I
comma
id|J
suffix:semicolon
r_int
r_int
id|Size
suffix:semicolon
r_int
r_int
id|SectorSize
suffix:semicolon
r_const
r_struct
id|JEDECTable
op_star
id|JEDEC
suffix:semicolon
singleline_comment|// Test #2 JEDEC numbers exhibit odd parity
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|I
op_ne
id|Count
suffix:semicolon
id|I
op_increment
)paren
(brace
r_if
c_cond
(paren
id|checkparity
c_func
(paren
id|Mfg
(braket
id|I
)braket
)paren
op_eq
l_int|0
op_logical_or
id|checkparity
c_func
(paren
id|Id
(braket
id|I
)braket
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// Finally, just make sure all the chip sizes are the same
id|JEDEC
op_assign
id|jedec_idtoinf
c_func
(paren
id|Mfg
(braket
l_int|0
)braket
comma
id|Id
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|JEDEC
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mtd: Found JEDEC flash chip, but do not have a table entry for %x:%x&bslash;n&quot;
comma
id|Mfg
(braket
l_int|0
)braket
comma
id|Mfg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|Size
op_assign
id|JEDEC-&gt;size
suffix:semicolon
id|SectorSize
op_assign
id|JEDEC-&gt;sectorsize
suffix:semicolon
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|I
op_ne
id|Count
suffix:semicolon
id|I
op_increment
)paren
(brace
id|JEDEC
op_assign
id|jedec_idtoinf
c_func
(paren
id|Mfg
(braket
l_int|0
)braket
comma
id|Id
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|JEDEC
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mtd: Found JEDEC flash chip, but do not have a table entry for %x:%x&bslash;n&quot;
comma
id|Mfg
(braket
l_int|0
)braket
comma
id|Mfg
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Size
op_ne
id|JEDEC-&gt;size
op_logical_or
id|SectorSize
op_ne
id|JEDEC-&gt;sectorsize
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mtd: Failed. Interleved flash does not have matching characteristics&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
singleline_comment|// Load the Chips
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|I
op_ne
id|MAX_JEDEC_CHIPS
suffix:semicolon
id|I
op_increment
)paren
(brace
r_if
c_cond
(paren
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|jedec
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|I
op_plus
id|Count
OG
id|MAX_JEDEC_CHIPS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mtd: Device has too many chips. Increase MAX_JEDEC_CHIPS&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// Add them to the table
r_for
c_loop
(paren
id|J
op_assign
l_int|0
suffix:semicolon
id|J
op_ne
id|Count
suffix:semicolon
id|J
op_increment
)paren
(brace
r_int
r_int
id|Bank
suffix:semicolon
id|JEDEC
op_assign
id|jedec_idtoinf
c_func
(paren
id|Mfg
(braket
id|J
)braket
comma
id|Id
(braket
id|J
)braket
)paren
suffix:semicolon
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|jedec
op_assign
(paren
id|Mfg
(braket
id|J
)braket
op_lshift
l_int|8
)paren
op_or
id|Id
(braket
id|J
)braket
suffix:semicolon
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|size
op_assign
id|JEDEC-&gt;size
suffix:semicolon
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|sectorsize
op_assign
id|JEDEC-&gt;sectorsize
suffix:semicolon
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|base
op_assign
id|base
op_plus
id|J
suffix:semicolon
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|datashift
op_assign
id|J
op_star
l_int|8
suffix:semicolon
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|capabilities
op_assign
id|JEDEC-&gt;capabilities
suffix:semicolon
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|offset
op_assign
id|priv-&gt;size
op_plus
id|J
suffix:semicolon
singleline_comment|// log2 n :|
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|addrshift
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|Bank
op_assign
id|Count
suffix:semicolon
id|Bank
op_ne
l_int|1
suffix:semicolon
id|Bank
op_rshift_assign
l_int|1
comma
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|addrshift
op_increment
)paren
suffix:semicolon
singleline_comment|// Determine how filled this bank is.
id|Bank
op_assign
id|base
op_amp
(paren
op_complement
(paren
id|map-&gt;bank_size
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;bank_fill
(braket
id|Bank
op_div
id|map-&gt;bank_size
)braket
OL
id|base
op_plus
(paren
id|JEDEC-&gt;size
op_lshift
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|addrshift
)paren
op_minus
id|Bank
)paren
id|priv-&gt;bank_fill
(braket
id|Bank
op_div
id|map-&gt;bank_size
)braket
op_assign
id|base
op_plus
(paren
id|JEDEC-&gt;size
op_lshift
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|addrshift
)paren
op_minus
id|Bank
suffix:semicolon
id|I
op_increment
suffix:semicolon
)brace
id|priv-&gt;size
op_add_assign
id|priv-&gt;chips
(braket
id|I
op_minus
l_int|1
)braket
dot
id|size
op_star
id|Count
suffix:semicolon
r_return
id|priv-&gt;chips
(braket
id|I
op_minus
l_int|1
)braket
dot
id|size
suffix:semicolon
)brace
multiline_comment|/* Lookup the chip information from the JEDEC ID table. */
DECL|function|jedec_idtoinf
r_const
r_struct
id|JEDECTable
op_star
id|jedec_idtoinf
c_func
(paren
id|__u8
id|mfr
comma
id|__u8
id|id
)paren
(brace
id|__u16
id|Id
op_assign
(paren
id|mfr
op_lshift
l_int|8
)paren
op_or
id|id
suffix:semicolon
r_int
r_int
id|I
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|JEDEC_table
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
suffix:semicolon
id|I
op_increment
)paren
r_if
c_cond
(paren
id|JEDEC_table
(braket
id|I
)braket
dot
id|jedec
op_eq
id|Id
)paren
r_return
id|JEDEC_table
op_plus
id|I
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// Look for flash using an 8 bit bus interface
DECL|function|jedec_probe8
r_int
id|jedec_probe8
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_int
r_int
id|base
comma
r_struct
id|jedec_private
op_star
id|priv
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// Look for flash using a 16 bit bus interface (ie 2 8-bit chips)
DECL|function|jedec_probe16
r_int
id|jedec_probe16
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_int
r_int
id|base
comma
r_struct
id|jedec_private
op_star
id|priv
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// Look for flash using a 32 bit bus interface (ie 4 8-bit chips)
DECL|function|jedec_probe32
r_int
id|jedec_probe32
c_func
(paren
r_struct
id|map_info
op_star
id|map
comma
r_int
r_int
id|base
comma
r_struct
id|jedec_private
op_star
id|priv
)paren
(brace
DECL|macro|flread
mdefine_line|#define flread(x) map-&gt;read32(map,base+((x)&lt;&lt;2))
DECL|macro|flwrite
mdefine_line|#define flwrite(v,x) map-&gt;write32(map,v,base+((x)&lt;&lt;2))
r_const
r_int
r_int
id|AutoSel1
op_assign
l_int|0xAAAAAAAA
suffix:semicolon
r_const
r_int
r_int
id|AutoSel2
op_assign
l_int|0x55555555
suffix:semicolon
r_const
r_int
r_int
id|AutoSel3
op_assign
l_int|0x90909090
suffix:semicolon
r_const
r_int
r_int
id|Reset
op_assign
l_int|0x90909090
suffix:semicolon
id|__u32
id|OldVal
suffix:semicolon
id|__u8
id|Mfg
(braket
l_int|4
)braket
suffix:semicolon
id|__u8
id|Id
(braket
l_int|4
)braket
suffix:semicolon
r_int
id|I
suffix:semicolon
r_int
r_int
id|Size
suffix:semicolon
singleline_comment|// Wait for any write/erase operation to settle
id|OldVal
op_assign
id|flread
c_func
(paren
id|base
)paren
suffix:semicolon
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|OldVal
op_ne
id|flread
c_func
(paren
id|base
)paren
op_logical_and
id|I
OL
l_int|10000
suffix:semicolon
id|I
op_increment
)paren
id|OldVal
op_assign
id|flread
c_func
(paren
id|base
)paren
suffix:semicolon
singleline_comment|// Reset the chip
id|flwrite
c_func
(paren
id|Reset
comma
l_int|0x555
)paren
suffix:semicolon
singleline_comment|// Send the sequence
id|flwrite
c_func
(paren
id|AutoSel1
comma
l_int|0x555
)paren
suffix:semicolon
id|flwrite
c_func
(paren
id|AutoSel2
comma
l_int|0x2AA
)paren
suffix:semicolon
id|flwrite
c_func
(paren
id|AutoSel3
comma
l_int|0x555
)paren
suffix:semicolon
singleline_comment|// Test #1, JEDEC numbers are readable from 0x??00/0x??01
r_if
c_cond
(paren
id|flread
c_func
(paren
l_int|0
)paren
op_ne
id|flread
c_func
(paren
l_int|0x100
)paren
op_logical_or
id|flread
c_func
(paren
l_int|1
)paren
op_ne
id|flread
c_func
(paren
l_int|0x101
)paren
)paren
(brace
id|flwrite
c_func
(paren
id|Reset
comma
l_int|0x555
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// Split up the JEDEC numbers
id|OldVal
op_assign
id|flread
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|I
op_ne
l_int|4
suffix:semicolon
id|I
op_increment
)paren
id|Mfg
(braket
id|I
)braket
op_assign
(paren
id|OldVal
op_rshift
(paren
id|I
op_star
l_int|8
)paren
)paren
suffix:semicolon
id|OldVal
op_assign
id|flread
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|I
op_ne
l_int|4
suffix:semicolon
id|I
op_increment
)paren
id|Id
(braket
id|I
)braket
op_assign
(paren
id|OldVal
op_rshift
(paren
id|I
op_star
l_int|8
)paren
)paren
suffix:semicolon
id|Size
op_assign
id|handle_jedecs
c_func
(paren
id|map
comma
id|Mfg
comma
id|Id
comma
l_int|4
comma
id|base
comma
id|priv
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Size
op_eq
l_int|0
)paren
(brace
id|flwrite
c_func
(paren
id|Reset
comma
l_int|0x555
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Check if there is address wrap around within a single bank, if this&n;      returns JEDEC numbers then we assume that it is wrap around. Notice&n;      we call this routine with the JEDEC return still enabled, if two or&n;      more flashes have a truncated address space the probe test will still&n;      work */
r_if
c_cond
(paren
id|base
op_plus
id|Size
op_plus
l_int|0x555
OL
id|map-&gt;size
op_logical_and
id|base
op_plus
id|Size
op_plus
l_int|0x555
OL
(paren
id|base
op_amp
(paren
op_complement
(paren
id|map-&gt;bank_size
op_minus
l_int|1
)paren
)paren
)paren
op_plus
id|map-&gt;bank_size
)paren
(brace
r_if
c_cond
(paren
id|flread
c_func
(paren
id|base
op_plus
id|Size
)paren
op_ne
id|flread
c_func
(paren
id|base
op_plus
id|Size
op_plus
l_int|0x100
)paren
op_logical_or
id|flread
c_func
(paren
id|base
op_plus
id|Size
op_plus
l_int|1
)paren
op_ne
id|flread
c_func
(paren
id|base
op_plus
id|Size
op_plus
l_int|0x101
)paren
)paren
(brace
id|jedec_probe32
c_func
(paren
id|map
comma
id|base
op_plus
id|Size
comma
id|priv
)paren
suffix:semicolon
)brace
)brace
singleline_comment|// Reset.
id|flwrite
c_func
(paren
l_int|0xF0F0F0F0
comma
l_int|0x555
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
DECL|macro|flread
macro_line|#undef flread
DECL|macro|flwrite
macro_line|#undef flwrite
)brace
multiline_comment|/* Linear read. */
DECL|function|jedec_read
r_static
r_int
id|jedec_read
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|map_info
op_star
id|map
op_assign
(paren
r_struct
id|map_info
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
id|map
op_member_access_from_pointer
id|copy_from
c_func
(paren
id|map
comma
id|buf
comma
id|from
comma
id|len
)paren
suffix:semicolon
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Banked read. Take special care to jump past the holes in the bank&n;   mapping. This version assumes symetry in the holes.. */
DECL|function|jedec_read_banked
r_static
r_int
id|jedec_read_banked
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|map_info
op_star
id|map
op_assign
(paren
r_struct
id|map_info
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|jedec_private
op_star
id|priv
op_assign
(paren
r_struct
id|jedec_private
op_star
)paren
id|map-&gt;fldrv_priv
suffix:semicolon
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
singleline_comment|// Determine what bank and offset into that bank the first byte is
r_int
r_int
id|bank
op_assign
id|from
op_amp
(paren
op_complement
(paren
id|priv-&gt;bank_fill
(braket
l_int|0
)braket
op_minus
l_int|1
)paren
)paren
suffix:semicolon
r_int
r_int
id|offset
op_assign
id|from
op_amp
(paren
id|priv-&gt;bank_fill
(braket
l_int|0
)braket
op_minus
l_int|1
)paren
suffix:semicolon
r_int
r_int
id|get
op_assign
id|len
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;bank_fill
(braket
l_int|0
)braket
op_minus
id|offset
OL
id|len
)paren
id|get
op_assign
id|priv-&gt;bank_fill
(braket
l_int|0
)braket
op_minus
id|offset
suffix:semicolon
id|bank
op_div_assign
id|priv-&gt;bank_fill
(braket
l_int|0
)braket
suffix:semicolon
id|map
op_member_access_from_pointer
id|copy_from
c_func
(paren
id|map
comma
id|buf
op_plus
op_star
id|retlen
comma
id|bank
op_star
id|map-&gt;bank_size
op_plus
id|offset
comma
id|get
)paren
suffix:semicolon
id|len
op_sub_assign
id|get
suffix:semicolon
op_star
id|retlen
op_add_assign
id|get
suffix:semicolon
id|from
op_add_assign
id|get
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Pass the flags value that the flash return before it re-entered read &n;   mode. */
DECL|function|jedec_flash_failed
r_static
r_void
id|jedec_flash_failed
c_func
(paren
r_int
r_char
id|code
)paren
(brace
multiline_comment|/* Bit 5 being high indicates that there was an internal device&n;      failure, erasure time limits exceeded or something */
r_if
c_cond
(paren
(paren
id|code
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mtd: Internal Flash failure&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;mtd: Programming didn&squot;t take&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* This uses the erasure function described in the AMD Flash Handbook, &n;   it will work for flashes with a fixed sector size only. Flashes with&n;   a selection of sector sizes (ie the AMD Am29F800B) will need a different&n;   routine. This routine tries to parallize erasing multiple chips/sectors &n;   where possible */
DECL|function|flash_erase
r_static
r_int
id|flash_erase
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
(brace
singleline_comment|// Does IO to the currently selected chip
DECL|macro|flread
mdefine_line|#define flread(x) map-&gt;read8(map,chip-&gt;base+((x)&lt;&lt;chip-&gt;addrshift))
DECL|macro|flwrite
mdefine_line|#define flwrite(v,x) map-&gt;write8(map,v,chip-&gt;base+((x)&lt;&lt;chip-&gt;addrshift))
r_int
r_int
id|Time
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|NoTime
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|start
op_assign
id|instr-&gt;addr
comma
id|len
op_assign
id|instr-&gt;len
suffix:semicolon
r_int
r_int
id|I
suffix:semicolon
r_struct
id|map_info
op_star
id|map
op_assign
(paren
r_struct
id|map_info
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|jedec_private
op_star
id|priv
op_assign
(paren
r_struct
id|jedec_private
op_star
)paren
id|map-&gt;fldrv_priv
suffix:semicolon
singleline_comment|// Verify the arguments..
r_if
c_cond
(paren
id|start
op_plus
id|len
OG
id|mtd-&gt;size
op_logical_or
(paren
id|start
op_mod
id|mtd-&gt;erasesize
)paren
op_ne
l_int|0
op_logical_or
(paren
id|len
op_mod
id|mtd-&gt;erasesize
)paren
op_ne
l_int|0
op_logical_or
(paren
id|len
op_div
id|mtd-&gt;erasesize
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|jedec_flash_chip_scan
c_func
(paren
id|priv
comma
id|start
comma
id|len
)paren
suffix:semicolon
singleline_comment|// Start the erase sequence on each chip
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
op_logical_and
id|I
OL
id|MAX_JEDEC_CHIPS
suffix:semicolon
id|I
op_increment
)paren
(brace
r_int
r_int
id|off
suffix:semicolon
r_struct
id|jedec_flash_chip
op_star
id|chip
op_assign
id|priv-&gt;chips
op_plus
id|I
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;length
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
singleline_comment|// Send the erase setup code
id|xprintf
c_func
(paren
l_string|&quot;Erase: &quot;
)paren
suffix:semicolon
id|puth
c_func
(paren
id|chip-&gt;start
)paren
suffix:semicolon
id|putc
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|puth
c_func
(paren
id|chip-&gt;base
)paren
suffix:semicolon
id|putc
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|puth
c_func
(paren
id|chip-&gt;length
)paren
suffix:semicolon
id|putc
c_func
(paren
l_char|&squot; &squot;
)paren
suffix:semicolon
id|puth
c_func
(paren
id|chip-&gt;sectorsize
)paren
suffix:semicolon
id|putc
c_func
(paren
l_char|&squot;&bslash;n&squot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;start
op_plus
id|chip-&gt;length
OG
id|chip-&gt;size
)paren
(brace
id|xprintf
c_func
(paren
l_string|&quot;DIE&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|flwrite
c_func
(paren
l_int|0xF0
comma
id|chip-&gt;start
op_plus
l_int|0x555
)paren
suffix:semicolon
id|flwrite
c_func
(paren
l_int|0xAA
comma
id|chip-&gt;start
op_plus
l_int|0x555
)paren
suffix:semicolon
id|flwrite
c_func
(paren
l_int|0x55
comma
id|chip-&gt;start
op_plus
l_int|0x2AA
)paren
suffix:semicolon
id|flwrite
c_func
(paren
l_int|0x80
comma
id|chip-&gt;start
op_plus
l_int|0x555
)paren
suffix:semicolon
id|flwrite
c_func
(paren
l_int|0xAA
comma
id|chip-&gt;start
op_plus
l_int|0x555
)paren
suffix:semicolon
id|flwrite
c_func
(paren
l_int|0x55
comma
id|chip-&gt;start
op_plus
l_int|0x2AA
)paren
suffix:semicolon
singleline_comment|// Use chip erase if possible
r_if
c_cond
(paren
id|chip-&gt;start
op_eq
l_int|0
op_logical_and
id|chip-&gt;length
op_eq
id|chip-&gt;size
)paren
(brace
id|flwrite
c_func
(paren
l_int|0x10
comma
l_int|0x555
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Once we start selecting the erase sectors the delay between each &n;         command must not exceed 50us or it will immediately start erasing &n;         and ignore the other sectors */
multiline_comment|/*    how do you portably turn off interrupts?&n;      save_flags(flags);&n;      cli();*/
r_for
c_loop
(paren
id|off
op_assign
l_int|0
suffix:semicolon
id|off
OL
id|chip-&gt;length
suffix:semicolon
id|off
op_add_assign
id|chip-&gt;sectorsize
)paren
(brace
singleline_comment|// Check to make sure we didn&squot;t timeout
id|flwrite
c_func
(paren
l_int|0x30
comma
id|chip-&gt;start
op_plus
id|off
)paren
suffix:semicolon
r_if
c_cond
(paren
id|off
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|flread
c_func
(paren
id|chip-&gt;start
op_plus
id|off
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|3
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mtd: Ack! We timed out the erase timer!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
singleline_comment|//      restore_flags(flags);
)brace
multiline_comment|/* We could split this into a timer routine and return early, performing&n;      background erasure.. Maybe later if the need warrents */
multiline_comment|/* Poll the flash for erasure completion, specs say this can take as long&n;      as 480 seconds to do all the sectors (for a 2 meg flash). &n;      Erasure time is dependant on chip age, temp and wear.. */
multiline_comment|/* This being a generic routine assumes a 32 bit bus. It does read32s&n;      and bundles interleved chips into the same grouping. This will work &n;      for all bus widths */
id|Time
op_assign
l_int|0
suffix:semicolon
id|NoTime
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
op_logical_and
id|I
OL
id|MAX_JEDEC_CHIPS
suffix:semicolon
id|I
op_increment
)paren
(brace
r_struct
id|jedec_flash_chip
op_star
id|chip
op_assign
id|priv-&gt;chips
op_plus
id|I
suffix:semicolon
r_int
r_int
id|off
op_assign
l_int|0
suffix:semicolon
r_int
id|todo
(braket
l_int|4
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|todo_left
op_assign
l_int|0
suffix:semicolon
r_int
id|J
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;length
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* Find all chips in this data line, realistically this is all &n;         or nothing up to the interleve count */
r_for
c_loop
(paren
id|J
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;chips
(braket
id|J
)braket
dot
id|jedec
op_ne
l_int|0
op_logical_and
id|J
OL
id|MAX_JEDEC_CHIPS
suffix:semicolon
id|J
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|priv-&gt;chips
(braket
id|J
)braket
dot
id|base
op_amp
(paren
op_complement
(paren
(paren
l_int|1
op_lshift
id|chip-&gt;addrshift
)paren
op_minus
l_int|1
)paren
)paren
)paren
op_eq
(paren
id|chip-&gt;base
op_amp
(paren
op_complement
(paren
(paren
l_int|1
op_lshift
id|chip-&gt;addrshift
)paren
op_minus
l_int|1
)paren
)paren
)paren
)paren
(brace
id|todo_left
op_increment
suffix:semicolon
id|todo
(braket
id|priv-&gt;chips
(braket
id|J
)braket
dot
id|base
op_amp
(paren
(paren
l_int|1
op_lshift
id|chip-&gt;addrshift
)paren
op_minus
l_int|1
)paren
)braket
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|xprintf
c_func
(paren
l_string|&quot;todo: %x %x %x %x&bslash;n&quot;
comma
(paren
r_int
)paren
id|todo
(braket
l_int|0
)braket
comma
(paren
r_int
)paren
id|todo
(braket
l_int|1
)braket
comma
(paren
r_int
)paren
id|todo
(braket
l_int|2
)braket
comma
(paren
r_int
)paren
id|todo
(braket
l_int|3
)braket
)paren
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|__u32
id|Last
(braket
l_int|4
)braket
suffix:semicolon
r_int
r_int
id|Count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* During erase bit 7 is held low and bit 6 toggles, we watch this,&n;&t;    should it stop toggling or go high then the erase is completed,&n;  &t;    or this is not really flash ;&gt; */
id|Last
(braket
l_int|0
)braket
op_assign
id|map
op_member_access_from_pointer
id|read32
c_func
(paren
id|map
comma
(paren
id|chip-&gt;base
op_rshift
id|chip-&gt;addrshift
)paren
op_plus
id|chip-&gt;start
op_plus
id|off
)paren
suffix:semicolon
id|Last
(braket
l_int|1
)braket
op_assign
id|map
op_member_access_from_pointer
id|read32
c_func
(paren
id|map
comma
(paren
id|chip-&gt;base
op_rshift
id|chip-&gt;addrshift
)paren
op_plus
id|chip-&gt;start
op_plus
id|off
)paren
suffix:semicolon
id|Last
(braket
l_int|2
)braket
op_assign
id|map
op_member_access_from_pointer
id|read32
c_func
(paren
id|map
comma
(paren
id|chip-&gt;base
op_rshift
id|chip-&gt;addrshift
)paren
op_plus
id|chip-&gt;start
op_plus
id|off
)paren
suffix:semicolon
id|Count
op_assign
l_int|3
suffix:semicolon
r_while
c_loop
(paren
id|todo_left
op_ne
l_int|0
)paren
(brace
r_for
c_loop
(paren
id|J
op_assign
l_int|0
suffix:semicolon
id|J
op_ne
l_int|4
suffix:semicolon
id|J
op_increment
)paren
(brace
id|__u8
id|Byte1
op_assign
(paren
id|Last
(braket
(paren
id|Count
op_minus
l_int|1
)paren
op_mod
l_int|4
)braket
op_rshift
(paren
id|J
op_star
l_int|8
)paren
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|__u8
id|Byte2
op_assign
(paren
id|Last
(braket
(paren
id|Count
op_minus
l_int|2
)paren
op_mod
l_int|4
)braket
op_rshift
(paren
id|J
op_star
l_int|8
)paren
)paren
op_amp
l_int|0xFF
suffix:semicolon
id|__u8
id|Byte3
op_assign
(paren
id|Last
(braket
(paren
id|Count
op_minus
l_int|3
)paren
op_mod
l_int|4
)braket
op_rshift
(paren
id|J
op_star
l_int|8
)paren
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|todo
(braket
id|J
)braket
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
id|Byte1
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
op_eq
l_int|0
op_logical_and
id|Byte1
op_ne
id|Byte2
)paren
(brace
singleline_comment|//&t;&t;  printk(&quot;Check %x %x %x&bslash;n&quot;,(short)J,(short)Byte1,(short)Byte2);
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|Byte1
op_eq
id|Byte2
)paren
(brace
id|jedec_flash_failed
c_func
(paren
id|Byte3
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|todo
(braket
id|J
)braket
op_assign
l_int|0
suffix:semicolon
id|todo_left
op_decrement
suffix:semicolon
)brace
multiline_comment|/*&t;    if (NoTime == 0)&n;&t;       Time += HZ/10 - schedule_timeout(HZ/10);*/
id|NoTime
op_assign
l_int|0
suffix:semicolon
id|Last
(braket
id|Count
op_mod
l_int|4
)braket
op_assign
id|map
op_member_access_from_pointer
id|read32
c_func
(paren
id|map
comma
(paren
id|chip-&gt;base
op_rshift
id|chip-&gt;addrshift
)paren
op_plus
id|chip-&gt;start
op_plus
id|off
)paren
suffix:semicolon
id|Count
op_increment
suffix:semicolon
id|putc
c_func
(paren
l_char|&squot;.&squot;
)paren
suffix:semicolon
multiline_comment|/*&t;    // Count time, max of 15s per sector (according to AMD)&n;&t;    if (Time &gt; 15*len/mtd-&gt;erasesize*HZ)&n;&t;    {&n;&t;       printk(&quot;mtd: Flash Erase Timed out&bslash;n&quot;);&n;&t;       return -EIO;&n;&t;    }&t;    */
)brace
id|puts
c_func
(paren
l_string|&quot;out&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Skip to the next chip if we used chip erase
r_if
c_cond
(paren
id|chip-&gt;length
op_eq
id|chip-&gt;size
)paren
id|off
op_assign
id|chip-&gt;size
suffix:semicolon
r_else
id|off
op_add_assign
id|chip-&gt;sectorsize
suffix:semicolon
r_if
c_cond
(paren
id|off
op_ge
id|chip-&gt;length
)paren
r_break
suffix:semicolon
id|NoTime
op_assign
l_int|1
suffix:semicolon
)brace
r_for
c_loop
(paren
id|J
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;chips
(braket
id|J
)braket
dot
id|jedec
op_ne
l_int|0
op_logical_and
id|J
OL
id|MAX_JEDEC_CHIPS
suffix:semicolon
id|J
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|priv-&gt;chips
(braket
id|J
)braket
dot
id|base
op_amp
(paren
op_complement
(paren
(paren
l_int|1
op_lshift
id|chip-&gt;addrshift
)paren
op_minus
l_int|1
)paren
)paren
)paren
op_eq
(paren
id|chip-&gt;base
op_amp
(paren
op_complement
(paren
(paren
l_int|1
op_lshift
id|chip-&gt;addrshift
)paren
op_minus
l_int|1
)paren
)paren
)paren
)paren
id|priv-&gt;chips
(braket
id|J
)braket
dot
id|length
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|puts
c_func
(paren
l_string|&quot;done&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
DECL|macro|flread
macro_line|#undef flread
DECL|macro|flwrite
macro_line|#undef flwrite
)brace
multiline_comment|/* This is the simple flash writing function. It writes to every byte, in&n;   sequence. It takes care of how to properly address the flash if&n;   the flash is interleved. It can only be used if all the chips in the &n;   array are identical!*/
DECL|function|flash_write
r_static
r_int
id|flash_write
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|start
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
multiline_comment|/* Does IO to the currently selected chip. It takes the bank addressing&n;      base (which is divisable by the chip size) adds the necesary lower bits&n;      of addrshift (interleve index) and then adds the control register index. */
DECL|macro|flread
mdefine_line|#define flread(x) map-&gt;read8(map,base+(off&amp;((1&lt;&lt;chip-&gt;addrshift)-1))+((x)&lt;&lt;chip-&gt;addrshift))
DECL|macro|flwrite
mdefine_line|#define flwrite(v,x) map-&gt;write8(map,v,base+(off&amp;((1&lt;&lt;chip-&gt;addrshift)-1))+((x)&lt;&lt;chip-&gt;addrshift))
r_struct
id|map_info
op_star
id|map
op_assign
(paren
r_struct
id|map_info
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|jedec_private
op_star
id|priv
op_assign
(paren
r_struct
id|jedec_private
op_star
)paren
id|map-&gt;fldrv_priv
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
r_int
id|off
suffix:semicolon
r_if
c_cond
(paren
id|start
op_plus
id|len
OG
id|mtd-&gt;size
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|puts
c_func
(paren
l_string|&quot;Here&quot;
)paren
suffix:semicolon
r_while
c_loop
(paren
id|len
op_ne
l_int|0
)paren
(brace
r_struct
id|jedec_flash_chip
op_star
id|chip
op_assign
id|priv-&gt;chips
suffix:semicolon
r_int
r_int
id|bank
suffix:semicolon
r_int
r_int
id|boffset
suffix:semicolon
singleline_comment|// Compute the base of the flash.
id|off
op_assign
id|start
op_mod
(paren
id|chip-&gt;size
op_lshift
id|chip-&gt;addrshift
)paren
suffix:semicolon
id|base
op_assign
id|start
op_minus
id|off
suffix:semicolon
singleline_comment|// Perform banked addressing translation.
id|bank
op_assign
id|base
op_amp
(paren
op_complement
(paren
id|priv-&gt;bank_fill
(braket
l_int|0
)braket
op_minus
l_int|1
)paren
)paren
suffix:semicolon
id|boffset
op_assign
id|base
op_amp
(paren
id|priv-&gt;bank_fill
(braket
l_int|0
)braket
op_minus
l_int|1
)paren
suffix:semicolon
id|bank
op_assign
(paren
id|bank
op_div
id|priv-&gt;bank_fill
(braket
l_int|0
)braket
)paren
op_star
id|map-&gt;bank_size
suffix:semicolon
id|base
op_assign
id|bank
op_plus
id|boffset
suffix:semicolon
id|xprintf
c_func
(paren
l_string|&quot;Flasing %X %X %X&bslash;n&quot;
comma
id|base
comma
id|chip-&gt;size
comma
id|len
)paren
suffix:semicolon
singleline_comment|// Loop over this page
r_for
c_loop
(paren
suffix:semicolon
id|off
op_ne
(paren
id|chip-&gt;size
op_lshift
id|chip-&gt;addrshift
)paren
op_logical_and
id|len
op_ne
l_int|0
suffix:semicolon
id|start
op_increment
comma
id|len
op_decrement
comma
id|off
op_increment
comma
id|buf
op_increment
)paren
(brace
r_int
r_char
id|oldbyte
op_assign
id|map
op_member_access_from_pointer
id|read8
c_func
(paren
id|map
comma
id|base
op_plus
id|off
)paren
suffix:semicolon
r_int
r_char
id|Last
(braket
l_int|4
)braket
suffix:semicolon
r_int
r_int
id|Count
op_assign
l_int|0
suffix:semicolon
singleline_comment|//&t; putc(&squot;.&squot;);
r_if
c_cond
(paren
id|oldbyte
op_eq
op_star
id|buf
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
op_complement
id|oldbyte
)paren
op_amp
op_star
id|buf
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;mtd: warn: Trying to set a 0 to a 1&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Write
id|flwrite
c_func
(paren
l_int|0xAA
comma
l_int|0x555
)paren
suffix:semicolon
id|flwrite
c_func
(paren
l_int|0x55
comma
l_int|0x2AA
)paren
suffix:semicolon
id|flwrite
c_func
(paren
l_int|0xA0
comma
l_int|0x555
)paren
suffix:semicolon
id|map
op_member_access_from_pointer
id|write8
c_func
(paren
id|map
comma
op_star
id|buf
comma
id|base
op_plus
id|off
)paren
suffix:semicolon
id|Last
(braket
l_int|0
)braket
op_assign
id|map
op_member_access_from_pointer
id|read8
c_func
(paren
id|map
comma
id|base
op_plus
id|off
)paren
suffix:semicolon
id|Last
(braket
l_int|1
)braket
op_assign
id|map
op_member_access_from_pointer
id|read8
c_func
(paren
id|map
comma
id|base
op_plus
id|off
)paren
suffix:semicolon
id|Last
(braket
l_int|2
)braket
op_assign
id|map
op_member_access_from_pointer
id|read8
c_func
(paren
id|map
comma
id|base
op_plus
id|off
)paren
suffix:semicolon
multiline_comment|/* Wait for the flash to finish the operation. We store the last 4&n;&t;    status bytes that have been retrieved so we can determine why&n;&t;    it failed. The toggle bits keep toggling when there is a &n;&t;    failure */
r_for
c_loop
(paren
id|Count
op_assign
l_int|3
suffix:semicolon
id|Last
(braket
(paren
id|Count
op_minus
l_int|1
)paren
op_mod
l_int|4
)braket
op_ne
id|Last
(braket
(paren
id|Count
op_minus
l_int|2
)paren
op_mod
l_int|4
)braket
op_logical_and
id|Count
OL
l_int|10000
suffix:semicolon
id|Count
op_increment
)paren
id|Last
(braket
id|Count
op_mod
l_int|4
)braket
op_assign
id|map
op_member_access_from_pointer
id|read8
c_func
(paren
id|map
comma
id|base
op_plus
id|off
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Last
(braket
(paren
id|Count
op_minus
l_int|1
)paren
op_mod
l_int|4
)braket
op_ne
op_star
id|buf
)paren
(brace
id|jedec_flash_failed
c_func
(paren
id|Last
(braket
(paren
id|Count
op_minus
l_int|3
)paren
op_mod
l_int|4
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
)brace
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* This is used to enhance the speed of the erase routine,&n;   when things are being done to multiple chips it is possible to&n;   parallize the operations, particularly full memory erases of multi&n;   chip memories benifit */
DECL|function|jedec_flash_chip_scan
r_static
r_void
id|jedec_flash_chip_scan
c_func
(paren
r_struct
id|jedec_private
op_star
id|priv
comma
r_int
r_int
id|start
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|I
suffix:semicolon
singleline_comment|// Zero the records
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
op_logical_and
id|I
OL
id|MAX_JEDEC_CHIPS
suffix:semicolon
id|I
op_increment
)paren
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|start
op_assign
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|length
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Intersect the region with each chip
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|priv-&gt;chips
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
op_logical_and
id|I
OL
id|MAX_JEDEC_CHIPS
suffix:semicolon
id|I
op_increment
)paren
(brace
r_struct
id|jedec_flash_chip
op_star
id|chip
op_assign
id|priv-&gt;chips
op_plus
id|I
suffix:semicolon
r_int
r_int
id|ByteStart
suffix:semicolon
r_int
r_int
id|ChipEndByte
op_assign
id|chip-&gt;offset
op_plus
(paren
id|chip-&gt;size
op_lshift
id|chip-&gt;addrshift
)paren
suffix:semicolon
singleline_comment|// End is before this chip or the start is after it
r_if
c_cond
(paren
id|start
op_plus
id|len
OL
id|chip-&gt;offset
op_logical_or
id|ChipEndByte
op_minus
(paren
l_int|1
op_lshift
id|chip-&gt;addrshift
)paren
OL
id|start
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|start
OL
id|chip-&gt;offset
)paren
(brace
id|ByteStart
op_assign
id|chip-&gt;offset
suffix:semicolon
id|chip-&gt;start
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|chip-&gt;start
op_assign
(paren
id|start
op_minus
id|chip-&gt;offset
op_plus
(paren
l_int|1
op_lshift
id|chip-&gt;addrshift
)paren
op_minus
l_int|1
)paren
op_rshift
id|chip-&gt;addrshift
suffix:semicolon
id|ByteStart
op_assign
id|start
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start
op_plus
id|len
op_ge
id|ChipEndByte
)paren
id|chip-&gt;length
op_assign
(paren
id|ChipEndByte
op_minus
id|ByteStart
)paren
op_rshift
id|chip-&gt;addrshift
suffix:semicolon
r_else
id|chip-&gt;length
op_assign
(paren
id|start
op_plus
id|len
op_minus
id|ByteStart
op_plus
(paren
l_int|1
op_lshift
id|chip-&gt;addrshift
)paren
op_minus
l_int|1
)paren
op_rshift
id|chip-&gt;addrshift
suffix:semicolon
)brace
)brace
multiline_comment|/*}}}*/
eof
