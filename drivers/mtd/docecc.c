multiline_comment|/*&n; * ECC algorithm for M-systems disk on chip. We use the excellent Reed&n; * Solmon code of Phil Karn (karn@ka9q.ampr.org) available under the&n; * GNU GPL License. The rest is simply to convert the disk on chip&n; * syndrom into a standard syndom.&n; *&n; * Author: Fabrice Bellard (fabrice.bellard@netgem.com) &n; * Copyright (C) 2000 Netgem S.A.&n; *&n; * $Id: docecc.c,v 1.1 2000/11/03 12:43:43 dwmw2 Exp $&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/doc2000.h&gt;
multiline_comment|/* need to undef it (from asm/termbits.h) */
DECL|macro|B0
macro_line|#undef B0
DECL|macro|MM
mdefine_line|#define MM 10 /* Symbol size in bits */
DECL|macro|KK
mdefine_line|#define KK (1023-4) /* Number of data symbols per block */
DECL|macro|B0
mdefine_line|#define B0 510 /* First root of generator polynomial, alpha form */
DECL|macro|PRIM
mdefine_line|#define PRIM 1 /* power of alpha used to generate roots of generator poly */
DECL|macro|NN
mdefine_line|#define&t;NN ((1 &lt;&lt; MM) - 1)
DECL|typedef|dtype
r_typedef
r_int
r_int
id|dtype
suffix:semicolon
multiline_comment|/* 1+x^3+x^10 */
DECL|variable|Pp
r_static
r_const
r_int
id|Pp
(braket
id|MM
op_plus
l_int|1
)braket
op_assign
(brace
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
)brace
suffix:semicolon
multiline_comment|/* This defines the type used to store an element of the Galois Field&n; * used by the code. Make sure this is something larger than a char if&n; * if anything larger than GF(256) is used.&n; *&n; * Note: unsigned char will work up to GF(256) but int seems to run&n; * faster on the Pentium.&n; */
DECL|typedef|gf
r_typedef
r_int
id|gf
suffix:semicolon
multiline_comment|/* No legal value in index form represents zero, so&n; * we need a special value for this purpose&n; */
DECL|macro|A0
mdefine_line|#define A0&t;(NN)
multiline_comment|/* Compute x % NN, where NN is 2**MM - 1,&n; * without a slow divide&n; */
r_static
r_inline
id|gf
DECL|function|modnn
id|modnn
c_func
(paren
r_int
id|x
)paren
(brace
r_while
c_loop
(paren
id|x
op_ge
id|NN
)paren
(brace
id|x
op_sub_assign
id|NN
suffix:semicolon
id|x
op_assign
(paren
id|x
op_rshift
id|MM
)paren
op_plus
(paren
id|x
op_amp
id|NN
)paren
suffix:semicolon
)brace
r_return
id|x
suffix:semicolon
)brace
DECL|macro|min
mdefine_line|#define&t;min(a,b)&t;((a) &lt; (b) ? (a) : (b))
DECL|macro|CLEAR
mdefine_line|#define&t;CLEAR(a,n) {&bslash;&n;int ci;&bslash;&n;for(ci=(n)-1;ci &gt;=0;ci--)&bslash;&n;(a)[ci] = 0;&bslash;&n;}
DECL|macro|COPY
mdefine_line|#define&t;COPY(a,b,n) {&bslash;&n;int ci;&bslash;&n;for(ci=(n)-1;ci &gt;=0;ci--)&bslash;&n;(a)[ci] = (b)[ci];&bslash;&n;}
DECL|macro|COPYDOWN
mdefine_line|#define&t;COPYDOWN(a,b,n) {&bslash;&n;int ci;&bslash;&n;for(ci=(n)-1;ci &gt;=0;ci--)&bslash;&n;(a)[ci] = (b)[ci];&bslash;&n;}
DECL|macro|Ldec
mdefine_line|#define Ldec 1
multiline_comment|/* generate GF(2**m) from the irreducible polynomial p(X) in Pp[0]..Pp[m]&n;   lookup tables:  index-&gt;polynomial form   alpha_to[] contains j=alpha**i;&n;                   polynomial form -&gt; index form  index_of[j=alpha**i] = i&n;   alpha=2 is the primitive element of GF(2**m)&n;   HARI&squot;s COMMENT: (4/13/94) alpha_to[] can be used as follows:&n;        Let @ represent the primitive element commonly called &quot;alpha&quot; that&n;   is the root of the primitive polynomial p(x). Then in GF(2^m), for any&n;   0 &lt;= i &lt;= 2^m-2,&n;        @^i = a(0) + a(1) @ + a(2) @^2 + ... + a(m-1) @^(m-1)&n;   where the binary vector (a(0),a(1),a(2),...,a(m-1)) is the representation&n;   of the integer &quot;alpha_to[i]&quot; with a(0) being the LSB and a(m-1) the MSB. Thus for&n;   example the polynomial representation of @^5 would be given by the binary&n;   representation of the integer &quot;alpha_to[5]&quot;.&n;                   Similarily, index_of[] can be used as follows:&n;        As above, let @ represent the primitive element of GF(2^m) that is&n;   the root of the primitive polynomial p(x). In order to find the power&n;   of @ (alpha) that has the polynomial representation&n;        a(0) + a(1) @ + a(2) @^2 + ... + a(m-1) @^(m-1)&n;   we consider the integer &quot;i&quot; whose binary representation with a(0) being LSB&n;   and a(m-1) MSB is (a(0),a(1),...,a(m-1)) and locate the entry&n;   &quot;index_of[i]&quot;. Now, @^index_of[i] is that element whose polynomial &n;    representation is (a(0),a(1),a(2),...,a(m-1)).&n;   NOTE:&n;        The element alpha_to[2^m-1] = 0 always signifying that the&n;   representation of &quot;@^infinity&quot; = 0 is (0,0,0,...,0).&n;        Similarily, the element index_of[0] = A0 always signifying&n;   that the power of alpha which has the polynomial representation&n;   (0,0,...,0) is &quot;infinity&quot;.&n; &n;*/
r_static
r_void
DECL|function|generate_gf
id|generate_gf
c_func
(paren
id|dtype
id|Alpha_to
(braket
id|NN
op_plus
l_int|1
)braket
comma
id|dtype
id|Index_of
(braket
id|NN
op_plus
l_int|1
)braket
)paren
(brace
r_register
r_int
id|i
comma
id|mask
suffix:semicolon
id|mask
op_assign
l_int|1
suffix:semicolon
id|Alpha_to
(braket
id|MM
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MM
suffix:semicolon
id|i
op_increment
)paren
(brace
id|Alpha_to
(braket
id|i
)braket
op_assign
id|mask
suffix:semicolon
id|Index_of
(braket
id|Alpha_to
(braket
id|i
)braket
)braket
op_assign
id|i
suffix:semicolon
multiline_comment|/* If Pp[i] == 1 then, term @^i occurs in poly-repr of @^MM */
r_if
c_cond
(paren
id|Pp
(braket
id|i
)braket
op_ne
l_int|0
)paren
id|Alpha_to
(braket
id|MM
)braket
op_xor_assign
id|mask
suffix:semicolon
multiline_comment|/* Bit-wise EXOR operation */
id|mask
op_lshift_assign
l_int|1
suffix:semicolon
multiline_comment|/* single left-shift */
)brace
id|Index_of
(braket
id|Alpha_to
(braket
id|MM
)braket
)braket
op_assign
id|MM
suffix:semicolon
multiline_comment|/*&n;   * Have obtained poly-repr of @^MM. Poly-repr of @^(i+1) is given by&n;   * poly-repr of @^i shifted left one-bit and accounting for any @^MM&n;   * term that may occur when poly-repr of @^i is shifted.&n;   */
id|mask
op_rshift_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|MM
op_plus
l_int|1
suffix:semicolon
id|i
OL
id|NN
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|Alpha_to
(braket
id|i
op_minus
l_int|1
)braket
op_ge
id|mask
)paren
id|Alpha_to
(braket
id|i
)braket
op_assign
id|Alpha_to
(braket
id|MM
)braket
op_xor
(paren
(paren
id|Alpha_to
(braket
id|i
op_minus
l_int|1
)braket
op_xor
id|mask
)paren
op_lshift
l_int|1
)paren
suffix:semicolon
r_else
id|Alpha_to
(braket
id|i
)braket
op_assign
id|Alpha_to
(braket
id|i
op_minus
l_int|1
)braket
op_lshift
l_int|1
suffix:semicolon
id|Index_of
(braket
id|Alpha_to
(braket
id|i
)braket
)braket
op_assign
id|i
suffix:semicolon
)brace
id|Index_of
(braket
l_int|0
)braket
op_assign
id|A0
suffix:semicolon
id|Alpha_to
(braket
id|NN
)braket
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Performs ERRORS+ERASURES decoding of RS codes. bb[] is the content&n; * of the feedback shift register after having processed the data and&n; * the ECC.&n; *&n; * Return number of symbols corrected, or -1 if codeword is illegal&n; * or uncorrectable. If eras_pos is non-null, the detected error locations&n; * are written back. NOTE! This array must be at least NN-KK elements long.&n; * The corrected data are written in eras_val[]. They must be xor with the data&n; * to retrieve the correct data : data[erase_pos[i]] ^= erase_val[i] .&n; * &n; * First &quot;no_eras&quot; erasures are declared by the calling program. Then, the&n; * maximum # of errors correctable is t_after_eras = floor((NN-KK-no_eras)/2).&n; * If the number of channel errors is not greater than &quot;t_after_eras&quot; the&n; * transmitted codeword will be recovered. Details of algorithm can be found&n; * in R. Blahut&squot;s &quot;Theory ... of Error-Correcting Codes&quot;.&n;&n; * Warning: the eras_pos[] array must not contain duplicate entries; decoder failure&n; * will result. The decoder *could* check for this condition, but it would involve&n; * extra time on every decoding operation.&n; * */
r_static
r_int
DECL|function|eras_dec_rs
id|eras_dec_rs
c_func
(paren
id|dtype
id|Alpha_to
(braket
id|NN
op_plus
l_int|1
)braket
comma
id|dtype
id|Index_of
(braket
id|NN
op_plus
l_int|1
)braket
comma
id|gf
id|bb
(braket
id|NN
op_minus
id|KK
op_plus
l_int|1
)braket
comma
id|gf
id|eras_val
(braket
id|NN
op_minus
id|KK
)braket
comma
r_int
id|eras_pos
(braket
id|NN
op_minus
id|KK
)braket
comma
r_int
id|no_eras
)paren
(brace
r_int
id|deg_lambda
comma
id|el
comma
id|deg_omega
suffix:semicolon
r_int
id|i
comma
id|j
comma
id|r
comma
id|k
suffix:semicolon
id|gf
id|u
comma
id|q
comma
id|tmp
comma
id|num1
comma
id|num2
comma
id|den
comma
id|discr_r
suffix:semicolon
id|gf
id|lambda
(braket
id|NN
op_minus
id|KK
op_plus
l_int|1
)braket
comma
id|s
(braket
id|NN
op_minus
id|KK
op_plus
l_int|1
)braket
suffix:semicolon
multiline_comment|/* Err+Eras Locator poly&n;&t;&t;&t;&t;&t; * and syndrome poly */
id|gf
id|b
(braket
id|NN
op_minus
id|KK
op_plus
l_int|1
)braket
comma
id|t
(braket
id|NN
op_minus
id|KK
op_plus
l_int|1
)braket
comma
id|omega
(braket
id|NN
op_minus
id|KK
op_plus
l_int|1
)braket
suffix:semicolon
id|gf
id|root
(braket
id|NN
op_minus
id|KK
)braket
comma
id|reg
(braket
id|NN
op_minus
id|KK
op_plus
l_int|1
)braket
comma
id|loc
(braket
id|NN
op_minus
id|KK
)braket
suffix:semicolon
r_int
id|syn_error
comma
id|count
suffix:semicolon
id|syn_error
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NN
op_minus
id|KK
suffix:semicolon
id|i
op_increment
)paren
(brace
id|syn_error
op_or_assign
id|bb
(braket
id|i
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|syn_error
)paren
(brace
multiline_comment|/* if remainder is zero, data[] is a codeword and there are no&n;     * errors to correct. So return data[] unmodified&n;     */
id|count
op_assign
l_int|0
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|NN
op_minus
id|KK
suffix:semicolon
id|i
op_increment
)paren
(brace
id|s
(braket
id|i
)braket
op_assign
id|bb
(braket
l_int|0
)braket
suffix:semicolon
)brace
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
OL
id|NN
op_minus
id|KK
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|bb
(braket
id|j
)braket
op_eq
l_int|0
)paren
(brace
r_continue
suffix:semicolon
)brace
id|tmp
op_assign
id|Index_of
(braket
id|bb
(braket
id|j
)braket
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|NN
op_minus
id|KK
suffix:semicolon
id|i
op_increment
)paren
(brace
id|s
(braket
id|i
)braket
op_xor_assign
id|Alpha_to
(braket
id|modnn
c_func
(paren
id|tmp
op_plus
(paren
id|B0
op_plus
id|i
op_minus
l_int|1
)paren
op_star
id|PRIM
op_star
id|j
)paren
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/* undo the feedback register implicit multiplication and convert&n;     syndromes to index form */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|NN
op_minus
id|KK
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
id|Index_of
(braket
id|s
(braket
id|i
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ne
id|A0
)paren
id|tmp
op_assign
id|modnn
c_func
(paren
id|tmp
op_plus
l_int|2
op_star
id|KK
op_star
(paren
id|B0
op_plus
id|i
op_minus
l_int|1
)paren
op_star
id|PRIM
)paren
suffix:semicolon
id|s
(braket
id|i
)braket
op_assign
id|tmp
suffix:semicolon
)brace
id|CLEAR
c_func
(paren
op_amp
id|lambda
(braket
l_int|1
)braket
comma
id|NN
op_minus
id|KK
)paren
suffix:semicolon
id|lambda
(braket
l_int|0
)braket
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|no_eras
OG
l_int|0
)paren
(brace
multiline_comment|/* Init lambda to be the erasure locator polynomial */
id|lambda
(braket
l_int|1
)braket
op_assign
id|Alpha_to
(braket
id|modnn
c_func
(paren
id|PRIM
op_star
id|eras_pos
(braket
l_int|0
)braket
)paren
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|no_eras
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u
op_assign
id|modnn
c_func
(paren
id|PRIM
op_star
id|eras_pos
(braket
id|i
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|i
op_plus
l_int|1
suffix:semicolon
id|j
OG
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
id|tmp
op_assign
id|Index_of
(braket
id|lambda
(braket
id|j
op_minus
l_int|1
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
id|tmp
op_ne
id|A0
)paren
(brace
id|lambda
(braket
id|j
)braket
op_xor_assign
id|Alpha_to
(braket
id|modnn
c_func
(paren
id|u
op_plus
id|tmp
)paren
)braket
suffix:semicolon
)brace
)brace
)brace
macro_line|#if DEBUG &gt;= 1
multiline_comment|/* Test code that verifies the erasure locator polynomial just constructed&n;       Needed only for decoder debugging. */
multiline_comment|/* find roots of the erasure location polynomial */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|no_eras
suffix:semicolon
id|i
op_increment
)paren
(brace
id|reg
(braket
id|i
)braket
op_assign
id|Index_of
(braket
id|lambda
(braket
id|i
)braket
)braket
suffix:semicolon
)brace
id|count
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|k
op_assign
id|NN
op_minus
id|Ldec
suffix:semicolon
id|i
op_le
id|NN
suffix:semicolon
id|i
op_increment
comma
id|k
op_assign
id|modnn
c_func
(paren
id|NN
op_plus
id|k
op_minus
id|Ldec
)paren
)paren
(brace
id|q
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|1
suffix:semicolon
id|j
op_le
id|no_eras
suffix:semicolon
id|j
op_increment
)paren
r_if
c_cond
(paren
id|reg
(braket
id|j
)braket
op_ne
id|A0
)paren
(brace
id|reg
(braket
id|j
)braket
op_assign
id|modnn
c_func
(paren
id|reg
(braket
id|j
)braket
op_plus
id|j
)paren
suffix:semicolon
id|q
op_xor_assign
id|Alpha_to
(braket
id|reg
(braket
id|j
)braket
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|q
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* store root and error location number indices */
id|root
(braket
id|count
)braket
op_assign
id|i
suffix:semicolon
id|loc
(braket
id|count
)braket
op_assign
id|k
suffix:semicolon
id|count
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
id|count
op_ne
id|no_eras
)paren
(brace
id|printf
c_func
(paren
l_string|&quot;&bslash;n lambda(x) is WRONG&bslash;n&quot;
)paren
suffix:semicolon
id|count
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
macro_line|#if DEBUG &gt;= 2
id|printf
c_func
(paren
l_string|&quot;&bslash;n Erasure positions as determined by roots of Eras Loc Poly:&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
id|printf
c_func
(paren
l_string|&quot;%d &quot;
comma
id|loc
(braket
id|i
)braket
)paren
suffix:semicolon
id|printf
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#endif
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NN
op_minus
id|KK
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|b
(braket
id|i
)braket
op_assign
id|Index_of
(braket
id|lambda
(braket
id|i
)braket
)braket
suffix:semicolon
)brace
multiline_comment|/*&n;   * Begin Berlekamp-Massey algorithm to determine error+erasure&n;   * locator polynomial&n;   */
id|r
op_assign
id|no_eras
suffix:semicolon
id|el
op_assign
id|no_eras
suffix:semicolon
r_while
c_loop
(paren
op_increment
id|r
op_le
id|NN
op_minus
id|KK
)paren
(brace
multiline_comment|/* r is the step number */
multiline_comment|/* Compute discrepancy at the r-th step in poly-form */
id|discr_r
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|r
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|lambda
(braket
id|i
)braket
op_ne
l_int|0
)paren
op_logical_and
(paren
id|s
(braket
id|r
op_minus
id|i
)braket
op_ne
id|A0
)paren
)paren
(brace
id|discr_r
op_xor_assign
id|Alpha_to
(braket
id|modnn
c_func
(paren
id|Index_of
(braket
id|lambda
(braket
id|i
)braket
)braket
op_plus
id|s
(braket
id|r
op_minus
id|i
)braket
)paren
)braket
suffix:semicolon
)brace
)brace
id|discr_r
op_assign
id|Index_of
(braket
id|discr_r
)braket
suffix:semicolon
multiline_comment|/* Index form */
r_if
c_cond
(paren
id|discr_r
op_eq
id|A0
)paren
(brace
multiline_comment|/* 2 lines below: B(x) &lt;-- x*B(x) */
id|COPYDOWN
c_func
(paren
op_amp
id|b
(braket
l_int|1
)braket
comma
id|b
comma
id|NN
op_minus
id|KK
)paren
suffix:semicolon
id|b
(braket
l_int|0
)braket
op_assign
id|A0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 7 lines below: T(x) &lt;-- lambda(x) - discr_r*x*b(x) */
id|t
(braket
l_int|0
)braket
op_assign
id|lambda
(braket
l_int|0
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NN
op_minus
id|KK
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|b
(braket
id|i
)braket
op_ne
id|A0
)paren
(brace
id|t
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|lambda
(braket
id|i
op_plus
l_int|1
)braket
op_xor
id|Alpha_to
(braket
id|modnn
c_func
(paren
id|discr_r
op_plus
id|b
(braket
id|i
)braket
)paren
)braket
suffix:semicolon
)brace
r_else
id|t
(braket
id|i
op_plus
l_int|1
)braket
op_assign
id|lambda
(braket
id|i
op_plus
l_int|1
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
l_int|2
op_star
id|el
op_le
id|r
op_plus
id|no_eras
op_minus
l_int|1
)paren
(brace
id|el
op_assign
id|r
op_plus
id|no_eras
op_minus
id|el
suffix:semicolon
multiline_comment|/*&n;&t; * 2 lines below: B(x) &lt;-- inv(discr_r) *&n;&t; * lambda(x)&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|NN
op_minus
id|KK
suffix:semicolon
id|i
op_increment
)paren
id|b
(braket
id|i
)braket
op_assign
(paren
id|lambda
(braket
id|i
)braket
op_eq
l_int|0
)paren
ques
c_cond
id|A0
suffix:colon
id|modnn
c_func
(paren
id|Index_of
(braket
id|lambda
(braket
id|i
)braket
)braket
op_minus
id|discr_r
op_plus
id|NN
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* 2 lines below: B(x) &lt;-- x*B(x) */
id|COPYDOWN
c_func
(paren
op_amp
id|b
(braket
l_int|1
)braket
comma
id|b
comma
id|NN
op_minus
id|KK
)paren
suffix:semicolon
id|b
(braket
l_int|0
)braket
op_assign
id|A0
suffix:semicolon
)brace
id|COPY
c_func
(paren
id|lambda
comma
id|t
comma
id|NN
op_minus
id|KK
op_plus
l_int|1
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Convert lambda to index form and compute deg(lambda(x)) */
id|deg_lambda
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NN
op_minus
id|KK
op_plus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
id|lambda
(braket
id|i
)braket
op_assign
id|Index_of
(braket
id|lambda
(braket
id|i
)braket
)braket
suffix:semicolon
r_if
c_cond
(paren
id|lambda
(braket
id|i
)braket
op_ne
id|A0
)paren
(brace
id|deg_lambda
op_assign
id|i
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;   * Find roots of the error+erasure locator polynomial by Chien&n;   * Search&n;   */
id|COPY
c_func
(paren
op_amp
id|reg
(braket
l_int|1
)braket
comma
op_amp
id|lambda
(braket
l_int|1
)braket
comma
id|NN
op_minus
id|KK
)paren
suffix:semicolon
id|count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Number of roots of lambda(x) */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
comma
id|k
op_assign
id|NN
op_minus
id|Ldec
suffix:semicolon
id|i
op_le
id|NN
suffix:semicolon
id|i
op_increment
comma
id|k
op_assign
id|modnn
c_func
(paren
id|NN
op_plus
id|k
op_minus
id|Ldec
)paren
)paren
(brace
id|q
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
id|deg_lambda
suffix:semicolon
id|j
OG
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|reg
(braket
id|j
)braket
op_ne
id|A0
)paren
(brace
id|reg
(braket
id|j
)braket
op_assign
id|modnn
c_func
(paren
id|reg
(braket
id|j
)braket
op_plus
id|j
)paren
suffix:semicolon
id|q
op_xor_assign
id|Alpha_to
(braket
id|reg
(braket
id|j
)braket
)braket
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|q
op_ne
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* store root (index-form) and error location number */
id|root
(braket
id|count
)braket
op_assign
id|i
suffix:semicolon
id|loc
(braket
id|count
)braket
op_assign
id|k
suffix:semicolon
multiline_comment|/* If we&squot;ve already found max possible roots,&n;     * abort the search to save time&n;     */
r_if
c_cond
(paren
op_increment
id|count
op_eq
id|deg_lambda
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|deg_lambda
op_ne
id|count
)paren
(brace
multiline_comment|/*&n;     * deg(lambda) unequal to number of roots =&gt; uncorrectable&n;     * error detected&n;     */
id|count
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
multiline_comment|/*&n;   * Compute err+eras evaluator poly omega(x) = s(x)*lambda(x) (modulo&n;   * x**(NN-KK)). in index form. Also find deg(omega).&n;   */
id|deg_omega
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|NN
op_minus
id|KK
suffix:semicolon
id|i
op_increment
)paren
(brace
id|tmp
op_assign
l_int|0
suffix:semicolon
id|j
op_assign
(paren
id|deg_lambda
OL
id|i
)paren
ques
c_cond
id|deg_lambda
suffix:colon
id|i
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
r_if
c_cond
(paren
(paren
id|s
(braket
id|i
op_plus
l_int|1
op_minus
id|j
)braket
op_ne
id|A0
)paren
op_logical_and
(paren
id|lambda
(braket
id|j
)braket
op_ne
id|A0
)paren
)paren
id|tmp
op_xor_assign
id|Alpha_to
(braket
id|modnn
c_func
(paren
id|s
(braket
id|i
op_plus
l_int|1
op_minus
id|j
)braket
op_plus
id|lambda
(braket
id|j
)braket
)paren
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|tmp
op_ne
l_int|0
)paren
(brace
id|deg_omega
op_assign
id|i
suffix:semicolon
)brace
id|omega
(braket
id|i
)braket
op_assign
id|Index_of
(braket
id|tmp
)braket
suffix:semicolon
)brace
id|omega
(braket
id|NN
op_minus
id|KK
)braket
op_assign
id|A0
suffix:semicolon
multiline_comment|/*&n;   * Compute error values in poly-form. num1 = omega(inv(X(l))), num2 =&n;   * inv(X(l))**(B0-1) and den = lambda_pr(inv(X(l))) all in poly-form&n;   */
r_for
c_loop
(paren
id|j
op_assign
id|count
op_minus
l_int|1
suffix:semicolon
id|j
op_ge
l_int|0
suffix:semicolon
id|j
op_decrement
)paren
(brace
id|num1
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|deg_omega
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|omega
(braket
id|i
)braket
op_ne
id|A0
)paren
id|num1
op_xor_assign
id|Alpha_to
(braket
id|modnn
c_func
(paren
id|omega
(braket
id|i
)braket
op_plus
id|i
op_star
id|root
(braket
id|j
)braket
)paren
)braket
suffix:semicolon
)brace
id|num2
op_assign
id|Alpha_to
(braket
id|modnn
c_func
(paren
id|root
(braket
id|j
)braket
op_star
(paren
id|B0
op_minus
l_int|1
)paren
op_plus
id|NN
)paren
)braket
suffix:semicolon
id|den
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* lambda[i+1] for i even is the formal derivative lambda_pr of lambda[i] */
r_for
c_loop
(paren
id|i
op_assign
id|min
c_func
(paren
id|deg_lambda
comma
id|NN
op_minus
id|KK
op_minus
l_int|1
)paren
op_amp
op_complement
l_int|1
suffix:semicolon
id|i
op_ge
l_int|0
suffix:semicolon
id|i
op_sub_assign
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|lambda
(braket
id|i
op_plus
l_int|1
)braket
op_ne
id|A0
)paren
(brace
id|den
op_xor_assign
id|Alpha_to
(braket
id|modnn
c_func
(paren
id|lambda
(braket
id|i
op_plus
l_int|1
)braket
op_plus
id|i
op_star
id|root
(braket
id|j
)braket
)paren
)braket
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|den
op_eq
l_int|0
)paren
(brace
macro_line|#if DEBUG &gt;= 1
id|printf
c_func
(paren
l_string|&quot;&bslash;n ERROR: denominator = 0&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Convert to dual- basis */
id|count
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|finish
suffix:semicolon
)brace
multiline_comment|/* Apply error to data */
r_if
c_cond
(paren
id|num1
op_ne
l_int|0
)paren
(brace
id|eras_val
(braket
id|j
)braket
op_assign
id|Alpha_to
(braket
id|modnn
c_func
(paren
id|Index_of
(braket
id|num1
)braket
op_plus
id|Index_of
(braket
id|num2
)braket
op_plus
id|NN
op_minus
id|Index_of
(braket
id|den
)braket
)paren
)braket
suffix:semicolon
)brace
r_else
(brace
id|eras_val
(braket
id|j
)braket
op_assign
l_int|0
suffix:semicolon
)brace
)brace
id|finish
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|eras_pos
(braket
id|i
)braket
op_assign
id|loc
(braket
id|i
)braket
suffix:semicolon
)brace
r_return
id|count
suffix:semicolon
)brace
multiline_comment|/***************************************************************************/
multiline_comment|/* The DOC specific code begins here */
DECL|macro|SECTOR_SIZE
mdefine_line|#define SECTOR_SIZE 512
multiline_comment|/* The sector bytes are packed into NB_DATA MM bits words */
DECL|macro|NB_DATA
mdefine_line|#define NB_DATA (((SECTOR_SIZE + 1) * 8 + 6) / MM)
multiline_comment|/* &n; * Correct the errors in &squot;sector[]&squot; by using &squot;ecc1[]&squot; which is the&n; * content of the feedback shift register applyied to the sector and&n; * the ECC. Return the number of errors corrected (and correct them in&n; * sector), or -1 if error &n; */
DECL|function|doc_decode_ecc
r_int
id|doc_decode_ecc
c_func
(paren
r_int
r_char
id|sector
(braket
id|SECTOR_SIZE
)braket
comma
r_int
r_char
id|ecc1
(braket
l_int|6
)braket
)paren
(brace
r_int
id|parity
comma
id|i
comma
id|nb_errors
suffix:semicolon
id|gf
id|bb
(braket
id|NN
op_minus
id|KK
op_plus
l_int|1
)braket
suffix:semicolon
id|gf
id|error_val
(braket
id|NN
op_minus
id|KK
)braket
suffix:semicolon
r_int
id|error_pos
(braket
id|NN
op_minus
id|KK
)braket
comma
id|pos
comma
id|bitpos
comma
id|index
comma
id|val
suffix:semicolon
id|dtype
op_star
id|Alpha_to
comma
op_star
id|Index_of
suffix:semicolon
multiline_comment|/* init log and exp tables here to save memory. However, it is slower */
id|Alpha_to
op_assign
id|kmalloc
c_func
(paren
(paren
id|NN
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|dtype
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Alpha_to
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|Index_of
op_assign
id|kmalloc
c_func
(paren
(paren
id|NN
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
id|dtype
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|Index_of
)paren
(brace
id|kfree
c_func
(paren
id|Alpha_to
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|generate_gf
c_func
(paren
id|Alpha_to
comma
id|Index_of
)paren
suffix:semicolon
id|parity
op_assign
id|ecc1
(braket
l_int|1
)braket
suffix:semicolon
id|bb
(braket
l_int|0
)braket
op_assign
(paren
id|ecc1
(braket
l_int|4
)braket
op_amp
l_int|0xff
)paren
op_or
(paren
(paren
id|ecc1
(braket
l_int|5
)braket
op_amp
l_int|0x03
)paren
op_lshift
l_int|8
)paren
suffix:semicolon
id|bb
(braket
l_int|1
)braket
op_assign
(paren
(paren
id|ecc1
(braket
l_int|5
)braket
op_amp
l_int|0xfc
)paren
op_rshift
l_int|2
)paren
op_or
(paren
(paren
id|ecc1
(braket
l_int|2
)braket
op_amp
l_int|0x0f
)paren
op_lshift
l_int|6
)paren
suffix:semicolon
id|bb
(braket
l_int|2
)braket
op_assign
(paren
(paren
id|ecc1
(braket
l_int|2
)braket
op_amp
l_int|0xf0
)paren
op_rshift
l_int|4
)paren
op_or
(paren
(paren
id|ecc1
(braket
l_int|3
)braket
op_amp
l_int|0x3f
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
id|bb
(braket
l_int|3
)braket
op_assign
(paren
(paren
id|ecc1
(braket
l_int|3
)braket
op_amp
l_int|0xc0
)paren
op_rshift
l_int|6
)paren
op_or
(paren
(paren
id|ecc1
(braket
l_int|0
)braket
op_amp
l_int|0xff
)paren
op_lshift
l_int|2
)paren
suffix:semicolon
id|nb_errors
op_assign
id|eras_dec_rs
c_func
(paren
id|Alpha_to
comma
id|Index_of
comma
id|bb
comma
id|error_val
comma
id|error_pos
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nb_errors
op_le
l_int|0
)paren
r_goto
id|the_end
suffix:semicolon
multiline_comment|/* correct the errors */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nb_errors
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pos
op_assign
id|error_pos
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pos
op_ge
id|NB_DATA
op_logical_and
id|pos
OL
id|KK
)paren
(brace
id|nb_errors
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|the_end
suffix:semicolon
)brace
r_if
c_cond
(paren
id|pos
OL
id|NB_DATA
)paren
(brace
multiline_comment|/* extract bit position (MSB first) */
id|pos
op_assign
l_int|10
op_star
(paren
id|NB_DATA
op_minus
l_int|1
op_minus
id|pos
)paren
op_minus
l_int|6
suffix:semicolon
multiline_comment|/* now correct the following 10 bits. At most two bytes&n;               can be modified since pos is even */
id|index
op_assign
(paren
id|pos
op_rshift
l_int|3
)paren
op_xor
l_int|1
suffix:semicolon
id|bitpos
op_assign
id|pos
op_amp
l_int|7
suffix:semicolon
r_if
c_cond
(paren
(paren
id|index
op_ge
l_int|0
op_logical_and
id|index
OL
id|SECTOR_SIZE
)paren
op_logical_or
id|index
op_eq
(paren
id|SECTOR_SIZE
op_plus
l_int|1
)paren
)paren
(brace
id|val
op_assign
id|error_val
(braket
id|i
)braket
op_rshift
(paren
l_int|2
op_plus
id|bitpos
)paren
suffix:semicolon
id|parity
op_xor_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
id|SECTOR_SIZE
)paren
id|sector
(braket
id|index
)braket
op_xor_assign
id|val
suffix:semicolon
)brace
id|index
op_assign
(paren
(paren
id|pos
op_rshift
l_int|3
)paren
op_plus
l_int|1
)paren
op_xor
l_int|1
suffix:semicolon
id|bitpos
op_assign
(paren
id|bitpos
op_plus
l_int|10
)paren
op_amp
l_int|7
suffix:semicolon
r_if
c_cond
(paren
id|bitpos
op_eq
l_int|0
)paren
id|bitpos
op_assign
l_int|8
suffix:semicolon
r_if
c_cond
(paren
(paren
id|index
op_ge
l_int|0
op_logical_and
id|index
OL
id|SECTOR_SIZE
)paren
op_logical_or
id|index
op_eq
(paren
id|SECTOR_SIZE
op_plus
l_int|1
)paren
)paren
(brace
id|val
op_assign
id|error_val
(braket
id|i
)braket
op_lshift
(paren
l_int|8
op_minus
id|bitpos
)paren
suffix:semicolon
id|parity
op_xor_assign
id|val
suffix:semicolon
r_if
c_cond
(paren
id|index
OL
id|SECTOR_SIZE
)paren
id|sector
(braket
id|index
)braket
op_xor_assign
id|val
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* use parity to test extra errors */
r_if
c_cond
(paren
(paren
id|parity
op_amp
l_int|0xff
)paren
op_ne
l_int|0
)paren
id|nb_errors
op_assign
op_minus
l_int|1
suffix:semicolon
id|the_end
suffix:colon
id|kfree
c_func
(paren
id|Alpha_to
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|Index_of
)paren
suffix:semicolon
r_return
id|nb_errors
suffix:semicolon
)brace
eof
