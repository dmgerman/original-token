multiline_comment|/* Linux driver for NAND Flash Translation Layer      */
multiline_comment|/* (c) 1999 Machine Vision Holdings, Inc.             */
multiline_comment|/* Author: David Woodhouse &lt;dwmw2@infradead.org&gt;      */
multiline_comment|/* $Id: nftl.c,v 1.36 2000/07/13 14:14:20 dwmw2 Exp $ */
multiline_comment|/*&n;  The contents of this file are distributed under the GNU Public&n;  Licence version 2 (&quot;GPL&quot;). The legal note below refers only to the&n;  _use_ of the code in some jurisdictions, and does not in any way&n;  affect the copying, distribution and modification of this code,&n;  which is permitted under the terms of the GPL.&n;&n;  Section 0 of the GPL says:&n;&n; &quot;Activities other than copying, distribution and modification are not&n;  covered by this License; they are outside its scope.&quot;&n;&n;  You may copy, distribute and modify this code to your hearts&squot;&n;  content - it&squot;s just that in some jurisdictions, you may only _use_&n;  it under the terms of the licence below. This puts it in a similar&n;  situation to the ISDN code, which you may need telco approval to&n;  use, and indeed any code which has uses that may be restricted in&n;  law. For example, certain malicious uses of the networking stack&n;  may be illegal, but that doesn&squot;t prevent the networking code from&n;  being under GPL.&n;&n;  In fact the ISDN case is worse than this, because modification of&n;  the code automatically invalidates its approval. Modificiation,&n;  unlike usage, _is_ one of the rights which is protected by the&n;  GPL. Happily, the law in those places where approval is required&n;  doesn&squot;t actually prevent you from modifying the code - it&squot;s just&n;  that you may not be allowed to _use_ it once you&squot;ve done so - and&n;  because usage isn&squot;t addressed by the GPL, that&squot;s just fine.&n;&n;  dwmw2@infradead.org&n;  6/7/0&n;&n;  LEGAL NOTE: The NFTL format is patented by M-Systems.  They have&n;  granted a licence for its use with their DiskOnChip products:&n;&n;    &quot;M-Systems grants a royalty-free, non-exclusive license under&n;    any presently existing M-Systems intellectual property rights&n;    necessary for the design and development of NFTL-compatible&n;    drivers, file systems and utilities to use the data formats with, &n;    and solely to support, M-Systems&squot; DiskOnChip products&quot;&n;&n;  A signed copy of this agreement from M-Systems is kept on file by&n;  Red Hat UK Limited. In the unlikely event that you need access to it,&n;  please contact dwmw2@redhat.com for assistance.  */
DECL|macro|PRERELEASE
mdefine_line|#define PRERELEASE
macro_line|#ifdef NFTL_DEBUG
DECL|macro|DEBUGLVL
mdefine_line|#define DEBUGLVL debug
macro_line|#endif
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nftl.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt;
DECL|macro|WE_KNOW_WTF_THIS_DOES_NOT_WORK
macro_line|#undef WE_KNOW_WTF_THIS_DOES_NOT_WORK
multiline_comment|/* NFTL block device stuff */
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR NFTL_MAJOR
DECL|macro|DEVICE_REQUEST
mdefine_line|#define DEVICE_REQUEST nftl_request
DECL|macro|DEVICE_OFF
mdefine_line|#define DEVICE_OFF(device)
macro_line|#ifdef WE_KNOW_WTF_THIS_DOES_NOT_WORK
DECL|macro|LOCAL_END_REQUEST
mdefine_line|#define LOCAL_END_REQUEST
macro_line|#endif
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#ifdef WE_KNOW_WTF_THIS_DOES_NOT_WORK
DECL|function|nftl_end_request
r_static
r_void
id|nftl_end_request
c_func
(paren
r_struct
id|request
op_star
id|req
comma
r_int
id|res
)paren
(brace
id|req-&gt;sector
op_add_assign
id|req-&gt;current_nr_sectors
suffix:semicolon
id|req-&gt;nr_sectors
op_sub_assign
id|req-&gt;current_nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|end_that_request_first
c_func
(paren
id|req
comma
id|res
comma
l_string|&quot;nftl&quot;
)paren
)paren
r_return
suffix:semicolon
id|end_that_request_last
c_func
(paren
id|req
)paren
suffix:semicolon
)brace
macro_line|#endif
macro_line|#ifdef NFTL_DEBUG
DECL|variable|debug
r_static
r_int
id|debug
op_assign
id|NFTL_DEBUG
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Linux-specific block device functions */
multiline_comment|/* I _HATE_ the Linux block device setup more than anything else I&squot;ve ever&n; *  encountered, except ...&n; */
DECL|variable|nftl_sizes
r_static
r_int
id|nftl_sizes
(braket
l_int|256
)braket
op_assign
initialization_block
suffix:semicolon
DECL|variable|nftl_blocksizes
r_static
r_int
id|nftl_blocksizes
(braket
l_int|256
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* .. for the Linux partition table handling. */
DECL|variable|part_table
r_struct
id|hd_struct
id|part_table
(braket
l_int|256
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; 0x20328
DECL|function|dummy_init
r_static
r_void
id|dummy_init
(paren
r_struct
id|gendisk
op_star
id|crap
)paren
(brace
)brace
macro_line|#endif
DECL|variable|nftl_gendisk
r_static
r_struct
id|gendisk
id|nftl_gendisk
op_assign
(brace
id|NFTL_MAJOR
comma
multiline_comment|/* Major number */
l_string|&quot;nftl&quot;
comma
multiline_comment|/* Major name */
l_int|4
comma
multiline_comment|/* Bits to shift to get real from partition */
l_int|15
comma
multiline_comment|/* Number of partitions per real */
macro_line|#if LINUX_VERSION_CODE &lt; 0x20328
id|MAX_NFTLS
comma
multiline_comment|/* maximum number of real */
id|dummy_init
comma
multiline_comment|/* init function */
macro_line|#endif
id|part_table
comma
multiline_comment|/* hd struct */
id|nftl_sizes
comma
multiline_comment|/* block sizes */
l_int|0
comma
multiline_comment|/* number */
l_int|NULL
comma
multiline_comment|/* internal use, not presently used */
l_int|NULL
multiline_comment|/* next */
)brace
suffix:semicolon
DECL|variable|NFTLs
r_struct
id|NFTLrecord
op_star
id|NFTLs
(braket
id|MAX_NFTLS
)braket
op_assign
(brace
l_int|NULL
)brace
suffix:semicolon
DECL|function|NFTL_setup
r_static
r_void
id|NFTL_setup
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_int
r_int
id|ofs
comma
r_struct
id|NFTLMediaHeader
op_star
id|hdr
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|NFTLrecord
op_star
id|thisNFTL
suffix:semicolon
r_int
r_int
id|temp
suffix:semicolon
r_int
id|firstfree
op_assign
op_minus
l_int|1
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;NFTL_setup&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NFTLS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|NFTLs
(braket
id|i
)braket
op_logical_and
id|firstfree
op_eq
op_minus
l_int|1
)paren
id|firstfree
op_assign
id|i
suffix:semicolon
r_else
r_if
c_cond
(paren
id|NFTLs
(braket
id|i
)braket
op_logical_and
id|NFTLs
(braket
id|i
)braket
op_member_access_from_pointer
id|mtd
op_eq
id|mtd
op_logical_and
id|NFTLs
(braket
id|i
)braket
op_member_access_from_pointer
id|MediaHdr.FirstPhysicalEUN
op_eq
id|hdr-&gt;FirstPhysicalEUN
)paren
(brace
multiline_comment|/* This is a Spare Media Header for an NFTL we&squot;ve already found */
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Spare Media Header for NFTL %d found at %lx&bslash;n&quot;
comma
id|i
comma
id|ofs
)paren
suffix:semicolon
id|NFTLs
(braket
id|i
)braket
op_member_access_from_pointer
id|SpareMediaUnit
op_assign
id|ofs
op_div
id|mtd-&gt;erasesize
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
multiline_comment|/* OK, it&squot;s a new one. Set up all the data structures. */
macro_line|#ifdef PSYCHO_DEBUG&t;
id|printk
c_func
(paren
l_string|&quot;Found new NFTL nftl%c at offset %lx&bslash;n&quot;
comma
id|firstfree
op_plus
l_char|&squot;a&squot;
comma
id|ofs
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|hdr-&gt;UnitSizeFactor
op_ne
l_int|0xff
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sorry, we don&squot;t support UnitSizeFactor of != 1 yet&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|thisNFTL
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|NFTLrecord
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thisNFTL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Out of memory for NFTL data structures&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|init_MUTEX
c_func
(paren
op_amp
id|thisNFTL-&gt;mutex
)paren
suffix:semicolon
id|thisNFTL-&gt;EraseSize
op_assign
id|mtd-&gt;erasesize
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
id|thisNFTL-&gt;MediaHdr
comma
id|hdr
comma
r_sizeof
(paren
op_star
id|hdr
)paren
)paren
suffix:semicolon
id|thisNFTL-&gt;mtd
op_assign
id|mtd
suffix:semicolon
id|thisNFTL-&gt;MediaUnit
op_assign
id|ofs
op_div
id|mtd-&gt;erasesize
suffix:semicolon
id|thisNFTL-&gt;SpareMediaUnit
op_assign
l_int|0xffff
suffix:semicolon
id|thisNFTL-&gt;numvunits
op_assign
id|le32_to_cpu
c_func
(paren
id|thisNFTL-&gt;MediaHdr.FormattedSize
)paren
op_div
l_int|8192
suffix:semicolon
id|thisNFTL-&gt;nr_sects
op_assign
id|thisNFTL-&gt;numvunits
op_star
(paren
id|thisNFTL-&gt;EraseSize
op_div
l_int|512
)paren
suffix:semicolon
id|thisNFTL-&gt;usecount
op_assign
l_int|0
suffix:semicolon
id|thisNFTL-&gt;cylinders
op_assign
l_int|1024
suffix:semicolon
id|thisNFTL-&gt;heads
op_assign
l_int|16
suffix:semicolon
id|temp
op_assign
id|thisNFTL-&gt;cylinders
op_star
id|thisNFTL-&gt;heads
suffix:semicolon
id|thisNFTL-&gt;sectors
op_assign
id|thisNFTL-&gt;nr_sects
op_div
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|thisNFTL-&gt;nr_sects
op_mod
id|temp
)paren
(brace
id|thisNFTL-&gt;sectors
op_increment
suffix:semicolon
id|temp
op_assign
id|thisNFTL-&gt;cylinders
op_star
id|thisNFTL-&gt;sectors
suffix:semicolon
id|thisNFTL-&gt;heads
op_assign
id|thisNFTL-&gt;nr_sects
op_div
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|thisNFTL-&gt;nr_sects
op_amp
id|temp
)paren
(brace
id|thisNFTL-&gt;heads
op_increment
suffix:semicolon
id|temp
op_assign
id|thisNFTL-&gt;heads
op_star
id|thisNFTL-&gt;sectors
suffix:semicolon
id|thisNFTL-&gt;cylinders
op_assign
id|thisNFTL-&gt;nr_sects
op_div
id|temp
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|thisNFTL-&gt;nr_sects
op_ne
id|thisNFTL-&gt;heads
op_star
id|thisNFTL-&gt;cylinders
op_star
id|thisNFTL-&gt;sectors
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Cannot calculate an NFTL geometry to match size of 0x%lx.&bslash;n&quot;
comma
id|thisNFTL-&gt;nr_sects
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Using C:%d H:%d S:%d (== %lx sects)&bslash;n&quot;
comma
id|thisNFTL-&gt;cylinders
comma
id|thisNFTL-&gt;heads
comma
id|thisNFTL-&gt;sectors
comma
(paren
r_int
)paren
id|thisNFTL-&gt;cylinders
op_star
(paren
r_int
)paren
id|thisNFTL-&gt;heads
op_star
(paren
r_int
)paren
id|thisNFTL-&gt;sectors
)paren
suffix:semicolon
multiline_comment|/* Oh no we don&squot;t &n;&t;&t; * thisNFTL-&gt;nr_sects = thisNFTL-&gt;heads * thisNFTL-&gt;cylinders * thisNFTL-&gt;sectors;&n;&t;&t; */
)brace
id|thisNFTL-&gt;EUNtable
op_assign
id|kmalloc
c_func
(paren
l_int|2
op_star
id|thisNFTL-&gt;numvunits
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thisNFTL-&gt;EUNtable
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENOMEM&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|thisNFTL
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|thisNFTL-&gt;EUNtable
comma
l_int|0xff
comma
l_int|2
op_star
id|thisNFTL-&gt;numvunits
)paren
suffix:semicolon
id|thisNFTL-&gt;VirtualUnitTable
op_assign
id|kmalloc
c_func
(paren
l_int|2
op_star
id|le16_to_cpu
c_func
(paren
id|thisNFTL-&gt;MediaHdr.NumEraseUnits
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thisNFTL-&gt;VirtualUnitTable
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENOMEM&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|thisNFTL-&gt;EUNtable
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|thisNFTL
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|thisNFTL-&gt;VirtualUnitTable
comma
l_int|0xff
comma
l_int|2
op_star
id|le16_to_cpu
c_func
(paren
id|thisNFTL-&gt;MediaHdr.NumEraseUnits
)paren
)paren
suffix:semicolon
id|thisNFTL-&gt;ReplUnitTable
op_assign
id|kmalloc
c_func
(paren
l_int|2
op_star
id|le16_to_cpu
c_func
(paren
id|thisNFTL-&gt;MediaHdr.NumEraseUnits
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thisNFTL-&gt;ReplUnitTable
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ENOMEM&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|thisNFTL-&gt;VirtualUnitTable
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|thisNFTL-&gt;EUNtable
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|thisNFTL
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|thisNFTL-&gt;ReplUnitTable
comma
l_int|0xff
comma
l_int|2
op_star
id|le16_to_cpu
c_func
(paren
id|thisNFTL-&gt;MediaHdr.NumEraseUnits
)paren
)paren
suffix:semicolon
multiline_comment|/* Ought to check the media header for bad blocks */
id|thisNFTL-&gt;lastEUN
op_assign
id|le16_to_cpu
c_func
(paren
id|thisNFTL-&gt;MediaHdr.NumEraseUnits
)paren
op_plus
id|le16_to_cpu
c_func
(paren
id|thisNFTL-&gt;MediaHdr.FirstPhysicalEUN
)paren
op_minus
l_int|1
suffix:semicolon
id|thisNFTL-&gt;numfreeEUNs
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Scan each physical Erase Unit for validity and to find the &n;&t;   Virtual Erase Unit Chain to which it belongs */
r_for
c_loop
(paren
id|i
op_assign
id|le16_to_cpu
c_func
(paren
id|thisNFTL-&gt;MediaHdr.FirstPhysicalEUN
)paren
suffix:semicolon
id|i
op_le
id|thisNFTL-&gt;lastEUN
suffix:semicolon
id|i
op_increment
)paren
(brace
r_union
id|nftl_uci
id|uci
suffix:semicolon
r_int
r_int
id|ofs
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|ofs
op_assign
id|i
op_star
id|thisNFTL-&gt;EraseSize
suffix:semicolon
id|MTD_READOOB
c_func
(paren
id|mtd
comma
(paren
id|i
op_star
id|thisNFTL-&gt;EraseSize
)paren
op_plus
l_int|512
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|uci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uci.b.EraseMark
op_ne
id|cpu_to_le16
c_func
(paren
l_int|0x3c69
)paren
op_logical_or
id|uci.b.EraseMark1
op_ne
id|cpu_to_le16
c_func
(paren
l_int|0x3c69
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;EUN %d: EraseMark not 0x3c69 (0x%4.4x 0x%4.4x instead)&bslash;n&quot;
comma
id|i
comma
id|le16_to_cpu
c_func
(paren
id|uci.b.EraseMark
)paren
comma
id|le16_to_cpu
c_func
(paren
id|uci.b.EraseMark1
)paren
)paren
suffix:semicolon
id|thisNFTL-&gt;VirtualUnitTable
(braket
id|i
)braket
op_assign
l_int|0x7fff
suffix:semicolon
id|thisNFTL-&gt;ReplUnitTable
(braket
id|i
)braket
op_assign
l_int|0xffff
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|MTD_READOOB
c_func
(paren
id|mtd
comma
(paren
id|i
op_star
id|thisNFTL-&gt;EraseSize
)paren
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
id|u_char
op_star
)paren
op_amp
id|uci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uci.a.VirtUnitNum
op_ne
id|uci.a.SpareVirtUnitNum
)paren
id|printk
c_func
(paren
l_string|&quot;EUN %d: VirtualUnitNumber (%x) != SpareVirtualUnitNumber (%x)&bslash;n&quot;
comma
id|i
comma
id|le16_to_cpu
c_func
(paren
id|uci.a.VirtUnitNum
)paren
comma
id|le16_to_cpu
c_func
(paren
id|uci.a.SpareVirtUnitNum
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|uci.a.ReplUnitNum
op_ne
id|uci.a.SpareReplUnitNum
)paren
id|printk
c_func
(paren
l_string|&quot;EUN %d: ReplacementUnitNumber (%x) != SpareReplacementUnitNumber (%x)&bslash;n&quot;
comma
id|i
comma
id|le16_to_cpu
c_func
(paren
id|uci.a.ReplUnitNum
)paren
comma
id|le16_to_cpu
c_func
(paren
id|uci.a.SpareReplUnitNum
)paren
)paren
suffix:semicolon
multiline_comment|/* We don&squot;t actually _do_ anything about the above, just whinge */
id|thisNFTL-&gt;VirtualUnitTable
(braket
id|i
)braket
op_assign
id|le16_to_cpu
c_func
(paren
id|uci.a.VirtUnitNum
)paren
suffix:semicolon
id|thisNFTL-&gt;ReplUnitTable
(braket
id|i
)braket
op_assign
id|le16_to_cpu
c_func
(paren
id|uci.a.ReplUnitNum
)paren
suffix:semicolon
multiline_comment|/* if (!(VUN &amp; 0x8000) &amp;&amp; VUN &lt; (arraybounds)).. optimises to: */
r_if
c_cond
(paren
id|le16_to_cpu
c_func
(paren
id|uci.a.VirtUnitNum
)paren
OL
id|thisNFTL-&gt;numvunits
)paren
id|thisNFTL-&gt;EUNtable
(braket
id|le16_to_cpu
c_func
(paren
id|uci.a.VirtUnitNum
)paren
op_amp
l_int|0x7fff
)braket
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|uci.a.VirtUnitNum
op_eq
l_int|0xffff
)paren
(brace
multiline_comment|/* Free block */
id|thisNFTL-&gt;LastFreeEUN
op_assign
id|i
suffix:semicolon
id|thisNFTL-&gt;numfreeEUNs
op_increment
suffix:semicolon
)brace
)brace
id|NFTLs
(braket
id|firstfree
)braket
op_assign
id|thisNFTL
suffix:semicolon
id|thisNFTL-&gt;LastFreeEUN
op_assign
id|le16_to_cpu
c_func
(paren
id|thisNFTL-&gt;MediaHdr.FirstPhysicalEUN
)paren
suffix:semicolon
singleline_comment|//#define PSYCHO_DEBUG&t;
macro_line|#ifdef PSYCHO_DEBUG
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
multiline_comment|/* thisNFTL-&gt;numvunits*/
suffix:semicolon
id|i
op_increment
)paren
(brace
id|u16
id|curEUN
op_assign
id|thisNFTL-&gt;EUNtable
(braket
id|i
)braket
suffix:semicolon
r_int
id|sillycount
op_assign
l_int|100
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Virtual Unit #%d: &quot;
comma
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|curEUN
op_logical_or
id|curEUN
op_eq
l_int|0xffff
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Not present&bslash;n&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;%d&quot;
comma
id|curEUN
)paren
suffix:semicolon
r_while
c_loop
(paren
(paren
id|curEUN
op_assign
id|thisNFTL-&gt;ReplUnitTable
(braket
id|curEUN
)braket
)paren
op_ne
l_int|0xffff
op_logical_and
op_decrement
id|sillycount
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;, %d&quot;
comma
id|curEUN
op_amp
l_int|0xffff
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* OK. Now we deal with the fact that we&squot;re in the real world. Sometimes &n;&t;   things don&squot;t actually happen the way they&squot;re supposed to. Find, fix,&n;&t;   and whinge about the most common deviations from spec that we have&n;&t;   been known to encounter.&n;&t;*/
multiline_comment|/* Except that I haven&squot;t implemented that bit yet :) */
multiline_comment|/* Finally, set up the block device sizes */
id|nftl_sizes
(braket
id|firstfree
op_star
l_int|16
)braket
op_assign
id|thisNFTL-&gt;nr_sects
suffix:semicolon
singleline_comment|//&t;nftl_blocksizes[firstfree*16] = 512;
id|part_table
(braket
id|firstfree
op_star
l_int|16
)braket
dot
id|nr_sects
op_assign
id|thisNFTL-&gt;nr_sects
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; 0x20328
id|resetup_one_dev
c_func
(paren
op_amp
id|nftl_gendisk
comma
id|firstfree
)paren
suffix:semicolon
macro_line|#else
id|grok_partitions
c_func
(paren
op_amp
id|nftl_gendisk
comma
id|firstfree
comma
l_int|1
op_lshift
l_int|4
comma
id|thisNFTL-&gt;nr_sects
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|NFTL_unsetup
r_static
r_void
id|NFTL_unsetup
c_func
(paren
r_int
id|i
)paren
(brace
r_struct
id|NFTLrecord
op_star
id|thisNFTL
op_assign
id|NFTLs
(braket
id|i
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;NFTL_unsetup %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|NFTLs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|thisNFTL-&gt;VirtualUnitTable
)paren
id|kfree
c_func
(paren
id|thisNFTL-&gt;VirtualUnitTable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thisNFTL-&gt;ReplUnitTable
)paren
id|kfree
c_func
(paren
id|thisNFTL-&gt;ReplUnitTable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thisNFTL-&gt;EUNtable
)paren
id|kfree
c_func
(paren
id|thisNFTL-&gt;EUNtable
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|thisNFTL
)paren
suffix:semicolon
)brace
multiline_comment|/* Search the MTD device for NFTL partitions */
DECL|function|NFTL_notify_add
r_static
r_void
id|NFTL_notify_add
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|ofs
suffix:semicolon
r_struct
id|NFTLMediaHeader
id|hdr
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;NFTL_notify_add for %s&bslash;n&quot;
comma
id|mtd-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mtd-&gt;read_oob
)paren
multiline_comment|/* If this MTD doesn&squot;t have out-of-band data,&n;&t;&t;&t;&t;       then there&squot;s no point continuing */
(brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;No OOB data, quitting&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;mtd-&gt;read = %p,size = %d, erasesize = %d&bslash;n&quot;
comma
id|mtd-&gt;read
comma
id|mtd-&gt;size
comma
id|mtd-&gt;erasesize
)paren
suffix:semicolon
r_for
c_loop
(paren
id|ofs
op_assign
l_int|0
suffix:semicolon
id|ofs
OL
id|mtd-&gt;size
suffix:semicolon
id|ofs
op_add_assign
id|mtd-&gt;erasesize
)paren
(brace
r_int
id|retlen
op_assign
l_int|0
suffix:semicolon
id|MTD_READ
c_func
(paren
id|mtd
comma
id|ofs
comma
r_sizeof
(paren
id|hdr
)paren
comma
op_amp
id|retlen
comma
(paren
id|u_char
op_star
)paren
op_amp
id|hdr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|retlen
OL
r_sizeof
(paren
id|hdr
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|strncmp
c_func
(paren
id|hdr.DataOrgID
comma
l_string|&quot;ANAND&quot;
comma
l_int|6
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;Valid NFTL partition at ofs %ld&bslash;n&quot;
comma
id|ofs
)paren
suffix:semicolon
id|NFTL_setup
c_func
(paren
id|mtd
comma
id|ofs
comma
op_amp
id|hdr
)paren
suffix:semicolon
)brace
r_else
(brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;No valid NFTL Partition at ofs %d&bslash;n&quot;
comma
id|ofs
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%x, &quot;
comma
id|hdr.DataOrgID
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot; = %s&bslash;n&quot;
comma
id|hdr.DataOrgID
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;%d, %d, %d, %d&bslash;n&quot;
comma
id|hdr.NumEraseUnits
comma
id|hdr.FirstPhysicalEUN
comma
id|hdr.FormattedSize
comma
id|hdr.UnitSizeFactor
)paren
suffix:semicolon
)brace
)brace
r_return
suffix:semicolon
)brace
)brace
DECL|function|NFTL_notify_remove
r_static
r_void
id|NFTL_notify_remove
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NFTLS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|NFTLs
(braket
id|i
)braket
op_logical_and
id|NFTLs
(braket
id|i
)braket
op_member_access_from_pointer
id|mtd
op_eq
id|mtd
)paren
id|NFTL_unsetup
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_NFTL_RW
multiline_comment|/* Actual NFTL access routines */
DECL|function|NFTL_findfreeblock
r_static
id|u16
id|NFTL_findfreeblock
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|thisNFTL
comma
r_int
id|desperate
)paren
(brace
multiline_comment|/* For a given Virtual Unit Chain: find or create a free block and&n;&t;   add it to the chain */
multiline_comment|/* We&squot;re passed the number of the last EUN in the chain, to save us from&n;&t;   having to look it up again */
id|u16
id|pot
op_assign
id|thisNFTL-&gt;LastFreeEUN
suffix:semicolon
r_int
id|silly
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Normally, we force a fold to happen before we run out of free blocks completely */
r_if
c_cond
(paren
op_logical_neg
id|desperate
op_logical_and
id|thisNFTL-&gt;numfreeEUNs
OL
l_int|2
)paren
(brace
singleline_comment|//&t;&t;printk(&quot;NFTL_findfreeblock: there are too few free EUNs&bslash;n&quot;);
r_return
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/* Scan for a free block */
r_do
(brace
r_if
c_cond
(paren
id|thisNFTL-&gt;VirtualUnitTable
(braket
id|pot
)braket
op_eq
l_int|0xffff
)paren
(brace
id|thisNFTL-&gt;LastFreeEUN
op_assign
id|pot
suffix:semicolon
id|thisNFTL-&gt;numfreeEUNs
op_decrement
suffix:semicolon
r_return
id|pot
suffix:semicolon
)brace
r_if
c_cond
(paren
op_increment
id|pot
OG
id|thisNFTL-&gt;lastEUN
)paren
id|pot
op_assign
id|le16_to_cpu
c_func
(paren
id|thisNFTL-&gt;MediaHdr.FirstPhysicalEUN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Tell Dave he fucked up. LastFreeEUN = %d, FirstEUN = %d&bslash;n&quot;
comma
id|thisNFTL-&gt;LastFreeEUN
comma
id|le16_to_cpu
c_func
(paren
id|thisNFTL-&gt;MediaHdr.FirstPhysicalEUN
)paren
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|pot
op_ne
id|thisNFTL-&gt;LastFreeEUN
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
DECL|function|NFTL_foldchain
r_static
id|u16
id|NFTL_foldchain
(paren
r_struct
id|NFTLrecord
op_star
id|thisNFTL
comma
id|u16
id|thisVUC
comma
r_int
id|pendingblock
)paren
(brace
id|u16
id|BlockMap
(braket
id|thisNFTL-&gt;EraseSize
op_div
l_int|512
)braket
suffix:semicolon
r_int
r_char
id|BlockLastState
(braket
id|thisNFTL-&gt;EraseSize
op_div
l_int|512
)braket
suffix:semicolon
r_int
r_char
id|BlockFreeFound
(braket
id|thisNFTL-&gt;EraseSize
op_div
l_int|512
)braket
suffix:semicolon
id|u16
id|thisEUN
suffix:semicolon
r_int
id|block
suffix:semicolon
r_int
id|silly
op_assign
op_minus
l_int|1
suffix:semicolon
id|u16
id|targetEUN
op_assign
l_int|0xffff
suffix:semicolon
r_struct
id|nftl_oob
id|oob
suffix:semicolon
r_int
id|inplace
op_assign
l_int|1
suffix:semicolon
id|memset
c_func
(paren
id|BlockMap
comma
l_int|0xff
comma
r_sizeof
(paren
id|BlockMap
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|BlockFreeFound
comma
l_int|0
comma
r_sizeof
(paren
id|BlockFreeFound
)paren
)paren
suffix:semicolon
id|thisEUN
op_assign
id|thisNFTL-&gt;EUNtable
(braket
id|thisVUC
)braket
suffix:semicolon
r_if
c_cond
(paren
id|thisEUN
op_eq
l_int|0xffff
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Trying to fold non-existent Virtual Unit Chain %d!&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/* Scan to find the Erase Unit which holds the actual data for each&n;&t;   512-byte block within the Chain.&n;&t;*/
r_while
c_loop
(paren
id|thisEUN
op_le
id|thisNFTL-&gt;lastEUN
)paren
(brace
r_int
id|retlen
suffix:semicolon
id|targetEUN
op_assign
id|thisEUN
suffix:semicolon
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|thisNFTL-&gt;EraseSize
op_div
l_int|512
suffix:semicolon
id|block
op_increment
)paren
(brace
id|MTD_READOOB
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|thisEUN
op_star
id|thisNFTL-&gt;EraseSize
)paren
op_plus
(paren
id|block
op_star
l_int|512
)paren
comma
l_int|16
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
op_eq
l_int|2
)paren
(brace
r_if
c_cond
(paren
id|oob.u.c.WriteInh
op_ne
l_int|0xffffffff
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Write Inhibited on EUN %d&bslash;n&quot;
comma
id|thisEUN
)paren
suffix:semicolon
id|inplace
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There&squot;s no other reason not to do inplace,&n;&t;&t;&t;&t;&t;   except ones that come later. So we don&squot;t need&n;&t;&t;&t;&t;&t;   to preserve inplace */
id|inplace
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|BlockLastState
(braket
id|block
)braket
op_assign
(paren
r_int
r_char
)paren
id|oob.b.Status
op_amp
l_int|0xff
suffix:semicolon
r_switch
c_cond
(paren
id|oob.b.Status
)paren
(brace
r_case
id|__constant_cpu_to_le16
c_func
(paren
id|BLOCK_FREE
)paren
suffix:colon
id|BlockFreeFound
(braket
id|block
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|__constant_cpu_to_le16
c_func
(paren
id|BLOCK_USED
)paren
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|BlockFreeFound
(braket
id|block
)braket
)paren
id|BlockMap
(braket
id|block
)braket
op_assign
id|thisEUN
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;BLOCK_USED found after BLOCK_FREE in Virtual Unit Chain %d for block %d&bslash;n&quot;
comma
id|thisVUC
comma
id|block
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|__constant_cpu_to_le16
c_func
(paren
id|BLOCK_IGNORE
)paren
suffix:colon
r_case
id|__constant_cpu_to_le16
c_func
(paren
id|BLOCK_DELETED
)paren
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unknown status for block %d in EUN %d: %x&bslash;n&quot;
comma
id|block
comma
id|thisEUN
comma
id|oob.b.Status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Infinite loop in Virtual Unit Chain 0x%x&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
id|thisEUN
op_assign
id|thisNFTL-&gt;ReplUnitTable
(braket
id|thisEUN
)braket
op_amp
l_int|0x7fff
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inplace
)paren
(brace
multiline_comment|/* We&squot;re being asked to be a fold-in-place. Check&n;&t;&t;   that all blocks are either present or BLOCK_FREE&n;&t;&t;   in the target block. If not, we&squot;re going to have&n;&t;&t;   to fold out-of-place anyway.&n;&t;&t;*/
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|thisNFTL-&gt;EraseSize
op_div
l_int|512
suffix:semicolon
id|block
op_increment
)paren
(brace
r_if
c_cond
(paren
id|BlockLastState
(braket
id|block
)braket
op_ne
(paren
r_int
r_char
)paren
(paren
id|cpu_to_le16
c_func
(paren
id|BLOCK_FREE
)paren
op_amp
l_int|0xff
)paren
op_logical_and
id|BlockMap
(braket
id|block
)braket
op_ne
id|targetEUN
)paren
(brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Setting inplace to 0. VUC %d, block %d was %x lastEUN, and is in EUN %d (%s) %d&bslash;n&quot;
comma
id|thisVUC
comma
id|block
comma
id|BlockLastState
(braket
id|block
)braket
comma
id|BlockMap
(braket
id|block
)braket
comma
id|BlockMap
(braket
id|block
)braket
op_eq
id|targetEUN
ques
c_cond
l_string|&quot;==&quot;
suffix:colon
l_string|&quot;!=&quot;
comma
id|targetEUN
)paren
suffix:semicolon
id|inplace
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pendingblock
op_ge
(paren
id|thisVUC
op_star
(paren
id|thisNFTL-&gt;EraseSize
op_div
l_int|512
)paren
)paren
op_logical_and
id|pendingblock
OL
(paren
(paren
id|thisVUC
op_plus
l_int|1
)paren
op_star
(paren
id|thisNFTL-&gt;EraseSize
op_div
l_int|512
)paren
)paren
op_logical_and
id|BlockLastState
(braket
id|pendingblock
op_minus
(paren
id|thisVUC
op_star
(paren
id|thisNFTL-&gt;EraseSize
op_div
l_int|512
)paren
)paren
)braket
op_ne
(paren
r_int
r_char
)paren
(paren
id|cpu_to_le16
c_func
(paren
id|BLOCK_FREE
)paren
op_amp
l_int|0xff
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Pending write not free in EUN %d. Folding out of place.&bslash;n&quot;
comma
id|targetEUN
)paren
suffix:semicolon
id|inplace
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|inplace
)paren
(brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Cannot fold Virtual Unit Chain %d in place. Trying out-of-place&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
multiline_comment|/* We need to find a targetEUN to fold into. */
id|targetEUN
op_assign
id|NFTL_findfreeblock
c_func
(paren
id|thisNFTL
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targetEUN
op_eq
l_int|0xffff
)paren
(brace
multiline_comment|/* Ouch. Now we&squot;re screwed. We need to do a &n;&t;&t;&t;&t;   fold-in-place of another chain to make room&n;&t;&t;&t;&t;   for this one. We need a better way of selecting&n;&t;&t;&t;&t;   which chain to fold, because makefreeblock will &n;&t;&t;&t;&t;   only ask us to fold the same one again.&n;&t;&t;&t;&t;*/
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NFTL_findfreeblock(desperate) returns 0xffff.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
)brace
multiline_comment|/* OK. We now know the location of every block in the Virtual Unit Chain,&n;&t;   and the Erase Unit into which we are supposed to be copying.&n;&t;   Go for it.&n;&t;*/
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Folding chain %d into unit %d&bslash;n&quot;
comma
id|thisVUC
comma
id|targetEUN
)paren
suffix:semicolon
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|thisNFTL-&gt;EraseSize
op_div
l_int|512
suffix:semicolon
id|block
op_increment
)paren
(brace
r_int
r_char
id|movebuf
(braket
l_int|512
)braket
suffix:semicolon
r_struct
id|nftl_oob
id|oob
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|oob
comma
l_int|0xff
comma
r_sizeof
(paren
id|oob
)paren
)paren
suffix:semicolon
multiline_comment|/* If it&squot;s in the target EUN already, or if it&squot;s pending write, do nothing */
r_if
c_cond
(paren
id|BlockMap
(braket
id|block
)braket
op_eq
id|targetEUN
op_logical_or
(paren
id|pendingblock
op_eq
(paren
id|thisVUC
op_star
(paren
id|thisNFTL-&gt;EraseSize
op_div
l_int|512
)paren
op_plus
id|block
)paren
)paren
)paren
(brace
multiline_comment|/* Except if it&squot;s the first block, in which case we have to&n;&t;&t;&t;   set the UnitNumbers */
r_if
c_cond
(paren
id|block
op_eq
l_int|0
)paren
(brace
id|thisNFTL-&gt;mtd
op_member_access_from_pointer
id|read_oob
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|thisNFTL-&gt;EraseSize
op_star
id|targetEUN
)paren
comma
l_int|16
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
singleline_comment|//&t;&t;&t;&t;printk(&quot;Setting VirtUnitNum on EUN %d to %x, was %x&bslash;n&quot;, targetEUN, thisVUC, 
singleline_comment|//&t;&t;&t;       le16_to_cpu(oob.u.a.VirtUnitNum));
id|oob.u.a.VirtUnitNum
op_assign
id|oob.u.a.SpareVirtUnitNum
op_assign
id|cpu_to_le16
c_func
(paren
id|thisVUC
op_amp
l_int|0x7fff
)paren
suffix:semicolon
id|thisNFTL-&gt;mtd
op_member_access_from_pointer
id|write_oob
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|thisNFTL-&gt;EraseSize
op_star
id|targetEUN
)paren
comma
l_int|16
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
)brace
r_continue
suffix:semicolon
)brace
id|oob.b.Status
op_assign
id|BLOCK_USED
suffix:semicolon
r_switch
c_cond
(paren
id|block
)paren
(brace
r_case
l_int|0
suffix:colon
id|oob.u.a.VirtUnitNum
op_assign
id|oob.u.a.SpareVirtUnitNum
op_assign
id|cpu_to_le16
c_func
(paren
id|thisVUC
op_amp
l_int|0x7fff
)paren
suffix:semicolon
singleline_comment|//&t;&t;printk(&quot;Setting VirtUnitNum on EUN %d to %x&bslash;n&quot;, targetEUN, thisVUC);
id|oob.u.a.ReplUnitNum
op_assign
id|oob.u.a.SpareReplUnitNum
op_assign
l_int|0xffff
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|oob.u.b.WearInfo
op_assign
id|cpu_to_le32
c_func
(paren
l_int|3
)paren
suffix:semicolon
singleline_comment|// We don&squot;t use this, but M-Systems&squot; drivers do
id|oob.u.b.EraseMark
op_assign
id|oob.u.b.EraseMark1
op_assign
id|cpu_to_le16
c_func
(paren
l_int|0x3c69
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
r_default
suffix:colon
id|oob.u.c.WriteInh
op_assign
l_int|0xffffffff
suffix:semicolon
id|oob.u.c.unused
op_assign
l_int|0xffffffff
suffix:semicolon
)brace
r_if
c_cond
(paren
id|thisNFTL-&gt;mtd
op_member_access_from_pointer
id|read_ecc
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|thisNFTL-&gt;EraseSize
op_star
id|BlockMap
(braket
id|block
)braket
)paren
op_plus
(paren
id|block
op_star
l_int|512
)paren
comma
l_int|512
comma
op_amp
id|retlen
comma
id|movebuf
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
op_eq
op_minus
id|EIO
)paren
(brace
r_if
c_cond
(paren
id|thisNFTL-&gt;mtd
op_member_access_from_pointer
id|read_ecc
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|thisNFTL-&gt;EraseSize
op_star
id|BlockMap
(braket
id|block
)braket
)paren
op_plus
(paren
id|block
op_star
l_int|512
)paren
comma
l_int|512
comma
op_amp
id|retlen
comma
id|movebuf
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
op_ne
op_minus
id|EIO
)paren
id|printk
c_func
(paren
l_string|&quot;Error went away on retry.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|thisNFTL-&gt;mtd
op_member_access_from_pointer
id|write_ecc
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|thisNFTL-&gt;EraseSize
op_star
id|targetEUN
)paren
op_plus
(paren
id|block
op_star
l_int|512
)paren
comma
l_int|512
comma
op_amp
id|retlen
comma
id|movebuf
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
multiline_comment|/* FIXME: Add some error checking.... */
id|thisNFTL-&gt;mtd
op_member_access_from_pointer
id|write_oob
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|thisNFTL-&gt;EraseSize
op_star
id|targetEUN
)paren
op_plus
(paren
id|block
op_star
l_int|512
)paren
comma
l_int|16
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
)brace
multiline_comment|/* OK. We&squot;ve moved the whole lot into the new block. Now we have to free the original blocks. */
multiline_comment|/* At this point, we have two different chains for this Virtual Unit, and no way to tell &n;&t;   them apart. If we crash now, we get confused. However, both contain the same data, so we&n;&t;   shouldn&squot;t actually lose data in this case. It&squot;s just that when we load up on a medium which&n;&t;   has duplicate chains, we need to free one of the chains because it&squot;s not necessary any more.&n;&t;*/
id|thisEUN
op_assign
id|thisNFTL-&gt;EUNtable
(braket
id|thisVUC
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Want to erase&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* For each block in the old chain (except the targetEUN of course), &n;&t;   free it and make it available for future use */
r_while
c_loop
(paren
id|thisEUN
op_le
id|thisNFTL-&gt;lastEUN
op_logical_and
id|thisEUN
op_ne
id|targetEUN
)paren
(brace
r_int
id|retlen
suffix:semicolon
r_struct
id|erase_info
op_star
id|instr
suffix:semicolon
id|u16
id|EUNtmp
suffix:semicolon
id|instr
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|erase_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|instr
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Out of memory for struct erase_info&bslash;n&quot;
)paren
suffix:semicolon
id|EUNtmp
op_assign
id|thisEUN
suffix:semicolon
id|thisEUN
op_assign
id|thisNFTL-&gt;ReplUnitTable
(braket
id|EUNtmp
)braket
op_amp
l_int|0x7fff
suffix:semicolon
id|thisNFTL-&gt;VirtualUnitTable
(braket
id|EUNtmp
)braket
op_assign
l_int|0x7fff
suffix:semicolon
id|thisNFTL-&gt;ReplUnitTable
(braket
id|EUNtmp
)braket
op_assign
l_int|0xffff
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
id|instr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|erase_info
)paren
)paren
suffix:semicolon
id|instr-&gt;addr
op_assign
id|thisEUN
op_star
id|thisNFTL-&gt;EraseSize
suffix:semicolon
id|instr-&gt;len
op_assign
id|thisNFTL-&gt;EraseSize
suffix:semicolon
id|MTD_ERASE
c_func
(paren
id|thisNFTL-&gt;mtd
comma
id|instr
)paren
suffix:semicolon
multiline_comment|/* This is an async interface. Or will be. At which point&n;&t;&t;&t;   this code will break. */
macro_line|#if 0
id|MTD_READOOB
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|thisEUN
op_star
id|thisNFTL-&gt;EraseSize
)paren
op_plus
l_int|512
comma
l_int|16
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;After erasing, EUN %d contains: %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X&bslash;n&quot;
comma
id|thisEUN
comma
id|oob.b.ECCSig
(braket
l_int|0
)braket
comma
id|oob.b.ECCSig
(braket
l_int|1
)braket
comma
id|oob.b.ECCSig
(braket
l_int|2
)braket
comma
id|oob.b.ECCSig
(braket
l_int|3
)braket
comma
id|oob.b.ECCSig
(braket
l_int|4
)braket
comma
id|oob.b.ECCSig
(braket
l_int|5
)braket
)paren
suffix:semicolon
macro_line|#endif
id|memset
c_func
(paren
op_amp
id|oob
comma
l_int|0xff
comma
r_sizeof
(paren
id|oob
)paren
)paren
suffix:semicolon
id|oob.u.b.WearInfo
op_assign
id|cpu_to_le32
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|oob.u.b.EraseMark
op_assign
id|oob.u.b.EraseMark1
op_assign
id|cpu_to_le16
c_func
(paren
l_int|0x3c69
)paren
suffix:semicolon
id|MTD_WRITEOOB
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|thisEUN
op_star
id|thisNFTL-&gt;EraseSize
)paren
op_plus
l_int|512
comma
l_int|16
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
id|EUNtmp
op_assign
id|thisEUN
suffix:semicolon
id|thisEUN
op_assign
id|thisNFTL-&gt;ReplUnitTable
(braket
id|EUNtmp
)braket
op_amp
l_int|0x7fff
suffix:semicolon
id|thisNFTL-&gt;VirtualUnitTable
(braket
id|EUNtmp
)braket
op_assign
l_int|0xffff
suffix:semicolon
id|thisNFTL-&gt;ReplUnitTable
(braket
id|EUNtmp
)braket
op_assign
l_int|0xffff
suffix:semicolon
id|thisNFTL-&gt;numfreeEUNs
op_increment
suffix:semicolon
)brace
singleline_comment|// shifted upwards:&t;thisEUN = thisNFTL-&gt;ReplUnitTable[thisEUN] &amp; 0x7fff;
)brace
multiline_comment|/* Make this the new start of chain for thisVUC */
id|thisNFTL-&gt;VirtualUnitTable
(braket
id|targetEUN
)braket
op_assign
id|thisVUC
suffix:semicolon
id|thisNFTL-&gt;ReplUnitTable
(braket
id|targetEUN
)braket
op_assign
l_int|0xffff
suffix:semicolon
id|thisNFTL-&gt;EUNtable
(braket
id|thisVUC
)braket
op_assign
id|targetEUN
suffix:semicolon
r_return
id|targetEUN
suffix:semicolon
)brace
DECL|function|NFTL_makefreeblock
id|u16
id|NFTL_makefreeblock
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|thisNFTL
comma
r_int
id|pendingblock
)paren
(brace
multiline_comment|/* This is the part that needs some cleverness applied. &n;&t;   For now, I&squot;m doing the minimum applicable to actually&n;&t;   get the thing to work.&n;&t;   Wear-levelling and other clever stuff needs to be implemented&n;&t;   and we also need to do some assessment of the results when&n;&t;   the system loses power half-way through the routine.&n;&t;*/
id|u16
id|LongestChain
op_assign
l_int|0
suffix:semicolon
id|u16
id|ChainLength
op_assign
l_int|0
comma
id|thislen
suffix:semicolon
id|u16
id|chain
comma
id|EUN
suffix:semicolon
r_for
c_loop
(paren
id|chain
op_assign
l_int|0
suffix:semicolon
id|chain
OL
id|thisNFTL-&gt;MediaHdr.FormattedSize
op_div
id|thisNFTL-&gt;EraseSize
suffix:semicolon
id|chain
op_increment
)paren
(brace
id|EUN
op_assign
id|thisNFTL-&gt;EUNtable
(braket
id|chain
)braket
suffix:semicolon
id|thislen
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|EUN
op_le
id|thisNFTL-&gt;lastEUN
)paren
(brace
id|thislen
op_increment
suffix:semicolon
singleline_comment|//&t;&t;&t;printk(&quot;VUC %d reaches len %d with EUN %d&bslash;n&quot;, chain, thislen, EUN);
id|EUN
op_assign
id|thisNFTL-&gt;ReplUnitTable
(braket
id|EUN
)braket
op_amp
l_int|0x7fff
suffix:semicolon
r_if
c_cond
(paren
id|thislen
OG
l_int|0xff00
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Endless loop in Virtual Chain %d: Unit %x&bslash;n&quot;
comma
id|chain
comma
id|EUN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|thislen
OG
l_int|0xff10
)paren
(brace
multiline_comment|/* Actually, don&squot;t return failure. Just ignore this chain and&n;&t;&t;&t;&t;   get on with it. */
id|thislen
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|thislen
OG
id|ChainLength
)paren
(brace
singleline_comment|//&t;&t;&t;printk(&quot;New longest chain is %d with length %d&bslash;n&quot;, chain, thislen);
id|ChainLength
op_assign
id|thislen
suffix:semicolon
id|LongestChain
op_assign
id|chain
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ChainLength
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No Virtual Unit Chains available for folding. Failing request&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
r_return
id|NFTL_foldchain
(paren
id|thisNFTL
comma
id|LongestChain
comma
id|pendingblock
)paren
suffix:semicolon
)brace
multiline_comment|/* NFTL_findwriteunit: Return the unit number into which we can write &n;                       for this block. Make it available if it isn&squot;t already&n;*/
DECL|function|NFTL_findwriteunit
r_static
r_inline
id|u16
id|NFTL_findwriteunit
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|thisNFTL
comma
r_int
id|block
)paren
(brace
id|u16
id|lastEUN
suffix:semicolon
id|u16
id|thisVUC
op_assign
id|block
op_div
(paren
id|thisNFTL-&gt;EraseSize
op_div
l_int|512
)paren
suffix:semicolon
id|u16
id|writeEUN
suffix:semicolon
r_int
r_int
id|blockofs
op_assign
(paren
id|block
op_star
l_int|512
)paren
op_amp
(paren
id|thisNFTL-&gt;EraseSize
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|silly
op_assign
l_int|0x10000
comma
id|silly2
op_assign
l_int|3
suffix:semicolon
r_struct
id|nftl_oob
id|oob
suffix:semicolon
r_int
id|debug
op_assign
l_int|0
suffix:semicolon
r_do
(brace
multiline_comment|/* Scan the media to find a unit in the VUC which has&n;&t;&t;   a free space for the block in question.&n;&t;&t;*/
multiline_comment|/* This condition catches the 0x[7f]fff cases, as well as &n;&t;&t;   being a sanity check for past-end-of-media access&n;&t;&t;*/
id|lastEUN
op_assign
l_int|0xffff
suffix:semicolon
id|writeEUN
op_assign
id|thisNFTL-&gt;EUNtable
(braket
id|thisVUC
)braket
suffix:semicolon
r_while
c_loop
(paren
id|writeEUN
op_le
id|thisNFTL-&gt;lastEUN
)paren
(brace
r_struct
id|nftl_bci
id|bci
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|lastEUN
op_assign
id|writeEUN
suffix:semicolon
id|MTD_READOOB
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|writeEUN
op_star
id|thisNFTL-&gt;EraseSize
)paren
op_plus
id|blockofs
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|bci
)paren
suffix:semicolon
r_if
c_cond
(paren
id|debug
)paren
id|printk
c_func
(paren
l_string|&quot;Status of block %d in EUN %d is %x&bslash;n&quot;
comma
id|block
comma
id|writeEUN
comma
id|le16_to_cpu
c_func
(paren
id|bci.Status
)paren
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bci.Status
)paren
(brace
r_case
id|__constant_cpu_to_le16
c_func
(paren
id|BLOCK_FREE
)paren
suffix:colon
r_return
id|writeEUN
suffix:semicolon
r_case
id|__constant_cpu_to_le16
c_func
(paren
id|BLOCK_DELETED
)paren
suffix:colon
r_case
id|__constant_cpu_to_le16
c_func
(paren
id|BLOCK_USED
)paren
suffix:colon
r_case
id|__constant_cpu_to_le16
c_func
(paren
id|BLOCK_IGNORE
)paren
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
singleline_comment|// Invalid block. Don&squot;t use it any more. Must implement.
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Infinite loop in Virtual Unit Chain 0x%x&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/* Skip to next block in chain */
id|writeEUN
op_assign
id|thisNFTL-&gt;ReplUnitTable
(braket
id|writeEUN
)braket
op_amp
l_int|0x7fff
suffix:semicolon
)brace
multiline_comment|/* OK. We didn&squot;t find one in the existing chain, or there &n;&t;&t;   is no existing chain. */
multiline_comment|/* Try to find an already-free block */
id|writeEUN
op_assign
id|NFTL_findfreeblock
c_func
(paren
id|thisNFTL
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|writeEUN
op_eq
l_int|0xffff
)paren
(brace
multiline_comment|/* That didn&squot;t work - there were no free blocks just&n;&t;&t;&t;   waiting to be picked up. We&squot;re going to have to fold&n;&t;&t;&t;   a chain to make room.&n;&t;&t;&t;*/
multiline_comment|/* First remember the start of this chain */
singleline_comment|//&t;&t;&t;u16 startEUN = thisNFTL-&gt;EUNtable[thisVUC];
singleline_comment|//printk(&quot;Write to VirtualUnitChain %d, calling makefreeblock()&bslash;n&quot;, thisVUC);
id|writeEUN
op_assign
id|NFTL_makefreeblock
c_func
(paren
id|thisNFTL
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|writeEUN
op_eq
l_int|0xffff
)paren
(brace
multiline_comment|/* Ouch. This should never happen - we should&n;&t;&t;&t;&t;   always be able to make some room somehow. &n;&t;&t;&t;&t;   If we get here, we&squot;ve allocated more storage &n;&t;&t;&t;&t;   space than actual media, or our makefreeblock&n;&t;&t;&t;&t;   routine is missing something.&n;&t;&t;&t;&t;*/
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Cannot make free space.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
singleline_comment|//&t;&t;&t;printk(&quot;Restarting scan&bslash;n&quot;);
id|lastEUN
op_assign
l_int|0xffff
suffix:semicolon
singleline_comment|//&t;&t;&t;debug = 1;
r_continue
suffix:semicolon
macro_line|#if 0
r_if
c_cond
(paren
id|startEUN
op_ne
id|thisNFTL-&gt;EUNtable
(braket
id|thisVUC
)braket
)paren
(brace
multiline_comment|/* The fold operation has moved the chain &n;&t;&t;&t;&t;   that we&squot;re looking at. Start the scan again.&n;&t;&t;&t;&t;*/
r_continue
suffix:semicolon
)brace
macro_line|#endif
)brace
multiline_comment|/* We&squot;ve found a free block. Insert it into the chain. */
r_if
c_cond
(paren
id|lastEUN
op_ne
l_int|0xffff
)paren
(brace
multiline_comment|/* Addition to an existing chain. Make the previous&n;&t;&t;&t;   last block in the chain point to this one.&n;&t;&t;&t;*/
singleline_comment|//printk(&quot;Linking EUN %d to EUN %d in VUC %d&bslash;n&quot;, 
singleline_comment|//&t;&t;&t;       lastEUN, writeEUN, thisVUC);
multiline_comment|/* Both in our cache... */
id|thisNFTL-&gt;ReplUnitTable
(braket
id|lastEUN
)braket
op_assign
id|writeEUN
suffix:semicolon
multiline_comment|/* ... and on the flash itself */
id|MTD_READOOB
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|lastEUN
op_star
id|thisNFTL-&gt;EraseSize
)paren
comma
l_int|16
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
id|oob.u.a.ReplUnitNum
op_assign
id|oob.u.a.SpareReplUnitNum
op_assign
id|cpu_to_le16
c_func
(paren
id|writeEUN
)paren
suffix:semicolon
id|MTD_WRITEOOB
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|lastEUN
op_star
id|thisNFTL-&gt;EraseSize
)paren
comma
l_int|16
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
id|thisVUC
op_or_assign
l_int|0x8000
suffix:semicolon
multiline_comment|/* It&squot;s a replacement block */
)brace
r_else
(brace
multiline_comment|/* The first block in a new chain */
id|thisNFTL-&gt;EUNtable
(braket
id|thisVUC
)braket
op_assign
id|writeEUN
suffix:semicolon
)brace
multiline_comment|/* Now set up the actual EUN we&squot;re writing into */
multiline_comment|/* Both in our cache... */
id|thisNFTL-&gt;VirtualUnitTable
(braket
id|writeEUN
)braket
op_assign
id|thisVUC
suffix:semicolon
id|thisNFTL-&gt;ReplUnitTable
(braket
id|writeEUN
)braket
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* ... and on the flash itself */
id|MTD_READOOB
c_func
(paren
id|thisNFTL-&gt;mtd
comma
id|writeEUN
op_star
id|thisNFTL-&gt;EraseSize
comma
l_int|16
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
id|oob.u.a.VirtUnitNum
op_assign
id|oob.u.a.SpareVirtUnitNum
op_assign
id|cpu_to_le16
c_func
(paren
id|thisVUC
)paren
suffix:semicolon
id|MTD_WRITEOOB
c_func
(paren
id|thisNFTL-&gt;mtd
comma
id|writeEUN
op_star
id|thisNFTL-&gt;EraseSize
comma
l_int|16
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
r_return
id|writeEUN
suffix:semicolon
)brace
r_while
c_loop
(paren
id|silly2
op_decrement
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Error folding to make room for Virtual Unit Chain 0x%x&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
DECL|function|NFTL_writeblock
r_static
r_int
id|NFTL_writeblock
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|thisNFTL
comma
r_int
id|block
comma
r_char
op_star
id|buffer
)paren
(brace
id|u16
id|writeEUN
suffix:semicolon
r_int
r_int
id|blockofs
op_assign
(paren
id|block
op_star
l_int|512
)paren
op_amp
(paren
id|thisNFTL-&gt;EraseSize
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|u16
id|eccbuf
(braket
l_int|8
)braket
suffix:semicolon
singleline_comment|//&t;if (thisEUN == 0xffff) thisEUN = 0;
id|writeEUN
op_assign
id|NFTL_findwriteunit
c_func
(paren
id|thisNFTL
comma
id|block
)paren
suffix:semicolon
singleline_comment|//&t;printk(&quot;writeblock(%d): Write to Unit %d&bslash;n&quot;, block, writeEUN);
r_if
c_cond
(paren
id|writeEUN
op_eq
l_int|0xffff
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NFTL_writeblock(): Cannot find block to write to&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* If we _still_ haven&squot;t got a block to use, we&squot;re screwed */
r_return
l_int|1
suffix:semicolon
)brace
singleline_comment|//&t;&t;printk(&quot;Writing block %lx to EUN %x&bslash;n&quot;,block, writeEUN);
id|thisNFTL-&gt;mtd
op_member_access_from_pointer
id|write_ecc
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|writeEUN
op_star
id|thisNFTL-&gt;EraseSize
)paren
op_plus
id|blockofs
comma
l_int|512
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
id|buffer
comma
(paren
r_char
op_star
)paren
id|eccbuf
)paren
suffix:semicolon
id|eccbuf
(braket
l_int|3
)braket
op_assign
id|BLOCK_USED
suffix:semicolon
id|eccbuf
(braket
l_int|4
)braket
op_assign
id|eccbuf
(braket
l_int|5
)braket
op_assign
id|eccbuf
(braket
l_int|6
)braket
op_assign
id|eccbuf
(braket
l_int|7
)braket
op_assign
l_int|0xffff
suffix:semicolon
id|thisNFTL-&gt;mtd
op_member_access_from_pointer
id|write_oob
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|writeEUN
op_star
id|thisNFTL-&gt;EraseSize
)paren
op_plus
id|blockofs
comma
l_int|16
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
id|eccbuf
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_NFTL_RW */
DECL|function|NFTL_readblock
r_static
r_int
id|NFTL_readblock
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|thisNFTL
comma
r_int
id|block
comma
r_char
op_star
id|buffer
)paren
(brace
id|u16
id|lastgoodEUN
op_assign
l_int|0xffff
suffix:semicolon
id|u16
id|thisEUN
op_assign
id|thisNFTL-&gt;EUNtable
(braket
id|block
op_div
(paren
id|thisNFTL-&gt;EraseSize
op_div
l_int|512
)paren
)braket
suffix:semicolon
r_int
r_int
id|blockofs
op_assign
(paren
id|block
op_star
l_int|512
)paren
op_amp
(paren
id|thisNFTL-&gt;EraseSize
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|silly
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|thisEUN
op_eq
l_int|0xffff
)paren
id|thisEUN
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|thisEUN
op_logical_and
(paren
id|thisEUN
op_amp
l_int|0x7fff
)paren
op_ne
l_int|0x7fff
)paren
(brace
r_struct
id|nftl_bci
id|bci
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|MTD_READOOB
c_func
(paren
id|thisNFTL-&gt;mtd
comma
(paren
id|thisEUN
op_star
id|thisNFTL-&gt;EraseSize
)paren
op_plus
id|blockofs
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|bci
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|bci.Status
)paren
(brace
r_case
id|__constant_cpu_to_le16
c_func
(paren
id|BLOCK_FREE
)paren
suffix:colon
id|thisEUN
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
r_case
id|__constant_cpu_to_le16
c_func
(paren
id|BLOCK_USED
)paren
suffix:colon
id|lastgoodEUN
op_assign
id|thisEUN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|__constant_cpu_to_le16
c_func
(paren
id|BLOCK_IGNORE
)paren
suffix:colon
r_case
id|__constant_cpu_to_le16
c_func
(paren
id|BLOCK_DELETED
)paren
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unknown status for block %d in EUN %d: %x&bslash;n&quot;
comma
id|block
comma
id|thisEUN
comma
id|bci.Status
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Infinite loop in Virtual Unit Chain 0x%x&bslash;n&quot;
comma
id|block
op_div
(paren
id|thisNFTL-&gt;EraseSize
op_div
l_int|512
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|thisEUN
)paren
id|thisEUN
op_assign
id|thisNFTL-&gt;ReplUnitTable
(braket
id|thisEUN
)braket
op_amp
l_int|0x7fff
suffix:semicolon
)brace
r_if
c_cond
(paren
id|lastgoodEUN
op_eq
l_int|0xffff
)paren
(brace
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
l_int|512
)paren
suffix:semicolon
)brace
r_else
(brace
id|loff_t
id|ptr
op_assign
(paren
id|lastgoodEUN
op_star
id|thisNFTL-&gt;EraseSize
)paren
op_plus
id|blockofs
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|u_char
id|eccbuf
(braket
l_int|6
)braket
suffix:semicolon
id|thisNFTL-&gt;mtd
op_member_access_from_pointer
id|read_ecc
c_func
(paren
id|thisNFTL-&gt;mtd
comma
id|ptr
comma
l_int|512
comma
op_amp
id|retlen
comma
id|buffer
comma
id|eccbuf
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nftl_ioctl
r_static
r_int
id|nftl_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|NFTLrecord
op_star
id|thisNFTL
suffix:semicolon
id|thisNFTL
op_assign
id|NFTLs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_div
l_int|16
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thisNFTL
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
(brace
r_struct
id|hd_geometry
id|g
suffix:semicolon
id|g.heads
op_assign
id|thisNFTL-&gt;heads
suffix:semicolon
id|g.sectors
op_assign
id|thisNFTL-&gt;sectors
suffix:semicolon
id|g.cylinders
op_assign
id|thisNFTL-&gt;cylinders
suffix:semicolon
id|g.start
op_assign
id|part_table
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|start_sect
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|g
comma
r_sizeof
id|g
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
r_case
id|BLKGETSIZE
suffix:colon
multiline_comment|/* Return device size */
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|part_table
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|nr_sects
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|BLKFLSBUF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
(brace
r_return
op_minus
id|EACCES
suffix:semicolon
)brace
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thisNFTL-&gt;mtd-&gt;sync
)paren
id|thisNFTL-&gt;mtd
op_member_access_from_pointer
id|sync
c_func
(paren
id|thisNFTL-&gt;mtd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRRPART
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|thisNFTL-&gt;usecount
OG
l_int|1
)paren
(brace
singleline_comment|//&t;&t;&t;printk(&quot;Use count %d&bslash;n&quot;, thisNFTL-&gt;usecount);
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &lt; 0x20328
id|resetup_one_dev
c_func
(paren
op_amp
id|nftl_gendisk
comma
id|MINOR
c_func
(paren
id|inode-&gt;i_dev
)paren
op_div
l_int|16
)paren
suffix:semicolon
macro_line|#else
id|grok_partitions
c_func
(paren
op_amp
id|nftl_gendisk
comma
id|MINOR
c_func
(paren
id|inode-&gt;i_dev
)paren
op_div
l_int|16
comma
l_int|1
op_lshift
l_int|4
comma
id|thisNFTL-&gt;nr_sects
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
singleline_comment|//        RO_IOCTLS(inode-&gt;i_rdev, arg);  /* ref. linux/blk.h */
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|nftl_request
r_void
id|nftl_request
c_func
(paren
id|RQFUNC_ARG
)paren
(brace
r_int
r_int
id|dev
comma
id|block
comma
id|nsect
suffix:semicolon
r_struct
id|NFTLrecord
op_star
id|thisNFTL
suffix:semicolon
r_char
op_star
id|buffer
suffix:semicolon
r_struct
id|request
op_star
id|req
suffix:semicolon
r_int
id|res
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|INIT_REQUEST
suffix:semicolon
multiline_comment|/* blk.h */
id|req
op_assign
id|CURRENT
suffix:semicolon
macro_line|#ifdef WE_KNOW_WTF_THIS_DOES_NOT_WORK
id|blkdev_dequeue_request
c_func
(paren
id|req
)paren
suffix:semicolon
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
macro_line|#else
id|req
op_assign
id|CURRENT
suffix:semicolon
macro_line|#endif&t;&t;
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;NFTL_request&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;NFTL %d request, %lx, %lx&quot;
comma
id|req-&gt;cmd
comma
id|req-&gt;sector
comma
id|req-&gt;current_nr_sectors
)paren
suffix:semicolon
id|dev
op_assign
id|MINOR
c_func
(paren
id|req-&gt;rq_dev
)paren
suffix:semicolon
id|block
op_assign
id|req-&gt;sector
suffix:semicolon
id|nsect
op_assign
id|req-&gt;current_nr_sectors
suffix:semicolon
id|buffer
op_assign
id|req-&gt;buffer
suffix:semicolon
id|res
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* succeed */
r_if
c_cond
(paren
id|dev
op_ge
id|MAX_NFTLS
op_star
l_int|16
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;fl: bad minor number: device=%s&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|req-&gt;rq_dev
)paren
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* fail */
r_goto
id|repeat
suffix:semicolon
)brace
id|thisNFTL
op_assign
id|NFTLs
(braket
id|dev
op_div
l_int|16
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;Waiting for mutex&bslash;n&quot;
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|thisNFTL-&gt;mutex
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;Got mutex&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
op_plus
id|nsect
op_ge
id|part_table
(braket
id|dev
)braket
dot
id|nr_sects
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;nftl%c%d: bad access: block=%d, count=%d&bslash;n&quot;
comma
(paren
id|MINOR
c_func
(paren
id|req-&gt;rq_dev
)paren
op_rshift
l_int|6
)paren
op_plus
l_char|&squot;a&squot;
comma
id|dev
op_amp
l_int|0xf
comma
id|block
comma
id|nsect
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|thisNFTL-&gt;mutex
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* fail */
r_goto
id|repeat
suffix:semicolon
)brace
id|block
op_add_assign
id|part_table
(braket
id|dev
)braket
dot
id|start_sect
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;cmd
op_eq
id|READ
)paren
(brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;NFTL read&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|nsect
OG
l_int|0
suffix:semicolon
id|nsect
op_decrement
comma
id|block
op_increment
comma
id|buffer
op_add_assign
l_int|512
)paren
(brace
multiline_comment|/* Read a single sector to req-&gt;buffer + (512 * i) */
r_if
c_cond
(paren
id|NFTL_readblock
c_func
(paren
id|thisNFTL
comma
id|block
comma
id|buffer
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;NFTL read request failed&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|thisNFTL-&gt;mutex
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;NFTL read request completed OK&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|thisNFTL-&gt;mutex
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|req-&gt;cmd
op_eq
id|WRITE
)paren
(brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;NFTL write request of 0x%x sectors @ %x (req-&gt;nr_sectors == %lx&bslash;n&quot;
comma
id|nsect
comma
id|block
comma
id|req-&gt;nr_sectors
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NFTL_RW
r_for
c_loop
(paren
suffix:semicolon
id|nsect
OG
l_int|0
suffix:semicolon
id|nsect
op_decrement
comma
id|block
op_increment
comma
id|buffer
op_add_assign
l_int|512
)paren
(brace
multiline_comment|/* Read a single sector to req-&gt;buffer + (512 * i) */
r_if
c_cond
(paren
id|NFTL_writeblock
c_func
(paren
id|thisNFTL
comma
id|block
comma
id|buffer
)paren
)paren
(brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;NFTL write request failed&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|thisNFTL-&gt;mutex
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;NFTL write request completed OK&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|res
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Writes always fail */
macro_line|#endif /* CONFIG_NFTL_RW */
id|up
c_func
(paren
op_amp
id|thisNFTL-&gt;mutex
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_else
(brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;NFTL ??? request&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|thisNFTL-&gt;mutex
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|repeat
suffix:colon
id|DEBUG
c_func
(paren
l_int|3
comma
l_string|&quot;end_request(%d)&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
macro_line|#ifdef WE_KNOW_WTF_THIS_DOES_NOT_WORK
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|nftl_end_request
c_func
(paren
id|req
comma
id|res
)paren
suffix:semicolon
macro_line|#else
id|end_request
c_func
(paren
id|res
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
DECL|function|nftl_open
r_static
r_int
id|nftl_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_struct
id|NFTLrecord
op_star
id|thisNFTL
suffix:semicolon
id|thisNFTL
op_assign
id|NFTLs
(braket
id|MINOR
c_func
(paren
id|ip-&gt;i_rdev
)paren
op_div
l_int|16
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;NFTL_open&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|thisNFTL
)paren
(brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;ENODEV: thisNFTL = %d, minor = %d, ip = %p, fp = %p&bslash;n&quot;
comma
id|MINOR
c_func
(paren
id|ip-&gt;i_rdev
)paren
op_div
l_int|16
comma
id|ip-&gt;i_rdev
comma
id|ip
comma
id|fp
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_NFTL_RW
r_if
c_cond
(paren
id|fp-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
macro_line|#endif /* !CONFIG_NFTL_RW */
id|thisNFTL-&gt;usecount
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_mtd_device
c_func
(paren
id|thisNFTL-&gt;mtd
comma
op_minus
l_int|1
)paren
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
multiline_comment|/* -E&squot;SBUGGEREDOFF */
op_minus
id|ENXIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nftl_release
r_static
r_int
id|nftl_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|get_super
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|NFTLrecord
op_star
id|thisNFTL
suffix:semicolon
id|thisNFTL
op_assign
id|NFTLs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_div
l_int|16
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;NFTL_release&bslash;n&quot;
)paren
suffix:semicolon
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
)paren
id|invalidate_inodes
c_func
(paren
id|sb
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thisNFTL-&gt;mtd-&gt;sync
)paren
id|thisNFTL-&gt;mtd
op_member_access_from_pointer
id|sync
c_func
(paren
id|thisNFTL-&gt;mtd
)paren
suffix:semicolon
id|thisNFTL-&gt;usecount
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|put_mtd_device
c_func
(paren
id|thisNFTL-&gt;mtd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &lt; 0x20326
DECL|variable|nftl_fops
r_static
r_struct
id|file_operations
id|nftl_fops
op_assign
(brace
id|read
suffix:colon
id|block_read
comma
id|write
suffix:colon
id|block_write
comma
id|ioctl
suffix:colon
id|nftl_ioctl
comma
id|open
suffix:colon
id|nftl_open
comma
id|release
suffix:colon
id|nftl_release
comma
id|fsync
suffix:colon
id|block_fsync
comma
)brace
suffix:semicolon
macro_line|#else
DECL|variable|nftl_fops
r_static
r_struct
id|block_device_operations
id|nftl_fops
op_assign
(brace
id|open
suffix:colon
id|nftl_open
comma
id|release
suffix:colon
id|nftl_release
comma
id|ioctl
suffix:colon
id|nftl_ioctl
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/****************************************************************************&n; *&n; * Module stuff&n; *&n; ****************************************************************************/
macro_line|#if LINUX_VERSION_CODE &lt; 0x20300
macro_line|#ifdef MODULE
DECL|macro|init_nftl
mdefine_line|#define init_nftl init_module
DECL|macro|cleanup_nftl
mdefine_line|#define cleanup_nftl cleanup_module
macro_line|#endif
DECL|macro|__exit
mdefine_line|#define __exit
macro_line|#endif
DECL|variable|nftl_notifier
r_static
r_struct
id|mtd_notifier
id|nftl_notifier
op_assign
(brace
id|NFTL_notify_add
comma
id|NFTL_notify_remove
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* static int __init init_nftl(void) */
DECL|function|init_nftl
r_int
id|__init
id|init_nftl
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;M-Systems NAND Flash Translation Layer driver. (C) 1999 MVHI&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef PRERELEASE 
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;$Id: nftl.c,v 1.36 2000/07/13 14:14:20 dwmw2 Exp $&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|NFTL_MAJOR
comma
l_string|&quot;nftl&quot;
comma
op_amp
id|nftl_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unable to register NFTL block device&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
macro_line|#if LINUX_VERSION_CODE &lt; 0x20320
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|nftl_request
suffix:semicolon
macro_line|#else
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
op_amp
id|nftl_request
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nftl_blocksizes
(braket
id|i
)braket
op_assign
l_int|1024
suffix:semicolon
)brace
id|blksize_size
(braket
id|NFTL_MAJOR
)braket
op_assign
id|nftl_blocksizes
suffix:semicolon
id|nftl_gendisk.next
op_assign
id|gendisk_head
suffix:semicolon
id|gendisk_head
op_assign
op_amp
id|nftl_gendisk
suffix:semicolon
)brace
id|register_mtd_user
c_func
(paren
op_amp
id|nftl_notifier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_nftl
r_static
r_void
id|__exit
id|cleanup_nftl
c_func
(paren
r_void
)paren
(brace
r_struct
id|gendisk
op_star
id|gd
comma
op_star
op_star
id|gdp
suffix:semicolon
id|unregister_mtd_user
c_func
(paren
op_amp
id|nftl_notifier
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|NFTL_MAJOR
comma
l_string|&quot;nftl&quot;
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; 0x20320
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
l_int|0
suffix:semicolon
macro_line|#else
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
macro_line|#endif&t;
r_for
c_loop
(paren
id|gdp
op_assign
op_amp
id|gendisk_head
suffix:semicolon
op_star
id|gdp
suffix:semicolon
id|gdp
op_assign
op_amp
(paren
(paren
op_star
id|gdp
)paren
op_member_access_from_pointer
id|next
)paren
)paren
r_if
c_cond
(paren
op_star
id|gdp
op_eq
op_amp
id|nftl_gendisk
)paren
(brace
id|gd
op_assign
op_star
id|gdp
suffix:semicolon
op_star
id|gdp
op_assign
id|gd-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#if LINUX_VERSION_CODE &gt; 0x20300
DECL|variable|init_nftl
id|module_init
c_func
(paren
id|init_nftl
)paren
suffix:semicolon
DECL|variable|cleanup_nftl
id|module_exit
c_func
(paren
id|cleanup_nftl
)paren
suffix:semicolon
macro_line|#endif
eof
