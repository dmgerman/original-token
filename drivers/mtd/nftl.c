multiline_comment|/* Linux driver for NAND Flash Translation Layer      */
multiline_comment|/* (c) 1999 Machine Vision Holdings, Inc.             */
multiline_comment|/* Author: David Woodhouse &lt;dwmw2@infradead.org&gt;      */
multiline_comment|/* $Id: nftl.c,v 1.57 2000/12/01 17:51:54 dwmw2 Exp $ */
multiline_comment|/*&n;  The contents of this file are distributed under the GNU General&n;  Public License version 2 (&quot;GPL&quot;). The author places no additional&n;  restrictions of any kind on it. However, local legislation in some&n;  countries may restrict the use of the algorithms implemented by this&n;  code in certain circumstances.&n;&n;  The legal note below refers only to the _use_ of the code in the &n;  affected jurisdictions, and does not in any way affect the copying,&n;  distribution and modification of this code, which are permitted, and&n;  indeed required, under the terms of the GPL.&n;&n;  Section 0 of the GPL says:&n; &quot;Activities other than copying, distribution and modification are not&n;  covered by this License; they are outside its scope.&quot;&n;&n;  You may copy, distribute and modify this code to your hearts&squot;&n;  content - it&squot;s just that in some jurisdictions, you may only _use_&n;  it under the terms of the patent grant below. This puts it in a&n;  similar situation to the ISDN code, which you may need telco&n;  approval to use, and indeed any code which has uses that may be&n;  restricted in law. For example, certain malicious uses of the&n;  networking stack may be illegal, but that doesn&squot;t prevent the&n;  networking code from being under GPL.&n;&n;  In fact the ISDN case is worse than this, because modification of&n;  the code automatically invalidates its approval. Modification,&n;  unlike usage, _is_ one of the rights which is protected by the&n;  GPL. Happily, the law in those places where approval is required&n;  doesn&squot;t actually prevent you from modifying the code - it&squot;s just&n;  that you may not be allowed to _use_ it once you&squot;ve done so - and&n;  because usage isn&squot;t addressed by the GPL, that&squot;s just fine.&n;&n;  dwmw2@infradead.org&n;  30/10/0&n;&n;  LEGAL NOTE: The NFTL format is patented by M-Systems.  They have&n;  granted a licence for its use with their DiskOnChip products:&n;&n;    &quot;M-Systems grants a royalty-free, non-exclusive license under&n;    any presently existing M-Systems intellectual property rights&n;    necessary for the design and development of NFTL-compatible&n;    drivers, file systems and utilities to use the data formats with, &n;    and solely to support, M-Systems&squot; DiskOnChip products&quot;&n;&n;  A signed copy of this agreement from M-Systems is kept on file by&n;  Red Hat UK Limited. In the unlikely event that you need access to it,&n;  please contact dwmw2@redhat.com for assistance.  */
DECL|macro|PRERELEASE
mdefine_line|#define PRERELEASE
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#ifdef CONFIG_KMOD
macro_line|#include &lt;linux/kmod.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nftl.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt;
multiline_comment|/* maximum number of loops while examining next block, to have a&n;   chance to detect consistency problems (they should never happen&n;   because of the checks done in the mounting */
DECL|macro|MAX_LOOPS
mdefine_line|#define MAX_LOOPS 10000
multiline_comment|/* NFTL block device stuff */
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR NFTL_MAJOR
DECL|macro|DEVICE_REQUEST
mdefine_line|#define DEVICE_REQUEST nftl_request
DECL|macro|DEVICE_OFF
mdefine_line|#define DEVICE_OFF(device)
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
multiline_comment|/* Linux-specific block device functions */
multiline_comment|/* I _HATE_ the Linux block device setup more than anything else I&squot;ve ever&n; *  encountered, except ...&n; */
DECL|variable|nftl_sizes
r_static
r_int
id|nftl_sizes
(braket
l_int|256
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
DECL|variable|nftl_blocksizes
r_static
r_int
id|nftl_blocksizes
(braket
l_int|256
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* .. for the Linux partition table handling. */
DECL|variable|part_table
r_struct
id|hd_struct
id|part_table
(braket
l_int|256
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|0
)brace
comma
)brace
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; 0x20328
DECL|function|dummy_init
r_static
r_void
id|dummy_init
(paren
r_struct
id|gendisk
op_star
id|crap
)paren
(brace
)brace
macro_line|#endif
DECL|variable|nftl_gendisk
r_static
r_struct
id|gendisk
id|nftl_gendisk
op_assign
(brace
id|MAJOR_NR
comma
multiline_comment|/* Major number */
l_string|&quot;nftl&quot;
comma
multiline_comment|/* Major name */
l_int|4
comma
multiline_comment|/* Bits to shift to get real from partition */
l_int|15
comma
multiline_comment|/* Number of partitions per real */
macro_line|#if LINUX_VERSION_CODE &lt; 0x20328
id|MAX_NFTLS
comma
multiline_comment|/* maximum number of real */
id|dummy_init
comma
multiline_comment|/* init function */
macro_line|#endif
id|part_table
comma
multiline_comment|/* hd struct */
id|nftl_sizes
comma
multiline_comment|/* block sizes */
l_int|0
comma
multiline_comment|/* number */
l_int|NULL
comma
multiline_comment|/* internal use, not presently used */
l_int|NULL
multiline_comment|/* next */
)brace
suffix:semicolon
DECL|variable|NFTLs
r_struct
id|NFTLrecord
op_star
id|NFTLs
(braket
id|MAX_NFTLS
)braket
op_assign
(brace
l_int|NULL
)brace
suffix:semicolon
DECL|function|NFTL_setup
r_static
r_void
id|NFTL_setup
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_int
id|i
suffix:semicolon
r_struct
id|NFTLrecord
op_star
id|nftl
suffix:semicolon
r_int
r_int
id|temp
suffix:semicolon
r_int
id|firstfree
op_assign
op_minus
l_int|1
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;NFTL_setup&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NFTLS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|NFTLs
(braket
id|i
)braket
op_logical_and
id|firstfree
op_eq
op_minus
l_int|1
)paren
id|firstfree
op_assign
id|i
suffix:semicolon
r_else
r_if
c_cond
(paren
id|NFTLs
(braket
id|i
)braket
op_logical_and
id|NFTLs
(braket
id|i
)braket
op_member_access_from_pointer
id|mtd
op_eq
id|mtd
)paren
(brace
multiline_comment|/* This is a Spare Media Header for an NFTL we&squot;ve already found */
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;MTD already mounted as NFTL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|firstfree
op_eq
op_minus
l_int|1
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No more NFTL slot available&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|nftl
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|NFTLrecord
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nftl
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Out of memory for NFTL data structures&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|init_MUTEX
c_func
(paren
op_amp
id|nftl-&gt;mutex
)paren
suffix:semicolon
multiline_comment|/* get physical parameters */
id|nftl-&gt;EraseSize
op_assign
id|mtd-&gt;erasesize
suffix:semicolon
id|nftl-&gt;nb_blocks
op_assign
id|mtd-&gt;size
op_div
id|mtd-&gt;erasesize
suffix:semicolon
id|nftl-&gt;mtd
op_assign
id|mtd
suffix:semicolon
r_if
c_cond
(paren
id|NFTL_mount
c_func
(paren
id|nftl
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Could not mount NFTL device&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|nftl
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* OK, it&squot;s a new one. Set up all the data structures. */
macro_line|#ifdef PSYCHO_DEBUG
id|printk
c_func
(paren
l_string|&quot;Found new NFTL nftl%c&bslash;n&quot;
comma
id|firstfree
op_plus
l_char|&squot;a&squot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* linux stuff */
id|nftl-&gt;usecount
op_assign
l_int|0
suffix:semicolon
id|nftl-&gt;cylinders
op_assign
l_int|1024
suffix:semicolon
id|nftl-&gt;heads
op_assign
l_int|16
suffix:semicolon
id|temp
op_assign
id|nftl-&gt;cylinders
op_star
id|nftl-&gt;heads
suffix:semicolon
id|nftl-&gt;sectors
op_assign
id|nftl-&gt;nr_sects
op_div
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|nftl-&gt;nr_sects
op_mod
id|temp
)paren
(brace
id|nftl-&gt;sectors
op_increment
suffix:semicolon
id|temp
op_assign
id|nftl-&gt;cylinders
op_star
id|nftl-&gt;sectors
suffix:semicolon
id|nftl-&gt;heads
op_assign
id|nftl-&gt;nr_sects
op_div
id|temp
suffix:semicolon
r_if
c_cond
(paren
id|nftl-&gt;nr_sects
op_mod
id|temp
)paren
(brace
id|nftl-&gt;heads
op_increment
suffix:semicolon
id|temp
op_assign
id|nftl-&gt;heads
op_star
id|nftl-&gt;sectors
suffix:semicolon
id|nftl-&gt;cylinders
op_assign
id|nftl-&gt;nr_sects
op_div
id|temp
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nftl-&gt;nr_sects
op_ne
id|nftl-&gt;heads
op_star
id|nftl-&gt;cylinders
op_star
id|nftl-&gt;sectors
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Cannot calculate an NFTL geometry to &quot;
l_string|&quot;match size of 0x%lx.&bslash;n&quot;
comma
id|nftl-&gt;nr_sects
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Using C:%d H:%d S:%d (== 0x%lx sects)&bslash;n&quot;
comma
id|nftl-&gt;cylinders
comma
id|nftl-&gt;heads
comma
id|nftl-&gt;sectors
comma
(paren
r_int
)paren
id|nftl-&gt;cylinders
op_star
(paren
r_int
)paren
id|nftl-&gt;heads
op_star
(paren
r_int
)paren
id|nftl-&gt;sectors
)paren
suffix:semicolon
multiline_comment|/* Oh no we don&squot;t have nftl-&gt;nr_sects = nftl-&gt;heads * nftl-&gt;cylinders * nftl-&gt;sectors; */
)brace
id|NFTLs
(braket
id|firstfree
)braket
op_assign
id|nftl
suffix:semicolon
multiline_comment|/* Finally, set up the block device sizes */
id|nftl_sizes
(braket
id|firstfree
op_star
l_int|16
)braket
op_assign
id|nftl-&gt;nr_sects
suffix:semicolon
singleline_comment|//nftl_blocksizes[firstfree*16] = 512;
id|part_table
(braket
id|firstfree
op_star
l_int|16
)braket
dot
id|nr_sects
op_assign
id|nftl-&gt;nr_sects
suffix:semicolon
multiline_comment|/* partition check ... */
macro_line|#if LINUX_VERSION_CODE &lt; 0x20328
id|resetup_one_dev
c_func
(paren
op_amp
id|nftl_gendisk
comma
id|firstfree
)paren
suffix:semicolon
macro_line|#else
id|grok_partitions
c_func
(paren
op_amp
id|nftl_gendisk
comma
id|firstfree
comma
l_int|1
op_lshift
l_int|4
comma
id|nftl-&gt;nr_sects
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|NFTL_unsetup
r_static
r_void
id|NFTL_unsetup
c_func
(paren
r_int
id|i
)paren
(brace
r_struct
id|NFTLrecord
op_star
id|nftl
op_assign
id|NFTLs
(braket
id|i
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;NFTL_unsetup %d&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|NFTLs
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
id|nftl-&gt;ReplUnitTable
)paren
id|kfree
c_func
(paren
id|nftl-&gt;ReplUnitTable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nftl-&gt;EUNtable
)paren
id|kfree
c_func
(paren
id|nftl-&gt;EUNtable
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|nftl
)paren
suffix:semicolon
)brace
multiline_comment|/* Search the MTD device for NFTL partitions */
DECL|function|NFTL_notify_add
r_static
r_void
id|NFTL_notify_add
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;NFTL_notify_add for %s&bslash;n&quot;
comma
id|mtd-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mtd
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|mtd-&gt;read_oob
)paren
(brace
multiline_comment|/* If this MTD doesn&squot;t have out-of-band data,&n;&t;&t;&t;   then there&squot;s no point continuing */
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;No OOB data, quitting&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;mtd-&gt;read = %p, size = %d, erasesize = %d&bslash;n&quot;
comma
id|mtd-&gt;read
comma
id|mtd-&gt;size
comma
id|mtd-&gt;erasesize
)paren
suffix:semicolon
id|NFTL_setup
c_func
(paren
id|mtd
)paren
suffix:semicolon
)brace
)brace
DECL|function|NFTL_notify_remove
r_static
r_void
id|NFTL_notify_remove
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_NFTLS
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|NFTLs
(braket
id|i
)braket
op_logical_and
id|NFTLs
(braket
id|i
)braket
op_member_access_from_pointer
id|mtd
op_eq
id|mtd
)paren
id|NFTL_unsetup
c_func
(paren
id|i
)paren
suffix:semicolon
)brace
)brace
macro_line|#ifdef CONFIG_NFTL_RW
multiline_comment|/* Actual NFTL access routines */
multiline_comment|/* NFTL_findfreeblock: Find a free Erase Unit on the NFTL partition. This function is used&n; *&t;when the give Virtual Unit Chain&n; */
DECL|function|NFTL_findfreeblock
r_static
id|u16
id|NFTL_findfreeblock
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
id|desperate
)paren
(brace
multiline_comment|/* For a given Virtual Unit Chain: find or create a free block and&n;&t;   add it to the chain */
multiline_comment|/* We&squot;re passed the number of the last EUN in the chain, to save us from&n;&t;   having to look it up again */
id|u16
id|pot
op_assign
id|nftl-&gt;LastFreeEUN
suffix:semicolon
r_int
id|silly
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Normally, we force a fold to happen before we run out of free blocks completely */
r_if
c_cond
(paren
op_logical_neg
id|desperate
op_logical_and
id|nftl-&gt;numfreeEUNs
OL
l_int|2
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;NFTL_findfreeblock: there are too few free EUNs&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/* Scan for a free block */
r_do
(brace
r_if
c_cond
(paren
id|nftl-&gt;ReplUnitTable
(braket
id|pot
)braket
op_eq
id|BLOCK_FREE
)paren
(brace
id|nftl-&gt;LastFreeEUN
op_assign
id|pot
suffix:semicolon
id|nftl-&gt;numfreeEUNs
op_decrement
suffix:semicolon
r_return
id|pot
suffix:semicolon
)brace
multiline_comment|/* This will probably point to the MediaHdr unit itself,&n;&t;&t;   right at the beginning of the partition. But that unit&n;&t;&t;   (and the backup unit too) should have the UCI set&n;&t;&t;   up so that it&squot;s not selected for overwriting */
r_if
c_cond
(paren
op_increment
id|pot
OG
id|nftl-&gt;lastEUN
)paren
id|pot
op_assign
id|le16_to_cpu
c_func
(paren
id|nftl-&gt;MediaHdr.FirstPhysicalEUN
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Argh! No free blocks found! LastFreeEUN = %d, &quot;
l_string|&quot;FirstEUN = %d&bslash;n&quot;
comma
id|nftl-&gt;LastFreeEUN
comma
id|le16_to_cpu
c_func
(paren
id|nftl-&gt;MediaHdr.FirstPhysicalEUN
)paren
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|pot
op_ne
id|nftl-&gt;LastFreeEUN
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
DECL|function|NFTL_foldchain
r_static
id|u16
id|NFTL_foldchain
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
id|thisVUC
comma
r_int
id|pendingblock
)paren
(brace
id|u16
id|BlockMap
(braket
id|MAX_SECTORS_PER_UNIT
)braket
suffix:semicolon
r_int
r_char
id|BlockLastState
(braket
id|MAX_SECTORS_PER_UNIT
)braket
suffix:semicolon
r_int
r_char
id|BlockFreeFound
(braket
id|MAX_SECTORS_PER_UNIT
)braket
suffix:semicolon
r_int
r_int
id|thisEUN
suffix:semicolon
r_int
id|block
suffix:semicolon
r_int
id|silly
suffix:semicolon
r_int
r_int
id|targetEUN
suffix:semicolon
r_struct
id|nftl_oob
id|oob
suffix:semicolon
r_int
id|inplace
op_assign
l_int|1
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|memset
c_func
(paren
id|BlockMap
comma
l_int|0xff
comma
r_sizeof
(paren
id|BlockMap
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|BlockFreeFound
comma
l_int|0
comma
r_sizeof
(paren
id|BlockFreeFound
)paren
)paren
suffix:semicolon
id|thisEUN
op_assign
id|nftl-&gt;EUNtable
(braket
id|thisVUC
)braket
suffix:semicolon
r_if
c_cond
(paren
id|thisEUN
op_eq
id|BLOCK_NIL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Trying to fold non-existent &quot;
l_string|&quot;Virtual Unit Chain %d!&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
id|BLOCK_NIL
suffix:semicolon
)brace
multiline_comment|/* Scan to find the Erase Unit which holds the actual data for each&n;&t;   512-byte block within the Chain.&n;&t;*/
id|silly
op_assign
id|MAX_LOOPS
suffix:semicolon
id|targetEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
r_while
c_loop
(paren
id|thisEUN
op_le
id|nftl-&gt;lastEUN
)paren
(brace
r_int
r_int
id|status
comma
id|foldmark
suffix:semicolon
id|targetEUN
op_assign
id|thisEUN
suffix:semicolon
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|nftl-&gt;EraseSize
op_div
l_int|512
suffix:semicolon
id|block
op_increment
)paren
(brace
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mtd
comma
(paren
id|thisEUN
op_star
id|nftl-&gt;EraseSize
)paren
op_plus
(paren
id|block
op_star
l_int|512
)paren
comma
l_int|16
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
op_eq
l_int|2
)paren
(brace
id|foldmark
op_assign
id|oob.u.c.FoldMark
op_or
id|oob.u.c.FoldMark1
suffix:semicolon
r_if
c_cond
(paren
id|foldmark
op_eq
id|FOLD_MARK_IN_PROGRESS
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;Write Inhibited on EUN %d&bslash;n&quot;
comma
id|thisEUN
)paren
suffix:semicolon
id|inplace
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* There&squot;s no other reason not to do inplace,&n;&t;&t;&t;&t;&t;   except ones that come later. So we don&squot;t need&n;&t;&t;&t;&t;&t;   to preserve inplace */
id|inplace
op_assign
l_int|1
suffix:semicolon
)brace
)brace
id|status
op_assign
id|oob.b.Status
op_or
id|oob.b.Status1
suffix:semicolon
id|BlockLastState
(braket
id|block
)braket
op_assign
id|status
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SECTOR_FREE
suffix:colon
id|BlockFreeFound
(braket
id|block
)braket
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SECTOR_USED
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|BlockFreeFound
(braket
id|block
)braket
)paren
id|BlockMap
(braket
id|block
)braket
op_assign
id|thisEUN
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;SECTOR_USED found after SECTOR_FREE &quot;
l_string|&quot;in Virtual Unit Chain %d for block %d&bslash;n&quot;
comma
id|thisVUC
comma
id|block
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SECTOR_IGNORE
suffix:colon
r_case
id|SECTOR_DELETED
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unknown status for block %d in EUN %d: %x&bslash;n&quot;
comma
id|block
comma
id|thisEUN
comma
id|status
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Infinite loop in Virtual Unit Chain 0x%x&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
id|BLOCK_NIL
suffix:semicolon
)brace
id|thisEUN
op_assign
id|nftl-&gt;ReplUnitTable
(braket
id|thisEUN
)braket
suffix:semicolon
)brace
r_if
c_cond
(paren
id|inplace
)paren
(brace
multiline_comment|/* We&squot;re being asked to be a fold-in-place. Check&n;&t;&t;   that all blocks are either present or SECTOR_FREE&n;&t;&t;   in the target block. If not, we&squot;re going to have&n;&t;&t;   to fold out-of-place anyway.&n;&t;&t;*/
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|nftl-&gt;EraseSize
op_div
l_int|512
suffix:semicolon
id|block
op_increment
)paren
(brace
r_if
c_cond
(paren
id|BlockLastState
(braket
id|block
)braket
op_ne
id|SECTOR_FREE
op_logical_and
id|BlockMap
(braket
id|block
)braket
op_ne
id|targetEUN
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;Setting inplace to 0. VUC %d, &quot;
l_string|&quot;block %d was %x lastEUN, &quot;
l_string|&quot;and is in EUN %d (%s) %d&bslash;n&quot;
comma
id|thisVUC
comma
id|block
comma
id|BlockLastState
(braket
id|block
)braket
comma
id|BlockMap
(braket
id|block
)braket
comma
id|BlockMap
(braket
id|block
)braket
op_eq
id|targetEUN
ques
c_cond
l_string|&quot;==&quot;
suffix:colon
l_string|&quot;!=&quot;
comma
id|targetEUN
)paren
suffix:semicolon
id|inplace
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pendingblock
op_ge
(paren
id|thisVUC
op_star
(paren
id|nftl-&gt;EraseSize
op_div
l_int|512
)paren
)paren
op_logical_and
id|pendingblock
OL
(paren
(paren
id|thisVUC
op_plus
l_int|1
)paren
op_star
(paren
id|nftl-&gt;EraseSize
op_div
l_int|512
)paren
)paren
op_logical_and
id|BlockLastState
(braket
id|pendingblock
op_minus
(paren
id|thisVUC
op_star
(paren
id|nftl-&gt;EraseSize
op_div
l_int|512
)paren
)paren
)braket
op_ne
id|SECTOR_FREE
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;Pending write not free in EUN %d. &quot;
l_string|&quot;Folding out of place.&bslash;n&quot;
comma
id|targetEUN
)paren
suffix:semicolon
id|inplace
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|inplace
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;Cannot fold Virtual Unit Chain %d in place. &quot;
l_string|&quot;Trying out-of-place&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
multiline_comment|/* We need to find a targetEUN to fold into. */
id|targetEUN
op_assign
id|NFTL_findfreeblock
c_func
(paren
id|nftl
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|targetEUN
op_eq
id|BLOCK_NIL
)paren
(brace
multiline_comment|/* Ouch. Now we&squot;re screwed. We need to do a &n;&t;&t;&t;   fold-in-place of another chain to make room&n;&t;&t;&t;   for this one. We need a better way of selecting&n;&t;&t;&t;   which chain to fold, because makefreeblock will &n;&t;&t;&t;   only ask us to fold the same one again.&n;&t;&t;&t;*/
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NFTL_findfreeblock(desperate) returns 0xffff.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|BLOCK_NIL
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* We put a fold mark in the chain we are folding only if&n;               we fold in place to help the mount check code. If we do&n;               not fold in place, it is possible to find the valid&n;               chain by selecting the longer one */
id|oob.u.c.FoldMark
op_assign
id|oob.u.c.FoldMark1
op_assign
id|cpu_to_le16
c_func
(paren
id|FOLD_MARK_IN_PROGRESS
)paren
suffix:semicolon
id|oob.u.c.unused
op_assign
l_int|0xffffffff
suffix:semicolon
id|MTD_WRITEOOB
c_func
(paren
id|nftl-&gt;mtd
comma
(paren
id|nftl-&gt;EraseSize
op_star
id|targetEUN
)paren
op_plus
l_int|2
op_star
l_int|512
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
)brace
multiline_comment|/* OK. We now know the location of every block in the Virtual Unit Chain,&n;&t;   and the Erase Unit into which we are supposed to be copying.&n;&t;   Go for it.&n;&t;*/
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;Folding chain %d into unit %d&bslash;n&quot;
comma
id|thisVUC
comma
id|targetEUN
)paren
suffix:semicolon
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|nftl-&gt;EraseSize
op_div
l_int|512
suffix:semicolon
id|block
op_increment
)paren
(brace
r_int
r_char
id|movebuf
(braket
l_int|512
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* If it&squot;s in the target EUN already, or if it&squot;s pending write, do nothing */
r_if
c_cond
(paren
id|BlockMap
(braket
id|block
)braket
op_eq
id|targetEUN
op_logical_or
(paren
id|pendingblock
op_eq
(paren
id|thisVUC
op_star
(paren
id|nftl-&gt;EraseSize
op_div
l_int|512
)paren
op_plus
id|block
)paren
)paren
)paren
(brace
r_continue
suffix:semicolon
)brace
multiline_comment|/* copy only in non free block (free blocks can only&n;                   happen in case of media errors or deleted blocks) */
r_if
c_cond
(paren
id|BlockMap
(braket
id|block
)braket
op_eq
id|BLOCK_NIL
)paren
r_continue
suffix:semicolon
id|ret
op_assign
id|MTD_READECC
c_func
(paren
id|nftl-&gt;mtd
comma
(paren
id|nftl-&gt;EraseSize
op_star
id|BlockMap
(braket
id|block
)braket
)paren
op_plus
(paren
id|block
op_star
l_int|512
)paren
comma
l_int|512
comma
op_amp
id|retlen
comma
id|movebuf
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
OL
l_int|0
)paren
(brace
id|ret
op_assign
id|MTD_READECC
c_func
(paren
id|nftl-&gt;mtd
comma
(paren
id|nftl-&gt;EraseSize
op_star
id|BlockMap
(braket
id|block
)braket
)paren
op_plus
(paren
id|block
op_star
l_int|512
)paren
comma
l_int|512
comma
op_amp
id|retlen
comma
id|movebuf
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
op_ne
op_minus
id|EIO
)paren
id|printk
c_func
(paren
l_string|&quot;Error went away on retry.&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|MTD_WRITEECC
c_func
(paren
id|nftl-&gt;mtd
comma
(paren
id|nftl-&gt;EraseSize
op_star
id|targetEUN
)paren
op_plus
(paren
id|block
op_star
l_int|512
)paren
comma
l_int|512
comma
op_amp
id|retlen
comma
id|movebuf
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
suffix:semicolon
)brace
multiline_comment|/* add the header so that it is now a valid chain */
id|oob.u.a.VirtUnitNum
op_assign
id|oob.u.a.SpareVirtUnitNum
op_assign
id|cpu_to_le16
c_func
(paren
id|thisVUC
)paren
suffix:semicolon
id|oob.u.a.ReplUnitNum
op_assign
id|oob.u.a.SpareReplUnitNum
op_assign
l_int|0xffff
suffix:semicolon
id|MTD_WRITEOOB
c_func
(paren
id|nftl-&gt;mtd
comma
(paren
id|nftl-&gt;EraseSize
op_star
id|targetEUN
)paren
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
multiline_comment|/* OK. We&squot;ve moved the whole lot into the new block. Now we have to free the original blocks. */
multiline_comment|/* At this point, we have two different chains for this Virtual Unit, and no way to tell &n;&t;   them apart. If we crash now, we get confused. However, both contain the same data, so we&n;&t;   shouldn&squot;t actually lose data in this case. It&squot;s just that when we load up on a medium which&n;&t;   has duplicate chains, we need to free one of the chains because it&squot;s not necessary any more.&n;&t;*/
id|thisEUN
op_assign
id|nftl-&gt;EUNtable
(braket
id|thisVUC
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;Want to erase&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* For each block in the old chain (except the targetEUN of course), &n;&t;   free it and make it available for future use */
r_while
c_loop
(paren
id|thisEUN
op_le
id|nftl-&gt;lastEUN
op_logical_and
id|thisEUN
op_ne
id|targetEUN
)paren
(brace
r_int
r_int
id|EUNtmp
suffix:semicolon
id|EUNtmp
op_assign
id|nftl-&gt;ReplUnitTable
(braket
id|thisEUN
)braket
suffix:semicolon
r_if
c_cond
(paren
id|NFTL_formatblock
c_func
(paren
id|nftl
comma
id|thisEUN
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* could not erase : mark block as reserved&n;&t;&t;&t; * FixMe: Update Bad Unit Table on disk&n;&t;&t;&t; */
id|nftl-&gt;ReplUnitTable
(braket
id|thisEUN
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* correctly erased : mark it as free */
id|nftl-&gt;ReplUnitTable
(braket
id|thisEUN
)braket
op_assign
id|BLOCK_FREE
suffix:semicolon
id|nftl-&gt;numfreeEUNs
op_increment
suffix:semicolon
)brace
id|thisEUN
op_assign
id|EUNtmp
suffix:semicolon
)brace
multiline_comment|/* Make this the new start of chain for thisVUC */
id|nftl-&gt;ReplUnitTable
(braket
id|targetEUN
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
id|nftl-&gt;EUNtable
(braket
id|thisVUC
)braket
op_assign
id|targetEUN
suffix:semicolon
r_return
id|targetEUN
suffix:semicolon
)brace
DECL|function|NFTL_makefreeblock
id|u16
id|NFTL_makefreeblock
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
id|pendingblock
)paren
(brace
multiline_comment|/* This is the part that needs some cleverness applied. &n;&t;   For now, I&squot;m doing the minimum applicable to actually&n;&t;   get the thing to work.&n;&t;   Wear-levelling and other clever stuff needs to be implemented&n;&t;   and we also need to do some assessment of the results when&n;&t;   the system loses power half-way through the routine.&n;&t;*/
id|u16
id|LongestChain
op_assign
l_int|0
suffix:semicolon
id|u16
id|ChainLength
op_assign
l_int|0
comma
id|thislen
suffix:semicolon
id|u16
id|chain
comma
id|EUN
suffix:semicolon
r_for
c_loop
(paren
id|chain
op_assign
l_int|0
suffix:semicolon
id|chain
OL
id|nftl-&gt;MediaHdr.FormattedSize
op_div
id|nftl-&gt;EraseSize
suffix:semicolon
id|chain
op_increment
)paren
(brace
id|EUN
op_assign
id|nftl-&gt;EUNtable
(braket
id|chain
)braket
suffix:semicolon
id|thislen
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|EUN
op_le
id|nftl-&gt;lastEUN
)paren
(brace
id|thislen
op_increment
suffix:semicolon
singleline_comment|//printk(&quot;VUC %d reaches len %d with EUN %d&bslash;n&quot;, chain, thislen, EUN);
id|EUN
op_assign
id|nftl-&gt;ReplUnitTable
(braket
id|EUN
)braket
op_amp
l_int|0x7fff
suffix:semicolon
r_if
c_cond
(paren
id|thislen
OG
l_int|0xff00
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Endless loop in Virtual Chain %d: Unit %x&bslash;n&quot;
comma
id|chain
comma
id|EUN
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|thislen
OG
l_int|0xff10
)paren
(brace
multiline_comment|/* Actually, don&squot;t return failure. Just ignore this chain and&n;&t;&t;&t;&t;   get on with it. */
id|thislen
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|thislen
OG
id|ChainLength
)paren
(brace
singleline_comment|//printk(&quot;New longest chain is %d with length %d&bslash;n&quot;, chain, thislen);
id|ChainLength
op_assign
id|thislen
suffix:semicolon
id|LongestChain
op_assign
id|chain
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|ChainLength
OL
l_int|2
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No Virtual Unit Chains available for folding. &quot;
l_string|&quot;Failing request&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
r_return
id|NFTL_foldchain
(paren
id|nftl
comma
id|LongestChain
comma
id|pendingblock
)paren
suffix:semicolon
)brace
multiline_comment|/* NFTL_findwriteunit: Return the unit number into which we can write &n;                       for this block. Make it available if it isn&squot;t already&n;*/
DECL|function|NFTL_findwriteunit
r_static
r_inline
id|u16
id|NFTL_findwriteunit
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
id|block
)paren
(brace
id|u16
id|lastEUN
suffix:semicolon
id|u16
id|thisVUC
op_assign
id|block
op_div
(paren
id|nftl-&gt;EraseSize
op_div
l_int|512
)paren
suffix:semicolon
r_int
r_int
id|writeEUN
suffix:semicolon
r_int
r_int
id|blockofs
op_assign
(paren
id|block
op_star
l_int|512
)paren
op_amp
(paren
id|nftl-&gt;EraseSize
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|silly
comma
id|silly2
op_assign
l_int|3
suffix:semicolon
r_struct
id|nftl_oob
id|oob
suffix:semicolon
r_do
(brace
multiline_comment|/* Scan the media to find a unit in the VUC which has&n;&t;&t;   a free space for the block in question.&n;&t;&t;*/
multiline_comment|/* This condition catches the 0x[7f]fff cases, as well as &n;&t;&t;   being a sanity check for past-end-of-media access&n;&t;&t;*/
id|lastEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
id|writeEUN
op_assign
id|nftl-&gt;EUNtable
(braket
id|thisVUC
)braket
suffix:semicolon
id|silly
op_assign
id|MAX_LOOPS
suffix:semicolon
r_while
c_loop
(paren
id|writeEUN
op_le
id|nftl-&gt;lastEUN
)paren
(brace
r_struct
id|nftl_bci
id|bci
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
id|lastEUN
op_assign
id|writeEUN
suffix:semicolon
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mtd
comma
(paren
id|writeEUN
op_star
id|nftl-&gt;EraseSize
)paren
op_plus
id|blockofs
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|bci
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;Status of block %d in EUN %d is %x&bslash;n&quot;
comma
id|block
comma
id|writeEUN
comma
id|le16_to_cpu
c_func
(paren
id|bci.Status
)paren
)paren
suffix:semicolon
id|status
op_assign
id|bci.Status
op_or
id|bci.Status1
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SECTOR_FREE
suffix:colon
r_return
id|writeEUN
suffix:semicolon
r_case
id|SECTOR_DELETED
suffix:colon
r_case
id|SECTOR_USED
suffix:colon
r_case
id|SECTOR_IGNORE
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
singleline_comment|// Invalid block. Don&squot;t use it any more. Must implement.
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Infinite loop in Virtual Unit Chain 0x%x&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
multiline_comment|/* Skip to next block in chain */
id|writeEUN
op_assign
id|nftl-&gt;ReplUnitTable
(braket
id|writeEUN
)braket
suffix:semicolon
)brace
multiline_comment|/* OK. We didn&squot;t find one in the existing chain, or there &n;&t;&t;   is no existing chain. */
multiline_comment|/* Try to find an already-free block */
id|writeEUN
op_assign
id|NFTL_findfreeblock
c_func
(paren
id|nftl
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|writeEUN
op_eq
id|BLOCK_NIL
)paren
(brace
multiline_comment|/* That didn&squot;t work - there were no free blocks just&n;&t;&t;&t;   waiting to be picked up. We&squot;re going to have to fold&n;&t;&t;&t;   a chain to make room.&n;&t;&t;&t;*/
multiline_comment|/* First remember the start of this chain */
singleline_comment|//u16 startEUN = nftl-&gt;EUNtable[thisVUC];
singleline_comment|//printk(&quot;Write to VirtualUnitChain %d, calling makefreeblock()&bslash;n&quot;, thisVUC);
id|writeEUN
op_assign
id|NFTL_makefreeblock
c_func
(paren
id|nftl
comma
l_int|0xffff
)paren
suffix:semicolon
r_if
c_cond
(paren
id|writeEUN
op_eq
id|BLOCK_NIL
)paren
(brace
multiline_comment|/* Ouch. This should never happen - we should&n;&t;&t;&t;&t;   always be able to make some room somehow. &n;&t;&t;&t;&t;   If we get here, we&squot;ve allocated more storage &n;&t;&t;&t;&t;   space than actual media, or our makefreeblock&n;&t;&t;&t;&t;   routine is missing something.&n;&t;&t;&t;&t;*/
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Cannot make free space.&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|BLOCK_NIL
suffix:semicolon
)brace
singleline_comment|//printk(&quot;Restarting scan&bslash;n&quot;);
id|lastEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* We&squot;ve found a free block. Insert it into the chain. */
r_if
c_cond
(paren
id|lastEUN
op_ne
id|BLOCK_NIL
)paren
(brace
id|thisVUC
op_or_assign
l_int|0x8000
suffix:semicolon
multiline_comment|/* It&squot;s a replacement block */
)brace
r_else
(brace
multiline_comment|/* The first block in a new chain */
id|nftl-&gt;EUNtable
(braket
id|thisVUC
)braket
op_assign
id|writeEUN
suffix:semicolon
)brace
multiline_comment|/* set up the actual EUN we&squot;re writing into */
multiline_comment|/* Both in our cache... */
id|nftl-&gt;ReplUnitTable
(braket
id|writeEUN
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
multiline_comment|/* ... and on the flash itself */
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mtd
comma
id|writeEUN
op_star
id|nftl-&gt;EraseSize
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
id|oob.u.a.VirtUnitNum
op_assign
id|oob.u.a.SpareVirtUnitNum
op_assign
id|cpu_to_le16
c_func
(paren
id|thisVUC
)paren
suffix:semicolon
id|MTD_WRITEOOB
c_func
(paren
id|nftl-&gt;mtd
comma
id|writeEUN
op_star
id|nftl-&gt;EraseSize
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
multiline_comment|/* we link the new block to the chain only after the&n;                   block is ready. It avoids the case where the chain&n;                   could point to a free block */
r_if
c_cond
(paren
id|lastEUN
op_ne
id|BLOCK_NIL
)paren
(brace
multiline_comment|/* Both in our cache... */
id|nftl-&gt;ReplUnitTable
(braket
id|lastEUN
)braket
op_assign
id|writeEUN
suffix:semicolon
multiline_comment|/* ... and on the flash itself */
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mtd
comma
(paren
id|lastEUN
op_star
id|nftl-&gt;EraseSize
)paren
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
id|oob.u.a.ReplUnitNum
op_assign
id|oob.u.a.SpareReplUnitNum
op_assign
id|cpu_to_le16
c_func
(paren
id|writeEUN
)paren
suffix:semicolon
id|MTD_WRITEOOB
c_func
(paren
id|nftl-&gt;mtd
comma
(paren
id|lastEUN
op_star
id|nftl-&gt;EraseSize
)paren
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|oob.u
)paren
suffix:semicolon
)brace
r_return
id|writeEUN
suffix:semicolon
)brace
r_while
c_loop
(paren
id|silly2
op_decrement
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Error folding to make room for Virtual Unit Chain 0x%x&bslash;n&quot;
comma
id|thisVUC
)paren
suffix:semicolon
r_return
l_int|0xffff
suffix:semicolon
)brace
DECL|function|NFTL_writeblock
r_static
r_int
id|NFTL_writeblock
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
id|block
comma
r_char
op_star
id|buffer
)paren
(brace
id|u16
id|writeEUN
suffix:semicolon
r_int
r_int
id|blockofs
op_assign
(paren
id|block
op_star
l_int|512
)paren
op_amp
(paren
id|nftl-&gt;EraseSize
op_minus
l_int|1
)paren
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|u8
id|eccbuf
(braket
l_int|6
)braket
suffix:semicolon
id|writeEUN
op_assign
id|NFTL_findwriteunit
c_func
(paren
id|nftl
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|writeEUN
op_eq
id|BLOCK_NIL
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;NFTL_writeblock(): Cannot find block to write to&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* If we _still_ haven&squot;t got a block to use, we&squot;re screwed */
r_return
l_int|1
suffix:semicolon
)brace
id|MTD_WRITEECC
c_func
(paren
id|nftl-&gt;mtd
comma
(paren
id|writeEUN
op_star
id|nftl-&gt;EraseSize
)paren
op_plus
id|blockofs
comma
l_int|512
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
id|buffer
comma
(paren
r_char
op_star
)paren
id|eccbuf
)paren
suffix:semicolon
multiline_comment|/* no need to write SECTOR_USED flags since they are written in mtd_writeecc */
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_NFTL_RW */
DECL|function|NFTL_readblock
r_static
r_int
id|NFTL_readblock
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
id|block
comma
r_char
op_star
id|buffer
)paren
(brace
id|u16
id|lastgoodEUN
suffix:semicolon
id|u16
id|thisEUN
op_assign
id|nftl-&gt;EUNtable
(braket
id|block
op_div
(paren
id|nftl-&gt;EraseSize
op_div
l_int|512
)paren
)braket
suffix:semicolon
r_int
r_int
id|blockofs
op_assign
(paren
id|block
op_star
l_int|512
)paren
op_amp
(paren
id|nftl-&gt;EraseSize
op_minus
l_int|1
)paren
suffix:semicolon
r_int
r_int
id|status
suffix:semicolon
r_int
id|silly
op_assign
id|MAX_LOOPS
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_struct
id|nftl_bci
id|bci
suffix:semicolon
id|lastgoodEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
r_if
c_cond
(paren
id|thisEUN
op_ne
id|BLOCK_NIL
)paren
(brace
r_while
c_loop
(paren
id|thisEUN
OL
id|nftl-&gt;nb_blocks
)paren
(brace
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mtd
comma
(paren
id|thisEUN
op_star
id|nftl-&gt;EraseSize
)paren
op_plus
id|blockofs
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|bci
)paren
OL
l_int|0
)paren
id|status
op_assign
id|SECTOR_IGNORE
suffix:semicolon
r_else
id|status
op_assign
id|bci.Status
op_or
id|bci.Status1
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SECTOR_FREE
suffix:colon
multiline_comment|/* no modification of a sector should follow a free sector */
r_goto
id|the_end
suffix:semicolon
r_case
id|SECTOR_DELETED
suffix:colon
id|lastgoodEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SECTOR_USED
suffix:colon
id|lastgoodEUN
op_assign
id|thisEUN
suffix:semicolon
r_break
suffix:semicolon
r_case
id|SECTOR_IGNORE
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;Unknown status for block %d in EUN %d: %x&bslash;n&quot;
comma
id|block
comma
id|thisEUN
comma
id|status
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|silly
op_decrement
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Infinite loop in Virtual Unit Chain 0x%x&bslash;n&quot;
comma
id|block
op_div
(paren
id|nftl-&gt;EraseSize
op_div
l_int|512
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|thisEUN
op_assign
id|nftl-&gt;ReplUnitTable
(braket
id|thisEUN
)braket
suffix:semicolon
)brace
)brace
id|the_end
suffix:colon
r_if
c_cond
(paren
id|lastgoodEUN
op_eq
id|BLOCK_NIL
)paren
(brace
multiline_comment|/* the requested block is not on the media, return all 0x00 */
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
l_int|512
)paren
suffix:semicolon
)brace
r_else
(brace
id|loff_t
id|ptr
op_assign
(paren
id|lastgoodEUN
op_star
id|nftl-&gt;EraseSize
)paren
op_plus
id|blockofs
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|u_char
id|eccbuf
(braket
l_int|6
)braket
suffix:semicolon
r_if
c_cond
(paren
id|MTD_READECC
c_func
(paren
id|nftl-&gt;mtd
comma
id|ptr
comma
l_int|512
comma
op_amp
id|retlen
comma
id|buffer
comma
id|eccbuf
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nftl_ioctl
r_static
r_int
id|nftl_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|NFTLrecord
op_star
id|nftl
suffix:semicolon
id|nftl
op_assign
id|NFTLs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_div
l_int|16
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|nftl
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
(brace
r_struct
id|hd_geometry
id|g
suffix:semicolon
id|g.heads
op_assign
id|nftl-&gt;heads
suffix:semicolon
id|g.sectors
op_assign
id|nftl-&gt;sectors
suffix:semicolon
id|g.cylinders
op_assign
id|nftl-&gt;cylinders
suffix:semicolon
id|g.start
op_assign
id|part_table
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|start_sect
suffix:semicolon
r_return
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|g
comma
r_sizeof
id|g
)paren
ques
c_cond
op_minus
id|EFAULT
suffix:colon
l_int|0
suffix:semicolon
)brace
r_case
id|BLKGETSIZE
suffix:colon
multiline_comment|/* Return device size */
r_if
c_cond
(paren
op_logical_neg
id|arg
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|put_user
c_func
(paren
id|part_table
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
)braket
dot
id|nr_sects
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_case
id|BLKFLSBUF
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nftl-&gt;mtd-&gt;sync
)paren
id|nftl-&gt;mtd
op_member_access_from_pointer
id|sync
c_func
(paren
id|nftl-&gt;mtd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|BLKRRPART
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
r_if
c_cond
(paren
id|nftl-&gt;usecount
OG
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; 0x20328
id|resetup_one_dev
c_func
(paren
op_amp
id|nftl_gendisk
comma
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_div
l_int|16
)paren
suffix:semicolon
macro_line|#else
id|grok_partitions
c_func
(paren
op_amp
id|nftl_gendisk
comma
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_div
l_int|16
comma
l_int|1
op_lshift
l_int|4
comma
id|nftl-&gt;nr_sects
)paren
suffix:semicolon
macro_line|#endif
r_return
l_int|0
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &lt; 0x20303)&t;&t;
id|RO_IOCTLS
c_func
(paren
id|inode-&gt;i_rdev
comma
id|arg
)paren
suffix:semicolon
multiline_comment|/* ref. linux/blk.h */
macro_line|#else
r_case
id|BLKROSET
suffix:colon
r_case
id|BLKROGET
suffix:colon
r_case
id|BLKSSZGET
suffix:colon
r_return
id|blk_ioctl
c_func
(paren
id|inode-&gt;i_rdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|nftl_request
r_void
id|nftl_request
c_func
(paren
id|RQFUNC_ARG
)paren
(brace
r_int
r_int
id|dev
comma
id|block
comma
id|nsect
suffix:semicolon
r_struct
id|NFTLrecord
op_star
id|nftl
suffix:semicolon
r_char
op_star
id|buffer
suffix:semicolon
r_struct
id|request
op_star
id|req
suffix:semicolon
r_int
id|res
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|INIT_REQUEST
suffix:semicolon
multiline_comment|/* blk.h */
id|req
op_assign
id|CURRENT
suffix:semicolon
multiline_comment|/* We can do this because the generic code knows not to&n;&t;&t;   touch the request at the head of the queue */
id|spin_unlock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;NFTL_request&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;NFTL %s request, from sector 0x%04lx for 0x%04lx sectors&bslash;n&quot;
comma
(paren
id|req-&gt;cmd
op_eq
id|READ
)paren
ques
c_cond
l_string|&quot;Read &quot;
suffix:colon
l_string|&quot;Write&quot;
comma
id|req-&gt;sector
comma
id|req-&gt;current_nr_sectors
)paren
suffix:semicolon
id|dev
op_assign
id|MINOR
c_func
(paren
id|req-&gt;rq_dev
)paren
suffix:semicolon
id|block
op_assign
id|req-&gt;sector
suffix:semicolon
id|nsect
op_assign
id|req-&gt;current_nr_sectors
suffix:semicolon
id|buffer
op_assign
id|req-&gt;buffer
suffix:semicolon
id|res
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* succeed */
r_if
c_cond
(paren
id|dev
op_ge
id|MAX_NFTLS
op_star
l_int|16
)paren
(brace
multiline_comment|/* there is no such partition */
id|printk
c_func
(paren
l_string|&quot;nftl: bad minor number: device = %s&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|req-&gt;rq_dev
)paren
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* fail */
r_goto
id|repeat
suffix:semicolon
)brace
id|nftl
op_assign
id|NFTLs
(braket
id|dev
op_div
l_int|16
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;Waiting for mutex&bslash;n&quot;
)paren
suffix:semicolon
id|down
c_func
(paren
op_amp
id|nftl-&gt;mutex
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;Got mutex&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
op_plus
id|nsect
OG
id|part_table
(braket
id|dev
)braket
dot
id|nr_sects
)paren
(brace
multiline_comment|/* access past the end of device */
id|printk
c_func
(paren
l_string|&quot;nftl%c%d: bad access: block = %d, count = %d&bslash;n&quot;
comma
(paren
id|MINOR
c_func
(paren
id|req-&gt;rq_dev
)paren
op_rshift
l_int|6
)paren
op_plus
l_char|&squot;a&squot;
comma
id|dev
op_amp
l_int|0xf
comma
id|block
comma
id|nsect
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|nftl-&gt;mutex
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* fail */
r_goto
id|repeat
suffix:semicolon
)brace
id|block
op_add_assign
id|part_table
(braket
id|dev
)braket
dot
id|start_sect
suffix:semicolon
r_if
c_cond
(paren
id|req-&gt;cmd
op_eq
id|READ
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;NFTL read request of 0x%x sectors @ %x &quot;
l_string|&quot;(req-&gt;nr_sectors == %lx)&bslash;n&quot;
comma
id|nsect
comma
id|block
comma
id|req-&gt;nr_sectors
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|nsect
OG
l_int|0
suffix:semicolon
id|nsect
op_decrement
comma
id|block
op_increment
comma
id|buffer
op_add_assign
l_int|512
)paren
(brace
multiline_comment|/* Read a single sector to req-&gt;buffer + (512 * i) */
r_if
c_cond
(paren
id|NFTL_readblock
c_func
(paren
id|nftl
comma
id|block
comma
id|buffer
)paren
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;NFTL read request failed&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|nftl-&gt;mutex
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;NFTL read request completed OK&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|nftl-&gt;mutex
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|req-&gt;cmd
op_eq
id|WRITE
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;NFTL write request of 0x%x sectors @ %x &quot;
l_string|&quot;(req-&gt;nr_sectors == %lx)&bslash;n&quot;
comma
id|nsect
comma
id|block
comma
id|req-&gt;nr_sectors
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_NFTL_RW
r_for
c_loop
(paren
suffix:semicolon
id|nsect
OG
l_int|0
suffix:semicolon
id|nsect
op_decrement
comma
id|block
op_increment
comma
id|buffer
op_add_assign
l_int|512
)paren
(brace
multiline_comment|/* Read a single sector to req-&gt;buffer + (512 * i) */
r_if
c_cond
(paren
id|NFTL_writeblock
c_func
(paren
id|nftl
comma
id|block
comma
id|buffer
)paren
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL1
comma
l_string|&quot;NFTL write request failed&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|nftl-&gt;mutex
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
)brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;NFTL write request completed OK&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|res
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Writes always fail */
macro_line|#endif /* CONFIG_NFTL_RW */
id|up
c_func
(paren
op_amp
id|nftl-&gt;mutex
)paren
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
r_else
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL0
comma
l_string|&quot;NFTL unknown request&bslash;n&quot;
)paren
suffix:semicolon
id|up
c_func
(paren
op_amp
id|nftl-&gt;mutex
)paren
suffix:semicolon
id|res
op_assign
l_int|0
suffix:semicolon
r_goto
id|repeat
suffix:semicolon
)brace
id|repeat
suffix:colon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;end_request(%d)&bslash;n&quot;
comma
id|res
)paren
suffix:semicolon
id|spin_lock_irq
c_func
(paren
op_amp
id|io_request_lock
)paren
suffix:semicolon
id|end_request
c_func
(paren
id|res
)paren
suffix:semicolon
)brace
)brace
DECL|function|nftl_open
r_static
r_int
id|nftl_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_int
id|nftlnum
op_assign
id|MINOR
c_func
(paren
id|ip-&gt;i_rdev
)paren
op_div
l_int|16
suffix:semicolon
r_struct
id|NFTLrecord
op_star
id|thisNFTL
suffix:semicolon
id|thisNFTL
op_assign
id|NFTLs
(braket
id|nftlnum
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;NFTL_open&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_KMOD
r_if
c_cond
(paren
op_logical_neg
id|thisNFTL
op_logical_and
id|nftlnum
op_eq
l_int|0
)paren
(brace
id|request_module
c_func
(paren
l_string|&quot;docprobe&quot;
)paren
suffix:semicolon
id|thisNFTL
op_assign
id|NFTLs
(braket
id|nftlnum
)braket
suffix:semicolon
)brace
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|thisNFTL
)paren
(brace
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;ENODEV: thisNFTL = %d, minor = %d, ip = %p, fp = %p&bslash;n&quot;
comma
id|nftlnum
comma
id|ip-&gt;i_rdev
comma
id|ip
comma
id|fp
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#ifndef CONFIG_NFTL_RW
r_if
c_cond
(paren
id|fp-&gt;f_mode
op_amp
id|FMODE_WRITE
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
macro_line|#endif /* !CONFIG_NFTL_RW */
id|thisNFTL-&gt;usecount
op_increment
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_mtd_device
c_func
(paren
id|thisNFTL-&gt;mtd
comma
op_minus
l_int|1
)paren
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
multiline_comment|/* -E&squot;SBUGGEREDOFF */
op_minus
id|ENXIO
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|nftl_release
r_static
r_int
id|nftl_release
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_struct
id|super_block
op_star
id|sb
op_assign
id|get_super
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_struct
id|NFTLrecord
op_star
id|thisNFTL
suffix:semicolon
id|thisNFTL
op_assign
id|NFTLs
(braket
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
op_div
l_int|16
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;NFTL_release&bslash;n&quot;
)paren
suffix:semicolon
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sb
)paren
id|invalidate_inodes
c_func
(paren
id|sb
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|thisNFTL-&gt;mtd-&gt;sync
)paren
id|thisNFTL-&gt;mtd
op_member_access_from_pointer
id|sync
c_func
(paren
id|thisNFTL-&gt;mtd
)paren
suffix:semicolon
id|thisNFTL-&gt;usecount
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|put_mtd_device
c_func
(paren
id|thisNFTL-&gt;mtd
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &lt; 0x20326
DECL|variable|nftl_fops
r_static
r_struct
id|file_operations
id|nftl_fops
op_assign
(brace
id|read
suffix:colon
id|block_read
comma
id|write
suffix:colon
id|block_write
comma
id|ioctl
suffix:colon
id|nftl_ioctl
comma
id|open
suffix:colon
id|nftl_open
comma
id|release
suffix:colon
id|nftl_release
comma
id|fsync
suffix:colon
id|block_fsync
comma
)brace
suffix:semicolon
macro_line|#else
DECL|variable|nftl_fops
r_static
r_struct
id|block_device_operations
id|nftl_fops
op_assign
(brace
id|open
suffix:colon
id|nftl_open
comma
id|release
suffix:colon
id|nftl_release
comma
id|ioctl
suffix:colon
id|nftl_ioctl
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/****************************************************************************&n; *&n; * Module stuff&n; *&n; ****************************************************************************/
macro_line|#if LINUX_VERSION_CODE &lt; 0x20212 &amp;&amp; defined(MODULE)
DECL|macro|init_nftl
mdefine_line|#define init_nftl init_module
DECL|macro|cleanup_nftl
mdefine_line|#define cleanup_nftl cleanup_module
macro_line|#endif
DECL|variable|nftl_notifier
r_static
r_struct
id|mtd_notifier
id|nftl_notifier
op_assign
(brace
id|NFTL_notify_add
comma
id|NFTL_notify_remove
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* static int __init init_nftl(void) */
DECL|function|init_nftl
r_int
id|__init
id|init_nftl
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;M-Systems NAND Flash Translation Layer driver. (C) 1999 MVHI&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#ifdef PRERELEASE 
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;$Id: nftl.c,v 1.57 2000/12/01 17:51:54 dwmw2 Exp $&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;nftl&quot;
comma
op_amp
id|nftl_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;unable to register NFTL block device on major %d&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
r_else
(brace
macro_line|#if LINUX_VERSION_CODE &lt; 0x20320
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|nftl_request
suffix:semicolon
macro_line|#else
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
op_amp
id|nftl_request
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* set block size to 1kB each */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
id|nftl_blocksizes
(braket
id|i
)braket
op_assign
l_int|1024
suffix:semicolon
)brace
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|nftl_blocksizes
suffix:semicolon
id|nftl_gendisk.next
op_assign
id|gendisk_head
suffix:semicolon
id|gendisk_head
op_assign
op_amp
id|nftl_gendisk
suffix:semicolon
)brace
id|register_mtd_user
c_func
(paren
op_amp
id|nftl_notifier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_nftl
r_static
r_void
id|__exit
id|cleanup_nftl
c_func
(paren
r_void
)paren
(brace
r_struct
id|gendisk
op_star
id|gd
comma
op_star
op_star
id|gdp
suffix:semicolon
id|unregister_mtd_user
c_func
(paren
op_amp
id|nftl_notifier
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;nftl&quot;
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; 0x20320
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
l_int|0
suffix:semicolon
macro_line|#else
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
macro_line|#endif&t;
multiline_comment|/* remove ourself from generic harddisk list&n;&t;   FIXME: why can&squot;t I found this partition on /proc/partition */
r_for
c_loop
(paren
id|gdp
op_assign
op_amp
id|gendisk_head
suffix:semicolon
op_star
id|gdp
suffix:semicolon
id|gdp
op_assign
op_amp
(paren
(paren
op_star
id|gdp
)paren
op_member_access_from_pointer
id|next
)paren
)paren
r_if
c_cond
(paren
op_star
id|gdp
op_eq
op_amp
id|nftl_gendisk
)paren
(brace
id|gd
op_assign
op_star
id|gdp
suffix:semicolon
op_star
id|gdp
op_assign
id|gd-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
DECL|variable|init_nftl
id|module_init
c_func
(paren
id|init_nftl
)paren
suffix:semicolon
DECL|variable|cleanup_nftl
id|module_exit
c_func
(paren
id|cleanup_nftl
)paren
suffix:semicolon
eof
