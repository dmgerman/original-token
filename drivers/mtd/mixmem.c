multiline_comment|/* &n; * mixmem - a block device driver for flash rom found on the &n; *          piggyback board of the multi-purpose mixcom card&n; *&n; * Author: Gergely Madarasz &lt;gorgo@itc.hu&gt; &n; *&n; * Copyright (c) 1999 ITConsult-Pro Co. &lt;info@itc.hu&gt;&n; *&n; * This code is GPL&n; *&n; */
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mtd/mapped.h&gt;
DECL|macro|MIXCOM_ID_OFFSET
mdefine_line|#define MIXCOM_ID_OFFSET 0xc10
DECL|macro|MIXCOM_PAGE_OFFSET
mdefine_line|#define MIXCOM_PAGE_OFFSET 0xc11
DECL|macro|MIXCOM_ID_1
mdefine_line|#define MIXCOM_ID_1 0x11
DECL|macro|MIXCOM_ID_2
mdefine_line|#define MIXCOM_ID_2 0x13
DECL|macro|MIXMEM_PAGESIZE
mdefine_line|#define MIXMEM_PAGESIZE 4096
DECL|macro|FIRST_BLOCK_OFFSET
mdefine_line|#define FIRST_BLOCK_OFFSET 0x1000
macro_line|#if LINUX_VERSION_CODE &lt; 0x20300
DECL|macro|__exit
mdefine_line|#define __exit
macro_line|#endif
DECL|variable|mixmem_addrs
r_static
r_int
r_int
id|mixmem_addrs
(braket
)braket
op_assign
(brace
l_int|0xc8000
comma
l_int|0xd8000
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|mixcom_ports
r_static
r_int
r_int
id|mixcom_ports
(braket
)braket
op_assign
(brace
l_int|0x180
comma
l_int|0x280
comma
l_int|0x380
comma
l_int|0
)brace
suffix:semicolon
singleline_comment|// We could store these in the mtd structure, but we only support 1 device..
DECL|variable|base_io
r_static
r_int
r_int
id|base_io
op_assign
l_int|0
suffix:semicolon
DECL|variable|base_addr
r_static
r_int
r_int
id|base_addr
op_assign
l_int|0
suffix:semicolon
DECL|variable|SSD
r_static
r_struct
id|mapped_mtd_info
op_star
id|SSD
suffix:semicolon
DECL|function|mixmem_page
r_static
r_int
r_int
id|mixmem_page
c_func
(paren
r_struct
id|mapped_mtd_info
op_star
id|map
comma
r_int
r_int
id|page
)paren
(brace
id|outb
c_func
(paren
(paren
r_char
)paren
(paren
id|page
op_amp
l_int|0xff
)paren
comma
id|base_io
op_plus
id|MIXCOM_PAGE_OFFSET
)paren
suffix:semicolon
id|outb
c_func
(paren
(paren
r_char
)paren
(paren
(paren
id|page
op_rshift
l_int|8
)paren
op_amp
l_int|0x7
)paren
comma
id|base_io
op_plus
id|MIXCOM_PAGE_OFFSET
op_plus
l_int|1
)paren
suffix:semicolon
r_return
id|base_addr
suffix:semicolon
)brace
DECL|function|flash_probe
r_static
r_int
id|flash_probe
c_func
(paren
r_int
id|base
)paren
(brace
r_int
id|prev
comma
id|curr
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|writeb
c_func
(paren
l_int|0xf0
comma
id|base
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|prev
op_assign
id|readw
c_func
(paren
id|base
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0xaa
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x55
comma
id|base
op_plus
l_int|0x2AA
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x90
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
id|curr
op_assign
id|readw
c_func
(paren
id|base
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0xf0
comma
id|base
)paren
suffix:semicolon
r_return
id|prev
op_eq
id|curr
ques
c_cond
l_int|0
suffix:colon
id|curr
suffix:semicolon
)brace
DECL|function|mixmem_probe
r_static
r_int
id|mixmem_probe
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|id
suffix:semicolon
r_int
id|chip
suffix:semicolon
multiline_comment|/* This should really check to see if the io ports are in use before&n;           writing to them */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mixcom_ports
(braket
id|i
)braket
op_ne
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
id|id
op_assign
id|inb
c_func
(paren
id|mixcom_ports
(braket
id|i
)braket
op_plus
id|MIXCOM_ID_OFFSET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|id
op_eq
id|MIXCOM_ID_1
op_logical_or
id|id
op_eq
id|MIXCOM_ID_2
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mixmem: mixcom board found at 0x%3x&bslash;n&quot;
comma
id|mixcom_ports
(braket
id|i
)braket
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mixcom_ports
(braket
id|i
)braket
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mixmem: no mixcom board found&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|mixcom_ports
(braket
id|i
)braket
op_plus
id|MIXCOM_PAGE_OFFSET
comma
l_int|2
)paren
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
singleline_comment|// What is the deal with first_block_offset?
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|mixmem_addrs
(braket
id|i
)braket
op_ne
l_int|0
suffix:semicolon
id|i
op_increment
)paren
(brace
id|chip
op_assign
id|flash_probe
c_func
(paren
id|mixmem_addrs
(braket
id|i
)braket
op_plus
id|FIRST_BLOCK_OFFSET
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chip
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|mixmem_addrs
(braket
id|i
)braket
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mixmem: no flash available&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|base_io
op_assign
id|mixcom_ports
(braket
id|i
)braket
suffix:semicolon
id|base_addr
op_assign
id|mixmem_addrs
(braket
id|i
)braket
suffix:semicolon
id|request_region
c_func
(paren
id|mixcom_ports
(braket
id|i
)braket
op_plus
id|MIXCOM_PAGE_OFFSET
comma
l_int|2
comma
l_string|&quot;mixmem&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_mixmem
r_static
r_void
id|__exit
id|cleanup_mixmem
c_func
(paren
)paren
(brace
id|mtd_mapped_remove
c_func
(paren
id|SSD
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|SSD
)paren
suffix:semicolon
id|SSD
op_assign
l_int|0
suffix:semicolon
id|release_region
c_func
(paren
id|base_io
op_plus
id|MIXCOM_PAGE_OFFSET
comma
l_int|2
)paren
suffix:semicolon
)brace
singleline_comment|//static int __init init_mixmem(void)
DECL|function|init_mixmem
r_int
id|__init
id|init_mixmem
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|mixmem_probe
c_func
(paren
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EAGAIN
suffix:semicolon
singleline_comment|// Print out our little header..
id|printk
c_func
(paren
l_string|&quot;mixcom MTD IO:0x%lx MEM:0x%lx-0x%lx&bslash;n&quot;
comma
id|base_io
comma
id|base_addr
comma
id|base_addr
op_plus
id|MIXMEM_PAGESIZE
)paren
suffix:semicolon
singleline_comment|// Allocate some memory
id|SSD
op_assign
(paren
r_struct
id|mapped_mtd_info
op_star
)paren
id|kmalloc
c_func
(paren
r_sizeof
(paren
op_star
id|SSD
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|SSD
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
id|SSD
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|SSD
)paren
)paren
suffix:semicolon
singleline_comment|// Setup the MTD structure
id|SSD-&gt;page
op_assign
id|mixmem_page
suffix:semicolon
id|SSD-&gt;pagesize
op_assign
id|MIXMEM_PAGESIZE
suffix:semicolon
id|SSD-&gt;maxsize
op_assign
l_int|0x7FF
suffix:semicolon
id|SSD-&gt;mtd.name
op_assign
l_string|&quot;mixcom piggyback&quot;
suffix:semicolon
singleline_comment|// Setup the MTD, this will sense the flash parameters and so on..
r_if
c_cond
(paren
id|mtd_mapped_setup
c_func
(paren
id|SSD
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Failed to register new device&bslash;n&quot;
)paren
suffix:semicolon
id|cleanup_module
c_func
(paren
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|init_mixmem
id|module_init
c_func
(paren
id|init_mixmem
)paren
suffix:semicolon
DECL|variable|cleanup_mixmem
id|module_exit
c_func
(paren
id|cleanup_mixmem
)paren
suffix:semicolon
eof
