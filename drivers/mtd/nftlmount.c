multiline_comment|/* &n; * NFTL mount code with extensive checks&n; *&n; * Author: Fabrice Bellard (fabrice.bellard@netgem.com) &n; * Copyright (C) 2000 Netgem S.A.&n; *&n; * $Id: nftlmount.c,v 1.11 2000/11/17 12:24:09 ollie Exp $&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2 of the License, or&n; * (at your option) any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; if not, write to the Free Software&n; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nftl.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt;
DECL|macro|SECTORSIZE
mdefine_line|#define SECTORSIZE 512
multiline_comment|/* find_boot_record: Find the NFTL Media Header and its Spare copy which contains the&n; *&t;various device information of the NFTL partition and Bad Unit Table. Update&n; *&t;the ReplUnitTable[] table accroding to the Bad Unit Table. ReplUnitTable[]&n; *&t;is used for management of Erase Unit in other routines in nftl.c and nftlmount.c&n; */
DECL|function|find_boot_record
r_static
r_int
id|find_boot_record
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
)paren
(brace
r_struct
id|nftl_uci1
id|h1
suffix:semicolon
r_struct
id|nftl_oob
id|oob
suffix:semicolon
r_int
r_int
id|block
comma
id|boot_record_count
suffix:semicolon
r_int
id|retlen
suffix:semicolon
id|u8
id|buf
(braket
id|SECTORSIZE
)braket
suffix:semicolon
r_struct
id|NFTLMediaHeader
op_star
id|mh
op_assign
op_amp
id|nftl-&gt;MediaHdr
suffix:semicolon
id|nftl-&gt;MediaUnit
op_assign
id|BLOCK_NIL
suffix:semicolon
id|nftl-&gt;SpareMediaUnit
op_assign
id|BLOCK_NIL
suffix:semicolon
id|boot_record_count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* search for a valid boot record */
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|nftl-&gt;nb_blocks
suffix:semicolon
id|block
op_increment
)paren
(brace
r_int
r_int
id|erase_mark
suffix:semicolon
multiline_comment|/* read ANAND header. To be safer with BIOS, also use erase mark as discriminant */
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mtd
comma
id|block
op_star
id|nftl-&gt;EraseSize
op_plus
id|SECTORSIZE
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|h1
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|erase_mark
op_assign
id|le16_to_cpu
(paren
(paren
id|h1.EraseMark
op_or
id|h1.EraseMark1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|erase_mark
op_ne
id|ERASE_MARK
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|MTD_READECC
c_func
(paren
id|nftl-&gt;mtd
comma
id|block
op_star
id|nftl-&gt;EraseSize
comma
id|SECTORSIZE
comma
op_amp
id|retlen
comma
id|buf
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
OL
l_int|0
)paren
r_continue
suffix:semicolon
id|memcpy
c_func
(paren
id|mh
comma
id|buf
comma
r_sizeof
(paren
r_struct
id|NFTLMediaHeader
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|mh-&gt;DataOrgID
comma
l_string|&quot;ANAND&quot;
comma
l_int|6
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* first boot record */
r_if
c_cond
(paren
id|boot_record_count
op_eq
l_int|0
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
multiline_comment|/* header found : read the bad block table data */
r_if
c_cond
(paren
id|mh-&gt;UnitSizeFactor
op_ne
l_int|0xff
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Sorry, we don&squot;t support UnitSizeFactor &quot;
l_string|&quot;of != 1 yet&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|ReplUnitTable
suffix:semicolon
)brace
id|nftl-&gt;nb_boot_blocks
op_assign
id|le16_to_cpu
c_func
(paren
id|mh-&gt;FirstPhysicalEUN
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|nftl-&gt;nb_boot_blocks
op_plus
l_int|2
)paren
op_ge
id|nftl-&gt;nb_blocks
)paren
r_goto
id|ReplUnitTable
suffix:semicolon
multiline_comment|/* small consistency check */
id|nftl-&gt;numvunits
op_assign
id|le32_to_cpu
c_func
(paren
id|mh-&gt;FormattedSize
)paren
op_div
id|nftl-&gt;EraseSize
suffix:semicolon
r_if
c_cond
(paren
id|nftl-&gt;numvunits
OG
(paren
id|nftl-&gt;nb_blocks
op_minus
id|nftl-&gt;nb_boot_blocks
op_minus
l_int|2
)paren
)paren
r_goto
id|ReplUnitTable
suffix:semicolon
multiline_comment|/* small consistency check */
multiline_comment|/* FixMe: with bad blocks, the total size available is not FormattedSize any&n;&t;&t;&t;&t;   more !!! */
id|nftl-&gt;nr_sects
op_assign
id|nftl-&gt;numvunits
op_star
(paren
id|nftl-&gt;EraseSize
op_div
id|SECTORSIZE
)paren
suffix:semicolon
id|nftl-&gt;MediaUnit
op_assign
id|block
suffix:semicolon
multiline_comment|/* read the Bad Erase Unit Table and modify ReplUnitTable[] accordingly */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nftl-&gt;nb_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|i
op_amp
(paren
id|SECTORSIZE
op_minus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* read one sector for every SECTORSIZE of blocks */
r_if
c_cond
(paren
id|MTD_READECC
c_func
(paren
id|nftl-&gt;mtd
comma
id|block
op_star
id|nftl-&gt;EraseSize
op_plus
id|i
op_plus
id|SECTORSIZE
comma
id|SECTORSIZE
comma
op_amp
id|retlen
comma
id|buf
comma
(paren
r_char
op_star
)paren
op_amp
id|oob
)paren
OL
l_int|0
)paren
r_goto
id|ReplUnitTable
suffix:semicolon
)brace
multiline_comment|/* mark the Bad Erase Unit as RESERVED in ReplUnitTable */
r_if
c_cond
(paren
id|buf
(braket
id|i
op_amp
(paren
id|SECTORSIZE
op_minus
l_int|1
)paren
)braket
op_ne
l_int|0xff
)paren
id|nftl-&gt;ReplUnitTable
(braket
id|i
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
)brace
id|boot_record_count
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|boot_record_count
op_eq
l_int|1
)paren
(brace
id|nftl-&gt;SpareMediaUnit
op_assign
id|block
suffix:semicolon
id|boot_record_count
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|ReplUnitTable
suffix:colon
)brace
r_if
c_cond
(paren
id|boot_record_count
op_eq
l_int|0
)paren
(brace
multiline_comment|/* no boot record found */
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_return
l_int|0
suffix:semicolon
)brace
)brace
DECL|function|memcmpb
r_static
r_int
id|memcmpb
c_func
(paren
r_void
op_star
id|a
comma
r_int
id|c
comma
r_int
id|n
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|n
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|c
op_ne
(paren
(paren
r_int
r_char
op_star
)paren
id|a
)paren
(braket
id|i
)braket
)paren
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* check_free_sector: check if a free sector is actually FREE, i.e. All 0xff in data and oob area */
DECL|function|check_free_sectors
r_static
r_int
id|check_free_sectors
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
r_int
id|address
comma
r_int
id|len
comma
r_int
id|check_oob
)paren
(brace
r_int
id|i
comma
id|retlen
suffix:semicolon
id|u8
id|buf
(braket
id|SECTORSIZE
)braket
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_add_assign
id|SECTORSIZE
)paren
(brace
multiline_comment|/* we want to read the sector without ECC check here since a free&n;&t;&t;   sector does not have ECC syndrome on it yet */
r_if
c_cond
(paren
id|MTD_READ
c_func
(paren
id|nftl-&gt;mtd
comma
id|address
comma
id|SECTORSIZE
comma
op_amp
id|retlen
comma
id|buf
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|memcmpb
c_func
(paren
id|buf
comma
l_int|0xff
comma
id|SECTORSIZE
)paren
op_ne
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|check_oob
)paren
(brace
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mtd
comma
id|address
comma
id|nftl-&gt;mtd-&gt;oobsize
comma
op_amp
id|retlen
comma
id|buf
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|memcmpb
c_func
(paren
id|buf
comma
l_int|0xff
comma
id|nftl-&gt;mtd-&gt;oobsize
)paren
op_ne
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|address
op_add_assign
id|SECTORSIZE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* NFTL_format: format a Erase Unit by erasing ALL Erase Zones in the Erase Unit and&n; *              Update NFTL metadata. Each erase operation is checked with check_free_sectors&n; *&n; * Return: 0 when succeed, -1 on error.&n; *&n; *  ToDo: 1. Is it neceressary to check_free_sector after erasing ?? &n; *        2. UnitSizeFactor != 0xFF&n; */
DECL|function|NFTL_formatblock
r_int
id|NFTL_formatblock
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
id|block
)paren
(brace
r_int
id|retlen
suffix:semicolon
r_int
r_int
id|nb_erases
comma
id|erase_mark
suffix:semicolon
r_struct
id|nftl_uci1
id|uci
suffix:semicolon
r_struct
id|erase_info
op_star
id|instr
op_assign
op_amp
id|nftl-&gt;instr
suffix:semicolon
multiline_comment|/* Read the Unit Control Information #1 for Wear-Leveling */
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mtd
comma
id|block
op_star
id|nftl-&gt;EraseSize
op_plus
id|SECTORSIZE
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|uci
)paren
OL
l_int|0
)paren
r_goto
id|default_uci1
suffix:semicolon
id|erase_mark
op_assign
id|le16_to_cpu
(paren
(paren
id|uci.EraseMark
op_or
id|uci.EraseMark1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|erase_mark
op_ne
id|ERASE_MARK
)paren
(brace
id|default_uci1
suffix:colon
id|uci.EraseMark
op_assign
id|cpu_to_le16
c_func
(paren
id|ERASE_MARK
)paren
suffix:semicolon
id|uci.EraseMark1
op_assign
id|cpu_to_le16
c_func
(paren
id|ERASE_MARK
)paren
suffix:semicolon
id|uci.WearInfo
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
id|memset
c_func
(paren
id|instr
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|erase_info
)paren
)paren
suffix:semicolon
multiline_comment|/* XXX: use async erase interface, XXX: test return code */
id|instr-&gt;addr
op_assign
id|block
op_star
id|nftl-&gt;EraseSize
suffix:semicolon
id|instr-&gt;len
op_assign
id|nftl-&gt;EraseSize
suffix:semicolon
id|MTD_ERASE
c_func
(paren
id|nftl-&gt;mtd
comma
id|instr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|instr-&gt;state
op_eq
id|MTD_ERASE_FAILED
)paren
(brace
multiline_comment|/* could not format, FixMe: We should update the BadUnitTable &n;&t;&t;   both in memory and on disk */
id|printk
c_func
(paren
l_string|&quot;Error while formatting block %d&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* increase and write Wear-Leveling info */
id|nb_erases
op_assign
id|le32_to_cpu
c_func
(paren
id|uci.WearInfo
)paren
suffix:semicolon
id|nb_erases
op_increment
suffix:semicolon
multiline_comment|/* wrap (almost impossible with current flashs) or free block */
r_if
c_cond
(paren
id|nb_erases
op_eq
l_int|0
)paren
id|nb_erases
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* check the &quot;freeness&quot; of Erase Unit before updating metadata&n;&t;&t; * FixMe:  is this check really necessary ? since we have check the&n;&t;&t; *         return code after the erase operation. */
r_if
c_cond
(paren
id|check_free_sectors
c_func
(paren
id|nftl
comma
id|instr-&gt;addr
comma
id|nftl-&gt;EraseSize
comma
l_int|1
)paren
op_ne
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|uci.WearInfo
op_assign
id|le32_to_cpu
c_func
(paren
id|nb_erases
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MTD_WRITEOOB
c_func
(paren
id|nftl-&gt;mtd
comma
id|block
op_star
id|nftl-&gt;EraseSize
op_plus
id|SECTORSIZE
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|uci
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* check_sectors_in_chain: Check that each sector of a Virtual Unit Chain is correct.&n; *&t;Mark as &squot;IGNORE&squot; each incorrect sector. This check is only done if the chain&n; *&t;was being folded when NFTL was interrupted.&n; *&n; *&t;The check_free_sectors in this function is neceressary. There is a possible&n; *&t;situation that after writing the Data area, the Block Control Information is&n; *&t;not updated according (due to power failure or something) which leaves the block&n; *&t;in an umconsistent state. So we have to check if a block is really FREE in this&n; *&t;case. */
DECL|function|check_sectors_in_chain
r_static
r_void
id|check_sectors_in_chain
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
r_int
id|first_block
)paren
(brace
r_int
r_int
id|block
comma
id|i
comma
id|status
suffix:semicolon
r_struct
id|nftl_bci
id|bci
suffix:semicolon
r_int
id|sectors_per_block
comma
id|retlen
suffix:semicolon
id|sectors_per_block
op_assign
id|nftl-&gt;EraseSize
op_div
id|SECTORSIZE
suffix:semicolon
id|block
op_assign
id|first_block
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|sectors_per_block
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mtd
comma
id|block
op_star
id|nftl-&gt;EraseSize
op_plus
id|i
op_star
id|SECTORSIZE
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|bci
)paren
OL
l_int|0
)paren
id|status
op_assign
id|SECTOR_IGNORE
suffix:semicolon
r_else
id|status
op_assign
id|bci.Status
op_or
id|bci.Status1
suffix:semicolon
r_switch
c_cond
(paren
id|status
)paren
(brace
r_case
id|SECTOR_FREE
suffix:colon
multiline_comment|/* verify that the sector is really free. If not, mark&n;&t;&t;&t;&t;   as ignore */
r_if
c_cond
(paren
id|memcmpb
c_func
(paren
op_amp
id|bci
comma
l_int|0xff
comma
l_int|8
)paren
op_ne
l_int|0
op_logical_or
id|check_free_sectors
c_func
(paren
id|nftl
comma
id|block
op_star
id|nftl-&gt;EraseSize
op_plus
id|i
op_star
id|SECTORSIZE
comma
id|SECTORSIZE
comma
l_int|0
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Incorrect free sector %d in block %d: &quot;
l_string|&quot;marking it as ignored&bslash;n&quot;
comma
id|i
comma
id|block
)paren
suffix:semicolon
multiline_comment|/* sector not free actually : mark it as SECTOR_IGNORE  */
id|bci.Status
op_assign
id|SECTOR_IGNORE
suffix:semicolon
id|bci.Status1
op_assign
id|SECTOR_IGNORE
suffix:semicolon
id|MTD_WRITEOOB
c_func
(paren
id|nftl-&gt;mtd
comma
id|block
op_star
id|nftl-&gt;EraseSize
op_plus
id|i
op_star
id|SECTORSIZE
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|bci
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* proceed to next Erase Unit on the chain */
id|block
op_assign
id|nftl-&gt;ReplUnitTable
(braket
id|block
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|block
op_eq
id|BLOCK_NIL
op_logical_or
id|block
OL
id|nftl-&gt;nb_blocks
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;incorrect ReplUnitTable[] : %d&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
op_eq
id|BLOCK_NIL
op_logical_or
id|block
op_ge
id|nftl-&gt;nb_blocks
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* calc_chain_lenght: Walk through a Virtual Unit Chain and estimate chain length */
DECL|function|calc_chain_length
r_static
r_int
id|calc_chain_length
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
r_int
id|first_block
)paren
(brace
r_int
r_int
id|length
op_assign
l_int|0
comma
id|block
op_assign
id|first_block
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|length
op_increment
suffix:semicolon
multiline_comment|/* avoid infinite loops, although this is guaranted not to&n;&t;&t;   happen because of the previous checks */
r_if
c_cond
(paren
id|length
op_ge
id|nftl-&gt;nb_blocks
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;nftl: length too long %d !&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|block
op_assign
id|nftl-&gt;ReplUnitTable
(braket
id|block
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|block
op_eq
id|BLOCK_NIL
op_logical_or
id|block
OL
id|nftl-&gt;nb_blocks
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;incorrect ReplUnitTable[] : %d&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
op_eq
id|BLOCK_NIL
op_logical_or
id|block
op_ge
id|nftl-&gt;nb_blocks
)paren
r_break
suffix:semicolon
)brace
r_return
id|length
suffix:semicolon
)brace
multiline_comment|/* format_chain: Format an invalid Virtual Unit chain. It frees all the Erase Units in a&n; *&t;Virtual Unit Chain, i.e. all the units are disconnected.&n; *&n; *&t;It is not stricly correct to begin from the first block of the chain because&n; *&t;if we stop the code, we may see again a valid chain if there was a first_block&n; *&t;flag in a block inside it. But is it really a problem ?&n; *&n; * FixMe: Figure out what the last statesment means. What if power failure when we are&n; *&t;in the for (;;) loop formatting blocks ??&n; */
DECL|function|format_chain
r_static
r_void
id|format_chain
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
r_int
id|first_block
)paren
(brace
r_int
r_int
id|block
op_assign
id|first_block
comma
id|block1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Formatting chain at block %d&bslash;n&quot;
comma
id|first_block
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
id|block1
op_assign
id|nftl-&gt;ReplUnitTable
(braket
id|block
)braket
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Formatting block %d&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NFTL_formatblock
c_func
(paren
id|nftl
comma
id|block
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* cannot format !!!! Mark it as Bad Unit,&n;&t;&t;&t;   FixMe: update the BadUnitTable on disk */
id|nftl-&gt;ReplUnitTable
(braket
id|block
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
)brace
r_else
(brace
id|nftl-&gt;ReplUnitTable
(braket
id|block
)braket
op_assign
id|BLOCK_FREE
suffix:semicolon
)brace
multiline_comment|/* goto next block on the chain */
id|block
op_assign
id|block1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|block
op_eq
id|BLOCK_NIL
op_logical_or
id|block
OL
id|nftl-&gt;nb_blocks
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;incorrect ReplUnitTable[] : %d&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|block
op_eq
id|BLOCK_NIL
op_logical_or
id|block
op_ge
id|nftl-&gt;nb_blocks
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* check_and_mark_free_block: Verify that a block is free in the NFTL sense (valid erase mark) or&n; *&t;totally free (only 0xff).&n; *&n; * Definition: Free Erase Unit -- A properly erased/formatted Free Erase Unit should have meet the&n; *&t;following critia:&n; *&t;1. */
DECL|function|check_and_mark_free_block
r_static
r_int
id|check_and_mark_free_block
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
id|block
)paren
(brace
r_struct
id|nftl_uci1
id|h1
suffix:semicolon
r_int
r_int
id|erase_mark
suffix:semicolon
r_int
id|i
comma
id|retlen
suffix:semicolon
r_int
r_char
id|buf
(braket
id|SECTORSIZE
)braket
suffix:semicolon
multiline_comment|/* check erase mark. */
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mtd
comma
id|block
op_star
id|nftl-&gt;EraseSize
op_plus
id|SECTORSIZE
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|h1
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|erase_mark
op_assign
id|le16_to_cpu
(paren
(paren
id|h1.EraseMark
op_or
id|h1.EraseMark1
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|erase_mark
op_ne
id|ERASE_MARK
)paren
(brace
multiline_comment|/* if no erase mark, the block must be totally free. This is&n;&t;&t;   possible in two cases : empty filsystem or interrupted erase (very unlikely) */
r_if
c_cond
(paren
id|check_free_sectors
(paren
id|nftl
comma
id|block
op_star
id|nftl-&gt;EraseSize
comma
id|nftl-&gt;EraseSize
comma
l_int|1
)paren
op_ne
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* free block : write erase mark */
id|h1.EraseMark
op_assign
id|cpu_to_le16
c_func
(paren
id|ERASE_MARK
)paren
suffix:semicolon
id|h1.EraseMark1
op_assign
id|cpu_to_le16
c_func
(paren
id|ERASE_MARK
)paren
suffix:semicolon
id|h1.WearInfo
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|MTD_WRITEOOB
c_func
(paren
id|nftl-&gt;mtd
comma
id|block
op_star
id|nftl-&gt;EraseSize
op_plus
id|SECTORSIZE
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|h1
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
macro_line|#if 0
multiline_comment|/* if erase mark present, need to skip it when doing check */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nftl-&gt;EraseSize
suffix:semicolon
id|i
op_add_assign
id|SECTORSIZE
)paren
(brace
multiline_comment|/* check free sector */
r_if
c_cond
(paren
id|check_free_sectors
(paren
id|nftl
comma
id|block
op_star
id|nftl-&gt;EraseSize
op_plus
id|i
comma
id|SECTORSIZE
comma
l_int|0
)paren
op_ne
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mtd
comma
id|block
op_star
id|nftl-&gt;EraseSize
op_plus
id|i
comma
l_int|16
comma
op_amp
id|retlen
comma
id|buf
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|SECTORSIZE
)paren
(brace
multiline_comment|/* skip erase mark */
r_if
c_cond
(paren
id|memcmpb
c_func
(paren
id|buf
comma
l_int|0xff
comma
l_int|8
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|memcmpb
c_func
(paren
id|buf
comma
l_int|0xff
comma
l_int|16
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
)brace
macro_line|#endif
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* get_fold_mark: Read fold mark from Unit Control Information #2, we use FOLD_MARK_IN_PROGRESS&n; *&t;to indicate that we are in the progression of a Virtual Unit Chain folding. If the UCI #2&n; *&t;is FOLD_MARK_IN_PROGRESS when mounting the NFTL, the (previous) folding process is interrupted&n; *&t;for some reason. A clean up/check of the VUC is neceressary in this case.&n; *&n; * WARNING: return 0 if read error&n; */
DECL|function|get_fold_mark
r_static
r_int
id|get_fold_mark
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|nftl
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|nftl_uci2
id|uci
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|nftl-&gt;mtd
comma
id|block
op_star
id|nftl-&gt;EraseSize
op_plus
l_int|2
op_star
id|SECTORSIZE
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|uci
)paren
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|le16_to_cpu
c_func
(paren
(paren
id|uci.FoldMark
op_or
id|uci.FoldMark1
)paren
)paren
suffix:semicolon
)brace
DECL|function|NFTL_mount
r_int
id|NFTL_mount
c_func
(paren
r_struct
id|NFTLrecord
op_star
id|s
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
r_int
id|first_logical_block
comma
id|logical_block
comma
id|rep_block
comma
id|nb_erases
comma
id|erase_mark
suffix:semicolon
r_int
r_int
id|block
comma
id|first_block
comma
id|is_first_block
suffix:semicolon
r_int
id|chain_length
comma
id|do_format_chain
suffix:semicolon
r_struct
id|nftl_uci0
id|h0
suffix:semicolon
r_struct
id|nftl_uci1
id|h1
suffix:semicolon
r_int
id|retlen
suffix:semicolon
multiline_comment|/* XXX: will be suppressed */
id|s-&gt;lastEUN
op_assign
id|s-&gt;nb_blocks
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* memory alloc */
id|s-&gt;EUNtable
op_assign
id|kmalloc
c_func
(paren
id|s-&gt;nb_blocks
op_star
r_sizeof
(paren
id|u16
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|s-&gt;ReplUnitTable
op_assign
id|kmalloc
c_func
(paren
id|s-&gt;nb_blocks
op_star
r_sizeof
(paren
id|u16
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|s-&gt;EUNtable
op_logical_or
op_logical_neg
id|s-&gt;ReplUnitTable
)paren
(brace
id|fail
suffix:colon
r_if
c_cond
(paren
id|s-&gt;EUNtable
)paren
id|kfree
c_func
(paren
id|s-&gt;EUNtable
)paren
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;ReplUnitTable
)paren
id|kfree
c_func
(paren
id|s-&gt;ReplUnitTable
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* mark all blocks as potentially containing data */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|s-&gt;nb_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|s-&gt;ReplUnitTable
(braket
id|i
)braket
op_assign
id|BLOCK_NOTEXPLORED
suffix:semicolon
)brace
multiline_comment|/* search for NFTL MediaHeader and Spare NFTL Media Header */
r_if
c_cond
(paren
id|find_boot_record
c_func
(paren
id|s
)paren
OL
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Could not find valid boot record&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|fail
suffix:semicolon
)brace
multiline_comment|/* mark the bios blocks (blocks before NFTL MediaHeader) as reserved */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|s-&gt;nb_boot_blocks
suffix:semicolon
id|i
op_increment
)paren
id|s-&gt;ReplUnitTable
(braket
id|i
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
multiline_comment|/* also mark the boot records (NFTL MediaHeader) blocks as reserved */
r_if
c_cond
(paren
id|s-&gt;MediaUnit
op_ne
id|BLOCK_NIL
)paren
id|s-&gt;ReplUnitTable
(braket
id|s-&gt;MediaUnit
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
r_if
c_cond
(paren
id|s-&gt;SpareMediaUnit
op_ne
id|BLOCK_NIL
)paren
id|s-&gt;ReplUnitTable
(braket
id|s-&gt;SpareMediaUnit
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
multiline_comment|/* init the logical to physical table */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|s-&gt;nb_blocks
suffix:semicolon
id|i
op_increment
)paren
(brace
id|s-&gt;EUNtable
(braket
id|i
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
)brace
multiline_comment|/* first pass : explore each block chain */
id|first_logical_block
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|first_block
op_assign
l_int|0
suffix:semicolon
id|first_block
OL
id|s-&gt;nb_blocks
suffix:semicolon
id|first_block
op_increment
)paren
(brace
multiline_comment|/* if the block was not already explored, we can look at it */
r_if
c_cond
(paren
id|s-&gt;ReplUnitTable
(braket
id|first_block
)braket
op_eq
id|BLOCK_NOTEXPLORED
)paren
(brace
id|block
op_assign
id|first_block
suffix:semicolon
id|chain_length
op_assign
l_int|0
suffix:semicolon
id|do_format_chain
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
suffix:semicolon
)paren
(brace
multiline_comment|/* read the block header. If error, we format the chain */
r_if
c_cond
(paren
id|MTD_READOOB
c_func
(paren
id|s-&gt;mtd
comma
id|block
op_star
id|s-&gt;EraseSize
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|h0
)paren
OL
l_int|0
op_logical_or
id|MTD_READOOB
c_func
(paren
id|s-&gt;mtd
comma
id|block
op_star
id|s-&gt;EraseSize
op_plus
id|SECTORSIZE
op_plus
l_int|8
comma
l_int|8
comma
op_amp
id|retlen
comma
(paren
r_char
op_star
)paren
op_amp
id|h1
)paren
OL
l_int|0
)paren
(brace
id|s-&gt;ReplUnitTable
(braket
id|block
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
id|do_format_chain
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
id|logical_block
op_assign
id|le16_to_cpu
(paren
(paren
id|h0.VirtUnitNum
op_or
id|h0.SpareVirtUnitNum
)paren
)paren
suffix:semicolon
id|rep_block
op_assign
id|le16_to_cpu
(paren
(paren
id|h0.ReplUnitNum
op_or
id|h0.SpareReplUnitNum
)paren
)paren
suffix:semicolon
id|nb_erases
op_assign
id|le32_to_cpu
(paren
id|h1.WearInfo
)paren
suffix:semicolon
id|erase_mark
op_assign
id|le16_to_cpu
(paren
(paren
id|h1.EraseMark
op_or
id|h1.EraseMark1
)paren
)paren
suffix:semicolon
id|is_first_block
op_assign
op_logical_neg
(paren
id|logical_block
op_rshift
l_int|15
)paren
suffix:semicolon
id|logical_block
op_assign
id|logical_block
op_amp
l_int|0x7fff
suffix:semicolon
multiline_comment|/* invalid/free block test */
r_if
c_cond
(paren
id|erase_mark
op_ne
id|ERASE_MARK
op_logical_or
id|logical_block
op_ge
id|s-&gt;nb_blocks
)paren
(brace
r_if
c_cond
(paren
id|chain_length
op_eq
l_int|0
)paren
(brace
multiline_comment|/* if not currently in a chain, we can handle it safely */
r_if
c_cond
(paren
id|check_and_mark_free_block
c_func
(paren
id|s
comma
id|block
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* not really free: format it */
id|printk
c_func
(paren
l_string|&quot;Formatting block %d&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NFTL_formatblock
c_func
(paren
id|s
comma
id|block
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* could not format: reserve the block */
id|s-&gt;ReplUnitTable
(braket
id|block
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
)brace
r_else
(brace
id|s-&gt;ReplUnitTable
(braket
id|block
)braket
op_assign
id|BLOCK_FREE
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* free block: mark it */
id|s-&gt;ReplUnitTable
(braket
id|block
)braket
op_assign
id|BLOCK_FREE
suffix:semicolon
)brace
multiline_comment|/* directly examine the next block. */
r_goto
id|examine_ReplUnitTable
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* the block was in a chain : this is bad. We&n;&t;&t;&t;&t;&t;&t;   must format all the chain */
id|printk
c_func
(paren
l_string|&quot;Block %d: free but referenced in chain %d&bslash;n&quot;
comma
id|block
comma
id|first_block
)paren
suffix:semicolon
id|s-&gt;ReplUnitTable
(braket
id|block
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
id|do_format_chain
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* we accept only first blocks here */
r_if
c_cond
(paren
id|chain_length
op_eq
l_int|0
)paren
(brace
multiline_comment|/* this block is not the first block in chain :&n;&t;&t;&t;&t;&t;   ignore it, it will be included in a chain&n;&t;&t;&t;&t;&t;   later, or marked as not explored */
r_if
c_cond
(paren
op_logical_neg
id|is_first_block
)paren
r_goto
id|examine_ReplUnitTable
suffix:semicolon
id|first_logical_block
op_assign
id|logical_block
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|logical_block
op_ne
id|first_logical_block
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Block %d: incorrect logical block: %d expected: %d&bslash;n&quot;
comma
id|block
comma
id|logical_block
comma
id|first_logical_block
)paren
suffix:semicolon
multiline_comment|/* the chain is incorrect : we must format it,&n;&t;&t;&t;&t;&t;&t;   but we need to read it completly */
id|do_format_chain
op_assign
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|is_first_block
)paren
(brace
multiline_comment|/* we accept that a block is marked as first&n;&t;&t;&t;&t;&t;&t;   block while being last block in a chain&n;&t;&t;&t;&t;&t;&t;   only if the chain is being folded */
r_if
c_cond
(paren
id|get_fold_mark
c_func
(paren
id|s
comma
id|block
)paren
op_ne
id|FOLD_MARK_IN_PROGRESS
op_logical_or
id|rep_block
op_ne
l_int|0xffff
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Block %d: incorrectly marked as first block in chain&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
multiline_comment|/* the chain is incorrect : we must format it,&n;&t;&t;&t;&t;&t;&t;&t;   but we need to read it completly */
id|do_format_chain
op_assign
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Block %d: folding in progress - ignoring first block flag&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
)brace
)brace
)brace
id|chain_length
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|rep_block
op_eq
l_int|0xffff
)paren
(brace
multiline_comment|/* no more blocks after */
id|s-&gt;ReplUnitTable
(braket
id|block
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rep_block
op_ge
id|s-&gt;nb_blocks
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Block %d: referencing invalid block %d&bslash;n&quot;
comma
id|block
comma
id|rep_block
)paren
suffix:semicolon
id|do_format_chain
op_assign
l_int|1
suffix:semicolon
id|s-&gt;ReplUnitTable
(braket
id|block
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|s-&gt;ReplUnitTable
(braket
id|rep_block
)braket
op_ne
id|BLOCK_NOTEXPLORED
)paren
(brace
multiline_comment|/* same problem as previous &squot;is_first_block&squot; test:&n;&t;&t;&t;&t;&t;   we accept that the last block of a chain has&n;&t;&t;&t;&t;&t;   the first_block flag set if folding is in&n;&t;&t;&t;&t;&t;   progress. We handle here the case where the&n;&t;&t;&t;&t;&t;   last block appeared first */
r_if
c_cond
(paren
id|s-&gt;ReplUnitTable
(braket
id|rep_block
)braket
op_eq
id|BLOCK_NIL
op_logical_and
id|s-&gt;EUNtable
(braket
id|first_logical_block
)braket
op_eq
id|rep_block
op_logical_and
id|get_fold_mark
c_func
(paren
id|s
comma
id|first_block
)paren
op_eq
id|FOLD_MARK_IN_PROGRESS
)paren
(brace
multiline_comment|/* EUNtable[] will be set after */
id|printk
c_func
(paren
l_string|&quot;Block %d: folding in progress - ignoring first block flag&bslash;n&quot;
comma
id|rep_block
)paren
suffix:semicolon
id|s-&gt;ReplUnitTable
(braket
id|block
)braket
op_assign
id|rep_block
suffix:semicolon
id|s-&gt;EUNtable
(braket
id|first_logical_block
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;Block %d: referencing block %d already in another chain&bslash;n&quot;
comma
id|block
comma
id|rep_block
)paren
suffix:semicolon
multiline_comment|/* XXX: should handle correctly fold in progress chains */
id|do_format_chain
op_assign
l_int|1
suffix:semicolon
id|s-&gt;ReplUnitTable
(braket
id|block
)braket
op_assign
id|BLOCK_NIL
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* this is OK */
id|s-&gt;ReplUnitTable
(braket
id|block
)braket
op_assign
id|rep_block
suffix:semicolon
id|block
op_assign
id|rep_block
suffix:semicolon
)brace
)brace
multiline_comment|/* the chain was completely explored. Now we can decide&n;&t;&t;&t;   what to do with it */
r_if
c_cond
(paren
id|do_format_chain
)paren
(brace
multiline_comment|/* invalid chain : format it */
id|format_chain
c_func
(paren
id|s
comma
id|first_block
)paren
suffix:semicolon
)brace
r_else
(brace
r_int
r_int
id|first_block1
comma
id|chain_to_format
comma
id|chain_length1
suffix:semicolon
r_int
id|fold_mark
suffix:semicolon
multiline_comment|/* valid chain : get foldmark */
id|fold_mark
op_assign
id|get_fold_mark
c_func
(paren
id|s
comma
id|first_block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|fold_mark
op_eq
l_int|0
)paren
(brace
multiline_comment|/* cannot get foldmark : format the chain */
id|printk
c_func
(paren
l_string|&quot;Could read foldmark at block %d&bslash;n&quot;
comma
id|first_block
)paren
suffix:semicolon
id|format_chain
c_func
(paren
id|s
comma
id|first_block
)paren
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|fold_mark
op_eq
id|FOLD_MARK_IN_PROGRESS
)paren
id|check_sectors_in_chain
c_func
(paren
id|s
comma
id|first_block
)paren
suffix:semicolon
multiline_comment|/* now handle the case where we find two chains at the&n;&t;&t;&t;&t;&t;   same virtual address : we select the longer one,&n;&t;&t;&t;&t;&t;   because the shorter one is the one which was being&n;&t;&t;&t;&t;&t;   folded if the folding was not done in place */
id|first_block1
op_assign
id|s-&gt;EUNtable
(braket
id|first_logical_block
)braket
suffix:semicolon
r_if
c_cond
(paren
id|first_block1
op_ne
id|BLOCK_NIL
)paren
(brace
multiline_comment|/* XXX: what to do if same length ? */
id|chain_length1
op_assign
id|calc_chain_length
c_func
(paren
id|s
comma
id|first_block1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Two chains at blocks %d (len=%d) and %d (len=%d)&bslash;n&quot;
comma
id|first_block1
comma
id|chain_length1
comma
id|first_block
comma
id|chain_length
)paren
suffix:semicolon
r_if
c_cond
(paren
id|chain_length
op_ge
id|chain_length1
)paren
(brace
id|chain_to_format
op_assign
id|first_block1
suffix:semicolon
id|s-&gt;EUNtable
(braket
id|first_logical_block
)braket
op_assign
id|first_block
suffix:semicolon
)brace
r_else
(brace
id|chain_to_format
op_assign
id|first_block
suffix:semicolon
)brace
id|format_chain
c_func
(paren
id|s
comma
id|chain_to_format
)paren
suffix:semicolon
)brace
r_else
(brace
id|s-&gt;EUNtable
(braket
id|first_logical_block
)braket
op_assign
id|first_block
suffix:semicolon
)brace
)brace
)brace
)brace
id|examine_ReplUnitTable
suffix:colon
)brace
multiline_comment|/* second pass to format unreferenced blocks  and init free block count */
id|s-&gt;numfreeEUNs
op_assign
l_int|0
suffix:semicolon
id|s-&gt;LastFreeEUN
op_assign
id|BLOCK_NIL
suffix:semicolon
r_for
c_loop
(paren
id|block
op_assign
l_int|0
suffix:semicolon
id|block
OL
id|s-&gt;nb_blocks
suffix:semicolon
id|block
op_increment
)paren
(brace
r_if
c_cond
(paren
id|s-&gt;ReplUnitTable
(braket
id|block
)braket
op_eq
id|BLOCK_NOTEXPLORED
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unreferenced block %d, formatting it&bslash;n&quot;
comma
id|block
)paren
suffix:semicolon
r_if
c_cond
(paren
id|NFTL_formatblock
c_func
(paren
id|s
comma
id|block
)paren
OL
l_int|0
)paren
id|s-&gt;ReplUnitTable
(braket
id|block
)braket
op_assign
id|BLOCK_RESERVED
suffix:semicolon
r_else
id|s-&gt;ReplUnitTable
(braket
id|block
)braket
op_assign
id|BLOCK_FREE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|s-&gt;ReplUnitTable
(braket
id|block
)braket
op_eq
id|BLOCK_FREE
)paren
(brace
id|s-&gt;numfreeEUNs
op_increment
suffix:semicolon
id|s-&gt;LastFreeEUN
op_assign
id|block
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
eof
