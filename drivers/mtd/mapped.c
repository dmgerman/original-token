singleline_comment|// -*- mode: cpp; mode: fold -*-
singleline_comment|// Description                                                          /*{{{*/
singleline_comment|// $Id: mapped.c,v 1.8 2000/03/31 14:40:42 dwmw2 Exp $
multiline_comment|/* ######################################################################&n;&n;   Flash MTD Routines&n;&n;   These routine support IDing and manipulating flash. Currently the &n;   older JEDEC ID mechanism and a table is used for determining the&n;   flash characterisitics, but it is trivial to add support for the&n;   CFI specification:&n;     http://www.pentium.com/design/flash/ in the technote section.&n;   &n;   ##################################################################### */
multiline_comment|/*}}}*/
macro_line|#include &lt;linux/mtd/mapped.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;asm/io.h&gt;
DECL|variable|mtd_JEDEC_table
r_struct
id|JEDECTable
id|mtd_JEDEC_table
(braket
)braket
op_assign
(brace
(brace
l_int|0x01AD
comma
l_string|&quot;AMD Am29F016&quot;
comma
l_int|2
op_star
l_int|1024
op_star
l_int|1024
comma
l_int|64
op_star
l_int|1024
comma
id|MTD_CAP_NORFLASH
)brace
comma
(brace
l_int|0x01D5
comma
l_string|&quot;AMD Am29F080&quot;
comma
l_int|1
op_star
l_int|1024
op_star
l_int|1024
comma
l_int|64
op_star
l_int|1024
comma
id|MTD_CAP_NORFLASH
)brace
comma
(brace
)brace
)brace
suffix:semicolon
singleline_comment|// flash_setup - Setup the mapped_mtd_info structure for normal flash&t;/*{{{*/
singleline_comment|// ---------------------------------------------------------------------
multiline_comment|/* There is a set of commands that flash manufactures follow for getting the&n;   JEDEC id, erasing and writing. So long as your flash device supports &n;   getting the JEDEC ID in this (standard?) way it will be supported as flash,&n;   otherwise it is converted to ROM. Upon completion the structure is &n;   registered with the MTD layer */
DECL|function|mtd_mapped_setup
r_int
id|mtd_mapped_setup
c_func
(paren
r_struct
id|mapped_mtd_info
op_star
id|map
)paren
(brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Must define a page function to use the defaults!
r_if
c_cond
(paren
id|map-&gt;page
op_eq
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;jedec_sense
op_eq
l_int|0
)paren
id|map-&gt;jedec_sense
op_assign
id|flash_jedec
suffix:semicolon
r_if
c_cond
(paren
id|map
op_member_access_from_pointer
id|jedec_sense
c_func
(paren
id|map
)paren
op_ne
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;mtd.erase
op_eq
l_int|0
op_logical_and
id|map-&gt;mtd.type
op_eq
id|MTD_NORFLASH
)paren
id|map-&gt;mtd.erase
op_assign
id|flash_erase
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;mtd.write
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|map-&gt;mtd.type
op_eq
id|MTD_NORFLASH
)paren
id|map-&gt;mtd.write
op_assign
id|flash_write
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;mtd.type
op_eq
id|MTD_RAM
)paren
id|map-&gt;mtd.write
op_assign
id|ram_write
suffix:semicolon
)brace
r_if
c_cond
(paren
id|map-&gt;mtd.read
op_eq
l_int|0
)paren
id|map-&gt;mtd.read
op_assign
id|rom_read
suffix:semicolon
r_return
id|add_mtd_device
c_func
(paren
op_amp
id|map-&gt;mtd
)paren
suffix:semicolon
)brace
multiline_comment|/*}}}*/
singleline_comment|// flash_remove - Remove the flash device from the MTD layer&t;&t;/*{{{*/
singleline_comment|// ---------------------------------------------------------------------
multiline_comment|/* Free any memory allocated for the device here */
DECL|function|mtd_mapped_remove
r_int
id|mtd_mapped_remove
c_func
(paren
r_struct
id|mapped_mtd_info
op_star
id|map
)paren
(brace
r_return
id|del_mtd_device
c_func
(paren
op_amp
id|map-&gt;mtd
)paren
suffix:semicolon
)brace
multiline_comment|/*}}}*/
singleline_comment|// checkparity - Checks a number for odd parity&t;&t;&t;&t;/*{{{*/
singleline_comment|// ---------------------------------------------------------------------
multiline_comment|/* Helper for the JEDEC function, JEDEC numbers all have odd parity */
DECL|function|checkparity
r_static
r_int
id|checkparity
c_func
(paren
id|u_char
id|C
)paren
(brace
id|u_char
id|parity
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|C
op_ne
l_int|0
)paren
(brace
id|parity
op_xor_assign
id|C
op_amp
l_int|1
suffix:semicolon
id|C
op_rshift_assign
l_int|1
suffix:semicolon
)brace
r_return
id|parity
op_eq
l_int|1
suffix:semicolon
)brace
multiline_comment|/*}}}*/
singleline_comment|// SetJedec - Set the jedec information for a chip&t;&t;&t;/*{{{*/
singleline_comment|// ---------------------------------------------------------------------
multiline_comment|/* We track the configuration of each chip separately in the chip list, &n;   each chip can have a different type and configuration to allow for &n;   maximum flexability. */
DECL|function|set_jedec
r_void
id|set_jedec
c_func
(paren
r_struct
id|mapped_mtd_info
op_star
id|map
comma
r_int
id|chip
comma
r_int
r_char
id|mfr
comma
r_int
r_char
id|id
)paren
(brace
r_int
r_int
id|longID
op_assign
(paren
id|mfr
op_lshift
l_int|8
)paren
op_plus
id|id
suffix:semicolon
r_int
r_int
id|I
suffix:semicolon
id|map-&gt;mtd.type
op_assign
id|MTD_NORFLASH
suffix:semicolon
id|map-&gt;mfr
op_assign
id|mfr
suffix:semicolon
id|map-&gt;id
op_assign
id|id
suffix:semicolon
singleline_comment|// Locate the chip in the jedec table
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|mtd_JEDEC_table
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
suffix:semicolon
id|I
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mtd_JEDEC_table
(braket
id|I
)braket
dot
id|jedec
op_eq
id|longID
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|mtd_JEDEC_table
(braket
id|I
)braket
dot
id|jedec
op_ne
id|longID
op_logical_or
id|longID
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unknown JEDEC number %x-%x, treating as ROM&bslash;n&quot;
comma
id|map-&gt;mfr
comma
id|map-&gt;id
)paren
suffix:semicolon
id|map-&gt;mtd.type
op_assign
id|MTD_ROM
suffix:semicolon
r_return
suffix:semicolon
)brace
singleline_comment|// Setup the MTD from the JEDEC information
singleline_comment|//   map-&gt;mtd.size = mtd_JEDEC_table[I].size;
singleline_comment|//   map-&gt;mtd.erasesize = mtd_JEDEC_table[I].sectorsize;
singleline_comment|//   map-&gt;mtd.capabilities = mtd_JEDEC_table[I].capabilities;
singleline_comment|//   strncpy(map-&gt;mtd.part,mtd_JEDEC_table[I].name,sizeof(map-&gt;mtd.part)-1);
id|map-&gt;chips
(braket
id|chip
)braket
dot
id|jedec
op_assign
id|longID
suffix:semicolon
id|map-&gt;chips
(braket
id|chip
)braket
dot
id|size
op_assign
id|mtd_JEDEC_table
(braket
id|I
)braket
dot
id|size
suffix:semicolon
id|map-&gt;chips
(braket
id|chip
)braket
dot
id|sectorsize
op_assign
id|mtd_JEDEC_table
(braket
id|I
)braket
dot
id|sectorsize
suffix:semicolon
id|map-&gt;chips
(braket
id|chip
)braket
dot
id|capabilities
op_assign
id|mtd_JEDEC_table
(braket
id|I
)braket
dot
id|capabilities
suffix:semicolon
id|map-&gt;chips
(braket
id|chip
)braket
dot
id|base
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/*}}}*/
singleline_comment|// isjedec - Check if reading from the memory location gives jedec #s&t;/*{{{*/
singleline_comment|// ---------------------------------------------------------------------
multiline_comment|/* This is ment to be called on the flash window once it is in jedec mode */
DECL|function|isjedec
r_int
id|isjedec
c_func
(paren
r_int
r_int
id|base
)paren
(brace
singleline_comment|// Test #1, JEDEC numbers are readable from 0x??00/0x??01
r_if
c_cond
(paren
id|readb
c_func
(paren
id|base
op_plus
l_int|0
)paren
op_ne
id|readb
c_func
(paren
id|base
op_plus
l_int|0x100
)paren
op_logical_or
id|readb
c_func
(paren
id|base
op_plus
l_int|1
)paren
op_ne
id|readb
c_func
(paren
id|base
op_plus
l_int|0x101
)paren
)paren
r_return
l_int|0
suffix:semicolon
singleline_comment|// Test #2 JEDEC numbers exhibit odd parity
r_if
c_cond
(paren
id|checkparity
c_func
(paren
id|readb
c_func
(paren
id|base
op_plus
l_int|0
)paren
)paren
op_eq
l_int|0
op_logical_or
id|checkparity
c_func
(paren
id|readb
c_func
(paren
id|base
op_plus
l_int|1
)paren
)paren
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/*}}}*/
singleline_comment|// flash_jedec - JEDEC ID sensor&t;&t;&t;&t;&t;/*{{{*/
singleline_comment|// ---------------------------------------------------------------------
multiline_comment|/* The mysterious jedec flash probe sequence writes a specific pattern of&n;   bytes to the flash. This should be general enough to work with any MTD&n;   structure that may contain a flash chip, but note that it will corrupt&n;   address 0x5555 on SRAM cards if the machine dies between the two &n;   critical operations. */
DECL|function|flash_jedec
r_int
id|flash_jedec
c_func
(paren
r_struct
id|mapped_mtd_info
op_star
id|map
)paren
(brace
r_int
id|I
suffix:semicolon
id|u_char
id|OldVal
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
r_int
id|baseaddr
op_assign
l_int|0
suffix:semicolon
r_int
id|chip
op_assign
l_int|0
suffix:semicolon
r_int
id|count
suffix:semicolon
singleline_comment|// Who has a page size this small? :&gt;
r_if
c_cond
(paren
id|map-&gt;pagesize
OL
l_int|0x555
)paren
r_return
l_int|1
suffix:semicolon
id|base
op_assign
id|map
op_member_access_from_pointer
id|page
c_func
(paren
id|map
comma
l_int|0
)paren
suffix:semicolon
singleline_comment|// Wait for any write/erase operation to settle
id|OldVal
op_assign
id|readb
c_func
(paren
id|base
)paren
suffix:semicolon
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|OldVal
op_ne
id|readb
c_func
(paren
id|base
)paren
op_logical_and
id|I
OL
l_int|10000
suffix:semicolon
id|I
op_increment
)paren
id|OldVal
op_assign
id|readb
c_func
(paren
id|base
)paren
suffix:semicolon
multiline_comment|/* Check for sram by writing to it, the write also happens to be part &n;      of the flash reset sequence.. */
id|OldVal
op_assign
id|readb
c_func
(paren
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
id|writeb
c_func
(paren
id|OldVal
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0xF0
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OldVal
op_ne
id|readb
c_func
(paren
id|base
op_plus
l_int|0x555
)paren
)paren
(brace
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
singleline_comment|// Set it back and make sure..
id|writeb
c_func
(paren
id|OldVal
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
r_if
c_cond
(paren
id|OldVal
op_eq
id|readb
c_func
(paren
id|base
op_plus
l_int|0x555
)paren
)paren
(brace
id|map-&gt;mtd.type
op_assign
id|MTD_RAM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|writeb
c_func
(paren
l_int|0xF0
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
)brace
singleline_comment|// Probe for chips
r_while
c_loop
(paren
id|chip
OL
r_sizeof
(paren
id|map-&gt;chips
)paren
op_div
r_sizeof
(paren
id|map-&gt;chips
(braket
l_int|0
)braket
)paren
)paren
(brace
singleline_comment|// Already in jedec mode, we might be doing some address wrap around
r_if
c_cond
(paren
id|chip
op_ne
l_int|0
op_logical_and
id|isjedec
c_func
(paren
id|base
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Try to reset this page and check if that resets the first page&n;&t;    to confirm */
id|writeb
c_func
(paren
l_int|0xF0
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isjedec
c_func
(paren
id|base
)paren
op_ne
l_int|0
)paren
r_break
suffix:semicolon
id|base
op_assign
id|map
op_member_access_from_pointer
id|page
c_func
(paren
id|map
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|isjedec
c_func
(paren
id|base
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
id|base
op_assign
id|map
op_member_access_from_pointer
id|page
c_func
(paren
id|map
comma
id|baseaddr
op_div
id|map-&gt;pagesize
)paren
suffix:semicolon
)brace
singleline_comment|// Send the sequence
id|writeb
c_func
(paren
l_int|0xAA
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x55
comma
id|base
op_plus
l_int|0x2AA
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x90
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
singleline_comment|// Check the jedec number
r_if
c_cond
(paren
id|isjedec
c_func
(paren
id|base
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* If this is the first chip it must be rom, otherwise it is the&n;&t;    end of the flash region */
r_if
c_cond
(paren
id|chip
op_eq
l_int|0
)paren
(brace
id|map-&gt;mtd.type
op_assign
id|MTD_ROM
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
singleline_comment|// Store the jdec info
id|set_jedec
c_func
(paren
id|map
comma
id|chip
comma
id|readb
c_func
(paren
id|base
op_plus
l_int|0
)paren
comma
id|readb
c_func
(paren
id|base
op_plus
l_int|1
)paren
)paren
suffix:semicolon
id|map-&gt;chips
(braket
id|chip
)braket
dot
id|base
op_assign
id|baseaddr
suffix:semicolon
singleline_comment|// Jump to the next chip
id|baseaddr
op_add_assign
id|map-&gt;chips
(braket
id|chip
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|baseaddr
op_div
id|map-&gt;pagesize
OG
id|map-&gt;maxsize
)paren
r_break
suffix:semicolon
id|base
op_assign
id|map
op_member_access_from_pointer
id|page
c_func
(paren
id|map
comma
id|baseaddr
op_div
id|map-&gt;pagesize
)paren
suffix:semicolon
r_if
c_cond
(paren
id|base
op_eq
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|chip
op_increment
suffix:semicolon
)brace
singleline_comment|// Reset all of the chips
id|map-&gt;mtd.size
op_assign
l_int|0
suffix:semicolon
id|baseaddr
op_assign
l_int|0
suffix:semicolon
id|map-&gt;mtd.flags
op_assign
l_int|0xFFFF
suffix:semicolon
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|map-&gt;chips
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
suffix:semicolon
id|I
op_increment
)paren
(brace
singleline_comment|// Fill in the various MTD structures
id|map-&gt;mtd.size
op_add_assign
id|map-&gt;chips
(braket
id|I
)braket
dot
id|size
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;mtd.erasesize
OL
id|map-&gt;chips
(braket
id|I
)braket
dot
id|sectorsize
)paren
id|map-&gt;mtd.erasesize
op_assign
id|map-&gt;chips
(braket
id|I
)braket
dot
id|sectorsize
suffix:semicolon
id|map-&gt;mtd.flags
op_and_assign
id|map-&gt;chips
(braket
id|I
)braket
dot
id|capabilities
suffix:semicolon
id|base
op_assign
id|map
op_member_access_from_pointer
id|page
c_func
(paren
id|map
comma
id|baseaddr
op_div
id|map-&gt;pagesize
)paren
suffix:semicolon
id|baseaddr
op_add_assign
id|map-&gt;chips
(braket
id|chip
)braket
dot
id|size
suffix:semicolon
id|writeb
c_func
(paren
l_int|0xF0
comma
id|base
op_plus
l_int|0
)paren
suffix:semicolon
singleline_comment|// Reset      
)brace
multiline_comment|/* Generate a part name that includes the number of different chips and&n;      other configuration information */
id|count
op_assign
l_int|1
suffix:semicolon
id|map-&gt;part
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|map-&gt;chips
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
suffix:semicolon
id|I
op_increment
)paren
(brace
r_int
id|J
suffix:semicolon
r_if
c_cond
(paren
id|map-&gt;chips
(braket
id|I
op_plus
l_int|1
)braket
dot
id|jedec
op_eq
id|map-&gt;chips
(braket
id|I
)braket
dot
id|jedec
)paren
(brace
id|count
op_increment
suffix:semicolon
r_continue
suffix:semicolon
)brace
singleline_comment|// Locate the chip in the jedec table
r_for
c_loop
(paren
id|J
op_assign
l_int|0
suffix:semicolon
id|mtd_JEDEC_table
(braket
id|J
)braket
dot
id|jedec
op_ne
l_int|0
suffix:semicolon
id|J
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mtd_JEDEC_table
(braket
id|J
)braket
dot
id|jedec
op_eq
id|map-&gt;chips
(braket
id|I
)braket
dot
id|jedec
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|map-&gt;part
(braket
l_int|0
)braket
op_ne
l_int|0
)paren
id|strcat
c_func
(paren
id|map-&gt;part
comma
l_string|&quot;,&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ne
l_int|1
)paren
id|sprintf
c_func
(paren
id|map-&gt;part
op_plus
id|strlen
c_func
(paren
id|map-&gt;part
)paren
comma
l_string|&quot;%u*[%s]&quot;
comma
id|count
comma
id|mtd_JEDEC_table
(braket
id|J
)braket
dot
id|name
)paren
suffix:semicolon
r_else
id|sprintf
c_func
(paren
id|map-&gt;part
op_plus
id|strlen
c_func
(paren
id|map-&gt;part
)paren
comma
l_string|&quot;%s&quot;
comma
id|mtd_JEDEC_table
(braket
id|J
)braket
dot
id|name
)paren
suffix:semicolon
id|count
op_assign
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*}}}*/
singleline_comment|// flash_failed - Print a console message about why the failure&t;&t;/*{{{*/
singleline_comment|// ---------------------------------------------------------------------
multiline_comment|/* Pass the flags value that the flash return before it re-entered read &n;   mode. */
DECL|function|flash_failed
r_static
r_void
id|flash_failed
c_func
(paren
r_int
r_char
id|code
)paren
(brace
multiline_comment|/* Bit 5 being high indicates that there was an internal device&n;      failure, erasure time limits exceeded or something */
r_if
c_cond
(paren
(paren
id|code
op_amp
(paren
l_int|1
op_lshift
l_int|5
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mtd: Internal Flash failure&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;mtd: Programming didn&squot;t take&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*}}}*/
singleline_comment|// flash_erase - Generic erase function&t;&t;&t;&t;&t;/*{{{*/
singleline_comment|// ---------------------------------------------------------------------
multiline_comment|/* This uses the erasure function described in the AMD Flash Handbook, &n;   it will work for flashes with a fixed sector size only. Flashes with&n;   a selection of sector sizes (ie the AMD Am29F800B) will need a different&n;   routine. This routine tries to parallize erasing multiple chips/sectors &n;   where possible */
DECL|function|flash_erase
r_int
id|flash_erase
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
(brace
r_int
r_int
id|Time
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|NoTime
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|start
op_assign
id|instr-&gt;addr
comma
id|len
op_assign
id|instr-&gt;len
suffix:semicolon
r_int
r_int
id|I
suffix:semicolon
r_struct
id|mapped_mtd_info
op_star
id|map
op_assign
(paren
r_struct
id|mapped_mtd_info
op_star
)paren
id|mtd
suffix:semicolon
singleline_comment|// Verify the arguments..
r_if
c_cond
(paren
id|start
op_plus
id|len
OG
id|map-&gt;mtd.size
op_logical_or
(paren
id|start
op_mod
id|map-&gt;mtd.erasesize
)paren
op_ne
l_int|0
op_logical_or
(paren
id|len
op_mod
id|map-&gt;mtd.erasesize
)paren
op_ne
l_int|0
op_logical_or
(paren
id|len
op_div
id|map-&gt;mtd.erasesize
)paren
op_eq
l_int|0
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|flash_chip_scan
c_func
(paren
id|map
comma
id|start
comma
id|len
)paren
suffix:semicolon
singleline_comment|// Start the erase sequence on each chip
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|map-&gt;chips
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
suffix:semicolon
id|I
op_increment
)paren
(brace
r_int
r_int
id|off
suffix:semicolon
r_struct
id|flash_chip
op_star
id|chip
op_assign
id|map-&gt;chips
op_plus
id|I
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;length
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|page_jump
c_func
(paren
id|map
comma
id|chip-&gt;base
op_plus
id|chip-&gt;start
comma
l_int|0x555
comma
op_amp
id|base
comma
l_int|0
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
singleline_comment|// Send the erase setup code
id|writeb
c_func
(paren
l_int|0xF0
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0xAA
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x55
comma
id|base
op_plus
l_int|0x2AA
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x80
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0xAA
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x55
comma
id|base
op_plus
l_int|0x2AA
)paren
suffix:semicolon
singleline_comment|// Use chip erase if possible
r_if
c_cond
(paren
id|chip-&gt;start
op_eq
l_int|0
op_logical_and
id|chip-&gt;length
op_eq
id|chip-&gt;size
)paren
(brace
id|writeb
c_func
(paren
l_int|0x10
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* Once we start selecting the erase sectors the delay between each &n;         command must not exceed 50us or it will immediately start erasing &n;         and ignore the other sectors */
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|off
op_assign
l_int|0
suffix:semicolon
id|off
OL
id|chip-&gt;length
suffix:semicolon
id|off
op_add_assign
id|chip-&gt;sectorsize
)paren
(brace
r_if
c_cond
(paren
id|page_jump
c_func
(paren
id|map
comma
id|chip-&gt;base
op_plus
id|chip-&gt;start
op_plus
id|off
comma
l_int|1
comma
op_amp
id|base
comma
l_int|0
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
singleline_comment|// Check to make sure we didn&squot;t timeout
id|writeb
c_func
(paren
l_int|0x30
comma
id|base
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|readb
c_func
(paren
id|base
)paren
op_amp
(paren
l_int|1
op_lshift
l_int|3
)paren
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mtd: Ack! We timed out the erase timer!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/* We could split this into a timer routine and return early, performing&n;      background erasure.. Maybe later if the need warrents */
multiline_comment|/* Poll the flash for erasure completion, specs say this can take as long&n;      as 480 seconds to do all the sectors (for a 2 meg flash). &n;      Erasure time is dependant on chip age, temp and wear.. */
id|Time
op_assign
l_int|0
suffix:semicolon
id|NoTime
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|map-&gt;chips
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
suffix:semicolon
id|I
op_increment
)paren
(brace
r_struct
id|flash_chip
op_star
id|chip
op_assign
id|map-&gt;chips
op_plus
id|I
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
r_int
id|off
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|chip-&gt;length
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|page_jump
c_func
(paren
id|map
comma
id|chip-&gt;base
op_plus
id|chip-&gt;start
comma
l_int|1
comma
op_amp
id|base
comma
l_int|0
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_int
r_char
id|Last
(braket
l_int|4
)braket
suffix:semicolon
r_int
r_int
id|Count
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* During erase bit 7 is held low and bit 6 toggles, we watch this,&n;&t;    should it stop toggling or go high then the erase is completed,&n;  &t;    or this is not really flash ;&gt; */
id|Last
(braket
l_int|0
)braket
op_assign
id|readb
c_func
(paren
id|base
)paren
suffix:semicolon
id|Last
(braket
l_int|1
)braket
op_assign
id|readb
c_func
(paren
id|base
)paren
suffix:semicolon
id|Last
(braket
l_int|2
)braket
op_assign
id|readb
c_func
(paren
id|base
)paren
suffix:semicolon
r_for
c_loop
(paren
id|Count
op_assign
l_int|3
suffix:semicolon
(paren
id|Last
(braket
(paren
id|Count
op_minus
l_int|1
)paren
op_mod
l_int|4
)braket
op_amp
(paren
l_int|1
op_lshift
l_int|7
)paren
)paren
op_eq
l_int|0
op_logical_and
id|Last
(braket
(paren
id|Count
op_minus
l_int|1
)paren
op_mod
l_int|4
)braket
op_ne
id|Last
(braket
(paren
id|Count
op_minus
l_int|2
)paren
op_mod
l_int|4
)braket
suffix:semicolon
id|Count
op_increment
)paren
(brace
r_if
c_cond
(paren
id|NoTime
op_eq
l_int|0
)paren
id|Time
op_add_assign
id|HZ
op_div
l_int|10
op_minus
id|schedule_timeout
c_func
(paren
id|HZ
op_div
l_int|10
)paren
suffix:semicolon
id|NoTime
op_assign
l_int|0
suffix:semicolon
id|Last
(braket
id|Count
op_mod
l_int|4
)braket
op_assign
id|readb
c_func
(paren
id|base
)paren
suffix:semicolon
singleline_comment|// Count time, max of 15s per sector (according to AMD)
r_if
c_cond
(paren
id|Time
OG
l_int|15
op_star
id|len
op_div
id|mtd-&gt;erasesize
op_star
id|HZ
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mtd: Flash Erase Timed out&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|Last
(braket
(paren
id|Count
op_minus
l_int|1
)paren
op_mod
l_int|4
)braket
op_eq
id|Last
(braket
(paren
id|Count
op_minus
l_int|2
)paren
op_mod
l_int|4
)braket
)paren
(brace
id|flash_failed
c_func
(paren
id|Last
(braket
(paren
id|Count
op_minus
l_int|3
)paren
op_mod
l_int|4
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
singleline_comment|// Skip to the next chip if we used chip erase
r_if
c_cond
(paren
id|chip-&gt;length
op_eq
id|chip-&gt;size
)paren
id|off
op_assign
id|chip-&gt;size
suffix:semicolon
r_else
id|off
op_add_assign
id|chip-&gt;sectorsize
suffix:semicolon
r_if
c_cond
(paren
id|off
op_ge
id|chip-&gt;length
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|page_jump
c_func
(paren
id|map
comma
id|chip-&gt;base
op_plus
id|chip-&gt;start
op_plus
id|off
comma
l_int|1
comma
op_amp
id|base
comma
l_int|0
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|NoTime
op_assign
l_int|1
suffix:semicolon
)brace
)brace
singleline_comment|// Paranoid verify of erasure
(brace
r_int
r_int
id|base
suffix:semicolon
r_int
r_int
id|buflen
suffix:semicolon
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
r_int
id|step
suffix:semicolon
r_if
c_cond
(paren
id|page_jump
c_func
(paren
id|map
comma
id|start
comma
id|len
comma
op_amp
id|base
comma
op_amp
id|buflen
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|start
op_add_assign
id|buflen
suffix:semicolon
id|len
op_sub_assign
id|buflen
suffix:semicolon
id|step
op_assign
id|buflen
op_div
l_int|128
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|buflen
op_ne
l_int|0
suffix:semicolon
id|buflen
op_sub_assign
id|step
)paren
(brace
r_if
c_cond
(paren
id|readb
c_func
(paren
id|base
op_plus
id|buflen
op_minus
l_int|1
)paren
op_ne
l_int|0xFF
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mtd: Flash Erase didn&squot;t take %lu %lu %lu&bslash;n&quot;
comma
id|buflen
comma
id|len
comma
id|start
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#if 1
multiline_comment|/*}}}*/
singleline_comment|// flash_write - Generic writing function&t;&t;&t;&t;/*{{{*/
singleline_comment|// ---------------------------------------------------------------------
multiline_comment|/* This could do parallel writes on multiple chips but doesnt, memory &n;   constraints make that infeasable. This should work with any sort of &n;   linear flash that is not interleved */
DECL|function|flash_write
r_extern
r_int
id|flash_write
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|start
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|mapped_mtd_info
op_star
id|map
op_assign
(paren
r_struct
id|mapped_mtd_info
op_star
)paren
id|mtd
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
r_int
id|off
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_plus
id|len
OG
id|mtd-&gt;size
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_while
c_loop
(paren
id|len
op_ne
l_int|0
)paren
(brace
singleline_comment|// Compute the page offset and reposition
id|base
op_assign
id|map
op_member_access_from_pointer
id|page
c_func
(paren
id|map
comma
(paren
id|u_long
)paren
id|start
op_div
id|map-&gt;pagesize
)paren
suffix:semicolon
id|off
op_assign
(paren
id|u_long
)paren
id|start
op_mod
id|map-&gt;pagesize
suffix:semicolon
singleline_comment|// Loop over this page
r_for
c_loop
(paren
suffix:semicolon
id|off
op_ne
id|map-&gt;pagesize
op_logical_and
id|len
op_ne
l_int|0
suffix:semicolon
id|start
op_increment
comma
id|len
op_decrement
comma
id|off
op_increment
comma
id|buf
op_increment
)paren
(brace
r_int
r_char
id|oldbyte
op_assign
id|readb
c_func
(paren
id|base
op_plus
id|off
)paren
suffix:semicolon
r_int
r_char
id|Last
(braket
l_int|4
)braket
suffix:semicolon
r_int
r_int
id|Count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|oldbyte
op_eq
op_star
id|buf
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
op_complement
id|oldbyte
)paren
op_amp
op_star
id|buf
)paren
op_ne
l_int|0
)paren
id|printk
c_func
(paren
l_string|&quot;mtd: warn: Trying to set a 0 to a 1&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Write
id|writeb
c_func
(paren
l_int|0xAA
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0x55
comma
id|base
op_plus
l_int|0x2AA
)paren
suffix:semicolon
id|writeb
c_func
(paren
l_int|0xA0
comma
id|base
op_plus
l_int|0x555
)paren
suffix:semicolon
id|writeb
c_func
(paren
op_star
id|buf
comma
id|base
op_plus
id|off
)paren
suffix:semicolon
id|Last
(braket
l_int|0
)braket
op_assign
id|readb
c_func
(paren
id|base
op_plus
id|off
)paren
suffix:semicolon
id|Last
(braket
l_int|1
)braket
op_assign
id|readb
c_func
(paren
id|base
op_plus
id|off
)paren
suffix:semicolon
id|Last
(braket
l_int|2
)braket
op_assign
id|readb
c_func
(paren
id|base
op_plus
id|off
)paren
suffix:semicolon
multiline_comment|/* Wait for the flash to finish the operation. We store the last 4&n;&t;    status bytes that have been retrieved so we can determine why&n;&t;    it failed. The toggle bits keep toggling when there is a &n;&t;    failure */
r_for
c_loop
(paren
id|Count
op_assign
l_int|3
suffix:semicolon
id|Last
(braket
(paren
id|Count
op_minus
l_int|1
)paren
op_mod
l_int|4
)braket
op_ne
id|Last
(braket
(paren
id|Count
op_minus
l_int|2
)paren
op_mod
l_int|4
)braket
op_logical_and
id|Count
OL
l_int|10000
suffix:semicolon
id|Count
op_increment
)paren
id|Last
(braket
id|Count
op_mod
l_int|4
)braket
op_assign
id|readb
c_func
(paren
id|base
op_plus
id|off
)paren
suffix:semicolon
r_if
c_cond
(paren
id|Last
(braket
(paren
id|Count
op_minus
l_int|1
)paren
op_mod
l_int|4
)braket
op_ne
op_star
id|buf
)paren
(brace
id|flash_failed
c_func
(paren
id|Last
(braket
(paren
id|Count
op_minus
l_int|3
)paren
op_mod
l_int|4
)braket
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
)brace
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif
singleline_comment|// ram_write - Generic writing function&t;for ram&t;&t;&t;&t;/*{{{*/
singleline_comment|// ---------------------------------------------------------------------
multiline_comment|/* */
DECL|function|ram_write
r_extern
r_int
id|ram_write
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|start
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|mapped_mtd_info
op_star
id|map
op_assign
(paren
r_struct
id|mapped_mtd_info
op_star
)paren
id|mtd
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
id|origlen
op_assign
id|len
suffix:semicolon
r_int
r_int
id|buflen
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_plus
id|len
OG
id|mtd-&gt;size
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_while
c_loop
(paren
id|len
op_ne
l_int|0
)paren
(brace
singleline_comment|// Reposition..
r_if
c_cond
(paren
id|page_jump
c_func
(paren
id|map
comma
id|start
comma
id|len
comma
op_amp
id|base
comma
op_amp
id|buflen
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
singleline_comment|// Copy
id|memcpy_toio
c_func
(paren
id|base
comma
id|buf
comma
id|buflen
)paren
suffix:semicolon
id|len
op_sub_assign
id|buflen
suffix:semicolon
id|start
op_add_assign
id|buflen
suffix:semicolon
)brace
op_star
id|retlen
op_assign
id|origlen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// rom_read - Read handler for any sort of device&t;&t;&t;/*{{{*/
singleline_comment|// ---------------------------------------------------------------------
multiline_comment|/* This is a generic read function that should work with any device in the&n;   mapped region. */
DECL|function|rom_read
r_extern
r_int
id|rom_read
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|start
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|mapped_mtd_info
op_star
id|map
op_assign
(paren
r_struct
id|mapped_mtd_info
op_star
)paren
id|mtd
suffix:semicolon
r_int
id|origlen
op_assign
id|len
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
r_int
id|buflen
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Rom_Read&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
op_plus
id|len
OG
id|mtd-&gt;size
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_while
c_loop
(paren
id|len
op_ne
l_int|0
)paren
(brace
singleline_comment|// Reposition..
r_if
c_cond
(paren
id|page_jump
c_func
(paren
id|map
comma
id|start
comma
id|len
comma
op_amp
id|base
comma
op_amp
id|buflen
)paren
op_ne
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
singleline_comment|// Copy
id|memcpy_fromio
c_func
(paren
id|buf
comma
id|base
comma
id|buflen
)paren
suffix:semicolon
id|len
op_sub_assign
id|buflen
suffix:semicolon
id|start
op_add_assign
id|buflen
suffix:semicolon
)brace
op_star
id|retlen
op_assign
id|origlen
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// page_jump - Move the window and return the buffer&t;&t;&t;/*{{{*/
singleline_comment|// ---------------------------------------------------------------------
multiline_comment|/* Unlike the page function this returns a buffer and length adjusted for&n;   the page dimensions and the reading offset into the page, simplifies&n;   many of the other routines */
DECL|function|page_jump
r_int
id|page_jump
c_func
(paren
r_struct
id|mapped_mtd_info
op_star
id|map
comma
r_int
r_int
id|start
comma
r_int
r_int
id|len
comma
r_int
r_int
op_star
id|base
comma
r_int
r_int
op_star
id|retlen
)paren
(brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;Page Jump&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start
OG
id|map-&gt;mtd.size
op_logical_or
id|start
op_plus
id|len
OG
id|map-&gt;mtd.size
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
op_star
id|base
op_assign
id|map
op_member_access_from_pointer
id|page
c_func
(paren
id|map
comma
id|start
op_div
id|map-&gt;pagesize
)paren
suffix:semicolon
r_if
c_cond
(paren
op_star
id|base
op_eq
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
op_star
id|base
op_add_assign
id|start
op_mod
id|map-&gt;pagesize
suffix:semicolon
singleline_comment|// If retlen is 0 that mean the caller requires len bytes, no quibbling.
r_if
c_cond
(paren
id|retlen
op_eq
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|len
OG
id|map-&gt;pagesize
op_minus
(paren
id|start
op_mod
id|map-&gt;pagesize
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
singleline_comment|// Compute the buffer paramaters and return
r_if
c_cond
(paren
id|len
OG
id|map-&gt;pagesize
op_minus
(paren
id|start
op_mod
id|map-&gt;pagesize
)paren
)paren
op_star
id|retlen
op_assign
id|map-&gt;pagesize
op_minus
(paren
id|start
op_mod
id|map-&gt;pagesize
)paren
suffix:semicolon
r_else
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*}}}*/
singleline_comment|// flash_chip_scan - Intersect a region with the flash chip structure&t;/*{{{*/
singleline_comment|// ---------------------------------------------------------------------
multiline_comment|/* This is used to enhance the speed of the erase routine,&n;   when things are being done to multiple chips it is possible to&n;   parallize the operations, particularly full memory erases of multi&n;   chip memories benifit */
DECL|function|flash_chip_scan
r_void
id|flash_chip_scan
c_func
(paren
r_struct
id|mapped_mtd_info
op_star
id|map
comma
r_int
r_int
id|start
comma
r_int
r_int
id|len
)paren
(brace
r_int
r_int
id|I
op_assign
l_int|0
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
singleline_comment|// Zero the records
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|map-&gt;chips
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
suffix:semicolon
id|I
op_increment
)paren
id|map-&gt;chips
(braket
id|I
)braket
dot
id|start
op_assign
id|map-&gt;chips
(braket
id|I
)braket
dot
id|length
op_assign
l_int|0
suffix:semicolon
singleline_comment|// Intesect our region with the chip structures
r_for
c_loop
(paren
id|I
op_assign
l_int|0
suffix:semicolon
id|map-&gt;chips
(braket
id|I
)braket
dot
id|jedec
op_ne
l_int|0
op_logical_and
id|len
op_ne
l_int|0
suffix:semicolon
id|I
op_increment
)paren
(brace
singleline_comment|// Havent found the start yet
r_if
c_cond
(paren
id|start
op_ge
id|map-&gt;chips
(braket
id|I
)braket
dot
id|base
op_plus
id|map-&gt;chips
(braket
id|I
)braket
dot
id|size
)paren
r_continue
suffix:semicolon
singleline_comment|// Store the portion of this chip that is being effected
id|map-&gt;chips
(braket
id|I
)braket
dot
id|start
op_assign
id|start
op_minus
id|map-&gt;chips
(braket
id|I
)braket
dot
id|base
suffix:semicolon
r_if
c_cond
(paren
id|len
op_le
id|map-&gt;chips
(braket
id|I
)braket
dot
id|size
op_minus
id|map-&gt;chips
(braket
id|I
)braket
dot
id|start
)paren
id|map-&gt;chips
(braket
id|I
)braket
dot
id|length
op_assign
id|len
suffix:semicolon
r_else
id|map-&gt;chips
(braket
id|I
)braket
dot
id|length
op_assign
id|map-&gt;chips
(braket
id|I
)braket
dot
id|size
op_minus
id|map-&gt;chips
(braket
id|I
)braket
dot
id|start
suffix:semicolon
id|len
op_sub_assign
id|map-&gt;chips
(braket
id|I
)braket
dot
id|length
suffix:semicolon
id|start
op_assign
id|map-&gt;chips
(braket
id|I
)braket
dot
id|base
op_plus
id|map-&gt;chips
(braket
id|I
)braket
dot
id|size
suffix:semicolon
)brace
)brace
multiline_comment|/*}}}*/
eof
