multiline_comment|/*&n; * $Id: pmc551.c,v 1.11 2000/11/23 13:40:12 dwmw2 Exp $&n; *&n; * PMC551 PCI Mezzanine Ram Device&n; *&n; * Author:&n; *       Mark Ferrell &lt;mferrell@mvista.com&gt;&n; *       Copyright 1999,2000 Nortel Networks&n; *&n; * License:&n; *&t; As part of this driver was derrived from the slram.c driver it falls&n; *&t; under the same license, which is GNU General Public License v2&n; *&n; * Description:&n; *&t; This driver is intended to support the PMC551 PCI Ram device from&n; *&t; Ramix Inc.  The PMC551 is a PMC Mezzanine module for cPCI embeded&n; *&t; systems.  The device contains a single SROM that initally programs the&n; *&t; V370PDC chipset onboard the device, and various banks of DRAM/SDRAM&n; *&t; onboard.  This driver implements this PCI Ram device as an MTD (Memory&n; *&t; Technologies Device) so that it can be used to hold a filesystem, or&n; *&t; for added swap space in embeded systems.  Since the memory on this&n; *&t; board isn&squot;t as fast as main memory we do not try to hook it into main&n; *&t; memeory as that would simply reduce performance on the system.  Using&n; *&t; it as a block device allows us to use it as high speed swap or for a&n; *&t; high speed disk device of some sort.  Which becomes very usefull on&n; *&t; diskless systems in the embeded market I might add.&n; *&t; &n; * Notes:&n; *&t; Due to what I assume is more buggy SROM, the 64M PMC551 I have&n; *&t; available claims that all 4 of it&squot;s DRAM banks have 64M of ram &n; *&t; configured (making a grand total of 256M onboard).  This is slightly&n; *&t; annoying since the BAR0 size reflects the aperture size, not the dram&n; *&t; size, and the V370PDC supplies no other method for memory size&n; *&t; discovery.  This problem is mostly only relivant when compiled as a&n; *&t; module, as the unloading of the module with an aperture size  smaller&n; *&t; then the ram will cause the driver to detect the onboard memory size&n; *&t; to be equal to the aperture size when the module is reloaded.  Soooo,&n; *&t; to help, the module supports an msize option to allow the&n; *&t; specification of the onboard memory, and an asize option, to allow the&n; *&t; specification of the aperture size.  The aperture must be equal to or&n; *&t; less then the memory size, the driver will correct this if you screw&n; *&t; it up.  This problem is not relivant for compiled in drivers as&n; *&t; compiled in drivers only init once.&n; *&n; * Credits:&n; *       Saeed Karamooz &lt;saeed@ramix.com&gt; of Ramix INC. for the initial&n; *       example code of how to initialize this device and for help with&n; *       questions I had concerning operation of the device.&n; *&n; *       Most of the MTD code for this driver was originally written for the&n; *       slram.o module in the MTD drivers package written by David Hinds&n; *       &lt;dhinds@allegro.stanford.edu&gt; which allows the mapping of system&n; *       memory into an mtd device.  Since the PMC551 memory module is&n; *       accessed in the same fashion as system memory, the slram.c code&n; *       became a very nice fit to the needs of this driver.  All we added was&n; *       PCI detection/initialization to the driver and automaticly figure out&n; *       the size via the PCI detection.o, later changes by Corey Minyard&n; *       settup the card to utilize a 1M sliding apature.&n; *&n; *&t; Corey Minyard &lt;minyard@nortelnetworks.com&gt;&n; *       * Modified driver to utilize a sliding apature instead of mapping all&n; *       memory into kernel space which turned out to be very wastefull.&n; *       * Located a bug in the SROM&squot;s initialization sequence that made the&n; *       memory unusable, added a fix to code to touch up the DRAM some.&n; *&n; * Bugs/FIXME&squot;s:&n; *       * MUST fix the init function to not spin on a register&n; *       waiting for it to set .. this does not safely handle busted devices&n; *       that never reset the register correctly which will cause the system to&n; *       hang w/ a reboot beeing the only chance at recover.&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/segment.h&gt;
macro_line|#include &lt;stdarg.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#ifndef CONFIG_PCI
macro_line|#error Enable PCI in your kernel config
macro_line|#endif
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/pmc551.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt;
macro_line|#if LINUX_VERSION_CODE &gt; 0x20300
DECL|macro|PCI_BASE_ADDRESS
mdefine_line|#define PCI_BASE_ADDRESS(dev) (dev-&gt;resource[0].start)
macro_line|#else
DECL|macro|PCI_BASE_ADDRESS
mdefine_line|#define PCI_BASE_ADDRESS(dev) (dev-&gt;base_address[0])
macro_line|#endif
DECL|variable|pmc551list
r_static
r_struct
id|mtd_info
op_star
id|pmc551list
op_assign
l_int|NULL
suffix:semicolon
DECL|function|pmc551_erase
r_static
r_int
id|pmc551_erase
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
(brace
r_struct
id|mypriv
op_star
id|priv
op_assign
id|mtd-&gt;priv
suffix:semicolon
id|u32
id|start_addr_highbits
suffix:semicolon
id|u32
id|end_addr_highbits
suffix:semicolon
id|u32
id|start_addr_lowbits
suffix:semicolon
id|u32
id|end_addr_lowbits
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
id|end
op_assign
id|instr-&gt;addr
op_plus
id|instr-&gt;len
suffix:semicolon
multiline_comment|/* Is it too much memory?  The second check find if we wrap around&n;           past the end of a u32. */
r_if
c_cond
(paren
(paren
id|end
OG
id|mtd-&gt;size
)paren
op_logical_or
(paren
id|end
OL
id|instr-&gt;addr
)paren
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|start_addr_highbits
op_assign
id|instr-&gt;addr
op_amp
id|PMC551_ADDR_HIGH_MASK
suffix:semicolon
id|end_addr_highbits
op_assign
id|end
op_amp
id|PMC551_ADDR_HIGH_MASK
suffix:semicolon
id|start_addr_lowbits
op_assign
id|instr-&gt;addr
op_amp
id|PMC551_ADDR_LOW_MASK
suffix:semicolon
id|end_addr_lowbits
op_assign
id|end
op_amp
id|PMC551_ADDR_LOW_MASK
suffix:semicolon
id|pci_write_config_dword
(paren
id|priv-&gt;dev
comma
id|PMC551_PCI_MEM_MAP0
comma
(paren
id|priv-&gt;mem_map0_base_val
op_or
id|start_addr_highbits
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|start_addr_highbits
op_eq
id|end_addr_highbits
)paren
(brace
multiline_comment|/* The whole thing fits within one access, so just one shot&n;                   will do it. */
id|memset
c_func
(paren
id|priv-&gt;start
op_plus
id|start_addr_lowbits
comma
l_int|0xff
comma
id|instr-&gt;len
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We have to do multiple writes to get all the data&n;                   written. */
id|memset
c_func
(paren
id|priv-&gt;start
op_plus
id|start_addr_lowbits
comma
l_int|0xff
comma
id|priv-&gt;aperture_size
op_minus
id|start_addr_lowbits
)paren
suffix:semicolon
id|start_addr_highbits
op_add_assign
id|priv-&gt;aperture_size
suffix:semicolon
r_while
c_loop
(paren
id|start_addr_highbits
op_ne
id|end_addr_highbits
)paren
(brace
id|pci_write_config_dword
(paren
id|priv-&gt;dev
comma
id|PMC551_PCI_MEM_MAP0
comma
(paren
id|priv-&gt;mem_map0_base_val
op_or
id|start_addr_highbits
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|priv-&gt;start
comma
l_int|0xff
comma
id|priv-&gt;aperture_size
)paren
suffix:semicolon
id|start_addr_highbits
op_add_assign
id|priv-&gt;aperture_size
suffix:semicolon
)brace
id|priv-&gt;curr_mem_map0_val
op_assign
(paren
id|priv-&gt;mem_map0_base_val
op_or
id|start_addr_highbits
)paren
suffix:semicolon
id|pci_write_config_dword
(paren
id|priv-&gt;dev
comma
id|PMC551_PCI_MEM_MAP0
comma
id|priv-&gt;curr_mem_map0_val
)paren
suffix:semicolon
id|memset
c_func
(paren
id|priv-&gt;start
comma
l_int|0xff
comma
id|end_addr_lowbits
)paren
suffix:semicolon
)brace
id|instr-&gt;state
op_assign
id|MTD_ERASE_DONE
suffix:semicolon
r_if
c_cond
(paren
id|instr-&gt;callback
)paren
(brace
(paren
op_star
(paren
id|instr-&gt;callback
)paren
)paren
(paren
id|instr
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pmc551_unpoint
r_static
r_void
id|pmc551_unpoint
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|u_char
op_star
id|addr
)paren
(brace
)brace
DECL|function|pmc551_read
r_static
r_int
id|pmc551_read
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|mypriv
op_star
id|priv
op_assign
(paren
r_struct
id|mypriv
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
id|u32
id|start_addr_highbits
suffix:semicolon
id|u32
id|end_addr_highbits
suffix:semicolon
id|u32
id|start_addr_lowbits
suffix:semicolon
id|u32
id|end_addr_lowbits
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
id|u_char
op_star
id|copyto
op_assign
id|buf
suffix:semicolon
multiline_comment|/* Is it past the end? */
r_if
c_cond
(paren
id|from
OG
id|mtd-&gt;size
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|end
op_assign
id|from
op_plus
id|len
suffix:semicolon
id|start_addr_highbits
op_assign
id|from
op_amp
id|PMC551_ADDR_HIGH_MASK
suffix:semicolon
id|end_addr_highbits
op_assign
id|end
op_amp
id|PMC551_ADDR_HIGH_MASK
suffix:semicolon
id|start_addr_lowbits
op_assign
id|from
op_amp
id|PMC551_ADDR_LOW_MASK
suffix:semicolon
id|end_addr_lowbits
op_assign
id|end
op_amp
id|PMC551_ADDR_LOW_MASK
suffix:semicolon
multiline_comment|/* Only rewrite the first value if it doesn&squot;t match our current&n;           values.  Most operations are on the same page as the previous&n;           value, so this is a pretty good optimization. */
r_if
c_cond
(paren
id|priv-&gt;curr_mem_map0_val
op_ne
(paren
id|priv-&gt;mem_map0_base_val
op_or
id|start_addr_highbits
)paren
)paren
(brace
id|priv-&gt;curr_mem_map0_val
op_assign
(paren
id|priv-&gt;mem_map0_base_val
op_or
id|start_addr_highbits
)paren
suffix:semicolon
id|pci_write_config_dword
(paren
id|priv-&gt;dev
comma
id|PMC551_PCI_MEM_MAP0
comma
id|priv-&gt;curr_mem_map0_val
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start_addr_highbits
op_eq
id|end_addr_highbits
)paren
(brace
multiline_comment|/* The whole thing fits within one access, so just one shot&n;                   will do it. */
id|memcpy
c_func
(paren
id|copyto
comma
id|priv-&gt;start
op_plus
id|start_addr_lowbits
comma
id|len
)paren
suffix:semicolon
id|copyto
op_add_assign
id|len
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We have to do multiple writes to get all the data&n;                   written. */
id|memcpy
c_func
(paren
id|copyto
comma
id|priv-&gt;start
op_plus
id|start_addr_lowbits
comma
id|priv-&gt;aperture_size
op_minus
id|start_addr_lowbits
)paren
suffix:semicolon
id|copyto
op_add_assign
id|priv-&gt;aperture_size
op_minus
id|start_addr_lowbits
suffix:semicolon
id|start_addr_highbits
op_add_assign
id|priv-&gt;aperture_size
suffix:semicolon
r_while
c_loop
(paren
id|start_addr_highbits
op_ne
id|end_addr_highbits
)paren
(brace
id|pci_write_config_dword
(paren
id|priv-&gt;dev
comma
id|PMC551_PCI_MEM_MAP0
comma
(paren
id|priv-&gt;mem_map0_base_val
op_or
id|start_addr_highbits
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|copyto
comma
id|priv-&gt;start
comma
id|priv-&gt;aperture_size
)paren
suffix:semicolon
id|copyto
op_add_assign
id|priv-&gt;aperture_size
suffix:semicolon
id|start_addr_highbits
op_add_assign
id|priv-&gt;aperture_size
suffix:semicolon
r_if
c_cond
(paren
id|start_addr_highbits
op_ge
id|mtd-&gt;size
)paren
(brace
multiline_comment|/* Make sure we have the right value here. */
id|priv-&gt;curr_mem_map0_val
op_assign
(paren
id|priv-&gt;mem_map0_base_val
op_or
id|start_addr_highbits
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|priv-&gt;curr_mem_map0_val
op_assign
(paren
id|priv-&gt;mem_map0_base_val
op_or
id|start_addr_highbits
)paren
suffix:semicolon
id|pci_write_config_dword
(paren
id|priv-&gt;dev
comma
id|PMC551_PCI_MEM_MAP0
comma
id|priv-&gt;curr_mem_map0_val
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|copyto
comma
id|priv-&gt;start
comma
id|end_addr_lowbits
)paren
suffix:semicolon
id|copyto
op_add_assign
id|end_addr_lowbits
suffix:semicolon
)brace
id|out
suffix:colon
op_star
id|retlen
op_assign
id|copyto
op_minus
id|buf
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pmc551_write
r_static
r_int
id|pmc551_write
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_struct
id|mypriv
op_star
id|priv
op_assign
(paren
r_struct
id|mypriv
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
id|u32
id|start_addr_highbits
suffix:semicolon
id|u32
id|end_addr_highbits
suffix:semicolon
id|u32
id|start_addr_lowbits
suffix:semicolon
id|u32
id|end_addr_lowbits
suffix:semicolon
r_int
r_int
id|end
suffix:semicolon
r_const
id|u_char
op_star
id|copyfrom
op_assign
id|buf
suffix:semicolon
multiline_comment|/* Is it past the end? */
r_if
c_cond
(paren
id|to
OG
id|mtd-&gt;size
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
id|end
op_assign
id|to
op_plus
id|len
suffix:semicolon
id|start_addr_highbits
op_assign
id|to
op_amp
id|PMC551_ADDR_HIGH_MASK
suffix:semicolon
id|end_addr_highbits
op_assign
id|end
op_amp
id|PMC551_ADDR_HIGH_MASK
suffix:semicolon
id|start_addr_lowbits
op_assign
id|to
op_amp
id|PMC551_ADDR_LOW_MASK
suffix:semicolon
id|end_addr_lowbits
op_assign
id|end
op_amp
id|PMC551_ADDR_LOW_MASK
suffix:semicolon
multiline_comment|/* Only rewrite the first value if it doesn&squot;t match our current&n;           values.  Most operations are on the same page as the previous&n;           value, so this is a pretty good optimization. */
r_if
c_cond
(paren
id|priv-&gt;curr_mem_map0_val
op_ne
(paren
id|priv-&gt;mem_map0_base_val
op_or
id|start_addr_highbits
)paren
)paren
(brace
id|priv-&gt;curr_mem_map0_val
op_assign
(paren
id|priv-&gt;mem_map0_base_val
op_or
id|start_addr_highbits
)paren
suffix:semicolon
id|pci_write_config_dword
(paren
id|priv-&gt;dev
comma
id|PMC551_PCI_MEM_MAP0
comma
id|priv-&gt;curr_mem_map0_val
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|start_addr_highbits
op_eq
id|end_addr_highbits
)paren
(brace
multiline_comment|/* The whole thing fits within one access, so just one shot&n;                   will do it. */
id|memcpy
c_func
(paren
id|priv-&gt;start
op_plus
id|start_addr_lowbits
comma
id|copyfrom
comma
id|len
)paren
suffix:semicolon
id|copyfrom
op_add_assign
id|len
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* We have to do multiple writes to get all the data&n;                   written. */
id|memcpy
c_func
(paren
id|priv-&gt;start
op_plus
id|start_addr_lowbits
comma
id|copyfrom
comma
id|priv-&gt;aperture_size
op_minus
id|start_addr_lowbits
)paren
suffix:semicolon
id|copyfrom
op_add_assign
id|priv-&gt;aperture_size
op_minus
id|start_addr_lowbits
suffix:semicolon
id|start_addr_highbits
op_add_assign
id|priv-&gt;aperture_size
suffix:semicolon
r_while
c_loop
(paren
id|start_addr_highbits
op_ne
id|end_addr_highbits
)paren
(brace
id|pci_write_config_dword
(paren
id|priv-&gt;dev
comma
id|PMC551_PCI_MEM_MAP0
comma
(paren
id|priv-&gt;mem_map0_base_val
op_or
id|start_addr_highbits
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|priv-&gt;start
comma
id|copyfrom
comma
id|priv-&gt;aperture_size
)paren
suffix:semicolon
id|copyfrom
op_add_assign
id|priv-&gt;aperture_size
suffix:semicolon
id|start_addr_highbits
op_add_assign
id|priv-&gt;aperture_size
suffix:semicolon
r_if
c_cond
(paren
id|start_addr_highbits
op_ge
id|mtd-&gt;size
)paren
(brace
multiline_comment|/* Make sure we have the right value here. */
id|priv-&gt;curr_mem_map0_val
op_assign
(paren
id|priv-&gt;mem_map0_base_val
op_or
id|start_addr_highbits
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
)brace
id|priv-&gt;curr_mem_map0_val
op_assign
(paren
id|priv-&gt;mem_map0_base_val
op_or
id|start_addr_highbits
)paren
suffix:semicolon
id|pci_write_config_dword
(paren
id|priv-&gt;dev
comma
id|PMC551_PCI_MEM_MAP0
comma
id|priv-&gt;curr_mem_map0_val
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|priv-&gt;start
comma
id|copyfrom
comma
id|end_addr_lowbits
)paren
suffix:semicolon
id|copyfrom
op_add_assign
id|end_addr_lowbits
suffix:semicolon
)brace
id|out
suffix:colon
op_star
id|retlen
op_assign
id|copyfrom
op_minus
id|buf
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Fixup routines for the V370PDC&n; * PCI device ID 0x020011b0&n; *&n; * This function basicly kick starts the DRAM oboard the card and gets it&n; * ready to be used.  Before this is done the device reads VERY erratic, so&n; * much that it can crash the Linux 2.2.x series kernels when a user cat&squot;s&n; * /proc/pci .. though that is mainly a kernel bug in handling the PCI DEVSEL&n; * register.  FIXME: stop spinning on registers .. must implement a timeout&n; * mechanism&n; * returns the size of the memory region found.&n; */
DECL|function|fixup_pmc551
r_static
id|u32
id|fixup_pmc551
(paren
r_struct
id|pci_dev
op_star
id|dev
)paren
(brace
macro_line|#ifdef CONFIG_MTD_PMC551_BUGFIX
id|u32
id|dram_data
suffix:semicolon
macro_line|#endif
id|u32
id|size
comma
id|dcmd
comma
id|cfg
comma
id|dtmp
suffix:semicolon
id|u16
id|cmd
comma
id|tmp
comma
id|i
suffix:semicolon
id|u8
id|bcmd
comma
id|counter
suffix:semicolon
multiline_comment|/* Sanity Check */
r_if
c_cond
(paren
op_logical_neg
id|dev
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Attempt to reset the card&n;&t; * FIXME: Stop Spinning registers&n;&t; */
id|counter
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* unlock registers */
id|pci_write_config_byte
c_func
(paren
id|dev
comma
id|PMC551_SYS_CTRL_REG
comma
l_int|0xA5
)paren
suffix:semicolon
multiline_comment|/* read in old data */
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PMC551_SYS_CTRL_REG
comma
op_amp
id|bcmd
)paren
suffix:semicolon
multiline_comment|/* bang the reset line up and down for a few */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|10
suffix:semicolon
id|i
op_increment
)paren
(brace
id|counter
op_assign
l_int|0
suffix:semicolon
id|bcmd
op_and_assign
op_complement
l_int|0x80
suffix:semicolon
r_while
c_loop
(paren
id|counter
op_increment
OL
l_int|100
)paren
(brace
id|pci_write_config_byte
c_func
(paren
id|dev
comma
id|PMC551_SYS_CTRL_REG
comma
id|bcmd
)paren
suffix:semicolon
)brace
id|counter
op_assign
l_int|0
suffix:semicolon
id|bcmd
op_or_assign
l_int|0x80
suffix:semicolon
r_while
c_loop
(paren
id|counter
op_increment
OL
l_int|100
)paren
(brace
id|pci_write_config_byte
c_func
(paren
id|dev
comma
id|PMC551_SYS_CTRL_REG
comma
id|bcmd
)paren
suffix:semicolon
)brace
)brace
id|bcmd
op_or_assign
(paren
l_int|0x40
op_or
l_int|0x20
)paren
suffix:semicolon
id|pci_write_config_byte
c_func
(paren
id|dev
comma
id|PMC551_SYS_CTRL_REG
comma
id|bcmd
)paren
suffix:semicolon
multiline_comment|/* &n;&t; * Take care and turn off the memory on the device while we&n;&t; * tweak the configurations&n;&t; */
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|tmp
op_assign
id|cmd
op_amp
op_complement
(paren
id|PCI_COMMAND_IO
op_or
id|PCI_COMMAND_MEMORY
)paren
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|tmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Disable existing aperture before probing memory size&n;&t; */
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_PCI_MEM_MAP0
comma
op_amp
id|dcmd
)paren
suffix:semicolon
id|dtmp
op_assign
(paren
id|dcmd
op_or
id|PMC551_PCI_MEM_MAP_ENABLE
op_or
id|PMC551_PCI_MEM_MAP_REG_EN
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PMC551_PCI_MEM_MAP0
comma
id|dtmp
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Grab old BAR0 config so that we can figure out memory size&n;&t; * This is another bit of kludge going on.  The reason for the&n;&t; * redundancy is I am hoping to retain the original configuration&n;&t; * previously assigned to the card by the BIOS or some previous &n;&t; * fixup routine in the kernel.  So we read the old config into cfg,&n;&t; * then write all 1&squot;s to the memory space, read back the result into&n;&t; * &quot;size&quot;, and then write back all the old config.&n;&t; */
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|cfg
)paren
suffix:semicolon
macro_line|#ifndef CONFIG_MTD_PMC551_BUGFIX
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
comma
op_complement
l_int|0
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
comma
op_amp
id|size
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
comma
id|cfg
)paren
suffix:semicolon
id|size
op_assign
op_complement
(paren
id|size
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
op_plus
l_int|1
suffix:semicolon
macro_line|#else
multiline_comment|/*&n;         * Get the size of the memory by reading all the DRAM size values&n;         * and adding them up.&n;         *&n;         * KLUDGE ALERT: the boards we are using have invalid column and&n;         * row mux values.  We fix them here, but this will break other&n;         * memory configurations.&n;         */
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK0
comma
op_amp
id|dram_data
)paren
suffix:semicolon
id|size
op_assign
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dram_data
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_COL_MUX
c_func
(paren
id|dram_data
comma
l_int|0x5
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_ROW_MUX
c_func
(paren
id|dram_data
comma
l_int|0x9
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK0
comma
id|dram_data
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK1
comma
op_amp
id|dram_data
)paren
suffix:semicolon
id|size
op_add_assign
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dram_data
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_COL_MUX
c_func
(paren
id|dram_data
comma
l_int|0x5
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_ROW_MUX
c_func
(paren
id|dram_data
comma
l_int|0x9
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK1
comma
id|dram_data
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK2
comma
op_amp
id|dram_data
)paren
suffix:semicolon
id|size
op_add_assign
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dram_data
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_COL_MUX
c_func
(paren
id|dram_data
comma
l_int|0x5
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_ROW_MUX
c_func
(paren
id|dram_data
comma
l_int|0x9
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK2
comma
id|dram_data
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK3
comma
op_amp
id|dram_data
)paren
suffix:semicolon
id|size
op_add_assign
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dram_data
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_COL_MUX
c_func
(paren
id|dram_data
comma
l_int|0x5
)paren
suffix:semicolon
id|dram_data
op_assign
id|PMC551_DRAM_BLK_SET_ROW_MUX
c_func
(paren
id|dram_data
comma
l_int|0x9
)paren
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK3
comma
id|dram_data
)paren
suffix:semicolon
multiline_comment|/*&n;         * Oops .. something went wrong&n;         */
r_if
c_cond
(paren
(paren
id|size
op_and_assign
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
op_eq
l_int|0
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_MTD_PMC551_BUGFIX */
r_if
c_cond
(paren
(paren
id|cfg
op_amp
id|PCI_BASE_ADDRESS_SPACE
)paren
op_ne
id|PCI_BASE_ADDRESS_SPACE_MEMORY
)paren
(brace
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;         * Precharge Dram&n;         */
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PMC551_SDRAM_MA
comma
l_int|0x0400
)paren
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PMC551_SDRAM_CMD
comma
l_int|0x00bf
)paren
suffix:semicolon
multiline_comment|/*&n;         * Wait untill command has gone through&n;         * FIXME: register spinning issue&n;         */
r_do
(brace
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PMC551_SDRAM_CMD
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_increment
OG
l_int|100
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|PCI_COMMAND_IO
)paren
op_amp
id|cmd
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Turn on auto refresh &n;&t; * The loop is taken directly from Ramix&squot;s example code.  I assume that&n;&t; * this must be held high for some duration of time, but I can find no&n;&t; * documentation refrencing the reasons why.&n;&t; * &n;         */
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
l_int|8
suffix:semicolon
id|i
op_increment
)paren
(brace
id|pci_write_config_word
(paren
id|dev
comma
id|PMC551_SDRAM_CMD
comma
l_int|0x0df
)paren
suffix:semicolon
multiline_comment|/*&n;                 * Make certain command has gone through&n;                 * FIXME: register spinning issue&n;                 */
id|counter
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PMC551_SDRAM_CMD
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_increment
OG
l_int|100
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|PCI_COMMAND_IO
)paren
op_amp
id|cmd
)paren
suffix:semicolon
)brace
id|pci_write_config_word
(paren
id|dev
comma
id|PMC551_SDRAM_MA
comma
l_int|0x0020
)paren
suffix:semicolon
id|pci_write_config_word
(paren
id|dev
comma
id|PMC551_SDRAM_CMD
comma
l_int|0x0ff
)paren
suffix:semicolon
multiline_comment|/*&n;         * Wait until command completes&n;         * FIXME: register spinning issue&n;         */
id|counter
op_assign
l_int|0
suffix:semicolon
r_do
(brace
id|pci_read_config_word
(paren
id|dev
comma
id|PMC551_SDRAM_CMD
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|counter
op_increment
OG
l_int|100
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
id|PCI_COMMAND_IO
)paren
op_amp
id|cmd
)paren
suffix:semicolon
id|pci_read_config_dword
(paren
id|dev
comma
id|PMC551_DRAM_CFG
comma
op_amp
id|dcmd
)paren
suffix:semicolon
id|dcmd
op_or_assign
l_int|0x02000000
suffix:semicolon
id|pci_write_config_dword
(paren
id|dev
comma
id|PMC551_DRAM_CFG
comma
id|dcmd
)paren
suffix:semicolon
multiline_comment|/*&n;         * Check to make certain fast back-to-back, if not&n;         * then set it so&n;         */
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_STATUS
comma
op_amp
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|cmd
op_amp
id|PCI_COMMAND_FAST_BACK
)paren
op_eq
l_int|0
)paren
(brace
id|cmd
op_or_assign
id|PCI_COMMAND_FAST_BACK
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_STATUS
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * Check to make certain the DEVSEL is set correctly, this device&n;         * has a tendancy to assert DEVSEL and TRDY when a write is performed&n;         * to the memory when memory is read-only&n;         */
r_if
c_cond
(paren
(paren
id|cmd
op_amp
id|PCI_STATUS_DEVSEL_MASK
)paren
op_ne
l_int|0x0
)paren
(brace
id|cmd
op_and_assign
op_complement
id|PCI_STATUS_DEVSEL_MASK
suffix:semicolon
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_STATUS
comma
id|cmd
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;         * Set to be prefetchable and put everything back based on old cfg.&n;&t; * it&squot;s possible that the reset of the V370PDC nuked the original&n;&t; * settup&n;         */
id|cfg
op_or_assign
id|PCI_BASE_ADDRESS_MEM_PREFETCH
suffix:semicolon
id|pci_write_config_dword
c_func
(paren
id|dev
comma
id|PCI_BASE_ADDRESS_0
comma
id|cfg
)paren
suffix:semicolon
multiline_comment|/*&n;         * Turn PCI memory and I/O bus access back on&n;         */
id|pci_write_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
id|PCI_COMMAND_MEMORY
op_or
id|PCI_COMMAND_IO
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
multiline_comment|/*&n;         * Some screen fun&n;         */
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: %d%c (0x%x) of %sprefetchable memory at 0x%lx&bslash;n&quot;
comma
(paren
id|size
OL
l_int|1024
)paren
ques
c_cond
id|size
suffix:colon
(paren
id|size
OL
l_int|1048576
)paren
ques
c_cond
id|size
op_div
l_int|1024
suffix:colon
id|size
op_div
l_int|1024
op_div
l_int|1024
comma
(paren
id|size
OL
l_int|1024
)paren
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
(paren
id|size
OL
l_int|1048576
)paren
ques
c_cond
l_char|&squot;K&squot;
suffix:colon
l_char|&squot;M&squot;
comma
id|size
comma
(paren
(paren
id|dcmd
op_amp
(paren
l_int|0x1
op_lshift
l_int|3
)paren
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;non-&quot;
suffix:colon
l_string|&quot;&quot;
comma
id|PCI_BASE_ADDRESS
c_func
(paren
id|dev
)paren
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
suffix:semicolon
multiline_comment|/*&n;         * Check to see the state of the memory&n;         */
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK0
comma
op_amp
id|dcmd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: DRAM_BLK0 Flags: %s,%s&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK0 Size: %d at %d&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK0 Row MUX: %d, Col MUX: %d&bslash;n&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|1
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;RW&quot;
suffix:colon
l_string|&quot;RO&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|0
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;Off&quot;
suffix:colon
l_string|&quot;On&quot;
comma
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dcmd
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|20
)paren
op_amp
l_int|0x7FF
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|13
)paren
op_amp
l_int|0x7
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|9
)paren
op_amp
l_int|0xF
)paren
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK1
comma
op_amp
id|dcmd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: DRAM_BLK1 Flags: %s,%s&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK1 Size: %d at %d&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK1 Row MUX: %d, Col MUX: %d&bslash;n&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|1
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;RW&quot;
suffix:colon
l_string|&quot;RO&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|0
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;Off&quot;
suffix:colon
l_string|&quot;On&quot;
comma
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dcmd
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|20
)paren
op_amp
l_int|0x7FF
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|13
)paren
op_amp
l_int|0x7
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|9
)paren
op_amp
l_int|0xF
)paren
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK2
comma
op_amp
id|dcmd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: DRAM_BLK2 Flags: %s,%s&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK2 Size: %d at %d&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK2 Row MUX: %d, Col MUX: %d&bslash;n&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|1
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;RW&quot;
suffix:colon
l_string|&quot;RO&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|0
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;Off&quot;
suffix:colon
l_string|&quot;On&quot;
comma
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dcmd
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|20
)paren
op_amp
l_int|0x7FF
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|13
)paren
op_amp
l_int|0x7
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|9
)paren
op_amp
l_int|0xF
)paren
)paren
suffix:semicolon
id|pci_read_config_dword
c_func
(paren
id|dev
comma
id|PMC551_DRAM_BLK3
comma
op_amp
id|dcmd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: DRAM_BLK3 Flags: %s,%s&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK3 Size: %d at %d&bslash;n&quot;
l_string|&quot;pmc551: DRAM_BLK3 Row MUX: %d, Col MUX: %d&bslash;n&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|1
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;RW&quot;
suffix:colon
l_string|&quot;RO&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|0
)paren
op_amp
id|dcmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;Off&quot;
suffix:colon
l_string|&quot;On&quot;
comma
id|PMC551_DRAM_BLK_GET_SIZE
c_func
(paren
id|dcmd
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|20
)paren
op_amp
l_int|0x7FF
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|13
)paren
op_amp
l_int|0x7
)paren
comma
(paren
(paren
id|dcmd
op_rshift
l_int|9
)paren
op_amp
l_int|0xF
)paren
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_COMMAND
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: Memory Access %s&bslash;n&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|1
)paren
op_amp
id|cmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;off&quot;
suffix:colon
l_string|&quot;on&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: I/O Access %s&bslash;n&quot;
comma
(paren
(paren
(paren
l_int|0x1
op_lshift
l_int|0
)paren
op_amp
id|cmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;off&quot;
suffix:colon
l_string|&quot;on&quot;
)paren
suffix:semicolon
id|pci_read_config_word
c_func
(paren
id|dev
comma
id|PCI_STATUS
comma
op_amp
id|cmd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: Devsel %s&bslash;n&quot;
comma
(paren
(paren
id|PCI_STATUS_DEVSEL_MASK
op_amp
id|cmd
)paren
op_eq
l_int|0x000
)paren
ques
c_cond
l_string|&quot;Fast&quot;
suffix:colon
(paren
(paren
id|PCI_STATUS_DEVSEL_MASK
op_amp
id|cmd
)paren
op_eq
l_int|0x200
)paren
ques
c_cond
l_string|&quot;Medium&quot;
suffix:colon
(paren
(paren
id|PCI_STATUS_DEVSEL_MASK
op_amp
id|cmd
)paren
op_eq
l_int|0x400
)paren
ques
c_cond
l_string|&quot;Slow&quot;
suffix:colon
l_string|&quot;Invalid&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: %sFast Back-to-Back&bslash;n&quot;
comma
(paren
(paren
id|PCI_COMMAND_FAST_BACK
op_amp
id|cmd
)paren
op_eq
l_int|0
)paren
ques
c_cond
l_string|&quot;Not &quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|pci_read_config_byte
c_func
(paren
id|dev
comma
id|PMC551_SYS_CTRL_REG
comma
op_amp
id|bcmd
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;pmc551: EEPROM is under %s control&bslash;n&quot;
l_string|&quot;pmc551: System Control Register is %slocked to PCI access&bslash;n&quot;
l_string|&quot;pmc551: System Control Register is %slocked to EEPROM access&bslash;n&quot;
comma
(paren
id|bcmd
op_amp
l_int|0x1
)paren
ques
c_cond
l_string|&quot;software&quot;
suffix:colon
l_string|&quot;hardware&quot;
comma
(paren
id|bcmd
op_amp
l_int|0x20
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;un&quot;
comma
(paren
id|bcmd
op_amp
l_int|0x40
)paren
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;un&quot;
)paren
suffix:semicolon
macro_line|#endif
r_return
id|size
suffix:semicolon
)brace
multiline_comment|/*&n; * Kernel version specific module stuffages&n; */
macro_line|#if LINUX_VERSION_CODE &lt; 0x20211
macro_line|#ifdef MODULE
DECL|macro|init_pmc551
mdefine_line|#define init_pmc551 init_module
DECL|macro|cleanup_pmc551
mdefine_line|#define cleanup_pmc551 cleanup_module
macro_line|#endif
DECL|macro|__exit
mdefine_line|#define __exit
macro_line|#endif
macro_line|#if defined(MODULE)
id|MODULE_AUTHOR
c_func
(paren
l_string|&quot;Mark Ferrell &lt;mferrell@mvista.com&gt;&quot;
)paren
suffix:semicolon
DECL|variable|PMC551_VERSION
id|MODULE_DESCRIPTION
c_func
(paren
id|PMC551_VERSION
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|msize
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|msize
comma
l_string|&quot;memory size, 6=32M, 7=64M, 8=128M, ect.. [32M-1024M]&quot;
)paren
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|asize
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
id|MODULE_PARM_DESC
c_func
(paren
id|asize
comma
l_string|&quot;aperture size, must be &lt;= memsize [1M-1024M]&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * Stuff these outside the ifdef so as to not bust compiled in driver support&n; */
DECL|variable|msize
r_static
r_int
id|msize
op_assign
l_int|0
suffix:semicolon
macro_line|#if defined(CONFIG_MTD_PMC551_APERTURE_SIZE)
DECL|variable|asize
r_static
r_int
id|asize
op_assign
id|CONFIG_MTD_PMC551_APERTURE_SIZE
macro_line|#else
r_static
r_int
id|asize
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n; * PMC551 Card Initialization&n; */
r_int
id|__init
id|init_pmc551
c_func
(paren
r_void
)paren
(brace
r_struct
id|pci_dev
op_star
id|PCI_Device
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|mypriv
op_star
id|priv
suffix:semicolon
r_int
id|count
comma
id|found
op_assign
l_int|0
suffix:semicolon
r_struct
id|mtd_info
op_star
id|mtd
suffix:semicolon
id|u32
id|length
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|msize
)paren
(brace
r_if
c_cond
(paren
id|msize
template_param
l_int|11
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Invalid memory size&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|msize
op_assign
(paren
l_int|512
op_star
l_int|1024
)paren
op_lshift
id|msize
suffix:semicolon
)brace
r_if
c_cond
(paren
id|asize
)paren
(brace
r_if
c_cond
(paren
id|asize
template_param
l_int|11
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Invalid aperture size&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
id|asize
op_assign
(paren
l_int|512
op_star
l_int|1024
)paren
op_lshift
id|asize
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_INFO
id|PMC551_VERSION
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pci_present
c_func
(paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: PCI not enabled.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
multiline_comment|/*&n;         * PCU-bus chipset probe.&n;         */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
id|MAX_MTD_DEVICES
suffix:semicolon
id|count
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
id|PCI_Device
op_assign
id|pci_find_device
c_func
(paren
id|PCI_VENDOR_ID_V3_SEMI
comma
id|PCI_DEVICE_ID_V3_SEMI_V370PDC
comma
id|PCI_Device
)paren
)paren
op_eq
l_int|NULL
)paren
(brace
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Found PCI V370PDC IRQ:%d&bslash;n&quot;
comma
id|PCI_Device-&gt;irq
)paren
suffix:semicolon
multiline_comment|/*&n;                 * The PMC551 device acts VERY wierd if you don&squot;t init it&n;                 * first.  i.e. it will not correctly report devsel.  If for&n;                 * some reason the sdram is in a wrote-protected state the&n;                 * device will DEVSEL when it is written to causing problems&n;                 * with the oldproc.c driver in&n;                 * some kernels (2.2.*)&n;                 */
r_if
c_cond
(paren
(paren
id|length
op_assign
id|fixup_pmc551
c_func
(paren
id|PCI_Device
)paren
)paren
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Cannot init SDRAM&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|msize
)paren
(brace
id|length
op_assign
id|msize
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Using specified memory size 0x%x&bslash;n&quot;
comma
id|length
)paren
suffix:semicolon
)brace
id|mtd
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|mtd_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mtd
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Cannot allocate new MTD device.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
id|mtd
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|mtd_info
)paren
)paren
suffix:semicolon
id|priv
op_assign
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|mypriv
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|priv
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Cannot allocate new MTD device.&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
id|priv
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|priv
)paren
)paren
suffix:semicolon
id|mtd-&gt;priv
op_assign
id|priv
suffix:semicolon
id|priv-&gt;dev
op_assign
id|PCI_Device
suffix:semicolon
r_if
c_cond
(paren
id|asize
)paren
(brace
r_if
c_cond
(paren
id|asize
OG
id|length
)paren
(brace
id|asize
op_assign
id|length
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: reducing aperture size to fit memory [0x%x]&bslash;n&quot;
comma
id|asize
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Using specified aperture size 0x%x&bslash;n&quot;
comma
id|asize
)paren
suffix:semicolon
)brace
id|priv-&gt;aperture_size
op_assign
id|asize
suffix:semicolon
)brace
r_else
(brace
id|priv-&gt;aperture_size
op_assign
id|length
suffix:semicolon
)brace
id|priv-&gt;start
op_assign
id|ioremap
c_func
(paren
(paren
id|PCI_BASE_ADDRESS
c_func
(paren
id|PCI_Device
)paren
op_amp
id|PCI_BASE_ADDRESS_MEM_MASK
)paren
comma
id|priv-&gt;aperture_size
)paren
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Due to the dynamic nature of the code, we need to figure&n;&t;&t; * this out in order to stuff the register to set the proper&n;&t;&t; * aperture size.  If you know of an easier way to do this then&n;&t;&t; * PLEASE help yourself.&n;&t;&t; *&n;&t;&t; * Not with bloody floating point, you don&squot;t. Consider yourself&n;&t;&t; * duly LARTed. dwmw2.&n;&t;&t; */
(brace
id|u32
id|size
suffix:semicolon
id|u16
id|bits
suffix:semicolon
id|size
op_assign
id|priv-&gt;aperture_size
op_rshift
l_int|20
suffix:semicolon
r_for
c_loop
(paren
id|bits
op_assign
l_int|0
suffix:semicolon
op_logical_neg
(paren
id|size
op_amp
l_int|0x01
)paren
op_logical_and
id|size
OG
l_int|0
suffix:semicolon
id|bits
op_increment
comma
id|size
op_assign
id|size
op_rshift
l_int|1
)paren
(brace
suffix:semicolon
)brace
singleline_comment|//size=((u32)((log10(priv-&gt;aperture_size)/.30103)-19)&lt;&lt;4);
id|priv-&gt;mem_map0_base_val
op_assign
(paren
id|PMC551_PCI_MEM_MAP_REG_EN
op_or
id|PMC551_PCI_MEM_MAP_ENABLE
op_or
id|size
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_MTD_PMC551_DEBUG
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: aperture set to %d[%d]&bslash;n&quot;
comma
id|size
comma
id|size
op_rshift
l_int|4
)paren
suffix:semicolon
macro_line|#endif
)brace
id|priv-&gt;curr_mem_map0_val
op_assign
id|priv-&gt;mem_map0_base_val
suffix:semicolon
id|pci_write_config_dword
(paren
id|priv-&gt;dev
comma
id|PMC551_PCI_MEM_MAP0
comma
id|priv-&gt;curr_mem_map0_val
)paren
suffix:semicolon
id|mtd-&gt;size
op_assign
id|length
suffix:semicolon
id|mtd-&gt;flags
op_assign
(paren
id|MTD_CLEAR_BITS
op_or
id|MTD_SET_BITS
op_or
id|MTD_WRITEB_WRITEABLE
op_or
id|MTD_VOLATILE
)paren
suffix:semicolon
id|mtd-&gt;erase
op_assign
id|pmc551_erase
suffix:semicolon
id|mtd-&gt;point
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;unpoint
op_assign
id|pmc551_unpoint
suffix:semicolon
id|mtd-&gt;read
op_assign
id|pmc551_read
suffix:semicolon
id|mtd-&gt;write
op_assign
id|pmc551_write
suffix:semicolon
id|mtd-&gt;module
op_assign
id|THIS_MODULE
suffix:semicolon
id|mtd-&gt;type
op_assign
id|MTD_RAM
suffix:semicolon
id|mtd-&gt;name
op_assign
l_string|&quot;PMC551 RAM board&quot;
suffix:semicolon
id|mtd-&gt;erasesize
op_assign
l_int|0x10000
suffix:semicolon
r_if
c_cond
(paren
id|add_mtd_device
c_func
(paren
id|mtd
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: Failed to register new device&bslash;n&quot;
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd-&gt;priv
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Registered pmc551 memory device.&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Mapped %dM of memory from 0x%p to 0x%p&bslash;n&quot;
comma
id|priv-&gt;aperture_size
op_div
l_int|1024
op_div
l_int|1024
comma
id|priv-&gt;start
comma
id|priv-&gt;start
op_plus
id|priv-&gt;aperture_size
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Total memory is %d%c&bslash;n&quot;
comma
(paren
id|length
OL
l_int|1024
)paren
ques
c_cond
id|length
suffix:colon
(paren
id|length
OL
l_int|1048576
)paren
ques
c_cond
id|length
op_div
l_int|1024
suffix:colon
id|length
op_div
l_int|1024
op_div
l_int|1024
comma
(paren
id|length
OL
l_int|1024
)paren
ques
c_cond
l_char|&squot;B&squot;
suffix:colon
(paren
id|length
OL
l_int|1048576
)paren
ques
c_cond
l_char|&squot;K&squot;
suffix:colon
l_char|&squot;M&squot;
)paren
suffix:semicolon
id|priv-&gt;nextpmc551
op_assign
id|pmc551list
suffix:semicolon
id|pmc551list
op_assign
id|mtd
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|pmc551list
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: not detected,&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENODEV
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: %d pmc551 devices loaded&bslash;n&quot;
comma
id|found
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * PMC551 Card Cleanup&n; */
r_static
r_void
id|__exit
id|cleanup_pmc551
c_func
(paren
r_void
)paren
(brace
r_int
id|found
op_assign
l_int|0
suffix:semicolon
r_struct
id|mtd_info
op_star
id|mtd
suffix:semicolon
r_struct
id|mypriv
op_star
id|priv
suffix:semicolon
r_while
c_loop
(paren
(paren
id|mtd
op_assign
id|pmc551list
)paren
)paren
(brace
id|priv
op_assign
(paren
r_struct
id|mypriv
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
id|pmc551list
op_assign
id|priv-&gt;nextpmc551
suffix:semicolon
r_if
c_cond
(paren
id|priv-&gt;start
)paren
(brace
id|iounmap
c_func
(paren
(paren
(paren
r_struct
id|mypriv
op_star
)paren
id|mtd-&gt;priv
)paren
op_member_access_from_pointer
id|start
)paren
suffix:semicolon
)brace
id|kfree
(paren
id|mtd-&gt;priv
)paren
suffix:semicolon
id|del_mtd_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|found
op_increment
suffix:semicolon
)brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;pmc551: %d pmc551 devices unloaded&bslash;n&quot;
comma
id|found
)paren
suffix:semicolon
)brace
macro_line|#if LINUX_VERSION_CODE &gt;= 0x20211
id|module_init
c_func
(paren
id|init_pmc551
)paren
suffix:semicolon
DECL|variable|cleanup_pmc551
id|module_exit
c_func
(paren
id|cleanup_pmc551
)paren
suffix:semicolon
macro_line|#endif
eof
