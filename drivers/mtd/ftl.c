multiline_comment|/* This version ported to the Linux-MTD system by dwmw2@infradead.org&n; *&n; * - Based on Id: ftl.c,v 1.21 2000/08/01 13:07:49 dwmw2 Exp&n; * - With the Franz Galiana&squot;s set_bam_entry fix from v1.23&n; * - Perhaps it&squot;s about time I made a branch for the 2.4 series.&n;&n; * Originally based on:&n; */
multiline_comment|/*======================================================================&n;&n;    A Flash Translation Layer memory card driver&n;&n;    This driver implements a disk-like block device driver with an&n;    apparent block size of 512 bytes for flash memory cards.&n;&n;    ftl_cs.c 1.62 2000/02/01 00:59:04&n;&n;    The contents of this file are subject to the Mozilla Public&n;    License Version 1.1 (the &quot;License&quot;); you may not use this file&n;    except in compliance with the License. You may obtain a copy of&n;    the License at http://www.mozilla.org/MPL/&n;&n;    Software distributed under the License is distributed on an &quot;AS&n;    IS&quot; basis, WITHOUT WARRANTY OF ANY KIND, either express or&n;    implied. See the License for the specific language governing&n;    rights and limitations under the License.&n;&n;    The initial developer of the original code is David A. Hinds&n;    &lt;dhinds@pcmcia.sourceforge.org&gt;.  Portions created by David A. Hinds&n;    are Copyright (C) 1999 David A. Hinds.  All Rights Reserved.&n;&n;    Alternatively, the contents of this file may be used under the&n;    terms of the GNU Public License version 2 (the &quot;GPL&quot;), in which&n;    case the provisions of the GPL are applicable instead of the&n;    above.  If you wish to allow the use of your version of this file&n;    only under the terms of the GPL and not to allow others to use&n;    your version of this file under the MPL, indicate your decision&n;    by deleting the provisions above and replace them with the notice&n;    and other provisions required by the GPL.  If you do not delete&n;    the provisions above, a recipient may use your version of this&n;    file under either the MPL or the GPL.&n;&n;    LEGAL NOTE: The FTL format is patented by M-Systems.  They have&n;    granted a license for its use with PCMCIA devices:&n;&n;     &quot;M-Systems grants a royalty-free, non-exclusive license under&n;      any presently existing M-Systems intellectual property rights&n;      necessary for the design and development of FTL-compatible&n;      drivers, file systems and utilities using the data formats with&n;      PCMCIA PC Cards as described in the PCMCIA Flash Translation&n;      Layer (FTL) Specification.&quot;&n;&n;    Use of the FTL format for non-PCMCIA applications may be an&n;    infringement of these patents.  For additional information,&n;    contact M-Systems (http://www.m-sys.com) directly.&n;      &n;======================================================================*/
DECL|macro|FTL_DEBUG
mdefine_line|#define FTL_DEBUG 5
macro_line|#ifdef FTL_DEBUG
DECL|macro|DEBUGLVL
mdefine_line|#define DEBUGLVL debug
macro_line|#endif
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/mtd/compatmac.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
multiline_comment|/*#define PSYCHO_DEBUG */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/ptrace.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/ioctl.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;stdarg.h&gt;
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x20100)
macro_line|#include &lt;linux/vmalloc.h&gt;
macro_line|#endif
macro_line|#if (LINUX_VERSION_CODE &gt;= 0x20303)
macro_line|#include &lt;linux/blkpg.h&gt;
macro_line|#endif
macro_line|#include &lt;linux/mtd/ftl.h&gt;
multiline_comment|/*====================================================================*/
multiline_comment|/* Stuff which really ought to be in compatmac.h */
macro_line|#if (LINUX_VERSION_CODE &lt; 0x20328)
DECL|macro|register_disk
mdefine_line|#define register_disk(dev, drive, minors, ops, size) &bslash;&n;    do { (dev)-&gt;part[(drive)*(minors)].nr_sects = size; &bslash;&n;        if (size == 0) (dev)-&gt;part[(drive)*(minors)].start_sect = -1; &bslash;&n;        resetup_one_dev(dev, drive); } while (0);
macro_line|#endif
macro_line|#if (LINUX_VERSION_CODE &lt; 0x20320)
DECL|macro|BLK_DEFAULT_QUEUE
mdefine_line|#define BLK_DEFAULT_QUEUE(n)    blk_dev[n].request_fn
DECL|macro|blk_init_queue
mdefine_line|#define blk_init_queue(q, req)  q = (req)
DECL|macro|blk_cleanup_queue
mdefine_line|#define blk_cleanup_queue(q)    q = NULL
DECL|macro|request_arg_t
mdefine_line|#define request_arg_t           void
macro_line|#else
DECL|macro|request_arg_t
mdefine_line|#define request_arg_t           request_queue_t *q
macro_line|#endif
multiline_comment|/*====================================================================*/
multiline_comment|/* Parameters that can be set with &squot;insmod&squot; */
multiline_comment|/* Major device # for FTL device */
DECL|variable|shuffle_freq
r_static
r_int
id|shuffle_freq
op_assign
l_int|50
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|shuffle_freq
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
multiline_comment|/*====================================================================*/
macro_line|#ifndef FTL_MAJOR
DECL|macro|FTL_MAJOR
mdefine_line|#define FTL_MAJOR&t;44
macro_line|#endif
multiline_comment|/* Funky stuff for setting up a block device */
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR&t;&t;FTL_MAJOR
DECL|macro|DEVICE_NAME
mdefine_line|#define DEVICE_NAME&t;&t;&quot;ftl&quot;
DECL|macro|DEVICE_REQUEST
mdefine_line|#define DEVICE_REQUEST&t;&t;do_ftl_request
DECL|macro|DEVICE_ON
mdefine_line|#define DEVICE_ON(device)
DECL|macro|DEVICE_OFF
mdefine_line|#define DEVICE_OFF(device)
DECL|macro|DEVICE_NR
mdefine_line|#define DEVICE_NR(minor)&t;((minor)&gt;&gt;5)
DECL|macro|REGION_NR
mdefine_line|#define REGION_NR(minor)&t;(((minor)&gt;&gt;3)&amp;3)
DECL|macro|PART_NR
mdefine_line|#define PART_NR(minor)&t;&t;((minor)&amp;7)
DECL|macro|MINOR_NR
mdefine_line|#define MINOR_NR(dev,reg,part)&t;(((dev)&lt;&lt;5)+((reg)&lt;&lt;3)+(part))
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#ifdef FTL_DEBUG
DECL|variable|debug
r_static
r_int
id|debug
op_assign
id|FTL_DEBUG
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|debug
comma
l_string|&quot;i&quot;
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/*====================================================================*/
macro_line|#ifndef FTL_MAJOR
DECL|macro|FTL_MAJOR
mdefine_line|#define FTL_MAJOR&t;44
macro_line|#endif
multiline_comment|/* Maximum number of separate memory devices we&squot;ll allow */
DECL|macro|MAX_DEV
mdefine_line|#define MAX_DEV&t;&t;4
multiline_comment|/* Maximum number of regions per device */
DECL|macro|MAX_REGION
mdefine_line|#define MAX_REGION&t;4
multiline_comment|/* Maximum number of partitions in an FTL region */
DECL|macro|PART_BITS
mdefine_line|#define PART_BITS&t;3
DECL|macro|MAX_PART
mdefine_line|#define MAX_PART&t;8
multiline_comment|/* Maximum number of outstanding erase requests per socket */
DECL|macro|MAX_ERASE
mdefine_line|#define MAX_ERASE&t;8
multiline_comment|/* Sector size -- shouldn&squot;t need to change */
DECL|macro|SECTOR_SIZE
mdefine_line|#define SECTOR_SIZE&t;512
multiline_comment|/* Each memory region corresponds to a minor device */
DECL|struct|partition_t
r_typedef
r_struct
id|partition_t
(brace
DECL|member|mtd
r_struct
id|mtd_info
op_star
id|mtd
suffix:semicolon
DECL|member|state
id|u_int32_t
id|state
suffix:semicolon
DECL|member|VirtualBlockMap
id|u_int32_t
op_star
id|VirtualBlockMap
suffix:semicolon
DECL|member|VirtualPageMap
id|u_int32_t
op_star
id|VirtualPageMap
suffix:semicolon
DECL|member|FreeTotal
id|u_int32_t
id|FreeTotal
suffix:semicolon
DECL|struct|eun_info_t
r_struct
id|eun_info_t
(brace
DECL|member|Offset
id|u_int32_t
id|Offset
suffix:semicolon
DECL|member|EraseCount
id|u_int32_t
id|EraseCount
suffix:semicolon
DECL|member|Free
id|u_int32_t
id|Free
suffix:semicolon
DECL|member|Deleted
id|u_int32_t
id|Deleted
suffix:semicolon
DECL|member|EUNInfo
)brace
op_star
id|EUNInfo
suffix:semicolon
DECL|struct|xfer_info_t
r_struct
id|xfer_info_t
(brace
DECL|member|Offset
id|u_int32_t
id|Offset
suffix:semicolon
DECL|member|EraseCount
id|u_int32_t
id|EraseCount
suffix:semicolon
DECL|member|state
id|u_int16_t
id|state
suffix:semicolon
DECL|member|XferInfo
)brace
op_star
id|XferInfo
suffix:semicolon
DECL|member|bam_index
id|u_int16_t
id|bam_index
suffix:semicolon
DECL|member|bam_cache
id|u_int32_t
op_star
id|bam_cache
suffix:semicolon
DECL|member|DataUnits
id|u_int16_t
id|DataUnits
suffix:semicolon
DECL|member|BlocksPerUnit
id|u_int32_t
id|BlocksPerUnit
suffix:semicolon
DECL|member|header
id|erase_unit_header_t
id|header
suffix:semicolon
macro_line|#if 0
id|region_info_t
id|region
suffix:semicolon
id|memory_handle_t
id|handle
suffix:semicolon
macro_line|#endif
DECL|member|open
id|atomic_t
id|open
suffix:semicolon
DECL|typedef|partition_t
)brace
id|partition_t
suffix:semicolon
DECL|variable|myparts
id|partition_t
op_star
id|myparts
(braket
id|MAX_MTD_DEVICES
)braket
suffix:semicolon
r_static
r_void
id|ftl_notify_add
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
suffix:semicolon
r_static
r_void
id|ftl_notify_remove
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
suffix:semicolon
r_void
id|ftl_freepart
c_func
(paren
id|partition_t
op_star
id|part
)paren
suffix:semicolon
DECL|variable|ftl_notifier
r_static
r_struct
id|mtd_notifier
id|ftl_notifier
op_assign
initialization_block
suffix:semicolon
multiline_comment|/* Partition state flags */
DECL|macro|FTL_FORMATTED
mdefine_line|#define FTL_FORMATTED&t;0x01
multiline_comment|/* Transfer unit states */
DECL|macro|XFER_UNKNOWN
mdefine_line|#define XFER_UNKNOWN&t;0x00
DECL|macro|XFER_ERASING
mdefine_line|#define XFER_ERASING&t;0x01
DECL|macro|XFER_ERASED
mdefine_line|#define XFER_ERASED&t;0x02
DECL|macro|XFER_PREPARED
mdefine_line|#define XFER_PREPARED&t;0x03
DECL|macro|XFER_FAILED
mdefine_line|#define XFER_FAILED&t;0x04
DECL|variable|ftl_hd
r_static
r_struct
id|hd_struct
id|ftl_hd
(braket
id|MINOR_NR
c_func
(paren
id|MAX_DEV
comma
l_int|0
comma
l_int|0
)paren
)braket
suffix:semicolon
DECL|variable|ftl_sizes
r_static
r_int
id|ftl_sizes
(braket
id|MINOR_NR
c_func
(paren
id|MAX_DEV
comma
l_int|0
comma
l_int|0
)paren
)braket
suffix:semicolon
DECL|variable|ftl_blocksizes
r_static
r_int
id|ftl_blocksizes
(braket
id|MINOR_NR
c_func
(paren
id|MAX_DEV
comma
l_int|0
comma
l_int|0
)paren
)braket
suffix:semicolon
DECL|variable|ftl_gendisk
r_static
r_struct
id|gendisk
id|ftl_gendisk
op_assign
(brace
id|major
suffix:colon
id|FTL_MAJOR
comma
id|major_name
suffix:colon
l_string|&quot;ftl&quot;
comma
id|minor_shift
suffix:colon
id|PART_BITS
comma
id|max_p
suffix:colon
id|MAX_PART
comma
macro_line|#if (LINUX_VERSION_CODE &lt; 0x20328)
id|max_nr
suffix:colon
id|MAX_DEV
op_star
id|MAX_PART
comma
macro_line|#endif
id|part
suffix:colon
id|ftl_hd
comma
id|sizes
suffix:colon
id|ftl_sizes
comma
id|nr_real
suffix:colon
l_int|0
)brace
suffix:semicolon
multiline_comment|/*====================================================================*/
r_static
r_int
id|ftl_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|u_int
id|cmd
comma
id|u_long
id|arg
)paren
suffix:semicolon
r_static
r_int
id|ftl_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
id|release_t
id|ftl_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|ftl_reread_partitions
c_func
(paren
r_int
id|minor
)paren
suffix:semicolon
r_static
r_void
id|ftl_erase_callback
c_func
(paren
r_struct
id|erase_info
op_star
id|done
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &lt; 0x20326
DECL|variable|ftl_blk_fops
r_static
r_struct
id|file_operations
id|ftl_blk_fops
op_assign
(brace
id|open
suffix:colon
id|ftl_open
comma
id|release
suffix:colon
id|ftl_close
comma
id|ioctl
suffix:colon
id|ftl_ioctl
comma
id|read
suffix:colon
id|block_read
comma
id|write
suffix:colon
id|block_write
comma
id|fsync
suffix:colon
id|block_fsync
)brace
suffix:semicolon
macro_line|#else
DECL|variable|ftl_blk_fops
r_static
r_struct
id|block_device_operations
id|ftl_blk_fops
op_assign
(brace
id|open
suffix:colon
id|ftl_open
comma
id|release
suffix:colon
id|ftl_close
comma
id|ioctl
suffix:colon
id|ftl_ioctl
comma
)brace
suffix:semicolon
macro_line|#endif
multiline_comment|/*======================================================================&n;&n;    Scan_header() checks to see if a memory region contains an FTL&n;    partition.  build_maps() reads all the erase unit headers, builds&n;    the erase unit map, and then builds the virtual page map.&n;    &n;======================================================================*/
DECL|function|scan_header
r_static
r_int
id|scan_header
c_func
(paren
id|partition_t
op_star
id|part
)paren
(brace
id|erase_unit_header_t
id|header
suffix:semicolon
id|loff_t
id|offset
comma
id|max_offset
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|part-&gt;header.FormattedSize
op_assign
l_int|0
suffix:semicolon
id|max_offset
op_assign
(paren
l_int|0x100000
OL
id|part-&gt;mtd-&gt;size
)paren
ques
c_cond
l_int|0x100000
suffix:colon
id|part-&gt;mtd-&gt;size
suffix:semicolon
multiline_comment|/* Search first megabyte for a valid FTL header */
r_for
c_loop
(paren
id|offset
op_assign
l_int|0
suffix:semicolon
id|offset
OL
id|max_offset
suffix:semicolon
id|offset
op_add_assign
id|part-&gt;mtd-&gt;erasesize
ques
c_cond
id|part-&gt;mtd-&gt;erasesize
suffix:colon
l_int|0x2000
)paren
(brace
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|part-&gt;mtd
comma
id|offset
comma
r_sizeof
(paren
id|header
)paren
comma
op_amp
id|ret
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|header
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|header.DataOrgTuple
op_plus
l_int|3
comma
l_string|&quot;FTL100&quot;
)paren
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|offset
op_eq
id|max_offset
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: FTL header not found.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOENT
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|le16_to_cpu
c_func
(paren
id|header.NumEraseUnits
)paren
OG
l_int|65536
)paren
op_logical_or
id|header.BlockSize
op_ne
l_int|9
op_logical_or
(paren
id|header.EraseUnitSize
OL
l_int|10
)paren
op_logical_or
(paren
id|header.EraseUnitSize
OG
l_int|31
)paren
op_logical_or
(paren
id|header.NumTransferUnits
op_ge
id|le16_to_cpu
c_func
(paren
id|header.NumEraseUnits
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: FTL header corrupt!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
l_int|1
op_lshift
id|header.EraseUnitSize
)paren
op_ne
id|part-&gt;mtd-&gt;erasesize
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl: FTL EraseUnitSize %x != MTD erasesize %lx&bslash;n&quot;
comma
l_int|1
op_lshift
id|header.EraseUnitSize
comma
id|part-&gt;mtd-&gt;erasesize
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|part-&gt;header
op_assign
id|header
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|build_maps
r_static
r_int
id|build_maps
c_func
(paren
id|partition_t
op_star
id|part
)paren
(brace
id|erase_unit_header_t
id|header
suffix:semicolon
id|u_int16_t
id|xvalid
comma
id|xtrans
comma
id|i
suffix:semicolon
id|u_int
id|blocks
comma
id|j
suffix:semicolon
r_int
id|hdr_ok
comma
id|ret
suffix:semicolon
id|ssize_t
id|retval
suffix:semicolon
id|loff_t
id|offset
suffix:semicolon
multiline_comment|/* Set up erase unit maps */
id|part-&gt;DataUnits
op_assign
id|le16_to_cpu
c_func
(paren
id|part-&gt;header.NumEraseUnits
)paren
op_minus
id|part-&gt;header.NumTransferUnits
suffix:semicolon
id|part-&gt;EUNInfo
op_assign
id|kmalloc
c_func
(paren
id|part-&gt;DataUnits
op_star
r_sizeof
(paren
r_struct
id|eun_info_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|part-&gt;EUNInfo
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|part-&gt;DataUnits
suffix:semicolon
id|i
op_increment
)paren
id|part-&gt;EUNInfo
(braket
id|i
)braket
dot
id|Offset
op_assign
l_int|0xffffffff
suffix:semicolon
id|part-&gt;XferInfo
op_assign
id|kmalloc
c_func
(paren
id|part-&gt;header.NumTransferUnits
op_star
r_sizeof
(paren
r_struct
id|xfer_info_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|part-&gt;XferInfo
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|xvalid
op_assign
id|xtrans
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|le16_to_cpu
c_func
(paren
id|part-&gt;header.NumEraseUnits
)paren
suffix:semicolon
id|i
op_increment
)paren
(brace
id|offset
op_assign
(paren
(paren
id|i
op_plus
id|le16_to_cpu
c_func
(paren
id|part-&gt;header.FirstPhysicalEUN
)paren
)paren
op_lshift
id|part-&gt;header.EraseUnitSize
)paren
suffix:semicolon
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|part-&gt;mtd
comma
id|offset
comma
r_sizeof
(paren
id|header
)paren
comma
op_amp
id|retval
comma
(paren
r_int
r_char
op_star
)paren
op_amp
id|header
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* Is this a transfer partition? */
id|hdr_ok
op_assign
(paren
id|strcmp
c_func
(paren
id|header.DataOrgTuple
op_plus
l_int|3
comma
l_string|&quot;FTL100&quot;
)paren
op_eq
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hdr_ok
op_logical_and
(paren
id|le16_to_cpu
c_func
(paren
id|header.LogicalEUN
)paren
OL
id|part-&gt;DataUnits
)paren
op_logical_and
(paren
id|part-&gt;EUNInfo
(braket
id|le16_to_cpu
c_func
(paren
id|header.LogicalEUN
)paren
)braket
dot
id|Offset
op_eq
l_int|0xffffffff
)paren
)paren
(brace
id|part-&gt;EUNInfo
(braket
id|le16_to_cpu
c_func
(paren
id|header.LogicalEUN
)paren
)braket
dot
id|Offset
op_assign
id|offset
suffix:semicolon
id|part-&gt;EUNInfo
(braket
id|le16_to_cpu
c_func
(paren
id|header.LogicalEUN
)paren
)braket
dot
id|EraseCount
op_assign
id|le32_to_cpu
c_func
(paren
id|header.EraseCount
)paren
suffix:semicolon
id|xvalid
op_increment
suffix:semicolon
)brace
r_else
(brace
r_if
c_cond
(paren
id|xtrans
op_eq
id|part-&gt;header.NumTransferUnits
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: format error: too many &quot;
l_string|&quot;transfer units!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|hdr_ok
op_logical_and
(paren
id|le16_to_cpu
c_func
(paren
id|header.LogicalEUN
)paren
op_eq
l_int|0xffff
)paren
)paren
(brace
id|part-&gt;XferInfo
(braket
id|xtrans
)braket
dot
id|state
op_assign
id|XFER_PREPARED
suffix:semicolon
id|part-&gt;XferInfo
(braket
id|xtrans
)braket
dot
id|EraseCount
op_assign
id|le32_to_cpu
c_func
(paren
id|header.EraseCount
)paren
suffix:semicolon
)brace
r_else
(brace
id|part-&gt;XferInfo
(braket
id|xtrans
)braket
dot
id|state
op_assign
id|XFER_UNKNOWN
suffix:semicolon
multiline_comment|/* Pick anything reasonable for the erase count */
id|part-&gt;XferInfo
(braket
id|xtrans
)braket
dot
id|EraseCount
op_assign
id|le32_to_cpu
c_func
(paren
id|part-&gt;header.EraseCount
)paren
suffix:semicolon
)brace
id|part-&gt;XferInfo
(braket
id|xtrans
)braket
dot
id|Offset
op_assign
id|offset
suffix:semicolon
id|xtrans
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Check for format trouble */
id|header
op_assign
id|part-&gt;header
suffix:semicolon
r_if
c_cond
(paren
(paren
id|xtrans
op_ne
id|header.NumTransferUnits
)paren
op_logical_or
(paren
id|xvalid
op_plus
id|xtrans
op_ne
id|le16_to_cpu
c_func
(paren
id|header.NumEraseUnits
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: format error: erase units &quot;
l_string|&quot;don&squot;t add up!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Set up virtual page map */
id|blocks
op_assign
id|le32_to_cpu
c_func
(paren
id|header.FormattedSize
)paren
op_rshift
id|header.BlockSize
suffix:semicolon
id|part-&gt;VirtualBlockMap
op_assign
id|vmalloc
c_func
(paren
id|blocks
op_star
r_sizeof
(paren
id|u_int32_t
)paren
)paren
suffix:semicolon
id|memset
c_func
(paren
id|part-&gt;VirtualBlockMap
comma
l_int|0xff
comma
id|blocks
op_star
r_sizeof
(paren
id|u_int32_t
)paren
)paren
suffix:semicolon
id|part-&gt;BlocksPerUnit
op_assign
(paren
l_int|1
op_lshift
id|header.EraseUnitSize
)paren
op_rshift
id|header.BlockSize
suffix:semicolon
id|part-&gt;bam_cache
op_assign
id|kmalloc
c_func
(paren
id|part-&gt;BlocksPerUnit
op_star
r_sizeof
(paren
id|u_int32_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|part-&gt;bam_cache
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|part-&gt;bam_index
op_assign
l_int|0xffff
suffix:semicolon
id|part-&gt;FreeTotal
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|part-&gt;DataUnits
suffix:semicolon
id|i
op_increment
)paren
(brace
id|part-&gt;EUNInfo
(braket
id|i
)braket
dot
id|Free
op_assign
l_int|0
suffix:semicolon
id|part-&gt;EUNInfo
(braket
id|i
)braket
dot
id|Deleted
op_assign
l_int|0
suffix:semicolon
id|offset
op_assign
id|part-&gt;EUNInfo
(braket
id|i
)braket
dot
id|Offset
op_plus
id|le32_to_cpu
c_func
(paren
id|header.BAMOffset
)paren
suffix:semicolon
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|part-&gt;mtd
comma
id|offset
comma
id|part-&gt;BlocksPerUnit
op_star
r_sizeof
(paren
id|u_int32_t
)paren
comma
op_amp
id|retval
comma
(paren
r_int
r_char
op_star
)paren
id|part-&gt;bam_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
id|part-&gt;BlocksPerUnit
suffix:semicolon
id|j
op_increment
)paren
(brace
r_if
c_cond
(paren
id|BLOCK_FREE
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|part-&gt;bam_cache
(braket
id|j
)braket
)paren
)paren
)paren
(brace
id|part-&gt;EUNInfo
(braket
id|i
)braket
dot
id|Free
op_increment
suffix:semicolon
id|part-&gt;FreeTotal
op_increment
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|BLOCK_TYPE
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|part-&gt;bam_cache
(braket
id|j
)braket
)paren
)paren
op_eq
id|BLOCK_DATA
)paren
op_logical_and
(paren
id|BLOCK_NUMBER
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|part-&gt;bam_cache
(braket
id|j
)braket
)paren
)paren
OL
id|blocks
)paren
)paren
id|part-&gt;VirtualBlockMap
(braket
id|BLOCK_NUMBER
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|part-&gt;bam_cache
(braket
id|j
)braket
)paren
)paren
)braket
op_assign
(paren
id|i
op_lshift
id|header.EraseUnitSize
)paren
op_plus
(paren
id|j
op_lshift
id|header.BlockSize
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|BLOCK_DELETED
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|part-&gt;bam_cache
(braket
id|j
)braket
)paren
)paren
)paren
id|part-&gt;EUNInfo
(braket
id|i
)braket
dot
id|Deleted
op_increment
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* build_maps */
multiline_comment|/*======================================================================&n;&n;    Erase_xfer() schedules an asynchronous erase operation for a&n;    transfer unit.&n;    &n;======================================================================*/
DECL|function|erase_xfer
r_static
r_int
id|erase_xfer
c_func
(paren
id|partition_t
op_star
id|part
comma
id|u_int16_t
id|xfernum
)paren
(brace
r_int
id|ret
suffix:semicolon
r_struct
id|xfer_info_t
op_star
id|xfer
suffix:semicolon
r_struct
id|erase_info
op_star
id|erase
suffix:semicolon
id|xfer
op_assign
op_amp
id|part-&gt;XferInfo
(braket
id|xfernum
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;ftl_cs: erasing xfer unit at 0x%x&bslash;n&quot;
comma
id|xfer-&gt;Offset
)paren
suffix:semicolon
id|xfer-&gt;state
op_assign
id|XFER_ERASING
suffix:semicolon
multiline_comment|/* Is there a free erase slot? Always in MTD. */
id|erase
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|erase_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|erase
)paren
r_return
op_minus
id|ENOMEM
suffix:semicolon
id|erase-&gt;callback
op_assign
id|ftl_erase_callback
suffix:semicolon
id|erase-&gt;addr
op_assign
id|xfer-&gt;Offset
suffix:semicolon
id|erase-&gt;len
op_assign
l_int|1
op_lshift
id|part-&gt;header.EraseUnitSize
suffix:semicolon
id|erase-&gt;priv
op_assign
(paren
id|u_long
)paren
id|part
suffix:semicolon
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|erase
c_func
(paren
id|part-&gt;mtd
comma
id|erase
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|xfer-&gt;EraseCount
op_increment
suffix:semicolon
r_else
id|kfree
c_func
(paren
id|erase
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* erase_xfer */
multiline_comment|/*======================================================================&n;&n;    Prepare_xfer() takes a freshly erased transfer unit and gives&n;    it an appropriate header.&n;    &n;======================================================================*/
DECL|function|ftl_erase_callback
r_static
r_void
id|ftl_erase_callback
c_func
(paren
r_struct
id|erase_info
op_star
id|erase
)paren
(brace
id|partition_t
op_star
id|part
suffix:semicolon
r_struct
id|xfer_info_t
op_star
id|xfer
suffix:semicolon
r_int
id|i
suffix:semicolon
multiline_comment|/* Look up the transfer unit */
id|part
op_assign
(paren
id|partition_t
op_star
)paren
(paren
id|erase-&gt;priv
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|part-&gt;header.NumTransferUnits
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|part-&gt;XferInfo
(braket
id|i
)braket
dot
id|Offset
op_eq
id|erase-&gt;addr
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
id|part-&gt;header.NumTransferUnits
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: internal error: &quot;
l_string|&quot;erase lookup failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|xfer
op_assign
op_amp
id|part-&gt;XferInfo
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|erase-&gt;state
op_eq
id|MTD_ERASE_DONE
)paren
id|xfer-&gt;state
op_assign
id|XFER_ERASED
suffix:semicolon
r_else
(brace
id|xfer-&gt;state
op_assign
id|XFER_FAILED
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: erase failed: state = %d&bslash;n&quot;
comma
id|erase-&gt;state
)paren
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|erase
)paren
suffix:semicolon
)brace
multiline_comment|/* ftl_erase_callback */
DECL|function|prepare_xfer
r_static
r_int
id|prepare_xfer
c_func
(paren
id|partition_t
op_star
id|part
comma
r_int
id|i
)paren
(brace
id|erase_unit_header_t
id|header
suffix:semicolon
r_struct
id|xfer_info_t
op_star
id|xfer
suffix:semicolon
r_int
id|nbam
comma
id|ret
suffix:semicolon
id|u_int32_t
id|ctl
suffix:semicolon
id|ssize_t
id|retlen
suffix:semicolon
id|loff_t
id|offset
suffix:semicolon
id|xfer
op_assign
op_amp
id|part-&gt;XferInfo
(braket
id|i
)braket
suffix:semicolon
id|xfer-&gt;state
op_assign
id|XFER_FAILED
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;ftl_cs: preparing xfer unit at 0x%x&bslash;n&quot;
comma
id|xfer-&gt;Offset
)paren
suffix:semicolon
multiline_comment|/* Write the transfer unit header */
id|header
op_assign
id|part-&gt;header
suffix:semicolon
id|header.LogicalEUN
op_assign
id|cpu_to_le16
c_func
(paren
l_int|0xffff
)paren
suffix:semicolon
id|header.EraseCount
op_assign
id|cpu_to_le32
c_func
(paren
id|xfer-&gt;EraseCount
)paren
suffix:semicolon
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|write
c_func
(paren
id|part-&gt;mtd
comma
id|xfer-&gt;Offset
comma
r_sizeof
(paren
id|header
)paren
comma
op_amp
id|retlen
comma
(paren
id|u_char
op_star
)paren
op_amp
id|header
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Write the BAM stub */
id|nbam
op_assign
(paren
id|part-&gt;BlocksPerUnit
op_star
r_sizeof
(paren
id|u_int32_t
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|part-&gt;header.BAMOffset
)paren
op_plus
id|SECTOR_SIZE
op_minus
l_int|1
)paren
op_div
id|SECTOR_SIZE
suffix:semicolon
id|offset
op_assign
id|xfer-&gt;Offset
op_plus
id|le32_to_cpu
c_func
(paren
id|part-&gt;header.BAMOffset
)paren
suffix:semicolon
id|ctl
op_assign
id|cpu_to_le32
c_func
(paren
id|BLOCK_CONTROL
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nbam
suffix:semicolon
id|i
op_increment
comma
id|offset
op_add_assign
r_sizeof
(paren
id|u_int32_t
)paren
)paren
(brace
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|write
c_func
(paren
id|part-&gt;mtd
comma
id|offset
comma
r_sizeof
(paren
id|u_int32_t
)paren
comma
op_amp
id|retlen
comma
(paren
id|u_char
op_star
)paren
op_amp
id|ctl
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
)brace
id|xfer-&gt;state
op_assign
id|XFER_PREPARED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* prepare_xfer */
multiline_comment|/*======================================================================&n;&n;    Copy_erase_unit() takes a full erase block and a transfer unit,&n;    copies everything to the transfer unit, then swaps the block&n;    pointers.&n;&n;    All data blocks are copied to the corresponding blocks in the&n;    target unit, so the virtual block map does not need to be&n;    updated.&n;    &n;======================================================================*/
DECL|function|copy_erase_unit
r_static
r_int
id|copy_erase_unit
c_func
(paren
id|partition_t
op_star
id|part
comma
id|u_int16_t
id|srcunit
comma
id|u_int16_t
id|xferunit
)paren
(brace
id|u_char
id|buf
(braket
id|SECTOR_SIZE
)braket
suffix:semicolon
r_struct
id|eun_info_t
op_star
id|eun
suffix:semicolon
r_struct
id|xfer_info_t
op_star
id|xfer
suffix:semicolon
id|u_int32_t
id|src
comma
id|dest
comma
id|free
comma
id|i
suffix:semicolon
id|u_int16_t
id|unit
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ssize_t
id|retlen
suffix:semicolon
id|loff_t
id|offset
suffix:semicolon
id|u_int16_t
id|srcunitswap
op_assign
id|cpu_to_le16
c_func
(paren
id|srcunit
)paren
suffix:semicolon
id|eun
op_assign
op_amp
id|part-&gt;EUNInfo
(braket
id|srcunit
)braket
suffix:semicolon
id|xfer
op_assign
op_amp
id|part-&gt;XferInfo
(braket
id|xferunit
)braket
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;ftl_cs: copying block 0x%x to 0x%x&bslash;n&quot;
comma
id|eun-&gt;Offset
comma
id|xfer-&gt;Offset
)paren
suffix:semicolon
multiline_comment|/* Read current BAM */
r_if
c_cond
(paren
id|part-&gt;bam_index
op_ne
id|srcunit
)paren
(brace
id|offset
op_assign
id|eun-&gt;Offset
op_plus
id|le32_to_cpu
c_func
(paren
id|part-&gt;header.BAMOffset
)paren
suffix:semicolon
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|part-&gt;mtd
comma
id|offset
comma
id|part-&gt;BlocksPerUnit
op_star
r_sizeof
(paren
id|u_int32_t
)paren
comma
op_amp
id|retlen
comma
(paren
id|u_char
op_star
)paren
(paren
id|part-&gt;bam_cache
)paren
)paren
suffix:semicolon
multiline_comment|/* mark the cache bad, in case we get an error later */
id|part-&gt;bam_index
op_assign
l_int|0xffff
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ftl: Failed to read BAM cache in copy_erase_unit()!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
multiline_comment|/* Write the LogicalEUN for the transfer unit */
id|xfer-&gt;state
op_assign
id|XFER_UNKNOWN
suffix:semicolon
id|offset
op_assign
id|xfer-&gt;Offset
op_plus
l_int|20
suffix:semicolon
multiline_comment|/* Bad! */
id|unit
op_assign
id|cpu_to_le16
c_func
(paren
l_int|0x7fff
)paren
suffix:semicolon
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|write
c_func
(paren
id|part-&gt;mtd
comma
id|offset
comma
r_sizeof
(paren
id|u_int16_t
)paren
comma
op_amp
id|retlen
comma
(paren
id|u_char
op_star
)paren
op_amp
id|unit
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ftl: Failed to write back to BAM cache in copy_erase_unit()!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Copy all data blocks from source unit to transfer unit */
id|src
op_assign
id|eun-&gt;Offset
suffix:semicolon
id|dest
op_assign
id|xfer-&gt;Offset
suffix:semicolon
id|free
op_assign
l_int|0
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|part-&gt;BlocksPerUnit
suffix:semicolon
id|i
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|BLOCK_TYPE
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|part-&gt;bam_cache
(braket
id|i
)braket
)paren
)paren
)paren
(brace
r_case
id|BLOCK_CONTROL
suffix:colon
multiline_comment|/* This gets updated later */
r_break
suffix:semicolon
r_case
id|BLOCK_DATA
suffix:colon
r_case
id|BLOCK_REPLACEMENT
suffix:colon
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|part-&gt;mtd
comma
id|src
comma
id|SECTOR_SIZE
comma
op_amp
id|retlen
comma
(paren
id|u_char
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ftl: Error reading old xfer unit in copy_erase_unit&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|write
c_func
(paren
id|part-&gt;mtd
comma
id|dest
comma
id|SECTOR_SIZE
comma
op_amp
id|retlen
comma
(paren
id|u_char
op_star
)paren
id|buf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ftl: Error writing new xfer unit in copy_erase_unit&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
multiline_comment|/* All other blocks must be free */
id|part-&gt;bam_cache
(braket
id|i
)braket
op_assign
id|cpu_to_le32
c_func
(paren
l_int|0xffffffff
)paren
suffix:semicolon
id|free
op_increment
suffix:semicolon
r_break
suffix:semicolon
)brace
id|src
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
id|dest
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
)brace
multiline_comment|/* Write the BAM to the transfer unit */
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|write
c_func
(paren
id|part-&gt;mtd
comma
id|xfer-&gt;Offset
op_plus
id|le32_to_cpu
c_func
(paren
id|part-&gt;header.BAMOffset
)paren
comma
id|part-&gt;BlocksPerUnit
op_star
r_sizeof
(paren
r_int32
)paren
comma
op_amp
id|retlen
comma
(paren
id|u_char
op_star
)paren
id|part-&gt;bam_cache
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ftl: Error writing BAM in copy_erase_unit&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* All clear? Then update the LogicalEUN again */
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|write
c_func
(paren
id|part-&gt;mtd
comma
id|xfer-&gt;Offset
op_plus
l_int|20
comma
r_sizeof
(paren
id|u_int16_t
)paren
comma
op_amp
id|retlen
comma
(paren
id|u_char
op_star
)paren
op_amp
id|srcunitswap
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ftl: Error writing new LogicalEUN in copy_erase_unit&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* Update the maps and usage stats*/
id|i
op_assign
id|xfer-&gt;EraseCount
suffix:semicolon
id|xfer-&gt;EraseCount
op_assign
id|eun-&gt;EraseCount
suffix:semicolon
id|eun-&gt;EraseCount
op_assign
id|i
suffix:semicolon
id|i
op_assign
id|xfer-&gt;Offset
suffix:semicolon
id|xfer-&gt;Offset
op_assign
id|eun-&gt;Offset
suffix:semicolon
id|eun-&gt;Offset
op_assign
id|i
suffix:semicolon
id|part-&gt;FreeTotal
op_sub_assign
id|eun-&gt;Free
suffix:semicolon
id|part-&gt;FreeTotal
op_add_assign
id|free
suffix:semicolon
id|eun-&gt;Free
op_assign
id|free
suffix:semicolon
id|eun-&gt;Deleted
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Now, the cache should be valid for the new block */
id|part-&gt;bam_index
op_assign
id|srcunit
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* copy_erase_unit */
multiline_comment|/*======================================================================&n;&n;    reclaim_block() picks a full erase unit and a transfer unit and&n;    then calls copy_erase_unit() to copy one to the other.  Then, it&n;    schedules an erase on the expired block.&n;&n;    What&squot;s a good way to decide which transfer unit and which erase&n;    unit to use?  Beats me.  My way is to always pick the transfer&n;    unit with the fewest erases, and usually pick the data unit with&n;    the most deleted blocks.  But with a small probability, pick the&n;    oldest data unit instead.  This means that we generally postpone&n;    the next reclaimation as long as possible, but shuffle static&n;    stuff around a bit for wear leveling.&n;    &n;======================================================================*/
DECL|function|reclaim_block
r_static
r_int
id|reclaim_block
c_func
(paren
id|partition_t
op_star
id|part
)paren
(brace
id|u_int16_t
id|i
comma
id|eun
comma
id|xfer
suffix:semicolon
id|u_int32_t
id|best
suffix:semicolon
r_int
id|queued
comma
id|ret
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;ftl_cs: reclaiming space...&bslash;n&quot;
)paren
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;NumTransferUnits == %x&bslash;n&quot;
comma
id|part-&gt;header.NumTransferUnits
)paren
suffix:semicolon
multiline_comment|/* Pick the least erased transfer unit */
id|best
op_assign
l_int|0xffffffff
suffix:semicolon
id|xfer
op_assign
l_int|0xffff
suffix:semicolon
r_do
(brace
id|queued
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|part-&gt;header.NumTransferUnits
suffix:semicolon
id|i
op_increment
)paren
(brace
r_int
id|n
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|part-&gt;XferInfo
(braket
id|i
)braket
dot
id|state
op_eq
id|XFER_UNKNOWN
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;XferInfo[%d].state == XFER_UNKNOWN&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|n
op_assign
l_int|1
suffix:semicolon
id|erase_xfer
c_func
(paren
id|part
comma
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|part-&gt;XferInfo
(braket
id|i
)braket
dot
id|state
op_eq
id|XFER_ERASING
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;XferInfo[%d].state == XFER_ERASING&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|n
op_assign
l_int|1
suffix:semicolon
id|queued
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|part-&gt;XferInfo
(braket
id|i
)braket
dot
id|state
op_eq
id|XFER_ERASED
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;XferInfo[%d].state == XFER_ERASED&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|n
op_assign
l_int|1
suffix:semicolon
id|prepare_xfer
c_func
(paren
id|part
comma
id|i
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|part-&gt;XferInfo
(braket
id|i
)braket
dot
id|state
op_eq
id|XFER_PREPARED
)paren
(brace
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;XferInfo[%d].state == XFER_PREPARED&bslash;n&quot;
comma
id|i
)paren
suffix:semicolon
id|n
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|part-&gt;XferInfo
(braket
id|i
)braket
dot
id|EraseCount
op_le
id|best
)paren
(brace
id|best
op_assign
id|part-&gt;XferInfo
(braket
id|i
)braket
dot
id|EraseCount
suffix:semicolon
id|xfer
op_assign
id|i
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|n
)paren
id|DEBUG
c_func
(paren
l_int|4
comma
l_string|&quot;XferInfo[%d].state == %x&bslash;n&quot;
comma
id|i
comma
id|part-&gt;XferInfo
(braket
id|i
)braket
dot
id|state
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|xfer
op_eq
l_int|0xffff
)paren
(brace
r_if
c_cond
(paren
id|queued
)paren
(brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;ftl_cs: waiting for transfer &quot;
l_string|&quot;unit to be prepared...&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|part-&gt;mtd-&gt;sync
)paren
id|part-&gt;mtd
op_member_access_from_pointer
id|sync
c_func
(paren
id|part-&gt;mtd
)paren
suffix:semicolon
)brace
r_else
(brace
r_static
r_int
id|ne
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|ne
OL
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: reclaim failed: no &quot;
l_string|&quot;suitable transfer units!&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;ftl_cs: reclaim failed: no &quot;
l_string|&quot;suitable transfer units!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
)brace
r_while
c_loop
(paren
id|xfer
op_eq
l_int|0xffff
)paren
suffix:semicolon
id|eun
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|jiffies
op_mod
id|shuffle_freq
)paren
op_eq
l_int|0
)paren
(brace
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;ftl_cs: recycling freshest block...&bslash;n&quot;
)paren
suffix:semicolon
id|best
op_assign
l_int|0xffffffff
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|part-&gt;DataUnits
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|part-&gt;EUNInfo
(braket
id|i
)braket
dot
id|EraseCount
op_le
id|best
)paren
(brace
id|best
op_assign
id|part-&gt;EUNInfo
(braket
id|i
)braket
dot
id|EraseCount
suffix:semicolon
id|eun
op_assign
id|i
suffix:semicolon
)brace
)brace
r_else
(brace
id|best
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|part-&gt;DataUnits
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|part-&gt;EUNInfo
(braket
id|i
)braket
dot
id|Deleted
op_ge
id|best
)paren
(brace
id|best
op_assign
id|part-&gt;EUNInfo
(braket
id|i
)braket
dot
id|Deleted
suffix:semicolon
id|eun
op_assign
id|i
suffix:semicolon
)brace
r_if
c_cond
(paren
id|best
op_eq
l_int|0
)paren
(brace
r_static
r_int
id|ne
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|ne
OL
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: reclaim failed: &quot;
l_string|&quot;no free blocks!&bslash;n&quot;
)paren
suffix:semicolon
r_else
id|DEBUG
c_func
(paren
l_int|1
comma
l_string|&quot;ftl_cs: reclaim failed: &quot;
l_string|&quot;no free blocks!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
id|ret
op_assign
id|copy_erase_unit
c_func
(paren
id|part
comma
id|eun
comma
id|xfer
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
id|erase_xfer
c_func
(paren
id|part
comma
id|xfer
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: copy_erase_unit failed!&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* reclaim_block */
multiline_comment|/*======================================================================&n;&n;    Find_free() searches for a free block.  If necessary, it updates&n;    the BAM cache for the erase unit containing the free block.  It&n;    returns the block index -- the erase unit is just the currently&n;    cached unit.  If there are no free blocks, it returns 0 -- this&n;    is never a valid data block because it contains the header.&n;    &n;======================================================================*/
macro_line|#ifdef PSYCHO_DEBUG
DECL|function|dump_lists
r_static
r_void
id|dump_lists
c_func
(paren
id|partition_t
op_star
id|part
)paren
(brace
r_int
id|i
suffix:semicolon
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ftl_cs: Free total = %d&bslash;n&quot;
comma
id|part-&gt;FreeTotal
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|part-&gt;DataUnits
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;ftl_cs:   unit %d: %d phys, %d free, &quot;
l_string|&quot;%d deleted&bslash;n&quot;
comma
id|i
comma
id|part-&gt;EUNInfo
(braket
id|i
)braket
dot
id|Offset
op_rshift
id|part-&gt;header.EraseUnitSize
comma
id|part-&gt;EUNInfo
(braket
id|i
)braket
dot
id|Free
comma
id|part-&gt;EUNInfo
(braket
id|i
)braket
dot
id|Deleted
)paren
suffix:semicolon
)brace
macro_line|#endif
DECL|function|find_free
r_static
id|u_int32_t
id|find_free
c_func
(paren
id|partition_t
op_star
id|part
)paren
(brace
id|u_int16_t
id|stop
comma
id|eun
suffix:semicolon
id|u_int32_t
id|blk
suffix:semicolon
r_int
id|retlen
suffix:semicolon
r_int
id|ret
suffix:semicolon
multiline_comment|/* Find an erase unit with some free space */
id|stop
op_assign
(paren
id|part-&gt;bam_index
op_eq
l_int|0xffff
)paren
ques
c_cond
l_int|0
suffix:colon
id|part-&gt;bam_index
suffix:semicolon
id|eun
op_assign
id|stop
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
id|part-&gt;EUNInfo
(braket
id|eun
)braket
dot
id|Free
op_ne
l_int|0
)paren
r_break
suffix:semicolon
multiline_comment|/* Wrap around at end of table */
r_if
c_cond
(paren
op_increment
id|eun
op_eq
id|part-&gt;DataUnits
)paren
id|eun
op_assign
l_int|0
suffix:semicolon
)brace
r_while
c_loop
(paren
id|eun
op_ne
id|stop
)paren
suffix:semicolon
r_if
c_cond
(paren
id|part-&gt;EUNInfo
(braket
id|eun
)braket
dot
id|Free
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Is this unit&squot;s BAM cached? */
r_if
c_cond
(paren
id|eun
op_ne
id|part-&gt;bam_index
)paren
(brace
multiline_comment|/* Invalidate cache */
id|part-&gt;bam_index
op_assign
l_int|0xffff
suffix:semicolon
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|part-&gt;mtd
comma
id|part-&gt;EUNInfo
(braket
id|eun
)braket
dot
id|Offset
op_plus
id|le32_to_cpu
c_func
(paren
id|part-&gt;header.BAMOffset
)paren
comma
id|part-&gt;BlocksPerUnit
op_star
r_sizeof
(paren
id|u_int32_t
)paren
comma
op_amp
id|retlen
comma
(paren
id|u_char
op_star
)paren
(paren
id|part-&gt;bam_cache
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ftl: Error reading BAM in find_free&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|part-&gt;bam_index
op_assign
id|eun
suffix:semicolon
)brace
multiline_comment|/* Find a free block */
r_for
c_loop
(paren
id|blk
op_assign
l_int|0
suffix:semicolon
id|blk
OL
id|part-&gt;BlocksPerUnit
suffix:semicolon
id|blk
op_increment
)paren
r_if
c_cond
(paren
id|BLOCK_FREE
c_func
(paren
id|le32_to_cpu
c_func
(paren
id|part-&gt;bam_cache
(braket
id|blk
)braket
)paren
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|blk
op_eq
id|part-&gt;BlocksPerUnit
)paren
(brace
macro_line|#ifdef PSYCHO_DEBUG
r_static
r_int
id|ne
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|ne
op_eq
l_int|1
)paren
id|dump_lists
c_func
(paren
id|part
)paren
suffix:semicolon
macro_line|#endif
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: bad free list!&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;ftl_cs: found free block at %d in %d&bslash;n&quot;
comma
id|blk
comma
id|eun
)paren
suffix:semicolon
r_return
id|blk
suffix:semicolon
)brace
multiline_comment|/* find_free */
multiline_comment|/*======================================================================&n;&n;    This gets a memory handle for the region corresponding to the&n;    minor device number.&n;    &n;======================================================================*/
DECL|function|ftl_open
r_static
r_int
id|ftl_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|partition_t
op_star
id|partition
suffix:semicolon
r_if
c_cond
(paren
id|minor
op_rshift
l_int|4
op_ge
id|MAX_MTD_DEVICES
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
id|partition
op_assign
id|myparts
(braket
id|minor
op_rshift
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|partition
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
r_if
c_cond
(paren
id|partition-&gt;state
op_ne
id|FTL_FORMATTED
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|ftl_gendisk.part
(braket
id|minor
)braket
dot
id|nr_sects
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|get_mtd_device
c_func
(paren
id|partition-&gt;mtd
comma
op_minus
l_int|1
)paren
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
multiline_comment|/* -E&squot;SBUGGEREDOFF */
op_minus
id|ENXIO
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|file-&gt;f_mode
op_amp
l_int|2
)paren
op_logical_and
op_logical_neg
(paren
id|partition-&gt;mtd-&gt;flags
op_amp
id|MTD_CLEAR_BITS
)paren
)paren
(brace
id|put_mtd_device
c_func
(paren
id|partition-&gt;mtd
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EROFS
suffix:semicolon
)brace
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;ftl_cs: ftl_open(%d)&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
id|atomic_inc
c_func
(paren
op_amp
id|partition-&gt;open
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*====================================================================*/
DECL|function|ftl_close
r_static
id|release_t
id|ftl_close
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,2,0)
r_struct
id|super_block
op_star
id|sb
op_assign
id|get_super
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
macro_line|#endif
r_int
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|partition_t
op_star
id|part
op_assign
id|myparts
(braket
id|minor
op_rshift
l_int|4
)braket
suffix:semicolon
r_int
id|i
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;ftl_cs: ftl_close(%d)&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
multiline_comment|/* Flush all writes */
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,2,0)
r_if
c_cond
(paren
id|sb
)paren
id|invalidate_inodes
c_func
(paren
id|sb
)paren
suffix:semicolon
macro_line|#endif
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
multiline_comment|/* Wait for any pending erase operations to complete */
r_if
c_cond
(paren
id|part-&gt;mtd-&gt;sync
)paren
id|part-&gt;mtd
op_member_access_from_pointer
id|sync
c_func
(paren
id|part-&gt;mtd
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|part-&gt;header.NumTransferUnits
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|part-&gt;XferInfo
(braket
id|i
)braket
dot
id|state
op_eq
id|XFER_ERASED
)paren
id|prepare_xfer
c_func
(paren
id|part
comma
id|i
)paren
suffix:semicolon
)brace
id|atomic_dec
c_func
(paren
op_amp
id|part-&gt;open
)paren
suffix:semicolon
id|put_mtd_device
c_func
(paren
id|part-&gt;mtd
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
id|release_return
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
multiline_comment|/* ftl_close */
multiline_comment|/*======================================================================&n;&n;    Read a series of sectors from an FTL partition.&n;    &n;======================================================================*/
DECL|function|ftl_read
r_static
r_int
id|ftl_read
c_func
(paren
id|partition_t
op_star
id|part
comma
id|caddr_t
id|buffer
comma
id|u_long
id|sector
comma
id|u_long
id|nblocks
)paren
(brace
id|u_int32_t
id|log_addr
comma
id|bsize
suffix:semicolon
id|u_long
id|i
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|offset
comma
id|retlen
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;ftl_cs: ftl_read(0x%p, 0x%lx, %ld)&bslash;n&quot;
comma
id|part
comma
id|sector
comma
id|nblocks
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|part-&gt;state
op_amp
id|FTL_FORMATTED
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: bad partition&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|bsize
op_assign
l_int|1
op_lshift
id|part-&gt;header.EraseUnitSize
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
(paren
(paren
id|sector
op_plus
id|i
)paren
op_star
id|SECTOR_SIZE
)paren
op_ge
id|le32_to_cpu
c_func
(paren
id|part-&gt;header.FormattedSize
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: bad read offset&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|log_addr
op_assign
id|part-&gt;VirtualBlockMap
(braket
id|sector
op_plus
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|log_addr
op_eq
l_int|0xffffffff
)paren
id|memset
c_func
(paren
id|buffer
comma
l_int|0
comma
id|SECTOR_SIZE
)paren
suffix:semicolon
r_else
(brace
id|offset
op_assign
(paren
id|part-&gt;EUNInfo
(braket
id|log_addr
op_div
id|bsize
)braket
dot
id|Offset
op_plus
(paren
id|log_addr
op_mod
id|bsize
)paren
)paren
suffix:semicolon
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|part-&gt;mtd
comma
id|offset
comma
id|SECTOR_SIZE
comma
op_amp
id|retlen
comma
(paren
id|u_char
op_star
)paren
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Error reading MTD device in ftl_read()&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
)brace
id|buffer
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ftl_read */
multiline_comment|/*======================================================================&n;&n;    Write a series of sectors to an FTL partition&n;    &n;======================================================================*/
DECL|function|set_bam_entry
r_static
r_int
id|set_bam_entry
c_func
(paren
id|partition_t
op_star
id|part
comma
id|u_int32_t
id|log_addr
comma
id|u_int32_t
id|virt_addr
)paren
(brace
id|u_int32_t
id|bsize
comma
id|blk
comma
id|le_virt_addr
suffix:semicolon
macro_line|#ifdef PSYCHO_DEBUG
id|u_int32_t
id|old_addr
suffix:semicolon
macro_line|#endif
id|u_int16_t
id|eun
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|retlen
comma
id|offset
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;ftl_cs: set_bam_entry(0x%p, 0x%x, 0x%x)&bslash;n&quot;
comma
id|part
comma
id|log_addr
comma
id|virt_addr
)paren
suffix:semicolon
id|bsize
op_assign
l_int|1
op_lshift
id|part-&gt;header.EraseUnitSize
suffix:semicolon
id|eun
op_assign
id|log_addr
op_div
id|bsize
suffix:semicolon
id|blk
op_assign
(paren
id|log_addr
op_mod
id|bsize
)paren
op_div
id|SECTOR_SIZE
suffix:semicolon
id|offset
op_assign
(paren
id|part-&gt;EUNInfo
(braket
id|eun
)braket
dot
id|Offset
op_plus
id|blk
op_star
r_sizeof
(paren
id|u_int32_t
)paren
op_plus
id|le32_to_cpu
c_func
(paren
id|part-&gt;header.BAMOffset
)paren
)paren
suffix:semicolon
macro_line|#ifdef PSYCHO_DEBUG
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|read
c_func
(paren
id|part-&gt;mtd
comma
id|offset
comma
r_sizeof
(paren
id|u_int32_t
)paren
comma
op_amp
id|retlen
comma
(paren
id|u_char
op_star
)paren
op_amp
id|old_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ftl: Error reading old_addr in set_bam_entry: %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
id|old_addr
op_assign
id|le32_to_cpu
c_func
(paren
id|old_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|virt_addr
op_eq
l_int|0xfffffffe
)paren
op_logical_and
op_logical_neg
id|BLOCK_FREE
c_func
(paren
id|old_addr
)paren
)paren
op_logical_or
(paren
(paren
id|virt_addr
op_eq
l_int|0
)paren
op_logical_and
(paren
id|BLOCK_TYPE
c_func
(paren
id|old_addr
)paren
op_ne
id|BLOCK_DATA
)paren
)paren
op_logical_or
(paren
op_logical_neg
id|BLOCK_DELETED
c_func
(paren
id|virt_addr
)paren
op_logical_and
(paren
id|old_addr
op_ne
l_int|0xfffffffe
)paren
)paren
)paren
(brace
r_static
r_int
id|ne
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|ne
OL
l_int|5
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: set_bam_entry() inconsistency!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs:   log_addr = 0x%x, old = 0x%x&quot;
l_string|&quot;, new = 0x%x&bslash;n&quot;
comma
id|log_addr
comma
id|old_addr
comma
id|virt_addr
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#endif
id|le_virt_addr
op_assign
id|cpu_to_le32
c_func
(paren
id|virt_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|part-&gt;bam_index
op_eq
id|eun
)paren
(brace
macro_line|#ifdef PSYCHO_DEBUG
r_if
c_cond
(paren
id|le32_to_cpu
c_func
(paren
id|part-&gt;bam_cache
(braket
id|blk
)braket
)paren
op_ne
id|old_addr
)paren
(brace
r_static
r_int
id|ne
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|ne
OL
l_int|5
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: set_bam_entry() &quot;
l_string|&quot;inconsistency!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs:   log_addr = 0x%x, cache&quot;
l_string|&quot; = 0x%x&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|part-&gt;bam_cache
(braket
id|blk
)braket
)paren
comma
id|old_addr
)paren
suffix:semicolon
)brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#endif
id|part-&gt;bam_cache
(braket
id|blk
)braket
op_assign
id|le_virt_addr
suffix:semicolon
)brace
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|write
c_func
(paren
id|part-&gt;mtd
comma
id|offset
comma
r_sizeof
(paren
id|u_int32_t
)paren
comma
op_amp
id|retlen
comma
(paren
id|u_char
op_star
)paren
op_amp
id|le_virt_addr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: set_bam_entry() failed!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs:   log_addr = 0x%x, new = 0x%x&bslash;n&quot;
comma
id|log_addr
comma
id|virt_addr
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* set_bam_entry */
DECL|function|ftl_write
r_static
r_int
id|ftl_write
c_func
(paren
id|partition_t
op_star
id|part
comma
id|caddr_t
id|buffer
comma
id|u_long
id|sector
comma
id|u_long
id|nblocks
)paren
(brace
id|u_int32_t
id|bsize
comma
id|log_addr
comma
id|virt_addr
comma
id|old_addr
comma
id|blk
suffix:semicolon
id|u_long
id|i
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_int
id|retlen
comma
id|offset
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|2
comma
l_string|&quot;ftl_cs: ftl_write(0x%p, %ld, %ld)&bslash;n&quot;
comma
id|part
comma
id|sector
comma
id|nblocks
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|part-&gt;state
op_amp
id|FTL_FORMATTED
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: bad partition&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* See if we need to reclaim space, before we start */
r_while
c_loop
(paren
id|part-&gt;FreeTotal
OL
id|nblocks
)paren
(brace
id|ret
op_assign
id|reclaim_block
c_func
(paren
id|part
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
)brace
id|bsize
op_assign
l_int|1
op_lshift
id|part-&gt;header.EraseUnitSize
suffix:semicolon
id|virt_addr
op_assign
id|sector
op_star
id|SECTOR_SIZE
op_or
id|BLOCK_DATA
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|nblocks
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|virt_addr
op_ge
id|le32_to_cpu
c_func
(paren
id|part-&gt;header.FormattedSize
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: bad write offset&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Grab a free block */
id|blk
op_assign
id|find_free
c_func
(paren
id|part
)paren
suffix:semicolon
r_if
c_cond
(paren
id|blk
op_eq
l_int|0
)paren
(brace
r_static
r_int
id|ne
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|ne
OL
l_int|5
)paren
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: internal error: &quot;
l_string|&quot;no free blocks!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|ENOSPC
suffix:semicolon
)brace
multiline_comment|/* Tag the BAM entry, and write the new block */
id|log_addr
op_assign
id|part-&gt;bam_index
op_star
id|bsize
op_plus
id|blk
op_star
id|SECTOR_SIZE
suffix:semicolon
id|part-&gt;EUNInfo
(braket
id|part-&gt;bam_index
)braket
dot
id|Free
op_decrement
suffix:semicolon
id|part-&gt;FreeTotal
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|set_bam_entry
c_func
(paren
id|part
comma
id|log_addr
comma
l_int|0xfffffffe
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|part-&gt;EUNInfo
(braket
id|part-&gt;bam_index
)braket
dot
id|Deleted
op_increment
suffix:semicolon
id|offset
op_assign
(paren
id|part-&gt;EUNInfo
(braket
id|part-&gt;bam_index
)braket
dot
id|Offset
op_plus
id|blk
op_star
id|SECTOR_SIZE
)paren
suffix:semicolon
id|ret
op_assign
id|part-&gt;mtd
op_member_access_from_pointer
id|write
c_func
(paren
id|part-&gt;mtd
comma
id|offset
comma
id|SECTOR_SIZE
comma
op_amp
id|retlen
comma
id|buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: block write failed!&bslash;n&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs:   log_addr = 0x%x, virt_addr&quot;
l_string|&quot; = 0x%x, Offset = 0x%x&bslash;n&quot;
comma
id|log_addr
comma
id|virt_addr
comma
id|offset
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Only delete the old entry when the new entry is ready */
id|old_addr
op_assign
id|part-&gt;VirtualBlockMap
(braket
id|sector
op_plus
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|old_addr
op_ne
l_int|0xffffffff
)paren
(brace
id|part-&gt;VirtualBlockMap
(braket
id|sector
op_plus
id|i
)braket
op_assign
l_int|0xffffffff
suffix:semicolon
id|part-&gt;EUNInfo
(braket
id|old_addr
op_div
id|bsize
)braket
dot
id|Deleted
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|set_bam_entry
c_func
(paren
id|part
comma
id|old_addr
comma
l_int|0
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Finally, set up the new pointers */
r_if
c_cond
(paren
id|set_bam_entry
c_func
(paren
id|part
comma
id|log_addr
comma
id|virt_addr
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|part-&gt;VirtualBlockMap
(braket
id|sector
op_plus
id|i
)braket
op_assign
id|log_addr
suffix:semicolon
id|part-&gt;EUNInfo
(braket
id|part-&gt;bam_index
)braket
dot
id|Deleted
op_decrement
suffix:semicolon
id|buffer
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
id|virt_addr
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* ftl_write */
multiline_comment|/*======================================================================&n;&n;    IOCTL calls for getting device parameters.&n;&n;======================================================================*/
DECL|function|ftl_ioctl
r_static
r_int
id|ftl_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|u_int
id|cmd
comma
id|u_long
id|arg
)paren
(brace
r_struct
id|hd_geometry
op_star
id|geo
op_assign
(paren
r_struct
id|hd_geometry
op_star
)paren
id|arg
suffix:semicolon
r_int
id|ret
op_assign
l_int|0
comma
id|minor
op_assign
id|MINOR
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|partition_t
op_star
id|part
op_assign
id|myparts
(braket
id|minor
op_rshift
l_int|4
)braket
suffix:semicolon
id|u_long
id|sect
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|part
)paren
r_return
op_minus
id|ENODEV
suffix:semicolon
multiline_comment|/* How? */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|HDIO_GETGEO
suffix:colon
id|ret
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
op_star
id|geo
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
multiline_comment|/* Sort of arbitrary: round size down to 4K boundary */
id|sect
op_assign
id|le32_to_cpu
c_func
(paren
id|part-&gt;header.FormattedSize
)paren
op_div
id|SECTOR_SIZE
suffix:semicolon
id|put_user
c_func
(paren
l_int|1
comma
(paren
r_char
op_star
)paren
op_amp
id|geo-&gt;heads
)paren
suffix:semicolon
id|put_user
c_func
(paren
l_int|8
comma
(paren
r_char
op_star
)paren
op_amp
id|geo-&gt;sectors
)paren
suffix:semicolon
id|put_user
c_func
(paren
(paren
id|sect
op_rshift
l_int|3
)paren
comma
(paren
r_int
op_star
)paren
op_amp
id|geo-&gt;cylinders
)paren
suffix:semicolon
id|put_user
c_func
(paren
id|ftl_hd
(braket
id|minor
)braket
dot
id|start_sect
comma
(paren
id|u_long
op_star
)paren
op_amp
id|geo-&gt;start
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKGETSIZE
suffix:colon
id|ret
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_int
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_int
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
r_return
id|ret
suffix:semicolon
id|put_user
c_func
(paren
id|ftl_hd
(braket
id|minor
)braket
dot
id|nr_sects
comma
(paren
r_int
op_star
)paren
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|BLKRRPART
suffix:colon
id|ret
op_assign
id|ftl_reread_partitions
c_func
(paren
id|minor
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#if (LINUX_VERSION_CODE &lt; 0x20303)
r_case
id|BLKFLSBUF
suffix:colon
macro_line|#if LINUX_VERSION_CODE &gt;= KERNEL_VERSION(2,2,0)
r_if
c_cond
(paren
op_logical_neg
id|capable
c_func
(paren
id|CAP_SYS_ADMIN
)paren
)paren
r_return
op_minus
id|EACCES
suffix:semicolon
macro_line|#endif
id|fsync_dev
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|inode-&gt;i_rdev
)paren
suffix:semicolon
r_break
suffix:semicolon
id|RO_IOCTLS
c_func
(paren
id|inode-&gt;i_rdev
comma
id|arg
)paren
suffix:semicolon
macro_line|#else
r_case
id|BLKROSET
suffix:colon
r_case
id|BLKROGET
suffix:colon
r_case
id|BLKFLSBUF
suffix:colon
id|ret
op_assign
id|blk_ioctl
c_func
(paren
id|inode-&gt;i_rdev
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
r_break
suffix:semicolon
macro_line|#endif
r_default
suffix:colon
id|ret
op_assign
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* ftl_ioctl */
multiline_comment|/*======================================================================&n;&n;    Handler for block device requests&n;&n;======================================================================*/
DECL|function|ftl_reread_partitions
r_static
r_int
id|ftl_reread_partitions
c_func
(paren
r_int
id|minor
)paren
(brace
id|partition_t
op_star
id|part
op_assign
id|myparts
(braket
id|minor
op_rshift
l_int|4
)braket
suffix:semicolon
r_int
id|i
comma
id|whole
suffix:semicolon
id|DEBUG
c_func
(paren
l_int|0
comma
l_string|&quot;ftl_cs: ftl_reread_partition(%d)&bslash;n&quot;
comma
id|minor
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|atomic_read
c_func
(paren
op_amp
id|part-&gt;open
)paren
OG
l_int|1
)paren
)paren
(brace
r_return
op_minus
id|EBUSY
suffix:semicolon
)brace
id|whole
op_assign
id|minor
op_amp
op_complement
(paren
id|MAX_PART
op_minus
l_int|1
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PART
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ftl_hd
(braket
id|whole
op_plus
id|i
)braket
dot
id|nr_sects
OG
l_int|0
)paren
(brace
id|kdev_t
id|rdev
op_assign
id|MKDEV
c_func
(paren
id|FTL_MAJOR
comma
id|whole
op_plus
id|i
)paren
suffix:semicolon
id|sync_dev
c_func
(paren
id|rdev
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|rdev
)paren
suffix:semicolon
)brace
id|ftl_hd
(braket
id|whole
op_plus
id|i
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
id|ftl_hd
(braket
id|whole
op_plus
id|i
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
)brace
id|scan_header
c_func
(paren
id|part
)paren
suffix:semicolon
id|register_disk
c_func
(paren
op_amp
id|ftl_gendisk
comma
id|whole
op_rshift
id|PART_BITS
comma
id|MAX_PART
comma
op_amp
id|ftl_blk_fops
comma
id|le32_to_cpu
c_func
(paren
id|part-&gt;header.FormattedSize
)paren
op_div
id|SECTOR_SIZE
)paren
suffix:semicolon
macro_line|#ifdef PCMCIA_DEBUG
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_PART
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|ftl_hd
(braket
id|whole
op_plus
id|i
)braket
dot
id|nr_sects
OG
l_int|0
)paren
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;  %d: start %ld size %ld&bslash;n&quot;
comma
id|i
comma
id|ftl_hd
(braket
id|whole
op_plus
id|i
)braket
dot
id|start_sect
comma
id|ftl_hd
(braket
id|whole
op_plus
id|i
)braket
dot
id|nr_sects
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*======================================================================&n;&n;    Handler for block device requests&n;&n;======================================================================*/
DECL|function|do_ftl_request
r_static
r_void
id|do_ftl_request
c_func
(paren
id|request_arg_t
)paren
(brace
r_int
id|ret
comma
id|minor
suffix:semicolon
id|partition_t
op_star
id|part
suffix:semicolon
r_do
(brace
singleline_comment|//&t;    sti();
id|INIT_REQUEST
suffix:semicolon
id|minor
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
suffix:semicolon
id|part
op_assign
id|myparts
(braket
id|minor
op_rshift
l_int|4
)braket
suffix:semicolon
r_if
c_cond
(paren
id|part
)paren
(brace
id|ret
op_assign
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|CURRENT-&gt;cmd
)paren
(brace
r_case
id|READ
suffix:colon
id|ret
op_assign
id|ftl_read
c_func
(paren
id|part
comma
id|CURRENT-&gt;buffer
comma
id|CURRENT-&gt;sector
op_plus
id|ftl_hd
(braket
id|minor
)braket
dot
id|start_sect
comma
id|CURRENT-&gt;current_nr_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|printk
c_func
(paren
l_string|&quot;ftl_read returned %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|WRITE
suffix:colon
id|ret
op_assign
id|ftl_write
c_func
(paren
id|part
comma
id|CURRENT-&gt;buffer
comma
id|CURRENT-&gt;sector
op_plus
id|ftl_hd
(braket
id|minor
)braket
dot
id|start_sect
comma
id|CURRENT-&gt;current_nr_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
id|printk
c_func
(paren
l_string|&quot;ftl_write returned %d&bslash;n&quot;
comma
id|ret
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
l_string|&quot;ftl_cs: unknown block command!&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|ret
op_assign
l_int|1
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;NULL part in ftl_request&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|ret
)paren
(brace
id|CURRENT-&gt;sector
op_add_assign
id|CURRENT-&gt;current_nr_sectors
suffix:semicolon
)brace
id|end_request
c_func
(paren
(paren
id|ret
op_eq
l_int|0
)paren
ques
c_cond
l_int|1
suffix:colon
l_int|0
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/* do_ftl_request */
multiline_comment|/*====================================================================*/
DECL|function|ftl_freepart
r_void
id|ftl_freepart
c_func
(paren
id|partition_t
op_star
id|part
)paren
(brace
r_if
c_cond
(paren
id|part-&gt;VirtualBlockMap
)paren
(brace
id|vfree
c_func
(paren
id|part-&gt;VirtualBlockMap
)paren
suffix:semicolon
id|part-&gt;VirtualBlockMap
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|part-&gt;VirtualPageMap
)paren
(brace
id|kfree
c_func
(paren
id|part-&gt;VirtualPageMap
)paren
suffix:semicolon
id|part-&gt;VirtualPageMap
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|part-&gt;EUNInfo
)paren
(brace
id|kfree
c_func
(paren
id|part-&gt;EUNInfo
)paren
suffix:semicolon
id|part-&gt;EUNInfo
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|part-&gt;XferInfo
)paren
(brace
id|kfree
c_func
(paren
id|part-&gt;XferInfo
)paren
suffix:semicolon
id|part-&gt;XferInfo
op_assign
l_int|NULL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|part-&gt;bam_cache
)paren
(brace
id|kfree
c_func
(paren
id|part-&gt;bam_cache
)paren
suffix:semicolon
id|part-&gt;bam_cache
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
multiline_comment|/* ftl_freepart */
DECL|function|ftl_notify_add
r_static
r_void
id|ftl_notify_add
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
id|partition_t
op_star
id|partition
suffix:semicolon
r_int
id|device
suffix:semicolon
r_for
c_loop
(paren
id|device
op_assign
l_int|0
suffix:semicolon
id|device
OL
id|MAX_MTD_DEVICES
op_logical_and
id|myparts
(braket
id|device
)braket
suffix:semicolon
id|device
op_increment
)paren
suffix:semicolon
r_if
c_cond
(paren
id|device
op_eq
id|MAX_MTD_DEVICES
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Maximum number of FTL partitions reached&bslash;n&quot;
l_string|&quot;Not scanning &lt;%s&gt;&bslash;n&quot;
comma
id|mtd-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|partition
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
id|partition_t
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|partition
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;No memory to scan for FTL on %s&bslash;n&quot;
comma
id|mtd-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|memset
c_func
(paren
id|partition
comma
l_int|0
comma
r_sizeof
(paren
id|partition_t
)paren
)paren
suffix:semicolon
id|partition-&gt;mtd
op_assign
id|mtd
suffix:semicolon
r_if
c_cond
(paren
(paren
id|scan_header
c_func
(paren
id|partition
)paren
op_eq
l_int|0
)paren
op_logical_and
(paren
id|build_maps
c_func
(paren
id|partition
)paren
op_eq
l_int|0
)paren
)paren
(brace
id|partition-&gt;state
op_assign
id|FTL_FORMATTED
suffix:semicolon
id|atomic_set
c_func
(paren
op_amp
id|partition-&gt;open
comma
l_int|0
)paren
suffix:semicolon
id|myparts
(braket
id|device
)braket
op_assign
id|partition
suffix:semicolon
id|ftl_reread_partitions
c_func
(paren
id|device
op_lshift
l_int|4
)paren
suffix:semicolon
macro_line|#ifdef PCMCIA_DEBUG
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;ftl_cs: opening %d kb FTL partition&bslash;n&quot;
comma
id|le32_to_cpu
c_func
(paren
id|partition-&gt;header.FormattedSize
)paren
op_rshift
l_int|10
)paren
suffix:semicolon
macro_line|#endif
)brace
)brace
DECL|function|ftl_notify_remove
r_static
r_void
id|ftl_notify_remove
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
multiline_comment|/* Q: What happens if you try to remove a device which has&n;&t; *    a currently-open FTL partition on it?&n;&t; *&n;&t; * A: You don&squot;t. The ftl_open routine is responsible for&n;&t; *    increasing the use count of the driver module which&n;&t; *    it uses.&n;&t; */
multiline_comment|/* That&squot;s the theory, anyway :) */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_MTD_DEVICES
suffix:semicolon
id|i
op_increment
)paren
r_if
c_cond
(paren
id|myparts
(braket
id|i
)braket
op_logical_and
id|myparts
(braket
id|i
)braket
op_member_access_from_pointer
id|mtd
op_eq
id|mtd
)paren
(brace
r_if
c_cond
(paren
id|myparts
(braket
id|i
)braket
op_member_access_from_pointer
id|state
op_eq
id|FTL_FORMATTED
)paren
id|ftl_freepart
c_func
(paren
id|myparts
(braket
id|i
)braket
)paren
suffix:semicolon
id|myparts
(braket
id|i
)braket
op_member_access_from_pointer
id|state
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|16
suffix:semicolon
id|j
op_increment
)paren
(brace
id|ftl_gendisk.part
(braket
id|j
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
id|ftl_gendisk.part
(braket
id|j
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
)brace
id|kfree
c_func
(paren
id|myparts
(braket
id|i
)braket
)paren
suffix:semicolon
id|myparts
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
)brace
)brace
macro_line|#if LINUX_VERSION_CODE &lt; 0x20300
macro_line|#ifdef MODULE
DECL|macro|init_ftl
mdefine_line|#define init_ftl init_module
DECL|macro|cleanup_ftl
mdefine_line|#define cleanup_ftl cleanup_module
macro_line|#endif
macro_line|#endif
DECL|function|init_ftl
id|mod_init_t
id|init_ftl
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|memset
c_func
(paren
id|myparts
comma
l_int|0
comma
r_sizeof
(paren
id|myparts
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|FTL_MAJOR
comma
l_string|&quot;ftl&quot;
comma
op_amp
id|ftl_blk_fops
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;ftl_cs: unable to grab major &quot;
l_string|&quot;device number!&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EAGAIN
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MINOR_NR
c_func
(paren
id|MAX_DEV
comma
l_int|0
comma
l_int|0
)paren
suffix:semicolon
id|i
op_increment
)paren
id|ftl_blocksizes
(braket
id|i
)braket
op_assign
l_int|1024
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_DEV
op_star
id|MAX_PART
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ftl_hd
(braket
id|i
)braket
dot
id|nr_sects
op_assign
l_int|0
suffix:semicolon
id|ftl_hd
(braket
id|i
)braket
dot
id|start_sect
op_assign
l_int|0
suffix:semicolon
)brace
id|blksize_size
(braket
id|FTL_MAJOR
)braket
op_assign
id|ftl_blocksizes
suffix:semicolon
id|ftl_gendisk.major
op_assign
id|FTL_MAJOR
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|FTL_MAJOR
)paren
comma
op_amp
id|do_ftl_request
)paren
suffix:semicolon
id|ftl_gendisk.next
op_assign
id|gendisk_head
suffix:semicolon
id|gendisk_head
op_assign
op_amp
id|ftl_gendisk
suffix:semicolon
id|register_mtd_user
c_func
(paren
op_amp
id|ftl_notifier
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_ftl
id|mod_exit_t
id|cleanup_ftl
c_func
(paren
r_void
)paren
(brace
r_struct
id|gendisk
op_star
id|gd
comma
op_star
op_star
id|gdp
suffix:semicolon
id|unregister_mtd_user
c_func
(paren
op_amp
id|ftl_notifier
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|FTL_MAJOR
comma
l_string|&quot;ftl&quot;
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|FTL_MAJOR
)paren
)paren
suffix:semicolon
id|blksize_size
(braket
id|FTL_MAJOR
)braket
op_assign
l_int|NULL
suffix:semicolon
r_for
c_loop
(paren
id|gdp
op_assign
op_amp
id|gendisk_head
suffix:semicolon
op_star
id|gdp
suffix:semicolon
id|gdp
op_assign
op_amp
(paren
(paren
op_star
id|gdp
)paren
op_member_access_from_pointer
id|next
)paren
)paren
r_if
c_cond
(paren
op_star
id|gdp
op_eq
op_amp
id|ftl_gendisk
)paren
(brace
id|gd
op_assign
op_star
id|gdp
suffix:semicolon
op_star
id|gdp
op_assign
id|gd-&gt;next
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
macro_line|#if LINUX_VERSION_CODE &gt; 0x20300
DECL|variable|init_ftl
id|module_init
c_func
(paren
id|init_ftl
)paren
suffix:semicolon
DECL|variable|cleanup_ftl
id|module_exit
c_func
(paren
id|cleanup_ftl
)paren
suffix:semicolon
macro_line|#endif
eof
