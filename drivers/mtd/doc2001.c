multiline_comment|/*&n; * Linux driver for Disk-On-Chip Millennium&n; * (c) 1999 Machine Vision Holdings, Inc.&n; * (c) 1999, 2000 David Woodhouse &lt;dwmw2@infradead.org&gt;&n; *&n; * $Id: doc2001.c,v 1.24 2000/12/01 13:11:02 dwmw2 Exp $&n; */
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;asm/errno.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/miscdevice.h&gt;
macro_line|#include &lt;linux/pci.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/mtd/mtd.h&gt;
macro_line|#include &lt;linux/mtd/nand.h&gt;
macro_line|#include &lt;linux/mtd/nand_ids.h&gt;
macro_line|#include &lt;linux/mtd/doc2000.h&gt;
multiline_comment|/* #define ECC_DEBUG */
multiline_comment|/* I have no idea why some DoC chips can not use memcop_form|to_io().&n; * This may be due to the different revisions of the ASIC controller built-in or&n; * simplily a QA/Bug issue. Who knows ?? If you have trouble, please uncomment&n; * this:&n; #undef USE_MEMCPY&n;*/
r_static
r_int
id|doc_read
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|doc_write
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|doc_read_ecc
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
)paren
suffix:semicolon
r_static
r_int
id|doc_write_ecc
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
)paren
suffix:semicolon
r_static
r_int
id|doc_read_oob
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|doc_write_oob
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
suffix:semicolon
r_static
r_int
id|doc_erase
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
suffix:semicolon
DECL|variable|docmillist
r_static
r_struct
id|mtd_info
op_star
id|docmillist
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* Perform the required delay cycles by reading from the NOP register */
DECL|function|DoC_Delay
r_static
r_void
id|DoC_Delay
c_func
(paren
r_int
r_int
id|docptr
comma
r_int
r_int
id|cycles
)paren
(brace
r_volatile
r_char
id|dummy
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|cycles
suffix:semicolon
id|i
op_increment
)paren
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|NOP
)paren
suffix:semicolon
)brace
multiline_comment|/* DOC_WaitReady: Wait for RDY line to be asserted by the flash chip */
DECL|function|_DoC_WaitReady
r_static
r_int
id|_DoC_WaitReady
c_func
(paren
r_int
r_int
id|docptr
)paren
(brace
r_int
r_int
id|c
op_assign
l_int|0xffff
suffix:semicolon
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL3
comma
l_string|&quot;_DoC_WaitReady called for out-of-line wait&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Out-of-line routine to wait for chip response */
r_while
c_loop
(paren
op_logical_neg
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
op_amp
id|CDSN_CTRL_FR_B
)paren
op_logical_and
op_decrement
id|c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|c
op_eq
l_int|0
)paren
id|DEBUG
c_func
(paren
id|MTD_DEBUG_LEVEL2
comma
l_string|&quot;_DoC_WaitReady timed out.&bslash;n&quot;
)paren
suffix:semicolon
r_return
(paren
id|c
op_eq
l_int|0
)paren
suffix:semicolon
)brace
DECL|function|DoC_WaitReady
r_static
r_inline
r_int
id|DoC_WaitReady
c_func
(paren
r_int
r_int
id|docptr
)paren
(brace
multiline_comment|/* This is inline, to optimise the common case, where it&squot;s ready instantly */
r_int
id|ret
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* 4 read form NOP register should be issued in prior to the read from CDSNControl&n;&t;   see Software Requirement 11.4 item 2. */
id|DoC_Delay
c_func
(paren
id|docptr
comma
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNControl
)paren
op_amp
id|CDSN_CTRL_FR_B
)paren
)paren
multiline_comment|/* Call the out-of-line routine to wait */
id|ret
op_assign
id|_DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
multiline_comment|/* issue 2 read from NOP register after reading from CDSNControl register&n;&t;   see Software Requirement 11.4 item 2. */
id|DoC_Delay
c_func
(paren
id|docptr
comma
l_int|2
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
multiline_comment|/* DoC_Command: Send a flash command to the flash chip through the CDSN Slow IO register to&n;   bypass the internal pipeline. Each of 4 delay cycles (read from the NOP register) is&n;   required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */
DECL|function|DoC_Command
r_static
r_inline
r_void
id|DoC_Command
c_func
(paren
r_int
r_int
id|docptr
comma
r_int
r_char
id|command
comma
r_int
r_char
id|xtraflags
)paren
(brace
multiline_comment|/* Assert the CLE (Command Latch Enable) line to the flash chip */
id|WriteDOC
c_func
(paren
id|xtraflags
op_or
id|CDSN_CTRL_CLE
op_or
id|CDSN_CTRL_CE
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|docptr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Send the command */
id|WriteDOC
c_func
(paren
id|command
comma
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|command
comma
id|docptr
comma
id|Mil_CDSN_IO
)paren
suffix:semicolon
multiline_comment|/* Lower the CLE line */
id|WriteDOC
c_func
(paren
id|xtraflags
op_or
id|CDSN_CTRL_CE
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|docptr
comma
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* DoC_Address: Set the current address for the flash chip through the CDSN Slow IO register to&n;   bypass the internal pipeline. Each of 4 delay cycles (read from the NOP register) is&n;   required after writing to CDSN Control register, see Software Requirement 11.4 item 3. */
DECL|function|DoC_Address
r_static
r_inline
r_void
id|DoC_Address
c_func
(paren
r_int
r_int
id|docptr
comma
r_int
id|numbytes
comma
r_int
r_int
id|ofs
comma
r_int
r_char
id|xtraflags1
comma
r_int
r_char
id|xtraflags2
)paren
(brace
multiline_comment|/* Assert the ALE (Address Latch Enable) line to the flash chip */
id|WriteDOC
c_func
(paren
id|xtraflags1
op_or
id|CDSN_CTRL_ALE
op_or
id|CDSN_CTRL_CE
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|docptr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Send the address */
r_switch
c_cond
(paren
id|numbytes
)paren
(brace
r_case
l_int|1
suffix:colon
multiline_comment|/* Send single byte, bits 0-7. */
id|WriteDOC
c_func
(paren
id|ofs
op_amp
l_int|0xff
comma
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|ofs
op_amp
l_int|0xff
comma
id|docptr
comma
id|Mil_CDSN_IO
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* Send bits 9-16 followed by 17-23 */
id|WriteDOC
c_func
(paren
(paren
id|ofs
op_rshift
l_int|9
)paren
op_amp
l_int|0xff
comma
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
(paren
id|ofs
op_rshift
l_int|9
)paren
op_amp
l_int|0xff
comma
id|docptr
comma
id|Mil_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
(paren
id|ofs
op_rshift
l_int|17
)paren
op_amp
l_int|0xff
comma
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
(paren
id|ofs
op_rshift
l_int|17
)paren
op_amp
l_int|0xff
comma
id|docptr
comma
id|Mil_CDSN_IO
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
multiline_comment|/* Send 0-7, 9-16, then 17-23 */
id|WriteDOC
c_func
(paren
id|ofs
op_amp
l_int|0xff
comma
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
id|ofs
op_amp
l_int|0xff
comma
id|docptr
comma
id|Mil_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
(paren
id|ofs
op_rshift
l_int|9
)paren
op_amp
l_int|0xff
comma
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
(paren
id|ofs
op_rshift
l_int|9
)paren
op_amp
l_int|0xff
comma
id|docptr
comma
id|Mil_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
(paren
id|ofs
op_rshift
l_int|17
)paren
op_amp
l_int|0xff
comma
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
(paren
id|ofs
op_rshift
l_int|17
)paren
op_amp
l_int|0xff
comma
id|docptr
comma
id|Mil_CDSN_IO
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
suffix:semicolon
)brace
multiline_comment|/* Lower the ALE line */
id|WriteDOC
c_func
(paren
id|xtraflags1
op_or
id|xtraflags2
op_or
id|CDSN_CTRL_CE
comma
id|docptr
comma
id|CDSNControl
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|docptr
comma
l_int|4
)paren
suffix:semicolon
)brace
multiline_comment|/* DoC_SelectChip: Select a given flash chip within the current floor */
DECL|function|DoC_SelectChip
r_static
r_int
id|DoC_SelectChip
c_func
(paren
r_int
r_int
id|docptr
comma
r_int
id|chip
)paren
(brace
multiline_comment|/* Select the individual flash chip requested */
id|WriteDOC
c_func
(paren
id|chip
comma
id|docptr
comma
id|CDSNDeviceSelect
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|docptr
comma
l_int|4
)paren
suffix:semicolon
multiline_comment|/* Wait for it to be ready */
r_return
id|DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
)brace
multiline_comment|/* DoC_SelectFloor: Select a given floor (bank of flash chips) */
DECL|function|DoC_SelectFloor
r_static
r_int
id|DoC_SelectFloor
c_func
(paren
r_int
r_int
id|docptr
comma
r_int
id|floor
)paren
(brace
multiline_comment|/* Select the floor (bank) of chips required */
id|WriteDOC
c_func
(paren
id|floor
comma
id|docptr
comma
id|FloorSelect
)paren
suffix:semicolon
multiline_comment|/* Wait for the chip to be ready */
r_return
id|DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
)brace
multiline_comment|/* DoC_IdentChip: Identify a given NAND chip given {floor,chip} */
DECL|function|DoC_IdentChip
r_static
r_int
id|DoC_IdentChip
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc
comma
r_int
id|floor
comma
r_int
id|chip
)paren
(brace
r_int
id|mfr
comma
id|id
comma
id|i
suffix:semicolon
r_volatile
r_char
id|dummy
suffix:semicolon
multiline_comment|/* Page in the required floor/chip&n;&t;   FIXME: is this supported by Millennium ?? */
id|DoC_SelectFloor
c_func
(paren
id|doc-&gt;virtadr
comma
id|floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|doc-&gt;virtadr
comma
id|chip
)paren
suffix:semicolon
multiline_comment|/* Reset the chip, see Software Requirement 11.4 item 1. */
id|DoC_Command
c_func
(paren
id|doc-&gt;virtadr
comma
id|NAND_CMD_RESET
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_WaitReady
c_func
(paren
id|doc-&gt;virtadr
)paren
suffix:semicolon
multiline_comment|/* Read the NAND chip ID: 1. Send ReadID command */
id|DoC_Command
c_func
(paren
id|doc-&gt;virtadr
comma
id|NAND_CMD_READID
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
multiline_comment|/* Read the NAND chip ID: 2. Send address byte zero */
id|DoC_Address
c_func
(paren
id|doc-&gt;virtadr
comma
l_int|1
comma
l_int|0x00
comma
id|CDSN_CTRL_WP
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Read the manufacturer and device id codes of the flash device through&n;&t;   CDSN Slow IO register see Software Requirement 11.4 item 5.*/
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc-&gt;virtadr
comma
l_int|2
)paren
suffix:semicolon
id|mfr
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|Mil_CDSN_IO
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|doc-&gt;virtadr
comma
l_int|2
)paren
suffix:semicolon
id|id
op_assign
id|ReadDOC
c_func
(paren
id|doc-&gt;virtadr
comma
id|Mil_CDSN_IO
)paren
suffix:semicolon
multiline_comment|/* No response - return failure */
r_if
c_cond
(paren
id|mfr
op_eq
l_int|0xff
op_logical_or
id|mfr
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* FIXME: to deal with multi-flash on multi-Millennium case more carefully */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|nand_flash_ids
(braket
id|i
)braket
dot
id|name
op_ne
l_int|NULL
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mfr
op_eq
id|nand_flash_ids
(braket
id|i
)braket
dot
id|manufacture_id
op_logical_and
id|id
op_eq
id|nand_flash_ids
(braket
id|i
)braket
dot
id|model_id
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Flash chip found: Manufacturer ID: %2.2X, &quot;
l_string|&quot;Chip ID: %2.2X (%s)&bslash;n&quot;
comma
id|mfr
comma
id|id
comma
id|nand_flash_ids
(braket
id|i
)braket
dot
id|name
)paren
suffix:semicolon
id|doc-&gt;mfr
op_assign
id|mfr
suffix:semicolon
id|doc-&gt;id
op_assign
id|id
suffix:semicolon
id|doc-&gt;chipshift
op_assign
id|nand_flash_ids
(braket
id|i
)braket
dot
id|chipshift
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nand_flash_ids
(braket
id|i
)braket
dot
id|name
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
r_else
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* DoC_ScanChips: Find all NAND chips present in a DiskOnChip, and identify them */
DECL|function|DoC_ScanChips
r_static
r_void
id|DoC_ScanChips
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|this
)paren
(brace
r_int
id|floor
comma
id|chip
suffix:semicolon
r_int
id|numchips
(braket
id|MAX_FLOORS_MIL
)braket
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|this-&gt;numchips
op_assign
l_int|0
suffix:semicolon
id|this-&gt;mfr
op_assign
l_int|0
suffix:semicolon
id|this-&gt;id
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* For each floor, find the number of valid chips it contains */
r_for
c_loop
(paren
id|floor
op_assign
l_int|0
comma
id|ret
op_assign
l_int|1
suffix:semicolon
id|floor
OL
id|MAX_FLOORS_MIL
suffix:semicolon
id|floor
op_increment
)paren
(brace
id|numchips
(braket
id|floor
)braket
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|chip
op_assign
l_int|0
suffix:semicolon
id|chip
OL
id|MAX_CHIPS_MIL
op_logical_and
id|ret
op_ne
l_int|0
suffix:semicolon
id|chip
op_increment
)paren
(brace
id|ret
op_assign
id|DoC_IdentChip
c_func
(paren
id|this
comma
id|floor
comma
id|chip
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ret
)paren
(brace
id|numchips
(braket
id|floor
)braket
op_increment
suffix:semicolon
id|this-&gt;numchips
op_increment
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* If there are none at all that we recognise, bail */
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;numchips
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No flash chips recognised.&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Allocate an array to hold the information for each chip */
id|this-&gt;chips
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|Nand
)paren
op_star
id|this-&gt;numchips
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;chips
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;No memory for allocating chip info structures&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
multiline_comment|/* Fill out the chip array with {floor, chipno} for each &n;&t; * detected chip in the device. */
r_for
c_loop
(paren
id|floor
op_assign
l_int|0
comma
id|ret
op_assign
l_int|0
suffix:semicolon
id|floor
OL
id|MAX_FLOORS_MIL
suffix:semicolon
id|floor
op_increment
)paren
(brace
r_for
c_loop
(paren
id|chip
op_assign
l_int|0
suffix:semicolon
id|chip
OL
id|numchips
(braket
id|floor
)braket
suffix:semicolon
id|chip
op_increment
)paren
(brace
id|this-&gt;chips
(braket
id|ret
)braket
dot
id|floor
op_assign
id|floor
suffix:semicolon
id|this-&gt;chips
(braket
id|ret
)braket
dot
id|chip
op_assign
id|chip
suffix:semicolon
id|this-&gt;chips
(braket
id|ret
)braket
dot
id|curadr
op_assign
l_int|0
suffix:semicolon
id|this-&gt;chips
(braket
id|ret
)braket
dot
id|curmode
op_assign
l_int|0x50
suffix:semicolon
id|ret
op_increment
suffix:semicolon
)brace
)brace
multiline_comment|/* Calculate and print the total size of the device */
id|this-&gt;totlen
op_assign
id|this-&gt;numchips
op_star
(paren
l_int|1
op_lshift
id|this-&gt;chipshift
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;%d flash chips found. Total DiskOnChip size: %ld Mbytes&bslash;n&quot;
comma
id|this-&gt;numchips
comma
id|this-&gt;totlen
op_rshift
l_int|20
)paren
suffix:semicolon
)brace
DECL|function|DoCMil_is_alias
r_static
r_int
id|DoCMil_is_alias
c_func
(paren
r_struct
id|DiskOnChip
op_star
id|doc1
comma
r_struct
id|DiskOnChip
op_star
id|doc2
)paren
(brace
r_int
id|tmp1
comma
id|tmp2
comma
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|doc1-&gt;physadr
op_eq
id|doc2-&gt;physadr
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* Use the alias resolution register which was set aside for this&n;&t; * purpose. If it&squot;s value is the same on both chips, they might&n;&t; * be the same chip, and we write to one and check for a change in&n;&t; * the other. It&squot;s unclear if this register is usuable in the&n;&t; * DoC 2000 (it&squot;s in the Millenium docs), but it seems to work. */
id|tmp1
op_assign
id|ReadDOC
c_func
(paren
id|doc1-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
id|tmp2
op_assign
id|ReadDOC
c_func
(paren
id|doc2-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp1
op_ne
id|tmp2
)paren
r_return
l_int|0
suffix:semicolon
id|WriteDOC
c_func
(paren
(paren
id|tmp1
op_plus
l_int|1
)paren
op_mod
l_int|0xff
comma
id|doc1-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
id|tmp2
op_assign
id|ReadDOC
c_func
(paren
id|doc2-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
r_if
c_cond
(paren
id|tmp2
op_eq
(paren
id|tmp1
op_plus
l_int|1
)paren
op_mod
l_int|0xff
)paren
id|retval
op_assign
l_int|1
suffix:semicolon
r_else
id|retval
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Restore register contents.  May not be necessary, but do it just to&n;&t; * be safe. */
id|WriteDOC
c_func
(paren
id|tmp1
comma
id|doc1-&gt;virtadr
comma
id|AliasResolution
)paren
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
DECL|variable|im_name
r_static
r_const
r_char
id|im_name
(braket
)braket
op_assign
l_string|&quot;DoCMil_init&quot;
suffix:semicolon
multiline_comment|/* This routine is made available to other mtd code via&n; * inter_module_register.  It must only be accessed through&n; * inter_module_get which will bump the use count of this module.  The&n; * addresses passed back in mtd are valid as long as the use count of&n; * this module is non-zero, i.e. between inter_module_get and&n; * inter_module_put.  Keith Owens &lt;kaos@ocs.com.au&gt; 29 Oct 2000.&n; */
DECL|function|DoCMil_init
r_static
r_void
id|DoCMil_init
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
)paren
(brace
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_struct
id|DiskOnChip
op_star
id|old
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* We must avoid being called twice for the same device. */
r_if
c_cond
(paren
id|docmillist
)paren
id|old
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|docmillist-&gt;priv
suffix:semicolon
r_while
c_loop
(paren
id|old
)paren
(brace
r_if
c_cond
(paren
id|DoCMil_is_alias
c_func
(paren
id|this
comma
id|old
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;Ignoring DiskOnChip Millennium at &quot;
l_string|&quot;0x%lX - already configured&bslash;n&quot;
comma
id|this-&gt;physadr
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|this-&gt;virtadr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|old-&gt;nextdoc
)paren
id|old
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|old-&gt;nextdoc-&gt;priv
suffix:semicolon
r_else
id|old
op_assign
l_int|NULL
suffix:semicolon
)brace
id|mtd-&gt;name
op_assign
l_string|&quot;DiskOnChip Millennium&quot;
suffix:semicolon
id|printk
c_func
(paren
id|KERN_NOTICE
l_string|&quot;DiskOnChip Millennium found at address 0x%lX&bslash;n&quot;
comma
id|this-&gt;physadr
)paren
suffix:semicolon
id|mtd-&gt;type
op_assign
id|MTD_NANDFLASH
suffix:semicolon
id|mtd-&gt;flags
op_assign
id|MTD_CAP_NANDFLASH
suffix:semicolon
id|mtd-&gt;size
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* FIXME: erase size is not always 8kB */
id|mtd-&gt;erasesize
op_assign
l_int|0x2000
suffix:semicolon
id|mtd-&gt;oobblock
op_assign
l_int|512
suffix:semicolon
id|mtd-&gt;oobsize
op_assign
l_int|16
suffix:semicolon
id|mtd-&gt;module
op_assign
id|THIS_MODULE
suffix:semicolon
id|mtd-&gt;erase
op_assign
id|doc_erase
suffix:semicolon
id|mtd-&gt;point
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;unpoint
op_assign
l_int|NULL
suffix:semicolon
id|mtd-&gt;read
op_assign
id|doc_read
suffix:semicolon
id|mtd-&gt;write
op_assign
id|doc_write
suffix:semicolon
id|mtd-&gt;read_ecc
op_assign
id|doc_read_ecc
suffix:semicolon
id|mtd-&gt;write_ecc
op_assign
id|doc_write_ecc
suffix:semicolon
id|mtd-&gt;read_oob
op_assign
id|doc_read_oob
suffix:semicolon
id|mtd-&gt;write_oob
op_assign
id|doc_write_oob
suffix:semicolon
id|mtd-&gt;sync
op_assign
l_int|NULL
suffix:semicolon
id|this-&gt;totlen
op_assign
l_int|0
suffix:semicolon
id|this-&gt;numchips
op_assign
l_int|0
suffix:semicolon
id|this-&gt;curfloor
op_assign
op_minus
l_int|1
suffix:semicolon
id|this-&gt;curchip
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Ident all the chips present. */
id|DoC_ScanChips
c_func
(paren
id|this
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|this-&gt;totlen
)paren
(brace
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|this-&gt;virtadr
)paren
suffix:semicolon
)brace
r_else
(brace
id|this-&gt;nextdoc
op_assign
id|docmillist
suffix:semicolon
id|docmillist
op_assign
id|mtd
suffix:semicolon
id|mtd-&gt;size
op_assign
id|this-&gt;totlen
suffix:semicolon
id|add_mtd_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
DECL|function|doc_read
r_static
r_int
id|doc_read
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
multiline_comment|/* Just a special case of doc_read_ecc */
r_return
id|doc_read_ecc
c_func
(paren
id|mtd
comma
id|from
comma
id|len
comma
id|retlen
comma
id|buf
comma
l_int|NULL
)paren
suffix:semicolon
)brace
DECL|function|doc_read_ecc
r_static
r_int
id|doc_read_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|from
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
)paren
(brace
r_int
id|i
comma
id|ret
suffix:semicolon
r_volatile
r_char
id|dummy
suffix:semicolon
r_int
r_char
id|syndrome
(braket
l_int|6
)braket
suffix:semicolon
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|from
op_rshift
(paren
id|this-&gt;chipshift
)paren
)braket
suffix:semicolon
multiline_comment|/* Don&squot;t allow read past end of device */
r_if
c_cond
(paren
id|from
op_ge
id|this-&gt;totlen
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Don&squot;t allow a single read to cross a 512-byte block boundary */
r_if
c_cond
(paren
id|from
op_plus
id|len
OG
(paren
(paren
id|from
op_or
l_int|0x1ff
)paren
op_plus
l_int|1
)paren
)paren
id|len
op_assign
(paren
(paren
id|from
op_or
l_int|0x1ff
)paren
op_plus
l_int|1
)paren
op_minus
id|from
suffix:semicolon
multiline_comment|/* Find the chip which is to be used and select it */
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|docptr
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
multiline_comment|/* issue the Read0 or Read1 command depend on which half of the page&n;&t;   we are accessing. Polling the Flash Ready bit after issue 3 bytes&n;&t;   address in Sequence Read Mode, see Software Requirement 11.4 item 1.*/
id|DoC_Command
c_func
(paren
id|docptr
comma
(paren
id|from
op_rshift
l_int|8
)paren
op_amp
l_int|1
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|docptr
comma
l_int|3
comma
id|from
comma
id|CDSN_CTRL_WP
comma
l_int|0x00
)paren
suffix:semicolon
id|DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eccbuf
)paren
(brace
multiline_comment|/* init the ECC engine, see Reed-Solomon EDC/ECC 11.1 .*/
id|WriteDOC
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
(paren
id|DOC_ECC_EN
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* disable the ECC engine */
id|WriteDOC
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the data via the internal pipeline through CDSN IO register,&n;&t;   see Pipelined Read Operations 11.3 */
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ReadPipeInit
)paren
suffix:semicolon
macro_line|#ifndef USE_MEMCPY
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* N.B. you have to increase the source address in this way or the&n;&t;&t;   ECC logic will not work properly */
id|buf
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mil_CDSN_IO
op_plus
(paren
id|i
op_amp
l_int|0xff
)paren
)paren
suffix:semicolon
)brace
macro_line|#else
id|memcpy_fromio
c_func
(paren
id|buf
comma
id|docptr
op_plus
id|DoC_Mil_CDSN_IO
comma
id|len
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|buf
(braket
id|len
op_minus
l_int|1
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|LastDataRead
)paren
suffix:semicolon
multiline_comment|/* Let the caller know we completed it */
op_star
id|retlen
op_assign
id|len
suffix:semicolon
id|ret
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|eccbuf
)paren
(brace
multiline_comment|/* Read the ECC data from Spare Data Area,&n;&t;&t;   see Reed-Solomon EDC/ECC 11.1 */
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ReadPipeInit
)paren
suffix:semicolon
macro_line|#ifndef USE_MEMCPY
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* N.B. you have to increase the source address in this way or the&n;&t;&t;&t;   ECC logic will not work properly */
id|eccbuf
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mil_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
)brace
macro_line|#else
id|memcpy_fromio
c_func
(paren
id|eccbuf
comma
id|docptr
op_plus
id|DoC_Mil_CDSN_IO
comma
l_int|5
)paren
suffix:semicolon
macro_line|#endif
id|eccbuf
(braket
l_int|5
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|LastDataRead
)paren
suffix:semicolon
multiline_comment|/* Flush the pipeline */
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
multiline_comment|/* Check the ECC Status */
r_if
c_cond
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCConf
)paren
op_amp
l_int|0x80
)paren
(brace
r_int
id|nb_errors
suffix:semicolon
multiline_comment|/* There was an ECC error */
macro_line|#ifdef ECC_DEBUG
id|printk
c_func
(paren
l_string|&quot;DiskOnChip ECC Error: Read at %lx&bslash;n&quot;
comma
(paren
r_int
)paren
id|from
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* Read the ECC syndrom through the DiskOnChip ECC logic.&n;&t;&t;&t;   These syndrome will be all ZERO when there is no error */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|syndrome
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCSyndrome0
op_plus
id|i
)paren
suffix:semicolon
)brace
id|nb_errors
op_assign
id|doc_decode_ecc
c_func
(paren
id|buf
comma
id|syndrome
)paren
suffix:semicolon
macro_line|#ifdef ECC_DEBUG
id|printk
c_func
(paren
l_string|&quot;Errors corrected: %x&bslash;n&quot;
comma
id|nb_errors
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|nb_errors
OL
l_int|0
)paren
(brace
multiline_comment|/* We return error, but have actually done the read. Not that&n;&t;&t;&t;&t;   this can be told to user-space, via sys_read(), but at least&n;&t;&t;&t;&t;   MTD-aware stuff can know about it by checking *retlen */
id|ret
op_assign
op_minus
id|EIO
suffix:semicolon
)brace
)brace
macro_line|#ifdef PSYCHO_DEBUG
id|printk
c_func
(paren
l_string|&quot;ECC DATA at %lx: %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X&bslash;n&quot;
comma
(paren
r_int
)paren
id|from
comma
id|eccbuf
(braket
l_int|0
)braket
comma
id|eccbuf
(braket
l_int|1
)braket
comma
id|eccbuf
(braket
l_int|2
)braket
comma
id|eccbuf
(braket
l_int|3
)braket
comma
id|eccbuf
(braket
l_int|4
)braket
comma
id|eccbuf
(braket
l_int|5
)braket
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* disable the ECC engine */
id|WriteDOC
c_func
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
r_return
id|ret
suffix:semicolon
)brace
DECL|function|doc_write
r_static
r_int
id|doc_write
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
r_char
id|eccbuf
(braket
l_int|6
)braket
suffix:semicolon
r_return
id|doc_write_ecc
c_func
(paren
id|mtd
comma
id|to
comma
id|len
comma
id|retlen
comma
id|buf
comma
id|eccbuf
)paren
suffix:semicolon
)brace
DECL|function|doc_write_ecc
r_static
r_int
id|doc_write_ecc
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|to
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
comma
id|u_char
op_star
id|eccbuf
)paren
(brace
r_int
id|i
suffix:semicolon
r_volatile
r_char
id|dummy
suffix:semicolon
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|to
op_rshift
(paren
id|this-&gt;chipshift
)paren
)braket
suffix:semicolon
multiline_comment|/* Don&squot;t allow write past end of device */
r_if
c_cond
(paren
id|to
op_ge
id|this-&gt;totlen
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#if 0
multiline_comment|/* Don&squot;t allow a single write to cross a 512-byte block boundary */
r_if
c_cond
(paren
id|to
op_plus
id|len
OG
(paren
(paren
id|to
op_or
l_int|0x1ff
)paren
op_plus
l_int|1
)paren
)paren
id|len
op_assign
(paren
(paren
id|to
op_or
l_int|0x1ff
)paren
op_plus
l_int|1
)paren
op_minus
id|to
suffix:semicolon
macro_line|#else
multiline_comment|/* Don&squot;t allow writes which aren&squot;t exactly one block */
r_if
c_cond
(paren
id|to
op_amp
l_int|0x1ff
op_logical_or
id|len
op_ne
l_int|0x200
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
macro_line|#endif
multiline_comment|/* Find the chip which is to be used and select it */
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|docptr
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
multiline_comment|/* Reset the chip, see Software Requirement 11.4 item 1. */
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_RESET
comma
l_int|0x00
)paren
suffix:semicolon
id|DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
multiline_comment|/* Set device to main plane of flash */
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_READ0
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* issue the Serial Data In command to initial the Page Program process */
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_SEQIN
comma
l_int|0x00
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|docptr
comma
l_int|3
comma
id|to
comma
l_int|0x00
comma
l_int|0x00
)paren
suffix:semicolon
id|DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eccbuf
)paren
(brace
multiline_comment|/* init the ECC engine, see Reed-Solomon EDC/ECC 11.1 .*/
id|WriteDOC
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
(paren
id|DOC_ECC_EN
op_or
id|DOC_ECC_RW
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* disable the ECC engine */
id|WriteDOC
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
)brace
multiline_comment|/* Write the data via the internal pipeline through CDSN IO register,&n;&t;   see Pipelined Write Operations 11.2 */
macro_line|#ifndef USE_MEMCPY
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* N.B. you have to increase the source address in this way or the&n;&t;&t;   ECC logic will not work properly */
id|WriteDOC
c_func
(paren
id|buf
(braket
id|i
)braket
comma
id|docptr
comma
id|Mil_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
)brace
macro_line|#else
id|memcpy_toio
c_func
(paren
id|docptr
op_plus
id|DoC_Mil_CDSN_IO
comma
id|buf
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
id|WriteDOC
c_func
(paren
l_int|0x00
comma
id|docptr
comma
id|WritePipeTerm
)paren
suffix:semicolon
r_if
c_cond
(paren
id|eccbuf
)paren
(brace
multiline_comment|/* Write ECC data to flash, the ECC info is generated by the DiskOnChip ECC logic&n;&t;&t;   see Reed-Solomon EDC/ECC 11.1 */
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|NOP
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|NOP
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0
comma
id|docptr
comma
id|NOP
)paren
suffix:semicolon
multiline_comment|/* Read the ECC data through the DiskOnChip ECC logic */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
id|eccbuf
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ECCSyndrome0
op_plus
id|i
)paren
suffix:semicolon
)brace
multiline_comment|/* ignore the ECC engine */
id|WriteDOC
c_func
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
macro_line|#ifndef USE_MEMCPY
multiline_comment|/* Write the ECC data to flash */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|6
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* N.B. you have to increase the source address in this way or the&n;&t;&t;&t;   ECC logic will not work properly */
id|WriteDOC
c_func
(paren
id|eccbuf
(braket
id|i
)braket
comma
id|docptr
comma
id|Mil_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
)brace
macro_line|#else
id|memcpy_toio
c_func
(paren
id|docptr
op_plus
id|DoC_Mil_CDSN_IO
comma
id|eccbuf
comma
l_int|6
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* write the block status BLOCK_USED (0x5555) at the end of ECC data&n;&t;&t;   FIXME: this is only a hack for programming the IPL area for LinuxBIOS&n;&t;&t;   and should be replace with proper codes in user space utilities */
id|WriteDOC
c_func
(paren
l_int|0x55
comma
id|docptr
comma
id|Mil_CDSN_IO
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0x55
comma
id|docptr
comma
id|Mil_CDSN_IO
op_plus
l_int|1
)paren
suffix:semicolon
id|WriteDOC
c_func
(paren
l_int|0x00
comma
id|docptr
comma
id|WritePipeTerm
)paren
suffix:semicolon
macro_line|#ifdef PSYCHO_DEBUG
id|printk
c_func
(paren
l_string|&quot;OOB data at %lx is %2.2X %2.2X %2.2X %2.2X %2.2X %2.2X&bslash;n&quot;
comma
(paren
r_int
)paren
id|to
comma
id|eccbuf
(braket
l_int|0
)braket
comma
id|eccbuf
(braket
l_int|1
)braket
comma
id|eccbuf
(braket
l_int|2
)braket
comma
id|eccbuf
(braket
l_int|3
)braket
comma
id|eccbuf
(braket
l_int|4
)braket
comma
id|eccbuf
(braket
l_int|5
)braket
)paren
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/* Commit the Page Program command and wait for ready&n;&t;   see Software Requirement 11.4 item 1.*/
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_PAGEPROG
comma
l_int|0x00
)paren
suffix:semicolon
id|DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
multiline_comment|/* Read the status of the flash device through CDSN Slow IO register&n;&t;   see Software Requirement 11.4 item 5.*/
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_STATUS
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|docptr
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mil_CDSN_IO
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error programming flash&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Error in programming&n;&t;&t;   FIXME: implement Bad Block Replacement (in nftl.c ??) */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* Let the caller know we completed it */
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc_read_oob
r_static
r_int
id|doc_read_oob
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
id|u_char
op_star
id|buf
)paren
(brace
macro_line|#ifndef USE_MEMCPY
r_int
id|i
suffix:semicolon
macro_line|#endif
r_volatile
r_char
id|dummy
suffix:semicolon
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|ofs
op_rshift
id|this-&gt;chipshift
)braket
suffix:semicolon
multiline_comment|/* Find the chip which is to be used and select it */
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|docptr
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
multiline_comment|/* disable the ECC engine */
id|WriteDOC
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
multiline_comment|/* issue the Read2 command to set the pointer to the Spare Data Area.&n;&t;   Polling the Flash Ready bit after issue 3 bytes address in&n;&t;   Sequence Read Mode, see Software Requirement 11.4 item 1.*/
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_READOOB
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|docptr
comma
l_int|3
comma
id|ofs
comma
id|CDSN_CTRL_WP
comma
l_int|0x00
)paren
suffix:semicolon
id|DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
multiline_comment|/* Read the data out via the internal pipeline through CDSN IO register,&n;&t;   see Pipelined Read Operations 11.3 */
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|ReadPipeInit
)paren
suffix:semicolon
macro_line|#ifndef USE_MEMCPY
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
op_minus
l_int|1
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* N.B. you have to increase the source address in this way or the&n;&t;&t;   ECC logic will not work properly */
id|buf
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mil_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
)brace
id|buf
(braket
id|i
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|LastDataRead
)paren
suffix:semicolon
macro_line|#else
id|memcpy_fromio
c_func
(paren
id|buf
comma
id|docptr
op_plus
id|DoC_Mil_CDSN_IO
comma
id|len
op_minus
l_int|1
)paren
suffix:semicolon
macro_line|#endif
id|buf
(braket
id|len
op_minus
l_int|1
)braket
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|LastDataRead
)paren
suffix:semicolon
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc_write_oob
r_static
r_int
id|doc_write_oob
c_func
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
id|loff_t
id|ofs
comma
r_int
id|len
comma
r_int
op_star
id|retlen
comma
r_const
id|u_char
op_star
id|buf
)paren
(brace
macro_line|#ifndef USE_MEMCPY
r_int
id|i
suffix:semicolon
macro_line|#endif
r_volatile
r_char
id|dummy
suffix:semicolon
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|ofs
op_rshift
id|this-&gt;chipshift
)braket
suffix:semicolon
multiline_comment|/* Find the chip which is to be used and select it */
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|docptr
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
multiline_comment|/* disable the ECC engine */
id|WriteDOC
(paren
id|DOC_ECC_RESET
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
id|WriteDOC
(paren
id|DOC_ECC_DIS
comma
id|docptr
comma
id|ECCConf
)paren
suffix:semicolon
multiline_comment|/* Reset the chip, see Software Requirement 11.4 item 1. */
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_RESET
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
multiline_comment|/* issue the Read2 command to set the pointer to the Spare Data Area. */
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_READOOB
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
multiline_comment|/* issue the Serial Data In command to initial the Page Program process */
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_SEQIN
comma
l_int|0x00
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|docptr
comma
l_int|3
comma
id|ofs
comma
l_int|0x00
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Write the data via the internal pipeline through CDSN IO register,&n;&t;   see Pipelined Write Operations 11.2 */
macro_line|#ifndef USE_MEMCPY
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
multiline_comment|/* N.B. you have to increase the source address in this way or the&n;&t;&t;   ECC logic will not work properly */
id|WriteDOC
c_func
(paren
id|buf
(braket
id|i
)braket
comma
id|docptr
comma
id|Mil_CDSN_IO
op_plus
id|i
)paren
suffix:semicolon
)brace
macro_line|#else
id|memcpy_toio
c_func
(paren
id|docptr
op_plus
id|DoC_Mil_CDSN_IO
comma
id|buf
comma
id|len
)paren
suffix:semicolon
macro_line|#endif
id|WriteDOC
c_func
(paren
l_int|0x00
comma
id|docptr
comma
id|WritePipeTerm
)paren
suffix:semicolon
multiline_comment|/* Commit the Page Program command and wait for ready&n;&t;   see Software Requirement 11.4 item 1.*/
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_PAGEPROG
comma
l_int|0x00
)paren
suffix:semicolon
id|DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
multiline_comment|/* Read the status of the flash device through CDSN Slow IO register&n;&t;   see Software Requirement 11.4 item 5.*/
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_STATUS
comma
l_int|0x00
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|docptr
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mil_CDSN_IO
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error programming oob data&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* FIXME: implement Bad Block Replacement (in nftl.c ??) */
op_star
id|retlen
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
op_star
id|retlen
op_assign
id|len
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|doc_erase
r_int
id|doc_erase
(paren
r_struct
id|mtd_info
op_star
id|mtd
comma
r_struct
id|erase_info
op_star
id|instr
)paren
(brace
r_volatile
r_char
id|dummy
suffix:semicolon
r_struct
id|DiskOnChip
op_star
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
r_int
r_int
id|ofs
op_assign
id|instr-&gt;addr
suffix:semicolon
r_int
r_int
id|len
op_assign
id|instr-&gt;len
suffix:semicolon
r_int
r_int
id|docptr
op_assign
id|this-&gt;virtadr
suffix:semicolon
r_struct
id|Nand
op_star
id|mychip
op_assign
op_amp
id|this-&gt;chips
(braket
id|ofs
op_rshift
id|this-&gt;chipshift
)braket
suffix:semicolon
r_if
c_cond
(paren
id|len
op_ne
id|mtd-&gt;erasesize
)paren
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Erase not right size (%lx != %lx)n&quot;
comma
id|len
comma
id|mtd-&gt;erasesize
)paren
suffix:semicolon
multiline_comment|/* Find the chip which is to be used and select it */
r_if
c_cond
(paren
id|this-&gt;curfloor
op_ne
id|mychip-&gt;floor
)paren
(brace
id|DoC_SelectFloor
c_func
(paren
id|docptr
comma
id|mychip-&gt;floor
)paren
suffix:semicolon
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|this-&gt;curchip
op_ne
id|mychip-&gt;chip
)paren
(brace
id|DoC_SelectChip
c_func
(paren
id|docptr
comma
id|mychip-&gt;chip
)paren
suffix:semicolon
)brace
id|this-&gt;curfloor
op_assign
id|mychip-&gt;floor
suffix:semicolon
id|this-&gt;curchip
op_assign
id|mychip-&gt;chip
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASE_PENDING
suffix:semicolon
multiline_comment|/* issue the Erase Setup command */
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_ERASE1
comma
l_int|0x00
)paren
suffix:semicolon
id|DoC_Address
c_func
(paren
id|docptr
comma
l_int|2
comma
id|ofs
comma
l_int|0x00
comma
l_int|0x00
)paren
suffix:semicolon
multiline_comment|/* Commit the Erase Start command and wait for ready&n;&t;   see Software Requirement 11.4 item 1.*/
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_ERASE2
comma
l_int|0x00
)paren
suffix:semicolon
id|DoC_WaitReady
c_func
(paren
id|docptr
)paren
suffix:semicolon
id|instr-&gt;state
op_assign
id|MTD_ERASING
suffix:semicolon
multiline_comment|/* Read the status of the flash device through CDSN Slow IO register&n;&t;   see Software Requirement 11.4 item 5.&n;&t;   FIXME: it seems that we are not wait long enough, some blocks are not&n;&t;   erased fully */
id|DoC_Command
c_func
(paren
id|docptr
comma
id|NAND_CMD_STATUS
comma
id|CDSN_CTRL_WP
)paren
suffix:semicolon
id|dummy
op_assign
id|ReadDOC
c_func
(paren
id|docptr
comma
id|CDSNSlowIO
)paren
suffix:semicolon
id|DoC_Delay
c_func
(paren
id|docptr
comma
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ReadDOC
c_func
(paren
id|docptr
comma
id|Mil_CDSN_IO
)paren
op_amp
l_int|1
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Error Erasing at 0x%lx&bslash;n&quot;
comma
id|ofs
)paren
suffix:semicolon
multiline_comment|/* There was an error&n;&t;&t;   FIXME: implement Bad Block Replacement (in nftl.c ??) */
id|instr-&gt;state
op_assign
id|MTD_ERASE_FAILED
suffix:semicolon
)brace
r_else
id|instr-&gt;state
op_assign
id|MTD_ERASE_DONE
suffix:semicolon
r_if
c_cond
(paren
id|instr-&gt;callback
)paren
id|instr
op_member_access_from_pointer
id|callback
c_func
(paren
id|instr
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; *&n; * Module stuff&n; *&n; ****************************************************************************/
macro_line|#if LINUX_VERSION_CODE &lt; 0x20212 &amp;&amp; defined(MODULE)
DECL|macro|cleanup_doc2001
mdefine_line|#define cleanup_doc2001 cleanup_module
DECL|macro|init_doc2001
mdefine_line|#define init_doc2001 init_module
macro_line|#endif
DECL|function|init_doc2001
r_int
id|__init
id|init_doc2001
c_func
(paren
r_void
)paren
(brace
id|inter_module_register
c_func
(paren
id|im_name
comma
id|THIS_MODULE
comma
op_amp
id|DoCMil_init
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cleanup_doc2001
r_static
r_void
id|__exit
id|cleanup_doc2001
c_func
(paren
r_void
)paren
(brace
r_struct
id|mtd_info
op_star
id|mtd
suffix:semicolon
r_struct
id|DiskOnChip
op_star
id|this
suffix:semicolon
r_while
c_loop
(paren
(paren
id|mtd
op_assign
id|docmillist
)paren
)paren
(brace
id|this
op_assign
(paren
r_struct
id|DiskOnChip
op_star
)paren
id|mtd-&gt;priv
suffix:semicolon
id|docmillist
op_assign
id|this-&gt;nextdoc
suffix:semicolon
id|del_mtd_device
c_func
(paren
id|mtd
)paren
suffix:semicolon
id|iounmap
c_func
(paren
(paren
r_void
op_star
)paren
id|this-&gt;virtadr
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|this-&gt;chips
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|mtd
)paren
suffix:semicolon
)brace
id|inter_module_unregister
c_func
(paren
id|im_name
)paren
suffix:semicolon
)brace
DECL|variable|cleanup_doc2001
id|module_exit
c_func
(paren
id|cleanup_doc2001
)paren
suffix:semicolon
DECL|variable|init_doc2001
id|module_init
c_func
(paren
id|init_doc2001
)paren
suffix:semicolon
eof
