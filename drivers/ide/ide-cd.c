multiline_comment|/*&n; * linux/drivers/ide/ide-cd.c&n; *&n; * Copyright (C) 1994, 1995, 1996  scott snyder  &lt;snyder@fnald0.fnal.gov&gt;&n; * Copyright (C) 1996-1998  Erik Andersen &lt;andersee@debian.org&gt;&n; * Copyright (C) 1998-2000  Jens Axboe &lt;axboe@suse.de&gt;&n; *&n; * May be copied or modified under the terms of the GNU General Public&n; * License.  See linux/COPYING for more information.&n; *&n; * ATAPI CD-ROM driver.  To be used with ide.c.&n; * See Documentation/cdrom/ide-cd for usage information.&n; *&n; * Suggestions are welcome. Patches that work are more welcome though. ;-)&n; * For those wishing to work on this driver, please be sure you download&n; * and comply with the latest Mt. Fuji (SFF8090 version 4) and ATAPI &n; * (SFF-8020i rev 2.6) standards. These documents can be obtained by &n; * anonymous ftp from:&n; * ftp://fission.dt.wdc.com/pub/standards/SFF_atapi/spec/SFF8020-r2.6/PS/8020r26.ps&n; * ftp://ftp.avc-pioneer.com/Mtfuji4/Spec/Fuji4r10.pdf&n; *&n; * Drives that deviate from these standards will be accomodated as much&n; * as possible via compile time or command-line options.  Since I only have&n; * a few drives, you generally need to send me patches...&n; *&n; * ----------------------------------&n; * TO DO LIST:&n; * -Make it so that Pioneer CD DR-A24X and friends don&squot;t get screwed up on&n; *   boot&n; *&n; * ----------------------------------&n; * 1.00  Oct 31, 1994 -- Initial version.&n; * 1.01  Nov  2, 1994 -- Fixed problem with starting request in&n; *                       cdrom_check_status.&n; * 1.03  Nov 25, 1994 -- leaving unmask_intr[] as a user-setting (as for disks)&n; * (from mlord)       -- minor changes to cdrom_setup()&n; *                    -- renamed ide_dev_s to ide_drive_t, enable irq on command&n; * 2.00  Nov 27, 1994 -- Generalize packet command interface;&n; *                       add audio ioctls.&n; * 2.01  Dec  3, 1994 -- Rework packet command interface to handle devices&n; *                       which send an interrupt when ready for a command.&n; * 2.02  Dec 11, 1994 -- Cache the TOC in the driver.&n; *                       Don&squot;t use SCMD_PLAYAUDIO_TI; it&squot;s not included&n; *                       in the current version of ATAPI.&n; *                       Try to use LBA instead of track or MSF addressing&n; *                       when possible.&n; *                       Don&squot;t wait for READY_STAT.&n; * 2.03  Jan 10, 1995 -- Rewrite block read routines to handle block sizes&n; *                       other than 2k and to move multiple sectors in a&n; *                       single transaction.&n; * 2.04  Apr 21, 1995 -- Add work-around for Creative Labs CD220E drives.&n; *                       Thanks to Nick Saw &lt;cwsaw@pts7.pts.mot.com&gt; for&n; *                       help in figuring this out.  Ditto for Acer and&n; *                       Aztech drives, which seem to have the same problem.&n; * 2.04b May 30, 1995 -- Fix to match changes in ide.c version 3.16 -ml&n; * 2.05  Jun  8, 1995 -- Don&squot;t attempt to retry after an illegal request&n; *                        or data protect error.&n; *                       Use HWIF and DEV_HWIF macros as in ide.c.&n; *                       Always try to do a request_sense after&n; *                        a failed command.&n; *                       Include an option to give textual descriptions&n; *                        of ATAPI errors.&n; *                       Fix a bug in handling the sector cache which&n; *                        showed up if the drive returned data in 512 byte&n; *                        blocks (like Pioneer drives).  Thanks to&n; *                        Richard Hirst &lt;srh@gpt.co.uk&gt; for diagnosing this.&n; *                       Properly supply the page number field in the&n; *                        MODE_SELECT command.&n; *                       PLAYAUDIO12 is broken on the Aztech; work around it.&n; * 2.05x Aug 11, 1995 -- lots of data structure renaming/restructuring in ide.c&n; *                       (my apologies to Scott, but now ide-cd.c is independent)&n; * 3.00  Aug 22, 1995 -- Implement CDROMMULTISESSION ioctl.&n; *                       Implement CDROMREADAUDIO ioctl (UNTESTED).&n; *                       Use input_ide_data() and output_ide_data().&n; *                       Add door locking.&n; *                       Fix usage count leak in cdrom_open, which happened&n; *                        when a read-write mount was attempted.&n; *                       Try to load the disk on open.&n; *                       Implement CDROMEJECT_SW ioctl (off by default).&n; *                       Read total cdrom capacity during open.&n; *                       Rearrange logic in cdrom_decode_status.  Issue&n; *                        request sense commands for failed packet commands&n; *                        from here instead of from cdrom_queue_packet_command.&n; *                        Fix a race condition in retrieving error information.&n; *                       Suppress printing normal unit attention errors and&n; *                        some drive not ready errors.&n; *                       Implement CDROMVOLREAD ioctl.&n; *                       Implement CDROMREADMODE1/2 ioctls.&n; *                       Fix race condition in setting up interrupt handlers&n; *                        when the `serialize&squot; option is used.&n; * 3.01  Sep  2, 1995 -- Fix ordering of reenabling interrupts in&n; *                        cdrom_queue_request.&n; *                       Another try at using ide_[input,output]_data.&n; * 3.02  Sep 16, 1995 -- Stick total disk capacity in partition table as well.&n; *                       Make VERBOSE_IDE_CD_ERRORS dump failed command again.&n; *                       Dump out more information for ILLEGAL REQUEST errs.&n; *                       Fix handling of errors occurring before the&n; *                        packet command is transferred.&n; *                       Fix transfers with odd bytelengths.&n; * 3.03  Oct 27, 1995 -- Some Creative drives have an id of just `CD&squot;.&n; *                       `DCI-2S10&squot; drives are broken too.&n; * 3.04  Nov 20, 1995 -- So are Vertos drives.&n; * 3.05  Dec  1, 1995 -- Changes to go with overhaul of ide.c and ide-tape.c&n; * 3.06  Dec 16, 1995 -- Add support needed for partitions.&n; *                       More workarounds for Vertos bugs (based on patches&n; *                        from Holger Dietze &lt;dietze@aix520.informatik.uni-leipzig.de&gt;).&n; *                       Try to eliminate byteorder assumptions.&n; *                       Use atapi_cdrom_subchnl struct definition.&n; *                       Add STANDARD_ATAPI compilation option.&n; * 3.07  Jan 29, 1996 -- More twiddling for broken drives: Sony 55D,&n; *                        Vertos 300.&n; *                       Add NO_DOOR_LOCKING configuration option.&n; *                       Handle drive_cmd requests w/NULL args (for hdparm -t).&n; *                       Work around sporadic Sony55e audio play problem.&n; * 3.07a Feb 11, 1996 -- check drive-&gt;id for NULL before dereferencing, to fix&n; *                        problem with &quot;hde=cdrom&quot; with no drive present.  -ml&n; * 3.08  Mar  6, 1996 -- More Vertos workarounds.&n; * 3.09  Apr  5, 1996 -- Add CDROMCLOSETRAY ioctl.&n; *                       Switch to using MSF addressing for audio commands.&n; *                       Reformat to match kernel tabbing style.&n; *                       Add CDROM_GET_UPC ioctl.&n; * 3.10  Apr 10, 1996 -- Fix compilation error with STANDARD_ATAPI.&n; * 3.11  Apr 29, 1996 -- Patch from Heiko Eissfeldt &lt;heiko@colossus.escape.de&gt;&n; *                       to remove redundant verify_area calls.&n; * 3.12  May  7, 1996 -- Rudimentary changer support.  Based on patches&n; *                        from Gerhard Zuber &lt;zuber@berlin.snafu.de&gt;.&n; *                       Let open succeed even if there&squot;s no loaded disc.&n; * 3.13  May 19, 1996 -- Fixes for changer code.&n; * 3.14  May 29, 1996 -- Add work-around for Vertos 600.&n; *                        (From Hennus Bergman &lt;hennus@sky.ow.nl&gt;.)&n; * 3.15  July 2, 1996 -- Added support for Sanyo 3 CD changers&n; *                        from Ben Galliart &lt;bgallia@luc.edu&gt; with &n; *                        special help from Jeff Lightfoot &n; *                        &lt;jeffml@pobox.com&gt;&n; * 3.15a July 9, 1996 -- Improved Sanyo 3 CD changer identification&n; * 3.16  Jul 28, 1996 -- Fix from Gadi to reduce kernel stack usage for ioctl.&n; * 3.17  Sep 17, 1996 -- Tweak audio reads for some drives.&n; *                       Start changing CDROMLOADFROMSLOT to CDROM_SELECT_DISC.&n; * 3.18  Oct 31, 1996 -- Added module and DMA support.&n; *                       &n; *                       &n; * 4.00  Nov 5, 1996   -- New ide-cd maintainer,&n; *                                 Erik B. Andersen &lt;andersee@debian.org&gt;&n; *                     -- Newer Creative drives don&squot;t always set the error&n; *                          register correctly.  Make sure we see media changes&n; *                          regardless.&n; *                     -- Integrate with generic cdrom driver.&n; *                     -- CDROMGETSPINDOWN and CDROMSETSPINDOWN ioctls, based on&n; *                          a patch from Ciro Cattuto &lt;&gt;.&n; *                     -- Call set_device_ro.&n; *                     -- Implement CDROMMECHANISMSTATUS and CDROMSLOTTABLE&n; *                          ioctls, based on patch by Erik Andersen&n; *                     -- Add some probes of drive capability during setup.&n; *&n; * 4.01  Nov 11, 1996  -- Split into ide-cd.c and ide-cd.h&n; *                     -- Removed CDROMMECHANISMSTATUS and CDROMSLOTTABLE &n; *                          ioctls in favor of a generalized approach &n; *                          using the generic cdrom driver.&n; *                     -- Fully integrated with the 2.1.X kernel.&n; *                     -- Other stuff that I forgot (lots of changes)&n; *&n; * 4.02  Dec 01, 1996  -- Applied patch from Gadi Oxman &lt;gadio@netvision.net.il&gt;&n; *                          to fix the drive door locking problems.&n; *&n; * 4.03  Dec 04, 1996  -- Added DSC overlap support.&n; * 4.04  Dec 29, 1996  -- Added CDROMREADRAW ioclt based on patch &n; *                          by Ales Makarov (xmakarov@sun.felk.cvut.cz)&n; *&n; * 4.05  Nov 20, 1997  -- Modified to print more drive info on init&n; *                        Minor other changes&n; *                        Fix errors on CDROMSTOP (If you have a &quot;Dolphin&quot;,&n; *                          you must define IHAVEADOLPHIN)&n; *                        Added identifier so new Sanyo CD-changer works&n; *                        Better detection if door locking isn&squot;t supported&n; *&n; * 4.06  Dec 17, 1997  -- fixed endless &quot;tray open&quot; messages  -ml&n; * 4.07  Dec 17, 1997  -- fallback to set pc-&gt;stat on &quot;tray open&quot;&n; * 4.08  Dec 18, 1997  -- spew less noise when tray is empty&n; *                     -- fix speed display for ACER 24X, 18X&n; * 4.09  Jan 04, 1998  -- fix handling of the last block so we return&n; *                         an end of file instead of an I/O error (Gadi)&n; * 4.10  Jan 24, 1998  -- fixed a bug so now changers can change to a new&n; *                         slot when there is no disc in the current slot.&n; *                     -- Fixed a memory leak where info-&gt;changer_info was&n; *                         malloc&squot;ed but never free&squot;d when closing the device.&n; *                     -- Cleaned up the global namespace a bit by making more&n; *                         functions static that should already have been.&n; * 4.11  Mar 12, 1998  -- Added support for the CDROM_SELECT_SPEED ioctl&n; *                         based on a patch for 2.0.33 by Jelle Foks &n; *                         &lt;jelle@scintilla.utwente.nl&gt;, a patch for 2.0.33&n; *                         by Toni Giorgino &lt;toni@pcape2.pi.infn.it&gt;, the SCSI&n; *                         version, and my own efforts.  -erik&n; *                     -- Fixed a stupid bug which egcs was kind enough to&n; *                         inform me of where &quot;Illegal mode for this track&quot;&n; *                         was never returned due to a comparison on data&n; *                         types of limited range.&n; * 4.12  Mar 29, 1998  -- Fixed bug in CDROM_SELECT_SPEED so write speed is &n; *                         now set ionly for CD-R and CD-RW drives.  I had &n; *                         removed this support because it produced errors.&n; *                         It produced errors _only_ for non-writers. duh.&n; * 4.13  May 05, 1998  -- Suppress useless &quot;in progress of becoming ready&quot;&n; *                         messages, since this is not an error.&n; *                     -- Change error messages to be const&n; *                     -- Remove a &quot;&bslash;t&quot; which looks ugly in the syslogs&n; * 4.14  July 17, 1998 -- Change to pointing to .ps version of ATAPI spec&n; *                         since the .pdf version doesn&squot;t seem to work...&n; *                     -- Updated the TODO list to something more current.&n; *&n; * 4.15  Aug 25, 1998  -- Updated ide-cd.h to respect mechine endianess, &n; *                         patch thanks to &quot;Eddie C. Dost&quot; &lt;ecd@skynet.be&gt;&n; *&n; * 4.50  Oct 19, 1998  -- New maintainers!&n; *                         Jens Axboe &lt;axboe@image.dk&gt;&n; *                         Chris Zwilling &lt;chris@cloudnet.com&gt;&n; *&n; * 4.51  Dec 23, 1998  -- Jens Axboe &lt;axboe@image.dk&gt;&n; *                      - ide_cdrom_reset enabled since the ide subsystem&n; *                         handles resets fine now. &lt;axboe@image.dk&gt;&n; *                      - Transfer size fix for Samsung CD-ROMs, thanks to&n; *                        &quot;Ville Hallik&quot; &lt;ville.hallik@mail.ee&gt;.&n; *                      - other minor stuff.&n; *&n; * 4.52  Jan 19, 1999  -- Jens Axboe &lt;axboe@image.dk&gt;&n; *                      - Detect DVD-ROM/RAM drives&n; *&n; * 4.53  Feb 22, 1999   - Include other model Samsung and one Goldstar&n; *                         drive in transfer size limit.&n; *                      - Fix the I/O error when doing eject without a medium&n; *                         loaded on some drives.&n; *                      - CDROMREADMODE2 is now implemented through&n; *                         CDROMREADRAW, since many drives don&squot;t support&n; *                         MODE2 (even though ATAPI 2.6 says they must).&n; *                      - Added ignore parameter to ide-cd (as a module), eg&n; *                         &t;insmod ide-cd ignore=&squot;hda hdb&squot;&n; *                         Useful when using ide-cd in conjunction with&n; *                         ide-scsi. TODO: non-modular way of doing the&n; *                         same.&n; *&n; * 4.54  Aug 5, 1999&t;- Support for MMC2 class commands through the generic&n; *&t;&t;&t;  packet interface to cdrom.c.&n; *&t;&t;&t;- Unified audio ioctl support, most of it.&n; *&t;&t;&t;- cleaned up various deprecated verify_area().&n; *&t;&t;&t;- Added ide_cdrom_packet() as the interface for&n; *&t;&t;&t;  the Uniform generic_packet().&n; *&t;&t;&t;- bunch of other stuff, will fill in logs later.&n; *&t;&t;&t;- report 1 slot for non-changers, like the other&n; *&t;&t;&t;  cd-rom drivers. don&squot;t report select disc for&n; *&t;&t;&t;  non-changers as well.&n; *&t;&t;&t;- mask out audio playing, if the device can&squot;t do it.&n; *&n; * 4.55  Sep 1, 1999&t;- Eliminated the rest of the audio ioctls, except&n; *&t;&t;&t;  for CDROMREADTOC[ENTRY|HEADER]. Some of the drivers&n; *&t;&t;&t;  use this independently of the actual audio handling.&n; *&t;&t;&t;  They will disappear later when I get the time to&n; *&t;&t;&t;  do it cleanly.&n; *&t;&t;&t;- Minimize the TOC reading - only do it when we&n; *&t;&t;&t;  know a media change has occured.&n; *&t;&t;&t;- Moved all the CDROMREADx ioctls to the Uniform layer.&n; *&t;&t;&t;- Heiko Eissfeldt &lt;heiko@colossus.escape.de&gt; supplied&n; *&t;&t;&t;  some fixes for CDI.&n; *&t;&t;&t;- CD-ROM leaving door locked fix from Andries&n; *&t;&t;&t;  Brouwer &lt;Andries.Brouwer@cwi.nl&gt;&n; *&t;&t;&t;- Erik Andersen &lt;andersen@xmission.com&gt; unified&n; *&t;&t;&t;  commands across the various drivers and how&n; *&t;&t;&t;  sense errors are handled.&n; *&n; * 4.56  Sep 12, 1999&t;- Removed changer support - it is now in the&n; *&t;&t;&t;  Uniform layer.&n; *&t;&t;&t;- Added partition based multisession handling.&n; *&t;&t;&t;- Mode sense and mode select moved to the&n; *&t;&t;&t;  Uniform layer.&n; *&t;&t;&t;- Fixed a problem with WPI CDS-32X drive - it&n; *&t;&t;&t;  failed the capabilities &n; *&n; * 4.57  Apr 7, 2000&t;- Fixed sense reporting.&n; *&t;&t;&t;- Fixed possible oops in ide_cdrom_get_last_session()&n; *&t;&t;&t;- Fix locking mania and make ide_cdrom_reset relock&n; *&t;&t;&t;- Stop spewing errors to log when magicdev polls with&n; *&t;&t;&t;  TEST_UNIT_READY on some drives.&n; *&t;&t;&t;- Various fixes from Tobias Ringstrom:&n; *&t;&t;&t;  tray if it was locked prior to the reset.&n; *&t;&t;&t;  - cdrom_read_capacity returns one frame too little.&n; *&t;&t;&t;  - Fix real capacity reporting.&n; *&n; * 4.58  May 1, 2000&t;- Clean up ACER50 stuff.&n; *&t;&t;&t;- Fix small problem with ide_cdrom_capacity&n; *&n; * 4.59  Aug 11, 2000&t;- Fix changer problem in cdrom_read_toc, we weren&squot;t&n; *&t;&t;&t;  correctly sensing a disc change.&n; *&t;&t;&t;- Rearranged some code&n; *&n; *************************************************************************/
DECL|macro|IDECD_VERSION
mdefine_line|#define IDECD_VERSION &quot;4.59&quot;
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/interrupt.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/byteorder.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;asm/unaligned.h&gt;
macro_line|#include &quot;ide-cd.h&quot;
multiline_comment|/****************************************************************************&n; * Generic packet command support and error handling routines.&n; */
multiline_comment|/* Mark that we&squot;ve seen a media change, and invalidate our internal&n;   buffers. */
DECL|function|cdrom_saw_media_change
r_static
r_void
id|cdrom_saw_media_change
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|1
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|0
suffix:semicolon
id|info-&gt;nsectors_buffered
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|cdrom_log_sense
r_static
r_int
id|cdrom_log_sense
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|packet_command
op_star
id|pc
comma
r_struct
id|request_sense
op_star
id|sense
)paren
(brace
r_int
id|log
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|sense
op_eq
l_int|NULL
op_logical_or
id|pc
op_eq
l_int|NULL
op_logical_or
id|pc-&gt;quiet
)paren
r_return
l_int|0
suffix:semicolon
r_switch
c_cond
(paren
id|sense-&gt;sense_key
)paren
(brace
r_case
id|NO_SENSE
suffix:colon
r_case
id|RECOVERED_ERROR
suffix:colon
r_break
suffix:semicolon
r_case
id|NOT_READY
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * don&squot;t care about tray state messages for&n;&t;&t;&t; * e.g. capacity commands or in-progress or&n;&t;&t;&t; * becoming ready&n;&t;&t;&t; */
r_if
c_cond
(paren
id|sense-&gt;asc
op_eq
l_int|0x3a
op_logical_or
id|sense-&gt;asc
op_eq
l_int|0x04
)paren
r_break
suffix:semicolon
id|log
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
id|UNIT_ATTENTION
suffix:colon
multiline_comment|/*&n;&t;&t;&t; * Make good and sure we&squot;ve seen this potential media&n;&t;&t;&t; * change. Some drives (i.e. Creative) fail to present&n;&t;&t;&t; * the correct sense key in the error register.&n;&t;&t;&t; */
id|cdrom_saw_media_change
c_func
(paren
id|drive
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|log
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|log
suffix:semicolon
)brace
r_static
DECL|function|cdrom_analyze_sense_data
r_void
id|cdrom_analyze_sense_data
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|packet_command
op_star
id|failed_command
comma
r_struct
id|request_sense
op_star
id|sense
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|cdrom_log_sense
c_func
(paren
id|drive
comma
id|failed_command
comma
id|sense
)paren
)paren
r_return
suffix:semicolon
multiline_comment|/*&n;&t; * If a read toc is executed for a CD-R or CD-RW medium where&n;&t; * the first toc has not been recorded yet, it will fail with&n;&t; * 05/24/00 (which is a confusing error)&n;&t; */
r_if
c_cond
(paren
id|failed_command
op_logical_and
id|failed_command-&gt;c
(braket
l_int|0
)braket
op_eq
id|GPCMD_READ_TOC_PMA_ATIP
)paren
r_if
c_cond
(paren
id|sense-&gt;sense_key
op_eq
l_int|0x05
op_logical_and
id|sense-&gt;asc
op_eq
l_int|0x24
)paren
r_return
suffix:semicolon
macro_line|#if VERBOSE_IDE_CD_ERRORS
(brace
r_int
id|i
suffix:semicolon
r_const
r_char
op_star
id|s
suffix:semicolon
r_char
id|buf
(braket
l_int|80
)braket
suffix:semicolon
id|printk
(paren
l_string|&quot;ATAPI device %s:&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sense-&gt;error_code
op_eq
l_int|0x70
)paren
id|printk
c_func
(paren
l_string|&quot;  Error: &quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sense-&gt;error_code
op_eq
l_int|0x71
)paren
id|printk
c_func
(paren
l_string|&quot;  Deferred Error: &quot;
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|sense-&gt;error_code
op_eq
l_int|0x7f
)paren
id|printk
c_func
(paren
l_string|&quot;  Vendor-specific Error: &quot;
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
l_string|&quot;  Unknown Error Type: &quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sense-&gt;sense_key
OL
id|ARY_LEN
c_func
(paren
id|sense_key_texts
)paren
)paren
id|s
op_assign
id|sense_key_texts
(braket
id|sense-&gt;sense_key
)braket
suffix:semicolon
r_else
id|s
op_assign
l_string|&quot;bad sense key!&quot;
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s -- (Sense key=0x%02x)&bslash;n&quot;
comma
id|s
comma
id|sense-&gt;sense_key
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sense-&gt;asc
op_eq
l_int|0x40
)paren
(brace
id|sprintf
c_func
(paren
id|buf
comma
l_string|&quot;Diagnostic failure on component 0x%02x&quot;
comma
id|sense-&gt;ascq
)paren
suffix:semicolon
id|s
op_assign
id|buf
suffix:semicolon
)brace
r_else
(brace
r_int
id|lo
op_assign
l_int|0
comma
id|mid
comma
id|hi
op_assign
id|ARY_LEN
c_func
(paren
id|sense_data_texts
)paren
suffix:semicolon
r_int
r_int
id|key
op_assign
(paren
id|sense-&gt;sense_key
op_lshift
l_int|16
)paren
suffix:semicolon
id|key
op_or_assign
(paren
id|sense-&gt;asc
op_lshift
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|sense-&gt;ascq
op_ge
l_int|0x80
op_logical_and
id|sense-&gt;ascq
op_le
l_int|0xdd
)paren
)paren
id|key
op_or_assign
id|sense-&gt;ascq
suffix:semicolon
id|s
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|hi
OG
id|lo
)paren
(brace
id|mid
op_assign
(paren
id|lo
op_plus
id|hi
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|sense_data_texts
(braket
id|mid
)braket
dot
id|asc_ascq
op_eq
id|key
op_logical_or
id|sense_data_texts
(braket
id|mid
)braket
dot
id|asc_ascq
op_eq
(paren
l_int|0xff0000
op_or
id|key
)paren
)paren
(brace
id|s
op_assign
id|sense_data_texts
(braket
id|mid
)braket
dot
id|text
suffix:semicolon
r_break
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense_data_texts
(braket
id|mid
)braket
dot
id|asc_ascq
OG
id|key
)paren
id|hi
op_assign
id|mid
suffix:semicolon
r_else
id|lo
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|s
op_eq
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|sense-&gt;asc
OG
l_int|0x80
)paren
id|s
op_assign
l_string|&quot;(vendor-specific error)&quot;
suffix:semicolon
r_else
id|s
op_assign
l_string|&quot;(reserved error code)&quot;
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;  %s -- (asc=0x%02x, ascq=0x%02x)&bslash;n&quot;
comma
id|s
comma
id|sense-&gt;asc
comma
id|sense-&gt;ascq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|failed_command
op_ne
l_int|NULL
)paren
(brace
r_int
id|lo
op_assign
l_int|0
comma
id|mid
comma
id|hi
op_assign
id|ARY_LEN
(paren
id|packet_command_texts
)paren
suffix:semicolon
id|s
op_assign
l_int|NULL
suffix:semicolon
r_while
c_loop
(paren
id|hi
OG
id|lo
)paren
(brace
id|mid
op_assign
(paren
id|lo
op_plus
id|hi
)paren
op_div
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|packet_command_texts
(braket
id|mid
)braket
dot
id|packet_command
op_eq
id|failed_command-&gt;c
(braket
l_int|0
)braket
)paren
(brace
id|s
op_assign
id|packet_command_texts
(braket
id|mid
)braket
dot
id|text
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|packet_command_texts
(braket
id|mid
)braket
dot
id|packet_command
OG
id|failed_command-&gt;c
(braket
l_int|0
)braket
)paren
id|hi
op_assign
id|mid
suffix:semicolon
r_else
id|lo
op_assign
id|mid
op_plus
l_int|1
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;  The failed &bslash;&quot;%s&bslash;&quot; packet command was: &bslash;n  &bslash;&quot;&quot;
comma
id|s
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
r_sizeof
(paren
id|failed_command-&gt;c
)paren
suffix:semicolon
id|i
op_increment
)paren
id|printk
(paren
l_string|&quot;%02x &quot;
comma
id|failed_command-&gt;c
(braket
id|i
)braket
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/* The SKSV bit specifies validity of the sense_key_specific&n;&t;&t; * in the next two commands. It is bit 7 of the first byte.&n;&t;&t; * In the case of NOT_READY, if SKSV is set the drive can&n;&t;&t; * give us nice ETA readings.&n;&t;&t; */
r_if
c_cond
(paren
id|sense-&gt;sense_key
op_eq
id|NOT_READY
op_logical_and
(paren
id|sense-&gt;sks
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
)paren
(brace
r_int
id|progress
op_assign
(paren
id|sense-&gt;sks
(braket
l_int|1
)braket
op_lshift
l_int|8
op_or
id|sense-&gt;sks
(braket
l_int|2
)braket
)paren
op_star
l_int|100
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;  Command is %02d%% complete&bslash;n&quot;
comma
id|progress
op_div
l_int|0xffff
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|sense-&gt;sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
(paren
id|sense-&gt;sks
(braket
l_int|0
)braket
op_amp
l_int|0x80
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;  Error in %s byte %d&quot;
comma
(paren
id|sense-&gt;sks
(braket
l_int|0
)braket
op_amp
l_int|0x40
)paren
op_ne
l_int|0
ques
c_cond
l_string|&quot;command packet&quot;
suffix:colon
l_string|&quot;command data&quot;
comma
(paren
id|sense-&gt;sks
(braket
l_int|1
)braket
op_lshift
l_int|8
)paren
op_plus
id|sense-&gt;sks
(braket
l_int|2
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|sense-&gt;sks
(braket
l_int|0
)braket
op_amp
l_int|0x40
)paren
op_ne
l_int|0
)paren
id|printk
(paren
l_string|&quot; bit %d&quot;
comma
id|sense-&gt;sks
(braket
l_int|0
)braket
op_amp
l_int|0x07
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
macro_line|#else /* not VERBOSE_IDE_CD_ERRORS */
multiline_comment|/* Suppress printing unit attention and `in progress of becoming ready&squot;&n;&t;   errors when we&squot;re not being verbose. */
r_if
c_cond
(paren
id|sense-&gt;sense_key
op_eq
id|UNIT_ATTENTION
op_logical_or
(paren
id|sense-&gt;sense_key
op_eq
id|NOT_READY
op_logical_and
(paren
id|sense-&gt;asc
op_eq
l_int|4
op_logical_or
id|sense-&gt;asc
op_eq
l_int|0x3a
)paren
)paren
)paren
r_return
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: error code: 0x%02x  sense_key: 0x%02x  asc: 0x%02x  ascq: 0x%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|sense-&gt;error_code
comma
id|sense-&gt;sense_key
comma
id|sense-&gt;asc
comma
id|sense-&gt;ascq
)paren
suffix:semicolon
macro_line|#endif /* not VERBOSE_IDE_CD_ERRORS */
)brace
DECL|function|cdrom_queue_request_sense
r_static
r_void
id|cdrom_queue_request_sense
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|semaphore
op_star
id|sem
comma
r_struct
id|request_sense
op_star
id|sense
comma
r_struct
id|packet_command
op_star
id|failed_command
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
op_amp
id|info-&gt;request_sense_pc
suffix:semicolon
r_struct
id|request
op_star
id|rq
suffix:semicolon
r_if
c_cond
(paren
id|sense
op_eq
l_int|NULL
)paren
id|sense
op_assign
op_amp
id|info-&gt;sense_data
suffix:semicolon
id|memset
c_func
(paren
id|pc
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|packet_command
)paren
)paren
suffix:semicolon
id|pc-&gt;c
(braket
l_int|0
)braket
op_assign
id|GPCMD_REQUEST_SENSE
suffix:semicolon
id|pc-&gt;c
(braket
l_int|4
)braket
op_assign
id|pc-&gt;buflen
op_assign
l_int|18
suffix:semicolon
id|pc-&gt;buffer
op_assign
(paren
r_char
op_star
)paren
id|sense
suffix:semicolon
id|pc-&gt;sense
op_assign
(paren
r_struct
id|request_sense
op_star
)paren
id|failed_command
suffix:semicolon
multiline_comment|/* stuff the sense request in front of our current request */
id|rq
op_assign
op_amp
id|info-&gt;request_sense_request
suffix:semicolon
id|ide_init_drive_cmd
c_func
(paren
id|rq
)paren
suffix:semicolon
id|rq-&gt;cmd
op_assign
id|REQUEST_SENSE_COMMAND
suffix:semicolon
id|rq-&gt;buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
id|rq-&gt;sem
op_assign
id|sem
suffix:semicolon
(paren
r_void
)paren
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
id|rq
comma
id|ide_preempt
)paren
suffix:semicolon
)brace
DECL|function|cdrom_end_request
r_static
r_void
id|cdrom_end_request
(paren
r_int
id|uptodate
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|REQUEST_SENSE_COMMAND
op_logical_and
id|uptodate
)paren
(brace
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|cdrom_analyze_sense_data
c_func
(paren
id|drive
comma
(paren
r_struct
id|packet_command
op_star
)paren
id|pc-&gt;sense
comma
(paren
r_struct
id|request_sense
op_star
)paren
(paren
id|pc-&gt;buffer
op_minus
id|pc-&gt;c
(braket
l_int|4
)braket
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|READ
op_logical_or
id|rq-&gt;cmd
op_eq
id|WRITE
)paren
r_if
c_cond
(paren
op_logical_neg
id|rq-&gt;current_nr_sectors
)paren
id|uptodate
op_assign
l_int|1
suffix:semicolon
id|ide_end_request
(paren
id|uptodate
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/* Returns 0 if the request should be continued.&n;   Returns 1 if the request was ended. */
DECL|function|cdrom_decode_status
r_static
r_int
id|cdrom_decode_status
(paren
id|ide_startstop_t
op_star
id|startstop
comma
id|ide_drive_t
op_star
id|drive
comma
r_int
id|good_stat
comma
r_int
op_star
id|stat_ret
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|stat
comma
id|err
comma
id|sense_key
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
suffix:semicolon
multiline_comment|/* Check for errors. */
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
op_star
id|stat_ret
op_assign
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|OK_STAT
(paren
id|stat
comma
id|good_stat
comma
id|BAD_R_STAT
)paren
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Get the IDE error register. */
id|err
op_assign
id|GET_ERR
c_func
(paren
)paren
suffix:semicolon
id|sense_key
op_assign
id|err
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|rq
op_eq
l_int|NULL
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: missing rq in cdrom_decode_status&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
op_star
id|startstop
op_assign
id|ide_stopped
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|REQUEST_SENSE_COMMAND
)paren
(brace
multiline_comment|/* We got an error trying to get sense info&n;&t;&t;   from the drive (probably while trying&n;&t;&t;   to recover from a former error).  Just give up. */
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
op_star
id|startstop
op_assign
id|ide_error
(paren
id|drive
comma
l_string|&quot;request sense failure&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|PACKET_COMMAND
)paren
(brace
multiline_comment|/* All other functions, except for READ. */
r_struct
id|semaphore
op_star
id|sem
op_assign
l_int|NULL
suffix:semicolon
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
multiline_comment|/* Check for tray open. */
r_if
c_cond
(paren
id|sense_key
op_eq
id|NOT_READY
)paren
(brace
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense_key
op_eq
id|UNIT_ATTENTION
)paren
(brace
multiline_comment|/* Check for media change. */
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/*printk(&quot;%s: media changed&bslash;n&quot;,drive-&gt;name);*/
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|pc-&gt;quiet
)paren
(brace
multiline_comment|/* Otherwise, print an error. */
id|ide_dump_status
c_func
(paren
id|drive
comma
l_string|&quot;packet command error&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* Set the error flag and complete the request.&n;&t;&t;   Then, if we have a CHECK CONDITION status,&n;&t;&t;   queue a request sense command.  We must be careful,&n;&t;&t;   though: we don&squot;t want the thread in&n;&t;&t;   cdrom_queue_packet_command to wake up until&n;&t;&t;   the request sense has completed.  We do this&n;&t;&t;   by transferring the semaphore from the packet&n;&t;&t;   command request to the request sense request. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_ne
l_int|0
)paren
(brace
id|sem
op_assign
id|rq-&gt;sem
suffix:semicolon
id|rq-&gt;sem
op_assign
l_int|NULL
suffix:semicolon
)brace
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_ne
l_int|0
)paren
id|cdrom_queue_request_sense
c_func
(paren
id|drive
comma
id|sem
comma
id|pc-&gt;sense
comma
id|pc
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Handle errors from READ and WRITE requests. */
r_if
c_cond
(paren
id|sense_key
op_eq
id|NOT_READY
)paren
(brace
multiline_comment|/* Tray open. */
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Fail the request. */
id|printk
(paren
l_string|&quot;%s: tray open&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense_key
op_eq
id|UNIT_ATTENTION
)paren
(brace
multiline_comment|/* Media change. */
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
multiline_comment|/* Arrange to retry the request.&n;&t;&t;&t;   But be sure to give up if we&squot;ve retried&n;&t;&t;&t;   too many times. */
r_if
c_cond
(paren
op_increment
id|rq-&gt;errors
OG
id|ERROR_MAX
)paren
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_or
id|sense_key
op_eq
id|DATA_PROTECT
)paren
(brace
multiline_comment|/* No point in retrying after an illegal&n;&t;&t;&t;   request or data protect error.*/
id|ide_dump_status
(paren
id|drive
comma
l_string|&quot;command error&quot;
comma
id|stat
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
id|err
op_amp
op_complement
id|ABRT_ERR
)paren
op_ne
l_int|0
)paren
(brace
multiline_comment|/* Go to the default handler&n;&t;&t;&t;   for other errors. */
op_star
id|startstop
op_assign
id|ide_error
(paren
id|drive
comma
l_string|&quot;cdrom_decode_status&quot;
comma
id|stat
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
(paren
op_increment
id|rq-&gt;errors
OG
id|ERROR_MAX
)paren
)paren
(brace
multiline_comment|/* We&squot;ve racked up too many retries.  Abort. */
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
multiline_comment|/* If we got a CHECK_CONDITION status,&n;&t;&t;   queue a request sense command. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_ne
l_int|0
)paren
id|cdrom_queue_request_sense
c_func
(paren
id|drive
comma
l_int|NULL
comma
l_int|NULL
comma
l_int|NULL
)paren
suffix:semicolon
)brace
multiline_comment|/* Retry, or handle the next request. */
op_star
id|startstop
op_assign
id|ide_stopped
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|cdrom_timer_expiry
r_static
r_int
id|cdrom_timer_expiry
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
r_int
r_int
id|wait
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n;&t; * Some commands are *slow* and normally take a long time to&n;&t; * complete. Usually we can use the ATAPI &quot;disconnect&quot; to bypass&n;&t; * this, but not all commands/drives support that. Let&n;&t; * ide_timer_expiry keep polling us for these.&n;&t; */
r_switch
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
)paren
(brace
r_case
id|GPCMD_BLANK
suffix:colon
r_case
id|GPCMD_FORMAT_UNIT
suffix:colon
r_case
id|GPCMD_RESERVE_RZONE_TRACK
suffix:colon
id|wait
op_assign
id|WAIT_CMD
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|wait
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_return
id|wait
suffix:semicolon
)brace
multiline_comment|/* Set up the device registers for transferring a packet command on DEV,&n;   expecting to later transfer XFERLEN bytes.  HANDLER is the routine&n;   which actually transfers the command to the drive.  If this is a&n;   drq_interrupt device, this routine will arrange for HANDLER to be&n;   called when the interrupt from the drive arrives.  Otherwise, HANDLER&n;   will be called immediately after the drive is prepared for the transfer. */
DECL|function|cdrom_start_packet_command
r_static
id|ide_startstop_t
id|cdrom_start_packet_command
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|xferlen
comma
id|ide_handler_t
op_star
id|handler
)paren
(brace
id|ide_startstop_t
id|startstop
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
multiline_comment|/* Wait for the controller to be idle. */
r_if
c_cond
(paren
id|ide_wait_stat
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
l_int|0
comma
id|BUSY_STAT
comma
id|WAIT_READY
)paren
)paren
r_return
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;dma
)paren
(brace
r_if
c_cond
(paren
id|info-&gt;cmd
op_eq
id|READ
)paren
(brace
id|info-&gt;dma
op_assign
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_read
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|info-&gt;cmd
op_eq
id|WRITE
)paren
(brace
id|info-&gt;dma
op_assign
op_logical_neg
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_write
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
(brace
id|printk
c_func
(paren
l_string|&quot;ide-cd: DMA set, but not allowed&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Set up the controller registers. */
id|OUT_BYTE
(paren
id|info-&gt;dma
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
l_int|0
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
l_int|0
comma
id|IDE_SECTOR_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|xferlen
op_amp
l_int|0xff
comma
id|IDE_LCYL_REG
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|xferlen
op_rshift
l_int|8
comma
id|IDE_HCYL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|IDE_CONTROL_REG
)paren
id|OUT_BYTE
(paren
id|drive-&gt;ctl
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;dma
)paren
(paren
r_void
)paren
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_begin
comma
id|drive
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
)paren
(brace
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|WAIT_CMD
comma
id|cdrom_timer_expiry
)paren
suffix:semicolon
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* packet command */
r_return
id|ide_started
suffix:semicolon
)brace
r_else
(brace
id|OUT_BYTE
(paren
id|WIN_PACKETCMD
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
multiline_comment|/* packet command */
r_return
(paren
op_star
id|handler
)paren
(paren
id|drive
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* Send a packet command to DRIVE described by CMD_BUF and CMD_LEN.&n;   The device registers must have already been prepared&n;   by cdrom_start_packet_command.&n;   HANDLER is the interrupt handler to call when the command completes&n;   or there&squot;s data ready. */
multiline_comment|/*&n; * changed 5 parameters to 3 for dvd-ram&n; * struct packet_command *pc; now packet_command_t *pc;&n; */
DECL|macro|CLASSIC_PACKET_STRUCT
macro_line|#undef CLASSIC_PACKET_STRUCT
DECL|function|cdrom_transfer_packet_command
r_static
id|ide_startstop_t
id|cdrom_transfer_packet_command
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|packet_command
op_star
id|pc
comma
id|ide_handler_t
op_star
id|handler
)paren
(brace
macro_line|#ifdef CLASSIC_PACKET_STRUCT
r_int
r_char
op_star
id|cmd_buf
op_assign
id|pc-&gt;c
suffix:semicolon
r_int
id|cmd_len
op_assign
r_sizeof
(paren
id|pc-&gt;c
)paren
suffix:semicolon
r_int
r_int
id|timeout
op_assign
id|pc-&gt;timeout
suffix:semicolon
macro_line|#endif
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
)paren
(brace
multiline_comment|/* Here we should have been called after receiving an interrupt&n;&t;&t;   from the device.  DRQ should how be set. */
r_int
id|stat_dum
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DRQ_STAT
comma
op_amp
id|stat_dum
)paren
)paren
r_return
id|startstop
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, we must wait for DRQ to get set. */
r_if
c_cond
(paren
id|ide_wait_stat
(paren
op_amp
id|startstop
comma
id|drive
comma
id|DRQ_STAT
comma
id|BUSY_STAT
comma
id|WAIT_READY
)paren
)paren
r_return
id|startstop
suffix:semicolon
)brace
multiline_comment|/* Arm the interrupt handler. */
macro_line|#ifdef CLASSIC_PACKET_STRUCT
multiline_comment|/* Arm the interrupt handler. */
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|timeout
comma
id|cdrom_timer_expiry
)paren
suffix:semicolon
multiline_comment|/* Send the command to the device. */
id|atapi_output_bytes
(paren
id|drive
comma
id|cmd_buf
comma
id|cmd_len
)paren
suffix:semicolon
macro_line|#else /* !CLASSIC_PACKET_STRUCT */
multiline_comment|/* Arm the interrupt handler. */
singleline_comment|//&t;ide_set_handler (drive, handler, (unsigned int) pc-&gt;timeout, cdrom_timer_expiry);
id|ide_set_handler
(paren
id|drive
comma
id|handler
comma
id|pc-&gt;timeout
comma
id|cdrom_timer_expiry
)paren
suffix:semicolon
multiline_comment|/* Send the command to the device. */
singleline_comment|//&t;atapi_output_bytes (drive, (void *)pc-&gt;c, (unsigned int) sizeof(pc-&gt;c));
id|atapi_output_bytes
(paren
id|drive
comma
id|pc-&gt;c
comma
r_sizeof
(paren
id|pc-&gt;c
)paren
)paren
suffix:semicolon
macro_line|#endif /* CLASSIC_PACKET_STRUCT */
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; * Block read functions.&n; */
multiline_comment|/*&n; * Buffer up to SECTORS_TO_TRANSFER sectors from the drive in our sector&n; * buffer.  Once the first sector is added, any subsequent sectors are&n; * assumed to be continuous (until the buffer is cleared).  For the first&n; * sector added, SECTOR is its sector number.  (SECTOR is then ignored until&n; * the buffer is cleared.)&n; */
DECL|function|cdrom_buffer_sectors
r_static
r_void
id|cdrom_buffer_sectors
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|sector
comma
r_int
id|sectors_to_transfer
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
multiline_comment|/* Number of sectors to read into the buffer. */
r_int
id|sectors_to_buffer
op_assign
id|MIN
(paren
id|sectors_to_transfer
comma
(paren
id|SECTOR_BUFFER_SIZE
op_rshift
id|SECTOR_BITS
)paren
op_minus
id|info-&gt;nsectors_buffered
)paren
suffix:semicolon
r_char
op_star
id|dest
suffix:semicolon
multiline_comment|/* If we couldn&squot;t get a buffer, don&squot;t try to buffer anything... */
r_if
c_cond
(paren
id|info-&gt;buffer
op_eq
l_int|NULL
)paren
id|sectors_to_buffer
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* If this is the first sector in the buffer, remember its number. */
r_if
c_cond
(paren
id|info-&gt;nsectors_buffered
op_eq
l_int|0
)paren
id|info-&gt;sector_buffered
op_assign
id|sector
suffix:semicolon
multiline_comment|/* Read the data into the buffer. */
id|dest
op_assign
id|info-&gt;buffer
op_plus
id|info-&gt;nsectors_buffered
op_star
id|SECTOR_SIZE
suffix:semicolon
r_while
c_loop
(paren
id|sectors_to_buffer
OG
l_int|0
)paren
(brace
id|atapi_input_bytes
(paren
id|drive
comma
id|dest
comma
id|SECTOR_SIZE
)paren
suffix:semicolon
op_decrement
id|sectors_to_buffer
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
op_increment
id|info-&gt;nsectors_buffered
suffix:semicolon
id|dest
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
)brace
multiline_comment|/* Throw away any remaining data. */
r_while
c_loop
(paren
id|sectors_to_transfer
OG
l_int|0
)paren
(brace
r_char
id|dum
(braket
id|SECTOR_SIZE
)braket
suffix:semicolon
id|atapi_input_bytes
(paren
id|drive
comma
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Check the contents of the interrupt reason register from the cdrom&n; * and attempt to recover if there are problems.  Returns  0 if everything&squot;s&n; * ok; nonzero if the request has been terminated.&n; */
r_static
r_inline
DECL|function|cdrom_read_check_ireason
r_int
id|cdrom_read_check_ireason
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|len
comma
r_int
id|ireason
)paren
(brace
id|ireason
op_and_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|ireason
op_eq
l_int|2
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|ireason
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Whoops... The drive is expecting to receive data from us! */
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: &quot;
l_string|&quot;Drive wants to transfer data the wrong way!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Throw some data at the drive so it doesn&squot;t hang&n;&t;&t;   and quit this request. */
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|atapi_output_bytes
(paren
id|drive
comma
op_amp
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
id|dum
)paren
suffix:semicolon
)brace
)brace
r_else
r_if
c_cond
(paren
id|ireason
op_eq
l_int|1
)paren
(brace
multiline_comment|/* Some drives (ASUS) seem to tell us that status&n;&t;&t; * info is available. just get it and ignore.&n;&t;&t; */
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Drive wants a command packet, or invalid ireason... */
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: bad interrupt reason %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|ireason
)paren
suffix:semicolon
)brace
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Interrupt routine.  Called when a read request has completed.&n; */
DECL|function|cdrom_read_intr
r_static
id|ide_startstop_t
id|cdrom_read_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|stat
suffix:semicolon
r_int
id|ireason
comma
id|len
comma
id|sectors_to_transfer
comma
id|nskip
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|i
comma
id|dma
op_assign
id|info-&gt;dma
comma
id|dma_error
op_assign
l_int|0
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|dma
)paren
(brace
id|info-&gt;dma
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dma_error
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_end
comma
id|drive
)paren
)paren
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off
comma
id|drive
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
op_amp
id|startstop
comma
id|drive
comma
l_int|0
comma
op_amp
id|stat
)paren
)paren
r_return
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|dma
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|dma_error
)paren
(brace
r_for
c_loop
(paren
id|i
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|i
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
r_else
r_return
id|ide_error
(paren
id|drive
comma
l_string|&quot;dma error&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the interrupt reason and the transfer length. */
id|ireason
op_assign
id|IN_BYTE
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|len
op_assign
id|IN_BYTE
(paren
id|IDE_LCYL_REG
)paren
op_plus
l_int|256
op_star
id|IN_BYTE
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/* If DRQ is clear, the command has completed. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* If we&squot;re not done filling the current buffer, complain.&n;&t;&t;   Otherwise, complete the command normally. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
OG
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: data underrun (%ld blocks)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/* Check that the drive is expecting to do the same thing we are. */
r_if
c_cond
(paren
id|cdrom_read_check_ireason
(paren
id|drive
comma
id|len
comma
id|ireason
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* Assume that the drive will always provide data in multiples&n;&t;   of at least SECTOR_SIZE, as it gets hairy to keep track&n;&t;   of the transfers otherwise. */
r_if
c_cond
(paren
(paren
id|len
op_mod
id|SECTOR_SIZE
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_intr: Bad transfer size %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|len
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|limit_nframes
)paren
id|printk
(paren
l_string|&quot;  This drive is not supported by this version of the driver&bslash;n&quot;
)paren
suffix:semicolon
r_else
(brace
id|printk
(paren
l_string|&quot;  Trying to limit transfer sizes&bslash;n&quot;
)paren
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|limit_nframes
op_assign
l_int|1
suffix:semicolon
)brace
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/* The number of sectors we need to read from the drive. */
id|sectors_to_transfer
op_assign
id|len
op_div
id|SECTOR_SIZE
suffix:semicolon
multiline_comment|/* First, figure out if we need to bit-bucket&n;&t;   any of the leading sectors. */
id|nskip
op_assign
id|MIN
(paren
(paren
r_int
)paren
(paren
id|rq-&gt;current_nr_sectors
op_minus
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
)paren
comma
id|sectors_to_transfer
)paren
suffix:semicolon
r_while
c_loop
(paren
id|nskip
OG
l_int|0
)paren
(brace
multiline_comment|/* We need to throw away a sector. */
r_char
id|dum
(braket
id|SECTOR_SIZE
)braket
suffix:semicolon
id|atapi_input_bytes
(paren
id|drive
comma
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_decrement
id|nskip
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
multiline_comment|/* Now loop while we still have data to read from the drive. */
r_while
c_loop
(paren
id|sectors_to_transfer
OG
l_int|0
)paren
(brace
r_int
id|this_transfer
suffix:semicolon
multiline_comment|/* If we&squot;ve filled the present buffer but there&squot;s another&n;&t;&t;   chained buffer after it, move on. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
op_logical_and
id|rq-&gt;nr_sectors
OG
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* If the buffers are full, cache the rest of the data in our&n;&t;&t;   internal buffer. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
(brace
id|cdrom_buffer_sectors
c_func
(paren
id|drive
comma
id|rq-&gt;sector
comma
id|sectors_to_transfer
)paren
suffix:semicolon
id|sectors_to_transfer
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Transfer data to the buffers.&n;&t;&t;&t;   Figure out how many sectors we can transfer&n;&t;&t;&t;   to the current buffer. */
id|this_transfer
op_assign
id|MIN
(paren
id|sectors_to_transfer
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
multiline_comment|/* Read this_transfer sectors&n;&t;&t;&t;   into the current buffer. */
r_while
c_loop
(paren
id|this_transfer
OG
l_int|0
)paren
(brace
id|atapi_input_bytes
c_func
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|SECTOR_SIZE
)paren
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
op_decrement
id|rq-&gt;nr_sectors
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_increment
id|rq-&gt;sector
suffix:semicolon
op_decrement
id|this_transfer
suffix:semicolon
op_decrement
id|sectors_to_transfer
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/* Done moving data!&n;&t;   Wait for another interrupt. */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|cdrom_read_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
multiline_comment|/*&n; * Try to satisfy some of the current read request from our cached data.&n; * Returns nonzero if the request has been completed, zero otherwise.&n; */
DECL|function|cdrom_read_from_buffer
r_static
r_int
id|cdrom_read_from_buffer
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
multiline_comment|/* Can&squot;t do anything if there&squot;s no buffer. */
r_if
c_cond
(paren
id|info-&gt;buffer
op_eq
l_int|NULL
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* Loop while this request needs data and the next block is present&n;&t;   in our cache. */
r_while
c_loop
(paren
id|rq-&gt;nr_sectors
OG
l_int|0
op_logical_and
id|rq-&gt;sector
op_ge
id|info-&gt;sector_buffered
op_logical_and
id|rq-&gt;sector
OL
id|info-&gt;sector_buffered
op_plus
id|info-&gt;nsectors_buffered
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
id|memcpy
(paren
id|rq-&gt;buffer
comma
id|info-&gt;buffer
op_plus
(paren
id|rq-&gt;sector
op_minus
id|info-&gt;sector_buffered
)paren
op_star
id|SECTOR_SIZE
comma
id|SECTOR_SIZE
)paren
suffix:semicolon
id|rq-&gt;buffer
op_add_assign
id|SECTOR_SIZE
suffix:semicolon
op_decrement
id|rq-&gt;current_nr_sectors
suffix:semicolon
op_decrement
id|rq-&gt;nr_sectors
suffix:semicolon
op_increment
id|rq-&gt;sector
suffix:semicolon
)brace
multiline_comment|/* If we&squot;ve satisfied the current request,&n;&t;   terminate it successfully. */
r_if
c_cond
(paren
id|rq-&gt;nr_sectors
op_eq
l_int|0
)paren
(brace
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Move on to the next buffer if needed. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
multiline_comment|/* If this condition does not hold, then the kluge i use to&n;&t;   represent the number of sectors to skip at the start of a transfer&n;&t;   will fail.  I think that this will never happen, but let&squot;s be&n;&t;   paranoid and check. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
OL
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
op_logical_and
(paren
id|rq-&gt;sector
op_mod
id|SECTORS_PER_FRAME
)paren
op_ne
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_read_from_buffer: buffer botch (%ld)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;sector
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Routine to send a read packet command to the drive.&n; * This is usually called directly from cdrom_start_read.&n; * However, for drq_interrupt devices, it is called from an interrupt&n; * when the drive is ready to accept the command.&n; */
DECL|function|cdrom_start_read_continuation
r_static
id|ide_startstop_t
id|cdrom_start_read_continuation
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|nsect
comma
id|sector
comma
id|nframes
comma
id|frame
comma
id|nskip
suffix:semicolon
multiline_comment|/* Number of sectors to transfer. */
id|nsect
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
multiline_comment|/* Starting sector. */
id|sector
op_assign
id|rq-&gt;sector
suffix:semicolon
multiline_comment|/* If the requested sector doesn&squot;t start on a cdrom block boundary,&n;&t;   we must adjust the start of the transfer so that it does,&n;&t;   and remember to skip the first few sectors.&n;&t;   If the CURRENT_NR_SECTORS field is larger than the size&n;&t;   of the buffer, it will mean that we&squot;re to skip a number&n;&t;   of sectors equal to the amount by which CURRENT_NR_SECTORS&n;&t;   is larger than the buffer size. */
id|nskip
op_assign
(paren
id|sector
op_mod
id|SECTORS_PER_FRAME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nskip
OG
l_int|0
)paren
(brace
multiline_comment|/* Sanity check... */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_ne
(paren
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
)paren
op_logical_and
(paren
id|rq-&gt;sector
op_mod
id|CD_FRAMESIZE
op_ne
l_int|0
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_start_read_continuation: buffer botch (%lu)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|cdrom_end_request
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
id|sector
op_sub_assign
id|nskip
suffix:semicolon
id|nsect
op_add_assign
id|nskip
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_add_assign
id|nskip
suffix:semicolon
)brace
multiline_comment|/* Convert from sectors to cdrom blocks, rounding up the transfer&n;&t;   length if needed. */
id|nframes
op_assign
(paren
id|nsect
op_plus
id|SECTORS_PER_FRAME
op_minus
l_int|1
)paren
op_div
id|SECTORS_PER_FRAME
suffix:semicolon
id|frame
op_assign
id|sector
op_div
id|SECTORS_PER_FRAME
suffix:semicolon
multiline_comment|/* Largest number of frames was can transfer at once is 64k-1. For&n;&t;   some drives we need to limit this even more. */
id|nframes
op_assign
id|MIN
(paren
id|nframes
comma
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|limit_nframes
)paren
ques
c_cond
(paren
l_int|65534
op_div
id|CD_FRAMESIZE
)paren
suffix:colon
l_int|65535
)paren
suffix:semicolon
multiline_comment|/* Set up the command */
id|memset
(paren
op_amp
id|pc.c
comma
l_int|0
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_10
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|nframes
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|nframes
op_amp
l_int|0xff
)paren
suffix:semicolon
id|put_unaligned
c_func
(paren
id|cpu_to_be32
c_func
(paren
id|frame
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|pc.timeout
op_assign
id|WAIT_CMD
suffix:semicolon
multiline_comment|/* Send the command to the drive and return. */
r_return
id|cdrom_transfer_packet_command
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
op_amp
id|cdrom_read_intr
)paren
suffix:semicolon
)brace
DECL|macro|IDECD_SEEK_THRESHOLD
mdefine_line|#define IDECD_SEEK_THRESHOLD&t;(1000)&t;&t;&t;/* 1000 blocks */
DECL|macro|IDECD_SEEK_TIMER
mdefine_line|#define IDECD_SEEK_TIMER&t;(5 * WAIT_MIN_SLEEP)&t;/* 100 ms */
DECL|macro|IDECD_SEEK_TIMEOUT
mdefine_line|#define IDECD_SEEK_TIMEOUT     WAIT_CMD&t;&t;&t;/* 10 sec */
DECL|function|cdrom_seek_intr
r_static
id|ide_startstop_t
id|cdrom_seek_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_static
r_int
id|retry
op_assign
l_int|10
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
op_amp
id|startstop
comma
id|drive
comma
l_int|0
comma
op_amp
id|stat
)paren
)paren
r_return
id|startstop
suffix:semicolon
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|seeking
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|retry
op_logical_and
id|jiffies
op_minus
id|info-&gt;start_seek
OG
id|IDECD_SEEK_TIMER
)paren
(brace
r_if
c_cond
(paren
op_decrement
id|retry
op_eq
l_int|0
)paren
(brace
multiline_comment|/*&n;&t;&t;&t; * this condition is far too common, to bother&n;&t;&t;&t; * users about it&n;&t;&t;&t; */
macro_line|#if 0
id|printk
c_func
(paren
l_string|&quot;%s: disabled DSC seek overlap&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
macro_line|#endif
id|drive-&gt;dsc_overlap
op_assign
l_int|0
suffix:semicolon
)brace
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
DECL|function|cdrom_start_seek_continuation
r_static
id|ide_startstop_t
id|cdrom_start_seek_continuation
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|sector
comma
id|frame
comma
id|nskip
suffix:semicolon
id|sector
op_assign
id|rq-&gt;sector
suffix:semicolon
id|nskip
op_assign
(paren
id|sector
op_mod
id|SECTORS_PER_FRAME
)paren
suffix:semicolon
r_if
c_cond
(paren
id|nskip
OG
l_int|0
)paren
id|sector
op_sub_assign
id|nskip
suffix:semicolon
id|frame
op_assign
id|sector
op_div
id|SECTORS_PER_FRAME
suffix:semicolon
id|memset
(paren
op_amp
id|pc.c
comma
l_int|0
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|GPCMD_SEEK
suffix:semicolon
id|put_unaligned
c_func
(paren
id|cpu_to_be32
c_func
(paren
id|frame
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|pc.timeout
op_assign
id|WAIT_CMD
suffix:semicolon
r_return
id|cdrom_transfer_packet_command
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
op_amp
id|cdrom_seek_intr
)paren
suffix:semicolon
)brace
DECL|function|cdrom_start_seek
r_static
id|ide_startstop_t
id|cdrom_start_seek
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|info-&gt;dma
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cmd
op_assign
l_int|0
suffix:semicolon
id|info-&gt;start_seek
op_assign
id|jiffies
suffix:semicolon
r_return
id|cdrom_start_packet_command
(paren
id|drive
comma
l_int|0
comma
id|cdrom_start_seek_continuation
)paren
suffix:semicolon
)brace
multiline_comment|/* Fix up a possibly partially-processed request so that we can&n;   start it over entirely, or even put it back on the request queue. */
DECL|function|restore_request
r_static
r_void
id|restore_request
(paren
r_struct
id|request
op_star
id|rq
)paren
(brace
r_if
c_cond
(paren
id|rq-&gt;buffer
op_ne
id|rq-&gt;bh-&gt;b_data
)paren
(brace
r_int
id|n
op_assign
(paren
id|rq-&gt;buffer
op_minus
id|rq-&gt;bh-&gt;b_data
)paren
op_div
id|SECTOR_SIZE
suffix:semicolon
id|rq-&gt;buffer
op_assign
id|rq-&gt;bh-&gt;b_data
suffix:semicolon
id|rq-&gt;nr_sectors
op_add_assign
id|n
suffix:semicolon
id|rq-&gt;sector
op_sub_assign
id|n
suffix:semicolon
)brace
id|rq-&gt;current_nr_sectors
op_assign
id|rq-&gt;bh-&gt;b_size
op_rshift
id|SECTOR_BITS
suffix:semicolon
)brace
multiline_comment|/*&n; * Start a read request from the CD-ROM.&n; */
DECL|function|cdrom_start_read
r_static
id|ide_startstop_t
id|cdrom_start_read
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
r_int
id|block
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|minor
op_assign
id|MINOR
(paren
id|rq-&gt;rq_dev
)paren
suffix:semicolon
multiline_comment|/* If the request is relative to a partition, fix it up to refer to the&n;&t;   absolute address.  */
r_if
c_cond
(paren
(paren
id|minor
op_amp
id|PARTN_MASK
)paren
op_ne
l_int|0
)paren
(brace
id|rq-&gt;sector
op_assign
id|block
suffix:semicolon
id|minor
op_and_assign
op_complement
id|PARTN_MASK
suffix:semicolon
id|rq-&gt;rq_dev
op_assign
id|MKDEV
(paren
id|MAJOR
c_func
(paren
id|rq-&gt;rq_dev
)paren
comma
id|minor
)paren
suffix:semicolon
)brace
multiline_comment|/* We may be retrying this request after an error.  Fix up&n;&t;   any weirdness which might be present in the request packet. */
id|restore_request
(paren
id|rq
)paren
suffix:semicolon
multiline_comment|/* Satisfy whatever we can of this request from our cached sector. */
r_if
c_cond
(paren
id|cdrom_read_from_buffer
c_func
(paren
id|drive
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* Clear the local sector buffer. */
id|info-&gt;nsectors_buffered
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* use dma, if possible. */
r_if
c_cond
(paren
id|drive-&gt;using_dma
op_logical_and
(paren
id|rq-&gt;sector
op_mod
id|SECTORS_PER_FRAME
op_eq
l_int|0
)paren
op_logical_and
(paren
id|rq-&gt;nr_sectors
op_mod
id|SECTORS_PER_FRAME
op_eq
l_int|0
)paren
)paren
id|info-&gt;dma
op_assign
l_int|1
suffix:semicolon
r_else
id|info-&gt;dma
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cmd
op_assign
id|READ
suffix:semicolon
multiline_comment|/* Start sending the read request to the drive. */
r_return
id|cdrom_start_packet_command
c_func
(paren
id|drive
comma
l_int|32768
comma
id|cdrom_start_read_continuation
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; * Execute all other packet commands.&n; */
multiline_comment|/* Forward declarations. */
r_static
r_int
id|cdrom_lockdoor
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lockflag
comma
r_struct
id|request_sense
op_star
id|sense
)paren
suffix:semicolon
multiline_comment|/* Interrupt routine for packet command completion. */
DECL|function|cdrom_pc_intr
r_static
id|ide_startstop_t
id|cdrom_pc_intr
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|ireason
comma
id|len
comma
id|stat
comma
id|thislen
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|cdrom_decode_status
(paren
op_amp
id|startstop
comma
id|drive
comma
l_int|0
comma
op_amp
id|stat
)paren
)paren
r_return
id|startstop
suffix:semicolon
multiline_comment|/* Read the interrupt reason and the transfer length. */
id|ireason
op_assign
id|IN_BYTE
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|len
op_assign
id|IN_BYTE
(paren
id|IDE_LCYL_REG
)paren
op_plus
l_int|256
op_star
id|IN_BYTE
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/* If DRQ is clear, the command has completed.&n;&t;   Complain if we still have data left to transfer. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Some of the trailing request sense fields are optional, and&n;&t;&t;   some drives don&squot;t send them.  Sigh. */
r_if
c_cond
(paren
id|pc-&gt;c
(braket
l_int|0
)braket
op_eq
id|GPCMD_REQUEST_SENSE
op_logical_and
id|pc-&gt;buflen
OG
l_int|0
op_logical_and
id|pc-&gt;buflen
op_le
l_int|5
)paren
(brace
r_while
c_loop
(paren
id|pc-&gt;buflen
OG
l_int|0
)paren
(brace
op_star
id|pc-&gt;buffer
op_increment
op_assign
l_int|0
suffix:semicolon
op_decrement
id|pc-&gt;buflen
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|pc-&gt;buflen
op_eq
l_int|0
)paren
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_else
(brace
multiline_comment|/* Comment this out, because this always happens &n;&t;&t;&t;   right after a reset occurs, and it is annoying to &n;&t;&t;&t;   always print expected stuff.  */
multiline_comment|/*&n;&t;&t;&t;printk (&quot;%s: cdrom_pc_intr: data underrun %d&bslash;n&quot;,&n;&t;&t;&t;&t;drive-&gt;name, pc-&gt;buflen);&n;&t;&t;&t;*/
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
id|cdrom_end_request
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/* Figure out how much data to transfer. */
id|thislen
op_assign
id|pc-&gt;buflen
suffix:semicolon
r_if
c_cond
(paren
id|thislen
OG
id|len
)paren
id|thislen
op_assign
id|len
suffix:semicolon
multiline_comment|/* The drive wants to be written to. */
r_if
c_cond
(paren
(paren
id|ireason
op_amp
l_int|3
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* Transfer the data. */
id|atapi_output_bytes
(paren
id|drive
comma
id|pc-&gt;buffer
comma
id|thislen
)paren
suffix:semicolon
multiline_comment|/* If we haven&squot;t moved enough data to satisfy the drive,&n;&t;&t;   add some padding. */
r_while
c_loop
(paren
id|len
OG
id|thislen
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|atapi_output_bytes
(paren
id|drive
comma
op_amp
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
id|dum
)paren
suffix:semicolon
)brace
multiline_comment|/* Keep count of how much data we&squot;ve moved. */
id|pc-&gt;buffer
op_add_assign
id|thislen
suffix:semicolon
id|pc-&gt;buflen
op_sub_assign
id|thislen
suffix:semicolon
)brace
multiline_comment|/* Same drill for reading. */
r_else
r_if
c_cond
(paren
(paren
id|ireason
op_amp
l_int|3
)paren
op_eq
l_int|2
)paren
(brace
multiline_comment|/* Transfer the data. */
id|atapi_input_bytes
(paren
id|drive
comma
id|pc-&gt;buffer
comma
id|thislen
)paren
suffix:semicolon
multiline_comment|/* If we haven&squot;t moved enough data to satisfy the drive,&n;&t;&t;   add some padding. */
r_while
c_loop
(paren
id|len
OG
id|thislen
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|atapi_input_bytes
(paren
id|drive
comma
op_amp
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
id|dum
)paren
suffix:semicolon
)brace
multiline_comment|/* Keep count of how much data we&squot;ve moved. */
id|pc-&gt;buffer
op_add_assign
id|thislen
suffix:semicolon
id|pc-&gt;buflen
op_sub_assign
id|thislen
suffix:semicolon
)brace
r_else
(brace
id|printk
(paren
l_string|&quot;%s: cdrom_pc_intr: The drive &quot;
l_string|&quot;appears confused (ireason = 0x%2x)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|ireason
)paren
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Now we wait for another interrupt. */
id|ide_set_handler
(paren
id|drive
comma
op_amp
id|cdrom_pc_intr
comma
id|WAIT_CMD
comma
id|cdrom_timer_expiry
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|cdrom_do_pc_continuation
r_static
id|ide_startstop_t
id|cdrom_do_pc_continuation
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pc-&gt;timeout
)paren
id|pc-&gt;timeout
op_assign
id|WAIT_CMD
suffix:semicolon
multiline_comment|/* Send the command to the drive and return. */
r_return
id|cdrom_transfer_packet_command
c_func
(paren
id|drive
comma
id|pc
comma
op_amp
id|cdrom_pc_intr
)paren
suffix:semicolon
)brace
DECL|function|cdrom_do_packet_command
r_static
id|ide_startstop_t
id|cdrom_do_packet_command
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|len
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|packet_command
op_star
id|pc
op_assign
(paren
r_struct
id|packet_command
op_star
)paren
id|rq-&gt;buffer
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|info-&gt;dma
op_assign
l_int|0
suffix:semicolon
id|info-&gt;cmd
op_assign
l_int|0
suffix:semicolon
id|pc-&gt;stat
op_assign
l_int|0
suffix:semicolon
id|len
op_assign
id|pc-&gt;buflen
suffix:semicolon
multiline_comment|/* Start sending the command to the drive. */
r_return
id|cdrom_start_packet_command
(paren
id|drive
comma
id|len
comma
id|cdrom_do_pc_continuation
)paren
suffix:semicolon
)brace
multiline_comment|/* Sleep for TIME jiffies.&n;   Not to be called from an interrupt handler. */
r_static
DECL|function|cdrom_sleep
r_void
id|cdrom_sleep
(paren
r_int
id|time
)paren
(brace
r_int
id|sleep
op_assign
id|time
suffix:semicolon
r_do
(brace
id|set_current_state
c_func
(paren
id|TASK_INTERRUPTIBLE
)paren
suffix:semicolon
id|sleep
op_assign
id|schedule_timeout
c_func
(paren
id|sleep
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
id|sleep
)paren
suffix:semicolon
)brace
r_static
DECL|function|cdrom_queue_packet_command
r_int
id|cdrom_queue_packet_command
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|packet_command
op_star
id|pc
)paren
(brace
r_struct
id|request_sense
id|sense
suffix:semicolon
r_struct
id|request
id|req
suffix:semicolon
r_int
id|retries
op_assign
l_int|10
suffix:semicolon
r_if
c_cond
(paren
id|pc-&gt;sense
op_eq
l_int|NULL
)paren
id|pc-&gt;sense
op_assign
op_amp
id|sense
suffix:semicolon
multiline_comment|/* Start of retry loop. */
r_do
(brace
id|ide_init_drive_cmd
(paren
op_amp
id|req
)paren
suffix:semicolon
id|req.cmd
op_assign
id|PACKET_COMMAND
suffix:semicolon
id|req.buffer
op_assign
(paren
r_char
op_star
)paren
id|pc
suffix:semicolon
r_if
c_cond
(paren
id|ide_do_drive_cmd
(paren
id|drive
comma
op_amp
id|req
comma
id|ide_wait
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: do_drive_cmd returned stat=%02x,err=%02x&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|req.buffer
(braket
l_int|0
)braket
comma
id|req.buffer
(braket
l_int|1
)braket
)paren
suffix:semicolon
multiline_comment|/* FIXME: we should probably abort/retry or something */
)brace
r_if
c_cond
(paren
id|pc-&gt;stat
op_ne
l_int|0
)paren
(brace
multiline_comment|/* The request failed.  Retry if it was due to a unit&n;&t;&t;&t;   attention status&n;&t;&t;&t;   (usually means media was changed). */
r_struct
id|request_sense
op_star
id|reqbuf
op_assign
id|pc-&gt;sense
suffix:semicolon
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|UNIT_ATTENTION
)paren
id|cdrom_saw_media_change
(paren
id|drive
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|reqbuf-&gt;sense_key
op_eq
id|NOT_READY
op_logical_and
id|reqbuf-&gt;asc
op_eq
l_int|4
op_logical_and
id|reqbuf-&gt;ascq
op_ne
l_int|4
)paren
(brace
multiline_comment|/* The drive is in the process of loading&n;&t;&t;&t;&t;   a disk.  Retry, but wait a little to give&n;&t;&t;&t;&t;   the drive time to complete the load. */
id|cdrom_sleep
c_func
(paren
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* Otherwise, don&squot;t retry. */
id|retries
op_assign
l_int|0
suffix:semicolon
)brace
op_decrement
id|retries
suffix:semicolon
)brace
multiline_comment|/* End of retry loop. */
)brace
r_while
c_loop
(paren
id|pc-&gt;stat
op_ne
l_int|0
op_logical_and
id|retries
op_ge
l_int|0
)paren
suffix:semicolon
multiline_comment|/* Return an error if the command failed. */
r_return
id|pc-&gt;stat
ques
c_cond
op_minus
id|EIO
suffix:colon
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Write handling&n; */
DECL|function|cdrom_write_check_ireason
r_static
r_inline
r_int
id|cdrom_write_check_ireason
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|len
comma
r_int
id|ireason
)paren
(brace
multiline_comment|/* Two notes about IDE interrupt reason here - 0 means that&n;&t; * the drive wants to receive data from us, 2 means that&n;&t; * the drive is expecting data from us.&n;&t; */
id|ireason
op_and_assign
l_int|3
suffix:semicolon
r_if
c_cond
(paren
id|ireason
op_eq
l_int|2
)paren
(brace
multiline_comment|/* Whoops... The drive wants to send data. */
id|printk
c_func
(paren
l_string|&quot;%s: cdrom_write_intr: wrong transfer direction!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
multiline_comment|/* Throw some data at the drive so it doesn&squot;t hang&n;&t;&t;   and quit this request. */
r_while
c_loop
(paren
id|len
OG
l_int|0
)paren
(brace
r_int
id|dum
op_assign
l_int|0
suffix:semicolon
id|atapi_output_bytes
c_func
(paren
id|drive
comma
op_amp
id|dum
comma
r_sizeof
(paren
id|dum
)paren
)paren
suffix:semicolon
id|len
op_sub_assign
r_sizeof
(paren
id|dum
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
multiline_comment|/* Drive wants a command packet, or invalid ireason... */
id|printk
c_func
(paren
l_string|&quot;%s: cdrom_write_intr: bad interrupt reason %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|ireason
)paren
suffix:semicolon
)brace
id|cdrom_end_request
c_func
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
DECL|function|cdrom_write_intr
r_static
id|ide_startstop_t
id|cdrom_write_intr
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|stat
comma
id|ireason
comma
id|len
comma
id|sectors_to_transfer
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|i
comma
id|dma_error
op_assign
l_int|0
comma
id|dma
op_assign
id|info-&gt;dma
suffix:semicolon
id|ide_startstop_t
id|startstop
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
multiline_comment|/* Check for errors. */
r_if
c_cond
(paren
id|dma
)paren
(brace
id|info-&gt;dma
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dma_error
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_end
comma
id|drive
)paren
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide-cd: write dma error&bslash;n&quot;
)paren
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_off
comma
id|drive
)paren
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|cdrom_decode_status
c_func
(paren
op_amp
id|startstop
comma
id|drive
comma
l_int|0
comma
op_amp
id|stat
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide-cd: write_intr decode_status bad&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|startstop
suffix:semicolon
)brace
r_if
c_cond
(paren
id|dma
)paren
(brace
r_if
c_cond
(paren
id|dma_error
)paren
r_return
id|ide_error
c_func
(paren
id|drive
comma
l_string|&quot;dma error&quot;
comma
id|stat
)paren
suffix:semicolon
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
id|rq-&gt;nr_sectors
suffix:semicolon
id|i
OG
l_int|0
suffix:semicolon
)paren
(brace
id|i
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|ide_end_request
c_func
(paren
l_int|1
comma
id|HWGROUP
c_func
(paren
id|drive
)paren
)paren
suffix:semicolon
)brace
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/* Read the interrupt reason and the transfer length. */
id|ireason
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
id|len
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_LCYL_REG
)paren
op_plus
l_int|256
op_star
id|IN_BYTE
c_func
(paren
id|IDE_HCYL_REG
)paren
suffix:semicolon
multiline_comment|/* If DRQ is clear, the command has completed. */
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|DRQ_STAT
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* If we&squot;re not done writing, complain.&n;&t;&t; * Otherwise, complete the command normally.&n;&t;&t; */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
OG
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: write_intr: data underrun (%ld blocks)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|cdrom_end_request
c_func
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
)brace
r_else
id|cdrom_end_request
c_func
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
multiline_comment|/* Check that the drive is expecting to do the same thing we are. */
r_if
c_cond
(paren
id|ireason
op_amp
l_int|3
)paren
r_if
c_cond
(paren
id|cdrom_write_check_ireason
c_func
(paren
id|drive
comma
id|len
comma
id|ireason
)paren
)paren
r_return
id|ide_stopped
suffix:semicolon
multiline_comment|/* The number of sectors we need to read from the drive. */
id|sectors_to_transfer
op_assign
id|len
op_div
id|SECTOR_SIZE
suffix:semicolon
multiline_comment|/* Now loop while we still have data to read from the drive. DMA&n;&t; * transfers will already have been complete&n;&t; */
r_while
c_loop
(paren
id|sectors_to_transfer
OG
l_int|0
)paren
(brace
multiline_comment|/* If we&squot;ve filled the present buffer but there&squot;s another&n;&t;&t;   chained buffer after it, move on. */
r_if
c_cond
(paren
id|rq-&gt;current_nr_sectors
op_eq
l_int|0
op_logical_and
id|rq-&gt;nr_sectors
OG
l_int|0
)paren
id|cdrom_end_request
c_func
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
id|atapi_output_bytes
c_func
(paren
id|drive
comma
id|rq-&gt;buffer
comma
id|rq-&gt;current_nr_sectors
)paren
suffix:semicolon
id|rq-&gt;nr_sectors
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|rq-&gt;current_nr_sectors
op_assign
l_int|0
suffix:semicolon
id|rq-&gt;sector
op_add_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
id|sectors_to_transfer
op_sub_assign
id|rq-&gt;current_nr_sectors
suffix:semicolon
)brace
multiline_comment|/* arm handler */
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|cdrom_write_intr
comma
l_int|5
op_star
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|ide_started
suffix:semicolon
)brace
DECL|function|cdrom_start_write_cont
r_static
id|ide_startstop_t
id|cdrom_start_write_cont
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
multiline_comment|/* packet_command_t pc; */
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_int
id|nframes
comma
id|frame
suffix:semicolon
id|nframes
op_assign
id|rq-&gt;nr_sectors
op_rshift
l_int|2
suffix:semicolon
id|frame
op_assign
id|rq-&gt;sector
op_rshift
l_int|2
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pc.c
comma
l_int|0
comma
r_sizeof
(paren
id|pc.c
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * we might as well use WRITE_12, but none of the device I have&n;&t; * support the streaming feature anyway, so who cares.&n;&t; */
id|pc.c
(braket
l_int|0
)braket
op_assign
id|GPCMD_WRITE_10
suffix:semicolon
macro_line|#if 0&t;/* the immediate bit */
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|1
op_lshift
l_int|3
suffix:semicolon
macro_line|#endif
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|nframes
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
id|nframes
op_amp
l_int|0xff
suffix:semicolon
id|put_unaligned
c_func
(paren
id|cpu_to_be32
c_func
(paren
id|frame
)paren
comma
(paren
r_int
r_int
op_star
)paren
op_amp
id|pc.c
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|pc.timeout
op_assign
l_int|2
op_star
id|WAIT_CMD
suffix:semicolon
r_return
id|cdrom_transfer_packet_command
c_func
(paren
id|drive
comma
op_amp
id|pc
comma
id|cdrom_write_intr
)paren
suffix:semicolon
)brace
DECL|function|cdrom_start_write
r_static
id|ide_startstop_t
id|cdrom_start_write
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
id|info-&gt;nsectors_buffered
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* use dma, if possible. we don&squot;t need to check more, since we&n;&t; * know that the transfer is always (at least!) 2KB aligned */
id|info-&gt;dma
op_assign
id|drive-&gt;using_dma
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|info-&gt;cmd
op_assign
id|WRITE
suffix:semicolon
multiline_comment|/* Start sending the read request to the drive. */
r_return
id|cdrom_start_packet_command
c_func
(paren
id|drive
comma
l_int|32768
comma
id|cdrom_start_write_cont
)paren
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; * cdrom driver request routine.&n; */
r_static
id|ide_startstop_t
DECL|function|ide_do_rw_cdrom
id|ide_do_rw_cdrom
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request
op_star
id|rq
comma
r_int
r_int
id|block
)paren
(brace
id|ide_startstop_t
id|action
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_switch
c_cond
(paren
id|rq-&gt;cmd
)paren
(brace
r_case
id|WRITE
suffix:colon
r_case
id|READ
suffix:colon
(brace
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|seeking
)paren
(brace
r_int
r_int
id|elpased
op_assign
id|jiffies
op_minus
id|info-&gt;start_seek
suffix:semicolon
r_int
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|SEEK_STAT
)paren
op_ne
id|SEEK_STAT
)paren
(brace
r_if
c_cond
(paren
id|elpased
OL
id|IDECD_SEEK_TIMEOUT
)paren
(brace
id|ide_stall_queue
c_func
(paren
id|drive
comma
id|IDECD_SEEK_TIMER
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
id|printk
(paren
l_string|&quot;%s: DSC timeout&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
)brace
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|seeking
op_assign
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
id|IDE_LARGE_SEEK
c_func
(paren
id|info-&gt;last_block
comma
id|block
comma
id|IDECD_SEEK_THRESHOLD
)paren
op_logical_and
id|drive-&gt;dsc_overlap
)paren
id|action
op_assign
id|cdrom_start_seek
(paren
id|drive
comma
id|block
)paren
suffix:semicolon
r_else
(brace
r_if
c_cond
(paren
id|rq-&gt;cmd
op_eq
id|READ
)paren
id|action
op_assign
id|cdrom_start_read
c_func
(paren
id|drive
comma
id|block
)paren
suffix:semicolon
r_else
id|action
op_assign
id|cdrom_start_write
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
id|info-&gt;last_block
op_assign
id|block
suffix:semicolon
r_return
id|action
suffix:semicolon
)brace
r_case
id|PACKET_COMMAND
suffix:colon
r_case
id|REQUEST_SENSE_COMMAND
suffix:colon
(brace
r_return
id|cdrom_do_packet_command
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_case
id|RESET_DRIVE_COMMAND
suffix:colon
(brace
id|cdrom_end_request
c_func
(paren
l_int|1
comma
id|drive
)paren
suffix:semicolon
r_return
id|ide_do_reset
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_default
suffix:colon
(brace
)brace
(brace
id|printk
c_func
(paren
l_string|&quot;ide-cd: bad cmd %d&bslash;n&quot;
comma
id|rq-&gt;cmd
)paren
suffix:semicolon
id|cdrom_end_request
c_func
(paren
l_int|0
comma
id|drive
)paren
suffix:semicolon
r_return
id|ide_stopped
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/****************************************************************************&n; * Ioctl handling.&n; *&n; * Routines which queue packet commands take as a final argument a pointer&n; * to a request_sense struct.  If execution of the command results&n; * in an error with a CHECK CONDITION status, this structure will be filled&n; * with the results of the subsequent request sense command.  The pointer&n; * can also be NULL, in which case no sense information is returned.&n; */
macro_line|#if ! STANDARD_ATAPI
r_static
r_inline
DECL|function|bin2bcd
r_int
id|bin2bcd
(paren
r_int
id|x
)paren
(brace
r_return
(paren
id|x
op_mod
l_int|10
)paren
op_or
(paren
(paren
id|x
op_div
l_int|10
)paren
op_lshift
l_int|4
)paren
suffix:semicolon
)brace
r_static
r_inline
DECL|function|bcd2bin
r_int
id|bcd2bin
(paren
r_int
id|x
)paren
(brace
r_return
(paren
id|x
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|x
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
r_static
DECL|function|msf_from_bcd
r_void
id|msf_from_bcd
(paren
r_struct
id|atapi_msf
op_star
id|msf
)paren
(brace
id|msf-&gt;minute
op_assign
id|bcd2bin
(paren
id|msf-&gt;minute
)paren
suffix:semicolon
id|msf-&gt;second
op_assign
id|bcd2bin
(paren
id|msf-&gt;second
)paren
suffix:semicolon
id|msf-&gt;frame
op_assign
id|bcd2bin
(paren
id|msf-&gt;frame
)paren
suffix:semicolon
)brace
macro_line|#endif /* not STANDARD_ATAPI */
r_static
r_inline
DECL|function|lba_to_msf
r_void
id|lba_to_msf
(paren
r_int
id|lba
comma
id|byte
op_star
id|m
comma
id|byte
op_star
id|s
comma
id|byte
op_star
id|f
)paren
(brace
id|lba
op_add_assign
id|CD_MSF_OFFSET
suffix:semicolon
id|lba
op_and_assign
l_int|0xffffff
suffix:semicolon
multiline_comment|/* negative lbas use only 24 bits */
op_star
id|m
op_assign
id|lba
op_div
(paren
id|CD_SECS
op_star
id|CD_FRAMES
)paren
suffix:semicolon
id|lba
op_mod_assign
(paren
id|CD_SECS
op_star
id|CD_FRAMES
)paren
suffix:semicolon
op_star
id|s
op_assign
id|lba
op_div
id|CD_FRAMES
suffix:semicolon
op_star
id|f
op_assign
id|lba
op_mod
id|CD_FRAMES
suffix:semicolon
)brace
r_static
r_inline
DECL|function|msf_to_lba
r_int
id|msf_to_lba
(paren
id|byte
id|m
comma
id|byte
id|s
comma
id|byte
id|f
)paren
(brace
r_return
(paren
(paren
(paren
id|m
op_star
id|CD_SECS
)paren
op_plus
id|s
)paren
op_star
id|CD_FRAMES
op_plus
id|f
)paren
op_minus
id|CD_MSF_OFFSET
suffix:semicolon
)brace
DECL|function|cdrom_check_status
r_static
r_int
id|cdrom_check_status
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request_sense
op_star
id|sense
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
op_amp
id|info-&gt;devinfo
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense
op_assign
id|sense
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|GPCMD_TEST_UNIT_READY
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
multiline_comment|/* the Sanyo 3 CD changer uses byte 7 of TEST_UNIT_READY to &n;           switch CDs instead of supporting the LOAD_UNLOAD opcode   */
id|pc.c
(braket
l_int|7
)braket
op_assign
id|cdi-&gt;sanyo_slot
op_mod
l_int|3
suffix:semicolon
macro_line|#endif /* not STANDARD_ATAPI */
r_return
id|cdrom_queue_packet_command
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* Lock the door if LOCKFLAG is nonzero; unlock it otherwise. */
r_static
r_int
DECL|function|cdrom_lockdoor
id|cdrom_lockdoor
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lockflag
comma
r_struct
id|request_sense
op_star
id|sense
)paren
(brace
r_struct
id|request_sense
id|my_sense
suffix:semicolon
r_struct
id|packet_command
id|pc
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|sense
op_eq
l_int|NULL
)paren
id|sense
op_assign
op_amp
id|my_sense
suffix:semicolon
multiline_comment|/* If the drive cannot lock the door, just pretend. */
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
)paren
(brace
id|stat
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|memset
c_func
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense
op_assign
id|sense
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
id|lockflag
ques
c_cond
l_int|1
suffix:colon
l_int|0
suffix:semicolon
id|stat
op_assign
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* If we got an illegal field error, the drive&n;&t;   probably cannot lock the door. */
r_if
c_cond
(paren
id|stat
op_ne
l_int|0
op_logical_and
id|sense-&gt;sense_key
op_eq
id|ILLEGAL_REQUEST
op_logical_and
(paren
id|sense-&gt;asc
op_eq
l_int|0x24
op_logical_or
id|sense-&gt;asc
op_eq
l_int|0x20
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: door locking not supported&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
op_assign
l_int|1
suffix:semicolon
id|stat
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* no medium, that&squot;s alright. */
r_if
c_cond
(paren
id|stat
op_ne
l_int|0
op_logical_and
id|sense-&gt;sense_key
op_eq
id|NOT_READY
op_logical_and
id|sense-&gt;asc
op_eq
l_int|0x3a
)paren
id|stat
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
)paren
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
op_assign
id|lockflag
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
multiline_comment|/* Eject the disk if EJECTFLAG is 0.&n;   If EJECTFLAG is 1, try to reload the disk. */
DECL|function|cdrom_eject
r_static
r_int
id|cdrom_eject
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|ejectflag
comma
r_struct
id|request_sense
op_star
id|sense
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_eject
op_logical_and
op_logical_neg
id|ejectflag
)paren
r_return
op_minus
id|EDRIVE_CANT_DO_THIS
suffix:semicolon
multiline_comment|/* reload fails on some drives, if the tray is locked */
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
op_logical_and
id|ejectflag
)paren
r_return
l_int|0
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense
op_assign
id|sense
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|GPCMD_START_STOP_UNIT
suffix:semicolon
id|pc.c
(braket
l_int|4
)braket
op_assign
l_int|0x02
op_plus
(paren
id|ejectflag
op_ne
l_int|0
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
DECL|function|cdrom_read_capacity
r_static
r_int
id|cdrom_read_capacity
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
op_star
id|capacity
comma
r_struct
id|request_sense
op_star
id|sense
)paren
(brace
r_struct
(brace
id|__u32
id|lba
suffix:semicolon
id|__u32
id|blocklen
suffix:semicolon
)brace
id|capbuf
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense
op_assign
id|sense
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_CDVD_CAPACITY
suffix:semicolon
id|pc.buffer
op_assign
(paren
r_char
op_star
)paren
op_amp
id|capbuf
suffix:semicolon
id|pc.buflen
op_assign
r_sizeof
(paren
id|capbuf
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_queue_packet_command
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
)paren
op_star
id|capacity
op_assign
l_int|1
op_plus
id|be32_to_cpu
c_func
(paren
id|capbuf.lba
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
DECL|function|cdrom_read_tocentry
r_static
r_int
id|cdrom_read_tocentry
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|trackno
comma
r_int
id|msf_flag
comma
r_int
id|format
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|request_sense
op_star
id|sense
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense
op_assign
id|sense
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_TOC_PMA_ATIP
suffix:semicolon
id|pc.c
(braket
l_int|6
)braket
op_assign
id|trackno
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
id|pc.c
(braket
l_int|9
)braket
op_assign
(paren
id|format
op_lshift
l_int|6
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msf_flag
)paren
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
r_return
id|cdrom_queue_packet_command
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* Try to read the entire TOC for the disk into our internal buffer. */
DECL|function|cdrom_read_toc
r_static
r_int
id|cdrom_read_toc
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|request_sense
op_star
id|sense
)paren
(brace
r_int
id|minor
comma
id|stat
comma
id|ntracks
comma
id|i
suffix:semicolon
id|kdev_t
id|dev
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
r_struct
(brace
r_struct
id|atapi_toc_header
id|hdr
suffix:semicolon
r_struct
id|atapi_toc_entry
id|ent
suffix:semicolon
)brace
id|ms_tmp
suffix:semicolon
r_if
c_cond
(paren
id|toc
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* Try to allocate space. */
id|toc
op_assign
(paren
r_struct
id|atapi_toc
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|atapi_toc
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
id|info-&gt;toc
op_assign
id|toc
suffix:semicolon
r_if
c_cond
(paren
id|toc
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: No cdrom TOC buffer!&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
op_minus
id|ENOMEM
suffix:semicolon
)brace
)brace
multiline_comment|/* Check to see if the existing data is still valid.&n;&t;   If it is, just return. */
(paren
r_void
)paren
id|cdrom_check_status
c_func
(paren
id|drive
comma
id|sense
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
)paren
r_return
l_int|0
suffix:semicolon
multiline_comment|/* First read just the header, so we know how long the TOC is. */
id|stat
op_assign
id|cdrom_read_tocentry
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
(paren
r_char
op_star
)paren
op_amp
id|toc-&gt;hdr
comma
r_sizeof
(paren
r_struct
id|atapi_toc_header
)paren
comma
id|sense
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
)paren
(brace
id|toc-&gt;hdr.first_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.first_track
)paren
suffix:semicolon
id|toc-&gt;hdr.last_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.last_track
)paren
suffix:semicolon
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
id|ntracks
op_assign
id|toc-&gt;hdr.last_track
op_minus
id|toc-&gt;hdr.first_track
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ntracks
op_le
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|ntracks
OG
id|MAX_TRACKS
)paren
id|ntracks
op_assign
id|MAX_TRACKS
suffix:semicolon
multiline_comment|/* Now read the whole schmeer. */
id|stat
op_assign
id|cdrom_read_tocentry
c_func
(paren
id|drive
comma
id|toc-&gt;hdr.first_track
comma
l_int|1
comma
l_int|0
comma
(paren
r_char
op_star
)paren
op_amp
id|toc-&gt;hdr
comma
r_sizeof
(paren
r_struct
id|atapi_toc_header
)paren
op_plus
(paren
id|ntracks
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|atapi_toc_entry
)paren
comma
id|sense
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_logical_and
id|toc-&gt;hdr.first_track
OG
l_int|1
)paren
(brace
multiline_comment|/* Cds with CDI tracks only don&squot;t have any TOC entries,&n;&t;&t;   despite of this the returned values are&n;&t;&t;   first_track == last_track = number of CDI tracks + 1,&n;&t;&t;   so that this case is indistinguishable from the same&n;&t;&t;   layout plus an additional audio track.&n;&t;&t;   If we get an error for the regular case, we assume&n;&t;&t;   a CDI without additional audio tracks. In this case&n;&t;&t;   the readable TOC is empty (CDI tracks are not included)&n;&t;&t;   and only holds the Leadout entry. Heiko Ei&#xfffd;feldt */
id|ntracks
op_assign
l_int|0
suffix:semicolon
id|stat
op_assign
id|cdrom_read_tocentry
c_func
(paren
id|drive
comma
id|CDROM_LEADOUT
comma
l_int|1
comma
l_int|0
comma
(paren
r_char
op_star
)paren
op_amp
id|toc-&gt;hdr
comma
r_sizeof
(paren
r_struct
id|atapi_toc_header
)paren
op_plus
(paren
id|ntracks
op_plus
l_int|1
)paren
op_star
r_sizeof
(paren
r_struct
id|atapi_toc_entry
)paren
comma
id|sense
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
(brace
r_return
id|stat
suffix:semicolon
)brace
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
)paren
(brace
id|toc-&gt;hdr.first_track
op_assign
id|bin2bcd
c_func
(paren
id|CDROM_LEADOUT
)paren
suffix:semicolon
id|toc-&gt;hdr.last_track
op_assign
id|bin2bcd
c_func
(paren
id|CDROM_LEADOUT
)paren
suffix:semicolon
)brace
r_else
macro_line|#endif  /* not STANDARD_ATAPI */
(brace
id|toc-&gt;hdr.first_track
op_assign
id|CDROM_LEADOUT
suffix:semicolon
id|toc-&gt;hdr.last_track
op_assign
id|CDROM_LEADOUT
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc-&gt;hdr.toc_length
op_assign
id|ntohs
(paren
id|toc-&gt;hdr.toc_length
)paren
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
)paren
(brace
id|toc-&gt;hdr.first_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.first_track
)paren
suffix:semicolon
id|toc-&gt;hdr.last_track
op_assign
id|bcd2bin
(paren
id|toc-&gt;hdr.last_track
)paren
suffix:semicolon
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
op_le
id|ntracks
suffix:semicolon
id|i
op_increment
)paren
(brace
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
)paren
(brace
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
)paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|track
op_assign
id|bcd2bin
(paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|track
)paren
suffix:semicolon
id|msf_from_bcd
(paren
op_amp
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf
)paren
suffix:semicolon
)brace
macro_line|#endif  /* not STANDARD_ATAPI */
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.lba
op_assign
id|msf_to_lba
(paren
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.minute
comma
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.second
comma
id|toc-&gt;ent
(braket
id|i
)braket
dot
id|addr.msf.frame
)paren
suffix:semicolon
)brace
multiline_comment|/* Read the multisession information. */
r_if
c_cond
(paren
id|toc-&gt;hdr.first_track
op_ne
id|CDROM_LEADOUT
)paren
(brace
multiline_comment|/* Read the multisession information. */
id|stat
op_assign
id|cdrom_read_tocentry
c_func
(paren
id|drive
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
(paren
r_char
op_star
)paren
op_amp
id|ms_tmp
comma
r_sizeof
(paren
id|ms_tmp
)paren
comma
id|sense
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
)brace
r_else
(brace
id|ms_tmp.ent.addr.msf.minute
op_assign
l_int|0
suffix:semicolon
id|ms_tmp.ent.addr.msf.second
op_assign
l_int|2
suffix:semicolon
id|ms_tmp.ent.addr.msf.frame
op_assign
l_int|0
suffix:semicolon
id|ms_tmp.hdr.first_track
op_assign
id|ms_tmp.hdr.last_track
op_assign
id|CDROM_LEADOUT
suffix:semicolon
)brace
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
)paren
id|msf_from_bcd
(paren
op_amp
id|ms_tmp.ent.addr.msf
)paren
suffix:semicolon
macro_line|#endif  /* not STANDARD_ATAPI */
id|toc-&gt;last_session_lba
op_assign
id|msf_to_lba
(paren
id|ms_tmp.ent.addr.msf.minute
comma
id|ms_tmp.ent.addr.msf.second
comma
id|ms_tmp.ent.addr.msf.frame
)paren
suffix:semicolon
id|toc-&gt;xa_flag
op_assign
(paren
id|ms_tmp.hdr.first_track
op_ne
id|ms_tmp.hdr.last_track
)paren
suffix:semicolon
multiline_comment|/* Now try to get the total cdrom capacity. */
id|minor
op_assign
(paren
id|drive-&gt;select.b.unit
)paren
op_lshift
id|PARTN_BITS
suffix:semicolon
id|dev
op_assign
id|MKDEV
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
comma
id|minor
)paren
suffix:semicolon
id|stat
op_assign
id|cdrom_get_last_written
c_func
(paren
id|dev
comma
(paren
r_int
op_star
)paren
op_amp
id|toc-&gt;capacity
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
id|stat
op_assign
id|cdrom_read_capacity
c_func
(paren
id|drive
comma
op_amp
id|toc-&gt;capacity
comma
id|sense
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
id|toc-&gt;capacity
op_assign
l_int|0x1fffff
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|gd-&gt;sizes
(braket
id|drive-&gt;select.b.unit
op_lshift
id|PARTN_BITS
)braket
op_assign
(paren
id|toc-&gt;capacity
op_star
id|SECTORS_PER_FRAME
)paren
op_rshift
(paren
id|BLOCK_SIZE_BITS
op_minus
l_int|9
)paren
suffix:semicolon
id|drive-&gt;part
(braket
l_int|0
)braket
dot
id|nr_sects
op_assign
id|toc-&gt;capacity
op_star
id|SECTORS_PER_FRAME
suffix:semicolon
multiline_comment|/* Remember that we&squot;ve read this stuff. */
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|cdrom_read_subchannel
r_static
r_int
id|cdrom_read_subchannel
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|format
comma
r_char
op_star
id|buf
comma
r_int
id|buflen
comma
r_struct
id|request_sense
op_star
id|sense
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense
op_assign
id|sense
suffix:semicolon
id|pc.buffer
op_assign
id|buf
suffix:semicolon
id|pc.buflen
op_assign
id|buflen
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|GPCMD_READ_SUBCHANNEL
suffix:semicolon
id|pc.c
(braket
l_int|1
)braket
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* MSF addressing */
id|pc.c
(braket
l_int|2
)braket
op_assign
l_int|0x40
suffix:semicolon
multiline_comment|/* request subQ data */
id|pc.c
(braket
l_int|3
)braket
op_assign
id|format
suffix:semicolon
id|pc.c
(braket
l_int|7
)braket
op_assign
(paren
id|buflen
op_rshift
l_int|8
)paren
suffix:semicolon
id|pc.c
(braket
l_int|8
)braket
op_assign
(paren
id|buflen
op_amp
l_int|0xff
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
multiline_comment|/* ATAPI cdrom drives are free to select the speed you request or any slower&n;   rate :-( Requesting too fast a speed will _not_ produce an error. */
DECL|function|cdrom_select_speed
r_static
r_int
id|cdrom_select_speed
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|speed
comma
r_struct
id|request_sense
op_star
id|sense
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense
op_assign
id|sense
suffix:semicolon
r_if
c_cond
(paren
id|speed
op_eq
l_int|0
)paren
id|speed
op_assign
l_int|0xffff
suffix:semicolon
multiline_comment|/* set to max */
r_else
id|speed
op_mul_assign
l_int|177
suffix:semicolon
multiline_comment|/* Nx to kbytes/s */
id|pc.c
(braket
l_int|0
)braket
op_assign
id|GPCMD_SET_SPEED
suffix:semicolon
multiline_comment|/* Read Drive speed in kbytes/second MSB */
id|pc.c
(braket
l_int|2
)braket
op_assign
(paren
id|speed
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* Read Drive speed in kbytes/second LSB */
id|pc.c
(braket
l_int|3
)braket
op_assign
id|speed
op_amp
l_int|0xff
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cd_r
op_logical_or
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|cd_rw
op_logical_or
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd_r
)paren
(brace
multiline_comment|/* Write Drive speed in kbytes/second MSB */
id|pc.c
(braket
l_int|4
)braket
op_assign
(paren
id|speed
op_rshift
l_int|8
)paren
op_amp
l_int|0xff
suffix:semicolon
multiline_comment|/* Write Drive speed in kbytes/second LSB */
id|pc.c
(braket
l_int|5
)braket
op_assign
id|speed
op_amp
l_int|0xff
suffix:semicolon
)brace
r_return
id|cdrom_queue_packet_command
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
DECL|function|cdrom_play_audio
r_static
r_int
id|cdrom_play_audio
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|lba_start
comma
r_int
id|lba_end
)paren
(brace
r_struct
id|request_sense
id|sense
suffix:semicolon
r_struct
id|packet_command
id|pc
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|pc.sense
op_assign
op_amp
id|sense
suffix:semicolon
id|pc.c
(braket
l_int|0
)braket
op_assign
id|GPCMD_PLAY_AUDIO_MSF
suffix:semicolon
id|lba_to_msf
c_func
(paren
id|lba_start
comma
op_amp
id|pc.c
(braket
l_int|3
)braket
comma
op_amp
id|pc.c
(braket
l_int|4
)braket
comma
op_amp
id|pc.c
(braket
l_int|5
)braket
)paren
suffix:semicolon
id|lba_to_msf
c_func
(paren
id|lba_end
op_minus
l_int|1
comma
op_amp
id|pc.c
(braket
l_int|6
)braket
comma
op_amp
id|pc.c
(braket
l_int|7
)braket
comma
op_amp
id|pc.c
(braket
l_int|8
)braket
)paren
suffix:semicolon
r_return
id|cdrom_queue_packet_command
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
DECL|function|cdrom_get_toc_entry
r_static
r_int
id|cdrom_get_toc_entry
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|track
comma
r_struct
id|atapi_toc_entry
op_star
op_star
id|ent
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
r_int
id|ntracks
suffix:semicolon
multiline_comment|/*&n;&t; * don&squot;t serve cached data, if the toc isn&squot;t valid&n;&t; */
r_if
c_cond
(paren
op_logical_neg
id|CDROM_STATE_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* Check validity of requested track number. */
id|ntracks
op_assign
id|toc-&gt;hdr.last_track
op_minus
id|toc-&gt;hdr.first_track
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|toc-&gt;hdr.first_track
op_eq
id|CDROM_LEADOUT
)paren
id|ntracks
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|track
op_eq
id|CDROM_LEADOUT
)paren
op_star
id|ent
op_assign
op_amp
id|toc-&gt;ent
(braket
id|ntracks
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|track
template_param
id|toc-&gt;hdr.last_track
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
op_star
id|ent
op_assign
op_amp
id|toc-&gt;ent
(braket
id|track
op_minus
id|toc-&gt;hdr.first_track
)braket
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* the generic packet interface to cdrom.c */
DECL|function|ide_cdrom_packet
r_static
r_int
id|ide_cdrom_packet
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_generic_command
op_star
id|cgc
)paren
(brace
r_struct
id|packet_command
id|pc
suffix:semicolon
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_if
c_cond
(paren
id|cgc-&gt;timeout
op_le
l_int|0
)paren
id|cgc-&gt;timeout
op_assign
id|WAIT_CMD
suffix:semicolon
multiline_comment|/* here we queue the commands from the uniform CD-ROM&n;&t;   layer. the packet must be complete, as we do not&n;&t;   touch it at all. */
id|memset
c_func
(paren
op_amp
id|pc
comma
l_int|0
comma
r_sizeof
(paren
id|pc
)paren
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|pc.c
comma
id|cgc-&gt;cmd
comma
id|CDROM_PACKET_SIZE
)paren
suffix:semicolon
id|pc.buffer
op_assign
id|cgc-&gt;buffer
suffix:semicolon
id|pc.buflen
op_assign
id|cgc-&gt;buflen
suffix:semicolon
id|pc.quiet
op_assign
id|cgc-&gt;quiet
suffix:semicolon
id|pc.timeout
op_assign
id|cgc-&gt;timeout
suffix:semicolon
id|pc.sense
op_assign
id|cgc-&gt;sense
suffix:semicolon
r_return
id|cgc-&gt;stat
op_assign
id|cdrom_queue_packet_command
c_func
(paren
id|drive
comma
op_amp
id|pc
)paren
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_dev_ioctl
r_int
id|ide_cdrom_dev_ioctl
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
r_char
id|buffer
(braket
l_int|16
)braket
suffix:semicolon
r_int
id|stat
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|buffer
comma
r_sizeof
(paren
id|buffer
)paren
comma
id|CGC_DATA_UNKNOWN
)paren
suffix:semicolon
multiline_comment|/* These will be moved into the Uniform layer shortly... */
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSETSPINDOWN
suffix:colon
(brace
r_char
id|spindown
suffix:semicolon
r_if
c_cond
(paren
id|copy_from_user
c_func
(paren
op_amp
id|spindown
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_char
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_assign
id|cdrom_mode_sense
c_func
(paren
id|cdi
comma
op_amp
id|cgc
comma
id|GPMODE_CDROM_PAGE
comma
l_int|0
)paren
)paren
)paren
r_return
id|stat
suffix:semicolon
id|buffer
(braket
l_int|11
)braket
op_assign
(paren
id|buffer
(braket
l_int|11
)braket
op_amp
l_int|0xf0
)paren
op_or
(paren
id|spindown
op_amp
l_int|0x0f
)paren
suffix:semicolon
r_return
id|cdrom_mode_select
c_func
(paren
id|cdi
comma
op_amp
id|cgc
)paren
suffix:semicolon
)brace
r_case
id|CDROMGETSPINDOWN
suffix:colon
(brace
r_char
id|spindown
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_assign
id|cdrom_mode_sense
c_func
(paren
id|cdi
comma
op_amp
id|cgc
comma
id|GPMODE_CDROM_PAGE
comma
l_int|0
)paren
)paren
)paren
r_return
id|stat
suffix:semicolon
id|spindown
op_assign
id|buffer
(braket
l_int|11
)braket
op_amp
l_int|0x0f
suffix:semicolon
r_if
c_cond
(paren
id|copy_to_user
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|spindown
comma
r_sizeof
(paren
r_char
)paren
)paren
)paren
r_return
op_minus
id|EFAULT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_static
DECL|function|ide_cdrom_audio_ioctl
r_int
id|ide_cdrom_audio_ioctl
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_switch
c_cond
(paren
id|cmd
)paren
(brace
multiline_comment|/*&n;&t; * emulate PLAY_AUDIO_TI command with PLAY_AUDIO_10, since&n;&t; * atapi doesn&squot;t support it&n;&t; */
r_case
id|CDROMPLAYTRKIND
suffix:colon
(brace
r_int
r_int
id|lba_start
comma
id|lba_end
suffix:semicolon
r_struct
id|cdrom_ti
op_star
id|ti
op_assign
(paren
r_struct
id|cdrom_ti
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|atapi_toc_entry
op_star
id|first_toc
comma
op_star
id|last_toc
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
c_func
(paren
id|drive
comma
id|ti-&gt;cdti_trk0
comma
op_amp
id|first_toc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
c_func
(paren
id|drive
comma
id|ti-&gt;cdti_trk1
comma
op_amp
id|last_toc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
r_if
c_cond
(paren
id|ti-&gt;cdti_trk1
op_ne
id|CDROM_LEADOUT
)paren
op_increment
id|last_toc
suffix:semicolon
id|lba_start
op_assign
id|first_toc-&gt;addr.lba
suffix:semicolon
id|lba_end
op_assign
id|last_toc-&gt;addr.lba
suffix:semicolon
r_if
c_cond
(paren
id|lba_end
op_le
id|lba_start
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|cdrom_play_audio
c_func
(paren
id|drive
comma
id|lba_start
comma
id|lba_end
)paren
suffix:semicolon
)brace
r_case
id|CDROMREADTOCHDR
suffix:colon
(brace
r_struct
id|cdrom_tochdr
op_star
id|tochdr
op_assign
(paren
r_struct
id|cdrom_tochdr
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
multiline_comment|/* Make sure our saved TOC is valid. */
id|stat
op_assign
id|cdrom_read_toc
c_func
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
id|tochdr-&gt;cdth_trk0
op_assign
id|toc-&gt;hdr.first_track
suffix:semicolon
id|tochdr-&gt;cdth_trk1
op_assign
id|toc-&gt;hdr.last_track
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMREADTOCENTRY
suffix:colon
(brace
r_struct
id|cdrom_tocentry
op_star
id|tocentry
op_assign
(paren
r_struct
id|cdrom_tocentry
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|atapi_toc_entry
op_star
id|toce
suffix:semicolon
id|stat
op_assign
id|cdrom_get_toc_entry
(paren
id|drive
comma
id|tocentry-&gt;cdte_track
comma
op_amp
id|toce
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
id|tocentry-&gt;cdte_ctrl
op_assign
id|toce-&gt;control
suffix:semicolon
id|tocentry-&gt;cdte_adr
op_assign
id|toce-&gt;adr
suffix:semicolon
r_if
c_cond
(paren
id|tocentry-&gt;cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
id|lba_to_msf
(paren
id|toce-&gt;addr.lba
comma
op_amp
id|tocentry-&gt;cdte_addr.msf.minute
comma
op_amp
id|tocentry-&gt;cdte_addr.msf.second
comma
op_amp
id|tocentry-&gt;cdte_addr.msf.frame
)paren
suffix:semicolon
)brace
r_else
id|tocentry-&gt;cdte_addr.lba
op_assign
id|toce-&gt;addr.lba
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_static
DECL|function|ide_cdrom_reset
r_int
id|ide_cdrom_reset
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_struct
id|request_sense
id|sense
suffix:semicolon
r_struct
id|request
id|req
suffix:semicolon
r_int
id|ret
suffix:semicolon
id|ide_init_drive_cmd
(paren
op_amp
id|req
)paren
suffix:semicolon
id|req.cmd
op_assign
id|RESET_DRIVE_COMMAND
suffix:semicolon
id|ret
op_assign
id|ide_do_drive_cmd
c_func
(paren
id|drive
comma
op_amp
id|req
comma
id|ide_wait
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * A reset will unlock the door. If it was previously locked,&n;&t; * lock it again.&n;&t; */
r_if
c_cond
(paren
id|CDROM_STATE_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
)paren
(paren
r_void
)paren
id|cdrom_lockdoor
c_func
(paren
id|drive
comma
l_int|1
comma
op_amp
id|sense
)paren
suffix:semicolon
r_return
id|ret
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_tray_move
r_int
id|ide_cdrom_tray_move
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|position
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_struct
id|request_sense
id|sense
suffix:semicolon
r_if
c_cond
(paren
id|position
)paren
(brace
r_int
id|stat
op_assign
id|cdrom_lockdoor
c_func
(paren
id|drive
comma
l_int|0
comma
op_amp
id|sense
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
)paren
r_return
id|stat
suffix:semicolon
)brace
r_return
id|cdrom_eject
c_func
(paren
id|drive
comma
op_logical_neg
id|position
comma
op_amp
id|sense
)paren
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_lock_door
r_int
id|ide_cdrom_lock_door
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|lock
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_return
id|cdrom_lockdoor
c_func
(paren
id|drive
comma
id|lock
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_select_speed
r_int
id|ide_cdrom_select_speed
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|speed
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_struct
id|request_sense
id|sense
suffix:semicolon
r_int
id|stat
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stat
op_assign
id|cdrom_select_speed
(paren
id|drive
comma
id|speed
comma
op_amp
id|sense
)paren
)paren
OL
l_int|0
)paren
r_return
id|stat
suffix:semicolon
id|cdi-&gt;speed
op_assign
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|current_speed
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_drive_status
r_int
id|ide_cdrom_drive_status
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|slot_nr
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_if
c_cond
(paren
id|slot_nr
op_eq
id|CDSL_CURRENT
)paren
(brace
r_struct
id|request_sense
id|sense
suffix:semicolon
r_int
id|stat
op_assign
id|cdrom_check_status
c_func
(paren
id|drive
comma
op_amp
id|sense
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stat
op_eq
l_int|0
op_logical_or
id|sense.sense_key
op_eq
id|UNIT_ATTENTION
)paren
r_return
id|CDS_DISC_OK
suffix:semicolon
r_if
c_cond
(paren
id|sense.sense_key
op_eq
id|NOT_READY
op_logical_and
id|sense.asc
op_eq
l_int|0x04
op_logical_and
id|sense.ascq
op_eq
l_int|0x04
)paren
r_return
id|CDS_DISC_OK
suffix:semicolon
r_if
c_cond
(paren
id|sense.sense_key
op_eq
id|NOT_READY
)paren
(brace
multiline_comment|/* ATAPI doesn&squot;t have anything that can help&n;&t;&t;&t;   us decide whether the drive is really&n;&t;&t;&t;   emtpy or the tray is just open. irk. */
r_return
id|CDS_TRAY_OPEN
suffix:semicolon
)brace
r_return
id|CDS_DRIVE_NOT_READY
suffix:semicolon
)brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_get_last_session
r_int
id|ide_cdrom_get_last_session
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_multisession
op_star
id|ms_info
)paren
(brace
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|request_sense
id|sense
suffix:semicolon
r_int
id|ret
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_STATE_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
op_logical_or
id|info-&gt;toc
op_eq
l_int|NULL
)paren
r_if
c_cond
(paren
(paren
id|ret
op_assign
id|cdrom_read_toc
c_func
(paren
id|drive
comma
op_amp
id|sense
)paren
)paren
)paren
r_return
id|ret
suffix:semicolon
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
id|ms_info-&gt;addr.lba
op_assign
id|toc-&gt;last_session_lba
suffix:semicolon
id|ms_info-&gt;xa_flag
op_assign
id|toc-&gt;xa_flag
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_get_mcn
r_int
id|ide_cdrom_get_mcn
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_struct
id|cdrom_mcn
op_star
id|mcn_info
)paren
(brace
r_int
id|stat
suffix:semicolon
r_char
id|mcnbuf
(braket
l_int|24
)braket
suffix:semicolon
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
multiline_comment|/* get MCN */
r_if
c_cond
(paren
(paren
id|stat
op_assign
id|cdrom_read_subchannel
c_func
(paren
id|drive
comma
l_int|2
comma
id|mcnbuf
comma
r_sizeof
(paren
id|mcnbuf
)paren
comma
l_int|NULL
)paren
)paren
)paren
r_return
id|stat
suffix:semicolon
id|memcpy
(paren
id|mcn_info-&gt;medium_catalog_number
comma
id|mcnbuf
op_plus
l_int|9
comma
r_sizeof
(paren
id|mcn_info-&gt;medium_catalog_number
)paren
op_minus
l_int|1
)paren
suffix:semicolon
id|mcn_info-&gt;medium_catalog_number
(braket
r_sizeof
(paren
id|mcn_info-&gt;medium_catalog_number
)paren
op_minus
l_int|1
)braket
op_assign
l_char|&squot;&bslash;0&squot;
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/****************************************************************************&n; * Other driver requests (open, close, check media change).&n; */
r_static
DECL|function|ide_cdrom_check_media_change_real
r_int
id|ide_cdrom_check_media_change_real
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|slot_nr
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|cdi-&gt;handle
suffix:semicolon
r_int
id|retval
suffix:semicolon
r_if
c_cond
(paren
id|slot_nr
op_eq
id|CDSL_CURRENT
)paren
(brace
(paren
r_void
)paren
id|cdrom_check_status
c_func
(paren
id|drive
comma
l_int|NULL
)paren
suffix:semicolon
id|retval
op_assign
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|0
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
r_else
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
r_static
DECL|function|ide_cdrom_open_real
r_int
id|ide_cdrom_open_real
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|purpose
)paren
(brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Close down the device.  Invalidate all cached blocks.&n; */
r_static
DECL|function|ide_cdrom_release_real
r_void
id|ide_cdrom_release_real
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
)brace
multiline_comment|/****************************************************************************&n; * Device initialization.&n; */
DECL|variable|ide_cdrom_dops
r_static
r_struct
id|cdrom_device_ops
id|ide_cdrom_dops
op_assign
(brace
id|open
suffix:colon
id|ide_cdrom_open_real
comma
id|release
suffix:colon
id|ide_cdrom_release_real
comma
id|drive_status
suffix:colon
id|ide_cdrom_drive_status
comma
id|media_changed
suffix:colon
id|ide_cdrom_check_media_change_real
comma
id|tray_move
suffix:colon
id|ide_cdrom_tray_move
comma
id|lock_door
suffix:colon
id|ide_cdrom_lock_door
comma
id|select_speed
suffix:colon
id|ide_cdrom_select_speed
comma
id|get_last_session
suffix:colon
id|ide_cdrom_get_last_session
comma
id|get_mcn
suffix:colon
id|ide_cdrom_get_mcn
comma
id|reset
suffix:colon
id|ide_cdrom_reset
comma
id|audio_ioctl
suffix:colon
id|ide_cdrom_audio_ioctl
comma
id|dev_ioctl
suffix:colon
id|ide_cdrom_dev_ioctl
comma
id|capability
suffix:colon
id|CDC_CLOSE_TRAY
op_or
id|CDC_OPEN_TRAY
op_or
id|CDC_LOCK
op_or
id|CDC_SELECT_SPEED
op_or
id|CDC_SELECT_DISC
op_or
id|CDC_MULTI_SESSION
op_or
id|CDC_MCN
op_or
id|CDC_MEDIA_CHANGED
op_or
id|CDC_PLAY_AUDIO
op_or
id|CDC_RESET
op_or
id|CDC_IOCTLS
op_or
id|CDC_DRIVE_STATUS
op_or
id|CDC_CD_R
op_or
id|CDC_CD_RW
op_or
id|CDC_DVD
op_or
id|CDC_DVD_R
op_or
id|CDC_DVD_RAM
op_or
id|CDC_GENERIC_PACKET
comma
id|generic_packet
suffix:colon
id|ide_cdrom_packet
comma
)brace
suffix:semicolon
DECL|function|ide_cdrom_register
r_static
r_int
id|ide_cdrom_register
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|nslots
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|devinfo
op_assign
op_amp
id|info-&gt;devinfo
suffix:semicolon
r_int
id|minor
op_assign
(paren
id|drive-&gt;select.b.unit
)paren
op_lshift
id|PARTN_BITS
suffix:semicolon
id|devinfo-&gt;dev
op_assign
id|MKDEV
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
comma
id|minor
)paren
suffix:semicolon
id|devinfo-&gt;ops
op_assign
op_amp
id|ide_cdrom_dops
suffix:semicolon
id|devinfo-&gt;mask
op_assign
l_int|0
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
op_amp
id|devinfo-&gt;speed
op_assign
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|current_speed
suffix:semicolon
op_star
(paren
r_int
op_star
)paren
op_amp
id|devinfo-&gt;capacity
op_assign
id|nslots
suffix:semicolon
id|devinfo-&gt;handle
op_assign
(paren
r_void
op_star
)paren
id|drive
suffix:semicolon
id|strcpy
c_func
(paren
id|devinfo-&gt;name
comma
id|drive-&gt;name
)paren
suffix:semicolon
multiline_comment|/* set capability mask to match the probe. */
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|cd_r
)paren
id|devinfo-&gt;mask
op_or_assign
id|CDC_CD_R
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|cd_rw
)paren
id|devinfo-&gt;mask
op_or_assign
id|CDC_CD_RW
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd
)paren
id|devinfo-&gt;mask
op_or_assign
id|CDC_DVD
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd_r
)paren
id|devinfo-&gt;mask
op_or_assign
id|CDC_DVD_R
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd_ram
)paren
id|devinfo-&gt;mask
op_or_assign
id|CDC_DVD_RAM
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|is_changer
)paren
id|devinfo-&gt;mask
op_or_assign
id|CDC_SELECT_DISC
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|audio_play
)paren
id|devinfo-&gt;mask
op_or_assign
id|CDC_PLAY_AUDIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|close_tray
)paren
id|devinfo-&gt;mask
op_or_assign
id|CDC_CLOSE_TRAY
suffix:semicolon
id|devinfo-&gt;de
op_assign
id|devfs_register
c_func
(paren
id|drive-&gt;de
comma
l_string|&quot;cd&quot;
comma
id|DEVFS_FL_DEFAULT
comma
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
comma
id|minor
comma
id|S_IFBLK
op_or
id|S_IRUGO
op_or
id|S_IWUGO
comma
id|ide_fops
comma
l_int|NULL
)paren
suffix:semicolon
r_return
id|register_cdrom
c_func
(paren
id|devinfo
)paren
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_get_capabilities
r_int
id|ide_cdrom_get_capabilities
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|atapi_capabilities_page
op_star
id|cap
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
op_amp
id|info-&gt;devinfo
suffix:semicolon
r_struct
id|cdrom_generic_command
id|cgc
suffix:semicolon
r_int
id|stat
comma
id|attempts
op_assign
l_int|3
comma
id|size
op_assign
r_sizeof
(paren
op_star
id|cap
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * ACER50 (and others?) require the full spec length mode sense&n;&t; * page capabilities size, but older drives break.&n;&t; */
r_if
c_cond
(paren
id|drive-&gt;id
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;ATAPI CD ROM DRIVE 50X MAX&quot;
)paren
op_logical_or
op_logical_neg
id|strcmp
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;WPI CDS-32X&quot;
)paren
)paren
)paren
id|size
op_sub_assign
r_sizeof
(paren
id|cap-&gt;pad
)paren
suffix:semicolon
)brace
multiline_comment|/* we have to cheat a little here. the packet will eventually&n;&t; * be queued with ide_cdrom_packet(), which extracts the&n;&t; * drive from cdi-&gt;handle. Since this device hasn&squot;t been&n;&t; * registered with the Uniform layer yet, it can&squot;t do this.&n;&t; * Same goes for cdi-&gt;ops.&n;&t; */
id|cdi-&gt;handle
op_assign
(paren
id|ide_drive_t
op_star
)paren
id|drive
suffix:semicolon
id|cdi-&gt;ops
op_assign
op_amp
id|ide_cdrom_dops
suffix:semicolon
id|init_cdrom_command
c_func
(paren
op_amp
id|cgc
comma
id|cap
comma
id|size
comma
id|CGC_DATA_UNKNOWN
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/* we seem to get stat=0x01,err=0x00 the first time (??) */
id|stat
op_assign
id|cdrom_mode_sense
c_func
(paren
id|cdi
comma
op_amp
id|cgc
comma
id|GPMODE_CAPABILITIES_PAGE
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stat
)paren
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
op_decrement
id|attempts
)paren
suffix:semicolon
r_return
id|stat
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_probe_capabilities
r_int
id|ide_cdrom_probe_capabilities
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
op_amp
id|info-&gt;devinfo
suffix:semicolon
r_struct
id|atapi_capabilities_page
id|cap
suffix:semicolon
r_int
id|nslots
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|nec260
)paren
(brace
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_eject
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|audio_play
op_assign
l_int|1
suffix:semicolon
r_return
id|nslots
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ide_cdrom_get_capabilities
c_func
(paren
id|drive
comma
op_amp
id|cap
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cap.lock
op_eq
l_int|0
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cap.eject
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_eject
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|cap.cd_r_write
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|cd_r
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cap.cd_rw_write
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|cd_rw
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cap.test_write
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|test_write
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cap.dvd_ram_read
op_logical_or
id|cap.dvd_r_read
op_logical_or
id|cap.dvd_rom
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cap.dvd_ram_write
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd_ram
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cap.dvd_r_write
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd_r
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cap.audio_play
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|audio_play
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|cap.mechtype
op_eq
id|mechtype_caddy
op_logical_or
id|cap.mechtype
op_eq
id|mechtype_popup
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|close_tray
op_assign
l_int|0
suffix:semicolon
macro_line|#if ! STANDARD_ATAPI
r_if
c_cond
(paren
id|cdi-&gt;sanyo_slot
OG
l_int|0
)paren
(brace
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|is_changer
op_assign
l_int|1
suffix:semicolon
id|nslots
op_assign
l_int|3
suffix:semicolon
)brace
r_else
macro_line|#endif /* not STANDARD_ATAPI */
r_if
c_cond
(paren
id|cap.mechtype
op_eq
id|mechtype_individual_changer
op_logical_or
id|cap.mechtype
op_eq
id|mechtype_cartridge_changer
)paren
(brace
r_if
c_cond
(paren
(paren
id|nslots
op_assign
id|cdrom_number_of_slots
c_func
(paren
id|cdi
)paren
)paren
OG
l_int|1
)paren
(brace
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|is_changer
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|supp_disc_present
op_assign
l_int|1
suffix:semicolon
)brace
)brace
multiline_comment|/* The ACER/AOpen 24X cdrom has the speed fields byte-swapped */
r_if
c_cond
(paren
id|drive-&gt;id
op_logical_and
op_logical_neg
id|drive-&gt;id-&gt;model
(braket
l_int|0
)braket
op_logical_and
op_logical_neg
id|strncmp
c_func
(paren
id|drive-&gt;id-&gt;fw_rev
comma
l_string|&quot;241N&quot;
comma
l_int|4
)paren
)paren
(brace
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|current_speed
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|cap.curspeed
)paren
op_plus
(paren
l_int|176
op_div
l_int|2
)paren
)paren
op_div
l_int|176
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|max_speed
op_assign
(paren
(paren
(paren
r_int
r_int
)paren
id|cap.maxspeed
)paren
op_plus
(paren
l_int|176
op_div
l_int|2
)paren
)paren
op_div
l_int|176
suffix:semicolon
)brace
r_else
(brace
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|current_speed
op_assign
(paren
id|ntohs
c_func
(paren
id|cap.curspeed
)paren
op_plus
(paren
l_int|176
op_div
l_int|2
)paren
)paren
op_div
l_int|176
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|max_speed
op_assign
(paren
id|ntohs
c_func
(paren
id|cap.maxspeed
)paren
op_plus
(paren
l_int|176
op_div
l_int|2
)paren
)paren
op_div
l_int|176
suffix:semicolon
)brace
multiline_comment|/* don&squot;t print speed if the drive reported 0.&n;&t; */
id|printk
c_func
(paren
l_string|&quot;%s: ATAPI&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|max_speed
)paren
id|printk
c_func
(paren
l_string|&quot; %dX&quot;
comma
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|max_speed
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %s&quot;
comma
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd
ques
c_cond
l_string|&quot;DVD-ROM&quot;
suffix:colon
l_string|&quot;CD-ROM&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd_r
op_or
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd_ram
)paren
id|printk
(paren
l_string|&quot; DVD%s%s&quot;
comma
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd_r
)paren
ques
c_cond
l_string|&quot;-R&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd_ram
)paren
ques
c_cond
l_string|&quot;AM&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|cd_r
op_or
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|cd_rw
)paren
id|printk
(paren
l_string|&quot; CD%s%s&quot;
comma
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|cd_r
)paren
ques
c_cond
l_string|&quot;-R&quot;
suffix:colon
l_string|&quot;&quot;
comma
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|cd_rw
)paren
ques
c_cond
l_string|&quot;/RW&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|is_changer
)paren
id|printk
(paren
l_string|&quot; changer w/%d slots&quot;
comma
id|nslots
)paren
suffix:semicolon
r_else
id|printk
(paren
l_string|&quot; drive&quot;
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;, %dkB Cache&quot;
comma
id|be16_to_cpu
c_func
(paren
id|cap.buffer_size
)paren
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA
r_if
c_cond
(paren
id|drive-&gt;using_dma
)paren
(paren
r_void
)paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dmaproc
c_func
(paren
id|ide_dma_verbose
comma
id|drive
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA */
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|nslots
suffix:semicolon
)brace
DECL|function|ide_cdrom_add_settings
r_static
r_void
id|ide_cdrom_add_settings
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|major
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
suffix:semicolon
r_int
id|minor
op_assign
id|drive-&gt;select.b.unit
op_lshift
id|PARTN_BITS
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;breada_readahead&quot;
comma
id|SETTING_RW
comma
id|BLKRAGET
comma
id|BLKRASET
comma
id|TYPE_INT
comma
l_int|0
comma
l_int|255
comma
l_int|1
comma
l_int|2
comma
op_amp
id|read_ahead
(braket
id|major
)braket
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;file_readahead&quot;
comma
id|SETTING_RW
comma
id|BLKFRAGET
comma
id|BLKFRASET
comma
id|TYPE_INTA
comma
l_int|0
comma
id|INT_MAX
comma
l_int|1
comma
l_int|1024
comma
op_amp
id|max_readahead
(braket
id|major
)braket
(braket
id|minor
)braket
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;max_kb_per_request&quot;
comma
id|SETTING_RW
comma
id|BLKSECTGET
comma
id|BLKSECTSET
comma
id|TYPE_INTA
comma
l_int|1
comma
l_int|255
comma
l_int|1
comma
l_int|2
comma
op_amp
id|max_sectors
(braket
id|major
)braket
(braket
id|minor
)braket
comma
l_int|NULL
)paren
suffix:semicolon
id|ide_add_setting
c_func
(paren
id|drive
comma
l_string|&quot;dsc_overlap&quot;
comma
id|SETTING_RW
comma
op_minus
l_int|1
comma
op_minus
l_int|1
comma
id|TYPE_BYTE
comma
l_int|0
comma
l_int|1
comma
l_int|1
comma
l_int|1
comma
op_amp
id|drive-&gt;dsc_overlap
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_setup
r_int
id|ide_cdrom_setup
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|cdi
op_assign
op_amp
id|info-&gt;devinfo
suffix:semicolon
r_int
id|minor
op_assign
id|drive-&gt;select.b.unit
op_lshift
id|PARTN_BITS
suffix:semicolon
r_int
id|nslots
suffix:semicolon
multiline_comment|/*&n;&t; * default to read-only always and fix latter at the bottom&n;&t; */
id|set_device_ro
c_func
(paren
id|MKDEV
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
comma
id|minor
)paren
comma
l_int|1
)paren
suffix:semicolon
id|set_blocksize
c_func
(paren
id|MKDEV
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
comma
id|minor
)paren
comma
id|CD_FRAMESIZE
)paren
suffix:semicolon
id|drive-&gt;special.all
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;ready_stat
op_assign
l_int|0
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|media_changed
op_assign
l_int|1
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
op_assign
l_int|0
suffix:semicolon
id|CDROM_STATE_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|door_locked
op_assign
l_int|0
suffix:semicolon
macro_line|#if NO_DOOR_LOCKING
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
op_assign
l_int|1
suffix:semicolon
macro_line|#else
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_doorlock
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|drive-&gt;id
op_ne
l_int|NULL
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
op_assign
(paren
(paren
id|drive-&gt;id-&gt;config
op_amp
l_int|0x0060
)paren
op_eq
l_int|0x20
)paren
suffix:semicolon
r_else
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|drq_interrupt
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|is_changer
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|cd_r
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|cd_rw
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|test_write
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd_r
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd_ram
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|no_eject
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|supp_disc_present
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|audio_play
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|close_tray
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* limit transfer size per interrupt. */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|limit_nframes
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* a testament to the nice quality of Samsung drives... */
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;SAMSUNG CD-ROM SCR-2430&quot;
)paren
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|limit_nframes
op_assign
l_int|1
suffix:semicolon
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;SAMSUNG CD-ROM SCR-2432&quot;
)paren
)paren
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|limit_nframes
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* the 3231 model does not support the SET_CD_SPEED command */
r_else
r_if
c_cond
(paren
op_logical_neg
id|strcmp
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;SAMSUNG CD-ROM SCR-3231&quot;
)paren
)paren
id|cdi-&gt;mask
op_or_assign
id|CDC_SELECT_SPEED
suffix:semicolon
)brace
macro_line|#if ! STANDARD_ATAPI
multiline_comment|/* by default Sanyo 3 CD changer support is turned off and&n;           ATAPI Rev 2.2+ standard support for CD changers is used */
id|cdi-&gt;sanyo_slot
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|nec260
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_as_bcd
op_assign
l_int|0
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|subchan_as_bcd
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;id
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;V003S0DS&quot;
)paren
op_eq
l_int|0
op_logical_and
id|drive-&gt;id-&gt;fw_rev
(braket
l_int|4
)braket
op_eq
l_char|&squot;1&squot;
op_logical_and
id|drive-&gt;id-&gt;fw_rev
(braket
l_int|6
)braket
op_le
l_char|&squot;2&squot;
)paren
(brace
multiline_comment|/* Vertos 300.&n;&t;&t;&t;   Some versions of this drive like to talk BCD. */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|subchan_as_bcd
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;V006E0DS&quot;
)paren
op_eq
l_int|0
op_logical_and
id|drive-&gt;id-&gt;fw_rev
(braket
l_int|4
)braket
op_eq
l_char|&squot;1&squot;
op_logical_and
id|drive-&gt;id-&gt;fw_rev
(braket
l_int|6
)braket
op_le
l_char|&squot;2&squot;
)paren
(brace
multiline_comment|/* Vertos 600 ESD. */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|toctracks_as_bcd
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;NEC CD-ROM DRIVE:260&quot;
)paren
op_eq
l_int|0
op_logical_and
id|strncmp
(paren
id|drive-&gt;id-&gt;fw_rev
comma
l_string|&quot;1.01&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* FIXME */
multiline_comment|/* Old NEC260 (not R).&n;&t;&t;&t;   This drive was released before the 1.2 version&n;&t;&t;&t;   of the spec. */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|tocaddr_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|subchan_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|nec260
op_assign
l_int|1
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|strcmp
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;WEARNES CDD-120&quot;
)paren
op_eq
l_int|0
op_logical_and
id|strncmp
(paren
id|drive-&gt;id-&gt;fw_rev
comma
l_string|&quot;A1.1&quot;
comma
l_int|4
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* FIXME */
multiline_comment|/* Wearnes */
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|playmsf_as_bcd
op_assign
l_int|1
suffix:semicolon
id|CDROM_CONFIG_FLAGS
(paren
id|drive
)paren
op_member_access_from_pointer
id|subchan_as_bcd
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Sanyo 3 CD changer uses a non-standard command&n;                    for CD changing */
r_else
r_if
c_cond
(paren
(paren
id|strcmp
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;CD-ROM CDR-C3 G&quot;
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|strcmp
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;CD-ROM CDR-C3G&quot;
)paren
op_eq
l_int|0
)paren
op_logical_or
(paren
id|strcmp
c_func
(paren
id|drive-&gt;id-&gt;model
comma
l_string|&quot;CD-ROM CDR_C36&quot;
)paren
op_eq
l_int|0
)paren
)paren
(brace
multiline_comment|/* uses CD in slot 0 when value is set to 3 */
id|cdi-&gt;sanyo_slot
op_assign
l_int|3
suffix:semicolon
)brace
)brace
macro_line|#endif /* not STANDARD_ATAPI */
id|info-&gt;toc
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;buffer
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;sector_buffered
op_assign
l_int|0
suffix:semicolon
id|info-&gt;nsectors_buffered
op_assign
l_int|0
suffix:semicolon
id|info-&gt;changer_info
op_assign
l_int|NULL
suffix:semicolon
id|info-&gt;last_block
op_assign
l_int|0
suffix:semicolon
id|info-&gt;start_seek
op_assign
l_int|0
suffix:semicolon
id|nslots
op_assign
id|ide_cdrom_probe_capabilities
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CDROM_CONFIG_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|dvd_ram
)paren
id|set_device_ro
c_func
(paren
id|MKDEV
c_func
(paren
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
comma
id|minor
)paren
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ide_cdrom_register
(paren
id|drive
comma
id|nslots
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: ide_cdrom_setup failed to register device with the cdrom driver.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|info-&gt;devinfo.handle
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|ide_cdrom_add_settings
c_func
(paren
id|drive
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* Forwarding functions to generic routines. */
r_static
DECL|function|ide_cdrom_ioctl
r_int
id|ide_cdrom_ioctl
(paren
id|ide_drive_t
op_star
id|drive
comma
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
(brace
r_return
id|cdrom_fops.ioctl
(paren
id|inode
comma
id|file
comma
id|cmd
comma
id|arg
)paren
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_open
r_int
id|ide_cdrom_open
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_int
id|rc
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;buffer
op_eq
l_int|NULL
)paren
id|info-&gt;buffer
op_assign
(paren
r_char
op_star
)paren
id|kmalloc
c_func
(paren
id|SECTOR_BUFFER_SIZE
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|rc
op_assign
id|cdrom_fops
dot
id|open
c_func
(paren
id|ip
comma
id|fp
)paren
)paren
)paren
(brace
id|drive-&gt;usage
op_decrement
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_return
id|rc
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_release
r_void
id|ide_cdrom_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|cdrom_fops.release
(paren
id|inode
comma
id|file
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_check_media_change
r_int
id|ide_cdrom_check_media_change
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_return
id|cdrom_fops
dot
id|check_media_change
c_func
(paren
id|MKDEV
(paren
id|HWIF
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
comma
(paren
id|drive-&gt;select.b.unit
)paren
op_lshift
id|PARTN_BITS
)paren
)paren
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_revalidate
r_void
id|ide_cdrom_revalidate
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|atapi_toc
op_star
id|toc
suffix:semicolon
r_int
id|minor
op_assign
id|drive-&gt;select.b.unit
op_lshift
id|PARTN_BITS
suffix:semicolon
r_struct
id|request_sense
id|sense
suffix:semicolon
id|cdrom_read_toc
c_func
(paren
id|drive
comma
op_amp
id|sense
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CDROM_STATE_FLAGS
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|toc_valid
)paren
r_return
suffix:semicolon
id|toc
op_assign
id|info-&gt;toc
suffix:semicolon
multiline_comment|/* for general /dev/cdrom like mounting, one big disc */
id|drive-&gt;part
(braket
l_int|0
)braket
dot
id|nr_sects
op_assign
id|toc-&gt;capacity
op_star
id|SECTORS_PER_FRAME
suffix:semicolon
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|gd-&gt;sizes
(braket
id|minor
)braket
op_assign
id|toc-&gt;capacity
op_star
id|BLOCKS_PER_FRAME
suffix:semicolon
id|blk_size
(braket
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|major
)braket
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|gd-&gt;sizes
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_capacity
r_int
r_int
id|ide_cdrom_capacity
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|capacity
suffix:semicolon
r_if
c_cond
(paren
id|cdrom_read_capacity
c_func
(paren
id|drive
comma
op_amp
id|capacity
comma
l_int|NULL
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_return
id|capacity
op_star
id|SECTORS_PER_FRAME
suffix:semicolon
)brace
r_static
DECL|function|ide_cdrom_cleanup
r_int
id|ide_cdrom_cleanup
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_struct
id|cdrom_info
op_star
id|info
op_assign
id|drive-&gt;driver_data
suffix:semicolon
r_struct
id|cdrom_device_info
op_star
id|devinfo
op_assign
op_amp
id|info-&gt;devinfo
suffix:semicolon
r_if
c_cond
(paren
id|ide_unregister_subdriver
(paren
id|drive
)paren
)paren
r_return
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;buffer
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|info-&gt;buffer
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;toc
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|info-&gt;toc
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info-&gt;changer_info
op_ne
l_int|NULL
)paren
id|kfree
c_func
(paren
id|info-&gt;changer_info
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devinfo-&gt;handle
op_eq
id|drive
op_logical_and
id|unregister_cdrom
(paren
id|devinfo
)paren
)paren
id|printk
(paren
l_string|&quot;%s: ide_cdrom_cleanup failed to unregister device from the cdrom driver.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|info
)paren
suffix:semicolon
id|drive-&gt;driver_data
op_assign
l_int|NULL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ide_cdrom_driver
r_static
id|ide_driver_t
id|ide_cdrom_driver
op_assign
(brace
id|name
suffix:colon
l_string|&quot;ide-cdrom&quot;
comma
id|version
suffix:colon
id|IDECD_VERSION
comma
id|media
suffix:colon
id|ide_cdrom
comma
id|supports_dma
suffix:colon
l_int|1
comma
id|supports_dsc_overlap
suffix:colon
l_int|1
comma
id|cleanup
suffix:colon
id|ide_cdrom_cleanup
comma
id|do_request
suffix:colon
id|ide_do_rw_cdrom
comma
id|ioctl
suffix:colon
id|ide_cdrom_ioctl
comma
id|open
suffix:colon
id|ide_cdrom_open
comma
id|release
suffix:colon
id|ide_cdrom_release
comma
id|media_change
suffix:colon
id|ide_cdrom_check_media_change
comma
id|revalidate
suffix:colon
id|ide_cdrom_revalidate
comma
id|capacity
suffix:colon
id|ide_cdrom_capacity
comma
)brace
suffix:semicolon
r_int
id|ide_cdrom_init
c_func
(paren
r_void
)paren
suffix:semicolon
DECL|variable|ide_cdrom_module
r_static
id|ide_module_t
id|ide_cdrom_module
op_assign
(brace
id|IDE_DRIVER_MODULE
comma
id|ide_cdrom_init
comma
op_amp
id|ide_cdrom_driver
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* options */
DECL|variable|ignore
r_char
op_star
id|ignore
op_assign
l_int|NULL
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|ignore
comma
l_string|&quot;s&quot;
)paren
suffix:semicolon
id|MODULE_DESCRIPTION
c_func
(paren
l_string|&quot;ATAPI CD-ROM Driver&quot;
)paren
suffix:semicolon
DECL|function|ide_cdrom_exit
r_static
r_void
id|__exit
id|ide_cdrom_exit
c_func
(paren
r_void
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_int
id|failed
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
id|drive
op_assign
id|ide_scan_devices
(paren
id|ide_cdrom
comma
id|ide_cdrom_driver.name
comma
op_amp
id|ide_cdrom_driver
comma
id|failed
)paren
)paren
op_ne
l_int|NULL
)paren
r_if
c_cond
(paren
id|ide_cdrom_cleanup
(paren
id|drive
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: cleanup_module() called while still busy&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|failed
op_increment
suffix:semicolon
)brace
id|ide_unregister_module
(paren
op_amp
id|ide_cdrom_module
)paren
suffix:semicolon
)brace
DECL|function|ide_cdrom_init
r_int
id|ide_cdrom_init
c_func
(paren
r_void
)paren
(brace
id|ide_drive_t
op_star
id|drive
suffix:semicolon
r_struct
id|cdrom_info
op_star
id|info
suffix:semicolon
r_int
id|failed
op_assign
l_int|0
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_while
c_loop
(paren
(paren
id|drive
op_assign
id|ide_scan_devices
(paren
id|ide_cdrom
comma
id|ide_cdrom_driver.name
comma
l_int|NULL
comma
id|failed
op_increment
)paren
)paren
op_ne
l_int|NULL
)paren
(brace
multiline_comment|/* skip drives that we were told to ignore */
r_if
c_cond
(paren
id|ignore
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
id|strstr
c_func
(paren
id|ignore
comma
id|drive-&gt;name
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide-cd: ignoring drive %s&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|drive-&gt;scsi
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide-cd: passing drive %s to ide-scsi emulation.&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|info
op_assign
(paren
r_struct
id|cdrom_info
op_star
)paren
id|kmalloc
(paren
r_sizeof
(paren
r_struct
id|cdrom_info
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|info
op_eq
l_int|NULL
)paren
(brace
id|printk
(paren
l_string|&quot;%s: Can&squot;t allocate a cdrom structure&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ide_register_subdriver
(paren
id|drive
comma
op_amp
id|ide_cdrom_driver
comma
id|IDE_SUBDRIVER_VERSION
)paren
)paren
(brace
id|printk
(paren
l_string|&quot;%s: Failed to register the driver with ide.c&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
id|kfree
(paren
id|info
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|memset
(paren
id|info
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|cdrom_info
)paren
)paren
suffix:semicolon
id|drive-&gt;driver_data
op_assign
id|info
suffix:semicolon
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busy
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|ide_cdrom_setup
(paren
id|drive
)paren
)paren
(brace
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busy
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|ide_cdrom_cleanup
(paren
id|drive
)paren
)paren
id|printk
(paren
l_string|&quot;%s: ide_cdrom_cleanup failed in ide_cdrom_init&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|DRIVER
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|busy
op_decrement
suffix:semicolon
id|failed
op_decrement
suffix:semicolon
)brace
id|ide_register_module
c_func
(paren
op_amp
id|ide_cdrom_module
)paren
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|variable|ide_cdrom_init
id|module_init
c_func
(paren
id|ide_cdrom_init
)paren
suffix:semicolon
DECL|variable|ide_cdrom_exit
id|module_exit
c_func
(paren
id|ide_cdrom_exit
)paren
suffix:semicolon
eof
