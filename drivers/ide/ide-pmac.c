multiline_comment|/*&n; * linux/drivers/ide/ide-pmac.c&t;&t;Version ?.??&t;Mar. 18, 2000&n; *&n; * Support for IDE interfaces on PowerMacs.&n; * These IDE interfaces are memory-mapped and have a DBDMA channel&n; * for doing DMA.&n; *&n; *  Copyright (C) 1998 Paul Mackerras.&n; *&n; *  Bits from Benjamin Herrenschmidt&n; *&n; *  This program is free software; you can redistribute it and/or&n; *  modify it under the terms of the GNU General Public License&n; *  as published by the Free Software Foundation; either version&n; *  2 of the License, or (at your option) any later version.&n; *&n; * Some code taken from drivers/ide/ide-dma.c:&n; *&n; *  Copyright (c) 1995-1998  Mark Lord&n; *&n; */
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;asm/prom.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/dbdma.h&gt;
macro_line|#include &lt;asm/ide.h&gt;
macro_line|#include &lt;asm/mediabay.h&gt;
macro_line|#include &lt;asm/feature.h&gt;
macro_line|#ifdef CONFIG_PMAC_PBOOK
macro_line|#include &lt;linux/adb.h&gt;
macro_line|#include &lt;linux/pmu.h&gt;
macro_line|#include &lt;asm/irq.h&gt;
macro_line|#endif
macro_line|#include &quot;ide_modes.h&quot;
r_extern
r_char
op_star
id|ide_dmafunc_verbose
c_func
(paren
id|ide_dma_action_t
id|dmafunc
)paren
suffix:semicolon
DECL|macro|IDE_PMAC_DEBUG
macro_line|#undef IDE_PMAC_DEBUG
DECL|macro|IDE_SYSCLK_NS
mdefine_line|#define IDE_SYSCLK_NS&t;&t;30
DECL|macro|IDE_SYSCLK_ULTRA_PS
mdefine_line|#define IDE_SYSCLK_ULTRA_PS&t;0x1d4c /* (15 * 1000 / 2)*/
DECL|struct|pmac_ide_hwif
r_struct
id|pmac_ide_hwif
(brace
DECL|member|regbase
id|ide_ioreg_t
id|regbase
suffix:semicolon
DECL|member|irq
r_int
id|irq
suffix:semicolon
DECL|member|kind
r_int
id|kind
suffix:semicolon
DECL|member|aapl_bus_id
r_int
id|aapl_bus_id
suffix:semicolon
DECL|member|node
r_struct
id|device_node
op_star
id|node
suffix:semicolon
DECL|member|timings
id|u32
id|timings
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
DECL|member|dma_regs
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma_regs
suffix:semicolon
DECL|member|dma_table
r_struct
id|dbdma_cmd
op_star
id|dma_table
suffix:semicolon
macro_line|#endif
DECL|variable|pmac_ide
)brace
id|pmac_ide
(braket
id|MAX_HWIFS
)braket
suffix:semicolon
DECL|variable|pmac_ide_count
r_static
r_int
id|pmac_ide_count
suffix:semicolon
r_enum
(brace
DECL|enumerator|controller_ohare
id|controller_ohare
comma
multiline_comment|/* OHare based */
DECL|enumerator|controller_heathrow
id|controller_heathrow
comma
multiline_comment|/* Heathrow/Paddington */
DECL|enumerator|controller_kl_ata3
id|controller_kl_ata3
comma
multiline_comment|/* KeyLargo ATA-3 */
DECL|enumerator|controller_kl_ata4
id|controller_kl_ata4
multiline_comment|/* KeyLargo ATA-4 */
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
r_typedef
r_struct
(brace
DECL|member|accessTime
r_int
id|accessTime
suffix:semicolon
DECL|member|cycleTime
r_int
id|cycleTime
suffix:semicolon
DECL|typedef|pmac_ide_timing
)brace
id|pmac_ide_timing
suffix:semicolon
multiline_comment|/* Multiword DMA timings */
DECL|variable|mdma_timings
r_static
id|pmac_ide_timing
id|mdma_timings
(braket
)braket
op_assign
(brace
(brace
l_int|215
comma
l_int|480
)brace
comma
multiline_comment|/* Mode 0 */
(brace
l_int|80
comma
l_int|150
)brace
comma
multiline_comment|/*      1 */
(brace
l_int|70
comma
l_int|120
)brace
multiline_comment|/*      2 */
)brace
suffix:semicolon
multiline_comment|/* Ultra DMA timings (for use when I know how to calculate them */
DECL|variable|udma_timings
r_static
id|pmac_ide_timing
id|udma_timings
(braket
)braket
op_assign
(brace
(brace
l_int|0
comma
l_int|114
)brace
comma
multiline_comment|/* Mode 0 */
(brace
l_int|0
comma
l_int|75
)brace
comma
multiline_comment|/*      1 */
(brace
l_int|0
comma
l_int|55
)brace
comma
multiline_comment|/*      2 */
(brace
l_int|100
comma
l_int|45
)brace
comma
multiline_comment|/*      3 */
(brace
l_int|100
comma
l_int|25
)brace
multiline_comment|/*      4 */
)brace
suffix:semicolon
multiline_comment|/* allow up to 256 DBDMA commands per xfer */
DECL|macro|MAX_DCMDS
mdefine_line|#define MAX_DCMDS&t;&t;256
multiline_comment|/* Wait 1.5s for disk to answer on IDE bus after&n; * enable operation.&n; * NOTE: There is at least one case I know of a disk that needs about 10sec&n; *       before anwering on the bus. I beleive we could add a kernel command&n; *       line arg to override this delay for such cases.&n; */
DECL|macro|IDE_WAKEUP_DELAY_MS
mdefine_line|#define IDE_WAKEUP_DELAY_MS&t;1500
r_static
r_void
id|pmac_ide_setup_dma
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
id|ix
)paren
suffix:semicolon
r_static
r_int
id|pmac_ide_dmaproc
c_func
(paren
id|ide_dma_action_t
id|func
comma
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
r_static
r_int
id|pmac_ide_build_dmatable
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|ix
comma
r_int
id|wr
)paren
suffix:semicolon
r_static
r_int
id|pmac_ide_tune_chipset
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|speed
)paren
suffix:semicolon
r_static
r_void
id|pmac_ide_tuneproc
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|pio
)paren
suffix:semicolon
r_static
r_void
id|pmac_ide_selectproc
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PMAC */
macro_line|#ifdef CONFIG_PMAC_PBOOK
r_static
r_int
id|idepmac_notify_sleep
c_func
(paren
r_struct
id|pmu_sleep_notifier
op_star
id|self
comma
r_int
id|when
)paren
suffix:semicolon
DECL|variable|idepmac_sleep_notifier
r_struct
id|pmu_sleep_notifier
id|idepmac_sleep_notifier
op_assign
(brace
id|idepmac_notify_sleep
comma
id|SLEEP_LEVEL_BLOCK
comma
)brace
suffix:semicolon
macro_line|#endif /* CONFIG_PMAC_PBOOK */
r_static
r_int
DECL|function|pmac_ide_find
id|pmac_ide_find
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
id|ide_ioreg_t
id|base
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmac_ide_count
suffix:semicolon
id|i
op_increment
)paren
(brace
id|base
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|regbase
suffix:semicolon
r_if
c_cond
(paren
id|base
op_logical_and
id|base
op_eq
id|hwif-&gt;io_ports
(braket
l_int|0
)braket
)paren
r_return
id|i
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * N.B. this can&squot;t be an initfunc, because the media-bay task can&n; * call ide_[un]register at any time.&n; */
DECL|function|pmac_ide_init_hwif_ports
r_void
id|pmac_ide_init_hwif_ports
c_func
(paren
id|hw_regs_t
op_star
id|hw
comma
id|ide_ioreg_t
id|data_port
comma
id|ide_ioreg_t
id|ctrl_port
comma
r_int
op_star
id|irq
)paren
(brace
r_int
id|i
comma
id|ix
suffix:semicolon
r_if
c_cond
(paren
id|data_port
op_eq
l_int|0
)paren
r_return
suffix:semicolon
r_for
c_loop
(paren
id|ix
op_assign
l_int|0
suffix:semicolon
id|ix
OL
id|MAX_HWIFS
suffix:semicolon
op_increment
id|ix
)paren
r_if
c_cond
(paren
id|data_port
op_eq
id|pmac_ide
(braket
id|ix
)braket
dot
id|regbase
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|ix
op_ge
id|MAX_HWIFS
)paren
(brace
multiline_comment|/* Probably a PCI interface... */
r_for
c_loop
(paren
id|i
op_assign
id|IDE_DATA_OFFSET
suffix:semicolon
id|i
op_le
id|IDE_STATUS_OFFSET
suffix:semicolon
op_increment
id|i
)paren
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
id|data_port
op_plus
id|i
op_minus
id|IDE_DATA_OFFSET
suffix:semicolon
multiline_comment|/* XXX is this right? */
id|hw-&gt;io_ports
(braket
id|IDE_CONTROL_OFFSET
)braket
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
l_int|0
)paren
op_star
id|irq
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|8
suffix:semicolon
op_increment
id|i
)paren
id|hw-&gt;io_ports
(braket
id|i
)braket
op_assign
id|data_port
op_plus
id|i
op_star
l_int|0x10
suffix:semicolon
id|hw-&gt;io_ports
(braket
l_int|8
)braket
op_assign
id|data_port
op_plus
l_int|0x160
suffix:semicolon
r_if
c_cond
(paren
id|irq
op_ne
l_int|NULL
)paren
op_star
id|irq
op_assign
id|pmac_ide
(braket
id|ix
)braket
dot
id|irq
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|tuneproc
op_assign
id|pmac_ide_tuneproc
suffix:semicolon
id|ide_hwifs
(braket
id|ix
)braket
dot
id|selectproc
op_assign
id|pmac_ide_selectproc
suffix:semicolon
r_if
c_cond
(paren
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_regs
op_logical_and
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_table
)paren
(brace
id|ide_hwifs
(braket
id|ix
)braket
dot
id|dmaproc
op_assign
op_amp
id|pmac_ide_dmaproc
suffix:semicolon
macro_line|#ifdef CONFIG_PMAC_IDEDMA_AUTO
id|ide_hwifs
(braket
id|ix
)braket
dot
id|autodma
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
singleline_comment|//&t;&t;ide_hwifs[ix].speedproc = &amp;pmac_ide_tune_chipset;
)brace
)brace
macro_line|#if 0
multiline_comment|/* This one could be later extended to handle CMD IDE and be used by some kind&n; * of /proc interface. I want to be able to get the devicetree path of a block&n; * device for yaboot configuration&n; */
r_struct
id|device_node
op_star
id|pmac_ide_get_devnode
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|i
op_assign
id|pmac_ide_find
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
r_return
l_int|NULL
suffix:semicolon
r_return
id|pmac_ide
(braket
id|i
)braket
dot
id|node
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/* Setup timings for the selected drive (master/slave). I still need to verify if this&n; * is enough, I beleive selectproc will be called whenever an IDE command is started,&n; * but... */
r_static
r_void
DECL|function|pmac_ide_selectproc
id|pmac_ide_selectproc
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
r_int
id|i
op_assign
id|pmac_ide_find
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
r_return
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;select.all
op_amp
l_int|0x10
)paren
id|out_le32
c_func
(paren
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
l_int|0x200
op_plus
id|_IO_BASE
)paren
comma
id|pmac_ide
(braket
id|i
)braket
dot
id|timings
(braket
l_int|1
)braket
)paren
suffix:semicolon
r_else
id|out_le32
c_func
(paren
(paren
r_int
op_star
)paren
(paren
id|IDE_DATA_REG
op_plus
l_int|0x200
op_plus
id|_IO_BASE
)paren
comma
id|pmac_ide
(braket
id|i
)braket
dot
id|timings
(braket
l_int|0
)braket
)paren
suffix:semicolon
)brace
multiline_comment|/* Number of IDE_SYSCLK_NS ticks, argument is in nanoseconds */
DECL|macro|SYSCLK_TICKS
mdefine_line|#define SYSCLK_TICKS(t)&t;&t;(((t) + IDE_SYSCLK_NS - 1) / IDE_SYSCLK_NS)
DECL|macro|SYSCLK_TICKS_UDMA
mdefine_line|#define SYSCLK_TICKS_UDMA(t)&t;(((t) + IDE_SYSCLK_ULTRA_PS - 1) / IDE_SYSCLK_ULTRA_PS)
multiline_comment|/* Calculate PIO timings */
r_static
r_void
DECL|function|pmac_ide_tuneproc
id|pmac_ide_tuneproc
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|pio
)paren
(brace
id|ide_pio_data_t
id|d
suffix:semicolon
r_int
id|i
suffix:semicolon
id|u32
op_star
id|timings
suffix:semicolon
r_int
id|accessTicks
comma
id|recTicks
suffix:semicolon
id|i
op_assign
id|pmac_ide_find
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
r_return
suffix:semicolon
id|pio
op_assign
id|ide_get_best_pio_mode
c_func
(paren
id|drive
comma
id|pio
comma
l_int|4
comma
op_amp
id|d
)paren
suffix:semicolon
id|accessTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|ide_pio_timings
(braket
id|pio
)braket
dot
id|active_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;select.all
op_amp
l_int|0x10
)paren
id|timings
op_assign
op_amp
id|pmac_ide
(braket
id|i
)braket
dot
id|timings
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|timings
op_assign
op_amp
id|pmac_ide
(braket
id|i
)braket
dot
id|timings
(braket
l_int|0
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pmac_ide
(braket
id|i
)braket
dot
id|kind
op_eq
id|controller_kl_ata4
)paren
(brace
multiline_comment|/* The &quot;ata-4&quot; IDE controller of Core99 machines */
id|accessTicks
op_assign
id|SYSCLK_TICKS_UDMA
c_func
(paren
id|ide_pio_timings
(braket
id|pio
)braket
dot
id|active_time
op_star
l_int|1000
)paren
suffix:semicolon
id|recTicks
op_assign
id|SYSCLK_TICKS_UDMA
c_func
(paren
id|d.cycle_time
op_star
l_int|1000
)paren
op_minus
id|accessTicks
suffix:semicolon
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
l_int|0x1FFFFFC00
)paren
op_or
id|accessTicks
op_or
(paren
id|recTicks
op_lshift
l_int|5
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The old &quot;ata-3&quot; IDE controller */
id|accessTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|ide_pio_timings
(braket
id|pio
)braket
dot
id|active_time
)paren
suffix:semicolon
r_if
c_cond
(paren
id|accessTicks
OL
l_int|4
)paren
id|accessTicks
op_assign
l_int|4
suffix:semicolon
id|recTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|d.cycle_time
)paren
op_minus
id|accessTicks
op_minus
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|recTicks
OL
l_int|1
)paren
id|recTicks
op_assign
l_int|1
suffix:semicolon
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
l_int|0xFFFFFF800
)paren
op_or
id|accessTicks
op_or
(paren
id|recTicks
op_lshift
l_int|5
)paren
suffix:semicolon
)brace
macro_line|#ifdef IDE_PMAC_DEBUG
id|printk
c_func
(paren
l_string|&quot;ide_pmac: Set PIO timing for mode %d, reg: 0x%08x&bslash;n&quot;
comma
id|pio
comma
op_star
id|timings
)paren
suffix:semicolon
macro_line|#endif&t;
r_if
c_cond
(paren
id|drive-&gt;select.all
op_eq
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
)paren
id|pmac_ide_selectproc
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
id|ide_ioreg_t
DECL|function|pmac_ide_get_base
id|pmac_ide_get_base
c_func
(paren
r_int
id|index
)paren
(brace
r_return
id|pmac_ide
(braket
id|index
)braket
dot
id|regbase
suffix:semicolon
)brace
DECL|variable|ide_majors
r_static
r_int
id|ide_majors
(braket
)braket
op_assign
(brace
l_int|3
comma
l_int|22
comma
l_int|33
comma
l_int|34
comma
l_int|56
comma
l_int|57
)brace
suffix:semicolon
id|kdev_t
id|__init
DECL|function|pmac_find_ide_boot
id|pmac_find_ide_boot
c_func
(paren
r_char
op_star
id|bootdevice
comma
r_int
id|n
)paren
(brace
r_int
id|i
suffix:semicolon
multiline_comment|/*&n;&t; * Look through the list of IDE interfaces for this one.&n;&t; */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmac_ide_count
suffix:semicolon
op_increment
id|i
)paren
(brace
r_char
op_star
id|name
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|pmac_ide
(braket
id|i
)braket
dot
id|node
op_logical_or
op_logical_neg
id|pmac_ide
(braket
id|i
)braket
dot
id|node-&gt;full_name
)paren
r_continue
suffix:semicolon
id|name
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|node-&gt;full_name
suffix:semicolon
r_if
c_cond
(paren
id|memcmp
c_func
(paren
id|name
comma
id|bootdevice
comma
id|n
)paren
op_eq
l_int|0
op_logical_and
id|name
(braket
id|n
)braket
op_eq
l_int|0
)paren
(brace
multiline_comment|/* XXX should cope with the 2nd drive as well... */
r_return
id|MKDEV
c_func
(paren
id|ide_majors
(braket
id|i
)braket
comma
l_int|0
)paren
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_void
id|__init
DECL|function|pmac_ide_probe
id|pmac_ide_probe
c_func
(paren
r_void
)paren
(brace
r_struct
id|device_node
op_star
id|np
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|device_node
op_star
id|atas
suffix:semicolon
r_struct
id|device_node
op_star
id|p
comma
op_star
op_star
id|pp
comma
op_star
id|removables
comma
op_star
op_star
id|rp
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_int
id|irq
comma
id|big_delay
suffix:semicolon
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
r_if
c_cond
(paren
id|_machine
op_ne
id|_MACH_Pmac
)paren
r_return
suffix:semicolon
id|pp
op_assign
op_amp
id|atas
suffix:semicolon
id|rp
op_assign
op_amp
id|removables
suffix:semicolon
id|p
op_assign
id|find_devices
c_func
(paren
l_string|&quot;ATA&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
id|p
op_assign
id|find_devices
c_func
(paren
l_string|&quot;IDE&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
id|p
op_assign
id|find_type_devices
c_func
(paren
l_string|&quot;ide&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|p
op_eq
l_int|NULL
)paren
id|p
op_assign
id|find_type_devices
c_func
(paren
l_string|&quot;ata&quot;
)paren
suffix:semicolon
multiline_comment|/* Move removable devices such as the media-bay CDROM&n;&t;   on the PB3400 to the end of the list. */
r_for
c_loop
(paren
suffix:semicolon
id|p
op_ne
l_int|NULL
suffix:semicolon
id|p
op_assign
id|p-&gt;next
)paren
(brace
r_if
c_cond
(paren
id|p-&gt;parent
op_logical_and
id|p-&gt;parent-&gt;type
op_logical_and
id|strcasecmp
c_func
(paren
id|p-&gt;parent-&gt;type
comma
l_string|&quot;media-bay&quot;
)paren
op_eq
l_int|0
)paren
(brace
op_star
id|rp
op_assign
id|p
suffix:semicolon
id|rp
op_assign
op_amp
id|p-&gt;next
suffix:semicolon
)brace
r_else
(brace
op_star
id|pp
op_assign
id|p
suffix:semicolon
id|pp
op_assign
op_amp
id|p-&gt;next
suffix:semicolon
)brace
)brace
op_star
id|rp
op_assign
l_int|NULL
suffix:semicolon
op_star
id|pp
op_assign
id|removables
suffix:semicolon
id|big_delay
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
comma
id|np
op_assign
id|atas
suffix:semicolon
id|i
OL
id|MAX_HWIFS
op_logical_and
id|np
op_ne
l_int|NULL
suffix:semicolon
id|np
op_assign
id|np-&gt;next
)paren
(brace
r_struct
id|device_node
op_star
id|tp
suffix:semicolon
r_int
op_star
id|bidp
suffix:semicolon
multiline_comment|/*&n;&t;&t; * If this node is not under a mac-io or dbdma node,&n;&t;&t; * leave it to the generic PCI driver.&n;&t;&t; */
r_for
c_loop
(paren
id|tp
op_assign
id|np-&gt;parent
suffix:semicolon
id|tp
op_ne
l_int|0
suffix:semicolon
id|tp
op_assign
id|tp-&gt;parent
)paren
r_if
c_cond
(paren
id|tp-&gt;type
op_logical_and
(paren
id|strcmp
c_func
(paren
id|tp-&gt;type
comma
l_string|&quot;mac-io&quot;
)paren
op_eq
l_int|0
op_logical_or
id|strcmp
c_func
(paren
id|tp-&gt;type
comma
l_string|&quot;dbdma&quot;
)paren
op_eq
l_int|0
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|tp
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;n_addrs
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;ide: no address for device %s&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * If this slot is taken (e.g. by ide-pci.c) try the next one.&n;&t;&t; */
r_while
c_loop
(paren
id|i
OL
id|MAX_HWIFS
op_logical_and
id|ide_hwifs
(braket
id|i
)braket
dot
id|io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_ne
l_int|0
)paren
op_increment
id|i
suffix:semicolon
r_if
c_cond
(paren
id|i
op_ge
id|MAX_HWIFS
)paren
r_break
suffix:semicolon
id|base
op_assign
(paren
r_int
r_int
)paren
id|ioremap
c_func
(paren
id|np-&gt;addrs
(braket
l_int|0
)braket
dot
id|address
comma
l_int|0x200
)paren
op_minus
id|_IO_BASE
suffix:semicolon
multiline_comment|/* XXX This is bogus. Should be fixed in the registry by checking&n;&t;&t;   the kind of host interrupt controller, a bit like gatwick&n;&t;&t;   fixes in irq.c&n;&t;&t; */
r_if
c_cond
(paren
id|np-&gt;n_intrs
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide: no intrs for device %s, using 13&bslash;n&quot;
comma
id|np-&gt;full_name
)paren
suffix:semicolon
id|irq
op_assign
l_int|13
suffix:semicolon
)brace
r_else
(brace
id|irq
op_assign
id|np-&gt;intrs
(braket
l_int|0
)braket
dot
id|line
suffix:semicolon
)brace
id|pmac_ide
(braket
id|i
)braket
dot
id|regbase
op_assign
id|base
suffix:semicolon
id|pmac_ide
(braket
id|i
)braket
dot
id|irq
op_assign
id|irq
suffix:semicolon
id|pmac_ide
(braket
id|i
)braket
dot
id|node
op_assign
id|np
suffix:semicolon
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
l_string|&quot;keylargo-ata&quot;
)paren
)paren
(brace
r_if
c_cond
(paren
id|strcmp
c_func
(paren
id|np-&gt;name
comma
l_string|&quot;ata-4&quot;
)paren
op_eq
l_int|0
)paren
id|pmac_ide
(braket
id|i
)braket
dot
id|kind
op_assign
id|controller_kl_ata4
suffix:semicolon
r_else
id|pmac_ide
(braket
id|i
)braket
dot
id|kind
op_assign
id|controller_kl_ata3
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|device_is_compatible
c_func
(paren
id|np
comma
l_string|&quot;heathrow-ata&quot;
)paren
)paren
id|pmac_ide
(braket
id|i
)braket
dot
id|kind
op_assign
id|controller_heathrow
suffix:semicolon
r_else
id|pmac_ide
(braket
id|i
)braket
dot
id|kind
op_assign
id|controller_ohare
suffix:semicolon
id|bidp
op_assign
(paren
r_int
op_star
)paren
id|get_property
c_func
(paren
id|np
comma
l_string|&quot;AAPL,bus-id&quot;
comma
l_int|NULL
)paren
suffix:semicolon
id|pmac_ide
(braket
id|i
)braket
dot
id|aapl_bus_id
op_assign
id|bidp
ques
c_cond
op_star
id|bidp
suffix:colon
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|np-&gt;parent
op_logical_and
id|np-&gt;parent-&gt;name
op_logical_and
id|strcasecmp
c_func
(paren
id|np-&gt;parent-&gt;name
comma
l_string|&quot;media-bay&quot;
)paren
op_eq
l_int|0
)paren
(brace
id|media_bay_set_ide_infos
c_func
(paren
id|np-&gt;parent
comma
id|base
comma
id|irq
comma
id|i
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|pmac_ide
(braket
id|i
)braket
dot
id|kind
op_eq
id|controller_ohare
)paren
(brace
multiline_comment|/* The code below is having trouble on some ohare machines&n;&t;&t;&t; * (timing related ?). Until I can put my hand on one of these&n;&t;&t;&t; * units, I keep the old way&n;&t;&t;&t; */
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE0_enable
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* This is necessary to enable IDE when net-booting */
id|printk
c_func
(paren
l_string|&quot;pmac_ide: enabling IDE bus ID %d&bslash;n&quot;
comma
id|pmac_ide
(braket
id|i
)braket
dot
id|aapl_bus_id
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|pmac_ide
(braket
id|i
)braket
dot
id|aapl_bus_id
)paren
(brace
r_case
l_int|0
suffix:colon
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE0_reset
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE0_enable
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|feature_clear
c_func
(paren
id|np
comma
id|FEATURE_IDE0_reset
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE1_reset
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE1_enable
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|feature_clear
c_func
(paren
id|np
comma
id|FEATURE_IDE1_reset
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* This one exists only for KL, I don&squot;t know&n;&t;&t;&t;&t;   about any enable bit */
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE2_reset
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|feature_clear
c_func
(paren
id|np
comma
id|FEATURE_IDE2_reset
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|big_delay
op_assign
l_int|1
suffix:semicolon
)brace
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
id|pmac_ide_init_hwif_ports
c_func
(paren
op_amp
id|hwif-&gt;hw
comma
id|base
comma
l_int|0
comma
op_amp
id|hwif-&gt;irq
)paren
suffix:semicolon
id|memcpy
c_func
(paren
id|hwif-&gt;io_ports
comma
id|hwif-&gt;hw.io_ports
comma
r_sizeof
(paren
id|hwif-&gt;io_ports
)paren
)paren
suffix:semicolon
id|hwif-&gt;chipset
op_assign
id|ide_pmac
suffix:semicolon
id|hwif-&gt;noprobe
op_assign
(paren
op_logical_neg
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
)paren
op_logical_or
(paren
id|check_media_bay_by_base
c_func
(paren
id|base
comma
id|MB_CD
)paren
op_eq
op_minus
id|EINVAL
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
r_if
c_cond
(paren
id|np-&gt;n_addrs
op_ge
l_int|2
)paren
(brace
multiline_comment|/* has a DBDMA controller channel */
id|pmac_ide_setup_dma
c_func
(paren
id|np
comma
id|i
)paren
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PMAC */
op_increment
id|i
suffix:semicolon
)brace
id|pmac_ide_count
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|big_delay
)paren
id|mdelay
c_func
(paren
id|IDE_WAKEUP_DELAY_MS
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_PMAC_PBOOK
id|pmu_register_sleep_notifier
c_func
(paren
op_amp
id|idepmac_sleep_notifier
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_PMAC_PBOOK */
)brace
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
r_static
r_void
id|__init
DECL|function|pmac_ide_setup_dma
id|pmac_ide_setup_dma
c_func
(paren
r_struct
id|device_node
op_star
id|np
comma
r_int
id|ix
)paren
(brace
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_regs
op_assign
(paren
r_volatile
r_struct
id|dbdma_regs
op_star
)paren
id|ioremap
c_func
(paren
id|np-&gt;addrs
(braket
l_int|1
)braket
dot
id|address
comma
l_int|0x200
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Allocate space for the DBDMA commands.&n;&t; * The +2 is +1 for the stop command and +1 to allow for&n;&t; * aligning the start address to a multiple of 16 bytes.&n;&t; */
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_table
op_assign
(paren
r_struct
id|dbdma_cmd
op_star
)paren
id|kmalloc
c_func
(paren
(paren
id|MAX_DCMDS
op_plus
l_int|2
)paren
op_star
r_sizeof
(paren
r_struct
id|dbdma_cmd
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_table
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
l_string|&quot;%s: unable to allocate DMA command list&bslash;n&quot;
comma
id|ide_hwifs
(braket
id|ix
)braket
dot
id|name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|ide_hwifs
(braket
id|ix
)braket
dot
id|dmaproc
op_assign
op_amp
id|pmac_ide_dmaproc
suffix:semicolon
macro_line|#ifdef CONFIG_PMAC_IDEDMA_AUTO
id|ide_hwifs
(braket
id|ix
)braket
dot
id|autodma
op_assign
l_int|1
suffix:semicolon
macro_line|#endif
)brace
multiline_comment|/*&n; * pmac_ide_build_dmatable builds the DBDMA command list&n; * for a transfer and sets the DBDMA channel to point to it.&n; */
r_static
r_int
DECL|function|pmac_ide_build_dmatable
id|pmac_ide_build_dmatable
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|ix
comma
r_int
id|wr
)paren
(brace
r_struct
id|dbdma_cmd
op_star
id|table
comma
op_star
id|tstart
suffix:semicolon
r_int
id|count
op_assign
l_int|0
suffix:semicolon
r_struct
id|request
op_star
id|rq
op_assign
id|HWGROUP
c_func
(paren
id|drive
)paren
op_member_access_from_pointer
id|rq
suffix:semicolon
r_struct
id|buffer_head
op_star
id|bh
op_assign
id|rq-&gt;bh
suffix:semicolon
r_int
r_int
id|size
comma
id|addr
suffix:semicolon
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma
op_assign
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_regs
suffix:semicolon
id|table
op_assign
id|tstart
op_assign
(paren
r_struct
id|dbdma_cmd
op_star
)paren
id|DBDMA_ALIGN
c_func
(paren
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_table
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|dma-&gt;control
comma
(paren
id|RUN
op_or
id|PAUSE
op_or
id|FLUSH
op_or
id|WAKE
op_or
id|DEAD
)paren
op_lshift
l_int|16
)paren
suffix:semicolon
r_while
c_loop
(paren
id|in_le32
c_func
(paren
op_amp
id|dma-&gt;status
)paren
op_amp
id|RUN
)paren
id|udelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_do
(brace
multiline_comment|/*&n;&t;&t; * Determine addr and size of next buffer area.  We assume that&n;&t;&t; * individual virtual buffers are always composed linearly in&n;&t;&t; * physical memory.  For example, we assume that any 8kB buffer&n;&t;&t; * is always composed of two adjacent physical 4kB pages rather&n;&t;&t; * than two possibly non-adjacent physical 4kB pages.&n;&t;&t; */
r_if
c_cond
(paren
id|bh
op_eq
l_int|NULL
)paren
(brace
multiline_comment|/* paging requests have (rq-&gt;bh == NULL) */
id|addr
op_assign
id|virt_to_bus
c_func
(paren
id|rq-&gt;buffer
)paren
suffix:semicolon
id|size
op_assign
id|rq-&gt;nr_sectors
op_lshift
l_int|9
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* group sequential buffers into one large buffer */
id|addr
op_assign
id|virt_to_bus
c_func
(paren
id|bh-&gt;b_data
)paren
suffix:semicolon
id|size
op_assign
id|bh-&gt;b_size
suffix:semicolon
r_while
c_loop
(paren
(paren
id|bh
op_assign
id|bh-&gt;b_reqnext
)paren
op_ne
l_int|NULL
)paren
(brace
r_if
c_cond
(paren
(paren
id|addr
op_plus
id|size
)paren
op_ne
id|virt_to_bus
c_func
(paren
id|bh-&gt;b_data
)paren
)paren
r_break
suffix:semicolon
id|size
op_add_assign
id|bh-&gt;b_size
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t;&t; * Fill in the next DBDMA command block.&n;&t;&t; * Note that one DBDMA command can transfer&n;&t;&t; * at most 65535 bytes.&n;&t;&t; */
r_while
c_loop
(paren
id|size
)paren
(brace
r_int
r_int
id|tc
op_assign
(paren
id|size
OL
l_int|0xfe00
)paren
ques
c_cond
id|size
suffix:colon
l_int|0xfe00
suffix:semicolon
r_if
c_cond
(paren
op_increment
id|count
op_ge
id|MAX_DCMDS
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: DMA table too small&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* revert to PIO for this request */
)brace
id|st_le16
c_func
(paren
op_amp
id|table-&gt;command
comma
id|wr
ques
c_cond
id|OUTPUT_MORE
suffix:colon
id|INPUT_MORE
)paren
suffix:semicolon
id|st_le16
c_func
(paren
op_amp
id|table-&gt;req_count
comma
id|tc
)paren
suffix:semicolon
id|st_le32
c_func
(paren
op_amp
id|table-&gt;phy_addr
comma
id|addr
)paren
suffix:semicolon
id|table-&gt;cmd_dep
op_assign
l_int|0
suffix:semicolon
id|table-&gt;xfer_status
op_assign
l_int|0
suffix:semicolon
id|table-&gt;res_count
op_assign
l_int|0
suffix:semicolon
id|addr
op_add_assign
id|tc
suffix:semicolon
id|size
op_sub_assign
id|tc
suffix:semicolon
op_increment
id|table
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|bh
op_ne
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* convert the last command to an input/output last command */
r_if
c_cond
(paren
id|count
)paren
id|st_le16
c_func
(paren
op_amp
id|table
(braket
op_minus
l_int|1
)braket
dot
id|command
comma
id|wr
ques
c_cond
id|OUTPUT_LAST
suffix:colon
id|INPUT_LAST
)paren
suffix:semicolon
r_else
id|printk
c_func
(paren
id|KERN_DEBUG
l_string|&quot;%s: empty DMA table?&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
multiline_comment|/* add the stop command to the end of the list */
id|memset
c_func
(paren
id|table
comma
l_int|0
comma
r_sizeof
(paren
r_struct
id|dbdma_cmd
)paren
)paren
suffix:semicolon
id|out_le16
c_func
(paren
op_amp
id|table-&gt;command
comma
id|DBDMA_STOP
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|dma-&gt;cmdptr
comma
id|virt_to_bus
c_func
(paren
id|tstart
)paren
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* This is fun.  -DaveM */
DECL|macro|IDE_SETXFER
mdefine_line|#define IDE_SETXFER&t;&t;0x03
DECL|macro|IDE_SETFEATURE
mdefine_line|#define IDE_SETFEATURE&t;&t;0xef
DECL|macro|IDE_DMA2_ENABLE
mdefine_line|#define IDE_DMA2_ENABLE&t;&t;0x22
DECL|macro|IDE_DMA1_ENABLE
mdefine_line|#define IDE_DMA1_ENABLE&t;&t;0x21
DECL|macro|IDE_DMA0_ENABLE
mdefine_line|#define IDE_DMA0_ENABLE&t;&t;0x20
DECL|macro|IDE_UDMA4_ENABLE
mdefine_line|#define IDE_UDMA4_ENABLE&t;0x44
DECL|macro|IDE_UDMA3_ENABLE
mdefine_line|#define IDE_UDMA3_ENABLE&t;0x43
DECL|macro|IDE_UDMA2_ENABLE
mdefine_line|#define IDE_UDMA2_ENABLE&t;0x42
DECL|macro|IDE_UDMA1_ENABLE
mdefine_line|#define IDE_UDMA1_ENABLE&t;0x41
DECL|macro|IDE_UDMA0_ENABLE
mdefine_line|#define IDE_UDMA0_ENABLE&t;0x40
r_static
id|__inline__
r_int
r_char
DECL|function|dma_bits_to_command
id|dma_bits_to_command
c_func
(paren
r_int
r_char
id|bits
)paren
(brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x04
)paren
(brace
r_return
id|IDE_DMA2_ENABLE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x02
)paren
(brace
r_return
id|IDE_DMA1_ENABLE
suffix:semicolon
)brace
r_return
id|IDE_DMA0_ENABLE
suffix:semicolon
)brace
r_static
id|__inline__
r_int
r_char
DECL|function|udma_bits_to_command
id|udma_bits_to_command
c_func
(paren
r_int
r_char
id|bits
)paren
(brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x10
)paren
(brace
r_return
id|IDE_UDMA4_ENABLE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x08
)paren
(brace
r_return
id|IDE_UDMA3_ENABLE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x04
)paren
(brace
r_return
id|IDE_UDMA2_ENABLE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x02
)paren
(brace
r_return
id|IDE_UDMA1_ENABLE
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bits
op_amp
l_int|0x01
)paren
(brace
r_return
id|IDE_UDMA0_ENABLE
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
id|__inline__
r_int
DECL|function|wait_for_ready
id|wait_for_ready
c_func
(paren
id|ide_drive_t
op_star
id|drive
)paren
(brace
multiline_comment|/* Timeout bumped for some powerbooks */
r_int
id|timeout
op_assign
l_int|2000
suffix:semicolon
id|byte
id|stat
suffix:semicolon
r_while
c_loop
(paren
op_decrement
id|timeout
)paren
(brace
id|stat
op_assign
id|GET_STAT
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|stat
op_amp
id|BUSY_STAT
)paren
)paren
(brace
r_if
c_cond
(paren
id|drive-&gt;ready_stat
op_eq
l_int|0
)paren
r_break
suffix:semicolon
r_else
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|drive-&gt;ready_stat
)paren
op_logical_or
(paren
id|stat
op_amp
id|ERR_STAT
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
)brace
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stat
op_amp
id|ERR_STAT
)paren
op_logical_or
id|timeout
op_le
l_int|0
)paren
(brace
r_if
c_cond
(paren
id|stat
op_amp
id|ERR_STAT
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide_pmace: wait_for_ready, error status: %x&bslash;n&quot;
comma
id|stat
)paren
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|pmac_ide_do_setfeature
id|pmac_ide_do_setfeature
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|command
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|byte
id|old_select
suffix:semicolon
r_int
id|result
op_assign
l_int|1
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|old_select
op_assign
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|drive-&gt;select.all
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|IDE_SETXFER
comma
id|IDE_FEATURE_REG
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|command
comma
id|IDE_NSECTOR_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|wait_for_ready
c_func
(paren
id|drive
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;pmac_ide_do_setfeature disk not ready before SET_FEATURE!&bslash;n&quot;
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|OUT_BYTE
c_func
(paren
id|IDE_SETFEATURE
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
id|result
op_assign
id|wait_for_ready
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|result
)paren
id|printk
c_func
(paren
l_string|&quot;pmac_ide_do_setfeature disk not ready after SET_FEATURE !&bslash;n&quot;
)paren
suffix:semicolon
id|out
suffix:colon
id|OUT_BYTE
c_func
(paren
id|old_select
comma
id|IDE_SELECT_REG
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|result
suffix:semicolon
)brace
multiline_comment|/* Calculate MultiWord DMA timings */
r_static
r_int
DECL|function|pmac_ide_mdma_enable
id|pmac_ide_mdma_enable
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|idx
)paren
(brace
id|byte
id|bits
op_assign
id|drive-&gt;id-&gt;dma_mword
op_amp
l_int|0x07
suffix:semicolon
id|byte
id|feature
op_assign
id|dma_bits_to_command
c_func
(paren
id|bits
)paren
suffix:semicolon
id|u32
op_star
id|timings
suffix:semicolon
r_int
id|cycleTime
comma
id|accessTime
suffix:semicolon
r_int
id|accessTicks
comma
id|recTicks
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
multiline_comment|/* Set feature on drive */
id|printk
c_func
(paren
l_string|&quot;%s: Enabling MultiWord DMA %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|feature
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmac_ide_do_setfeature
c_func
(paren
id|drive
comma
id|feature
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Failed !&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;init_speed
)paren
id|drive-&gt;init_speed
op_assign
id|feature
suffix:semicolon
multiline_comment|/* which drive is it ? */
r_if
c_cond
(paren
id|drive-&gt;select.all
op_amp
l_int|0x10
)paren
id|timings
op_assign
op_amp
id|pmac_ide
(braket
id|idx
)braket
dot
id|timings
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|timings
op_assign
op_amp
id|pmac_ide
(braket
id|idx
)braket
dot
id|timings
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* Calculate accesstime and cycle time */
id|cycleTime
op_assign
id|mdma_timings
(braket
id|feature
op_amp
l_int|0xf
)braket
dot
id|cycleTime
suffix:semicolon
id|accessTime
op_assign
id|mdma_timings
(braket
id|feature
op_amp
l_int|0xf
)braket
dot
id|accessTime
suffix:semicolon
r_if
c_cond
(paren
(paren
id|id-&gt;field_valid
op_amp
l_int|2
)paren
op_logical_and
(paren
id|id-&gt;eide_dma_time
)paren
)paren
id|cycleTime
op_assign
id|id-&gt;eide_dma_time
suffix:semicolon
r_if
c_cond
(paren
(paren
id|pmac_ide
(braket
id|idx
)braket
dot
id|kind
op_eq
id|controller_ohare
)paren
op_logical_and
(paren
id|cycleTime
OL
l_int|150
)paren
)paren
id|cycleTime
op_assign
l_int|150
suffix:semicolon
multiline_comment|/* For ata-4 controller, we don&squot;t know the calculation */
r_if
c_cond
(paren
id|pmac_ide
(braket
id|idx
)braket
dot
id|kind
op_eq
id|controller_kl_ata4
)paren
(brace
id|accessTicks
op_assign
id|SYSCLK_TICKS_UDMA
c_func
(paren
id|accessTime
op_star
l_int|1000
)paren
suffix:semicolon
id|recTicks
op_assign
id|SYSCLK_TICKS_UDMA
c_func
(paren
id|cycleTime
op_star
l_int|1000
)paren
op_minus
id|accessTicks
suffix:semicolon
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
l_int|0xffe003ff
)paren
op_or
(paren
id|accessTicks
op_or
(paren
id|recTicks
op_lshift
l_int|5
)paren
)paren
op_lshift
l_int|10
suffix:semicolon
)brace
r_else
(brace
r_int
id|halfTick
op_assign
l_int|0
suffix:semicolon
r_int
id|origAccessTime
op_assign
id|accessTime
suffix:semicolon
r_int
id|origCycleTime
op_assign
id|cycleTime
suffix:semicolon
id|accessTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|accessTime
)paren
suffix:semicolon
r_if
c_cond
(paren
id|accessTicks
OL
l_int|1
)paren
id|accessTicks
op_assign
l_int|1
suffix:semicolon
id|accessTime
op_assign
id|accessTicks
op_star
id|IDE_SYSCLK_NS
suffix:semicolon
id|recTicks
op_assign
id|SYSCLK_TICKS
c_func
(paren
id|cycleTime
op_minus
id|accessTime
)paren
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|recTicks
OL
l_int|1
)paren
id|recTicks
op_assign
l_int|1
suffix:semicolon
id|cycleTime
op_assign
(paren
id|recTicks
op_plus
l_int|1
op_plus
id|accessTicks
)paren
op_star
id|IDE_SYSCLK_NS
suffix:semicolon
multiline_comment|/* KeyLargo ata-3 don&squot;t support the half-tick stuff */
r_if
c_cond
(paren
(paren
id|pmac_ide
(braket
id|idx
)braket
dot
id|kind
op_ne
id|controller_kl_ata3
)paren
op_logical_and
(paren
id|accessTicks
OG
l_int|1
)paren
op_logical_and
(paren
(paren
id|accessTime
op_minus
id|IDE_SYSCLK_NS
op_div
l_int|2
)paren
op_ge
id|origAccessTime
)paren
op_logical_and
(paren
(paren
id|cycleTime
op_minus
id|IDE_SYSCLK_NS
)paren
op_ge
id|origCycleTime
)paren
)paren
(brace
id|halfTick
op_assign
l_int|1
suffix:semicolon
id|accessTicks
op_decrement
suffix:semicolon
)brace
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
l_int|0x7FF
)paren
op_or
(paren
id|accessTicks
op_or
(paren
id|recTicks
op_lshift
l_int|5
)paren
op_or
(paren
id|halfTick
op_lshift
l_int|10
)paren
)paren
op_lshift
l_int|11
suffix:semicolon
)brace
macro_line|#ifdef IDE_PMAC_DEBUG
id|printk
c_func
(paren
l_string|&quot;ide_pmac: Set MDMA timing for mode %d, reg: 0x%08x&bslash;n&quot;
comma
id|feature
op_amp
l_int|0xf
comma
op_star
id|timings
)paren
suffix:semicolon
macro_line|#endif
id|drive-&gt;current_speed
op_assign
id|feature
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
multiline_comment|/* Calculate Ultra DMA timings */
r_static
r_int
DECL|function|pmac_ide_udma_enable
id|pmac_ide_udma_enable
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|idx
)paren
(brace
id|byte
id|bits
op_assign
id|drive-&gt;id-&gt;dma_ultra
op_amp
l_int|0x1f
suffix:semicolon
id|byte
id|feature
op_assign
id|udma_bits_to_command
c_func
(paren
id|bits
)paren
suffix:semicolon
r_int
id|cycleTime
comma
id|accessTime
suffix:semicolon
r_int
id|rdyToPauseTicks
comma
id|cycleTicks
suffix:semicolon
id|u32
op_star
id|timings
suffix:semicolon
multiline_comment|/* Set feature on drive */
id|printk
c_func
(paren
l_string|&quot;%s: Enabling Ultra DMA %d&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|feature
op_amp
l_int|0xf
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pmac_ide_do_setfeature
c_func
(paren
id|drive
comma
id|feature
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: Failed !&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;init_speed
)paren
id|drive-&gt;init_speed
op_assign
id|feature
suffix:semicolon
multiline_comment|/* which drive is it ? */
r_if
c_cond
(paren
id|drive-&gt;select.all
op_amp
l_int|0x10
)paren
id|timings
op_assign
op_amp
id|pmac_ide
(braket
id|idx
)braket
dot
id|timings
(braket
l_int|1
)braket
suffix:semicolon
r_else
id|timings
op_assign
op_amp
id|pmac_ide
(braket
id|idx
)braket
dot
id|timings
(braket
l_int|0
)braket
suffix:semicolon
id|cycleTime
op_assign
id|udma_timings
(braket
id|feature
op_amp
l_int|0xf
)braket
dot
id|cycleTime
suffix:semicolon
id|accessTime
op_assign
id|udma_timings
(braket
id|feature
op_amp
l_int|0xf
)braket
dot
id|accessTime
suffix:semicolon
id|rdyToPauseTicks
op_assign
id|SYSCLK_TICKS_UDMA
c_func
(paren
id|accessTime
op_star
l_int|1000
)paren
suffix:semicolon
id|cycleTicks
op_assign
id|SYSCLK_TICKS_UDMA
c_func
(paren
id|cycleTime
op_star
l_int|1000
)paren
suffix:semicolon
op_star
id|timings
op_assign
(paren
(paren
op_star
id|timings
)paren
op_amp
l_int|0xe00fffff
)paren
op_or
(paren
(paren
id|cycleTicks
op_lshift
l_int|1
)paren
op_or
(paren
id|rdyToPauseTicks
op_lshift
l_int|5
)paren
op_or
l_int|1
)paren
op_lshift
l_int|20
suffix:semicolon
id|drive-&gt;current_speed
op_assign
id|feature
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|pmac_ide_dma_onoff
id|pmac_ide_dma_onoff
c_func
(paren
id|ide_drive_t
op_star
id|drive
comma
r_int
id|enable
)paren
(brace
r_int
id|ata4
comma
id|udma
comma
id|idx
suffix:semicolon
r_struct
id|hd_driveid
op_star
id|id
op_assign
id|drive-&gt;id
suffix:semicolon
id|drive-&gt;using_dma
op_assign
l_int|0
suffix:semicolon
id|idx
op_assign
id|pmac_ide_find
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idx
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_eq
id|ide_floppy
)paren
id|enable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
(paren
(paren
id|id-&gt;capability
op_amp
l_int|1
)paren
op_eq
l_int|0
)paren
op_logical_and
op_logical_neg
id|check_drive_lists
c_func
(paren
id|drive
comma
id|GOOD_DMA_DRIVE
)paren
)paren
id|enable
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|check_drive_lists
c_func
(paren
id|drive
comma
id|BAD_DMA_DRIVE
)paren
)paren
id|enable
op_assign
l_int|0
suffix:semicolon
id|udma
op_assign
l_int|0
suffix:semicolon
id|ata4
op_assign
(paren
id|pmac_ide
(braket
id|idx
)braket
dot
id|kind
op_eq
id|controller_kl_ata4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|enable
)paren
(brace
r_if
c_cond
(paren
id|ata4
op_logical_and
(paren
id|drive-&gt;media
op_eq
id|ide_disk
)paren
op_logical_and
(paren
id|id-&gt;field_valid
op_amp
l_int|0x0004
)paren
op_logical_and
(paren
id|id-&gt;dma_ultra
op_amp
l_int|0x17
)paren
)paren
(brace
multiline_comment|/* UltraDMA modes. */
id|drive-&gt;using_dma
op_assign
id|pmac_ide_udma_enable
c_func
(paren
id|drive
comma
id|idx
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|drive-&gt;using_dma
op_logical_and
(paren
id|id-&gt;dma_mword
op_amp
l_int|0x0007
)paren
)paren
(brace
multiline_comment|/* Normal MultiWord DMA modes. */
id|drive-&gt;using_dma
op_assign
id|pmac_ide_mdma_enable
c_func
(paren
id|drive
comma
id|idx
)paren
suffix:semicolon
)brace
multiline_comment|/* Without this, strange things will happen on Keylargo-based&n;&t;&t; * machines&n;&t;&t; */
id|OUT_BYTE
c_func
(paren
l_int|0
comma
id|IDE_CONTROL_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;select.all
op_eq
id|IN_BYTE
c_func
(paren
id|IDE_SELECT_REG
)paren
)paren
id|pmac_ide_selectproc
c_func
(paren
id|drive
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|pmac_ide_dmaproc
r_int
id|pmac_ide_dmaproc
c_func
(paren
id|ide_dma_action_t
id|func
comma
id|ide_drive_t
op_star
id|drive
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
id|HWIF
c_func
(paren
id|drive
)paren
suffix:semicolon
r_int
id|ix
comma
id|dstat
suffix:semicolon
r_volatile
r_struct
id|dbdma_regs
op_star
id|dma
suffix:semicolon
multiline_comment|/* Can we stuff a pointer to our intf structure in config_data&n;&t; * or select_data in hwif ?&n;&t; */
id|ix
op_assign
id|pmac_ide_find
c_func
(paren
id|drive
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ix
OL
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|dma
op_assign
id|pmac_ide
(braket
id|ix
)braket
dot
id|dma_regs
suffix:semicolon
r_switch
c_cond
(paren
id|func
)paren
(brace
r_case
id|ide_dma_on
suffix:colon
r_case
id|ide_dma_off
suffix:colon
r_case
id|ide_dma_off_quietly
suffix:colon
id|pmac_ide_dma_onoff
c_func
(paren
id|drive
comma
(paren
id|func
op_eq
id|ide_dma_on
)paren
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ide_dma_check
suffix:colon
id|printk
c_func
(paren
l_string|&quot;IDE-DMA check !&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;autodma
)paren
id|pmac_ide_dma_onoff
c_func
(paren
id|drive
comma
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ide_dma_read
suffix:colon
r_case
id|ide_dma_write
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|pmac_ide_build_dmatable
c_func
(paren
id|drive
comma
id|ix
comma
id|func
op_eq
id|ide_dma_write
)paren
)paren
r_return
l_int|1
suffix:semicolon
id|drive-&gt;waiting_for_dma
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|drive-&gt;media
op_ne
id|ide_disk
)paren
r_return
l_int|0
suffix:semicolon
id|ide_set_handler
c_func
(paren
id|drive
comma
op_amp
id|ide_dma_intr
comma
id|WAIT_CMD
comma
l_int|NULL
)paren
suffix:semicolon
id|OUT_BYTE
c_func
(paren
id|func
op_eq
id|ide_dma_write
ques
c_cond
id|WIN_WRITEDMA
suffix:colon
id|WIN_READDMA
comma
id|IDE_COMMAND_REG
)paren
suffix:semicolon
r_case
id|ide_dma_begin
suffix:colon
id|out_le32
c_func
(paren
op_amp
id|dma-&gt;control
comma
(paren
id|RUN
op_lshift
l_int|16
)paren
op_or
id|RUN
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|ide_dma_end
suffix:colon
id|drive-&gt;waiting_for_dma
op_assign
l_int|0
suffix:semicolon
id|dstat
op_assign
id|in_le32
c_func
(paren
op_amp
id|dma-&gt;status
)paren
suffix:semicolon
id|out_le32
c_func
(paren
op_amp
id|dma-&gt;control
comma
(paren
(paren
id|RUN
op_or
id|WAKE
op_or
id|DEAD
)paren
op_lshift
l_int|16
)paren
)paren
suffix:semicolon
multiline_comment|/* verify good dma status */
r_return
(paren
id|dstat
op_amp
(paren
id|RUN
op_or
id|DEAD
op_or
id|ACTIVE
)paren
)paren
op_ne
id|RUN
suffix:semicolon
r_case
id|ide_dma_test_irq
suffix:colon
r_return
(paren
id|in_le32
c_func
(paren
op_amp
id|dma-&gt;status
)paren
op_amp
(paren
id|RUN
op_or
id|ACTIVE
)paren
)paren
op_eq
id|RUN
suffix:semicolon
multiline_comment|/* Let&squot;s implement tose just in case someone wants them */
r_case
id|ide_dma_bad_drive
suffix:colon
r_case
id|ide_dma_good_drive
suffix:colon
r_return
id|check_drive_lists
c_func
(paren
id|drive
comma
(paren
id|func
op_eq
id|ide_dma_good_drive
)paren
)paren
suffix:semicolon
r_case
id|ide_dma_verbose
suffix:colon
r_return
id|report_drive_dmaing
c_func
(paren
id|drive
)paren
suffix:semicolon
r_case
id|ide_dma_retune
suffix:colon
r_case
id|ide_dma_lostirq
suffix:colon
r_case
id|ide_dma_timeout
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ide_pmac_dmaproc: chipset supported %s func only: %d&bslash;n&quot;
comma
id|ide_dmafunc_verbose
c_func
(paren
id|func
)paren
comma
id|func
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;ide_pmac_dmaproc: unsupported %s func: %d&bslash;n&quot;
comma
id|ide_dmafunc_verbose
c_func
(paren
id|func
)paren
comma
id|func
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_IDEDMA_PMAC */
macro_line|#ifdef CONFIG_PMAC_PBOOK
DECL|function|idepmac_sleep_disk
r_static
r_void
id|idepmac_sleep_disk
c_func
(paren
r_int
id|i
comma
r_int
r_int
id|base
)paren
(brace
r_struct
id|device_node
op_star
id|np
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|node
suffix:semicolon
r_int
id|j
suffix:semicolon
multiline_comment|/* FIXME: We only handle the master IDE */
r_if
c_cond
(paren
id|ide_hwifs
(braket
id|i
)braket
dot
id|drives
(braket
l_int|0
)braket
dot
id|media
op_eq
id|ide_disk
)paren
(brace
multiline_comment|/* Spin down the drive */
id|outb
c_func
(paren
l_int|0xa0
comma
id|base
op_plus
l_int|0x60
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0
comma
id|base
op_plus
l_int|0x30
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0
comma
id|base
op_plus
l_int|0x20
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0
comma
id|base
op_plus
l_int|0x40
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x0
comma
id|base
op_plus
l_int|0x50
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0xe0
comma
id|base
op_plus
l_int|0x70
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x2
comma
id|base
op_plus
l_int|0x160
)paren
suffix:semicolon
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|10
suffix:semicolon
id|j
op_increment
)paren
(brace
r_int
id|status
suffix:semicolon
id|mdelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
id|base
op_plus
l_int|0x70
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|BUSY_STAT
)paren
op_logical_and
(paren
id|status
op_amp
id|DRQ_STAT
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE0_reset
)paren
suffix:semicolon
id|feature_clear
c_func
(paren
id|np
comma
id|FEATURE_IDE0_enable
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|pmac_ide
(braket
id|i
)braket
dot
id|aapl_bus_id
)paren
(brace
r_case
l_int|0
suffix:colon
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE0_reset
)paren
suffix:semicolon
id|feature_clear
c_func
(paren
id|np
comma
id|FEATURE_IDE0_enable
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE1_reset
)paren
suffix:semicolon
id|feature_clear
c_func
(paren
id|np
comma
id|FEATURE_IDE1_enable
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE2_reset
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|pmac_ide
(braket
id|i
)braket
dot
id|timings
(braket
l_int|0
)braket
op_assign
l_int|0
suffix:semicolon
id|pmac_ide
(braket
id|i
)braket
dot
id|timings
(braket
l_int|1
)braket
op_assign
l_int|0
suffix:semicolon
)brace
DECL|function|idepmac_wake_disk
r_static
r_void
id|idepmac_wake_disk
c_func
(paren
r_int
id|i
comma
r_int
r_int
id|base
)paren
(brace
r_struct
id|device_node
op_star
id|np
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|node
suffix:semicolon
r_int
id|j
suffix:semicolon
multiline_comment|/* Revive IDE disk and controller */
r_switch
c_cond
(paren
id|pmac_ide
(braket
id|i
)braket
dot
id|aapl_bus_id
)paren
(brace
r_case
l_int|0
suffix:colon
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE0_reset
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE0_enable
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|feature_clear
c_func
(paren
id|np
comma
id|FEATURE_IDE0_reset
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE1_reset
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE1_enable
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|feature_clear
c_func
(paren
id|np
comma
id|FEATURE_IDE1_reset
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|2
suffix:colon
multiline_comment|/* This one exists only for KL, I don&squot;t know&n;&t;&t;   about any enable bit */
id|feature_set
c_func
(paren
id|np
comma
id|FEATURE_IDE2_reset
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|feature_clear
c_func
(paren
id|np
comma
id|FEATURE_IDE2_reset
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
id|mdelay
c_func
(paren
id|IDE_WAKEUP_DELAY_MS
)paren
suffix:semicolon
multiline_comment|/* Reset timings */
id|pmac_ide_selectproc
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|i
)braket
dot
id|drives
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
multiline_comment|/* Wait up to 10 seconds (enough for recent drives) */
r_for
c_loop
(paren
id|j
op_assign
l_int|0
suffix:semicolon
id|j
OL
l_int|100
suffix:semicolon
id|j
op_increment
)paren
(brace
r_int
id|status
suffix:semicolon
id|mdelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
id|status
op_assign
id|inb
c_func
(paren
id|base
op_plus
l_int|0x70
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|status
op_amp
id|BUSY_STAT
)paren
)paren
r_break
suffix:semicolon
)brace
)brace
multiline_comment|/* Here we handle media bay devices */
r_static
r_void
DECL|function|idepmac_wake_bay
id|idepmac_wake_bay
c_func
(paren
r_int
id|i
comma
r_int
r_int
id|base
)paren
(brace
r_int
id|timeout
suffix:semicolon
multiline_comment|/* Reset timings */
id|pmac_ide_selectproc
c_func
(paren
op_amp
id|ide_hwifs
(braket
id|i
)braket
dot
id|drives
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|mdelay
c_func
(paren
l_int|10
)paren
suffix:semicolon
id|timeout
op_assign
l_int|10000
suffix:semicolon
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|base
op_plus
l_int|0x70
)paren
op_amp
id|BUSY_STAT
)paren
op_logical_and
id|timeout
)paren
(brace
id|mdelay
c_func
(paren
l_int|1
)paren
suffix:semicolon
op_decrement
id|timeout
suffix:semicolon
)brace
)brace
multiline_comment|/* Note: We support only master drives for now. This will have to be&n; * improved if we want to handle sleep on the iMacDV where the CD-ROM&n; * is a slave&n; */
DECL|function|idepmac_notify_sleep
r_static
r_int
id|idepmac_notify_sleep
c_func
(paren
r_struct
id|pmu_sleep_notifier
op_star
id|self
comma
r_int
id|when
)paren
(brace
r_int
id|i
comma
id|ret
suffix:semicolon
r_int
r_int
id|base
suffix:semicolon
r_switch
c_cond
(paren
id|when
)paren
(brace
r_case
id|PBOOK_SLEEP_REQUEST
suffix:colon
r_break
suffix:semicolon
r_case
id|PBOOK_SLEEP_REJECT
suffix:colon
r_break
suffix:semicolon
r_case
id|PBOOK_SLEEP_NOW
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmac_ide_count
suffix:semicolon
op_increment
id|i
)paren
(brace
r_if
c_cond
(paren
(paren
id|base
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|regbase
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
multiline_comment|/* Disable irq during sleep */
id|disable_irq
c_func
(paren
id|pmac_ide
(braket
id|i
)braket
dot
id|irq
)paren
suffix:semicolon
id|ret
op_assign
id|check_media_bay_by_base
c_func
(paren
id|base
comma
id|MB_CD
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
op_minus
id|ENODEV
)paren
op_logical_and
id|ide_hwifs
(braket
id|i
)braket
dot
id|drives
(braket
l_int|0
)braket
dot
id|present
)paren
multiline_comment|/* not media bay - put the disk to sleep */
id|idepmac_sleep_disk
c_func
(paren
id|i
comma
id|base
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|PBOOK_WAKE
suffix:colon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|pmac_ide_count
suffix:semicolon
op_increment
id|i
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
suffix:semicolon
r_if
c_cond
(paren
(paren
id|base
op_assign
id|pmac_ide
(braket
id|i
)braket
dot
id|regbase
)paren
op_eq
l_int|0
)paren
r_continue
suffix:semicolon
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
multiline_comment|/* We don&squot;t handle media bay devices this way */
id|ret
op_assign
id|check_media_bay_by_base
c_func
(paren
id|base
comma
id|MB_CD
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ret
op_eq
op_minus
id|ENODEV
)paren
op_logical_and
id|ide_hwifs
(braket
id|i
)braket
dot
id|drives
(braket
l_int|0
)braket
dot
id|present
)paren
id|idepmac_wake_disk
c_func
(paren
id|i
comma
id|base
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|ret
op_eq
l_int|0
)paren
id|idepmac_wake_bay
c_func
(paren
id|i
comma
id|base
)paren
suffix:semicolon
id|enable_irq
c_func
(paren
id|pmac_ide
(braket
id|i
)braket
dot
id|irq
)paren
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
r_if
c_cond
(paren
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|present
op_logical_and
id|hwif-&gt;drives
(braket
l_int|0
)braket
dot
id|using_dma
)paren
id|pmac_ide_dma_onoff
c_func
(paren
op_amp
id|hwif-&gt;drives
(braket
l_int|0
)braket
comma
l_int|1
)paren
suffix:semicolon
macro_line|#endif&t;&t;&t;&t;
)brace
r_break
suffix:semicolon
)brace
r_return
id|PBOOK_SLEEP_OK
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_PMAC_PBOOK */
eof
