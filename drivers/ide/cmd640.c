multiline_comment|/*&n; *  linux/drivers/ide/cmd640.c&t;&t;Version 1.02  Sep 01, 1996&n; *&n; *  Copyright (C) 1995-1996  Linus Torvalds &amp; authors (see below)&n; */
multiline_comment|/*&n; *  Original authors:&t;abramov@cecmow.enet.dec.com (Igor Abramov)&n; *  &t;&t;&t;mlord@pobox.com (Mark Lord)&n; *&n; *  See linux/MAINTAINERS for address of current maintainer.&n; *&n; *  This file provides support for the advanced features and bugs&n; *  of IDE interfaces using the CMD Technologies 0640 IDE interface chip.&n; *&n; *  These chips are basically fucked by design, and getting this driver&n; *  to work on every motherboard design that uses this screwed chip seems&n; *  bloody well impossible.  However, we&squot;re still trying.&n; *&n; *  Version 0.97 worked for everybody.&n; *&n; *  User feedback is essential.  Many thanks to the beta test team:&n; *&n; *  A.Hartgers@stud.tue.nl, JZDQC@CUNYVM.CUNY.edu, abramov@cecmow.enet.dec.com,&n; *  bardj@utopia.ppp.sn.no, bart@gaga.tue.nl, bbol001@cs.auckland.ac.nz,&n; *  chrisc@dbass.demon.co.uk, dalecki@namu26.Num.Math.Uni-Goettingen.de,&n; *  derekn@vw.ece.cmu.edu, florian@btp2x3.phy.uni-bayreuth.de,&n; *  flynn@dei.unipd.it, gadio@netvision.net.il, godzilla@futuris.net,&n; *  j@pobox.com, jkemp1@mises.uni-paderborn.de, jtoppe@hiwaay.net,&n; *  kerouac@ssnet.com, meskes@informatik.rwth-aachen.de, hzoli@cs.elte.hu,&n; *  peter@udgaard.isgtec.com, phil@tazenda.demon.co.uk, roadcapw@cfw.com,&n; *  s0033las@sun10.vsz.bme.hu, schaffer@tam.cornell.edu, sjd@slip.net,&n; *  steve@ei.org, ulrpeg@bigcomm.gun.de, ism@tardis.ed.ac.uk, mack@cray.com&n; *  liug@mama.indstate.edu, and others.&n; *&n; *  Version 0.01&t;Initial version, hacked out of ide.c,&n; *&t;&t;&t;and #include&squot;d rather than compiled separately.&n; *&t;&t;&t;This will get cleaned up in a subsequent release.&n; *&n; *  Version 0.02&t;Fixes for vlb initialization code, enable prefetch&n; *&t;&t;&t;for versions &squot;B&squot; and &squot;C&squot; of chip by default,&n; *&t;&t;&t;some code cleanup.&n; *&n; *  Version 0.03&t;Added reset of secondary interface,&n; *&t;&t;&t;and black list for devices which are not compatible&n; *&t;&t;&t;with prefetch mode. Separate function for setting&n; *&t;&t;&t;prefetch is added, possibly it will be called some&n; *&t;&t;&t;day from ioctl processing code.&n; *&n; *  Version 0.04&t;Now configs/compiles separate from ide.c&n; *&n; *  Version 0.05&t;Major rewrite of interface timing code.&n; *&t;&t;&t;Added new function cmd640_set_mode to set PIO mode&n; *&t;&t;&t;from ioctl call. New drives added to black list.&n; *&n; *  Version 0.06&t;More code cleanup. Prefetch is enabled only for&n; *&t;&t;&t;detected hard drives, not included in prefetch&n; *&t;&t;&t;black list.&n; *&n; *  Version 0.07&t;Changed to more conservative drive tuning policy.&n; *&t;&t;&t;Unknown drives, which report PIO &lt; 4 are set to&n; *&t;&t;&t;(reported_PIO - 1) if it is supported, or to PIO0.&n; *&t;&t;&t;List of known drives extended by info provided by&n; *&t;&t;&t;CMD at their ftp site.&n; *&n; *  Version 0.08&t;Added autotune/noautotune support.&n; *&n; *  Version 0.09&t;Try to be smarter about 2nd port enabling.&n; *  Version 0.10&t;Be nice and don&squot;t reset 2nd port.&n; *  Version 0.11&t;Try to handle more wierd situations.&n; *&n; *  Version 0.12&t;Lots of bug fixes from Laszlo Peter&n; *&t;&t;&t;irq unmasking disabled for reliability.&n; *&t;&t;&t;try to be even smarter about the second port.&n; *&t;&t;&t;tidy up source code formatting.&n; *  Version 0.13&t;permit irq unmasking again.&n; *  Version 0.90&t;massive code cleanup, some bugs fixed.&n; *&t;&t;&t;defaults all drives to PIO mode0, prefetch off.&n; *&t;&t;&t;autotune is OFF by default, with compile time flag.&n; *&t;&t;&t;prefetch can be turned OFF/ON using &quot;hdparm -p8/-p9&quot;&n; *&t;&t;&t; (requires hdparm-3.1 or newer)&n; *  Version 0.91&t;first release to linux-kernel list.&n; *  Version 0.92&t;move initial reg dump to separate callable function&n; *&t;&t;&t;change &quot;readahead&quot; to &quot;prefetch&quot; to avoid confusion&n; *  Version 0.95&t;respect original BIOS timings unless autotuning.&n; *&t;&t;&t;tons of code cleanup and rearrangement.&n; *&t;&t;&t;added CONFIG_BLK_DEV_CMD640_ENHANCED option&n; *&t;&t;&t;prevent use of unmask when prefetch is on&n; *  Version 0.96&t;prevent use of io_32bit when prefetch is off&n; *  Version 0.97&t;fix VLB secondary interface for sjd@slip.net&n; *&t;&t;&t;other minor tune-ups:  0.96 was very good.&n; *  Version 0.98&t;ignore PCI version when disabled by BIOS&n; *  Version 0.99&t;display setup/active/recovery clocks with PIO mode&n; *  Version 1.00&t;Mmm.. cannot depend on PCMD_ENA in all systems&n; *  Version 1.01&t;slow/fast devsel can be selected with &quot;hdparm -p6/-p7&quot;&n; *&t;&t;&t; (&quot;fast&quot; is necessary for 32bit I/O in some systems)&n; *  Version 1.02&t;fix bug that resulted in slow &quot;setup times&quot;&n; *&t;&t;&t; (patch courtesy of Zoltan Hidvegi)&n; */
DECL|macro|REALLY_SLOW_IO
macro_line|#undef REALLY_SLOW_IO&t;&t;/* most systems can safely undef this */
DECL|macro|CMD640_PREFETCH_MASKS
mdefine_line|#define CMD640_PREFETCH_MASKS 1
macro_line|#include &lt;linux/config.h&gt;
macro_line|#include &lt;linux/types.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/blkdev.h&gt;
macro_line|#include &lt;linux/hdreg.h&gt;
macro_line|#include &lt;linux/ide.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &quot;ide_modes.h&quot;
multiline_comment|/*&n; * This flag is set in ide.c by the parameter:  ide0=cmd640_vlb&n; */
DECL|variable|cmd640_vlb
r_int
id|cmd640_vlb
op_assign
l_int|0
suffix:semicolon
multiline_comment|/*&n; * CMD640 specific registers definition.&n; */
DECL|macro|VID
mdefine_line|#define VID&t;&t;0x00
DECL|macro|DID
mdefine_line|#define DID&t;&t;0x02
DECL|macro|PCMD
mdefine_line|#define PCMD&t;&t;0x04
DECL|macro|PCMD_ENA
mdefine_line|#define   PCMD_ENA&t;0x01
DECL|macro|PSTTS
mdefine_line|#define PSTTS&t;&t;0x06
DECL|macro|REVID
mdefine_line|#define REVID&t;&t;0x08
DECL|macro|PROGIF
mdefine_line|#define PROGIF&t;&t;0x09
DECL|macro|SUBCL
mdefine_line|#define SUBCL&t;&t;0x0a
DECL|macro|BASCL
mdefine_line|#define BASCL&t;&t;0x0b
DECL|macro|BaseA0
mdefine_line|#define BaseA0&t;&t;0x10
DECL|macro|BaseA1
mdefine_line|#define BaseA1&t;&t;0x14
DECL|macro|BaseA2
mdefine_line|#define BaseA2&t;&t;0x18
DECL|macro|BaseA3
mdefine_line|#define BaseA3&t;&t;0x1c
DECL|macro|INTLINE
mdefine_line|#define INTLINE&t;&t;0x3c
DECL|macro|INPINE
mdefine_line|#define INPINE&t;&t;0x3d
DECL|macro|CFR
mdefine_line|#define&t;CFR&t;&t;0x50
DECL|macro|CFR_DEVREV
mdefine_line|#define   CFR_DEVREV&t;&t;0x03
DECL|macro|CFR_IDE01INTR
mdefine_line|#define   CFR_IDE01INTR&t;&t;0x04
DECL|macro|CFR_DEVID
mdefine_line|#define&t;  CFR_DEVID&t;&t;0x18
DECL|macro|CFR_AT_VESA_078h
mdefine_line|#define&t;  CFR_AT_VESA_078h&t;0x20
DECL|macro|CFR_DSA1
mdefine_line|#define&t;  CFR_DSA1&t;&t;0x40
DECL|macro|CFR_DSA0
mdefine_line|#define&t;  CFR_DSA0&t;&t;0x80
DECL|macro|CNTRL
mdefine_line|#define CNTRL&t;&t;0x51
DECL|macro|CNTRL_DIS_RA0
mdefine_line|#define&t;  CNTRL_DIS_RA0&t;&t;0x40
DECL|macro|CNTRL_DIS_RA1
mdefine_line|#define   CNTRL_DIS_RA1&t;&t;0x80
DECL|macro|CNTRL_ENA_2ND
mdefine_line|#define&t;  CNTRL_ENA_2ND&t;&t;0x08
DECL|macro|CMDTIM
mdefine_line|#define&t;CMDTIM&t;&t;0x52
DECL|macro|ARTTIM0
mdefine_line|#define&t;ARTTIM0&t;&t;0x53
DECL|macro|DRWTIM0
mdefine_line|#define&t;DRWTIM0&t;&t;0x54
DECL|macro|ARTTIM1
mdefine_line|#define ARTTIM1 &t;0x55
DECL|macro|DRWTIM1
mdefine_line|#define DRWTIM1&t;&t;0x56
DECL|macro|ARTTIM23
mdefine_line|#define ARTTIM23&t;0x57
DECL|macro|ARTTIM23_DIS_RA2
mdefine_line|#define   ARTTIM23_DIS_RA2&t;0x04
DECL|macro|ARTTIM23_DIS_RA3
mdefine_line|#define   ARTTIM23_DIS_RA3&t;0x08
DECL|macro|DRWTIM23
mdefine_line|#define DRWTIM23&t;0x58
DECL|macro|BRST
mdefine_line|#define BRST&t;&t;0x59
multiline_comment|/*&n; * Registers and masks for easy access by drive index:&n; */
DECL|variable|prefetch_regs
r_static
id|byte
id|prefetch_regs
(braket
l_int|4
)braket
op_assign
(brace
id|CNTRL
comma
id|CNTRL
comma
id|ARTTIM23
comma
id|ARTTIM23
)brace
suffix:semicolon
DECL|variable|prefetch_masks
r_static
id|byte
id|prefetch_masks
(braket
l_int|4
)braket
op_assign
(brace
id|CNTRL_DIS_RA0
comma
id|CNTRL_DIS_RA1
comma
id|ARTTIM23_DIS_RA2
comma
id|ARTTIM23_DIS_RA3
)brace
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_CMD640_ENHANCED
DECL|variable|arttim_regs
r_static
id|byte
id|arttim_regs
(braket
l_int|4
)braket
op_assign
(brace
id|ARTTIM0
comma
id|ARTTIM1
comma
id|ARTTIM23
comma
id|ARTTIM23
)brace
suffix:semicolon
DECL|variable|drwtim_regs
r_static
id|byte
id|drwtim_regs
(braket
l_int|4
)braket
op_assign
(brace
id|DRWTIM0
comma
id|DRWTIM1
comma
id|DRWTIM23
comma
id|DRWTIM23
)brace
suffix:semicolon
multiline_comment|/*&n; * Current cmd640 timing values for each drive.&n; * The defaults for each are the slowest possible timings.&n; */
DECL|variable|setup_counts
r_static
id|byte
id|setup_counts
(braket
l_int|4
)braket
op_assign
(brace
l_int|4
comma
l_int|4
comma
l_int|4
comma
l_int|4
)brace
suffix:semicolon
multiline_comment|/* Address setup count (in clocks) */
DECL|variable|active_counts
r_static
id|byte
id|active_counts
(braket
l_int|4
)braket
op_assign
(brace
l_int|16
comma
l_int|16
comma
l_int|16
comma
l_int|16
)brace
suffix:semicolon
multiline_comment|/* Active count   (encoded) */
DECL|variable|recovery_counts
r_static
id|byte
id|recovery_counts
(braket
l_int|4
)braket
op_assign
(brace
l_int|16
comma
l_int|16
comma
l_int|16
comma
l_int|16
)brace
suffix:semicolon
multiline_comment|/* Recovery count (encoded) */
macro_line|#endif /* CONFIG_BLK_DEV_CMD640_ENHANCED */
multiline_comment|/*&n; * These are initialized to point at the devices we control&n; */
DECL|variable|cmd_hwif0
DECL|variable|cmd_hwif1
r_static
id|ide_hwif_t
op_star
id|cmd_hwif0
comma
op_star
id|cmd_hwif1
suffix:semicolon
DECL|variable|cmd_drives
r_static
id|ide_drive_t
op_star
id|cmd_drives
(braket
l_int|4
)braket
suffix:semicolon
multiline_comment|/*&n; * Interface to access cmd640x registers&n; */
DECL|variable|cmd640_key
r_static
r_int
r_int
id|cmd640_key
suffix:semicolon
DECL|variable|put_cmd640_reg
r_static
r_void
(paren
op_star
id|put_cmd640_reg
)paren
(paren
r_int
r_int
id|reg
comma
id|byte
id|val
)paren
suffix:semicolon
DECL|variable|get_cmd640_reg
r_static
id|byte
(paren
op_star
id|get_cmd640_reg
)paren
(paren
r_int
r_int
id|reg
)paren
suffix:semicolon
multiline_comment|/*&n; * This is read from the CFR reg, and is used in several places.&n; */
DECL|variable|cmd640_chip_version
r_static
r_int
r_int
id|cmd640_chip_version
suffix:semicolon
multiline_comment|/*&n; * The CMD640x chip does not support DWORD config write cycles, but some&n; * of the BIOSes use them to implement the config services.&n; * Therefore, we must use direct IO instead.&n; */
multiline_comment|/* PCI method 1 access */
DECL|function|put_cmd640_reg_pci1
r_static
r_void
id|put_cmd640_reg_pci1
(paren
r_int
r_int
id|reg
comma
id|byte
id|val
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outl_p
c_func
(paren
(paren
id|reg
op_amp
l_int|0xfc
)paren
op_or
id|cmd640_key
comma
l_int|0xcf8
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|val
comma
(paren
id|reg
op_amp
l_int|3
)paren
op_or
l_int|0xcfc
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|get_cmd640_reg_pci1
r_static
id|byte
id|get_cmd640_reg_pci1
(paren
r_int
r_int
id|reg
)paren
(brace
id|byte
id|b
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outl_p
c_func
(paren
(paren
id|reg
op_amp
l_int|0xfc
)paren
op_or
id|cmd640_key
comma
l_int|0xcf8
)paren
suffix:semicolon
id|b
op_assign
id|inb_p
c_func
(paren
(paren
id|reg
op_amp
l_int|3
)paren
op_or
l_int|0xcfc
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
multiline_comment|/* PCI method 2 access (from CMD datasheet) */
DECL|function|put_cmd640_reg_pci2
r_static
r_void
id|put_cmd640_reg_pci2
(paren
r_int
r_int
id|reg
comma
id|byte
id|val
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x10
comma
l_int|0xcf8
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|val
comma
id|cmd640_key
op_plus
id|reg
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
l_int|0xcf8
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|get_cmd640_reg_pci2
r_static
id|byte
id|get_cmd640_reg_pci2
(paren
r_int
r_int
id|reg
)paren
(brace
id|byte
id|b
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x10
comma
l_int|0xcf8
)paren
suffix:semicolon
id|b
op_assign
id|inb_p
c_func
(paren
id|cmd640_key
op_plus
id|reg
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0
comma
l_int|0xcf8
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
multiline_comment|/* VLB access */
DECL|function|put_cmd640_reg_vlb
r_static
r_void
id|put_cmd640_reg_vlb
(paren
r_int
r_int
id|reg
comma
id|byte
id|val
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|reg
comma
id|cmd640_key
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|val
comma
id|cmd640_key
op_plus
l_int|4
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
DECL|function|get_cmd640_reg_vlb
r_static
id|byte
id|get_cmd640_reg_vlb
(paren
r_int
r_int
id|reg
)paren
(brace
id|byte
id|b
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
id|reg
comma
id|cmd640_key
)paren
suffix:semicolon
id|b
op_assign
id|inb_p
c_func
(paren
id|cmd640_key
op_plus
l_int|4
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|b
suffix:semicolon
)brace
DECL|function|match_pci_cmd640_device
r_static
r_int
id|__init
id|match_pci_cmd640_device
(paren
r_void
)paren
(brace
r_const
id|byte
id|ven_dev
(braket
l_int|4
)braket
op_assign
(brace
l_int|0x95
comma
l_int|0x10
comma
l_int|0x40
comma
l_int|0x06
)brace
suffix:semicolon
r_int
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|get_cmd640_reg
c_func
(paren
id|i
)paren
op_ne
id|ven_dev
(braket
id|i
)braket
)paren
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef STUPIDLY_TRUST_BROKEN_PCMD_ENA_BIT
r_if
c_cond
(paren
(paren
id|get_cmd640_reg
c_func
(paren
id|PCMD
)paren
op_amp
id|PCMD_ENA
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide: cmd640 on PCI disabled by BIOS&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#endif /* STUPIDLY_TRUST_BROKEN_PCMD_ENA_BIT */
r_return
l_int|1
suffix:semicolon
multiline_comment|/* success */
)brace
multiline_comment|/*&n; * Probe for CMD640x -- pci method 1&n; */
DECL|function|probe_for_cmd640_pci1
r_static
r_int
id|__init
id|probe_for_cmd640_pci1
(paren
r_void
)paren
(brace
id|get_cmd640_reg
op_assign
id|get_cmd640_reg_pci1
suffix:semicolon
id|put_cmd640_reg
op_assign
id|put_cmd640_reg_pci1
suffix:semicolon
r_for
c_loop
(paren
id|cmd640_key
op_assign
l_int|0x80000000
suffix:semicolon
id|cmd640_key
op_le
l_int|0x8000f800
suffix:semicolon
id|cmd640_key
op_add_assign
l_int|0x800
)paren
(brace
r_if
c_cond
(paren
id|match_pci_cmd640_device
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* success */
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Probe for CMD640x -- pci method 2&n; */
DECL|function|probe_for_cmd640_pci2
r_static
r_int
id|__init
id|probe_for_cmd640_pci2
(paren
r_void
)paren
(brace
id|get_cmd640_reg
op_assign
id|get_cmd640_reg_pci2
suffix:semicolon
id|put_cmd640_reg
op_assign
id|put_cmd640_reg_pci2
suffix:semicolon
r_for
c_loop
(paren
id|cmd640_key
op_assign
l_int|0xc000
suffix:semicolon
id|cmd640_key
op_le
l_int|0xcf00
suffix:semicolon
id|cmd640_key
op_add_assign
l_int|0x100
)paren
(brace
r_if
c_cond
(paren
id|match_pci_cmd640_device
c_func
(paren
)paren
)paren
r_return
l_int|1
suffix:semicolon
multiline_comment|/* success */
)brace
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Probe for CMD640x -- vlb&n; */
DECL|function|probe_for_cmd640_vlb
r_static
r_int
id|__init
id|probe_for_cmd640_vlb
(paren
r_void
)paren
(brace
id|byte
id|b
suffix:semicolon
id|get_cmd640_reg
op_assign
id|get_cmd640_reg_vlb
suffix:semicolon
id|put_cmd640_reg
op_assign
id|put_cmd640_reg_vlb
suffix:semicolon
id|cmd640_key
op_assign
l_int|0x178
suffix:semicolon
id|b
op_assign
id|get_cmd640_reg
c_func
(paren
id|CFR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|b
op_eq
l_int|0xff
op_logical_or
id|b
op_eq
l_int|0x00
op_logical_or
(paren
id|b
op_amp
id|CFR_AT_VESA_078h
)paren
)paren
(brace
id|cmd640_key
op_assign
l_int|0x78
suffix:semicolon
id|b
op_assign
id|get_cmd640_reg
c_func
(paren
id|CFR
)paren
suffix:semicolon
r_if
c_cond
(paren
id|b
op_eq
l_int|0xff
op_logical_or
id|b
op_eq
l_int|0x00
op_logical_or
op_logical_neg
(paren
id|b
op_amp
id|CFR_AT_VESA_078h
)paren
)paren
r_return
l_int|0
suffix:semicolon
)brace
r_return
l_int|1
suffix:semicolon
multiline_comment|/* success */
)brace
multiline_comment|/*&n; *  Returns 1 if an IDE interface/drive exists at 0x170,&n; *  Returns 0 otherwise.&n; */
DECL|function|secondary_port_responding
r_static
r_int
id|__init
id|secondary_port_responding
(paren
r_void
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|outb_p
c_func
(paren
l_int|0x0a
comma
l_int|0x170
op_plus
id|IDE_SELECT_OFFSET
)paren
suffix:semicolon
multiline_comment|/* select drive0 */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
l_int|0x170
op_plus
id|IDE_SELECT_OFFSET
)paren
op_amp
l_int|0x1f
)paren
op_ne
l_int|0x0a
)paren
(brace
id|outb_p
c_func
(paren
l_int|0x1a
comma
l_int|0x170
op_plus
id|IDE_SELECT_OFFSET
)paren
suffix:semicolon
multiline_comment|/* select drive1 */
id|udelay
c_func
(paren
l_int|100
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb_p
c_func
(paren
l_int|0x170
op_plus
id|IDE_SELECT_OFFSET
)paren
op_amp
l_int|0x1f
)paren
op_ne
l_int|0x1a
)paren
(brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* nothing responded */
)brace
)brace
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
multiline_comment|/* success */
)brace
macro_line|#ifdef CMD640_DUMP_REGS
multiline_comment|/*&n; * Dump out all cmd640 registers.  May be called from ide.c&n; */
DECL|function|cmd640_dump_regs
r_void
id|cmd640_dump_regs
(paren
r_void
)paren
(brace
r_int
r_int
id|reg
op_assign
id|cmd640_vlb
ques
c_cond
l_int|0x50
suffix:colon
l_int|0x00
suffix:semicolon
multiline_comment|/* Dump current state of chip registers */
id|printk
c_func
(paren
l_string|&quot;ide: cmd640 internal register dump:&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
suffix:semicolon
id|reg
op_le
l_int|0x59
suffix:semicolon
id|reg
op_increment
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|reg
op_amp
l_int|0x0f
)paren
)paren
id|printk
c_func
(paren
l_string|&quot;&bslash;n%04x:&quot;
comma
id|reg
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot; %02x&quot;
comma
id|get_cmd640_reg
c_func
(paren
id|reg
)paren
)paren
suffix:semicolon
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*&n; * Check whether prefetch is on for a drive,&n; * and initialize the unmask flags for safe operation.&n; */
DECL|function|check_prefetch
r_static
r_void
id|__init
id|check_prefetch
(paren
r_int
r_int
id|index
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|cmd_drives
(braket
id|index
)braket
suffix:semicolon
id|byte
id|b
op_assign
id|get_cmd640_reg
c_func
(paren
id|prefetch_regs
(braket
id|index
)braket
)paren
suffix:semicolon
r_if
c_cond
(paren
id|b
op_amp
id|prefetch_masks
(braket
id|index
)braket
)paren
(brace
multiline_comment|/* is prefetch off? */
id|drive-&gt;no_unmask
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;no_io_32bit
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
macro_line|#if CMD640_PREFETCH_MASKS
id|drive-&gt;no_unmask
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;unmask
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|drive-&gt;no_io_32bit
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Figure out which devices we control&n; */
DECL|function|setup_device_ptrs
r_static
r_void
id|__init
id|setup_device_ptrs
(paren
r_void
)paren
(brace
r_int
r_int
id|i
suffix:semicolon
id|cmd_hwif0
op_assign
op_amp
id|ide_hwifs
(braket
l_int|0
)braket
suffix:semicolon
multiline_comment|/* default, if not found below */
id|cmd_hwif1
op_assign
op_amp
id|ide_hwifs
(braket
l_int|1
)braket
suffix:semicolon
multiline_comment|/* default, if not found below */
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_HWIFS
suffix:semicolon
id|i
op_increment
)paren
(brace
id|ide_hwif_t
op_star
id|hwif
op_assign
op_amp
id|ide_hwifs
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
id|hwif-&gt;chipset
op_eq
id|ide_unknown
op_logical_or
id|hwif-&gt;chipset
op_eq
id|ide_generic
)paren
(brace
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
l_int|0x1f0
)paren
id|cmd_hwif0
op_assign
id|hwif
suffix:semicolon
r_else
r_if
c_cond
(paren
id|hwif-&gt;io_ports
(braket
id|IDE_DATA_OFFSET
)braket
op_eq
l_int|0x170
)paren
id|cmd_hwif1
op_assign
id|hwif
suffix:semicolon
)brace
)brace
id|cmd_drives
(braket
l_int|0
)braket
op_assign
op_amp
id|cmd_hwif0-&gt;drives
(braket
l_int|0
)braket
suffix:semicolon
id|cmd_drives
(braket
l_int|1
)braket
op_assign
op_amp
id|cmd_hwif0-&gt;drives
(braket
l_int|1
)braket
suffix:semicolon
id|cmd_drives
(braket
l_int|2
)braket
op_assign
op_amp
id|cmd_hwif1-&gt;drives
(braket
l_int|0
)braket
suffix:semicolon
id|cmd_drives
(braket
l_int|3
)braket
op_assign
op_amp
id|cmd_hwif1-&gt;drives
(braket
l_int|1
)braket
suffix:semicolon
)brace
macro_line|#ifdef CONFIG_BLK_DEV_CMD640_ENHANCED
multiline_comment|/*&n; * Sets prefetch mode for a drive.&n; */
DECL|function|set_prefetch_mode
r_static
r_void
id|set_prefetch_mode
(paren
r_int
r_int
id|index
comma
r_int
id|mode
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|cmd_drives
(braket
id|index
)braket
suffix:semicolon
r_int
id|reg
op_assign
id|prefetch_regs
(braket
id|index
)braket
suffix:semicolon
id|byte
id|b
suffix:semicolon
r_int
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|b
op_assign
id|get_cmd640_reg
c_func
(paren
id|reg
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mode
)paren
(brace
multiline_comment|/* want prefetch on? */
macro_line|#if CMD640_PREFETCH_MASKS
id|drive-&gt;no_unmask
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;unmask
op_assign
l_int|0
suffix:semicolon
macro_line|#endif
id|drive-&gt;no_io_32bit
op_assign
l_int|0
suffix:semicolon
id|b
op_and_assign
op_complement
id|prefetch_masks
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/* enable prefetch */
)brace
r_else
(brace
id|drive-&gt;no_unmask
op_assign
l_int|0
suffix:semicolon
id|drive-&gt;no_io_32bit
op_assign
l_int|1
suffix:semicolon
id|drive-&gt;io_32bit
op_assign
l_int|0
suffix:semicolon
id|b
op_or_assign
id|prefetch_masks
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/* disable prefetch */
)brace
id|put_cmd640_reg
c_func
(paren
id|reg
comma
id|b
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Dump out current drive clocks settings&n; */
DECL|function|display_clocks
r_static
r_void
id|display_clocks
(paren
r_int
r_int
id|index
)paren
(brace
id|byte
id|active_count
comma
id|recovery_count
suffix:semicolon
id|active_count
op_assign
id|active_counts
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|active_count
op_eq
l_int|1
)paren
op_increment
id|active_count
suffix:semicolon
id|recovery_count
op_assign
id|recovery_counts
(braket
id|index
)braket
suffix:semicolon
r_if
c_cond
(paren
id|active_count
OG
l_int|3
op_logical_and
id|recovery_count
op_eq
l_int|1
)paren
op_increment
id|recovery_count
suffix:semicolon
r_if
c_cond
(paren
id|cmd640_chip_version
OG
l_int|1
)paren
id|recovery_count
op_add_assign
l_int|1
suffix:semicolon
multiline_comment|/* cmd640b uses (count + 1)*/
id|printk
c_func
(paren
l_string|&quot;, clocks=%d/%d/%d&bslash;n&quot;
comma
id|setup_counts
(braket
id|index
)braket
comma
id|active_count
comma
id|recovery_count
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Pack active and recovery counts into single byte representation&n; * used by controller&n; */
DECL|function|pack_nibbles
r_inline
r_static
id|byte
id|pack_nibbles
(paren
id|byte
id|upper
comma
id|byte
id|lower
)paren
(brace
r_return
(paren
(paren
id|upper
op_amp
l_int|0x0f
)paren
op_lshift
l_int|4
)paren
op_or
(paren
id|lower
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine retrieves the initial drive timings from the chipset.&n; */
DECL|function|retrieve_drive_counts
r_static
r_void
id|__init
id|retrieve_drive_counts
(paren
r_int
r_int
id|index
)paren
(brace
id|byte
id|b
suffix:semicolon
multiline_comment|/*&n;&t; * Get the internal setup timing, and convert to clock count&n;&t; */
id|b
op_assign
id|get_cmd640_reg
c_func
(paren
id|arttim_regs
(braket
id|index
)braket
)paren
op_amp
op_complement
l_int|0x3f
suffix:semicolon
r_switch
c_cond
(paren
id|b
)paren
(brace
r_case
l_int|0x00
suffix:colon
id|b
op_assign
l_int|4
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x80
suffix:colon
id|b
op_assign
l_int|3
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|0x40
suffix:colon
id|b
op_assign
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|b
op_assign
l_int|5
suffix:semicolon
r_break
suffix:semicolon
)brace
id|setup_counts
(braket
id|index
)braket
op_assign
id|b
suffix:semicolon
multiline_comment|/*&n;&t; * Get the active/recovery counts&n;&t; */
id|b
op_assign
id|get_cmd640_reg
c_func
(paren
id|drwtim_regs
(braket
id|index
)braket
)paren
suffix:semicolon
id|active_counts
(braket
id|index
)braket
op_assign
(paren
id|b
op_rshift
l_int|4
)paren
ques
c_cond
(paren
id|b
op_rshift
l_int|4
)paren
suffix:colon
l_int|0x10
suffix:semicolon
id|recovery_counts
(braket
id|index
)braket
op_assign
(paren
id|b
op_amp
l_int|0x0f
)paren
ques
c_cond
(paren
id|b
op_amp
l_int|0x0f
)paren
suffix:colon
l_int|0x10
suffix:semicolon
)brace
multiline_comment|/*&n; * This routine writes the prepared setup/active/recovery counts&n; * for a drive into the cmd640 chipset registers to active them.&n; */
DECL|function|program_drive_counts
r_static
r_void
id|program_drive_counts
(paren
r_int
r_int
id|index
)paren
(brace
r_int
r_int
id|flags
suffix:semicolon
id|byte
id|setup_count
op_assign
id|setup_counts
(braket
id|index
)braket
suffix:semicolon
id|byte
id|active_count
op_assign
id|active_counts
(braket
id|index
)braket
suffix:semicolon
id|byte
id|recovery_count
op_assign
id|recovery_counts
(braket
id|index
)braket
suffix:semicolon
multiline_comment|/*&n;&t; * Set up address setup count and drive read/write timing registers.&n;&t; * Primary interface has individual count/timing registers for&n;&t; * each drive.  Secondary interface has one common set of registers,&n;&t; * so we merge the timings, using the slowest value for each timing.&n;&t; */
r_if
c_cond
(paren
id|index
OG
l_int|1
)paren
(brace
r_int
r_int
id|mate
suffix:semicolon
r_if
c_cond
(paren
id|cmd_drives
(braket
id|mate
op_assign
id|index
op_xor
l_int|1
)braket
op_member_access_from_pointer
id|present
)paren
(brace
r_if
c_cond
(paren
id|setup_count
OL
id|setup_counts
(braket
id|mate
)braket
)paren
id|setup_count
op_assign
id|setup_counts
(braket
id|mate
)braket
suffix:semicolon
r_if
c_cond
(paren
id|active_count
OL
id|active_counts
(braket
id|mate
)braket
)paren
id|active_count
op_assign
id|active_counts
(braket
id|mate
)braket
suffix:semicolon
r_if
c_cond
(paren
id|recovery_count
OL
id|recovery_counts
(braket
id|mate
)braket
)paren
id|recovery_count
op_assign
id|recovery_counts
(braket
id|mate
)braket
suffix:semicolon
)brace
)brace
multiline_comment|/*&n;&t; * Convert setup_count to internal chipset representation&n;&t; */
r_switch
c_cond
(paren
id|setup_count
)paren
(brace
r_case
l_int|4
suffix:colon
id|setup_count
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|3
suffix:colon
id|setup_count
op_assign
l_int|0x80
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|1
suffix:colon
r_case
l_int|2
suffix:colon
id|setup_count
op_assign
l_int|0x40
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|setup_count
op_assign
l_int|0xc0
suffix:semicolon
multiline_comment|/* case 5 */
)brace
multiline_comment|/*&n;&t; * Now that everything is ready, program the new timings&n;&t; */
id|save_flags
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Program the address_setup clocks into ARTTIM reg,&n;&t; * and then the active/recovery counts into the DRWTIM reg&n;&t; * (this converts counts of 16 into counts of zero -- okay).&n;&t; */
id|setup_count
op_or_assign
id|get_cmd640_reg
c_func
(paren
id|arttim_regs
(braket
id|index
)braket
)paren
op_amp
l_int|0x3f
suffix:semicolon
id|put_cmd640_reg
c_func
(paren
id|arttim_regs
(braket
id|index
)braket
comma
id|setup_count
)paren
suffix:semicolon
id|put_cmd640_reg
c_func
(paren
id|drwtim_regs
(braket
id|index
)braket
comma
id|pack_nibbles
c_func
(paren
id|active_count
comma
id|recovery_count
)paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Set a specific pio_mode for a drive&n; */
DECL|function|cmd640_set_mode
r_static
r_void
id|cmd640_set_mode
(paren
r_int
r_int
id|index
comma
id|byte
id|pio_mode
comma
r_int
r_int
id|cycle_time
)paren
(brace
r_int
id|setup_time
comma
id|active_time
comma
id|recovery_time
comma
id|clock_time
suffix:semicolon
id|byte
id|setup_count
comma
id|active_count
comma
id|recovery_count
comma
id|recovery_count2
comma
id|cycle_count
suffix:semicolon
r_int
id|bus_speed
op_assign
id|system_bus_clock
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pio_mode
OG
l_int|5
)paren
id|pio_mode
op_assign
l_int|5
suffix:semicolon
id|setup_time
op_assign
id|ide_pio_timings
(braket
id|pio_mode
)braket
dot
id|setup_time
suffix:semicolon
id|active_time
op_assign
id|ide_pio_timings
(braket
id|pio_mode
)braket
dot
id|active_time
suffix:semicolon
id|recovery_time
op_assign
id|cycle_time
op_minus
(paren
id|setup_time
op_plus
id|active_time
)paren
suffix:semicolon
id|clock_time
op_assign
l_int|1000
op_div
id|bus_speed
suffix:semicolon
id|cycle_count
op_assign
(paren
id|cycle_time
op_plus
id|clock_time
op_minus
l_int|1
)paren
op_div
id|clock_time
suffix:semicolon
id|setup_count
op_assign
(paren
id|setup_time
op_plus
id|clock_time
op_minus
l_int|1
)paren
op_div
id|clock_time
suffix:semicolon
id|active_count
op_assign
(paren
id|active_time
op_plus
id|clock_time
op_minus
l_int|1
)paren
op_div
id|clock_time
suffix:semicolon
r_if
c_cond
(paren
id|active_count
OL
l_int|2
)paren
id|active_count
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* minimum allowed by cmd640 */
id|recovery_count
op_assign
(paren
id|recovery_time
op_plus
id|clock_time
op_minus
l_int|1
)paren
op_div
id|clock_time
suffix:semicolon
id|recovery_count2
op_assign
id|cycle_count
op_minus
(paren
id|setup_count
op_plus
id|active_count
)paren
suffix:semicolon
r_if
c_cond
(paren
id|recovery_count2
OG
id|recovery_count
)paren
id|recovery_count
op_assign
id|recovery_count2
suffix:semicolon
r_if
c_cond
(paren
id|recovery_count
OL
l_int|2
)paren
id|recovery_count
op_assign
l_int|2
suffix:semicolon
multiline_comment|/* minimum allowed by cmd640 */
r_if
c_cond
(paren
id|recovery_count
OG
l_int|17
)paren
(brace
id|active_count
op_add_assign
id|recovery_count
op_minus
l_int|17
suffix:semicolon
id|recovery_count
op_assign
l_int|17
suffix:semicolon
)brace
r_if
c_cond
(paren
id|active_count
OG
l_int|16
)paren
id|active_count
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* maximum allowed by cmd640 */
r_if
c_cond
(paren
id|cmd640_chip_version
OG
l_int|1
)paren
id|recovery_count
op_sub_assign
l_int|1
suffix:semicolon
multiline_comment|/* cmd640b uses (count + 1)*/
r_if
c_cond
(paren
id|recovery_count
OG
l_int|16
)paren
id|recovery_count
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* maximum allowed by cmd640 */
id|setup_counts
(braket
id|index
)braket
op_assign
id|setup_count
suffix:semicolon
id|active_counts
(braket
id|index
)braket
op_assign
id|active_count
suffix:semicolon
id|recovery_counts
(braket
id|index
)braket
op_assign
id|recovery_count
suffix:semicolon
multiline_comment|/*&n;&t; * In a perfect world, we might set the drive pio mode here&n;&t; * (using WIN_SETFEATURE) before continuing.&n;&t; *&n;&t; * But we do not, because:&n;&t; *&t;1) this is the wrong place to do it (proper is do_special() in ide.c)&n;&t; * &t;2) in practice this is rarely, if ever, necessary&n;&t; */
id|program_drive_counts
(paren
id|index
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Drive PIO mode selection:&n; */
DECL|function|cmd640_tune_drive
r_static
r_void
id|cmd640_tune_drive
(paren
id|ide_drive_t
op_star
id|drive
comma
id|byte
id|mode_wanted
)paren
(brace
id|byte
id|b
suffix:semicolon
id|ide_pio_data_t
id|d
suffix:semicolon
r_int
r_int
id|index
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|drive
op_ne
id|cmd_drives
(braket
id|index
)braket
)paren
(brace
r_if
c_cond
(paren
op_increment
id|index
OG
l_int|3
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;%s: bad news in cmd640_tune_drive&bslash;n&quot;
comma
id|drive-&gt;name
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
)brace
r_switch
c_cond
(paren
id|mode_wanted
)paren
(brace
r_case
l_int|6
suffix:colon
multiline_comment|/* set fast-devsel off */
r_case
l_int|7
suffix:colon
multiline_comment|/* set fast-devsel on */
id|mode_wanted
op_and_assign
l_int|1
suffix:semicolon
id|b
op_assign
id|get_cmd640_reg
c_func
(paren
id|CNTRL
)paren
op_amp
op_complement
l_int|0x27
suffix:semicolon
r_if
c_cond
(paren
id|mode_wanted
)paren
id|b
op_or_assign
l_int|0x27
suffix:semicolon
id|put_cmd640_reg
c_func
(paren
id|CNTRL
comma
id|b
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %sabled cmd640 fast host timing (devsel)&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|mode_wanted
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
l_int|8
suffix:colon
multiline_comment|/* set prefetch off */
r_case
l_int|9
suffix:colon
multiline_comment|/* set prefetch on */
id|mode_wanted
op_and_assign
l_int|1
suffix:semicolon
id|set_prefetch_mode
c_func
(paren
id|index
comma
id|mode_wanted
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: %sabled cmd640 prefetch&bslash;n&quot;
comma
id|drive-&gt;name
comma
id|mode_wanted
ques
c_cond
l_string|&quot;en&quot;
suffix:colon
l_string|&quot;dis&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
(paren
r_void
)paren
id|ide_get_best_pio_mode
(paren
id|drive
comma
id|mode_wanted
comma
l_int|5
comma
op_amp
id|d
)paren
suffix:semicolon
id|cmd640_set_mode
(paren
id|index
comma
id|d.pio_mode
comma
id|d.cycle_time
)paren
suffix:semicolon
id|printk
(paren
l_string|&quot;%s: selected cmd640 PIO mode%d (%dns)%s&quot;
comma
id|drive-&gt;name
comma
id|d.pio_mode
comma
id|d.cycle_time
comma
id|d.overridden
ques
c_cond
l_string|&quot; (overriding vendor mode)&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|display_clocks
c_func
(paren
id|index
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#endif /* CONFIG_BLK_DEV_CMD640_ENHANCED */
multiline_comment|/*&n; * Probe for a cmd640 chipset, and initialize it if found.  Called from ide.c&n; */
DECL|function|ide_probe_for_cmd640x
r_int
id|__init
id|ide_probe_for_cmd640x
(paren
r_void
)paren
(brace
macro_line|#ifdef CONFIG_BLK_DEV_CMD640_ENHANCED
r_int
id|second_port_toggled
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_CMD640_ENHANCED */
r_int
id|second_port_cmd640
op_assign
l_int|0
suffix:semicolon
r_const
r_char
op_star
id|bus_type
comma
op_star
id|port2
suffix:semicolon
r_int
r_int
id|index
suffix:semicolon
id|byte
id|b
comma
id|cfr
suffix:semicolon
r_if
c_cond
(paren
id|cmd640_vlb
op_logical_and
id|probe_for_cmd640_vlb
c_func
(paren
)paren
)paren
(brace
id|bus_type
op_assign
l_string|&quot;VLB&quot;
suffix:semicolon
)brace
r_else
(brace
id|cmd640_vlb
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|probe_for_cmd640_pci1
c_func
(paren
)paren
)paren
id|bus_type
op_assign
l_string|&quot;PCI (type1)&quot;
suffix:semicolon
r_else
r_if
c_cond
(paren
id|probe_for_cmd640_pci2
c_func
(paren
)paren
)paren
id|bus_type
op_assign
l_string|&quot;PCI (type2)&quot;
suffix:semicolon
r_else
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Undocumented magic (there is no 0x5b reg in specs)&n;&t; */
id|put_cmd640_reg
c_func
(paren
l_int|0x5b
comma
l_int|0xbd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|get_cmd640_reg
c_func
(paren
l_int|0x5b
)paren
op_ne
l_int|0xbd
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;ide: cmd640 init failed: wrong value in reg 0x5b&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|put_cmd640_reg
c_func
(paren
l_int|0x5b
comma
l_int|0
)paren
suffix:semicolon
macro_line|#ifdef CMD640_DUMP_REGS
id|CMD640_DUMP_REGS
suffix:semicolon
macro_line|#endif
multiline_comment|/*&n;&t; * Documented magic begins here&n;&t; */
id|cfr
op_assign
id|get_cmd640_reg
c_func
(paren
id|CFR
)paren
suffix:semicolon
id|cmd640_chip_version
op_assign
id|cfr
op_amp
id|CFR_DEVREV
suffix:semicolon
r_if
c_cond
(paren
id|cmd640_chip_version
op_eq
l_int|0
)paren
(brace
id|printk
(paren
l_string|&quot;ide: bad cmd640 revision: %d&bslash;n&quot;
comma
id|cmd640_chip_version
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Initialize data for primary port&n;&t; */
id|setup_device_ptrs
(paren
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;%s: buggy cmd640%c interface on %s, config=0x%02x&bslash;n&quot;
comma
id|cmd_hwif0-&gt;name
comma
l_char|&squot;a&squot;
op_plus
id|cmd640_chip_version
op_minus
l_int|1
comma
id|bus_type
comma
id|cfr
)paren
suffix:semicolon
id|cmd_hwif0-&gt;chipset
op_assign
id|ide_cmd640
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_CMD640_ENHANCED
id|cmd_hwif0-&gt;tuneproc
op_assign
op_amp
id|cmd640_tune_drive
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_CMD640_ENHANCED */
multiline_comment|/*&n;&t; * Ensure compatibility by always using the slowest timings&n;&t; * for access to the drive&squot;s command register block,&n;&t; * and reset the prefetch burstsize to default (512 bytes).&n;&t; *&n;&t; * Maybe we need a way to NOT do these on *some* systems?&n;&t; */
id|put_cmd640_reg
c_func
(paren
id|CMDTIM
comma
l_int|0
)paren
suffix:semicolon
id|put_cmd640_reg
c_func
(paren
id|BRST
comma
l_int|0x40
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Try to enable the secondary interface, if not already enabled&n;&t; */
r_if
c_cond
(paren
id|cmd_hwif1-&gt;noprobe
)paren
(brace
id|port2
op_assign
l_string|&quot;not probed&quot;
suffix:semicolon
)brace
r_else
(brace
id|b
op_assign
id|get_cmd640_reg
c_func
(paren
id|CNTRL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|secondary_port_responding
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
(paren
id|b
op_amp
id|CNTRL_ENA_2ND
)paren
)paren
(brace
id|second_port_cmd640
op_assign
l_int|1
suffix:semicolon
id|port2
op_assign
l_string|&quot;okay&quot;
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|cmd640_vlb
)paren
(brace
id|second_port_cmd640
op_assign
l_int|1
suffix:semicolon
id|port2
op_assign
l_string|&quot;alive&quot;
suffix:semicolon
)brace
r_else
id|port2
op_assign
l_string|&quot;not cmd640&quot;
suffix:semicolon
)brace
r_else
(brace
id|put_cmd640_reg
c_func
(paren
id|CNTRL
comma
id|b
op_xor
id|CNTRL_ENA_2ND
)paren
suffix:semicolon
multiline_comment|/* toggle the bit */
r_if
c_cond
(paren
id|secondary_port_responding
c_func
(paren
)paren
)paren
(brace
id|second_port_cmd640
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_CMD640_ENHANCED
id|second_port_toggled
op_assign
l_int|1
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_CMD640_ENHANCED */
id|port2
op_assign
l_string|&quot;enabled&quot;
suffix:semicolon
)brace
r_else
(brace
id|put_cmd640_reg
c_func
(paren
id|CNTRL
comma
id|b
)paren
suffix:semicolon
multiline_comment|/* restore original setting */
id|port2
op_assign
l_string|&quot;not responding&quot;
suffix:semicolon
)brace
)brace
)brace
multiline_comment|/*&n;&t; * Initialize data for secondary cmd640 port, if enabled&n;&t; */
r_if
c_cond
(paren
id|second_port_cmd640
)paren
(brace
id|cmd_hwif0-&gt;serialized
op_assign
l_int|1
suffix:semicolon
id|cmd_hwif1-&gt;serialized
op_assign
l_int|1
suffix:semicolon
id|cmd_hwif1-&gt;chipset
op_assign
id|ide_cmd640
suffix:semicolon
id|cmd_hwif0-&gt;mate
op_assign
id|cmd_hwif1
suffix:semicolon
id|cmd_hwif1-&gt;mate
op_assign
id|cmd_hwif0
suffix:semicolon
id|cmd_hwif1-&gt;channel
op_assign
l_int|1
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_CMD640_ENHANCED
id|cmd_hwif1-&gt;tuneproc
op_assign
op_amp
id|cmd640_tune_drive
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_CMD640_ENHANCED */
)brace
id|printk
c_func
(paren
l_string|&quot;%s: %sserialized, secondary interface %s&bslash;n&quot;
comma
id|cmd_hwif1-&gt;name
comma
id|cmd_hwif0-&gt;serialized
ques
c_cond
l_string|&quot;&quot;
suffix:colon
l_string|&quot;not &quot;
comma
id|port2
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * Establish initial timings/prefetch for all drives.&n;&t; * Do not unnecessarily disturb any prior BIOS setup of these.&n;&t; */
r_for
c_loop
(paren
id|index
op_assign
l_int|0
suffix:semicolon
id|index
OL
(paren
l_int|2
op_plus
(paren
id|second_port_cmd640
op_lshift
l_int|1
)paren
)paren
suffix:semicolon
id|index
op_increment
)paren
(brace
id|ide_drive_t
op_star
id|drive
op_assign
id|cmd_drives
(braket
id|index
)braket
suffix:semicolon
macro_line|#ifdef CONFIG_BLK_DEV_CMD640_ENHANCED
r_if
c_cond
(paren
id|drive-&gt;autotune
op_logical_or
(paren
(paren
id|index
OG
l_int|1
)paren
op_logical_and
id|second_port_toggled
)paren
)paren
(brace
multiline_comment|/*&n;&t; &t;&t; * Reset timing to the slowest speed and turn off prefetch.&n;&t;&t;&t; * This way, the drive identify code has a better chance.&n;&t;&t;&t; */
id|setup_counts
(braket
id|index
)braket
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* max possible */
id|active_counts
(braket
id|index
)braket
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* max possible */
id|recovery_counts
(braket
id|index
)braket
op_assign
l_int|16
suffix:semicolon
multiline_comment|/* max possible */
id|program_drive_counts
(paren
id|index
)paren
suffix:semicolon
id|set_prefetch_mode
(paren
id|index
comma
l_int|0
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cmd640: drive%d timings/prefetch cleared&bslash;n&quot;
comma
id|index
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/*&n;&t;&t;&t; * Record timings/prefetch without changing them.&n;&t;&t;&t; * This preserves any prior BIOS setup.&n;&t;&t;&t; */
id|retrieve_drive_counts
(paren
id|index
)paren
suffix:semicolon
id|check_prefetch
(paren
id|index
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cmd640: drive%d timings/prefetch(%s) preserved&quot;
comma
id|index
comma
id|drive-&gt;no_io_32bit
ques
c_cond
l_string|&quot;off&quot;
suffix:colon
l_string|&quot;on&quot;
)paren
suffix:semicolon
id|display_clocks
c_func
(paren
id|index
)paren
suffix:semicolon
)brace
macro_line|#else
multiline_comment|/*&n;&t;&t; * Set the drive unmask flags to match the prefetch setting&n;&t;&t; */
id|check_prefetch
(paren
id|index
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;cmd640: drive%d timings/prefetch(%s) preserved&bslash;n&quot;
comma
id|index
comma
id|drive-&gt;no_io_32bit
ques
c_cond
l_string|&quot;off&quot;
suffix:colon
l_string|&quot;on&quot;
)paren
suffix:semicolon
macro_line|#endif /* CONFIG_BLK_DEV_CMD640_ENHANCED */
)brace
macro_line|#ifdef CMD640_DUMP_REGS
id|CMD640_DUMP_REGS
suffix:semicolon
macro_line|#endif
r_return
l_int|1
suffix:semicolon
)brace
eof
