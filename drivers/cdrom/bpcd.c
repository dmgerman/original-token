multiline_comment|/* &n;&t;bpcd.c&t;(c) 1996  Grant R. Guenther &lt;grant@torque.net&gt;&n;&t;&t;          Under the terms of the GNU public license.&n;&n;&t;bpcd.c is a driver for the MicroSolutions &quot;backpack&quot; CDrom,&n;&t;an external parallel port device.  &n;&n;&t;There are apparently two versions of the backpack protocol.  This &n;        driver knows about the version 2 protocol - as is used in the 4x &n;&t;and 6x products.  There is no support for the sound hardware that&n;        is included in some models.  It should not be difficult to add &n;        support for the ATAPI audio play functions and the corresponding &n;        ioctls.&n;&n;&t;The driver was developed by reverse engineering the protocol&n;        and testing it on the backpack model 164550.  This model&n;&t;is actually a stock ATAPI drive packaged with a custom &n;&t;ASIC that implements the IDE over parallel protocol.&n;&t;I tested with a backpack that happened to contain a Goldstar&n;        drive, but I&squot;ve seen reports of Sony and Mitsumi drives as well.&n;&n;&t;bpcd.c can be compiled for version 1.2.13 of the Linux kernel&n;        and for the 2.0 series.  (It should also work with most of the&n;        later 1.3 kernels.)&n;&n;        If you have a copy of the driver that has not been integrated into&n;        the kernel source tree, you can compile the driver manually, as a &n;        module.  Ensure that /usr/include/linux and /usr/include/asm are &n;&t;links to the correct include files for the target system.  Compile &n;        the driver with&n;&n;                cc -D__KERNEL__ -DMODULE -O2 -c bpcd.c&n;&n;        You must then load it with insmod.  If you are using&n;        MODVERSIONS, add the following to the cc command:&n;&n;&t;&t;-DMODVERSIONS -I /usr/include/linux/modversions.h&n;&n;&t;Before attempting to access the new driver, you will need to&n;        create a new device special file.  The following commands will&n;&t;do that for you:&n;&n;&t;&t;mknod /dev/bpcd b 41 0&n;&t;&t;chown root:disk /dev/bpcd&n;&t;&t;chmod 660 /dev/bpcd&n;&n;&t;Afterward, you can mount a disk in the usual way:&n;&n;&t;&t;mount -t iso9660 /dev/bpcd /cdrom&n;&n;&t;(assuming you have made a directory /cdrom to use as a&n;        mount point).&n;&n;&t;The driver will attempt to detect which parallel port your&n;        backpack is connected to.  If this fails for any reason, you&n;        can override it by specifying a port on the LILO command line&n;        (for built in drivers) or the insmod command (for drivers built&n;        as modules).   If your drive is on the port at 0x3bc, you would&n;        use one of these commands:&n;&n;&t;&t;LILO:&t;   bpcd=0x3bc&n;&n;&t;&t;insmod:    insmod bpcd bp_base=0x3bc&n;&n;&t;The driver can detect if the parallel port supports 8-bit&n;        transfers.  If so, it will use them.  You can force it to use&n;        4-bit (nybble) mode by setting the variable bp_nybble to 1 on&n;        an insmod command, or using the following LILO parameters:&n;&n;&t;&t;bpcd=0x3bc,1&n;&n;&t;(you must specify the correct port address if you use this method.)&n;&n;&t;There is currently no support for EPP or ECP modes.  Also,&n;        as far as I can tell, the MicroSolutions protocol does not&n;        support interrupts in the 4-bit and 8-bit modes.&n;&n;&t;MicroSolutions&squot; protocol allows for several drives to be&n;        chained together off the same parallel port.  Currently, this&n;        driver will recognise only one of them.  If you do have more&n;        than one drive, it will choose the one with the lowest id number,&n;        where the id number is the last two digits of the product&squot;s&n;        serial number.&n;&n;&t;It is not currently possible to connect a printer to the chained&n;        port on the BackPack and expect Linux to use both devices at once.&n;&n;&t;If you need to use this driver together with a printer on the&n;        same port, build both the bpcd and lp drivers are modules.&n;&n;&t;Keep an eye on http://www.torque.net/bpcd.html for news and&n;        other information about the driver.  If you have any problems&n;        with this driver, please send me, grant@torque.net, some mail &n;        directly before posting into the newsgroups or mailing lists.&n;&n;*/
DECL|macro|BP_VERSION
mdefine_line|#define&t;BP_VERSION&t;&quot;0.14&quot; 
DECL|macro|BP_BASE
mdefine_line|#define&t;BP_BASE&t;&t;0&t;/* set to 0 for autoprobe */
DECL|macro|BP_REP
mdefine_line|#define BP_REP&t;&t;4
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/major.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/tqueue.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#ifndef BPCD_MAJOR
DECL|macro|BPCD_MAJOR
mdefine_line|#define BPCD_MAJOR   41&t;
macro_line|#endif
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR BPCD_MAJOR
multiline_comment|/* set up defines for blk.h,  why don&squot;t all drivers do it this way ? */
DECL|macro|DEVICE_NAME
mdefine_line|#define DEVICE_NAME &quot;BackPack&quot;
DECL|macro|DEVICE_REQUEST
mdefine_line|#define DEVICE_REQUEST do_bp_request
DECL|macro|DEVICE_NR
mdefine_line|#define DEVICE_NR(device) (MINOR(device))
DECL|macro|DEVICE_ON
mdefine_line|#define DEVICE_ON(device)
DECL|macro|DEVICE_OFF
mdefine_line|#define DEVICE_OFF(device)
macro_line|#include &lt;linux/blk.h&gt;
DECL|macro|BP_TMO
mdefine_line|#define BP_TMO&t;&t;   300&t;&t;/* timeout in jiffies */
DECL|macro|BP_DELAY
mdefine_line|#define BP_DELAY            50          /* spin delay in uS */
DECL|macro|BP_SPIN
mdefine_line|#define BP_SPIN&t;&t;(10000/BP_DELAY)*BP_TMO
r_int
id|bpcd_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|bpcd_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
suffix:semicolon
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|bp_open
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_void
id|do_bp_request
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|do_bp_read
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|bp_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
suffix:semicolon
r_static
r_void
id|bp_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
suffix:semicolon
r_static
r_int
id|bp_detect
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|bp_lock
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|bp_unlock
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|bp_eject
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|bp_interrupt
c_func
(paren
r_void
op_star
id|data
)paren
suffix:semicolon
DECL|variable|bp_base
r_static
r_int
id|bp_base
op_assign
id|BP_BASE
suffix:semicolon
DECL|variable|bp_rep
r_static
r_int
id|bp_rep
op_assign
id|BP_REP
suffix:semicolon
DECL|variable|bp_nybble
r_static
r_int
id|bp_nybble
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* force 4-bit mode ? */
DECL|variable|bp_unit_id
r_static
r_int
id|bp_unit_id
suffix:semicolon
DECL|variable|bp_access
r_static
r_int
id|bp_access
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* count of active opens ... */
DECL|variable|bp_mode
r_static
r_int
id|bp_mode
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* 4- or 8-bit mode */
DECL|variable|bp_busy
r_static
r_int
id|bp_busy
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* request being processed ? */
DECL|variable|bp_timeout
r_static
r_int
id|bp_timeout
suffix:semicolon
multiline_comment|/* &quot;interrupt&quot; loop limiter */
DECL|variable|bp_sector
r_static
r_int
id|bp_sector
suffix:semicolon
multiline_comment|/* address of next requested sector */
DECL|variable|bp_count
r_static
r_int
id|bp_count
suffix:semicolon
multiline_comment|/* number of blocks still to do */
DECL|variable|bp_buf
r_static
r_char
op_star
id|bp_buf
suffix:semicolon
multiline_comment|/* buffer for request in progress */
DECL|variable|bp_buffer
r_static
r_char
id|bp_buffer
(braket
l_int|2048
)braket
suffix:semicolon
multiline_comment|/* raw block buffer */
DECL|variable|bp_bufblk
r_static
r_int
id|bp_bufblk
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* block in buffer, in CD units,&n;&t;&t;&t;&t;&t;   -1 for nothing there */
DECL|variable|nyb_map
r_static
r_int
id|nyb_map
(braket
l_int|256
)braket
suffix:semicolon
multiline_comment|/* decodes a nybble */
DECL|variable|PortCache
r_static
r_int
id|PortCache
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* cache of the control port */
DECL|variable|bp_tq
r_static
r_struct
id|tq_struct
id|bp_tq
op_assign
(brace
l_int|0
comma
l_int|0
comma
id|bp_interrupt
comma
l_int|NULL
)brace
suffix:semicolon
multiline_comment|/* kernel glue structures */
DECL|variable|bp_fops
r_static
r_struct
id|file_operations
id|bp_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* readdir - bad */
l_int|NULL
comma
multiline_comment|/* select */
id|bp_ioctl
comma
multiline_comment|/* ioctl */
l_int|NULL
comma
multiline_comment|/* mmap */
id|bp_open
comma
multiline_comment|/* open */
id|bp_release
comma
multiline_comment|/* release */
id|block_fsync
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
l_int|NULL
comma
multiline_comment|/* media change ? */
l_int|NULL
multiline_comment|/* revalidate new media */
)brace
suffix:semicolon
multiline_comment|/* the MicroSolutions protocol uses bits 3,4,5 &amp; 7 of the status port to&n;   deliver a nybble in 4 bit mode.  We use a table lookup to extract the&n;   nybble value.  The following function initialises the table.&n;*/
DECL|function|init_nyb_map
r_static
r_void
id|init_nyb_map
c_func
(paren
r_void
)paren
(brace
r_int
id|i
comma
id|j
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|256
suffix:semicolon
id|i
op_increment
)paren
(brace
id|j
op_assign
(paren
id|i
op_rshift
l_int|3
)paren
op_amp
l_int|0x7
suffix:semicolon
r_if
c_cond
(paren
id|i
op_amp
l_int|0x80
)paren
id|j
op_or_assign
l_int|8
suffix:semicolon
id|nyb_map
(braket
id|i
)braket
op_assign
id|j
suffix:semicolon
)brace
)brace
DECL|function|bpcd_init
r_int
id|bpcd_init
(paren
r_void
)paren
multiline_comment|/* preliminary initialisation */
(brace
id|init_nyb_map
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp_detect
c_func
(paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;bpcd&quot;
comma
op_amp
id|bp_fops
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;bpcd: unable to get major number %d&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|8
suffix:semicolon
multiline_comment|/* 8 sector (4kB) read ahead */
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bp_open
r_static
r_int
id|bp_open
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
r_if
c_cond
(paren
id|file-&gt;f_mode
op_amp
l_int|2
)paren
r_return
op_minus
id|EROFS
suffix:semicolon
multiline_comment|/* wants to write ? */
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp_access
)paren
r_if
c_cond
(paren
id|bp_lock
c_func
(paren
)paren
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|ENXIO
suffix:semicolon
)brace
id|bp_access
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|do_bp_request
r_static
r_void
id|do_bp_request
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|bp_busy
)paren
r_return
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
r_if
c_cond
(paren
(paren
op_logical_neg
id|CURRENT
)paren
op_logical_or
(paren
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
)paren
r_return
suffix:semicolon
id|INIT_REQUEST
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT-&gt;cmd
op_eq
id|READ
)paren
(brace
id|bp_sector
op_assign
id|CURRENT-&gt;sector
suffix:semicolon
id|bp_count
op_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
id|bp_buf
op_assign
id|CURRENT-&gt;buffer
suffix:semicolon
id|do_bp_read
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp_busy
)paren
r_return
suffix:semicolon
)brace
r_else
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
)brace
)brace
DECL|function|bp_ioctl
r_static
r_int
id|bp_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
comma
r_int
r_int
id|cmd
comma
r_int
r_int
id|arg
)paren
multiline_comment|/* we currently support only the EJECT ioctl. */
(brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMEJECT
suffix:colon
r_if
c_cond
(paren
id|bp_access
op_eq
l_int|1
)paren
(brace
id|bp_eject
c_func
(paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|bp_release
r_static
r_void
id|bp_release
(paren
r_struct
id|inode
op_star
id|inode
comma
r_struct
id|file
op_star
id|file
)paren
(brace
id|kdev_t
id|devp
suffix:semicolon
id|bp_access
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp_access
)paren
(brace
id|devp
op_assign
id|inode-&gt;i_rdev
suffix:semicolon
id|fsync_dev
c_func
(paren
id|devp
)paren
suffix:semicolon
id|invalidate_inodes
c_func
(paren
id|devp
)paren
suffix:semicolon
id|invalidate_buffers
c_func
(paren
id|devp
)paren
suffix:semicolon
id|bp_unlock
c_func
(paren
)paren
suffix:semicolon
)brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
macro_line|#ifdef MODULE
multiline_comment|/* Glue for modules ... */
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|err
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|err
op_assign
id|bpcd_init
c_func
(paren
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
r_return
id|err
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|flags
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;bpcd&quot;
)paren
suffix:semicolon
id|release_region
c_func
(paren
id|bp_base
comma
l_int|3
)paren
suffix:semicolon
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
)brace
macro_line|#else 
multiline_comment|/* bpcd_setup:  process lilo command parameters ...&n;&n;   syntax:&t;bpcd=base[,nybble[,rep]]&n;*/
DECL|function|bpcd_setup
r_void
id|bpcd_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|ints
)paren
(brace
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|bp_base
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|1
)paren
id|bp_nybble
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|2
)paren
id|bp_rep
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
)brace
macro_line|#endif
DECL|function|out_p
r_static
r_void
id|out_p
c_func
(paren
r_int
id|port
comma
r_char
id|byte
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bp_rep
suffix:semicolon
id|i
op_increment
)paren
(brace
id|outb
c_func
(paren
id|byte
comma
id|bp_base
op_plus
id|port
)paren
suffix:semicolon
)brace
)brace
DECL|function|in_p
r_static
r_int
id|in_p
c_func
(paren
r_int
id|port
)paren
(brace
r_int
id|i
suffix:semicolon
r_char
id|c
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|bp_rep
suffix:semicolon
id|i
op_increment
)paren
(brace
id|c
op_assign
id|inb
c_func
(paren
id|bp_base
op_plus
id|port
)paren
suffix:semicolon
)brace
id|c
op_assign
id|inb
c_func
(paren
id|bp_base
op_plus
id|port
)paren
suffix:semicolon
r_return
id|c
op_amp
l_int|0xff
suffix:semicolon
)brace
multiline_comment|/* Unlike other PP devices I&squot;ve worked on, the backpack protocol seems&n;   to be driven by *changes* in the values of certain bits on the control&n;   port, rather than their absolute value.  Hence the unusual macros ...&n;*/
DECL|macro|w0
mdefine_line|#define w0(byte)  &t;&t;out_p(0,byte)
DECL|macro|r0
mdefine_line|#define r0()      &t;&t;(in_p(0) &amp; 0xff)
DECL|macro|w1
mdefine_line|#define w1(byte)  &t;&t;out_p(1,byte)
DECL|macro|r1
mdefine_line|#define r1()      &t;&t;(in_p(1) &amp; 0xff)
DECL|macro|w2
mdefine_line|#define w2(byte)  &t;&t;out_p(2,byte) ; PortCache = byte
DECL|macro|t2
mdefine_line|#define t2(pat)   &t;&t;PortCache ^= pat; out_p(2,PortCache)
DECL|macro|e2
mdefine_line|#define e2()&t;&t;&t;PortCache &amp;= 0xfe; out_p(2,PortCache)
DECL|macro|o2
mdefine_line|#define o2()&t;&t;&t;PortCache |= 1; out_p(2,PortCache)
DECL|function|read_byte
r_static
r_int
id|read_byte
c_func
(paren
r_void
)paren
(brace
r_int
id|l
comma
id|h
suffix:semicolon
id|t2
c_func
(paren
l_int|4
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp_mode
op_eq
l_int|2
)paren
r_return
id|r0
c_func
(paren
)paren
suffix:semicolon
id|l
op_assign
id|nyb_map
(braket
id|r1
c_func
(paren
)paren
)braket
suffix:semicolon
id|t2
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|h
op_assign
id|nyb_map
(braket
id|r1
c_func
(paren
)paren
)braket
suffix:semicolon
r_return
(paren
id|h
op_lshift
l_int|4
)paren
op_plus
id|l
suffix:semicolon
)brace
DECL|function|read_regr
r_static
r_int
id|read_regr
c_func
(paren
r_char
id|regr
)paren
(brace
r_int
id|r
suffix:semicolon
id|w0
c_func
(paren
id|regr
op_amp
l_int|0xf
)paren
suffix:semicolon
id|w0
c_func
(paren
id|regr
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp_mode
op_eq
l_int|2
)paren
(brace
id|e2
c_func
(paren
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|0x20
)paren
suffix:semicolon
)brace
id|r
op_assign
id|read_byte
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp_mode
op_eq
l_int|2
)paren
(brace
id|t2
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|0x20
)paren
suffix:semicolon
)brace
r_return
id|r
suffix:semicolon
)brace
DECL|function|write_regr
r_static
r_void
id|write_regr
c_func
(paren
r_char
id|regr
comma
r_char
id|val
)paren
(brace
id|w0
c_func
(paren
id|regr
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|w0
c_func
(paren
id|val
)paren
suffix:semicolon
id|o2
c_func
(paren
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
DECL|function|write_cmd
r_static
r_void
id|write_cmd
c_func
(paren
r_char
op_star
id|cmd
comma
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|f
suffix:semicolon
r_if
c_cond
(paren
id|bp_mode
op_eq
l_int|2
)paren
id|f
op_assign
l_int|0x10
suffix:semicolon
r_else
id|f
op_assign
l_int|0
suffix:semicolon
id|write_regr
c_func
(paren
l_int|4
comma
l_int|0x40
op_or
id|f
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0x40
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|i
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|i
OL
id|len
)paren
(brace
id|w0
c_func
(paren
id|cmd
(braket
id|i
op_increment
)braket
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|4
)paren
suffix:semicolon
)brace
id|write_regr
c_func
(paren
l_int|4
comma
id|f
)paren
suffix:semicolon
)brace
DECL|function|read_data
r_static
r_void
id|read_data
c_func
(paren
r_char
op_star
id|buf
comma
r_int
id|len
)paren
(brace
r_int
id|i
comma
id|f
suffix:semicolon
r_if
c_cond
(paren
id|bp_mode
op_eq
l_int|2
)paren
id|f
op_assign
l_int|0x50
suffix:semicolon
r_else
id|f
op_assign
l_int|0x40
suffix:semicolon
id|write_regr
c_func
(paren
l_int|4
comma
id|f
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0x40
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|2
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp_mode
op_eq
l_int|2
)paren
id|t2
c_func
(paren
l_int|0x20
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|len
suffix:semicolon
id|i
op_increment
)paren
(brace
id|buf
(braket
id|i
)braket
op_assign
id|read_byte
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp_mode
op_eq
l_int|2
)paren
(brace
id|t2
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|0x20
)paren
suffix:semicolon
)brace
)brace
DECL|function|probe
r_static
r_int
id|probe
c_func
(paren
r_int
id|id
)paren
(brace
r_int
id|l
comma
id|h
comma
id|t
suffix:semicolon
r_int
id|r
op_assign
op_minus
l_int|1
suffix:semicolon
id|w2
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|0xe
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|0xec
)paren
suffix:semicolon
id|w1
c_func
(paren
l_int|0x7f
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r1
c_func
(paren
)paren
op_amp
l_int|0xf8
)paren
op_ne
l_int|0x78
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|w0
c_func
(paren
l_int|255
op_minus
id|id
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|w0
c_func
(paren
id|id
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|t
op_assign
(paren
id|r1
c_func
(paren
)paren
op_amp
l_int|0xf8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|t
op_ne
l_int|0x78
)paren
(brace
id|l
op_assign
id|nyb_map
(braket
id|t
)braket
suffix:semicolon
id|t2
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|h
op_assign
id|nyb_map
(braket
id|r1
c_func
(paren
)paren
)braket
suffix:semicolon
id|t2
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|r
op_assign
l_int|0
suffix:semicolon
)brace
id|w0
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|0x4c
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0x13
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|connect
r_static
r_void
id|connect
(paren
r_void
)paren
(brace
r_int
id|f
suffix:semicolon
id|w0
c_func
(paren
l_int|0xff
op_minus
id|bp_unit_id
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|4
)paren
suffix:semicolon
id|w0
c_func
(paren
id|bp_unit_id
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|8
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|8
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp_mode
op_eq
l_int|2
)paren
id|f
op_assign
l_int|0x10
suffix:semicolon
r_else
id|f
op_assign
l_int|0
suffix:semicolon
id|write_regr
c_func
(paren
l_int|4
comma
id|f
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|5
comma
l_int|8
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x46
comma
l_int|0x10
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x4c
comma
l_int|0x38
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x4d
comma
l_int|0x88
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x46
comma
l_int|0xa0
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x41
comma
l_int|0
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x4e
comma
l_int|8
)paren
suffix:semicolon
)brace
DECL|function|disconnect
r_static
r_void
id|disconnect
(paren
r_void
)paren
(brace
id|w0
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|t2
c_func
(paren
l_int|2
)paren
suffix:semicolon
id|w2
c_func
(paren
l_int|0x4c
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp_mode
op_eq
l_int|2
)paren
id|w0
c_func
(paren
l_int|0xff
)paren
suffix:semicolon
r_else
id|w0
c_func
(paren
l_int|0x13
)paren
suffix:semicolon
)brace
DECL|function|bp_wait_drq
r_static
r_int
id|bp_wait_drq
c_func
(paren
r_char
op_star
id|lab
comma
r_char
op_star
id|fun
)paren
(brace
r_int
id|j
comma
id|r
comma
id|e
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
l_int|1
)paren
(brace
id|r
op_assign
id|read_regr
c_func
(paren
l_int|0x47
)paren
suffix:semicolon
id|e
op_assign
id|read_regr
c_func
(paren
l_int|0x41
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|r
op_amp
l_int|9
)paren
op_logical_or
(paren
id|j
op_increment
op_ge
id|BP_SPIN
)paren
)paren
r_break
suffix:semicolon
id|udelay
c_func
(paren
id|BP_DELAY
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|j
op_ge
id|BP_SPIN
)paren
op_logical_or
(paren
id|r
op_amp
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|lab
op_logical_and
id|fun
)paren
id|printk
c_func
(paren
l_string|&quot;bpcd: %s (%s): %s status: %x error: %x&bslash;n&quot;
comma
id|lab
comma
id|fun
comma
(paren
id|j
op_ge
id|BP_SPIN
)paren
ques
c_cond
l_string|&quot;timeout, &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|r
comma
id|e
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bp_wait
r_static
r_int
id|bp_wait
c_func
(paren
r_char
op_star
id|lab
comma
r_char
op_star
id|fun
)paren
(brace
r_int
id|j
comma
id|r
comma
id|e
suffix:semicolon
id|j
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
(paren
op_logical_neg
(paren
id|read_regr
c_func
(paren
l_int|0xb
)paren
op_amp
l_int|0x80
)paren
)paren
op_logical_and
(paren
id|j
op_increment
OL
id|BP_SPIN
)paren
)paren
id|udelay
c_func
(paren
id|BP_DELAY
)paren
suffix:semicolon
id|r
op_assign
id|read_regr
c_func
(paren
l_int|0x47
)paren
suffix:semicolon
id|e
op_assign
id|read_regr
c_func
(paren
l_int|0x41
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|j
op_ge
id|BP_SPIN
)paren
op_logical_or
(paren
id|r
op_amp
l_int|1
)paren
)paren
(brace
r_if
c_cond
(paren
id|lab
op_logical_and
id|fun
)paren
id|printk
c_func
(paren
l_string|&quot;bpcd: %s (%s): %s status: %x error: %x&bslash;n&quot;
comma
id|lab
comma
id|fun
comma
(paren
id|j
op_ge
id|BP_SPIN
)paren
ques
c_cond
l_string|&quot;timeout, &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|r
comma
id|e
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bp_command
r_static
r_int
id|bp_command
c_func
(paren
r_char
op_star
id|cmd
comma
r_int
id|dlen
comma
r_char
op_star
id|fun
)paren
(brace
r_int
id|r
suffix:semicolon
id|connect
c_func
(paren
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x44
comma
id|dlen
op_mod
l_int|256
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x45
comma
id|dlen
op_div
l_int|256
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x46
comma
l_int|0xa0
)paren
suffix:semicolon
multiline_comment|/* drive 0 */
id|write_regr
c_func
(paren
l_int|0x47
comma
l_int|0xa0
)paren
suffix:semicolon
multiline_comment|/* ATAPI packet command */
r_if
c_cond
(paren
(paren
id|r
op_assign
id|bp_wait_drq
c_func
(paren
l_string|&quot;bp_command&quot;
comma
id|fun
)paren
)paren
)paren
(brace
id|disconnect
c_func
(paren
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
id|write_cmd
c_func
(paren
id|cmd
comma
l_int|12
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bp_completion
r_static
r_int
id|bp_completion
c_func
(paren
r_char
op_star
id|fun
)paren
(brace
r_int
id|r
comma
id|n
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r
op_assign
id|bp_wait
c_func
(paren
l_string|&quot;bp_completion&quot;
comma
id|fun
)paren
)paren
)paren
(brace
r_if
c_cond
(paren
id|read_regr
c_func
(paren
l_int|0x42
)paren
op_eq
l_int|2
)paren
(brace
id|n
op_assign
(paren
id|read_regr
c_func
(paren
l_int|0x44
)paren
op_plus
l_int|256
op_star
id|read_regr
c_func
(paren
l_int|0x45
)paren
)paren
suffix:semicolon
id|read_data
c_func
(paren
id|bp_buffer
comma
id|n
)paren
suffix:semicolon
id|r
op_assign
id|bp_wait
c_func
(paren
l_string|&quot;transfer done&quot;
comma
id|fun
)paren
suffix:semicolon
)brace
)brace
id|disconnect
c_func
(paren
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|bp_atapi
r_static
r_int
id|bp_atapi
c_func
(paren
r_char
op_star
id|cmd
comma
r_int
id|dlen
comma
r_char
op_star
id|fun
)paren
(brace
r_int
id|r
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|r
op_assign
id|bp_command
c_func
(paren
id|cmd
comma
id|dlen
comma
id|fun
)paren
)paren
)paren
id|r
op_assign
id|bp_completion
c_func
(paren
id|fun
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|bp_req_sense
r_static
r_int
id|bp_req_sense
c_func
(paren
r_char
op_star
id|msg
)paren
(brace
r_char
id|rs_cmd
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x03
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|18
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_int
id|r
suffix:semicolon
id|r
op_assign
id|bp_atapi
c_func
(paren
id|rs_cmd
comma
l_int|18
comma
l_string|&quot;request sense&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|msg
)paren
id|printk
c_func
(paren
l_string|&quot;bpcd: %s:  sense key: %x, ASC: %x, ASQ: %x&bslash;n&quot;
comma
id|msg
comma
id|bp_buffer
(braket
l_int|2
)braket
op_amp
l_int|0xf
comma
id|bp_buffer
(braket
l_int|12
)braket
comma
id|bp_buffer
(braket
l_int|13
)braket
)paren
suffix:semicolon
r_return
id|r
suffix:semicolon
)brace
DECL|function|bp_lock
r_static
r_int
id|bp_lock
c_func
(paren
r_void
)paren
(brace
r_char
id|lo_cmd
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x1e
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_char
id|cl_cmd
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x1b
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|3
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|bp_atapi
c_func
(paren
id|cl_cmd
comma
l_int|0
comma
l_string|&quot;close door&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp_req_sense
c_func
(paren
l_int|NULL
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* check for disk */
id|bp_atapi
c_func
(paren
id|lo_cmd
comma
l_int|0
comma
l_int|NULL
)paren
suffix:semicolon
id|bp_req_sense
c_func
(paren
l_int|NULL
)paren
suffix:semicolon
multiline_comment|/* in case there was a media change */
id|bp_atapi
c_func
(paren
id|lo_cmd
comma
l_int|0
comma
l_string|&quot;lock door&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bp_unlock
r_static
r_void
id|bp_unlock
c_func
(paren
r_void
)paren
(brace
r_char
id|un_cmd
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x1e
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|bp_atapi
c_func
(paren
id|un_cmd
comma
l_int|0
comma
l_string|&quot;unlock door&quot;
)paren
suffix:semicolon
)brace
DECL|function|bp_eject
r_static
r_void
id|bp_eject
c_func
(paren
r_void
)paren
(brace
r_char
id|ej_cmd
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x1b
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|2
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|bp_unlock
c_func
(paren
)paren
suffix:semicolon
id|bp_atapi
c_func
(paren
id|ej_cmd
comma
l_int|0
comma
l_string|&quot;eject&quot;
)paren
suffix:semicolon
)brace
DECL|function|bp_reset
r_static
r_int
id|bp_reset
c_func
(paren
r_void
)paren
multiline_comment|/* the ATAPI standard actually specifies the contents of all 7 registers&n;   after a reset, but the specification is ambiguous concerning the last&n;   two bytes, and different drives interpret the standard differently.&n;*/
(brace
r_int
id|i
comma
id|flg
suffix:semicolon
r_int
id|expect
(braket
l_int|5
)braket
op_assign
(brace
l_int|1
comma
l_int|1
comma
l_int|1
comma
l_int|0x14
comma
l_int|0xeb
)brace
suffix:semicolon
r_int
id|flags
suffix:semicolon
id|connect
c_func
(paren
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x46
comma
l_int|0xa0
)paren
suffix:semicolon
id|write_regr
c_func
(paren
l_int|0x47
comma
l_int|8
)paren
suffix:semicolon
id|save_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|sti
c_func
(paren
)paren
suffix:semicolon
id|udelay
c_func
(paren
l_int|500000
)paren
suffix:semicolon
multiline_comment|/* delay 0.5 seconds */
id|restore_flags
c_func
(paren
id|flags
)paren
suffix:semicolon
id|flg
op_assign
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|5
suffix:semicolon
id|i
op_increment
)paren
(brace
id|flg
op_and_assign
(paren
id|read_regr
c_func
(paren
id|i
op_plus
l_int|0x41
)paren
op_eq
id|expect
(braket
id|i
)braket
)paren
suffix:semicolon
)brace
id|disconnect
c_func
(paren
)paren
suffix:semicolon
r_return
id|flg
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|bp_identify
r_static
r_int
id|bp_identify
c_func
(paren
r_char
op_star
id|id
)paren
(brace
r_int
id|k
suffix:semicolon
r_char
id|id_cmd
(braket
l_int|12
)braket
op_assign
(brace
l_int|0x12
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|36
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|bp_bufblk
op_assign
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bp_atapi
c_func
(paren
id|id_cmd
comma
l_int|36
comma
l_string|&quot;identify&quot;
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|16
suffix:semicolon
id|k
op_increment
)paren
id|id
(braket
id|k
)braket
op_assign
id|bp_buffer
(braket
l_int|16
op_plus
id|k
)braket
suffix:semicolon
id|id
(braket
l_int|16
)braket
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bp_port_check
r_static
r_int
id|bp_port_check
c_func
(paren
r_void
)paren
multiline_comment|/* check for 8-bit port */
(brace
r_int
id|r
suffix:semicolon
id|w2
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0x55
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r0
c_func
(paren
)paren
op_ne
l_int|0x55
)paren
r_return
l_int|0
suffix:semicolon
id|w0
c_func
(paren
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r0
c_func
(paren
)paren
op_ne
l_int|0xaa
)paren
r_return
l_int|0
suffix:semicolon
id|w2
c_func
(paren
l_int|0x20
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0x55
)paren
suffix:semicolon
id|r
op_assign
id|r0
c_func
(paren
)paren
suffix:semicolon
id|w0
c_func
(paren
l_int|0xaa
)paren
suffix:semicolon
r_if
c_cond
(paren
id|r0
c_func
(paren
)paren
op_eq
id|r
)paren
r_return
l_int|2
suffix:semicolon
r_if
c_cond
(paren
id|r0
c_func
(paren
)paren
op_eq
l_int|0xaa
)paren
r_return
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|bp_locate
r_static
r_int
id|bp_locate
c_func
(paren
r_void
)paren
(brace
r_int
id|k
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|100
suffix:semicolon
id|k
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
id|probe
c_func
(paren
id|k
)paren
)paren
(brace
id|bp_unit_id
op_assign
id|k
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|bp_do_detect
r_static
r_int
id|bp_do_detect
c_func
(paren
r_int
id|autop
)paren
(brace
r_char
id|id
(braket
l_int|18
)braket
suffix:semicolon
r_if
c_cond
(paren
id|autop
)paren
id|bp_base
op_assign
id|autop
suffix:semicolon
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|bp_base
comma
l_int|3
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|autop
)paren
id|printk
c_func
(paren
l_string|&quot;bpcd: Ports at 0x%x are not available&bslash;n&quot;
comma
id|bp_base
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|bp_mode
op_assign
id|bp_port_check
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp_mode
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|autop
)paren
id|printk
c_func
(paren
l_string|&quot;bpcd: No parallel port at 0x%x&bslash;n&quot;
comma
id|bp_base
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp_nybble
)paren
id|bp_mode
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|bp_locate
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|autop
)paren
id|printk
c_func
(paren
l_string|&quot;bpcd: Couldn&squot;t find a backpack adapter at 0x%x&bslash;n&quot;
comma
id|bp_base
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp_reset
c_func
(paren
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|autop
)paren
id|printk
c_func
(paren
l_string|&quot;bpcd: Failed to reset CD drive&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp_identify
c_func
(paren
id|id
)paren
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|autop
)paren
id|printk
c_func
(paren
l_string|&quot;bpcd: ATAPI inquiry failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|request_region
c_func
(paren
id|bp_base
comma
l_int|3
comma
l_string|&quot;bpcd&quot;
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bpcd: Found %s, ID %d, using port 0x%x in %d-bit mode&bslash;n&quot;
comma
id|id
comma
id|bp_unit_id
comma
id|bp_base
comma
l_int|4
op_star
id|bp_mode
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* If you know about some other weird parallel port base address,&n;   add it here ....&n;*/
DECL|function|bp_detect
r_static
r_int
id|bp_detect
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|bp_base
)paren
r_return
id|bp_do_detect
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp_do_detect
c_func
(paren
l_int|0x378
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp_do_detect
c_func
(paren
l_int|0x278
)paren
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp_do_detect
c_func
(paren
l_int|0x3bc
)paren
)paren
r_return
l_int|0
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;bpcd: Autoprobe failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|bp_transfer
r_static
r_void
id|bp_transfer
c_func
(paren
r_void
)paren
(brace
r_int
id|k
comma
id|o
suffix:semicolon
r_while
c_loop
(paren
id|bp_count
op_logical_and
(paren
id|bp_sector
op_div
l_int|4
op_eq
id|bp_bufblk
)paren
)paren
(brace
id|o
op_assign
(paren
id|bp_sector
op_mod
l_int|4
)paren
op_star
l_int|512
suffix:semicolon
r_for
c_loop
(paren
id|k
op_assign
l_int|0
suffix:semicolon
id|k
OL
l_int|512
suffix:semicolon
id|k
op_increment
)paren
(brace
id|bp_buf
(braket
id|k
)braket
op_assign
id|bp_buffer
(braket
id|o
op_plus
id|k
)braket
suffix:semicolon
)brace
id|bp_count
op_decrement
suffix:semicolon
id|bp_buf
op_add_assign
l_int|512
suffix:semicolon
id|bp_sector
op_increment
suffix:semicolon
)brace
)brace
DECL|function|do_bp_read
r_static
r_void
id|do_bp_read
c_func
(paren
r_void
)paren
(brace
r_int
id|b
comma
id|i
suffix:semicolon
r_char
id|rd_cmd
(braket
l_int|12
)braket
op_assign
(brace
l_int|0xa8
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|1
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|bp_busy
op_assign
l_int|1
suffix:semicolon
id|bp_transfer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|bp_count
)paren
(brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|bp_busy
op_assign
l_int|0
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
id|bp_bufblk
op_assign
id|bp_sector
op_div
l_int|4
suffix:semicolon
id|b
op_assign
id|bp_bufblk
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
l_int|4
suffix:semicolon
id|i
op_increment
)paren
(brace
id|rd_cmd
(braket
l_int|5
op_minus
id|i
)braket
op_assign
id|b
op_amp
l_int|0xff
suffix:semicolon
id|b
op_assign
id|b
op_rshift
l_int|8
suffix:semicolon
)brace
r_if
c_cond
(paren
id|bp_command
c_func
(paren
id|rd_cmd
comma
l_int|2048
comma
l_string|&quot;read block&quot;
)paren
)paren
(brace
id|bp_bufblk
op_assign
op_minus
l_int|1
suffix:semicolon
id|bp_busy
op_assign
l_int|0
suffix:semicolon
id|cli
c_func
(paren
)paren
suffix:semicolon
id|bp_req_sense
c_func
(paren
l_string|&quot;send read command&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|bp_timeout
op_assign
id|jiffies
op_plus
id|BP_TMO
suffix:semicolon
id|queue_task
c_func
(paren
op_amp
id|bp_tq
comma
op_amp
id|tq_scheduler
)paren
suffix:semicolon
)brace
DECL|function|bp_interrupt
r_static
r_void
id|bp_interrupt
c_func
(paren
r_void
op_star
id|data
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|read_regr
c_func
(paren
l_int|0xb
)paren
op_amp
l_int|0x80
)paren
)paren
(brace
r_if
c_cond
(paren
id|jiffies
OG
id|bp_timeout
)paren
(brace
id|bp_bufblk
op_assign
op_minus
l_int|1
suffix:semicolon
id|bp_busy
op_assign
l_int|0
suffix:semicolon
id|bp_req_sense
c_func
(paren
l_string|&quot;interrupt timeout&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|do_bp_request
c_func
(paren
)paren
suffix:semicolon
)brace
id|queue_task
c_func
(paren
op_amp
id|bp_tq
comma
op_amp
id|tq_scheduler
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|sti
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|bp_completion
c_func
(paren
l_string|&quot;read completion&quot;
)paren
)paren
(brace
id|cli
c_func
(paren
)paren
suffix:semicolon
id|bp_busy
op_assign
l_int|0
suffix:semicolon
id|bp_bufblk
op_assign
op_minus
l_int|1
suffix:semicolon
id|bp_req_sense
c_func
(paren
l_string|&quot;read completion&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|do_bp_request
c_func
(paren
)paren
suffix:semicolon
)brace
id|do_bp_read
c_func
(paren
)paren
suffix:semicolon
id|do_bp_request
c_func
(paren
)paren
suffix:semicolon
)brace
multiline_comment|/* end of bpcd.c */
eof
