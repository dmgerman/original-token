multiline_comment|/*&n; * The Mitsumi CDROM interface&n; *&n; * (H) Hackright 1996 by Marcin Dalecki &lt;dalecki@namu03.gwdg.de&gt;&n; * &n; * Based on previous work (as of version 1.9) done by:&n; * Copyright (C) 1995 Heiko Schlittermann &lt;heiko@lotte.sax.de&gt;&n; *&n; * VERSION: 2.5&n; * &n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; * &n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; * &n; * You should have received a copy of the GNU General Public License&n; * along with this program; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Thanks to&n; *  The Linux Community at all and ...&n; *  Martin Harriss (he wrote the first Mitsumi Driver)&n; *  Eberhard Moenkeberg (he gave me much support and the initial kick)&n; *  Bernd Huebner, Ruediger Helsch (Unifix-Software GmbH, they&n; *      improved the original driver)&n; *  Jon Tombs, Bjorn Ekwall (module support)&n; *  Daniel v. Mosnenck (he sent me the Technical and Programming Reference)&n; *  Gerd Knorr (he lent me his PhotoCD)&n; *  Nils Faerber and Roger E. Wolff (extensively tested the LU portion)&n; *  Andreas Kies (testing the mysterious hangups)&n; *  ... somebody forgotten?&n; * &n; * 2.1  1996/04/29 Marcin Dalecki &lt;dalecki@namu03.gwdg.de&gt;&n; *      Far too many bugfixes/changes to mention them all separately.&n; * 2.2  1996/05/06 Marcin Dalecki &lt;dalecki@namu03.gwdg.de&gt;&n; *      Mostly fixes to some silly bugs in the previous release :-).&n; *      (Hi Michael Thimm! Thank&squot;s for lending me Your&squot;s double speed drive.)&n; * 2.3  1996/05/15 Marcin Dalecki &lt;dalecki@namu03.gwdg.de&gt;&n; *      Fixed stereo support. &n; * 2.5  1996/05/19 Marcin Dalecki &lt;dalecki@namu03.gwdg.de&gt;&n; *      Overall performance increased by a factor of 1.25 :-).&n; *      I hope Heiko doesn&squot;t mind the Hackright change, but there isn&squot;t much of&n; *      code left from his version 1.9 anymore. &n; *      Start speedup for Work(Man|Bone).&n; *&n; * NOTE:&n; *      There will be probably a 3.0 adhering to the new generic non ATAPI&n; *      CDROM interface in the unforeseen future.&n; */
DECL|macro|VERSION
mdefine_line|#define VERSION &quot;2.5&quot;
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;linux/major.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR MITSUMI_X_CDROM_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
multiline_comment|/* &n; * for compatible parameter passing with &quot;insmod&quot; &n; */
DECL|macro|mcdx_drive_map
mdefine_line|#define&t;mcdx_drive_map mcdx
macro_line|#include &lt;linux/mcdx.h&gt;
DECL|macro|REQUEST_SIZE
mdefine_line|#define REQUEST_SIZE&t;400
DECL|enum|drivemodes
r_enum
id|drivemodes
(brace
DECL|enumerator|TOC
DECL|enumerator|DATA
DECL|enumerator|RAW
DECL|enumerator|COOKED
id|TOC
comma
id|DATA
comma
id|RAW
comma
id|COOKED
)brace
suffix:semicolon
DECL|macro|MODE0
mdefine_line|#define&t;MODE0 &t;&t;0x00
DECL|macro|MODE1
mdefine_line|#define MODE1 &t;&t;0x01
DECL|macro|MODE2
mdefine_line|#define MODE2 &t;&t;0x02
DECL|macro|DOOR_LOCK
mdefine_line|#define DOOR_LOCK &t;0x01
DECL|macro|DOOR_UNLOCK
mdefine_line|#define DOOR_UNLOCK &t;0x00
multiline_comment|/*&n; * Structs used to gather info reported by the drive.&n; */
DECL|struct|s_subqcode
r_struct
id|s_subqcode
(brace
DECL|member|adr
id|u_char
id|adr
suffix:colon
l_int|4
suffix:semicolon
DECL|member|ctrl
id|u_char
id|ctrl
suffix:colon
l_int|4
suffix:semicolon
DECL|member|tno
id|u_char
id|tno
suffix:semicolon
DECL|member|index
id|u_char
id|index
suffix:semicolon
DECL|member|tt
r_struct
id|cdrom_msf0
id|tt
suffix:semicolon
DECL|member|dummy
id|u_char
id|dummy
suffix:semicolon
multiline_comment|/* padding for matching the returned struct */
DECL|member|dt
r_struct
id|cdrom_msf0
id|dt
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|s_multi
r_struct
id|s_multi
(brace
DECL|member|multi
r_int
r_char
id|multi
suffix:semicolon
DECL|member|msf_last
r_struct
id|cdrom_msf0
id|msf_last
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|s_play
r_struct
id|s_play
(brace
DECL|member|start
r_struct
id|cdrom_msf0
id|start
suffix:semicolon
DECL|member|stop
r_struct
id|cdrom_msf0
id|stop
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* &n; * Per drive/controller stuff.&n; */
DECL|struct|s_drive_stuff
r_struct
id|s_drive_stuff
(brace
DECL|member|busyq
r_struct
id|wait_queue
op_star
id|busyq
suffix:semicolon
multiline_comment|/* flags */
DECL|member|used
id|u_char
id|used
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* locks on open, we allow only&n;&t;&t;&t;&t;   exclusive usage of the drive */
DECL|member|introk
id|u_char
id|introk
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* status of last irq operation */
DECL|member|busy
id|u_char
id|busy
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* drive performs an operation */
DECL|member|eject_sw
id|u_char
id|eject_sw
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1 - eject on last close (default 0) */
DECL|member|autoclose
id|u_char
id|autoclose
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1 - close the door on open (default 1) */
DECL|member|xxx
id|u_char
id|xxx
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* set if changed, reset while open */
DECL|member|xa
id|u_char
id|xa
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1 if xa disk */
DECL|member|audio
id|u_char
id|audio
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* 1 if audio disk */
DECL|member|eom
id|u_char
id|eom
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* end of media reached during read request */
multiline_comment|/* drives capabilities */
DECL|member|door
id|u_char
id|door
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* can close/lock tray */
DECL|member|multi_cap
id|u_char
id|multi_cap
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* multi-session capable */
DECL|member|double_speed
id|u_char
id|double_speed
suffix:colon
l_int|1
suffix:semicolon
multiline_comment|/* double speed drive */
multiline_comment|/* cd infos */
DECL|member|first
id|u_int
id|first
suffix:semicolon
DECL|member|last
id|u_int
id|last
suffix:semicolon
DECL|member|msf_leadout
r_struct
id|cdrom_msf0
id|msf_leadout
suffix:semicolon
DECL|member|multi
r_struct
id|s_multi
id|multi
suffix:semicolon
DECL|member|toc
r_struct
id|s_subqcode
op_star
id|toc
suffix:semicolon
multiline_comment|/* first entry of the toc array */
DECL|member|resume
r_struct
id|s_play
id|resume
suffix:semicolon
multiline_comment|/* where to resume after pause */
DECL|member|audiostatus
r_int
id|audiostatus
suffix:semicolon
multiline_comment|/* `buffer&squot; control */
DECL|member|valid
id|u_char
id|valid
suffix:colon
l_int|1
suffix:semicolon
DECL|member|pending
r_int
id|pending
suffix:semicolon
DECL|member|border
r_int
id|border
suffix:semicolon
multiline_comment|/* the last sector in sequence we will read,&n;&t;&t;&t;&t;   without reissuing a read command */
DECL|member|base
id|u_int
id|base
suffix:semicolon
multiline_comment|/* base for all registers of the drive */
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* irq used by this drive */
DECL|member|lastsector
r_int
id|lastsector
suffix:semicolon
multiline_comment|/* last accessible block */
)brace
suffix:semicolon
multiline_comment|/*&n; * Macros for accessing interface registers&n; */
DECL|macro|DATA_REG
mdefine_line|#define DATA_REG&t;(stuffp-&gt;base)
DECL|macro|RESET_REG
mdefine_line|#define RESET_REG&t;(stuffp-&gt;base+1)
DECL|macro|STAT_REG
mdefine_line|#define STAT_REG&t;(stuffp-&gt;base+1)
DECL|macro|CHAN_REG
mdefine_line|#define CHAN_REG&t;(stuffp-&gt;base+3)
multiline_comment|/*      &n; * Access to elements of the mcdx_drive_map members &n; */
DECL|macro|PORT
mdefine_line|#define PORT &t;0
DECL|macro|IRQ
mdefine_line|#define IRQ &t;1
multiline_comment|/* &n; * declared in blk.h &n; */
r_int
id|mcdx_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|do_mcdx_request
c_func
(paren
r_void
)paren
suffix:semicolon
multiline_comment|/* &n; * already declared in init/main &n; */
r_void
id|mcdx_setup
c_func
(paren
r_char
op_star
comma
r_int
op_star
)paren
suffix:semicolon
multiline_comment|/*      &n; * Indirect exported functions. These functions are exported by their&n; * addresses, such as mcdx_open and mcdx_close in the &n; * structure fops. &n; */
multiline_comment|/* &n; * ???  exported by the mcdx_sigaction struct &n; */
r_static
r_void
id|mcdx_intr
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
multiline_comment|/* &n; * exported by file_ops &n; */
r_static
r_int
id|mcdx_open
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_void
id|mcdx_close
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
)paren
suffix:semicolon
r_static
r_int
id|mcdx_ioctl
c_func
(paren
r_struct
id|inode
op_star
comma
r_struct
id|file
op_star
comma
r_int
r_int
comma
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_media_change
c_func
(paren
id|kdev_t
)paren
suffix:semicolon
DECL|variable|mcdx_blksize_size
r_static
r_int
id|mcdx_blksize_size
(braket
id|MCDX_NDRIVES
)braket
suffix:semicolon
DECL|variable|mcdx_drive_map
r_static
r_int
id|mcdx_drive_map
(braket
)braket
(braket
l_int|2
)braket
op_assign
id|MCDX_DRIVEMAP
suffix:semicolon
DECL|variable|mcdx_stuffp
r_static
r_struct
id|s_drive_stuff
op_star
id|mcdx_stuffp
(braket
id|MCDX_NDRIVES
)braket
suffix:semicolon
DECL|variable|mcdx_irq_map
r_static
r_struct
id|s_drive_stuff
op_star
id|mcdx_irq_map
(braket
l_int|16
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
DECL|variable|mcdx_fops
r_static
r_struct
id|file_operations
id|mcdx_fops
op_assign
(brace
l_int|NULL
comma
multiline_comment|/* lseek - use kernel default */
id|block_read
comma
multiline_comment|/* read - general block-dev read */
id|block_write
comma
multiline_comment|/* write - general block-dev write */
l_int|NULL
comma
multiline_comment|/* no readdir */
l_int|NULL
comma
multiline_comment|/* no select */
id|mcdx_ioctl
comma
multiline_comment|/* ioctl() */
l_int|NULL
comma
multiline_comment|/* no mmap */
id|mcdx_open
comma
multiline_comment|/* open() */
id|mcdx_close
comma
multiline_comment|/* close() */
l_int|NULL
comma
multiline_comment|/* fsync */
l_int|NULL
comma
multiline_comment|/* fasync */
id|mcdx_media_change
comma
multiline_comment|/* media_change */
l_int|NULL
multiline_comment|/* revalidate */
)brace
suffix:semicolon
multiline_comment|/*     &n; * Misc number converters &n; */
DECL|function|bcd2uint
r_static
r_int
r_int
id|bcd2uint
c_func
(paren
r_int
r_int
id|c
)paren
(brace
r_return
(paren
id|c
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|c
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
DECL|function|uint2bcd
r_static
r_int
r_int
id|uint2bcd
c_func
(paren
r_int
r_int
id|ival
)paren
(brace
r_return
(paren
(paren
id|ival
op_div
l_int|10
)paren
op_lshift
l_int|4
)paren
op_or
(paren
id|ival
op_mod
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|msf2log
r_static
r_int
r_int
id|msf2log
c_func
(paren
r_const
r_struct
id|cdrom_msf0
op_star
id|pmsf
)paren
(brace
r_return
id|bcd2uint
c_func
(paren
id|pmsf-&gt;frame
)paren
op_plus
id|bcd2uint
c_func
(paren
id|pmsf-&gt;second
)paren
op_star
l_int|75
op_plus
id|bcd2uint
c_func
(paren
id|pmsf-&gt;minute
)paren
op_star
l_int|4500
op_minus
id|CD_BLOCK_OFFSET
suffix:semicolon
)brace
multiline_comment|/*&n; * Low level hardware related functions.&n; */
multiline_comment|/*&n; * Return drives status in case of success, -1 otherwise.&n; *&n; * First we try to get the status information quickly.&n; * Then we sleep repeatedly for about 10 usecs, before we finally reach the &n; * timeout. For this reason this command must be called with the drive being &n; * locked!&n; */
DECL|function|get_status
r_static
r_int
id|get_status
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_int
r_int
id|timeout
)paren
(brace
r_int
r_int
id|bang
op_assign
id|jiffies
op_plus
l_int|2
suffix:semicolon
id|timeout
op_add_assign
id|jiffies
suffix:semicolon
r_do
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|STAT_REG
)paren
op_amp
id|MCDX_RBIT_STEN
)paren
)paren
(brace
r_return
(paren
id|inb
c_func
(paren
id|DATA_REG
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
id|jiffies
OL
id|bang
)paren
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
id|STAT_REG
)paren
op_amp
id|MCDX_RBIT_STEN
)paren
(brace
r_if
c_cond
(paren
id|jiffies
OG
id|timeout
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|2
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_return
(paren
id|inb
c_func
(paren
id|DATA_REG
)paren
op_amp
l_int|0xff
)paren
suffix:semicolon
)brace
DECL|function|release_toc
r_static
r_void
id|release_toc
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
)paren
(brace
r_if
c_cond
(paren
id|stuffp-&gt;toc
)paren
(brace
id|kfree
c_func
(paren
id|stuffp-&gt;toc
)paren
suffix:semicolon
id|stuffp-&gt;toc
op_assign
l_int|0
suffix:semicolon
)brace
)brace
multiline_comment|/* Send a command to the drive, wait for the result.&n; * returns -1 on timeout, drive status otherwise.&n; * If buffer is not zero, the result (length size) is stored there.&n; * If buffer is zero the size should be the number of bytes to read&n; * from the drive.  These bytes are discarded.&n; */
DECL|function|talk
r_static
r_int
id|talk
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_const
r_int
r_char
id|command
comma
r_void
op_star
id|pars
comma
r_int
id|parslen
comma
r_void
op_star
id|buffer
comma
r_int
id|size
comma
r_int
r_int
id|timeout
)paren
(brace
r_int
id|st
suffix:semicolon
id|stuffp-&gt;valid
op_assign
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|command
comma
id|DATA_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|parslen
)paren
id|outsb
c_func
(paren
id|DATA_REG
comma
id|pars
comma
id|parslen
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
id|st
op_assign
id|get_status
c_func
(paren
id|stuffp
comma
id|timeout
)paren
)paren
)paren
(brace
r_goto
id|end_talk
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st
op_amp
id|MCDX_RBIT_CMDERR
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|MCDX
l_string|&quot;: error in command 0x%2x&bslash;n&quot;
comma
id|command
)paren
suffix:semicolon
id|st
op_assign
op_minus
l_int|1
suffix:semicolon
r_goto
id|end_talk
suffix:semicolon
)brace
multiline_comment|/* audio status? */
r_if
c_cond
(paren
id|stuffp-&gt;audiostatus
op_eq
id|CDROM_AUDIO_INVALID
)paren
(brace
id|stuffp-&gt;audiostatus
op_assign
(paren
id|st
op_amp
id|MCDX_RBIT_AUDIOBS
)paren
ques
c_cond
id|CDROM_AUDIO_PLAY
suffix:colon
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|stuffp-&gt;audiostatus
op_eq
id|CDROM_AUDIO_PLAY
op_logical_and
op_logical_neg
(paren
id|st
op_amp
id|MCDX_RBIT_AUDIOBS
)paren
)paren
(brace
id|stuffp-&gt;audiostatus
op_assign
id|CDROM_AUDIO_COMPLETED
suffix:semicolon
)brace
multiline_comment|/* media change? */
r_if
c_cond
(paren
id|st
op_amp
id|MCDX_RBIT_CHANGED
)paren
id|stuffp-&gt;xxx
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* now actually get the data */
r_while
c_loop
(paren
id|size
op_decrement
)paren
(brace
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
id|st
op_assign
id|get_status
c_func
(paren
id|stuffp
comma
id|timeout
)paren
)paren
)paren
(brace
r_break
suffix:semicolon
)brace
op_star
(paren
(paren
r_char
op_star
)paren
id|buffer
)paren
op_assign
id|st
suffix:semicolon
id|buffer
op_increment
suffix:semicolon
)brace
multiline_comment|/* The goto&squot;s make GCC generate better code.&n;&t; */
id|end_talk
suffix:colon
r_return
id|st
suffix:semicolon
)brace
DECL|function|issue_command
r_static
r_int
id|issue_command
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_int
r_char
id|command
comma
r_int
r_int
id|timeout
)paren
(brace
r_return
id|talk
c_func
(paren
id|stuffp
comma
id|command
comma
l_int|0
comma
l_int|0
comma
l_int|NULL
comma
l_int|0
comma
id|timeout
)paren
suffix:semicolon
)brace
DECL|function|set_command
r_static
r_inline
r_int
id|set_command
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_const
r_int
r_char
id|command
comma
r_void
op_star
id|pars
comma
r_int
id|parlen
comma
r_int
r_int
id|timeout
)paren
(brace
r_return
id|talk
c_func
(paren
id|stuffp
comma
id|command
comma
id|pars
comma
id|parlen
comma
l_int|NULL
comma
l_int|0
comma
id|timeout
)paren
suffix:semicolon
)brace
DECL|function|get_command
r_static
r_inline
r_int
id|get_command
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_const
r_int
r_char
id|command
comma
r_void
op_star
id|buffer
comma
r_int
id|size
comma
r_int
r_int
id|timeout
)paren
(brace
r_return
id|talk
c_func
(paren
id|stuffp
comma
id|command
comma
l_int|NULL
comma
l_int|0
comma
id|buffer
comma
id|size
comma
id|timeout
)paren
suffix:semicolon
)brace
DECL|function|request_subq_code
r_static
r_int
id|request_subq_code
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_struct
id|s_subqcode
op_star
id|sub
)paren
(brace
r_return
id|get_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_GET_SUBQ_CODE
comma
id|sub
comma
r_sizeof
(paren
r_struct
id|s_subqcode
)paren
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
)brace
DECL|function|request_toc_data
r_static
r_int
id|request_toc_data
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
)paren
(brace
r_char
id|buf
(braket
l_int|8
)braket
suffix:semicolon
r_int
id|ans
suffix:semicolon
id|ans
op_assign
id|get_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_GET_TOC
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ans
op_eq
op_minus
l_int|1
)paren
(brace
id|stuffp-&gt;first
op_assign
l_int|0
suffix:semicolon
id|stuffp-&gt;last
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|stuffp-&gt;first
op_assign
id|bcd2uint
c_func
(paren
id|buf
(braket
l_int|0
)braket
)paren
suffix:semicolon
id|stuffp-&gt;last
op_assign
id|bcd2uint
c_func
(paren
id|buf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|memcpy
c_func
(paren
op_amp
(paren
id|stuffp-&gt;msf_leadout
)paren
comma
id|buf
op_plus
l_int|2
comma
l_int|3
)paren
suffix:semicolon
)brace
r_return
id|ans
suffix:semicolon
)brace
DECL|function|set_drive_mode
r_static
r_int
id|set_drive_mode
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_enum
id|drivemodes
id|mode
)paren
(brace
r_char
id|value
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|get_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_GET_DRIVE_MODE
comma
op_amp
id|value
comma
l_int|1
comma
l_int|5
op_star
id|HZ
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|TOC
suffix:colon
id|value
op_or_assign
l_int|0x04
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DATA
suffix:colon
id|value
op_and_assign
op_complement
l_int|0x04
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RAW
suffix:colon
id|value
op_or_assign
l_int|0x40
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COOKED
suffix:colon
id|value
op_and_assign
op_complement
l_int|0x40
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
r_return
id|set_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_SET_DRIVE_MODE
comma
op_amp
id|value
comma
l_int|1
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
)brace
DECL|function|config_drive
r_static
r_int
id|config_drive
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
)paren
(brace
r_int
r_char
id|buf
(braket
l_int|2
)braket
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* irq enable */
id|buf
(braket
l_int|1
)braket
op_assign
l_int|0x05
suffix:semicolon
multiline_comment|/* pre, err irq enable */
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|set_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_CONFIG
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_int|1
op_star
id|HZ
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|buf
(braket
l_int|0
)braket
op_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* dma select */
id|buf
(braket
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* no dma */
r_return
id|set_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_CONFIG
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
)brace
multiline_comment|/*  &n; * Read the toc entries from the CD.&n; * Return: -1 on failure, else 0 &n; */
DECL|function|read_toc
r_int
id|read_toc
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
)paren
(brace
r_int
id|trk
suffix:semicolon
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;toc
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|issue_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_HOLD
comma
l_int|2
op_star
id|HZ
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|set_drive_mode
c_func
(paren
id|stuffp
comma
id|TOC
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* All seems to be OK so far ... malloc. When this fails all bets&n;&t; * are off anyway, so we don&squot;t check for it.&n;&t; */
id|stuffp-&gt;toc
op_assign
id|kmalloc
c_func
(paren
r_sizeof
(paren
r_struct
id|s_subqcode
)paren
op_star
(paren
id|stuffp-&gt;last
op_minus
id|stuffp-&gt;first
op_plus
l_int|1
)paren
comma
id|GFP_KERNEL
)paren
suffix:semicolon
multiline_comment|/* now read actually the index tracks */
r_for
c_loop
(paren
id|trk
op_assign
l_int|0
suffix:semicolon
id|trk
OL
id|stuffp-&gt;last
op_minus
id|stuffp-&gt;first
op_plus
l_int|1
suffix:semicolon
id|trk
op_increment
)paren
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|index
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|300
suffix:semicolon
id|i
suffix:semicolon
op_decrement
id|i
)paren
(brace
multiline_comment|/* why 300? */
r_struct
id|s_subqcode
id|q
suffix:semicolon
r_int
r_int
id|idx
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|request_subq_code
c_func
(paren
id|stuffp
comma
op_amp
id|q
)paren
)paren
(brace
id|set_drive_mode
c_func
(paren
id|stuffp
comma
id|DATA
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|idx
op_assign
id|bcd2uint
c_func
(paren
id|q.index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|idx
OG
l_int|0
op_logical_and
id|idx
op_le
id|stuffp-&gt;last
op_logical_and
id|q.tno
op_eq
l_int|0
op_logical_and
id|stuffp-&gt;toc
(braket
id|idx
op_minus
id|stuffp-&gt;first
)braket
dot
id|index
op_eq
l_int|0
)paren
(brace
id|stuffp-&gt;toc
(braket
id|idx
op_minus
id|stuffp-&gt;first
)braket
op_assign
id|q
suffix:semicolon
id|trk
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|trk
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|i
op_assign
id|stuffp-&gt;last
op_minus
id|stuffp-&gt;first
op_plus
l_int|1
suffix:semicolon
id|memset
c_func
(paren
op_amp
id|stuffp-&gt;toc
(braket
id|i
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|stuffp-&gt;toc
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|stuffp-&gt;toc
(braket
id|i
)braket
dot
id|dt
op_assign
id|stuffp-&gt;msf_leadout
suffix:semicolon
multiline_comment|/* unset toc mode */
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|set_drive_mode
c_func
(paren
id|stuffp
comma
id|DATA
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Return 0 on success, error value -1 otherwise.&n; */
DECL|function|play_track
r_static
r_int
id|play_track
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_const
r_struct
id|cdrom_ti
op_star
id|ti
)paren
(brace
r_struct
id|s_play
id|times
suffix:semicolon
r_if
c_cond
(paren
id|ti
)paren
(brace
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|read_toc
c_func
(paren
id|stuffp
)paren
)paren
(brace
id|stuffp-&gt;audiostatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|times.start
op_assign
id|stuffp-&gt;toc
(braket
id|ti-&gt;cdti_trk0
op_minus
id|stuffp-&gt;first
)braket
dot
id|dt
suffix:semicolon
id|times.stop
op_assign
id|stuffp-&gt;resume.stop
op_assign
id|stuffp-&gt;toc
(braket
id|ti-&gt;cdti_trk1
op_minus
id|stuffp-&gt;first
op_plus
l_int|1
)braket
dot
id|dt
suffix:semicolon
)brace
r_else
(brace
id|times
op_assign
id|stuffp-&gt;resume
suffix:semicolon
)brace
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|set_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_PLAY
comma
op_amp
id|times
comma
r_sizeof
(paren
id|times
)paren
comma
l_int|5
op_star
id|HZ
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
id|MCDX
l_string|&quot;: play track timeout&bslash;n&quot;
)paren
suffix:semicolon
id|stuffp-&gt;audiostatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|stuffp-&gt;audiostatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|lock_door
r_static
r_int
id|lock_door
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
id|u_char
id|lock
)paren
(brace
r_if
c_cond
(paren
id|stuffp-&gt;door
)paren
r_return
id|set_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_LOCK_DOOR
comma
op_amp
id|lock
comma
r_sizeof
(paren
id|lock
)paren
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/* &n; * KERNEL INTERFACE FUNCTIONS&n; */
DECL|function|mcdx_ioctl
r_static
r_int
id|mcdx_ioctl
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
comma
r_int
r_int
id|command
comma
r_int
r_int
id|arg
)paren
(brace
r_int
id|ans
suffix:semicolon
r_struct
id|cdrom_ti
id|ti
suffix:semicolon
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_struct
id|cdrom_tocentry
id|entry
suffix:semicolon
r_struct
id|s_subqcode
op_star
id|tp
op_assign
l_int|NULL
suffix:semicolon
r_struct
id|cdrom_subchnl
id|sub
suffix:semicolon
r_struct
id|s_subqcode
id|q
suffix:semicolon
r_struct
id|cdrom_tochdr
id|toc
suffix:semicolon
r_struct
id|cdrom_multisession
id|ms
suffix:semicolon
r_struct
id|cdrom_volctrl
id|volctrl
suffix:semicolon
r_struct
id|s_drive_stuff
op_star
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|ip-&gt;i_rdev
)paren
)braket
suffix:semicolon
id|MCDX_TRACE_IOCTL
c_func
(paren
(paren
l_string|&quot;mcdx_ioctl():&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|ip
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_switch
c_cond
(paren
id|command
)paren
(brace
r_case
id|CDROMSTART
suffix:colon
multiline_comment|/* spin up the drive */
id|MCDX_TRACE_IOCTL
c_func
(paren
(paren
l_string|&quot;CDROMSTART&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/* Don&squot;t think we can do this.  Even if we could,&n;&t;&t; * I think the drive times out and stops after a while&n;&t;&t; * anyway.  For now, ignore it.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
id|MCDX_TRACE_IOCTL
c_func
(paren
(paren
l_string|&quot;CDROMSTOP&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stuffp-&gt;audiostatus
op_assign
id|CDROM_AUDIO_INVALID
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|issue_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_STOP
comma
l_int|2
op_star
id|HZ
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMPLAYTRKIND
suffix:colon
id|MCDX_TRACE_IOCTL
c_func
(paren
(paren
l_string|&quot;CDROMPLAYTRKIND&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|ti
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|ti
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ti.cdti_trk0
template_param
id|stuffp-&gt;last
op_logical_or
id|ti.cdti_trk1
OL
id|stuffp-&gt;first
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ti.cdti_trk1
OG
id|stuffp-&gt;last
)paren
id|ti.cdti_trk1
op_assign
id|stuffp-&gt;last
suffix:semicolon
r_return
id|play_track
c_func
(paren
id|stuffp
comma
op_amp
id|ti
)paren
suffix:semicolon
r_case
id|CDROMPLAYMSF
suffix:colon
id|MCDX_TRACE_IOCTL
c_func
(paren
(paren
l_string|&quot;CDROMPLAYMSF &quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|cdrom_msf
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|msf
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|msf
)paren
suffix:semicolon
id|msf.cdmsf_min0
op_assign
id|uint2bcd
c_func
(paren
id|msf.cdmsf_min0
)paren
suffix:semicolon
id|msf.cdmsf_sec0
op_assign
id|uint2bcd
c_func
(paren
id|msf.cdmsf_sec0
)paren
suffix:semicolon
id|msf.cdmsf_frame0
op_assign
id|uint2bcd
c_func
(paren
id|msf.cdmsf_frame0
)paren
suffix:semicolon
id|stuffp-&gt;resume.stop.minute
op_assign
id|msf.cdmsf_min1
op_assign
id|uint2bcd
c_func
(paren
id|msf.cdmsf_min1
)paren
suffix:semicolon
id|stuffp-&gt;resume.stop.second
op_assign
id|msf.cdmsf_sec1
op_assign
id|uint2bcd
c_func
(paren
id|msf.cdmsf_sec1
)paren
suffix:semicolon
id|stuffp-&gt;resume.stop.frame
op_assign
id|msf.cdmsf_frame1
op_assign
id|uint2bcd
c_func
(paren
id|msf.cdmsf_frame1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|set_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_PLAY
comma
op_amp
id|msf
comma
r_sizeof
(paren
id|msf
)paren
comma
l_int|3
op_star
id|HZ
)paren
)paren
(brace
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|stuffp-&gt;audiostatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMPAUSE
suffix:colon
id|MCDX_TRACE_IOCTL
c_func
(paren
(paren
l_string|&quot;CDROMPAUSE&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;audiostatus
op_ne
id|CDROM_AUDIO_PLAY
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|issue_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_STOP
comma
l_int|2
op_star
id|HZ
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|request_subq_code
c_func
(paren
id|stuffp
comma
op_amp
id|q
)paren
)paren
(brace
id|stuffp-&gt;audiostatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|stuffp-&gt;resume.start
op_assign
id|q.dt
suffix:semicolon
id|stuffp-&gt;audiostatus
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
id|MCDX_TRACE_IOCTL
c_func
(paren
(paren
l_string|&quot;CDROMRESUME&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;audiostatus
op_ne
id|CDROM_AUDIO_PAUSED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
id|play_track
c_func
(paren
id|stuffp
comma
l_int|NULL
)paren
suffix:semicolon
r_case
id|CDROMREADTOCENTRY
suffix:colon
id|MCDX_TRACE_IOCTL
c_func
(paren
(paren
l_string|&quot;CDROMREADTOCENTRY&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|read_toc
c_func
(paren
id|stuffp
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|entry
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|entry
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|entry
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|entry.cdte_track
op_eq
id|CDROM_LEADOUT
)paren
id|tp
op_assign
op_amp
id|stuffp-&gt;toc
(braket
id|stuffp-&gt;last
op_minus
id|stuffp-&gt;first
op_plus
l_int|1
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry.cdte_track
OG
id|stuffp-&gt;last
op_logical_or
id|entry.cdte_track
OL
id|stuffp-&gt;first
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
id|tp
op_assign
op_amp
id|stuffp-&gt;toc
(braket
id|entry.cdte_track
op_minus
id|stuffp-&gt;first
)braket
suffix:semicolon
id|entry.cdte_adr
op_assign
id|tp-&gt;adr
suffix:semicolon
id|entry.cdte_ctrl
op_assign
id|tp-&gt;ctrl
suffix:semicolon
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
id|entry.cdte_addr.msf.minute
op_assign
id|bcd2uint
c_func
(paren
id|tp-&gt;dt.minute
)paren
suffix:semicolon
id|entry.cdte_addr.msf.second
op_assign
id|bcd2uint
c_func
(paren
id|tp-&gt;dt.second
)paren
suffix:semicolon
id|entry.cdte_addr.msf.frame
op_assign
id|bcd2uint
c_func
(paren
id|tp-&gt;dt.frame
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|entry.cdte_format
op_eq
id|CDROM_LBA
)paren
id|entry.cdte_addr.lba
op_assign
id|msf2log
c_func
(paren
op_amp
id|tp-&gt;dt
)paren
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|entry
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|entry
comma
r_sizeof
(paren
id|entry
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMSUBCHNL
suffix:colon
id|MCDX_TRACE_IOCTL
c_func
(paren
(paren
l_string|&quot;CDROMSUBCHNL&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|sub
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|sub
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|sub
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|request_subq_code
c_func
(paren
id|stuffp
comma
op_amp
id|q
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|sub.cdsc_audiostatus
op_assign
id|stuffp-&gt;audiostatus
suffix:semicolon
id|sub.cdsc_adr
op_assign
id|q.adr
suffix:semicolon
id|sub.cdsc_ctrl
op_assign
id|q.ctrl
suffix:semicolon
id|sub.cdsc_trk
op_assign
id|bcd2uint
c_func
(paren
id|q.tno
)paren
suffix:semicolon
id|sub.cdsc_ind
op_assign
id|bcd2uint
c_func
(paren
id|q.index
)paren
suffix:semicolon
r_if
c_cond
(paren
id|sub.cdsc_format
op_eq
id|CDROM_LBA
)paren
(brace
id|sub.cdsc_absaddr.lba
op_assign
id|msf2log
c_func
(paren
op_amp
id|q.dt
)paren
suffix:semicolon
id|sub.cdsc_reladdr.lba
op_assign
id|msf2log
c_func
(paren
op_amp
id|q.tt
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|sub.cdsc_format
op_eq
id|CDROM_MSF
)paren
(brace
id|sub.cdsc_absaddr.msf.minute
op_assign
id|bcd2uint
c_func
(paren
id|q.dt.minute
)paren
suffix:semicolon
id|sub.cdsc_absaddr.msf.second
op_assign
id|bcd2uint
c_func
(paren
id|q.dt.second
)paren
suffix:semicolon
id|sub.cdsc_absaddr.msf.frame
op_assign
id|bcd2uint
c_func
(paren
id|q.dt.frame
)paren
suffix:semicolon
id|sub.cdsc_reladdr.msf.minute
op_assign
id|bcd2uint
c_func
(paren
id|q.tt.minute
)paren
suffix:semicolon
id|sub.cdsc_reladdr.msf.second
op_assign
id|bcd2uint
c_func
(paren
id|q.tt.second
)paren
suffix:semicolon
id|sub.cdsc_reladdr.msf.frame
op_assign
id|bcd2uint
c_func
(paren
id|q.tt.frame
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|sub
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|sub
comma
r_sizeof
(paren
id|sub
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMREADTOCHDR
suffix:colon
id|MCDX_TRACE_IOCTL
c_func
(paren
(paren
l_string|&quot;CDROMREADTOCHDR&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
id|toc
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
multiline_comment|/*&n;&t;&t; * Make sure, we really read it!&n;&t;&t; */
id|release_toc
c_func
(paren
id|stuffp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|request_toc_data
c_func
(paren
id|stuffp
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|toc.cdth_trk0
op_assign
id|stuffp-&gt;first
suffix:semicolon
id|toc.cdth_trk1
op_assign
id|stuffp-&gt;last
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|toc
comma
r_sizeof
id|toc
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMMULTISESSION
suffix:colon
id|MCDX_TRACE_IOCTL
c_func
(paren
(paren
l_string|&quot;CDROMMULTISESSION&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|ms
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ms.addr_format
op_eq
id|CDROM_MSF
)paren
(brace
id|ms.addr.msf.minute
op_assign
id|bcd2uint
c_func
(paren
id|stuffp-&gt;multi.msf_last.minute
)paren
suffix:semicolon
id|ms.addr.msf.second
op_assign
id|bcd2uint
c_func
(paren
id|stuffp-&gt;multi.msf_last.second
)paren
suffix:semicolon
id|ms.addr.msf.frame
op_assign
id|bcd2uint
c_func
(paren
id|stuffp-&gt;multi.msf_last.frame
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|ms.addr_format
op_eq
id|CDROM_LBA
)paren
id|ms.addr.lba
op_assign
id|msf2log
c_func
(paren
op_amp
id|stuffp-&gt;multi.msf_last
)paren
suffix:semicolon
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
id|ms.xa_flag
op_assign
op_logical_neg
op_logical_neg
id|stuffp-&gt;multi.multi
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_WRITE
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_tofs
c_func
(paren
(paren
r_void
op_star
)paren
id|arg
comma
op_amp
id|ms
comma
r_sizeof
(paren
r_struct
id|cdrom_multisession
)paren
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMEJECT
suffix:colon
id|MCDX_TRACE_IOCTL
c_func
(paren
(paren
l_string|&quot;CDROMEJECT&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;door
)paren
(brace
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|issue_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_EJECT
comma
l_int|5
op_star
id|HZ
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t; * Force rereading of toc next time the disk gets accessed!&n;&t;&t; */
id|release_toc
c_func
(paren
id|stuffp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMEJECT_SW
suffix:colon
id|MCDX_TRACE_IOCTL
c_func
(paren
(paren
l_string|&quot;CDROMEJECT_SW&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|stuffp-&gt;eject_sw
op_assign
op_logical_neg
op_logical_neg
id|arg
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMVOLCTRL
suffix:colon
id|MCDX_TRACE_IOCTL
c_func
(paren
(paren
l_string|&quot;CDROMVOLCTRL&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ans
op_assign
id|verify_area
c_func
(paren
id|VERIFY_READ
comma
(paren
r_void
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|memcpy_fromfs
c_func
(paren
op_amp
id|volctrl
comma
(paren
r_char
op_star
)paren
id|arg
comma
r_sizeof
(paren
id|volctrl
)paren
)paren
suffix:semicolon
multiline_comment|/* Adjust for the weirdness of workman. */
id|volctrl.channel2
op_assign
id|volctrl.channel1
suffix:semicolon
id|volctrl.channel1
op_assign
id|volctrl.channel3
op_assign
l_int|0x00
suffix:semicolon
r_return
id|talk
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_SET_ATTENATOR
comma
op_amp
id|volctrl
comma
r_sizeof
(paren
id|volctrl
)paren
comma
op_amp
id|volctrl
comma
r_sizeof
(paren
id|volctrl
)paren
comma
l_int|2
op_star
id|HZ
)paren
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
id|KERN_WARNING
id|MCDX
l_string|&quot;: unknown ioctl request 0x%04x&bslash;n&quot;
comma
id|command
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*   &n; * This does actually the transfer from the drive.&n; * Return:      -1 on timeout or other error&n; */
DECL|function|transfer_data
r_static
r_int
id|transfer_data
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_char
op_star
id|p
comma
r_int
id|sector
comma
r_int
id|nr_sectors
)paren
(brace
r_int
id|off
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;valid
op_logical_or
id|sector
template_param
id|stuffp-&gt;border
)paren
(brace
r_int
r_char
id|cmd
(braket
l_int|6
)braket
suffix:semicolon
id|stuffp-&gt;valid
op_assign
l_int|1
suffix:semicolon
id|stuffp-&gt;pending
op_assign
id|sector
op_amp
op_complement
l_int|3
suffix:semicolon
multiline_comment|/* do some sanity checks */
r_if
c_cond
(paren
id|stuffp-&gt;pending
OG
id|stuffp-&gt;lastsector
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|MCDX
l_string|&quot;: sector %d transfer from nirvana requested.&bslash;n&quot;
comma
id|stuffp-&gt;pending
)paren
suffix:semicolon
id|stuffp-&gt;eom
op_assign
l_int|1
suffix:semicolon
id|stuffp-&gt;valid
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stuffp-&gt;border
op_assign
id|stuffp-&gt;pending
op_plus
id|REQUEST_SIZE
)paren
OG
id|stuffp-&gt;lastsector
)paren
id|stuffp-&gt;border
op_assign
id|stuffp-&gt;lastsector
suffix:semicolon
(brace
r_int
r_int
id|l
op_assign
(paren
id|stuffp-&gt;pending
op_div
l_int|4
)paren
op_plus
id|CD_BLOCK_OFFSET
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|uint2bcd
c_func
(paren
id|l
op_div
l_int|4500
)paren
comma
id|l
op_mod_assign
l_int|4500
suffix:semicolon
multiline_comment|/* minute */
id|cmd
(braket
l_int|1
)braket
op_assign
id|uint2bcd
c_func
(paren
id|l
op_div
l_int|75
)paren
suffix:semicolon
multiline_comment|/* second */
id|cmd
(braket
l_int|2
)braket
op_assign
id|uint2bcd
c_func
(paren
id|l
op_mod
l_int|75
)paren
suffix:semicolon
multiline_comment|/* frame */
)brace
id|stuffp-&gt;busy
op_assign
l_int|1
suffix:semicolon
multiline_comment|/*&n;&t;&t; * FIXME: What about the ominous frame length?!&n;&t;&t; */
id|cmd
(braket
l_int|5
)braket
op_assign
id|cmd
(braket
l_int|4
)braket
op_assign
id|cmd
(braket
l_int|3
)braket
op_assign
op_complement
l_int|0
suffix:semicolon
id|outb
c_func
(paren
id|stuffp-&gt;double_speed
ques
c_cond
id|MCDX_CMD_PLAY_2X
suffix:colon
id|MCDX_CMD_PLAY
comma
id|DATA_REG
)paren
suffix:semicolon
id|outsb
c_func
(paren
id|DATA_REG
comma
id|cmd
comma
l_int|6
)paren
suffix:semicolon
)brace
id|off
op_assign
id|sector
op_plus
id|nr_sectors
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;border
OL
id|off
)paren
id|off
op_assign
id|stuffp-&gt;border
suffix:semicolon
r_do
(brace
multiline_comment|/* wait for the drive become idle, but first&n;&t;&t; * check for possible occurred errors --- the drive&n;&t;&t; * seems to report them asynchronously&n;&t;&t; */
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
r_while
c_loop
(paren
id|stuffp-&gt;introk
op_logical_and
id|stuffp-&gt;busy
op_logical_and
id|current-&gt;timeout
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|stuffp-&gt;busyq
)paren
suffix:semicolon
)brace
multiline_comment|/* test for possible errors */
r_if
c_cond
(paren
id|current-&gt;timeout
op_eq
l_int|0
op_logical_or
op_logical_neg
id|stuffp-&gt;introk
)paren
(brace
r_if
c_cond
(paren
id|current-&gt;timeout
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_ERR
id|MCDX
l_string|&quot;: transfer timeout.&bslash;n&quot;
)paren
suffix:semicolon
)brace
multiline_comment|/*&n;&t;&t;&t; * We don&squot;t report about !stuffp-&gt;introk, sice this is&n;&t;&t;&t; * allready done in the interrupt routine.&n;&t;&t;&t; */
id|stuffp-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|stuffp-&gt;valid
op_assign
l_int|0
suffix:semicolon
id|stuffp-&gt;introk
op_assign
l_int|1
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* test if it&squot;s the first sector of a block,&n;&t;&t; * there we have to skip some bytes as we read raw data &n;&t;&t; */
r_if
c_cond
(paren
id|stuffp-&gt;xa
op_logical_and
(paren
l_int|0
op_eq
(paren
id|stuffp-&gt;pending
op_amp
l_int|3
)paren
)paren
)paren
(brace
id|insb
c_func
(paren
id|DATA_REG
comma
id|p
comma
id|CD_FRAMESIZE_RAW
op_minus
id|CD_XA_TAIL
op_minus
id|CD_FRAMESIZE
)paren
suffix:semicolon
)brace
multiline_comment|/* now actually read the data */
id|insb
c_func
(paren
id|DATA_REG
comma
id|p
comma
l_int|512
)paren
suffix:semicolon
multiline_comment|/* test if it&squot;s the last sector of a block,&n;&t;&t; * if so, we have to expect an interrupt and to skip &n;&t;&t; * some data too &n;&t;&t; */
r_if
c_cond
(paren
(paren
id|stuffp-&gt;busy
op_assign
(paren
l_int|3
op_eq
(paren
id|stuffp-&gt;pending
op_amp
l_int|3
)paren
)paren
)paren
op_logical_and
id|stuffp-&gt;xa
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|CD_XA_TAIL
suffix:semicolon
op_increment
id|i
)paren
id|inb
c_func
(paren
id|DATA_REG
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stuffp-&gt;pending
op_eq
id|sector
)paren
(brace
id|p
op_add_assign
l_int|512
suffix:semicolon
id|done
op_increment
suffix:semicolon
id|sector
op_increment
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_increment
(paren
id|stuffp-&gt;pending
)paren
OL
id|off
)paren
suffix:semicolon
r_return
id|done
suffix:semicolon
)brace
DECL|function|do_mcdx_request
r_void
id|do_mcdx_request
c_func
(paren
)paren
(brace
r_int
id|dev
suffix:semicolon
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
id|again
suffix:colon
r_if
c_cond
(paren
(paren
id|CURRENT
op_eq
l_int|NULL
)paren
op_logical_or
(paren
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
)paren
(brace
r_return
suffix:semicolon
)brace
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
)braket
suffix:semicolon
id|INIT_REQUEST
suffix:semicolon
id|dev
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
suffix:semicolon
r_if
c_cond
(paren
id|dev
OL
l_int|0
op_logical_or
id|dev
op_ge
id|MCDX_NDRIVES
op_logical_or
op_logical_neg
id|stuffp
op_logical_or
id|stuffp-&gt;audio
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|CURRENT-&gt;cmd
)paren
(brace
r_case
id|WRITE
suffix:colon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
r_case
id|READ
suffix:colon
id|stuffp-&gt;eom
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* clear end of media flag */
r_while
c_loop
(paren
id|CURRENT-&gt;nr_sectors
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|transfer_data
c_func
(paren
id|stuffp
comma
id|CURRENT-&gt;buffer
comma
id|CURRENT-&gt;sector
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|stuffp-&gt;eom
)paren
(brace
id|CURRENT-&gt;sector
op_add_assign
id|CURRENT-&gt;nr_sectors
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_assign
l_int|0
suffix:semicolon
)brace
r_else
r_break
suffix:semicolon
multiline_comment|/* FIXME: drop down speed ??? */
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
id|CURRENT-&gt;sector
op_add_assign
id|i
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|i
suffix:semicolon
id|CURRENT-&gt;buffer
op_add_assign
(paren
id|i
op_star
l_int|512
)paren
suffix:semicolon
)brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
id|MCDX
l_string|&quot;do_request: unknown command.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_goto
id|again
suffix:semicolon
)brace
multiline_comment|/*  &n; * actions done on open:&n; * 1)   get the drives status &n; * 2)   handle disk changes&n; */
DECL|function|mcdx_open
r_static
r_int
id|mcdx_open
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|ip-&gt;i_rdev
)paren
)braket
suffix:semicolon
r_int
id|st
op_assign
l_int|0
suffix:semicolon
r_int
r_int
id|bang
suffix:semicolon
id|MCDX_TRACE
c_func
(paren
(paren
l_string|&quot;mcdx_open()&bslash;n&quot;
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* We don&squot;t allow multiple users of a drive. In case of data CD&squot;s they&n;&t; * will be only used by mounting, which ensures anyway exclusive usage.&n;&t; * In case of sound CD&squot;s it&squot;s anyway meaningless to try playing two&n;&t; * different tracks at once! This saves us A LOT of trouble.&n;&t; */
r_if
c_cond
(paren
id|stuffp-&gt;used
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
multiline_comment|/* close the door, if necessary (get the door information&n;&t; * from the hardware status register). &n;&t; * If we can&squot;t read the CD after an autoclose&n;&t; * no further auto-closes will be tried &n;&t; */
r_if
c_cond
(paren
id|inb
c_func
(paren
id|STAT_REG
)paren
op_amp
id|MCDX_RBIT_DOOR
)paren
(brace
r_if
c_cond
(paren
id|stuffp-&gt;autoclose
op_logical_and
(paren
id|stuffp-&gt;door
)paren
)paren
id|issue_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_CLOSE_DOOR
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
r_else
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n;&t; * Check if a disk is in.&n;&t; */
id|bang
op_assign
id|jiffies
op_plus
l_int|5
op_star
id|HZ
suffix:semicolon
r_while
c_loop
(paren
id|jiffies
OL
id|bang
)paren
(brace
id|st
op_assign
id|issue_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_GET_STATUS
comma
l_int|1
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_ne
op_minus
l_int|1
op_logical_and
(paren
id|st
op_amp
id|MCDX_RBIT_DISKSET
)paren
)paren
r_break
suffix:semicolon
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
l_int|1
op_star
id|HZ
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|st
op_eq
op_minus
l_int|1
op_logical_or
(paren
id|st
op_amp
id|MCDX_RBIT_DISKSET
)paren
op_eq
l_int|0
)paren
(brace
id|printk
c_func
(paren
id|KERN_INFO
id|MCDX
l_string|&quot;: no disk in drive&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/* if the media changed we will have to do a little more &n;&t; * FIXME: after removing of the mcdx_requestmultisession() it is showed&n;&t; * that the logics of this may be broken.&n;&t; */
r_if
c_cond
(paren
id|stuffp-&gt;xxx
)paren
(brace
multiline_comment|/* but wait - the time of media change will be set at the &n;&t;&t; * very last of this block.&n;&t;&t; */
id|stuffp-&gt;audiostatus
op_assign
id|CDROM_AUDIO_INVALID
suffix:semicolon
id|stuffp-&gt;autoclose
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* get the multisession information */
r_if
c_cond
(paren
id|stuffp-&gt;multi_cap
)paren
(brace
r_int
id|i
op_assign
l_int|6
suffix:semicolon
multiline_comment|/* number of retries */
r_while
c_loop
(paren
id|i
op_decrement
)paren
r_if
c_cond
(paren
op_minus
l_int|1
op_ne
id|get_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_GET_MDISK_INFO
comma
op_amp
id|stuffp-&gt;multi
comma
r_sizeof
(paren
r_struct
id|s_multi
)paren
comma
l_int|2
op_star
id|HZ
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
id|stuffp-&gt;autoclose
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* don&squot;t try it again on next open */
r_if
c_cond
(paren
id|stuffp-&gt;door
)paren
id|issue_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_EJECT
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
r_else
id|stuffp-&gt;multi.multi
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;multi.multi
)paren
id|stuffp-&gt;multi.msf_last.second
op_assign
l_int|2
suffix:semicolon
id|release_toc
c_func
(paren
id|stuffp
)paren
suffix:semicolon
multiline_comment|/* force rereading */
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|request_toc_data
c_func
(paren
id|stuffp
)paren
)paren
id|stuffp-&gt;lastsector
op_assign
op_minus
l_int|1
suffix:semicolon
r_else
(brace
id|stuffp-&gt;lastsector
op_assign
(paren
id|CD_FRAMESIZE
op_div
l_int|512
)paren
op_star
id|msf2log
c_func
(paren
op_amp
id|stuffp-&gt;msf_leadout
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|config_drive
c_func
(paren
id|stuffp
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* try to get the first sector, iff any ... */
r_if
c_cond
(paren
id|stuffp-&gt;lastsector
op_ge
l_int|0
)paren
(brace
r_int
id|tries
suffix:semicolon
id|stuffp-&gt;xa
op_assign
l_int|0
suffix:semicolon
id|stuffp-&gt;audio
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|tries
op_assign
l_int|6
suffix:semicolon
id|tries
suffix:semicolon
id|tries
op_decrement
)paren
(brace
r_char
id|buf
(braket
l_int|512
)braket
suffix:semicolon
r_int
id|st
suffix:semicolon
r_int
r_char
id|c
suffix:semicolon
id|stuffp-&gt;introk
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* set data mode */
id|c
op_assign
id|stuffp-&gt;xa
ques
c_cond
id|MODE2
suffix:colon
id|MODE1
suffix:semicolon
id|st
op_assign
id|set_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_SET_DATA_MODE
comma
op_amp
id|c
comma
r_sizeof
(paren
id|c
)paren
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|st
)paren
(brace
id|stuffp-&gt;xa
op_assign
l_int|0
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|st
op_amp
id|MCDX_RBIT_AUDIOTR
)paren
(brace
id|stuffp-&gt;audio
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_while
c_loop
(paren
l_int|0
op_eq
(paren
id|st
op_assign
id|transfer_data
c_func
(paren
id|stuffp
comma
id|buf
comma
l_int|0
comma
l_int|1
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_eq
l_int|1
)paren
r_break
suffix:semicolon
id|stuffp-&gt;xa
op_assign
op_logical_neg
id|stuffp-&gt;xa
suffix:semicolon
)brace
multiline_comment|/* if (!tries) return -EIO; */
)brace
multiline_comment|/* xa disks will be read in raw mode, others not */
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|set_drive_mode
c_func
(paren
id|stuffp
comma
id|stuffp-&gt;xa
ques
c_cond
id|RAW
suffix:colon
id|COOKED
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|stuffp-&gt;xxx
op_assign
l_int|0
suffix:semicolon
)brace
multiline_comment|/* lock the door if not already done */
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;used
op_logical_and
(paren
op_minus
l_int|1
op_eq
id|lock_door
c_func
(paren
id|stuffp
comma
id|DOOR_LOCK
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|stuffp-&gt;used
op_assign
l_int|1
suffix:semicolon
id|MOD_INC_USE_COUNT
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mcdx_close
r_static
r_void
id|mcdx_close
c_func
(paren
r_struct
id|inode
op_star
id|ip
comma
r_struct
id|file
op_star
id|fp
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|ip-&gt;i_rdev
)paren
)braket
suffix:semicolon
id|MCDX_TRACE
c_func
(paren
(paren
l_string|&quot;mcdx_close()&bslash;n&quot;
)paren
)paren
suffix:semicolon
id|sync_dev
c_func
(paren
id|ip-&gt;i_rdev
)paren
suffix:semicolon
multiline_comment|/* needed for r/o device? */
multiline_comment|/* invalidate_inodes(ip-&gt;i_rdev); */
id|invalidate_buffers
c_func
(paren
id|ip-&gt;i_rdev
)paren
suffix:semicolon
id|lock_door
c_func
(paren
id|stuffp
comma
id|DOOR_UNLOCK
)paren
suffix:semicolon
multiline_comment|/* eject if wished and possible */
r_if
c_cond
(paren
id|stuffp-&gt;eject_sw
op_logical_and
(paren
id|stuffp-&gt;door
)paren
)paren
(brace
id|issue_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_EJECT
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
)brace
id|stuffp-&gt;used
op_assign
l_int|0
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
multiline_comment|/*      &n; * Return: 1 if media changed since last call to this function, 0 otherwise.&n; */
DECL|function|mcdx_media_change
r_static
r_int
id|mcdx_media_change
c_func
(paren
id|kdev_t
id|full_dev
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
id|MCDX_TRACE
c_func
(paren
(paren
l_string|&quot;mcdx_media_change()&bslash;n&quot;
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;&t; * FIXME: probably this is unneeded or should be simplified!&n;&t; */
id|issue_command
c_func
(paren
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|full_dev
)paren
)braket
comma
id|MCDX_CMD_GET_STATUS
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
r_return
id|stuffp-&gt;xxx
suffix:semicolon
)brace
multiline_comment|/* Interrupt handler routine.&n; * This function is called, when during transfer the end of a physical 2048&n; * byte block is reached.&n; */
DECL|function|mcdx_intr
r_static
r_void
id|mcdx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
id|u_char
id|b
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|stuffp
op_assign
id|mcdx_irq_map
(braket
id|irq
)braket
)paren
)paren
(brace
r_return
suffix:semicolon
multiline_comment|/* huh? */
)brace
multiline_comment|/* NOTE: We only should get interrupts if data were requested.&n;&t; * But the drive seems to generate ``asynchronous&squot;&squot; interrupts&n;&t; * on several error conditions too.  (Despite the err int enable&n;&t; * setting during initialization) &n;&t; */
id|b
op_assign
id|inb
c_func
(paren
id|STAT_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|b
op_amp
id|MCDX_RBIT_DTEN
)paren
)paren
id|stuffp-&gt;introk
op_assign
l_int|1
suffix:semicolon
r_else
(brace
id|stuffp-&gt;introk
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|b
op_amp
id|MCDX_RBIT_STEN
)paren
)paren
(brace
id|b
op_assign
id|inb
c_func
(paren
id|DATA_REG
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;used
)paren
id|printk
c_func
(paren
id|KERN_DEBUG
id|MCDX
l_string|&quot;: irq %d status 0x%02x&bslash;n&quot;
comma
id|irq
comma
id|b
)paren
suffix:semicolon
)brace
r_else
id|MCDX_TRACE
c_func
(paren
(paren
l_string|&quot;irq %d ambiguous hw status&bslash;n&quot;
comma
id|irq
)paren
)paren
suffix:semicolon
)brace
id|stuffp-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|stuffp-&gt;busyq
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * FIXME:&n; * This seems to hang badly, when the driver is loaded with inappropriate&n; * port/irq settings!&n; */
DECL|function|mcdx_init
r_int
id|mcdx_init
c_func
(paren
r_void
)paren
(brace
r_int
id|drive
suffix:semicolon
macro_line|#ifdef MODULE
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Mitsumi driver V&quot;
id|VERSION
l_string|&quot; for %s&bslash;n&quot;
comma
id|kernel_version
)paren
suffix:semicolon
macro_line|#else
id|printk
c_func
(paren
id|KERN_INFO
l_string|&quot;Mitsumi driver V&quot;
id|VERSION
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|MCDX_NDRIVES
suffix:semicolon
id|drive
op_increment
)paren
(brace
r_struct
(brace
id|u_char
id|code
suffix:semicolon
id|u_char
id|version
suffix:semicolon
)brace
id|firmware
suffix:semicolon
r_int
id|i
suffix:semicolon
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
r_int
id|size
suffix:semicolon
id|mcdx_blksize_size
(braket
id|drive
)braket
op_assign
l_int|0
suffix:semicolon
id|mcdx_stuffp
(braket
id|drive
)braket
op_assign
l_int|0
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
op_star
id|stuffp
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|stuffp
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
)paren
)paren
r_break
suffix:semicolon
multiline_comment|/* set default values */
id|memset
c_func
(paren
id|stuffp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|stuffp
)paren
)paren
suffix:semicolon
id|stuffp-&gt;autoclose
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* close the door on open(2) */
id|stuffp-&gt;base
op_assign
id|mcdx_drive_map
(braket
id|drive
)braket
(braket
id|PORT
)braket
suffix:semicolon
id|stuffp-&gt;irq
op_assign
id|mcdx_drive_map
(braket
id|drive
)braket
(braket
id|IRQ
)braket
suffix:semicolon
multiline_comment|/* check if i/o addresses are available */
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|stuffp-&gt;base
comma
id|MCDX_IO_SIZE
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Init failed. I/O ports (0x%3x..0x%3x) &quot;
l_string|&quot;already in use.&bslash;n&quot;
comma
id|stuffp-&gt;base
comma
id|stuffp-&gt;base
op_plus
id|MCDX_IO_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* next drive */
)brace
multiline_comment|/*&n;&t;&t; * Hardware reset.&n;&t;&t; */
id|outb
c_func
(paren
l_int|0
comma
id|CHAN_REG
)paren
suffix:semicolon
multiline_comment|/* no dma, no irq -&gt; hardware */
id|outb
c_func
(paren
l_int|0
comma
id|RESET_REG
)paren
suffix:semicolon
multiline_comment|/* hw reset */
id|i
op_assign
l_int|10
suffix:semicolon
multiline_comment|/* number of retries */
r_while
c_loop
(paren
op_minus
l_int|1
op_eq
id|get_command
c_func
(paren
id|stuffp
comma
id|MCDX_CMD_GET_FIRMWARE
comma
op_amp
id|firmware
comma
r_sizeof
(paren
id|firmware
)paren
comma
l_int|2
op_star
id|HZ
)paren
)paren
op_decrement
id|i
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|i
)paren
(brace
multiline_comment|/* failed, next drive */
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;%s=0x%3x,%d: Init failed. Can&squot;t get version.&bslash;n&quot;
comma
id|MCDX
comma
id|stuffp-&gt;base
comma
id|stuffp-&gt;irq
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|firmware.code
)paren
(brace
r_case
l_char|&squot;D&squot;
suffix:colon
id|stuffp-&gt;double_speed
op_assign
id|stuffp-&gt;door
op_assign
id|stuffp-&gt;multi_cap
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;F&squot;
suffix:colon
id|stuffp-&gt;door
op_assign
id|stuffp-&gt;multi_cap
op_assign
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;M&squot;
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|stuffp
)paren
r_continue
suffix:semicolon
multiline_comment|/* next drive */
r_if
c_cond
(paren
id|register_blkdev
c_func
(paren
id|MAJOR_NR
comma
id|DEVICE_NAME
comma
op_amp
id|mcdx_fops
)paren
)paren
(brace
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* next drive */
)brace
multiline_comment|/*&n;&t;&t; * CD-ROM&squot;s are an example of non 1024 devices&n;&t;&t; */
id|mcdx_blksize_size
(braket
id|drive
)braket
op_assign
l_int|1024
suffix:semicolon
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
id|READ_AHEAD
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|mcdx_blksize_size
suffix:semicolon
id|mcdx_irq_map
(braket
id|stuffp-&gt;irq
)braket
op_assign
id|stuffp
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|stuffp-&gt;irq
comma
id|mcdx_intr
comma
id|SA_INTERRUPT
comma
id|DEVICE_NAME
comma
l_int|NULL
)paren
)paren
(brace
id|stuffp-&gt;irq
op_assign
l_int|0
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
r_continue
suffix:semicolon
multiline_comment|/* next drive */
)brace
id|request_region
c_func
(paren
id|stuffp-&gt;base
comma
id|MCDX_IO_SIZE
comma
id|DEVICE_NAME
)paren
suffix:semicolon
multiline_comment|/* get junk after some delay.&n;&t;&t; */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|current-&gt;timeout
op_assign
id|jiffies
op_plus
id|HZ
op_div
l_int|2
suffix:semicolon
id|schedule
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|100
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(paren
r_void
)paren
id|inb
c_func
(paren
id|STAT_REG
)paren
suffix:semicolon
macro_line|#if WE_KNOW_WHY
id|outb
c_func
(paren
l_int|0x50
comma
id|CHAN_REG
)paren
suffix:semicolon
multiline_comment|/* irq 11 -&gt; channel register */
macro_line|#endif
id|config_drive
c_func
(paren
id|stuffp
)paren
suffix:semicolon
id|printk
c_func
(paren
id|KERN_INFO
id|MCDX
l_string|&quot;%d: at 0x%3x, irq %d, type: %c, firmware: %x&bslash;n&quot;
comma
id|drive
comma
id|stuffp-&gt;base
comma
id|stuffp-&gt;irq
comma
id|firmware.code
comma
id|firmware.version
)paren
suffix:semicolon
id|mcdx_stuffp
(braket
id|drive
)braket
op_assign
id|stuffp
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|function|init_module
r_int
id|init_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|mcdx_init
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MCDX_NDRIVES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mcdx_stuffp
(braket
id|i
)braket
)paren
(brace
id|register_symtab
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_return
op_minus
id|EIO
suffix:semicolon
)brace
DECL|function|cleanup_module
r_void
id|cleanup_module
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
id|DEVICE_NAME
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MCDX_NDRIVES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp
)paren
r_continue
suffix:semicolon
id|release_region
c_func
(paren
id|stuffp-&gt;base
comma
id|MCDX_IO_SIZE
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|stuffp-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
id|release_toc
c_func
(paren
id|stuffp
)paren
suffix:semicolon
id|mcdx_stuffp
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
)brace
id|blk_dev
(braket
id|MAJOR_NR
)braket
dot
id|request_fn
op_assign
id|DEVICE_REQUEST
suffix:semicolon
)brace
macro_line|#else&t;&t;&t;&t;/* MODULE */
multiline_comment|/*&n; * This function is used by the kernel in init/main.c to provide semantics&n; * for the corresponding kernel options. It&squot;s unused otherwise.&n; */
DECL|function|mcdx_setup
r_void
id|mcdx_setup
c_func
(paren
r_char
op_star
id|str
comma
r_int
op_star
id|pi
)paren
(brace
r_if
c_cond
(paren
id|pi
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|mcdx_drive_map
(braket
l_int|0
)braket
(braket
l_int|0
)braket
op_assign
id|pi
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pi
(braket
l_int|0
)braket
OG
l_int|1
)paren
id|mcdx_drive_map
(braket
l_int|0
)braket
(braket
l_int|1
)braket
op_assign
id|pi
(braket
l_int|2
)braket
suffix:semicolon
)brace
macro_line|#endif&t;&t;&t;&t;/* MODULE */
eof
