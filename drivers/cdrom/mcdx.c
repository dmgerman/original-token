multiline_comment|/*&n; * The Mitsumi CDROM interface&n; * Copyright (C) 1995 1996 Heiko Schlittermann &lt;heiko@lotte.sax.de&gt;&n; * VERSION: 2.14(hs)&n; *&n; * ... anyway, I&squot;m back again, thanks to Marcin, he adopted&n; * large portions of my code (at least the parts containing&n; * my main thoughts ...)&n; *&n; ****************** H E L P *********************************&n; * If you ever plan to update your CD ROM drive and perhaps&n; * want to sell or simply give away your Mitsumi FX-001[DS]&n; * -- Please --&n; * mail me (heiko@lotte.sax.de).  When my last drive goes&n; * ballistic no more driver support will be available from me!&n; *************************************************************&n; *&n; * This program is free software; you can redistribute it and/or modify&n; * it under the terms of the GNU General Public License as published by&n; * the Free Software Foundation; either version 2, or (at your option)&n; * any later version.&n; *&n; * This program is distributed in the hope that it will be useful,&n; * but WITHOUT ANY WARRANTY; without even the implied warranty of&n; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n; * GNU General Public License for more details.&n; *&n; * You should have received a copy of the GNU General Public License&n; * along with this program; see the file COPYING.  If not, write to&n; * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.&n; *&n; * Thanks to&n; *  The Linux Community at all and ...&n; *  Martin Harriss (he wrote the first Mitsumi Driver)&n; *  Eberhard Moenkeberg (he gave me much support and the initial kick)&n; *  Bernd Huebner, Ruediger Helsch (Unifix-Software GmbH, they&n; *      improved the original driver)&n; *  Jon Tombs, Bjorn Ekwall (module support)&n; *  Daniel v. Mosnenck (he sent me the Technical and Programming Reference)&n; *  Gerd Knorr (he lent me his PhotoCD)&n; *  Nils Faerber and Roger E. Wolff (extensively tested the LU portion)&n; *  Andreas Kies (testing the mysterious hang-ups)&n; *  Heiko Eissfeldt (VERIFY_READ/WRITE)&n; *  Marcin Dalecki (improved performance, shortened code)&n; *  ... somebody forgotten?&n; *&n; *  9 November 1999 -- Make kernel-parameter implementation work with 2.3.x &n; *&t;               Removed init_module &amp; cleanup_module in favor of &n; *&t;&t;       module_init &amp; module_exit.&n; *&t;&t;       Torben Mathiasen &lt;tmm@image.dk&gt;&n; */
macro_line|#if RCS
DECL|variable|mcdx_c_version
r_static
r_const
r_char
op_star
id|mcdx_c_version
op_assign
l_string|&quot;$Id: mcdx.c,v 1.21 1997/01/26 07:12:59 davem Exp $&quot;
suffix:semicolon
macro_line|#endif
macro_line|#include &lt;linux/version.h&gt;
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/malloc.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
macro_line|#include &lt;linux/major.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR MITSUMI_X_CDROM_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
multiline_comment|/* for compatible parameter passing with &quot;insmod&quot; */
DECL|macro|mcdx_drive_map
mdefine_line|#define&t;mcdx_drive_map mcdx
macro_line|#include &quot;mcdx.h&quot;
macro_line|#ifndef HZ
macro_line|#error HZ not defined
macro_line|#endif
DECL|macro|xwarn
mdefine_line|#define xwarn(fmt, args...) printk(KERN_WARNING MCDX &quot; &quot; fmt, ## args)
macro_line|#if !MCDX_QUIET
DECL|macro|xinfo
mdefine_line|#define xinfo(fmt, args...) printk(KERN_INFO MCDX &quot; &quot; fmt, ## args)
macro_line|#else
DECL|macro|xinfo
mdefine_line|#define xinfo(fmt, args...) { ; }
macro_line|#endif
macro_line|#if MCDX_DEBUG
DECL|macro|xtrace
mdefine_line|#define xtrace(lvl, fmt, args...) &bslash;&n;&t;&t;{ if (lvl &gt; 0) &bslash;&n;&t;&t;&t;{ printk(KERN_DEBUG MCDX &quot;:: &quot; fmt, ## args); } }
DECL|macro|xdebug
mdefine_line|#define xdebug(fmt, args...) printk(KERN_DEBUG MCDX &quot;:: &quot; fmt, ## args)
macro_line|#else
DECL|macro|xtrace
mdefine_line|#define xtrace(lvl, fmt, args...) { ; }
DECL|macro|xdebug
mdefine_line|#define xdebug(fmt, args...) { ; }
macro_line|#endif
multiline_comment|/* CONSTANTS *******************************************************/
multiline_comment|/* Following are the number of sectors we _request_ from the drive&n;   every time an access outside the already requested range is done.&n;   The _direct_ size is the number of sectors we&squot;re allowed to skip&n;   directly (performing a read instead of requesting the new sector&n;   needed */
DECL|variable|REQUEST_SIZE
r_const
r_int
id|REQUEST_SIZE
op_assign
l_int|800
suffix:semicolon
multiline_comment|/* should be less then 255 * 4 */
DECL|variable|DIRECT_SIZE
r_const
r_int
id|DIRECT_SIZE
op_assign
l_int|400
suffix:semicolon
multiline_comment|/* should be less then REQUEST_SIZE */
DECL|enum|drivemodes
DECL|enumerator|TOC
DECL|enumerator|DATA
DECL|enumerator|RAW
DECL|enumerator|COOKED
r_enum
id|drivemodes
(brace
id|TOC
comma
id|DATA
comma
id|RAW
comma
id|COOKED
)brace
suffix:semicolon
DECL|enum|datamodes
DECL|enumerator|MODE0
DECL|enumerator|MODE1
DECL|enumerator|MODE2
r_enum
id|datamodes
(brace
id|MODE0
comma
id|MODE1
comma
id|MODE2
)brace
suffix:semicolon
DECL|enum|resetmodes
DECL|enumerator|SOFT
DECL|enumerator|HARD
r_enum
id|resetmodes
(brace
id|SOFT
comma
id|HARD
)brace
suffix:semicolon
DECL|variable|SINGLE
r_const
r_int
id|SINGLE
op_assign
l_int|0x01
suffix:semicolon
multiline_comment|/* single speed drive (FX001S, LU) */
DECL|variable|DOUBLE
r_const
r_int
id|DOUBLE
op_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* double speed drive (FX001D, ..? */
DECL|variable|DOOR
r_const
r_int
id|DOOR
op_assign
l_int|0x04
suffix:semicolon
multiline_comment|/* door locking capability */
DECL|variable|MULTI
r_const
r_int
id|MULTI
op_assign
l_int|0x08
suffix:semicolon
multiline_comment|/* multi session capability */
DECL|variable|READ1X
r_const
r_int
r_char
id|READ1X
op_assign
l_int|0xc0
suffix:semicolon
DECL|variable|READ2X
r_const
r_int
r_char
id|READ2X
op_assign
l_int|0xc1
suffix:semicolon
multiline_comment|/* DECLARATIONS ****************************************************/
DECL|struct|s_subqcode
r_struct
id|s_subqcode
(brace
DECL|member|control
r_int
r_char
id|control
suffix:semicolon
DECL|member|tno
r_int
r_char
id|tno
suffix:semicolon
DECL|member|index
r_int
r_char
id|index
suffix:semicolon
DECL|member|tt
r_struct
id|cdrom_msf0
id|tt
suffix:semicolon
DECL|member|dt
r_struct
id|cdrom_msf0
id|dt
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|s_diskinfo
r_struct
id|s_diskinfo
(brace
DECL|member|n_first
r_int
r_int
id|n_first
suffix:semicolon
DECL|member|n_last
r_int
r_int
id|n_last
suffix:semicolon
DECL|member|msf_leadout
r_struct
id|cdrom_msf0
id|msf_leadout
suffix:semicolon
DECL|member|msf_first
r_struct
id|cdrom_msf0
id|msf_first
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|s_multi
r_struct
id|s_multi
(brace
DECL|member|multi
r_int
r_char
id|multi
suffix:semicolon
DECL|member|msf_last
r_struct
id|cdrom_msf0
id|msf_last
suffix:semicolon
)brace
suffix:semicolon
DECL|struct|s_version
r_struct
id|s_version
(brace
DECL|member|code
r_int
r_char
id|code
suffix:semicolon
DECL|member|ver
r_int
r_char
id|ver
suffix:semicolon
)brace
suffix:semicolon
multiline_comment|/* Per drive/controller stuff **************************************/
DECL|struct|s_drive_stuff
r_struct
id|s_drive_stuff
(brace
multiline_comment|/* waitqueues */
DECL|member|busyq
id|wait_queue_head_t
id|busyq
suffix:semicolon
DECL|member|lockq
id|wait_queue_head_t
id|lockq
suffix:semicolon
DECL|member|sleepq
id|wait_queue_head_t
id|sleepq
suffix:semicolon
multiline_comment|/* flags */
DECL|member|introk
r_volatile
r_int
id|introk
suffix:semicolon
multiline_comment|/* status of last irq operation */
DECL|member|busy
r_volatile
r_int
id|busy
suffix:semicolon
multiline_comment|/* drive performs an operation */
DECL|member|lock
r_volatile
r_int
id|lock
suffix:semicolon
multiline_comment|/* exclusive usage */
multiline_comment|/* cd infos */
DECL|member|di
r_struct
id|s_diskinfo
id|di
suffix:semicolon
DECL|member|multi
r_struct
id|s_multi
id|multi
suffix:semicolon
DECL|member|toc
r_struct
id|s_subqcode
op_star
id|toc
suffix:semicolon
multiline_comment|/* first entry of the toc array */
DECL|member|start
r_struct
id|s_subqcode
id|start
suffix:semicolon
DECL|member|stop
r_struct
id|s_subqcode
id|stop
suffix:semicolon
DECL|member|xa
r_int
id|xa
suffix:semicolon
multiline_comment|/* 1 if xa disk */
DECL|member|audio
r_int
id|audio
suffix:semicolon
multiline_comment|/* 1 if audio disk */
DECL|member|audiostatus
r_int
id|audiostatus
suffix:semicolon
multiline_comment|/* `buffer&squot; control */
DECL|member|valid
r_volatile
r_int
id|valid
suffix:semicolon
multiline_comment|/* pending, ..., values are valid */
DECL|member|pending
r_volatile
r_int
id|pending
suffix:semicolon
multiline_comment|/* next sector to be read */
DECL|member|low_border
r_volatile
r_int
id|low_border
suffix:semicolon
multiline_comment|/* first sector not to be skipped direct */
DECL|member|high_border
r_volatile
r_int
id|high_border
suffix:semicolon
multiline_comment|/* first sector `out of area&squot; */
macro_line|#ifdef AK2
DECL|member|int_err
r_volatile
r_int
id|int_err
suffix:semicolon
macro_line|#endif /* AK2 */
multiline_comment|/* adds and odds */
DECL|member|wreg_data
r_void
op_star
id|wreg_data
suffix:semicolon
multiline_comment|/* w data */
DECL|member|wreg_reset
r_void
op_star
id|wreg_reset
suffix:semicolon
multiline_comment|/* w hardware reset */
DECL|member|wreg_hcon
r_void
op_star
id|wreg_hcon
suffix:semicolon
multiline_comment|/* w hardware conf */
DECL|member|wreg_chn
r_void
op_star
id|wreg_chn
suffix:semicolon
multiline_comment|/* w channel */
DECL|member|rreg_data
r_void
op_star
id|rreg_data
suffix:semicolon
multiline_comment|/* r data */
DECL|member|rreg_status
r_void
op_star
id|rreg_status
suffix:semicolon
multiline_comment|/* r status */
DECL|member|irq
r_int
id|irq
suffix:semicolon
multiline_comment|/* irq used by this drive */
DECL|member|minor
r_int
id|minor
suffix:semicolon
multiline_comment|/* minor number of this drive */
DECL|member|present
r_int
id|present
suffix:semicolon
multiline_comment|/* drive present and its capabilities */
DECL|member|readcmd
r_int
r_char
id|readcmd
suffix:semicolon
multiline_comment|/* read cmd depends on single/double speed */
DECL|member|playcmd
r_int
r_char
id|playcmd
suffix:semicolon
multiline_comment|/* play should always be single speed */
DECL|member|xxx
r_int
r_int
id|xxx
suffix:semicolon
multiline_comment|/* set if changed, reset while open */
DECL|member|yyy
r_int
r_int
id|yyy
suffix:semicolon
multiline_comment|/* set if changed, reset by media_changed */
DECL|member|users
r_int
id|users
suffix:semicolon
multiline_comment|/* keeps track of open/close */
DECL|member|lastsector
r_int
id|lastsector
suffix:semicolon
multiline_comment|/* last block accessible */
DECL|member|status
r_int
id|status
suffix:semicolon
multiline_comment|/* last operation&squot;s error / status */
DECL|member|readerrs
r_int
id|readerrs
suffix:semicolon
multiline_comment|/* # of blocks read w/o error */
)brace
suffix:semicolon
multiline_comment|/* Prototypes ******************************************************/
multiline_comment|/*&t;The following prototypes are already declared elsewhere.  They are&n; &t;repeated here to show what&squot;s going on.  And to sense, if they&squot;re&n;&t;changed elsewhere. */
multiline_comment|/* declared in blk.h */
r_int
id|mcdx_init
c_func
(paren
r_void
)paren
suffix:semicolon
r_void
id|do_mcdx_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
suffix:semicolon
multiline_comment|/*&t;Indirect exported functions. These functions are exported by their&n;&t;addresses, such as mcdx_open and mcdx_close in the&n;&t;structure mcdx_dops. */
multiline_comment|/* ???  exported by the mcdx_sigaction struct */
r_static
r_void
id|mcdx_intr
c_func
(paren
r_int
comma
r_void
op_star
comma
r_struct
id|pt_regs
op_star
)paren
suffix:semicolon
multiline_comment|/* exported by file_ops */
r_static
r_int
id|mcdx_open
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|purpose
)paren
suffix:semicolon
r_static
r_void
id|mcdx_close
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
suffix:semicolon
r_static
r_int
id|mcdx_media_changed
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|disc_nr
)paren
suffix:semicolon
r_static
r_int
id|mcdx_tray_move
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|position
)paren
suffix:semicolon
r_static
r_int
id|mcdx_lockdoor
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|lock
)paren
suffix:semicolon
r_static
r_int
id|mcdx_audio_ioctl
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
suffix:semicolon
multiline_comment|/* misc internal support functions */
r_static
r_void
id|log2msf
c_func
(paren
r_int
r_int
comma
r_struct
id|cdrom_msf0
op_star
)paren
suffix:semicolon
r_static
r_int
r_int
id|msf2log
c_func
(paren
r_const
r_struct
id|cdrom_msf0
op_star
)paren
suffix:semicolon
r_static
r_int
r_int
id|uint2bcd
c_func
(paren
r_int
r_int
)paren
suffix:semicolon
r_static
r_int
r_int
id|bcd2uint
c_func
(paren
r_int
r_char
)paren
suffix:semicolon
r_static
r_char
op_star
id|port
c_func
(paren
r_int
op_star
)paren
suffix:semicolon
r_static
r_int
id|irq
c_func
(paren
r_int
op_star
)paren
suffix:semicolon
r_static
r_void
id|mcdx_delay
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_int
id|jifs
)paren
suffix:semicolon
r_static
r_int
id|mcdx_transfer
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_char
op_star
id|buf
comma
r_int
id|sector
comma
r_int
id|nr_sectors
)paren
suffix:semicolon
r_static
r_int
id|mcdx_xfer
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_char
op_star
id|buf
comma
r_int
id|sector
comma
r_int
id|nr_sectors
)paren
suffix:semicolon
r_static
r_int
id|mcdx_config
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_requestversion
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_struct
id|s_version
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_stop
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_hold
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_reset
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_enum
id|resetmodes
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_setdrivemode
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_enum
id|drivemodes
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_setdatamode
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_enum
id|datamodes
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_requestsubqcode
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_struct
id|s_subqcode
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_requestmultidiskinfo
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_struct
id|s_multi
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_requesttocdata
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_struct
id|s_diskinfo
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_getstatus
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_getval
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_int
id|to
comma
r_int
id|delay
comma
r_char
op_star
)paren
suffix:semicolon
r_static
r_int
id|mcdx_talk
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_const
r_int
r_char
op_star
id|cmd
comma
r_int
comma
r_void
op_star
id|buffer
comma
r_int
id|size
comma
r_int
r_int
id|timeout
comma
r_int
)paren
suffix:semicolon
r_static
r_int
id|mcdx_readtoc
c_func
(paren
r_struct
id|s_drive_stuff
op_star
)paren
suffix:semicolon
r_static
r_int
id|mcdx_playtrk
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_const
r_struct
id|cdrom_ti
op_star
)paren
suffix:semicolon
r_static
r_int
id|mcdx_playmsf
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_const
r_struct
id|cdrom_msf
op_star
)paren
suffix:semicolon
r_static
r_int
id|mcdx_setattentuator
c_func
(paren
r_struct
id|s_drive_stuff
op_star
comma
r_struct
id|cdrom_volctrl
op_star
comma
r_int
)paren
suffix:semicolon
multiline_comment|/* static variables ************************************************/
DECL|variable|mcdx_blocksizes
r_static
r_int
id|mcdx_blocksizes
(braket
id|MCDX_NDRIVES
)braket
suffix:semicolon
DECL|variable|mcdx_drive_map
r_static
r_int
id|mcdx_drive_map
(braket
)braket
(braket
l_int|2
)braket
op_assign
id|MCDX_DRIVEMAP
suffix:semicolon
DECL|variable|mcdx_stuffp
r_static
r_struct
id|s_drive_stuff
op_star
id|mcdx_stuffp
(braket
id|MCDX_NDRIVES
)braket
suffix:semicolon
DECL|variable|mcdx_irq_map
r_static
r_struct
id|s_drive_stuff
op_star
id|mcdx_irq_map
(braket
l_int|16
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|MODULE_PARM
c_func
(paren
id|mcdx
comma
l_string|&quot;1-4i&quot;
)paren
suffix:semicolon
DECL|variable|mcdx_dops
r_static
r_struct
id|cdrom_device_ops
id|mcdx_dops
op_assign
(brace
id|open
suffix:colon
id|mcdx_open
comma
id|release
suffix:colon
id|mcdx_close
comma
id|media_changed
suffix:colon
id|mcdx_media_changed
comma
id|tray_move
suffix:colon
id|mcdx_tray_move
comma
id|lock_door
suffix:colon
id|mcdx_lockdoor
comma
id|audio_ioctl
suffix:colon
id|mcdx_audio_ioctl
comma
id|capability
suffix:colon
id|CDC_OPEN_TRAY
op_or
id|CDC_LOCK
op_or
id|CDC_MEDIA_CHANGED
op_or
id|CDC_PLAY_AUDIO
op_or
id|CDC_DRIVE_STATUS
comma
)brace
suffix:semicolon
DECL|variable|mcdx_info
r_static
r_struct
id|cdrom_device_info
id|mcdx_info
op_assign
(brace
id|ops
suffix:colon
op_amp
id|mcdx_dops
comma
id|speed
suffix:colon
l_int|2
comma
id|capacity
suffix:colon
l_int|1
comma
id|name
suffix:colon
l_string|&quot;mcdx&quot;
comma
)brace
suffix:semicolon
multiline_comment|/* KERNEL INTERFACE FUNCTIONS **************************************/
DECL|function|mcdx_audio_ioctl
r_static
r_int
id|mcdx_audio_ioctl
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|cdi-&gt;dev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;present
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;xxx
)paren
(brace
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_requesttocdata
c_func
(paren
id|stuffp
comma
op_amp
id|stuffp-&gt;di
comma
l_int|1
)paren
)paren
(brace
id|stuffp-&gt;lastsector
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|stuffp-&gt;lastsector
op_assign
(paren
id|CD_FRAMESIZE
op_div
l_int|512
)paren
op_star
id|msf2log
c_func
(paren
op_amp
id|stuffp-&gt;di.msf_leadout
)paren
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stuffp-&gt;toc
)paren
(brace
id|kfree
c_func
(paren
id|stuffp-&gt;toc
)paren
suffix:semicolon
id|stuffp-&gt;toc
op_assign
l_int|NULL
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_readtoc
c_func
(paren
id|stuffp
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|stuffp-&gt;xxx
op_assign
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSTART
suffix:colon
(brace
id|xtrace
c_func
(paren
id|IOCTL
comma
l_string|&quot;ioctl() START&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Spin up the drive.  Don&squot;t think we can do this.&n;                 * For now, ignore it.&n;                 */
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMSTOP
suffix:colon
(brace
id|xtrace
c_func
(paren
id|IOCTL
comma
l_string|&quot;ioctl() STOP&bslash;n&quot;
)paren
suffix:semicolon
id|stuffp-&gt;audiostatus
op_assign
id|CDROM_AUDIO_INVALID
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_stop
c_func
(paren
id|stuffp
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMPLAYTRKIND
suffix:colon
(brace
r_struct
id|cdrom_ti
op_star
id|ti
op_assign
(paren
r_struct
id|cdrom_ti
op_star
)paren
id|arg
suffix:semicolon
id|xtrace
c_func
(paren
id|IOCTL
comma
l_string|&quot;ioctl() PLAYTRKIND&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|ti-&gt;cdti_trk0
OL
id|stuffp-&gt;di.n_first
)paren
op_logical_or
(paren
id|ti-&gt;cdti_trk0
OG
id|stuffp-&gt;di.n_last
)paren
op_logical_or
(paren
id|ti-&gt;cdti_trk1
OL
id|stuffp-&gt;di.n_first
)paren
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
id|ti-&gt;cdti_trk1
OG
id|stuffp-&gt;di.n_last
)paren
id|ti-&gt;cdti_trk1
op_assign
id|stuffp-&gt;di.n_last
suffix:semicolon
id|xtrace
c_func
(paren
id|PLAYTRK
comma
l_string|&quot;ioctl() track %d to %d&bslash;n&quot;
comma
id|ti-&gt;cdti_trk0
comma
id|ti-&gt;cdti_trk1
)paren
suffix:semicolon
r_return
id|mcdx_playtrk
c_func
(paren
id|stuffp
comma
id|ti
)paren
suffix:semicolon
)brace
r_case
id|CDROMPLAYMSF
suffix:colon
(brace
r_struct
id|cdrom_msf
op_star
id|msf
op_assign
(paren
r_struct
id|cdrom_msf
op_star
)paren
id|arg
suffix:semicolon
id|xtrace
c_func
(paren
id|IOCTL
comma
l_string|&quot;ioctl() PLAYMSF&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|stuffp-&gt;audiostatus
op_eq
id|CDROM_AUDIO_PLAY
)paren
op_logical_and
(paren
op_minus
l_int|1
op_eq
id|mcdx_hold
c_func
(paren
id|stuffp
comma
l_int|1
)paren
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|msf-&gt;cdmsf_min0
op_assign
id|uint2bcd
c_func
(paren
id|msf-&gt;cdmsf_min0
)paren
suffix:semicolon
id|msf-&gt;cdmsf_sec0
op_assign
id|uint2bcd
c_func
(paren
id|msf-&gt;cdmsf_sec0
)paren
suffix:semicolon
id|msf-&gt;cdmsf_frame0
op_assign
id|uint2bcd
c_func
(paren
id|msf-&gt;cdmsf_frame0
)paren
suffix:semicolon
id|msf-&gt;cdmsf_min1
op_assign
id|uint2bcd
c_func
(paren
id|msf-&gt;cdmsf_min1
)paren
suffix:semicolon
id|msf-&gt;cdmsf_sec1
op_assign
id|uint2bcd
c_func
(paren
id|msf-&gt;cdmsf_sec1
)paren
suffix:semicolon
id|msf-&gt;cdmsf_frame1
op_assign
id|uint2bcd
c_func
(paren
id|msf-&gt;cdmsf_frame1
)paren
suffix:semicolon
id|stuffp-&gt;stop.dt.minute
op_assign
id|msf-&gt;cdmsf_min1
suffix:semicolon
id|stuffp-&gt;stop.dt.second
op_assign
id|msf-&gt;cdmsf_sec1
suffix:semicolon
id|stuffp-&gt;stop.dt.frame
op_assign
id|msf-&gt;cdmsf_frame1
suffix:semicolon
r_return
id|mcdx_playmsf
c_func
(paren
id|stuffp
comma
id|msf
)paren
suffix:semicolon
)brace
r_case
id|CDROMRESUME
suffix:colon
(brace
id|xtrace
c_func
(paren
id|IOCTL
comma
l_string|&quot;ioctl() RESUME&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|mcdx_playtrk
c_func
(paren
id|stuffp
comma
l_int|NULL
)paren
suffix:semicolon
)brace
r_case
id|CDROMREADTOCENTRY
suffix:colon
(brace
r_struct
id|cdrom_tocentry
op_star
id|entry
op_assign
(paren
r_struct
id|cdrom_tocentry
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|s_subqcode
op_star
id|tp
op_assign
l_int|NULL
suffix:semicolon
id|xtrace
c_func
(paren
id|IOCTL
comma
l_string|&quot;ioctl() READTOCENTRY&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_readtoc
c_func
(paren
id|stuffp
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;cdte_track
op_eq
id|CDROM_LEADOUT
)paren
id|tp
op_assign
op_amp
id|stuffp-&gt;toc
(braket
id|stuffp-&gt;di.n_last
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|1
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry-&gt;cdte_track
OG
id|stuffp-&gt;di.n_last
op_logical_or
id|entry-&gt;cdte_track
OL
id|stuffp-&gt;di.n_first
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
id|tp
op_assign
op_amp
id|stuffp-&gt;toc
(braket
id|entry-&gt;cdte_track
op_minus
id|stuffp-&gt;di.n_first
)braket
suffix:semicolon
r_if
c_cond
(paren
l_int|NULL
op_eq
id|tp
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|entry-&gt;cdte_adr
op_assign
id|tp-&gt;control
suffix:semicolon
id|entry-&gt;cdte_ctrl
op_assign
id|tp-&gt;control
op_rshift
l_int|4
suffix:semicolon
multiline_comment|/* Always return stuff in MSF, and let the Uniform cdrom driver&n;                worry about what the user actually wants */
id|entry-&gt;cdte_addr.msf.minute
op_assign
id|bcd2uint
c_func
(paren
id|tp-&gt;dt.minute
)paren
suffix:semicolon
id|entry-&gt;cdte_addr.msf.second
op_assign
id|bcd2uint
c_func
(paren
id|tp-&gt;dt.second
)paren
suffix:semicolon
id|entry-&gt;cdte_addr.msf.frame
op_assign
id|bcd2uint
c_func
(paren
id|tp-&gt;dt.frame
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMSUBCHNL
suffix:colon
(brace
r_struct
id|cdrom_subchnl
op_star
id|sub
op_assign
(paren
r_struct
id|cdrom_subchnl
op_star
)paren
id|arg
suffix:semicolon
r_struct
id|s_subqcode
id|q
suffix:semicolon
id|xtrace
c_func
(paren
id|IOCTL
comma
l_string|&quot;ioctl() SUBCHNL&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_requestsubqcode
c_func
(paren
id|stuffp
comma
op_amp
id|q
comma
l_int|2
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|xtrace
c_func
(paren
id|SUBCHNL
comma
l_string|&quot;audiostatus: %x&bslash;n&quot;
comma
id|stuffp-&gt;audiostatus
)paren
suffix:semicolon
id|sub-&gt;cdsc_audiostatus
op_assign
id|stuffp-&gt;audiostatus
suffix:semicolon
id|sub-&gt;cdsc_adr
op_assign
id|q.control
suffix:semicolon
id|sub-&gt;cdsc_ctrl
op_assign
id|q.control
op_rshift
l_int|4
suffix:semicolon
id|sub-&gt;cdsc_trk
op_assign
id|bcd2uint
c_func
(paren
id|q.tno
)paren
suffix:semicolon
id|sub-&gt;cdsc_ind
op_assign
id|bcd2uint
c_func
(paren
id|q.index
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|SUBCHNL
comma
l_string|&quot;trk %d, ind %d&bslash;n&quot;
comma
id|sub-&gt;cdsc_trk
comma
id|sub-&gt;cdsc_ind
)paren
suffix:semicolon
multiline_comment|/* Always return stuff in MSF, and let the Uniform cdrom driver&n;                worry about what the user actually wants */
id|sub-&gt;cdsc_absaddr.msf.minute
op_assign
id|bcd2uint
c_func
(paren
id|q.dt.minute
)paren
suffix:semicolon
id|sub-&gt;cdsc_absaddr.msf.second
op_assign
id|bcd2uint
c_func
(paren
id|q.dt.second
)paren
suffix:semicolon
id|sub-&gt;cdsc_absaddr.msf.frame
op_assign
id|bcd2uint
c_func
(paren
id|q.dt.frame
)paren
suffix:semicolon
id|sub-&gt;cdsc_reladdr.msf.minute
op_assign
id|bcd2uint
c_func
(paren
id|q.tt.minute
)paren
suffix:semicolon
id|sub-&gt;cdsc_reladdr.msf.second
op_assign
id|bcd2uint
c_func
(paren
id|q.tt.second
)paren
suffix:semicolon
id|sub-&gt;cdsc_reladdr.msf.frame
op_assign
id|bcd2uint
c_func
(paren
id|q.tt.frame
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|SUBCHNL
comma
l_string|&quot;msf: abs %02d:%02d:%02d, rel %02d:%02d:%02d&bslash;n&quot;
comma
id|sub-&gt;cdsc_absaddr.msf.minute
comma
id|sub-&gt;cdsc_absaddr.msf.second
comma
id|sub-&gt;cdsc_absaddr.msf.frame
comma
id|sub-&gt;cdsc_reladdr.msf.minute
comma
id|sub-&gt;cdsc_reladdr.msf.second
comma
id|sub-&gt;cdsc_reladdr.msf.frame
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMREADTOCHDR
suffix:colon
(brace
r_struct
id|cdrom_tochdr
op_star
id|toc
op_assign
(paren
r_struct
id|cdrom_tochdr
op_star
)paren
id|arg
suffix:semicolon
id|xtrace
c_func
(paren
id|IOCTL
comma
l_string|&quot;ioctl() READTOCHDR&bslash;n&quot;
)paren
suffix:semicolon
id|toc-&gt;cdth_trk0
op_assign
id|stuffp-&gt;di.n_first
suffix:semicolon
id|toc-&gt;cdth_trk1
op_assign
id|stuffp-&gt;di.n_last
suffix:semicolon
id|xtrace
c_func
(paren
id|TOCHDR
comma
l_string|&quot;ioctl() track0 = %d, track1 = %d&bslash;n&quot;
comma
id|stuffp-&gt;di.n_first
comma
id|stuffp-&gt;di.n_last
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMPAUSE
suffix:colon
(brace
id|xtrace
c_func
(paren
id|IOCTL
comma
l_string|&quot;ioctl() PAUSE&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;audiostatus
op_ne
id|CDROM_AUDIO_PLAY
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_stop
c_func
(paren
id|stuffp
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|stuffp-&gt;audiostatus
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_requestsubqcode
c_func
(paren
id|stuffp
comma
op_amp
id|stuffp-&gt;start
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMMULTISESSION
suffix:colon
(brace
r_struct
id|cdrom_multisession
op_star
id|ms
op_assign
(paren
r_struct
id|cdrom_multisession
op_star
)paren
id|arg
suffix:semicolon
id|xtrace
c_func
(paren
id|IOCTL
comma
l_string|&quot;ioctl() MULTISESSION&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Always return stuff in LBA, and let the Uniform cdrom driver&n;&t;&t;&t;&t;worry about what the user actually wants */
id|ms-&gt;addr.lba
op_assign
id|msf2log
c_func
(paren
op_amp
id|stuffp-&gt;multi.msf_last
)paren
suffix:semicolon
id|ms-&gt;xa_flag
op_assign
op_logical_neg
op_logical_neg
id|stuffp-&gt;multi.multi
suffix:semicolon
id|xtrace
c_func
(paren
id|MS
comma
l_string|&quot;ioctl() (%d, 0x%08x [%02x:%02x.%02x])&bslash;n&quot;
comma
id|ms-&gt;xa_flag
comma
id|ms-&gt;addr.lba
comma
id|stuffp-&gt;multi.msf_last.minute
comma
id|stuffp-&gt;multi.msf_last.second
comma
id|stuffp-&gt;multi.msf_last.frame
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_case
id|CDROMEJECT
suffix:colon
(brace
id|xtrace
c_func
(paren
id|IOCTL
comma
l_string|&quot;ioctl() EJECT&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;users
OG
l_int|1
)paren
r_return
op_minus
id|EBUSY
suffix:semicolon
r_return
id|mcdx_tray_move
c_func
(paren
id|cdi
comma
l_int|1
)paren
suffix:semicolon
)brace
r_case
id|CDROMCLOSETRAY
suffix:colon
(brace
id|xtrace
c_func
(paren
id|IOCTL
comma
l_string|&quot;ioctl() CDROMCLOSETRAY&bslash;n&quot;
)paren
suffix:semicolon
r_return
id|mcdx_tray_move
c_func
(paren
id|cdi
comma
l_int|0
)paren
suffix:semicolon
)brace
r_case
id|CDROMVOLCTRL
suffix:colon
(brace
r_struct
id|cdrom_volctrl
op_star
id|volctrl
op_assign
(paren
r_struct
id|cdrom_volctrl
op_star
)paren
id|arg
suffix:semicolon
id|xtrace
c_func
(paren
id|IOCTL
comma
l_string|&quot;ioctl() VOLCTRL&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#if 0&t;&t;/* not tested! */
multiline_comment|/* adjust for the weirdness of workman (md) */
multiline_comment|/* can&squot;t test it (hs) */
id|volctrl.channel2
op_assign
id|volctrl.channel1
suffix:semicolon
id|volctrl.channel1
op_assign
id|volctrl.channel3
op_assign
l_int|0x00
suffix:semicolon
macro_line|#endif
r_return
id|mcdx_setattentuator
c_func
(paren
id|stuffp
comma
id|volctrl
comma
l_int|2
)paren
suffix:semicolon
)brace
r_default
suffix:colon
id|xwarn
c_func
(paren
l_string|&quot;ioctl(): unknown request 0x%04x&bslash;n&quot;
comma
id|cmd
)paren
suffix:semicolon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
DECL|function|do_mcdx_request
r_void
id|do_mcdx_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
r_int
id|dev
suffix:semicolon
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
id|again
suffix:colon
r_if
c_cond
(paren
id|QUEUE_EMPTY
)paren
(brace
id|xtrace
c_func
(paren
id|REQUEST
comma
l_string|&quot;end_request(0): CURRENT == NULL&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT-&gt;rq_status
op_eq
id|RQ_INACTIVE
)paren
(brace
id|xtrace
c_func
(paren
id|REQUEST
comma
l_string|&quot;end_request(0): rq_status == RQ_INACTIVE&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|INIT_REQUEST
suffix:semicolon
id|dev
op_assign
id|MINOR
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
suffix:semicolon
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|dev
)braket
suffix:semicolon
r_if
c_cond
(paren
(paren
id|dev
OL
l_int|0
)paren
op_logical_or
(paren
id|dev
op_ge
id|MCDX_NDRIVES
)paren
op_logical_or
op_logical_neg
id|stuffp
op_logical_or
(paren
op_logical_neg
id|stuffp-&gt;present
)paren
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;do_request(): bad device: %s&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|CURRENT-&gt;rq_dev
)paren
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|REQUEST
comma
l_string|&quot;end_request(0): bad device&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stuffp-&gt;audio
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;do_request() attempt to read from audio cd&bslash;n&quot;
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|REQUEST
comma
l_string|&quot;end_request(0): read from audio&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|xtrace
c_func
(paren
id|REQUEST
comma
l_string|&quot;do_request() (%lu + %lu)&bslash;n&quot;
comma
id|CURRENT-&gt;sector
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|CURRENT-&gt;cmd
)paren
(brace
r_case
id|WRITE
suffix:colon
id|xwarn
c_func
(paren
l_string|&quot;do_request(): attempt to write to cd!!&bslash;n&quot;
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|REQUEST
comma
l_string|&quot;end_request(0): write&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_return
suffix:semicolon
r_case
id|READ
suffix:colon
id|stuffp-&gt;status
op_assign
l_int|0
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT-&gt;nr_sectors
)paren
(brace
r_int
id|i
suffix:semicolon
id|i
op_assign
id|mcdx_transfer
c_func
(paren
id|stuffp
comma
id|CURRENT-&gt;buffer
comma
id|CURRENT-&gt;sector
comma
id|CURRENT-&gt;nr_sectors
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
op_eq
op_minus
l_int|1
)paren
(brace
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
)brace
id|CURRENT-&gt;sector
op_add_assign
id|i
suffix:semicolon
id|CURRENT-&gt;nr_sectors
op_sub_assign
id|i
suffix:semicolon
id|CURRENT-&gt;buffer
op_add_assign
(paren
id|i
op_star
l_int|512
)paren
suffix:semicolon
)brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_goto
id|again
suffix:semicolon
id|xtrace
c_func
(paren
id|REQUEST
comma
l_string|&quot;end_request(1)&bslash;n&quot;
)paren
suffix:semicolon
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|panic
c_func
(paren
id|MCDX
l_string|&quot;do_request: unknown command.&bslash;n&quot;
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
r_goto
id|again
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_open
id|mcdx_open
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|purpose
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
id|xtrace
c_func
(paren
id|OPENCLOSE
comma
l_string|&quot;open()&bslash;n&quot;
)paren
suffix:semicolon
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|cdi-&gt;dev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;present
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* Make the modules looking used ... (thanx bjorn).&n;&t; * But we shouldn&squot;t forget to decrement the module counter&n;&t; * on error return */
id|MOD_INC_USE_COUNT
suffix:semicolon
multiline_comment|/* this is only done to test if the drive talks with us */
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_getstatus
c_func
(paren
id|stuffp
comma
l_int|1
)paren
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stuffp-&gt;xxx
)paren
(brace
id|xtrace
c_func
(paren
id|OPENCLOSE
comma
l_string|&quot;open() media changed&bslash;n&quot;
)paren
suffix:semicolon
id|stuffp-&gt;audiostatus
op_assign
id|CDROM_AUDIO_INVALID
suffix:semicolon
id|stuffp-&gt;readcmd
op_assign
l_int|0
suffix:semicolon
id|xtrace
c_func
(paren
id|OPENCLOSE
comma
l_string|&quot;open() Request multisession info&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_requestmultidiskinfo
c_func
(paren
id|stuffp
comma
op_amp
id|stuffp-&gt;multi
comma
l_int|6
)paren
)paren
id|xinfo
c_func
(paren
l_string|&quot;No multidiskinfo&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* multisession ? */
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;multi.multi
)paren
id|stuffp-&gt;multi.msf_last.second
op_assign
l_int|2
suffix:semicolon
id|xtrace
c_func
(paren
id|OPENCLOSE
comma
l_string|&quot;open() MS: %d, last @ %02x:%02x.%02x&bslash;n&quot;
comma
id|stuffp-&gt;multi.multi
comma
id|stuffp-&gt;multi.msf_last.minute
comma
id|stuffp-&gt;multi.msf_last.second
comma
id|stuffp-&gt;multi.msf_last.frame
)paren
suffix:semicolon
(brace
suffix:semicolon
)brace
multiline_comment|/* got multisession information */
multiline_comment|/* request the disks table of contents (aka diskinfo) */
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_requesttocdata
c_func
(paren
id|stuffp
comma
op_amp
id|stuffp-&gt;di
comma
l_int|1
)paren
)paren
(brace
id|stuffp-&gt;lastsector
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
r_else
(brace
id|stuffp-&gt;lastsector
op_assign
(paren
id|CD_FRAMESIZE
op_div
l_int|512
)paren
op_star
id|msf2log
c_func
(paren
op_amp
id|stuffp-&gt;di.msf_leadout
)paren
op_minus
l_int|1
suffix:semicolon
id|xtrace
c_func
(paren
id|OPENCLOSE
comma
l_string|&quot;open() start %d (%02x:%02x.%02x) %d&bslash;n&quot;
comma
id|stuffp-&gt;di.n_first
comma
id|stuffp-&gt;di.msf_first.minute
comma
id|stuffp-&gt;di.msf_first.second
comma
id|stuffp-&gt;di.msf_first.frame
comma
id|msf2log
c_func
(paren
op_amp
id|stuffp-&gt;di.msf_first
)paren
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|OPENCLOSE
comma
l_string|&quot;open() last %d (%02x:%02x.%02x) %d&bslash;n&quot;
comma
id|stuffp-&gt;di.n_last
comma
id|stuffp-&gt;di.msf_leadout.minute
comma
id|stuffp-&gt;di.msf_leadout.second
comma
id|stuffp-&gt;di.msf_leadout.frame
comma
id|msf2log
c_func
(paren
op_amp
id|stuffp-&gt;di.msf_leadout
)paren
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stuffp-&gt;toc
)paren
(brace
id|xtrace
c_func
(paren
id|MALLOC
comma
l_string|&quot;open() free old toc @ %p&bslash;n&quot;
comma
id|stuffp-&gt;toc
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp-&gt;toc
)paren
suffix:semicolon
id|stuffp-&gt;toc
op_assign
l_int|NULL
suffix:semicolon
)brace
id|xtrace
c_func
(paren
id|OPENCLOSE
comma
l_string|&quot;open() init irq generation&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_config
c_func
(paren
id|stuffp
comma
l_int|1
)paren
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
macro_line|#if FALLBACK
multiline_comment|/* Set the read speed */
id|xwarn
c_func
(paren
l_string|&quot;AAA %x AAA&bslash;n&quot;
comma
id|stuffp-&gt;readcmd
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;readerrs
)paren
id|stuffp-&gt;readcmd
op_assign
id|READ1X
suffix:semicolon
r_else
id|stuffp-&gt;readcmd
op_assign
id|stuffp-&gt;present
op_or
id|SINGLE
ques
c_cond
id|READ1X
suffix:colon
id|READ2X
suffix:semicolon
id|xwarn
c_func
(paren
l_string|&quot;XXX %x XXX&bslash;n&quot;
comma
id|stuffp-&gt;readcmd
)paren
suffix:semicolon
macro_line|#else
id|stuffp-&gt;readcmd
op_assign
id|stuffp-&gt;present
op_or
id|SINGLE
ques
c_cond
id|READ1X
suffix:colon
id|READ2X
suffix:semicolon
macro_line|#endif
multiline_comment|/* try to get the first sector, iff any ... */
r_if
c_cond
(paren
id|stuffp-&gt;lastsector
op_ge
l_int|0
)paren
(brace
r_char
id|buf
(braket
l_int|512
)braket
suffix:semicolon
r_int
id|ans
suffix:semicolon
r_int
id|tries
suffix:semicolon
id|stuffp-&gt;xa
op_assign
l_int|0
suffix:semicolon
id|stuffp-&gt;audio
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|tries
op_assign
l_int|6
suffix:semicolon
id|tries
suffix:semicolon
id|tries
op_decrement
)paren
(brace
id|stuffp-&gt;introk
op_assign
l_int|1
suffix:semicolon
id|xtrace
c_func
(paren
id|OPENCLOSE
comma
l_string|&quot;open() try as %s&bslash;n&quot;
comma
id|stuffp-&gt;xa
ques
c_cond
l_string|&quot;XA&quot;
suffix:colon
l_string|&quot;normal&quot;
)paren
suffix:semicolon
multiline_comment|/* set data mode */
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
id|ans
op_assign
id|mcdx_setdatamode
c_func
(paren
id|stuffp
comma
id|stuffp-&gt;xa
ques
c_cond
id|MODE2
suffix:colon
id|MODE1
comma
l_int|1
)paren
)paren
)paren
(brace
multiline_comment|/* MOD_DEC_USE_COUNT, return -EIO; */
id|stuffp-&gt;xa
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stuffp-&gt;audio
op_assign
id|e_audio
c_func
(paren
id|ans
)paren
)paren
)paren
r_break
suffix:semicolon
r_while
c_loop
(paren
l_int|0
op_eq
(paren
id|ans
op_assign
id|mcdx_transfer
c_func
(paren
id|stuffp
comma
id|buf
comma
l_int|0
comma
l_int|1
)paren
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ans
op_eq
l_int|1
)paren
r_break
suffix:semicolon
id|stuffp-&gt;xa
op_assign
op_logical_neg
id|stuffp-&gt;xa
suffix:semicolon
)brace
)brace
multiline_comment|/* xa disks will be read in raw mode, others not */
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_setdrivemode
c_func
(paren
id|stuffp
comma
id|stuffp-&gt;xa
ques
c_cond
id|RAW
suffix:colon
id|COOKED
comma
l_int|1
)paren
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stuffp-&gt;audio
)paren
(brace
id|xinfo
c_func
(paren
l_string|&quot;open() audio disk found&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|stuffp-&gt;lastsector
op_ge
l_int|0
)paren
(brace
id|xinfo
c_func
(paren
l_string|&quot;open() %s%s disk found&bslash;n&quot;
comma
id|stuffp-&gt;xa
ques
c_cond
l_string|&quot;XA / &quot;
suffix:colon
l_string|&quot;&quot;
comma
id|stuffp-&gt;multi.multi
ques
c_cond
l_string|&quot;Multi Session&quot;
suffix:colon
l_string|&quot;Single Session&quot;
)paren
suffix:semicolon
)brace
)brace
id|stuffp-&gt;xxx
op_assign
l_int|0
suffix:semicolon
id|stuffp-&gt;users
op_increment
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mcdx_close
r_static
r_void
id|mcdx_close
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
id|xtrace
c_func
(paren
id|OPENCLOSE
comma
l_string|&quot;close()&bslash;n&quot;
)paren
suffix:semicolon
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|cdi-&gt;dev
)paren
)braket
suffix:semicolon
op_decrement
id|stuffp-&gt;users
suffix:semicolon
id|MOD_DEC_USE_COUNT
suffix:semicolon
)brace
DECL|function|mcdx_media_changed
r_static
r_int
id|mcdx_media_changed
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|disc_nr
)paren
multiline_comment|/*&t;Return: 1 if media changed since last call to this function&n;&t;&t;&t;0 otherwise */
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
id|xinfo
c_func
(paren
l_string|&quot;mcdx_media_changed called for device %s&bslash;n&quot;
comma
id|kdevname
c_func
(paren
id|cdi-&gt;dev
)paren
)paren
suffix:semicolon
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|cdi-&gt;dev
)paren
)braket
suffix:semicolon
id|mcdx_getstatus
c_func
(paren
id|stuffp
comma
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;yyy
op_eq
l_int|0
)paren
r_return
l_int|0
suffix:semicolon
id|stuffp-&gt;yyy
op_assign
l_int|0
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
macro_line|#ifndef MODULE
DECL|function|mcdx_setup
r_static
r_int
id|__init
id|mcdx_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|pi
(braket
l_int|4
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|pi
)paren
comma
id|pi
)paren
suffix:semicolon
r_if
c_cond
(paren
id|pi
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|mcdx_drive_map
(braket
l_int|0
)braket
(braket
l_int|0
)braket
op_assign
id|pi
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|pi
(braket
l_int|0
)braket
OG
l_int|1
)paren
id|mcdx_drive_map
(braket
l_int|0
)braket
(braket
l_int|1
)braket
op_assign
id|pi
(braket
l_int|2
)braket
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;mcdx=&quot;
comma
id|mcdx_setup
)paren
suffix:semicolon
macro_line|#endif
multiline_comment|/* DIRTY PART ******************************************************/
DECL|function|mcdx_delay
r_static
r_void
id|mcdx_delay
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuff
comma
r_int
id|jifs
)paren
multiline_comment|/* This routine is used for sleeping.&n; * A jifs value &lt;0 means NO sleeping,&n; *              =0 means minimal sleeping (let the kernel&n; *                 run for other processes)&n; *              &gt;0 means at least sleep for that amount.&n; *&t;May be we could use a simple count loop w/ jumps to itself, but&n; *&t;I wanna make this independent of cpu speed. [1 jiffy is 1/HZ] sec */
(brace
r_if
c_cond
(paren
id|jifs
OL
l_int|0
)paren
r_return
suffix:semicolon
id|xtrace
c_func
(paren
id|SLEEP
comma
l_string|&quot;*** delay: sleepq&bslash;n&quot;
)paren
suffix:semicolon
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|stuff-&gt;sleepq
comma
id|jifs
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|SLEEP
comma
l_string|&quot;delay awoken&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|xtrace
c_func
(paren
id|SLEEP
comma
l_string|&quot;got signal&bslash;n&quot;
)paren
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|mcdx_intr
id|mcdx_intr
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
r_int
r_char
id|b
suffix:semicolon
id|stuffp
op_assign
id|mcdx_irq_map
(braket
id|irq
)braket
suffix:semicolon
r_if
c_cond
(paren
id|stuffp
op_eq
l_int|NULL
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;mcdx: no device for intr %d&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
macro_line|#ifdef AK2
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;busy
op_logical_and
id|stuffp-&gt;pending
)paren
id|stuffp-&gt;int_err
op_assign
l_int|1
suffix:semicolon
macro_line|#endif /* AK2 */
multiline_comment|/* get the interrupt status */
id|b
op_assign
id|inb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_status
)paren
suffix:semicolon
id|stuffp-&gt;introk
op_assign
op_complement
id|b
op_amp
id|MCDX_RBIT_DTEN
suffix:semicolon
multiline_comment|/* NOTE: We only should get interrupts if the data we&n;&t; * requested are ready to transfer.&n;&t; * But the drive seems to generate ``asynchronous&squot;&squot; interrupts&n;&t; * on several error conditions too.  (Despite the err int enable&n;&t; * setting during initialisation) */
multiline_comment|/* if not ok, read the next byte as the drives status */
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;introk
)paren
(brace
id|xtrace
c_func
(paren
id|IRQ
comma
l_string|&quot;intr() irq %d hw status 0x%02x&bslash;n&quot;
comma
id|irq
comma
id|b
)paren
suffix:semicolon
r_if
c_cond
(paren
op_complement
id|b
op_amp
id|MCDX_RBIT_STEN
)paren
(brace
id|xinfo
c_func
(paren
l_string|&quot;intr() irq %d    status 0x%02x&bslash;n&quot;
comma
id|irq
comma
id|inb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_data
)paren
)paren
suffix:semicolon
)brace
r_else
(brace
id|xinfo
c_func
(paren
l_string|&quot;intr() irq %d ambiguous hw status&bslash;n&quot;
comma
id|irq
)paren
suffix:semicolon
)brace
)brace
r_else
(brace
id|xtrace
c_func
(paren
id|IRQ
comma
l_string|&quot;irq() irq %d ok, status %02x&bslash;n&quot;
comma
id|irq
comma
id|b
)paren
suffix:semicolon
)brace
id|stuffp-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|stuffp-&gt;busyq
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_talk
id|mcdx_talk
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_const
r_int
r_char
op_star
id|cmd
comma
r_int
id|cmdlen
comma
r_void
op_star
id|buffer
comma
r_int
id|size
comma
r_int
r_int
id|timeout
comma
r_int
id|tries
)paren
multiline_comment|/* Send a command to the drive, wait for the result.&n; * returns -1 on timeout, drive status otherwise&n; * If buffer is not zero, the result (length size) is stored there.&n; * If buffer is zero the size should be the number of bytes to read&n; * from the drive.  These bytes are discarded.&n; */
(brace
r_int
id|st
suffix:semicolon
r_char
id|c
suffix:semicolon
r_int
id|discard
suffix:semicolon
multiline_comment|/* Somebody wants the data read? */
r_if
c_cond
(paren
(paren
id|discard
op_assign
(paren
id|buffer
op_eq
l_int|NULL
)paren
)paren
)paren
id|buffer
op_assign
op_amp
id|c
suffix:semicolon
r_while
c_loop
(paren
id|stuffp-&gt;lock
)paren
(brace
id|xtrace
c_func
(paren
id|SLEEP
comma
l_string|&quot;*** talk: lockq&bslash;n&quot;
)paren
suffix:semicolon
id|interruptible_sleep_on
c_func
(paren
op_amp
id|stuffp-&gt;lockq
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|SLEEP
comma
l_string|&quot;talk: awoken&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|stuffp-&gt;lock
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* An operation other then reading data destroys the&n;     * data already requested and remembered in stuffp-&gt;request, ... */
id|stuffp-&gt;valid
op_assign
l_int|0
suffix:semicolon
macro_line|#if MCDX_DEBUG &amp; TALK
(brace
r_int
r_char
id|i
suffix:semicolon
id|xtrace
c_func
(paren
id|TALK
comma
l_string|&quot;talk() %d / %d tries, res.size %d, command 0x%02x&quot;
comma
id|tries
comma
id|timeout
comma
id|size
comma
(paren
r_int
r_char
)paren
id|cmd
(braket
l_int|0
)braket
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
OL
id|cmdlen
suffix:semicolon
id|i
op_increment
)paren
id|xtrace
c_func
(paren
id|TALK
comma
l_string|&quot; 0x%02x&quot;
comma
id|cmd
(braket
id|i
)braket
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|TALK
comma
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
)brace
macro_line|#endif
multiline_comment|/*  give up if all tries are done (bad) or if the status&n;     *  st != -1 (good) */
r_for
c_loop
(paren
id|st
op_assign
op_minus
l_int|1
suffix:semicolon
id|st
op_eq
op_minus
l_int|1
op_logical_and
id|tries
suffix:semicolon
id|tries
op_decrement
)paren
(brace
r_char
op_star
id|bp
op_assign
(paren
r_char
op_star
)paren
id|buffer
suffix:semicolon
r_int
id|sz
op_assign
id|size
suffix:semicolon
id|outsb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_data
comma
id|cmd
comma
id|cmdlen
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|TALK
comma
l_string|&quot;talk() command sent&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* get the status byte */
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_getval
c_func
(paren
id|stuffp
comma
id|timeout
comma
l_int|0
comma
id|bp
)paren
)paren
(brace
id|xinfo
c_func
(paren
l_string|&quot;talk() %02x timed out (status), %d tr%s left&bslash;n&quot;
comma
id|cmd
(braket
l_int|0
)braket
comma
id|tries
op_minus
l_int|1
comma
id|tries
op_eq
l_int|2
ques
c_cond
l_string|&quot;y&quot;
suffix:colon
l_string|&quot;ies&quot;
)paren
suffix:semicolon
r_continue
suffix:semicolon
)brace
id|st
op_assign
op_star
id|bp
suffix:semicolon
id|sz
op_decrement
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|discard
)paren
id|bp
op_increment
suffix:semicolon
id|xtrace
c_func
(paren
id|TALK
comma
l_string|&quot;talk() got status 0x%02x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
multiline_comment|/* command error? */
r_if
c_cond
(paren
id|e_cmderr
c_func
(paren
id|st
)paren
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;command error cmd = %02x %s &bslash;n&quot;
comma
id|cmd
(braket
l_int|0
)braket
comma
id|cmdlen
OG
l_int|1
ques
c_cond
l_string|&quot;...&quot;
suffix:colon
l_string|&quot;&quot;
)paren
suffix:semicolon
id|st
op_assign
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
multiline_comment|/* audio status? */
r_if
c_cond
(paren
id|stuffp-&gt;audiostatus
op_eq
id|CDROM_AUDIO_INVALID
)paren
id|stuffp-&gt;audiostatus
op_assign
id|e_audiobusy
c_func
(paren
id|st
)paren
ques
c_cond
id|CDROM_AUDIO_PLAY
suffix:colon
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_else
r_if
c_cond
(paren
id|stuffp-&gt;audiostatus
op_eq
id|CDROM_AUDIO_PLAY
op_logical_and
id|e_audiobusy
c_func
(paren
id|st
)paren
op_eq
l_int|0
)paren
id|stuffp-&gt;audiostatus
op_assign
id|CDROM_AUDIO_COMPLETED
suffix:semicolon
multiline_comment|/* media change? */
r_if
c_cond
(paren
id|e_changed
c_func
(paren
id|st
)paren
)paren
(brace
id|xinfo
c_func
(paren
l_string|&quot;talk() media changed&bslash;n&quot;
)paren
suffix:semicolon
id|stuffp-&gt;xxx
op_assign
id|stuffp-&gt;yyy
op_assign
l_int|1
suffix:semicolon
)brace
multiline_comment|/* now actually get the data */
r_while
c_loop
(paren
id|sz
op_decrement
)paren
(brace
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_getval
c_func
(paren
id|stuffp
comma
id|timeout
comma
l_int|0
comma
id|bp
)paren
)paren
(brace
id|xinfo
c_func
(paren
l_string|&quot;talk() %02x timed out (data), %d tr%s left&bslash;n&quot;
comma
id|cmd
(braket
l_int|0
)braket
comma
id|tries
op_minus
l_int|1
comma
id|tries
op_eq
l_int|2
ques
c_cond
l_string|&quot;y&quot;
suffix:colon
l_string|&quot;ies&quot;
)paren
suffix:semicolon
id|st
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|discard
)paren
id|bp
op_increment
suffix:semicolon
id|xtrace
c_func
(paren
id|TALK
comma
l_string|&quot;talk() got 0x%02x&bslash;n&quot;
comma
op_star
(paren
id|bp
op_minus
l_int|1
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#if !MCDX_QUIET
r_if
c_cond
(paren
op_logical_neg
id|tries
op_logical_and
id|st
op_eq
op_minus
l_int|1
)paren
id|xinfo
c_func
(paren
l_string|&quot;talk() giving up&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|stuffp-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|stuffp-&gt;lockq
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|TALK
comma
l_string|&quot;talk() done with 0x%02x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
r_return
id|st
suffix:semicolon
)brace
multiline_comment|/* MODULE STUFF ***********************************************************/
id|EXPORT_NO_SYMBOLS
suffix:semicolon
DECL|function|__mcdx_init
r_int
id|__mcdx_init
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|drives
op_assign
l_int|0
suffix:semicolon
id|mcdx_init
c_func
(paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MCDX_NDRIVES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_if
c_cond
(paren
id|mcdx_stuffp
(braket
id|i
)braket
)paren
(brace
id|xtrace
c_func
(paren
id|INIT
comma
l_string|&quot;init_module() drive %d stuff @ %p&bslash;n&quot;
comma
id|i
comma
id|mcdx_stuffp
(braket
id|i
)braket
)paren
suffix:semicolon
id|drives
op_increment
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
op_logical_neg
id|drives
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mcdx_exit
r_void
id|__exit
id|mcdx_exit
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
id|xinfo
c_func
(paren
l_string|&quot;cleanup_module called&bslash;n&quot;
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MCDX_NDRIVES
suffix:semicolon
id|i
op_increment
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
r_if
c_cond
(paren
id|unregister_cdrom
c_func
(paren
op_amp
id|mcdx_info
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Can&squot;t unregister cdrom mcdx&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|i
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp
)paren
r_continue
suffix:semicolon
id|release_region
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_data
comma
id|MCDX_IO_SIZE
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|stuffp-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;toc
)paren
(brace
id|xtrace
c_func
(paren
id|MALLOC
comma
l_string|&quot;cleanup_module() free toc @ %p&bslash;n&quot;
comma
id|stuffp-&gt;toc
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp-&gt;toc
)paren
suffix:semicolon
)brace
id|xtrace
c_func
(paren
id|MALLOC
comma
l_string|&quot;cleanup_module() free stuffp @ %p&bslash;n&quot;
comma
id|stuffp
)paren
suffix:semicolon
id|mcdx_stuffp
(braket
id|i
)braket
op_assign
l_int|NULL
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;mcdx&quot;
)paren
op_ne
l_int|0
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;cleanup() unregister_blkdev() failed&bslash;n&quot;
)paren
suffix:semicolon
)brace
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
macro_line|#if !MCDX_QUIET
r_else
id|xinfo
c_func
(paren
l_string|&quot;cleanup() succeeded&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
macro_line|#ifdef MODULE
DECL|variable|__mcdx_init
id|module_init
c_func
(paren
id|__mcdx_init
)paren
suffix:semicolon
macro_line|#endif
DECL|variable|mcdx_exit
id|module_exit
c_func
(paren
id|mcdx_exit
)paren
suffix:semicolon
multiline_comment|/* Support functions ************************************************/
DECL|function|mcdx_init_drive
r_int
id|__init
id|mcdx_init_drive
c_func
(paren
r_int
id|drive
)paren
(brace
r_struct
id|s_version
id|version
suffix:semicolon
r_struct
id|s_drive_stuff
op_star
id|stuffp
suffix:semicolon
r_int
id|size
op_assign
r_sizeof
(paren
op_star
id|stuffp
)paren
suffix:semicolon
r_char
id|msg
(braket
l_int|80
)braket
suffix:semicolon
id|mcdx_blocksizes
(braket
id|drive
)braket
op_assign
l_int|0
suffix:semicolon
id|xtrace
c_func
(paren
id|INIT
comma
l_string|&quot;init() try drive %d&bslash;n&quot;
comma
id|drive
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|INIT
comma
l_string|&quot;kmalloc space for stuffpt&squot;s&bslash;n&quot;
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|MALLOC
comma
l_string|&quot;init() malloc %d bytes&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|stuffp
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
)paren
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;init() malloc failed&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|xtrace
c_func
(paren
id|INIT
comma
l_string|&quot;init() got %d bytes for drive stuff @ %p&bslash;n&quot;
comma
r_sizeof
(paren
op_star
id|stuffp
)paren
comma
id|stuffp
)paren
suffix:semicolon
multiline_comment|/* set default values */
id|memset
c_func
(paren
id|stuffp
comma
l_int|0
comma
r_sizeof
(paren
op_star
id|stuffp
)paren
)paren
suffix:semicolon
id|stuffp-&gt;present
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* this should be 0 already */
id|stuffp-&gt;toc
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* this should be NULL already */
multiline_comment|/* setup our irq and i/o addresses */
id|stuffp-&gt;irq
op_assign
id|irq
c_func
(paren
id|mcdx_drive_map
(braket
id|drive
)braket
)paren
suffix:semicolon
id|stuffp-&gt;wreg_data
op_assign
id|stuffp-&gt;rreg_data
op_assign
id|port
c_func
(paren
id|mcdx_drive_map
(braket
id|drive
)braket
)paren
suffix:semicolon
id|stuffp-&gt;wreg_reset
op_assign
id|stuffp-&gt;rreg_status
op_assign
id|stuffp-&gt;wreg_data
op_plus
l_int|1
suffix:semicolon
id|stuffp-&gt;wreg_hcon
op_assign
id|stuffp-&gt;wreg_reset
op_plus
l_int|1
suffix:semicolon
id|stuffp-&gt;wreg_chn
op_assign
id|stuffp-&gt;wreg_hcon
op_plus
l_int|1
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|stuffp-&gt;busyq
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|stuffp-&gt;lockq
)paren
suffix:semicolon
id|init_waitqueue_head
c_func
(paren
op_amp
id|stuffp-&gt;sleepq
)paren
suffix:semicolon
multiline_comment|/* check if i/o addresses are available */
r_if
c_cond
(paren
id|check_region
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_data
comma
id|MCDX_IO_SIZE
)paren
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;0x%3p,%d: Init failed. &quot;
l_string|&quot;I/O ports (0x%3p..0x%3p) already in use.&bslash;n&quot;
comma
id|stuffp-&gt;wreg_data
comma
id|stuffp-&gt;irq
comma
id|stuffp-&gt;wreg_data
comma
id|stuffp-&gt;wreg_data
op_plus
id|MCDX_IO_SIZE
op_minus
l_int|1
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|MALLOC
comma
l_string|&quot;init() free stuffp @ %p&bslash;n&quot;
comma
id|stuffp
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|INIT
comma
l_string|&quot;init() continue at next drive&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* next drive */
)brace
id|xtrace
c_func
(paren
id|INIT
comma
l_string|&quot;init() i/o port is available at 0x%3p&bslash;n&quot;
comma
id|stuffp-&gt;wreg_data
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|INIT
comma
l_string|&quot;init() hardware reset&bslash;n&quot;
)paren
suffix:semicolon
id|mcdx_reset
c_func
(paren
id|stuffp
comma
id|HARD
comma
l_int|1
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|INIT
comma
l_string|&quot;init() get version&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_requestversion
c_func
(paren
id|stuffp
comma
op_amp
id|version
comma
l_int|4
)paren
)paren
(brace
multiline_comment|/* failed, next drive */
id|xwarn
c_func
(paren
l_string|&quot;%s=0x%3p,%d: Init failed. Can&squot;t get version.&bslash;n&quot;
comma
id|MCDX
comma
id|stuffp-&gt;wreg_data
comma
id|stuffp-&gt;irq
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|MALLOC
comma
l_string|&quot;init() free stuffp @ %p&bslash;n&quot;
comma
id|stuffp
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|INIT
comma
l_string|&quot;init() continue at next drive&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_switch
c_cond
(paren
id|version.code
)paren
(brace
r_case
l_char|&squot;D&squot;
suffix:colon
id|stuffp-&gt;readcmd
op_assign
id|READ2X
suffix:semicolon
id|stuffp-&gt;present
op_assign
id|DOUBLE
op_or
id|DOOR
op_or
id|MULTI
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;F&squot;
suffix:colon
id|stuffp-&gt;readcmd
op_assign
id|READ1X
suffix:semicolon
id|stuffp-&gt;present
op_assign
id|SINGLE
op_or
id|DOOR
op_or
id|MULTI
suffix:semicolon
r_break
suffix:semicolon
r_case
l_char|&squot;M&squot;
suffix:colon
id|stuffp-&gt;readcmd
op_assign
id|READ1X
suffix:semicolon
id|stuffp-&gt;present
op_assign
id|SINGLE
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
id|stuffp-&gt;present
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
id|stuffp-&gt;playcmd
op_assign
id|READ1X
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;present
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;%s=0x%3p,%d: Init failed. No Mitsumi CD-ROM?.&bslash;n&quot;
comma
id|MCDX
comma
id|stuffp-&gt;wreg_data
comma
id|stuffp-&gt;irq
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
multiline_comment|/* next drive */
)brace
id|xtrace
c_func
(paren
id|INIT
comma
l_string|&quot;init() register blkdev&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;mcdx&quot;
comma
op_amp
id|cdrom_fops
)paren
op_ne
l_int|0
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;%s=0x%3p,%d: Init failed. Can&squot;t get major %d.&bslash;n&quot;
comma
id|MCDX
comma
id|stuffp-&gt;wreg_data
comma
id|stuffp-&gt;irq
comma
id|MAJOR_NR
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|DEVICE_REQUEST
)paren
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
id|READ_AHEAD
suffix:semicolon
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|mcdx_blocksizes
suffix:semicolon
id|xtrace
c_func
(paren
id|INIT
comma
l_string|&quot;init() subscribe irq and i/o&bslash;n&quot;
)paren
suffix:semicolon
id|mcdx_irq_map
(braket
id|stuffp-&gt;irq
)braket
op_assign
id|stuffp
suffix:semicolon
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|stuffp-&gt;irq
comma
id|mcdx_intr
comma
id|SA_INTERRUPT
comma
l_string|&quot;mcdx&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;%s=0x%3p,%d: Init failed. Can&squot;t get irq (%d).&bslash;n&quot;
comma
id|MCDX
comma
id|stuffp-&gt;wreg_data
comma
id|stuffp-&gt;irq
comma
id|stuffp-&gt;irq
)paren
suffix:semicolon
id|stuffp-&gt;irq
op_assign
l_int|0
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|request_region
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_data
comma
id|MCDX_IO_SIZE
comma
l_string|&quot;mcdx&quot;
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|INIT
comma
l_string|&quot;init() get garbage&bslash;n&quot;
)paren
suffix:semicolon
(brace
r_int
id|i
suffix:semicolon
id|mcdx_delay
c_func
(paren
id|stuffp
comma
id|HZ
op_div
l_int|2
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|100
suffix:semicolon
id|i
suffix:semicolon
id|i
op_decrement
)paren
(paren
r_void
)paren
id|inb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_status
)paren
suffix:semicolon
)brace
macro_line|#if WE_KNOW_WHY
multiline_comment|/* irq 11 -&gt; channel register */
id|outb
c_func
(paren
l_int|0x50
comma
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_chn
)paren
suffix:semicolon
macro_line|#endif
id|xtrace
c_func
(paren
id|INIT
comma
l_string|&quot;init() set non dma but irq mode&bslash;n&quot;
)paren
suffix:semicolon
id|mcdx_config
c_func
(paren
id|stuffp
comma
l_int|1
)paren
suffix:semicolon
id|stuffp-&gt;minor
op_assign
id|drive
suffix:semicolon
id|sprintf
c_func
(paren
id|msg
comma
l_string|&quot; mcdx: Mitsumi CD-ROM installed at 0x%3p, irq %d.&quot;
l_string|&quot; (Firmware version %c %x)&bslash;n&quot;
comma
id|stuffp-&gt;wreg_data
comma
id|stuffp-&gt;irq
comma
id|version.code
comma
id|version.ver
)paren
suffix:semicolon
id|mcdx_stuffp
(braket
id|drive
)braket
op_assign
id|stuffp
suffix:semicolon
id|xtrace
c_func
(paren
id|INIT
comma
l_string|&quot;init() mcdx_stuffp[%d] = %p&bslash;n&quot;
comma
id|drive
comma
id|stuffp
)paren
suffix:semicolon
id|mcdx_info.dev
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_cdrom
c_func
(paren
op_amp
id|mcdx_info
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cannot register Mitsumi CD-ROM!&bslash;n&quot;
)paren
suffix:semicolon
id|release_region
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_data
comma
id|MCDX_IO_SIZE
)paren
suffix:semicolon
id|free_irq
c_func
(paren
id|stuffp-&gt;irq
comma
l_int|NULL
)paren
suffix:semicolon
id|kfree
c_func
(paren
id|stuffp
)paren
suffix:semicolon
r_if
c_cond
(paren
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;mcdx&quot;
)paren
op_ne
l_int|0
)paren
id|xwarn
c_func
(paren
l_string|&quot;cleanup() unregister_blkdev() failed&bslash;n&quot;
)paren
suffix:semicolon
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
r_return
l_int|2
suffix:semicolon
)brace
id|printk
c_func
(paren
id|msg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
DECL|function|mcdx_init
r_int
id|__init
id|mcdx_init
c_func
(paren
r_void
)paren
(brace
r_int
id|drive
suffix:semicolon
macro_line|#ifdef MODULE
id|xwarn
c_func
(paren
l_string|&quot;Version 2.14(hs) for &quot;
id|UTS_RELEASE
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#else
id|xwarn
c_func
(paren
l_string|&quot;Version 2.14(hs) &bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|xwarn
c_func
(paren
l_string|&quot;$Id: mcdx.c,v 1.21 1997/01/26 07:12:59 davem Exp $&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* zero the pointer array */
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|MCDX_NDRIVES
suffix:semicolon
id|drive
op_increment
)paren
id|mcdx_stuffp
(braket
id|drive
)braket
op_assign
l_int|NULL
suffix:semicolon
multiline_comment|/* do the initialisation */
r_for
c_loop
(paren
id|drive
op_assign
l_int|0
suffix:semicolon
id|drive
OL
id|MCDX_NDRIVES
suffix:semicolon
id|drive
op_increment
)paren
(brace
r_switch
c_cond
(paren
id|mcdx_init_drive
c_func
(paren
id|drive
)paren
)paren
(brace
r_case
l_int|2
suffix:colon
r_return
op_minus
id|EIO
suffix:semicolon
r_case
l_int|1
suffix:colon
r_break
suffix:semicolon
)brace
)brace
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_transfer
id|mcdx_transfer
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_char
op_star
id|p
comma
r_int
id|sector
comma
r_int
id|nr_sectors
)paren
multiline_comment|/*&t;This seems to do the actually transfer.  But it does more.  It&n;&t;keeps track of errors occurred and will (if possible) fall back&n;&t;to single speed on error.&n;&t;Return:&t;-1 on timeout or other error&n;&t;&t;&t;else status byte (as in stuff-&gt;st) */
(brace
r_int
id|ans
suffix:semicolon
id|ans
op_assign
id|mcdx_xfer
c_func
(paren
id|stuffp
comma
id|p
comma
id|sector
comma
id|nr_sectors
)paren
suffix:semicolon
r_return
id|ans
suffix:semicolon
macro_line|#if FALLBACK
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|ans
)paren
id|stuffp-&gt;readerrs
op_increment
suffix:semicolon
r_else
r_return
id|ans
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;readerrs
op_logical_and
id|stuffp-&gt;readcmd
op_eq
id|READ1X
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;XXX Already reading 1x -- no chance&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|xwarn
c_func
(paren
l_string|&quot;XXX Fallback to 1x&bslash;n&quot;
)paren
suffix:semicolon
id|stuffp-&gt;readcmd
op_assign
id|READ1X
suffix:semicolon
r_return
id|mcdx_transfer
c_func
(paren
id|stuffp
comma
id|p
comma
id|sector
comma
id|nr_sectors
)paren
suffix:semicolon
macro_line|#endif
)brace
DECL|function|mcdx_xfer
r_static
r_int
id|mcdx_xfer
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_char
op_star
id|p
comma
r_int
id|sector
comma
r_int
id|nr_sectors
)paren
multiline_comment|/*&t;This does actually the transfer from the drive.&n;&t;Return:&t;-1 on timeout or other error&n;&t;&t;&t;else status byte (as in stuff-&gt;st) */
(brace
r_int
id|border
suffix:semicolon
r_int
id|done
op_assign
l_int|0
suffix:semicolon
r_int
id|timeout
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;audio
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;Attempt to read from audio CD.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;readcmd
)paren
(brace
id|xinfo
c_func
(paren
l_string|&quot;Can&squot;t transfer from missing disk.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_while
c_loop
(paren
id|stuffp-&gt;lock
)paren
(brace
id|interruptible_sleep_on
c_func
(paren
op_amp
id|stuffp-&gt;lockq
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stuffp-&gt;valid
op_logical_and
(paren
id|sector
op_ge
id|stuffp-&gt;pending
)paren
op_logical_and
(paren
id|sector
OL
id|stuffp-&gt;low_border
)paren
)paren
(brace
multiline_comment|/* All (or at least a part of the sectors requested) seems&n;         * to be already requested, so we don&squot;t need to bother the&n;&t;&t; * drive with new requests ...&n;&t;&t; * Wait for the drive become idle, but first&n;&t;&t; * check for possible occurred errors --- the drive&n;&t;&t; * seems to report them asynchronously */
id|border
op_assign
id|stuffp-&gt;high_border
OL
(paren
id|border
op_assign
id|sector
op_plus
id|nr_sectors
)paren
ques
c_cond
id|stuffp-&gt;high_border
suffix:colon
id|border
suffix:semicolon
id|stuffp-&gt;lock
op_assign
id|current-&gt;pid
suffix:semicolon
r_do
(brace
r_while
c_loop
(paren
id|stuffp-&gt;busy
)paren
(brace
id|timeout
op_assign
id|interruptible_sleep_on_timeout
c_func
(paren
op_amp
id|stuffp-&gt;busyq
comma
l_int|5
op_star
id|HZ
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;introk
)paren
(brace
id|xtrace
c_func
(paren
id|XFER
comma
l_string|&quot;error via interrupt&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
op_logical_neg
id|timeout
)paren
(brace
id|xtrace
c_func
(paren
id|XFER
comma
l_string|&quot;timeout&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_if
c_cond
(paren
id|signal_pending
c_func
(paren
id|current
)paren
)paren
(brace
id|xtrace
c_func
(paren
id|XFER
comma
l_string|&quot;signal&bslash;n&quot;
)paren
suffix:semicolon
)brace
r_else
r_continue
suffix:semicolon
id|stuffp-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|stuffp-&gt;busy
op_assign
l_int|0
suffix:semicolon
id|stuffp-&gt;valid
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|stuffp-&gt;lockq
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|XFER
comma
l_string|&quot;transfer() done (-1)&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/* check if we need to set the busy flag (as we&n;&t;&t; * expect an interrupt */
id|stuffp-&gt;busy
op_assign
(paren
l_int|3
op_eq
(paren
id|stuffp-&gt;pending
op_amp
l_int|3
)paren
)paren
suffix:semicolon
multiline_comment|/* Test if it&squot;s the first sector of a block,&n;&t;&t; * there we have to skip some bytes as we read raw data */
r_if
c_cond
(paren
id|stuffp-&gt;xa
op_logical_and
(paren
l_int|0
op_eq
(paren
id|stuffp-&gt;pending
op_amp
l_int|3
)paren
)paren
)paren
(brace
r_const
r_int
id|HEAD
op_assign
id|CD_FRAMESIZE_RAW
op_minus
id|CD_XA_TAIL
op_minus
id|CD_FRAMESIZE
suffix:semicolon
id|insb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_data
comma
id|p
comma
id|HEAD
)paren
suffix:semicolon
)brace
multiline_comment|/* now actually read the data */
id|insb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_data
comma
id|p
comma
l_int|512
)paren
suffix:semicolon
multiline_comment|/* test if it&squot;s the last sector of a block,&n;&t;&t; * if so, we have to handle XA special */
r_if
c_cond
(paren
(paren
l_int|3
op_eq
(paren
id|stuffp-&gt;pending
op_amp
l_int|3
)paren
)paren
op_logical_and
id|stuffp-&gt;xa
)paren
(brace
r_char
id|dummy
(braket
id|CD_XA_TAIL
)braket
suffix:semicolon
id|insb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_data
comma
op_amp
id|dummy
(braket
l_int|0
)braket
comma
id|CD_XA_TAIL
)paren
suffix:semicolon
)brace
r_if
c_cond
(paren
id|stuffp-&gt;pending
op_eq
id|sector
)paren
(brace
id|p
op_add_assign
l_int|512
suffix:semicolon
id|done
op_increment
suffix:semicolon
id|sector
op_increment
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
op_increment
(paren
id|stuffp-&gt;pending
)paren
OL
id|border
)paren
suffix:semicolon
id|stuffp-&gt;lock
op_assign
l_int|0
suffix:semicolon
id|wake_up_interruptible
c_func
(paren
op_amp
id|stuffp-&gt;lockq
)paren
suffix:semicolon
)brace
r_else
(brace
multiline_comment|/* The requested sector(s) is/are out of the&n;&t;&t; * already requested range, so we have to bother the drive&n;&t;&t; * with a new request. */
r_static
r_int
r_char
id|cmd
(braket
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
id|stuffp-&gt;readcmd
suffix:semicolon
multiline_comment|/* The numbers held in -&gt;pending, ..., should be valid */
id|stuffp-&gt;valid
op_assign
l_int|1
suffix:semicolon
id|stuffp-&gt;pending
op_assign
id|sector
op_amp
op_complement
l_int|3
suffix:semicolon
multiline_comment|/* do some sanity checks */
r_if
c_cond
(paren
id|stuffp-&gt;pending
OG
id|stuffp-&gt;lastsector
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;transfer() sector %d from nirvana requested.&bslash;n&quot;
comma
id|stuffp-&gt;pending
)paren
suffix:semicolon
id|stuffp-&gt;status
op_assign
id|MCDX_ST_EOM
suffix:semicolon
id|stuffp-&gt;valid
op_assign
l_int|0
suffix:semicolon
id|xtrace
c_func
(paren
id|XFER
comma
l_string|&quot;transfer() done (-1)&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stuffp-&gt;low_border
op_assign
id|stuffp-&gt;pending
op_plus
id|DIRECT_SIZE
)paren
OG
id|stuffp-&gt;lastsector
op_plus
l_int|1
)paren
(brace
id|xtrace
c_func
(paren
id|XFER
comma
l_string|&quot;cut low_border&bslash;n&quot;
)paren
suffix:semicolon
id|stuffp-&gt;low_border
op_assign
id|stuffp-&gt;lastsector
op_plus
l_int|1
suffix:semicolon
)brace
r_if
c_cond
(paren
(paren
id|stuffp-&gt;high_border
op_assign
id|stuffp-&gt;pending
op_plus
id|REQUEST_SIZE
)paren
OG
id|stuffp-&gt;lastsector
op_plus
l_int|1
)paren
(brace
id|xtrace
c_func
(paren
id|XFER
comma
l_string|&quot;cut high_border&bslash;n&quot;
)paren
suffix:semicolon
id|stuffp-&gt;high_border
op_assign
id|stuffp-&gt;lastsector
op_plus
l_int|1
suffix:semicolon
)brace
(brace
multiline_comment|/* Convert the sector to be requested to MSF format */
r_struct
id|cdrom_msf0
id|pending
suffix:semicolon
id|log2msf
c_func
(paren
id|stuffp-&gt;pending
op_div
l_int|4
comma
op_amp
id|pending
)paren
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
id|pending.minute
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
id|pending.second
suffix:semicolon
id|cmd
(braket
l_int|3
)braket
op_assign
id|pending.frame
suffix:semicolon
)brace
id|cmd
(braket
l_int|6
)braket
op_assign
(paren
r_int
r_char
)paren
(paren
(paren
id|stuffp-&gt;high_border
op_minus
id|stuffp-&gt;pending
)paren
op_div
l_int|4
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|XFER
comma
l_string|&quot;[%2d]&bslash;n&quot;
comma
id|cmd
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|stuffp-&gt;busy
op_assign
l_int|1
suffix:semicolon
multiline_comment|/* Now really issue the request command */
id|outsb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_data
comma
id|cmd
comma
r_sizeof
id|cmd
)paren
suffix:semicolon
)brace
macro_line|#ifdef AK2
r_if
c_cond
(paren
id|stuffp-&gt;int_err
)paren
(brace
id|stuffp-&gt;valid
op_assign
l_int|0
suffix:semicolon
id|stuffp-&gt;int_err
op_assign
l_int|0
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
macro_line|#endif /* AK2 */
id|stuffp-&gt;low_border
op_assign
(paren
id|stuffp-&gt;low_border
op_add_assign
id|done
)paren
OL
id|stuffp-&gt;high_border
ques
c_cond
id|stuffp-&gt;low_border
suffix:colon
id|stuffp-&gt;high_border
suffix:semicolon
r_return
id|done
suffix:semicolon
)brace
multiline_comment|/*&t;Access to elements of the mcdx_drive_map members */
DECL|function|port
r_static
r_char
op_star
id|port
c_func
(paren
r_int
op_star
id|ip
)paren
(brace
r_return
(paren
r_char
op_star
)paren
id|ip
(braket
l_int|0
)braket
suffix:semicolon
)brace
DECL|function|irq
r_static
r_int
id|irq
c_func
(paren
r_int
op_star
id|ip
)paren
(brace
r_return
id|ip
(braket
l_int|1
)braket
suffix:semicolon
)brace
multiline_comment|/*&t;Misc number converters */
DECL|function|bcd2uint
r_static
r_int
r_int
id|bcd2uint
c_func
(paren
r_int
r_char
id|c
)paren
(brace
r_return
(paren
id|c
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|c
op_amp
l_int|0x0f
)paren
suffix:semicolon
)brace
DECL|function|uint2bcd
r_static
r_int
r_int
id|uint2bcd
c_func
(paren
r_int
r_int
id|ival
)paren
(brace
r_return
(paren
(paren
id|ival
op_div
l_int|10
)paren
op_lshift
l_int|4
)paren
op_or
(paren
id|ival
op_mod
l_int|10
)paren
suffix:semicolon
)brace
DECL|function|log2msf
r_static
r_void
id|log2msf
c_func
(paren
r_int
r_int
id|l
comma
r_struct
id|cdrom_msf0
op_star
id|pmsf
)paren
(brace
id|l
op_add_assign
id|CD_MSF_OFFSET
suffix:semicolon
id|pmsf-&gt;minute
op_assign
id|uint2bcd
c_func
(paren
id|l
op_div
l_int|4500
)paren
comma
id|l
op_mod_assign
l_int|4500
suffix:semicolon
id|pmsf-&gt;second
op_assign
id|uint2bcd
c_func
(paren
id|l
op_div
l_int|75
)paren
suffix:semicolon
id|pmsf-&gt;frame
op_assign
id|uint2bcd
c_func
(paren
id|l
op_mod
l_int|75
)paren
suffix:semicolon
)brace
DECL|function|msf2log
r_static
r_int
r_int
id|msf2log
c_func
(paren
r_const
r_struct
id|cdrom_msf0
op_star
id|pmsf
)paren
(brace
r_return
id|bcd2uint
c_func
(paren
id|pmsf-&gt;frame
)paren
op_plus
id|bcd2uint
c_func
(paren
id|pmsf-&gt;second
)paren
op_star
l_int|75
op_plus
id|bcd2uint
c_func
(paren
id|pmsf-&gt;minute
)paren
op_star
l_int|4500
op_minus
id|CD_MSF_OFFSET
suffix:semicolon
)brace
DECL|function|mcdx_readtoc
r_int
id|mcdx_readtoc
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
)paren
multiline_comment|/*  Read the toc entries from the CD,&n; *  Return: -1 on failure, else 0 */
(brace
r_if
c_cond
(paren
id|stuffp-&gt;toc
)paren
(brace
id|xtrace
c_func
(paren
id|READTOC
comma
l_string|&quot;ioctl() toc already read&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|xtrace
c_func
(paren
id|READTOC
comma
l_string|&quot;ioctl() readtoc for %d tracks&bslash;n&quot;
comma
id|stuffp-&gt;di.n_last
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|1
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_hold
c_func
(paren
id|stuffp
comma
l_int|1
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|xtrace
c_func
(paren
id|READTOC
comma
l_string|&quot;ioctl() tocmode&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_setdrivemode
c_func
(paren
id|stuffp
comma
id|TOC
comma
l_int|1
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* all seems to be ok so far ... malloc */
(brace
r_int
id|size
suffix:semicolon
id|size
op_assign
r_sizeof
(paren
r_struct
id|s_subqcode
)paren
op_star
(paren
id|stuffp-&gt;di.n_last
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|2
)paren
suffix:semicolon
id|xtrace
c_func
(paren
id|MALLOC
comma
l_string|&quot;ioctl() malloc %d bytes&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
id|stuffp-&gt;toc
op_assign
id|kmalloc
c_func
(paren
id|size
comma
id|GFP_KERNEL
)paren
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;toc
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;Cannot malloc %d bytes for toc&bslash;n&quot;
comma
id|size
)paren
suffix:semicolon
id|mcdx_setdrivemode
c_func
(paren
id|stuffp
comma
id|DATA
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
)brace
multiline_comment|/* now read actually the index */
(brace
r_int
id|trk
suffix:semicolon
r_int
id|retries
suffix:semicolon
r_for
c_loop
(paren
id|trk
op_assign
l_int|0
suffix:semicolon
id|trk
OL
(paren
id|stuffp-&gt;di.n_last
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|1
)paren
suffix:semicolon
id|trk
op_increment
)paren
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|index
op_assign
l_int|0
suffix:semicolon
r_for
c_loop
(paren
id|retries
op_assign
l_int|300
suffix:semicolon
id|retries
suffix:semicolon
id|retries
op_decrement
)paren
(brace
multiline_comment|/* why 300? */
r_struct
id|s_subqcode
id|q
suffix:semicolon
r_int
r_int
id|idx
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_requestsubqcode
c_func
(paren
id|stuffp
comma
op_amp
id|q
comma
l_int|1
)paren
)paren
(brace
id|mcdx_setdrivemode
c_func
(paren
id|stuffp
comma
id|DATA
comma
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|idx
op_assign
id|bcd2uint
c_func
(paren
id|q.index
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|idx
OG
l_int|0
)paren
op_logical_and
(paren
id|idx
op_le
id|stuffp-&gt;di.n_last
)paren
op_logical_and
(paren
id|q.tno
op_eq
l_int|0
)paren
op_logical_and
(paren
id|stuffp-&gt;toc
(braket
id|idx
op_minus
id|stuffp-&gt;di.n_first
)braket
dot
id|index
op_eq
l_int|0
)paren
)paren
(brace
id|stuffp-&gt;toc
(braket
id|idx
op_minus
id|stuffp-&gt;di.n_first
)braket
op_assign
id|q
suffix:semicolon
id|xtrace
c_func
(paren
id|READTOC
comma
l_string|&quot;ioctl() toc idx %d (trk %d)&bslash;n&quot;
comma
id|idx
comma
id|trk
)paren
suffix:semicolon
id|trk
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|trk
op_eq
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|memset
c_func
(paren
op_amp
id|stuffp-&gt;toc
(braket
id|stuffp-&gt;di.n_last
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|1
)braket
comma
l_int|0
comma
r_sizeof
(paren
id|stuffp-&gt;toc
(braket
l_int|0
)braket
)paren
)paren
suffix:semicolon
id|stuffp-&gt;toc
(braket
id|stuffp-&gt;di.n_last
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|1
)braket
dot
id|dt
op_assign
id|stuffp-&gt;di.msf_leadout
suffix:semicolon
)brace
multiline_comment|/* unset toc mode */
id|xtrace
c_func
(paren
id|READTOC
comma
l_string|&quot;ioctl() undo toc mode&bslash;n&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_setdrivemode
c_func
(paren
id|stuffp
comma
id|DATA
comma
l_int|2
)paren
)paren
r_return
op_minus
id|EIO
suffix:semicolon
macro_line|#if MCDX_DEBUG &amp;&amp; READTOC
(brace
r_int
id|trk
suffix:semicolon
r_for
c_loop
(paren
id|trk
op_assign
l_int|0
suffix:semicolon
id|trk
OL
(paren
id|stuffp-&gt;di.n_last
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|2
)paren
suffix:semicolon
id|trk
op_increment
)paren
id|xtrace
c_func
(paren
id|READTOC
comma
l_string|&quot;ioctl() %d readtoc %02x %02x %02x&quot;
l_string|&quot;  %02x:%02x.%02x  %02x:%02x.%02x&bslash;n&quot;
comma
id|trk
op_plus
id|stuffp-&gt;di.n_first
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|control
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|tno
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|index
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|tt.minute
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|tt.second
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|tt.frame
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|dt.minute
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|dt.second
comma
id|stuffp-&gt;toc
(braket
id|trk
)braket
dot
id|dt.frame
)paren
suffix:semicolon
)brace
macro_line|#endif
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_playmsf
id|mcdx_playmsf
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_const
r_struct
id|cdrom_msf
op_star
id|msf
)paren
(brace
r_int
r_char
id|cmd
(braket
l_int|7
)braket
op_assign
(brace
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
comma
l_int|0
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;readcmd
)paren
(brace
id|xinfo
c_func
(paren
l_string|&quot;Can&squot;t play from missing disk.&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|cmd
(braket
l_int|0
)braket
op_assign
id|stuffp-&gt;playcmd
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
id|msf-&gt;cdmsf_min0
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
id|msf-&gt;cdmsf_sec0
suffix:semicolon
id|cmd
(braket
l_int|3
)braket
op_assign
id|msf-&gt;cdmsf_frame0
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
id|msf-&gt;cdmsf_min1
suffix:semicolon
id|cmd
(braket
l_int|5
)braket
op_assign
id|msf-&gt;cdmsf_sec1
suffix:semicolon
id|cmd
(braket
l_int|6
)braket
op_assign
id|msf-&gt;cdmsf_frame1
suffix:semicolon
id|xtrace
c_func
(paren
id|PLAYMSF
comma
l_string|&quot;ioctl(): play %x &quot;
l_string|&quot;%02x:%02x:%02x -- %02x:%02x:%02x&bslash;n&quot;
comma
id|cmd
(braket
l_int|0
)braket
comma
id|cmd
(braket
l_int|1
)braket
comma
id|cmd
(braket
l_int|2
)braket
comma
id|cmd
(braket
l_int|3
)braket
comma
id|cmd
(braket
l_int|4
)braket
comma
id|cmd
(braket
l_int|5
)braket
comma
id|cmd
(braket
l_int|6
)braket
)paren
suffix:semicolon
id|outsb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_data
comma
id|cmd
comma
r_sizeof
id|cmd
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_getval
c_func
(paren
id|stuffp
comma
l_int|3
op_star
id|HZ
comma
l_int|0
comma
l_int|NULL
)paren
)paren
(brace
id|xwarn
c_func
(paren
l_string|&quot;playmsf() timeout&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|stuffp-&gt;audiostatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_playtrk
id|mcdx_playtrk
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_const
r_struct
id|cdrom_ti
op_star
id|ti
)paren
(brace
r_struct
id|s_subqcode
op_star
id|p
suffix:semicolon
r_struct
id|cdrom_msf
id|msf
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_readtoc
c_func
(paren
id|stuffp
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|ti
)paren
id|p
op_assign
op_amp
id|stuffp-&gt;toc
(braket
id|ti-&gt;cdti_trk0
op_minus
id|stuffp-&gt;di.n_first
)braket
suffix:semicolon
r_else
id|p
op_assign
op_amp
id|stuffp-&gt;start
suffix:semicolon
id|msf.cdmsf_min0
op_assign
id|p-&gt;dt.minute
suffix:semicolon
id|msf.cdmsf_sec0
op_assign
id|p-&gt;dt.second
suffix:semicolon
id|msf.cdmsf_frame0
op_assign
id|p-&gt;dt.frame
suffix:semicolon
r_if
c_cond
(paren
id|ti
)paren
(brace
id|p
op_assign
op_amp
id|stuffp-&gt;toc
(braket
id|ti-&gt;cdti_trk1
op_minus
id|stuffp-&gt;di.n_first
op_plus
l_int|1
)braket
suffix:semicolon
id|stuffp-&gt;stop
op_assign
op_star
id|p
suffix:semicolon
)brace
r_else
id|p
op_assign
op_amp
id|stuffp-&gt;stop
suffix:semicolon
id|msf.cdmsf_min1
op_assign
id|p-&gt;dt.minute
suffix:semicolon
id|msf.cdmsf_sec1
op_assign
id|p-&gt;dt.second
suffix:semicolon
id|msf.cdmsf_frame1
op_assign
id|p-&gt;dt.frame
suffix:semicolon
r_return
id|mcdx_playmsf
c_func
(paren
id|stuffp
comma
op_amp
id|msf
)paren
suffix:semicolon
)brace
multiline_comment|/* Drive functions ************************************************/
r_static
r_int
DECL|function|mcdx_tray_move
id|mcdx_tray_move
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|position
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|cdi-&gt;dev
)paren
)braket
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|stuffp-&gt;present
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|stuffp-&gt;present
op_amp
id|DOOR
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
id|position
)paren
multiline_comment|/* 1: eject */
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;xf6&quot;
comma
l_int|1
comma
l_int|NULL
comma
l_int|1
comma
l_int|5
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
r_else
multiline_comment|/* 0: close */
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;xf8&quot;
comma
l_int|1
comma
l_int|NULL
comma
l_int|1
comma
l_int|5
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
r_return
l_int|1
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_stop
id|mcdx_stop
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_int
id|tries
)paren
(brace
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;xf0&quot;
comma
l_int|1
comma
l_int|NULL
comma
l_int|1
comma
l_int|2
op_star
id|HZ
comma
id|tries
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_hold
id|mcdx_hold
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_int
id|tries
)paren
(brace
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;x70&quot;
comma
l_int|1
comma
l_int|NULL
comma
l_int|1
comma
l_int|2
op_star
id|HZ
comma
id|tries
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_requestsubqcode
id|mcdx_requestsubqcode
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_struct
id|s_subqcode
op_star
id|sub
comma
r_int
id|tries
)paren
(brace
r_char
id|buf
(braket
l_int|11
)braket
suffix:semicolon
r_int
id|ans
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
id|ans
op_assign
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;x20&quot;
comma
l_int|1
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_int|2
op_star
id|HZ
comma
id|tries
)paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|sub-&gt;control
op_assign
id|buf
(braket
l_int|1
)braket
suffix:semicolon
id|sub-&gt;tno
op_assign
id|buf
(braket
l_int|2
)braket
suffix:semicolon
id|sub-&gt;index
op_assign
id|buf
(braket
l_int|3
)braket
suffix:semicolon
id|sub-&gt;tt.minute
op_assign
id|buf
(braket
l_int|4
)braket
suffix:semicolon
id|sub-&gt;tt.second
op_assign
id|buf
(braket
l_int|5
)braket
suffix:semicolon
id|sub-&gt;tt.frame
op_assign
id|buf
(braket
l_int|6
)braket
suffix:semicolon
id|sub-&gt;dt.minute
op_assign
id|buf
(braket
l_int|8
)braket
suffix:semicolon
id|sub-&gt;dt.second
op_assign
id|buf
(braket
l_int|9
)braket
suffix:semicolon
id|sub-&gt;dt.frame
op_assign
id|buf
(braket
l_int|10
)braket
suffix:semicolon
r_return
id|ans
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_requestmultidiskinfo
id|mcdx_requestmultidiskinfo
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_struct
id|s_multi
op_star
id|multi
comma
r_int
id|tries
)paren
(brace
r_char
id|buf
(braket
l_int|5
)braket
suffix:semicolon
r_int
id|ans
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;present
op_amp
id|MULTI
)paren
(brace
id|ans
op_assign
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;x11&quot;
comma
l_int|1
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_int|2
op_star
id|HZ
comma
id|tries
)paren
suffix:semicolon
id|multi-&gt;multi
op_assign
id|buf
(braket
l_int|1
)braket
suffix:semicolon
id|multi-&gt;msf_last.minute
op_assign
id|buf
(braket
l_int|2
)braket
suffix:semicolon
id|multi-&gt;msf_last.second
op_assign
id|buf
(braket
l_int|3
)braket
suffix:semicolon
id|multi-&gt;msf_last.frame
op_assign
id|buf
(braket
l_int|4
)braket
suffix:semicolon
r_return
id|ans
suffix:semicolon
)brace
r_else
(brace
id|multi-&gt;multi
op_assign
l_int|0
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
)brace
r_static
r_int
DECL|function|mcdx_requesttocdata
id|mcdx_requesttocdata
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_struct
id|s_diskinfo
op_star
id|info
comma
r_int
id|tries
)paren
(brace
r_char
id|buf
(braket
l_int|9
)braket
suffix:semicolon
r_int
id|ans
suffix:semicolon
id|ans
op_assign
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;x10&quot;
comma
l_int|1
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_int|2
op_star
id|HZ
comma
id|tries
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ans
op_eq
op_minus
l_int|1
)paren
(brace
id|info-&gt;n_first
op_assign
l_int|0
suffix:semicolon
id|info-&gt;n_last
op_assign
l_int|0
suffix:semicolon
)brace
r_else
(brace
id|info-&gt;n_first
op_assign
id|bcd2uint
c_func
(paren
id|buf
(braket
l_int|1
)braket
)paren
suffix:semicolon
id|info-&gt;n_last
op_assign
id|bcd2uint
c_func
(paren
id|buf
(braket
l_int|2
)braket
)paren
suffix:semicolon
id|info-&gt;msf_leadout.minute
op_assign
id|buf
(braket
l_int|3
)braket
suffix:semicolon
id|info-&gt;msf_leadout.second
op_assign
id|buf
(braket
l_int|4
)braket
suffix:semicolon
id|info-&gt;msf_leadout.frame
op_assign
id|buf
(braket
l_int|5
)braket
suffix:semicolon
id|info-&gt;msf_first.minute
op_assign
id|buf
(braket
l_int|6
)braket
suffix:semicolon
id|info-&gt;msf_first.second
op_assign
id|buf
(braket
l_int|7
)braket
suffix:semicolon
id|info-&gt;msf_first.frame
op_assign
id|buf
(braket
l_int|8
)braket
suffix:semicolon
)brace
r_return
id|ans
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_setdrivemode
id|mcdx_setdrivemode
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_enum
id|drivemodes
id|mode
comma
r_int
id|tries
)paren
(brace
r_char
id|cmd
(braket
l_int|2
)braket
suffix:semicolon
r_int
id|ans
suffix:semicolon
id|xtrace
c_func
(paren
id|HW
comma
l_string|&quot;setdrivemode() %d&bslash;n&quot;
comma
id|mode
)paren
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
id|ans
op_assign
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;xc2&quot;
comma
l_int|1
comma
id|cmd
comma
r_sizeof
(paren
id|cmd
)paren
comma
l_int|5
op_star
id|HZ
comma
id|tries
)paren
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|TOC
suffix:colon
id|cmd
(braket
l_int|1
)braket
op_or_assign
l_int|0x04
suffix:semicolon
r_break
suffix:semicolon
r_case
id|DATA
suffix:colon
id|cmd
(braket
l_int|1
)braket
op_and_assign
op_complement
l_int|0x04
suffix:semicolon
r_break
suffix:semicolon
r_case
id|RAW
suffix:colon
id|cmd
(braket
l_int|1
)braket
op_or_assign
l_int|0x40
suffix:semicolon
r_break
suffix:semicolon
r_case
id|COOKED
suffix:colon
id|cmd
(braket
l_int|1
)braket
op_and_assign
op_complement
l_int|0x40
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_break
suffix:semicolon
)brace
id|cmd
(braket
l_int|0
)braket
op_assign
l_int|0x50
suffix:semicolon
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
id|cmd
comma
l_int|2
comma
l_int|NULL
comma
l_int|1
comma
l_int|5
op_star
id|HZ
comma
id|tries
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_setdatamode
id|mcdx_setdatamode
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_enum
id|datamodes
id|mode
comma
r_int
id|tries
)paren
(brace
r_int
r_char
id|cmd
(braket
l_int|2
)braket
op_assign
(brace
l_int|0xa0
)brace
suffix:semicolon
id|xtrace
c_func
(paren
id|HW
comma
l_string|&quot;setdatamode() %d&bslash;n&quot;
comma
id|mode
)paren
suffix:semicolon
r_switch
c_cond
(paren
id|mode
)paren
(brace
r_case
id|MODE0
suffix:colon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|0x00
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODE1
suffix:colon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|0x01
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MODE2
suffix:colon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|0x02
suffix:semicolon
r_break
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
id|cmd
comma
l_int|2
comma
l_int|NULL
comma
l_int|1
comma
l_int|5
op_star
id|HZ
comma
id|tries
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_config
id|mcdx_config
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_int
id|tries
)paren
(brace
r_char
id|cmd
(braket
l_int|4
)braket
suffix:semicolon
id|xtrace
c_func
(paren
id|HW
comma
l_string|&quot;config()&bslash;n&quot;
)paren
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
l_int|0x90
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|0x10
suffix:semicolon
multiline_comment|/* irq enable */
id|cmd
(braket
l_int|2
)braket
op_assign
l_int|0x05
suffix:semicolon
multiline_comment|/* pre, err irq enable */
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
id|mcdx_talk
c_func
(paren
id|stuffp
comma
id|cmd
comma
l_int|3
comma
l_int|NULL
comma
l_int|1
comma
l_int|1
op_star
id|HZ
comma
id|tries
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
l_int|0x02
suffix:semicolon
multiline_comment|/* dma select */
id|cmd
(braket
l_int|2
)braket
op_assign
l_int|0x00
suffix:semicolon
multiline_comment|/* no dma */
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
id|cmd
comma
l_int|3
comma
l_int|NULL
comma
l_int|1
comma
l_int|1
op_star
id|HZ
comma
id|tries
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_requestversion
id|mcdx_requestversion
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_struct
id|s_version
op_star
id|ver
comma
r_int
id|tries
)paren
(brace
r_char
id|buf
(braket
l_int|3
)braket
suffix:semicolon
r_int
id|ans
suffix:semicolon
r_if
c_cond
(paren
op_minus
l_int|1
op_eq
(paren
id|ans
op_assign
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;xdc&quot;
comma
l_int|1
comma
id|buf
comma
r_sizeof
(paren
id|buf
)paren
comma
l_int|2
op_star
id|HZ
comma
id|tries
)paren
)paren
)paren
r_return
id|ans
suffix:semicolon
id|ver-&gt;code
op_assign
id|buf
(braket
l_int|1
)braket
suffix:semicolon
id|ver-&gt;ver
op_assign
id|buf
(braket
l_int|2
)braket
suffix:semicolon
r_return
id|ans
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_reset
id|mcdx_reset
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_enum
id|resetmodes
id|mode
comma
r_int
id|tries
)paren
(brace
r_if
c_cond
(paren
id|mode
op_eq
id|HARD
)paren
(brace
id|outb
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_chn
)paren
suffix:semicolon
multiline_comment|/* no dma, no irq -&gt; hardware */
id|outb
c_func
(paren
l_int|0
comma
(paren
r_int
r_int
)paren
id|stuffp-&gt;wreg_reset
)paren
suffix:semicolon
multiline_comment|/* hw reset */
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;x60&quot;
comma
l_int|1
comma
l_int|NULL
comma
l_int|1
comma
l_int|5
op_star
id|HZ
comma
id|tries
)paren
suffix:semicolon
)brace
DECL|function|mcdx_lockdoor
r_static
r_int
id|mcdx_lockdoor
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|lock
)paren
(brace
r_struct
id|s_drive_stuff
op_star
id|stuffp
op_assign
id|mcdx_stuffp
(braket
id|MINOR
c_func
(paren
id|cdi-&gt;dev
)paren
)braket
suffix:semicolon
r_char
id|cmd
(braket
l_int|2
)braket
op_assign
(brace
l_int|0xfe
)brace
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
(paren
id|stuffp-&gt;present
op_amp
id|DOOR
)paren
)paren
r_return
op_minus
id|ENOSYS
suffix:semicolon
r_if
c_cond
(paren
id|stuffp-&gt;present
op_amp
id|DOOR
)paren
(brace
id|cmd
(braket
l_int|1
)braket
op_assign
id|lock
ques
c_cond
l_int|0x01
suffix:colon
l_int|0x00
suffix:semicolon
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
id|cmd
comma
r_sizeof
(paren
id|cmd
)paren
comma
l_int|NULL
comma
l_int|1
comma
l_int|5
op_star
id|HZ
comma
l_int|3
)paren
suffix:semicolon
)brace
r_else
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_getstatus
id|mcdx_getstatus
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_int
id|tries
)paren
(brace
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
l_string|&quot;&bslash;x40&quot;
comma
l_int|1
comma
l_int|NULL
comma
l_int|1
comma
l_int|5
op_star
id|HZ
comma
id|tries
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_getval
id|mcdx_getval
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_int
id|to
comma
r_int
id|delay
comma
r_char
op_star
id|buf
)paren
(brace
r_int
r_int
id|timeout
op_assign
id|to
op_plus
id|jiffies
suffix:semicolon
r_char
id|c
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|buf
)paren
id|buf
op_assign
op_amp
id|c
suffix:semicolon
r_while
c_loop
(paren
id|inb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_status
)paren
op_amp
id|MCDX_RBIT_STEN
)paren
(brace
r_if
c_cond
(paren
id|time_after
c_func
(paren
id|jiffies
comma
id|timeout
)paren
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|mcdx_delay
c_func
(paren
id|stuffp
comma
id|delay
)paren
suffix:semicolon
)brace
op_star
id|buf
op_assign
(paren
r_int
r_char
)paren
id|inb
c_func
(paren
(paren
r_int
r_int
)paren
id|stuffp-&gt;rreg_data
)paren
op_amp
l_int|0xff
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcdx_setattentuator
id|mcdx_setattentuator
c_func
(paren
r_struct
id|s_drive_stuff
op_star
id|stuffp
comma
r_struct
id|cdrom_volctrl
op_star
id|vol
comma
r_int
id|tries
)paren
(brace
r_char
id|cmd
(braket
l_int|5
)braket
suffix:semicolon
id|cmd
(braket
l_int|0
)braket
op_assign
l_int|0xae
suffix:semicolon
id|cmd
(braket
l_int|1
)braket
op_assign
id|vol-&gt;channel0
suffix:semicolon
id|cmd
(braket
l_int|2
)braket
op_assign
l_int|0
suffix:semicolon
id|cmd
(braket
l_int|3
)braket
op_assign
id|vol-&gt;channel1
suffix:semicolon
id|cmd
(braket
l_int|4
)braket
op_assign
l_int|0
suffix:semicolon
r_return
id|mcdx_talk
c_func
(paren
id|stuffp
comma
id|cmd
comma
r_sizeof
(paren
id|cmd
)paren
comma
l_int|NULL
comma
l_int|5
comma
l_int|200
comma
id|tries
)paren
suffix:semicolon
)brace
multiline_comment|/* ex:set ts=4 sw=4 ai si: */
eof
