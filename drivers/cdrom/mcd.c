multiline_comment|/*&n;&t;linux/kernel/blk_drv/mcd.c - Mitsumi CDROM driver&n;&n;&t;Copyright (C) 1992  Martin Harriss&n;&n;&t;martin@bdsi.com (no longer valid - where are you now, Martin?)&n;&n;&t;This program is free software; you can redistribute it and/or modify&n;&t;it under the terms of the GNU General Public License as published by&n;&t;the Free Software Foundation; either version 2, or (at your option)&n;&t;any later version.&n;&n;&t;This program is distributed in the hope that it will be useful,&n;&t;but WITHOUT ANY WARRANTY; without even the implied warranty of&n;&t;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the&n;&t;GNU General Public License for more details.&n;&n;&t;You should have received a copy of the GNU General Public License&n;&t;along with this program; if not, write to the Free Software&n;&t;Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.&n;&n;&t;HISTORY&n;&n;&t;0.1&t;First attempt - internal use only&n;&t;0.2&t;Cleaned up delays and use of timer - alpha release&n;&t;0.3&t;Audio support added&n;&t;0.3.1 Changes for mitsumi CRMC LU005S march version&n;&t;&t;   (stud11@cc4.kuleuven.ac.be)&n;        0.3.2 bug fixes to the ioctls and merged with ALPHA0.99-pl12&n;&t;&t;   (Jon Tombs &lt;jon@robots.ox.ac.uk&gt;)&n;        0.3.3 Added more #defines and mcd_setup()&n;   &t;&t;   (Jon Tombs &lt;jon@gtex02.us.es&gt;)&n;&n;&t;October 1993 Bernd Huebner and Ruediger Helsch, Unifix Software GmbH,&n;&t;Braunschweig, Germany: rework to speed up data read operation.&n;&t;Also enabled definition of irq and address from bootstrap, using the&n;&t;environment.&n;&t;November 93 added code for FX001 S,D (single &amp; double speed).&n;&t;February 94 added code for broken M 5/6 series of 16-bit single speed.&n;&n;&n;        0.4   &n;        Added support for loadable MODULEs, so mcd can now also be loaded by &n;        insmod and removed by rmmod during runtime.&n;        Werner Zimmermann (zimmerma@rz.fht-esslingen.de), Mar. 26, 95&n;&n;&t;0.5&n;&t;I added code for FX001 D to drop from double speed to single speed &n;&t;when encountering errors... this helps with some &quot;problematic&quot; CD&squot;s&n;&t;that are supposedly &quot;OUT OF TOLERANCE&quot; (but are really shitty presses!)&n;&t;severely scratched, or possibly slightly warped! I have noticed that&n;&t;the Mitsumi 2x/4x drives are just less tolerant and the firmware is &n;&t;not smart enough to drop speed,&t;so let&squot;s just kludge it with software!&n;&t;****** THE 4X SPEED MITSUMI DRIVES HAVE THE SAME PROBLEM!!!!!! ******&n;&t;Anyone want to &quot;DONATE&quot; one to me?! ;) I hear sometimes they are&n;&t;even WORSE! ;)&n;&t;** HINT... HINT... TAKE NOTES MITSUMI This could save some hassles with&n;&t;certain &quot;large&quot; CD&squot;s that have data on the outside edge in your &n;&t;DOS DRIVERS .... Accuracy counts... speed is secondary ;)&n;&t;17 June 95 Modifications By Andrew J. Kroll &lt;ag784@freenet.buffalo.edu&gt;&n;&t;07 July 1995 Modifications by Andrew J. Kroll&n;&n;&t;Bjorn Ekwall &lt;bj0rn@blox.se&gt; added unregister_blkdev to mcd_init()&n;&n;&t;Michael K. Johnson &lt;johnsonm@redhat.com&gt; added retries on open&n;&t;for slow drives which take a while to recognize that they contain&n;&t;a CD.&n;&n;&t;November 1997 -- ported to the Uniform CD-ROM driver by Erik Andersen.&n;&t;March    1999 -- made io base and irq CONFIG_ options (Tigran Aivazian).&n;&t;&n;&t;November 1999 -- Make kernel-parameter implementation work with 2.3.x &n;&t;                 Removed init_module &amp; cleanup_module in favor of &n;&t;&t;&t; module_init &amp; module_exit.&n;&t;&t;&t; Torben Mathiasen &lt;tmm@image.dk&gt;&n;&t;&t;&n;&t;&t;&t; &n;*/
macro_line|#include &lt;linux/module.h&gt;
macro_line|#include &lt;linux/errno.h&gt;
macro_line|#include &lt;linux/signal.h&gt;
macro_line|#include &lt;linux/sched.h&gt;
macro_line|#include &lt;linux/mm.h&gt;
macro_line|#include &lt;linux/timer.h&gt;
macro_line|#include &lt;linux/fs.h&gt;
macro_line|#include &lt;linux/kernel.h&gt;
macro_line|#include &lt;linux/devfs_fs_kernel.h&gt;
macro_line|#include &lt;linux/cdrom.h&gt;
macro_line|#include &lt;linux/ioport.h&gt;
macro_line|#include &lt;linux/string.h&gt;
macro_line|#include &lt;linux/delay.h&gt;
macro_line|#include &lt;linux/init.h&gt;
macro_line|#include &lt;linux/config.h&gt;
multiline_comment|/* #define REALLY_SLOW_IO  */
macro_line|#include &lt;asm/system.h&gt;
macro_line|#include &lt;asm/io.h&gt;
macro_line|#include &lt;asm/uaccess.h&gt;
DECL|macro|MAJOR_NR
mdefine_line|#define MAJOR_NR MITSUMI_CDROM_MAJOR
macro_line|#include &lt;linux/blk.h&gt;
DECL|macro|mcd_port
mdefine_line|#define mcd_port mcd    /* for compatible parameter passing with &quot;insmod&quot; */
macro_line|#include &quot;mcd.h&quot;
DECL|variable|mcd_blocksizes
r_static
r_int
id|mcd_blocksizes
(braket
l_int|1
)braket
op_assign
(brace
l_int|0
comma
)brace
suffix:semicolon
multiline_comment|/* I added A flag to drop to 1x speed if too many errors 0 = 1X ; 1 = 2X */
DECL|variable|mcdDouble
r_static
r_int
id|mcdDouble
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* How many sectors to hold at 1x speed counter */
DECL|variable|mcd1xhold
r_static
r_int
id|mcd1xhold
op_assign
l_int|0
suffix:semicolon
multiline_comment|/* Is the drive connected properly and responding?? */
DECL|variable|mcdPresent
r_static
r_int
id|mcdPresent
op_assign
l_int|0
suffix:semicolon
macro_line|#if 0
mdefine_line|#define TEST1 /* &lt;int-..&gt; */
mdefine_line|#define TEST2 /* do_mcd_req */
mdefine_line|#define TEST3 */ /* MCD_S_state */
mdefine_line|#define TEST4 /* QUICK_LOOP-counter */
mdefine_line|#define TEST5 */ /* port(1) state */
macro_line|#endif
macro_line|#if 1
DECL|macro|QUICK_LOOP_DELAY
mdefine_line|#define QUICK_LOOP_DELAY udelay(45)  /* use udelay */
DECL|macro|QUICK_LOOP_COUNT
mdefine_line|#define QUICK_LOOP_COUNT 20
macro_line|#else
DECL|macro|QUICK_LOOP_DELAY
mdefine_line|#define QUICK_LOOP_DELAY
DECL|macro|QUICK_LOOP_COUNT
mdefine_line|#define QUICK_LOOP_COUNT 140 /* better wait constant time */
macro_line|#endif
multiline_comment|/* #define DOUBLE_QUICK_ONLY */
DECL|macro|CURRENT_VALID
mdefine_line|#define CURRENT_VALID &bslash;&n;(!QUEUE_EMPTY &amp;&amp; MAJOR(CURRENT -&gt; rq_dev) == MAJOR_NR &amp;&amp; CURRENT -&gt; cmd == READ &bslash;&n;&amp;&amp; CURRENT -&gt; sector != -1)
DECL|macro|MFL_STATUSorDATA
mdefine_line|#define MFL_STATUSorDATA (MFL_STATUS | MFL_DATA)
DECL|macro|MCD_BUF_SIZ
mdefine_line|#define MCD_BUF_SIZ 16
DECL|variable|mcd_transfer_is_active
r_static
r_volatile
r_int
id|mcd_transfer_is_active
suffix:semicolon
DECL|variable|mcd_buf
r_static
r_char
id|mcd_buf
(braket
l_int|2048
op_star
id|MCD_BUF_SIZ
)braket
suffix:semicolon
multiline_comment|/* buffer for block size conversion */
DECL|variable|mcd_buf_bn
DECL|variable|mcd_next_bn
r_static
r_volatile
r_int
id|mcd_buf_bn
(braket
id|MCD_BUF_SIZ
)braket
comma
id|mcd_next_bn
suffix:semicolon
DECL|variable|mcd_buf_in
DECL|variable|mcd_buf_out
r_static
r_volatile
r_int
id|mcd_buf_in
comma
id|mcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|mcd_error
r_static
r_volatile
r_int
id|mcd_error
suffix:semicolon
DECL|variable|mcd_open_count
r_static
r_int
id|mcd_open_count
suffix:semicolon
DECL|enum|mcd_state_e
r_enum
id|mcd_state_e
(brace
DECL|enumerator|MCD_S_IDLE
id|MCD_S_IDLE
comma
multiline_comment|/* 0 */
DECL|enumerator|MCD_S_START
id|MCD_S_START
comma
multiline_comment|/* 1 */
DECL|enumerator|MCD_S_MODE
id|MCD_S_MODE
comma
multiline_comment|/* 2 */
DECL|enumerator|MCD_S_READ
id|MCD_S_READ
comma
multiline_comment|/* 3 */
DECL|enumerator|MCD_S_DATA
id|MCD_S_DATA
comma
multiline_comment|/* 4 */
DECL|enumerator|MCD_S_STOP
id|MCD_S_STOP
comma
multiline_comment|/* 5 */
DECL|enumerator|MCD_S_STOPPING
id|MCD_S_STOPPING
multiline_comment|/* 6 */
)brace
suffix:semicolon
DECL|variable|mcd_state
r_static
r_volatile
r_enum
id|mcd_state_e
id|mcd_state
op_assign
id|MCD_S_IDLE
suffix:semicolon
DECL|variable|mcd_mode
r_static
r_int
id|mcd_mode
op_assign
op_minus
l_int|1
suffix:semicolon
DECL|variable|MCMD_DATA_READ
r_static
r_int
id|MCMD_DATA_READ
op_assign
id|MCMD_PLAY_READ
suffix:semicolon
DECL|macro|READ_TIMEOUT
mdefine_line|#define READ_TIMEOUT 3000
DECL|macro|WORK_AROUND_MITSUMI_BUG_92
mdefine_line|#define WORK_AROUND_MITSUMI_BUG_92
DECL|macro|WORK_AROUND_MITSUMI_BUG_93
mdefine_line|#define WORK_AROUND_MITSUMI_BUG_93
macro_line|#ifdef WORK_AROUND_MITSUMI_BUG_93
DECL|variable|mitsumi_bug_93_wait
r_int
id|mitsumi_bug_93_wait
op_assign
l_int|0
suffix:semicolon
macro_line|#endif /* WORK_AROUND_MITSUMI_BUG_93 */
DECL|variable|mcd_port
r_static
r_int
id|mcd_port
op_assign
id|CONFIG_MCD_BASE
suffix:semicolon
multiline_comment|/* used as &quot;mcd&quot; by &quot;insmod&quot; */
DECL|variable|mcd_irq
r_static
r_int
id|mcd_irq
op_assign
id|CONFIG_MCD_IRQ
suffix:semicolon
multiline_comment|/* must directly follow mcd_port */
id|MODULE_PARM
c_func
(paren
id|mcd
comma
l_string|&quot;1-2i&quot;
)paren
suffix:semicolon
DECL|variable|McdTimeout
DECL|variable|McdTries
r_static
r_int
id|McdTimeout
comma
id|McdTries
suffix:semicolon
r_static
id|DECLARE_WAIT_QUEUE_HEAD
c_func
(paren
id|mcd_waitq
)paren
suffix:semicolon
DECL|variable|DiskInfo
r_static
r_struct
id|mcd_DiskInfo
id|DiskInfo
suffix:semicolon
DECL|variable|Toc
r_static
r_struct
id|mcd_Toc
id|Toc
(braket
id|MAX_TRACKS
)braket
suffix:semicolon
DECL|variable|mcd_Play
r_static
r_struct
id|mcd_Play_msf
id|mcd_Play
suffix:semicolon
DECL|variable|audioStatus
r_static
r_int
id|audioStatus
suffix:semicolon
DECL|variable|mcdDiskChanged
r_static
r_char
id|mcdDiskChanged
suffix:semicolon
DECL|variable|tocUpToDate
r_static
r_char
id|tocUpToDate
suffix:semicolon
DECL|variable|mcdVersion
r_static
r_char
id|mcdVersion
suffix:semicolon
r_static
r_void
id|mcd_transfer
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|mcd_poll
c_func
(paren
r_int
r_int
id|dummy
)paren
suffix:semicolon
r_static
r_void
id|mcd_invalidate_buffers
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|hsg2msf
c_func
(paren
r_int
id|hsg
comma
r_struct
id|msf
op_star
id|msf
)paren
suffix:semicolon
r_static
r_void
id|bin2bcd
c_func
(paren
r_int
r_char
op_star
id|p
)paren
suffix:semicolon
r_static
r_int
id|bcd2bin
c_func
(paren
r_int
r_char
id|bcd
)paren
suffix:semicolon
r_static
r_int
id|mcdStatus
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_void
id|sendMcdCmd
c_func
(paren
r_int
id|cmd
comma
r_struct
id|mcd_Play_msf
op_star
id|params
)paren
suffix:semicolon
r_static
r_int
id|getMcdStatus
c_func
(paren
r_int
id|timeout
)paren
suffix:semicolon
r_static
r_int
id|GetQChannelInfo
c_func
(paren
r_struct
id|mcd_Toc
op_star
id|qp
)paren
suffix:semicolon
r_static
r_int
id|updateToc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|GetDiskInfo
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|GetToc
c_func
(paren
r_void
)paren
suffix:semicolon
r_static
r_int
id|getValue
c_func
(paren
r_int
r_char
op_star
id|result
)paren
suffix:semicolon
r_static
r_int
id|mcd_open
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|purpose
)paren
suffix:semicolon
r_static
r_void
id|mcd_release
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
suffix:semicolon
r_static
r_int
id|mcd_media_changed
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|disc_nr
)paren
suffix:semicolon
r_static
r_int
id|mcd_tray_move
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|position
)paren
suffix:semicolon
r_int
id|mcd_audio_ioctl
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
suffix:semicolon
r_int
id|mcd_drive_status
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|slot_nr
)paren
suffix:semicolon
DECL|variable|mcd_timer
r_static
r_struct
id|timer_list
id|mcd_timer
suffix:semicolon
DECL|variable|mcd_dops
r_static
r_struct
id|cdrom_device_ops
id|mcd_dops
op_assign
(brace
id|open
suffix:colon
id|mcd_open
comma
id|release
suffix:colon
id|mcd_release
comma
id|drive_status
suffix:colon
id|mcd_drive_status
comma
id|media_changed
suffix:colon
id|mcd_media_changed
comma
id|tray_move
suffix:colon
id|mcd_tray_move
comma
id|audio_ioctl
suffix:colon
id|mcd_audio_ioctl
comma
id|capability
suffix:colon
id|CDC_OPEN_TRAY
op_or
id|CDC_MEDIA_CHANGED
op_or
id|CDC_PLAY_AUDIO
op_or
id|CDC_DRIVE_STATUS
comma
)brace
suffix:semicolon
DECL|variable|mcd_info
r_static
r_struct
id|cdrom_device_info
id|mcd_info
op_assign
(brace
id|ops
suffix:colon
op_amp
id|mcd_dops
comma
id|speed
suffix:colon
l_int|2
comma
id|capacity
suffix:colon
l_int|1
comma
id|name
suffix:colon
l_string|&quot;mcd&quot;
comma
)brace
suffix:semicolon
macro_line|#ifndef MODULE
DECL|function|mcd_setup
r_static
r_int
id|__init
id|mcd_setup
c_func
(paren
r_char
op_star
id|str
)paren
(brace
r_int
id|ints
(braket
l_int|9
)braket
suffix:semicolon
(paren
r_void
)paren
id|get_options
c_func
(paren
id|str
comma
id|ARRAY_SIZE
c_func
(paren
id|ints
)paren
comma
id|ints
)paren
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|0
)paren
id|mcd_port
op_assign
id|ints
(braket
l_int|1
)braket
suffix:semicolon
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|1
)paren
id|mcd_irq
op_assign
id|ints
(braket
l_int|2
)braket
suffix:semicolon
macro_line|#ifdef WORK_AROUND_MITSUMI_BUG_93
r_if
c_cond
(paren
id|ints
(braket
l_int|0
)braket
OG
l_int|2
)paren
id|mitsumi_bug_93_wait
op_assign
id|ints
(braket
l_int|3
)braket
suffix:semicolon
macro_line|#endif /* WORK_AROUND_MITSUMI_BUG_93 */
r_return
l_int|1
suffix:semicolon
)brace
id|__setup
c_func
(paren
l_string|&quot;mcd=&quot;
comma
id|mcd_setup
)paren
suffix:semicolon
macro_line|#endif /* MODULE */ 
DECL|function|mcd_media_changed
r_static
r_int
id|mcd_media_changed
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|disc_nr
)paren
(brace
r_int
id|retval
suffix:semicolon
macro_line|#if 1&t; /* the below is not reliable */
r_return
l_int|0
suffix:semicolon
macro_line|#endif  
r_if
c_cond
(paren
id|cdi-&gt;dev
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: Mitsumi CD-ROM request error: invalid device.&bslash;n&quot;
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|retval
op_assign
id|mcdDiskChanged
suffix:semicolon
id|mcdDiskChanged
op_assign
l_int|0
suffix:semicolon
r_return
id|retval
suffix:semicolon
)brace
multiline_comment|/*&n; * Do a &squot;get status&squot; command and get the result.  Only use from the top half&n; * because it calls &squot;getMcdStatus&squot; which sleeps.&n; */
r_static
r_int
DECL|function|statusCmd
id|statusCmd
c_func
(paren
r_void
)paren
(brace
r_int
id|st
op_assign
op_minus
l_int|1
comma
id|retry
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|outb
c_func
(paren
id|MCMD_GET_STATUS
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* send get-status cmd */
id|st
op_assign
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
r_return
id|st
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a &squot;Play&squot; command and get the status.  Use only from the top half.&n; */
r_static
r_int
DECL|function|mcdPlay
id|mcdPlay
c_func
(paren
r_struct
id|mcd_Play_msf
op_star
id|arg
)paren
(brace
r_int
id|retry
comma
id|st
op_assign
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|sendMcdCmd
c_func
(paren
id|MCMD_PLAY_READ
comma
id|arg
)paren
suffix:semicolon
id|st
op_assign
id|getMcdStatus
c_func
(paren
l_int|2
op_star
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
r_return
id|st
suffix:semicolon
)brace
r_static
r_int
DECL|function|mcd_tray_move
id|mcd_tray_move
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|position
)paren
(brace
r_int
id|i
suffix:semicolon
r_if
c_cond
(paren
id|position
)paren
(brace
multiline_comment|/*  Eject */
multiline_comment|/* all drives can at least stop! */
r_if
c_cond
(paren
id|audioStatus
op_eq
id|CDROM_AUDIO_PLAY
)paren
(brace
id|outb
c_func
(paren
id|MCMD_STOP
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_assign
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
)brace
id|audioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
id|outb
c_func
(paren
id|MCMD_EJECT
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/*&n;                 * the status (i) shows failure on all but the FX drives.&n;                 * But nothing we can do about that in software!&n;                 * So just read the status and forget it. - Jon.&n;                 */
id|i
op_assign
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_int
DECL|function|msf2hsg
id|msf2hsg
c_func
(paren
r_struct
id|msf
op_star
id|mp
)paren
(brace
r_return
id|bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|frame
)paren
op_plus
id|bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|sec
)paren
op_star
l_int|75
op_plus
id|bcd2bin
c_func
(paren
id|mp
op_member_access_from_pointer
id|min
)paren
op_star
l_int|4500
op_minus
l_int|150
suffix:semicolon
)brace
DECL|function|mcd_audio_ioctl
r_int
id|mcd_audio_ioctl
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
r_int
id|cmd
comma
r_void
op_star
id|arg
)paren
(brace
r_int
id|i
comma
id|st
suffix:semicolon
r_struct
id|mcd_Toc
id|qInfo
suffix:semicolon
r_struct
id|cdrom_ti
op_star
id|ti
suffix:semicolon
r_struct
id|cdrom_tochdr
op_star
id|tocHdr
suffix:semicolon
r_struct
id|cdrom_msf
op_star
id|msf
suffix:semicolon
r_struct
id|cdrom_subchnl
op_star
id|subchnl
suffix:semicolon
r_struct
id|cdrom_tocentry
op_star
id|entry
suffix:semicolon
r_struct
id|mcd_Toc
op_star
id|tocPtr
suffix:semicolon
r_struct
id|cdrom_volctrl
op_star
id|volctrl
suffix:semicolon
id|st
op_assign
id|statusCmd
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|st
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|tocUpToDate
)paren
(brace
id|i
op_assign
id|updateToc
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
r_return
id|i
suffix:semicolon
multiline_comment|/* error reading TOC */
)brace
r_switch
c_cond
(paren
id|cmd
)paren
(brace
r_case
id|CDROMSTART
suffix:colon
multiline_comment|/* Spin up the drive */
multiline_comment|/* Don&squot;t think we can do this.  Even if we could,&n; &t;&t; * I think the drive times out and stops after a while&n;&t;&t; * anyway.  For now, ignore it.&n;&t;&t; */
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMSTOP
suffix:colon
multiline_comment|/* Spin down the drive */
id|outb
c_func
(paren
id|MCMD_STOP
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_assign
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
multiline_comment|/* should we do anything if it fails? */
id|audioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMPAUSE
suffix:colon
multiline_comment|/* Pause the drive */
r_if
c_cond
(paren
id|audioStatus
op_ne
id|CDROM_AUDIO_PLAY
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
id|outb
c_func
(paren
id|MCMD_STOP
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_assign
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|GetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
(brace
multiline_comment|/* didn&squot;t get q channel info */
id|audioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
id|mcd_Play.start
op_assign
id|qInfo.diskTime
suffix:semicolon
multiline_comment|/* remember restart point */
id|audioStatus
op_assign
id|CDROM_AUDIO_PAUSED
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMRESUME
suffix:colon
multiline_comment|/* Play it again, Sam */
r_if
c_cond
(paren
id|audioStatus
op_ne
id|CDROM_AUDIO_PAUSED
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
multiline_comment|/* restart the drive at the saved position. */
id|i
op_assign
id|mcdPlay
c_func
(paren
op_amp
id|mcd_Play
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|audioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|audioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMPLAYTRKIND
suffix:colon
multiline_comment|/* Play a track.  This currently ignores index. */
id|ti
op_assign
(paren
r_struct
id|cdrom_ti
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|ti-&gt;cdti_trk0
template_param
id|DiskInfo.last
op_logical_or
id|ti-&gt;cdti_trk1
OL
id|ti-&gt;cdti_trk0
)paren
(brace
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
r_if
c_cond
(paren
id|ti-&gt;cdti_trk1
OG
id|DiskInfo.last
)paren
id|ti-&gt;cdti_trk1
op_assign
id|DiskInfo.last
suffix:semicolon
id|mcd_Play.start
op_assign
id|Toc
(braket
id|ti-&gt;cdti_trk0
)braket
dot
id|diskTime
suffix:semicolon
id|mcd_Play.end
op_assign
id|Toc
(braket
id|ti-&gt;cdti_trk1
op_plus
l_int|1
)braket
dot
id|diskTime
suffix:semicolon
macro_line|#ifdef MCD_DEBUG
id|printk
c_func
(paren
l_string|&quot;play: %02x:%02x.%02x to %02x:%02x.%02x&bslash;n&quot;
comma
id|mcd_Play.start.min
comma
id|mcd_Play.start.sec
comma
id|mcd_Play.start.frame
comma
id|mcd_Play.end.min
comma
id|mcd_Play.end.sec
comma
id|mcd_Play.end.frame
)paren
suffix:semicolon
macro_line|#endif
id|i
op_assign
id|mcdPlay
c_func
(paren
op_amp
id|mcd_Play
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|audioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|audioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMPLAYMSF
suffix:colon
multiline_comment|/* Play starting at the given MSF address. */
r_if
c_cond
(paren
id|audioStatus
op_eq
id|CDROM_AUDIO_PLAY
)paren
(brace
id|outb
c_func
(paren
id|MCMD_STOP
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_assign
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
id|audioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
)brace
id|msf
op_assign
(paren
r_struct
id|cdrom_msf
op_star
)paren
id|arg
suffix:semicolon
multiline_comment|/* convert to bcd */
id|bin2bcd
c_func
(paren
op_amp
id|msf-&gt;cdmsf_min0
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf-&gt;cdmsf_sec0
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf-&gt;cdmsf_frame0
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf-&gt;cdmsf_min1
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf-&gt;cdmsf_sec1
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf-&gt;cdmsf_frame1
)paren
suffix:semicolon
id|mcd_Play.start.min
op_assign
id|msf-&gt;cdmsf_min0
suffix:semicolon
id|mcd_Play.start.sec
op_assign
id|msf-&gt;cdmsf_sec0
suffix:semicolon
id|mcd_Play.start.frame
op_assign
id|msf-&gt;cdmsf_frame0
suffix:semicolon
id|mcd_Play.end.min
op_assign
id|msf-&gt;cdmsf_min1
suffix:semicolon
id|mcd_Play.end.sec
op_assign
id|msf-&gt;cdmsf_sec1
suffix:semicolon
id|mcd_Play.end.frame
op_assign
id|msf-&gt;cdmsf_frame1
suffix:semicolon
macro_line|#ifdef MCD_DEBUG
id|printk
c_func
(paren
l_string|&quot;play: %02x:%02x.%02x to %02x:%02x.%02x&bslash;n&quot;
comma
id|mcd_Play.start.min
comma
id|mcd_Play.start.sec
comma
id|mcd_Play.start.frame
comma
id|mcd_Play.end.min
comma
id|mcd_Play.end.sec
comma
id|mcd_Play.end.frame
)paren
suffix:semicolon
macro_line|#endif
id|i
op_assign
id|mcdPlay
c_func
(paren
op_amp
id|mcd_Play
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
(brace
id|audioStatus
op_assign
id|CDROM_AUDIO_ERROR
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|audioStatus
op_assign
id|CDROM_AUDIO_PLAY
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMREADTOCHDR
suffix:colon
multiline_comment|/* Read the table of contents header */
id|tocHdr
op_assign
(paren
r_struct
id|cdrom_tochdr
op_star
)paren
id|arg
suffix:semicolon
id|tocHdr-&gt;cdth_trk0
op_assign
id|DiskInfo.first
suffix:semicolon
id|tocHdr-&gt;cdth_trk1
op_assign
id|DiskInfo.last
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMREADTOCENTRY
suffix:colon
multiline_comment|/* Read an entry in the table of contents */
id|entry
op_assign
(paren
r_struct
id|cdrom_tocentry
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;cdte_track
op_eq
id|CDROM_LEADOUT
)paren
id|tocPtr
op_assign
op_amp
id|Toc
(braket
id|DiskInfo.last
op_minus
id|DiskInfo.first
op_plus
l_int|1
)braket
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry-&gt;cdte_track
OG
id|DiskInfo.last
op_logical_or
id|entry-&gt;cdte_track
OL
id|DiskInfo.first
)paren
r_return
op_minus
id|EINVAL
suffix:semicolon
r_else
id|tocPtr
op_assign
op_amp
id|Toc
(braket
id|entry-&gt;cdte_track
)braket
suffix:semicolon
id|entry-&gt;cdte_adr
op_assign
id|tocPtr
op_member_access_from_pointer
id|ctrl_addr
suffix:semicolon
id|entry-&gt;cdte_ctrl
op_assign
id|tocPtr
op_member_access_from_pointer
id|ctrl_addr
op_rshift
l_int|4
suffix:semicolon
r_if
c_cond
(paren
id|entry-&gt;cdte_format
op_eq
id|CDROM_LBA
)paren
id|entry-&gt;cdte_addr.lba
op_assign
id|msf2hsg
c_func
(paren
op_amp
id|tocPtr
op_member_access_from_pointer
id|diskTime
)paren
suffix:semicolon
r_else
r_if
c_cond
(paren
id|entry-&gt;cdte_format
op_eq
id|CDROM_MSF
)paren
(brace
id|entry-&gt;cdte_addr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.min
)paren
suffix:semicolon
id|entry-&gt;cdte_addr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.sec
)paren
suffix:semicolon
id|entry-&gt;cdte_addr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|tocPtr
op_member_access_from_pointer
id|diskTime.frame
)paren
suffix:semicolon
)brace
r_else
r_return
op_minus
id|EINVAL
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMSUBCHNL
suffix:colon
multiline_comment|/* Get subchannel info */
id|subchnl
op_assign
(paren
r_struct
id|cdrom_subchnl
op_star
)paren
id|arg
suffix:semicolon
r_if
c_cond
(paren
id|GetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|subchnl-&gt;cdsc_audiostatus
op_assign
id|audioStatus
suffix:semicolon
id|subchnl-&gt;cdsc_adr
op_assign
id|qInfo.ctrl_addr
suffix:semicolon
id|subchnl-&gt;cdsc_ctrl
op_assign
id|qInfo.ctrl_addr
op_rshift
l_int|4
suffix:semicolon
id|subchnl-&gt;cdsc_trk
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.track
)paren
suffix:semicolon
id|subchnl-&gt;cdsc_ind
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.pointIndex
)paren
suffix:semicolon
id|subchnl-&gt;cdsc_absaddr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.diskTime.min
)paren
suffix:semicolon
id|subchnl-&gt;cdsc_absaddr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.diskTime.sec
)paren
suffix:semicolon
id|subchnl-&gt;cdsc_absaddr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.diskTime.frame
)paren
suffix:semicolon
id|subchnl-&gt;cdsc_reladdr.msf.minute
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.trackTime.min
)paren
suffix:semicolon
id|subchnl-&gt;cdsc_reladdr.msf.second
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.trackTime.sec
)paren
suffix:semicolon
id|subchnl-&gt;cdsc_reladdr.msf.frame
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.trackTime.frame
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
r_case
id|CDROMVOLCTRL
suffix:colon
multiline_comment|/* Volume control */
id|volctrl
op_assign
(paren
r_struct
id|cdrom_volctrl
op_star
)paren
id|arg
suffix:semicolon
id|outb
c_func
(paren
id|MCMD_SET_VOLUME
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|volctrl-&gt;channel0
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|255
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|volctrl-&gt;channel1
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|255
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|i
op_assign
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
(brace
r_char
id|a
comma
id|b
comma
id|c
comma
id|d
suffix:semicolon
id|getValue
c_func
(paren
op_amp
id|a
)paren
suffix:semicolon
id|getValue
c_func
(paren
op_amp
id|b
)paren
suffix:semicolon
id|getValue
c_func
(paren
op_amp
id|c
)paren
suffix:semicolon
id|getValue
c_func
(paren
op_amp
id|d
)paren
suffix:semicolon
)brace
r_return
l_int|0
suffix:semicolon
r_default
suffix:colon
r_return
op_minus
id|EINVAL
suffix:semicolon
)brace
)brace
multiline_comment|/*&n; * Take care of the different block sizes between cdrom and Linux.&n; * When Linux gets variable block sizes this will probably go away.&n; */
r_static
r_void
DECL|function|mcd_transfer
id|mcd_transfer
c_func
(paren
r_void
)paren
(brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
(brace
r_while
c_loop
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
)paren
(brace
r_int
id|bn
op_assign
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
suffix:semicolon
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MCD_BUF_SIZ
op_logical_and
id|mcd_buf_bn
(braket
id|i
)braket
op_ne
id|bn
suffix:semicolon
op_increment
id|i
)paren
suffix:semicolon
r_if
c_cond
(paren
id|i
OL
id|MCD_BUF_SIZ
)paren
(brace
r_int
id|offs
op_assign
(paren
id|i
op_star
l_int|4
op_plus
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_amp
l_int|3
)paren
)paren
op_star
l_int|512
suffix:semicolon
r_int
id|nr_sectors
op_assign
l_int|4
op_minus
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_amp
l_int|3
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mcd_buf_out
op_ne
id|i
)paren
(brace
id|mcd_buf_out
op_assign
id|i
suffix:semicolon
r_if
c_cond
(paren
id|mcd_buf_bn
(braket
id|i
)braket
op_ne
id|bn
)paren
(brace
id|mcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
r_continue
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|nr_sectors
OG
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
)paren
id|nr_sectors
op_assign
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
suffix:semicolon
id|memcpy
c_func
(paren
id|CURRENT
op_member_access_from_pointer
id|buffer
comma
id|mcd_buf
op_plus
id|offs
comma
id|nr_sectors
op_star
l_int|512
)paren
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_sub_assign
id|nr_sectors
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|sector
op_add_assign
id|nr_sectors
suffix:semicolon
id|CURRENT
op_member_access_from_pointer
id|buffer
op_add_assign
id|nr_sectors
op_star
l_int|512
suffix:semicolon
)brace
r_else
(brace
id|mcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
)brace
)brace
multiline_comment|/*&n; * We only seem to get interrupts after an error.&n; * Just take the interrupt and clear out the status reg.&n; */
r_static
r_void
DECL|function|mcd_interrupt
id|mcd_interrupt
c_func
(paren
r_int
id|irq
comma
r_void
op_star
id|dev_id
comma
r_struct
id|pt_regs
op_star
id|regs
)paren
(brace
r_int
id|st
suffix:semicolon
id|st
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
l_int|0xFF
suffix:semicolon
macro_line|#ifdef TEST1
id|printk
c_func
(paren
l_string|&quot;&lt;int1-%02X&gt;&quot;
comma
id|st
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
(paren
id|st
op_amp
id|MFL_STATUS
)paren
)paren
(brace
id|st
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
op_amp
l_int|0xFF
suffix:semicolon
macro_line|#ifdef TEST1
id|printk
c_func
(paren
l_string|&quot;&lt;int0-%02X&gt;&quot;
comma
id|st
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|st
op_amp
l_int|0xFF
)paren
op_ne
l_int|0xFF
)paren
id|mcd_error
op_assign
id|st
ques
c_cond
id|st
op_amp
l_int|0xFF
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
)brace
r_static
r_void
DECL|function|do_mcd_request
id|do_mcd_request
c_func
(paren
id|request_queue_t
op_star
id|q
)paren
(brace
macro_line|#ifdef TEST2
id|printk
c_func
(paren
l_string|&quot; do_mcd_request(%ld+%ld)&bslash;n&quot;
comma
id|CURRENT
op_member_access_from_pointer
id|sector
comma
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
)paren
suffix:semicolon
macro_line|#endif
id|mcd_transfer_is_active
op_assign
l_int|1
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
(brace
r_if
c_cond
(paren
id|CURRENT-&gt;bh
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|buffer_locked
c_func
(paren
id|CURRENT-&gt;bh
)paren
)paren
id|panic
c_func
(paren
id|DEVICE_NAME
l_string|&quot;: block not locked&quot;
)paren
suffix:semicolon
)brace
id|mcd_transfer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_eq
l_int|0
)paren
(brace
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
)brace
r_else
(brace
id|mcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
multiline_comment|/* Want to read a block not in buffer */
r_if
c_cond
(paren
id|mcd_state
op_eq
id|MCD_S_IDLE
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
id|tocUpToDate
)paren
(brace
r_if
c_cond
(paren
id|updateToc
c_func
(paren
)paren
OL
l_int|0
)paren
(brace
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_break
suffix:semicolon
)brace
)brace
id|mcd_state
op_assign
id|MCD_S_START
suffix:semicolon
id|McdTries
op_assign
l_int|5
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|mcd_poll
comma
l_int|1
)paren
suffix:semicolon
)brace
r_break
suffix:semicolon
)brace
)brace
id|mcd_transfer_is_active
op_assign
l_int|0
suffix:semicolon
macro_line|#ifdef TEST2
id|printk
c_func
(paren
l_string|&quot; do_mcd_request ends&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
)brace
r_static
r_void
DECL|function|mcd_poll
id|mcd_poll
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_int
id|st
suffix:semicolon
r_if
c_cond
(paren
id|mcd_error
)paren
(brace
r_if
c_cond
(paren
id|mcd_error
op_amp
l_int|0xA5
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: I/O error 0x%02x&quot;
comma
id|mcd_error
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mcd_error
op_amp
l_int|0x80
)paren
id|printk
c_func
(paren
l_string|&quot; (Door open)&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mcd_error
op_amp
l_int|0x20
)paren
id|printk
c_func
(paren
l_string|&quot; (Disk changed)&quot;
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mcd_error
op_amp
l_int|0x04
)paren
(brace
id|printk
c_func
(paren
l_string|&quot; (Read error)&quot;
)paren
suffix:semicolon
multiline_comment|/* Bitch about the problem. */
multiline_comment|/* Time to get fancy! If at 2x speed and 1 error, drop to 1x speed! */
multiline_comment|/* Interesting how it STAYS at MCD_RETRY_ATTEMPTS on first error! */
multiline_comment|/* But I find that rather HANDY!!! */
multiline_comment|/* Neat! it REALLY WORKS on those LOW QUALITY CD&squot;s!!! Smile! :) */
multiline_comment|/* AJK [06/17/95] */
multiline_comment|/* Slap the CD down to single speed! */
r_if
c_cond
(paren
id|mcdDouble
op_eq
l_int|1
op_logical_and
id|McdTries
op_eq
id|MCD_RETRY_ATTEMPTS
op_logical_and
id|MCMD_DATA_READ
op_eq
id|MCMD_2X_READ
)paren
(brace
id|MCMD_DATA_READ
op_assign
id|MCMD_PLAY_READ
suffix:semicolon
multiline_comment|/* Uhhh, Ummmm, muhuh-huh! */
id|mcd1xhold
op_assign
id|SINGLE_HOLD_SECTORS
suffix:semicolon
multiline_comment|/* Hey Beavis! */
id|printk
c_func
(paren
l_string|&quot; Speed now 1x&quot;
)paren
suffix:semicolon
multiline_comment|/* Pull my finger! */
)brace
)brace
id|printk
c_func
(paren
l_string|&quot;&bslash;n&quot;
)paren
suffix:semicolon
id|mcd_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
macro_line|#ifdef WARN_IF_READ_FAILURE
r_if
c_cond
(paren
id|McdTries
op_eq
id|MCD_RETRY_ATTEMPTS
)paren
id|printk
c_func
(paren
l_string|&quot;mcd: read of block %d failed&bslash;n&quot;
comma
id|mcd_next_bn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|McdTries
op_decrement
)paren
(brace
multiline_comment|/* Nuts! This cd is ready for recycling! */
multiline_comment|/* When WAS the last time YOU cleaned it CORRECTLY?! */
id|printk
c_func
(paren
l_string|&quot;mcd: read of block %d failed, giving up&bslash;n&quot;
comma
id|mcd_next_bn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mcd_transfer_is_active
)paren
(brace
id|McdTries
op_assign
l_int|0
suffix:semicolon
r_goto
id|ret
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|McdTries
op_assign
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
)brace
)brace
id|mcd_error
op_assign
l_int|0
suffix:semicolon
id|mcd_state
op_assign
id|MCD_S_STOP
suffix:semicolon
)brace
multiline_comment|/* Switch back to Double speed if enough GOOD sectors were read! */
multiline_comment|/* Are we a double speed with a crappy CD?! */
r_if
c_cond
(paren
id|mcdDouble
op_eq
l_int|1
op_logical_and
id|McdTries
op_eq
id|MCD_RETRY_ATTEMPTS
op_logical_and
id|MCMD_DATA_READ
op_eq
id|MCMD_PLAY_READ
)paren
(brace
multiline_comment|/* We ARE a double speed and we ARE bitching! */
r_if
c_cond
(paren
id|mcd1xhold
op_eq
l_int|0
)paren
multiline_comment|/* Okay, Like are we STILL at single speed? */
(brace
multiline_comment|/* We need to switch back to double speed now... */
id|MCMD_DATA_READ
op_assign
id|MCMD_2X_READ
suffix:semicolon
multiline_comment|/* Uhhh... BACK You GO! */
id|printk
c_func
(paren
l_string|&quot;mcd: Switching back to 2X speed!&bslash;n&quot;
)paren
suffix:semicolon
multiline_comment|/* Tell &squot;em! */
)brace
r_else
id|mcd1xhold
op_decrement
suffix:semicolon
multiline_comment|/* No?! Count down the good reads some more... */
multiline_comment|/* and try, try again! */
)brace
id|immediately
suffix:colon
r_switch
c_cond
(paren
id|mcd_state
)paren
(brace
r_case
id|MCD_S_IDLE
suffix:colon
macro_line|#ifdef TEST3
id|printk
c_func
(paren
l_string|&quot;MCD_S_IDLE&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_goto
id|out
suffix:semicolon
r_case
id|MCD_S_START
suffix:colon
macro_line|#ifdef TEST3
id|printk
c_func
(paren
l_string|&quot;MCD_S_START&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|outb
c_func
(paren
id|MCMD_GET_STATUS
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|mcd_state
op_assign
id|mcd_mode
op_eq
l_int|1
ques
c_cond
id|MCD_S_READ
suffix:colon
id|MCD_S_MODE
suffix:semicolon
id|McdTimeout
op_assign
l_int|3000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MCD_S_MODE
suffix:colon
macro_line|#ifdef TEST3
id|printk
c_func
(paren
l_string|&quot;MCD_S_MODE&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|st
op_assign
id|mcdStatus
c_func
(paren
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|st
op_amp
id|MST_DSK_CHG
)paren
(brace
id|mcdDiskChanged
op_assign
l_int|1
suffix:semicolon
id|tocUpToDate
op_assign
l_int|0
suffix:semicolon
id|mcd_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
id|set_mode_immediately
suffix:colon
r_if
c_cond
(paren
(paren
id|st
op_amp
id|MST_DOOR_OPEN
)paren
op_logical_or
op_logical_neg
(paren
id|st
op_amp
id|MST_READY
)paren
)paren
(brace
id|mcdDiskChanged
op_assign
l_int|1
suffix:semicolon
id|tocUpToDate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mcd_transfer_is_active
)paren
(brace
id|mcd_state
op_assign
id|MCD_S_START
suffix:semicolon
r_goto
id|immediately
suffix:semicolon
)brace
id|printk
c_func
(paren
(paren
id|st
op_amp
id|MST_DOOR_OPEN
)paren
ques
c_cond
l_string|&quot;mcd: door open&bslash;n&quot;
suffix:colon
l_string|&quot;mcd: disk removed&bslash;n&quot;
)paren
suffix:semicolon
id|mcd_state
op_assign
id|MCD_S_IDLE
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|outb
c_func
(paren
id|MCMD_SET_MODE
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|1
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|mcd_mode
op_assign
l_int|1
suffix:semicolon
id|mcd_state
op_assign
id|MCD_S_READ
suffix:semicolon
id|McdTimeout
op_assign
l_int|3000
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MCD_S_READ
suffix:colon
macro_line|#ifdef TEST3
id|printk
c_func
(paren
l_string|&quot;MCD_S_READ&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|st
op_assign
id|mcdStatus
c_func
(paren
)paren
)paren
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|st
op_amp
id|MST_DSK_CHG
)paren
(brace
id|mcdDiskChanged
op_assign
l_int|1
suffix:semicolon
id|tocUpToDate
op_assign
l_int|0
suffix:semicolon
id|mcd_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
id|read_immediately
suffix:colon
r_if
c_cond
(paren
(paren
id|st
op_amp
id|MST_DOOR_OPEN
)paren
op_logical_or
op_logical_neg
(paren
id|st
op_amp
id|MST_READY
)paren
)paren
(brace
id|mcdDiskChanged
op_assign
l_int|1
suffix:semicolon
id|tocUpToDate
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mcd_transfer_is_active
)paren
(brace
id|mcd_state
op_assign
id|MCD_S_START
suffix:semicolon
r_goto
id|immediately
suffix:semicolon
)brace
id|printk
c_func
(paren
(paren
id|st
op_amp
id|MST_DOOR_OPEN
)paren
ques
c_cond
l_string|&quot;mcd: door open&bslash;n&quot;
suffix:colon
l_string|&quot;mcd: disk removed&bslash;n&quot;
)paren
suffix:semicolon
id|mcd_state
op_assign
id|MCD_S_IDLE
suffix:semicolon
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
(brace
r_struct
id|mcd_Play_msf
id|msf
suffix:semicolon
id|mcd_next_bn
op_assign
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
suffix:semicolon
id|hsg2msf
c_func
(paren
id|mcd_next_bn
comma
op_amp
id|msf.start
)paren
suffix:semicolon
id|msf.end.min
op_assign
op_complement
l_int|0
suffix:semicolon
id|msf.end.sec
op_assign
op_complement
l_int|0
suffix:semicolon
id|msf.end.frame
op_assign
op_complement
l_int|0
suffix:semicolon
id|sendMcdCmd
c_func
(paren
id|MCMD_DATA_READ
comma
op_amp
id|msf
)paren
suffix:semicolon
id|mcd_state
op_assign
id|MCD_S_DATA
suffix:semicolon
id|McdTimeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
)brace
r_else
(brace
id|mcd_state
op_assign
id|MCD_S_STOP
suffix:semicolon
r_goto
id|immediately
suffix:semicolon
)brace
)brace
r_break
suffix:semicolon
r_case
id|MCD_S_DATA
suffix:colon
macro_line|#ifdef TEST3
id|printk
c_func
(paren
l_string|&quot;MCD_S_DATA&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
id|st
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
(paren
id|MFL_STATUSorDATA
)paren
suffix:semicolon
id|data_immediately
suffix:colon
macro_line|#ifdef TEST5
id|printk
c_func
(paren
l_string|&quot;Status %02x&bslash;n&quot;
comma
id|st
)paren
suffix:semicolon
macro_line|#endif
r_switch
c_cond
(paren
id|st
)paren
(brace
r_case
id|MFL_DATA
suffix:colon
macro_line|#ifdef WARN_IF_READ_FAILURE
r_if
c_cond
(paren
id|McdTries
op_eq
l_int|5
)paren
id|printk
c_func
(paren
l_string|&quot;mcd: read of block %d failed&bslash;n&quot;
comma
id|mcd_next_bn
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
op_logical_neg
id|McdTries
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: read of block %d failed, giving up&bslash;n&quot;
comma
id|mcd_next_bn
)paren
suffix:semicolon
r_if
c_cond
(paren
id|mcd_transfer_is_active
)paren
(brace
id|McdTries
op_assign
l_int|0
suffix:semicolon
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
id|end_request
c_func
(paren
l_int|0
)paren
suffix:semicolon
id|McdTries
op_assign
l_int|5
suffix:semicolon
)brace
id|mcd_state
op_assign
id|MCD_S_START
suffix:semicolon
id|McdTimeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
r_goto
id|immediately
suffix:semicolon
r_case
id|MFL_STATUSorDATA
suffix:colon
r_break
suffix:semicolon
r_default
suffix:colon
id|McdTries
op_assign
l_int|5
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|CURRENT_VALID
op_logical_and
id|mcd_buf_in
op_eq
id|mcd_buf_out
)paren
(brace
id|mcd_state
op_assign
id|MCD_S_STOP
suffix:semicolon
r_goto
id|immediately
suffix:semicolon
)brace
id|mcd_buf_bn
(braket
id|mcd_buf_in
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|READ_DATA
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
comma
id|mcd_buf
op_plus
l_int|2048
op_star
id|mcd_buf_in
comma
l_int|2048
)paren
suffix:semicolon
id|mcd_buf_bn
(braket
id|mcd_buf_in
)braket
op_assign
id|mcd_next_bn
op_increment
suffix:semicolon
r_if
c_cond
(paren
id|mcd_buf_out
op_eq
op_minus
l_int|1
)paren
id|mcd_buf_out
op_assign
id|mcd_buf_in
suffix:semicolon
id|mcd_buf_in
op_assign
id|mcd_buf_in
op_plus
l_int|1
op_eq
id|MCD_BUF_SIZ
ques
c_cond
l_int|0
suffix:colon
id|mcd_buf_in
op_plus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|mcd_transfer_is_active
)paren
(brace
r_while
c_loop
(paren
id|CURRENT_VALID
)paren
(brace
id|mcd_transfer
c_func
(paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|CURRENT
op_member_access_from_pointer
id|nr_sectors
op_eq
l_int|0
)paren
id|end_request
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_else
r_break
suffix:semicolon
)brace
)brace
r_if
c_cond
(paren
id|CURRENT_VALID
op_logical_and
(paren
id|CURRENT
op_member_access_from_pointer
id|sector
op_div
l_int|4
template_param
id|mcd_next_bn
op_plus
l_int|16
)paren
)paren
(brace
id|mcd_state
op_assign
id|MCD_S_STOP
suffix:semicolon
r_goto
id|immediately
suffix:semicolon
)brace
id|McdTimeout
op_assign
id|READ_TIMEOUT
suffix:semicolon
macro_line|#ifdef DOUBLE_QUICK_ONLY
r_if
c_cond
(paren
id|MCMD_DATA_READ
op_ne
id|MCMD_PLAY_READ
)paren
macro_line|#endif
(brace
r_int
id|count
op_assign
id|QUICK_LOOP_COUNT
suffix:semicolon
r_while
c_loop
(paren
id|count
op_decrement
)paren
(brace
id|QUICK_LOOP_DELAY
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_assign
(paren
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
)paren
op_amp
(paren
id|MFL_STATUSorDATA
)paren
)paren
op_ne
(paren
id|MFL_STATUSorDATA
)paren
)paren
(brace
macro_line|#   ifdef TEST4
multiline_comment|/*&t;    printk(&quot;Quickloop success at %d&bslash;n&quot;,QUICK_LOOP_COUNT-count); */
id|printk
c_func
(paren
l_string|&quot; %d &quot;
comma
id|QUICK_LOOP_COUNT
op_minus
id|count
)paren
suffix:semicolon
macro_line|#   endif
r_goto
id|data_immediately
suffix:semicolon
)brace
)brace
macro_line|#   ifdef TEST4
multiline_comment|/*      printk(&quot;Quickloop ended at %d&bslash;n&quot;,QUICK_LOOP_COUNT); */
id|printk
c_func
(paren
l_string|&quot;ended &quot;
)paren
suffix:semicolon
macro_line|#   endif
)brace
r_break
suffix:semicolon
)brace
r_break
suffix:semicolon
r_case
id|MCD_S_STOP
suffix:colon
macro_line|#ifdef TEST3
id|printk
c_func
(paren
l_string|&quot;MCD_S_STOP&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
macro_line|#ifdef WORK_AROUND_MITSUMI_BUG_93
r_if
c_cond
(paren
op_logical_neg
id|mitsumi_bug_93_wait
)paren
r_goto
id|do_not_work_around_mitsumi_bug_93_1
suffix:semicolon
id|McdTimeout
op_assign
id|mitsumi_bug_93_wait
suffix:semicolon
id|mcd_state
op_assign
l_int|9
op_plus
l_int|3
op_plus
l_int|1
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
op_plus
l_int|3
op_plus
l_int|1
suffix:colon
r_if
c_cond
(paren
id|McdTimeout
)paren
r_break
suffix:semicolon
id|do_not_work_around_mitsumi_bug_93_1
suffix:colon
macro_line|#endif /* WORK_AROUND_MITSUMI_BUG_93 */
id|outb
c_func
(paren
id|MCMD_STOP
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
macro_line|#ifdef WORK_AROUND_MITSUMI_BUG_92
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
id|MFL_STATUSorDATA
)paren
op_eq
id|MFL_STATUS
)paren
(brace
r_int
id|i
op_assign
l_int|4096
suffix:semicolon
r_do
(brace
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
id|MFL_STATUSorDATA
)paren
op_eq
id|MFL_STATUS
op_logical_and
op_decrement
id|i
)paren
suffix:semicolon
id|outb
c_func
(paren
id|MCMD_STOP
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
(paren
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
id|MFL_STATUSorDATA
)paren
op_eq
id|MFL_STATUS
)paren
(brace
id|i
op_assign
l_int|4096
suffix:semicolon
r_do
(brace
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
r_while
c_loop
(paren
(paren
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
id|MFL_STATUSorDATA
)paren
op_eq
id|MFL_STATUS
op_logical_and
op_decrement
id|i
)paren
suffix:semicolon
id|outb
c_func
(paren
id|MCMD_STOP
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
)brace
macro_line|#endif /* WORK_AROUND_MITSUMI_BUG_92 */
id|mcd_state
op_assign
id|MCD_S_STOPPING
suffix:semicolon
id|McdTimeout
op_assign
l_int|1000
suffix:semicolon
r_break
suffix:semicolon
r_case
id|MCD_S_STOPPING
suffix:colon
macro_line|#ifdef TEST3
id|printk
c_func
(paren
l_string|&quot;MCD_S_STOPPING&bslash;n&quot;
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
(paren
id|st
op_assign
id|mcdStatus
c_func
(paren
)paren
)paren
op_eq
op_minus
l_int|1
op_logical_and
id|McdTimeout
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_ne
op_minus
l_int|1
)paren
op_logical_and
(paren
id|st
op_amp
id|MST_DSK_CHG
)paren
)paren
(brace
id|mcdDiskChanged
op_assign
l_int|1
suffix:semicolon
id|tocUpToDate
op_assign
l_int|0
suffix:semicolon
id|mcd_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
macro_line|#ifdef WORK_AROUND_MITSUMI_BUG_93
r_if
c_cond
(paren
op_logical_neg
id|mitsumi_bug_93_wait
)paren
r_goto
id|do_not_work_around_mitsumi_bug_93_2
suffix:semicolon
id|McdTimeout
op_assign
id|mitsumi_bug_93_wait
suffix:semicolon
id|mcd_state
op_assign
l_int|9
op_plus
l_int|3
op_plus
l_int|2
suffix:semicolon
r_break
suffix:semicolon
r_case
l_int|9
op_plus
l_int|3
op_plus
l_int|2
suffix:colon
r_if
c_cond
(paren
id|McdTimeout
)paren
r_break
suffix:semicolon
id|st
op_assign
op_minus
l_int|1
suffix:semicolon
id|do_not_work_around_mitsumi_bug_93_2
suffix:colon
macro_line|#endif /* WORK_AROUND_MITSUMI_BUG_93 */
macro_line|#ifdef TEST3
id|printk
c_func
(paren
l_string|&quot;CURRENT_VALID %d mcd_mode %d&bslash;n&quot;
comma
id|CURRENT_VALID
comma
id|mcd_mode
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|CURRENT_VALID
)paren
(brace
r_if
c_cond
(paren
id|st
op_ne
op_minus
l_int|1
)paren
(brace
r_if
c_cond
(paren
id|mcd_mode
op_eq
l_int|1
)paren
r_goto
id|read_immediately
suffix:semicolon
r_else
r_goto
id|set_mode_immediately
suffix:semicolon
)brace
r_else
(brace
id|mcd_state
op_assign
id|MCD_S_START
suffix:semicolon
id|McdTimeout
op_assign
l_int|1
suffix:semicolon
)brace
)brace
r_else
(brace
id|mcd_state
op_assign
id|MCD_S_IDLE
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
r_break
suffix:semicolon
r_default
suffix:colon
id|printk
c_func
(paren
l_string|&quot;mcd: invalid state %d&bslash;n&quot;
comma
id|mcd_state
)paren
suffix:semicolon
r_goto
id|out
suffix:semicolon
)brace
id|ret
suffix:colon
r_if
c_cond
(paren
op_logical_neg
id|McdTimeout
op_decrement
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: timeout in state %d&bslash;n&quot;
comma
id|mcd_state
)paren
suffix:semicolon
id|mcd_state
op_assign
id|MCD_S_STOP
suffix:semicolon
)brace
id|SET_TIMER
c_func
(paren
id|mcd_poll
comma
l_int|1
)paren
suffix:semicolon
id|out
suffix:colon
r_return
suffix:semicolon
)brace
r_static
r_void
DECL|function|mcd_invalidate_buffers
id|mcd_invalidate_buffers
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MCD_BUF_SIZ
suffix:semicolon
op_increment
id|i
)paren
id|mcd_buf_bn
(braket
id|i
)braket
op_assign
op_minus
l_int|1
suffix:semicolon
id|mcd_buf_out
op_assign
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Open the device special file.  Check that a disk is in.&n; */
DECL|function|mcd_open
r_static
r_int
id|mcd_open
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|purpose
)paren
(brace
r_int
id|st
comma
id|count
op_assign
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|mcdPresent
op_eq
l_int|0
)paren
r_return
op_minus
id|ENXIO
suffix:semicolon
multiline_comment|/* no hardware */
id|MOD_INC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
id|mcd_open_count
op_logical_or
id|mcd_state
op_ne
id|MCD_S_IDLE
)paren
r_goto
id|bump_count
suffix:semicolon
id|mcd_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
r_do
(brace
id|st
op_assign
id|statusCmd
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* check drive status */
r_if
c_cond
(paren
id|st
op_eq
op_minus
l_int|1
)paren
r_goto
id|err_out
suffix:semicolon
multiline_comment|/* drive doesn&squot;t respond */
r_if
c_cond
(paren
(paren
id|st
op_amp
id|MST_READY
)paren
op_eq
l_int|0
)paren
(brace
multiline_comment|/* no disk? wait a sec... */
id|current-&gt;state
op_assign
id|TASK_INTERRUPTIBLE
suffix:semicolon
id|schedule_timeout
c_func
(paren
id|HZ
)paren
suffix:semicolon
)brace
)brace
r_while
c_loop
(paren
(paren
(paren
id|st
op_amp
id|MST_READY
)paren
op_eq
l_int|0
)paren
op_logical_and
id|count
op_increment
OL
id|MCD_RETRY_ATTEMPTS
)paren
suffix:semicolon
r_if
c_cond
(paren
id|updateToc
c_func
(paren
)paren
OL
l_int|0
)paren
r_goto
id|err_out
suffix:semicolon
id|bump_count
suffix:colon
op_increment
id|mcd_open_count
suffix:semicolon
r_return
l_int|0
suffix:semicolon
id|err_out
suffix:colon
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n; * On close, we flush all mcd blocks from the buffer cache.&n; */
DECL|function|mcd_release
r_static
r_void
id|mcd_release
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
)paren
(brace
id|MOD_DEC_USE_COUNT
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
op_decrement
id|mcd_open_count
)paren
(brace
id|mcd_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
)brace
)brace
multiline_comment|/* This routine gets called during initialization if things go wrong,&n; * and is used in mcd_exit as well. */
DECL|function|cleanup
r_static
r_void
id|cleanup
c_func
(paren
r_int
id|level
)paren
(brace
r_switch
c_cond
(paren
id|level
)paren
(brace
r_case
l_int|3
suffix:colon
r_if
c_cond
(paren
id|unregister_cdrom
c_func
(paren
op_amp
id|mcd_info
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Can&squot;t unregister cdrom mcd&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|free_irq
c_func
(paren
id|mcd_irq
comma
l_int|NULL
)paren
suffix:semicolon
r_case
l_int|2
suffix:colon
id|release_region
c_func
(paren
id|mcd_port
comma
l_int|4
)paren
suffix:semicolon
r_case
l_int|1
suffix:colon
r_if
c_cond
(paren
id|devfs_unregister_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;mcd&quot;
)paren
)paren
(brace
id|printk
c_func
(paren
id|KERN_WARNING
l_string|&quot;Can&squot;t unregister major mcd&bslash;n&quot;
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|blk_cleanup_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
)paren
suffix:semicolon
r_default
suffix:colon
(brace
)brace
)brace
)brace
multiline_comment|/*&n; * Test for presence of drive and initialize it.  Called at boot time.&n; */
DECL|function|mcd_init
r_int
id|__init
id|mcd_init
c_func
(paren
r_void
)paren
(brace
r_int
id|count
suffix:semicolon
r_int
r_char
id|result
(braket
l_int|3
)braket
suffix:semicolon
r_char
id|msg
(braket
l_int|80
)braket
suffix:semicolon
r_if
c_cond
(paren
id|mcd_port
op_le
l_int|0
op_logical_or
id|mcd_irq
op_le
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;skip mcd_init&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|devfs_register_blkdev
c_func
(paren
id|MAJOR_NR
comma
l_string|&quot;mcd&quot;
comma
op_amp
id|cdrom_fops
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get major %d for Mitsumi CD-ROM&bslash;n&quot;
comma
id|MAJOR_NR
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|check_region
c_func
(paren
id|mcd_port
comma
l_int|4
)paren
)paren
(brace
id|cleanup
c_func
(paren
l_int|1
)paren
suffix:semicolon
id|printk
c_func
(paren
l_string|&quot;Init failed, I/O port (%X) already in use&bslash;n&quot;
comma
id|mcd_port
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|blksize_size
(braket
id|MAJOR_NR
)braket
op_assign
id|mcd_blocksizes
suffix:semicolon
id|blk_init_queue
c_func
(paren
id|BLK_DEFAULT_QUEUE
c_func
(paren
id|MAJOR_NR
)paren
comma
id|DEVICE_REQUEST
)paren
suffix:semicolon
id|read_ahead
(braket
id|MAJOR_NR
)braket
op_assign
l_int|4
suffix:semicolon
multiline_comment|/* check for card */
id|outb
c_func
(paren
l_int|0
comma
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* send reset */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|2000000
suffix:semicolon
id|count
op_increment
)paren
(paren
r_void
)paren
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
suffix:semicolon
multiline_comment|/* delay a bit */
id|outb
c_func
(paren
l_int|0x40
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* send get-stat cmd */
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|2000000
suffix:semicolon
id|count
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
id|MFL_STATUS
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
l_int|2000000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Init failed. No mcd device at 0x%x irq %d&bslash;n&quot;
comma
id|mcd_port
comma
id|mcd_irq
)paren
suffix:semicolon
id|cleanup
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|count
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* pick up the status */
id|outb
c_func
(paren
id|MCMD_GET_VERSION
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|3
suffix:semicolon
id|count
op_increment
)paren
r_if
c_cond
(paren
id|getValue
c_func
(paren
id|result
op_plus
id|count
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mitsumi get version failed at 0x%x&bslash;n&quot;
comma
id|mcd_port
)paren
suffix:semicolon
id|cleanup
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
(braket
l_int|0
)braket
op_eq
id|result
(braket
l_int|1
)braket
op_logical_and
id|result
(braket
l_int|1
)braket
op_eq
id|result
(braket
l_int|2
)braket
)paren
(brace
id|cleanup
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|mcdVersion
op_assign
id|result
(braket
l_int|2
)braket
suffix:semicolon
r_if
c_cond
(paren
id|mcdVersion
op_ge
l_int|4
)paren
id|outb
c_func
(paren
l_int|4
comma
id|MCDPORT
c_func
(paren
l_int|2
)paren
)paren
suffix:semicolon
multiline_comment|/* magic happens */
multiline_comment|/* don&squot;t get the IRQ until we know for sure the drive is there */
r_if
c_cond
(paren
id|request_irq
c_func
(paren
id|mcd_irq
comma
id|mcd_interrupt
comma
id|SA_INTERRUPT
comma
l_string|&quot;Mitsumi CD&quot;
comma
l_int|NULL
)paren
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Unable to get IRQ%d for Mitsumi CD-ROM&bslash;n&quot;
comma
id|mcd_irq
)paren
suffix:semicolon
id|cleanup
c_func
(paren
l_int|1
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
r_if
c_cond
(paren
id|result
(braket
l_int|1
)braket
op_eq
l_char|&squot;D&squot;
)paren
(brace
id|MCMD_DATA_READ
op_assign
id|MCMD_2X_READ
suffix:semicolon
multiline_comment|/* Added flag to drop to 1x speed if too many errors */
id|mcdDouble
op_assign
l_int|1
suffix:semicolon
)brace
r_else
id|mcd_info.speed
op_assign
l_int|1
suffix:semicolon
id|sprintf
c_func
(paren
id|msg
comma
l_string|&quot; mcd: Mitsumi %s Speed CD-ROM at port=0x%x,&quot;
l_string|&quot; irq=%d&bslash;n&quot;
comma
id|mcd_info.speed
op_eq
l_int|1
ques
c_cond
l_string|&quot;Single&quot;
suffix:colon
l_string|&quot;Double&quot;
comma
id|mcd_port
comma
id|mcd_irq
)paren
suffix:semicolon
id|request_region
c_func
(paren
id|mcd_port
comma
l_int|4
comma
l_string|&quot;mcd&quot;
)paren
suffix:semicolon
id|outb
c_func
(paren
id|MCMD_CONFIG_DRIVE
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x02
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x00
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|getValue
c_func
(paren
id|result
)paren
suffix:semicolon
id|outb
c_func
(paren
id|MCMD_CONFIG_DRIVE
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x10
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x04
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|getValue
c_func
(paren
id|result
)paren
suffix:semicolon
id|mcd_invalidate_buffers
c_func
(paren
)paren
suffix:semicolon
id|mcdPresent
op_assign
l_int|1
suffix:semicolon
id|mcd_info.dev
op_assign
id|MKDEV
c_func
(paren
id|MAJOR_NR
comma
l_int|0
)paren
suffix:semicolon
r_if
c_cond
(paren
id|register_cdrom
c_func
(paren
op_amp
id|mcd_info
)paren
op_ne
l_int|0
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;Cannot register Mitsumi CD-ROM!&bslash;n&quot;
)paren
suffix:semicolon
id|cleanup
c_func
(paren
l_int|3
)paren
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
id|printk
c_func
(paren
id|msg
)paren
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
r_static
r_void
DECL|function|hsg2msf
id|hsg2msf
c_func
(paren
r_int
id|hsg
comma
r_struct
id|msf
op_star
id|msf
)paren
(brace
id|hsg
op_add_assign
l_int|150
suffix:semicolon
id|msf
op_member_access_from_pointer
id|min
op_assign
id|hsg
op_div
l_int|4500
suffix:semicolon
id|hsg
op_mod_assign
l_int|4500
suffix:semicolon
id|msf
op_member_access_from_pointer
id|sec
op_assign
id|hsg
op_div
l_int|75
suffix:semicolon
id|msf
op_member_access_from_pointer
id|frame
op_assign
id|hsg
op_mod
l_int|75
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf
op_member_access_from_pointer
id|min
)paren
suffix:semicolon
multiline_comment|/* convert to BCD */
id|bin2bcd
c_func
(paren
op_amp
id|msf
op_member_access_from_pointer
id|sec
)paren
suffix:semicolon
id|bin2bcd
c_func
(paren
op_amp
id|msf
op_member_access_from_pointer
id|frame
)paren
suffix:semicolon
)brace
r_static
r_void
DECL|function|bin2bcd
id|bin2bcd
c_func
(paren
r_int
r_char
op_star
id|p
)paren
(brace
r_int
id|u
comma
id|t
suffix:semicolon
id|u
op_assign
op_star
id|p
op_mod
l_int|10
suffix:semicolon
id|t
op_assign
op_star
id|p
op_div
l_int|10
suffix:semicolon
op_star
id|p
op_assign
id|u
op_or
(paren
id|t
op_lshift
l_int|4
)paren
suffix:semicolon
)brace
r_static
r_int
DECL|function|bcd2bin
id|bcd2bin
c_func
(paren
r_int
r_char
id|bcd
)paren
(brace
r_return
(paren
id|bcd
op_rshift
l_int|4
)paren
op_star
l_int|10
op_plus
(paren
id|bcd
op_amp
l_int|0xF
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * See if a status is ready from the drive and return it&n; * if it is ready.&n; */
r_static
r_int
DECL|function|mcdStatus
id|mcdStatus
c_func
(paren
r_void
)paren
(brace
r_int
id|i
suffix:semicolon
r_int
id|st
suffix:semicolon
id|st
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
id|MFL_STATUS
suffix:semicolon
r_if
c_cond
(paren
op_logical_neg
id|st
)paren
(brace
id|i
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_return
id|i
suffix:semicolon
)brace
r_else
r_return
op_minus
l_int|1
suffix:semicolon
)brace
multiline_comment|/*&n; * Send a play or read command to the drive&n; */
r_static
r_void
DECL|function|sendMcdCmd
id|sendMcdCmd
c_func
(paren
r_int
id|cmd
comma
r_struct
id|mcd_Play_msf
op_star
id|params
)paren
(brace
id|outb
c_func
(paren
id|cmd
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.min
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.sec
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|start.frame
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.min
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.sec
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
id|params
op_member_access_from_pointer
id|end.frame
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Timer interrupt routine to test for status ready from the drive.&n; * (see the next routine)&n; */
r_static
r_void
DECL|function|mcdStatTimer
id|mcdStatTimer
c_func
(paren
r_int
r_int
id|dummy
)paren
(brace
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
id|MFL_STATUS
)paren
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|mcd_waitq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|McdTimeout
op_decrement
suffix:semicolon
r_if
c_cond
(paren
id|McdTimeout
op_le
l_int|0
)paren
(brace
id|wake_up
c_func
(paren
op_amp
id|mcd_waitq
)paren
suffix:semicolon
r_return
suffix:semicolon
)brace
id|SET_TIMER
c_func
(paren
id|mcdStatTimer
comma
l_int|1
)paren
suffix:semicolon
)brace
multiline_comment|/*&n; * Wait for a status to be returned from the drive.  The actual test&n; * (see routine above) is done by the timer interrupt to avoid&n; * excessive rescheduling.&n; */
r_static
r_int
DECL|function|getMcdStatus
id|getMcdStatus
c_func
(paren
r_int
id|timeout
)paren
(brace
r_int
id|st
suffix:semicolon
id|McdTimeout
op_assign
id|timeout
suffix:semicolon
id|SET_TIMER
c_func
(paren
id|mcdStatTimer
comma
l_int|1
)paren
suffix:semicolon
id|sleep_on
c_func
(paren
op_amp
id|mcd_waitq
)paren
suffix:semicolon
r_if
c_cond
(paren
id|McdTimeout
op_le
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|st
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
op_amp
l_int|0xFF
suffix:semicolon
r_if
c_cond
(paren
id|st
op_eq
l_int|0xFF
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_amp
id|MST_BUSY
)paren
op_eq
l_int|0
op_logical_and
id|audioStatus
op_eq
id|CDROM_AUDIO_PLAY
)paren
multiline_comment|/* XXX might be an error? look at q-channel? */
id|audioStatus
op_assign
id|CDROM_AUDIO_COMPLETED
suffix:semicolon
r_if
c_cond
(paren
id|st
op_amp
id|MST_DSK_CHG
)paren
(brace
id|mcdDiskChanged
op_assign
l_int|1
suffix:semicolon
id|tocUpToDate
op_assign
l_int|0
suffix:semicolon
id|audioStatus
op_assign
id|CDROM_AUDIO_NO_STATUS
suffix:semicolon
)brace
r_return
id|st
suffix:semicolon
)brace
multiline_comment|/* gives current state of the drive This function is quite unreliable, &n;   and should probably be rewritten by someone, eventually... */
DECL|function|mcd_drive_status
r_int
id|mcd_drive_status
c_func
(paren
r_struct
id|cdrom_device_info
op_star
id|cdi
comma
r_int
id|slot_nr
)paren
(brace
r_int
id|st
suffix:semicolon
id|st
op_assign
id|statusCmd
c_func
(paren
)paren
suffix:semicolon
multiline_comment|/* check drive status */
r_if
c_cond
(paren
id|st
op_eq
op_minus
l_int|1
)paren
r_return
op_minus
id|EIO
suffix:semicolon
multiline_comment|/* drive doesn&squot;t respond */
r_if
c_cond
(paren
(paren
id|st
op_amp
id|MST_READY
)paren
)paren
r_return
id|CDS_DISC_OK
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_amp
id|MST_DOOR_OPEN
)paren
)paren
r_return
id|CDS_TRAY_OPEN
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_amp
id|MST_DSK_CHG
)paren
)paren
r_return
id|CDS_NO_DISC
suffix:semicolon
r_if
c_cond
(paren
(paren
id|st
op_amp
id|MST_BUSY
)paren
)paren
r_return
id|CDS_DRIVE_NOT_READY
suffix:semicolon
r_return
op_minus
id|EIO
suffix:semicolon
)brace
multiline_comment|/*&n; * Read a value from the drive.&n; */
r_static
r_int
DECL|function|getValue
id|getValue
c_func
(paren
r_int
r_char
op_star
id|result
)paren
(brace
r_int
id|count
suffix:semicolon
r_int
id|s
suffix:semicolon
r_for
c_loop
(paren
id|count
op_assign
l_int|0
suffix:semicolon
id|count
OL
l_int|2000
suffix:semicolon
id|count
op_increment
)paren
r_if
c_cond
(paren
op_logical_neg
(paren
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|1
)paren
)paren
op_amp
id|MFL_STATUS
)paren
)paren
r_break
suffix:semicolon
r_if
c_cond
(paren
id|count
op_ge
l_int|2000
)paren
(brace
id|printk
c_func
(paren
l_string|&quot;mcd: getValue timeout&bslash;n&quot;
)paren
suffix:semicolon
r_return
op_minus
l_int|1
suffix:semicolon
)brace
id|s
op_assign
id|inb
c_func
(paren
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
op_amp
l_int|0xFF
suffix:semicolon
op_star
id|result
op_assign
(paren
r_int
r_char
)paren
id|s
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the current Q-channel info.  Also used for reading the&n; * table of contents.&n; */
r_int
DECL|function|GetQChannelInfo
id|GetQChannelInfo
c_func
(paren
r_struct
id|mcd_Toc
op_star
id|qp
)paren
(brace
r_int
r_char
id|notUsed
suffix:semicolon
r_int
id|retry
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|outb
c_func
(paren
id|MCMD_GET_Q_CHANNEL
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retry
op_ge
id|MCD_RETRY_ATTEMPTS
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|ctrl_addr
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|track
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|pointIndex
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|trackTime.min
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|trackTime.sec
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|trackTime.frame
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|notUsed
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|diskTime.min
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|diskTime.sec
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|qp
op_member_access_from_pointer
id|diskTime.frame
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the table of contents (TOC) and TOC header if necessary&n; */
r_static
r_int
DECL|function|updateToc
id|updateToc
c_func
(paren
)paren
(brace
r_if
c_cond
(paren
id|tocUpToDate
)paren
r_return
l_int|0
suffix:semicolon
r_if
c_cond
(paren
id|GetDiskInfo
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
r_if
c_cond
(paren
id|GetToc
c_func
(paren
)paren
OL
l_int|0
)paren
r_return
op_minus
id|EIO
suffix:semicolon
id|tocUpToDate
op_assign
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the table of contents header&n; */
r_static
r_int
DECL|function|GetDiskInfo
id|GetDiskInfo
c_func
(paren
)paren
(brace
r_int
id|retry
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|outb
c_func
(paren
id|MCMD_GET_DISK_INFO
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retry
op_ge
id|MCD_RETRY_ATTEMPTS
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.first
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.last
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
id|DiskInfo.first
op_assign
id|bcd2bin
c_func
(paren
id|DiskInfo.first
)paren
suffix:semicolon
id|DiskInfo.last
op_assign
id|bcd2bin
c_func
(paren
id|DiskInfo.last
)paren
suffix:semicolon
macro_line|#ifdef MCD_DEBUG
id|printk
c_func
(paren
l_string|&quot;Disk Info: first %d last %d length %02x:%02x.%02x first %02x:%02x.%02x&bslash;n&quot;
comma
id|DiskInfo.first
comma
id|DiskInfo.last
comma
id|DiskInfo.diskLength.min
comma
id|DiskInfo.diskLength.sec
comma
id|DiskInfo.diskLength.frame
comma
id|DiskInfo.firstTrack.min
comma
id|DiskInfo.firstTrack.sec
comma
id|DiskInfo.firstTrack.frame
)paren
suffix:semicolon
macro_line|#endif
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.diskLength.min
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.diskLength.sec
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.diskLength.frame
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.firstTrack.min
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.firstTrack.sec
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getValue
c_func
(paren
op_amp
id|DiskInfo.firstTrack.frame
)paren
OL
l_int|0
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_return
l_int|0
suffix:semicolon
)brace
multiline_comment|/*&n; * Read the table of contents (TOC)&n; */
r_static
r_int
DECL|function|GetToc
id|GetToc
c_func
(paren
)paren
(brace
r_int
id|i
comma
id|px
suffix:semicolon
r_int
id|limit
suffix:semicolon
r_int
id|retry
suffix:semicolon
r_struct
id|mcd_Toc
id|qInfo
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|0
suffix:semicolon
id|i
OL
id|MAX_TRACKS
suffix:semicolon
id|i
op_increment
)paren
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
op_assign
l_int|0
suffix:semicolon
id|i
op_assign
id|DiskInfo.last
op_plus
l_int|3
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|outb
c_func
(paren
id|MCMD_STOP
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
r_if
c_cond
(paren
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retry
op_ge
id|MCD_RETRY_ATTEMPTS
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|outb
c_func
(paren
id|MCMD_SET_MODE
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x05
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
multiline_comment|/* mode: toc */
id|mcd_mode
op_assign
l_int|0x05
suffix:semicolon
r_if
c_cond
(paren
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
r_if
c_cond
(paren
id|retry
op_ge
id|MCD_RETRY_ATTEMPTS
)paren
r_return
op_minus
l_int|1
suffix:semicolon
r_for
c_loop
(paren
id|limit
op_assign
l_int|300
suffix:semicolon
id|limit
OG
l_int|0
suffix:semicolon
id|limit
op_decrement
)paren
(brace
r_if
c_cond
(paren
id|GetQChannelInfo
c_func
(paren
op_amp
id|qInfo
)paren
OL
l_int|0
)paren
r_break
suffix:semicolon
id|px
op_assign
id|bcd2bin
c_func
(paren
id|qInfo.pointIndex
)paren
suffix:semicolon
r_if
c_cond
(paren
id|px
OG
l_int|0
op_logical_and
id|px
OL
id|MAX_TRACKS
op_logical_and
id|qInfo.track
op_eq
l_int|0
)paren
r_if
c_cond
(paren
id|Toc
(braket
id|px
)braket
dot
id|pointIndex
op_eq
l_int|0
)paren
(brace
id|Toc
(braket
id|px
)braket
op_assign
id|qInfo
suffix:semicolon
id|i
op_decrement
suffix:semicolon
)brace
r_if
c_cond
(paren
id|i
op_le
l_int|0
)paren
r_break
suffix:semicolon
)brace
id|Toc
(braket
id|DiskInfo.last
op_plus
l_int|1
)braket
dot
id|diskTime
op_assign
id|DiskInfo.diskLength
suffix:semicolon
r_for
c_loop
(paren
id|retry
op_assign
l_int|0
suffix:semicolon
id|retry
OL
id|MCD_RETRY_ATTEMPTS
suffix:semicolon
id|retry
op_increment
)paren
(brace
id|outb
c_func
(paren
id|MCMD_SET_MODE
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|outb
c_func
(paren
l_int|0x01
comma
id|MCDPORT
c_func
(paren
l_int|0
)paren
)paren
suffix:semicolon
id|mcd_mode
op_assign
l_int|1
suffix:semicolon
r_if
c_cond
(paren
id|getMcdStatus
c_func
(paren
id|MCD_STATUS_DELAY
)paren
op_ne
op_minus
l_int|1
)paren
r_break
suffix:semicolon
)brace
macro_line|#ifdef MCD_DEBUG
r_for
c_loop
(paren
id|i
op_assign
l_int|1
suffix:semicolon
id|i
op_le
id|DiskInfo.last
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;i = %2d ctl-adr = %02X track %2d px %02X %02X:%02X.%02X    %02X:%02X.%02X&bslash;n&quot;
comma
id|i
comma
id|Toc
(braket
id|i
)braket
dot
id|ctrl_addr
comma
id|Toc
(braket
id|i
)braket
dot
id|track
comma
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.frame
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.frame
)paren
suffix:semicolon
r_for
c_loop
(paren
id|i
op_assign
l_int|100
suffix:semicolon
id|i
OL
l_int|103
suffix:semicolon
id|i
op_increment
)paren
id|printk
c_func
(paren
l_string|&quot;i = %2d ctl-adr = %02X track %2d px %02X %02X:%02X.%02X    %02X:%02X.%02X&bslash;n&quot;
comma
id|i
comma
id|Toc
(braket
id|i
)braket
dot
id|ctrl_addr
comma
id|Toc
(braket
id|i
)braket
dot
id|track
comma
id|Toc
(braket
id|i
)braket
dot
id|pointIndex
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|trackTime.frame
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.min
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.sec
comma
id|Toc
(braket
id|i
)braket
dot
id|diskTime.frame
)paren
suffix:semicolon
macro_line|#endif
r_return
id|limit
OG
l_int|0
ques
c_cond
l_int|0
suffix:colon
op_minus
l_int|1
suffix:semicolon
)brace
DECL|function|mcd_exit
r_void
id|__exit
id|mcd_exit
c_func
(paren
r_void
)paren
(brace
id|cleanup
c_func
(paren
l_int|3
)paren
suffix:semicolon
id|del_timer_sync
c_func
(paren
op_amp
id|mcd_timer
)paren
suffix:semicolon
)brace
macro_line|#ifdef MODULE
DECL|variable|mcd_init
id|module_init
c_func
(paren
id|mcd_init
)paren
suffix:semicolon
macro_line|#endif 
DECL|variable|mcd_exit
id|module_exit
c_func
(paren
id|mcd_exit
)paren
suffix:semicolon
eof
